Project Path: arc_gmh5225_x64dbgPlaytime_to67ux8y

Source Tree:

```txt
arc_gmh5225_x64dbgPlaytime_to67ux8y
├── LICENSE
├── README.md
├── appveyor.yml
├── build-release.bat
├── lua
│   ├── autorun
│   │   ├── Test_AutorunDir
│   │   │   ├── init.lua
│   │   │   └── test_include.lua
│   │   └── test_loadscript.lua
│   ├── core
│   │   ├── assembler.lua
│   │   ├── assembler_defs.lua
│   │   ├── init.lua
│   │   ├── printhelper.lua
│   │   ├── proxies.lua
│   │   └── registers.lua
│   ├── examples
│   │   └── assembler_basics.lua
│   └── libs
│       ├── dll
│       │   ├── x32
│       │   │   ├── bit.dll
│       │   │   ├── mime
│       │   │   │   └── core.dll
│       │   │   └── socket
│       │   │       └── core.dll
│       │   └── x64
│       │       ├── bit.dll
│       │       ├── mime
│       │       │   └── core.dll
│       │       └── socket
│       │           └── core.dll
│       ├── ltn12.lua
│       ├── mime.lua
│       ├── mobdebug.lua
│       ├── socket
│       │   ├── ftp.lua
│       │   ├── headers.lua
│       │   ├── http.lua
│       │   ├── smtp.lua
│       │   ├── tp.lua
│       │   └── url.lua
│       └── socket.lua
└── src
    ├── Lua
    │   ├── Lua.vcxproj
    │   ├── Lua.vcxproj.filters
    │   ├── bit
    │   │   └── bit.c
    │   ├── lapi.c
    │   ├── lapi.h
    │   ├── lauxlib.c
    │   ├── lauxlib.h
    │   ├── lbaselib.c
    │   ├── lbitlib.c
    │   ├── lcode.c
    │   ├── lcode.h
    │   ├── lcorolib.c
    │   ├── lctype.c
    │   ├── lctype.h
    │   ├── ldblib.c
    │   ├── ldebug.c
    │   ├── ldebug.h
    │   ├── ldo.c
    │   ├── ldo.h
    │   ├── ldump.c
    │   ├── lfunc.c
    │   ├── lfunc.h
    │   ├── lgc.c
    │   ├── lgc.h
    │   ├── linit.c
    │   ├── liolib.c
    │   ├── llex.c
    │   ├── llex.h
    │   ├── llimits.h
    │   ├── lmathlib.c
    │   ├── lmem.c
    │   ├── lmem.h
    │   ├── loadlib.c
    │   ├── lobject.c
    │   ├── lobject.h
    │   ├── lopcodes.c
    │   ├── lopcodes.h
    │   ├── loslib.c
    │   ├── lparser.c
    │   ├── lparser.h
    │   ├── lprefix.h
    │   ├── lstate.c
    │   ├── lstate.h
    │   ├── lstring.c
    │   ├── lstring.h
    │   ├── lstrlib.c
    │   ├── ltable.c
    │   ├── ltable.h
    │   ├── ltablib.c
    │   ├── ltm.c
    │   ├── ltm.h
    │   ├── lua.h
    │   ├── lua.hpp
    │   ├── luaconf.h
    │   ├── lualib.h
    │   ├── lundump.c
    │   ├── lundump.h
    │   ├── lutf8lib.c
    │   ├── lvm.c
    │   ├── lvm.h
    │   ├── lzio.c
    │   ├── lzio.h
    │   └── socket
    │       ├── LICENSE
    │       ├── README
    │       ├── auxiliar.c
    │       ├── auxiliar.h
    │       ├── buffer.c
    │       ├── buffer.h
    │       ├── compat.c
    │       ├── compat.h
    │       ├── except.c
    │       ├── except.h
    │       ├── inet.c
    │       ├── inet.h
    │       ├── io.c
    │       ├── io.h
    │       ├── luasocket.c
    │       ├── luasocket.h
    │       ├── mime.c
    │       ├── mime.h
    │       ├── options.c
    │       ├── options.h
    │       ├── pierror.h
    │       ├── select.c
    │       ├── select.h
    │       ├── socket.h
    │       ├── tcp.c
    │       ├── tcp.h
    │       ├── timeout.c
    │       ├── timeout.h
    │       ├── udp.c
    │       ├── udp.h
    │       ├── unix.h
    │       ├── unixdgram.h
    │       ├── unixstream.h
    │       ├── usocket.h
    │       ├── wsocket.c
    │       └── wsocket.h
    ├── TestingProject
    │   ├── TestingProject.cpp
    │   ├── TestingProject.vcxproj
    │   ├── TestingProject.vcxproj.filters
    │   ├── pch.cpp
    │   └── pch.h
    ├── luasocketforwarder
    │   ├── luasocketforwarder
    │   │   ├── luasocketforwarder.cpp
    │   │   ├── luasocketforwarder.vcxproj
    │   │   └── luasocketforwarder.vcxproj.filters
    │   └── luasocketforwarder.sln
    ├── x64dbgPlaytime
    │   ├── lua_assembler.cpp
    │   ├── lua_bootstrap.cpp
    │   ├── lua_bps.cpp
    │   ├── lua_constants.cpp
    │   ├── lua_context.cpp
    │   ├── lua_context.hpp
    │   ├── lua_debugger.cpp
    │   ├── lua_globals.cpp
    │   ├── lua_labels.cpp
    │   ├── lua_memory.cpp
    │   ├── lua_modules.cpp
    │   ├── lua_print.cpp
    │   ├── lua_registers.cpp
    │   ├── lua_table_utils.h
    │   ├── lua_utils.cpp
    │   ├── lua_xrefs.cpp
    │   ├── plugin.cpp
    │   ├── plugin.h
    │   ├── pluginmain.cpp
    │   ├── pluginmain.h
    │   ├── pluginsdk
    │   │   ├── DeviceNameResolver
    │   │   │   ├── DeviceNameResolver.h
    │   │   │   ├── DeviceNameResolver_x64.lib
    │   │   │   └── DeviceNameResolver_x86.lib
    │   │   ├── TitanEngine
    │   │   │   ├── TitanEngine.h
    │   │   │   ├── TitanEngine_x64.lib
    │   │   │   └── TitanEngine_x86.lib
    │   │   ├── XEDParse
    │   │   │   ├── XEDParse.h
    │   │   │   ├── XEDParse_x64.lib
    │   │   │   └── XEDParse_x86.lib
    │   │   ├── _dbgfunctions.h
    │   │   ├── _plugin_types.h
    │   │   ├── _plugins.h
    │   │   ├── _scriptapi.h
    │   │   ├── _scriptapi_argument.h
    │   │   ├── _scriptapi_assembler.h
    │   │   ├── _scriptapi_bookmark.h
    │   │   ├── _scriptapi_comment.h
    │   │   ├── _scriptapi_debug.h
    │   │   ├── _scriptapi_flag.h
    │   │   ├── _scriptapi_function.h
    │   │   ├── _scriptapi_gui.h
    │   │   ├── _scriptapi_label.h
    │   │   ├── _scriptapi_memory.h
    │   │   ├── _scriptapi_misc.h
    │   │   ├── _scriptapi_module.h
    │   │   ├── _scriptapi_pattern.h
    │   │   ├── _scriptapi_register.h
    │   │   ├── _scriptapi_stack.h
    │   │   ├── _scriptapi_symbol.h
    │   │   ├── bridgegraph.h
    │   │   ├── bridgelist.h
    │   │   ├── bridgemain.h
    │   │   ├── capstone
    │   │   │   ├── arm.h
    │   │   │   ├── arm64.h
    │   │   │   ├── capstone.h
    │   │   │   ├── capstone_x64.lib
    │   │   │   ├── capstone_x86.lib
    │   │   │   ├── m68k.h
    │   │   │   ├── mips.h
    │   │   │   ├── platform.h
    │   │   │   ├── ppc.h
    │   │   │   ├── sparc.h
    │   │   │   ├── systemz.h
    │   │   │   ├── x86.h
    │   │   │   └── xcore.h
    │   │   ├── dbghelp
    │   │   │   └── dbghelp.h
    │   │   ├── jansson
    │   │   │   ├── jansson.h
    │   │   │   ├── jansson_config.h
    │   │   │   ├── jansson_x64.lib
    │   │   │   ├── jansson_x64dbg.h
    │   │   │   └── jansson_x86.lib
    │   │   ├── lz4
    │   │   │   ├── lz4.h
    │   │   │   ├── lz4_x64.lib
    │   │   │   ├── lz4_x86.lib
    │   │   │   ├── lz4file.h
    │   │   │   └── lz4hc.h
    │   │   ├── x32bridge.lib
    │   │   ├── x32dbg.lib
    │   │   ├── x64bridge.lib
    │   │   ├── x64dbg.lib
    │   │   └── yara
    │   │       ├── yara
    │   │       │   ├── ahocorasick.h
    │   │       │   ├── arena.h
    │   │       │   ├── atoms.h
    │   │       │   ├── compiler.h
    │   │       │   ├── elf.h
    │   │       │   ├── error.h
    │   │       │   ├── exec.h
    │   │       │   ├── exefiles.h
    │   │       │   ├── filemap.h
    │   │       │   ├── globals.h
    │   │       │   ├── hash.h
    │   │       │   ├── hex_lexer.h
    │   │       │   ├── integers.h
    │   │       │   ├── lexer.h
    │   │       │   ├── libyara.h
    │   │       │   ├── limits.h
    │   │       │   ├── mem.h
    │   │       │   ├── modules.h
    │   │       │   ├── object.h
    │   │       │   ├── parser.h
    │   │       │   ├── pe.h
    │   │       │   ├── proc.h
    │   │       │   ├── re.h
    │   │       │   ├── re_lexer.h
    │   │       │   ├── rules.h
    │   │       │   ├── scan.h
    │   │       │   ├── sizedstr.h
    │   │       │   ├── stream.h
    │   │       │   ├── strutils.h
    │   │       │   ├── threading.h
    │   │       │   ├── types.h
    │   │       │   └── utils.h
    │   │       ├── yara.h
    │   │       ├── yara_x64.lib
    │   │       └── yara_x86.lib
    │   ├── utils.cpp
    │   ├── utils.h
    │   ├── x64dbgPlaytime.def
    │   ├── x64dbgPlaytime.vcxproj
    │   └── x64dbgPlaytime.vcxproj.filters
    └── x64dbgPlaytime.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 ζeh Matt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# x64dbgPlaytime
Plugin for x64Dbg adding Lua scripting.

[![Build status](https://ci.appveyor.com/api/projects/status/e6tljk3hk29blmya/branch/master?svg=true)](https://ci.appveyor.com/project/ZehMatt/x64dbgplaytime/branch/master)

```

`appveyor.yml`:

```yml
version: 0.1.{build}
image: Visual Studio 2017
configuration: Release
platform: x86-x64
build_script:
- cmd: .\build-release.bat
artifacts:
- path: build
  name: build-rel-0-1-%APPVEYOR_BUILD_NUMBER%-x86x64
```

`build-release.bat`:

```bat
Rem Prepare folders
mkdir build
mkdir build\x32
mkdir build\x64
mkdir build\x32\plugins
mkdir build\x64\plugins

Rem x86 build
set platform=x86
set configuration=release
msbuild "src\x64dbgPlaytime.sln" /m /verbosity:normal

Rem x64 build
set platform=x64
set configuration=release
msbuild "src\x64dbgPlaytime.sln" /m /verbosity:normal

Rem Prepare package
robocopy "bin\x32" "build\x32\plugins" /E /NJH /NJS
robocopy "bin\x64" "build\x64\plugins" /E /NJH /NJS
robocopy "lua" "build\lua" /E /NJH /NJS

Rem Complete
EXIT /B 0
```

`lua/autorun/Test_AutorunDir/init.lua`:

```lua
include("test_include.lua")

```

`lua/autorun/Test_AutorunDir/test_include.lua`:

```lua
print("Yay I got included")
```

`lua/autorun/test_loadscript.lua`:

```lua
-- x64dbgplaytime test file.
-- Assigning the global signals a completed load for testing purposes.
TEST_LOADSCRIPT = true

print("_SCRIPT_PATH = " .. _SCRIPT_PATH)
print("_SCRIPT_NAME = " .. _SCRIPT_NAME)
```

`lua/core/assembler.lua`:

```lua
include("assembler_defs.lua")

local printVerbose = function() end
local printtableVerbose = function() end

local function makeMemoryReference()

	local REF_META = {}
	REF_META.__index = REF_META
	function REF_META:clone()
		local res = { base = self.base, index = self.index, scale = self.scale, disp32 = self.disp32, label = self.label }
		setmetatable(res, REF_META)
		return res
	end
	function REF_META:__add(other)
		printVerbose(self, "REF_META:ADD", other)
		if type(other) == "number" then
			local res = self:clone()
			res.disp32 = other + (res.disp32 or 0)
			return res
		elseif type(other) == "table" and other.object == assembler.OP_REGISTER then
			local res = self:clone()
			if res.base ~= nil and res.index == nil then
				res.index = other
			elseif res.index ~= nil and res.base == nil then
				res.base = other
			elseif res.index ~= nil and res.base ~= nil then
				error("complex expression: can only have two registers for memory reference")
			end
			return res
		elseif type(other) == "table" and other.object == assembler.OP_LABEL then
			local res = self:clone()
			if res.label ~= nil then
				error("complex expression: only one label is currently supported")
			end
			res.label = other
			return res
		else
			error("unsupported reference model")
		end
	end
	function REF_META:__mul(other)
		printVerbose(self, "REF_META:MUL", other)
		if type(other) == "number" then
			local res = self:clone()
			res.scale = other
			if res.base ~= nil and res.index == nil then
				res.index = res.base
				res.base = nil
			end
			return res
		end
	end
	local ref = { object = assembler.OP_MEMORYREF }
	setmetatable(ref, REF_META)
	return ref
end

local function makeOperandRegister(name, id, size)
	local REG_META = {}
	REG_META.__index = REG_META
	function REG_META:__add(other)
		printVerbose(self, "REG_META:ADD", other)
		local res = makeMemoryReference()
		if type(other) == "number" then
			res.base = self
			res.disp32 = other
		elseif type(other) == "table" and other.object == assembler.OP_REGISTER then
			res.base = self
			res.index = other
		else
			error("complex expression: unsupported expression")
			res = nil
		end
		return res
	end
	function REG_META:__mul(other)
		printVerbose(self, "REG_META:MUL", other)
		local res = makeMemoryReference()
		if type(other) == "number" then
			res.index = self
			res.scale = other
		else
			error("complex expression: unsupported expression")
			res = nil
		end
		return res
	end
	local res = { object = assembler.OP_REGISTER, name = name, id = id, size = size }
	setmetatable(res, REG_META)
	return res
end

local function makeOperandImm(imm)
	return { object = assembler.OP_IMM, val = imm }
end

local function makeOperandLabel(id)
	return { object = assembler.OP_LABEL, id = id }
end

local function makeOperandMemory(size, ref)
	return { object = assembler.OP_MEMORY, size = size, ref = ref }
end

local function splitString(s, delimiter)
	res = {}
	for match in (s .. delimiter):gmatch("(.-)" .. delimiter) do
		table.insert(res, match)
	end
	return res
end

local function initInstructions(a)
	-- Setup instruction functions.
	for mnemonicId, data in pairs(assembler.INSTRUCTION_TABLE) do
		local mnemonics = data[1]
		local operands = data[2]
		local encoding = data[3]
		-- TODO: Create better validation routines.
		-- We only use mnemonic for now
		mnemonics = splitString(mnemonics, "/")
		for subId, mnemonic in pairs(mnemonics) do
			if a[mnemonic] == nil then
				a[mnemonic] = function(s, op1, op2, op3, op4)
					s:emit(mnemonicId, op1, op2, op3, op4, subId)
					return s
				end
			end
		end
	end
end

local function fixupOperand(op)
	if op ~= nil and type(op) == "number" then
		op = makeOperandImm(op)
	end
	return op
end

local function initMemoryOperands(a)

	local function getMemoryReference(arg)
		local ref 
		if type(arg) == "table" and arg.object == assembler.OP_MEMORYREF then
			ref = arg
		elseif type(arg) == "table" and arg.object == assembler.OP_REGISTER then
			printVerbose("reference from register")
			ref = makeMemoryReference()
			ref.base = arg
		elseif type(arg) == "table" and arg.object == assembler.OP_LABEL then
			printVerbose("reference from label")
			ref = makeMemoryReference()
			ref.label = arg
		elseif type(arg) == "number" then
			ref = makeMemoryReference()
			ref.disp32 = arg
		else
			error("unsupported argument")
		end
		assert(ref ~= nil)
		return ref
	end
	
	a.byte_ptr = function(arg)
		local ref = getMemoryReference(arg)
		local res = makeOperandMemory(8, ref)
		assert(res.ref ~= nil)
		return res
	end
	a.word_ptr = function(arg)
		local ref = getMemoryReference(arg)
		local res =  makeOperandMemory(16, ref)
		assert(res.ref ~= nil)
		return res
	end
	a.dword_ptr = function(arg)
		local ref = getMemoryReference(arg)
		local res =  makeOperandMemory(32, ref)
		assert(res.ref ~= nil)
		return res
	end
	a.qword_ptr = function(arg)
		local ref = getMemoryReference(arg)
		local res = makeOperandMemory(64, ref)
		assert(res.ref ~= nil)
		return res
	end
	
end

local function initRegisters(a)
	a.rax = makeOperandRegister("rax", 1, 64)
	a.eax = makeOperandRegister("eax", 2, 32)
	a.ax = makeOperandRegister("ax", 3, 16)
	a.ah = makeOperandRegister("ah", 4, 8)
	a.al = makeOperandRegister("al", 5, 8)

	a.rbx = makeOperandRegister("rbx", 6, 64)
	a.ebx = makeOperandRegister("ebx", 7, 32)
	a.bx = makeOperandRegister("bx", 8, 16)
	a.bh = makeOperandRegister("bh", 9, 8)
	a.bl = makeOperandRegister("bl", 10, 8)

	a.rcx = makeOperandRegister("rcx", 11, 64)
	a.ecx = makeOperandRegister("ecx", 12, 32)
	a.cx = makeOperandRegister("cx", 13, 16)
	a.ch = makeOperandRegister("ch", 14, 8)
	a.cl = makeOperandRegister("cl", 15, 8)

	a.rdx = makeOperandRegister("rdx", 16, 64)
	a.edx = makeOperandRegister("edx", 17, 32)
	a.dx = makeOperandRegister("dx", 18, 16)
	a.dh = makeOperandRegister("dh", 19, 8)
	a.dl = makeOperandRegister("dl", 20, 8)

	a.rdi = makeOperandRegister("rdi", 21, 64)
	a.edi = makeOperandRegister("edi", 22, 32)
	a.di = makeOperandRegister("di", 23, 16)
	a.dil = makeOperandRegister("dil", 24, 8)

	a.rsi = makeOperandRegister("rsi", 25, 64)
	a.esi = makeOperandRegister("esi", 26, 32)
	a.si = makeOperandRegister("si", 27, 16)
	a.sil = makeOperandRegister("sil", 28, 8)

	a.rbp = makeOperandRegister("rbp", 29, 64)
	a.ebp = makeOperandRegister("ebp", 30, 32)
	a.bp = makeOperandRegister("bp", 31, 16)
	a.bpl = makeOperandRegister("bpl", 32, 8)

	a.rsp = makeOperandRegister("rsp", 33, 64)
	a.esp = makeOperandRegister("esp", 34, 32)
	a.sp = makeOperandRegister("sp", 35, 16)
	a.spl = makeOperandRegister("spl", 36, 8)

	a.rip = makeOperandRegister("rip", 37, 64)
	a.eip = makeOperandRegister("eip", 38, 32)

	a.r8 = makeOperandRegister("r8", 39, 64)
	a.r8d = makeOperandRegister("r8d", 40, 32)
	a.r8w = makeOperandRegister("r8w", 41, 16)
	a.r8b = makeOperandRegister("r8b", 42, 8)

	a.r9 = makeOperandRegister("r9", 43, 64)
	a.r9d = makeOperandRegister("r9d", 44, 32)
	a.r9w = makeOperandRegister("r9w", 45, 16)
	a.r9b = makeOperandRegister("r9b", 46, 8)

	a.r10 = makeOperandRegister("r10", 47, 64)
	a.r10d = makeOperandRegister("r10d", 48, 32)
	a.r10w = makeOperandRegister("r10w", 49, 16)
	a.r10b = makeOperandRegister("r10b", 50, 8)

	a.r11 = makeOperandRegister("r11", 51, 64)
	a.r11d = makeOperandRegister("r11d", 52, 32)
	a.r11w = makeOperandRegister("r11w", 53, 16)
	a.r11b = makeOperandRegister("r11b", 54, 8)

	a.r12 = makeOperandRegister("r12", 55, 64)
	a.r12d = makeOperandRegister("r12d", 56, 32)
	a.r12w = makeOperandRegister("r12w", 57, 16)
	a.r12b = makeOperandRegister("r12b", 58, 8)

	a.r13 = makeOperandRegister("r13", 59, 64)
	a.r13d = makeOperandRegister("r13d", 60, 32)
	a.r13w = makeOperandRegister("r13w", 61, 16)
	a.r13b = makeOperandRegister("r13b", 62, 8)

	a.r14 = makeOperandRegister("r14", 63, 64)
	a.r14d = makeOperandRegister("r14d", 64, 32)
	a.r14w = makeOperandRegister("r14w", 65, 16)
	a.r14b = makeOperandRegister("r14b", 66, 8)

	a.r15 = makeOperandRegister("r15", 67, 64)
	a.r15d = makeOperandRegister("r15d", 68, 32)
	a.r15w = makeOperandRegister("r15w", 69, 16)
	a.r15b = makeOperandRegister("r15b", 70, 8)
end

local ASSEMBLER_META = {}
ASSEMBLER_META.__index = ASSEMBLER_META

function ASSEMBLER_META:init()	
	initRegisters(self)
	initInstructions(self)
	initMemoryOperands(self)
	self:clear()
end

function ASSEMBLER_META:createLabel(name)
	local id = #self.Labels + 1
	local label = {
		id = id,
		name = name,
		index = -1,
		address = nil,
	}
	table.insert(self.Labels, label)
	return makeOperandLabel(id)
end

function ASSEMBLER_META:bindLabel(label)
	local labelData = self.Labels[label.id]
	if labelData == nil then
		error("Label not created within assembler")
		return
	end
	labelData.index = #self.Objects + 1
	local obj = {
		object = assembler.OBJECT_LABEL,
		id = label.id
	}
	table.insert(self.Objects, obj)
end

function ASSEMBLER_META:getLabelAddress(label)
	local labelData = self.Labels[label.id]
	if labelData == nil then
		error("Label not created within assembler")
		return
	end
	return labelData.address
end

function ASSEMBLER_META:emit(mnemonicId, op1, op2, op3, op4, subId)
	op1 = fixupOperand(op1)
	op2 = fixupOperand(op2)
	op3 = fixupOperand(op3)
	op4 = fixupOperand(op4)
	local instr = {
		object = assembler.OBJECT_INSTRUCTION,
		mnemonicId = mnemonicId,
		subId = subId,
		op1 = op1,
		op2 = op2,
		op3 = op3,
		op4 = op4,
		address = nil,	-- We only get an offset after encoding.
	}
	table.insert(self.Objects, instr)
end

local function encodeOperandRegister(a, base, fixups, idx, data, op)
	return op.name
end

local function encodeOperandImm(a, base, fixups, idx, data, op)
	return tostring(op.val)
end

local function encodeOperandLabel(a, base, fixups, idx, data, op)
	local res
	local labelData = a.Labels[op.id]
	if labelData.address ~= nil then
		res = string.format("0x%X", labelData.address)
	else
		-- Temporary.
		-- XEDParse has issues having arbitary values here.
		res = string.format("0x%X", base)
		table.insert(fixups, idx)
	end
	return res
end

local function encodeOperandMemory(a, base, fixups, idx, data, op)
	local res = ""
	
	-- Decoration
	if op.size == 8 then
		res = "byte ptr ["
	elseif op.size == 16 then
		res = "word ptr ["
	elseif op.size == 32 then
		res = "dword ptr ["
	elseif op.size == 64 then
		res = "qword ptr ["
	end
	
	printtableVerbose(op)
	
	local continued = false
	local ref = op.ref
	-- Registers
	if ref.base ~= nil then
		res = res .. encodeOperandRegister(a, base, fixups, idx, data, ref.base)
		continued = true
	end
	if ref.index ~= nil then
		if continued then res = res .. "+" end
		res = res .. encodeOperandRegister(a, base, fixups, idx, data, ref.index)
		continued = true
	end
	if ref.scale ~= nil and ref.scale ~= 1 then
		if continued then res = res .. "*" end
		res = res .. tostring(ref.scale)
		continued = true
	end
	
	-- Disp
	if ref.disp32 ~= nil then
		if continued then res = res .. "+" end
	end
	
	-- Label
	if ref.label ~= nil then
		if continued then res = res .. "+" end
		res = res .. encodeOperandLabel(a, base, fixups, idx, data, ref.label)
	end
	
	res = res .. "]"
	return res
end

local function encodeOperand(a, base, fixups, idx, data, op)
	if op.object == assembler.OP_REGISTER then
		return encodeOperandRegister(a, base, fixups, idc, data, op)
	elseif op.object == assembler.OP_IMM then
		return encodeOperandImm(a, base, fixups, idx, data, op)
	elseif op.object == assembler.OP_MEMORY then
		return encodeOperandMemory(a, base, fixups, idx, data, op)
	elseif op.object == assembler.OP_LABEL then
		return encodeOperandLabel(a, base, fixups, idx, data, op)
	end
end

local function encodeInstruction(a, base, fixups, idx, data)
	
	local instrData = assembler.INSTRUCTION_TABLE[data.mnemonicId]
	local mnemonics = splitString(instrData[1], "/")
	local mnemonic = mnemonics[data.subId]
	local instrStr = mnemonic
	
	if data.op1 ~= nil then
		instrStr = instrStr .. " " .. encodeOperand(a, base, fixups, idx, data, data.op1)
	end
	if data.op2 ~= nil then
		instrStr = instrStr .. ", " .. encodeOperand(a, base, fixups, idx, data, data.op2)
	end
	if data.op3 ~= nil then
		instrStr = instrStr .. ", " .. encodeOperand(a, base, fixups, idx, data, data.op3)
	end
	if data.op4 ~= nil then
		instrStr = instrStr .. ", " .. encodeOperand(a, base, fixups, idx, data, data.op4)
	end

	printVerbose("Encode: " .. instrStr)
	local data, err = assembler.encode(base, instrStr)
	if data == nil then
		error("Unable to encode instruction: \"" .. instrStr .. "\" , reason: " .. err)
	end
	
	return { data = data, readable = instrStr }
	
end

function ASSEMBLER_META:make(base, dumpOutput)
	
	local buffers = {}
	local dumps = {}
	local addresses = {}
	local currentOffset = 0
	
	local function processObject(address, idx, data, fixups)
		
		local objectSize = 0
		
		if data.object == assembler.OBJECT_INSTRUCTION then
			local res = encodeInstruction(self, address, fixups, idx, data)
			data.address = address
			buffers[idx] = res.data
			if dumpOutput == true then
				dumps[idx] = { address = address, text = res.readable }
			end
			objectSize = #res.data
		elseif data.object == assembler.OBJECT_LABEL then
			local labelData = self.Labels[data.id]
			labelData.address = address
			buffers[idx] = "" -- Need to keep it aligned, 0/empty buffer.
			if dumpOutput == true then
				dumps[idx] = { address = labelData.address, text = labelData.name .. ":" }
			end
		end
		
		return objectSize

	end
	
	local fixups = {}
	for idx, data in pairs(self.Objects) do
		local address = base + currentOffset
		local objSize = processObject(address, idx, data, fixups)
		addresses[idx] = address
		currentOffset = currentOffset + objSize
	end
	
	-- Every label should be bound now, creating fixups.
	for _, fixup in pairs(fixups) do
		-- Update buffer.		
		-- Invalidate everything down if required.
		local address = addresses[fixup]
		local tempFixups = {}
		for idx = fixup, #self.Objects do
			local prevSize = #buffers[idx]
			local data = self.Objects[idx]
			local objSize = processObject(address, idx, data, tempFixups)
			addresses[idx] = address
			address = address + objSize
			if idx == fixup and prevSize == objSize then
				-- If no shift happens we can break out of this fixup entry.
				-- otherwise we need to invalidate all data down.
				printVerbose("Fixup applied without invalidation, early break out")
				break
			elseif idx == fixup and prevSize ~= objSize then
				-- Size changed.
				printVerbose("Size change at " .. tostring(idx))
				-- Need to fixup size change for bound labels
				table.insert(fixups, idx)
			end
		end
	end
	
	local function tohex(buf)
		local l = ""
		for i = 1, #buf do
			l = l .. string.format("%02X ", buf:byte(i))
		end
		return l
	end

	if dumpOutput == true then
		for k,v in pairs(dumps) do
			local data = buffers[k]
			if #data > 0 then
				data = tohex(buffers[k])
				for i = #data, 30 do
					data = data .. " "
				end
			end
			print(string.format("%016x", v.address), data, v.text)
		end
	end
	
	-- Combine all buffers into one output.
	local data = table.concat(buffers)
	return data

end

function ASSEMBLER_META:clear()
	self.Objects = {}
	self.Labels = {}
end

function assembler.create()
	local res = {}
	setmetatable(res, ASSEMBLER_META)
	res:init()
	return res
end
```

`lua/core/assembler_defs.lua`:

```lua
assembler.OP_REGISTER = 1
assembler.OP_MEMORYREF = 2
assembler.OP_MEMORY = 3
assembler.OP_IMM = 4
assembler.OP_LABEL = 5

assembler.OBJECT_INSTRUCTION = 1
assembler.OBJECT_LABEL = 2

assembler.INSTRUCTION_TABLE =
{
	{"aaa", "x:<ax>", "NONE", "37", "X86 Deprecated OF=U SF=U ZF=U AF=W PF=U CF=W"},
	{"aas", "x:<ax>", "NONE", "3F", "X86 Deprecated OF=U SF=U ZF=U AF=W PF=U CF=W"},
	{"aad", "x:<ax>, ib/ub", "I", "D5 ib", "X86 Deprecated OF=U SF=W ZF=W AF=U PF=W CF=U"},
	{"aam", "x:<ax>, ib/ub", "I", "D4 ib", "X86 Deprecated OF=U SF=W ZF=W AF=U PF=W CF=U"},
	{"adc", "x:al, ib/ub", "I", "14 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "x:ax, iw/uw", "I", "66 15 iw", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:eax, id/ud", "I", "15 id", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:rax, id", "I", "REX.W 15 id", "X64OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "x:r8/m8, ib/ub", "MI", "80 /2 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "x:r16/m16, iw/uw", "MI", "66 81 /2 iw", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:r32/m32, id/ud", "MI", "81 /2 id", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:r64/m64, id", "MI", "REX.W 81 /2 id", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "x:r16/m16, ib", "MI", "66 83 /2 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:r32/m32, ib", "MI", "83 /2 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:r64/m64, ib", "MI", "REX.W 83 /2 ib", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "x:~r8/m8,~r8", "MR", "10 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "x:~r16/m16,~r16", "MR", "66 11 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:~r32/m32,~r32", "MR", "11 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:~r64/m64,~r64", "MR", "REX.W 11 /r", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "x:~r8,~r8/m8", "RM", "12 /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "x:~r16,~r16/m16", "RM", "66 13 /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:~r32,~r32/m32", "RM", "13 /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"adc", "X:~r64,~r64/m64", "RM", "REX.W 13 /r", "X64OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"add", "x:al, ib/ub", "I", "04 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "x:ax, iw/uw", "I", "66 05 iw", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:eax, id/ud", "I", "05 id", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:rax, id", "I", "REX.W 05 id", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "x:r8/m8, ib/ub", "MI", "80 /0 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "x:r16/m16, iw/uw", "MI", "66 81 /0 iw", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:r32/m32, id/ud", "MI", "81 /0 id", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:r64/m64, id", "MI", "REX.W 81 /0 id", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "x:r16/m16, ib", "MI", "66 83 /0 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:r32/m32, ib", "MI", "83 /0 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:r64/m64, ib", "MI", "REX.W 83 /0 ib", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "x:~r8/m8,~r8", "MR", "00 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "x:~r16/m16,~r16", "MR", "66 01 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:~r32/m32,~r32", "MR", "01 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:~r64/m64,~r64", "MR", "REX.W 01 /r", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "x:~r8,~r8/m8", "RM", "02 /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "x:~r16,~r16/m16", "RM", "66 03 /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:~r32,~r32/m32", "RM", "03 /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"add", "X:~r64,~r64/m64", "RM", "REX.W 03 /r", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"and", "x:al, ib/ub", "I", "24 ib", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "x:ax, iw/uw", "I", "66 25 iw", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:eax, id/ud", "I", "25 id", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:rax, ud", "I", "25 id", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:rax, id", "I", "REX.W 25 id", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "x:r8/m8, ib/ub", "MI", "80 /4 ib", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "x:r16/m16, iw/uw", "MI", "66 81 /4 iw", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:r32/m32, id/ud", "MI", "81 /4 id", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:r64, ud", "MI", "81 /4 id", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:r64/m64, id", "MI", "REX.W 81 /4 id", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "x:r16/m16, ib/ub", "MI", "66 83 /4 ib", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:r32/m32, ib/ub", "MI", "83 /4 ib", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:r64/m64, ib/ub", "MI", "REX.W 83 /4 ib", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "x:~r8/m8,~r8", "MR", "20 /r", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "x:~r16/m16,~r16", "MR", "66 21 /r", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:~r32/m32,~r32", "MR", "21 /r", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:~r64/m64,~r64", "MR", "REX.W 21 /r", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "x:~r8,~r8/m8", "RM", "22 /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "x:~r16,~r16/m16", "RM", "66 23 /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:~r32,~r32/m32", "RM", "23 /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"and", "X:~r64,~r64/m64", "RM", "REX.W 23 /r", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"arpl", "x:r16/m16, R:r16", "MR", "63 /r", "X86 ZF=W"},
	{"bndcl", "R:bnd, r32/m32", "RM", "F3 0F 1A /r", "MPX X86"},
	{"bndcl", "R:bnd, r64/m64", "RM", "F3 0F 1A /r", "MPX X64"},
	{"bndcn", "R:bnd, r32/m32", "RM", "F2 0F 1B /r", "MPX X86"},
	{"bndcn", "R:bnd, r64/m64", "RM", "F2 0F 1B /r", "MPX X64"},
	{"bndcu", "R:bnd, r32/m32", "RM", "F2 0F 1A /r", "MPX X86"},
	{"bndcu", "R:bnd, r64/m64", "RM", "F2 0F 1A /r", "MPX X64"},
	{"bndldx", "W:bnd, mib", "RM", "0F 1A /r", "MPX"},
	{"bndmk", "W:bnd, mem", "RM", "F3 0F 1B /r", "MPX"},
	{"bndmov", "W:bnd, bnd/mem", "RM", "66 0F 1A /r", "MPX"},
	{"bndmov", "W:bnd/mem, bnd", "MR", "66 0F 1B /r", "MPX"},
	{"bndstx", "W:mib, bnd", "MR", "0F 1B /r", "MPX"},
	{"bound", "R:r16, R:m32", "RM", "66 62 /r", "X86 Deprecated"},
	{"bound", "R:r32, R:m64", "RM", "62 /r", "X86 Deprecated"},
	{"bsf", "w:r16, r16/m16", "RM", "66 0F BC /r", "ANYOF=U SF=U ZF=W AF=U PF=U CF=U"},
	{"bsf", "W:r32, r32/m32", "RM", "0F BC /r", "ANYOF=U SF=U ZF=W AF=U PF=U CF=U"},
	{"bsf", "W:r64, r64/m64", "RM", "REX.W 0F BC /r", "X64OF=U SF=U ZF=W AF=U PF=U CF=U"},
	{"bsr", "w:r16, r16/m16", "RM", "66 0F BD /r", "ANYOF=U SF=U ZF=W AF=U PF=U CF=U"},
	{"bsr", "W:r32, r32/m32", "RM", "0F BD /r", "ANYOF=U SF=U ZF=W AF=U PF=U CF=U"},
	{"bsr", "W:r64, r64/m64", "RM", "REX.W 0F BD /r", "X64OF=U SF=U ZF=W AF=U PF=U CF=U"},
	{"bswap", "X:r32", "O", "0F C8+r", "ANY"},
	{"bswap", "X:r64", "O", "REX.W 0F C8+r", "X64"},
	{"bt", "R:r16/m16, ib/ub", "MI", "66 0F BA /4 ib", "ANYOF=U SF=U AF=U PF=U CF=W"},
	{"bt", "R:r32/m32, ib/ub", "MI", "0F BA /4 ib", "ANYOF=U SF=U AF=U PF=U CF=W"},
	{"bt", "R:r64/m64, ib/ub", "MI", "REX.W 0F BA /4 ib", "X64OF=U SF=U AF=U PF=U CF=W"},
	{"bt", "R:r16/m16, r16", "MR", "66 0F A3 /r", "ANYOF=U SF=U AF=U PF=U CF=W"},
	{"bt", "R:r32/m32, r32", "MR", "0F A3 /r", "ANYOF=U SF=U AF=U PF=U CF=W"},
	{"bt", "R:r64/m64, r64", "MR", "REX.W 0F A3 /r", "X64OF=U SF=U AF=U PF=U CF=W"},
	{"btc", "x:r16/m16, ib/ub", "MI", "66 0F BA /7 ib", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btc", "X:r32/m32, ib/ub", "MI", "0F BA /7 ib", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btc", "X:r64/m64, ib/ub", "MI", "REX.W 0F BA /7 ib", "X64 _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btc", "x:r16/m16, r16", "MR", "66 0F BB /r", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btc", "X:r32/m32, r32", "MR", "0F BB /r", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btc", "X:r64/m64, r64", "MR", "REX.W 0F BB /r", "X64 _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btr", "x:r16/m16, ib/ub", "MI", "66 0F BA /6 ib", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btr", "X:r32/m32, ib/ub", "MI", "0F BA /6 ib", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btr", "X:r64/m64, ib/ub", "MI", "REX.W 0F BA /6 ib", "X64 _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btr", "x:r16/m16, r16", "MR", "66 0F B3 /r", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btr", "X:r32/m32, r32", "MR", "0F B3 /r", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"btr", "X:r64/m64, r64", "MR", "REX.W 0F B3 /r", "X64 _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"bts", "x:r16/m16, ib/ub", "MI", "66 0F BA /5 ib", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"bts", "X:r32/m32, ib/ub", "MI", "0F BA /5 ib", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"bts", "X:r64/m64, ib/ub", "MI", "REX.W 0F BA /5 ib", "X64 _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"bts", "x:r16/m16, r16", "MR", "66 0F AB /r", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"bts", "X:r32/m32, r32", "MR", "0F AB /r", "ANY _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"bts", "X:r64/m64, r64", "MR", "REX.W 0F AB /r", "X64 _XLock OF=U SF=U AF=U PF=U CF=W"},
	{"call", "rel16", "D", "66 E8 cw", "X86Control=Call OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"call", "rel32", "D", "E8 cd", "ANYControl=Call OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"call", "R:r16/m16", "M", "66 FF /2", "X86Control=Call OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"call", "R:r32/m32", "M", "FF /2", "X86Control=Call OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"call", "R:r64/m64", "M", "FF /2", "X64Control=Call OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"cbw", "x:<ax>", "NONE", "66 98", "ANY"},
	{"cwde", "X:<eax>", "NONE", "98", "ANY"},
	{"cdqe", "X:<rax>", "NONE", "REX.W 98", "X64"},
	{"cwd", "w:<dx>, <ax>", "NONE", "66 99", "ANY"},
	{"cdq", "W:<edx>, <eax>", "NONE", "99", "ANY"},
	{"cqo", "W:<rdx>, <rax>", "NONE", "REX.W 99", "X64"},
	{"clac", "", "NONE", "0F 01 CA", "SMAP Volatile AC=0"},
	{"clflush", "R:mem", "M", "0F AE /7", "CLFLUSHVolatile"},
	{"clflushopt", "R:mem", "M", "66 0F AE /7", "CLFLUSHOPT Volatile"},
	{"cli", "", "NONE", "FA", "ANYVolatile IF=W"},
	{"clwb", "R:mem", "M", "66 0F AE /6", "CLWB Volatile"},
	{"clzero", "R:<ds:zax>", "NONE", "0F 01 FC", "CLZERO Volatile"},
	{"clc", "", "NONE", "F8", "ANYCF=0"},
	{"cld", "", "NONE", "FC", "ANYDF=0"},
	{"cmc", "", "NONE", "F5", "ANYCF=X"},
	{"cmovo", "x:r16, r16/m16", "RM", "66 0F 40 /r", "CMOV OF=R"},
	{"cmovo", "X:r32, r32/m32", "RM", "0F 40 /r", "CMOV OF=R"},
	{"cmovo", "X:r64, r64/m64", "RM", "REX.W 0F 40 /r", "CMOV X64 OF=R"},
	{"cmovno", "x:r16, r16/m16", "RM", "66 0F 41 /r", "CMOV OF=R"},
	{"cmovno", "X:r32, r32/m32", "RM", "0F 41 /r", "CMOV OF=R"},
	{"cmovno", "X:r64, r64/m64", "RM", "REX.W 0F 41 /r", "CMOV X64 OF=R"},
	{"cmovb/cmovnae/cmovc", "x:r16, r16/m16", "RM", "66 0F 42 /r", "CMOV CF=R"},
	{"cmovb/cmovnae/cmovc", "X:r32, r32/m32", "RM", "0F 42 /r", "CMOV CF=R"},
	{"cmovb/cmovnae/cmovc", "X:r64, r64/m64", "RM", "REX.W 0F 42 /r", "CMOV X64 CF=R"},
	{"cmovae/cmovnb/cmovnc", "x:r16, r16/m16", "RM", "66 0F 43 /r", "CMOV CF=R"},
	{"cmovae/cmovnb/cmovnc", "X:r32, r32/m32", "RM", "0F 43 /r", "CMOV CF=R"},
	{"cmovae/cmovnb/cmovnc", "X:r64, r64/m64", "RM", "REX.W 0F 43 /r", "CMOV X64 CF=R"},
	{"cmove/cmovz", "x:r16, r16/m16", "RM", "66 0F 44 /r", "CMOV ZF=R"},
	{"cmove/cmovz", "X:r32, r32/m32", "RM", "0F 44 /r", "CMOV ZF=R"},
	{"cmove/cmovz", "X:r64, r64/m64", "RM", "REX.W 0F 44 /r", "CMOV X64 ZF=R"},
	{"cmovne/cmovnz", "x:r16, r16/m16", "RM", "66 0F 45 /r", "CMOV ZF=R"},
	{"cmovne/cmovnz", "X:r32, r32/m32", "RM", "0F 45 /r", "CMOV ZF=R"},
	{"cmovne/cmovnz", "X:r64, r64/m64", "RM", "REX.W 0F 45 /r", "CMOV X64 ZF=R"},
	{"cmovbe/cmovna", "x:r16, r16/m16", "RM", "66 0F 46 /r", "CMOV CF=R ZF=R"},
	{"cmovbe/cmovna", "X:r32, r32/m32", "RM", "0F 46 /r", "CMOV CF=R ZF=R"},
	{"cmovbe/cmovna", "X:r64, r64/m64", "RM", "REX.W 0F 46 /r", "CMOV X64 CF=R ZF=R"},
	{"cmova/cmovnbe", "x:r16, r16/m16", "RM", "66 0F 47 /r", "CMOV CF=R ZF=R"},
	{"cmova/cmovnbe", "X:r32, r32/m32", "RM", "0F 47 /r", "CMOV CF=R ZF=R"},
	{"cmova/cmovnbe", "X:r64, r64/m64", "RM", "REX.W 0F 47 /r", "CMOV X64 CF=R ZF=R"},
	{"cmovs", "x:r16, r16/m16", "RM", "66 0F 48 /r", "CMOV SF=R"},
	{"cmovs", "X:r32, r32/m32", "RM", "0F 48 /r", "CMOV SF=R"},
	{"cmovs", "X:r64, r64/m64", "RM", "REX.W 0F 48 /r", "CMOV X64 SF=R"},
	{"cmovns", "x:r16, r16/m16", "RM", "66 0F 49 /r", "CMOV SF=R"},
	{"cmovns", "X:r32, r32/m32", "RM", "0F 49 /r", "CMOV SF=R"},
	{"cmovns", "X:r64, r64/m64", "RM", "REX.W 0F 49 /r", "CMOV X64 SF=R"},
	{"cmovp/cmovpe", "x:r16, r16/m16", "RM", "66 0F 4A /r", "CMOV PF=R"},
	{"cmovp/cmovpe", "X:r32, r32/m32", "RM", "0F 4A /r", "CMOV PF=R"},
	{"cmovp/cmovpe", "X:r64, r64/m64", "RM", "REX.W 0F 4A /r", "CMOV X64 PF=R"},
	{"cmovnp/cmovpo", "x:r16, r16/m16", "RM", "66 0F 4B /r", "CMOV PF=R"},
	{"cmovnp/cmovpo", "X:r32, r32/m32", "RM", "0F 4B /r", "CMOV PF=R"},
	{"cmovnp/cmovpo", "X:r64, r64/m64", "RM", "REX.W 0F 4B /r", "CMOV X64 PF=R"},
	{"cmovl/cmovnge", "x:r16, r16/m16", "RM", "66 0F 4C /r", "CMOV SF=R OF=R"},
	{"cmovl/cmovnge", "X:r32, r32/m32", "RM", "0F 4C /r", "CMOV SF=R OF=R"},
	{"cmovl/cmovnge", "X:r64, r64/m64", "RM", "REX.W 0F 4C /r", "CMOV X64 SF=R OF=R"},
	{"cmovge/cmovnl", "x:r16, r16/m16", "RM", "66 0F 4D /r", "CMOV SF=R OF=R"},
	{"cmovge/cmovnl", "X:r32, r32/m32", "RM", "0F 4D /r", "CMOV SF=R OF=R"},
	{"cmovge/cmovnl", "X:r64, r64/m64", "RM", "REX.W 0F 4D /r", "CMOV X64 SF=R OF=R"},
	{"cmovle/cmovng", "x:r16, r16/m16", "RM", "66 0F 4E /r", "CMOV ZF=R SF=R OF=R"},
	{"cmovle/cmovng", "X:r32, r32/m32", "RM", "0F 4E /r", "CMOV ZF=R SF=R OF=R"},
	{"cmovle/cmovng", "X:r64, r64/m64", "RM", "REX.W 0F 4E /r", "CMOV X64 ZF=R SF=R OF=R"},
	{"cmovg/cmovnle", "x:r16, r16/m16", "RM", "66 0F 4F /r", "CMOV ZF=R SF=R OF=R"},
	{"cmovg/cmovnle", "X:r32, r32/m32", "RM", "0F 4F /r", "CMOV ZF=R SF=R OF=R"},
	{"cmovg/cmovnle", "X:r64, r64/m64", "RM", "REX.W 0F 4F /r", "CMOV X64 ZF=R SF=R OF=R"},
	{"cmp", "R:al, ib/ub", "I", "3C ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:ax, iw/uw", "I", "66 3D iw", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:eax, id/ud", "I", "3D id", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:rax, id", "I", "REX.W 3D id", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r8/m8, ib/ub", "MI", "80 /7 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r16/m16, iw/uw", "MI", "66 81 /7 iw", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r32/m32, id/ud", "MI", "81 /7 id", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r64/m64, id", "MI", "REX.W 81 /7 id", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r16/m16, ib", "MI", "66 83 /7 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r32/m32, ib", "MI", "83 /7 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r64/m64, ib", "MI", "REX.W 83 /7 ib", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r8/m8, r8", "MR", "38 /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r16/m16, r16", "MR", "66 39 /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r32/m32, r32", "MR", "39 /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r64/m64, r64", "MR", "REX.W 39 /r", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r8, r8/m8", "RM", "3A /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r16, r16/m16", "RM", "66 3B /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r32, r32/m32", "RM", "3B /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmp", "R:r64, r64/m64", "RM", "REX.W 3B /r", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmpsb", "X:<ds:zsi>, X:<es:zdi>", "NONE", "A6", "ANY _Rep OF=W SF=W ZF=W AF=W PF=W CF=W DF=R"},
	{"cmpsw", "X:<ds:zsi>, X:<es:zdi>", "NONE", "66 A7", "ANY _Rep OF=W SF=W ZF=W AF=W PF=W CF=W DF=R"},
	{"cmpsd", "X:<ds:zsi>, X:<es:zdi>", "NONE", "A7", "ANY _Rep OF=W SF=W ZF=W AF=W PF=W CF=W DF=R"},
	{"cmpsq", "X:<ds:zsi>, X:<es:zdi>", "NONE", "REX.W A7", "X64 _Rep OF=W SF=W ZF=W AF=W PF=W CF=W DF=R"},
	{"cmpxchg", "x:r8/m8, r8, <al>", "MR", "0F B0 /r", "I486 _XLock Volatile OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmpxchg", "x:r16/m16, r16, <ax>", "MR", "66 0F B1 /r", "I486 _XLock Volatile OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmpxchg", "X:r32/m32, r32, <eax>", "MR", "0F B1 /r", "I486 _XLock Volatile OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmpxchg", "X:r64/m64, r64, <rax>", "MR", "REX.W 0F B1 /r", "I486 X64 _XLock Volatile OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"cmpxchg8b", "X:m64, X:<edx>, X:<eax>, <ecx>, <ebx>", "M", "0F C7 /1", "CMPXCHG8B_XLock Volatile ZF=W"},
	{"cmpxchg16b", "X:m128, X:<rdx>, X:<rax>, <rcx>, <rbx>", "M", "REX.W 0F C7 /1", "CMPXCHG16B X64 _XLock Volatile ZF=W"},
	{"cpuid", "X:<eax>, W:<ebx>, X:<ecx>, W:<edx>", "NONE", "0F A2", "I486 Volatile"},
	{"daa", "x:<ax>", "NONE", "27", "X86 Deprecated OF=U SF=W ZF=W AF=W PF=W CF=W"},
	{"das", "x:<ax>", "NONE", "2F", "X86 Deprecated OF=U SF=W ZF=W AF=W PF=W CF=W"},
	{"dec", "x:r16", "O", "66 48+r", "X86OF=W SF=W ZF=W AF=W PF=W"},
	{"dec", "X:r32", "O", "48+r", "X86OF=W SF=W ZF=W AF=W PF=W"},
	{"dec", "x:r8/m8", "M", "FE /1", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W"},
	{"dec", "x:r16/m16", "M", "66 FF /1", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W"},
	{"dec", "X:r32/m32", "M", "FF /1", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W"},
	{"dec", "X:r64/m64", "M", "REX.W FF /1", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W"},
	{"div", "x:<ax>, r8/m8", "M", "F6 /6", "ANYOF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"div", "x:<dx>, x:<ax>, r16/m16", "M", "66 F7 /6", "ANYOF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"div", "X:<edx>, X:<eax>, r32/m32", "M", "F7 /6", "ANYOF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"div", "X:<rdx>, X:<rax>, r64/m64", "M", "REX.W F7 /6", "X64OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"idiv", "x:<ax>, r8/m8", "M", "F6 /7", "ANYOF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"idiv", "x:<dx>, x:<ax>, r16/m16", "M", "66 F7 /7", "ANYOF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"idiv", "X:<edx>, X:<eax>, r32/m32", "M", "F7 /7", "ANYOF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"idiv", "X:<rdx>, X:<rax>, r64/m64", "M", "REX.W F7 /7", "X64OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"imul", "x:<ax>, r8/m8", "M", "F6 /5", "ANYOF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "w:<dx>, x:<ax>, r16/m16", "M", "66 F7 /5", "ANYOF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "W:<edx>, X:<eax>, r32/m32", "M", "F7 /5", "ANYOF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "W:<rdx>, X:<rax>, r64/m64", "M", "REX.W F7 /5", "X64OF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "x:~r16,~r16/m16", "RM", "66 0F AF /r", "ANYOF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "X:~r32,~r32/m32", "RM", "0F AF /r", "ANYOF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "X:~r64,~r64/m64", "RM", "REX.W 0F AF /r", "X64OF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "w:r16, r16/m16, ib", "RMI", "66 6B /r ib", "ANYOF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "W:r32, r32/m32, ib", "RMI", "6B /r ib", "ANYOF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "W:r64, r64/m64, ib", "RMI", "REX.W 6B /r ib", "X64OF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "w:r16, r16/m16, iw/uw", "RMI", "66 69 /r iw", "ANYOF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "W:r32, r32/m32, id/ud", "RMI", "69 /r id", "ANYOF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"imul", "W:r64, r64/m64, id", "RMI", "REX.W 69 /r id", "X64OF=W SF=W ZF=U AF=U PF=U CF=W"},
	{"in", "w:al, ib/ub", "I", "E4 ib", "ANYVolatile"},
	{"in", "w:ax, ib/ub", "I", "66 E5 ib", "ANYVolatile"},
	{"in", "W:eax, ib/ub", "I", "E5 ib", "ANYVolatile"},
	{"in", "w:al, dx", "NONE", "EC", "ANYVolatile"},
	{"in", "w:ax, dx", "NONE", "66 ED", "ANYVolatile"},
	{"in", "W:eax, dx", "NONE", "ED", "ANYVolatile"},
	{"insb", "W:es:zdi, dx", "NONE", "6C", "ANY _Rep Volatile"},
	{"insw", "W:es:zdi, dx", "NONE", "66 6D", "ANY _Rep Volatile"},
	{"insd", "W:es:zdi, dx", "NONE", "6D", "ANY _Rep Volatile"},
	{"inc", "x:r16", "O", "66 40+r", "X86OF=W SF=W ZF=W AF=W PF=W"},
	{"inc", "X:r32", "O", "40+r", "X86OF=W SF=W ZF=W AF=W PF=W"},
	{"inc", "x:r8/m8", "M", "FE /0", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W"},
	{"inc", "x:r16/m16", "M", "66 FF /0", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W"},
	{"inc", "X:r32/m32", "M", "FF /0", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W"},
	{"inc", "X:r64/m64", "M", "REX.W FF /0", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W"},
	{"int", "ib/ub", "I", "CD ib", "ANYVolatile"},
	{"int3", "", "NONE", "CC", "ANYVolatile"},
	{"into", "", "NONE", "CE", "X86 Deprecated Volatile OF=R"},
	{"iret/iretd", "", "NONE", "CF", "ANYControl=Return OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"iretw", "", "NONE", "66 CF", "ANYControl=Return OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"iretq", "", "NONE", "REX.W CF", "X64Control=Return OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"jo", "rel8", "D", "70 cb", "ANYControl=Branch OF=R"},
	{"jno", "rel8", "D", "71 cb", "ANYControl=Branch OF=R"},
	{"jb/jnae/jc", "rel8", "D", "72 cb", "ANYControl=Branch CF=R"},
	{"jae/jnb/jnc", "rel8", "D", "73 cb", "ANYControl=Branch CF=R"},
	{"je/jz", "rel8", "D", "74 cb", "ANYControl=Branch ZF=R"},
	{"jne/jnz", "rel8", "D", "75 cb", "ANYControl=Branch ZF=R"},
	{"jbe/jna", "rel8", "D", "76 cb", "ANYControl=Branch CF=R ZF=R"},
	{"ja/jnbe", "rel8", "D", "77 cb", "ANYControl=Branch CF=R ZF=R"},
	{"js", "rel8", "D", "78 cb", "ANYControl=Branch SF=R"},
	{"jns", "rel8", "D", "79 cb", "ANYControl=Branch SF=R"},
	{"jp/jpe", "rel8", "D", "7A cb", "ANYControl=Branch PF=R"},
	{"jnp/jpo", "rel8", "D", "7B cb", "ANYControl=Branch PF=R"},
	{"jl/jnge", "rel8", "D", "7C cb", "ANYControl=Branch SF=R OF=R"},
	{"jge/jnl", "rel8", "D", "7D cb", "ANYControl=Branch SF=R OF=R"},
	{"jle/jng", "rel8", "D", "7E cb", "ANYControl=Branch ZF=R SF=R OF=R"},
	{"jg/jnle", "rel8", "D", "7F cb", "ANYControl=Branch ZF=R SF=R OF=R"},
	{"jo", "rel16", "D", "66 0F 80 cw", "X86Control=Branch OF=R"},
	{"jo", "rel32", "D", "0F 80 cd", "ANYControl=Branch OF=R"},
	{"jno", "rel16", "D", "66 0F 81 cw", "X86Control=Branch OF=R"},
	{"jno", "rel32", "D", "0F 81 cd", "ANYControl=Branch OF=R"},
	{"jb/jnae/jc", "rel16", "D", "66 0F 82 cw", "X86Control=Branch CF=R"},
	{"jb/jnae/jc", "rel32", "D", "0F 82 cd", "ANYControl=Branch CF=R"},
	{"jae/jnb/jnc", "rel16", "D", "66 0F 83 cw", "X86Control=Branch CF=R"},
	{"jae/jnb/jnc", "rel32", "D", "0F 83 cd", "ANYControl=Branch CF=R"},
	{"je/jz", "rel16", "D", "66 0F 84 cw", "X86Control=Branch ZF=R"},
	{"je/jz", "rel32", "D", "0F 84 cd", "ANYControl=Branch ZF=R"},
	{"jne/jnz", "rel16", "D", "66 0F 85 cw", "X86Control=Branch ZF=R"},
	{"jne/jnz", "rel32", "D", "0F 85 cd", "ANYControl=Branch ZF=R"},
	{"jbe/jna", "rel16", "D", "66 0F 86 cw", "X86Control=Branch CF=R ZF=R"},
	{"jbe/jna", "rel32", "D", "0F 86 cd", "ANYControl=Branch CF=R ZF=R"},
	{"ja/jnbe", "rel16", "D", "66 0F 87 cw", "X86Control=Branch CF=R ZF=R"},
	{"ja/jnbe", "rel32", "D", "0F 87 cd", "ANYControl=Branch CF=R ZF=R"},
	{"js", "rel16", "D", "66 0F 88 cw", "X86Control=Branch SF=R"},
	{"js", "rel32", "D", "0F 88 cd", "ANYControl=Branch SF=R"},
	{"jns", "rel16", "D", "66 0F 89 cw", "X86Control=Branch SF=R"},
	{"jns", "rel32", "D", "0F 89 cd", "ANYControl=Branch SF=R"},
	{"jp/jpe", "rel16", "D", "66 0F 8A cw", "X86Control=Branch PF=R"},
	{"jp/jpe", "rel32", "D", "0F 8A cd", "ANYControl=Branch PF=R"},
	{"jnp/jpo", "rel16", "D", "66 0F 8B cw", "X86Control=Branch PF=R"},
	{"jnp/jpo", "rel32", "D", "0F 8B cd", "ANYControl=Branch PF=R"},
	{"jl/jnge", "rel16", "D", "66 0F 8C cw", "X86Control=Branch SF=R OF=R"},
	{"jl/jnge", "rel32", "D", "0F 8C cd", "ANYControl=Branch SF=R OF=R"},
	{"jge/jnl", "rel16", "D", "66 0F 8D cw", "X86Control=Branch SF=R OF=R"},
	{"jge/jnl", "rel32", "D", "0F 8D cd", "ANYControl=Branch SF=R OF=R"},
	{"jle/jng", "rel16", "D", "66 0F 8E cw", "X86Control=Branch ZF=R SF=R OF=R"},
	{"jle/jng", "rel32", "D", "0F 8E cd", "ANYControl=Branch ZF=R SF=R OF=R"},
	{"jg/jnle", "rel16", "D", "66 0F 8F cw", "X86Control=Branch ZF=R SF=R OF=R"},
	{"jg/jnle", "rel32", "D", "0F 8F cd", "ANYControl=Branch ZF=R SF=R OF=R"},
	{"jecxz", "R:<cx>, rel8", "D", "67 E3 cb", "X86Control=Branch"},
	{"jecxz", "R:<ecx>, rel8", "D", "E3 cb", "X86Control=Branch"},
	{"jecxz", "R:<ecx>, rel8", "D", "67 E3 cb", "X64Control=Branch"},
	{"jecxz", "R:<rcx>, rel8", "D", "E3 cb", "X64Control=Branch"},
	{"jmp", "rel8", "D", "EB cb", "ANYControl=Jump"},
	{"jmp", "rel16", "D", "66 E9 cw", "X86Control=Jump"},
	{"jmp", "rel32", "D", "E9 cd", "ANYControl=Jump"},
	{"jmp", "R:r32/m32", "D", "FF /4", "X86Control=Jump"},
	{"jmp", "R:r64/m64", "D", "FF /4", "X64Control=Jump"},
	{"lar", "w:r16, R:r16/m16", "RM", "66 0F 02 /r", "ANYVolatile ZF=W"},
	{"lar", "W:r32, R:r32/m16", "RM", "0F 02 /r", "ANYVolatile ZF=W"},
	{"lds", "x:r16, m16_16", "RM", "66 C5 /r", "X86Volatile"},
	{"lds", "X:r32, m16_32", "RM", "C5 /r", "X86Volatile"},
	{"lea", "w:r16, mem", "RM", "67 8D /r", "ANY"},
	{"lea", "W:r32, mem", "RM", "8D /r", "ANY"},
	{"lea", "W:r64, mem", "RM", "REX.W 8D /r", "X64"},
	{"les", "x:r16, m16_16", "RM", "66 C4 /r", "X86Volatile"},
	{"les", "X:r32, m16_32", "RM", "C4 /r", "X86Volatile"},
	{"lfs", "x:r16, m16_16", "RM", "66 0F B4 /r", "ANYVolatile"},
	{"lfs", "X:r32, m16_32", "RM", "0F B4 /r", "ANYVolatile"},
	{"lfs", "X:r64, m16_64", "RM", "REX.W 0F B4 /r", "X64Volatile"},
	{"lgs", "x:r16, m16_16", "RM", "66 0F B5 /r", "ANYVolatile"},
	{"lgs", "X:r32, m16_32", "RM", "0F B5 /r", "ANYVolatile"},
	{"lgs", "X:r64, m16_64", "RM", "REX.W 0F B5 /r", "X64Volatile"},
	{"lodsb", "w:<al>, X:<ds:zsi>", "NONE", "AC", "ANY _Rep DF=R"},
	{"lodsw", "w:<ax>, X:<ds:zsi>", "NONE", "66 AD", "ANY _Rep DF=R"},
	{"lodsd", "W:<eax>, X:<ds:zsi>", "NONE", "AD", "ANY _Rep DF=R"},
	{"lodsq", "W:<rax>, X:<ds:zsi>", "NONE", "REX.W AD", "X64 _Rep DF=R"},
	{"loop", "x:<cx>, rel8", "D", "67 E2 cb", "X86Control=Branch"},
	{"loop", "X:<ecx>, rel8", "D", "E2 cb", "X86Control=Branch"},
	{"loop", "X:<ecx>, rel8", "D", "67 E2 cb", "X64Control=Branch"},
	{"loop", "X:<rcx>, rel8", "D", "E2 cb", "X64Control=Branch"},
	{"loope", "x:<cx>, rel8", "D", "67 E1 cb", "X86Control=Branch ZF=R"},
	{"loope", "X:<ecx>, rel8", "D", "E1 cb", "X86Control=Branch ZF=R"},
	{"loope", "X:<ecx>, rel8", "D", "67 E1 cb", "X64Control=Branch ZF=R"},
	{"loope", "X:<rcx>, rel8", "D", "E1 cb", "X64Control=Branch ZF=R"},
	{"loopne", "x:<cx>, rel8", "D", "67 E0 cb", "X86Control=Branch ZF=R"},
	{"loopne", "X:<ecx>, rel8", "D", "E0 cb", "X86Control=Branch ZF=R"},
	{"loopne", "X:<ecx>, rel8", "D", "67 E0 cb", "X64Control=Branch ZF=R"},
	{"loopne", "X:<rcx>, rel8", "D", "E0 cb", "X64Control=Branch ZF=R"},
	{"lsl", "w:r16, R:r16/m16", "RM", "66 0F 03 /r", "ANYVolatile ZF=W"},
	{"lsl", "W:r32, R:r32/m16", "RM", "0F 03 /r", "ANYVolatile ZF=W"},
	{"lsl", "W:r64, R:r32/m16", "RM", "REX.W 0F 03 /r", "X64Volatile ZF=W"},
	{"lss", "x:r16, m16_16", "RM", "66 0F B2 /r", "ANYVolatile"},
	{"lss", "X:r32, m16_32", "RM", "0F B2 /r", "ANYVolatile"},
	{"lss", "X:r64, m16_64", "RM", "REX.W 0F B2 /r", "X64Volatile"},
	{"mov", "w:r8/m8, r8", "MR", "88 /r", "ANY XRelease"},
	{"mov", "w:r16/m16, r16", "MR", "66 89 /r", "ANY XRelease"},
	{"mov", "W:r32/m32, r32", "MR", "89 /r", "ANY XRelease"},
	{"mov", "W:r64/m64, r64", "MR", "REX.W 89 /r", "X64 XRelease"},
	{"mov", "w:r8/m8, ib/ub", "MI", "C6 /0 ib", "ANY XRelease"},
	{"mov", "w:r16/m16, iw/uw", "MI", "66 C7 /0 iw", "ANY XRelease"},
	{"mov", "W:r32/m32, id/ud", "MI", "C7 /0 id", "ANY XRelease"},
	{"mov", "W:r64/m64, id", "MI", "REX.W C7 /0 id", "X64 XRelease"},
	{"mov", "w:r8, ib/ub", "I", "B0+r ib", "ANY"},
	{"mov", "w:r16, iw/uw", "I", "66 B8+r iw", "ANY"},
	{"mov", "W:r32, id/ud", "I", "B8+r id", "ANY"},
	{"mov", "W:r64, iq/uq", "I", "REX.W B8+r iq", "X64"},
	{"mov", "w:r8, r8/m8", "RM", "8A /r", "ANY"},
	{"mov", "w:r16, r16/m16", "RM", "66 8B /r", "ANY"},
	{"mov", "W:r32, r32/m32", "RM", "8B /r", "ANY"},
	{"mov", "W:r64, r64/m64", "RM", "REX.W 8B /r", "X64"},
	{"mov", "w:r16/m16, sreg", "MR", "8C /r", "ANY"},
	{"mov", "W:r32, sreg", "MR", "8C /r", "ANY"},
	{"mov", "W:r64/m64, sreg", "MR", "REX.W 8C /r", "X64"},
	{"mov", "W:sreg, r16/m16", "RM", "8E /r", "ANY"},
	{"mov", "W:sreg, r32", "RM", "8E /r", "ANY"},
	{"mov", "W:sreg, r64/m64", "RM", "REX.W 8E /r", "X64"},
	{"mov", "w:al, moff8", "NONE", "A0", "ANY"},
	{"mov", "w:ax, moff16", "NONE", "66 A1", "ANY"},
	{"mov", "W:eax, moff32", "NONE", "A1", "ANY"},
	{"mov", "W:rax, moff64", "NONE", "REX.W A1", "X64"},
	{"mov", "W:moff8, al", "NONE", "A2", "ANY"},
	{"mov", "W:moff16, ax", "NONE", "66 A3", "ANY"},
	{"mov", "W:moff32, eax", "NONE", "A3", "ANY"},
	{"mov", "W:moff64, rax", "NONE", "REX.W A3", "X64"},
	{"mov", "W:r32, creg", "MR", "0F 20 /r", "X86OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"mov", "W:r64, creg", "MR", "0F 20 /r", "X64OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"mov", "W:creg, r32", "RM", "0F 22 /r", "X86OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"mov", "W:creg, r64", "RM", "0F 22 /r", "X64OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"mov", "W:r32, dreg", "MR", "0F 21 /r", "X86OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"mov", "W:r64, dreg", "MR", "0F 21 /r", "X64OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"mov", "W:dreg, r32", "RM", "0F 23 /r", "X86OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"mov", "W:dreg, r64", "RM", "0F 23 /r", "X64OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"movsb", "X:<es:zdi>, X:<ds:zsi>", "NONE", "A4", "ANY _Rep DF=R"},
	{"movsw", "X:<es:zdi>, X:<ds:zsi>", "NONE", "66 A5", "ANY _Rep DF=R"},
	{"movsd", "X:<es:zdi>, X:<ds:zsi>", "NONE", "A5", "ANY _Rep DF=R"},
	{"movsq", "X:<es:zdi>, X:<ds:zsi>", "NONE", "REX.W A5", "X64 _Rep DF=R"},
	{"movsx", "w:r16, r8/m8", "RM", "66 0F BE /r", "ANY"},
	{"movsx", "W:r32, r8/m8", "RM", "0F BE /r", "ANY"},
	{"movsx", "W:r64, r8/m8", "RM", "REX.W 0F BE /r", "X64"},
	{"movsx", "W:r32, r16/m16", "RM", "0F BF /r", "ANY"},
	{"movsx", "W:r64, r16/m16", "RM", "REX.W 0F BF /r", "X64"},
	{"movsxd", "W:r64, r32/m32", "RM", "REX.W 63 /r", "X64"},
	{"movzx", "w:r16, r8/m8", "RM", "66 0F B6 /r", "ANY"},
	{"movzx", "W:r32, r8/m8", "RM", "0F B6 /r", "ANY"},
	{"movzx", "W:r64, r8/m8", "RM", "REX.W 0F B6 /r", "X64"},
	{"movzx", "W:r32, r16/m16", "RM", "0F B7 /r", "ANY"},
	{"movzx", "W:r64, r16/m16", "RM", "REX.W 0F B7 /r", "X64"},
	{"mul", "x:<ax>, r8/m8", "M", "F6 /4", "ANYOF=W SF=U ZF=U AF=U PF=U CF=W"},
	{"mul", "w:<dx>, x:<ax>, r16/m16", "M", "66 F7 /4", "ANYOF=W SF=U ZF=U AF=U PF=U CF=W"},
	{"mul", "W:<edx>, X:<eax>, r32/m32", "M", "F7 /4", "ANYOF=W SF=U ZF=U AF=U PF=U CF=W"},
	{"mul", "W:<rdx>, X:<rax>, r64/m64", "M", "REX.W F7 /4", "X64OF=W SF=U ZF=U AF=U PF=U CF=W"},
	{"neg", "x:r8/m8", "M", "F6 /3", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"neg", "x:r16/m16", "M", "66 F7 /3", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"neg", "X:r32/m32", "M", "F7 /3", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"neg", "X:r64/m64", "M", "REX.W F7 /3", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"nop", "", "NONE", "90", ""},
	{"nop", "R:r16/m16", "M", "66 0F 1F /0", ""},
	{"nop", "R:r32/m32", "M", "0F 1F /0", ""},
	{"not", "x:r8/m8", "M", "F6 /2", "ANY _XLock"},
	{"not", "x:r16/m16", "M", "66 F7 /2", "ANY _XLock"},
	{"not", "X:r32/m32", "M", "F7 /2", "ANY _XLock"},
	{"not", "X:r64/m64", "M", "REX.W F7 /2", "X64 _XLock"},
	{"or", "x:al, ib/ub", "I", "0C ib", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "x:ax, iw/uw", "I", "66 0D iw", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:eax, id/ud", "I", "0D id", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:rax, id", "I", "REX.W 0D id", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "x:r8/m8, ib/ub", "MI", "80 /1 ib", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "x:r16/m16, iw/uw", "MI", "66 81 /1 iw", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:r32/m32, id/ud", "MI", "81 /1 id", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:r64/m64, id", "MI", "REX.W 81 /1 id", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "x:r16/m16, ib", "MI", "66 83 /1 ib", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:r32/m32, ib", "MI", "83 /1 ib", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:r64/m64, ib", "MI", "REX.W 83 /1 ib", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "x:~r8/m8,~r8", "MR", "08 /r", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "x:~r16/m16,~r16", "MR", "66 09 /r", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:~r32/m32,~r32", "MR", "09 /r", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:~r64/m64,~r64", "MR", "REX.W 09 /r", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "x:~r8,~r8/m8", "RM", "0A /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "x:~r16,~r16/m16", "RM", "66 0B /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:~r32,~r32/m32", "RM", "0B /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"or", "X:~r64,~r64/m64", "RM", "REX.W 0B /r", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"out", "ub, al", "I", "E6 ib", "ANYVolatile"},
	{"out", "ub, ax", "I", "66 E7 ib", "ANYVolatile"},
	{"out", "ub, eax", "I", "E7 ib", "ANYVolatile"},
	{"out", "R:dx, R:al", "NONE", "EE", "ANYVolatile"},
	{"out", "R:dx, R:ax", "NONE", "66 EF", "ANYVolatile"},
	{"out", "R:dx, R:eax", "NONE", "EF", "ANYVolatile"},
	{"outsb", "R:dx, R:ds:zsi", "NONE", "6E", "ANY _Rep Volatile"},
	{"outsw", "R:dx, R:ds:zsi", "NONE", "66 6F", "ANY _Rep Volatile"},
	{"outsd", "R:dx, R:ds:zsi", "NONE", "6F", "ANY _Rep Volatile"},
	{"pause", "", "NONE", "F3 90", "ANYVolatile"},
	{"pcommit", "", "NONE", "66 0F AE F8", "PCOMMITVolatile"},
	{"pop", "w:r16/m16", "M", "66 8F /0", "ANY"},
	{"pop", "W:r32/m32", "M", "8F /0", "X86"},
	{"pop", "W:r64/m64", "M", "8F /0", "X64"},
	{"pop", "w:r16", "O", "66 58+r", "ANY"},
	{"pop", "W:r32", "O", "58+r", "X86"},
	{"pop", "W:r64", "O", "58+r", "X64"},
	{"pop", "W:ds", "NONE", "1F", "X86"},
	{"pop", "W:es", "NONE", "07", "X86"},
	{"pop", "W:ss", "NONE", "17", "X86"},
	{"pop", "W:fs", "NONE", "0F A1", "ANY"},
	{"pop", "W:gs", "NONE", "0F A9", "ANY"},
	{"popa", "", "NONE", "66 61", "X86 Deprecated"},
	{"popad", "", "NONE", "61", "X86 Deprecated"},
	{"popf", "", "NONE", "66 9D", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"popfd", "", "NONE", "9D", "X86OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"popfq", "", "NONE", "9D", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"prefetchw", "R:mem", "M", "0F 0D /1", "PREFETCHWOF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"prefetchwt1", "R:mem", "M", "0F 0D /2", "PREFETCHWT1OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"push", "R:r16/m16", "M", "66 FF /6", "ANY"},
	{"push", "R:r32/m32", "M", "FF /6", "X86"},
	{"push", "R:r64/m64", "M", "FF /6", "X64"},
	{"push", "R:r16", "O", "66 50+r", "ANY"},
	{"push", "R:r32", "O", "50+r", "X86"},
	{"push", "R:r64", "O", "50+r", "X64"},
	{"push", "ib", "I", "6A ib", "ANY"},
	{"push", "iw", "I", "66 68 iw", "ANY"},
	{"push", "id/ud", "I", "68 id", "X86"},
	{"push", "id", "I", "68 id", "X64"},
	{"push", "R:cs", "NONE", "0E", "X86"},
	{"push", "R:ss", "NONE", "16", "X86"},
	{"push", "R:ds", "NONE", "1E", "X86"},
	{"push", "R:es", "NONE", "06", "X86"},
	{"push", "R:fs", "NONE", "0F A0", "ANY"},
	{"push", "R:gs", "NONE", "0F A8", "ANY"},
	{"pusha", "", "NONE", "66 60", "X86 Deprecated"},
	{"pushad", "", "NONE", "60", "X86 Deprecated"},
	{"pushf", "", "NONE", "66 9C", "ANY"},
	{"pushfd", "", "NONE", "9C", "X86"},
	{"pushfq", "", "NONE", "9C", "X64"},
	{"rcl", "x:r8/m8, 1", "M", "D0 /2", "ANY CF=X OF=X"},
	{"rcl", "x:r8/m8, cl", "M", "D2 /2", "ANY CF=X OF=X"},
	{"rcl", "x:r8/m8, ib/ub", "MI", "C0 /2 ib", "ANY CF=X OF=X"},
	{"rcl", "x:r16/m16, 1", "M", "66 D1 /2", "ANY CF=X OF=X"},
	{"rcl", "x:r16/m16, cl", "M", "66 D3 /2", "ANY CF=X OF=X"},
	{"rcl", "x:r16/m16, ib/ub", "MI", "66 C1 /2 ib", "ANY CF=X OF=X"},
	{"rcl", "X:r32/m32, 1", "M", "D1 /2", "ANY CF=X OF=X"},
	{"rcl", "X:r32/m32, cl", "M", "D3 /2", "ANY CF=X OF=X"},
	{"rcl", "X:r32/m32, ib/ub", "MI", "C1 /2 ib", "ANY CF=X OF=X"},
	{"rcl", "X:r64/m64, 1", "M", "REX.W D1 /2", "X64 CF=X OF=X"},
	{"rcl", "X:r64/m64, cl", "M", "REX.W D3 /2", "X64 CF=X OF=X"},
	{"rcl", "X:r64/m64, ib/ub", "MI", "REX.W C1 /2 ib", "X64 CF=X OF=X"},
	{"rcr", "x:r8/m8, 1", "M", "D0 /3", "ANY CF=X OF=X"},
	{"rcr", "x:r8/m8, cl", "M", "D2 /3", "ANY CF=X OF=X"},
	{"rcr", "x:r8/m8, ib/ub", "MI", "C0 /3 ib", "ANY CF=X OF=X"},
	{"rcr", "x:r16/m16, 1", "M", "66 D1 /3", "ANY CF=X OF=X"},
	{"rcr", "x:r16/m16, cl", "M", "66 D3 /3", "ANY CF=X OF=X"},
	{"rcr", "x:r16/m16, ib/ub", "MI", "66 C1 /3 ib", "ANY CF=X OF=X"},
	{"rcr", "X:r32/m32, 1", "M", "D1 /3", "ANY CF=X OF=X"},
	{"rcr", "X:r32/m32, cl", "M", "D3 /3", "ANY CF=X OF=X"},
	{"rcr", "X:r32/m32, ib/ub", "MI", "C1 /3 ib", "ANY CF=X OF=X"},
	{"rcr", "X:r64/m64, 1", "M", "REX.W D1 /3", "X64 CF=X OF=X"},
	{"rcr", "X:r64/m64, cl", "M", "REX.W D3 /3", "X64 CF=X OF=X"},
	{"rcr", "X:r64/m64, ib/ub", "MI", "REX.W C1 /3 ib", "X64 CF=X OF=X"},
	{"rdfsbase", "W:r32", "M", "F3 0F AE /0", "FSGSBASE X64 Volatile"},
	{"rdfsbase", "W:r64", "M", "REX.W F3 0F AE /0", "FSGSBASE X64 Volatile"},
	{"rdgsbase", "W:r32", "M", "F3 0F AE /1", "FSGSBASE X64 Volatile"},
	{"rdgsbase", "W:r64", "M", "REX.W F3 0F AE /1", "FSGSBASE X64 Volatile"},
	{"rdrand", "w:r16", "M", "66 0F C7 /6", "RDRAND Volatile OF=0 SF=0 ZF=0 AF=0 PF=0 CF=W"},
	{"rdrand", "W:r32", "M", "0F C7 /6", "RDRAND Volatile OF=0 SF=0 ZF=0 AF=0 PF=0 CF=W"},
	{"rdrand", "W:r64", "M", "REX.W 0F C7 /6", "RDRAND X64 Volatile OF=0 SF=0 ZF=0 AF=0 PF=0 CF=W"},
	{"rdseed", "w:r16", "M", "66 0F C7 /7", "RDSEED Volatile OF=0 SF=0 ZF=0 AF=0 PF=0 CF=W"},
	{"rdseed", "W:r32", "M", "0F C7 /7", "RDSEED Volatile OF=0 SF=0 ZF=0 AF=0 PF=0 CF=W"},
	{"rdseed", "W:r64", "M", "REX.W 0F C7 /7", "RDSEED X64 Volatile OF=0 SF=0 ZF=0 AF=0 PF=0 CF=W"},
	{"ret", "", "NONE", "C3", "ANY _RepIgnoredControl=Return"},
	{"ret", "uw", "I", "C2 iw", "ANY _RepIgnoredControl=Return"},
	{"rol", "x:r8/m8, 1", "M", "D0 /0", "ANYCF=W OF=W"},
	{"rol", "x:r8/m8, cl", "M", "D2 /0", "ANYCF=W OF=W"},
	{"rol", "x:r8/m8, ib/ub", "MI", "C0 /0 ib", "ANYCF=W OF=W"},
	{"rol", "x:r16/m16, 1", "M", "66 D1 /0", "ANYCF=W OF=W"},
	{"rol", "x:r16/m16, cl", "M", "66 D3 /0", "ANYCF=W OF=W"},
	{"rol", "x:r16/m16, ib/ub", "MI", "66 C1 /0 ib", "ANYCF=W OF=W"},
	{"rol", "X:r32/m32, 1", "M", "D1 /0", "ANYCF=W OF=W"},
	{"rol", "X:r32/m32, cl", "M", "D3 /0", "ANYCF=W OF=W"},
	{"rol", "X:r32/m32, ib/ub", "MI", "C1 /0 ib", "ANYCF=W OF=W"},
	{"rol", "X:r64/m64, 1", "M", "REX.W D1 /0", "X64CF=W OF=W"},
	{"rol", "X:r64/m64, cl", "M", "REX.W D3 /0", "X64CF=W OF=W"},
	{"rol", "X:r64/m64, ib/ub", "MI", "REX.W C1 /0 ib", "X64CF=W OF=W"},
	{"ror", "x:r8/m8, 1", "M", "D0 /1", "ANYCF=W OF=W"},
	{"ror", "x:r8/m8, cl", "M", "D2 /1", "ANYCF=W OF=W"},
	{"ror", "x:r8/m8, ib/ub", "MI", "C0 /1 ib", "ANYCF=W OF=W"},
	{"ror", "x:r16/m16, 1", "M", "66 D1 /1", "ANYCF=W OF=W"},
	{"ror", "x:r16/m16, cl", "M", "66 D3 /1", "ANYCF=W OF=W"},
	{"ror", "x:r16/m16, ib/ub", "MI", "66 C1 /1 ib", "ANYCF=W OF=W"},
	{"ror", "X:r32/m32, 1", "M", "D1 /1", "ANYCF=W OF=W"},
	{"ror", "X:r32/m32, cl", "M", "D3 /1", "ANYCF=W OF=W"},
	{"ror", "X:r32/m32, ib/ub", "MI", "C1 /1 ib", "ANYCF=W OF=W"},
	{"ror", "X:r64/m64, 1", "M", "REX.W D1 /1", "X64CF=W OF=W"},
	{"ror", "X:r64/m64, cl", "M", "REX.W D3 /1", "X64CF=W OF=W"},
	{"ror", "X:r64/m64, ib/ub", "MI", "REX.W C1 /1 ib", "X64CF=W OF=W"},
	{"rsm", "", "NONE", "0F AA", "X86Volatile OF=U SF=U ZF=U AF=U PF=U CF=U"},
	{"sar", "x:r8/m8, 1", "M", "D0 /7", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "x:r8/m8, cl", "M", "D2 /7", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "x:r8/m8, ib/ub", "MI", "C0 /7 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "x:r16/m16, 1", "M", "66 D1 /7", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "x:r16/m16, cl", "M", "66 D3 /7", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "x:r16/m16, ib/ub", "MI", "66 C1 /7 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "X:r32/m32, 1", "M", "D1 /7", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "X:r32/m32, cl", "M", "D3 /7", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "X:r32/m32, ib/ub", "MI", "C1 /7 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "X:r64/m64, 1", "M", "REX.W D1 /7", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "X:r64/m64, cl", "M", "REX.W D3 /7", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sar", "X:r64/m64, ib/ub", "MI", "REX.W C1 /7 ib", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sbb", "x:al, ib/ub", "I", "1C ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "x:ax, iw/uw", "I", "66 1D iw", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:eax, id/ud", "I", "1D id", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:rax, id", "I", "REX.W 1D id", "X64OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "x:r8/m8, ib/ub", "MI", "80 /3 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "x:r16/m16, iw/uw", "MI", "66 81 /3 iw", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:r32/m32, id/ud", "MI", "81 /3 id", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:r64/m64, id", "MI", "REX.W 81 /3 id", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "x:r16/m16, ib", "MI", "66 83 /3 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:r32/m32, ib", "MI", "83 /3 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:r64/m64, ib", "MI", "REX.W 83 /3 ib", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "x:r8/m8, r8", "MR", "18 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "x:r16/m16, r16", "MR", "66 19 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:r32/m32, r32", "MR", "19 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:r64/m64, r64", "MR", "REX.W 19 /r", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "x:r8, r8/m8", "RM", "1A /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "x:r16, r16/m16", "RM", "66 1B /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:r32, r32/m32", "RM", "1B /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"sbb", "X:r64, r64/m64", "RM", "REX.W 1B /r", "X64OF=W SF=W ZF=W AF=W PF=W CF=X"},
	{"scasb", "R:<al>, X:<es:zdi>", "NONE", "AE", "ANY _Rep OF=W SF=W ZF=W AF=W PF=W CF=W DF=R"},
	{"scasw", "R:<ax>, X:<es:zdi>", "NONE", "66 AF", "ANY _Rep OF=W SF=W ZF=W AF=W PF=W CF=W DF=R"},
	{"scasd", "R:<eax>, X:<es:zdi>", "NONE", "AF", "ANY _Rep OF=W SF=W ZF=W AF=W PF=W CF=W DF=R"},
	{"scasq", "R:<rax>, X:<es:zdi>", "NONE", "REX.W AF", "X64 _Rep OF=W SF=W ZF=W AF=W PF=W CF=W DF=R"},
	{"seto", "w:r8/m8", "M", "0F 90 /r", "ANYOF=R"},
	{"setno", "w:r8/m8", "M", "0F 91 /r", "ANYOF=R"},
	{"setb/setnae/setc", "w:r8/m8", "M", "0F 92 /r", "ANYCF=R"},
	{"setae/setnb/setnc", "w:r8/m8", "M", "0F 93 /r", "ANYCF=R"},
	{"sete/setz", "w:r8/m8", "M", "0F 94 /r", "ANYZF=R"},
	{"setne/setnz", "w:r8/m8", "M", "0F 95 /r", "ANYZF=R"},
	{"setbe/setna", "w:r8/m8", "M", "0F 96 /r", "ANYCF=R ZF=R"},
	{"seta/setnbe", "w:r8/m8", "M", "0F 97 /r", "ANYCF=R ZF=R"},
	{"sets", "w:r8/m8", "M", "0F 98 /r", "ANYSF=R"},
	{"setns", "w:r8/m8", "M", "0F 99 /r", "ANYSF=R"},
	{"setp/setpe", "w:r8/m8", "M", "0F 9A /r", "ANYPF=R"},
	{"setnp/setpo", "w:r8/m8", "M", "0F 9B /r", "ANYPF=R"},
	{"setl/setnge", "w:r8/m8", "M", "0F 9C /r", "ANYSF=R OF=R"},
	{"setge/setnl", "w:r8/m8", "M", "0F 9D /r", "ANYSF=R OF=R"},
	{"setle/setng", "w:r8/m8", "M", "0F 9E /r", "ANYZF=R SF=R OF=R"},
	{"setg/setnle", "w:r8/m8", "M", "0F 9F /r", "ANYZF=R SF=R OF=R"},
	{"sgdt", "W:mem", "M", "0F 01 /0", "Volatile"},
	{"shl/sal", "x:r8/m8, 1", "M", "D0 /4", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "x:r8/m8, cl", "M", "D2 /4", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "x:r8/m8, ib/ub", "MI", "C0 /4 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "x:r16/m16, 1", "M", "66 D1 /4", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "x:r16/m16, cl", "M", "66 D3 /4", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "x:r16/m16, ib/ub", "MI", "66 C1 /4 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "X:r32/m32, 1", "M", "D1 /4", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "X:r32/m32, cl", "M", "D3 /4", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "X:r32/m32, ib/ub", "MI", "C1 /4 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "X:r64/m64, 1", "M", "REX.W D1 /4", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "X:r64/m64, cl", "M", "REX.W D3 /4", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shl/sal", "X:r64/m64, ib/ub", "MI", "REX.W C1 /4 ib", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "x:r8/m8, 1", "M", "D0 /5", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "x:r8/m8, cl", "M", "D2 /5", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "x:r8/m8, ib/ub", "MI", "C0 /5 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "x:r16/m16, 1", "M", "66 D1 /5", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "x:r16/m16, cl", "M", "66 D3 /5", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "x:r16/m16, ib/ub", "MI", "66 C1 /5 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "X:r32/m32, 1", "M", "D1 /5", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "X:r32/m32, cl", "M", "D3 /5", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "X:r32/m32, ib/ub", "MI", "C1 /5 ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "X:r64/m64, 1", "M", "REX.W D1 /5", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "X:r64/m64, cl", "M", "REX.W D3 /5", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shr", "X:r64/m64, ib/ub", "MI", "REX.W C1 /5 ib", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"shld", "x:r16/m16, r16, cl", "MR", "66 0F A5 /r", "ANYOF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shld", "x:r16/m16, r16, ib/ub", "MRI", "66 0F A4 /r ib", "ANYOF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shld", "X:r32/m32, r32, cl", "MR", "0F A5 /r", "ANYOF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shld", "X:r32/m32, r32, ib/ub", "MRI", "0F A4 /r ib", "ANYOF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shld", "X:r64/m64, r64, cl", "MR", "REX.W 0F A5 /r", "X64OF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shld", "X:r64/m64, r64, ib/ub", "MRI", "REX.W 0F A4 /r ib", "X64OF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shrd", "x:r16/m16, r16, cl", "MR", "66 0F AD /r", "ANYOF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shrd", "x:r16/m16, r16, ib/ub", "MRI", "66 0F AC /r ib", "ANYOF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shrd", "X:r32/m32, r32, cl", "MR", "0F AD /r", "ANYOF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shrd", "X:r32/m32, r32, ib/ub", "MRI", "0F AC /r ib", "ANYOF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shrd", "X:r64/m64, r64, cl", "MR", "REX.W 0F AD /r", "X64OF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"shrd", "X:r64/m64, r64, ib/ub", "MRI", "REX.W 0F AC /r ib", "X64OF=W SF=W ZF=W AF=U PF=W CF=W"},
	{"sidt", "W:mem", "M", "0F 01 /1", "ANY Volatile"},
	{"sldt", "w:r16/m16", "M", "66 0F 00 /0", "ANY Volatile"},
	{"sldt", "W:r32/m16", "M", "0F 00 /0", "ANY Volatile"},
	{"sldt", "W:r64/m16", "M", "REX.W 0F 00 /0", "X64 Volatile"},
	{"smsw", "w:r16/m16", "M", "66 0F 01 /4", "ANY Volatile"},
	{"smsw", "W:r32/m16", "M", "0F 01 /4", "ANY Volatile"},
	{"smsw", "W:r64/m16", "M", "REX.W 0F 01 /4", "X64 Volatile"},
	{"stac", "", "NONE", "0F 01 CB", "SMAP Volatile AC=1"},
	{"stc", "", "NONE", "F9", "ANYCF=1"},
	{"std", "", "NONE", "FD", "ANYDF=1"},
	{"sti", "", "NONE", "FB", "ANYVolatile IF=1"},
	{"stosb", "X:<es:zdi>, R:<al>", "NONE", "AA", "ANY _Rep DF=R"},
	{"stosw", "X:<es:zdi>, R:<ax>", "NONE", "66 AB", "ANY _Rep DF=R"},
	{"stosd", "X:<es:zdi>, R:<eax>", "NONE", "AB", "ANY _Rep DF=R"},
	{"stosq", "X:<es:zdi>, R:<rax>", "NONE", "REX.W AB", "X64 _Rep DF=R"},
	{"str", "w:r16/m16", "M", "66 0F 00 /1", "ANYVolatile"},
	{"str", "W:r32/m16", "M", "0F 00 /1", "ANYVolatile"},
	{"str", "W:r64/m16", "M", "REX.W 0F 00 /1", "X64Volatile"},
	{"sub", "x:al, ib/ub", "I", "2C ib", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "x:ax, iw/uw", "I", "66 2D iw", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:eax, id/ud", "I", "2D id", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:rax, id", "I", "REX.W 2D id", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "x:r8/m8, ib/ub", "MI", "80 /5 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "x:r16/m16, iw/uw", "MI", "66 81 /5 iw", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:r32/m32, id/ud", "MI", "81 /5 id", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:r64/m64, id", "MI", "REX.W 81 /5 id", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "x:r16/m16, ib", "MI", "66 83 /5 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:r32/m32, ib", "MI", "83 /5 ib", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:r64/m64, ib", "MI", "REX.W 83 /5 ib", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "x:r8/m8, r8", "MR", "28 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "x:r16/m16, r16", "MR", "66 29 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:r32/m32, r32", "MR", "29 /r", "ANY _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:r64/m64, r64", "MR", "REX.W 29 /r", "X64 _XLock OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "x:r8, r8/m8", "RM", "2A /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "x:r16, r16/m16", "RM", "66 2B /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:r32, r32/m32", "RM", "2B /r", "ANYOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"sub", "X:r64, r64/m64", "RM", "REX.W 2B /r", "X64OF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"test", "R:al, ib/ub", "I", "A8 ib", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:ax, iw/uw", "I", "66 A9 iw", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:eax, id/ud", "I", "A9 id", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:rax, id", "I", "REX.W A9 id", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:r8/m8, ib/ub", "MI", "F6 /0 ib", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:r16/m16, iw/uw", "MI", "66 F7 /0 iw", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:r32/m32, id/ud", "MI", "F7 /0 id", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:r64/m64, id", "MI", "REX.W F7 /0 id", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:~r8/m8,~r8", "MR", "84 /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:~r16/m16,~r16", "MR", "66 85 /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:~r32/m32,~r32", "MR", "85 /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"test", "R:~r64/m64,~r64", "MR", "REX.W 85 /r", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"ud2", "", "NONE", "0F 0B", "ANY"},
	{"verr", "R:r16/m16", "M", "0F 00 /4", "ANY Volatile ZF=W"},
	{"verw", "R:r16/m16", "M", "0F 00 /5", "ANY Volatile ZF=W"},
	{"wrfsbase", "R:r32", "M", "F3 0F AE /2", "FSGSBASE X64 Volatile"},
	{"wrfsbase", "R:r64", "M", "REX.W F3 0F AE /2", "FSGSBASE X64 Volatile"},
	{"wrgsbase", "R:r32", "M", "F3 0F AE /3", "FSGSBASE X64 Volatile"},
	{"wrgsbase", "R:r64", "M", "REX.W F3 0F AE /3", "FSGSBASE X64 Volatile"},
	{"xadd", "x:r8/m8, x:r8", "MR", "0F C0 /r", "I486 _XLockOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"xadd", "x:r16/m16, x:r16", "MR", "66 0F C1 /r", "I486 _XLockOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"xadd", "X:r32/m32, X:r32", "MR", "0F C1 /r", "I486 _XLockOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"xadd", "X:r64/m64, X:r64", "MR", "REX.W 0F C1 /r", "I486 X64 _XLockOF=W SF=W ZF=W AF=W PF=W CF=W"},
	{"xchg", "x:~ax, x:~r16", "O", "66 90+r", "ANY"},
	{"xchg", "X:~eax, X:~r32", "O", "90+r", "ANY"},
	{"xchg", "X:~rax, X:~r64", "O", "REX.W 90+r", "X64"},
	{"xchg", "x:~r16, x:~ax", "O", "66 90+r", "ANY"},
	{"xchg", "X:~r32, X:~eax", "O", "90+r", "ANY"},
	{"xchg", "X:~r64, X:~rax", "O", "REX.W 90+r", "X64"},
	{"xchg", "x:~r8/m8, x:~r8", "MR", "86 /r", "ANY _ILock XAcquire"},
	{"xchg", "x:~r16/m16, x:~r16", "MR", "66 87 /r", "ANY _ILock XAcquire"},
	{"xchg", "X:~r32/m32, X:~r32", "MR", "87 /r", "ANY _ILock XAcquire"},
	{"xchg", "X:~r64/m64, X:~r64", "MR", "REX.W 87 /r", "X64 _ILock XAcquire"},
	{"xchg", "x:~r8, x:~r8/m8", "RM", "86 /r", "ANY _ILock"},
	{"xchg", "x:~r16, x:~r16/m16", "RM", "66 87 /r", "ANY _ILock"},
	{"xchg", "X:~r32, X:~r32/m32", "RM", "87 /r", "ANY _ILock"},
	{"xchg", "X:~r64, X:~r64/m64", "RM", "REX.W 87 /r", "X64 _ILock"},
	{"xlatb", "", "NONE", "D7", "ANYVolatile"},
	{"xor", "x:al, ib/ub", "I", "34 ib", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "x:ax, iw/uw", "I", "66 35 iw", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:eax, id/ud", "I", "35 id", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:rax, id", "I", "REX.W 35 id", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "x:r8/m8, ib/ub", "MI", "80 /6 ib", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "x:r16/m16, iw/uw", "MI", "66 81 /6 iw", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:r32/m32, id/ud", "MI", "81 /6 id", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:r64/m64, id", "MI", "REX.W 81 /6 id", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "x:r16/m16, ib", "MI", "66 83 /6 ib", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:r32/m32, ib", "MI", "83 /6 ib", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:r64/m64, ib", "MI", "REX.W 83 /6 ib", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "x:~r8/m8, ~r8", "MR", "30 /r", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "x:~r16/m16, ~r16", "MR", "66 31 /r", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:~r32/m32, ~r32", "MR", "31 /r", "ANY _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:~r64/m64, ~r64", "MR", "REX.W 31 /r", "X64 _XLock OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "x:~r8, ~r8/m8", "RM", "32 /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "x:~r16, ~r16/m16", "RM", "66 33 /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:~r32, ~r32/m32", "RM", "33 /r", "ANYOF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"xor", "X:~r64, ~r64/m64", "RM", "REX.W 33 /r", "X64OF=0 SF=W ZF=W AF=U PF=W CF=0"},
	{"enter", "iw/uw, ib/ub", "II", "C8 iw ib", "ANYVolatile"},
	{"leave", "", "NONE", "C9", "ANYVolatile"},
	{"lahf", "w:<ah>", "NONE", "9F", "LAHFSAHF Volatile SF=R ZF=R AF=R PF=R CF=R"},
	{"sahf", "R:<ah>", "NONE", "9E", "LAHFSAHF Volatile SF=W ZF=W AF=W PF=W CF=W"},
	{"syscall", "", "NONE", "0F 05", "X64Volatile"},
	{"sysenter", "", "NONE", "0F 34", "ANYVolatile"},
	{"sysexit", "", "NONE", "0F 35", "ANYVolatile PRIVILEGE=L0"},
	{"sysexit64", "", "NONE", "REX.W 0F 35", "ANYVolatile PRIVILEGE=L0"},
	{"sysret", "", "NONE", "0F 07", "X64Volatile PRIVILEGE=L0"},
	{"sysret64", "", "NONE", "REX.W 0F 07", "X64Volatile PRIVILEGE=L0"},
	{"clts", "", "NONE", "0F 06", "ANYVolatile PRIVILEGE=L0"},
	{"hlt", "", "NONE", "F4", "ANYVolatile PRIVILEGE=L0"},
	{"invd", "", "NONE", "0F 08", "I486 Volatile PRIVILEGE=L0"},
	{"invlpg", "R:mem", "M", "0F 01 /7", "I486 Volatile PRIVILEGE=L0"},
	{"invpcid", "R:r32, R:m128", "RM", "66 0F 38 82 /r", "I486 X86 Volatile PRIVILEGE=L0"},
	{"invpcid", "R:r64, R:m128", "RM", "66 0F 38 82 /r", "I486 X64 Volatile PRIVILEGE=L0"},
	{"lgdt", "R:mem", "M", "0F 01 /2", "ANYVolatile PRIVILEGE=L0"},
	{"lidt", "R:mem", "M", "0F 01 /3", "ANYVolatile PRIVILEGE=L0"},
	{"lldt", "R:r16/m16", "M", "0F 00 /2", "ANYVolatile PRIVILEGE=L0"},
	{"lmsw", "R:r16/m16", "M", "0F 01 /6", "ANYVolatile PRIVILEGE=L0"},
	{"ltr", "R:r16/m16", "M", "0F 00 /3", "ANYVolatile PRIVILEGE=L0"},
	{"monitor", "R:<ds:zax>, R:<ecx>, R:<edx>", "NONE", "0F 01 C8", "MONITORVolatile PRIVILEGE=L0"},
	{"monitorx", "R:<ds:zax>, R:<ecx>, R:<edx>", "NONE", "0F 01 FA", "MONITORX Volatile"},
	{"mwait", "R:<eax>, R:<ecx>", "NONE", "0F 01 C9", "MONITORVolatile PRIVILEGE=L0"},
	{"mwaitx", "R:<eax>, R:<ecx>, R:<ebx>", "NONE", "0F 01 FB", "MONITORX Volatile"},
	{"rdpmc", "W:<edx>,W:<eax>,R:<ecx>", "NONE", "0F 33", "ANYVolatile PRIVILEGE=L0"},
	{"rdmsr", "W:<edx>,W:<eax>,R:<ecx>", "NONE", "0F 32", "ANYVolatile PRIVILEGE=L0 MSR=R"},
	{"wrmsr", "R:<edx>,R:<eax>,R:<ecx>", "NONE", "0F 30", "ANYVolatile PRIVILEGE=L0 MSR=W"},
	{"wbinvd", "", "NONE", "0F 09", "ANYVolatile PRIVILEGE=L0"},
	{"swapgs", "", "NONE", "0F 01 F8", "X64Volatile PRIVILEGE=L0"},
	{"xgetbv", "W:<edx>, W:<eax>, R:<ecx>", "NONE", "0F 01 D0", "XSAVEVolatileXCR=R"},
	{"xsetbv", "R:<edx>, R:<eax>, R:<ecx>", "NONE", "0F 01 D1", "XSAVEVolatile PRIVILEGE=L0 XCR=W"},
	{"rdtsc", "W:<edx>, W:<eax>", "NONE", "0F 31", "RDTSCVolatile"},
	{"rdtscp", "W:<edx>, W:<eax>, W:<ecx>", "NONE", "0F 01 F9", "RDTSCP Volatile"},
	{"fxrstor", "R:mem", "NONE", "0F AE /1", "FXSR Volatile C0=W C1=W C2=W C3=W"},
	{"fxrstor64", "R:mem", "NONE", "REX.W 0F AE /1", "FXSR X64 Volatile C0=W C1=W C2=W C3=W"},
	{"fxsave", "W:mem", "NONE", "0F AE /0", "FXSR Volatile"},
	{"fxsave64", "W:mem", "NONE", "REX.W 0F AE /0", "FXSR X64 Volatile"},
	{"xrstor", "R:mem, <edx>, <eax>", "M", "0F AE /5", "XSAVEVolatile XCR=R"},
	{"xrstor64", "R:mem, <edx>, <eax>", "M", "REX.W 0F AE /5", "XSAVE X64Volatile XCR=R"},
	{"xrstors", "R:mem, <edx>, <eax>", "M", "0F C7 /3", "XSAVES Volatile XCR=R"},
	{"xrstors64", "R:mem, <edx>, <eax>", "M", "REX.W 0F C7 /3", "XSAVES X64 Volatile XCR=R"},
	{"xsave", "W:mem, <edx>, <eax>", "M", "0F AE /4", "XSAVEVolatile XCR=R"},
	{"xsave64", "W:mem, <edx>, <eax>", "M", "REX.W 0F AE /4", "XSAVE X64Volatile XCR=R"},
	{"xsavec", "W:mem, <edx>, <eax>", "M", "0F C7 /4", "XSAVEC Volatile XCR=R"},
	{"xsavec64", "W:mem, <edx>, <eax>", "M", "REX.W 0F C7 /4", "XSAVEC X64 Volatile XCR=R"},
	{"xsaveopt", "W:mem, <edx>, <eax>", "M", "0F AE /6", "XSAVEOPT Volatile XCR=R"},
	{"xsaveopt64", "W:mem, <edx>, <eax>", "M", "REX.W 0F AE /6", "XSAVEOPT X64 Volatile XCR=R"},
	{"xsaves", "W:mem, <edx>, <eax>", "M", "0F C7 /5", "XSAVES Volatile XCR=R"},
	{"xsaves64", "W:mem, <edx>, <eax>", "M", "REX.W 0F C7 /5", "XSAVES X64 Volatile XCR=R"},
	{"xbegin", "rel16", "NONE", "66 C7 /7 cw", "RTMVolatile"},
	{"xbegin", "rel32", "NONE", "C7 /7 cd", "RTMVolatile"},
	{"xend", "", "NONE", "0F 01 D5", "RTMVolatile"},
	{"xtest", "", "NONE", "0F 01 D6", "TSXVolatile OF=0 SF=0 ZF=W AF=0 PF=0 CF=0"},
	{"xabort", "ib/ub", "I", "C6 /7 ib", "RTMVolatile"},
	{"adcx", "X:~r32, ~r32/m32", "RM", "66 0F 38 F6 /r", "ADXCF=X"},
	{"adcx", "X:~r64, ~r64/m64", "RM", "REX.W 66 0F 38 F6 /r", "ADX X64CF=X"},
	{"adox", "X:~r32, ~r32/m32", "RM", "F3 0F 38 F6 /r", "ADXOF=X"},
	{"adox", "X:~r64, ~r64/m64", "RM", "REX.W F3 0F 38 F6 /r", "ADX X64OF=X"},
	{"andn", "W:r32, r32, r32/m32", "RVM", "VEX.NDS.LZ.0F38.W0 F2 /r", "BMIOF=0 SF=W ZF=W AF=U PF=U CF=0"},
	{"andn", "W:r64, r64, r64/m64", "RVM", "VEX.NDS.LZ.0F38.W1 F2 /r", "BMI X64OF=0 SF=W ZF=W AF=U PF=U CF=0"},
	{"bextr", "W:r32, r32/m32, r32", "RMV", "VEX.NDS.LZ.0F38.W0 F7 /r", "BMIOF=0 SF=U ZF=W AF=U PF=U CF=0"},
	{"bextr", "W:r64, r64/m64, r64", "RMV", "VEX.NDS.LZ.0F38.W1 F7 /r", "BMI X64OF=0 SF=U ZF=W AF=U PF=U CF=0"},
	{"blsi", "W:r32, r32/m32", "VM", "VEX.NDD.LZ.0F38.W0 F3 /3", "BMIOF=0 SF=W ZF=W AF=U PF=U CF=W"},
	{"blsi", "W:r64, r64/m64", "VM", "VEX.NDD.LZ.0F38.W1 F3 /3", "BMI X64OF=0 SF=W ZF=W AF=U PF=U CF=W"},
	{"blsmsk", "W:r32, r32/m32", "VM", "VEX.NDD.LZ.0F38.W0 F3 /2", "BMIOF=0 SF=W ZF=0 AF=U PF=U CF=W"},
	{"blsmsk", "W:r64, r64/m64", "VM", "VEX.NDD.LZ.0F38.W1 F3 /2", "BMI X64OF=0 SF=W ZF=0 AF=U PF=U CF=W"},
	{"blsr", "W:r32, r32/m32", "VM", "VEX.NDD.LZ.0F38.W0 F3 /1", "BMIOF=0 SF=W ZF=W AF=U PF=U CF=W"},
	{"blsr", "W:r64, r64/m64", "VM", "VEX.NDD.LZ.0F38.W1 F3 /1", "BMI X64OF=0 SF=W ZF=W AF=U PF=U CF=W"},
	{"bzhi", "W:r32, r32/m32, r32", "RMV", "VEX.NDS.LZ.0F38.W0 F5 /r", "BMI2 OF=0 SF=W ZF=W AF=U PF=U CF=W"},
	{"bzhi", "W:r64, r64/m64, r64", "RMV", "VEX.NDS.LZ.0F38.W1 F5 /r", "BMI2 X64 OF=0 SF=W ZF=W AF=U PF=U CF=W"},
	{"lzcnt", "w:r16, r16/m16", "RM", "66 F3 0F BD /r", "LZCNTOF=U SF=U ZF=W AF=U PF=U CF=W"},
	{"lzcnt", "W:r32, r32/m32", "RM", "F3 0F BD /r", "LZCNTOF=U SF=U ZF=W AF=U PF=U CF=W"},
	{"lzcnt", "W:r64, r64/m64", "RM", "REX.W F3 0F BD /r", "LZCNT X64OF=U SF=U ZF=W AF=U PF=U CF=W"},
	{"mulx", "W:r32, W:r32, ~r32/m32, ~<edx>", "RVM", "VEX.NDD.LZ.F2.0F38.W0 F6 /r", "BMI2"},
	{"mulx", "W:r64, W:r64, ~r64/m64, ~<rdx>", "RVM", "VEX.NDD.LZ.F2.0F38.W1 F6 /r", "BMI2 X64"},
	{"pdep", "W:r32, r32, r32/m32", "RVM", "VEX.NDS.LZ.F2.0F38.W0 F5 /r", "BMI2"},
	{"pdep", "W:r64, r64, r64/m64", "RVM", "VEX.NDS.LZ.F2.0F38.W1 F5 /r", "BMI2 X64"},
	{"pext", "W:r32, r32, r32/m32", "RVM", "VEX.NDS.LZ.F3.0F38.W0 F5 /r", "BMI2"},
	{"pext", "W:r64, r64, r64/m64", "RVM", "VEX.NDS.LZ.F3.0F38.W1 F5 /r", "BMI2 X64"},
	{"popcnt", "W:r16, r16/m16", "RM", "66 F3 0F B8 /r", "POPCNT OF=0 SF=0 ZF=W AF=0 PF=0 CF=0"},
	{"popcnt", "W:r32, r32/m32", "RM", "F3 0F B8 /r", "POPCNT OF=0 SF=0 ZF=W AF=0 PF=0 CF=0"},
	{"popcnt", "W:r64, r64/m64", "RM", "REX.W F3 0F B8 /r", "POPCNT X64 OF=0 SF=0 ZF=W AF=0 PF=0 CF=0"},
	{"rorx", "W:r32, r32/m32, ib/ub", "RMI", "VEX.LZ.F2.0F3A.W0 F0 /r ib", "BMI2"},
	{"rorx", "W:r64, r64/m64, ib/ub", "RMI", "VEX.LZ.F2.0F3A.W1 F0 /r ib", "BMI2 X64"},
	{"sarx", "W:r32, r32/m32, r32", "RMV", "VEX.NDS.LZ.F3.0F38.W0 F7 /r", "BMI2"},
	{"sarx", "W:r64, r64/m64, r64", "RMV", "VEX.NDS.LZ.F3.0F38.W1 F7 /r", "BMI2 X64"},
	{"shlx", "W:r32, r32/m32, r32", "RMV", "VEX.NDS.LZ.66.0F38.W0 F7 /r", "BMI2"},
	{"shlx", "W:r64, r64/m64, r64", "RMV", "VEX.NDS.LZ.66.0F38.W1 F7 /r", "BMI2 X64"},
	{"shrx", "W:r32, r32/m32, r32", "RMV", "VEX.NDS.LZ.F2.0F38.W0 F7 /r", "BMI2"},
	{"shrx", "W:r64, r64/m64, r64", "RMV", "VEX.NDS.LZ.F2.0F38.W1 F7 /r", "BMI2 X64"},
	{"tzcnt", "w:r16, r16/m16", "RM", "66 F3 0F BC /r", "BMIOF=U SF=U ZF=W AF=U PF=U CF=W"},
	{"tzcnt", "W:r32, r32/m32", "RM", "F3 0F BC /r", "BMIOF=U SF=U ZF=W AF=U PF=U CF=W"},
	{"tzcnt", "W:r64, r64/m64", "RM", "REX.W F3 0F BC /r", "BMI X64OF=U SF=U ZF=W AF=U PF=U CF=W"},
	{"crc32", "X:r32, r8/m8", "RM", "F2 0F 38 F0 /r", "SSE4_2"},
	{"crc32", "X:r32, r16/m16", "RM", "66 F2 0F 38 F1 /r", "SSE4_2"},
	{"crc32", "X:r32, r32/m32", "RM", "F2 0F 38 F1 /r", "SSE4_2"},
	{"crc32", "X:r64, r8/m8", "RM", "REX.W F2 0F 38 F0 /r", "SSE4_2 X64"},
	{"crc32", "X:r64, r64/m64", "RM", "REX.W F2 0F 38 F1 /r", "SSE4_2 X64"},
	{"movbe", "w:r16, m16", "RM", "66 0F 38 F0 /r", "MOVBE"},
	{"movbe", "W:r32, m32", "RM", "0F 38 F0 /r", "MOVBE"},
	{"movbe", "W:r64, m64", "RM", "REX.W 0F 38 F0 /r", "MOVBE X64"},
	{"movbe", "W:m16, r16", "MR", "66 0F 38 F1 /r", "MOVBE"},
	{"movbe", "W:m32, r32", "MR", "0F 38 F1 /r", "MOVBE"},
	{"movbe", "W:m64, r64", "MR", "REX.W 0F 38 F1 /r", "MOVBE X64"},
	{"blci", "W:r32, r32/m32", "VM", "XOP.NDD.LZ.M09.W0 02 /6", "TBM"},
	{"blci", "W:r64, r64/m64", "VM", "XOP.NDD.LZ.M09.W1 02 /6", "TBM X64"},
	{"blcic", "W:r32, r32/m32", "VM", "XOP.NDD.LZ.M09.W0 01 /5", "TBM"},
	{"blcic", "W:r64, r64/m64", "VM", "XOP.NDD.LZ.M09.W1 01 /5", "TBM X64"},
	{"blsic", "W:r32, r32/m32", "VM", "XOP.NDD.LZ.M09.W0 01 /6", "TBM"},
	{"blsic", "W:r64, r64/m64", "VM", "XOP.NDD.LZ.M09.W1 01 /6", "TBM X64"},
	{"blcfill", "W:r32, r32/m32", "VM", "XOP.NDD.LZ.M09.W0 01 /1", "TBM"},
	{"blcfill", "W:r64, r64/m64", "VM", "XOP.NDD.LZ.M09.W1 01 /1", "TBM X64"},
	{"blsfill", "W:r32, r32/m32", "VM", "XOP.NDD.LZ.M09.W0 01 /2", "TBM"},
	{"blsfill", "W:r64, r64/m64", "VM", "XOP.NDD.LZ.M09.W1 01 /2", "TBM X64"},
	{"blcmsk", "W:r32, r32/m32", "VM", "XOP.NDD.LZ.M09.W0 02 /1", "TBM"},
	{"blcmsk", "W:r64, r64/m64", "VM", "XOP.NDD.LZ.M09.W1 02 /1", "TBM X64"},
	{"blcs", "W:r32, r32/m32", "VM", "XOP.NDD.LZ.M09.W0 01 /3", "TBM"},
	{"blcs", "W:r64, r64/m64", "VM", "XOP.NDD.LZ.M09.W1 01 /3", "TBM X64"},
	{"tzmsk", "W:r32, r32/m32", "VM", "XOP.NDD.LZ.M09.W0 01 /4", "TBM"},
	{"tzmsk", "W:r64, r64/m64", "VM", "XOP.NDD.LZ.M09.W1 01 /4", "TBM X64"},
	{"t1mskc", "W:r32, r32/m32", "VM", "XOP.NDD.LZ.M09.W0 01 /7", "TBM"},
	{"t1mskc", "W:r64, r64/m64", "VM", "XOP.NDD.LZ.M09.W1 01 /7", "TBM X64"},
	{"llwpcb", "R:r32", "M", "XOP.L0.P0.M09.W0 12 /0", "LWP"},
	{"llwpcb", "R:r64", "M", "XOP.L0.P0.M09.W1 12 /0", "LWP X64"},
	{"lwpins", "R:r32, R:r32/m32, id/ud", "VMI", "XOP.L0.P0.M0A.W0 12 /0 id", "LWP"},
	{"lwpins", "R:r64, R:r32/m32, id/ud", "VMI", "XOP.L0.P0.M0A.W1 12 /0 id", "LWP X64"},
	{"lwpval", "R:r32, R:r32/m32, id/ud", "VMI", "XOP.L0.P0.M0A.W0 12 /1 id", "LWP"},
	{"lwpval", "R:r64, R:r32/m32, id/ud", "VMI", "XOP.L0.P0.M0A.W1 12 /1 id", "LWP X64"},
	{"slwpcb", "W:r32", "M", "XOP.L0.P0.M09.W0 12 /1", "LWP"},
	{"slwpcb", "W:r64", "M", "XOP.L0.P0.M09.W1 12 /1", "LWP X64"},
	{"getsec", "", "NONE", "0F 37", "SMX"},
	{"invept", "R:r32, R:m128", "RM", "66 0F 38 80 /r", "VMX X86PRIVILEGE=L0"},
	{"invept", "R:r64, R:m128", "RM", "66 0F 38 80 /r", "VMX X64PRIVILEGE=L0"},
	{"invvpid", "R:r32, R:m128", "RM", "66 0F 38 81 /r", "VMX X86PRIVILEGE=L0"},
	{"invvpid", "R:r64, R:m128", "RM", "66 0F 38 81 /r", "VMX X64PRIVILEGE=L0"},
	{"vmcall", "", "NONE", "0F 01 C1", "VMXPRIVILEGE=L0"},
	{"vmclear", "W:m64", "M", "66 0F C7 /6", "VMX X64PRIVILEGE=L0"},
	{"vmfunc", "", "NONE", "0F 01 D4", "VMX"},
	{"vmlaunch", "", "NONE", "0F 01 C2", "VMXPRIVILEGE=L0"},
	{"vmptrld", "R:m64", "M", "0F C7 /6", "VMXPRIVILEGE=L0"},
	{"vmptrst", "W:m64", "M", "0F C7 /7", "VMXPRIVILEGE=L0"},
	{"vmread", "W:r32/m32, R:r32", "MR", "0F 78 /r", "VMX X86PRIVILEGE=L0"},
	{"vmread", "W:r64/m64, R:r64", "MR", "0F 78 /r", "VMX X64PRIVILEGE=L0"},
	{"vmresume", "", "NONE", "0F 01 C3", "VMXPRIVILEGE=L0"},
	{"vmwrite", "R:r32, R:r32/m32", "RM", "0F 79 /r", "VMX X86PRIVILEGE=L0"},
	{"vmwrite", "R:r64, R:r64/m64", "RM", "0F 79 /r", "VMX X64PRIVILEGE=L0"},
	{"vmxon", "R:m64", "M", "F3 0F C7 /6", "VMX"},
	{"skinit", "X:<eax>", "NONE", "0F 01 DE", "SKINIT PRIVILEGE=L0"},
	{"stgi", "", "NONE", "0F 01 DC", "SKINIT PRIVILEGE=L0"},
	{"clgi", "", "NONE", "0F 01 DD", "SVMPRIVILEGE=L0"},
	{"invlpga", "R:<eax>, R:<ecx>", "NONE", "0F 01 DF", "SVMPRIVILEGE=L0"},
	{"invlpga", "R:<rax>, R:<ecx>", "NONE", "0F 01 DF", "SVM X64PRIVILEGE=L0"},
	{"vmload", "R:<eax>", "NONE", "0F 01 DA", "SVM X86PRIVILEGE=L0"},
	{"vmload", "R:<rax>", "NONE", "0F 01 DA", "SVM X64PRIVILEGE=L0"},
	{"vmmcall", "", "NONE", "0F 01 D9", "SVM"},
	{"vmrun", "X:<eax>", "NONE", "0F 01 D8", "SVM X86PRIVILEGE=L0"},
	{"vmrun", "X:<rax>", "NONE", "0F 01 D8", "SVM X64PRIVILEGE=L0"},
	{"vmsave", "R:<eax>", "NONE", "0F 01 DB", "SVM X86PRIVILEGE=L0"},
	{"vmsave", "R:<rax>", "NONE", "0F 01 DB", "SVM X64PRIVILEGE=L0"},
	{"f2xm1", "", "NONE", "D9 F0", "FPUC0=U C1=W C2=U C3=U"},
	{"fabs", "", "NONE", "D9 E1", "FPUC0=U C1=0 C2=U C3=U"},
	{"fadd", "R:m32fp", "M", "D8 /0", "FPUC0=U C1=W C2=U C3=U"},
	{"fadd", "R:m64fp", "M", "DC /0", "FPUC0=U C1=W C2=U C3=U"},
	{"fadd", "st(0), st(i)", "O", "D8 C0+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fadd", "st(i), st(0)", "O", "DC C0+i", "FPUC0=U C1=W C2=U C3=U"},
	{"faddp", "", "NONE", "DE C1", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"faddp", "st(i)", "O", "DE C0+i", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fbld", "R:m80dec", "M", "DF /4", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fbstp", "W:m80bcd", "M", "DF /6", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fchs", "", "NONE", "D9 E0", "FPUC0=U C1=0 C2=U C3=U"},
	{"fclex", "", "NONE", "9B DB E2", "FPUC0=U C1=U C2=U C3=U"},
	{"fcmovb", "st(i)", "O", "DA C0+i", "FPU CMOV C0=U C1=W C2=U C3=U"},
	{"fcmovbe", "st(i)", "O", "DA D0+i", "FPU CMOV C0=U C1=W C2=U C3=U"},
	{"fcmove", "st(i)", "O", "DA C8+i", "FPU CMOV C0=U C1=W C2=U C3=U"},
	{"fcmovnb", "st(i)", "O", "DB C0+i", "FPU CMOV C0=U C1=W C2=U C3=U"},
	{"fcmovnbe", "st(i)", "O", "DB D0+i", "FPU CMOV C0=U C1=W C2=U C3=U"},
	{"fcmovne", "st(i)", "O", "DB C8+i", "FPU CMOV C0=U C1=W C2=U C3=U"},
	{"fcmovnu", "st(i)", "O", "DB D8+i", "FPU CMOV C0=U C1=W C2=U C3=U"},
	{"fcmovu", "st(i)", "O", "DA D8+i", "FPU CMOV C0=U C1=W C2=U C3=U"},
	{"fcom", "", "NONE", "D8 D1", "FPUC0=W C1=0 C2=W C3=W"},
	{"fcom", "R:m32fp", "M", "D8 /2", "FPUC0=W C1=0 C2=W C3=W"},
	{"fcom", "R:m64fp", "M", "DC /2", "FPUC0=W C1=0 C2=W C3=W"},
	{"fcom", "R:st(i)", "O", "D8 D0+i", "FPUC0=W C1=0 C2=W C3=W"},
	{"fcomi", "R:st(i)", "O", "DB F0+i", "FPUC1=0 ZF=W PF=W CF=W"},
	{"fcomip", "R:st(i)", "O", "DF F0+i", "FPU_POPC1=0 ZF=W PF=W CF=W"},
	{"fcomp", "", "NONE", "D8 D9", "FPU_POPC0=W C1=W C2=W C3=W"},
	{"fcomp", "R:m32fp", "M", "D8 /3", "FPU_POPC0=W C1=W C2=W C3=W"},
	{"fcomp", "R:m64fp", "M", "DC /3", "FPU_POPC0=W C1=W C2=W C3=W"},
	{"fcomp", "R:st(i)", "O", "D8 D8+i", "FPU_POPC0=W C1=W C2=W C3=W"},
	{"fcompp", "", "NONE", "DE D9", "FPU_POP=2C0=W C1=W C2=W C3=W"},
	{"fcos", "", "NONE", "D9 FF", "FPUC0=U C1=W C2=W C3=U"},
	{"fdecstp", "", "NONE", "D9 F6", "FPU_TOP=-1 C0=U C1=W C2=U C3=U"},
	{"fdiv", "R:m32fp", "M", "D8 /6", "FPUC0=U C1=W C2=U C3=U"},
	{"fdiv", "R:m64fp", "M", "DC /6", "FPUC0=U C1=W C2=U C3=U"},
	{"fdiv", "st(0), st(i)", "O", "D8 F0+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fdiv", "st(i), st(0)", "O", "DC F8+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fdivp", "", "NONE", "DE F9", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fdivp", "st(i)", "O", "DE F8+i", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fdivr", "R:m32fp", "M", "D8 /7", "FPUC0=U C1=W C2=U C3=U"},
	{"fdivr", "R:m64fp", "M", "DC /7", "FPUC0=U C1=W C2=U C3=U"},
	{"fdivr", "st(0), st(i)", "O", "D8 F8+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fdivr", "st(i), st(0)", "O", "DC F0+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fdivrp", "", "NONE", "DE F1", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fdivrp", "st(i)", "O", "DE F0+i", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"ffree", "st(i)", "O", "DD C0+i", "FPUC0=U C1=U C2=U C3=U"},
	{"fiadd", "R:m16int", "M", "DE /0", "FPUC0=U C1=W C2=U C3=U"},
	{"fiadd", "R:m32int", "M", "DA /0", "FPUC0=U C1=W C2=U C3=U"},
	{"ficom", "R:m16int", "M", "DE /2", "FPUC0=W C1=0 C2=W C3=W"},
	{"ficom", "R:m32int", "M", "DA /2", "FPUC0=W C1=0 C2=W C3=W"},
	{"ficomp", "R:m16int", "M", "DE /3", "FPUC0=W C1=0 C2=W C3=W"},
	{"ficomp", "R:m32int", "M", "DA /3", "FPUC0=W C1=0 C2=W C3=W"},
	{"fidiv", "R:m16int", "M", "DE /6", "FPUC0=U C1=W C2=U C3=U"},
	{"fidiv", "R:m32int", "M", "DA /6", "FPUC0=U C1=W C2=U C3=U"},
	{"fidivr", "R:m16int", "M", "DE /7", "FPUC0=U C1=W C2=U C3=U"},
	{"fidivr", "R:m32int", "M", "DA /7", "FPUC0=U C1=W C2=U C3=U"},
	{"fild", "R:m16int", "M", "DF /0", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fild", "R:m32int", "M", "DB /0", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fild", "R:m64int", "M", "DF /5", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fimul", "R:m16int", "M", "DE /1", "FPUC0=U C1=W C2=U C3=U"},
	{"fimul", "R:m32int", "M", "DA /1", "FPUC0=U C1=W C2=U C3=U"},
	{"fincstp", "", "NONE", "D9 F7", "FPU_TOP=+1 C0=U C1=0 C2=U C3=U"},
	{"finit", "", "NONE", "9B DB E3", "FPUC0=0 C1=0 C2=0 C3=0"},
	{"fist", "W:m16int", "M", "DF /2", "FPUC0=U C1=W C2=U C3=U"},
	{"fist", "W:m32int", "M", "DB /2", "FPUC0=U C1=W C2=U C3=U"},
	{"fistp", "W:m16int", "M", "DF /3", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fistp", "W:m32int", "M", "DB /3", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fistp", "W:m64int", "M", "DF /7", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fisttp", "W:m16int", "M", "DF /1", "FPU_POP SSE3 C0=U C1=0 C2=U C3=U"},
	{"fisttp", "W:m32int", "M", "DB /1", "FPU_POP SSE3 C0=U C1=0 C2=U C3=U"},
	{"fisttp", "W:m64int", "M", "DD /1", "FPU_POP SSE3 C0=U C1=0 C2=U C3=U"},
	{"fisub", "R:m16int", "M", "DE /4", "FPUC0=U C1=W C2=U C3=U"},
	{"fisub", "R:m32int", "M", "DA /4", "FPUC0=U C1=W C2=U C3=U"},
	{"fisubr", "R:m16int", "M", "DE /5", "FPUC0=U C1=W C2=U C3=U"},
	{"fisubr", "R:m32int", "M", "DA /5", "FPUC0=U C1=W C2=U C3=U"},
	{"fld", "R:m32fp", "M", "D9 /0", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fld", "R:m64fp", "M", "DD /0", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fld", "R:m80fp", "M", "DB /5", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fld", "R:st(i)", "O", "D9 C0+i", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fld1", "", "NONE", "D9 E8", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fldcw", "R:m16", "M", "D9 /5", "FPUC0=U C1=U C2=U C3=U"},
	{"fldenv", "R:mem", "M", "D9 /4", "FPUC0=W C1=W C2=W C3=W"},
	{"fldl2e", "", "NONE", "D9 EA", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fldl2t", "", "NONE", "D9 E9", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fldlg2", "", "NONE", "D9 EC", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fldln2", "", "NONE", "D9 ED", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fldpi", "", "NONE", "D9 EB", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fldz", "", "NONE", "D9 EE", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fmul", "m32fp", "M", "D8 /1", "FPUC0=U C1=W C2=U C3=U"},
	{"fmul", "m64fp", "M", "DC /1", "FPUC0=U C1=W C2=U C3=U"},
	{"fmul", "st(0), st(i)", "O", "D8 C8+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fmul", "st(i), st(0)", "O", "DC C8+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fmulp", "", "NONE", "DE C9", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fmulp", "st(i)", "O", "DE C8+i", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fnclex", "", "NONE", "DB E2", "FPUC0=U C1=U C2=U C3=U"},
	{"fninit", "", "NONE", "DB E3", "FPUC0=0 C1=0 C2=0 C3=0"},
	{"fnop", "", "NONE", "D9 D0", "FPUC0=U C1=U C2=U C3=U"},
	{"fnsave", "W:mem", "M", "DD /6", "FPUC0=W C1=W C2=W C3=W"},
	{"fnstcw", "W:m16", "M", "D9 /7", "FPUC0=U C1=U C2=U C3=U"},
	{"fnstenv", "W:mem", "M", "D9 /6", "FPUC0=U C1=U C2=U C3=U"},
	{"fnstsw", "w:ax", "NONE", "DF E0", "FPUC0=U C1=U C2=U C3=U"},
	{"fnstsw", "W:m16", "M", "DD /7", "FPUC0=U C1=U C2=U C3=U"},
	{"fpatan", "", "NONE", "D9 F3", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fprem", "", "NONE", "D9 F8", "FPUC0=U C1=W C2=U C3=U"},
	{"fprem1", "", "NONE", "D9 F5", "FPUC0=W C1=W C2=W C3=W"},
	{"fptan", "", "NONE", "D9 F2", "FPU_POPC0=U C1=W C2=W C3=U"},
	{"frndint", "", "NONE", "D9 FC", "FPUC0=U C1=W C2=U C3=U"},
	{"frstor", "R:mem", "M", "DD /4", "FPUC0=W C1=W C2=W C3=W"},
	{"fsave", "W:mem", "M", "9B DD /6", "FPUC0=W C1=W C2=W C3=W"},
	{"fscale", "", "NONE", "D9 FD", "FPUC0=U C1=W C2=U C3=U"},
	{"fsin", "", "NONE", "D9 FE", "FPUC0=U C1=W C2=W C3=U"},
	{"fsincos", "", "NONE", "D9 FB", "FPU_PUSH C0=U C1=W C2=W C3=U"},
	{"fsqrt", "", "NONE", "D9 FE", "FPUC0=U C1=W C2=U C3=U"},
	{"fst", "W:m32fp", "M", "D9 /2", "FPUC0=U C1=W C2=U C3=U"},
	{"fst", "W:m64fp", "M", "DD /2", "FPUC0=U C1=W C2=U C3=U"},
	{"fst", "W:st(i)", "O", "DD D0+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fstcw", "W:m16", "M", "9B D9 /7", "FPUC0=U C1=U C2=U C3=U"},
	{"fstenv", "W:mem", "M", "9B D9 /6", "FPUC0=U C1=U C2=U C3=U"},
	{"fstp", "W:m32fp", "M", "D9 /3", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fstp", "W:m64fp", "M", "DD /3", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fstp", "W:m80fp", "M", "DB /7", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fstp", "W:st(i)", "O", "DD D8+i", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fstsw", "w:ax", "NONE", "9B DF E0", "FPUC0=U C1=U C2=U C3=U"},
	{"fstsw", "W:m16", "M", "9B DD /7", "FPUC0=U C1=U C2=U C3=U"},
	{"fsub", "R:m32fp", "M", "D8 /4", "FPUC0=U C1=W C2=U C3=U"},
	{"fsub", "R:m64fp", "M", "DC /4", "FPUC0=U C1=W C2=U C3=U"},
	{"fsub", "st(0), st(i)", "O", "D8 E0+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fsub", "st(i), st(0)", "O", "DC E8+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fsubp", "", "NONE", "DE E9", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fsubp", "st(i)", "O", "DE E8+i", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fsubr", "R:m32fp", "M", "D8 /5", "FPUC0=U C1=W C2=U C3=U"},
	{"fsubr", "R:m64fp", "M", "DC /5", "FPUC0=U C1=W C2=U C3=U"},
	{"fsubr", "st(0), st(i)", "O", "D8 E8+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fsubr", "st(i), st(0)", "O", "DC E0+i", "FPUC0=U C1=W C2=U C3=U"},
	{"fsubrp", "", "NONE", "DE E1", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fsubrp", "st(i)", "O", "DE E0+i", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"ftst", "", "NONE", "D9 E4", "FPUC0=W C1=0 C2=W C3=W"},
	{"fucom", "", "NONE", "DD E1", "FPUC0=W C1=0 C2=W C3=W"},
	{"fucom", "R:st(i)", "O", "DD E0+i", "FPUC0=W C1=0 C2=W C3=W"},
	{"fucomi", "R:st(i)", "O", "DB E8+i", "FPUC1=0 ZF=W PF=W CF=W"},
	{"fucomip", "R:st(i)", "O", "DF E8+i", "FPU_POPC1=0 ZF=W PF=W CF=W"},
	{"fucomp", "", "NONE", "DD E9", "FPU_POPC0=W C1=W C2=W C3=W"},
	{"fucomp", "R:st(i)", "O", "DD E8+i", "FPU_POPC0=W C1=W C2=W C3=W"},
	{"fucompp", "", "NONE", "DA E9", "FPU_POP=2C0=W C1=W C2=W C3=W"},
	{"fwait/wait", "", "NONE", "DB", "FPUC0=U C1=U C2=U C3=U"},
	{"fxam", "", "NONE", "D9 E5", "FPUC0=W C1=W C2=W C3=W"},
	{"fxch", "", "NONE", "D9 C9", "FPUC0=U C1=0 C2=U C3=U"},
	{"fxch", "st(i)", "O", "D9 C8+i", "FPUC0=U C1=0 C2=U C3=U"},
	{"fxtract", "", "NONE", "D9 F4", "FPU_PUSH C0=U C1=W C2=U C3=U"},
	{"fyl2x", "", "NONE", "D9 F1", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"fyl2xp1", "", "NONE", "D9 F9", "FPU_POPC0=U C1=W C2=U C3=U"},
	{"addpd", "X:~xmm, ~xmm/m128", "RM", "66 0F 58 /r", "SSE2"},
	{"addps", "X:~xmm, ~xmm/m128", "RM", "0F 58 /r", "SSE"},
	{"addsd", "x:xmm{7:0}, xmm{7:0}/m64", "RM", "F2 0F 58 /r", "SSE2"},
	{"addss", "x:xmm{3:0}, xmm{3:0}/m32", "RM", "F3 0F 58 /r", "SSE"},
	{"addsubpd", "X:xmm, xmm/m128", "RM", "66 0F D0 /r", "SSE3"},
	{"addsubps", "X:xmm, xmm/m128", "RM", "F2 0F D0 /r", "SSE3"},
	{"andnpd", "X:xmm, xmm/m128", "RM", "66 0F 55 /r", "SSE2"},
	{"andnps", "X:xmm, xmm/m128", "RM", "0F 55 /r", "SSE"},
	{"andpd", "X:~xmm, ~xmm/m128", "RM", "66 0F 54 /r", "SSE2"},
	{"andps", "X:~xmm, ~xmm/m128", "RM", "0F 54 /r", "SSE"},
	{"blendpd", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 0D /r ib", "SSE4_1"},
	{"blendps", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 0C /r ib", "SSE4_1"},
	{"blendvpd", "X:xmm, xmm/m128, <xmm0>", "RM", "66 0F 38 15 /r", "SSE4_1"},
	{"blendvps", "X:xmm, xmm/m128, <xmm0>", "RM", "66 0F 38 14 /r", "SSE4_1"},
	{"cmppd", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F C2 /r ib", "SSE2"},
	{"cmpps", "X:xmm, xmm/m128, ib/ub", "RMI", "0F C2 /r ib", "SSE"},
	{"cmpsd", "x:xmm{7:0}, xmm{7:0}/m64, ib/ub", "RMI", "F2 0F C2 /r ib", "SSE2"},
	{"cmpss", "x:xmm{3:0}, xmm{3:0}/m32, ib/ub", "RMI", "F3 0F C2 /r ib", "SSE"},
	{"comisd", "R:xmm{7:0}, xmm{7:0}/m64", "RM", "66 0F 2F /r", "SSE2 OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"comiss", "R:xmm{3:0}, xmm{3:0}/m32", "RM", "0F 2F /r", "SSEOF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"cvtdq2pd", "W:xmm, xmm{7:0}/m64", "RM", "F3 0F E6 /r", "SSE2"},
	{"cvtdq2ps", "W:xmm, xmm/m128", "RM", "0F 5B /r", "SSE2"},
	{"cvtpd2dq", "W:xmm{7:0}, xmm/m128", "RM", "F2 0F E6 /r", "SSE2"},
	{"cvtpd2pi", "W:mm, xmm/m128", "RM", "66 0F 2D /r", "SSE2"},
	{"cvtpd2ps", "W:xmm{7:0}, xmm/m128", "RM", "66 0F 5A /r", "SSE2"},
	{"cvtpi2pd", "W:xmm, R:mm{7:0}/m64", "RM", "66 0F 2A /r", "SSE2"},
	{"cvtpi2ps", "w:xmm{7:0}, mm/m64", "RM", "0F 2A /r", "SSE"},
	{"cvtps2dq", "W:xmm, xmm/m128", "RM", "66 0F 5B /r", "SSE2"},
	{"cvtps2pd", "W:xmm, xmm{7:0}/m64", "RM", "0F 5A /r", "SSE2"},
	{"cvtps2pi", "W:mm, xmm{7:0}/m64", "RM", "0F 2D /r", "SSE"},
	{"cvtsd2si", "W:r32, xmm{7:0}/m64", "RM", "F2 0F 2D /r", "SSE2"},
	{"cvtsd2si", "W:r64, xmm{7:0}/m64", "RM", "REX.W F2 0F 2D /r", "SSE2 X64"},
	{"cvtsd2ss", "w:xmm{3:0}, xmm{7:0}/m64", "RM", "F2 0F 5A /r", "SSE2"},
	{"cvtsi2sd", "w:xmm{7:0}, r32/m32", "RM", "F2 0F 2A /r", "SSE2"},
	{"cvtsi2sd", "w:xmm{7:0}, r64/m64", "RM", "REX.W F2 0F 2A /r", "SSE2 X64"},
	{"cvtsi2ss", "w:xmm{3:0}, r32/m32", "RM", "F3 0F 2A /r", "SSE"},
	{"cvtsi2ss", "w:xmm{3:0}, r64/m64", "RM", "REX.W F3 0F 2A /r", "SSE X64"},
	{"cvtss2sd", "w:xmm{7:0}, xmm{3:0}/m32", "RM", "F3 0F 5A /r", "SSE2"},
	{"cvtss2si", "W:r32, xmm{3:0}/m32", "RM", "F3 0F 2D /r", "SSE"},
	{"cvtss2si", "W:r64, xmm{3:0}/m32", "RM", "REX.W F3 0F 2D /r", "SSE X64"},
	{"cvttpd2dq", "W:xmm{7:0}, xmm/m128", "RM", "66 0F E6 /r", "SSE2"},
	{"cvttpd2pi", "W:mm, xmm/m128", "RM", "66 0F 2C /r", "SSE2"},
	{"cvttps2dq", "W:xmm, xmm/m128", "RM", "F3 0F 5B /r", "SSE2"},
	{"cvttps2pi", "W:mm, xmm{7:0}/m64", "RM", "0F 2C /r", "SSE"},
	{"cvttsd2si", "W:r32, xmm{7:0}/m64", "RM", "F2 0F 2C /r", "SSE2"},
	{"cvttsd2si", "W:r64, xmm{7:0}/m64", "RM", "REX.W F2 0F 2C /r", "SSE2 X64"},
	{"cvttss2si", "W:r32, xmm{3:0}/m32", "RM", "F3 0F 2C /r", "SSE"},
	{"cvttss2si", "W:r64, xmm{3:0}/m32", "RM", "REX.W F3 0F 2C /r", "SSE X64"},
	{"divpd", "X:xmm, xmm/m128", "RM", "66 0F 5E /r", "SSE2"},
	{"divps", "X:xmm, xmm/m128", "RM", "0F 5E /r", "SSE"},
	{"divsd", "x:xmm{7:0}, xmm{7:0}/m64", "RM", "F2 0F 5E /r", "SSE2"},
	{"divss", "x:xmm{3:0}, xmm{3:0}/m32", "RM", "F3 0F 5E /r", "SSE"},
	{"dppd", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 41 /r ib", "SSE4_1"},
	{"dpps", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 40 /r ib", "SSE4_1"},
	{"extractps", "W:r32/m32, xmm, ib/ub", "MRI", "66 0F 3A 17 /r ib", "SSE4_1"},
	{"extractps", "W:r64, xmm, ib/ub", "MRI", "66 0F 3A 17 /r ib", "SSE4_1 X64"},
	{"extrq", "X:xmm, ib/ub, ib/ub", "RII", "66 0F 78 /0 ib ib", "SSE4A"},
	{"extrq", "X:xmm, xmm", "RM", "66 0F 79 /r", "SSE4A"},
	{"haddpd", "X:~xmm, ~xmm/m128", "RM", "66 0F 7C /r", "SSE3"},
	{"haddps", "X:~xmm, ~xmm/m128", "RM", "F2 0F 7C /r", "SSE3"},
	{"hsubpd", "X:xmm, xmm/m128", "RM", "66 0F 7D /r", "SSE3"},
	{"hsubps", "X:xmm, xmm/m128", "RM", "F2 0F 7D /r", "SSE3"},
	{"insertps", "X:xmm, xmm{3:0}/m32, ib/ub", "RMI", "66 0F 3A 21 /r ib", "SSE4_1"},
	{"insertq", "X:xmm, xmm", "RM", "F2 0F 79 /r", "SSE4A"},
	{"insertq", "X:xmm, xmm, ib/ub, ib/ub", "RMII", "F2 0F 78 /r ib ib", "SSE4A"},
	{"lddqu", "W:xmm, m128", "RM", "F2 0F F0 /r", "SSE3"},
	{"maskmovdqu", "R:xmm, xmm, X:<ds:zdi>", "RM", "66 0F F7 /r", "SSE2"},
	{"maskmovq", "R:mm, mm, X:<ds:zdi>", "RM", "0F F7 /r", "MMX2"},
	{"maxpd", "X:xmm, xmm/m128", "RM", "66 0F 5F /r", "SSE2"},
	{"maxps", "X:xmm, xmm/m128", "RM", "0F 5F /r", "SSE"},
	{"maxsd", "x:xmm{7:0}, xmm{7:0}/m64", "RM", "F2 0F 5F /r", "SSE2"},
	{"maxss", "x:xmm{3:0}, xmm{3:0}/m32", "RM", "F3 0F 5F /r", "SSE"},
	{"minpd", "X:xmm, xmm/m128", "RM", "66 0F 5D /r", "SSE2"},
	{"minps", "X:xmm, xmm/m128", "RM", "0F 5D /r", "SSE"},
	{"minsd", "x:xmm{7:0}, xmm{7:0}/m64", "RM", "F2 0F 5D /r", "SSE2"},
	{"minss", "x:xmm{3:0}, xmm{3:0}/m32", "RM", "F3 0F 5D /r", "SSE"},
	{"movapd", "W:xmm, xmm/m128", "RM", "66 0F 28 /r", "SSE2"},
	{"movapd", "W:xmm/m128, xmm", "MR", "66 0F 29 /r", "SSE2"},
	{"movaps", "W:xmm, xmm/m128", "RM", "0F 28 /r", "SSE"},
	{"movaps", "W:xmm/m128, xmm", "MR", "0F 29 /r", "SSE"},
	{"movd", "W:mm{3:0}, R:r32{3:0}/m32", "RM", "0F 6E /r", "MMX"},
	{"movd", "W:mm{3:0}, R:r64{3:0}", "RM", "0F 6E /r", "MMX X64"},
	{"movd", "W:r32{3:0}/m32, R:mm{3:0}", "MR", "0F 7E /r", "MMX"},
	{"movd", "W:r64{3:0}, R:mm{3:0}", "MR", "0F 7E /r", "MMX X64"},
	{"movd", "W:r32{3:0}/m32, xmm{3:0}", "MR", "66 0F 7E /r", "SSE2"},
	{"movd", "W:r64{3:0}, xmm{3:0}", "MR", "66 0F 7E /r", "SSE2 X64"},
	{"movd", "W:xmm{3:0}, R:r32{3:0}/m32", "RM", "66 0F 6E /r", "SSE2"},
	{"movd", "W:xmm{3:0}, R:r64{3:0}", "RM", "66 0F 6E /r", "SSE2 X64"},
	{"movddup", "W:xmm, xmm{7:0}/m64", "RM", "F2 0F 12 /r", "SSE3"},
	{"movdq2q", "W:mm, xmm{7:0}", "RM", "F2 0F D6 /r", "SSE2"},
	{"movdqa", "W:xmm, xmm/m128", "RM", "66 0F 6F /r", "SSE2"},
	{"movdqa", "W:xmm/m128, xmm", "MR", "66 0F 7F /r", "SSE2"},
	{"movdqu", "W:xmm, xmm/m128", "RM", "F3 0F 6F /r", "SSE2"},
	{"movdqu", "W:xmm/m128, xmm", "MR", "F3 0F 7F /r", "SSE2"},
	{"movhlps", "w:xmm{7:0}, xmm{15:8}", "RM", "0F 12 /r", "SSE"},
	{"movhpd", "W:m64, xmm{15:8}", "MR", "66 0F 17 /r", "SSE2"},
	{"movhpd", "w:xmm{15:8}, m64", "RM", "66 0F 16 /r", "SSE2"},
	{"movhps", "W:m64, xmm{15:8}", "MR", "0F 17 /r", "SSE"},
	{"movhps", "w:xmm{15:8}, m64", "RM", "0F 16 /r", "SSE"},
	{"movlhps", "w:xmm{15:8}, xmm{7:0}", "RM", "0F 16 /r", "SSE"},
	{"movlpd", "W:m64, xmm{7:0}", "MR", "66 0F 13 /r", "SSE2"},
	{"movlpd", "w:xmm{7:0}, m64", "RM", "66 0F 12 /r", "SSE2"},
	{"movlps", "W:m64, xmm{7:0}", "MR", "0F 13 /r", "SSE"},
	{"movlps", "w:xmm{7:0}, m64", "RM", "0F 12 /r", "SSE"},
	{"movmskpd", "W:r32{0}, xmm", "RM", "66 0F 50 /r", "SSE2"},
	{"movmskpd", "W:r64{0}, xmm", "RM", "66 0F 50 /r", "SSE2 X64"},
	{"movmskps", "W:r32{0}, xmm", "RM", "0F 50 /r", "SSE"},
	{"movmskps", "W:r64{0}, xmm", "RM", "0F 50 /r", "SSE X64"},
	{"movntdq", "W:m128, xmm", "MR", "66 0F E7 /r", "SSE2"},
	{"movntdqa", "W:xmm, m128", "RM", "66 0F 38 2A /r", "SSE4_1"},
	{"movnti", "W:m32, r32", "MR", "0F C3 /r", "SSE2"},
	{"movnti", "W:m64, r64", "MR", "REX.W 0F C3 /r", "SSE2 X64"},
	{"movntpd", "W:m128, xmm", "MR", "66 0F 2B /r", "SSE2"},
	{"movntps", "W:m128, xmm", "MR", "0F 2B /r", "SSE"},
	{"movntq", "W:m64, mm", "MR", "0F E7 /r", "MMX2"},
	{"movntsd", "W:m64, xmm{7:0}", "RM", "F2 0F 2B /r", "SSE4A"},
	{"movntss", "W:m32, xmm{3:0}", "RM", "F3 0F 2B /r", "SSE4A"},
	{"movq", "W:mm, mm/m64", "RM", "0F 6F /r", "MMX"},
	{"movq", "W:mm, r64/m64", "RM", "REX.W 0F 6E /r", "MMX X64"},
	{"movq", "W:mm/m64, mm", "MR", "0F 7F /r", "MMX"},
	{"movq", "W:r64/m64, mm", "MR", "REX.W 0F 7E /r", "MMX X64"},
	{"movq", "W:r64/m64, xmm{7:0}", "MR", "REX.W 66 0F 7E /r", "SSE2 X64"},
	{"movq", "W:xmm{7:0}, r64{7:0}/m64", "RM", "REX.W 66 0F 6E /r", "SSE2 X64"},
	{"movq", "W:xmm{7:0}, xmm{7:0}/m64", "RM", "F3 0F 7E /r", "SSE2"},
	{"movq", "W:xmm{7:0}/m64, xmm{7:0}", "MR", "66 0F D6 /r", "SSE2"},
	{"movq2dq", "W:xmm{7:0}, mm", "RM", "F3 0F D6 /r", "SSE2"},
	{"movsd", "w:xmm{7:0}, xmm{7:0}", "RM", "F2 0F 10 /r", "SSE2"},
	{"movsd", "W:xmm{7:0}, m64", "RM", "F2 0F 10 /r", "SSE2"},
	{"movsd", "W:m64, xmm{7:0}", "MR", "F2 0F 11 /r", "SSE2"},
	{"movshdup", "W:xmm, xmm/m128", "RM", "F3 0F 16 /r", "SSE3"},
	{"movsldup", "W:xmm, xmm/m128", "RM", "F3 0F 12 /r", "SSE3"},
	{"movss", "w:xmm{3:0}, xmm{3:0}", "RM", "F3 0F 10 /r", "SSE"},
	{"movss", "W:xmm{3:0}, m32", "RM", "F3 0F 10 /r", "SSE"},
	{"movss", "W:m32, xmm{3:0}", "MR", "F3 0F 11 /r", "SSE"},
	{"movupd", "W:xmm, xmm/m128", "RM", "66 0F 10 /r", "SSE2"},
	{"movupd", "W:xmm/m128, xmm", "MR", "66 0F 11 /r", "SSE2"},
	{"movups", "W:xmm, xmm/m128", "RM", "0F 10 /r", "SSE"},
	{"movups", "W:xmm/m128, xmm", "MR", "0F 11 /r", "SSE"},
	{"mpsadbw", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 42 /r ib", "SSE4_1"},
	{"mulpd", "X:~xmm, ~xmm/m128", "RM", "66 0F 59 /r", "SSE2"},
	{"mulps", "X:~xmm, ~xmm/m128", "RM", "0F 59 /r", "SSE"},
	{"mulsd", "x:xmm{7:0}, xmm{7:0}/m64", "RM", "F2 0F 59 /r", "SSE2"},
	{"mulss", "x:xmm{3:0}, xmm{3:0}/m32", "RM", "F3 0F 59 /r", "SSE"},
	{"orpd", "X:~xmm, ~xmm/m128", "RM", "66 0F 56 /r", "SSE2"},
	{"orps", "X:~xmm, ~xmm/m128", "RM", "0F 56 /r", "SSE"},
	{"pabsb", "W:mm, mm/m64", "RM", "0F 38 1C /r", "SSSE3"},
	{"pabsb", "W:xmm, xmm/m128", "RM", "66 0F 38 1C /r", "SSSE3"},
	{"pabsd", "W:mm, mm/m64", "RM", "0F 38 1E /r", "SSSE3"},
	{"pabsd", "W:xmm, xmm/m128", "RM", "66 0F 38 1E /r", "SSSE3"},
	{"pabsw", "W:mm, mm/m64", "RM", "0F 38 1D /r", "SSSE3"},
	{"pabsw", "W:xmm, xmm/m128", "RM", "66 0F 38 1D /r", "SSSE3"},
	{"packssdw", "X:mm, mm/m64", "RM", "0F 6B /r", "MMX"},
	{"packssdw", "X:xmm, xmm/m128", "RM", "66 0F 6B /r", "SSE2"},
	{"packsswb", "X:mm, mm/m64", "RM", "0F 63 /r", "MMX"},
	{"packsswb", "X:xmm, xmm/m128", "RM", "66 0F 63 /r", "SSE2"},
	{"packusdw", "X:xmm, xmm/m128", "RM", "66 0F 38 2B /r", "SSE4_1"},
	{"packuswb", "X:mm, mm/m64", "RM", "0F 67 /r", "MMX"},
	{"packuswb", "X:xmm, xmm/m128", "RM", "66 0F 67 /r", "SSE2"},
	{"paddb", "X:~mm, ~mm/m64", "RM", "0F FC /r", "MMX"},
	{"paddb", "X:~xmm, ~xmm/m128", "RM", "66 0F FC /r", "SSE2"},
	{"paddd", "X:~mm, ~mm/m64", "RM", "0F FE /r", "MMX"},
	{"paddd", "X:~xmm, ~xmm/m128", "RM", "66 0F FE /r", "SSE2"},
	{"paddq", "X:~mm, ~mm/m64", "RM", "0F D4 /r", "SSE2"},
	{"paddq", "X:~xmm, ~xmm/m128", "RM", "66 0F D4 /r", "SSE2"},
	{"paddsb", "X:~mm, ~mm/m64", "RM", "0F EC /r", "MMX"},
	{"paddsb", "X:~xmm, ~xmm/m128", "RM", "66 0F EC /r", "SSE2"},
	{"paddsw", "X:~mm, ~mm/m64", "RM", "0F ED /r", "MMX"},
	{"paddsw", "X:~xmm, ~xmm/m128", "RM", "66 0F ED /r", "SSE2"},
	{"paddusb", "X:~mm, ~mm/m64", "RM", "0F DC /r", "MMX"},
	{"paddusb", "X:~xmm, ~xmm/m128", "RM", "66 0F DC /r", "SSE2"},
	{"paddusw", "X:~mm, ~mm/m64", "RM", "0F DD /r", "MMX"},
	{"paddusw", "X:~xmm, ~xmm/m128", "RM", "66 0F DD /r", "SSE2"},
	{"paddw", "X:~mm, ~mm/m64", "RM", "0F FD /r", "MMX"},
	{"paddw", "X:~xmm, ~xmm/m128", "RM", "66 0F FD /r", "SSE2"},
	{"palignr", "X:mm, mm/m64, ib/ub", "RMI", "0F 3A 0F /r ib", "SSE3"},
	{"palignr", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 0F /r ib", "SSE3"},
	{"pand", "X:~mm, ~mm/m64", "RM", "0F DB /r", "MMX"},
	{"pand", "X:~xmm, ~xmm/m128", "RM", "66 0F DB /r", "SSE2"},
	{"pandn", "X:mm, mm/m64", "RM", "0F DF /r", "MMX"},
	{"pandn", "X:xmm, xmm/m128", "RM", "66 0F DF /r", "SSE2"},
	{"pavgb", "X:~mm, ~mm/m64", "RM", "0F E0 /r", "MMX2"},
	{"pavgb", "X:~xmm, ~xmm/m128", "RM", "66 0F E0 /r", "SSE2"},
	{"pavgw", "X:~mm, ~mm/m64", "RM", "0F E3 /r", "MMX2"},
	{"pavgw", "X:~xmm, ~xmm/m128", "RM", "66 0F E3 /r", "SSE2"},
	{"pblendvb", "X:xmm, xmm/m128, <xmm0>", "RM", "66 0F E0 /r", "SSE4_1"},
	{"pblendw", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 0E /r ib", "SSE4_1"},
	{"pclmulqdq", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 44 /r ib", "PCLMULQDQ"},
	{"pcmpeqb", "X:~mm, ~mm/m64", "RM", "0F 74 /r", "MMX"},
	{"pcmpeqb", "X:~xmm, ~xmm/m128", "RM", "66 0F 74 /r", "SSE2"},
	{"pcmpeqd", "X:~mm, ~mm/m64", "RM", "0F 76 /r", "MMX"},
	{"pcmpeqd", "X:~xmm, ~xmm/m128", "RM", "66 0F 76 /r", "SSE2"},
	{"pcmpeqq", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 29 /r", "SSE4_1"},
	{"pcmpeqw", "X:~mm, ~mm/m64", "RM", "0F 75 /r", "MMX"},
	{"pcmpeqw", "X:~xmm, ~xmm/m128", "RM", "66 0F 75 /r", "SSE2"},
	{"pcmpestri", "R:xmm, xmm/m128, ib/ub, W:<ecx>,<eax>,<edx>", "RMI", "66 0F 3A 61 /r ib", "SSE4_2 OF=W SF=W ZF=W AF=0 PF=0 CF=W"},
	{"pcmpestrm", "R:xmm, xmm/m128, ib/ub, W:<xmm0>,<eax>,<edx>", "RMI", "66 0F 3A 60 /r ib", "SSE4_2 OF=W SF=W ZF=W AF=0 PF=0 CF=W"},
	{"pcmpgtb", "X:mm, mm/m64", "RM", "0F 64 /r", "MMX"},
	{"pcmpgtb", "X:xmm, xmm/m128", "RM", "66 0F 64 /r", "SSE2"},
	{"pcmpgtd", "X:mm, mm/m64", "RM", "0F 66 /r", "MMX"},
	{"pcmpgtd", "X:xmm, xmm/m128", "RM", "66 0F 66 /r", "SSE2"},
	{"pcmpgtq", "X:xmm, xmm/m128", "RM", "66 0F 38 37 /r", "SSE4_2"},
	{"pcmpgtw", "X:mm, mm/m64", "RM", "0F 65 /r", "MMX"},
	{"pcmpgtw", "X:xmm, xmm/m128", "RM", "66 0F 65 /r", "SSE2"},
	{"pcmpistri", "R:xmm, xmm/m128, ib/ub, W:<ecx>", "RMI", "66 0F 3A 63 /r ib", "SSE4_2 OF=W SF=W ZF=W AF=0 PF=0 CF=W"},
	{"pcmpistrm", "R:xmm, xmm/m128, ib/ub, W:<xmm0>", "RMI", "66 0F 3A 62 /r ib", "SSE4_2 OF=W SF=W ZF=W AF=0 PF=0 CF=W"},
	{"pextrb", "W:r32{0}/m8, xmm, ib/ub", "MRI", "66 0F 3A 14 /r ib", "SSE4_1"},
	{"pextrb", "W:r64{0}, xmm, ib/ub", "MRI", "66 0F 3A 14 /r ib", "SSE4_1 X64"},
	{"pextrd", "W:r32{3:0}/m32, xmm, ib/ub", "MRI", "66 0F 3A 16 /r ib", "SSE4_1"},
	{"pextrd", "W:r64{3:0}, xmm, ib/ub", "MRI", "66 0F 3A 16 /r ib", "SSE4_1 X64"},
	{"pextrq", "W:r64/m64, xmm, ib/ub", "MRI", "REX.W 66 0F 3A 16 /r ib", "SSE4_1 X64"},
	{"pextrw", "W:r32{1:0}, mm, ib/ub", "RMI", "0F C5 /r ib", "MMX2"},
	{"pextrw", "W:r64{1:0}, mm, ib/ub", "RMI", "0F C5 /r ib", "MMX2 X64"},
	{"pextrw", "W:r32{1:0}, xmm, ib/ub", "RMI", "66 0F C5 /r ib", "SSE2"},
	{"pextrw", "W:r64{1:0}, xmm, ib/ub", "RMI", "66 0F C5 /r ib", "SSE2 X64"},
	{"pextrw", "W:r32{1:0}/m16, xmm, ib/ub", "MRI", "66 0F 3A 15 /r ib", "SSE4_1"},
	{"pextrw", "W:r64{1:0}, xmm, ib/ub", "MRI", "66 0F 3A 15 /r ib", "SSE4_1 X64"},
	{"phaddd", "X:~mm, ~mm/m64", "RM", "0F 38 02 /r", "SSSE3"},
	{"phaddd", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 02 /r", "SSSE3"},
	{"phaddsw", "X:~mm, ~mm/m64", "RM", "0F 38 03 /r", "SSSE3"},
	{"phaddsw", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 03 /r", "SSSE3"},
	{"phaddw", "X:~mm, ~mm/m64", "RM", "0F 38 01 /r", "SSSE3"},
	{"phaddw", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 01 /r", "SSSE3"},
	{"phminposuw", "W:xmm{2:0}, xmm/m128", "RM", "66 0F 38 41 /r", "SSE4_1"},
	{"phsubd", "X:mm, mm/m64", "RM", "0F 38 06 /r", "SSSE3"},
	{"phsubd", "X:xmm, xmm/m128", "RM", "66 0F 38 06 /r", "SSSE3"},
	{"phsubsw", "X:mm, mm/m64", "RM", "0F 38 07 /r", "SSSE3"},
	{"phsubsw", "X:xmm, xmm/m128", "RM", "66 0F 38 07 /r", "SSSE3"},
	{"phsubw", "X:mm, mm/m64", "RM", "0F 38 05 /r", "SSSE3"},
	{"phsubw", "X:xmm, xmm/m128", "RM", "66 0F 38 05 /r", "SSSE3"},
	{"pinsrb", "X:xmm, r32{0}/m8, ib/ub", "RMI", "66 0F 3A 20 /r ib", "SSE4_1"},
	{"pinsrb", "X:xmm, r64{0}, ib/ub", "RMI", "66 0F 3A 20 /r ib", "SSE4_1 X64"},
	{"pinsrd", "X:xmm, r32{3:0}/m32, ib/ub", "RMI", "66 0F 3A 22 /r ib", "SSE4_1"},
	{"pinsrd", "X:xmm, r64{3:0}, ib/ub", "RMI", "66 0F 3A 22 /r ib", "SSE4_1 X64"},
	{"pinsrq", "X:xmm, r64/m64, ib/ub", "RMI", "REX.W 66 0F 3A 22 /r ib", "SSE4_1 X64"},
	{"pinsrw", "X:mm, r32{1:0}/m16, ib/ub", "RMI", "0F C4 /r ib", "MMX2"},
	{"pinsrw", "X:mm, r64{1:0}, ib/ub", "RMI", "0F C4 /r ib", "MMX2 X64"},
	{"pinsrw", "X:xmm, r32{1:0}/m16, ib/ub", "RMI", "66 0F C4 /r ib", "SSE2"},
	{"pinsrw", "X:xmm, r64{1:0}, ib/ub", "RMI", "66 0F C4 /r ib", "SSE2 X64"},
	{"pmaddubsw", "X:~mm, ~mm/m64", "RM", "0F 38 04 /r", "SSSE3"},
	{"pmaddubsw", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 04 /r", "SSSE3"},
	{"pmaddwd", "X:~mm, ~mm/m64", "RM", "0F F5 /r", "MMX"},
	{"pmaddwd", "X:~xmm, ~xmm/m128", "RM", "66 0F F5 /r", "SSE2"},
	{"pmaxsb", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 3C /r", "SSE4_1"},
	{"pmaxsd", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 3D /r", "SSE4_1"},
	{"pmaxsw", "X:~mm, ~mm/m64", "RM", "0F EE /r", "MMX2"},
	{"pmaxsw", "X:~xmm, ~xmm/m128", "RM", "66 0F EE /r", "SSE2"},
	{"pmaxub", "X:~mm, ~mm/m64", "RM", "0F DE /r", "MMX2"},
	{"pmaxub", "X:~xmm, ~xmm/m128", "RM", "66 0F DE /r", "SSE2"},
	{"pmaxud", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 3F /r", "SSE4_1"},
	{"pmaxuw", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 3E /r", "SSE4_1"},
	{"pminsb", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 38 /r", "SSE4_1"},
	{"pminsd", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 39 /r", "SSE4_1"},
	{"pminsw", "X:~mm, ~mm/m64", "RM", "0F EA /r", "MMX2"},
	{"pminsw", "X:~xmm, ~xmm/m128", "RM", "66 0F EA /r", "SSE2"},
	{"pminub", "X:~mm, ~mm/m64", "RM", "0F DA /r", "MMX2"},
	{"pminub", "X:~xmm, ~xmm/m128", "RM", "66 0F DA /r", "SSE2"},
	{"pminud", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 3B /r", "SSE4_1"},
	{"pminuw", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 3A /r", "SSE4_1"},
	{"pmovmskb", "W:r32{0}, mm", "RM", "0F D7 /r", "MMX2"},
	{"pmovmskb", "W:r64{0}, mm", "RM", "0F D7 /r", "MMX2 X64"},
	{"pmovmskb", "W:r32{1:0}, xmm", "RM", "66 0F D7 /r", "SSE2"},
	{"pmovmskb", "W:r64{1:0}, xmm", "RM", "66 0F D7 /r", "SSE2 X64"},
	{"pmovsxbd", "W:xmm, xmm{3:0}/m32", "RM", "66 0F 38 21 /r", "SSE4_1"},
	{"pmovsxbq", "W:xmm, xmm{1:0}/m16", "RM", "66 0F 38 22 /r", "SSE4_1"},
	{"pmovsxbw", "W:xmm, xmm{7:0}/m64", "RM", "66 0F 38 20 /r", "SSE4_1"},
	{"pmovsxdq", "W:xmm, xmm{7:0}/m64", "RM", "66 0F 38 25 /r", "SSE4_1"},
	{"pmovsxwd", "W:xmm, xmm{7:0}/m64", "RM", "66 0F 38 23 /r", "SSE4_1"},
	{"pmovsxwq", "W:xmm, xmm{3:0}/m32", "RM", "66 0F 38 24 /r", "SSE4_1"},
	{"pmovzxbd", "W:xmm, xmm{3:0}/m32", "RM", "66 0F 38 31 /r", "SSE4_1"},
	{"pmovzxbq", "W:xmm, xmm{1:0}/m16", "RM", "66 0F 38 32 /r", "SSE4_1"},
	{"pmovzxbw", "W:xmm, xmm{7:0}/m64", "RM", "66 0F 38 30 /r", "SSE4_1"},
	{"pmovzxdq", "W:xmm, xmm{7:0}/m64", "RM", "66 0F 38 35 /r", "SSE4_1"},
	{"pmovzxwd", "W:xmm, xmm{7:0}/m64", "RM", "66 0F 38 33 /r", "SSE4_1"},
	{"pmovzxwq", "W:xmm, xmm{3:0}/m32", "RM", "66 0F 38 34 /r", "SSE4_1"},
	{"pmuldq", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 28 /r", "SSE4_1"},
	{"pmulhrsw", "X:~mm, ~mm/m64", "RM", "0F 38 0B /r", "SSSE3"},
	{"pmulhrsw", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 0B /r", "SSSE3"},
	{"pmulhuw", "X:~mm, ~mm/m64", "RM", "0F E4 /r", "MMX2"},
	{"pmulhuw", "X:~xmm, ~xmm/m128", "RM", "66 0F E4 /r", "SSE2"},
	{"pmulhw", "X:~mm, ~mm/m64", "RM", "0F E5 /r", "MMX"},
	{"pmulhw", "X:~xmm, ~xmm/m128", "RM", "66 0F E5 /r", "SSE2"},
	{"pmulld", "X:~xmm, ~xmm/m128", "RM", "66 0F 38 40 /r", "SSE4_1"},
	{"pmullw", "X:~mm, ~mm/m64", "RM", "0F D5 /r", "MMX"},
	{"pmullw", "X:~xmm, ~xmm/m128", "RM", "66 0F D5 /r", "SSE2"},
	{"pmuludq", "X:~mm, ~mm/m64", "RM", "0F F4 /r", "SSE2"},
	{"pmuludq", "X:~xmm, ~xmm/m128", "RM", "66 0F F4 /r", "SSE2"},
	{"por", "X:~mm, ~mm/m64", "RM", "0F EB /r", "MMX"},
	{"por", "X:~xmm, ~xmm/m128", "RM", "66 0F EB /r", "SSE2"},
	{"prefetchnta", "R:mem", "M", "0F 18 /0", "MMX2"},
	{"prefetcht0", "R:mem", "M", "0F 18 /1", "MMX2"},
	{"prefetcht1", "R:mem", "M", "0F 18 /2", "MMX2"},
	{"prefetcht2", "R:mem", "M", "0F 18 /3", "MMX2"},
	{"psadbw", "X:~mm, ~mm/m64", "RM", "0F F6 /r", "MMX2"},
	{"psadbw", "X:~xmm, ~xmm/m128", "RM", "66 0F F6 /r", "SSE2"},
	{"pshufb", "X:mm, mm/m64", "RM", "0F 38 00 /r", "SSSE3"},
	{"pshufb", "X:xmm, xmm/m128", "RM", "66 0F 38 00 /r", "SSSE3"},
	{"pshufd", "W:xmm, xmm/m128, ib/ub", "RMI", "66 0F 70 /r ib", "SSE2"},
	{"pshufhw", "W:xmm, xmm/m128, ib/ub", "RMI", "F3 0F 70 /r ib", "SSE2"},
	{"pshuflw", "W:xmm, xmm/m128, ib/ub", "RMI", "F2 0F 70 /r ib", "SSE2"},
	{"pshufw", "W:mm, mm/m64, ib/ub", "RMI", "0F 70 /r ib", "MMX2"},
	{"psignb", "X:mm, mm/m64", "RM", "0F 38 08 /r", "SSSE3"},
	{"psignb", "X:xmm, xmm/m128", "RM", "66 0F 38 08 /r", "SSSE3"},
	{"psignd", "X:mm, mm/m64", "RM", "0F 38 0A /r", "SSSE3"},
	{"psignd", "X:xmm, xmm/m128", "RM", "66 0F 38 0A /r", "SSSE3"},
	{"psignw", "X:mm, mm/m64", "RM", "0F 38 09 /r", "SSSE3"},
	{"psignw", "X:xmm, xmm/m128", "RM", "66 0F 38 09 /r", "SSSE3"},
	{"pslld", "X:mm, ib/ub", "MI", "0F 72 /6 ib", "MMX"},
	{"pslld", "X:mm, mm/m64", "RM", "0F F2 /r", "MMX"},
	{"pslld", "X:xmm, ib/ub", "MI", "66 0F 72 /6 ib", "SSE2"},
	{"pslld", "X:xmm, xmm/m128", "RM", "66 0F F2 /r", "SSE2"},
	{"pslldq", "X:xmm, ib/ub", "MI", "66 0F 73 /7 ib", "SSE2"},
	{"psllq", "X:mm, ib/ub", "MI", "0F 73 /6 ib", "MMX"},
	{"psllq", "X:mm, mm/m64", "RM", "0F F3 /r", "MMX"},
	{"psllq", "X:xmm, ib/ub", "MI", "66 0F 73 /6 ib", "SSE2"},
	{"psllq", "X:xmm, xmm/m128", "RM", "66 0F F3 /r", "SSE2"},
	{"psllw", "X:mm, ib/ub", "MI", "0F 71 /6 ib", "MMX"},
	{"psllw", "X:mm, mm/m64", "RM", "0F F1 /r", "MMX"},
	{"psllw", "X:xmm, ib/ub", "MI", "66 0F 71 /6 ib", "SSE2"},
	{"psllw", "X:xmm, xmm/m128", "RM", "66 0F F1 /r", "SSE2"},
	{"psrad", "X:mm, ib/ub", "MI", "0F 72 /4 ib", "MMX"},
	{"psrad", "X:mm, mm/m64", "RM", "0F E2 /r", "MMX"},
	{"psrad", "X:xmm, ib/ub", "MI", "66 0F 72 /4 ib", "SSE2"},
	{"psrad", "X:xmm, xmm/m128", "RM", "66 0F E2 /r", "SSE2"},
	{"psraw", "X:mm, ib/ub", "MI", "0F 71 /4 ib", "MMX"},
	{"psraw", "X:mm, mm/m64", "RM", "0F E1 /r", "MMX"},
	{"psraw", "X:xmm, ib/ub", "MI", "66 0F 71 /4 ib", "SSE2"},
	{"psraw", "X:xmm, xmm/m128", "RM", "66 0F E1 /r", "SSE2"},
	{"psrld", "X:mm, ib/ub", "MI", "0F 72 /2 ib", "MMX"},
	{"psrld", "X:mm, mm/m64", "RM", "0F D2 /r", "MMX"},
	{"psrld", "X:xmm, ib/ub", "MI", "66 0F 72 /2 ib", "SSE2"},
	{"psrld", "X:xmm, xmm/m128", "RM", "66 0F D2 /r", "SSE2"},
	{"psrldq", "X:xmm, ib/ub", "MI", "66 0F 73 /3 ib", "SSE2"},
	{"psrlq", "X:mm, ib/ub", "MI", "0F 73 /2 ib", "MMX"},
	{"psrlq", "X:mm, mm/m64", "RM", "0F D3 /r", "MMX"},
	{"psrlq", "X:xmm, ib/ub", "MI", "66 0F 73 /2 ib", "SSE2"},
	{"psrlq", "X:xmm, xmm/m128", "RM", "66 0F D3 /r", "SSE2"},
	{"psrlw", "X:mm, ib/ub", "MI", "0F 71 /2 ib", "MMX"},
	{"psrlw", "X:mm, mm/m64", "RM", "0F D1 /r", "MMX"},
	{"psrlw", "X:xmm, ib/ub", "MI", "66 0F 71 /2 ib", "SSE2"},
	{"psrlw", "X:xmm, xmm/m128", "RM", "66 0F D1 /r", "SSE2"},
	{"psubb", "X:mm, mm/m64", "RM", "0F F8 /r", "MMX"},
	{"psubb", "X:xmm, xmm/m128", "RM", "66 0F F8 /r", "SSE2"},
	{"psubd", "X:mm, mm/m64", "RM", "0F FA /r", "MMX"},
	{"psubd", "X:xmm, xmm/m128", "RM", "66 0F FA /r", "SSE2"},
	{"psubq", "X:mm, mm/m64", "RM", "0F FB /r", "SSE2"},
	{"psubq", "X:xmm, xmm/m128", "RM", "66 0F FB /r", "SSE2"},
	{"psubsb", "X:mm, mm/m64", "RM", "0F E8 /r", "MMX"},
	{"psubsb", "X:xmm, xmm/m128", "RM", "66 0F E8 /r", "SSE2"},
	{"psubsw", "X:mm, mm/m64", "RM", "0F E9 /r", "MMX"},
	{"psubsw", "X:xmm, xmm/m128", "RM", "66 0F E9 /r", "SSE2"},
	{"psubusb", "X:mm, mm/m64", "RM", "0F D8 /r", "MMX"},
	{"psubusb", "X:xmm, xmm/m128", "RM", "66 0F D8 /r", "SSE2"},
	{"psubusw", "X:mm, mm/m64", "RM", "0F D9 /r", "MMX"},
	{"psubusw", "X:xmm, xmm/m128", "RM", "66 0F D9 /r", "SSE2"},
	{"psubw", "X:mm, mm/m64", "RM", "0F F9 /r", "MMX"},
	{"psubw", "X:xmm, xmm/m128", "RM", "66 0F F9 /r", "SSE2"},
	{"ptest", "R:~xmm, ~xmm/m128", "RM", "66 0F 38 17 /r", "SSE4_1 OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"punpckhbw", "X:mm, mm/m64", "RM", "0F 68 /r", "MMX"},
	{"punpckhbw", "X:xmm, xmm/m128", "RM", "66 0F 68 /r", "SSE2"},
	{"punpckhdq", "X:mm, mm/m64", "RM", "0F 6A /r", "MMX"},
	{"punpckhdq", "X:xmm, xmm/m128", "RM", "66 0F 6A /r", "SSE2"},
	{"punpckhqdq", "X:xmm, xmm/m128", "RM", "66 0F 6D /r", "SSE2"},
	{"punpckhwd", "X:mm, mm/m64", "RM", "0F 69 /r", "MMX"},
	{"punpckhwd", "X:xmm, xmm/m128", "RM", "66 0F 69 /r", "SSE2"},
	{"punpcklbw", "X:mm, mm/m64", "RM", "0F 60 /r", "MMX"},
	{"punpcklbw", "X:xmm, xmm/m128", "RM", "66 0F 60 /r", "SSE2"},
	{"punpckldq", "X:mm, mm/m64", "RM", "0F 62 /r", "MMX"},
	{"punpckldq", "X:xmm, xmm/m128", "RM", "66 0F 62 /r", "SSE2"},
	{"punpcklqdq", "X:xmm, xmm/m128", "RM", "66 0F 6C /r", "SSE2"},
	{"punpcklwd", "X:mm, mm/m64", "RM", "0F 61 /r", "MMX"},
	{"punpcklwd", "X:xmm, xmm/m128", "RM", "66 0F 61 /r", "SSE2"},
	{"pxor", "X:~mm, ~mm/m64", "RM", "0F EF /r", "MMX"},
	{"pxor", "X:~xmm, ~xmm/m128", "RM", "66 0F EF /r", "SSE2"},
	{"rcpps", "W:xmm, xmm/m128", "RM", "0F 53 /r", "SSE"},
	{"rcpss", "w:xmm{3:0}, xmm{3:0}/m32", "RM", "F3 0F 53 /r", "SSE"},
	{"roundpd", "W:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 09 /r ib", "SSE4_1"},
	{"roundps", "W:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A 08 /r ib", "SSE4_1"},
	{"roundsd", "w:xmm{7:0}, xmm{7:0}/m64, ib/ub", "RMI", "66 0F 3A 0B /r ib", "SSE4_1"},
	{"roundss", "w:xmm{3:0}, xmm{3:0}/m32, ib/ub", "RMI", "66 0F 3A 0A /r ib", "SSE4_1"},
	{"rsqrtps", "W:xmm, xmm/m128", "RM", "0F 52 /r", "SSE"},
	{"rsqrtss", "w:xmm{3:0}, xmm{3:0}/m32", "RM", "F3 0F 52 /r", "SSE"},
	{"shufpd", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F C6 /r ib", "SSE2"},
	{"shufps", "X:xmm, xmm/m128, ib/ub", "RMI", "0F C6 /r ib", "SSE"},
	{"sqrtpd", "W:xmm, xmm/m128", "RM", "66 0F 51 /r", "SSE2"},
	{"sqrtps", "W:xmm, xmm/m128", "RM", "0F 51 /r", "SSE"},
	{"sqrtsd", "w:xmm{7:0}, xmm{7:0}/m64", "RM", "F2 0F 51 /r", "SSE2"},
	{"sqrtss", "w:xmm{3:0}, xmm{3:0}/m32", "RM", "F3 0F 51 /r", "SSE"},
	{"subpd", "X:xmm, xmm/m128", "RM", "66 0F 5C /r", "SSE2"},
	{"subps", "X:xmm, xmm/m128", "RM", "0F 5C /r", "SSE"},
	{"subsd", "x:xmm{7:0}, xmm{7:0}/m64", "RM", "F2 0F 5C /r", "SSE2"},
	{"subss", "x:xmm{3:0}, xmm{3:0}/m32", "RM", "F3 0F 5C /r", "SSE"},
	{"ucomisd", "R:xmm{7:0}, xmm{7:0}/m64", "RM", "66 0F 2E /r", "SSE2 OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"ucomiss", "R:xmm{3:0}, xmm{3:0}/m32", "RM", "0F 2E /r", "SSEOF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"unpckhpd", "X:xmm, xmm/m128", "RM", "66 0F 15 /r", "SSE2"},
	{"unpckhps", "X:xmm, xmm/m128", "RM", "0F 15 /r", "SSE"},
	{"unpcklpd", "X:xmm, xmm/m128", "RM", "66 0F 14 /r", "SSE2"},
	{"unpcklps", "X:xmm, xmm/m128", "RM", "0F 14 /r", "SSE"},
	{"xorpd", "X:~xmm, ~xmm/m128", "RM", "66 0F 57 /r", "SSE2"},
	{"xorps", "X:~xmm, ~xmm/m128", "RM", "0F 57 /r", "SSE"},
	{"pavgusb", "X:mm, mm/m64", "RM", "0F 0F /r BF", "3DNOW"},
	{"pf2id", "W:mm, mm/m64", "RM", "0F 0F /r 1D", "3DNOW"},
	{"pf2iw", "W:mm, mm/m64", "RM", "0F 0F /r 1C", "3DNOW2"},
	{"pfacc", "X:mm, mm/m64", "RM", "0F 0F /r AE", "3DNOW"},
	{"pfadd", "X:mm, mm/m64", "RM", "0F 0F /r 9E", "3DNOW"},
	{"pfcmpeq", "X:mm, mm/m64", "RM", "0F 0F /r B0", "3DNOW"},
	{"pfcmpge", "X:mm, mm/m64", "RM", "0F 0F /r 90", "3DNOW"},
	{"pfcmpgt", "X:mm, mm/m64", "RM", "0F 0F /r A0", "3DNOW"},
	{"pfmax", "X:mm, mm/m64", "RM", "0F 0F /r A4", "3DNOW"},
	{"pfmin", "X:mm, mm/m64", "RM", "0F 0F /r 94", "3DNOW"},
	{"pfmul", "X:mm, mm/m64", "RM", "0F 0F /r B4", "3DNOW"},
	{"pfnacc", "X:mm, mm/m64", "RM", "0F 0F /r 8A", "3DNOW2"},
	{"pfpnacc", "X:mm, mm/m64", "RM", "0F 0F /r 8E", "3DNOW2"},
	{"pfrcp", "W:mm, mm/m64", "RM", "0F 0F /r 96", "3DNOW"},
	{"pfrcpit1", "X:mm, mm/m64", "RM", "0F 0F /r A6", "3DNOW"},
	{"pfrcpit2", "X:mm, mm/m64", "RM", "0F 0F /r B6", "3DNOW"},
	{"pfrcpv", "X:mm, mm/m64", "RM", "0F 0F /r 86", "GEODE"},
	{"pfrsqit1", "W:mm, mm/m64", "RM", "0F 0F /r A7", "3DNOW"},
	{"pfrsqrt", "W:mm, mm/m64", "RM", "0F 0F /r 97", "3DNOW"},
	{"pfrsqrtv", "X:mm, mm/m64", "RM", "0F 0F /r 87", "GEODE"},
	{"pfsub", "X:mm, mm/m64", "RM", "0F 0F /r 9A", "3DNOW"},
	{"pfsubr", "X:mm, mm/m64", "RM", "0F 0F /r AA", "3DNOW"},
	{"pi2fd", "W:mm, mm/m64", "RM", "0F 0F /r 0D", "3DNOW"},
	{"pi2fw", "W:mm, mm/m64", "RM", "0F 0F /r 0C", "3DNOW2"},
	{"pmulhrw", "X:mm, mm/m64", "RM", "0F 0F /r B7", "3DNOW"},
	{"prefetch", "R:mem", "M", "0F 0D /0", "3DNOW"},
	{"pswapd", "W:mm, mm/m64", "RM", "0F 0F /r BB", "3DNOW2"},
	{"emms", "", "NONE", "0F 77", "MMX Volatile"},
	{"femms", "", "NONE", "0F 0E", "3DNOW Volatile"},
	{"lfence", "", "NONE", "0F AE /5", "SSE2 Volatile"},
	{"mfence", "", "NONE", "0F AE /6", "SSE2 Volatile"},
	{"sfence", "", "NONE", "0F AE /7", "MMX2 Volatile"},
	{"ldmxcsr", "R:m32", "M", "0F AE /2", "SSE"},
	{"stmxcsr", "W:m32", "M", "0F AE /3", "SSE"},
	{"aesdec", "X:xmm, xmm/m128", "RM", "66 0F 38 DE /r", "AESNI"},
	{"aesdeclast", "X:xmm, xmm/m128", "RM", "66 0F 38 DF /r", "AESNI"},
	{"aesenc", "X:xmm, xmm/m128", "RM", "66 0F 38 DC /r", "AESNI"},
	{"aesenclast", "X:xmm, xmm/m128", "RM", "66 0F 38 DD /r", "AESNI"},
	{"aesimc", "W:xmm, xmm/m128", "RM", "66 0F 38 DB /r", "AESNI"},
	{"aeskeygenassist", "W:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A DF /r ib", "AESNI"},
	{"sha1msg1", "xmm, xmm/m128", "RM", "0F 38 C9 /r", "SHA"},
	{"sha1msg2", "xmm, xmm/m128", "RM", "0F 38 CA /r", "SHA"},
	{"sha1nexte", "xmm, xmm/m128", "RM", "0F 38 C8 /r", "SHA"},
	{"sha1rnds4", "xmm, xmm/m128, ib/ub", "RMI", "0F 3A CC /r ib", "SHA"},
	{"sha256msg1", "xmm, xmm/m128", "RM", "0F 38 CC /r", "SHA"},
	{"sha256msg2", "xmm, xmm/m128", "RM", "0F 38 CD /r", "SHA"},
	{"sha256rnds2", "xmm, xmm/m128, <xmm0>", "RM", "0F 38 CB /r", "SHA"},
	{"gf2p8affineinvqb", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A CF /r ib", "GFNI"},
	{"gf2p8affineqb", "X:xmm, xmm/m128, ib/ub", "RMI", "66 0F 3A CE /r ib", "GFNI"},
	{"gf2p8mulb", "X:xmm, xmm/m128", "RM", "66 0F 38 CF /r", "GFNI"},
	{"vaddpd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 58 /r", "AVX"},
	{"vaddpd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 58 /r", "AVX"},
	{"vaddps", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 58 /r", "AVX"},
	{"vaddps", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 58 /r", "AVX"},
	{"vaddsd", "W:xmm, xmm{15:8}, xmm{7:0}/m64", "RVM", "VEX.NDS.LIG.F2.0F.WIG 58 /r", "AVX"},
	{"vaddss", "W:xmm, xmm{15:4}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 58 /r", "AVX"},
	{"vaddsubpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG D0 /r", "AVX"},
	{"vaddsubpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG D0 /r", "AVX"},
	{"vaddsubps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.F2.0F.WIG D0 /r", "AVX"},
	{"vaddsubps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.F2.0F.WIG D0 /r", "AVX"},
	{"vaesdec", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG DE /r", "AVX AESNI"},
	{"vaesdec", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG DE /r", "VAES"},
	{"vaesdeclast", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG DF /r", "AVX AESNI"},
	{"vaesdeclast", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG DF /r", "VAES"},
	{"vaesenc", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG DC /r", "AVX AESNI"},
	{"vaesenc", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG DC /r", "VAES"},
	{"vaesenclast", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG DD /r", "AVX AESNI"},
	{"vaesenclast", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG DD /r", "VAES"},
	{"vaesimc", "W:xmm, xmm/m128", "RVM", "VEX.128.66.0F38.WIG DB /r", "AVX AESNI"},
	{"vaeskeygenassist", "W:xmm, xmm/m128, ib/ub", "RVMI", "VEX.128.66.0F3A.WIG DF /r ib", "AVX AESNI"},
	{"vandnpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 55 /r", "AVX"},
	{"vandnpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 55 /r", "AVX"},
	{"vandnps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 55 /r", "AVX"},
	{"vandnps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 55 /r", "AVX"},
	{"vandpd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 54 /r", "AVX"},
	{"vandpd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 54 /r", "AVX"},
	{"vandps", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 54 /r", "AVX"},
	{"vandps", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 54 /r", "AVX"},
	{"vblendpd", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.WIG 0D /r ib", "AVX"},
	{"vblendpd", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.WIG 0D /r ib", "AVX"},
	{"vblendps", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.WIG 0C /r ib", "AVX"},
	{"vblendps", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.WIG 0C /r ib", "AVX"},
	{"vblendvpd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 4B /r /is4", "AVX"},
	{"vblendvpd", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 4B /r /is4", "AVX"},
	{"vblendvps", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 4A /r /is4", "AVX"},
	{"vblendvps", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 4A /r /is4", "AVX"},
	{"vbroadcastf128", "W:ymm, m128", "RM", "VEX.256.66.0F38.W0 1A /r", "AVX"},
	{"vbroadcasti128", "W:ymm, m128", "RM", "VEX.256.66.0F38.W0 5A /r", "AVX2"},
	{"vbroadcastsd", "W:ymm, m64", "RM", "VEX.256.66.0F38.W0 19 /r", "AVX"},
	{"vbroadcastsd", "W:ymm, xmm", "RM", "VEX.256.66.0F38.W0 19 /r", "AVX2"},
	{"vbroadcastss", "W:xmm, m32", "RM", "VEX.128.66.0F38.W0 18 /r", "AVX"},
	{"vbroadcastss", "W:xmm, xmm", "RM", "VEX.128.66.0F38.W0 18 /r", "AVX2"},
	{"vbroadcastss", "W:ymm, m32", "RM", "VEX.256.66.0F38.W0 18 /r", "AVX"},
	{"vbroadcastss", "W:ymm, xmm", "RM", "VEX.256.66.0F38.W0 18 /r", "AVX2"},
	{"vcmppd", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F.WIG C2 /r ib", "AVX"},
	{"vcmppd", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F.WIG C2 /r ib", "AVX"},
	{"vcmpps", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.0F.WIG C2 /r ib", "AVX"},
	{"vcmpps", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.0F.WIG C2 /r ib", "AVX"},
	{"vcmpsd", "W:xmm, xmm{15:8}, xmm{7:0}/m64, ib/ub", "RVMI", "VEX.NDS.LIG.F2.0F.WIG C2 /r ib", "AVX"},
	{"vcmpss", "W:xmm, xmm{15:4}, xmm{3:0}/m32, ib/ub", "RVMI", "VEX.NDS.LIG.F3.0F.WIG C2 /r ib", "AVX"},
	{"vcomisd", "R:xmm{7:0}, xmm{7:0}/m64", "RM", "VEX.LIG.66.0F.WIG 2F /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"vcomiss", "R:xmm{3:0}, xmm{3:0}/m32", "RM", "VEX.LIG.0F.WIG 2F /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"vcvtdq2pd", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.F3.0F.WIG E6 /r", "AVX"},
	{"vcvtdq2pd", "W:ymm, xmm/m128", "RM", "VEX.256.F3.0F.WIG E6 /r", "AVX"},
	{"vcvtdq2ps", "W:xmm, xmm/m128", "RM", "VEX.128.0F.WIG 5B /r", "AVX"},
	{"vcvtdq2ps", "W:ymm, ymm/m256", "RM", "VEX.256.0F.WIG 5B /r", "AVX"},
	{"vcvtpd2dq", "W:xmm{7:0}, xmm/m128", "RM", "VEX.128.F2.0F.WIG E6 /r", "AVX"},
	{"vcvtpd2dq", "W:xmm, ymm/m256", "RM", "VEX.256.F2.0F.WIG E6 /r", "AVX"},
	{"vcvtpd2ps", "W:xmm{7:0}, xmm/m128", "RM", "VEX.128.66.0F.WIG 5A /r", "AVX"},
	{"vcvtpd2ps", "W:xmm, ymm/m256", "RM", "VEX.256.66.0F.WIG 5A /r", "AVX"},
	{"vcvtps2dq", "W:xmm, xmm/m128", "RM", "VEX.128.66.0F.WIG 5B /r", "AVX"},
	{"vcvtps2dq", "W:ymm, ymm/m256", "RM", "VEX.256.66.0F.WIG 5B /r", "AVX"},
	{"vcvtps2pd", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.0F.WIG 5A /r", "AVX"},
	{"vcvtps2pd", "W:ymm, xmm/m128", "RM", "VEX.256.0F.WIG 5A /r", "AVX"},
	{"vcvtsd2si", "W:r32, xmm{7:0}/m64", "RM", "VEX.LIG.F2.0F.W0 2D /r", "AVX"},
	{"vcvtsd2si", "W:r64, xmm{7:0}/m64", "RM", "VEX.LIG.F2.0F.W1 2D /r", "AVX X64"},
	{"vcvtsd2ss", "W:xmm, xmm{15:4}, xmm{7:0}/m64", "RVM", "VEX.NDS.LIG.F2.0F.WIG 5A /r", "AVX"},
	{"vcvtsi2sd", "W:xmm, xmm{15:8}, r32/m32", "RVM", "VEX.NDS.LIG.F2.0F.W0 2A /r", "AVX"},
	{"vcvtsi2sd", "W:xmm, xmm{15:8}, r64/m64", "RVM", "VEX.NDS.LIG.F2.0F.W1 2A /r", "AVX X64"},
	{"vcvtsi2ss", "W:xmm, xmm{15:4}, r32/m32", "RVM", "VEX.NDS.LIG.F3.0F.W0 2A /r", "AVX"},
	{"vcvtsi2ss", "W:xmm, xmm{15:4}, r64/m64", "RVM", "VEX.NDS.LIG.F3.0F.W1 2A /r", "AVX X64"},
	{"vcvtss2sd", "W:xmm, xmm{15:8}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 5A /r", "AVX"},
	{"vcvtss2si", "W:r32, xmm{3:0}/m32", "RM", "VEX.LIG.F3.0F.W0 2D /r", "AVX"},
	{"vcvtss2si", "W:r64, xmm{3:0}/m32", "RM", "VEX.LIG.F3.0F.W1 2D /r", "AVX X64"},
	{"vcvttpd2dq", "W:xmm{7:0}, xmm/m128", "RM", "VEX.128.66.0F.WIG E6 /r", "AVX"},
	{"vcvttpd2dq", "W:xmm, ymm/m256", "RM", "VEX.256.66.0F.WIG E6 /r", "AVX"},
	{"vcvttps2dq", "W:xmm, xmm/m128", "RM", "VEX.128.F3.0F.WIG 5B /r", "AVX"},
	{"vcvttps2dq", "W:ymm, ymm/m256", "RM", "VEX.256.F3.0F.WIG 5B /r", "AVX"},
	{"vcvttsd2si", "W:r32, xmm{7:0}/m64", "RM", "VEX.LIG.F2.0F.W0 2C /r", "AVX"},
	{"vcvttsd2si", "W:r64, xmm{7:0}/m64", "RM", "VEX.LIG.F2.0F.W1 2C /r", "AVX X64"},
	{"vcvttss2si", "W:r32, xmm{3:0}/m32", "RM", "VEX.LIG.F3.0F.W0 2C /r", "AVX"},
	{"vcvttss2si", "W:r64, xmm{3:0}/m32", "RM", "VEX.LIG.F3.0F.W1 2C /r", "AVX X64"},
	{"vdivpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 5E /r", "AVX"},
	{"vdivpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 5E /r", "AVX"},
	{"vdivps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 5E /r", "AVX"},
	{"vdivps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 5E /r", "AVX"},
	{"vdivsd", "W:xmm, xmm{15:8}, xmm{7:0}/m64", "RVM", "VEX.NDS.LIG.F2.0F.WIG 5E /r", "AVX"},
	{"vdivss", "W:xmm, xmm{15:4}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 5E /r", "AVX"},
	{"vdppd", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.WIG 41 /r ib", "AVX"},
	{"vdpps", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.WIG 40 /r ib", "AVX"},
	{"vdpps", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.WIG 40 /r ib", "AVX"},
	{"vextractf128", "W:xmm/m128, ymm, ib/ub", "MRI", "VEX.256.66.0F3A.W0 19 /r ib", "AVX"},
	{"vextracti128", "W:xmm/m128, ymm, ib/ub", "MRI", "VEX.256.66.0F3A.W0 39 /r ib", "AVX2"},
	{"vextractps", "W:r32{3:0}/m32, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.WIG 17 /r ib", "AVX"},
	{"vextractps", "W:r64{3:0}, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.WIG 17 /r ib", "AVX X64"},
	{"vgatherdpd", "X:xmm, vm32x, X:xmm", "RMV", "VEX.DDS.128.66.0F38.W1 92 /r", "AVX2"},
	{"vgatherdpd", "X:ymm, vm32x, X:ymm", "RMV", "VEX.DDS.256.66.0F38.W1 92 /r", "AVX2"},
	{"vgatherdps", "X:xmm, vm32x, X:xmm", "RMV", "VEX.DDS.128.66.0F38.W0 92 /r", "AVX2"},
	{"vgatherdps", "X:ymm, vm32y, X:ymm", "RMV", "VEX.DDS.256.66.0F38.W0 92 /r", "AVX2"},
	{"vgatherqpd", "X:xmm, vm64x, X:xmm", "RMV", "VEX.DDS.128.66.0F38.W1 93 /r", "AVX2"},
	{"vgatherqpd", "X:ymm, vm64y, X:ymm", "RMV", "VEX.DDS.256.66.0F38.W1 93 /r", "AVX2"},
	{"vgatherqps", "X:xmm, vm64x, X:xmm", "RMV", "VEX.DDS.128.66.0F38.W0 93 /r", "AVX2"},
	{"vgatherqps", "X:xmm, vm64y, X:xmm", "RMV", "VEX.DDS.256.66.0F38.W0 93 /r", "AVX2"},
	{"vgf2p8affineinvqb", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.W1 CF /r ib", "AVX GFNI"},
	{"vgf2p8affineinvqb", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.W1 CF /r ib", "AVX GFNI"},
	{"vgf2p8affineqb", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.W1 CE /r ib", "AVX GFNI"},
	{"vgf2p8affineqb", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.W1 CE /r ib", "AVX GFNI"},
	{"vgf2p8mulb", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.W0 CF /r", "AVX GFNI"},
	{"vgf2p8mulb", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W0 CF /r", "AVX GFNI"},
	{"vhaddpd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 7C /r", "AVX"},
	{"vhaddpd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 7C /r", "AVX"},
	{"vhaddps", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.F2.0F.WIG 7C /r", "AVX"},
	{"vhaddps", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.F2.0F.WIG 7C /r", "AVX"},
	{"vhsubpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 7D /r", "AVX"},
	{"vhsubpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 7D /r", "AVX"},
	{"vhsubps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.F2.0F.WIG 7D /r", "AVX"},
	{"vhsubps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.F2.0F.WIG 7D /r", "AVX"},
	{"vinsertf128", "W:ymm, ymm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.W0 18 /r ib", "AVX"},
	{"vinserti128", "W:ymm, ymm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.W0 38 /r ib", "AVX2"},
	{"vinsertps", "W:xmm, xmm, xmm{3:0}/m32, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.WIG 21 /r ib", "AVX"},
	{"vlddqu", "W:xmm, m128", "RM", "VEX.128.F2.0F.WIG F0 /r", "AVX"},
	{"vlddqu", "W:ymm, m256", "RM", "VEX.256.F2.0F.WIG F0 /r", "AVX"},
	{"vmaskmovdqu", "R:xmm, xmm, X:<ds:zdi>", "RM", "VEX.128.66.0F.WIG F7 /r", "AVX"},
	{"vmaskmovpd", "X:m128, xmm, xmm", "MVR", "VEX.NDS.128.66.0F38.W0 2F /r", "AVX"},
	{"vmaskmovpd", "X:m256, ymm, ymm", "MVR", "VEX.NDS.256.66.0F38.W0 2F /r", "AVX"},
	{"vmaskmovpd", "W:xmm, xmm, m128", "RVM", "VEX.NDS.128.66.0F38.W0 2D /r", "AVX"},
	{"vmaskmovpd", "W:ymm, ymm, m256", "RVM", "VEX.NDS.256.66.0F38.W0 2D /r", "AVX"},
	{"vmaskmovps", "X:m128, xmm, xmm", "MVR", "VEX.NDS.128.66.0F38.W0 2E /r", "AVX"},
	{"vmaskmovps", "X:m256, ymm, ymm", "MVR", "VEX.NDS.256.66.0F38.W0 2E /r", "AVX"},
	{"vmaskmovps", "W:xmm, xmm, m128", "RVM", "VEX.NDS.128.66.0F38.W0 2C /r", "AVX"},
	{"vmaskmovps", "W:ymm, ymm, m256", "RVM", "VEX.NDS.256.66.0F38.W0 2C /r", "AVX"},
	{"vmaxpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 5F /r", "AVX"},
	{"vmaxpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 5F /r", "AVX"},
	{"vmaxps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 5F /r", "AVX"},
	{"vmaxps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 5F /r", "AVX"},
	{"vmaxsd", "W:xmm, xmm{15:8}, xmm{7:0}/m64", "RVM", "VEX.NDS.LIG.F2.0F.WIG 5F /r", "AVX"},
	{"vmaxss", "W:xmm, xmm{15:4}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 5F /r", "AVX"},
	{"vminpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 5D /r", "AVX"},
	{"vminpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 5D /r", "AVX"},
	{"vminps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 5D /r", "AVX"},
	{"vminps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 5D /r", "AVX"},
	{"vminsd", "W:xmm, xmm{15:8}, xmm{7:0}/m64", "RVM", "VEX.NDS.LIG.F2.0F.WIG 5D /r", "AVX"},
	{"vminss", "W:xmm, xmm{15:4}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 5D /r", "AVX"},
	{"vmovapd", "W:xmm, xmm/m128", "RM", "VEX.128.66.0F.WIG 28 /r", "AVX"},
	{"vmovapd", "W:xmm/m128, xmm", "MR", "VEX.128.66.0F.WIG 29 /r", "AVX"},
	{"vmovapd", "W:ymm, ymm/m256", "RM", "VEX.256.66.0F.WIG 28 /r", "AVX"},
	{"vmovapd", "W:ymm/m256, ymm", "MR", "VEX.256.66.0F.WIG 29 /r", "AVX"},
	{"vmovaps", "W:xmm, xmm/m128", "RM", "VEX.128.0F.WIG 28 /r", "AVX"},
	{"vmovaps", "W:xmm/m128, xmm", "MR", "VEX.128.0F.WIG 29 /r", "AVX"},
	{"vmovaps", "W:ymm, ymm/m256", "RM", "VEX.256.0F.WIG 28 /r", "AVX"},
	{"vmovaps", "W:ymm/m256, ymm", "MR", "VEX.256.0F.WIG 29 /r", "AVX"},
	{"vmovd", "W:r32{3:0}/m32, xmm{3:0}", "MR", "VEX.128.66.0F.W0 7E /r", "AVX"},
	{"vmovd", "W:r64{3:0}, xmm{3:0}", "MR", "VEX.128.66.0F.W0 7E /r", "AVX X64"},
	{"vmovd", "W:xmm{3:0}, r32{3:0}/m32", "RM", "VEX.128.66.0F.W0 6E /r", "AVX"},
	{"vmovd", "W:xmm{3:0}, r64{3:0}", "RM", "VEX.128.66.0F.W0 6E /r", "AVX X64"},
	{"vmovddup", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.F2.0F.WIG 12 /r", "AVX"},
	{"vmovddup", "W:ymm, ymm/m256", "RM", "VEX.256.F2.0F.WIG 12 /r", "AVX"},
	{"vmovdqa", "W:xmm, xmm/m128", "RM", "VEX.128.66.0F.WIG 6F /r", "AVX"},
	{"vmovdqa", "W:xmm/m128, xmm", "MR", "VEX.128.66.0F.WIG 7F /r", "AVX"},
	{"vmovdqa", "W:ymm, ymm/m256", "RM", "VEX.256.66.0F.WIG 6F /r", "AVX"},
	{"vmovdqa", "W:ymm/m256, ymm", "MR", "VEX.256.66.0F.WIG 7F /r", "AVX"},
	{"vmovdqu", "W:xmm, xmm/m128", "RM", "VEX.128.F3.0F.WIG 6F /r", "AVX"},
	{"vmovdqu", "W:xmm/m128, xmm", "MR", "VEX.128.F3.0F.WIG 7F /r", "AVX"},
	{"vmovdqu", "W:ymm, ymm/m256", "RM", "VEX.256.F3.0F.WIG 6F /r", "AVX"},
	{"vmovdqu", "W:ymm/m256, ymm", "MR", "VEX.256.F3.0F.WIG 7F /r", "AVX"},
	{"vmovhlps", "W:xmm, xmm{15:8}, xmm{15:8}", "RVM", "VEX.NDS.128.0F.WIG 12 /r", "AVX"},
	{"vmovhpd", "W:m64, xmm{15:8}", "MR", "VEX.128.66.0F.WIG 17 /r", "AVX"},
	{"vmovhpd", "W:xmm, xmm{7:0}, m64", "RVM", "VEX.NDS.128.66.0F.WIG 16 /r", "AVX"},
	{"vmovhps", "W:m64, xmm{15:8}", "MR", "VEX.128.0F.WIG 17 /r", "AVX"},
	{"vmovhps", "W:xmm, xmm{7:0}, m64", "RVM", "VEX.NDS.128.0F.WIG 16 /r", "AVX"},
	{"vmovlhps", "W:xmm, xmm{7:0}, xmm{7:0}", "RVM", "VEX.NDS.128.0F.WIG 16 /r", "AVX"},
	{"vmovlpd", "W:m64, xmm{7:0}", "MR", "VEX.128.66.0F.WIG 13 /r", "AVX"},
	{"vmovlpd", "W:xmm, xmm{15:8}, m64", "RVM", "VEX.NDS.128.66.0F.WIG 12 /r", "AVX"},
	{"vmovlps", "W:m64, xmm{7:0}", "MR", "VEX.128.0F.WIG 13 /r", "AVX"},
	{"vmovlps", "W:xmm, xmm{15:8}, m64", "RVM", "VEX.NDS.128.0F.WIG 12 /r", "AVX"},
	{"vmovmskpd", "W:r32{0}, xmm", "RM", "VEX.128.66.0F.WIG 50 /r", "AVX"},
	{"vmovmskpd", "W:r64{0}, xmm", "RM", "VEX.128.66.0F.WIG 50 /r", "AVX X64"},
	{"vmovmskpd", "W:r32{0}, ymm", "RM", "VEX.256.66.0F.WIG 50 /r", "AVX"},
	{"vmovmskpd", "W:r64{0}, ymm", "RM", "VEX.256.66.0F.WIG 50 /r", "AVX X64"},
	{"vmovmskps", "W:r32{0}, xmm", "RM", "VEX.128.0F.WIG 50 /r", "AVX"},
	{"vmovmskps", "W:r64{0}, xmm", "RM", "VEX.128.0F.WIG 50 /r", "AVX X64"},
	{"vmovmskps", "W:r32{0}, ymm", "RM", "VEX.256.0F.WIG 50 /r", "AVX"},
	{"vmovmskps", "W:r64{0}, ymm", "RM", "VEX.256.0F.WIG 50 /r", "AVX X64"},
	{"vmovntdq", "W:m128, xmm", "MR", "VEX.128.66.0F.WIG E7 /r", "AVX"},
	{"vmovntdq", "W:m256, ymm", "MR", "VEX.256.66.0F.WIG E7 /r", "AVX"},
	{"vmovntdqa", "W:xmm, m128", "RM", "VEX.128.66.0F38.WIG 2A /r", "AVX"},
	{"vmovntdqa", "W:ymm, m256", "RM", "VEX.256.66.0F38.WIG 2A /r", "AVX2"},
	{"vmovntpd", "W:m128, xmm", "MR", "VEX.128.66.0F.WIG 2B /r", "AVX"},
	{"vmovntpd", "W:m256, ymm", "MR", "VEX.256.66.0F.WIG 2B /r", "AVX"},
	{"vmovntps", "W:m128, xmm", "MR", "VEX.128.0F.WIG 2B /r", "AVX"},
	{"vmovntps", "W:m256, ymm", "MR", "VEX.256.0F.WIG 2B /r", "AVX"},
	{"vmovq", "W:r64/m64, xmm{7:0}", "MR", "VEX.128.66.0F.W1 7E /r", "AVX X64"},
	{"vmovq", "W:xmm{7:0}, xmm{7:0}/m64", "RM", "VEX.128.F3.0F.WIG 7E /r", "AVX"},
	{"vmovq", "W:xmm{7:0}, r64/m64", "RM", "VEX.128.66.0F.W1 6E /r", "AVX X64"},
	{"vmovq", "W:xmm{7:0}/m64, xmm{7:0}", "MR", "VEX.128.66.0F.WIG D6 /r", "AVX"},
	{"vmovsd", "W:m64, xmm{7:0}", "MR", "VEX.LIG.F2.0F.WIG 11 /r", "AVX"},
	{"vmovsd", "W:xmm{7:0}, m64", "RM", "VEX.LIG.F2.0F.WIG 10 /r", "AVX"},
	{"vmovsd", "W:xmm, xmm{15:8}, xmm{7:0}", "MVR", "VEX.NDS.LIG.F2.0F.WIG 11 /r", "AVX"},
	{"vmovsd", "W:xmm, xmm{15:8}, xmm{7:0}", "RVM", "VEX.NDS.LIG.F2.0F.WIG 10 /r", "AVX"},
	{"vmovshdup", "W:xmm, xmm/m128", "RM", "VEX.128.F3.0F.WIG 16 /r", "AVX"},
	{"vmovshdup", "W:ymm, ymm/m256", "RM", "VEX.256.F3.0F.WIG 16 /r", "AVX"},
	{"vmovsldup", "W:xmm, xmm/m128", "RM", "VEX.128.F3.0F.WIG 12 /r", "AVX"},
	{"vmovsldup", "W:ymm, ymm/m256", "RM", "VEX.256.F3.0F.WIG 12 /r", "AVX"},
	{"vmovss", "W:m32, xmm{3:0}", "MR", "VEX.LIG.F3.0F.WIG 11 /r", "AVX"},
	{"vmovss", "W:xmm{3:0}, m32", "RM", "VEX.LIG.F3.0F.WIG 10 /r", "AVX"},
	{"vmovss", "W:xmm, xmm{15:4}, xmm{3:0}", "MVR", "VEX.NDS.LIG.F3.0F.WIG 11 /r", "AVX"},
	{"vmovss", "W:xmm, xmm{15:4}, xmm{3:0}", "RVM", "VEX.NDS.LIG.F3.0F.WIG 10 /r", "AVX"},
	{"vmovupd", "W:xmm, xmm/m128", "RM", "VEX.128.0F.WIG 10 /r", "AVX"},
	{"vmovupd", "W:xmm/m128, xmm", "MR", "VEX.128.0F.WIG 11 /r", "AVX"},
	{"vmovupd", "W:ymm, ymm/m256", "RM", "VEX.256.0F.WIG 10 /r", "AVX"},
	{"vmovupd", "W:ymm/m256, ymm", "MR", "VEX.256.0F.WIG 11 /r", "AVX"},
	{"vmovups", "W:xmm, xmm/m128", "RM", "VEX.128.66.0F.WIG 10 /r", "AVX"},
	{"vmovups", "W:xmm/m128, xmm", "MR", "VEX.128.66.0F.WIG 11 /r", "AVX"},
	{"vmovups", "W:ymm, ymm/m256", "RM", "VEX.256.66.0F.WIG 10 /r", "AVX"},
	{"vmovups", "W:ymm/m256, ymm", "MR", "VEX.256.66.0F.WIG 11 /r", "AVX"},
	{"vmpsadbw", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.WIG 42 /r ib", "AVX"},
	{"vmpsadbw", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.WIG 42 /r ib", "AVX2"},
	{"vmulpd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 59 /r", "AVX"},
	{"vmulpd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 59 /r", "AVX"},
	{"vmulps", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 59 /r", "AVX"},
	{"vmulps", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 59 /r", "AVX"},
	{"vmulsd", "W:xmm, xmm{15:8}, xmm{7:0}/m64", "RVM", "VEX.NDS.LIG.F2.0F.WIG 59 /r", "AVX"},
	{"vmulss", "W:xmm, xmm{15:4}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 59 /r", "AVX"},
	{"vorpd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 56 /r", "AVX"},
	{"vorpd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 56 /r", "AVX"},
	{"vorps", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 56 /r", "AVX"},
	{"vorps", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 56 /r", "AVX"},
	{"vpabsb", "W:xmm, xmm/m128", "RM", "VEX.128.66.0F38.WIG 1C /r", "AVX"},
	{"vpabsb", "W:ymm, ymm/m256", "RM", "VEX.256.66.0F38.WIG 1C /r", "AVX2"},
	{"vpabsd", "W:xmm, xmm/m128", "RM", "VEX.128.66.0F38.WIG 1E /r", "AVX"},
	{"vpabsd", "W:ymm, ymm/m256", "RM", "VEX.256.66.0F38.WIG 1E /r", "AVX2"},
	{"vpabsw", "W:xmm, xmm/m128", "RM", "VEX.128.66.0F38.WIG 1D /r", "AVX"},
	{"vpabsw", "W:ymm, ymm/m256", "RM", "VEX.256.66.0F38.WIG 1D /r", "AVX2"},
	{"vpackssdw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 6B /r", "AVX"},
	{"vpackssdw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 6B /r", "AVX2"},
	{"vpacksswb", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 63 /r", "AVX"},
	{"vpacksswb", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 63 /r", "AVX2"},
	{"vpackusdw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 2B /r", "AVX"},
	{"vpackusdw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 2B /r", "AVX2"},
	{"vpackuswb", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 67 /r", "AVX"},
	{"vpackuswb", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 67 /r", "AVX2"},
	{"vpaddb", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG FC /r", "AVX"},
	{"vpaddb", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG FC /r", "AVX2"},
	{"vpaddd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG FE /r", "AVX"},
	{"vpaddd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG FE /r", "AVX2"},
	{"vpaddq", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG D4 /r", "AVX"},
	{"vpaddq", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG D4 /r", "AVX2"},
	{"vpaddsb", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG EC /r", "AVX"},
	{"vpaddsb", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG EC /r", "AVX2"},
	{"vpaddsw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG ED /r", "AVX"},
	{"vpaddsw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG ED /r", "AVX2"},
	{"vpaddusb", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG DC /r", "AVX"},
	{"vpaddusb", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG DC /r", "AVX2"},
	{"vpaddusw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG DD /r", "AVX"},
	{"vpaddusw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG DD /r", "AVX2"},
	{"vpaddw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG FD /r", "AVX"},
	{"vpaddw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG FD /r", "AVX2"},
	{"vpalignr", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.WIG 0F /r ib", "AVX"},
	{"vpalignr", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.WIG 0F /r ib", "AVX2"},
	{"vpand", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG DB /r", "AVX"},
	{"vpand", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG DB /r", "AVX2"},
	{"vpandn", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG DF /r", "AVX"},
	{"vpandn", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG DF /r", "AVX2"},
	{"vpavgb", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG E0 /r", "AVX"},
	{"vpavgb", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG E0 /r", "AVX2"},
	{"vpavgw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG E3 /r", "AVX"},
	{"vpavgw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG E3 /r", "AVX2"},
	{"vpblendd", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.W0 02 /r ib", "AVX2"},
	{"vpblendd", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.W0 02 /r ib", "AVX2"},
	{"vpblendvb", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 4C /r /is4", "AVX"},
	{"vpblendvb", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 4C /r /is4", "AVX2"},
	{"vpblendw", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.WIG 0E /r ib", "AVX"},
	{"vpblendw", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.WIG 0E /r ib", "AVX2"},
	{"vpbroadcastb", "W:xmm, xmm{0}/m8", "RM", "VEX.128.66.0F38.W0 78 /r", "AVX2"},
	{"vpbroadcastb", "W:ymm, xmm{0}/m8", "RM", "VEX.256.66.0F38.W0 78 /r", "AVX2"},
	{"vpbroadcastd", "W:xmm, xmm{3:0}/m32", "RM", "VEX.128.66.0F38.W0 58 /r", "AVX2"},
	{"vpbroadcastd", "W:ymm, xmm{3:0}/m32", "RM", "VEX.256.66.0F38.W0 58 /r", "AVX2"},
	{"vpbroadcastq", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.66.0F38.W0 59 /r", "AVX2"},
	{"vpbroadcastq", "W:ymm, xmm{7:0}/m64", "RM", "VEX.256.66.0F38.W0 59 /r", "AVX2"},
	{"vpbroadcastw", "W:xmm, xmm{1:0}/m16", "RM", "VEX.128.66.0F38.W0 79 /r", "AVX2"},
	{"vpbroadcastw", "W:ymm, xmm{1:0}/m16", "RM", "VEX.256.66.0F38.W0 79 /r", "AVX2"},
	{"vpclmulqdq", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.WIG 44 /r ib", "AVX PCLMULQDQ"},
	{"vpclmulqdq", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.WIG 44 /r ib", "VPCLMULQDQ"},
	{"vpcmpeqb", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 74 /r", "AVX"},
	{"vpcmpeqb", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 74 /r", "AVX2"},
	{"vpcmpeqd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 76 /r", "AVX"},
	{"vpcmpeqd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 76 /r", "AVX2"},
	{"vpcmpeqq", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 29 /r", "AVX"},
	{"vpcmpeqq", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 29 /r", "AVX2"},
	{"vpcmpeqw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 75 /r", "AVX"},
	{"vpcmpeqw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 75 /r", "AVX2"},
	{"vpcmpestri", "R:xmm, xmm/m128, ib/ub, W:<ecx>,<eax>,<edx>", "RMI", "VEX.128.66.0F3A.WIG 61 /r ib", "AVX OF=W SF=W ZF=W AF=0 PF=0 CF=W"},
	{"vpcmpestrm", "R:xmm, xmm/m128, ib/ub, W:<xmm0>,<eax>,<edx>", "RMI", "VEX.128.66.0F3A.WIG 60 /r ib", "AVX OF=W SF=W ZF=W AF=0 PF=0 CF=W"},
	{"vpcmpgtb", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 64 /r", "AVX"},
	{"vpcmpgtb", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 64 /r", "AVX2"},
	{"vpcmpgtd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 66 /r", "AVX"},
	{"vpcmpgtd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 66 /r", "AVX2"},
	{"vpcmpgtq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 37 /r", "AVX"},
	{"vpcmpgtq", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 37 /r", "AVX2"},
	{"vpcmpgtw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 65 /r", "AVX"},
	{"vpcmpgtw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 65 /r", "AVX2"},
	{"vpcmpistri", "R:xmm, xmm/m128, ib/ub, W:<ecx>", "RMI", "VEX.128.66.0F3A.WIG 63 /r ib", "AVX OF=W SF=W ZF=W AF=0 PF=0 CF=W"},
	{"vpcmpistrm", "R:xmm, xmm/m128, ib/ub, W:<xmm0>", "RMI", "VEX.128.66.0F3A.WIG 62 /r ib", "AVX OF=W SF=W ZF=W AF=0 PF=0 CF=W"},
	{"vperm2f128", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.W0 06 /r ib", "AVX"},
	{"vperm2i128", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F3A.W0 46 /r ib", "AVX2"},
	{"vpermd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W0 36 /r", "AVX2"},
	{"vpermilpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.W0 0D /r", "AVX"},
	{"vpermilpd", "W:xmm, xmm/m128, ib/ub", "RMI", "VEX.128.66.0F3A.W0 05 /r ib", "AVX"},
	{"vpermilpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W0 0D /r", "AVX"},
	{"vpermilpd", "W:ymm, ymm/m256, ib/ub", "RMI", "VEX.256.66.0F3A.W0 05 /r ib", "AVX"},
	{"vpermilps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.W0 0C /r", "AVX"},
	{"vpermilps", "W:xmm, xmm/m128, ib/ub", "RMI", "VEX.128.66.0F3A.W0 04 /r ib", "AVX"},
	{"vpermilps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W0 0C /r", "AVX"},
	{"vpermilps", "W:ymm, ymm/m256, ib/ub", "RMI", "VEX.256.66.0F3A.W0 04 /r ib", "AVX"},
	{"vpermpd", "W:ymm, ymm/m256, ib/ub", "RMI", "VEX.256.66.0F3A.W1 01 /r ib", "AVX2"},
	{"vpermps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W0 16 /r", "AVX2"},
	{"vpermq", "W:ymm, ymm/m256, ib/ub", "RMI", "VEX.256.66.0F3A.W1 00 /r ib", "AVX2"},
	{"vpextrb", "W:r32{0}/m8, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.W0 14 /r ib", "AVX"},
	{"vpextrb", "W:r64{0}, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.W0 14 /r ib", "AVX X64"},
	{"vpextrd", "W:r32{3:0}/m32, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.W0 16 /r ib", "AVX"},
	{"vpextrd", "W:r64{3:0}, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.W0 16 /r ib", "AVX X64"},
	{"vpextrq", "W:r64/m64, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.W1 16 /r ib", "AVX X64"},
	{"vpextrw", "W:r32{1:0}, xmm, ib/ub", "RMI", "VEX.128.66.0F.W0 C5 /r ib", "AVX"},
	{"vpextrw", "W:r64{1:0}, xmm, ib/ub", "RMI", "VEX.128.66.0F.W0 C5 /r ib", "AVX X64"},
	{"vpextrw", "W:r32{1:0}/m16, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.W0 15 /r ib", "AVX"},
	{"vpextrw", "W:r64{1:0}, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.W0 15 /r ib", "AVX X64"},
	{"vpgatherdd", "X:xmm, vm32x, X:xmm", "RMV", "VEX.DDS.128.66.0F38.W0 90 /r", "AVX2"},
	{"vpgatherdd", "X:ymm, vm32y, X:ymm", "RMV", "VEX.DDS.256.66.0F38.W0 90 /r", "AVX2"},
	{"vpgatherdq", "X:xmm, vm32x, X:xmm", "RMV", "VEX.DDS.128.66.0F38.W1 90 /r", "AVX2"},
	{"vpgatherdq", "X:ymm, vm32x, X:ymm", "RMV", "VEX.DDS.256.66.0F38.W1 90 /r", "AVX2"},
	{"vpgatherqd", "X:xmm, vm64x, X:xmm", "RMV", "VEX.DDS.128.66.0F38.W0 91 /r", "AVX2"},
	{"vpgatherqd", "X:xmm, vm64y, X:xmm", "RMV", "VEX.DDS.256.66.0F38.W0 91 /r", "AVX2"},
	{"vpgatherqq", "X:xmm, vm64x, X:xmm", "RMV", "VEX.DDS.128.66.0F38.W1 91 /r", "AVX2"},
	{"vpgatherqq", "X:ymm, vm64y, X:ymm", "RMV", "VEX.DDS.256.66.0F38.W1 91 /r", "AVX2"},
	{"vphaddd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 02 /r", "AVX"},
	{"vphaddd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 02 /r", "AVX2"},
	{"vphaddsw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 03 /r", "AVX"},
	{"vphaddsw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 03 /r", "AVX2"},
	{"vphaddw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 01 /r", "AVX"},
	{"vphaddw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 01 /r", "AVX2"},
	{"vphminposuw", "W:xmm{2:0}, xmm/m128", "RM", "VEX.128.66.0F38.WIG 41 /r", "AVX"},
	{"vphsubd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 06 /r", "AVX"},
	{"vphsubd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 06 /r", "AVX2"},
	{"vphsubsw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 07 /r", "AVX"},
	{"vphsubsw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 07 /r", "AVX2"},
	{"vphsubw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 05 /r", "AVX"},
	{"vphsubw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 05 /r", "AVX2"},
	{"vpinsrb", "W:xmm, xmm, r32{0}/m8, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.W0 20 /r ib", "AVX"},
	{"vpinsrb", "W:xmm, xmm, r64{0}, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.W0 20 /r ib", "AVX X64"},
	{"vpinsrd", "W:xmm, xmm, r32{3:0}/m32, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.W0 22 /r ib", "AVX"},
	{"vpinsrd", "W:xmm, xmm, r64{3:0}, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.W0 22 /r ib", "AVX X64"},
	{"vpinsrq", "W:xmm, xmm, r64/m64, ib/ub", "RVMI", "VEX.NDS.128.66.0F3A.W1 22 /r ib", "AVX X64"},
	{"vpinsrw", "W:xmm, xmm, r32{1:0}/m16, ib/ub", "RVMI", "VEX.NDS.128.66.0F.W0 C4 /r ib", "AVX"},
	{"vpinsrw", "W:xmm, xmm, r64{1:0}, ib/ub", "RVMI", "VEX.NDS.128.66.0F.W0 C4 /r ib", "AVX X64"},
	{"vpmaddubsw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 04 /r", "AVX"},
	{"vpmaddubsw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 04 /r", "AVX2"},
	{"vpmaddwd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG F5 /r", "AVX"},
	{"vpmaddwd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG F5 /r", "AVX2"},
	{"vpmaskmovd", "X:m128, xmm, xmm", "MVR", "VEX.NDS.128.66.0F38.W0 8E /r", "AVX2"},
	{"vpmaskmovd", "X:m256, ymm, ymm", "MVR", "VEX.NDS.256.66.0F38.W0 8E /r", "AVX2"},
	{"vpmaskmovd", "W:xmm, xmm, m128", "RVM", "VEX.NDS.128.66.0F38.W0 8C /r", "AVX2"},
	{"vpmaskmovd", "W:ymm, ymm, m256", "RVM", "VEX.NDS.256.66.0F38.W0 8C /r", "AVX2"},
	{"vpmaskmovq", "X:m128, xmm, xmm", "MVR", "VEX.NDS.128.66.0F38.W1 8E /r", "AVX2"},
	{"vpmaskmovq", "X:m256, ymm, ymm", "MVR", "VEX.NDS.256.66.0F38.W1 8E /r", "AVX2"},
	{"vpmaskmovq", "W:xmm, xmm, m128", "RVM", "VEX.NDS.128.66.0F38.W1 8C /r", "AVX2"},
	{"vpmaskmovq", "W:ymm, ymm, m256", "RVM", "VEX.NDS.256.66.0F38.W1 8C /r", "AVX2"},
	{"vpmaxsb", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 3C /r", "AVX"},
	{"vpmaxsb", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 3C /r", "AVX2"},
	{"vpmaxsd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 3D /r", "AVX"},
	{"vpmaxsd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 3D /r", "AVX2"},
	{"vpmaxsw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG EE /r", "AVX"},
	{"vpmaxsw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG EE /r", "AVX2"},
	{"vpmaxub", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG DE /r", "AVX"},
	{"vpmaxub", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG DE /r", "AVX2"},
	{"vpmaxud", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 3F /r", "AVX"},
	{"vpmaxud", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 3F /r", "AVX2"},
	{"vpmaxuw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 3E /r", "AVX"},
	{"vpmaxuw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 3E /r", "AVX2"},
	{"vpminsb", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 38 /r", "AVX"},
	{"vpminsb", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 38 /r", "AVX2"},
	{"vpminsd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 39 /r", "AVX"},
	{"vpminsd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 39 /r", "AVX2"},
	{"vpminsw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG EA /r", "AVX"},
	{"vpminsw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG EA /r", "AVX2"},
	{"vpminub", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG DA /r", "AVX"},
	{"vpminub", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG DA /r", "AVX2"},
	{"vpminud", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 3B /r", "AVX"},
	{"vpminud", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 3B /r", "AVX2"},
	{"vpminuw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 3A /r", "AVX"},
	{"vpminuw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 3A /r", "AVX2"},
	{"vpmovmskb", "W:r32{1:0}, xmm", "RVM", "VEX.128.66.0F.WIG D7 /r", "AVX"},
	{"vpmovmskb", "W:r64{1:0}, xmm", "RVM", "VEX.128.66.0F.WIG D7 /r", "AVX X64"},
	{"vpmovmskb", "W:r32{3:0}, ymm", "RVM", "VEX.256.66.0F.WIG D7 /r", "AVX2"},
	{"vpmovmskb", "W:r64{3:0}, ymm", "RVM", "VEX.256.66.0F.WIG D7 /r", "AVX2 X64"},
	{"vpmovsxbd", "W:xmm, xmm{3:0}/m32", "RM", "VEX.128.66.0F38.WIG 21 /r", "AVX"},
	{"vpmovsxbd", "W:ymm, xmm{7:0}/m64", "RM", "VEX.256.66.0F38.WIG 21 /r", "AVX2"},
	{"vpmovsxbq", "W:xmm, xmm{1:0}/m16", "RM", "VEX.128.66.0F38.WIG 22 /r", "AVX"},
	{"vpmovsxbq", "W:ymm, xmm{3:0}/m32", "RM", "VEX.256.66.0F38.WIG 22 /r", "AVX2"},
	{"vpmovsxbw", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.66.0F38.WIG 20 /r", "AVX"},
	{"vpmovsxbw", "W:ymm, xmm/m128", "RM", "VEX.256.66.0F38.WIG 20 /r", "AVX2"},
	{"vpmovsxdq", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.66.0F38.WIG 25 /r", "AVX"},
	{"vpmovsxdq", "W:ymm, xmm/m128", "RM", "VEX.256.66.0F38.WIG 25 /r", "AVX2"},
	{"vpmovsxwd", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.66.0F38.WIG 23 /r", "AVX"},
	{"vpmovsxwd", "W:ymm, xmm/m128", "RM", "VEX.256.66.0F38.WIG 23 /r", "AVX2"},
	{"vpmovsxwq", "W:xmm, xmm{3:0}/m32", "RM", "VEX.128.66.0F38.WIG 24 /r", "AVX"},
	{"vpmovsxwq", "W:ymm, xmm{7:0}/m64", "RM", "VEX.256.66.0F38.WIG 24 /r", "AVX2"},
	{"vpmovzxbd", "W:xmm, xmm{3:0}/m32", "RM", "VEX.128.66.0F38.WIG 31 /r", "AVX"},
	{"vpmovzxbd", "W:ymm, xmm{7:0}/m64", "RM", "VEX.256.66.0F38.WIG 31 /r", "AVX2"},
	{"vpmovzxbq", "W:xmm, xmm{1:0}/m16", "RM", "VEX.128.66.0F38.WIG 32 /r", "AVX"},
	{"vpmovzxbq", "W:ymm, xmm{3:0}/m32", "RM", "VEX.256.66.0F38.WIG 32 /r", "AVX2"},
	{"vpmovzxbw", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.66.0F38.WIG 30 /r", "AVX"},
	{"vpmovzxbw", "W:ymm, xmm/m128", "RM", "VEX.256.66.0F38.WIG 30 /r", "AVX2"},
	{"vpmovzxdq", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.66.0F38.WIG 35 /r", "AVX"},
	{"vpmovzxdq", "W:ymm, xmm/m128", "RM", "VEX.256.66.0F38.WIG 35 /r", "AVX2"},
	{"vpmovzxwd", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.66.0F38.WIG 33 /r", "AVX"},
	{"vpmovzxwd", "W:ymm, xmm/m128", "RM", "VEX.256.66.0F38.WIG 33 /r", "AVX2"},
	{"vpmovzxwq", "W:xmm, xmm{3:0}/m32", "RM", "VEX.128.66.0F38.WIG 34 /r", "AVX"},
	{"vpmovzxwq", "W:ymm, xmm{7:0}/m64", "RM", "VEX.256.66.0F38.WIG 34 /r", "AVX2"},
	{"vpmuldq", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 28 /r", "AVX"},
	{"vpmuldq", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 28 /r", "AVX2"},
	{"vpmulhrsw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 0B /r", "AVX"},
	{"vpmulhrsw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 0B /r", "AVX2"},
	{"vpmulhuw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG E4 /r", "AVX"},
	{"vpmulhuw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG E4 /r", "AVX2"},
	{"vpmulhw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG E5 /r", "AVX"},
	{"vpmulhw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG E5 /r", "AVX2"},
	{"vpmulld", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 40 /r", "AVX"},
	{"vpmulld", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 40 /r", "AVX2"},
	{"vpmullw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG D5 /r", "AVX"},
	{"vpmullw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG D5 /r", "AVX2"},
	{"vpmuludq", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG F4 /r", "AVX"},
	{"vpmuludq", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG F4 /r", "AVX2"},
	{"vpor", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG EB /r", "AVX"},
	{"vpor", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG EB /r", "AVX2"},
	{"vpsadbw", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG F6 /r", "AVX"},
	{"vpsadbw", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG F6 /r", "AVX2"},
	{"vpshufb", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 00 /r", "AVX"},
	{"vpshufb", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 00 /r", "AVX2"},
	{"vpshufd", "W:xmm, xmm/m128, ib/ub", "RMI", "VEX.128.66.0F.WIG 70 /r ib", "AVX"},
	{"vpshufd", "W:ymm, ymm/m256, ib/ub", "RMI", "VEX.256.66.0F.WIG 70 /r ib", "AVX2"},
	{"vpshufhw", "W:xmm, xmm/m128, ib/ub", "RMI", "VEX.128.F3.0F.WIG 70 /r ib", "AVX"},
	{"vpshufhw", "W:ymm, ymm/m256, ib/ub", "RMI", "VEX.256.F3.0F.WIG 70 /r ib", "AVX2"},
	{"vpshuflw", "W:xmm, xmm/m128, ib/ub", "RMI", "VEX.128.F2.0F.WIG 70 /r ib", "AVX"},
	{"vpshuflw", "W:ymm, ymm/m256, ib/ub", "RMI", "VEX.256.F2.0F.WIG 70 /r ib", "AVX2"},
	{"vpsignb", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 08 /r", "AVX"},
	{"vpsignb", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 08 /r", "AVX2"},
	{"vpsignd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 0A /r", "AVX"},
	{"vpsignd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 0A /r", "AVX2"},
	{"vpsignw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.WIG 09 /r", "AVX"},
	{"vpsignw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.WIG 09 /r", "AVX2"},
	{"vpslld", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 72 /6 ib", "AVX"},
	{"vpslld", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG F2 /r", "AVX"},
	{"vpslld", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 72 /6 ib", "AVX2"},
	{"vpslld", "W:ymm, ymm, xmm/m128", "RVM", "VEX.NDS.256.66.0F.WIG F2 /r", "AVX2"},
	{"vpslldq", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 73 /7 ib", "AVX"},
	{"vpslldq", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 73 /7 ib", "AVX2"},
	{"vpsllq", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 73 /6 ib", "AVX"},
	{"vpsllq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG F3 /r", "AVX"},
	{"vpsllq", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 73 /6 ib", "AVX2"},
	{"vpsllq", "W:ymm, ymm, xmm/m128", "RVM", "VEX.NDS.256.66.0F.WIG F3 /r", "AVX2"},
	{"vpsllvd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.W0 47 /r", "AVX2"},
	{"vpsllvd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W0 47 /r", "AVX2"},
	{"vpsllvq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.W1 47 /r", "AVX2"},
	{"vpsllvq", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W1 47 /r", "AVX2"},
	{"vpsllw", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 71 /6 ib", "AVX"},
	{"vpsllw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG F1 /r", "AVX"},
	{"vpsllw", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 71 /6 ib", "AVX2"},
	{"vpsllw", "W:ymm, ymm, xmm/m128", "RVM", "VEX.NDS.256.66.0F.WIG F1 /r", "AVX2"},
	{"vpsrad", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 72 /4 ib", "AVX"},
	{"vpsrad", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG E2 /r", "AVX"},
	{"vpsrad", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 72 /4 ib", "AVX2"},
	{"vpsrad", "W:ymm, ymm, xmm/m128", "RVM", "VEX.NDS.256.66.0F.WIG E2 /r", "AVX2"},
	{"vpsravd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.W0 46 /r", "AVX2"},
	{"vpsravd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W0 46 /r", "AVX2"},
	{"vpsraw", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 71 /4 ib", "AVX"},
	{"vpsraw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG E1 /r", "AVX"},
	{"vpsraw", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 71 /4 ib", "AVX2"},
	{"vpsraw", "W:ymm, ymm, xmm/m128", "RVM", "VEX.NDS.256.66.0F.WIG E1 /r", "AVX2"},
	{"vpsrld", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 72 /2 ib", "AVX"},
	{"vpsrld", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG D2 /r", "AVX"},
	{"vpsrld", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 72 /2 ib", "AVX2"},
	{"vpsrld", "W:ymm, ymm, xmm/m128", "RVM", "VEX.NDS.256.66.0F.WIG D2 /r", "AVX2"},
	{"vpsrldq", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 73 /3 ib", "AVX"},
	{"vpsrldq", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 73 /3 ib", "AVX2"},
	{"vpsrlq", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 73 /2 ib", "AVX"},
	{"vpsrlq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG D3 /r", "AVX"},
	{"vpsrlq", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 73 /2 ib", "AVX2"},
	{"vpsrlq", "W:ymm, ymm, xmm/m128", "RVM", "VEX.NDS.256.66.0F.WIG D3 /r", "AVX2"},
	{"vpsrlvd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.W0 45 /r", "AVX2"},
	{"vpsrlvd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W0 45 /r", "AVX2"},
	{"vpsrlvq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F38.W1 45 /r", "AVX2"},
	{"vpsrlvq", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F38.W1 45 /r", "AVX2"},
	{"vpsrlw", "W:xmm, xmm, ib/ub", "VMI", "VEX.NDD.128.66.0F.WIG 71 /2 ib", "AVX"},
	{"vpsrlw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG D1 /r", "AVX"},
	{"vpsrlw", "W:ymm, ymm, ib/ub", "VMI", "VEX.NDD.256.66.0F.WIG 71 /2 ib", "AVX2"},
	{"vpsrlw", "W:ymm, ymm, xmm/m128", "RVM", "VEX.NDS.256.66.0F.WIG D1 /r", "AVX2"},
	{"vpsubb", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG F8 /r", "AVX"},
	{"vpsubb", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG F8 /r", "AVX2"},
	{"vpsubd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG FA /r", "AVX"},
	{"vpsubd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG FA /r", "AVX2"},
	{"vpsubq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG FB /r", "AVX"},
	{"vpsubq", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG FB /r", "AVX2"},
	{"vpsubsb", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG E8 /r", "AVX"},
	{"vpsubsb", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG E8 /r", "AVX2"},
	{"vpsubsw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG E9 /r", "AVX"},
	{"vpsubsw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG E9 /r", "AVX2"},
	{"vpsubusb", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG D8 /r", "AVX"},
	{"vpsubusb", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG D8 /r", "AVX2"},
	{"vpsubusw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG D9 /r", "AVX"},
	{"vpsubusw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG D9 /r", "AVX2"},
	{"vpsubw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG F9 /r", "AVX"},
	{"vpsubw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG F9 /r", "AVX2"},
	{"vptest", "R:~xmm, ~xmm/m128", "RM", "VEX.128.66.0F38.WIG 17 /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"vptest", "R:~ymm, ~ymm/m256", "RM", "VEX.256.66.0F38.WIG 17 /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"vpunpckhbw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 68 /r", "AVX"},
	{"vpunpckhbw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 68 /r", "AVX2"},
	{"vpunpckhdq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 6A /r", "AVX"},
	{"vpunpckhdq", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 6A /r", "AVX2"},
	{"vpunpckhqdq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 6D /r", "AVX"},
	{"vpunpckhqdq", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 6D /r", "AVX2"},
	{"vpunpckhwd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 69 /r", "AVX"},
	{"vpunpckhwd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 69 /r", "AVX2"},
	{"vpunpcklbw", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 60 /r", "AVX"},
	{"vpunpcklbw", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 60 /r", "AVX2"},
	{"vpunpckldq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 62 /r", "AVX"},
	{"vpunpckldq", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 62 /r", "AVX2"},
	{"vpunpcklqdq", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 6C /r", "AVX"},
	{"vpunpcklqdq", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 6C /r", "AVX2"},
	{"vpunpcklwd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 61 /r", "AVX"},
	{"vpunpcklwd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 61 /r", "AVX2"},
	{"vpxor", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG EF /r", "AVX"},
	{"vpxor", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG EF /r", "AVX2"},
	{"vrcpps", "W:xmm, xmm/m128", "RM", "VEX.128.0F.WIG 53 /r", "AVX"},
	{"vrcpps", "W:ymm, ymm/m256", "RM", "VEX.256.0F.WIG 53 /r", "AVX"},
	{"vrcpss", "W:xmm, xmm{15:4}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 53 /r", "AVX"},
	{"vroundpd", "W:xmm, xmm/m128, ib/ub", "RMI", "VEX.128.66.0F3A.WIG 09 /r ib", "AVX"},
	{"vroundpd", "W:ymm, ymm/m256, ib/ub", "RMI", "VEX.256.66.0F3A.WIG 09 /r ib", "AVX"},
	{"vroundps", "W:xmm, xmm/m128, ib/ub", "RMI", "VEX.128.66.0F3A.WIG 08 /r ib", "AVX"},
	{"vroundps", "W:ymm, ymm/m256, ib/ub", "RMI", "VEX.256.66.0F3A.WIG 08 /r ib", "AVX"},
	{"vroundsd", "W:xmm, xmm{15:8}, xmm{7:0}/m64, ib/ub", "RVMI", "VEX.NDS.LIG.66.0F3A.WIG 0B /r ib", "AVX"},
	{"vroundss", "W:xmm, xmm{15:4}, xmm{3:0}/m32, ib/ub", "RVMI", "VEX.NDS.LIG.66.0F3A.WIG 0A /r ib", "AVX"},
	{"vrsqrtps", "W:xmm, xmm/m128", "RM", "VEX.128.0F.WIG 52 /r", "AVX"},
	{"vrsqrtps", "W:ymm, ymm/m256", "RM", "VEX.256.0F.WIG 52 /r", "AVX"},
	{"vrsqrtss", "W:xmm, xmm{15:4}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 52 /r", "AVX"},
	{"vshufpd", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.66.0F.WIG C6 /r ib", "AVX"},
	{"vshufpd", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.66.0F.WIG C6 /r ib", "AVX"},
	{"vshufps", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "VEX.NDS.128.0F.WIG C6 /r ib", "AVX"},
	{"vshufps", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI", "VEX.NDS.256.0F.WIG C6 /r ib", "AVX"},
	{"vsqrtpd", "W:xmm, xmm/m128", "RM", "VEX.128.66.0F.WIG 51 /r", "AVX"},
	{"vsqrtpd", "W:ymm, ymm/m256", "RM", "VEX.256.66.0F.WIG 51 /r", "AVX"},
	{"vsqrtps", "W:xmm, xmm/m128", "RM", "VEX.128.0F.WIG 51 /r", "AVX"},
	{"vsqrtps", "W:ymm, ymm/m256", "RM", "VEX.256.0F.WIG 51 /r", "AVX"},
	{"vsqrtsd", "W:xmm, xmm{15:8}, xmm{7:0}/m64", "RVM", "VEX.NDS.LIG.F2.0F.WIG 51 /r", "AVX"},
	{"vsqrtss", "W:xmm, xmm{15:4}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 51 /r", "AVX"},
	{"vsubpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 5C /r", "AVX"},
	{"vsubpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 5C /r", "AVX"},
	{"vsubps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 5C /r", "AVX"},
	{"vsubps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 5C /r", "AVX"},
	{"vsubsd", "W:xmm, xmm{15:8}, xmm{7:0}/m64", "RVM", "VEX.NDS.LIG.F2.0F.WIG 5C /r", "AVX"},
	{"vsubss", "W:xmm, xmm{15:4}, xmm{3:0}/m32", "RVM", "VEX.NDS.LIG.F3.0F.WIG 5C /r", "AVX"},
	{"vtestpd", "R:~xmm, ~xmm/m128", "RM", "VEX.128.66.0F38.W0 0F /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"vtestpd", "R:~ymm, ~ymm/m256", "RM", "VEX.256.66.0F38.W0 0F /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"vtestps", "R:~xmm, ~xmm/m128", "RM", "VEX.128.66.0F38.W0 0E /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"vtestps", "R:~ymm, ~ymm/m256", "RM", "VEX.256.66.0F38.W0 0E /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"vucomisd", "R:xmm{7:0}, xmm{7:0}/m64", "RM", "VEX.LIG.66.0F.WIG 2E /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"vucomiss", "R:xmm{3:0}, xmm{3:0}/m32", "RM", "VEX.LIG.0F.WIG 2E /r", "AVX OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"vunpckhpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 15 /r", "AVX"},
	{"vunpckhpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 15 /r", "AVX"},
	{"vunpckhps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 15 /r", "AVX"},
	{"vunpckhps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 15 /r", "AVX"},
	{"vunpcklpd", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 14 /r", "AVX"},
	{"vunpcklpd", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 14 /r", "AVX"},
	{"vunpcklps", "W:xmm, xmm, xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 14 /r", "AVX"},
	{"vunpcklps", "W:ymm, ymm, ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 14 /r", "AVX"},
	{"vxorpd", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.66.0F.WIG 57 /r", "AVX"},
	{"vxorpd", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.66.0F.WIG 57 /r", "AVX"},
	{"vxorps", "W:xmm,~xmm,~xmm/m128", "RVM", "VEX.NDS.128.0F.WIG 57 /r", "AVX"},
	{"vxorps", "W:ymm,~ymm,~ymm/m256", "RVM", "VEX.NDS.256.0F.WIG 57 /r", "AVX"},
	{"vldmxcsr", "R:m32", "M", "VEX.LZ.0F.WIG AE /2", "AVX"},
	{"vstmxcsr", "W:m32", "M", "VEX.LZ.0F.WIG AE /3", "AVX"},
	{"vzeroall", "", "NONE", "VEX.256.0F.WIG 77", "AVX Volatile"},
	{"vzeroupper", "", "NONE", "VEX.128.0F.WIG 77", "AVX Volatile"},
	{"vcvtph2ps", "W:xmm, xmm{7:0}/m64", "RM", "VEX.128.66.0F38.W0 13 /r", "F16C"},
	{"vcvtph2ps", "W:ymm, xmm/m128", "RM", "VEX.256.66.0F38.W0 13 /r", "F16C"},
	{"vcvtps2ph", "W:xmm{7:0}/m64, xmm, ib/ub", "MRI", "VEX.128.66.0F3A.W0 1D /r ib", "F16C"},
	{"vcvtps2ph", "W:xmm/m128, ymm, ib/ub", "MRI", "VEX.256.66.0F3A.W0 1D /r ib", "F16C"},
	{"vfmadd132pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 98 /r", "FMA"},
	{"vfmadd132pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 98 /r", "FMA"},
	{"vfmadd132ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 98 /r", "FMA"},
	{"vfmadd132ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 98 /r", "FMA"},
	{"vfmadd132sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 99 /r", "FMA"},
	{"vfmadd132ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 99 /r", "FMA"},
	{"vfmadd213pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 A8 /r", "FMA"},
	{"vfmadd213pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 A8 /r", "FMA"},
	{"vfmadd213ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 A8 /r", "FMA"},
	{"vfmadd213ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 A8 /r", "FMA"},
	{"vfmadd213sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 A9 /r", "FMA"},
	{"vfmadd213ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 A9 /r", "FMA"},
	{"vfmadd231pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 B8 /r", "FMA"},
	{"vfmadd231pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 B8 /r", "FMA"},
	{"vfmadd231ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 B8 /r", "FMA"},
	{"vfmadd231ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 B8 /r", "FMA"},
	{"vfmadd231sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 B9 /r", "FMA"},
	{"vfmadd231ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 B9 /r", "FMA"},
	{"vfmaddsub132pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 96 /r", "FMA"},
	{"vfmaddsub132pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 96 /r", "FMA"},
	{"vfmaddsub132ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 96 /r", "FMA"},
	{"vfmaddsub132ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 96 /r", "FMA"},
	{"vfmaddsub213pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 A6 /r", "FMA"},
	{"vfmaddsub213pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 A6 /r", "FMA"},
	{"vfmaddsub213ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 A6 /r", "FMA"},
	{"vfmaddsub213ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 A6 /r", "FMA"},
	{"vfmaddsub231pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 B6 /r", "FMA"},
	{"vfmaddsub231pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 B6 /r", "FMA"},
	{"vfmaddsub231ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 B6 /r", "FMA"},
	{"vfmaddsub231ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 B6 /r", "FMA"},
	{"vfmsub132pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 9A /r", "FMA"},
	{"vfmsub132pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 9A /r", "FMA"},
	{"vfmsub132ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 9A /r", "FMA"},
	{"vfmsub132ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 9A /r", "FMA"},
	{"vfmsub132sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 9B /r", "FMA"},
	{"vfmsub132ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 9B /r", "FMA"},
	{"vfmsub213pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 AA /r", "FMA"},
	{"vfmsub213pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 AA /r", "FMA"},
	{"vfmsub213ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 AA /r", "FMA"},
	{"vfmsub213ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 AA /r", "FMA"},
	{"vfmsub213sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 AB /r", "FMA"},
	{"vfmsub213ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 AB /r", "FMA"},
	{"vfmsub231pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 BA /r", "FMA"},
	{"vfmsub231pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 BA /r", "FMA"},
	{"vfmsub231ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 BA /r", "FMA"},
	{"vfmsub231ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 BA /r", "FMA"},
	{"vfmsub231sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 BB /r", "FMA"},
	{"vfmsub231ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 BB /r", "FMA"},
	{"vfmsubadd132pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 97 /r", "FMA"},
	{"vfmsubadd132pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 97 /r", "FMA"},
	{"vfmsubadd132ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 97 /r", "FMA"},
	{"vfmsubadd132ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 97 /r", "FMA"},
	{"vfmsubadd213pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 A7 /r", "FMA"},
	{"vfmsubadd213pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 A7 /r", "FMA"},
	{"vfmsubadd213ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 A7 /r", "FMA"},
	{"vfmsubadd213ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 A7 /r", "FMA"},
	{"vfmsubadd231pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 B7 /r", "FMA"},
	{"vfmsubadd231pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 B7 /r", "FMA"},
	{"vfmsubadd231ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 B7 /r", "FMA"},
	{"vfmsubadd231ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 B7 /r", "FMA"},
	{"vfnmadd132pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 9C /r", "FMA"},
	{"vfnmadd132pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 9C /r", "FMA"},
	{"vfnmadd132ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 9C /r", "FMA"},
	{"vfnmadd132ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 9C /r", "FMA"},
	{"vfnmadd132sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 9D /r", "FMA"},
	{"vfnmadd132ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 9D /r", "FMA"},
	{"vfnmadd213pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 AC /r", "FMA"},
	{"vfnmadd213pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 AC /r", "FMA"},
	{"vfnmadd213ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 AC /r", "FMA"},
	{"vfnmadd213ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 AC /r", "FMA"},
	{"vfnmadd213sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 AD /r", "FMA"},
	{"vfnmadd213ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 AD /r", "FMA"},
	{"vfnmadd231pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 BC /r", "FMA"},
	{"vfnmadd231pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 BC /r", "FMA"},
	{"vfnmadd231ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 BC /r", "FMA"},
	{"vfnmadd231ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 BC /r", "FMA"},
	{"vfnmadd231sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 BD /r", "FMA"},
	{"vfnmadd231ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 BD /r", "FMA"},
	{"vfnmsub132pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 9E /r", "FMA"},
	{"vfnmsub132pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 9E /r", "FMA"},
	{"vfnmsub132ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 9E /r", "FMA"},
	{"vfnmsub132ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 9E /r", "FMA"},
	{"vfnmsub132sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 9F /r", "FMA"},
	{"vfnmsub132ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 9F /r", "FMA"},
	{"vfnmsub213pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 AE /r", "FMA"},
	{"vfnmsub213pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 AE /r", "FMA"},
	{"vfnmsub213ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 AE /r", "FMA"},
	{"vfnmsub213ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 AE /r", "FMA"},
	{"vfnmsub213sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 AF /r", "FMA"},
	{"vfnmsub213ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 AF /r", "FMA"},
	{"vfnmsub231pd", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W1 BE /r", "FMA"},
	{"vfnmsub231pd", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W1 BE /r", "FMA"},
	{"vfnmsub231ps", "X:xmm, xmm, xmm/m128", "RVM", "VEX.DDS.128.66.0F38.W0 BE /r", "FMA"},
	{"vfnmsub231ps", "X:ymm, ymm, ymm/m256", "RVM", "VEX.DDS.256.66.0F38.W0 BE /r", "FMA"},
	{"vfnmsub231sd", "x:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVM", "VEX.DDS.LIG.66.0F38.W1 BF /r", "FMA"},
	{"vfnmsub231ss", "x:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVM", "VEX.DDS.LIG.66.0F38.W0 BF /r", "FMA"},
	{"vfmaddpd", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 69 /r /is4", "FMA4"},
	{"vfmaddpd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 69 /r /is4", "FMA4"},
	{"vfmaddpd", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 69 /r /is4", "FMA4"},
	{"vfmaddpd", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 69 /r /is4", "FMA4"},
	{"vfmaddps", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 68 /r /is4", "FMA4"},
	{"vfmaddps", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 68 /r /is4", "FMA4"},
	{"vfmaddps", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 68 /r /is4", "FMA4"},
	{"vfmaddps", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 68 /r /is4", "FMA4"},
	{"vfmaddsd", "W:xmm{7:0}, xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVSM", "VEX.NDS.128.66.0F3A.W1 6b /r /is4", "FMA4"},
	{"vfmaddsd", "W:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64, xmm{7:0}", "RVMS", "VEX.NDS.128.66.0F3A.W0 6b /r /is4", "FMA4"},
	{"vfmaddss", "W:xmm{3:0}, xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVSM", "VEX.NDS.128.66.0F3A.W1 6a /r /is4", "FMA4"},
	{"vfmaddss", "W:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32, xmm{3:0}", "RVMS", "VEX.NDS.128.66.0F3A.W0 6a /r /is4", "FMA4"},
	{"vfmaddsubpd", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 5D /r /is4", "FMA4"},
	{"vfmaddsubpd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 5D /r /is4", "FMA4"},
	{"vfmaddsubpd", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 5D /r /is4", "FMA4"},
	{"vfmaddsubpd", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 5D /r /is4", "FMA4"},
	{"vfmaddsubps", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 5C /r /is4", "FMA4"},
	{"vfmaddsubps", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 5C /r /is4", "FMA4"},
	{"vfmaddsubps", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 5C /r /is4", "FMA4"},
	{"vfmaddsubps", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 5C /r /is4", "FMA4"},
	{"vfmsubaddpd", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 5F /r /is4", "FMA4"},
	{"vfmsubaddpd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 5F /r /is4", "FMA4"},
	{"vfmsubaddpd", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 5F /r /is4", "FMA4"},
	{"vfmsubaddpd", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 5F /r /is4", "FMA4"},
	{"vfmsubaddps", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 5E /r /is4", "FMA4"},
	{"vfmsubaddps", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 5E /r /is4", "FMA4"},
	{"vfmsubaddps", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 5E /r /is4", "FMA4"},
	{"vfmsubaddps", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 5E /r /is4", "FMA4"},
	{"vfmsubpd", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 6D /r /is4", "FMA4"},
	{"vfmsubpd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 6D /r /is4", "FMA4"},
	{"vfmsubpd", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 6D /r /is4", "FMA4"},
	{"vfmsubpd", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 6D /r /is4", "FMA4"},
	{"vfmsubps", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 6C /r /is4", "FMA4"},
	{"vfmsubps", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 6C /r /is4", "FMA4"},
	{"vfmsubps", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 6C /r /is4", "FMA4"},
	{"vfmsubps", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 6C /r /is4", "FMA4"},
	{"vfmsubsd", "W:xmm{7:0}, xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVSM", "VEX.NDS.128.66.0F3A.W1 6F /r /is4", "FMA4"},
	{"vfmsubsd", "W:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64, xmm{7:0}", "RVMS", "VEX.NDS.128.66.0F3A.W0 6F /r /is4", "FMA4"},
	{"vfmsubss", "W:xmm{3:0}, xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVSM", "VEX.NDS.128.66.0F3A.W1 6E /r /is4", "FMA4"},
	{"vfmsubss", "W:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32, xmm{3:0}", "RVMS", "VEX.NDS.128.66.0F3A.W0 6E /r /is4", "FMA4"},
	{"vfnmaddpd", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 79 /r /is4", "FMA4"},
	{"vfnmaddpd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 79 /r /is4", "FMA4"},
	{"vfnmaddpd", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 79 /r /is4", "FMA4"},
	{"vfnmaddpd", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 79 /r /is4", "FMA4"},
	{"vfnmaddps", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 78 /r /is4", "FMA4"},
	{"vfnmaddps", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 78 /r /is4", "FMA4"},
	{"vfnmaddps", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 78 /r /is4", "FMA4"},
	{"vfnmaddps", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 78 /r /is4", "FMA4"},
	{"vfnmaddsd", "W:xmm{7:0}, xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVSM", "VEX.NDS.128.66.0F3A.W1 7B /r /is4", "FMA4"},
	{"vfnmaddsd", "W:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64, xmm{7:0}", "RVMS", "VEX.NDS.128.66.0F3A.W0 7B /r /is4", "FMA4"},
	{"vfnmaddss", "W:xmm{3:0}, xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVSM", "VEX.NDS.128.66.0F3A.W1 7A /r /is4", "FMA4"},
	{"vfnmaddss", "W:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32, xmm{3:0}", "RVMS", "VEX.NDS.128.66.0F3A.W0 7A /r /is4", "FMA4"},
	{"vfnmsubpd", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 7D /r /is4", "FMA4"},
	{"vfnmsubpd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 7D /r /is4", "FMA4"},
	{"vfnmsubpd", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 7D /r /is4", "FMA4"},
	{"vfnmsubpd", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 7D /r /is4", "FMA4"},
	{"vfnmsubps", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "VEX.NDS.128.66.0F3A.W1 7C /r /is4", "FMA4"},
	{"vfnmsubps", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "VEX.NDS.128.66.0F3A.W0 7C /r /is4", "FMA4"},
	{"vfnmsubps", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "VEX.NDS.256.66.0F3A.W1 7C /r /is4", "FMA4"},
	{"vfnmsubps", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "VEX.NDS.256.66.0F3A.W0 7C /r /is4", "FMA4"},
	{"vfnmsubsd", "W:xmm{7:0}, xmm{7:0}, xmm{7:0}, xmm{7:0}/m64", "RVSM", "VEX.NDS.128.66.0F3A.W1 7F /r /is4", "FMA4"},
	{"vfnmsubsd", "W:xmm{7:0}, xmm{7:0}, xmm{7:0}/m64, xmm{7:0}", "RVMS", "VEX.NDS.128.66.0F3A.W0 7F /r /is4", "FMA4"},
	{"vfnmsubss", "W:xmm{3:0}, xmm{3:0}, xmm{3:0}, xmm{3:0}/m32", "RVSM", "VEX.NDS.128.66.0F3A.W1 7E /r /is4", "FMA4"},
	{"vfnmsubss", "W:xmm{3:0}, xmm{3:0}, xmm{3:0}/m32, xmm{3:0}", "RVMS", "VEX.NDS.128.66.0F3A.W0 7E /r /is4", "FMA4"},
	{"vfrczpd", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 81 /r", "XOP"},
	{"vfrczpd", "W:ymm, ymm/m256", "RM", "XOP.L1.P0.M09.W0 81 /r", "XOP"},
	{"vfrczps", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 80 /r", "XOP"},
	{"vfrczps", "W:ymm, ymm/m256", "RM", "XOP.L1.P0.M09.W0 80 /r", "XOP"},
	{"vfrczsd", "W:xmm{7:0}, xmm{7:0}/m64", "RM", "XOP.L0.P0.M09.W0 83 /r", "XOP"},
	{"vfrczss", "W:xmm{3:0}, xmm{3:0}/m32", "RM", "XOP.L0.P0.M09.W0 82 /r", "XOP"},
	{"vpcmov", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "XOP.NDS.L0.P0.M08.W1 A2 /r /is4", "XOP"},
	{"vpcmov", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 A2 /r /is4", "XOP"},
	{"vpcmov", "W:ymm, ymm, ymm, ymm/m256", "RVSM", "XOP.NDS.L1.P0.M08.W1 A2 /r /is4", "XOP"},
	{"vpcmov", "W:ymm, ymm, ymm/m256, ymm", "RVMS", "XOP.NDS.L1.P0.M08.W0 A2 /r /is4", "XOP"},
	{"vpcomb", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "XOP.NDS.L0.P0.M08.W0 CC /r ib", "XOP"},
	{"vpcomd", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "XOP.NDS.L0.P0.M08.W0 CE /r ib", "XOP"},
	{"vpcomq", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "XOP.NDS.L0.P0.M08.W0 CF /r ib", "XOP"},
	{"vpcomub", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "XOP.NDS.L0.P0.M08.W0 EC /r ib", "XOP"},
	{"vpcomud", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "XOP.NDS.L0.P0.M08.W0 EE /r ib", "XOP"},
	{"vpcomuq", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "XOP.NDS.L0.P0.M08.W0 EF /r ib", "XOP"},
	{"vpcomuw", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "XOP.NDS.L0.P0.M08.W0 ED /r ib", "XOP"},
	{"vpcomw", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI", "XOP.NDS.L0.P0.M08.W0 CD /r ib", "XOP"},
	{"vpermil2pd", "W:xmm, xmm, xmm/m128, xmm, i4/u4", "RVMSI", "VEX.L0.66.0F3A.W0 49 /r /is4", "XOP"},
	{"vpermil2pd", "W:xmm, xmm, xmm, xmm/m128, i4/u4", "RVSMI", "VEX.L0.66.0F3A.W1 49 /r /is4", "XOP"},
	{"vpermil2pd", "W:ymm, ymm, ymm/m256, ymm, i4/u4", "RVMSI", "VEX.L1.66.0F3A.W0 49 /r /is4", "XOP"},
	{"vpermil2pd", "W:ymm, ymm, ymm, ymm/m256, i4/u4", "RVSMI", "VEX.L1.66.0F3A.W1 49 /r /is4", "XOP"},
	{"vpermil2ps", "W:xmm, xmm, xmm/m128, xmm, i4/u4", "RVMSI", "VEX.L0.66.0F3A.W0 48 /r /is4", "XOP"},
	{"vpermil2ps", "W:xmm, xmm, xmm, xmm/m128, i4/u4", "RVSMI", "VEX.L0.66.0F3A.W1 48 /r /is4", "XOP"},
	{"vpermil2ps", "W:ymm, ymm, ymm/m256, ymm, i4/u4", "RVMSI", "VEX.L1.66.0F3A.W0 48 /r /is4", "XOP"},
	{"vpermil2ps", "W:ymm, ymm, ymm, ymm/m256, i4/u4", "RVSMI", "VEX.L1.66.0F3A.W1 48 /r /is4", "XOP"},
	{"vphaddbd", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 C2 /r", "XOP"},
	{"vphaddbq", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 C3 /r", "XOP"},
	{"vphaddbw", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 C1 /r", "XOP"},
	{"vphadddq", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 CB /r", "XOP"},
	{"vphaddubd", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 D2 /r", "XOP"},
	{"vphaddubq", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 D3 /r", "XOP"},
	{"vphaddubw", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 D1 /r", "XOP"},
	{"vphaddudq", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 DB /r", "XOP"},
	{"vphadduwd", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 D6 /r", "XOP"},
	{"vphadduwq", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 D7 /r", "XOP"},
	{"vphaddwd", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 C6 /r", "XOP"},
	{"vphaddwq", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 C7 /r", "XOP"},
	{"vphsubbw", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 E1 /r", "XOP"},
	{"vphsubdq", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 E3 /r", "XOP"},
	{"vphsubwd", "W:xmm, xmm/m128", "RM", "XOP.L0.P0.M09.W0 E2 /r", "XOP"},
	{"vpmacsdd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 9E /r /is4", "XOP"},
	{"vpmacsdqh", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 9F /r /is4", "XOP"},
	{"vpmacsdql", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 97 /r /is4", "XOP"},
	{"vpmacssdd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 8E /r /is4", "XOP"},
	{"vpmacssdqh", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 8F /r /is4", "XOP"},
	{"vpmacssdql", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 87 /r /is4", "XOP"},
	{"vpmacsswd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 86 /r /is4", "XOP"},
	{"vpmacssww", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 85 /r /is4", "XOP"},
	{"vpmacswd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 96 /r /is4", "XOP"},
	{"vpmacsww", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 95 /r /is4", "XOP"},
	{"vpmadcsswd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 A6 /r /is4", "XOP"},
	{"vpmadcswd", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 B6 /r /is4", "XOP"},
	{"vpperm", "W:xmm, xmm, xmm, xmm/m128", "RVSM", "XOP.NDS.L0.P0.M08.W1 A3 /r /is4", "XOP"},
	{"vpperm", "W:xmm, xmm, xmm/m128, xmm", "RVMS", "XOP.NDS.L0.P0.M08.W0 A3 /r /is4", "XOP"},
	{"vprotb", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 90 /r", "XOP"},
	{"vprotb", "W:xmm, xmm/m128, ib/ub", "RMI", "XOP.NDS.L0.P0.M08.W0 C0 /r ib", "XOP"},
	{"vprotb", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 90 /r", "XOP"},
	{"vprotd", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 92 /r", "XOP"},
	{"vprotd", "W:xmm, xmm/m128, ib/ub", "RMI", "XOP.NDS.L0.P0.M08.W0 C2 /r ib", "XOP"},
	{"vprotd", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 92 /r", "XOP"},
	{"vprotq", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 93 /r", "XOP"},
	{"vprotq", "W:xmm, xmm/m128, ib/ub", "RMI", "XOP.NDS.L0.P0.M08.W0 C3 /r ib", "XOP"},
	{"vprotq", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 93 /r", "XOP"},
	{"vprotw", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 91 /r", "XOP"},
	{"vprotw", "W:xmm, xmm/m128, ib/ub", "RMI", "XOP.NDS.L0.P0.M08.W0 C1 /r ib", "XOP"},
	{"vprotw", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 91 /r", "XOP"},
	{"vpshab", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 98 /r", "XOP"},
	{"vpshab", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 98 /r", "XOP"},
	{"vpshad", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 9A /r", "XOP"},
	{"vpshad", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 9A /r", "XOP"},
	{"vpshaq", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 9B /r", "XOP"},
	{"vpshaq", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 9B /r", "XOP"},
	{"vpshaw", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 99 /r", "XOP"},
	{"vpshaw", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 99 /r", "XOP"},
	{"vpshlb", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 94 /r", "XOP"},
	{"vpshlb", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 94 /r", "XOP"},
	{"vpshld", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 96 /r", "XOP"},
	{"vpshld", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 96 /r", "XOP"},
	{"vpshlq", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 97 /r", "XOP"},
	{"vpshlq", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 97 /r", "XOP"},
	{"vpshlw", "W:xmm, xmm, xmm/m128", "RVM", "XOP.NDS.L0.P0.M09.W1 95 /r", "XOP"},
	{"vpshlw", "W:xmm, xmm/m128, xmm", "RMV", "XOP.NDS.L0.P0.M09.W0 95 /r", "XOP"},
	{"kaddb", "W:k{0},~k{0},~k{0}", "RVM", "VEX.L1.66.0F.W0 4A /r", "AVX512_DQ"},
	{"kaddd", "W:k{3:0},~k{3:0},~k{3:0}", "RVM", "VEX.L1.66.0F.W1 4A /r", "AVX512_BW"},
	{"kaddq", "W:k{7:0},~k{7:0},~k{7:0}", "RVM", "VEX.L1.0F.W1 4A /r", "AVX512_BW"},
	{"kaddw", "W:k{1:0},~k{1:0},~k{1:0}", "RVM", "VEX.L1.0F.W0 4A /r", "AVX512_DQ"},
	{"kandb", "W:k{0},~k{0},~k{0}", "RVM", "VEX.L1.66.0F.W0 41 /r", "AVX512_DQ"},
	{"kandd", "W:k{3:0},~k{3:0},~k{3:0}", "RVM", "VEX.L1.66.0F.W1 41 /r", "AVX512_BW"},
	{"kandnb", "W:k{0}, k{0}, k{0}", "RVM", "VEX.L1.66.0F.W0 42 /r", "AVX512_DQ"},
	{"kandnd", "W:k{3:0}, k{3:0}, k{3:0}", "RVM", "VEX.L1.66.0F.W1 42 /r", "AVX512_BW"},
	{"kandnq", "W:k{7:0}, k{7:0}, k{7:0}", "RVM", "VEX.L1.0F.W1 42 /r", "AVX512_BW"},
	{"kandnw", "W:k{1:0}, k{1:0}, k{1:0}", "RVM", "VEX.NDS.L1.0F.W0 42 /r", "AVX512_F"},
	{"kandq", "W:k{7:0},~k{7:0},~k{7:0}", "RVM", "VEX.L1.0F.W1 41 /r", "AVX512_BW"},
	{"kandw", "W:k{1:0},~k{1:0},~k{1:0}", "RVM", "VEX.NDS.L1.0F.W0 41 /r", "AVX512_F"},
	{"kmovb", "W:k{0}, k{0}/m8", "RM", "VEX.L0.66.0F.W0 90 /r", "AVX512_DQ"},
	{"kmovb", "W:k{0}, r32{0}", "RM", "VEX.L0.66.0F.W0 92 /r", "AVX512_DQ"},
	{"kmovb", "W:k{0}, r64{0}", "RM", "VEX.L0.66.0F.W0 92 /r", "AVX512_DQ X64"},
	{"kmovb", "W:m8, k{0}", "MR", "VEX.L0.66.0F.W0 91 /r", "AVX512_DQ"},
	{"kmovb", "W:r32{0}, k{0}", "RM", "VEX.L0.66.0F.W0 93 /r", "AVX512_DQ"},
	{"kmovb", "W:r64{0}, k{0}", "RM", "VEX.L0.66.0F.W0 93 /r", "AVX512_DQ X64"},
	{"kmovd", "W:k{3:0}, k{3:0}/m32", "RM", "VEX.L0.66.0F.W1 90 /r", "AVX512_BW"},
	{"kmovd", "W:k{3:0}, r32{3:0}", "RM", "VEX.L0.F2.0F.W0 92 /r", "AVX512_BW"},
	{"kmovd", "W:k{3:0}, r64{3:0}", "RM", "VEX.L0.F2.0F.W0 92 /r", "AVX512_BW X64"},
	{"kmovd", "W:m32, k{3:0}", "MR", "VEX.L0.66.0F.W1 91 /r", "AVX512_BW"},
	{"kmovd", "W:r32{3:0}, k{3:0}", "RM", "VEX.L0.F2.0F.W0 93 /r", "AVX512_BW"},
	{"kmovd", "W:r64{3:0}, k{3:0}", "RM", "VEX.L0.F2.0F.W0 93 /r", "AVX512_BW X64"},
	{"kmovq", "W:k{7:0}, k{7:0}/m64", "RM", "VEX.L0.0F.W1 90 /r", "AVX512_BW"},
	{"kmovq", "W:k{7:0}, r64", "RM", "VEX.L0.F2.0F.W1 92 /r", "AVX512_BW X64"},
	{"kmovq", "W:m64, k{7:0}", "MR", "VEX.L0.0F.W1 91 /r", "AVX512_BW"},
	{"kmovq", "W:r64, k{7:0}", "RM", "VEX.L0.F2.0F.W1 93 /r", "AVX512_BW X64"},
	{"kmovw", "W:k{1:0}, k{1:0}/m16", "RM", "VEX.L0.0F.W0 90 /r", "AVX512_F"},
	{"kmovw", "W:k{1:0}, r32{1:0}", "RM", "VEX.L0.0F.W0 92 /r", "AVX512_F"},
	{"kmovw", "W:k{1:0}, r64{1:0}", "RM", "VEX.L0.0F.W0 92 /r", "AVX512_FX64"},
	{"kmovw", "W:m16, k{1:0}", "MR", "VEX.L0.0F.W0 91 /r", "AVX512_F"},
	{"kmovw", "W:r32{1:0}, k{1:0}", "RM", "VEX.L0.0F.W0 93 /r", "AVX512_F"},
	{"kmovw", "W:r64{1:0}, k{1:0}", "RM", "VEX.L0.0F.W0 93 /r", "AVX512_FX64"},
	{"knotb", "W:k{0}, k{0}", "RM", "VEX.L0.66.0F.W0 44 /r", "AVX512_DQ"},
	{"knotd", "W:k{3:0}, k{3:0}", "RM", "VEX.L0.66.0F.W1 44 /r", "AVX512_BW"},
	{"knotq", "W:k{7:0}, k{7:0}", "RM", "VEX.L0.0F.W1 44 /r", "AVX512_BW"},
	{"knotw", "W:k{1:0}, k{1:0}", "RM", "VEX.L0.0F.W0 44 /r", "AVX512_F"},
	{"korb", "W:k{0}, ~k{0}, ~k{0}", "RVM", "VEX.L1.66.0F.W0 45 /r", "AVX512_DQ"},
	{"kord", "W:k{3:0}, ~k{3:0}, ~k{3:0}", "RVM", "VEX.L1.66.0F.W1 45 /r", "AVX512_BW"},
	{"korq", "W:k{7:0}, ~k{7:0}, ~k{7:0}", "RVM", "VEX.L1.0F.W1 45 /r", "AVX512_BW"},
	{"kortestb", "R:~k{0}, ~k{0}", "RM", "VEX.L0.66.0F.W0 98 /r", "AVX512_DQ OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"kortestd", "R:~k{3:0}, ~k{3:0}", "RM", "VEX.L0.66.0F.W1 98 /r", "AVX512_BW OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"kortestq", "R:~k{7:0}, ~k{7:0}", "RM", "VEX.L0.0F.W1 98 /r", "AVX512_BW OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"kortestw", "R:~k{1:0}, ~k{1:0}", "RM", "VEX.L0.0F.W0 98 /r", "AVX512_FOF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"korw", "W:k{1:0}, ~k{1:0}, ~k{1:0}", "RVM", "VEX.NDS.L1.0F.W0 45 /r", "AVX512_F"},
	{"kshiftlb", "W:k{0}, k{0}, ib/ub", "RMI", "VEX.L0.66.0F3A.W0 32 /r ib", "AVX512_DQ"},
	{"kshiftld", "W:k{3:0}, k{3:0}, ib/ub", "RMI", "VEX.L0.66.0F3A.W0 33 /r ib", "AVX512_BW"},
	{"kshiftlq", "W:k{7:0}, k{7:0}, ib/ub", "RMI", "VEX.L0.66.0F3A.W1 33 /r ib", "AVX512_BW"},
	{"kshiftlw", "W:k{1:0}, k{1:0}, ib/ub", "RMI", "VEX.L0.66.0F3A.W1 32 /r ib", "AVX512_F"},
	{"kshiftrb", "W:k{0}, k{0}, ib/ub", "RMI", "VEX.L0.66.0F3A.W0 30 /r ib", "AVX512_DQ"},
	{"kshiftrd", "W:k{3:0}, k{3:0}, ib/ub", "RMI", "VEX.L0.66.0F3A.W0 31 /r ib", "AVX512_BW"},
	{"kshiftrq", "W:k{7:0}, k{7:0}, ib/ub", "RMI", "VEX.L0.66.0F3A.W1 31 /r ib", "AVX512_BW"},
	{"kshiftrw", "W:k{1:0}, k{1:0}, ib/ub", "RMI", "VEX.L0.66.0F3A.W1 30 /r ib", "AVX512_F"},
	{"ktestb", "R:~k{0}, ~k{0}", "RM", "VEX.L0.66.0F.W0 99 /r", "AVX512_DQ OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"ktestd", "R:~k{3:0}, ~k{3:0}", "RM", "VEX.L0.66.0F.W1 99 /r", "AVX512_BW OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"ktestq", "R:~k{7:0}, ~k{7:0}", "RM", "VEX.L0.0F.W1 99 /r", "AVX512_BW OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"ktestw", "R:~k{1:0}, ~k{1:0}", "RM", "VEX.L0.0F.W0 99 /r", "AVX512_DQ OF=0 SF=0 ZF=W AF=0 PF=0 CF=W"},
	{"kunpckbw", "W:k{1:0}, k{0}, k{0}", "RVM", "VEX.NDS.L1.66.0F.W0 4B /r", "AVX512_F"},
	{"kunpckdq", "W:k{7:0}, k{3:0}, k{3:0}", "RVM", "VEX.NDS.L1.0F.W1 4B /r", "AVX512_BW"},
	{"kunpckwd", "W:k{3:0}, k{1:0}, k{1:0}", "RVM", "VEX.NDS.L1.0F.W0 4B /r", "AVX512_BW"},
	{"kxnorb", "W:k{0}, k{0}, k{0}", "RVM", "VEX.L1.66.0F.W0 46 /r", "AVX512_DQ"},
	{"kxnord", "W:k{3:0}, k{3:0}, k{3:0}", "RVM", "VEX.L1.66.0F.W1 46 /r", "AVX512_BW"},
	{"kxnorq", "W:k{7:0}, k{7:0}, k{7:0}", "RVM", "VEX.L1.0F.W1 46 /r", "AVX512_BW"},
	{"kxnorw", "W:k{1:0}, k{1:0}, k{1:0}", "RVM", "VEX.NDS.L1.0F.W0 46 /r", "AVX512_F"},
	{"kxorb", "W:k{0},~k{0},~k{0}", "RVM", "VEX.L1.66.0F.W0 47 /r", "AVX512_DQ"},
	{"kxord", "W:k{3:0},~k{3:0},~k{3:0}", "RVM", "VEX.L1.66.0F.W1 47 /r", "AVX512_BW"},
	{"kxorq", "W:k{7:0},~k{7:0},~k{7:0}", "RVM", "VEX.L1.0F.W1 47 /r", "AVX512_BW"},
	{"kxorw", "W:k{1:0},~k{1:0},~k{1:0}", "RVM", "VEX.NDS.L1.0F.W0 47 /r", "AVX512_F"},
	{"v4fmaddps", "X:zmm {kz}, zmm, zmm, zmm, zmm, m128", "RM-T1_4X", "EVEX.DDS.512.F2.0F38.W0 9A /r", "AVX512_4FMAPS"},
	{"v4fmaddss", "X:xmm {kz}, xmm, xmm, xmm, xmm, m128", "RM-T1_4X", "EVEX.DDS.LIG.F2.0F38.W0 9B /r", "AVX512_4FMAPS"},
	{"v4fnmaddps", "X:zmm {kz}, zmm, zmm, zmm, zmm, m128", "RM-T1_4X", "EVEX.DDS.512.F2.0F38.W0 AA /r", "AVX512_4FMAPS"},
	{"v4fnmaddss", "X:xmm {kz}, xmm, xmm, xmm, xmm, m128", "RM-T1_4X", "EVEX.DDS.LIG.F2.0F38.W0 AB /r", "AVX512_4FMAPS"},
	{"vaddpd", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 58 /r", "AVX512_F-VL"},
	{"vaddpd", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 58 /r", "AVX512_F-VL"},
	{"vaddpd", "W:zmm {kz},~zmm,~zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F.W1 58 /r", "AVX512_F"},
	{"vaddps", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 58 /r", "AVX512_F-VL"},
	{"vaddps", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 58 /r", "AVX512_F-VL"},
	{"vaddps", "W:zmm {kz},~zmm,~zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.0F.W0 58 /r", "AVX512_F"},
	{"vaddsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 58 /r", "AVX512_F"},
	{"vaddss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 58 /r", "AVX512_F"},
	{"vaesdec", "W:xmm, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG DE /r", "AVX512_F-VL VAES"},
	{"vaesdec", "W:ymm, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG DE /r", "AVX512_F-VL VAES"},
	{"vaesdec", "W:zmm, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG DE /r", "AVX512_FVAES"},
	{"vaesdeclast", "W:xmm, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG DF /r", "AVX512_F-VL VAES"},
	{"vaesdeclast", "W:ymm, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG DF /r", "AVX512_F-VL VAES"},
	{"vaesdeclast", "W:zmm, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG DF /r", "AVX512_FVAES"},
	{"vaesenc", "W:xmm, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG DC /r", "AVX512_F-VL VAES"},
	{"vaesenc", "W:ymm, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG DC /r", "AVX512_F-VL VAES"},
	{"vaesenc", "W:zmm, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG DC /r", "AVX512_FVAES"},
	{"vaesenclast", "W:xmm, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG DD /r", "AVX512_F-VL VAES"},
	{"vaesenclast", "W:ymm, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG DD /r", "AVX512_F-VL VAES"},
	{"vaesenclast", "W:zmm, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG DD /r", "AVX512_FVAES"},
	{"valignd", "W:xmm {kz}, xmm, xmm/m128/b32, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W0 03 /r ib", "AVX512_F-VL"},
	{"valignd", "W:ymm {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W0 03 /r ib", "AVX512_F-VL"},
	{"valignd", "W:zmm {kz}, zmm, zmm/m512/b32, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W0 03 /r ib", "AVX512_F"},
	{"valignq", "W:xmm {kz}, xmm, xmm/m128/b64, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W1 03 /r ib", "AVX512_F-VL"},
	{"valignq", "W:ymm {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W1 03 /r ib", "AVX512_F-VL"},
	{"valignq", "W:zmm {kz}, zmm, zmm/m512/b64, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W1 03 /r ib", "AVX512_F"},
	{"vandnpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 55 /r", "AVX512_DQ-VL"},
	{"vandnpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 55 /r", "AVX512_DQ-VL"},
	{"vandnpd", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 55 /r", "AVX512_DQ"},
	{"vandnps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.W0 55 /r", "AVX512_DQ-VL"},
	{"vandnps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.W0 55 /r", "AVX512_DQ-VL"},
	{"vandnps", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.W0 55 /r", "AVX512_DQ"},
	{"vandpd", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 54 /r", "AVX512_DQ-VL"},
	{"vandpd", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 54 /r", "AVX512_DQ-VL"},
	{"vandpd", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 54 /r", "AVX512_DQ"},
	{"vandps", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 54 /r", "AVX512_DQ-VL"},
	{"vandps", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 54 /r", "AVX512_DQ-VL"},
	{"vandps", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.0F.W0 54 /r", "AVX512_DQ"},
	{"vblendmb", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W0 66 /r", "AVX512_BW-VL"},
	{"vblendmb", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W0 66 /r", "AVX512_BW-VL"},
	{"vblendmb", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W0 66 /r", "AVX512_BW"},
	{"vblendmd", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 64 /r", "AVX512_F-VL"},
	{"vblendmd", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 64 /r", "AVX512_F-VL"},
	{"vblendmd", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 64 /r", "AVX512_F"},
	{"vblendmpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 65 /r", "AVX512_F-VL"},
	{"vblendmpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 65 /r", "AVX512_F-VL"},
	{"vblendmpd", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 65 /r", "AVX512_F"},
	{"vblendmps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 65 /r", "AVX512_F-VL"},
	{"vblendmps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 65 /r", "AVX512_F-VL"},
	{"vblendmps", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 65 /r", "AVX512_F"},
	{"vblendmq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 64 /r", "AVX512_F-VL"},
	{"vblendmq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 64 /r", "AVX512_F-VL"},
	{"vblendmq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 64 /r", "AVX512_F"},
	{"vblendmw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W1 66 /r", "AVX512_BW-VL"},
	{"vblendmw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W1 66 /r", "AVX512_BW-VL"},
	{"vblendmw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W1 66 /r", "AVX512_BW"},
	{"vbroadcastf32x2", "W:ymm {kz}, xmm{7:0}/m64", "RM-T2", "EVEX.256.66.0F38.W0 19 /r", "AVX512_DQ-VL"},
	{"vbroadcastf32x2", "W:zmm {kz}, xmm{7:0}/m64", "RM-T2", "EVEX.512.66.0F38.W0 19 /r", "AVX512_DQ"},
	{"vbroadcastf32x4", "W:ymm {kz}, m128", "RM-T4", "EVEX.256.66.0F38.W0 1A /r", "AVX512_F"},
	{"vbroadcastf32x4", "W:zmm {kz}, m128", "RM-T4", "EVEX.512.66.0F38.W0 1A /r", "AVX512_F"},
	{"vbroadcastf32x8", "W:zmm {kz}, m256", "RM-T8", "EVEX.512.66.0F38.W0 1B /r", "AVX512_DQ"},
	{"vbroadcastf64x2", "W:ymm {kz}, m128", "RM-T2", "EVEX.256.66.0F38.W1 1A /r", "AVX512_DQ-VL"},
	{"vbroadcastf64x2", "W:zmm {kz}, m128", "RM-T2", "EVEX.512.66.0F38.W1 1A /r", "AVX512_DQ"},
	{"vbroadcastf64x4", "W:zmm {kz}, m256", "RM-T4", "EVEX.512.66.0F38.W1 1B /r", "AVX512_F"},
	{"vbroadcasti32x2", "W:xmm {kz}, xmm{7:0}/m64", "RM-T2", "EVEX.128.66.0F38.W0 59 /r", "AVX512_DQ-VL"},
	{"vbroadcasti32x2", "W:ymm {kz}, xmm{7:0}/m64", "RM-T2", "EVEX.256.66.0F38.W0 59 /r", "AVX512_DQ-VL"},
	{"vbroadcasti32x2", "W:zmm {kz}, xmm{7:0}/m64", "RM-T2", "EVEX.512.66.0F38.W0 59 /r", "AVX512_DQ"},
	{"vbroadcasti32x4", "W:ymm {kz}, m128", "RM-T4", "EVEX.256.66.0F38.W0 5A /r", "AVX512_F-VL"},
	{"vbroadcasti32x4", "W:zmm {kz}, m128", "RM-T4", "EVEX.512.66.0F38.W0 5A /r", "AVX512_F"},
	{"vbroadcasti32x8", "W:zmm {kz}, m256", "RM-T8", "EVEX.512.66.0F38.W0 5B /r", "AVX512_DQ"},
	{"vbroadcasti64x2", "W:ymm {kz}, m128", "RM-T2", "EVEX.256.66.0F38.W1 5A /r", "AVX512_DQ-VL"},
	{"vbroadcasti64x2", "W:zmm {kz}, m128", "RM-T2", "EVEX.512.66.0F38.W1 5A /r", "AVX512_DQ"},
	{"vbroadcasti64x4", "W:zmm {kz}, m256", "RM-T4", "EVEX.512.66.0F38.W1 5B /r", "AVX512_F"},
	{"vbroadcastsd", "W:ymm {kz}, xmm{7:0}/m64", "RM-T1S", "EVEX.256.66.0F38.W1 19 /r", "AVX512_F-VL"},
	{"vbroadcastsd", "W:zmm {kz}, xmm{7:0}/m64", "RM-T1S", "EVEX.512.66.0F38.W1 19 /r", "AVX512_F"},
	{"vbroadcastss", "W:xmm {kz}, xmm{3:0}/m64", "RM-T1S", "EVEX.128.66.0F38.W0 18 /r", "AVX512_F-VL"},
	{"vbroadcastss", "W:ymm {kz}, xmm{3:0}/m64", "RM-T1S", "EVEX.256.66.0F38.W0 18 /r", "AVX512_F-VL"},
	{"vbroadcastss", "W:zmm {kz}, xmm{3:0}/m64", "RM-T1S", "EVEX.512.66.0F38.W0 18 /r", "AVX512_F"},
	{"vcmppd", "W:k {kz}, xmm, xmm/m128/b64, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F.W1 C2 /r ib", "AVX512_F-VL"},
	{"vcmppd", "W:k {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F.W1 C2 /r ib", "AVX512_F-VL"},
	{"vcmppd", "W:k {kz}, zmm, zmm/m512/b64, ib/ub {sae}", "RVMI-FV", "EVEX.NDS.512.66.0F.W1 C2 /r ib", "AVX512_F"},
	{"vcmpps", "W:k {kz}, xmm, xmm/m128/b32, ib/ub", "RVMI-FV", "EVEX.NDS.128.0F.W0 C2 /r ib", "AVX512_F-VL"},
	{"vcmpps", "W:k {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.NDS.256.0F.W0 C2 /r ib", "AVX512_F-VL"},
	{"vcmpps", "W:k {kz}, zmm, zmm/m512/b32, ib/ub {sae}", "RVMI-FV", "EVEX.NDS.512.0F.W0 C2 /r ib", "AVX512_F"},
	{"vcmpsd", "W:k {kz}, xmm, xmm{7:0}/m64, ib/ub {sae}", "RVMI-T1S", "EVEX.NDS.LIG.F2.0F.W1 C2 /r ib", "AVX512_F"},
	{"vcmpss", "W:k {kz}, xmm, xmm{3:0}/m32, ib/ub {sae}", "RVMI-T1S", "EVEX.NDS.LIG.F3.0F.W0 C2 /r ib", "AVX512_F"},
	{"vcomisd", "R:xmm{7:0}, xmm{7:0}/m64 {sae}", "RM-T1S", "EVEX.LIG.66.0F.W1 2F /r", "AVX512_F OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"vcomiss", "R:xmm{3:0}, xmm{3:0}/m32 {sae}", "RM-T1S", "EVEX.LIG.0F.W0 2F /r", "AVX512_F OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"vcompresspd", "W:xmm/m128 {kz}, xmm", "MR-T1S", "EVEX.128.66.0F38.W1 8A /r", "AVX512_F-VL"},
	{"vcompresspd", "W:ymm/m256 {kz}, ymm", "MR-T1S", "EVEX.256.66.0F38.W1 8A /r", "AVX512_F-VL"},
	{"vcompresspd", "W:zmm/m512 {kz}, zmm", "MR-T1S", "EVEX.512.66.0F38.W1 8A /r", "AVX512_F"},
	{"vcompressps", "W:xmm/m128 {kz}, xmm", "MR-T1S", "EVEX.128.66.0F38.W0 8A /r", "AVX512_F-VL"},
	{"vcompressps", "W:ymm/m256 {kz}, ymm", "MR-T1S", "EVEX.256.66.0F38.W0 8A /r", "AVX512_F-VL"},
	{"vcompressps", "W:zmm/m512 {kz}, zmm", "MR-T1S", "EVEX.512.66.0F38.W0 8A /r", "AVX512_F"},
	{"vcvtdq2pd", "W:xmm {kz}, xmm{7:0}/m64/b32", "RM-HV", "EVEX.128.F3.0F.W0 E6 /r", "AVX512_F-VL"},
	{"vcvtdq2pd", "W:ymm {kz}, xmm/m128/b32", "RM-HV", "EVEX.256.F3.0F.W0 E6 /r", "AVX512_F-VL"},
	{"vcvtdq2pd", "W:zmm {kz}, ymm/m256/b32", "RM-HV", "EVEX.512.F3.0F.W0 E6 /r", "AVX512_F"},
	{"vcvtdq2ps", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.0F.W0 5B /r", "AVX512_F-VL"},
	{"vcvtdq2ps", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.0F.W0 5B /r", "AVX512_F-VL"},
	{"vcvtdq2ps", "W:zmm {kz}, zmm/m512/b32 {er}", "RM-FV", "EVEX.512.0F.W0 5B /r", "AVX512_F"},
	{"vcvtpd2ps", "W:xmm{7:0} {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F.W1 5A /r", "AVX512_F-VL"},
	{"vcvtpd2ps", "W:xmm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F.W1 5A /r", "AVX512_F-VL"},
	{"vcvtpd2ps", "W:ymm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.66.0F.W1 5A /r", "AVX512_F"},
	{"vcvtpd2dq", "W:xmm{7:0} {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.F2.0F.W1 E6 /r", "AVX512_F-VL"},
	{"vcvtpd2dq", "W:xmm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.F2.0F.W1 E6 /r", "AVX512_F-VL"},
	{"vcvtpd2dq", "W:ymm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.F2.0F.W1 E6 /r", "AVX512_F"},
	{"vcvtpd2qq", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F.W1 7B /r", "AVX512_DQ-VL"},
	{"vcvtpd2qq", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F.W1 7B /r", "AVX512_DQ-VL"},
	{"vcvtpd2qq", "W:zmm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.66.0F.W1 7B /r", "AVX512_DQ"},
	{"vcvtpd2udq", "W:xmm{7:0} {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.0F.W1 79 /r", "AVX512_F-VL"},
	{"vcvtpd2udq", "W:xmm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.0F.W1 79 /r", "AVX512_F-VL"},
	{"vcvtpd2udq", "W:ymm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.0F.W1 79 /r", "AVX512_F"},
	{"vcvtpd2uqq", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F.W1 79 /r", "AVX512_DQ-VL"},
	{"vcvtpd2uqq", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F.W1 79 /r", "AVX512_DQ-VL"},
	{"vcvtpd2uqq", "W:zmm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.66.0F.W1 79 /r", "AVX512_DQ"},
	{"vcvtph2ps", "W:xmm {kz}, xmm{7:0}/m64", "RM-HVM", "EVEX.128.66.0F38.W0 13 /r", "AVX512_F-VL"},
	{"vcvtph2ps", "W:ymm {kz}, xmm/m128", "RM-HVM", "EVEX.256.66.0F38.W0 13 /r", "AVX512_F-VL"},
	{"vcvtph2ps", "W:zmm {kz}, ymm/m256 {sae}", "RM-HVM", "EVEX.512.66.0F38.W0 13 /r", "AVX512_F"},
	{"vcvtps2dq", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.66.0F.W0 5B /r", "AVX512_F-VL"},
	{"vcvtps2dq", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.66.0F.W0 5B /r", "AVX512_F-VL"},
	{"vcvtps2dq", "W:zmm {kz}, zmm/m512/b32 {er}", "RM-FV", "EVEX.512.66.0F.W0 5B /r", "AVX512_F"},
	{"vcvtps2pd", "W:xmm {kz}, xmm{7:0}/m64/b32", "RM-HV", "EVEX.128.0F.W0 5A /r", "AVX512_F-VL"},
	{"vcvtps2pd", "W:ymm {kz}, xmm/m128/b32", "RM-HV", "EVEX.256.0F.W0 5A /r", "AVX512_F-VL"},
	{"vcvtps2pd", "W:zmm {kz}, ymm/m256/b32 {er}", "RM-HV", "EVEX.512.0F.W0 5A /r", "AVX512_F"},
	{"vcvtps2ph", "W:xmm{7:0}/m64{kz}, xmm, ib/ub", "MRI-HVM", "EVEX.128.66.0F3A.W0 1D /r ib", "AVX512_F-VL"},
	{"vcvtps2ph", "W:xmm/m128 {kz}, ymm, ib/ub", "MRI-HVM", "EVEX.256.66.0F3A.W0 1D /r ib", "AVX512_F-VL"},
	{"vcvtps2ph", "W:ymm/m256 {kz}, zmm, ib/ub {sae}", "MRI-HVM", "EVEX.512.66.0F3A.W0 1D /r ib", "AVX512_F"},
	{"vcvtps2qq", "W:xmm {kz}, xmm{7:0}/m64/b32", "RM-HV", "EVEX.128.66.0F.W0 7B /r", "AVX512_DQ-VL"},
	{"vcvtps2qq", "W:ymm {kz}, xmm/m128/b32", "RM-HV", "EVEX.256.66.0F.W0 7B /r", "AVX512_DQ-VL"},
	{"vcvtps2qq", "W:zmm {kz}, ymm/m256/b32 {er}", "RM-HV", "EVEX.512.66.0F.W0 7B /r", "AVX512_DQ"},
	{"vcvtps2udq", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.0F.W0 79 /r", "AVX512_F-VL"},
	{"vcvtps2udq", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.0F.W0 79 /r", "AVX512_F-VL"},
	{"vcvtps2udq", "W:zmm {kz}, zmm/m512/b32 {er}", "RM-FV", "EVEX.512.0F.W0 79 /r", "AVX512_F"},
	{"vcvtps2uqq", "W:xmm {kz}, xmm{7:0}/m64/b32", "RM-HV", "EVEX.128.66.0F.W0 79 /r", "AVX512_DQ-VL"},
	{"vcvtps2uqq", "W:ymm {kz}, xmm/m128/b32", "RM-HV", "EVEX.256.66.0F.W0 79 /r", "AVX512_DQ-VL"},
	{"vcvtps2uqq", "W:zmm {kz}, ymm/m256/b32 {er}", "RM-HV", "EVEX.512.66.0F.W0 79 /r", "AVX512_DQ"},
	{"vcvtqq2pd", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.F3.0F.W1 E6 /r", "AVX512_DQ-VL"},
	{"vcvtqq2pd", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.F3.0F.W1 E6 /r", "AVX512_DQ-VL"},
	{"vcvtqq2pd", "W:zmm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.F3.0F.W1 E6 /r", "AVX512_DQ"},
	{"vcvtqq2ps", "W:xmm{7:0} {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.0F.W1 5B /r", "AVX512_DQ-VL"},
	{"vcvtqq2ps", "W:xmm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.0F.W1 5B /r", "AVX512_DQ-VL"},
	{"vcvtqq2ps", "W:ymm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.0F.W1 5B /r", "AVX512_DQ"},
	{"vcvtsd2si", "W:r32, xmm{7:0}/m64 {er}", "RM-T1F", "EVEX.LIG.F2.0F.W0 2D /r", "AVX512_F"},
	{"vcvtsd2si", "W:r64, xmm{7:0}/m64 {er}", "RM-T1F", "EVEX.LIG.F2.0F.W1 2D /r", "AVX512_F X64"},
	{"vcvtsd2ss", "W:xmm {kz}, xmm{15:4}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 5A /r", "AVX512_F"},
	{"vcvtsd2usi", "W:r32, xmm{7:0}/m64 {er}", "RM-T1F", "EVEX.LIG.F2.0F.W0 79 /r", "AVX512_F"},
	{"vcvtsd2usi", "W:r64, xmm{7:0}/m64 {er}", "RM-T1F", "EVEX.LIG.F2.0F.W1 79 /r", "AVX512_F X64"},
	{"vcvtsi2sd", "W:xmm, xmm{15:8}, r32/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W0 2A /r", "AVX512_F"},
	{"vcvtsi2sd", "W:xmm, xmm{15:8}, r64/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 2A /r", "AVX512_F X64"},
	{"vcvtsi2ss", "W:xmm, xmm{15:4}, r32/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 2A /r", "AVX512_F"},
	{"vcvtsi2ss", "W:xmm, xmm{15:4}, r64/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W1 2A /r", "AVX512_F X64"},
	{"vcvtss2sd", "W:xmm {kz}, xmm{15:8}, xmm{3:0}/m32 {sae}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 5A /r", "AVX512_F"},
	{"vcvtss2si", "W:r32, xmm{3:0}/m32 {er}", "RM-T1F", "EVEX.LIG.F3.0F.W0 2D /r", "AVX512_F"},
	{"vcvtss2si", "W:r64, xmm{3:0}/m32 {er}", "RM-T1F", "EVEX.LIG.F3.0F.W1 2D /r", "AVX512_F X64"},
	{"vcvtss2usi", "W:r32, xmm{3:0}/m32 {er}", "RM-T1F", "EVEX.LIG.F3.0F.W0 79 /r", "AVX512_F"},
	{"vcvtss2usi", "W:r64, xmm{3:0}/m32 {er}", "RM-T1F", "EVEX.LIG.F3.0F.W1 79 /r", "AVX512_F X64"},
	{"vcvttpd2dq", "W:xmm{7:0} {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F.W1 E6 /r", "AVX512_F-VL"},
	{"vcvttpd2dq", "W:xmm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F.W1 E6 /r", "AVX512_F-VL"},
	{"vcvttpd2dq", "W:ymm {kz}, zmm/m512/b64 {sae}", "RM-FV", "EVEX.512.66.0F.W1 E6 /r", "AVX512_F"},
	{"vcvttpd2qq", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F.W1 7A /r", "AVX512_F-VL"},
	{"vcvttpd2qq", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F.W1 7A /r", "AVX512_F-VL"},
	{"vcvttpd2qq", "W:zmm {kz}, zmm/m512/b64 {sae}", "RM-FV", "EVEX.512.66.0F.W1 7A /r", "AVX512_F"},
	{"vcvttpd2udq", "W:xmm{7:0} {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.0F.W1 78 /r", "AVX512_F-VL"},
	{"vcvttpd2udq", "W:xmm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.0F.W1 78 /r", "AVX512_F-VL"},
	{"vcvttpd2udq", "W:ymm {kz}, zmm/m512/b64 {sae}", "RM-FV", "EVEX.512.0F.W1 78 /r", "AVX512_F"},
	{"vcvttpd2uqq", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F.W1 78 /r", "AVX512_DQ-VL"},
	{"vcvttpd2uqq", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F.W1 78 /r", "AVX512_DQ-VL"},
	{"vcvttpd2uqq", "W:zmm {kz}, zmm/m512/b64 {sae}", "RM-FV", "EVEX.512.66.0F.W1 78 /r", "AVX512_DQ"},
	{"vcvttps2dq", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.F3.0F.W0 5B /r", "AVX512_F-VL"},
	{"vcvttps2dq", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.F3.0F.W0 5B /r", "AVX512_F-VL"},
	{"vcvttps2dq", "W:zmm {kz}, zmm/m512/b32 {sae}", "RM-FV", "EVEX.512.F3.0F.W0 5B /r", "AVX512_F"},
	{"vcvttps2qq", "W:xmm {kz}, xmm{7:0}/m64/b32", "RM-HV", "EVEX.128.66.0F.W0 7A /r", "AVX512_DQ-VL"},
	{"vcvttps2qq", "W:ymm {kz}, xmm/m128/b32", "RM-HV", "EVEX.256.66.0F.W0 7A /r", "AVX512_DQ-VL"},
	{"vcvttps2qq", "W:zmm {kz}, ymm/m256/b32 {sae}", "RM-HV", "EVEX.512.66.0F.W0 7A /r", "AVX512_DQ"},
	{"vcvttps2udq", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.0F.W0 78 /r", "AVX512_F-VL"},
	{"vcvttps2udq", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.0F.W0 78 /r", "AVX512_F-VL"},
	{"vcvttps2udq", "W:zmm {kz}, zmm/m512/b32 {sae}", "RM-FV", "EVEX.512.0F.W0 78 /r", "AVX512_F"},
	{"vcvttps2uqq", "W:xmm {kz}, xmm{7:0}/m64/b32", "RM-HV", "EVEX.128.66.0F.W0 78 /r", "AVX512_DQ-VL"},
	{"vcvttps2uqq", "W:ymm {kz}, xmm/m128/b32", "RM-HV", "EVEX.256.66.0F.W0 78 /r", "AVX512_DQ-VL"},
	{"vcvttps2uqq", "W:zmm {kz}, ymm/m256/b32 {sae}", "RM-HV", "EVEX.512.66.0F.W0 78 /r", "AVX512_DQ"},
	{"vcvttsd2si", "W:r32, xmm{7:0}/m64 {sae}", "RM-T1F", "EVEX.LIG.F2.0F.W0 2C /r", "AVX512_F"},
	{"vcvttsd2si", "W:r64, xmm{7:0}/m64 {sae}", "RM-T1F", "EVEX.LIG.F2.0F.W1 2C /r", "AVX512_F X64"},
	{"vcvttsd2usi", "W:r32, xmm{7:0}/m64 {sae}", "RM-T1F", "EVEX.LIG.F2.0F.W0 78 /r", "AVX512_F"},
	{"vcvttsd2usi", "W:r64, xmm{7:0}/m64 {sae}", "RM-T1F", "EVEX.LIG.F2.0F.W1 78 /r", "AVX512_F X64"},
	{"vcvttss2si", "W:r32, xmm{3:0}/m32 {sae}", "RM-T1F", "EVEX.LIG.F3.0F.W0 2C /r", "AVX512_F"},
	{"vcvttss2si", "W:r64, xmm{3:0}/m32 {sae}", "RM-T1F", "EVEX.LIG.F3.0F.W1 2C /r", "AVX512_F X64"},
	{"vcvttss2usi", "W:r32, xmm{3:0}/m32 {sae}", "RM-T1F", "EVEX.LIG.F3.0F.W0 78 /r", "AVX512_F"},
	{"vcvttss2usi", "W:r64, xmm{3:0}/m32 {sae}", "RM-T1F", "EVEX.LIG.F3.0F.W1 78 /r", "AVX512_F X64"},
	{"vcvtudq2pd", "W:xmm {kz}, xmm{7:0}/m64/b32", "RM-HV", "EVEX.128.F3.0F.W0 7A /r", "AVX512_F-VL"},
	{"vcvtudq2pd", "W:ymm {kz}, xmm/m128/b32", "RM-HV", "EVEX.256.F3.0F.W0 7A /r", "AVX512_F-VL"},
	{"vcvtudq2pd", "W:zmm {kz}, ymm/m256/b32", "RM-HV", "EVEX.512.F3.0F.W0 7A /r", "AVX512_F"},
	{"vcvtudq2ps", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.F2.0F.W0 7A /r", "AVX512_F-VL"},
	{"vcvtudq2ps", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.F2.0F.W0 7A /r", "AVX512_F-VL"},
	{"vcvtudq2ps", "W:zmm {kz}, zmm/m512/b32 {er}", "RM-FV", "EVEX.512.F2.0F.W0 7A /r", "AVX512_F"},
	{"vcvtuqq2pd", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.F3.0F.W1 7A /r", "AVX512_DQ-VL"},
	{"vcvtuqq2pd", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.F3.0F.W1 7A /r", "AVX512_DQ-VL"},
	{"vcvtuqq2pd", "W:zmm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.F3.0F.W1 7A /r", "AVX512_DQ"},
	{"vcvtuqq2ps", "W:xmm{7:0} {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.F2.0F.W1 7A /r", "AVX512_DQ-VL"},
	{"vcvtuqq2ps", "W:xmm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.F2.0F.W1 7A /r", "AVX512_DQ-VL"},
	{"vcvtuqq2ps", "W:ymm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.F2.0F.W1 7A /r", "AVX512_DQ"},
	{"vcvtusi2sd", "W:xmm, xmm{15:8}, r32/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W0 7B /r", "AVX512_F"},
	{"vcvtusi2sd", "W:xmm, xmm{15:8}, r64/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 7B /r", "AVX512_F X64"},
	{"vcvtusi2ss", "W:xmm, xmm{15:4}, r32/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 7B /r", "AVX512_F"},
	{"vcvtusi2ss", "W:xmm, xmm{15:4}, r64/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W1 7B /r", "AVX512_F X64"},
	{"vdbpsadbw", "W:xmm {kz}, xmm, xmm/m128, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W0 42 /r ib", "AVX512_BW-VL"},
	{"vdbpsadbw", "W:ymm {kz}, ymm, ymm/m256, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W0 42 /r ib", "AVX512_BW-VL"},
	{"vdbpsadbw", "W:zmm {kz}, zmm, zmm/m512, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W0 42 /r ib", "AVX512_BW"},
	{"vdivpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 5E /r", "AVX512_F-VL"},
	{"vdivpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 5E /r", "AVX512_F-VL"},
	{"vdivpd", "W:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F.W1 5E /r", "AVX512_F"},
	{"vdivps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 5E /r", "AVX512_F-VL"},
	{"vdivps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 5E /r", "AVX512_F-VL"},
	{"vdivps", "W:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.0F.W0 5E /r", "AVX512_F"},
	{"vdivsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 5E /r", "AVX512_F"},
	{"vdivss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 5E /r", "AVX512_F"},
	{"vexp2pd", "W:zmm {kz}, zmm/m512/b64 {sae}", "RM-FV", "EVEX.512.66.0F38.W1 C8 /r", "AVX512_ERI"},
	{"vexp2ps", "W:zmm {kz}, zmm/m512/b32 {sae}", "RM-FV", "EVEX.512.66.0F38.W0 C8 /r", "AVX512_ERI"},
	{"vexpandpd", "W:xmm {kz}, xmm/m128", "RM-T1S", "EVEX.128.66.0F38.W1 88 /r", "AVX512_F-VL"},
	{"vexpandpd", "W:ymm {kz}, ymm/m256", "RM-T1S", "EVEX.256.66.0F38.W1 88 /r", "AVX512_F-VL"},
	{"vexpandpd", "W:zmm {kz}, zmm/m512", "RM-T1S", "EVEX.512.66.0F38.W1 88 /r", "AVX512_F"},
	{"vexpandps", "W:xmm {kz}, xmm/m128", "RM-T1S", "EVEX.128.66.0F38.W0 88 /r", "AVX512_F-VL"},
	{"vexpandps", "W:ymm {kz}, ymm/m256", "RM-T1S", "EVEX.256.66.0F38.W0 88 /r", "AVX512_F-VL"},
	{"vexpandps", "W:zmm {kz}, zmm/m512", "RM-T1S", "EVEX.512.66.0F38.W0 88 /r", "AVX512_F"},
	{"vextractf32x4", "W:xmm/m128 {kz}, ymm, ib/ub", "MRI-T4", "EVEX.256.66.0F3A.W0 19 /r ib", "AVX512_F-VL"},
	{"vextractf32x4", "W:xmm/m128 {kz}, zmm, ib/ub", "MRI-T4", "EVEX.512.66.0F3A.W0 19 /r ib", "AVX512_F"},
	{"vextractf32x8", "W:ymm/m256 {kz}, zmm, ib/ub", "MRI-T8", "EVEX.512.66.0F3A.W0 1B /r ib", "AVX512_DQ"},
	{"vextractf64x2", "W:xmm/m128 {kz}, ymm, ib/ub", "MRI-T2", "EVEX.256.66.0F3A.W1 19 /r ib", "AVX512_DQ-VL"},
	{"vextractf64x2", "W:xmm/m128 {kz}, zmm, ib/ub", "MRI-T2", "EVEX.512.66.0F3A.W1 19 /r ib", "AVX512_DQ"},
	{"vextractf64x4", "W:ymm/m256 {kz}, zmm, ib/ub", "MRI-T4", "EVEX.512.66.0F3A.W1 1B /r ib", "AVX512_F"},
	{"vextracti32x4", "W:xmm/m128 {kz}, ymm, ib/ub", "MRI-T4", "EVEX.256.66.0F3A.W0 39 /r ib", "AVX512_F-VL"},
	{"vextracti32x4", "W:xmm/m128 {kz}, zmm, ib/ub", "MRI-T4", "EVEX.512.66.0F3A.W0 39 /r ib", "AVX512_F"},
	{"vextracti32x8", "W:ymm/m256 {kz}, zmm, ib/ub", "MRI-T8", "EVEX.512.66.0F3A.W0 3B /r ib", "AVX512_DQ"},
	{"vextracti64x2", "W:xmm/m128 {kz}, ymm, ib/ub", "MRI-T2", "EVEX.256.66.0F3A.W1 39 /r ib", "AVX512_DQ-VL"},
	{"vextracti64x2", "W:xmm/m128 {kz}, zmm, ib/ub", "MRI-T2", "EVEX.512.66.0F3A.W1 39 /r ib", "AVX512_DQ"},
	{"vextracti64x4", "W:ymm/m256 {kz}, zmm, ib/ub", "MRI-T4", "EVEX.512.66.0F3A.W1 3B /r ib", "AVX512_F"},
	{"vextractps", "W:r32{3:0}/m32, xmm, ib/ub", "MRI-T1S", "EVEX.128.66.0F3A.WIG 17 /r ib", "AVX512_F"},
	{"vextractps", "W:r64{3:0}, xmm, ib/ub", "MRI-T1S", "EVEX.128.66.0F3A.WIG 17 /r ib", "AVX512_F X64"},
	{"vfixupimmpd", "X:xmm {kz}, xmm, xmm/m128/b64, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W1 54 /r ib", "AVX512_F-VL"},
	{"vfixupimmpd", "X:ymm {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W1 54 /r ib", "AVX512_F-VL"},
	{"vfixupimmpd", "X:zmm {kz}, zmm, zmm/m512/b64, ib/ub {sae}", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W1 54 /r ib", "AVX512_F"},
	{"vfixupimmps", "X:xmm {kz}, xmm, xmm/m128/b32, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W0 54 /r ib", "AVX512_F-VL"},
	{"vfixupimmps", "X:ymm {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W0 54 /r ib", "AVX512_F-VL"},
	{"vfixupimmps", "X:zmm {kz}, zmm, zmm/m512/b32, ib/ub {sae}", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W0 54 /r ib", "AVX512_F"},
	{"vfixupimmsd", "X:xmm {kz}, xmm{15:8}, xmm{7:0}/m64,ib/ub {sae}", "RVMI-T1S", "EVEX.NDS.LIG.66.0F3A.W1 55 /r ib", "AVX512_F"},
	{"vfixupimmss", "X:xmm {kz}, xmm{15:4}, xmm{3:0}/m32,ib/ub {sae}", "RVMI-T1S", "EVEX.NDS.LIG.66.0F3A.W0 55 /r ib", "AVX512_F"},
	{"vfmadd132pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 98 /r", "AVX512_F-VL"},
	{"vfmadd132pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 98 /r", "AVX512_F-VL"},
	{"vfmadd132pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 98 /r", "AVX512_F"},
	{"vfmadd132ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 98 /r", "AVX512_F-VL"},
	{"vfmadd132ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 98 /r", "AVX512_F-VL"},
	{"vfmadd132ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 98 /r", "AVX512_F"},
	{"vfmadd132sd", "x:xmm{7:0} {kz},xmm{7:0},xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 99 /r", "AVX512_F"},
	{"vfmadd132ss", "x:xmm{3:0} {kz},xmm{3:0},xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 99 /r", "AVX512_F"},
	{"vfmadd213pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 A8 /r", "AVX512_F-VL"},
	{"vfmadd213pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 A8 /r", "AVX512_F-VL"},
	{"vfmadd213pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 A8 /r", "AVX512_F"},
	{"vfmadd213ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 A8 /r", "AVX512_F-VL"},
	{"vfmadd213ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 A8 /r", "AVX512_F-VL"},
	{"vfmadd213ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 A8 /r", "AVX512_F"},
	{"vfmadd213sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 A9 /r", "AVX512_F"},
	{"vfmadd213ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 A9 /r", "AVX512_F"},
	{"vfmadd231pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 B8 /r", "AVX512_F-VL"},
	{"vfmadd231pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 B8 /r", "AVX512_F-VL"},
	{"vfmadd231pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 B8 /r", "AVX512_F"},
	{"vfmadd231ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 B8 /r", "AVX512_F-VL"},
	{"vfmadd231ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 B8 /r", "AVX512_F-VL"},
	{"vfmadd231ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 B8 /r", "AVX512_F"},
	{"vfmadd231sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 B9 /r", "AVX512_F"},
	{"vfmadd231ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 B9 /r", "AVX512_F"},
	{"vfmaddsub132pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 96 /r", "AVX512_F-VL"},
	{"vfmaddsub132pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 96 /r", "AVX512_F-VL"},
	{"vfmaddsub132pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 96 /r", "AVX512_F"},
	{"vfmaddsub132ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 96 /r", "AVX512_F-VL"},
	{"vfmaddsub132ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 96 /r", "AVX512_F-VL"},
	{"vfmaddsub132ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 96 /r", "AVX512_F"},
	{"vfmaddsub213pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 A6 /r", "AVX512_F-VL"},
	{"vfmaddsub213pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 A6 /r", "AVX512_F-VL"},
	{"vfmaddsub213pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 A6 /r", "AVX512_F"},
	{"vfmaddsub213ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 A6 /r", "AVX512_F-VL"},
	{"vfmaddsub213ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 A6 /r", "AVX512_F-VL"},
	{"vfmaddsub213ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 A6 /r", "AVX512_F"},
	{"vfmaddsub231pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 B6 /r", "AVX512_F-VL"},
	{"vfmaddsub231pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 B6 /r", "AVX512_F-VL"},
	{"vfmaddsub231pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 B6 /r", "AVX512_F"},
	{"vfmaddsub231ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 B6 /r", "AVX512_F-VL"},
	{"vfmaddsub231ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 B6 /r", "AVX512_F-VL"},
	{"vfmaddsub231ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 B6 /r", "AVX512_F"},
	{"vfmsub132pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 9A /r", "AVX512_F-VL"},
	{"vfmsub132pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 9A /r", "AVX512_F-VL"},
	{"vfmsub132pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 9A /r", "AVX512_F"},
	{"vfmsub132ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 9A /r", "AVX512_F-VL"},
	{"vfmsub132ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 9A /r", "AVX512_F-VL"},
	{"vfmsub132ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 9A /r", "AVX512_F"},
	{"vfmsub132sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 9B /r", "AVX512_F"},
	{"vfmsub132ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 9B /r", "AVX512_F"},
	{"vfmsub213pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 AA /r", "AVX512_F-VL"},
	{"vfmsub213pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 AA /r", "AVX512_F-VL"},
	{"vfmsub213pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 AA /r", "AVX512_F"},
	{"vfmsub213ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 AA /r", "AVX512_F-VL"},
	{"vfmsub213ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 AA /r", "AVX512_F-VL"},
	{"vfmsub213ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 AA /r", "AVX512_F"},
	{"vfmsub213sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 AB /r", "AVX512_F"},
	{"vfmsub213ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 AB /r", "AVX512_F"},
	{"vfmsub231pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 BA /r", "AVX512_F-VL"},
	{"vfmsub231pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 BA /r", "AVX512_F-VL"},
	{"vfmsub231pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 BA /r", "AVX512_F"},
	{"vfmsub231ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 BA /r", "AVX512_F-VL"},
	{"vfmsub231ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 BA /r", "AVX512_F-VL"},
	{"vfmsub231ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 BA /r", "AVX512_F"},
	{"vfmsub231sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 BB /r", "AVX512_F"},
	{"vfmsub231ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 BB /r", "AVX512_F"},
	{"vfmsubadd132pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 97 /r", "AVX512_F-VL"},
	{"vfmsubadd132pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 97 /r", "AVX512_F-VL"},
	{"vfmsubadd132pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 97 /r", "AVX512_F"},
	{"vfmsubadd132ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 97 /r", "AVX512_F-VL"},
	{"vfmsubadd132ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 97 /r", "AVX512_F-VL"},
	{"vfmsubadd132ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 97 /r", "AVX512_F"},
	{"vfmsubadd213pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 A7 /r", "AVX512_F-VL"},
	{"vfmsubadd213pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 A7 /r", "AVX512_F-VL"},
	{"vfmsubadd213pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 A7 /r", "AVX512_F"},
	{"vfmsubadd213ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 A7 /r", "AVX512_F-VL"},
	{"vfmsubadd213ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 A7 /r", "AVX512_F-VL"},
	{"vfmsubadd213ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 A7 /r", "AVX512_F"},
	{"vfmsubadd231pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 B7 /r", "AVX512_F-VL"},
	{"vfmsubadd231pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 B7 /r", "AVX512_F-VL"},
	{"vfmsubadd231pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 B7 /r", "AVX512_F"},
	{"vfmsubadd231ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 B7 /r", "AVX512_F-VL"},
	{"vfmsubadd231ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 B7 /r", "AVX512_F-VL"},
	{"vfmsubadd231ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 B7 /r", "AVX512_F"},
	{"vfnmadd132pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 9C /r", "AVX512_F-VL"},
	{"vfnmadd132pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 9C /r", "AVX512_F-VL"},
	{"vfnmadd132pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 9C /r", "AVX512_F"},
	{"vfnmadd132ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 9C /r", "AVX512_F-VL"},
	{"vfnmadd132ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 9C /r", "AVX512_F-VL"},
	{"vfnmadd132ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 9C /r", "AVX512_F"},
	{"vfnmadd132sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 9D /r", "AVX512_F"},
	{"vfnmadd132ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 9D /r", "AVX512_F"},
	{"vfnmadd213pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 AC /r", "AVX512_F-VL"},
	{"vfnmadd213pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 AC /r", "AVX512_F-VL"},
	{"vfnmadd213pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 AC /r", "AVX512_F"},
	{"vfnmadd213ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 AC /r", "AVX512_F-VL"},
	{"vfnmadd213ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 AC /r", "AVX512_F-VL"},
	{"vfnmadd213ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 AC /r", "AVX512_F"},
	{"vfnmadd213sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 AD /r", "AVX512_F"},
	{"vfnmadd213ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 AD /r", "AVX512_F"},
	{"vfnmadd231pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 BC /r", "AVX512_F-VL"},
	{"vfnmadd231pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 BC /r", "AVX512_F-VL"},
	{"vfnmadd231pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 BC /r", "AVX512_F"},
	{"vfnmadd231ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 BC /r", "AVX512_F-VL"},
	{"vfnmadd231ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 BC /r", "AVX512_F-VL"},
	{"vfnmadd231ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 BC /r", "AVX512_F"},
	{"vfnmadd231sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 BD /r", "AVX512_F"},
	{"vfnmadd231ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 BD /r", "AVX512_F"},
	{"vfnmsub132pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 9E /r", "AVX512_F-VL"},
	{"vfnmsub132pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 9E /r", "AVX512_F-VL"},
	{"vfnmsub132pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 9E /r", "AVX512_F"},
	{"vfnmsub132ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 9E /r", "AVX512_F-VL"},
	{"vfnmsub132ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 9E /r", "AVX512_F-VL"},
	{"vfnmsub132ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 9E /r", "AVX512_F"},
	{"vfnmsub132sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 9F /r", "AVX512_F"},
	{"vfnmsub132ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 9F /r", "AVX512_F"},
	{"vfnmsub213pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 AE /r", "AVX512_F-VL"},
	{"vfnmsub213pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 AE /r", "AVX512_F-VL"},
	{"vfnmsub213pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 AE /r", "AVX512_F"},
	{"vfnmsub213ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 AE /r", "AVX512_F-VL"},
	{"vfnmsub213ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 AE /r", "AVX512_F-VL"},
	{"vfnmsub213ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 AE /r", "AVX512_F"},
	{"vfnmsub213sd", "x:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 AF /r", "AVX512_F"},
	{"vfnmsub213ss", "x:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 AF /r", "AVX512_F"},
	{"vfnmsub231pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 BE /r", "AVX512_F-VL"},
	{"vfnmsub231pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 BE /r", "AVX512_F-VL"},
	{"vfnmsub231pd", "X:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 BE /r", "AVX512_F"},
	{"vfnmsub231ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 BE /r", "AVX512_F-VL"},
	{"vfnmsub231ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 BE /r", "AVX512_F-VL"},
	{"vfnmsub231ps", "X:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 BE /r", "AVX512_F"},
	{"vfnmsub231sd", "X:xmm{7:0} {kz}, xmm{7:0}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W1 BF /r", "AVX512_F"},
	{"vfnmsub231ss", "X:xmm{3:0} {kz}, xmm{3:0}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.DDS.LIG.66.0F38.W0 BF /r", "AVX512_F"},
	{"vfpclasspd", "W:k {k}, xmm/m128/b64, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W1 66 /r ib", "AVX512_DQ-VL"},
	{"vfpclasspd", "W:k {k}, ymm/m256/b64, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W1 66 /r ib", "AVX512_DQ-VL"},
	{"vfpclasspd", "W:k {k}, zmm/m512/b64, ib/ub", "RMI-FV", "EVEX.512.66.0F3A.W1 66 /r ib", "AVX512_DQ"},
	{"vfpclassps", "W:k {k}, xmm/m128/b32, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W0 66 /r ib", "AVX512_DQ-VL"},
	{"vfpclassps", "W:k {k}, ymm/m256/b32, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W0 66 /r ib", "AVX512_DQ-VL"},
	{"vfpclassps", "W:k {k}, zmm/m512/b32, ib/ub", "RMI-FV", "EVEX.512.66.0F3A.W0 66 /r ib", "AVX512_DQ"},
	{"vfpclasssd", "W:k {k}, xmm{7:0}/m64, ib/ub", "RMI-T1S", "EVEX.LIG.66.0F3A.W1 67 /r ib", "AVX512_DQ"},
	{"vfpclassss", "W:k {k}, xmm{3:0}/m32, ib/ub", "RMI-T1S", "EVEX.LIG.66.0F3A.W0 67 /r ib", "AVX512_DQ"},
	{"vgatherdpd", "X:xmm {k}, vm32x", "RM-T1S", "EVEX.128.66.0F38.W1 92 /r", "AVX512_F-VL"},
	{"vgatherdpd", "X:ymm {k}, vm32y", "RM-T1S", "EVEX.256.66.0F38.W1 92 /r", "AVX512_F-VL"},
	{"vgatherdpd", "X:zmm {k}, vm32z", "RM-T1S", "EVEX.512.66.0F38.W1 92 /r", "AVX512_F"},
	{"vgatherdps", "X:xmm {k}, vm32x", "RM-T1S", "EVEX.128.66.0F38.W0 92 /r", "AVX512_F-VL"},
	{"vgatherdps", "X:ymm {k}, vm32y", "RM-T1S", "EVEX.256.66.0F38.W0 92 /r", "AVX512_F-VL"},
	{"vgatherdps", "X:zmm {k}, vm32z", "RM-T1S", "EVEX.512.66.0F38.W0 92 /r", "AVX512_F"},
	{"vgatherpf0dpd", "R:vm32y {k}", "M-T1S", "EVEX.512.66.0F38.W1 C6 /1", "AVX512_PFI"},
	{"vgatherpf0dps", "R:vm32z {k}", "M-T1S", "EVEX.512.66.0F38.W0 C6 /1", "AVX512_PFI"},
	{"vgatherpf0qpd", "R:vm64z {k}", "M-T1S", "EVEX.512.66.0F38.W1 C7 /1", "AVX512_PFI"},
	{"vgatherpf0qps", "R:vm64z {k}", "M-T1S", "EVEX.512.66.0F38.W0 C7 /1", "AVX512_PFI"},
	{"vgatherpf1dpd", "R:vm32y {k}", "M-T1S", "EVEX.512.66.0F38.W1 C6 /2", "AVX512_PFI"},
	{"vgatherpf1dps", "R:vm32z {k}", "M-T1S", "EVEX.512.66.0F38.W0 C6 /2", "AVX512_PFI"},
	{"vgatherpf1qpd", "R:vm64z {k}", "M-T1S", "EVEX.512.66.0F38.W1 C7 /2", "AVX512_PFI"},
	{"vgatherpf1qps", "R:vm64z {k}", "M-T1S", "EVEX.512.66.0F38.W0 C7 /2", "AVX512_PFI"},
	{"vgatherqpd", "X:xmm {k}, vm64x", "RM-T1S", "EVEX.128.66.0F38.W1 93 /r", "AVX512_F-VL"},
	{"vgatherqpd", "X:ymm {k}, vm64y", "RM-T1S", "EVEX.256.66.0F38.W1 93 /r", "AVX512_F-VL"},
	{"vgatherqpd", "X:zmm {k}, vm64z", "RM-T1S", "EVEX.512.66.0F38.W1 93 /r", "AVX512_F"},
	{"vgatherqps", "X:xmm {k}, vm64x", "RM-T1S", "EVEX.128.66.0F38.W0 93 /r", "AVX512_F-VL"},
	{"vgatherqps", "X:ymm {k}, vm64y", "RM-T1S", "EVEX.256.66.0F38.W0 93 /r", "AVX512_F-VL"},
	{"vgatherqps", "X:zmm {k}, vm64z", "RM-T1S", "EVEX.512.66.0F38.W0 93 /r", "AVX512_F"},
	{"vgetexppd", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F38.W1 42 /r", "AVX512_F-VL"},
	{"vgetexppd", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F38.W1 42 /r", "AVX512_F-VL"},
	{"vgetexppd", "W:zmm {kz}, zmm/m512/b64 {sae}", "RM-FV", "EVEX.512.66.0F38.W1 42 /r", "AVX512_F"},
	{"vgetexpps", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.66.0F38.W0 42 /r", "AVX512_F-VL"},
	{"vgetexpps", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.66.0F38.W0 42 /r", "AVX512_F-VL"},
	{"vgetexpps", "W:zmm {kz}, zmm/m512/b32 {sae}", "RM-FV", "EVEX.512.66.0F38.W0 42 /r", "AVX512_F"},
	{"vgetexpsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {sae}", "RM-T1S", "EVEX.NDS.LIG.66.0F38.W1 43 /r", "AVX512_F"},
	{"vgetexpss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {sae}", "RM-T1S", "EVEX.NDS.LIG.66.0F38.W0 43 /r", "AVX512_F"},
	{"vgetmantpd", "W:xmm {kz}, xmm/m128/b64, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W1 26 /r ib", "AVX512_F-VL"},
	{"vgetmantpd", "W:ymm {kz}, ymm/m256/b64, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W1 26 /r ib", "AVX512_F-VL"},
	{"vgetmantpd", "W:zmm {kz}, zmm/m512/b64, ib/ub {sae}", "RMI-FV", "EVEX.512.66.0F3A.W1 26 /r ib", "AVX512_F"},
	{"vgetmantps", "W:xmm {kz}, xmm/m128/b32, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W0 26 /r ib", "AVX512_F-VL"},
	{"vgetmantps", "W:ymm {kz}, ymm/m256/b32, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W0 26 /r ib", "AVX512_F-VL"},
	{"vgetmantps", "W:zmm {kz}, zmm/m512/b32, ib/ub {sae}", "RMI-FV", "EVEX.512.66.0F3A.W0 26 /r ib", "AVX512_F"},
	{"vgetmantsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64,ib/ub {sae}", "RMI-T1S", "EVEX.NDS.LIG.66.0F3A.W1 27 /r ib", "AVX512_F"},
	{"vgetmantss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32,ib/ub {sae}", "RMI-T1S", "EVEX.NDS.LIG.66.0F3A.W0 27 /r ib", "AVX512_F"},
	{"vgf2p8affineinvqb", "W:xmm {kz}, xmm, xmm/m128, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W1 CF /r ib", "AVX512_F-VL GFNI"},
	{"vgf2p8affineinvqb", "W:ymm {kz}, ymm, ymm/m256, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W1 CF /r ib", "AVX512_F-VL GFNI"},
	{"vgf2p8affineinvqb", "W:zmm {kz}, zmm, zmm/m512, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W1 CF /r ib", "AVX512_FGFNI"},
	{"vgf2p8affineqb", "W:xmm {kz}, xmm, xmm/m128, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W1 CE /r ib", "AVX512_F-VL GFNI"},
	{"vgf2p8affineqb", "W:ymm {kz}, ymm, ymm/m256, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W1 CE /r ib", "AVX512_F-VL GFNI"},
	{"vgf2p8affineqb", "W:zmm {kz}, zmm, zmm/m512, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W1 CE /r ib", "AVX512_FGFNI"},
	{"vgf2p8mulb", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W0 CF /r", "AVX512_F-VL GFNI"},
	{"vgf2p8mulb", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W0 CF /r", "AVX512_F-VL GFNI"},
	{"vgf2p8mulb", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W0 CF /r", "AVX512_FGFNI"},
	{"vinsertf32x4", "W:ymm {kz}, ymm, xmm/m128, ib/ub", "RVMI-T4", "EVEX.NDS.256.66.0F3A.W0 18 /r ib", "AVX512_F-VL"},
	{"vinsertf32x4", "W:zmm {kz}, zmm, xmm/m128, ib/ub", "RVMI-T4", "EVEX.NDS.512.66.0F3A.W0 18 /r ib", "AVX512_F"},
	{"vinsertf32x8", "W:zmm {kz}, zmm, ymm/m256, ib/ub", "RVMI-T8", "EVEX.NDS.512.66.0F3A.W0 1A /r ib", "AVX512_DQ"},
	{"vinsertf64x2", "W:ymm {kz}, ymm, xmm/m128, ib/ub", "RVMI-T2", "EVEX.NDS.256.66.0F3A.W1 18 /r ib", "AVX512_DQ-VL"},
	{"vinsertf64x2", "W:zmm {kz}, zmm, xmm/m128, ib/ub", "RVMI-T2", "EVEX.NDS.512.66.0F3A.W1 18 /r ib", "AVX512_DQ"},
	{"vinsertf64x4", "W:zmm {kz}, zmm, ymm/m256, ib/ub", "RVMI-T4", "EVEX.NDS.512.66.0F3A.W1 1A /r ib", "AVX512_F"},
	{"vinserti32x4", "W:ymm {kz}, ymm, xmm/m128, ib/ub", "RVMI-T4", "EVEX.NDS.256.66.0F3A.W0 38 /r ib", "AVX512_F-VL"},
	{"vinserti32x4", "W:zmm {kz}, zmm, xmm/m128, ib/ub", "RVMI-T4", "EVEX.NDS.512.66.0F3A.W0 38 /r ib", "AVX512_F"},
	{"vinserti32x8", "W:zmm {kz}, zmm, ymm/m256, ib/ub", "RVMI-T8", "EVEX.NDS.512.66.0F3A.W0 3A /r ib", "AVX512_DQ"},
	{"vinserti64x2", "W:ymm {kz}, ymm, xmm/m128, ib/ub", "RVMI-T2", "EVEX.NDS.256.66.0F3A.W1 38 /r ib", "AVX512_DQ-VL"},
	{"vinserti64x2", "W:zmm {kz}, zmm, xmm/m128, ib/ub", "RVMI-T2", "EVEX.NDS.512.66.0F3A.W1 38 /r ib", "AVX512_DQ"},
	{"vinserti64x4", "W:zmm {kz}, zmm, ymm/m256, ib/ub", "RVMI-T4", "EVEX.NDS.512.66.0F3A.W1 3A /r ib", "AVX512_F"},
	{"vinsertps", "W:xmm, xmm, xmm{3:0}/m32, ib/ub", "RVMI-T1S", "EVEX.NDS.128.66.0F3A.W0 21 /r ib", "AVX512_F"},
	{"vmaxpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 5F /r", "AVX512_F-VL"},
	{"vmaxpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 5F /r", "AVX512_F-VL"},
	{"vmaxpd", "W:zmm {kz}, zmm, zmm/m512/b64 {sae}", "RVM-FV", "EVEX.NDS.512.66.0F.W1 5F /r", "AVX512_F"},
	{"vmaxps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 5F /r", "AVX512_F-VL"},
	{"vmaxps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 5F /r", "AVX512_F-VL"},
	{"vmaxps", "W:zmm {kz}, zmm, zmm/m512/b32 {sae}", "RVM-FV", "EVEX.NDS.512.0F.W0 5F /r", "AVX512_F"},
	{"vmaxsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {sae}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 5F /r", "AVX512_F-VL"},
	{"vmaxss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {sae}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 5F /r", "AVX512_F-VL"},
	{"vminpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 5D /r", "AVX512_F-VL"},
	{"vminpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 5D /r", "AVX512_F-VL"},
	{"vminpd", "W:zmm {kz}, zmm, zmm/m512/b64 {sae}", "RVM-FV", "EVEX.NDS.512.66.0F.W1 5D /r", "AVX512_F"},
	{"vminps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 5D /r", "AVX512_F-VL"},
	{"vminps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 5D /r", "AVX512_F-VL"},
	{"vminps", "W:zmm {kz}, zmm, zmm/m512/b32 {sae}", "RVM-FV", "EVEX.NDS.512.0F.W0 5D /r", "AVX512_F"},
	{"vminsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {sae}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 5D /r", "AVX512_F-VL"},
	{"vminss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {sae}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 5D /r", "AVX512_F-VL"},
	{"vmovapd", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F.W1 28 /r", "AVX512_F-VL"},
	{"vmovapd", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.66.0F.W1 29 /r", "AVX512_F-VL"},
	{"vmovapd", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F.W1 28 /r", "AVX512_F-VL"},
	{"vmovapd", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.66.0F.W1 29 /r", "AVX512_F-VL"},
	{"vmovapd", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F.W1 28 /r", "AVX512_F"},
	{"vmovapd", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.66.0F.W1 29 /r", "AVX512_F"},
	{"vmovaps", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.0F.W0 28 /r", "AVX512_F-VL"},
	{"vmovaps", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.0F.W0 29 /r", "AVX512_F-VL"},
	{"vmovaps", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.0F.W0 28 /r", "AVX512_F-VL"},
	{"vmovaps", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.0F.W0 29 /r", "AVX512_F-VL"},
	{"vmovaps", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.0F.W0 28 /r", "AVX512_F"},
	{"vmovaps", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.0F.W0 29 /r", "AVX512_F"},
	{"vmovd", "W:r32/m32, xmm{3:0}", "MR-T1S", "EVEX.128.66.0F.W0 7E /r", "AVX512_F"},
	{"vmovd", "W:r64{3:0}, xmm{3:0}", "MR-T1S", "EVEX.128.66.0F.W0 7E /r", "AVX512_F X64"},
	{"vmovd", "W:xmm{3:0}, r32/m32", "RM-T1S", "EVEX.128.66.0F.W0 6E /r", "AVX512_F"},
	{"vmovd", "W:xmm{3:0}, r64{3:0}", "RM-T1S", "EVEX.128.66.0F.W0 6E /r", "AVX512_F X64"},
	{"vmovddup", "W:xmm {kz}, xmm{7:0}/m64", "RM-DUP", "EVEX.128.F2.0F.W1 12 /r", "AVX512_F-VL"},
	{"vmovddup", "W:ymm {kz}, ymm/m256", "RM-DUP", "EVEX.256.F2.0F.W1 12 /r", "AVX512_F-VL"},
	{"vmovddup", "W:zmm {kz}, zmm/m512", "RM-DUP", "EVEX.512.F2.0F.W1 12 /r", "AVX512_F"},
	{"vmovdqa32", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F.W0 6F /r", "AVX512_F-VL"},
	{"vmovdqa32", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.66.0F.W0 7F /r", "AVX512_F-VL"},
	{"vmovdqa32", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F.W0 6F /r", "AVX512_F-VL"},
	{"vmovdqa32", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.66.0F.W0 7F /r", "AVX512_F-VL"},
	{"vmovdqa32", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F.W0 6F /r", "AVX512_F"},
	{"vmovdqa32", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.66.0F.W0 7F /r", "AVX512_F"},
	{"vmovdqa64", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F.W1 6F /r", "AVX512_F-VL"},
	{"vmovdqa64", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.66.0F.W1 7F /r", "AVX512_F-VL"},
	{"vmovdqa64", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F.W1 6F /r", "AVX512_F-VL"},
	{"vmovdqa64", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.66.0F.W1 7F /r", "AVX512_F-VL"},
	{"vmovdqa64", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F.W1 6F /r", "AVX512_F"},
	{"vmovdqa64", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.66.0F.W1 7F /r", "AVX512_F"},
	{"vmovdqu16", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.F2.0F.W1 6F /r", "AVX512_BW-VL"},
	{"vmovdqu16", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.F2.0F.W1 7F /r", "AVX512_BW-VL"},
	{"vmovdqu16", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.F2.0F.W1 6F /r", "AVX512_BW-VL"},
	{"vmovdqu16", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.F2.0F.W1 7F /r", "AVX512_BW-VL"},
	{"vmovdqu16", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.F2.0F.W1 6F /r", "AVX512_BW"},
	{"vmovdqu16", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.F2.0F.W1 7F /r", "AVX512_BW"},
	{"vmovdqu32", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.F3.0F.W0 6F /r", "AVX512_F-VL"},
	{"vmovdqu32", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.F3.0F.W0 7F /r", "AVX512_F-VL"},
	{"vmovdqu32", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.F3.0F.W0 6F /r", "AVX512_F-VL"},
	{"vmovdqu32", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.F3.0F.W0 7F /r", "AVX512_F-VL"},
	{"vmovdqu32", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.F3.0F.W0 6F /r", "AVX512_F"},
	{"vmovdqu32", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.F3.0F.W0 7F /r", "AVX512_F"},
	{"vmovdqu64", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.F3.0F.W1 6F /r", "AVX512_F-VL"},
	{"vmovdqu64", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.F3.0F.W1 7F /r", "AVX512_F-VL"},
	{"vmovdqu64", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.F3.0F.W1 6F /r", "AVX512_F-VL"},
	{"vmovdqu64", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.F3.0F.W1 7F /r", "AVX512_F-VL"},
	{"vmovdqu64", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.F3.0F.W1 6F /r", "AVX512_F"},
	{"vmovdqu64", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.F3.0F.W1 7F /r", "AVX512_F"},
	{"vmovdqu8", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.F2.0F.W0 6F /r", "AVX512_BW-VL"},
	{"vmovdqu8", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.F2.0F.W0 7F /r", "AVX512_BW-VL"},
	{"vmovdqu8", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.F2.0F.W0 6F /r", "AVX512_BW-VL"},
	{"vmovdqu8", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.F2.0F.W0 7F /r", "AVX512_BW-VL"},
	{"vmovdqu8", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.F2.0F.W0 6F /r", "AVX512_BW"},
	{"vmovdqu8", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.F2.0F.W0 7F /r", "AVX512_BW"},
	{"vmovhlps", "W:xmm, xmm{15:8}, xmm{15:8}", "RVM", "EVEX.NDS.128.0F.W0 12 /r", "AVX512_F"},
	{"vmovhpd", "W:m64, xmm{15:8}", "MR-T1S", "EVEX.128.66.0F.W1 17 /r", "AVX512_F"},
	{"vmovhpd", "W:xmm, xmm{7:0}, m64", "RVM-T1S", "EVEX.NDS.128.66.0F.W1 16 /r", "AVX512_F"},
	{"vmovhps", "W:m64, xmm{15:8}", "MR-T2", "EVEX.128.0F.W0 17 /r", "AVX512_F"},
	{"vmovhps", "W:xmm, xmm{7:0}, m64", "RVM-T2", "EVEX.NDS.128.0F.W0 16 /r", "AVX512_F"},
	{"vmovlhps", "W:xmm, xmm{7:0}, xmm{7:0}", "RVM", "EVEX.NDS.128.0F.W0 16 /r", "AVX512_F"},
	{"vmovlpd", "W:m64, xmm{7:0}", "MR-T1S", "EVEX.128.66.0F.W1 13 /r", "AVX512_F"},
	{"vmovlpd", "W:xmm, xmm{15:8}, m64", "RVM-T1S", "EVEX.NDS.128.66.0F.W1 12 /r", "AVX512_F"},
	{"vmovlps", "W:m64, xmm{7:0}", "MR-T2", "EVEX.128.0F.W0 13 /r", "AVX512_F"},
	{"vmovlps", "W:xmm, xmm{15:8}, m64", "RVM-T2", "EVEX.NDS.128.0F.W0 12 /r", "AVX512_F"},
	{"vmovntdq", "W:m128, xmm", "MR-FVM", "EVEX.128.66.0F.W0 E7 /r", "AVX512_F-VL"},
	{"vmovntdq", "W:m256, ymm", "MR-FVM", "EVEX.256.66.0F.W0 E7 /r", "AVX512_F-VL"},
	{"vmovntdq", "W:m512, zmm", "MR-FVM", "EVEX.512.66.0F.W0 E7 /r", "AVX512_F"},
	{"vmovntdqa", "W:xmm, m128", "RM-FVM", "EVEX.128.66.0F38.W0 2A /r", "AVX512_F-VL"},
	{"vmovntdqa", "W:ymm, m256", "RM-FVM", "EVEX.256.66.0F38.W0 2A /r", "AVX512_F-VL"},
	{"vmovntdqa", "W:zmm, m512", "RM-FVM", "EVEX.512.66.0F38.W0 2A /r", "AVX512_F"},
	{"vmovntpd", "W:m128, xmm", "MR-FVM", "EVEX.128.66.0F.W1 2B /r", "AVX512_F-VL"},
	{"vmovntpd", "W:m256, ymm", "MR-FVM", "EVEX.256.66.0F.W1 2B /r", "AVX512_F-VL"},
	{"vmovntpd", "W:m512, zmm", "MR-FVM", "EVEX.512.66.0F.W1 2B /r", "AVX512_F"},
	{"vmovntps", "W:m128, xmm", "MR-FVM", "EVEX.128.66.0F.W0 2B /r", "AVX512_F-VL"},
	{"vmovntps", "W:m256, ymm", "MR-FVM", "EVEX.256.66.0F.W0 2B /r", "AVX512_F-VL"},
	{"vmovntps", "W:m512, zmm", "MR-FVM", "EVEX.512.0F.W0 2B /r", "AVX512_F"},
	{"vmovq", "W:r64/m64, xmm{7:0}", "MR-T1S", "EVEX.128.66.0F.W1 7E /r", "AVX512_F X64"},
	{"vmovq", "W:xmm{7:0}, r64/m64", "RM-T1S", "EVEX.128.66.0F.W1 6E /r", "AVX512_F X64"},
	{"vmovq", "W:xmm{7:0}, xmm{7:0}/m64", "RM-T1S", "EVEX.128.F3.0F.W1 7E /r", "AVX512_F"},
	{"vmovq", "W:xmm{7:0}/m64, xmm{7:0}", "MR-T1S", "EVEX.128.66.0F.W1 D6 /r", "AVX512_F"},
	{"vmovsd", "W:m64, xmm{7:0}", "MR-T1S", "EVEX.LIG.F2.0F.W1 11 /r", "AVX512_F"},
	{"vmovsd", "W:xmm{7:0} {kz}, m64", "MR-T1S", "EVEX.LIG.F2.0F.W1 10 /r", "AVX512_F"},
	{"vmovsd", "W:xmm{7:0} {kz}, xmm{15:8}, xmm{7:0}", "MVR", "EVEX.NDS.LIG.F2.0F.W1 11 /r", "AVX512_F"},
	{"vmovsd", "W:xmm{7:0} {kz}, xmm{15:8}, xmm{7:0}", "RVM", "EVEX.NDS.LIG.F2.0F.W1 10 /r", "AVX512_F"},
	{"vmovshdup", "W:xmm {kz}, xmm/m128", "RVM-FVM", "EVEX.128.F3.0F.W0 16 /r", "AVX512_F-VL"},
	{"vmovshdup", "W:ymm {kz}, ymm/m256", "RVM-FVM", "EVEX.256.F3.0F.W0 16 /r", "AVX512_F-VL"},
	{"vmovshdup", "W:zmm {kz}, zmm/m512", "RVM-FVM", "EVEX.512.F3.0F.W0 16 /r", "AVX512_F"},
	{"vmovsldup", "W:xmm {kz}, xmm/m128", "RVM-FVM", "EVEX.128.F3.0F.W0 12 /r", "AVX512_F-VL"},
	{"vmovsldup", "W:ymm {kz}, ymm/m256", "RVM-FVM", "EVEX.256.F3.0F.W0 12 /r", "AVX512_F-VL"},
	{"vmovsldup", "W:zmm {kz}, zmm/m512", "RVM-FVM", "EVEX.512.F3.0F.W0 12 /r", "AVX512_F"},
	{"vmovss", "W:m32, xmm{3:0}", "MR-T1S", "EVEX.LIG.F3.0F.W0 11 /r", "AVX512_F"},
	{"vmovss", "W:xmm{3:0} {kz}, m32", "MR-T1S", "EVEX.LIG.F3.0F.W0 10 /r", "AVX512_F"},
	{"vmovss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}", "MVR", "EVEX.NDS.LIG.F3.0F.W0 11 /r", "AVX512_F"},
	{"vmovss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}", "RVM", "EVEX.NDS.LIG.F3.0F.W0 10 /r", "AVX512_F"},
	{"vmovupd", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F.W1 10 /r", "AVX512_F-VL"},
	{"vmovupd", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.66.0F.W1 11 /r", "AVX512_F-VL"},
	{"vmovupd", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F.W1 11 /r", "AVX512_F-VL"},
	{"vmovupd", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.66.0F.W1 10 /r", "AVX512_F-VL"},
	{"vmovupd", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F.W1 10 /r", "AVX512_F"},
	{"vmovupd", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.66.0F.W1 11 /r", "AVX512_F"},
	{"vmovups", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.0F.W0 10 /r", "AVX512_F-VL"},
	{"vmovups", "W:xmm/m128 {kz}, xmm", "MR-FVM", "EVEX.128.0F.W0 11 /r", "AVX512_F-VL"},
	{"vmovups", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.0F.W0 10 /r", "AVX512_F-VL"},
	{"vmovups", "W:ymm/m256 {kz}, ymm", "MR-FVM", "EVEX.256.0F.W0 11 /r", "AVX512_F-VL"},
	{"vmovups", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.0F.W0 10 /r", "AVX512_F"},
	{"vmovups", "W:zmm/m512 {kz}, zmm", "MR-FVM", "EVEX.512.0F.W0 11 /r", "AVX512_F"},
	{"vmulpd", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 59 /r", "AVX512_F-VL"},
	{"vmulpd", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 59 /r", "AVX512_F-VL"},
	{"vmulpd", "W:zmm {kz},~zmm,~zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F.W1 59 /r", "AVX512_F"},
	{"vmulps", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 59 /r", "AVX512_F-VL"},
	{"vmulps", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 59 /r", "AVX512_F-VL"},
	{"vmulps", "W:zmm {kz},~zmm,~zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.0F.W0 59 /r", "AVX512_F"},
	{"vmulsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 59 /r", "AVX512_F"},
	{"vmulss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 59 /r", "AVX512_F"},
	{"vorpd", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 56 /r", "AVX512_DQ-VL"},
	{"vorpd", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 56 /r", "AVX512_DQ-VL"},
	{"vorpd", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 56 /r", "AVX512_DQ"},
	{"vorps", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 56 /r", "AVX512_DQ-VL"},
	{"vorps", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 56 /r", "AVX512_DQ-VL"},
	{"vorps", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.0F.W0 56 /r", "AVX512_DQ"},
	{"vp4dpwssd", "W:zmm {kz}, zmm, zmm, zmm, zmm, m128", "RM-T1_4X", "EVEX.DDS.512.F2.0F38.W0 52 /r", "AVX512_4VNNIW"},
	{"vp4dpwssds", "W:zmm {kz}, zmm, zmm, zmm, zmm, m128", "RM-T1_4X", "EVEX.DDS.512.F2.0F38.W0 53 /r", "AVX512_4VNNIW"},
	{"vpabsb", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F38 1C /r", "AVX512_BW-VL"},
	{"vpabsb", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F38 1C /r", "AVX512_BW-VL"},
	{"vpabsb", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F38 1C /r", "AVX512_BW"},
	{"vpabsd", "W:xmm {kz}, xmm/m128", "RM-FV", "EVEX.128.66.0F38.W0 1E /r", "AVX512_F-VL"},
	{"vpabsd", "W:ymm {kz}, ymm/m256", "RM-FV", "EVEX.256.66.0F38.W0 1E /r", "AVX512_F-VL"},
	{"vpabsd", "W:zmm {kz}, zmm/m512", "RM-FV", "EVEX.512.66.0F38.W0 1E /r", "AVX512_F"},
	{"vpabsq", "W:xmm {kz}, xmm/m128", "RM-FV", "EVEX.128.66.0F38.W1 1F /r", "AVX512_F-VL"},
	{"vpabsq", "W:ymm {kz}, ymm/m256", "RM-FV", "EVEX.256.66.0F38.W1 1F /r", "AVX512_F-VL"},
	{"vpabsq", "W:zmm {kz}, zmm/m512", "RM-FV", "EVEX.512.66.0F38.W1 1F /r", "AVX512_F"},
	{"vpabsw", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F38 1D /r", "AVX512_BW-VL"},
	{"vpabsw", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F38 1D /r", "AVX512_BW-VL"},
	{"vpabsw", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F38 1D /r", "AVX512_BW"},
	{"vpackssdw", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F.W0 6B /r", "AVX512_BW-VL"},
	{"vpackssdw", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F.W0 6B /r", "AVX512_BW-VL"},
	{"vpackssdw", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F.W0 6B /r", "AVX512_BW"},
	{"vpacksswb", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG 63 /r", "AVX512_BW-VL"},
	{"vpacksswb", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG 63 /r", "AVX512_BW-VL"},
	{"vpacksswb", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG 63 /r", "AVX512_BW"},
	{"vpackusdw", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 2B /r", "AVX512_BW-VL"},
	{"vpackusdw", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 2B /r", "AVX512_BW-VL"},
	{"vpackusdw", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 2B /r", "AVX512_BW"},
	{"vpackuswb", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG 67 /r", "AVX512_BW-VL"},
	{"vpackuswb", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG 67 /r", "AVX512_BW-VL"},
	{"vpackuswb", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG 67 /r", "AVX512_BW"},
	{"vpaddb", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG FC /r", "AVX512_BW-VL"},
	{"vpaddb", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG FC /r", "AVX512_BW-VL"},
	{"vpaddb", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG FC /r", "AVX512_BW"},
	{"vpaddd", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F.W0 FE /r", "AVX512_F-VL"},
	{"vpaddd", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F.W0 FE /r", "AVX512_F-VL"},
	{"vpaddd", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F.W0 FE /r", "AVX512_F"},
	{"vpaddq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 D4 /r", "AVX512_F-VL"},
	{"vpaddq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 D4 /r", "AVX512_F-VL"},
	{"vpaddq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 D4 /r", "AVX512_F"},
	{"vpaddsb", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG EC /r", "AVX512_BW-VL"},
	{"vpaddsb", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG EC /r", "AVX512_BW-VL"},
	{"vpaddsb", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG EC /r", "AVX512_BW"},
	{"vpaddsw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG ED /r", "AVX512_BW-VL"},
	{"vpaddsw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG ED /r", "AVX512_BW-VL"},
	{"vpaddsw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG ED /r", "AVX512_BW"},
	{"vpaddusb", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG DC /r", "AVX512_BW-VL"},
	{"vpaddusb", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG DC /r", "AVX512_BW-VL"},
	{"vpaddusb", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG DC /r", "AVX512_BW"},
	{"vpaddusw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG DD /r", "AVX512_BW-VL"},
	{"vpaddusw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG DD /r", "AVX512_BW-VL"},
	{"vpaddusw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG DD /r", "AVX512_BW"},
	{"vpaddw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG FD /r", "AVX512_BW-VL"},
	{"vpaddw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG FD /r", "AVX512_BW-VL"},
	{"vpaddw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG FD /r", "AVX512_BW"},
	{"vpalignr", "W:xmm {kz}, xmm, xmm/m128, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.WIG 0F /r ib", "AVX512_BW-VL"},
	{"vpalignr", "W:ymm {kz}, ymm, ymm/m256, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.WIG 0F /r ib", "AVX512_BW-VL"},
	{"vpalignr", "W:zmm {kz}, zmm, zmm/m512, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.WIG 0F /r ib", "AVX512_BW"},
	{"vpandd", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F.W0 DB /r", "AVX512_F-VL"},
	{"vpandd", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F.W0 DB /r", "AVX512_F-VL"},
	{"vpandd", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F.W0 DB /r", "AVX512_F"},
	{"vpandnd", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F.W0 DF /r", "AVX512_F-VL"},
	{"vpandnd", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F.W0 DF /r", "AVX512_F-VL"},
	{"vpandnd", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F.W0 DF /r", "AVX512_F"},
	{"vpandnq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 DF /r", "AVX512_F-VL"},
	{"vpandnq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 DF /r", "AVX512_F-VL"},
	{"vpandnq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 DF /r", "AVX512_F"},
	{"vpandq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 DB /r", "AVX512_F-VL"},
	{"vpandq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 DB /r", "AVX512_F-VL"},
	{"vpandq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 DB /r", "AVX512_F"},
	{"vpavgb", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG E0 /r", "AVX512_BW-VL"},
	{"vpavgb", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG E0 /r", "AVX512_BW-VL"},
	{"vpavgb", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG E0 /r", "AVX512_BW"},
	{"vpavgw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG E3 /r", "AVX512_BW-VL"},
	{"vpavgw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG E3 /r", "AVX512_BW-VL"},
	{"vpavgw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG E3 /r", "AVX512_BW"},
	{"vpbroadcastb", "W:xmm {kz}, r32{0}", "RM-T1S", "EVEX.128.66.0F38.W0 7A /r", "AVX512_BW-VL"},
	{"vpbroadcastb", "W:xmm {kz}, r64{0}", "RM-T1S", "EVEX.128.66.0F38.W0 7A /r", "AVX512_BW-VL X64"},
	{"vpbroadcastb", "W:xmm {kz}, xmm{0}/m8", "RM-T1S", "EVEX.128.66.0F38.W0 78 /r", "AVX512_BW-VL"},
	{"vpbroadcastb", "W:ymm {kz}, r32{0}", "RM-T1S", "EVEX.256.66.0F38.W0 7A /r", "AVX512_BW-VL"},
	{"vpbroadcastb", "W:ymm {kz}, r64{0}", "RM-T1S", "EVEX.256.66.0F38.W0 7A /r", "AVX512_BW-VL X64"},
	{"vpbroadcastb", "W:ymm {kz}, xmm{0}/m8", "RM-T1S", "EVEX.256.66.0F38.W0 78 /r", "AVX512_BW-VL"},
	{"vpbroadcastb", "W:zmm {kz}, r32{0}", "RM-T1S", "EVEX.512.66.0F38.W0 7A /r", "AVX512_BW"},
	{"vpbroadcastb", "W:zmm {kz}, r64{0}", "RM-T1S", "EVEX.512.66.0F38.W0 7A /r", "AVX512_BW X64"},
	{"vpbroadcastb", "W:zmm {kz}, xmm{0}/m8", "RM-T1S", "EVEX.512.66.0F38.W0 78 /r", "AVX512_BW"},
	{"vpbroadcastd", "W:xmm {kz}, r32{3:0}", "RM-T1S", "EVEX.128.66.0F38.W0 7C /r", "AVX512_F-VL"},
	{"vpbroadcastd", "W:xmm {kz}, r64{3:0}", "RM-T1S", "EVEX.128.66.0F38.W0 7C /r", "AVX512_F-VL X64"},
	{"vpbroadcastd", "W:xmm {kz}, xmm{3:0}/m32", "RM-T1S", "EVEX.128.66.0F38.W0 58 /r", "AVX512_F-VL"},
	{"vpbroadcastd", "W:ymm {kz}, r32{3:0}", "RM-T1S", "EVEX.256.66.0F38.W0 7C /r", "AVX512_F-VL"},
	{"vpbroadcastd", "W:ymm {kz}, r64{3:0}", "RM-T1S", "EVEX.256.66.0F38.W0 7C /r", "AVX512_F-VL X64"},
	{"vpbroadcastd", "W:ymm {kz}, xmm{3:0}/m32", "RM-T1S", "EVEX.256.66.0F38.W0 58 /r", "AVX512_F-VL"},
	{"vpbroadcastd", "W:zmm {kz}, r32{3:0}", "RM-T1S", "EVEX.512.66.0F38.W0 7C /r", "AVX512_F"},
	{"vpbroadcastd", "W:zmm {kz}, r64{3:0}", "RM-T1S", "EVEX.512.66.0F38.W0 7C /r", "AVX512_F X64"},
	{"vpbroadcastd", "W:zmm {kz}, xmm{3:0}/m32", "RM-T1S", "EVEX.512.66.0F38.W0 58 /r", "AVX512_F"},
	{"vpbroadcastmb2d", "W:xmm, k", "RM", "EVEX.128.F3.0F38.W0 3A /r", "AVX512_CDI-VL"},
	{"vpbroadcastmb2d", "W:ymm, k", "RM", "EVEX.256.F3.0F38.W0 3A /r", "AVX512_CDI-VL"},
	{"vpbroadcastmb2d", "W:zmm, k", "RM", "EVEX.512.F3.0F38.W0 3A /r", "AVX512_CDI"},
	{"vpbroadcastmb2q", "W:xmm, k", "RM", "EVEX.128.F3.0F38.W1 2A /r", "AVX512_CDI-VL"},
	{"vpbroadcastmb2q", "W:ymm, k", "RM", "EVEX.256.F3.0F38.W1 2A /r", "AVX512_CDI-VL"},
	{"vpbroadcastmb2q", "W:zmm, k", "RM", "EVEX.512.F3.0F38.W1 2A /r", "AVX512_CDI"},
	{"vpbroadcastq", "W:xmm {kz}, r64{7:0}", "RM-T1S", "EVEX.128.66.0F38.W1 7C /r", "AVX512_F-VL X64"},
	{"vpbroadcastq", "W:xmm {kz}, xmm{7:0}/m64", "RM-T1S", "EVEX.128.66.0F38.W1 59 /r", "AVX512_F-VL"},
	{"vpbroadcastq", "W:ymm {kz}, r64{7:0}", "RM-T1S", "EVEX.256.66.0F38.W1 7C /r", "AVX512_F-VL X64"},
	{"vpbroadcastq", "W:ymm {kz}, xmm{7:0}/m64", "RM-T1S", "EVEX.256.66.0F38.W1 59 /r", "AVX512_F-VL"},
	{"vpbroadcastq", "W:zmm {kz}, r64{7:0}", "RM-T1S", "EVEX.512.66.0F38.W1 7C /r", "AVX512_F X64"},
	{"vpbroadcastq", "W:zmm {kz}, xmm{7:0}/m64", "RM-T1S", "EVEX.512.66.0F38.W1 59 /r", "AVX512_F"},
	{"vpbroadcastw", "W:xmm {kz}, r32{1:0}", "RM-T1S", "EVEX.128.66.0F38.W0 7B /r", "AVX512_BW-VL"},
	{"vpbroadcastw", "W:xmm {kz}, r64{1:0}", "RM-T1S", "EVEX.128.66.0F38.W0 7B /r", "AVX512_BW-VL X64"},
	{"vpbroadcastw", "W:xmm {kz}, xmm{1:0}/m16", "RM-T1S", "EVEX.128.66.0F38.W0 79 /r", "AVX512_BW-VL"},
	{"vpbroadcastw", "W:ymm {kz}, r32{1:0}", "RM-T1S", "EVEX.256.66.0F38.W0 7B /r", "AVX512_BW-VL"},
	{"vpbroadcastw", "W:ymm {kz}, r64{1:0}", "RM-T1S", "EVEX.256.66.0F38.W0 7B /r", "AVX512_BW-VL X64"},
	{"vpbroadcastw", "W:ymm {kz}, xmm{1:0}/m16", "RM-T1S", "EVEX.256.66.0F38.W0 79 /r", "AVX512_BW-VL"},
	{"vpbroadcastw", "W:zmm {kz}, r32{1:0}", "RM-T1S", "EVEX.512.66.0F38.W0 7B /r", "AVX512_BW"},
	{"vpbroadcastw", "W:zmm {kz}, r64{1:0}", "RM-T1S", "EVEX.512.66.0F38.W0 7B /r", "AVX512_BW X64"},
	{"vpbroadcastw", "W:zmm {kz}, xmm{1:0}/m16", "RM-T1S", "EVEX.512.66.0F38.W0 79 /r", "AVX512_BW"},
	{"vpclmulqdq", "W:xmm, xmm, xmm/m128, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.WIG 44 /r ib", "AVX512_F-VL VPCLMULQDQ"},
	{"vpclmulqdq", "W:ymm, ymm, ymm/m256, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.WIG 44 /r ib", "AVX512_F-VL VPCLMULQDQ"},
	{"vpclmulqdq", "W:zmm, zmm, zmm/m512, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.WIG 44 /r ib", "AVX512_FVPCLMULQDQ"},
	{"vpcmpb", "W:k {k}, xmm, xmm/m128, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W0 3F /r ib", "AVX512_BW-VL"},
	{"vpcmpb", "W:k {k}, ymm, ymm/m256, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W0 3F /r ib", "AVX512_BW-VL"},
	{"vpcmpb", "W:k {k}, zmm, zmm/m512, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W0 3F /r ib", "AVX512_BW"},
	{"vpcmpd", "W:k {k}, xmm, xmm/m128/b32, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W0 1F /r ib", "AVX512_F-VL"},
	{"vpcmpd", "W:k {k}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W0 1F /r ib", "AVX512_F-VL"},
	{"vpcmpd", "W:k {k}, zmm, zmm/m512/b32, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W0 1F /r ib", "AVX512_F"},
	{"vpcmpeqb", "W:k {k},~xmm,~xmm/m128", "RVM-FV", "EVEX.NDS.128.66.0F.WIG 74 /r", "AVX512_BW-VL"},
	{"vpcmpeqb", "W:k {k},~ymm,~ymm/m256", "RVM-FV", "EVEX.NDS.256.66.0F.WIG 74 /r", "AVX512_BW-VL"},
	{"vpcmpeqb", "W:k {k},~zmm,~zmm/m512", "RVM-FV", "EVEX.NDS.512.66.0F.WIG 74 /r", "AVX512_BW"},
	{"vpcmpeqd", "W:k {k},~xmm,~xmm/m128/b32", "RVM-FVM", "EVEX.NDS.128.66.0F.W0 76 /r", "AVX512_F-VL"},
	{"vpcmpeqd", "W:k {k},~ymm,~ymm/m256/b32", "RVM-FVM", "EVEX.NDS.256.66.0F.W0 76 /r", "AVX512_F-VL"},
	{"vpcmpeqd", "W:k {k},~zmm,~zmm/m512/b32", "RVM-FVM", "EVEX.NDS.512.66.0F.W0 76 /r", "AVX512_F"},
	{"vpcmpeqq", "W:k {k},~xmm,~xmm/m128/b64", "RVM-FVM", "EVEX.NDS.128.66.0F38.W1 29 /r", "AVX512_F-VL"},
	{"vpcmpeqq", "W:k {k},~ymm,~ymm/m256/b64", "RVM-FVM", "EVEX.NDS.256.66.0F38.W1 29 /r", "AVX512_F-VL"},
	{"vpcmpeqq", "W:k {k},~zmm,~zmm/m512/b64", "RVM-FVM", "EVEX.NDS.512.66.0F38.W1 29 /r", "AVX512_F"},
	{"vpcmpeqw", "W:k {k},~xmm,~xmm/m128", "RVM-FV", "EVEX.NDS.128.66.0F.WIG 75 /r", "AVX512_BW-VL"},
	{"vpcmpeqw", "W:k {k},~ymm,~ymm/m256", "RVM-FV", "EVEX.NDS.256.66.0F.WIG 75 /r", "AVX512_BW-VL"},
	{"vpcmpeqw", "W:k {k},~zmm,~zmm/m512", "RVM-FV", "EVEX.NDS.512.66.0F.WIG 75 /r", "AVX512_BW"},
	{"vpcmpgtb", "W:k {k}, xmm, xmm/m128", "RVM-FV", "EVEX.NDS.128.66.0F.WIG 64 /r", "AVX512_BW-VL"},
	{"vpcmpgtb", "W:k {k}, ymm, ymm/m256", "RVM-FV", "EVEX.NDS.256.66.0F.WIG 64 /r", "AVX512_BW-VL"},
	{"vpcmpgtb", "W:k {k}, zmm, zmm/m512", "RVM-FV", "EVEX.NDS.512.66.0F.WIG 64 /r", "AVX512_BW"},
	{"vpcmpgtd", "W:k {k}, xmm, xmm/m128/b32", "RVM-FVM", "EVEX.NDS.128.66.0F.W0 66 /r", "AVX512_F-VL"},
	{"vpcmpgtd", "W:k {k}, ymm, ymm/m256/b32", "RVM-FVM", "EVEX.NDS.256.66.0F.W0 66 /r", "AVX512_F-VL"},
	{"vpcmpgtd", "W:k {k}, zmm, zmm/m512/b32", "RVM-FVM", "EVEX.NDS.512.66.0F.W0 66 /r", "AVX512_F"},
	{"vpcmpgtq", "W:k {k}, xmm, xmm/m128/b64", "RVM-FVM", "EVEX.NDS.128.66.0F38.W1 37 /r", "AVX512_F-VL"},
	{"vpcmpgtq", "W:k {k}, ymm, ymm/m256/b64", "RVM-FVM", "EVEX.NDS.256.66.0F38.W1 37 /r", "AVX512_F-VL"},
	{"vpcmpgtq", "W:k {k}, zmm, zmm/m512/b64", "RVM-FVM", "EVEX.NDS.512.66.0F38.W1 37 /r", "AVX512_F"},
	{"vpcmpgtw", "W:k {k}, xmm, xmm/m128", "RVM-FV", "EVEX.NDS.128.66.0F.WIG 65 /r", "AVX512_BW-VL"},
	{"vpcmpgtw", "W:k {k}, ymm, ymm/m256", "RVM-FV", "EVEX.NDS.256.66.0F.WIG 65 /r", "AVX512_BW-VL"},
	{"vpcmpgtw", "W:k {k}, zmm, zmm/m512", "RVM-FV", "EVEX.NDS.512.66.0F.WIG 65 /r", "AVX512_BW"},
	{"vpcmpq", "W:k {k}, xmm, xmm/m128/b64, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W1 1F /r ib", "AVX512_F-VL"},
	{"vpcmpq", "W:k {k}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W1 1F /r ib", "AVX512_F-VL"},
	{"vpcmpq", "W:k {k}, zmm, zmm/m512/b64, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W1 1F /r ib", "AVX512_F"},
	{"vpcmpub", "W:k {k}, xmm, xmm/m128, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W0 3E /r ib", "AVX512_BW-VL"},
	{"vpcmpub", "W:k {k}, ymm, ymm/m256, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W0 3E /r ib", "AVX512_BW-VL"},
	{"vpcmpub", "W:k {k}, zmm, zmm/m512, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W0 3E /r ib", "AVX512_BW"},
	{"vpcmpud", "W:k {k}, xmm, xmm/m128/b32, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W0 1E /r ib", "AVX512_F-VL"},
	{"vpcmpud", "W:k {k}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W0 1E /r ib", "AVX512_F-VL"},
	{"vpcmpud", "W:k {k}, zmm, zmm/m512/b32, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W0 1E /r ib", "AVX512_F"},
	{"vpcmpuq", "W:k {k}, xmm, xmm/m128/b64, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W1 1E /r ib", "AVX512_F-VL"},
	{"vpcmpuq", "W:k {k}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W1 1E /r ib", "AVX512_F-VL"},
	{"vpcmpuq", "W:k {k}, zmm, zmm/m512/b64, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W1 1E /r ib", "AVX512_F"},
	{"vpcmpuw", "W:k {k}, xmm, xmm/m128/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W1 3E /r ib", "AVX512_BW-VL"},
	{"vpcmpuw", "W:k {k}, ymm, ymm/m256/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W1 3E /r ib", "AVX512_BW-VL"},
	{"vpcmpuw", "W:k {k}, zmm, zmm/m512/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W1 3E /r ib", "AVX512_BW"},
	{"vpcmpw", "W:k {k}, xmm, xmm/m128/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W1 3F /r ib", "AVX512_BW-VL"},
	{"vpcmpw", "W:k {k}, ymm, ymm/m256/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W1 3F /r ib", "AVX512_BW-VL"},
	{"vpcmpw", "W:k {k}, zmm, zmm/m512/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W1 3F /r ib", "AVX512_BW"},
	{"vpcompressb", "W:xmm/m128 {kz}, xmm", "RVM-T1S", "EVEX.128.66.0F38.W0 63 /r", "AVX512_VBMI2-VL"},
	{"vpcompressb", "W:ymm/m256 {kz}, ymm", "RVM-T1S", "EVEX.256.66.0F38.W0 63 /r", "AVX512_VBMI2-VL"},
	{"vpcompressb", "W:zmm/m512 {kz}, zmm", "RVM-T1S", "EVEX.512.66.0F38.W0 63 /r", "AVX512_VBMI2"},
	{"vpcompressw", "W:xmm/m128 {kz}, xmm", "RVM-T1S", "EVEX.128.66.0F38.W1 63 /r", "AVX512_VBMI2-VL"},
	{"vpcompressw", "W:ymm/m256 {kz}, ymm", "RVM-T1S", "EVEX.256.66.0F38.W1 63 /r", "AVX512_VBMI2-VL"},
	{"vpcompressw", "W:zmm/m512 {kz}, zmm", "RVM-T1S", "EVEX.512.66.0F38.W1 63 /r", "AVX512_VBMI2"},
	{"vpcompressd", "W:xmm/m128 {kz}, xmm", "MR-T1S", "EVEX.128.66.0F38.W0 8B /r", "AVX512_F-VL"},
	{"vpcompressd", "W:ymm/m256 {kz}, ymm", "MR-T1S", "EVEX.256.66.0F38.W0 8B /r", "AVX512_F-VL"},
	{"vpcompressd", "W:zmm/m512 {kz}, zmm", "MR-T1S", "EVEX.512.66.0F38.W0 8B /r", "AVX512_F"},
	{"vpcompressq", "W:xmm/m128 {kz}, xmm", "MR-T1S", "EVEX.128.66.0F38.W1 8B /r", "AVX512_F-VL"},
	{"vpcompressq", "W:ymm/m256 {kz}, ymm", "MR-T1S", "EVEX.256.66.0F38.W1 8B /r", "AVX512_F-VL"},
	{"vpcompressq", "W:zmm/m512 {kz}, zmm", "MR-T1S", "EVEX.512.66.0F38.W1 8B /r", "AVX512_F"},
	{"vpconflictd", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.66.0F38.W0 C4 /r", "AVX512_CDI-VL"},
	{"vpconflictd", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.66.0F38.W0 C4 /r", "AVX512_CDI-VL"},
	{"vpconflictd", "W:zmm {kz}, zmm/m512/b32", "RM-FV", "EVEX.512.66.0F38.W0 C4 /r", "AVX512_CDI"},
	{"vpconflictq", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.66.0F38.W1 C4 /r", "AVX512_CDI-VL"},
	{"vpconflictq", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.66.0F38.W1 C4 /r", "AVX512_CDI-VL"},
	{"vpconflictq", "W:zmm {kz}, zmm/m512/b32", "RM-FV", "EVEX.512.66.0F38.W1 C4 /r", "AVX512_CDI"},
	{"vpdpwssd", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 52 /r", "AVX512_VNNI-VL"},
	{"vpdpwssd", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 52 /r", "AVX512_VNNI-VL"},
	{"vpdpwssd", "X:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 52 /r", "AVX512_VNNI"},
	{"vpdpwssds", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 53 /r", "AVX512_VNNI-VL"},
	{"vpdpwssds", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 53 /r", "AVX512_VNNI-VL"},
	{"vpdpwssds", "X:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 53 /r", "AVX512_VNNI"},
	{"vpdpbusd", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 50 /r", "AVX512_VNNI-VL"},
	{"vpdpbusd", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 50 /r", "AVX512_VNNI-VL"},
	{"vpdpbusd", "X:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 50 /r", "AVX512_VNNI"},
	{"vpdpbusds", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 51 /r", "AVX512_VNNI-VL"},
	{"vpdpbusds", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 51 /r", "AVX512_VNNI-VL"},
	{"vpdpbusds", "X:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 51 /r", "AVX512_VNNI"},
	{"vpexpandb", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F38.W0 62 /r", "AVX512_VBMI2-VL"},
	{"vpexpandb", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F38.W0 62 /r", "AVX512_VBMI2-VL"},
	{"vpexpandb", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F38.W0 62 /r", "AVX512_VBMI2"},
	{"vpexpandw", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F38.W1 62 /r", "AVX512_VBMI2-VL"},
	{"vpexpandw", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F38.W1 62 /r", "AVX512_VBMI2-VL"},
	{"vpexpandw", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F38.W1 62 /r", "AVX512_VBMI2"},
	{"vpermb", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W0 8D /r", "AVX512_VBMI-VL"},
	{"vpermb", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W0 8D /r", "AVX512_VBMI-VL"},
	{"vpermb", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W0 8D /r", "AVX512_VBMI"},
	{"vpermd", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 36 /r", "AVX512_F-VL"},
	{"vpermd", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 36 /r", "AVX512_F"},
	{"vpermi2b", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.DDS.128.66.0F38.W0 75 /r", "AVX512_VBMI-VL"},
	{"vpermi2b", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W0 75 /r", "AVX512_VBMI-VL"},
	{"vpermi2b", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W0 75 /r", "AVX512_VBMI"},
	{"vpermi2d", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 76 /r", "AVX512_F-VL"},
	{"vpermi2d", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 76 /r", "AVX512_F-VL"},
	{"vpermi2d", "X:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 76 /r", "AVX512_F"},
	{"vpermi2pd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 77 /r", "AVX512_F-VL"},
	{"vpermi2pd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 77 /r", "AVX512_F-VL"},
	{"vpermi2pd", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 77 /r", "AVX512_F"},
	{"vpermi2ps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 77 /r", "AVX512_F-VL"},
	{"vpermi2ps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 77 /r", "AVX512_F-VL"},
	{"vpermi2ps", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 77 /r", "AVX512_F"},
	{"vpermi2q", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 76 /r", "AVX512_F-VL"},
	{"vpermi2q", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 76 /r", "AVX512_F-VL"},
	{"vpermi2q", "X:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 76 /r", "AVX512_F"},
	{"vpermi2w", "X:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.DDS.128.66.0F38.W1 75 /r", "AVX512_BW-VL"},
	{"vpermi2w", "X:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.DDS.256.66.0F38.W1 75 /r", "AVX512_BW-VL"},
	{"vpermi2w", "X:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.DDS.512.66.0F38.W1 75 /r", "AVX512_BW"},
	{"vpermilpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 0D /r", "AVX512_F-VL"},
	{"vpermilpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 0D /r", "AVX512_F-VL"},
	{"vpermilpd", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 0D /r", "AVX512_F"},
	{"vpermilpd", "W:xmm {kz}, xmm/m128/b64, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W1 05 /r ib", "AVX512_F-VL"},
	{"vpermilpd", "W:ymm {kz}, ymm/m256/b64, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W1 05 /r ib", "AVX512_F-VL"},
	{"vpermilpd", "W:zmm {kz}, zmm/m512/b64, ib/ub", "RMI-FV", "EVEX.512.66.0F3A.W1 05 /r ib", "AVX512_F"},
	{"vpermilps", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 0C /r", "AVX512_F-VL"},
	{"vpermilps", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 0C /r", "AVX512_F-VL"},
	{"vpermilps", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 0C /r", "AVX512_F"},
	{"vpermilps", "W:xmm {kz}, xmm/m128/b64, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W0 04 /r ib", "AVX512_F-VL"},
	{"vpermilps", "W:ymm {kz}, ymm/m256/b64, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W0 04 /r ib", "AVX512_F-VL"},
	{"vpermilps", "W:zmm {kz}, zmm/m512/b64, ib/ub", "RMI-FV", "EVEX.512.66.0F3A.W0 04 /r ib", "AVX512_F"},
	{"vpermq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 36 /r", "AVX512_F-VL"},
	{"vpermq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 36 /r", "AVX512_F"},
	{"vpermq", "W:ymm {kz}, ymm/m256/b64, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W1 00 /r ib", "AVX512_F-VL"},
	{"vpermq", "W:zmm {kz}, zmm/m512/b64, ib/ub", "RMI-FV", "EVEX.512.66.0F3A.W1 00 /r ib", "AVX512_F"},
	{"vpermt2b", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.DDS.128.66.0F38.W0 7D /r", "AVX512_VBMI-VL"},
	{"vpermt2b", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W0 7D /r", "AVX512_VBMI-VL"},
	{"vpermt2b", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W0 7D /r", "AVX512_VBMI"},
	{"vpermt2d", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 7E /r", "AVX512_F-VL"},
	{"vpermt2d", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 7E /r", "AVX512_F-VL"},
	{"vpermt2d", "X:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 7E /r", "AVX512_F"},
	{"vpermt2pd", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 7F /r", "AVX512_F-VL"},
	{"vpermt2pd", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 7F /r", "AVX512_F-VL"},
	{"vpermt2pd", "X:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 7F /r", "AVX512_F"},
	{"vpermt2ps", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.DDS.128.66.0F38.W0 7F /r", "AVX512_F-VL"},
	{"vpermt2ps", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.DDS.256.66.0F38.W0 7F /r", "AVX512_F-VL"},
	{"vpermt2ps", "X:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.DDS.512.66.0F38.W0 7F /r", "AVX512_F"},
	{"vpermt2q", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 7E /r", "AVX512_F-VL"},
	{"vpermt2q", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 7E /r", "AVX512_F-VL"},
	{"vpermt2q", "X:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 7E /r", "AVX512_F"},
	{"vpermt2w", "X:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.DDS.128.66.0F38.W1 7D /r", "AVX512_BW-VL"},
	{"vpermt2w", "X:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.DDS.256.66.0F38.W1 7D /r", "AVX512_BW-VL"},
	{"vpermt2w", "X:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.DDS.512.66.0F38.W1 7D /r", "AVX512_BW"},
	{"vpermw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W1 8D /r", "AVX512_BW-VL"},
	{"vpermw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W1 8D /r", "AVX512_BW-VL"},
	{"vpermw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W1 8D /r", "AVX512_BW"},
	{"vpexpandd", "W:xmm {kz}, xmm/m128", "RM-T1S", "EVEX.128.66.0F38.W0 89 /r", "AVX512_F-VL"},
	{"vpexpandd", "W:ymm {kz}, ymm/m256", "RM-T1S", "EVEX.256.66.0F38.W0 89 /r", "AVX512_F-VL"},
	{"vpexpandd", "W:zmm {kz}, zmm/m512", "RM-T1S", "EVEX.512.66.0F38.W0 89 /r", "AVX512_F"},
	{"vpexpandq", "W:xmm {kz}, xmm/m128", "RM-T1S", "EVEX.128.66.0F38.W1 89 /r", "AVX512_F-VL"},
	{"vpexpandq", "W:ymm {kz}, ymm/m256", "RM-T1S", "EVEX.256.66.0F38.W1 89 /r", "AVX512_F-VL"},
	{"vpexpandq", "W:zmm {kz}, zmm/m512", "RM-T1S", "EVEX.512.66.0F38.W1 89 /r", "AVX512_F"},
	{"vpextrb", "W:r32{0}/m8, xmm, ib/ub", "MRI-T1S", "EVEX.128.66.0F3A.WIG 14 /r ib", "AVX512_BW"},
	{"vpextrb", "W:r64{0}, xmm, ib/ub", "MRI", "EVEX.128.66.0F3A.WIG 14 /r ib", "AVX512_BW X64"},
	{"vpextrd", "W:r32{3:0}/m32, xmm, ib/ub", "MRI-T1S", "EVEX.128.66.0F3A.W0 16 /r ib", "AVX512_DQ"},
	{"vpextrd", "W:r64{3:0}, xmm, ib/ub", "MRI", "EVEX.128.66.0F3A.W0 16 /r ib", "AVX512_DQ X64"},
	{"vpextrq", "W:r64/m64, xmm, ib/ub", "MRI-T1S", "EVEX.128.66.0F3A.W1 16 /r ib", "AVX512_DQ X64"},
	{"vpextrw", "W:r32{1:0}, xmm, ib/ub", "RMI", "EVEX.128.66.0F.WIG C5 /r ib", "AVX512_BW"},
	{"vpextrw", "W:r64{1:0}, xmm, ib/ub", "RMI", "EVEX.128.66.0F.WIG C5 /r ib", "AVX512_BW X64"},
	{"vpextrw", "W:r32{1:0}/m16, xmm, ib/ub", "MRI-T1S", "EVEX.128.66.0F3A.WIG 15 /r ib", "AVX512_BW"},
	{"vpextrw", "W:r64{1:0}, xmm, ib/ub", "MRI", "EVEX.128.66.0F3A.WIG 15 /r ib", "AVX512_BW X64"},
	{"vpgatherdd", "X:xmm {k}, vm32x", "RM-T1S", "EVEX.128.66.0F38.W0 90", "AVX512_F-VL"},
	{"vpgatherdd", "X:ymm {k}, vm32y", "RM-T1S", "EVEX.256.66.0F38.W0 90", "AVX512_F-VL"},
	{"vpgatherdd", "X:zmm {k}, vm32z", "RM-T1S", "EVEX.512.66.0F38.W0 90", "AVX512_F"},
	{"vpgatherdq", "X:xmm {k}, vm32x", "RM-T1S", "EVEX.128.66.0F38.W1 90", "AVX512_F-VL"},
	{"vpgatherdq", "X:ymm {k}, vm32y", "RM-T1S", "EVEX.256.66.0F38.W1 90", "AVX512_F-VL"},
	{"vpgatherdq", "X:zmm {k}, vm32z", "RM-T1S", "EVEX.512.66.0F38.W1 90", "AVX512_F"},
	{"vpgatherqd", "X:xmm {k}, vm64x", "RM-T1S", "EVEX.128.66.0F38.W0 91", "AVX512_F-VL"},
	{"vpgatherqd", "X:ymm {k}, vm64y", "RM-T1S", "EVEX.256.66.0F38.W0 91", "AVX512_F-VL"},
	{"vpgatherqd", "X:zmm {k}, vm64z", "RM-T1S", "EVEX.512.66.0F38.W0 91", "AVX512_F"},
	{"vpgatherqq", "X:xmm {k}, vm64x", "RM-T1S", "EVEX.128.66.0F38.W1 91", "AVX512_F-VL"},
	{"vpgatherqq", "X:ymm {k}, vm64y", "RM-T1S", "EVEX.256.66.0F38.W1 91", "AVX512_F-VL"},
	{"vpgatherqq", "X:zmm {k}, vm64z", "RM-T1S", "EVEX.512.66.0F38.W1 91", "AVX512_F"},
	{"vpinsrb", "W:xmm {kz}, xmm, r32{0}/m8, ib/ub", "RVMI-T1S", "EVEX.NDS.128.66.0F3A.WIG 20 /r ib", "AVX512_BW"},
	{"vpinsrb", "W:xmm {kz}, xmm, r64{0}, ib/ub", "RVMI", "EVEX.NDS.128.66.0F3A.WIG 20 /r ib", "AVX512_BW X64"},
	{"vpinsrd", "W:xmm {kz}, xmm, r32{3:0}/m32, ib/ub", "RVMI-T1S", "EVEX.NDS.128.66.0F3A.W0 22 /r ib", "AVX512_DQ"},
	{"vpinsrd", "W:xmm {kz}, xmm, r64{3:0}, ib/ub", "RVMI", "EVEX.NDS.128.66.0F3A.W0 22 /r ib", "AVX512_DQ X64"},
	{"vpinsrq", "W:xmm {kz}, xmm, r64{7:0}/m64, ib/ub", "RVMI-T1S", "EVEX.NDS.128.66.0F3A.W1 22 /r ib", "AVX512_DQ X64"},
	{"vpinsrw", "W:xmm {kz}, xmm, r32{1:0}/m16, ib/ub", "RVMI-T1S", "EVEX.NDS.128.66.0F.WIG C4 /r ib", "AVX512_BW"},
	{"vpinsrw", "W:xmm {kz}, xmm, r64{1:0}, ib/ub", "RVMI", "EVEX.NDS.128.66.0F.WIG C4 /r ib", "AVX512_BW X64"},
	{"vplzcntd", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.66.0F38.W0 44 /r", "AVX512_CDI-VL"},
	{"vplzcntd", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.66.0F38.W0 44 /r", "AVX512_CDI-VL"},
	{"vplzcntd", "W:zmm {kz}, zmm/m512/b32", "RM-FV", "EVEX.512.66.0F38.W0 44 /r", "AVX512_CDI"},
	{"vplzcntq", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F38.W1 44 /r", "AVX512_CDI-VL"},
	{"vplzcntq", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F38.W1 44 /r", "AVX512_CDI-VL"},
	{"vplzcntq", "W:zmm {kz}, zmm/m512/b64", "RM-FV", "EVEX.512.66.0F38.W1 44 /r", "AVX512_CDI"},
	{"vpmadd52luq", "X:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 B4 /r", "AVX512_IFMA-VL"},
	{"vpmadd52luq", "X:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 B4 /r", "AVX512_IFMA-VL"},
	{"vpmadd52luq", "X:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 B4 /r", "AVX512_IFMA"},
	{"vpmadd52huq", "X:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 B5 /r", "AVX512_IFMA-VL"},
	{"vpmadd52huq", "X:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 B5 /r", "AVX512_IFMA-VL"},
	{"vpmadd52huq", "X:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 B5 /r", "AVX512_IFMA"},
	{"vpmaddubsw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG 04 /r", "AVX512_BW-VL"},
	{"vpmaddubsw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG 04 /r", "AVX512_BW-VL"},
	{"vpmaddubsw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG 04 /r", "AVX512_BW"},
	{"vpmaddwd", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG F5 /r", "AVX512_BW-VL"},
	{"vpmaddwd", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG F5 /r", "AVX512_BW-VL"},
	{"vpmaddwd", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG F5 /r", "AVX512_BW"},
	{"vpmaxsb", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG 3C /r", "AVX512_BW-VL"},
	{"vpmaxsb", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG 3C /r", "AVX512_BW-VL"},
	{"vpmaxsb", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG 3C /r", "AVX512_BW"},
	{"vpmaxsd", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 3D /r", "AVX512_F-VL"},
	{"vpmaxsd", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 3D /r", "AVX512_F-VL"},
	{"vpmaxsd", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 3D /r", "AVX512_F"},
	{"vpmaxsq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 3D /r", "AVX512_F-VL"},
	{"vpmaxsq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 3D /r", "AVX512_F-VL"},
	{"vpmaxsq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 3D /r", "AVX512_F"},
	{"vpmaxsw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG EE /r", "AVX512_BW-VL"},
	{"vpmaxsw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG EE /r", "AVX512_BW-VL"},
	{"vpmaxsw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG EE /r", "AVX512_BW"},
	{"vpmaxub", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG DE /r", "AVX512_BW-VL"},
	{"vpmaxub", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG DE /r", "AVX512_BW-VL"},
	{"vpmaxub", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG DE /r", "AVX512_BW"},
	{"vpmaxud", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 3F /r", "AVX512_F-VL"},
	{"vpmaxud", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 3F /r", "AVX512_F-VL"},
	{"vpmaxud", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 3F /r", "AVX512_F"},
	{"vpmaxuq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 3F /r", "AVX512_F-VL"},
	{"vpmaxuq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 3F /r", "AVX512_F-VL"},
	{"vpmaxuq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 3F /r", "AVX512_F"},
	{"vpmaxuw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG 3E /r", "AVX512_BW-VL"},
	{"vpmaxuw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG 3E /r", "AVX512_BW-VL"},
	{"vpmaxuw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG 3E /r", "AVX512_BW"},
	{"vpminsb", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG 38 /r", "AVX512_BW-VL"},
	{"vpminsb", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG 38 /r", "AVX512_BW-VL"},
	{"vpminsb", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG 38 /r", "AVX512_BW"},
	{"vpminsd", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 39 /r", "AVX512_F-VL"},
	{"vpminsd", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 39 /r", "AVX512_F-VL"},
	{"vpminsd", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 39 /r", "AVX512_F"},
	{"vpminsq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 39 /r", "AVX512_F-VL"},
	{"vpminsq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 39 /r", "AVX512_F-VL"},
	{"vpminsq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 39 /r", "AVX512_F"},
	{"vpminsw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG EA /r", "AVX512_BW-VL"},
	{"vpminsw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG EA /r", "AVX512_BW-VL"},
	{"vpminsw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG EA /r", "AVX512_BW"},
	{"vpminub", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F DA /r", "AVX512_BW-VL"},
	{"vpminub", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F DA /r", "AVX512_BW-VL"},
	{"vpminub", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F DA /r", "AVX512_BW"},
	{"vpminud", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 3B /r", "AVX512_F-VL"},
	{"vpminud", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 3B /r", "AVX512_F-VL"},
	{"vpminud", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 3B /r", "AVX512_F"},
	{"vpminuq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 3B /r", "AVX512_F-VL"},
	{"vpminuq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 3B /r", "AVX512_F-VL"},
	{"vpminuq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 3B /r", "AVX512_F"},
	{"vpminuw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38 3A /r", "AVX512_BW-VL"},
	{"vpminuw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38 3A /r", "AVX512_BW-VL"},
	{"vpminuw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38 3A /r", "AVX512_BW"},
	{"vpmovb2m", "W:k, xmm", "RM", "EVEX.128.F3.0F38.W0 29 /r", "AVX512_BW-VL"},
	{"vpmovb2m", "W:k, ymm", "RM", "EVEX.256.F3.0F38.W0 29 /r", "AVX512_BW-VL"},
	{"vpmovb2m", "W:k, zmm", "RM", "EVEX.512.F3.0F38.W0 29 /r", "AVX512_BW"},
	{"vpmovd2m", "W:k, xmm", "RM", "EVEX.128.F3.0F38.W0 39 /r", "AVX512_DQ-VL"},
	{"vpmovd2m", "W:k, ymm", "RM", "EVEX.256.F3.0F38.W0 39 /r", "AVX512_DQ-VL"},
	{"vpmovd2m", "W:k, zmm", "RM", "EVEX.512.F3.0F38.W0 39 /r", "AVX512_DQ"},
	{"vpmovdb", "W:xmm{3:0}/m32 {kz}, xmm", "MR-QVM", "EVEX.128.F3.0F38.W0 31 /r", "AVX512_F-VL"},
	{"vpmovdb", "W:xmm{7:0}/m64 {kz}, ymm", "MR-QVM", "EVEX.256.F3.0F38.W0 31 /r", "AVX512_F-VL"},
	{"vpmovdb", "W:xmm/m128 {kz}, zmm", "MR-QVM", "EVEX.512.F3.0F38.W0 31 /r", "AVX512_F"},
	{"vpmovdw", "W:xmm{7:0}/m64 {kz}, xmm", "MR-HVM", "EVEX.128.F3.0F38.W0 33 /r", "AVX512_F-VL"},
	{"vpmovdw", "W:xmm/m128 {kz}, ymm", "MR-HVM", "EVEX.256.F3.0F38.W0 33 /r", "AVX512_F-VL"},
	{"vpmovdw", "W:ymm/m256 {kz}, zmm", "MR-HVM", "EVEX.512.F3.0F38.W0 33 /r", "AVX512_F"},
	{"vpmovm2b", "W:xmm, k", "RM", "EVEX.128.F3.0F38.W0 28 /r", "AVX512_BW-VL"},
	{"vpmovm2b", "W:ymm, k", "RM", "EVEX.256.F3.0F38.W0 28 /r", "AVX512_BW-VL"},
	{"vpmovm2b", "W:zmm, k", "RM", "EVEX.512.F3.0F38.W0 28 /r", "AVX512_BW"},
	{"vpmovm2d", "W:xmm, k", "RM", "EVEX.128.F3.0F38.W0 38 /r", "AVX512_DQ-VL"},
	{"vpmovm2d", "W:ymm, k", "RM", "EVEX.256.F3.0F38.W0 38 /r", "AVX512_DQ-VL"},
	{"vpmovm2d", "W:zmm, k", "RM", "EVEX.512.F3.0F38.W0 38 /r", "AVX512_DQ"},
	{"vpmovm2q", "W:xmm, k", "RM", "EVEX.128.F3.0F38.W1 38 /r", "AVX512_DQ-VL"},
	{"vpmovm2q", "W:ymm, k", "RM", "EVEX.256.F3.0F38.W1 38 /r", "AVX512_DQ-VL"},
	{"vpmovm2q", "W:zmm, k", "RM", "EVEX.512.F3.0F38.W1 38 /r", "AVX512_DQ"},
	{"vpmovm2w", "W:xmm, k", "RM", "EVEX.128.F3.0F38.W1 28 /r", "AVX512_BW-VL"},
	{"vpmovm2w", "W:ymm, k", "RM", "EVEX.256.F3.0F38.W1 28 /r", "AVX512_BW-VL"},
	{"vpmovm2w", "W:zmm, k", "RM", "EVEX.512.F3.0F38.W1 28 /r", "AVX512_BW"},
	{"vpmovq2m", "W:k, xmm", "RM", "EVEX.128.F3.0F38.W1 39 /r", "AVX512_DQ-VL"},
	{"vpmovq2m", "W:k, ymm", "RM", "EVEX.256.F3.0F38.W1 39 /r", "AVX512_DQ-VL"},
	{"vpmovq2m", "W:k, zmm", "RM", "EVEX.512.F3.0F38.W1 39 /r", "AVX512_DQ"},
	{"vpmovqb", "W:xmm{1:0}/m16 {kz}, xmm", "MR-OVM", "EVEX.128.F3.0F38.W0 32 /r", "AVX512_F-VL"},
	{"vpmovqb", "W:xmm{3:0}/m32 {kz}, ymm", "MR-OVM", "EVEX.256.F3.0F38.W0 32 /r", "AVX512_F-VL"},
	{"vpmovqb", "W:xmm{7:0}/m64 {kz}, zmm", "MR-OVM", "EVEX.512.F3.0F38.W0 32 /r", "AVX512_F"},
	{"vpmovqd", "W:xmm{7:0}/m64 {kz}, xmm", "MR-HVM", "EVEX.128.F3.0F38.W0 35 /r", "AVX512_F-VL"},
	{"vpmovqd", "W:xmm/m128 {kz}, ymm", "MR-HVM", "EVEX.256.F3.0F38.W0 35 /r", "AVX512_F-VL"},
	{"vpmovqd", "W:ymm/m256 {kz}, zmm", "MR-HVM", "EVEX.512.F3.0F38.W0 35 /r", "AVX512_F"},
	{"vpmovqw", "W:xmm{3:0}/m32 {kz}, xmm", "MR-QVM", "EVEX.128.F3.0F38.W0 34 /r", "AVX512_F-VL"},
	{"vpmovqw", "W:xmm{7:0}/m64 {kz}, ymm", "MR-QVM", "EVEX.256.F3.0F38.W0 34 /r", "AVX512_F-VL"},
	{"vpmovqw", "W:xmm/m128 {kz}, zmm", "MR-QVM", "EVEX.512.F3.0F38.W0 34 /r", "AVX512_F"},
	{"vpmovsdb", "W:xmm{3:0}/m32 {kz}, xmm", "MR-QVM", "EVEX.128.F3.0F38.W0 21 /r", "AVX512_F-VL"},
	{"vpmovsdb", "W:xmm{7:0}/m64 {kz}, ymm", "MR-QVM", "EVEX.256.F3.0F38.W0 21 /r", "AVX512_F-VL"},
	{"vpmovsdb", "W:xmm/m128 {kz}, zmm", "MR-QVM", "EVEX.512.F3.0F38.W0 21 /r", "AVX512_F"},
	{"vpmovsdw", "W:xmm{7:0}/m64 {kz}, xmm", "MR-HVM", "EVEX.128.F3.0F38.W0 23 /r", "AVX512_F-VL"},
	{"vpmovsdw", "W:xmm/m128 {kz}, ymm", "MR-HVM", "EVEX.256.F3.0F38.W0 23 /r", "AVX512_F-VL"},
	{"vpmovsdw", "W:ymm/m256 {kz}, zmm", "MR-HVM", "EVEX.512.F3.0F38.W0 23 /r", "AVX512_F"},
	{"vpmovsqb", "W:xmm{1:0}/m16 {kz}, xmm", "MR-OVM", "EVEX.128.F3.0F38.W0 22 /r", "AVX512_F-VL"},
	{"vpmovsqb", "W:xmm{3:0}/m32 {kz}, ymm", "MR-OVM", "EVEX.256.F3.0F38.W0 22 /r", "AVX512_F-VL"},
	{"vpmovsqb", "W:xmm{7:0}/m64 {kz}, zmm", "MR-OVM", "EVEX.512.F3.0F38.W0 22 /r", "AVX512_F"},
	{"vpmovsqd", "W:xmm{7:0}/m64 {kz}, xmm", "MR-HVM", "EVEX.128.F3.0F38.W0 25 /r", "AVX512_F-VL"},
	{"vpmovsqd", "W:xmm/m128 {kz}, ymm", "MR-HVM", "EVEX.256.F3.0F38.W0 25 /r", "AVX512_F-VL"},
	{"vpmovsqd", "W:ymm/m256 {kz}, zmm", "MR-HVM", "EVEX.512.F3.0F38.W0 25 /r", "AVX512_F"},
	{"vpmovsqw", "W:xmm{3:0}/m32 {kz}, xmm", "MR-QVM", "EVEX.128.F3.0F38.W0 24 /r", "AVX512_F-VL"},
	{"vpmovsqw", "W:xmm{7:0}/m64 {kz}, ymm", "MR-QVM", "EVEX.256.F3.0F38.W0 24 /r", "AVX512_F-VL"},
	{"vpmovsqw", "W:xmm/m128 {kz}, zmm", "MR-QVM", "EVEX.512.F3.0F38.W0 24 /r", "AVX512_F"},
	{"vpmovswb", "W:xmm{7:0}/m64 {kz}, xmm", "MR-HVM", "EVEX.128.F3.0F38.W0 20 /r", "AVX512_BW-VL"},
	{"vpmovswb", "W:xmm/m128 {kz}, ymm", "MR-HVM", "EVEX.256.F3.0F38.W0 20 /r", "AVX512_BW-VL"},
	{"vpmovswb", "W:ymm/m256 {kz}, zmm", "MR-HVM", "EVEX.512.F3.0F38.W0 20 /r", "AVX512_BW"},
	{"vpmovsxbd", "W:xmm {kz}, xmm{3:0}/m32", "RM-QVM", "EVEX.128.66.0F38.WIG 21 /r", "AVX512_F-VL"},
	{"vpmovsxbd", "W:ymm {kz}, xmm{7:0}/m64", "RM-QVM", "EVEX.256.66.0F38.WIG 21 /r", "AVX512_F-VL"},
	{"vpmovsxbd", "W:zmm {kz}, xmm/m128", "RM-QVM", "EVEX.512.66.0F38.WIG 21 /r", "AVX512_F"},
	{"vpmovsxbq", "W:xmm {kz}, xmm{1:0}/m16", "RM-OVM", "EVEX.128.66.0F38.WIG 22 /r", "AVX512_F-VL"},
	{"vpmovsxbq", "W:ymm {kz}, xmm{3:0}/m32", "RM-OVM", "EVEX.256.66.0F38.WIG 22 /r", "AVX512_F-VL"},
	{"vpmovsxbq", "W:zmm {kz}, xmm{7:0}/m64", "RM-OVM", "EVEX.512.66.0F38.WIG 22 /r", "AVX512_F"},
	{"vpmovsxbw", "W:xmm {kz}, xmm{7:0}/m64", "RM-HVM", "EVEX.128.66.0F38.WIG 20 /r", "AVX512_BW-VL"},
	{"vpmovsxbw", "W:ymm {kz}, xmm/m128", "RM-HVM", "EVEX.256.66.0F38.WIG 20 /r", "AVX512_BW-VL"},
	{"vpmovsxbw", "W:zmm {kz}, ymm/m256", "RM-HVM", "EVEX.512.66.0F38.WIG 20 /r", "AVX512_BW"},
	{"vpmovsxdq", "W:xmm {kz}, xmm{7:0}/m64", "RM-HVM", "EVEX.128.66.0F38.W0 25 /r", "AVX512_F-VL"},
	{"vpmovsxdq", "W:ymm {kz}, xmm/m128", "RM-HVM", "EVEX.256.66.0F38.W0 25 /r", "AVX512_F-VL"},
	{"vpmovsxdq", "W:zmm {kz}, ymm/m256", "RM-HVM", "EVEX.512.66.0F38.W0 25 /r", "AVX512_F"},
	{"vpmovsxwd", "W:xmm {kz}, xmm{7:0}/m64", "RM-HVM", "EVEX.128.66.0F38.WIG 23 /r", "AVX512_F-VL"},
	{"vpmovsxwd", "W:ymm {kz}, xmm/m128", "RM-HVM", "EVEX.256.66.0F38.WIG 23 /r", "AVX512_F-VL"},
	{"vpmovsxwd", "W:zmm {kz}, ymm/m256", "RM-HVM", "EVEX.512.66.0F38.WIG 23 /r", "AVX512_F"},
	{"vpmovsxwq", "W:xmm {kz}, xmm{3:0}/m32", "RM-QVM", "EVEX.128.66.0F38.WIG 24 /r", "AVX512_F-VL"},
	{"vpmovsxwq", "W:ymm {kz}, xmm{7:0}/m64", "RM-QVM", "EVEX.256.66.0F38.WIG 24 /r", "AVX512_F-VL"},
	{"vpmovsxwq", "W:zmm {kz}, xmm/m128", "RM-QVM", "EVEX.512.66.0F38.WIG 24 /r", "AVX512_F"},
	{"vpmovusdb", "W:xmm{3:0}/m32 {kz}, xmm", "MR-QVM", "EVEX.128.F3.0F38.W0 11 /r", "AVX512_F-VL"},
	{"vpmovusdb", "W:xmm{7:0}/m64 {kz}, ymm", "MR-QVM", "EVEX.256.F3.0F38.W0 11 /r", "AVX512_F-VL"},
	{"vpmovusdb", "W:xmm/m128 {kz}, zmm", "MR-QVM", "EVEX.512.F3.0F38.W0 11 /r", "AVX512_F"},
	{"vpmovusdw", "W:xmm{7:0}/m64 {kz}, xmm", "MR-HVM", "EVEX.128.F3.0F38.W0 13 /r", "AVX512_F-VL"},
	{"vpmovusdw", "W:xmm/m128 {kz}, ymm", "MR-HVM", "EVEX.256.F3.0F38.W0 13 /r", "AVX512_F-VL"},
	{"vpmovusdw", "W:ymm/m256 {kz}, zmm", "MR-HVM", "EVEX.512.F3.0F38.W0 13 /r", "AVX512_F"},
	{"vpmovusqb", "W:xmm{1:0}/m16 {kz}, xmm", "MR-OVM", "EVEX.128.F3.0F38.W0 12 /r", "AVX512_F-VL"},
	{"vpmovusqb", "W:xmm{3:0}/m32 {kz}, ymm", "MR-OVM", "EVEX.256.F3.0F38.W0 12 /r", "AVX512_F-VL"},
	{"vpmovusqb", "W:xmm{7:0}/m64 {kz}, zmm", "MR-OVM", "EVEX.512.F3.0F38.W0 12 /r", "AVX512_F"},
	{"vpmovusqd", "W:xmm{7:0}/m64 {kz}, xmm", "MR-HVM", "EVEX.128.F3.0F38.W0 15 /r", "AVX512_F-VL"},
	{"vpmovusqd", "W:xmm/m128 {kz}, ymm", "MR-HVM", "EVEX.256.F3.0F38.W0 15 /r", "AVX512_F-VL"},
	{"vpmovusqd", "W:ymm/m256 {kz}, zmm", "MR-HVM", "EVEX.512.F3.0F38.W0 15 /r", "AVX512_F"},
	{"vpmovusqw", "W:xmm{3:0}/m32 {kz}, xmm", "MR-QVM", "EVEX.128.F3.0F38.W0 14 /r", "AVX512_F-VL"},
	{"vpmovusqw", "W:xmm{7:0}/m64 {kz}, ymm", "MR-QVM", "EVEX.256.F3.0F38.W0 14 /r", "AVX512_F-VL"},
	{"vpmovusqw", "W:xmm/m128 {kz}, zmm", "MR-QVM", "EVEX.512.F3.0F38.W0 14 /r", "AVX512_F"},
	{"vpmovuswb", "W:xmm{7:0}/m64 {kz}, xmm", "MR-HVM", "EVEX.128.F3.0F38.W0 10 /r", "AVX512_BW-VL"},
	{"vpmovuswb", "W:xmm/m128 {kz}, ymm", "MR-HVM", "EVEX.256.F3.0F38.W0 10 /r", "AVX512_BW-VL"},
	{"vpmovuswb", "W:ymm/m256 {kz}, zmm", "MR-HVM", "EVEX.512.F3.0F38.W0 10 /r", "AVX512_BW"},
	{"vpmovw2m", "W:k, xmm", "RM", "EVEX.128.F3.0F38.W1 29 /r", "AVX512_BW-VL"},
	{"vpmovw2m", "W:k, ymm", "RM", "EVEX.256.F3.0F38.W1 29 /r", "AVX512_BW-VL"},
	{"vpmovw2m", "W:k, zmm", "RM", "EVEX.512.F3.0F38.W1 29 /r", "AVX512_BW"},
	{"vpmovwb", "W:xmm{7:0}/m64 {kz}, xmm", "MR-HVM", "EVEX.128.F3.0F38.W0 30 /r", "AVX512_BW-VL"},
	{"vpmovwb", "W:xmm/m128 {kz}, ymm", "MR-HVM", "EVEX.256.F3.0F38.W0 30 /r", "AVX512_BW-VL"},
	{"vpmovwb", "W:ymm/m256 {kz}, zmm", "MR-HVM", "EVEX.512.F3.0F38.W0 30 /r", "AVX512_BW"},
	{"vpmovzxbd", "W:xmm {kz}, xmm{3:0}/m32", "RM-QVM", "EVEX.128.66.0F38.WIG 31 /r", "AVX512_F-VL"},
	{"vpmovzxbd", "W:ymm {kz}, xmm{7:0}/m64", "RM-QVM", "EVEX.256.66.0F38.WIG 31 /r", "AVX512_F-VL"},
	{"vpmovzxbd", "W:zmm {kz}, xmm/m128", "RM-QVM", "EVEX.512.66.0F38.WIG 31 /r", "AVX512_F"},
	{"vpmovzxbq", "W:xmm {kz}, xmm{1:0}/m16", "RM-OVM", "EVEX.128.66.0F38.WIG 32 /r", "AVX512_F-VL"},
	{"vpmovzxbq", "W:ymm {kz}, xmm{3:0}/m32", "RM-OVM", "EVEX.256.66.0F38.WIG 32 /r", "AVX512_F-VL"},
	{"vpmovzxbq", "W:zmm {kz}, xmm{7:0}/m64", "RM-OVM", "EVEX.512.66.0F38.WIG 32 /r", "AVX512_F"},
	{"vpmovzxbw", "W:xmm {kz}, xmm{7:0}/m64", "RM-HVM", "EVEX.128.66.0F38.WIG 30 /r", "AVX512_BW-VL"},
	{"vpmovzxbw", "W:ymm {kz}, xmm/m128", "RM-HVM", "EVEX.256.66.0F38.WIG 30 /r", "AVX512_BW-VL"},
	{"vpmovzxbw", "W:zmm {kz}, ymm/m256", "RM-HVM", "EVEX.512.66.0F38.WIG 30 /r", "AVX512_BW"},
	{"vpmovzxdq", "W:xmm {kz}, xmm{7:0}/m64", "RM-HVM", "EVEX.128.66.0F38.W0 35 /r", "AVX512_F-VL"},
	{"vpmovzxdq", "W:ymm {kz}, xmm/m128", "RM-HVM", "EVEX.256.66.0F38.W0 35 /r", "AVX512_F-VL"},
	{"vpmovzxdq", "W:zmm {kz}, ymm/m256", "RM-HVM", "EVEX.512.66.0F38.W0 35 /r", "AVX512_F"},
	{"vpmovzxwd", "W:xmm {kz}, xmm{7:0}/m64", "RM-HVM", "EVEX.128.66.0F38.WIG 33 /r", "AVX512_F-VL"},
	{"vpmovzxwd", "W:ymm {kz}, xmm/m128", "RM-HVM", "EVEX.256.66.0F38.WIG 33 /r", "AVX512_F-VL"},
	{"vpmovzxwd", "W:zmm {kz}, ymm/m256", "RM-HVM", "EVEX.512.66.0F38.WIG 33 /r", "AVX512_F"},
	{"vpmovzxwq", "W:xmm {kz}, xmm{3:0}/m32", "RM-QVM", "EVEX.128.66.0F38.WIG 34 /r", "AVX512_F-VL"},
	{"vpmovzxwq", "W:ymm {kz}, xmm{7:0}/m64", "RM-QVM", "EVEX.256.66.0F38.WIG 34 /r", "AVX512_F-VL"},
	{"vpmovzxwq", "W:zmm {kz}, xmm/m128", "RM-QVM", "EVEX.512.66.0F38.WIG 34 /r", "AVX512_F"},
	{"vpmuldq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 28 /r", "AVX512_F-VL"},
	{"vpmuldq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 28 /r", "AVX512_F-VL"},
	{"vpmuldq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 28 /r", "AVX512_F"},
	{"vpmulhrsw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG 0B /r", "AVX512_BW-VL"},
	{"vpmulhrsw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG 0B /r", "AVX512_BW-VL"},
	{"vpmulhrsw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG 0B /r", "AVX512_BW"},
	{"vpmulhuw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG E4 /r", "AVX512_BW-VL"},
	{"vpmulhuw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG E4 /r", "AVX512_BW-VL"},
	{"vpmulhuw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG E4 /r", "AVX512_BW"},
	{"vpmulhw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG E5 /r", "AVX512_BW-VL"},
	{"vpmulhw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG E5 /r", "AVX512_BW-VL"},
	{"vpmulhw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG E5 /r", "AVX512_BW"},
	{"vpmulld", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 40 /r", "AVX512_F-VL"},
	{"vpmulld", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 40 /r", "AVX512_F-VL"},
	{"vpmulld", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 40 /r", "AVX512_F"},
	{"vpmullq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 40 /r", "AVX512_DQ-VL"},
	{"vpmullq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 40 /r", "AVX512_DQ-VL"},
	{"vpmullq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 40 /r", "AVX512_DQ"},
	{"vpmullw", "W:xmm {kz},~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG D5 /r", "AVX512_BW-VL"},
	{"vpmullw", "W:ymm {kz},~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG D5 /r", "AVX512_BW-VL"},
	{"vpmullw", "W:zmm {kz},~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG D5 /r", "AVX512_BW"},
	{"vpmultishiftqb", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 83 /r", "AVX512_VBMI-VL"},
	{"vpmultishiftqb", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 83 /r", "AVX512_VBMI-VL"},
	{"vpmultishiftqb", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 83 /r", "AVX512_VBMI"},
	{"vpmuludq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 F4 /r", "AVX512_F-VL"},
	{"vpmuludq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 F4 /r", "AVX512_F-VL"},
	{"vpmuludq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 F4 /r", "AVX512_F"},
	{"vpopcntb", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F38.W0 54 /r", "AVX512_BITALG-VL"},
	{"vpopcntb", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F38.W0 54 /r", "AVX512_BITALG-VL"},
	{"vpopcntb", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F38.W0 54 /r", "AVX512_BITALG"},
	{"vpopcntd", "W:xmm {kz}, xmm/m128/b32", "RM-FVM", "EVEX.128.66.0F38.W0 55 /r", "AVX512_VPOPCNTDQ-VL"},
	{"vpopcntd", "W:ymm {kz}, ymm/m256/b32", "RM-FVM", "EVEX.256.66.0F38.W0 55 /r", "AVX512_VPOPCNTDQ-VL"},
	{"vpopcntd", "W:zmm {kz}, zmm/m512/b32", "RM-FVM", "EVEX.512.66.0F38.W0 55 /r", "AVX512_VPOPCNTDQ"},
	{"vpopcntq", "W:xmm {kz}, xmm/m128/b64", "RM-FVM", "EVEX.128.66.0F38.W1 55 /r", "AVX512_VPOPCNTDQ-VL"},
	{"vpopcntq", "W:ymm {kz}, ymm/m256/b64", "RM-FVM", "EVEX.256.66.0F38.W1 55 /r", "AVX512_VPOPCNTDQ-VL"},
	{"vpopcntq", "W:zmm {kz}, zmm/m512/b64", "RM-FVM", "EVEX.512.66.0F38.W1 55 /r", "AVX512_VPOPCNTDQ"},
	{"vpopcntw", "W:xmm {kz}, xmm/m128", "RM-FVM", "EVEX.128.66.0F38.W1 54 /r", "AVX512_BITALG-VL"},
	{"vpopcntw", "W:ymm {kz}, ymm/m256", "RM-FVM", "EVEX.256.66.0F38.W1 54 /r", "AVX512_BITALG-VL"},
	{"vpopcntw", "W:zmm {kz}, zmm/m512", "RM-FVM", "EVEX.512.66.0F38.W1 54 /r", "AVX512_BITALG"},
	{"vpord", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F.W0 EB /r", "AVX512_F-VL"},
	{"vpord", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F.W0 EB /r", "AVX512_F-VL"},
	{"vpord", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F.W0 EB /r", "AVX512_F"},
	{"vporq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 EB /r", "AVX512_F-VL"},
	{"vporq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 EB /r", "AVX512_F-VL"},
	{"vporq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 EB /r", "AVX512_F"},
	{"vprold", "W:xmm {kz}, xmm/m128/b32, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W0 72 /1 ib", "AVX512_F-VL"},
	{"vprold", "W:ymm {kz}, ymm/m256/b32, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W0 72 /1 ib", "AVX512_F-VL"},
	{"vprold", "W:zmm {kz}, zmm/m512/b32, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W0 72 /1 ib", "AVX512_F"},
	{"vprolq", "W:xmm {kz}, xmm/m128/b64, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W1 72 /1 ib", "AVX512_F-VL"},
	{"vprolq", "W:ymm {kz}, ymm/m256/b64, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W1 72 /1 ib", "AVX512_F-VL"},
	{"vprolq", "W:zmm {kz}, zmm/m512/b64, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W1 72 /1 ib", "AVX512_F"},
	{"vprolvd", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 15 /r", "AVX512_F-VL"},
	{"vprolvd", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 15 /r", "AVX512_F-VL"},
	{"vprolvd", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 15 /r", "AVX512_F"},
	{"vprolvq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 15 /r", "AVX512_F-VL"},
	{"vprolvq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 15 /r", "AVX512_F-VL"},
	{"vprolvq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 15 /r", "AVX512_F"},
	{"vprord", "W:xmm {kz}, xmm/m128/b32, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W0 72 /0 ib", "AVX512_F-VL"},
	{"vprord", "W:ymm {kz}, ymm/m256/b32, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W0 72 /0 ib", "AVX512_F-VL"},
	{"vprord", "W:zmm {kz}, zmm/m512/b32, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W0 72 /0 ib", "AVX512_F"},
	{"vprorq", "W:xmm {kz}, xmm/m128/b64, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W1 72 /0 ib", "AVX512_F-VL"},
	{"vprorq", "W:ymm {kz}, ymm/m256/b64, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W1 72 /0 ib", "AVX512_F-VL"},
	{"vprorq", "W:zmm {kz}, zmm/m512/b64, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W1 72 /0 ib", "AVX512_F"},
	{"vprorvd", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 14 /r", "AVX512_F-VL"},
	{"vprorvd", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 14 /r", "AVX512_F-VL"},
	{"vprorvd", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 14 /r", "AVX512_F"},
	{"vprorvq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 14 /r", "AVX512_F-VL"},
	{"vprorvq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 14 /r", "AVX512_F-VL"},
	{"vprorvq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 14 /r", "AVX512_F"},
	{"vpsadbw", "W:xmm,~xmm,~xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG F6 /r", "AVX512_BW-VL"},
	{"vpsadbw", "W:ymm,~ymm,~ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG F6 /r", "AVX512_BW-VL"},
	{"vpsadbw", "W:zmm,~zmm,~zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG F6 /r", "AVX512_BW"},
	{"vpscatterdd", "W:vm32x {k}, xmm", "MR-T1S", "EVEX.128.66.0F38.W0 A0 /r", "AVX512_F-VL"},
	{"vpscatterdd", "W:vm32y {k}, ymm", "MR-T1S", "EVEX.256.66.0F38.W0 A0 /r", "AVX512_F-VL"},
	{"vpscatterdd", "W:vm32z {k}, zmm", "MR-T1S", "EVEX.512.66.0F38.W0 A0 /r", "AVX512_F"},
	{"vpscatterdq", "W:vm32x {k}, xmm", "MR-T1S", "EVEX.128.66.0F38.W1 A0 /r", "AVX512_F-VL"},
	{"vpscatterdq", "W:vm32y {k}, ymm", "MR-T1S", "EVEX.256.66.0F38.W1 A0 /r", "AVX512_F-VL"},
	{"vpscatterdq", "W:vm32z {k}, zmm", "MR-T1S", "EVEX.512.66.0F38.W1 A0 /r", "AVX512_F"},
	{"vpscatterqd", "W:vm64x {k}, xmm", "MR-T1S", "EVEX.128.66.0F38.W0 A1 /r", "AVX512_F-VL"},
	{"vpscatterqd", "W:vm64y {k}, xmm", "MR-T1S", "EVEX.256.66.0F38.W0 A1 /r", "AVX512_F-VL"},
	{"vpscatterqd", "W:vm64z {k}, ymm", "MR-T1S", "EVEX.512.66.0F38.W0 A1 /r", "AVX512_F"},
	{"vpscatterqq", "W:vm64x {k}, xmm", "MR-T1S", "EVEX.128.66.0F38.W1 A1 /r", "AVX512_F-VL"},
	{"vpscatterqq", "W:vm64y {k}, ymm", "MR-T1S", "EVEX.256.66.0F38.W1 A1 /r", "AVX512_F-VL"},
	{"vpscatterqq", "W:vm64z {k}, zmm", "MR-T1S", "EVEX.512.66.0F38.W1 A1 /r", "AVX512_F"},
	{"vpshldd", "W:xmm {kz}, xmm, xmm/m128/b32, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W0 71 /r ib", "AVX512_VBMI2-VL"},
	{"vpshldd", "W:ymm {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W0 71 /r ib", "AVX512_VBMI2-VL"},
	{"vpshldd", "W:zmm {kz}, zmm, zmm/m512/b32, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W0 71 /r ib", "AVX512_VBMI2"},
	{"vpshldq", "W:xmm {kz}, xmm, xmm/m128/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W1 71 /r ib", "AVX512_VBMI2-VL"},
	{"vpshldq", "W:ymm {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W1 71 /r ib", "AVX512_VBMI2-VL"},
	{"vpshldq", "W:zmm {kz}, zmm, zmm/m512/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W1 71 /r ib", "AVX512_VBMI2"},
	{"vpshldvd", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FVM", "EVEX.DDS.128.66.0F38.W0 71 /r", "AVX512_VBMI2-VL"},
	{"vpshldvd", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FVM", "EVEX.DDS.256.66.0F38.W0 71 /r", "AVX512_VBMI2-VL"},
	{"vpshldvd", "X:zmm {kz}, zmm, zmm/m512/b32", "RVM-FVM", "EVEX.DDS.512.66.0F38.W0 71 /r", "AVX512_VBMI2"},
	{"vpshldvq", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FVM", "EVEX.DDS.128.66.0F38.W1 71 /r", "AVX512_VBMI2-VL"},
	{"vpshldvq", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FVM", "EVEX.DDS.256.66.0F38.W1 71 /r", "AVX512_VBMI2-VL"},
	{"vpshldvq", "X:zmm {kz}, zmm, zmm/m512/b64", "RVM-FVM", "EVEX.DDS.512.66.0F38.W1 71 /r", "AVX512_VBMI2"},
	{"vpshldvw", "X:xmm {kz}, xmm, xmm/m128", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 70 /r", "AVX512_VBMI2-VL"},
	{"vpshldvw", "X:ymm {kz}, ymm, ymm/m256", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 70 /r", "AVX512_VBMI2-VL"},
	{"vpshldvw", "X:zmm {kz}, zmm, zmm/m512", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 70 /r", "AVX512_VBMI2"},
	{"vpshldw", "W:xmm {kz}, xmm, xmm/m128, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W1 70 /r ib", "AVX512_VBMI2-VL"},
	{"vpshldw", "W:ymm {kz}, ymm, ymm/m256, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W1 70 /r ib", "AVX512_VBMI2-VL"},
	{"vpshldw", "W:zmm {kz}, zmm, zmm/m512, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W1 70 /r ib", "AVX512_VBMI2"},
	{"vpshrdd", "W:xmm {kz}, xmm, xmm/m128/b32, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W0 73 /r ib", "AVX512_VBMI2-VL"},
	{"vpshrdd", "W:ymm {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W0 73 /r ib", "AVX512_VBMI2-VL"},
	{"vpshrdd", "W:zmm {kz}, zmm, zmm/m512/b32, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W0 73 /r ib", "AVX512_VBMI2"},
	{"vpshrdq", "W:xmm {kz}, xmm, xmm/m128/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.128.66.0F3A.W1 73 /r ib", "AVX512_VBMI2-VL"},
	{"vpshrdq", "W:ymm {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.256.66.0F3A.W1 73 /r ib", "AVX512_VBMI2-VL"},
	{"vpshrdq", "W:zmm {kz}, zmm, zmm/m512/b64, ib/ub", "RVMI-FVM", "EVEX.NDS.512.66.0F3A.W1 73 /r ib", "AVX512_VBMI2"},
	{"vpshrdvd", "X:xmm {kz}, xmm, xmm/m128/b32", "RVM-FVM", "EVEX.DDS.128.66.0F38.W0 73 /r", "AVX512_VBMI2-VL"},
	{"vpshrdvd", "X:ymm {kz}, ymm, ymm/m256/b32", "RVM-FVM", "EVEX.DDS.256.66.0F38.W0 73 /r", "AVX512_VBMI2-VL"},
	{"vpshrdvd", "X:zmm {kz}, zmm, zmm/m512/b32", "RVM-FVM", "EVEX.DDS.512.66.0F38.W0 73 /r", "AVX512_VBMI2"},
	{"vpshrdvq", "X:xmm {kz}, xmm, xmm/m128/b64", "RVM-FVM", "EVEX.DDS.128.66.0F38.W1 73 /r", "AVX512_VBMI2-VL"},
	{"vpshrdvq", "X:ymm {kz}, ymm, ymm/m256/b64", "RVM-FVM", "EVEX.DDS.256.66.0F38.W1 73 /r", "AVX512_VBMI2-VL"},
	{"vpshrdvq", "X:zmm {kz}, zmm, zmm/m512/b64", "RVM-FVM", "EVEX.DDS.512.66.0F38.W1 73 /r", "AVX512_VBMI2"},
	{"vpshrdvw", "X:xmm {kz}, xmm, xmm/m128", "RVM-FV", "EVEX.DDS.128.66.0F38.W1 72 /r", "AVX512_VBMI2-VL"},
	{"vpshrdvw", "X:ymm {kz}, ymm, ymm/m256", "RVM-FV", "EVEX.DDS.256.66.0F38.W1 72 /r", "AVX512_VBMI2-VL"},
	{"vpshrdvw", "X:zmm {kz}, zmm, zmm/m512", "RVM-FV", "EVEX.DDS.512.66.0F38.W1 72 /r", "AVX512_VBMI2"},
	{"vpshrdw", "W:xmm {kz}, xmm, xmm/m128, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W1 72 /r ib", "AVX512_VBMI2-VL"},
	{"vpshrdw", "W:ymm {kz}, ymm, ymm/m256, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W1 72 /r ib", "AVX512_VBMI2-VL"},
	{"vpshrdw", "W:zmm {kz}, zmm, zmm/m512, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W1 72 /r ib", "AVX512_VBMI2"},
	{"vpshufb", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.WIG 00 /r", "AVX512_BW-VL"},
	{"vpshufb", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.WIG 00 /r", "AVX512_BW-VL"},
	{"vpshufb", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.WIG 00 /r", "AVX512_BW"},
	{"vpshufbitqmb", "W:k {k}, xmm, xmm/m128", "RM-FVM", "EVEX.NDS.128.66.0F38.W0 8F /r", "AVX512_BITALG-VL"},
	{"vpshufbitqmb", "W:k {k}, ymm, ymm/m256", "RM-FVM", "EVEX.NDS.256.66.0F38.W0 8F /r", "AVX512_BITALG-VL"},
	{"vpshufbitqmb", "W:k {k}, zmm, zmm/m512", "RM-FVM", "EVEX.NDS.512.66.0F38.W0 8F /r", "AVX512_BITALG"},
	{"vpshufd", "W:xmm {kz}, xmm/m128/b32, ib/ub", "RMI-FV", "EVEX.128.66.0F.W0 70 /r ib", "AVX512_F-VL"},
	{"vpshufd", "W:ymm {kz}, ymm/m256/b32, ib/ub", "RMI-FV", "EVEX.256.66.0F.W0 70 /r ib", "AVX512_F-VL"},
	{"vpshufd", "W:zmm {kz}, zmm/m512/b32, ib/ub", "RMI-FV", "EVEX.512.66.0F.W0 70 /r ib", "AVX512_F"},
	{"vpshufhw", "W:xmm {kz}, xmm/m128, ib/ub", "RMI-FVM", "EVEX.128.F3.0F.WIG 70 /r ib", "AVX512_BW-VL"},
	{"vpshufhw", "W:ymm {kz}, ymm/m256, ib/ub", "RMI-FVM", "EVEX.256.F3.0F.WIG 70 /r ib", "AVX512_BW-VL"},
	{"vpshufhw", "W:zmm {kz}, zmm/m512, ib/ub", "RMI-FVM", "EVEX.512.F3.0F.WIG 70 /r ib", "AVX512_BW"},
	{"vpshuflw", "W:xmm {kz}, xmm/m128, ib/ub", "RMI-FVM", "EVEX.128.F2.0F.WIG 70 /r ib", "AVX512_BW-VL"},
	{"vpshuflw", "W:ymm {kz}, ymm/m256, ib/ub", "RMI-FVM", "EVEX.256.F2.0F.WIG 70 /r ib", "AVX512_BW-VL"},
	{"vpshuflw", "W:zmm {kz}, zmm/m512, ib/ub", "RMI-FVM", "EVEX.512.F2.0F.WIG 70 /r ib", "AVX512_BW"},
	{"vpslld", "W:xmm {kz}, xmm, xmm/m128", "RVM-M128", "EVEX.NDS.128.66.0F.W0 F2 /r", "AVX512_F-VL"},
	{"vpslld", "W:xmm {kz}, xmm/m128/b32, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W0 72 /6 ib", "AVX512_F-VL"},
	{"vpslld", "W:ymm {kz}, ymm, xmm/m128", "RVM-M128", "EVEX.NDS.256.66.0F.W0 F2 /r", "AVX512_F-VL"},
	{"vpslld", "W:ymm {kz}, ymm/m256/b32, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W0 72 /6 ib", "AVX512_F-VL"},
	{"vpslld", "W:zmm {kz}, zmm, xmm/m128", "RVM-M128", "EVEX.NDS.512.66.0F.W0 F2 /r", "AVX512_F"},
	{"vpslld", "W:zmm {kz}, zmm/m512/b32, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W0 72 /6 ib", "AVX512_F"},
	{"vpslldq", "W:xmm, xmm/m128, ib/ub", "VMI-FVM", "EVEX.NDD.128.66.0F.WIG 73 /7 ib", "AVX512_BW-VL"},
	{"vpslldq", "W:ymm, ymm/m256, ib/ub", "VMI-FVM", "EVEX.NDD.256.66.0F.WIG 73 /7 ib", "AVX512_BW-VL"},
	{"vpslldq", "W:zmm, zmm/m512, ib/ub", "VMI-FVM", "EVEX.NDD.512.66.0F.WIG 73 /7 ib", "AVX512_BW"},
	{"vpsllq", "W:xmm {kz}, xmm, xmm/m128", "RVM-M128", "EVEX.NDS.128.66.0F.W1 F3 /r", "AVX512_F-VL"},
	{"vpsllq", "W:xmm {kz}, xmm/m128/b64, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W1 73 /6 ib", "AVX512_F-VL"},
	{"vpsllq", "W:ymm {kz}, ymm, xmm/m128", "RVM-M128", "EVEX.NDS.256.66.0F.W1 F3 /r", "AVX512_F-VL"},
	{"vpsllq", "W:ymm {kz}, ymm/m256/b64, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W1 73 /6 ib", "AVX512_F-VL"},
	{"vpsllq", "W:zmm {kz}, zmm, xmm/m128", "RVM-M128", "EVEX.NDS.512.66.0F.W1 F3 /r", "AVX512_F"},
	{"vpsllq", "W:zmm {kz}, zmm/m512/b64, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W1 73 /6 ib", "AVX512_F"},
	{"vpsllvd", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 47 /r", "AVX512_F-VL"},
	{"vpsllvd", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 47 /r", "AVX512_F-VL"},
	{"vpsllvd", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 47 /r", "AVX512_F"},
	{"vpsllvq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 47 /r", "AVX512_F-VL"},
	{"vpsllvq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 47 /r", "AVX512_F-VL"},
	{"vpsllvq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 47 /r", "AVX512_F"},
	{"vpsllvw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W1 12 /r", "AVX512_BW-VL"},
	{"vpsllvw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W1 12 /r", "AVX512_BW-VL"},
	{"vpsllvw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W1 12 /r", "AVX512_BW"},
	{"vpsllw", "W:xmm {kz}, xmm, xmm/m128", "RVM-M128", "EVEX.NDS.128.66.0F.WIG F1 /r", "AVX512_BW-VL"},
	{"vpsllw", "W:xmm {kz}, xmm/m128, ib/ub", "VMI-FVM", "EVEX.NDD.128.66.0F.WIG 71 /6 ib", "AVX512_BW-VL"},
	{"vpsllw", "W:ymm {kz}, ymm, xmm/m128", "RVM-M128", "EVEX.NDS.256.66.0F.WIG F1 /r", "AVX512_BW-VL"},
	{"vpsllw", "W:ymm {kz}, ymm/m256, ib/ub", "VMI-FVM", "EVEX.NDD.256.66.0F.WIG 71 /6 ib", "AVX512_BW-VL"},
	{"vpsllw", "W:zmm {kz}, zmm, xmm/m128", "RVM-M128", "EVEX.NDS.512.66.0F.WIG F1 /r", "AVX512_BW"},
	{"vpsllw", "W:zmm {kz}, zmm/m512, ib/ub", "VMI-FVM", "EVEX.NDD.512.66.0F.WIG 71 /6 ib", "AVX512_BW"},
	{"vpsrad", "W:xmm {kz}, xmm, xmm/m128", "RVM-M128", "EVEX.NDS.128.66.0F.W0 E2 /r", "AVX512_F-VL"},
	{"vpsrad", "W:xmm {kz}, xmm/m128/b32, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W0 72 /4 ib", "AVX512_F-VL"},
	{"vpsrad", "W:ymm {kz}, ymm, xmm/m128", "RVM-M128", "EVEX.NDS.256.66.0F.W0 E2 /r", "AVX512_F-VL"},
	{"vpsrad", "W:ymm {kz}, ymm/m256/b32, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W0 72 /4 ib", "AVX512_F-VL"},
	{"vpsrad", "W:zmm {kz}, zmm, xmm/m128", "RVM-M128", "EVEX.NDS.512.66.0F.W0 E2 /r", "AVX512_F"},
	{"vpsrad", "W:zmm {kz}, zmm/m512/b32, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W0 72 /4 ib", "AVX512_F"},
	{"vpsraq", "W:xmm {kz}, xmm, xmm/m128", "RVM-M128", "EVEX.NDS.128.66.0F.W1 E2 /r", "AVX512_F-VL"},
	{"vpsraq", "W:xmm {kz}, xmm/m128/b64, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W1 72 /4 ib", "AVX512_F-VL"},
	{"vpsraq", "W:ymm {kz}, ymm, xmm/m128", "RVM-M128", "EVEX.NDS.256.66.0F.W1 E2 /r", "AVX512_F-VL"},
	{"vpsraq", "W:ymm {kz}, ymm/m256/b64, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W1 72 /4 ib", "AVX512_F-VL"},
	{"vpsraq", "W:zmm {kz}, zmm, xmm/m128", "RVM-M128", "EVEX.NDS.512.66.0F.W1 E2 /r", "AVX512_F"},
	{"vpsraq", "W:zmm {kz}, zmm/m512/b64, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W1 72 /4 ib", "AVX512_F"},
	{"vpsravd", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 46 /r", "AVX512_F-VL"},
	{"vpsravd", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 46 /r", "AVX512_F-VL"},
	{"vpsravd", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 46 /r", "AVX512_F"},
	{"vpsravq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 46 /r", "AVX512_F-VL"},
	{"vpsravq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 46 /r", "AVX512_F-VL"},
	{"vpsravq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 46 /r", "AVX512_F"},
	{"vpsravw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W1 11 /r", "AVX512_BW-VL"},
	{"vpsravw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W1 11 /r", "AVX512_BW-VL"},
	{"vpsravw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W1 11 /r", "AVX512_BW"},
	{"vpsraw", "W:xmm {kz}, xmm, xmm/m128", "RVM-M128", "EVEX.NDS.128.66.0F.WIG E1 /r", "AVX512_BW-VL"},
	{"vpsraw", "W:xmm {kz}, xmm/m128, ib/ub", "VMI-FVM", "EVEX.NDD.128.66.0F.WIG 71 /4 ib", "AVX512_BW-VL"},
	{"vpsraw", "W:ymm {kz}, ymm, xmm/m128", "RVM-M128", "EVEX.NDS.256.66.0F.WIG E1 /r", "AVX512_BW-VL"},
	{"vpsraw", "W:ymm {kz}, ymm/m256, ib/ub", "VMI-FVM", "EVEX.NDD.256.66.0F.WIG 71 /4 ib", "AVX512_BW-VL"},
	{"vpsraw", "W:zmm {kz}, zmm, xmm/m128", "RVM-M128", "EVEX.NDS.512.66.0F.WIG E1 /r", "AVX512_BW"},
	{"vpsraw", "W:zmm {kz}, zmm/m512, ib/ub", "VMI-FVM", "EVEX.NDD.512.66.0F.WIG 71 /4 ib", "AVX512_BW"},
	{"vpsrld", "W:xmm {kz}, xmm, xmm/m128", "RVM-M128", "EVEX.NDS.128.66.0F.W0 D2 /r", "AVX512_F-VL"},
	{"vpsrld", "W:xmm {kz}, xmm/m128/b32, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W0 72 /2 ib", "AVX512_F-VL"},
	{"vpsrld", "W:ymm {kz}, ymm, xmm/m128", "RVM-M128", "EVEX.NDS.256.66.0F.W0 D2 /r", "AVX512_F-VL"},
	{"vpsrld", "W:ymm {kz}, ymm/m256/b32, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W0 72 /2 ib", "AVX512_F-VL"},
	{"vpsrld", "W:zmm {kz}, zmm, xmm/m128", "RVM-M128", "EVEX.NDS.512.66.0F.W0 D2 /r", "AVX512_F"},
	{"vpsrld", "W:zmm {kz}, zmm/m512/b32, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W0 72 /2 ib", "AVX512_F"},
	{"vpsrldq", "W:xmm, xmm/m128, ib/ub", "VMI-FVM", "EVEX.NDD.128.66.0F.WIG 73 /3 ib", "AVX512_BW-VL"},
	{"vpsrldq", "W:ymm, ymm/m256, ib/ub", "VMI-FVM", "EVEX.NDD.256.66.0F.WIG 73 /3 ib", "AVX512_BW-VL"},
	{"vpsrldq", "W:zmm, zmm/m512, ib/ub", "VMI-FVM", "EVEX.NDD.512.66.0F.WIG 73 /3 ib", "AVX512_BW"},
	{"vpsrlq", "W:xmm {kz}, xmm, xmm/m128", "RVM-M128", "EVEX.NDS.128.66.0F.W1 D3 /r", "AVX512_F-VL"},
	{"vpsrlq", "W:xmm {kz}, xmm/m128/b64, ib/ub", "VMI-FV", "EVEX.NDD.128.66.0F.W1 73 /2 ib", "AVX512_F-VL"},
	{"vpsrlq", "W:ymm {kz}, ymm, xmm/m128", "RVM-M128", "EVEX.NDS.256.66.0F.W1 D3 /r", "AVX512_F-VL"},
	{"vpsrlq", "W:ymm {kz}, ymm/m256/b64, ib/ub", "VMI-FV", "EVEX.NDD.256.66.0F.W1 73 /2 ib", "AVX512_F-VL"},
	{"vpsrlq", "W:zmm {kz}, zmm, xmm/m128", "RVM-M128", "EVEX.NDS.512.66.0F.W1 D3 /r", "AVX512_F"},
	{"vpsrlq", "W:zmm {kz}, zmm/m512/b64, ib/ub", "VMI-FV", "EVEX.NDD.512.66.0F.W1 73 /2 ib", "AVX512_F"},
	{"vpsrlvd", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 45 /r", "AVX512_F-VL"},
	{"vpsrlvd", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 45 /r", "AVX512_F-VL"},
	{"vpsrlvd", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 45 /r", "AVX512_F"},
	{"vpsrlvq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 45 /r", "AVX512_F-VL"},
	{"vpsrlvq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 45 /r", "AVX512_F-VL"},
	{"vpsrlvq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 45 /r", "AVX512_F"},
	{"vpsrlvw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W1 10 /r", "AVX512_BW-VL"},
	{"vpsrlvw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W1 10 /r", "AVX512_BW-VL"},
	{"vpsrlvw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W1 10 /r", "AVX512_BW"},
	{"vpsrlw", "W:xmm {kz}, xmm, xmm/m128", "RVM-M128", "EVEX.NDS.128.66.0F.WIG D1 /r", "AVX512_BW-VL"},
	{"vpsrlw", "W:xmm {kz}, xmm/m128, ib/ub", "VMI-FVM", "EVEX.NDD.128.66.0F.WIG 71 /2 ib", "AVX512_BW-VL"},
	{"vpsrlw", "W:ymm {kz}, ymm, xmm/m128", "RVM-M128", "EVEX.NDS.256.66.0F.WIG D1 /r", "AVX512_BW-VL"},
	{"vpsrlw", "W:ymm {kz}, ymm/m256, ib/ub", "VMI-FVM", "EVEX.NDD.256.66.0F.WIG 71 /2 ib", "AVX512_BW-VL"},
	{"vpsrlw", "W:zmm {kz}, zmm, xmm/m128", "RVM-M128", "EVEX.NDS.512.66.0F.WIG D1 /r", "AVX512_BW"},
	{"vpsrlw", "W:zmm {kz}, zmm/m512, ib/ub", "VMI-FVM", "EVEX.NDD.512.66.0F.WIG 71 /2 ib", "AVX512_BW"},
	{"vpsubb", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG F8 /r", "AVX512_BW-VL"},
	{"vpsubb", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG F8 /r", "AVX512_BW-VL"},
	{"vpsubb", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG F8 /r", "AVX512_BW"},
	{"vpsubd", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F.W0 FA /r", "AVX512_F-VL"},
	{"vpsubd", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F.W0 FA /r", "AVX512_F-VL"},
	{"vpsubd", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F.W0 FA /r", "AVX512_F"},
	{"vpsubq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 FB /r", "AVX512_F-VL"},
	{"vpsubq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 FB /r", "AVX512_F-VL"},
	{"vpsubq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 FB /r", "AVX512_F"},
	{"vpsubsb", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG E8 /r", "AVX512_BW-VL"},
	{"vpsubsb", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG E8 /r", "AVX512_BW-VL"},
	{"vpsubsb", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG E8 /r", "AVX512_BW"},
	{"vpsubsw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG E9 /r", "AVX512_BW-VL"},
	{"vpsubsw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG E9 /r", "AVX512_BW-VL"},
	{"vpsubsw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG E9 /r", "AVX512_BW"},
	{"vpsubusb", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG D8 /r", "AVX512_BW-VL"},
	{"vpsubusb", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG D8 /r", "AVX512_BW-VL"},
	{"vpsubusb", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG D8 /r", "AVX512_BW"},
	{"vpsubusw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG D9 /r", "AVX512_BW-VL"},
	{"vpsubusw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG D9 /r", "AVX512_BW-VL"},
	{"vpsubusw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG D9 /r", "AVX512_BW"},
	{"vpsubw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG F9 /r", "AVX512_BW-VL"},
	{"vpsubw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG F9 /r", "AVX512_BW-VL"},
	{"vpsubw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG F9 /r", "AVX512_BW"},
	{"vpternlogd", "X:xmm {kz}, xmm, xmm/m128/b32, ib/ub", "RVMI-FV", "EVEX.DDS.128.66.0F3A.W0 25 /r ib", "AVX512_F-VL"},
	{"vpternlogd", "X:ymm {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.DDS.256.66.0F3A.W0 25 /r ib", "AVX512_F-VL"},
	{"vpternlogd", "X:zmm {kz}, zmm, zmm/m512/b32, ib/ub", "RVMI-FV", "EVEX.DDS.512.66.0F3A.W0 25 /r ib", "AVX512_F"},
	{"vpternlogq", "X:xmm {kz}, xmm, xmm/m128/b64, ib/ub", "RVMI-FV", "EVEX.DDS.128.66.0F3A.W1 25 /r ib", "AVX512_F-VL"},
	{"vpternlogq", "X:ymm {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.DDS.256.66.0F3A.W1 25 /r ib", "AVX512_F-VL"},
	{"vpternlogq", "X:zmm {kz}, zmm, zmm/m512/b64, ib/ub", "RVMI-FV", "EVEX.DDS.512.66.0F3A.W1 25 /r ib", "AVX512_F"},
	{"vptestmb", "W:k {k}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W0 26 /r", "AVX512_BW-VL"},
	{"vptestmb", "W:k {k}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W0 26 /r", "AVX512_BW-VL"},
	{"vptestmb", "W:k {k}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W0 26 /r", "AVX512_BW"},
	{"vptestmd", "W:k {k}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 27 /r", "AVX512_F-VL"},
	{"vptestmd", "W:k {k}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 27 /r", "AVX512_F-VL"},
	{"vptestmd", "W:k {k}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 27 /r", "AVX512_F"},
	{"vptestmq", "W:k {k}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 27 /r", "AVX512_F-VL"},
	{"vptestmq", "W:k {k}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 27 /r", "AVX512_F-VL"},
	{"vptestmq", "W:k {k}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 27 /r", "AVX512_F"},
	{"vptestmw", "W:k {k}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F38.W1 26 /r", "AVX512_BW-VL"},
	{"vptestmw", "W:k {k}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F38.W1 26 /r", "AVX512_BW-VL"},
	{"vptestmw", "W:k {k}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F38.W1 26 /r", "AVX512_BW"},
	{"vptestnmb", "W:k {k}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.F3.0F38.W0 26 /r", "AVX512_BW-VL"},
	{"vptestnmb", "W:k {k}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.F3.0F38.W0 26 /r", "AVX512_BW-VL"},
	{"vptestnmb", "W:k {k}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.F3.0F38.W0 26 /r", "AVX512_BW"},
	{"vptestnmd", "W:k {k}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.F3.0F38.W0 27 /r", "AVX512_F-VL"},
	{"vptestnmd", "W:k {k}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.F3.0F38.W0 27 /r", "AVX512_F-VL"},
	{"vptestnmd", "W:k {k}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.F3.0F38.W0 27 /r", "AVX512_F"},
	{"vptestnmq", "W:k {k}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.F3.0F38.W1 27 /r", "AVX512_F-VL"},
	{"vptestnmq", "W:k {k}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.F3.0F38.W1 27 /r", "AVX512_F-VL"},
	{"vptestnmq", "W:k {k}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.F3.0F38.W1 27 /r", "AVX512_F"},
	{"vptestnmw", "W:k {k}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.F3.0F38.W1 26 /r", "AVX512_BW-VL"},
	{"vptestnmw", "W:k {k}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.F3.0F38.W1 26 /r", "AVX512_BW-VL"},
	{"vptestnmw", "W:k {k}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.F3.0F38.W1 26 /r", "AVX512_BW"},
	{"vpunpckhbw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG 68 /r", "AVX512_BW-VL"},
	{"vpunpckhbw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG 68 /r", "AVX512_BW-VL"},
	{"vpunpckhbw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG 68 /r", "AVX512_BW"},
	{"vpunpckhdq", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F.W0 6A /r", "AVX512_F-VL"},
	{"vpunpckhdq", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F.W0 6A /r", "AVX512_F-VL"},
	{"vpunpckhdq", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F.W0 6A /r", "AVX512_F"},
	{"vpunpckhqdq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 6D /r", "AVX512_F-VL"},
	{"vpunpckhqdq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 6D /r", "AVX512_F-VL"},
	{"vpunpckhqdq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 6D /r", "AVX512_F"},
	{"vpunpckhwd", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG 69 /r", "AVX512_BW-VL"},
	{"vpunpckhwd", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG 69 /r", "AVX512_BW-VL"},
	{"vpunpckhwd", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG 69 /r", "AVX512_BW"},
	{"vpunpcklbw", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG 60 /r", "AVX512_BW-VL"},
	{"vpunpcklbw", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG 60 /r", "AVX512_BW-VL"},
	{"vpunpcklbw", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG 60 /r", "AVX512_BW"},
	{"vpunpckldq", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F.W0 62 /r", "AVX512_F-VL"},
	{"vpunpckldq", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F.W0 62 /r", "AVX512_F-VL"},
	{"vpunpckldq", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F.W0 62 /r", "AVX512_F"},
	{"vpunpcklqdq", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 6C /r", "AVX512_F-VL"},
	{"vpunpcklqdq", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 6C /r", "AVX512_F-VL"},
	{"vpunpcklqdq", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 6C /r", "AVX512_F"},
	{"vpunpcklwd", "W:xmm {kz}, xmm, xmm/m128", "RVM-FVM", "EVEX.NDS.128.66.0F.WIG 61 /r", "AVX512_BW-VL"},
	{"vpunpcklwd", "W:ymm {kz}, ymm, ymm/m256", "RVM-FVM", "EVEX.NDS.256.66.0F.WIG 61 /r", "AVX512_BW-VL"},
	{"vpunpcklwd", "W:zmm {kz}, zmm, zmm/m512", "RVM-FVM", "EVEX.NDS.512.66.0F.WIG 61 /r", "AVX512_BW"},
	{"vpxord", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F.W0 EF /r", "AVX512_F-VL"},
	{"vpxord", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F.W0 EF /r", "AVX512_F-VL"},
	{"vpxord", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.66.0F.W0 EF /r", "AVX512_F"},
	{"vpxorq", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 EF /r", "AVX512_F-VL"},
	{"vpxorq", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 EF /r", "AVX512_F-VL"},
	{"vpxorq", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 EF /r", "AVX512_F"},
	{"vrangepd", "W:xmm {kz}, xmm, xmm/m128/b64, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W1 50 /r ib", "AVX512_DQ-VL"},
	{"vrangepd", "W:ymm {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W1 50 /r ib", "AVX512_DQ-VL"},
	{"vrangepd", "W:zmm {kz}, zmm, zmm/m512/b64, ib/ub {sae}", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W1 50 /r ib", "AVX512_DQ"},
	{"vrangeps", "W:xmm {kz}, xmm, xmm/m128/b32, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F3A.W0 50 /r ib", "AVX512_DQ-VL"},
	{"vrangeps", "W:ymm {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W0 50 /r ib", "AVX512_DQ-VL"},
	{"vrangeps", "W:zmm {kz}, zmm, zmm/m512/b32, ib/ub {sae}", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W0 50 /r ib", "AVX512_DQ"},
	{"vrangesd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64,ib/ub {sae}", "RVMI-T1S", "EVEX.NDS.LIG.66.0F3A.W1 51 /r ib", "AVX512_DQ"},
	{"vrangess", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32,ib/ub {sae}", "RVMI-T1S", "EVEX.NDS.LIG.66.0F3A.W0 51 /r ib", "AVX512_DQ"},
	{"vrcp14pd", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F38.W1 4C /r", "AVX512_F-VL"},
	{"vrcp14pd", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F38.W1 4C /r", "AVX512_F-VL"},
	{"vrcp14pd", "W:zmm {kz}, zmm/m512/b64", "RM-FV", "EVEX.512.66.0F38.W1 4C /r", "AVX512_F"},
	{"vrcp14ps", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.66.0F38.W0 4C /r", "AVX512_F-VL"},
	{"vrcp14ps", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.66.0F38.W0 4C /r", "AVX512_F-VL"},
	{"vrcp14ps", "W:zmm {kz}, zmm/m512/b32", "RM-FV", "EVEX.512.66.0F38.W0 4C /r", "AVX512_F"},
	{"vrcp14sd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W1 4D /r", "AVX512_F"},
	{"vrcp14ss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W0 4D /r", "AVX512_F"},
	{"vrcp28pd", "W:zmm {kz}, zmm/m512/b64 {sae}", "RM-FV", "EVEX.512.66.0F38.W1 CA /r", "AVX512_ERI"},
	{"vrcp28ps", "W:zmm {kz}, zmm/m512/b32 {sae}", "RM-FV", "EVEX.512.66.0F38.W0 CA /r", "AVX512_ERI"},
	{"vrcp28sd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {sae}", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W1 CB /r", "AVX512_ERI"},
	{"vrcp28ss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {sae}", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W0 CB /r", "AVX512_ERI"},
	{"vreducepd", "W:xmm {kz}, xmm/m128/b64, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W1 56 /r ib", "AVX512_DQ-VL"},
	{"vreducepd", "W:ymm {kz}, ymm/m256/b64, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W1 56 /r ib", "AVX512_DQ-VL"},
	{"vreducepd", "W:zmm {kz}, zmm/m512/b64, ib/ub", "RMI-FV", "EVEX.512.66.0F3A.W1 56 /r ib", "AVX512_DQ"},
	{"vreduceps", "W:xmm {kz}, xmm/m128/b32, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W0 56 /r ib", "AVX512_DQ-VL"},
	{"vreduceps", "W:ymm {kz}, ymm/m256/b32, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W0 56 /r ib", "AVX512_DQ-VL"},
	{"vreduceps", "W:zmm {kz}, zmm/m512/b32, ib/ub", "RMI-FV", "EVEX.512.66.0F3A.W0 56 /r ib", "AVX512_DQ"},
	{"vreducesd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64, ib/ub", "RVMI-T1S", "EVEX.NDS.LIG.66.0F3A.W1 57 /r ib", "AVX512_DQ"},
	{"vreducess", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32, ib/ub", "RVMI-T1S", "EVEX.NDS.LIG.66.0F3A.W0 57 /r ib", "AVX512_DQ"},
	{"vrndscalepd", "W:xmm {kz}, xmm/m128/b64, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W1 09 /r ib", "AVX512_F-VL"},
	{"vrndscalepd", "W:ymm {kz}, ymm/m256/b64, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W1 09 /r ib", "AVX512_F-VL"},
	{"vrndscalepd", "W:zmm {kz}, zmm/m512/b64, ib/ub {sae}", "RMI-FV", "EVEX.512.66.0F3A.W1 09 /r ib", "AVX512_F"},
	{"vrndscaleps", "W:xmm {kz}, xmm/m128/b32, ib/ub", "RMI-FV", "EVEX.128.66.0F3A.W0 08 /r ib", "AVX512_F-VL"},
	{"vrndscaleps", "W:ymm {kz}, ymm/m256/b32, ib/ub", "RMI-FV", "EVEX.256.66.0F3A.W0 08 /r ib", "AVX512_F-VL"},
	{"vrndscaleps", "W:zmm {kz}, zmm/m512/b32, ib/ub {sae}", "RMI-FV", "EVEX.512.66.0F3A.W0 08 /r ib", "AVX512_F"},
	{"vrndscalesd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64,ib/ub {sae}", "RVMI-T1S", "EVEX.NDS.LIG.66.0F3A.W1 0B /r ib", "AVX512_F"},
	{"vrndscaless", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32,ib/ub {sae}", "RVMI-T1S", "EVEX.NDS.LIG.66.0F3A.W0 0A /r ib", "AVX512_F"},
	{"vrsqrt14pd", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F38.W1 4E /r", "AVX512_F-VL"},
	{"vrsqrt14pd", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F38.W1 4E /r", "AVX512_F-VL"},
	{"vrsqrt14pd", "W:zmm {kz}, zmm/m512/b64", "RM-FV", "EVEX.512.66.0F38.W1 4E /r", "AVX512_F"},
	{"vrsqrt14ps", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.66.0F38.W0 4E /r", "AVX512_F-VL"},
	{"vrsqrt14ps", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.66.0F38.W0 4E /r", "AVX512_F-VL"},
	{"vrsqrt14ps", "W:zmm {kz}, zmm/m512/b32", "RM-FV", "EVEX.512.66.0F38.W0 4E /r", "AVX512_F"},
	{"vrsqrt14sd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W1 4F /r", "AVX512_F"},
	{"vrsqrt14ss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W0 4F /r", "AVX512_F"},
	{"vrsqrt28pd", "W:zmm {kz}, zmm/m512/b64 {sae}", "RM-FV", "EVEX.512.66.0F38.W1 CC /r", "AVX512_ERI"},
	{"vrsqrt28ps", "W:zmm {kz}, zmm/m512/b32 {sae}", "RM-FV", "EVEX.512.66.0F38.W0 CC /r", "AVX512_ERI"},
	{"vrsqrt28sd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {sae}", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W1 CD /r", "AVX512_ERI"},
	{"vrsqrt28ss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {sae}", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W0 CD /r", "AVX512_ERI"},
	{"vscalefpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F38.W1 2C /r", "AVX512_F-VL"},
	{"vscalefpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F38.W1 2C /r", "AVX512_F-VL"},
	{"vscalefpd", "W:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W1 2C /r", "AVX512_F"},
	{"vscalefps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.66.0F38.W0 2C /r", "AVX512_F-VL"},
	{"vscalefps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.66.0F38.W0 2C /r", "AVX512_F-VL"},
	{"vscalefps", "W:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.66.0F38.W0 2C /r", "AVX512_F"},
	{"vscalefsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W1 2D /r", "AVX512_F"},
	{"vscalefss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.66.0F38.W0 2D /r", "AVX512_F"},
	{"vscatterdpd", "W:vm32x {k}, xmm", "MR-T1S", "EVEX.128.66.0F38.W1 A2 /r", "AVX512_F-VL"},
	{"vscatterdpd", "W:vm32x {k}, ymm", "MR-T1S", "EVEX.256.66.0F38.W1 A2 /r", "AVX512_F-VL"},
	{"vscatterdpd", "W:vm32y {k}, zmm", "MR-T1S", "EVEX.512.66.0F38.W1 A2 /r", "AVX512_F"},
	{"vscatterdps", "W:vm32x {k}, xmm", "MR-T1S", "EVEX.128.66.0F38.W0 A2 /r", "AVX512_F-VL"},
	{"vscatterdps", "W:vm32y {k}, ymm", "MR-T1S", "EVEX.256.66.0F38.W0 A2 /r", "AVX512_F-VL"},
	{"vscatterdps", "W:vm32z {k}, zmm", "MR-T1S", "EVEX.512.66.0F38.W0 A2 /r", "AVX512_F"},
	{"vscatterpf0dpd", "R:vm32y {k}", "M-T1S", "EVEX.512.66.0F38.W1 C6 /5", "AVX512_PFI"},
	{"vscatterpf0dps", "R:vm32z {k}", "M-T1S", "EVEX.512.66.0F38.W0 C6 /5", "AVX512_PFI"},
	{"vscatterpf0qpd", "R:vm64z {k}", "M-T1S", "EVEX.512.66.0F38.W1 C7 /5", "AVX512_PFI"},
	{"vscatterpf0qps", "R:vm64z {k}", "M-T1S", "EVEX.512.66.0F38.W0 C7 /5", "AVX512_PFI"},
	{"vscatterpf1dpd", "R:vm32y {k}", "M-T1S", "EVEX.512.66.0F38.W1 C6 /6", "AVX512_PFI"},
	{"vscatterpf1dps", "R:vm32z {k}", "M-T1S", "EVEX.512.66.0F38.W0 C6 /6", "AVX512_PFI"},
	{"vscatterpf1qpd", "R:vm64z {k}", "M-T1S", "EVEX.512.66.0F38.W1 C7 /6", "AVX512_PFI"},
	{"vscatterpf1qps", "R:vm64z {k}", "M-T1S", "EVEX.512.66.0F38.W0 C7 /6", "AVX512_PFI"},
	{"vscatterqpd", "W:vm64x {k}, xmm", "MR-T1S", "EVEX.128.66.0F38.W1 A3", "AVX512_F-VL"},
	{"vscatterqpd", "W:vm64y {k}, ymm", "MR-T1S", "EVEX.256.66.0F38.W1 A3", "AVX512_F-VL"},
	{"vscatterqpd", "W:vm64z {k}, zmm", "MR-T1S", "EVEX.512.66.0F38.W1 A3", "AVX512_F"},
	{"vscatterqps", "W:vm64x {k}, xmm", "MR-T1S", "EVEX.128.66.0F38.W0 A3", "AVX512_F-VL"},
	{"vscatterqps", "W:vm64y {k}, xmm", "MR-T1S", "EVEX.256.66.0F38.W0 A3", "AVX512_F-VL"},
	{"vscatterqps", "W:vm64z {k}, ymm", "MR-T1S", "EVEX.512.66.0F38.W0 A3", "AVX512_F"},
	{"vshuff32x4", "W:ymm {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W0 23 /r ib", "AVX512_F-VL"},
	{"vshuff32x4", "W:zmm {kz}, zmm, zmm/m512/b32, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W0 23 /r ib", "AVX512_F"},
	{"vshuff64x2", "W:ymm {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W1 23 /r ib", "AVX512_F-VL"},
	{"vshuff64x2", "W:zmm {kz}, zmm, zmm/m512/b64, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W1 23 /r ib", "AVX512_F"},
	{"vshufi32x4", "W:ymm {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W0 43 /r ib", "AVX512_F-VL"},
	{"vshufi32x4", "W:zmm {kz}, zmm, zmm/m512/b32, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W0 43 /r ib", "AVX512_F"},
	{"vshufi64x2", "W:ymm {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F3A.W1 43 /r ib", "AVX512_F-VL"},
	{"vshufi64x2", "W:zmm {kz}, zmm, zmm/m512/b64, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F3A.W1 43 /r ib", "AVX512_F"},
	{"vshufpd", "W:xmm {kz}, xmm, xmm/m128/b32, ib/ub", "RVMI-FV", "EVEX.NDS.128.66.0F.W1 C6 /r ib", "AVX512_F-VL"},
	{"vshufpd", "W:ymm {kz}, ymm, ymm/m256/b32, ib/ub", "RVMI-FV", "EVEX.NDS.256.66.0F.W1 C6 /r ib", "AVX512_F-VL"},
	{"vshufpd", "W:zmm {kz}, zmm, zmm/m512/b32, ib/ub", "RVMI-FV", "EVEX.NDS.512.66.0F.W1 C6 /r ib", "AVX512_F"},
	{"vshufps", "W:xmm {kz}, xmm, xmm/m128/b64, ib/ub", "RVMI-FV", "EVEX.NDS.128.0F.W0 C6 /r ib", "AVX512_F-VL"},
	{"vshufps", "W:ymm {kz}, ymm, ymm/m256/b64, ib/ub", "RVMI-FV", "EVEX.NDS.256.0F.W0 C6 /r ib", "AVX512_F-VL"},
	{"vshufps", "W:zmm {kz}, zmm, zmm/m512/b64, ib/ub", "RVMI-FV", "EVEX.NDS.512.0F.W0 C6 /r ib", "AVX512_F"},
	{"vsqrtpd", "W:xmm {kz}, xmm/m128/b64", "RM-FV", "EVEX.128.66.0F.W1 51 /r", "AVX512_F-VL"},
	{"vsqrtpd", "W:ymm {kz}, ymm/m256/b64", "RM-FV", "EVEX.256.66.0F.W1 51 /r", "AVX512_F-VL"},
	{"vsqrtpd", "W:zmm {kz}, zmm/m512/b64 {er}", "RM-FV", "EVEX.512.66.0F.W1 51 /r", "AVX512_F"},
	{"vsqrtps", "W:xmm {kz}, xmm/m128/b32", "RM-FV", "EVEX.128.0F.W0 51 /r", "AVX512_F-VL"},
	{"vsqrtps", "W:ymm {kz}, ymm/m256/b32", "RM-FV", "EVEX.256.0F.W0 51 /r", "AVX512_F-VL"},
	{"vsqrtps", "W:zmm {kz}, zmm/m512/b32 {er}", "RM-FV", "EVEX.512.0F.W0 51 /r", "AVX512_F"},
	{"vsqrtsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 51 /r", "AVX512_F"},
	{"vsqrtss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 51 /r", "AVX512_F"},
	{"vsubpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 5C /r", "AVX512_F-VL"},
	{"vsubpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 5C /r", "AVX512_F-VL"},
	{"vsubpd", "W:zmm {kz}, zmm, zmm/m512/b64 {er}", "RVM-FV", "EVEX.NDS.512.66.0F.W1 5C /r", "AVX512_F"},
	{"vsubps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 5C /r", "AVX512_F-VL"},
	{"vsubps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 5C /r", "AVX512_F-VL"},
	{"vsubps", "W:zmm {kz}, zmm, zmm/m512/b32 {er}", "RVM-FV", "EVEX.NDS.512.0F.W0 5C /r", "AVX512_F"},
	{"vsubsd", "W:xmm {kz}, xmm{15:8}, xmm{7:0}/m64 {er}", "RVM-T1S", "EVEX.NDS.LIG.F2.0F.W1 5C /r", "AVX512_F"},
	{"vsubss", "W:xmm {kz}, xmm{15:4}, xmm{3:0}/m32 {er}", "RVM-T1S", "EVEX.NDS.LIG.F3.0F.W0 5C /r", "AVX512_F"},
	{"vucomisd", "R:xmm{7:0}, xmm{7:0}/m64 {sae}", "RM-T1S", "EVEX.LIG.66.0F.W1 2E /r", "AVX512_F OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"vucomiss", "R:xmm{3:0}, xmm{3:0}/m32 {sae}", "RM-T1S", "EVEX.LIG.0F.W0 2E /r", "AVX512_F OF=0 SF=0 ZF=W AF=0 PF=W CF=W"},
	{"vunpckhpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 15 /r", "AVX512_F-VL"},
	{"vunpckhpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 15 /r", "AVX512_F-VL"},
	{"vunpckhpd", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 15 /r", "AVX512_F"},
	{"vunpckhps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 15 /r", "AVX512_F-VL"},
	{"vunpckhps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 15 /r", "AVX512_F-VL"},
	{"vunpckhps", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.0F.W0 15 /r", "AVX512_F"},
	{"vunpcklpd", "W:xmm {kz}, xmm, xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 14 /r", "AVX512_F-VL"},
	{"vunpcklpd", "W:ymm {kz}, ymm, ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 14 /r", "AVX512_F-VL"},
	{"vunpcklpd", "W:zmm {kz}, zmm, zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 14 /r", "AVX512_F"},
	{"vunpcklps", "W:xmm {kz}, xmm, xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 14 /r", "AVX512_F-VL"},
	{"vunpcklps", "W:ymm {kz}, ymm, ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 14 /r", "AVX512_F-VL"},
	{"vunpcklps", "W:zmm {kz}, zmm, zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.0F.W0 14 /r", "AVX512_F"},
	{"vxorpd", "W:xmm {kz},~xmm,~xmm/m128/b64", "RVM-FV", "EVEX.NDS.128.66.0F.W1 57 /r", "AVX512_DQ-VL"},
	{"vxorpd", "W:ymm {kz},~ymm,~ymm/m256/b64", "RVM-FV", "EVEX.NDS.256.66.0F.W1 57 /r", "AVX512_DQ-VL"},
	{"vxorpd", "W:zmm {kz},~zmm,~zmm/m512/b64", "RVM-FV", "EVEX.NDS.512.66.0F.W1 57 /r", "AVX512_DQ"},
	{"vxorps", "W:xmm {kz},~xmm,~xmm/m128/b32", "RVM-FV", "EVEX.NDS.128.0F.W0 57 /r", "AVX512_DQ-VL"},
	{"vxorps", "W:ymm {kz},~ymm,~ymm/m256/b32", "RVM-FV", "EVEX.NDS.256.0F.W0 57 /r", "AVX512_DQ-VL"},
	{"vxorps", "W:zmm {kz},~zmm,~zmm/m512/b32", "RVM-FV", "EVEX.NDS.512.0F.W0 57 /r", "AVX512_DQ"},
}

```

`lua/core/init.lua`:

```lua
include("proxies.lua")
include("printhelper.lua")
include("registers.lua")
include("assembler.lua")

```

`lua/core/printhelper.lua`:

```lua
function printhexdump(buf)
	local l = ""
	for i=1,math.ceil(#buf/16) * 16 do
		if (i-1) % 16 == 0 then l = l .. string.format("%08X  ", i-1) end
		l = l .. ( i > #buf and "   " or string.format("%02X ", buf:byte(i)) )
		if i %  8 == 0 then l = l .. " " end
		if i % 16 == 0 then l = l .. buf:sub(i-16+1, i):gsub("%c",".") .. "\n" end
	end
	if l:sub(-1, -1) == "\n" then
		l = l:sub(1, #l - 1)
	end
	print(l)
end

function printtable(node)
    -- to make output beautiful
    local function tab(amt)
        local str = ""
        for i=1,amt do
            str = str .. "  "
        end
        return str
    end

    local cache, stack, output = {},{},{}
    local depth = 1
    local output_str = "{\n"

    while true do
        local size = 0
        for k,v in pairs(node) do
            size = size + 1
        end

        local cur_index = 1
        for k,v in pairs(node) do
            if (cache[node] == nil) or (cur_index >= cache[node]) then

                if (string.find(output_str,"}",output_str:len())) then
                    output_str = output_str .. ",\n"
                elseif not (string.find(output_str,"\n",output_str:len())) then
                    output_str = output_str .. "\n"
                end

                -- This is necessary for working with HUGE tables otherwise we run out of memory using concat on huge strings
                table.insert(output,output_str)
                output_str = ""

                local key
                if (type(k) == "number" or type(k) == "boolean") then
                    key = "["..tostring(k).."]"
                else
                    key = "['"..tostring(k).."']"
                end

                if (type(v) == "number" or type(v) == "boolean") then
                    output_str = output_str .. tab(depth) .. key .. " = "..tostring(v)
                elseif (type(v) == "table") then
                    output_str = output_str .. tab(depth) .. key .. " = {\n"
                    table.insert(stack,node)
                    table.insert(stack,v)
                    cache[node] = cur_index+1
                    break
                else
                    output_str = output_str .. tab(depth) .. key .. " = '"..tostring(v).."'"
                end

                if (cur_index == size) then
                    output_str = output_str .. "\n" .. tab(depth-1) .. "}"
                else
                    output_str = output_str .. ","
                end
            else
                -- close the table
                if (cur_index == size) then
                    output_str = output_str .. "\n" .. tab(depth-1) .. "}"
                end
            end

            cur_index = cur_index + 1
        end

        if (size == 0) then
            output_str = output_str .. "\n" .. tab(depth-1) .. "}"
        end

        if (#stack > 0) then
            node = stack[#stack]
            stack[#stack] = nil
            depth = cache[node] == nil and depth + 1 or depth - 1
        else
            break
        end
    end

    -- This is necessary for working with HUGE tables otherwise we run out of memory using concat on huge strings
    table.insert(output,output_str)
    output_str = table.concat(output)

    print(output_str)
end
```

`lua/core/proxies.lua`:

```lua
proxies = {}

local _INSTALLED_PROXIES = {}

function proxies.install(proxy)
	table.insert(_INSTALLED_PROXIES, proxy)
end

function proxies.getInstalled()
	return _INSTALLED_PROXIES
end

setmetatable(_G, { 
	__index = function(t, k)
		for _,proxy in pairs(_INSTALLED_PROXIES) do
			if proxy.__index ~= nil then
				local r = proxy.__index(t, k)
				if r ~= nil then
					return r
				end
			end
		end
		return rawget(t, k) 
	end, 
	__newindex = function(t, k, v)
		for _,proxy in pairs(_INSTALLED_PROXIES) do
			if proxy.__newindex ~= nil then
				local r = proxy.__newindex(t, k, v)
				if r ~= nil then
					return
				end
			end
		end
		return rawset(t, k, v) 
	end, 
})
```

`lua/core/registers.lua`:

```lua
-- Create a proxy on _G __index/__newindex to get direct access to registers without having
-- to use registers lib directly. So instead of having registers.write("rax", 1) we can say rax = 1
local register_names = 
{ 
	["rflags"] = true,
	["eflags"] = true,
	["rax"] = true, 
	["eax"] = true, 
	["ax"] = true, 
	["ah"] = true, 
	["al"] = true,
	["rbx"] = true, 
	["ebx"] = true, 
	["bx"] = true, 
	["bh"] = true, 
	["bl"] = true, 
	["rcx"] = true, 
	["ecx"] = true, 
	["cx"] = true, 
	["ch"] = true, 
	["cl"] = true, 
	["rdx"] = true, 
	["edx"] = true, 
	["dx"] = true, 
	["dh"] = true, 
	["dl"] = true, 
	["rdi"] = true, 
	["edi"] = true, 
	["di"] = true, 
	["dil"] = true, 
	["rsi"] = true, 
	["esi"] = true, 
	["si"] = true, 
	["sil"] = true, 
	["rbp"] = true, 
	["ebp"] = true, 
	["bp"] = true, 
	["bpl"] = true, 
	["rsp"] = true, 
	["esp"] = true, 
	["sp"] = true, 
	["spl"] = true, 
	["rip"] = true, 
	["eip"] = true, 
	["r8"] = true, 
	["r8d"] = true, 
	["r8w"] = true, 
	["r8b"] = true, 
} 

local function IS_REGISTER(k) 
	return register_names[string.lower(k)] == true 
end

proxies.install({
	__index = function(t, k) 
		if IS_DEBUGGING and IS_REGISTER(k) then
			return registers.read(k) 
		end
		return nil
	end, 
	__newindex = function(t, k, v)
		if IS_DEBUGGING and IS_REGISTER(k) then
			registers.write(k, v)
			return true
		end
		return nil
	end, 
})
```

`lua/examples/assembler_basics.lua`:

```lua
local a = assembler.create()

local label1 = a:createLabel("label1") 
local label2 = a:createLabel("label2")

-- GAS
-- base = rax, index = rbx, disp = 3
local ref1 = a.rax+0x03+a.rbx
local ref2 = a.rbx*1 + 1 + 2
local ref3 = a.rax+a.rbx+0x03
-- base = rax, index = rbx, disp = 3, label = label1
local ref4 = a.rbx*1 + 1 + 2 + a.rax + label1

a:mov(a.dword_ptr(a.rax), 1)
a:lea(a.rax, a.qword_ptr(a.rax*2))
a:mov(a.rcx, label2) -- Usage before binding.
a:mov(a.eax, 1)
a:lea(a.rax, a.qword_ptr(label1))
a:mov(a.edx, 2)
a:bindLabel(label1)
a:sub(a.edx, a.eax)
a:cmp(a.edx, 0)
a:ja(label1) -- Usage after binding.
a:lea(a.rax, a.qword_ptr(a.rax*2))
a:mov(a.rcx, label1) -- Usage before binding.
a:mov(a.eax, 1)
a:bindLabel(label2)
a:lea(a.rax, a.qword_ptr(label1))
a:mov(a.edx, 2)
a:sub(a.edx, a.eax)
a:cmp(a.edx, 0)

-- If we are not debugging we dont copy it to rip.
local rip = IS_DEBUGGING and rip or 0x00400000
local bytes = a:make(rip, true --[[ dump output ]])
if IS_DEBUGGING then
	for i = 1, #bytes do
		byte_ptr[rip + (i - 1)] = bytes:byte(i)
	end
end

```

`lua/libs/ltn12.lua`:

```lua
-----------------------------------------------------------------------------
-- LTN12 - Filters, sources, sinks and pumps.
-- LuaSocket toolkit.
-- Author: Diego Nehab
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module
-----------------------------------------------------------------------------
local string = require("string")
local table = require("table")
local unpack = unpack or table.unpack
local base = _G
local _M = {}
if module then -- heuristic for exporting a global package table
    ltn12 = _M
end
local filter,source,sink,pump = {},{},{},{}

_M.filter = filter
_M.source = source
_M.sink = sink
_M.pump = pump

local unpack = unpack or table.unpack
local select = base.select

-- 2048 seems to be better in windows...
_M.BLOCKSIZE = 2048
_M._VERSION = "LTN12 1.0.3"

-----------------------------------------------------------------------------
-- Filter stuff
-----------------------------------------------------------------------------
-- returns a high level filter that cycles a low-level filter
function filter.cycle(low, ctx, extra)
    base.assert(low)
    return function(chunk)
        local ret
        ret, ctx = low(ctx, chunk, extra)
        return ret
    end
end

-- chains a bunch of filters together
-- (thanks to Wim Couwenberg)
function filter.chain(...)
    local arg = {...}
    local n = base.select('#',...)
    local top, index = 1, 1
    local retry = ""
    return function(chunk)
        retry = chunk and retry
        while true do
            if index == top then
                chunk = arg[index](chunk)
                if chunk == "" or top == n then return chunk
                elseif chunk then index = index + 1
                else
                    top = top+1
                    index = top
                end
            else
                chunk = arg[index](chunk or "")
                if chunk == "" then
                    index = index - 1
                    chunk = retry
                elseif chunk then
                    if index == n then return chunk
                    else index = index + 1 end
                else base.error("filter returned inappropriate nil") end
            end
        end
    end
end

-----------------------------------------------------------------------------
-- Source stuff
-----------------------------------------------------------------------------
-- create an empty source
local function empty()
    return nil
end

function source.empty()
    return empty
end

-- returns a source that just outputs an error
function source.error(err)
    return function()
        return nil, err
    end
end

-- creates a file source
function source.file(handle, io_err)
    if handle then
        return function()
            local chunk = handle:read(_M.BLOCKSIZE)
            if not chunk then handle:close() end
            return chunk
        end
    else return source.error(io_err or "unable to open file") end
end

-- turns a fancy source into a simple source
function source.simplify(src)
    base.assert(src)
    return function()
        local chunk, err_or_new = src()
        src = err_or_new or src
        if not chunk then return nil, err_or_new
        else return chunk end
    end
end

-- creates string source
function source.string(s)
    if s then
        local i = 1
        return function()
            local chunk = string.sub(s, i, i+_M.BLOCKSIZE-1)
            i = i + _M.BLOCKSIZE
            if chunk ~= "" then return chunk
            else return nil end
        end
    else return source.empty() end
end

-- creates table source
function source.table(t)
    base.assert('table' == type(t))
    local i = 0
    return function()
        i = i + 1
        return t[i]
    end
end

-- creates rewindable source
function source.rewind(src)
    base.assert(src)
    local t = {}
    return function(chunk)
        if not chunk then
            chunk = table.remove(t)
            if not chunk then return src()
            else return chunk end
        else
            table.insert(t, chunk)
        end
    end
end

-- chains a source with one or several filter(s)
function source.chain(src, f, ...)
    if ... then f=filter.chain(f, ...) end
    base.assert(src and f)
    local last_in, last_out = "", ""
    local state = "feeding"
    local err
    return function()
        if not last_out then
            base.error('source is empty!', 2)
        end
        while true do
            if state == "feeding" then
                last_in, err = src()
                if err then return nil, err end
                last_out = f(last_in)
                if not last_out then
                    if last_in then
                        base.error('filter returned inappropriate nil')
                    else
                        return nil
                    end
                elseif last_out ~= "" then
                    state = "eating"
                    if last_in then last_in = "" end
                    return last_out
                end
            else
                last_out = f(last_in)
                if last_out == "" then
                    if last_in == "" then
                        state = "feeding"
                    else
                        base.error('filter returned ""')
                    end
                elseif not last_out then
                    if last_in then
                        base.error('filter returned inappropriate nil')
                    else
                        return nil
                    end
                else
                    return last_out
                end
            end
        end
    end
end

-- creates a source that produces contents of several sources, one after the
-- other, as if they were concatenated
-- (thanks to Wim Couwenberg)
function source.cat(...)
    local arg = {...}
    local src = table.remove(arg, 1)
    return function()
        while src do
            local chunk, err = src()
            if chunk then return chunk end
            if err then return nil, err end
            src = table.remove(arg, 1)
        end
    end
end

-----------------------------------------------------------------------------
-- Sink stuff
-----------------------------------------------------------------------------
-- creates a sink that stores into a table
function sink.table(t)
    t = t or {}
    local f = function(chunk, err)
        if chunk then table.insert(t, chunk) end
        return 1
    end
    return f, t
end

-- turns a fancy sink into a simple sink
function sink.simplify(snk)
    base.assert(snk)
    return function(chunk, err)
        local ret, err_or_new = snk(chunk, err)
        if not ret then return nil, err_or_new end
        snk = err_or_new or snk
        return 1
    end
end

-- creates a file sink
function sink.file(handle, io_err)
    if handle then
        return function(chunk, err)
            if not chunk then
                handle:close()
                return 1
            else return handle:write(chunk) end
        end
    else return sink.error(io_err or "unable to open file") end
end

-- creates a sink that discards data
local function null()
    return 1
end

function sink.null()
    return null
end

-- creates a sink that just returns an error
function sink.error(err)
    return function()
        return nil, err
    end
end

-- chains a sink with one or several filter(s)
function sink.chain(f, snk, ...)
    if ... then
        local args = { f, snk, ... }
        snk = table.remove(args, #args)
        f = filter.chain(unpack(args))
    end
    base.assert(f and snk)
    return function(chunk, err)
        if chunk ~= "" then
            local filtered = f(chunk)
            local done = chunk and ""
            while true do
                local ret, snkerr = snk(filtered, err)
                if not ret then return nil, snkerr end
                if filtered == done then return 1 end
                filtered = f(done)
            end
        else return 1 end
    end
end

-----------------------------------------------------------------------------
-- Pump stuff
-----------------------------------------------------------------------------
-- pumps one chunk from the source to the sink
function pump.step(src, snk)
    local chunk, src_err = src()
    local ret, snk_err = snk(chunk, src_err)
    if chunk and ret then return 1
    else return nil, src_err or snk_err end
end

-- pumps all data from a source to a sink, using a step function
function pump.all(src, snk, step)
    base.assert(src and snk)
    step = step or pump.step
    while true do
        local ret, err = step(src, snk)
        if not ret then
            if err then return nil, err
            else return 1 end
        end
    end
end

return _M

```

`lua/libs/mime.lua`:

```lua
-----------------------------------------------------------------------------
-- MIME support for the Lua language.
-- Author: Diego Nehab
-- Conforming to RFCs 2045-2049
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module and import dependencies
-----------------------------------------------------------------------------
local base = _G
local ltn12 = require("ltn12")
local mime = require("mime.core")
local string = require("string")
local _M = mime

-- encode, decode and wrap algorithm tables
local encodet, decodet, wrapt = {},{},{}

_M.encodet = encodet
_M.decodet = decodet
_M.wrapt   = wrapt  

-- creates a function that chooses a filter by name from a given table
local function choose(table)
    return function(name, opt1, opt2)
        if base.type(name) ~= "string" then
            name, opt1, opt2 = "default", name, opt1
        end
        local f = table[name or "nil"]
        if not f then 
            base.error("unknown key (" .. base.tostring(name) .. ")", 3)
        else return f(opt1, opt2) end
    end
end

-- define the encoding filters
encodet['base64'] = function()
    return ltn12.filter.cycle(_M.b64, "")
end

encodet['quoted-printable'] = function(mode)
    return ltn12.filter.cycle(_M.qp, "",
        (mode == "binary") and "=0D=0A" or "\r\n")
end

-- define the decoding filters
decodet['base64'] = function()
    return ltn12.filter.cycle(_M.unb64, "")
end

decodet['quoted-printable'] = function()
    return ltn12.filter.cycle(_M.unqp, "")
end

local function format(chunk)
    if chunk then
        if chunk == "" then return "''"
        else return string.len(chunk) end
    else return "nil" end
end

-- define the line-wrap filters
wrapt['text'] = function(length)
    length = length or 76
    return ltn12.filter.cycle(_M.wrp, length, length)
end
wrapt['base64'] = wrapt['text']
wrapt['default'] = wrapt['text']

wrapt['quoted-printable'] = function()
    return ltn12.filter.cycle(_M.qpwrp, 76, 76)
end

-- function that choose the encoding, decoding or wrap algorithm
_M.encode = choose(encodet)
_M.decode = choose(decodet)
_M.wrap = choose(wrapt)

-- define the end-of-line normalization filter
function _M.normalize(marker)
    return ltn12.filter.cycle(_M.eol, 0, marker)
end

-- high level stuffing filter
function _M.stuff()
    return ltn12.filter.cycle(_M.dot, 2)
end

return _M

```

`lua/libs/mobdebug.lua`:

```lua
--
-- MobDebug -- Lua remote debugger
-- Copyright 2011-18 Paul Kulchenko
-- Based on RemDebug 1.0 Copyright Kepler Project 2005
--

-- use loaded modules or load explicitly on those systems that require that
local require = require
local io = io or require "io"
local table = table or require "table"
local string = string or require "string"
local coroutine = coroutine or require "coroutine"
local debug = require "debug"
-- protect require "os" as it may fail on embedded systems without os module
local os = os or (function(module)
  local ok, res = pcall(require, module)
  return ok and res or nil
end)("os")

local mobdebug = {
  _NAME = "mobdebug",
  _VERSION = "0.705",
  _COPYRIGHT = "Paul Kulchenko",
  _DESCRIPTION = "Mobile Remote Debugger for the Lua programming language",
  port = os and os.getenv and tonumber((os.getenv("MOBDEBUG_PORT"))) or 8172,
  checkcount = 200,
  yieldtimeout = 0.02, -- yield timeout (s)
  connecttimeout = 2, -- connect timeout (s)
}

local HOOKMASK = "lcr"
local error = error
local getfenv = getfenv
local setfenv = setfenv
local loadstring = loadstring or load -- "load" replaced "loadstring" in Lua 5.2
local pairs = pairs
local setmetatable = setmetatable
local tonumber = tonumber
local unpack = table.unpack or unpack
local rawget = rawget
local gsub, sub, find = string.gsub, string.sub, string.find

-- if strict.lua is used, then need to avoid referencing some global
-- variables, as they can be undefined;
-- use rawget to avoid complaints from strict.lua at run-time.
-- it's safe to do the initialization here as all these variables
-- should get defined values (if any) before the debugging starts.
-- there is also global 'wx' variable, which is checked as part of
-- the debug loop as 'wx' can be loaded at any time during debugging.
local genv = _G or _ENV
local jit = rawget(genv, "jit")
local MOAICoroutine = rawget(genv, "MOAICoroutine")

-- ngx_lua debugging requires a special handling as its coroutine.*
-- methods use a different mechanism that doesn't allow resume calls
-- from debug hook handlers.
-- Instead, the "original" coroutine.* methods are used.
-- `rawget` needs to be used to protect against `strict` checks, but
-- ngx_lua hides those in a metatable, so need to use that.
local metagindex = getmetatable(genv) and getmetatable(genv).__index
local ngx = type(metagindex) == "table" and metagindex.rawget and metagindex:rawget("ngx") or nil
local corocreate = ngx and coroutine._create or coroutine.create
local cororesume = ngx and coroutine._resume or coroutine.resume
local coroyield = ngx and coroutine._yield or coroutine.yield
local corostatus = ngx and coroutine._status or coroutine.status
local corowrap = coroutine.wrap

if not setfenv then -- Lua 5.2+
  -- based on http://lua-users.org/lists/lua-l/2010-06/msg00314.html
  -- this assumes f is a function
  local function findenv(f)
    local level = 1
    repeat
      local name, value = debug.getupvalue(f, level)
      if name == '_ENV' then return level, value end
      level = level + 1
    until name == nil
    return nil end
  getfenv = function (f) return(select(2, findenv(f)) or _G) end
  setfenv = function (f, t)
    local level = findenv(f)
    if level then debug.setupvalue(f, level, t) end
    return f end
end

-- check for OS and convert file names to lower case on windows
-- (its file system is case insensitive, but case preserving), as setting a
-- breakpoint on x:\Foo.lua will not work if the file was loaded as X:\foo.lua.
-- OSX and Windows behave the same way (case insensitive, but case preserving).
-- OSX can be configured to be case-sensitive, so check for that. This doesn't
-- handle the case of different partitions having different case-sensitivity.
local win = os and os.getenv and (os.getenv('WINDIR') or (os.getenv('OS') or ''):match('[Ww]indows')) and true or false
local mac = not win and (os and os.getenv and os.getenv('DYLD_LIBRARY_PATH') or not io.open("/proc")) and true or false
local iscasepreserving = win or (mac and io.open('/library') ~= nil)

-- turn jit off based on Mike Pall's comment in this discussion:
-- http://www.freelists.org/post/luajit/Debug-hooks-and-JIT,2
-- "You need to turn it off at the start if you plan to receive
-- reliable hook calls at any later point in time."
if jit and jit.off then jit.off() end

local socket = require "socket"
local coro_debugger
local coro_debugee
local coroutines = {}; setmetatable(coroutines, {__mode = "k"}) -- "weak" keys
local events = { BREAK = 1, WATCH = 2, RESTART = 3, STACK = 4 }
local breakpoints = {}
local watches = {}
local lastsource
local lastfile
local watchescnt = 0
local abort -- default value is nil; this is used in start/loop distinction
local seen_hook = false
local checkcount = 0
local step_into = false
local step_over = false
local step_level = 0
local stack_level = 0
local server
local buf
local outputs = {}
local iobase = {print = print}
local basedir = ""
local deferror = "execution aborted at default debugee"
local debugee = function ()
  local a = 1
  for _ = 1, 10 do a = a + 1 end
  error(deferror)
end
local function q(s) return string.gsub(s, '([%(%)%.%%%+%-%*%?%[%^%$%]])','%%%1') end

local serpent = (function() ---- include Serpent module for serialization
local n, v = "serpent", "0.302" -- (C) 2012-18 Paul Kulchenko; MIT License
local c, d = "Paul Kulchenko", "Lua serializer and pretty printer"
local snum = {[tostring(1/0)]='1/0 --[[math.huge]]',[tostring(-1/0)]='-1/0 --[[-math.huge]]',[tostring(0/0)]='0/0'}
local badtype = {thread = true, userdata = true, cdata = true}
local getmetatable = debug and debug.getmetatable or getmetatable
local pairs = function(t) return next, t end -- avoid using __pairs in Lua 5.2+
local keyword, globals, G = {}, {}, (_G or _ENV)
for _,k in ipairs({'and', 'break', 'do', 'else', 'elseif', 'end', 'false',
  'for', 'function', 'goto', 'if', 'in', 'local', 'nil', 'not', 'or', 'repeat',
  'return', 'then', 'true', 'until', 'while'}) do keyword[k] = true end
for k,v in pairs(G) do globals[v] = k end -- build func to name mapping
for _,g in ipairs({'coroutine', 'debug', 'io', 'math', 'string', 'table', 'os'}) do
  for k,v in pairs(type(G[g]) == 'table' and G[g] or {}) do globals[v] = g..'.'..k end end

local function s(t, opts)
  local name, indent, fatal, maxnum = opts.name, opts.indent, opts.fatal, opts.maxnum
  local sparse, custom, huge = opts.sparse, opts.custom, not opts.nohuge
  local space, maxl = (opts.compact and '' or ' '), (opts.maxlevel or math.huge)
  local maxlen, metatostring = tonumber(opts.maxlength), opts.metatostring
  local iname, comm = '_'..(name or ''), opts.comment and (tonumber(opts.comment) or math.huge)
  local numformat = opts.numformat or "%.17g"
  local seen, sref, syms, symn = {}, {'local '..iname..'={}'}, {}, 0
  local function gensym(val) return '_'..(tostring(tostring(val)):gsub("[^%w]",""):gsub("(%d%w+)",
    -- tostring(val) is needed because __tostring may return a non-string value
    function(s) if not syms[s] then symn = symn+1; syms[s] = symn end return tostring(syms[s]) end)) end
  local function safestr(s) return type(s) == "number" and tostring(huge and snum[tostring(s)] or numformat:format(s))
    or type(s) ~= "string" and tostring(s) -- escape NEWLINE/010 and EOF/026
    or ("%q"):format(s):gsub("\010","n"):gsub("\026","\\026") end
  local function comment(s,l) return comm and (l or 0) < comm and ' --[['..select(2, pcall(tostring, s))..']]' or '' end
  local function globerr(s,l) return globals[s] and globals[s]..comment(s,l) or not fatal
    and safestr(select(2, pcall(tostring, s))) or error("Can't serialize "..tostring(s)) end
  local function safename(path, name) -- generates foo.bar, foo[3], or foo['b a r']
    local n = name == nil and '' or name
    local plain = type(n) == "string" and n:match("^[%l%u_][%w_]*$") and not keyword[n]
    local safe = plain and n or '['..safestr(n)..']'
    return (path or '')..(plain and path and '.' or '')..safe, safe end
  local alphanumsort = type(opts.sortkeys) == 'function' and opts.sortkeys or function(k, o, n) -- k=keys, o=originaltable, n=padding
    local maxn, to = tonumber(n) or 12, {number = 'a', string = 'b'}
    local function padnum(d) return ("%0"..tostring(maxn).."d"):format(tonumber(d)) end
    table.sort(k, function(a,b)
      -- sort numeric keys first: k[key] is not nil for numerical keys
      return (k[a] ~= nil and 0 or to[type(a)] or 'z')..(tostring(a):gsub("%d+",padnum))
           < (k[b] ~= nil and 0 or to[type(b)] or 'z')..(tostring(b):gsub("%d+",padnum)) end) end
  local function val2str(t, name, indent, insref, path, plainindex, level)
    local ttype, level, mt = type(t), (level or 0), getmetatable(t)
    local spath, sname = safename(path, name)
    local tag = plainindex and
      ((type(name) == "number") and '' or name..space..'='..space) or
      (name ~= nil and sname..space..'='..space or '')
    if seen[t] then -- already seen this element
      sref[#sref+1] = spath..space..'='..space..seen[t]
      return tag..'nil'..comment('ref', level) end
    -- protect from those cases where __tostring may fail
    if type(mt) == 'table' and metatostring ~= false then
      local to, tr = pcall(function() return mt.__tostring(t) end)
      local so, sr = pcall(function() return mt.__serialize(t) end)
      if (to or so) then -- knows how to serialize itself
        seen[t] = insref or spath
        t = so and sr or tr
        ttype = type(t)
      end -- new value falls through to be serialized
    end
    if ttype == "table" then
      if level >= maxl then return tag..'{}'..comment('maxlvl', level) end
      seen[t] = insref or spath
      if next(t) == nil then return tag..'{}'..comment(t, level) end -- table empty
      if maxlen and maxlen < 0 then return tag..'{}'..comment('maxlen', level) end
      local maxn, o, out = math.min(#t, maxnum or #t), {}, {}
      for key = 1, maxn do o[key] = key end
      if not maxnum or #o < maxnum then
        local n = #o -- n = n + 1; o[n] is much faster than o[#o+1] on large tables
        for key in pairs(t) do if o[key] ~= key then n = n + 1; o[n] = key end end end
      if maxnum and #o > maxnum then o[maxnum+1] = nil end
      if opts.sortkeys and #o > maxn then alphanumsort(o, t, opts.sortkeys) end
      local sparse = sparse and #o > maxn -- disable sparsness if only numeric keys (shorter output)
      for n, key in ipairs(o) do
        local value, ktype, plainindex = t[key], type(key), n <= maxn and not sparse
        if opts.valignore and opts.valignore[value] -- skip ignored values; do nothing
        or opts.keyallow and not opts.keyallow[key]
        or opts.keyignore and opts.keyignore[key]
        or opts.valtypeignore and opts.valtypeignore[type(value)] -- skipping ignored value types
        or sparse and value == nil then -- skipping nils; do nothing
        elseif ktype == 'table' or ktype == 'function' or badtype[ktype] then
          if not seen[key] and not globals[key] then
            sref[#sref+1] = 'placeholder'
            local sname = safename(iname, gensym(key)) -- iname is table for local variables
            sref[#sref] = val2str(key,sname,indent,sname,iname,true) end
          sref[#sref+1] = 'placeholder'
          local path = seen[t]..'['..tostring(seen[key] or globals[key] or gensym(key))..']'
          sref[#sref] = path..space..'='..space..tostring(seen[value] or val2str(value,nil,indent,path))
        else
          out[#out+1] = val2str(value,key,indent,nil,seen[t],plainindex,level+1)
          if maxlen then
            maxlen = maxlen - #out[#out]
            if maxlen < 0 then break end
          end
        end
      end
      local prefix = string.rep(indent or '', level)
      local head = indent and '{\n'..prefix..indent or '{'
      local body = table.concat(out, ','..(indent and '\n'..prefix..indent or space))
      local tail = indent and "\n"..prefix..'}' or '}'
      return (custom and custom(tag,head,body,tail,level) or tag..head..body..tail)..comment(t, level)
    elseif badtype[ttype] then
      seen[t] = insref or spath
      return tag..globerr(t, level)
    elseif ttype == 'function' then
      seen[t] = insref or spath
      if opts.nocode then return tag.."function() --[[..skipped..]] end"..comment(t, level) end
      local ok, res = pcall(string.dump, t)
      local func = ok and "((loadstring or load)("..safestr(res)..",'@serialized'))"..comment(t, level)
      return tag..(func or globerr(t, level))
    else return tag..safestr(t) end -- handle all other types
  end
  local sepr = indent and "\n" or ";"..space
  local body = val2str(t, name, indent) -- this call also populates sref
  local tail = #sref>1 and table.concat(sref, sepr)..sepr or ''
  local warn = opts.comment and #sref>1 and space.."--[[incomplete output with shared/self-references skipped]]" or ''
  return not name and body..warn or "do local "..body..sepr..tail.."return "..name..sepr.."end"
end

local function deserialize(data, opts)
  local env = (opts and opts.safe == false) and G
    or setmetatable({}, {
        __index = function(t,k) return t end,
        __call = function(t,...) error("cannot call functions") end
      })
  local f, res = (loadstring or load)('return '..data, nil, nil, env)
  if not f then f, res = (loadstring or load)(data, nil, nil, env) end
  if not f then return f, res end
  if setfenv then setfenv(f, env) end
  return pcall(f)
end

local function merge(a, b) if b then for k,v in pairs(b) do a[k] = v end end; return a; end
return { _NAME = n, _COPYRIGHT = c, _DESCRIPTION = d, _VERSION = v, serialize = s,
  load = deserialize,
  dump = function(a, opts) return s(a, merge({name = '_', compact = true, sparse = true}, opts)) end,
  line = function(a, opts) return s(a, merge({sortkeys = true, comment = true}, opts)) end,
  block = function(a, opts) return s(a, merge({indent = '  ', sortkeys = true, comment = true}, opts)) end }
end)() ---- end of Serpent module

mobdebug.line = serpent.line
mobdebug.dump = serpent.dump
mobdebug.linemap = nil
mobdebug.loadstring = loadstring

local function removebasedir(path, basedir)
  if iscasepreserving then
    -- check if the lowercased path matches the basedir
    -- if so, return substring of the original path (to not lowercase it)
    return path:lower():find('^'..q(basedir:lower()))
      and path:sub(#basedir+1) or path
  else
    return string.gsub(path, '^'..q(basedir), '')
  end
end

local function stack(start)
  local function vars(f)
    local func = debug.getinfo(f, "f").func
    local i = 1
    local locals = {}
    -- get locals
    while true do
      local name, value = debug.getlocal(f, i)
      if not name then break end
      if string.sub(name, 1, 1) ~= '(' then
        locals[name] = {value, select(2,pcall(tostring,value))}
      end
      i = i + 1
    end
    -- get varargs (these use negative indices)
    i = 1
    while true do
      local name, value = debug.getlocal(f, -i)
      -- `not name` should be enough, but LuaJIT 2.0.0 incorrectly reports `(*temporary)` names here
      if not name or name ~= "(*vararg)" then break end
      locals[name:gsub("%)$"," "..i..")")] = {value, select(2,pcall(tostring,value))}
      i = i + 1
    end
    -- get upvalues
    i = 1
    local ups = {}
    while func do -- check for func as it may be nil for tail calls
      local name, value = debug.getupvalue(func, i)
      if not name then break end
      ups[name] = {value, select(2,pcall(tostring,value))}
      i = i + 1
    end
    return locals, ups
  end

  local stack = {}
  local linemap = mobdebug.linemap
  for i = (start or 0), 100 do
    local source = debug.getinfo(i, "Snl")
    if not source then break end

    local src = source.source
    if src:find("@") == 1 then
      src = src:sub(2):gsub("\\", "/")
      if src:find("%./") == 1 then src = src:sub(3) end
    end

    table.insert(stack, { -- remove basedir from source
      {source.name, removebasedir(src, basedir),
       linemap and linemap(source.linedefined, source.source) or source.linedefined,
       linemap and linemap(source.currentline, source.source) or source.currentline,
       source.what, source.namewhat, source.short_src},
      vars(i+1)})
    if source.what == 'main' then break end
  end
  return stack
end

local function set_breakpoint(file, line)
  if file == '-' and lastfile then file = lastfile
  elseif iscasepreserving then file = string.lower(file) end
  if not breakpoints[line] then breakpoints[line] = {} end
  breakpoints[line][file] = true
end

local function remove_breakpoint(file, line)
  if file == '-' and lastfile then file = lastfile
  elseif file == '*' and line == 0 then breakpoints = {}
  elseif iscasepreserving then file = string.lower(file) end
  if breakpoints[line] then breakpoints[line][file] = nil end
end

local function has_breakpoint(file, line)
  return breakpoints[line]
     and breakpoints[line][iscasepreserving and string.lower(file) or file]
end

local function restore_vars(vars)
  if type(vars) ~= 'table' then return end

  -- locals need to be processed in the reverse order, starting from
  -- the inner block out, to make sure that the localized variables
  -- are correctly updated with only the closest variable with
  -- the same name being changed
  -- first loop find how many local variables there is, while
  -- the second loop processes them from i to 1
  local i = 1
  while true do
    local name = debug.getlocal(3, i)
    if not name then break end
    i = i + 1
  end
  i = i - 1
  local written_vars = {}
  while i > 0 do
    local name = debug.getlocal(3, i)
    if not written_vars[name] then
      if string.sub(name, 1, 1) ~= '(' then
        debug.setlocal(3, i, rawget(vars, name))
      end
      written_vars[name] = true
    end
    i = i - 1
  end

  i = 1
  local func = debug.getinfo(3, "f").func
  while true do
    local name = debug.getupvalue(func, i)
    if not name then break end
    if not written_vars[name] then
      if string.sub(name, 1, 1) ~= '(' then
        debug.setupvalue(func, i, rawget(vars, name))
      end
      written_vars[name] = true
    end
    i = i + 1
  end
end

local function capture_vars(level, thread)
  level = (level or 0)+2 -- add two levels for this and debug calls
  local func = (thread and debug.getinfo(thread, level, "f") or debug.getinfo(level, "f") or {}).func
  if not func then return {} end

  local vars = {['...'] = {}}
  local i = 1
  while true do
    local name, value = debug.getupvalue(func, i)
    if not name then break end
    if string.sub(name, 1, 1) ~= '(' then vars[name] = value end
    i = i + 1
  end
  i = 1
  while true do
    local name, value
    if thread then
      name, value = debug.getlocal(thread, level, i)
    else
      name, value = debug.getlocal(level, i)
    end
    if not name then break end
    if string.sub(name, 1, 1) ~= '(' then vars[name] = value end
    i = i + 1
  end
  -- get varargs (these use negative indices)
  i = 1
  while true do
    local name, value
    if thread then
      name, value = debug.getlocal(thread, level, -i)
    else
      name, value = debug.getlocal(level, -i)
    end
    -- `not name` should be enough, but LuaJIT 2.0.0 incorrectly reports `(*temporary)` names here
    if not name or name ~= "(*vararg)" then break end
    vars['...'][i] = value
    i = i + 1
  end
  -- returned 'vars' table plays a dual role: (1) it captures local values
  -- and upvalues to be restored later (in case they are modified in "eval"),
  -- and (2) it provides an environment for evaluated chunks.
  -- getfenv(func) is needed to provide proper environment for functions,
  -- including access to globals, but this causes vars[name] to fail in
  -- restore_vars on local variables or upvalues with `nil` values when
  -- 'strict' is in effect. To avoid this `rawget` is used in restore_vars.
  setmetatable(vars, { __index = getfenv(func), __newindex = getfenv(func), __mode = "v" })
  return vars
end

local function stack_depth(start_depth)
  for i = start_depth, 0, -1 do
    if debug.getinfo(i, "l") then return i+1 end
  end
  return start_depth
end

local function is_safe(stack_level)
  -- the stack grows up: 0 is getinfo, 1 is is_safe, 2 is debug_hook, 3 is user function
  if stack_level == 3 then return true end
  for i = 3, stack_level do
    -- return if it is not safe to abort
    local info = debug.getinfo(i, "S")
    if not info then return true end
    if info.what == "C" then return false end
  end
  return true
end

local function in_debugger()
  local this = debug.getinfo(1, "S").source
  -- only need to check few frames as mobdebug frames should be close
  for i = 3, 7 do
    local info = debug.getinfo(i, "S")
    if not info then return false end
    if info.source == this then return true end
  end
  return false
end

local function is_pending(peer)
  -- if there is something already in the buffer, skip check
  if not buf and checkcount >= mobdebug.checkcount then
    peer:settimeout(0) -- non-blocking
    buf = peer:receive(1)
    peer:settimeout() -- back to blocking
    checkcount = 0
  end
  return buf
end

local function readnext(peer, num)
  peer:settimeout(0) -- non-blocking
  local res, err, partial = peer:receive(num)
  peer:settimeout() -- back to blocking
  return res or partial or '', err
end

local function handle_breakpoint(peer)
  -- check if the buffer has the beginning of SETB/DELB command;
  -- this is to avoid reading the entire line for commands that
  -- don't need to be handled here.
  if not buf or not (buf:sub(1,1) == 'S' or buf:sub(1,1) == 'D') then return end

  -- check second character to avoid reading STEP or other S* and D* commands
  if #buf == 1 then buf = buf .. readnext(peer, 1) end
  if buf:sub(2,2) ~= 'E' then return end

  -- need to read few more characters
  buf = buf .. readnext(peer, 5-#buf)
  if buf ~= 'SETB ' and buf ~= 'DELB ' then return end

  local res, _, partial = peer:receive() -- get the rest of the line; blocking
  if not res then
    if partial then buf = buf .. partial end
    return
  end

  local _, _, cmd, file, line = (buf..res):find("^([A-Z]+)%s+(.-)%s+(%d+)%s*$")
  if cmd == 'SETB' then set_breakpoint(file, tonumber(line))
  elseif cmd == 'DELB' then remove_breakpoint(file, tonumber(line))
  else
    -- this looks like a breakpoint command, but something went wrong;
    -- return here to let the "normal" processing to handle,
    -- although this is likely to not go well.
    return
  end

  buf = nil
end

local function normalize_path(file)
  local n
  repeat
    file, n = file:gsub("/+%.?/+","/") -- remove all `//` and `/./` references
  until n == 0
  -- collapse all up-dir references: this will clobber UNC prefix (\\?\)
  -- and disk on Windows when there are too many up-dir references: `D:\foo\..\..\bar`;
  -- handle the case of multiple up-dir references: `foo/bar/baz/../../../more`;
  -- only remove one at a time as otherwise `../../` could be removed;
  repeat
    file, n = file:gsub("[^/]+/%.%./", "", 1)
  until n == 0
  -- there may still be a leading up-dir reference left (as `/../` or `../`); remove it
  return (file:gsub("^(/?)%.%./", "%1"))
end

local function debug_hook(event, line)
  -- (1) LuaJIT needs special treatment. Because debug_hook is set for
  -- *all* coroutines, and not just the one being debugged as in regular Lua
  -- (http://lua-users.org/lists/lua-l/2011-06/msg00513.html),
  -- need to avoid debugging mobdebug's own code as LuaJIT doesn't
  -- always correctly generate call/return hook events (there are more
  -- calls than returns, which breaks stack depth calculation and
  -- 'step' and 'step over' commands stop working; possibly because
  -- 'tail return' events are not generated by LuaJIT).
  -- the next line checks if the debugger is run under LuaJIT and if
  -- one of debugger methods is present in the stack, it simply returns.
  if jit then
    -- when luajit is compiled with LUAJIT_ENABLE_LUA52COMPAT,
    -- coroutine.running() returns non-nil for the main thread.
    local coro, main = coroutine.running()
    if not coro or main then coro = 'main' end
    local disabled = coroutines[coro] == false
      or coroutines[coro] == nil and coro ~= (coro_debugee or 'main')
    if coro_debugee and disabled or not coro_debugee and (disabled or in_debugger())
    then return end
  end

  -- (2) check if abort has been requested and it's safe to abort
  if abort and is_safe(stack_level) then error(abort) end

  -- (3) also check if this debug hook has not been visited for any reason.
  -- this check is needed to avoid stepping in too early
  -- (for example, when coroutine.resume() is executed inside start()).
  if not seen_hook and in_debugger() then return end

  if event == "call" then
    stack_level = stack_level + 1
  elseif event == "return" or event == "tail return" then
    stack_level = stack_level - 1
  elseif event == "line" then
    if mobdebug.linemap then
      local ok, mappedline = pcall(mobdebug.linemap, line, debug.getinfo(2, "S").source)
      if ok then line = mappedline end
      if not line then return end
    end

    -- may need to fall through because of the following:
    -- (1) step_into
    -- (2) step_over and stack_level <= step_level (need stack_level)
    -- (3) breakpoint; check for line first as it's known; then for file
    -- (4) socket call (only do every Xth check)
    -- (5) at least one watch is registered
    if not (
      step_into or step_over or breakpoints[line] or watchescnt > 0
      or is_pending(server)
    ) then checkcount = checkcount + 1; return end

    checkcount = mobdebug.checkcount -- force check on the next command

    -- this is needed to check if the stack got shorter or longer.
    -- unfortunately counting call/return calls is not reliable.
    -- the discrepancy may happen when "pcall(load, '')" call is made
    -- or when "error()" is called in a function.
    -- in either case there are more "call" than "return" events reported.
    -- this validation is done for every "line" event, but should be "cheap"
    -- as it checks for the stack to get shorter (or longer by one call).
    -- start from one level higher just in case we need to grow the stack.
    -- this may happen after coroutine.resume call to a function that doesn't
    -- have any other instructions to execute. it triggers three returns:
    -- "return, tail return, return", which needs to be accounted for.
    stack_level = stack_depth(stack_level+1)

    local caller = debug.getinfo(2, "S")

    -- grab the filename and fix it if needed
    local file = lastfile
    if (lastsource ~= caller.source) then
      file, lastsource = caller.source, caller.source
      -- technically, users can supply names that may not use '@',
      -- for example when they call loadstring('...', 'filename.lua').
      -- Unfortunately, there is no reliable/quick way to figure out
      -- what is the filename and what is the source code.
      -- If the name doesn't start with `@`, assume it's a file name if it's all on one line.
      if find(file, "^@") or not find(file, "[\r\n]") then
        file = gsub(gsub(file, "^@", ""), "\\", "/")
        -- normalize paths that may include up-dir or same-dir references
        -- if the path starts from the up-dir or reference,
        -- prepend `basedir` to generate absolute path to keep breakpoints working.
        -- ignore qualified relative path (`D:../`) and UNC paths (`\\?\`)
        if find(file, "^%.%./") then file = basedir..file end
        if find(file, "/%.%.?/") then file = normalize_path(file) end
        -- need this conversion to be applied to relative and absolute
        -- file names as you may write "require 'Foo'" to
        -- load "foo.lua" (on a case insensitive file system) and breakpoints
        -- set on foo.lua will not work if not converted to the same case.
        if iscasepreserving then file = string.lower(file) end
        if find(file, "^%./") then file = sub(file, 3)
        else file = gsub(file, "^"..q(basedir), "") end
        -- some file systems allow newlines in file names; remove these.
        file = gsub(file, "\n", ' ')
      else
        file = mobdebug.line(file)
      end

      -- set to true if we got here; this only needs to be done once per
      -- session, so do it here to at least avoid setting it for every line.
      seen_hook = true
      lastfile = file
    end

    if is_pending(server) then handle_breakpoint(server) end

    local vars, status, res
    if (watchescnt > 0) then
      vars = capture_vars(1)
      for index, value in pairs(watches) do
        setfenv(value, vars)
        local ok, fired = pcall(value)
        if ok and fired then
          status, res = cororesume(coro_debugger, events.WATCH, vars, file, line, index)
          break -- any one watch is enough; don't check multiple times
        end
      end
    end

    -- need to get into the "regular" debug handler, but only if there was
    -- no watch that was fired. If there was a watch, handle its result.
    local getin = (status == nil) and
      (step_into
      -- when coroutine.running() return `nil` (main thread in Lua 5.1),
      -- step_over will equal 'main', so need to check for that explicitly.
      or (step_over and step_over == (coroutine.running() or 'main') and stack_level <= step_level)
      or has_breakpoint(file, line)
      or is_pending(server))

    if getin then
      vars = vars or capture_vars(1)
      step_into = false
      step_over = false
      status, res = cororesume(coro_debugger, events.BREAK, vars, file, line)
    end

    -- handle 'stack' command that provides stack() information to the debugger
    while status and res == 'stack' do
      -- resume with the stack trace and variables
      if vars then restore_vars(vars) end -- restore vars so they are reflected in stack values
      status, res = cororesume(coro_debugger, events.STACK, stack(3), file, line)
    end

    -- need to recheck once more as resume after 'stack' command may
    -- return something else (for example, 'exit'), which needs to be handled
    if status and res and res ~= 'stack' then
      if not abort and res == "exit" then mobdebug.onexit(1, true); return end
      if not abort and res == "done" then mobdebug.done(); return end
      abort = res
      -- only abort if safe; if not, there is another (earlier) check inside
      -- debug_hook, which will abort execution at the first safe opportunity
      if is_safe(stack_level) then error(abort) end
    elseif not status and res then
      error(res, 2) -- report any other (internal) errors back to the application
    end

    if vars then restore_vars(vars) end

    -- last command requested Step Over/Out; store the current thread
    if step_over == true then step_over = coroutine.running() or 'main' end
  end
end

local function stringify_results(params, status, ...)
  if not status then return status, ... end -- on error report as it

  params = params or {}
  if params.nocode == nil then params.nocode = true end
  if params.comment == nil then params.comment = 1 end

  local t = {...}
  for i,v in pairs(t) do -- stringify each of the returned values
    local ok, res = pcall(mobdebug.line, v, params)
    t[i] = ok and res or ("%q"):format(res):gsub("\010","n"):gsub("\026","\\026")
  end
  -- stringify table with all returned values
  -- this is done to allow each returned value to be used (serialized or not)
  -- intependently and to preserve "original" comments
  return pcall(mobdebug.dump, t, {sparse = false})
end

local function isrunning()
  return coro_debugger and (corostatus(coro_debugger) == 'suspended' or corostatus(coro_debugger) == 'running')
end

-- this is a function that removes all hooks and closes the socket to
-- report back to the controller that the debugging is done.
-- the script that called `done` can still continue.
local function done()
  if not (isrunning() and server) then return end

  if not jit then
    for co, debugged in pairs(coroutines) do
      if debugged then debug.sethook(co) end
    end
  end

  debug.sethook()
  server:close()

  coro_debugger = nil -- to make sure isrunning() returns `false`
  seen_hook = nil -- to make sure that the next start() call works
  abort = nil -- to make sure that callback calls use proper "abort" value
end

local function debugger_loop(sev, svars, sfile, sline)
  local command
  local app, osname
  local eval_env = svars or {}
  local function emptyWatch () return false end
  local loaded = {}
  for k in pairs(package.loaded) do loaded[k] = true end

  while true do
    local line, err
    local wx = rawget(genv, "wx") -- use rawread to make strict.lua happy
    if (wx or mobdebug.yield) and server.settimeout then server:settimeout(mobdebug.yieldtimeout) end
    while true do
      line, err = server:receive()
      if not line and err == "timeout" then
        -- yield for wx GUI applications if possible to avoid "busyness"
        app = app or (wx and wx.wxGetApp and wx.wxGetApp())
        if app then
          local win = app:GetTopWindow()
          local inloop = app:IsMainLoopRunning()
          osname = osname or wx.wxPlatformInfo.Get():GetOperatingSystemFamilyName()
          if win and not inloop then
            -- process messages in a regular way
            -- and exit as soon as the event loop is idle
            if osname == 'Unix' then wx.wxTimer(app):Start(10, true) end
            local exitLoop = function()
              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE)
              win:Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER)
              app:ExitMainLoop()
            end
            win:Connect(wx.wxEVT_IDLE, exitLoop)
            win:Connect(wx.wxEVT_TIMER, exitLoop)
            app:MainLoop()
          end
        elseif mobdebug.yield then mobdebug.yield()
        end
      elseif not line and err == "closed" then
        error("Debugger connection closed", 0)
      else
        -- if there is something in the pending buffer, prepend it to the line
        if buf then line = buf .. line; buf = nil end
        break
      end
    end
    if server.settimeout then server:settimeout() end -- back to blocking
    command = string.sub(line, string.find(line, "^[A-Z]+"))
    if command == "SETB" then
      local _, _, _, file, line = string.find(line, "^([A-Z]+)%s+(.-)%s+(%d+)%s*$")
      if file and line then
        set_breakpoint(file, tonumber(line))
        server:send("200 OK\n")
      else
        server:send("400 Bad Request\n")
      end
    elseif command == "DELB" then
      local _, _, _, file, line = string.find(line, "^([A-Z]+)%s+(.-)%s+(%d+)%s*$")
      if file and line then
        remove_breakpoint(file, tonumber(line))
        server:send("200 OK\n")
      else
        server:send("400 Bad Request\n")
      end
    elseif command == "EXEC" then
      -- extract any optional parameters
      local params = string.match(line, "--%s*(%b{})%s*$")
      local _, _, chunk = string.find(line, "^[A-Z]+%s+(.+)$")
      if chunk then
        local func, res = mobdebug.loadstring(chunk)
        local status
        if func then
          local pfunc = params and loadstring("return "..params) -- use internal function
          params = pfunc and pfunc()
          params = (type(params) == "table" and params or {})
          local stack = tonumber(params.stack)
          -- if the requested stack frame is not the current one, then use a new capture
          -- with a specific stack frame: `capture_vars(0, coro_debugee)`
          local env = stack and coro_debugee and capture_vars(stack-1, coro_debugee) or eval_env
          setfenv(func, env)
          status, res = stringify_results(params, pcall(func, unpack(env['...'] or {})))
        end
        if status then
          if mobdebug.onscratch then mobdebug.onscratch(res) end
          server:send("200 OK " .. tostring(#res) .. "\n")
          server:send(res)
        else
          -- fix error if not set (for example, when loadstring is not present)
          if not res then res = "Unknown error" end
          server:send("401 Error in Expression " .. tostring(#res) .. "\n")
          server:send(res)
        end
      else
        server:send("400 Bad Request\n")
      end
    elseif command == "LOAD" then
      local _, _, size, name = string.find(line, "^[A-Z]+%s+(%d+)%s+(%S.-)%s*$")
      size = tonumber(size)

      if abort == nil then -- no LOAD/RELOAD allowed inside start()
        if size > 0 then server:receive(size) end
        if sfile and sline then
          server:send("201 Started " .. sfile .. " " .. tostring(sline) .. "\n")
        else
          server:send("200 OK 0\n")
        end
      else
        -- reset environment to allow required modules to load again
        -- remove those packages that weren't loaded when debugger started
        for k in pairs(package.loaded) do
          if not loaded[k] then package.loaded[k] = nil end
        end

        if size == 0 and name == '-' then -- RELOAD the current script being debugged
          server:send("200 OK 0\n")
          coroyield("load")
        else
          -- receiving 0 bytes blocks (at least in luasocket 2.0.2), so skip reading
          local chunk = size == 0 and "" or server:receive(size)
          if chunk then -- LOAD a new script for debugging
            local func, res = mobdebug.loadstring(chunk, "@"..name)
            if func then
              server:send("200 OK 0\n")
              debugee = func
              coroyield("load")
            else
              server:send("401 Error in Expression " .. tostring(#res) .. "\n")
              server:send(res)
            end
          else
            server:send("400 Bad Request\n")
          end
        end
      end
    elseif command == "SETW" then
      local _, _, exp = string.find(line, "^[A-Z]+%s+(.+)%s*$")
      if exp then
        local func, res = mobdebug.loadstring("return(" .. exp .. ")")
        if func then
          watchescnt = watchescnt + 1
          local newidx = #watches + 1
          watches[newidx] = func
          server:send("200 OK " .. tostring(newidx) .. "\n")
        else
          server:send("401 Error in Expression " .. tostring(#res) .. "\n")
          server:send(res)
        end
      else
        server:send("400 Bad Request\n")
      end
    elseif command == "DELW" then
      local _, _, index = string.find(line, "^[A-Z]+%s+(%d+)%s*$")
      index = tonumber(index)
      if index > 0 and index <= #watches then
        watchescnt = watchescnt - (watches[index] ~= emptyWatch and 1 or 0)
        watches[index] = emptyWatch
        server:send("200 OK\n")
      else
        server:send("400 Bad Request\n")
      end
    elseif command == "RUN" then
      server:send("200 OK\n")

      local ev, vars, file, line, idx_watch = coroyield()
      eval_env = vars
      if ev == events.BREAK then
        server:send("202 Paused " .. file .. " " .. tostring(line) .. "\n")
      elseif ev == events.WATCH then
        server:send("203 Paused " .. file .. " " .. tostring(line) .. " " .. tostring(idx_watch) .. "\n")
      elseif ev == events.RESTART then
        -- nothing to do
      else
        server:send("401 Error in Execution " .. tostring(#file) .. "\n")
        server:send(file)
      end
    elseif command == "STEP" then
      server:send("200 OK\n")
      step_into = true

      local ev, vars, file, line, idx_watch = coroyield()
      eval_env = vars
      if ev == events.BREAK then
        server:send("202 Paused " .. file .. " " .. tostring(line) .. "\n")
      elseif ev == events.WATCH then
        server:send("203 Paused " .. file .. " " .. tostring(line) .. " " .. tostring(idx_watch) .. "\n")
      elseif ev == events.RESTART then
        -- nothing to do
      else
        server:send("401 Error in Execution " .. tostring(#file) .. "\n")
        server:send(file)
      end
    elseif command == "OVER" or command == "OUT" then
      server:send("200 OK\n")
      step_over = true

      -- OVER and OUT are very similar except for
      -- the stack level value at which to stop
      if command == "OUT" then step_level = stack_level - 1
      else step_level = stack_level end

      local ev, vars, file, line, idx_watch = coroyield()
      eval_env = vars
      if ev == events.BREAK then
        server:send("202 Paused " .. file .. " " .. tostring(line) .. "\n")
      elseif ev == events.WATCH then
        server:send("203 Paused " .. file .. " " .. tostring(line) .. " " .. tostring(idx_watch) .. "\n")
      elseif ev == events.RESTART then
        -- nothing to do
      else
        server:send("401 Error in Execution " .. tostring(#file) .. "\n")
        server:send(file)
      end
    elseif command == "BASEDIR" then
      local _, _, dir = string.find(line, "^[A-Z]+%s+(.+)%s*$")
      if dir then
        basedir = iscasepreserving and string.lower(dir) or dir
        -- reset cached source as it may change with basedir
        lastsource = nil
        server:send("200 OK\n")
      else
        server:send("400 Bad Request\n")
      end
    elseif command == "SUSPEND" then
      -- do nothing; it already fulfilled its role
    elseif command == "DONE" then
      coroyield("done")
      return -- done with all the debugging
    elseif command == "STACK" then
      -- first check if we can execute the stack command
      -- as it requires yielding back to debug_hook it cannot be executed
      -- if we have not seen the hook yet as happens after start().
      -- in this case we simply return an empty result
      local vars, ev = {}
      if seen_hook then
        ev, vars = coroyield("stack")
      end
      if ev and ev ~= events.STACK then
        server:send("401 Error in Execution " .. tostring(#vars) .. "\n")
        server:send(vars)
      else
        local params = string.match(line, "--%s*(%b{})%s*$")
        local pfunc = params and loadstring("return "..params) -- use internal function
        params = pfunc and pfunc()
        params = (type(params) == "table" and params or {})
        if params.nocode == nil then params.nocode = true end
        if params.sparse == nil then params.sparse = false end
        -- take into account additional levels for the stack frames and data management
        if tonumber(params.maxlevel) then params.maxlevel = tonumber(params.maxlevel)+4 end

        local ok, res = pcall(mobdebug.dump, vars, params)
        if ok then
          server:send("200 OK " .. tostring(res) .. "\n")
        else
          server:send("401 Error in Execution " .. tostring(#res) .. "\n")
          server:send(res)
        end
      end
    elseif command == "OUTPUT" then
      local _, _, stream, mode = string.find(line, "^[A-Z]+%s+(%w+)%s+([dcr])%s*$")
      if stream and mode and stream == "stdout" then
        -- assign "print" in the global environment
        local default = mode == 'd'
        genv.print = default and iobase.print or corowrap(function()
          -- wrapping into coroutine.wrap protects this function from
          -- being stepped through in the debugger.
          -- don't use vararg (...) as it adds a reference for its values,
          -- which may affect how they are garbage collected
          while true do
            local tbl = {coroutine.yield()}
            if mode == 'c' then iobase.print(unpack(tbl)) end
            for n = 1, #tbl do
              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})) end
            local file = table.concat(tbl, "\t").."\n"
            server:send("204 Output " .. stream .. " " .. tostring(#file) .. "\n" .. file)
          end
        end)
        if not default then genv.print() end -- "fake" print to start printing loop
        server:send("200 OK\n")
      else
        server:send("400 Bad Request\n")
      end
    elseif command == "EXIT" then
      server:send("200 OK\n")
      coroyield("exit")
    else
      server:send("400 Bad Request\n")
    end
  end
end

local function output(stream, data)
  if server then return server:send("204 Output "..stream.." "..tostring(#data).."\n"..data) end
end

local function connect(controller_host, controller_port)
  local sock, err = socket.tcp()
  if not sock then return nil, err end

  if sock.settimeout then sock:settimeout(mobdebug.connecttimeout) end
  local res, err = sock:connect(controller_host, tostring(controller_port))
  if sock.settimeout then sock:settimeout() end

  if not res then return nil, err end
  return sock
end

local lasthost, lastport

-- Starts a debug session by connecting to a controller
local function start(controller_host, controller_port)
  -- only one debugging session can be run (as there is only one debug hook)
  if isrunning() then return end

  lasthost = controller_host or lasthost
  lastport = controller_port or lastport

  controller_host = lasthost or "localhost"
  controller_port = lastport or mobdebug.port

  local err
  server, err = mobdebug.connect(controller_host, controller_port)
  if server then
    -- correct stack depth which already has some calls on it
    -- so it doesn't go into negative when those calls return
    -- as this breaks subsequence checks in stack_depth().
    -- start from 16th frame, which is sufficiently large for this check.
    stack_level = stack_depth(16)

    -- provide our own traceback function to report errors remotely
    -- but only under Lua 5.1/LuaJIT as it's not called under Lua 5.2+
    -- (http://lua-users.org/lists/lua-l/2016-05/msg00297.html)
    local function f() return function()end end
    if f() ~= f() then -- Lua 5.1 or LuaJIT
      local dtraceback = debug.traceback
      debug.traceback = function (...)
        if select('#', ...) >= 1 then
          local thr, err, lvl = ...
          if type(thr) ~= 'thread' then err, lvl = thr, err end
          local trace = dtraceback(err, (lvl or 1)+1)
          if genv.print == iobase.print then -- no remote redirect
            return trace
          else
            genv.print(trace) -- report the error remotely
            return -- don't report locally to avoid double reporting
          end
        end
        -- direct call to debug.traceback: return the original.
        -- debug.traceback(nil, level) doesn't work in Lua 5.1
        -- (http://lua-users.org/lists/lua-l/2011-06/msg00574.html), so
        -- simply remove first frame from the stack trace
        local tb = dtraceback("", 2) -- skip debugger frames
        -- if the string is returned, then remove the first new line as it's not needed
        return type(tb) == "string" and tb:gsub("^\n","") or tb
      end
    end
    coro_debugger = corocreate(debugger_loop)
    debug.sethook(debug_hook, HOOKMASK)
    seen_hook = nil -- reset in case the last start() call was refused
    step_into = true -- start with step command
    return true
  else
    print(("Could not connect to %s:%s: %s")
      :format(controller_host, controller_port, err or "unknown error"))
  end
end

local function controller(controller_host, controller_port, scratchpad)
  -- only one debugging session can be run (as there is only one debug hook)
  if isrunning() then return end

  lasthost = controller_host or lasthost
  lastport = controller_port or lastport

  controller_host = lasthost or "localhost"
  controller_port = lastport or mobdebug.port

  local exitonerror = not scratchpad
  local err
  server, err = mobdebug.connect(controller_host, controller_port)
  if server then
    local function report(trace, err)
      local msg = err .. "\n" .. trace
      server:send("401 Error in Execution " .. tostring(#msg) .. "\n")
      server:send(msg)
      return err
    end

    seen_hook = true -- allow to accept all commands
    coro_debugger = corocreate(debugger_loop)

    while true do
      step_into = true -- start with step command
      abort = false -- reset abort flag from the previous loop
      if scratchpad then checkcount = mobdebug.checkcount end -- force suspend right away

      coro_debugee = corocreate(debugee)
      debug.sethook(coro_debugee, debug_hook, HOOKMASK)
      local status, err = cororesume(coro_debugee, unpack(arg or {}))

      -- was there an error or is the script done?
      -- 'abort' state is allowed here; ignore it
      if abort then
        if tostring(abort) == 'exit' then break end
      else
        if status then -- no errors
          if corostatus(coro_debugee) == "suspended" then
            -- the script called `coroutine.yield` in the "main" thread
            error("attempt to yield from the main thread", 3)
          end
          break -- normal execution is done
        elseif err and not string.find(tostring(err), deferror) then
          -- report the error back
          -- err is not necessarily a string, so convert to string to report
          report(debug.traceback(coro_debugee), tostring(err))
          if exitonerror then break end
          -- check if the debugging is done (coro_debugger is nil)
          if not coro_debugger then break end
          -- resume once more to clear the response the debugger wants to send
          -- need to use capture_vars(0) to capture only two (default) level,
          -- as even though there is controller() call, because of the tail call,
          -- the caller may not exist for it;
          -- This is not entirely safe as the user may see the local
          -- variable from console, but they will be reset anyway.
          -- This functionality is used when scratchpad is paused to
          -- gain access to remote console to modify global variables.
          local status, err = cororesume(coro_debugger, events.RESTART, capture_vars(0))
          if not status or status and err == "exit" then break end
        end
      end
    end
  else
    print(("Could not connect to %s:%s: %s")
      :format(controller_host, controller_port, err or "unknown error"))
    return false
  end
  return true
end

local function scratchpad(controller_host, controller_port)
  return controller(controller_host, controller_port, true)
end

local function loop(controller_host, controller_port)
  return controller(controller_host, controller_port, false)
end

local function on()
  if not (isrunning() and server) then return end

  -- main is set to true under Lua5.2 for the "main" chunk.
  -- Lua5.1 returns co as `nil` in that case.
  local co, main = coroutine.running()
  if main then co = nil end
  if co then
    coroutines[co] = true
    debug.sethook(co, debug_hook, HOOKMASK)
  else
    if jit then coroutines.main = true end
    debug.sethook(debug_hook, HOOKMASK)
  end
end

local function off()
  if not (isrunning() and server) then return end

  -- main is set to true under Lua5.2 for the "main" chunk.
  -- Lua5.1 returns co as `nil` in that case.
  local co, main = coroutine.running()
  if main then co = nil end

  -- don't remove coroutine hook under LuaJIT as there is only one (global) hook
  if co then
    coroutines[co] = false
    if not jit then debug.sethook(co) end
  else
    if jit then coroutines.main = false end
    if not jit then debug.sethook() end
  end

  -- check if there is any thread that is still being debugged under LuaJIT;
  -- if not, turn the debugging off
  if jit then
    local remove = true
    for _, debugged in pairs(coroutines) do
      if debugged then remove = false; break end
    end
    if remove then debug.sethook() end
  end
end

-- Handles server debugging commands
local function handle(params, client, options)
  -- when `options.verbose` is not provided, use normal `print`; verbose output can be
  -- disabled (`options.verbose == false`) or redirected (`options.verbose == function()...end`)
  local verbose = not options or options.verbose ~= nil and options.verbose
  local print = verbose and (type(verbose) == "function" and verbose or print) or function() end
  local file, line, watch_idx
  local _, _, command = string.find(params, "^([a-z]+)")
  if command == "run" or command == "step" or command == "out"
  or command == "over" or command == "exit" then
    client:send(string.upper(command) .. "\n")
    client:receive() -- this should consume the first '200 OK' response
    while true do
      local done = true
      local breakpoint = client:receive()
      if not breakpoint then
        print("Program finished")
        return nil, nil, false
      end
      local _, _, status = string.find(breakpoint, "^(%d+)")
      if status == "200" then
        -- don't need to do anything
      elseif status == "202" then
        _, _, file, line = string.find(breakpoint, "^202 Paused%s+(.-)%s+(%d+)%s*$")
        if file and line then
          print("Paused at file " .. file .. " line " .. line)
        end
      elseif status == "203" then
        _, _, file, line, watch_idx = string.find(breakpoint, "^203 Paused%s+(.-)%s+(%d+)%s+(%d+)%s*$")
        if file and line and watch_idx then
          print("Paused at file " .. file .. " line " .. line .. " (watch expression " .. watch_idx .. ": [" .. watches[watch_idx] .. "])")
        end
      elseif status == "204" then
        local _, _, stream, size = string.find(breakpoint, "^204 Output (%w+) (%d+)$")
        if stream and size then
          local size = tonumber(size)
          local msg = size > 0 and client:receive(size) or ""
          print(msg)
          if outputs[stream] then outputs[stream](msg) end
          -- this was just the output, so go back reading the response
          done = false
        end
      elseif status == "401" then
        local _, _, size = string.find(breakpoint, "^401 Error in Execution (%d+)$")
        if size then
          local msg = client:receive(tonumber(size))
          print("Error in remote application: " .. msg)
          return nil, nil, msg
        end
      else
        print("Unknown error")
        return nil, nil, "Debugger error: unexpected response '" .. breakpoint .. "'"
      end
      if done then break end
    end
  elseif command == "done" then
    client:send(string.upper(command) .. "\n")
    -- no response is expected
  elseif command == "setb" or command == "asetb" then
    _, _, _, file, line = string.find(params, "^([a-z]+)%s+(.-)%s+(%d+)%s*$")
    if file and line then
      -- if this is a file name, and not a file source
      if not file:find('^".*"$') then
        file = string.gsub(file, "\\", "/") -- convert slash
        file = removebasedir(file, basedir)
      end
      client:send("SETB " .. file .. " " .. line .. "\n")
      if command == "asetb" or client:receive() == "200 OK" then
        set_breakpoint(file, line)
      else
        print("Error: breakpoint not inserted")
      end
    else
      print("Invalid command")
    end
  elseif command == "setw" then
    local _, _, exp = string.find(params, "^[a-z]+%s+(.+)$")
    if exp then
      client:send("SETW " .. exp .. "\n")
      local answer = client:receive()
      local _, _, watch_idx = string.find(answer, "^200 OK (%d+)%s*$")
      if watch_idx then
        watches[watch_idx] = exp
        print("Inserted watch exp no. " .. watch_idx)
      else
        local _, _, size = string.find(answer, "^401 Error in Expression (%d+)$")
        if size then
          local err = client:receive(tonumber(size)):gsub(".-:%d+:%s*","")
          print("Error: watch expression not set: " .. err)
        else
          print("Error: watch expression not set")
        end
      end
    else
      print("Invalid command")
    end
  elseif command == "delb" or command == "adelb" then
    _, _, _, file, line = string.find(params, "^([a-z]+)%s+(.-)%s+(%d+)%s*$")
    if file and line then
      -- if this is a file name, and not a file source
      if not file:find('^".*"$') then
        file = string.gsub(file, "\\", "/") -- convert slash
        file = removebasedir(file, basedir)
      end
      client:send("DELB " .. file .. " " .. line .. "\n")
      if command == "adelb" or client:receive() == "200 OK" then
        remove_breakpoint(file, line)
      else
        print("Error: breakpoint not removed")
      end
    else
      print("Invalid command")
    end
  elseif command == "delallb" then
    local file, line = "*", 0
    client:send("DELB " .. file .. " " .. tostring(line) .. "\n")
    if client:receive() == "200 OK" then
      remove_breakpoint(file, line)
    else
      print("Error: all breakpoints not removed")
    end
  elseif command == "delw" then
    local _, _, index = string.find(params, "^[a-z]+%s+(%d+)%s*$")
    if index then
      client:send("DELW " .. index .. "\n")
      if client:receive() == "200 OK" then
        watches[index] = nil
      else
        print("Error: watch expression not removed")
      end
    else
      print("Invalid command")
    end
  elseif command == "delallw" then
    for index, exp in pairs(watches) do
      client:send("DELW " .. index .. "\n")
      if client:receive() == "200 OK" then
        watches[index] = nil
      else
        print("Error: watch expression at index " .. index .. " [" .. exp .. "] not removed")
      end
    end
  elseif command == "eval" or command == "exec"
      or command == "load" or command == "loadstring"
      or command == "reload" then
    local _, _, exp = string.find(params, "^[a-z]+%s+(.+)$")
    if exp or (command == "reload") then
      if command == "eval" or command == "exec" then
        exp = (exp:gsub("%-%-%[(=*)%[.-%]%1%]", "") -- remove comments
                  :gsub("%-%-.-\n", " ") -- remove line comments
                  :gsub("\n", " ")) -- convert new lines
        if command == "eval" then exp = "return " .. exp end
        client:send("EXEC " .. exp .. "\n")
      elseif command == "reload" then
        client:send("LOAD 0 -\n")
      elseif command == "loadstring" then
        local _, _, _, file, lines = string.find(exp, "^([\"'])(.-)%1%s(.+)")
        if not file then
           _, _, file, lines = string.find(exp, "^(%S+)%s(.+)")
        end
        client:send("LOAD " .. tostring(#lines) .. " " .. file .. "\n")
        client:send(lines)
      else
        local file = io.open(exp, "r")
        if not file and pcall(require, "winapi") then
          -- if file is not open and winapi is there, try with a short path;
          -- this may be needed for unicode paths on windows
          winapi.set_encoding(winapi.CP_UTF8)
          local shortp = winapi.short_path(exp)
          file = shortp and io.open(shortp, "r")
        end
        if not file then return nil, nil, "Cannot open file " .. exp end
        -- read the file and remove the shebang line as it causes a compilation error
        local lines = file:read("*all"):gsub("^#!.-\n", "\n")
        file:close()

        local file = string.gsub(exp, "\\", "/") -- convert slash
        file = removebasedir(file, basedir)
        client:send("LOAD " .. tostring(#lines) .. " " .. file .. "\n")
        if #lines > 0 then client:send(lines) end
      end
      while true do
        local params, err = client:receive()
        if not params then
          return nil, nil, "Debugger connection " .. (err or "error")
        end
        local done = true
        local _, _, status, len = string.find(params, "^(%d+).-%s+(%d+)%s*$")
        if status == "200" then
          len = tonumber(len)
          if len > 0 then
            local status, res
            local str = client:receive(len)
            -- handle serialized table with results
            local func, err = loadstring(str)
            if func then
              status, res = pcall(func)
              if not status then err = res
              elseif type(res) ~= "table" then
                err = "received "..type(res).." instead of expected 'table'"
              end
            end
            if err then
              print("Error in processing results: " .. err)
              return nil, nil, "Error in processing results: " .. err
            end
            print(unpack(res))
            return res[1], res
          end
        elseif status == "201" then
          _, _, file, line = string.find(params, "^201 Started%s+(.-)%s+(%d+)%s*$")
        elseif status == "202" or params == "200 OK" then
          -- do nothing; this only happens when RE/LOAD command gets the response
          -- that was for the original command that was aborted
        elseif status == "204" then
          local _, _, stream, size = string.find(params, "^204 Output (%w+) (%d+)$")
          if stream and size then
            local size = tonumber(size)
            local msg = size > 0 and client:receive(size) or ""
            print(msg)
            if outputs[stream] then outputs[stream](msg) end
            -- this was just the output, so go back reading the response
            done = false
          end
        elseif status == "401" then
          len = tonumber(len)
          local res = client:receive(len)
          print("Error in expression: " .. res)
          return nil, nil, res
        else
          print("Unknown error")
          return nil, nil, "Debugger error: unexpected response after EXEC/LOAD '" .. params .. "'"
        end
        if done then break end
      end
    else
      print("Invalid command")
    end
  elseif command == "listb" then
    for l, v in pairs(breakpoints) do
      for f in pairs(v) do
        print(f .. ": " .. l)
      end
    end
  elseif command == "listw" then
    for i, v in pairs(watches) do
      print("Watch exp. " .. i .. ": " .. v)
    end
  elseif command == "suspend" then
    client:send("SUSPEND\n")
  elseif command == "stack" then
    local opts = string.match(params, "^[a-z]+%s+(.+)$")
    client:send("STACK" .. (opts and " "..opts or "") .."\n")
    local resp = client:receive()
    local _, _, status, res = string.find(resp, "^(%d+)%s+%w+%s+(.+)%s*$")
    if status == "200" then
      local func, err = loadstring(res)
      if func == nil then
        print("Error in stack information: " .. err)
        return nil, nil, err
      end
      local ok, stack = pcall(func)
      if not ok then
        print("Error in stack information: " .. stack)
        return nil, nil, stack
      end
      for _,frame in ipairs(stack) do
        print(mobdebug.line(frame[1], {comment = false}))
      end
      return stack
    elseif status == "401" then
      local _, _, len = string.find(resp, "%s+(%d+)%s*$")
      len = tonumber(len)
      local res = len > 0 and client:receive(len) or "Invalid stack information."
      print("Error in expression: " .. res)
      return nil, nil, res
    else
      print("Unknown error")
      return nil, nil, "Debugger error: unexpected response after STACK"
    end
  elseif command == "output" then
    local _, _, stream, mode = string.find(params, "^[a-z]+%s+(%w+)%s+([dcr])%s*$")
    if stream and mode then
      client:send("OUTPUT "..stream.." "..mode.."\n")
      local resp, err = client:receive()
      if not resp then
        print("Unknown error: "..err)
        return nil, nil, "Debugger connection error: "..err
      end
      local _, _, status = string.find(resp, "^(%d+)%s+%w+%s*$")
      if status == "200" then
        print("Stream "..stream.." redirected")
        outputs[stream] = type(options) == 'table' and options.handler or nil
      -- the client knows when she is doing, so install the handler
      elseif type(options) == 'table' and options.handler then
        outputs[stream] = options.handler
      else
        print("Unknown error")
        return nil, nil, "Debugger error: can't redirect "..stream
      end
    else
      print("Invalid command")
    end
  elseif command == "basedir" then
    local _, _, dir = string.find(params, "^[a-z]+%s+(.+)$")
    if dir then
      dir = string.gsub(dir, "\\", "/") -- convert slash
      if not string.find(dir, "/$") then dir = dir .. "/" end

      local remdir = dir:match("\t(.+)")
      if remdir then dir = dir:gsub("/?\t.+", "/") end
      basedir = dir

      client:send("BASEDIR "..(remdir or dir).."\n")
      local resp, err = client:receive()
      if not resp then
        print("Unknown error: "..err)
        return nil, nil, "Debugger connection error: "..err
      end
      local _, _, status = string.find(resp, "^(%d+)%s+%w+%s*$")
      if status == "200" then
        print("New base directory is " .. basedir)
      else
        print("Unknown error")
        return nil, nil, "Debugger error: unexpected response after BASEDIR"
      end
    else
      print(basedir)
    end
  elseif command == "help" then
    print("setb <file> <line>    -- sets a breakpoint")
    print("delb <file> <line>    -- removes a breakpoint")
    print("delallb               -- removes all breakpoints")
    print("setw <exp>            -- adds a new watch expression")
    print("delw <index>          -- removes the watch expression at index")
    print("delallw               -- removes all watch expressions")
    print("run                   -- runs until next breakpoint")
    print("step                  -- runs until next line, stepping into function calls")
    print("over                  -- runs until next line, stepping over function calls")
    print("out                   -- runs until line after returning from current function")
    print("listb                 -- lists breakpoints")
    print("listw                 -- lists watch expressions")
    print("eval <exp>            -- evaluates expression on the current context and returns its value")
    print("exec <stmt>           -- executes statement on the current context")
    print("load <file>           -- loads a local file for debugging")
    print("reload                -- restarts the current debugging session")
    print("stack                 -- reports stack trace")
    print("output stdout <d|c|r> -- capture and redirect io stream (default|copy|redirect)")
    print("basedir [<path>]      -- sets the base path of the remote application, or shows the current one")
    print("done                  -- stops the debugger and continues application execution")
    print("exit                  -- exits debugger and the application")
  else
    local _, _, spaces = string.find(params, "^(%s*)$")
    if spaces then
      return nil, nil, "Empty command"
    else
      print("Invalid command")
      return nil, nil, "Invalid command"
    end
  end
  return file, line
end

-- Starts debugging server
local function listen(host, port)
  host = host or "*"
  port = port or mobdebug.port

  local socket = require "socket"

  print("Lua Remote Debugger")
  print("Run the program you wish to debug")

  local server = socket.bind(host, port)
  local client = server:accept()

  client:send("STEP\n")
  client:receive()

  local breakpoint = client:receive()
  local _, _, file, line = string.find(breakpoint, "^202 Paused%s+(.-)%s+(%d+)%s*$")
  if file and line then
    print("Paused at file " .. file )
    print("Type 'help' for commands")
  else
    local _, _, size = string.find(breakpoint, "^401 Error in Execution (%d+)%s*$")
    if size then
      print("Error in remote application: ")
      print(client:receive(size))
    end
  end

  while true do
    io.write("> ")
    local file, line, err = handle(io.read("*line"), client)
    if not file and err == false then break end -- completed debugging
  end

  client:close()
end

local cocreate
local function coro()
  if cocreate then return end -- only set once
  cocreate = cocreate or coroutine.create
  coroutine.create = function(f, ...)
    return cocreate(function(...)
      mobdebug.on()
      return f(...)
    end, ...)
  end
end

local moconew
local function moai()
  if moconew then return end -- only set once
  moconew = moconew or (MOAICoroutine and MOAICoroutine.new)
  if not moconew then return end
  MOAICoroutine.new = function(...)
    local thread = moconew(...)
    -- need to support both thread.run and getmetatable(thread).run, which
    -- was used in earlier MOAI versions
    local mt = thread.run and thread or getmetatable(thread)
    local patched = mt.run
    mt.run = function(self, f, ...)
      return patched(self,  function(...)
        mobdebug.on()
        return f(...)
      end, ...)
    end
    return thread
  end
end

-- make public functions available
mobdebug.setbreakpoint = set_breakpoint
mobdebug.removebreakpoint = remove_breakpoint
mobdebug.listen = listen
mobdebug.loop = loop
mobdebug.scratchpad = scratchpad
mobdebug.handle = handle
mobdebug.connect = connect
mobdebug.start = start
mobdebug.on = on
mobdebug.off = off
mobdebug.moai = moai
mobdebug.coro = coro
mobdebug.done = done
mobdebug.pause = function() step_into = true end
mobdebug.yield = nil -- callback
mobdebug.output = output
mobdebug.onexit = os and os.exit or done
mobdebug.onscratch = nil -- callback
mobdebug.basedir = function(b) if b then basedir = b end return basedir end

return mobdebug

```

`lua/libs/socket.lua`:

```lua
-----------------------------------------------------------------------------
-- LuaSocket helper module
-- Author: Diego Nehab
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module and import dependencies
-----------------------------------------------------------------------------
local base = _G
local string = require("string")
local math = require("math")
local socket = require("socket.core")

local _M = socket

-----------------------------------------------------------------------------
-- Exported auxiliar functions
-----------------------------------------------------------------------------
function _M.connect4(address, port, laddress, lport)
    return socket.connect(address, port, laddress, lport, "inet")
end

function _M.connect6(address, port, laddress, lport)
    return socket.connect(address, port, laddress, lport, "inet6")
end

function _M.bind(host, port, backlog)
    if host == "*" then host = "0.0.0.0" end
    local addrinfo, err = socket.dns.getaddrinfo(host);
    if not addrinfo then return nil, err end
    local sock, res
    err = "no info on address"
    for i, alt in base.ipairs(addrinfo) do
        if alt.family == "inet" then
            sock, err = socket.tcp4()
        else
            sock, err = socket.tcp6()
        end
        if not sock then return nil, err end
        sock:setoption("reuseaddr", true)
        res, err = sock:bind(alt.addr, port)
        if not res then
            sock:close()
        else
            res, err = sock:listen(backlog)
            if not res then
                sock:close()
            else
                return sock
            end
        end
    end
    return nil, err
end

_M.try = _M.newtry()

function _M.choose(table)
    return function(name, opt1, opt2)
        if base.type(name) ~= "string" then
            name, opt1, opt2 = "default", name, opt1
        end
        local f = table[name or "nil"]
        if not f then base.error("unknown key (".. base.tostring(name) ..")", 3)
        else return f(opt1, opt2) end
    end
end

-----------------------------------------------------------------------------
-- Socket sources and sinks, conforming to LTN12
-----------------------------------------------------------------------------
-- create namespaces inside LuaSocket namespace
local sourcet, sinkt = {}, {}
_M.sourcet = sourcet
_M.sinkt = sinkt

_M.BLOCKSIZE = 2048

sinkt["close-when-done"] = function(sock)
    return base.setmetatable({
        getfd = function() return sock:getfd() end,
        dirty = function() return sock:dirty() end
    }, {
        __call = function(self, chunk, err)
            if not chunk then
                sock:close()
                return 1
            else return sock:send(chunk) end
        end
    })
end

sinkt["keep-open"] = function(sock)
    return base.setmetatable({
        getfd = function() return sock:getfd() end,
        dirty = function() return sock:dirty() end
    }, {
        __call = function(self, chunk, err)
            if chunk then return sock:send(chunk)
            else return 1 end
        end
    })
end

sinkt["default"] = sinkt["keep-open"]

_M.sink = _M.choose(sinkt)

sourcet["by-length"] = function(sock, length)
    return base.setmetatable({
        getfd = function() return sock:getfd() end,
        dirty = function() return sock:dirty() end
    }, {
        __call = function()
            if length <= 0 then return nil end
            local size = math.min(socket.BLOCKSIZE, length)
            local chunk, err = sock:receive(size)
            if err then return nil, err end
            length = length - string.len(chunk)
            return chunk
        end
    })
end

sourcet["until-closed"] = function(sock)
    local done
    return base.setmetatable({
        getfd = function() return sock:getfd() end,
        dirty = function() return sock:dirty() end
    }, {
        __call = function()
            if done then return nil end
            local chunk, err, partial = sock:receive(socket.BLOCKSIZE)
            if not err then return chunk
            elseif err == "closed" then
                sock:close()
                done = 1
                return partial
            else return nil, err end
        end
    })
end


sourcet["default"] = sourcet["until-closed"]

_M.source = _M.choose(sourcet)

return _M

```

`lua/libs/socket/ftp.lua`:

```lua
-----------------------------------------------------------------------------
-- FTP support for the Lua language
-- LuaSocket toolkit.
-- Author: Diego Nehab
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module and import dependencies
-----------------------------------------------------------------------------
local base = _G
local table = require("table")
local string = require("string")
local math = require("math")
local socket = require("socket")
local url = require("socket.url")
local tp = require("socket.tp")
local ltn12 = require("ltn12")
socket.ftp = {}
local _M = socket.ftp
-----------------------------------------------------------------------------
-- Program constants
-----------------------------------------------------------------------------
-- timeout in seconds before the program gives up on a connection
_M.TIMEOUT = 60
-- default port for ftp service
local PORT = 21
-- this is the default anonymous password. used when no password is
-- provided in url. should be changed to your e-mail.
_M.USER = "ftp"
_M.PASSWORD = "anonymous@anonymous.org"

-----------------------------------------------------------------------------
-- Low level FTP API
-----------------------------------------------------------------------------
local metat = { __index = {} }

function _M.open(server, port, create)
    local tp = socket.try(tp.connect(server, port or PORT, _M.TIMEOUT, create))
    local f = base.setmetatable({ tp = tp }, metat)
    -- make sure everything gets closed in an exception
    f.try = socket.newtry(function() f:close() end)
    return f
end

function metat.__index:portconnect()
    self.try(self.server:settimeout(_M.TIMEOUT))
    self.data = self.try(self.server:accept())
    self.try(self.data:settimeout(_M.TIMEOUT))
end

function metat.__index:pasvconnect()
    self.data = self.try(socket.tcp())
    self.try(self.data:settimeout(_M.TIMEOUT))
    self.try(self.data:connect(self.pasvt.address, self.pasvt.port))
end

function metat.__index:login(user, password)
    self.try(self.tp:command("user", user or _M.USER))
    local code, reply = self.try(self.tp:check{"2..", 331})
    if code == 331 then
        self.try(self.tp:command("pass", password or _M.PASSWORD))
        self.try(self.tp:check("2.."))
    end
    return 1
end

function metat.__index:pasv()
    self.try(self.tp:command("pasv"))
    local code, reply = self.try(self.tp:check("2.."))
    local pattern = "(%d+)%D(%d+)%D(%d+)%D(%d+)%D(%d+)%D(%d+)"
    local a, b, c, d, p1, p2 = socket.skip(2, string.find(reply, pattern))
    self.try(a and b and c and d and p1 and p2, reply)
    self.pasvt = {
        address = string.format("%d.%d.%d.%d", a, b, c, d),
        port = p1*256 + p2
    }
    if self.server then
        self.server:close()
        self.server = nil
    end
    return self.pasvt.address, self.pasvt.port
end

function metat.__index:epsv()
    self.try(self.tp:command("epsv"))
    local code, reply = self.try(self.tp:check("229"))
    local pattern = "%((.)(.-)%1(.-)%1(.-)%1%)"
    local d, prt, address, port = string.match(reply, pattern)
    self.try(port, "invalid epsv response")
    self.pasvt = {
        address = self.tp:getpeername(),
        port = port
    }
    if self.server then
        self.server:close()
        self.server = nil
    end
    return self.pasvt.address, self.pasvt.port
end


function metat.__index:port(address, port)
    self.pasvt = nil
    if not address then
        address, port = self.try(self.tp:getsockname())
        self.server = self.try(socket.bind(address, 0))
        address, port = self.try(self.server:getsockname())
        self.try(self.server:settimeout(_M.TIMEOUT))
    end
    local pl = math.mod(port, 256)
    local ph = (port - pl)/256
    local arg = string.gsub(string.format("%s,%d,%d", address, ph, pl), "%.", ",")
    self.try(self.tp:command("port", arg))
    self.try(self.tp:check("2.."))
    return 1
end

function metat.__index:eprt(family, address, port)
    self.pasvt = nil
    if not address then
        address, port = self.try(self.tp:getsockname())
        self.server = self.try(socket.bind(address, 0))
        address, port = self.try(self.server:getsockname())
        self.try(self.server:settimeout(_M.TIMEOUT))
    end
    local arg = string.format("|%s|%s|%d|", family, address, port)
    self.try(self.tp:command("eprt", arg))
    self.try(self.tp:check("2.."))
    return 1
end


function metat.__index:send(sendt)
    self.try(self.pasvt or self.server, "need port or pasv first")
    -- if there is a pasvt table, we already sent a PASV command
    -- we just get the data connection into self.data
    if self.pasvt then self:pasvconnect() end
    -- get the transfer argument and command
    local argument = sendt.argument or
        url.unescape(string.gsub(sendt.path or "", "^[/\\]", ""))
    if argument == "" then argument = nil end
    local command = sendt.command or "stor"
    -- send the transfer command and check the reply
    self.try(self.tp:command(command, argument))
    local code, reply = self.try(self.tp:check{"2..", "1.."})
    -- if there is not a pasvt table, then there is a server
    -- and we already sent a PORT command
    if not self.pasvt then self:portconnect() end
    -- get the sink, source and step for the transfer
    local step = sendt.step or ltn12.pump.step
    local readt = { self.tp }
    local checkstep = function(src, snk)
        -- check status in control connection while downloading
        local readyt = socket.select(readt, nil, 0)
        if readyt[tp] then code = self.try(self.tp:check("2..")) end
        return step(src, snk)
    end
    local sink = socket.sink("close-when-done", self.data)
    -- transfer all data and check error
    self.try(ltn12.pump.all(sendt.source, sink, checkstep))
    if string.find(code, "1..") then self.try(self.tp:check("2..")) end
    -- done with data connection
    self.data:close()
    -- find out how many bytes were sent
    local sent = socket.skip(1, self.data:getstats())
    self.data = nil
    return sent
end

function metat.__index:receive(recvt)
    self.try(self.pasvt or self.server, "need port or pasv first")
    if self.pasvt then self:pasvconnect() end
    local argument = recvt.argument or
        url.unescape(string.gsub(recvt.path or "", "^[/\\]", ""))
    if argument == "" then argument = nil end
    local command = recvt.command or "retr"
    self.try(self.tp:command(command, argument))
    local code,reply = self.try(self.tp:check{"1..", "2.."})
    if (code >= 200) and (code <= 299) then
        recvt.sink(reply)
        return 1
    end
    if not self.pasvt then self:portconnect() end
    local source = socket.source("until-closed", self.data)
    local step = recvt.step or ltn12.pump.step
    self.try(ltn12.pump.all(source, recvt.sink, step))
    if string.find(code, "1..") then self.try(self.tp:check("2..")) end
    self.data:close()
    self.data = nil
    return 1
end

function metat.__index:cwd(dir)
    self.try(self.tp:command("cwd", dir))
    self.try(self.tp:check(250))
    return 1
end

function metat.__index:type(type)
    self.try(self.tp:command("type", type))
    self.try(self.tp:check(200))
    return 1
end

function metat.__index:greet()
    local code = self.try(self.tp:check{"1..", "2.."})
    if string.find(code, "1..") then self.try(self.tp:check("2..")) end
    return 1
end

function metat.__index:quit()
    self.try(self.tp:command("quit"))
    self.try(self.tp:check("2.."))
    return 1
end

function metat.__index:close()
    if self.data then self.data:close() end
    if self.server then self.server:close() end
    return self.tp:close()
end

-----------------------------------------------------------------------------
-- High level FTP API
-----------------------------------------------------------------------------
local function override(t)
    if t.url then
        local u = url.parse(t.url)
        for i,v in base.pairs(t) do
            u[i] = v
        end
        return u
    else return t end
end

local function tput(putt)
    putt = override(putt)
    socket.try(putt.host, "missing hostname")
    local f = _M.open(putt.host, putt.port, putt.create)
    f:greet()
    f:login(putt.user, putt.password)
    if putt.type then f:type(putt.type) end
    f:epsv()
    local sent = f:send(putt)
    f:quit()
    f:close()
    return sent
end

local default = {
    path = "/",
    scheme = "ftp"
}

local function genericform(u)
    local t = socket.try(url.parse(u, default))
    socket.try(t.scheme == "ftp", "wrong scheme '" .. t.scheme .. "'")
    socket.try(t.host, "missing hostname")
    local pat = "^type=(.)$"
    if t.params then
        t.type = socket.skip(2, string.find(t.params, pat))
        socket.try(t.type == "a" or t.type == "i",
            "invalid type '" .. t.type .. "'")
    end
    return t
end

_M.genericform = genericform

local function sput(u, body)
    local putt = genericform(u)
    putt.source = ltn12.source.string(body)
    return tput(putt)
end

_M.put = socket.protect(function(putt, body)
    if base.type(putt) == "string" then return sput(putt, body)
    else return tput(putt) end
end)

local function tget(gett)
    gett = override(gett)
    socket.try(gett.host, "missing hostname")
    local f = _M.open(gett.host, gett.port, gett.create)
    f:greet()
    f:login(gett.user, gett.password)
    if gett.type then f:type(gett.type) end
    f:epsv()
    f:receive(gett)
    f:quit()
    return f:close()
end

local function sget(u)
    local gett = genericform(u)
    local t = {}
    gett.sink = ltn12.sink.table(t)
    tget(gett)
    return table.concat(t)
end

_M.command = socket.protect(function(cmdt)
    cmdt = override(cmdt)
    socket.try(cmdt.host, "missing hostname")
    socket.try(cmdt.command, "missing command")
    local f = _M.open(cmdt.host, cmdt.port, cmdt.create)
    f:greet()
    f:login(cmdt.user, cmdt.password)
    if type(cmdt.command) == "table" then
        local argument = cmdt.argument or {}
        local check = cmdt.check or {}
        for i,cmd in ipairs(cmdt.command) do
            f.try(f.tp:command(cmd, argument[i]))
            if check[i] then f.try(f.tp:check(check[i])) end
        end
    else
        f.try(f.tp:command(cmdt.command, cmdt.argument))
        if cmdt.check then f.try(f.tp:check(cmdt.check)) end
    end
    f:quit()
    return f:close()
end)

_M.get = socket.protect(function(gett)
    if base.type(gett) == "string" then return sget(gett)
    else return tget(gett) end
end)

return _M

```

`lua/libs/socket/headers.lua`:

```lua
-----------------------------------------------------------------------------
-- Canonic header field capitalization
-- LuaSocket toolkit.
-- Author: Diego Nehab
-----------------------------------------------------------------------------
local socket = require("socket")
socket.headers = {}
local _M = socket.headers

_M.canonic = {
    ["accept"] = "Accept",
    ["accept-charset"] = "Accept-Charset",
    ["accept-encoding"] = "Accept-Encoding",
    ["accept-language"] = "Accept-Language",
    ["accept-ranges"] = "Accept-Ranges",
    ["action"] = "Action",
    ["alternate-recipient"] = "Alternate-Recipient",
    ["age"] = "Age",
    ["allow"] = "Allow",
    ["arrival-date"] = "Arrival-Date",
    ["authorization"] = "Authorization",
    ["bcc"] = "Bcc",
    ["cache-control"] = "Cache-Control",
    ["cc"] = "Cc",
    ["comments"] = "Comments",
    ["connection"] = "Connection",
    ["content-description"] = "Content-Description",
    ["content-disposition"] = "Content-Disposition",
    ["content-encoding"] = "Content-Encoding",
    ["content-id"] = "Content-ID",
    ["content-language"] = "Content-Language",
    ["content-length"] = "Content-Length",
    ["content-location"] = "Content-Location",
    ["content-md5"] = "Content-MD5",
    ["content-range"] = "Content-Range",
    ["content-transfer-encoding"] = "Content-Transfer-Encoding",
    ["content-type"] = "Content-Type",
    ["cookie"] = "Cookie",
    ["date"] = "Date",
    ["diagnostic-code"] = "Diagnostic-Code",
    ["dsn-gateway"] = "DSN-Gateway",
    ["etag"] = "ETag",
    ["expect"] = "Expect",
    ["expires"] = "Expires",
    ["final-log-id"] = "Final-Log-ID",
    ["final-recipient"] = "Final-Recipient",
    ["from"] = "From",
    ["host"] = "Host",
    ["if-match"] = "If-Match",
    ["if-modified-since"] = "If-Modified-Since",
    ["if-none-match"] = "If-None-Match",
    ["if-range"] = "If-Range",
    ["if-unmodified-since"] = "If-Unmodified-Since",
    ["in-reply-to"] = "In-Reply-To",
    ["keywords"] = "Keywords",
    ["last-attempt-date"] = "Last-Attempt-Date",
    ["last-modified"] = "Last-Modified",
    ["location"] = "Location",
    ["max-forwards"] = "Max-Forwards",
    ["message-id"] = "Message-ID",
    ["mime-version"] = "MIME-Version",
    ["original-envelope-id"] = "Original-Envelope-ID",
    ["original-recipient"] = "Original-Recipient",
    ["pragma"] = "Pragma",
    ["proxy-authenticate"] = "Proxy-Authenticate",
    ["proxy-authorization"] = "Proxy-Authorization",
    ["range"] = "Range",
    ["received"] = "Received",
    ["received-from-mta"] = "Received-From-MTA",
    ["references"] = "References",
    ["referer"] = "Referer",
    ["remote-mta"] = "Remote-MTA",
    ["reply-to"] = "Reply-To",
    ["reporting-mta"] = "Reporting-MTA",
    ["resent-bcc"] = "Resent-Bcc",
    ["resent-cc"] = "Resent-Cc",
    ["resent-date"] = "Resent-Date",
    ["resent-from"] = "Resent-From",
    ["resent-message-id"] = "Resent-Message-ID",
    ["resent-reply-to"] = "Resent-Reply-To",
    ["resent-sender"] = "Resent-Sender",
    ["resent-to"] = "Resent-To",
    ["retry-after"] = "Retry-After",
    ["return-path"] = "Return-Path",
    ["sender"] = "Sender",
    ["server"] = "Server",
    ["smtp-remote-recipient"] = "SMTP-Remote-Recipient",
    ["status"] = "Status",
    ["subject"] = "Subject",
    ["te"] = "TE",
    ["to"] = "To",
    ["trailer"] = "Trailer",
    ["transfer-encoding"] = "Transfer-Encoding",
    ["upgrade"] = "Upgrade",
    ["user-agent"] = "User-Agent",
    ["vary"] = "Vary",
    ["via"] = "Via",
    ["warning"] = "Warning",
    ["will-retry-until"] = "Will-Retry-Until",
    ["www-authenticate"] = "WWW-Authenticate",
    ["x-mailer"] = "X-Mailer",
}

return _M
```

`lua/libs/socket/http.lua`:

```lua
-----------------------------------------------------------------------------
-- HTTP/1.1 client support for the Lua language.
-- LuaSocket toolkit.
-- Author: Diego Nehab
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module and import dependencies
-------------------------------------------------------------------------------
local socket = require("socket")
local url = require("socket.url")
local ltn12 = require("ltn12")
local mime = require("mime")
local string = require("string")
local headers = require("socket.headers")
local base = _G
local table = require("table")
socket.http = {}
local _M = socket.http

-----------------------------------------------------------------------------
-- Program constants
-----------------------------------------------------------------------------
-- connection timeout in seconds
_M.TIMEOUT = 60
-- user agent field sent in request
_M.USERAGENT = socket._VERSION

-- supported schemes and their particulars
local SCHEMES = {
    http = {
        port = 80
        , create = function(t)
            return socket.tcp end }
    , https = {
        port = 443
        , create = function(t)
          local https = assert(
            require("ssl.https"), 'LuaSocket: LuaSec not found')
          local tcp = assert(
            https.tcp, 'LuaSocket: Function tcp() not available from LuaSec')
          return tcp(t) end }}

-- default scheme and port for document retrieval
local SCHEME = 'http'
local PORT = SCHEMES[SCHEME].port
-----------------------------------------------------------------------------
-- Reads MIME headers from a connection, unfolding where needed
-----------------------------------------------------------------------------
local function receiveheaders(sock, headers)
    local line, name, value, err
    headers = headers or {}
    -- get first line
    line, err = sock:receive()
    if err then return nil, err end
    -- headers go until a blank line is found
    while line ~= "" do
        -- get field-name and value
        name, value = socket.skip(2, string.find(line, "^(.-):%s*(.*)"))
        if not (name and value) then return nil, "malformed reponse headers" end
        name = string.lower(name)
        -- get next line (value might be folded)
        line, err  = sock:receive()
        if err then return nil, err end
        -- unfold any folded values
        while string.find(line, "^%s") do
            value = value .. line
            line = sock:receive()
            if err then return nil, err end
        end
        -- save pair in table
        if headers[name] then headers[name] = headers[name] .. ", " .. value
        else headers[name] = value end
    end
    return headers
end

-----------------------------------------------------------------------------
-- Extra sources and sinks
-----------------------------------------------------------------------------
socket.sourcet["http-chunked"] = function(sock, headers)
    return base.setmetatable({
        getfd = function() return sock:getfd() end,
        dirty = function() return sock:dirty() end
    }, {
        __call = function()
            -- get chunk size, skip extention
            local line, err = sock:receive()
            if err then return nil, err end
            local size = base.tonumber(string.gsub(line, ";.*", ""), 16)
            if not size then return nil, "invalid chunk size" end
            -- was it the last chunk?
            if size > 0 then
                -- if not, get chunk and skip terminating CRLF
                local chunk, err, part = sock:receive(size)
                if chunk then sock:receive() end
                return chunk, err
            else
                -- if it was, read trailers into headers table
                headers, err = receiveheaders(sock, headers)
                if not headers then return nil, err end
            end
        end
    })
end

socket.sinkt["http-chunked"] = function(sock)
    return base.setmetatable({
        getfd = function() return sock:getfd() end,
        dirty = function() return sock:dirty() end
    }, {
        __call = function(self, chunk, err)
            if not chunk then return sock:send("0\r\n\r\n") end
            local size = string.format("%X\r\n", string.len(chunk))
            return sock:send(size ..  chunk .. "\r\n")
        end
    })
end

-----------------------------------------------------------------------------
-- Low level HTTP API
-----------------------------------------------------------------------------
local metat = { __index = {} }

function _M.open(host, port, create)
    -- create socket with user connect function, or with default
    local c = socket.try(create())
    local h = base.setmetatable({ c = c }, metat)
    -- create finalized try
    h.try = socket.newtry(function() h:close() end)
    -- set timeout before connecting
    h.try(c:settimeout(_M.TIMEOUT))
    h.try(c:connect(host, port))
    -- here everything worked
    return h
end

function metat.__index:sendrequestline(method, uri)
    local reqline = string.format("%s %s HTTP/1.1\r\n", method or "GET", uri)
    return self.try(self.c:send(reqline))
end

function metat.__index:sendheaders(tosend)
    local canonic = headers.canonic
    local h = "\r\n"
    for f, v in base.pairs(tosend) do
        h = (canonic[f] or f) .. ": " .. v .. "\r\n" .. h
    end
    self.try(self.c:send(h))
    return 1
end

function metat.__index:sendbody(headers, source, step)
    source = source or ltn12.source.empty()
    step = step or ltn12.pump.step
    -- if we don't know the size in advance, send chunked and hope for the best
    local mode = "http-chunked"
    if headers["content-length"] then mode = "keep-open" end
    return self.try(ltn12.pump.all(source, socket.sink(mode, self.c), step))
end

function metat.__index:receivestatusline()
    local status,ec = self.try(self.c:receive(5))
    -- identify HTTP/0.9 responses, which do not contain a status line
    -- this is just a heuristic, but is what the RFC recommends
    if status ~= "HTTP/" then
        if ec == "timeout" then
            return 408
        end 
        return nil, status 
    end
    -- otherwise proceed reading a status line
    status = self.try(self.c:receive("*l", status))
    local code = socket.skip(2, string.find(status, "HTTP/%d*%.%d* (%d%d%d)"))
    return self.try(base.tonumber(code), status)
end

function metat.__index:receiveheaders()
    return self.try(receiveheaders(self.c))
end

function metat.__index:receivebody(headers, sink, step)
    sink = sink or ltn12.sink.null()
    step = step or ltn12.pump.step
    local length = base.tonumber(headers["content-length"])
    local t = headers["transfer-encoding"] -- shortcut
    local mode = "default" -- connection close
    if t and t ~= "identity" then mode = "http-chunked"
    elseif base.tonumber(headers["content-length"]) then mode = "by-length" end
    return self.try(ltn12.pump.all(socket.source(mode, self.c, length),
        sink, step))
end

function metat.__index:receive09body(status, sink, step)
    local source = ltn12.source.rewind(socket.source("until-closed", self.c))
    source(status)
    return self.try(ltn12.pump.all(source, sink, step))
end

function metat.__index:close()
    return self.c:close()
end

-----------------------------------------------------------------------------
-- High level HTTP API
-----------------------------------------------------------------------------
local function adjusturi(reqt)
    local u = reqt
    -- if there is a proxy, we need the full url. otherwise, just a part.
    if not reqt.proxy and not _M.PROXY then
        u = {
           path = socket.try(reqt.path, "invalid path 'nil'"),
           params = reqt.params,
           query = reqt.query,
           fragment = reqt.fragment
        }
    end
    return url.build(u)
end

local function adjustproxy(reqt)
    local proxy = reqt.proxy or _M.PROXY
    if proxy then
        proxy = url.parse(proxy)
        return proxy.host, proxy.port or 3128
    else
        return reqt.host, reqt.port
    end
end

local function adjustheaders(reqt)
    -- default headers
    local host = reqt.host
    local port = tostring(reqt.port)
    if port ~= tostring(SCHEMES[reqt.scheme].port) then
        host = host .. ':' .. port end
    local lower = {
        ["user-agent"] = _M.USERAGENT,
        ["host"] = host,
        ["connection"] = "close, TE",
        ["te"] = "trailers"
    }
    -- if we have authentication information, pass it along
    if reqt.user and reqt.password then
        lower["authorization"] =
            "Basic " ..  (mime.b64(reqt.user .. ":" ..
		url.unescape(reqt.password)))
    end
    -- if we have proxy authentication information, pass it along
    local proxy = reqt.proxy or _M.PROXY
    if proxy then
        proxy = url.parse(proxy)
        if proxy.user and proxy.password then
            lower["proxy-authorization"] =
                "Basic " ..  (mime.b64(proxy.user .. ":" .. proxy.password))
        end
    end
    -- override with user headers
    for i,v in base.pairs(reqt.headers or lower) do
        lower[string.lower(i)] = v
    end
    return lower
end

-- default url parts
local default = {
    path ="/"
    , scheme = "http"
}

local function adjustrequest(reqt)
    -- parse url if provided
    local nreqt = reqt.url and url.parse(reqt.url, default) or {}
    -- explicit components override url
    for i,v in base.pairs(reqt) do nreqt[i] = v end
    -- default to scheme particulars
    local schemedefs, host, port, method
        = SCHEMES[nreqt.scheme], nreqt.host, nreqt.port, nreqt.method
    if not nreqt.create then nreqt.create = schemedefs.create(nreqt) end
    if not (port and port ~= '') then nreqt.port = schemedefs.port end
    if not (method and method ~= '') then nreqt.method = 'GET' end
    if not (host and host ~= "") then
        socket.try(nil, "invalid host '" .. base.tostring(nreqt.host) .. "'")
    end
    -- compute uri if user hasn't overriden
    nreqt.uri = reqt.uri or adjusturi(nreqt)
    -- adjust headers in request
    nreqt.headers = adjustheaders(nreqt)
    -- ajust host and port if there is a proxy
    nreqt.host, nreqt.port = adjustproxy(nreqt)
    return nreqt
end

local function shouldredirect(reqt, code, headers)
    local location = headers.location
    if not location then return false end
    location = string.gsub(location, "%s", "")
    if location == "" then return false end
    local scheme = url.parse(location).scheme
    if scheme and (not SCHEMES[scheme]) then return false end
    -- avoid https downgrades
    if ('https' == reqt.scheme) and ('https' ~= scheme) then return false end
    return (reqt.redirect ~= false) and
           (code == 301 or code == 302 or code == 303 or code == 307) and
           (not reqt.method or reqt.method == "GET" or reqt.method == "HEAD")
        and ((false == reqt.maxredirects)
                or ((reqt.nredirects or 0)
                        < (reqt.maxredirects or 5)))
end

local function shouldreceivebody(reqt, code)
    if reqt.method == "HEAD" then return nil end
    if code == 204 or code == 304 then return nil end
    if code >= 100 and code < 200 then return nil end
    return 1
end

-- forward declarations
local trequest, tredirect

--[[local]] function tredirect(reqt, location)
    -- the RFC says the redirect URL has to be absolute, but some
    -- servers do not respect that
    local newurl = url.absolute(reqt.url, location)
    -- if switching schemes, reset port and create function
    if url.parse(newurl).scheme ~= reqt.scheme then
        reqt.port = nil
        reqt.create = nil end
    -- make new request
    local result, code, headers, status = trequest {
        url = newurl,
        source = reqt.source,
        sink = reqt.sink,
        headers = reqt.headers,
        proxy = reqt.proxy,
        maxredirects = reqt.maxredirects,
        nredirects = (reqt.nredirects or 0) + 1,
        create = reqt.create
    }
    -- pass location header back as a hint we redirected
    headers = headers or {}
    headers.location = headers.location or location
    return result, code, headers, status
end

--[[local]] function trequest(reqt)
    -- we loop until we get what we want, or
    -- until we are sure there is no way to get it
    local nreqt = adjustrequest(reqt)
    local h = _M.open(nreqt.host, nreqt.port, nreqt.create)
    -- send request line and headers
    h:sendrequestline(nreqt.method, nreqt.uri)
    h:sendheaders(nreqt.headers)
    -- if there is a body, send it
    if nreqt.source then
        h:sendbody(nreqt.headers, nreqt.source, nreqt.step)
    end
    local code, status = h:receivestatusline()
    -- if it is an HTTP/0.9 server, simply get the body and we are done
    if not code then
        h:receive09body(status, nreqt.sink, nreqt.step)
        return 1, 200
    elseif code == 408 then
        return 1, code
    end
    local headers
    -- ignore any 100-continue messages
    while code == 100 do
        headers = h:receiveheaders()
        code, status = h:receivestatusline()
    end
    headers = h:receiveheaders()
    -- at this point we should have a honest reply from the server
    -- we can't redirect if we already used the source, so we report the error
    if shouldredirect(nreqt, code, headers) and not nreqt.source then
        h:close()
        return tredirect(reqt, headers.location)
    end
    -- here we are finally done
    if shouldreceivebody(nreqt, code) then
        h:receivebody(headers, nreqt.sink, nreqt.step)
    end
    h:close()
    return 1, code, headers, status
end

-- turns an url and a body into a generic request
local function genericform(u, b)
    local t = {}
    local reqt = {
        url = u,
        sink = ltn12.sink.table(t),
        target = t
    }
    if b then
        reqt.source = ltn12.source.string(b)
        reqt.headers = {
            ["content-length"] = string.len(b),
            ["content-type"] = "application/x-www-form-urlencoded"
        }
        reqt.method = "POST"
    end
    return reqt
end

_M.genericform = genericform

local function srequest(u, b)
    local reqt = genericform(u, b)
    local _, code, headers, status = trequest(reqt)
    return table.concat(reqt.target), code, headers, status
end

_M.request = socket.protect(function(reqt, body)
    if base.type(reqt) == "string" then return srequest(reqt, body)
    else return trequest(reqt) end
end)

_M.schemes = SCHEMES
return _M

```

`lua/libs/socket/smtp.lua`:

```lua
-----------------------------------------------------------------------------
-- SMTP client support for the Lua language.
-- LuaSocket toolkit.
-- Author: Diego Nehab
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module and import dependencies
-----------------------------------------------------------------------------
local base = _G
local coroutine = require("coroutine")
local string = require("string")
local math = require("math")
local os = require("os")
local socket = require("socket")
local tp = require("socket.tp")
local ltn12 = require("ltn12")
local headers = require("socket.headers")
local mime = require("mime")

socket.smtp = {}
local _M = socket.smtp

-----------------------------------------------------------------------------
-- Program constants
-----------------------------------------------------------------------------
-- timeout for connection
_M.TIMEOUT = 60
-- default server used to send e-mails
_M.SERVER = "localhost"
-- default port
_M.PORT = 25
-- domain used in HELO command and default sendmail
-- If we are under a CGI, try to get from environment
_M.DOMAIN = os.getenv("SERVER_NAME") or "localhost"
-- default time zone (means we don't know)
_M.ZONE = "-0000"

---------------------------------------------------------------------------
-- Low level SMTP API
-----------------------------------------------------------------------------
local metat = { __index = {} }

function metat.__index:greet(domain)
    self.try(self.tp:check("2.."))
    self.try(self.tp:command("EHLO", domain or _M.DOMAIN))
    return socket.skip(1, self.try(self.tp:check("2..")))
end

function metat.__index:mail(from)
    self.try(self.tp:command("MAIL", "FROM:" .. from))
    return self.try(self.tp:check("2.."))
end

function metat.__index:rcpt(to)
    self.try(self.tp:command("RCPT", "TO:" .. to))
    return self.try(self.tp:check("2.."))
end

function metat.__index:data(src, step)
    self.try(self.tp:command("DATA"))
    self.try(self.tp:check("3.."))
    self.try(self.tp:source(src, step))
    self.try(self.tp:send("\r\n.\r\n"))
    return self.try(self.tp:check("2.."))
end

function metat.__index:quit()
    self.try(self.tp:command("QUIT"))
    return self.try(self.tp:check("2.."))
end

function metat.__index:close()
    return self.tp:close()
end

function metat.__index:login(user, password)
    self.try(self.tp:command("AUTH", "LOGIN"))
    self.try(self.tp:check("3.."))
    self.try(self.tp:send(mime.b64(user) .. "\r\n"))
    self.try(self.tp:check("3.."))
    self.try(self.tp:send(mime.b64(password) .. "\r\n"))
    return self.try(self.tp:check("2.."))
end

function metat.__index:plain(user, password)
    local auth = "PLAIN " .. mime.b64("\0" .. user .. "\0" .. password)
    self.try(self.tp:command("AUTH", auth))
    return self.try(self.tp:check("2.."))
end

function metat.__index:auth(user, password, ext)
    if not user or not password then return 1 end
    if string.find(ext, "AUTH[^\n]+LOGIN") then
        return self:login(user, password)
    elseif string.find(ext, "AUTH[^\n]+PLAIN") then
        return self:plain(user, password)
    else
        self.try(nil, "authentication not supported")
    end
end

-- send message or throw an exception
function metat.__index:send(mailt)
    self:mail(mailt.from)
    if base.type(mailt.rcpt) == "table" then
        for i,v in base.ipairs(mailt.rcpt) do
            self:rcpt(v)
        end
    else
        self:rcpt(mailt.rcpt)
    end
    self:data(ltn12.source.chain(mailt.source, mime.stuff()), mailt.step)
end

function _M.open(server, port, create)
    local tp = socket.try(tp.connect(server or _M.SERVER, port or _M.PORT,
        _M.TIMEOUT, create))
    local s = base.setmetatable({tp = tp}, metat)
    -- make sure tp is closed if we get an exception
    s.try = socket.newtry(function()
        s:close()
    end)
    return s
end

-- convert headers to lowercase
local function lower_headers(headers)
    local lower = {}
    for i,v in base.pairs(headers or lower) do
        lower[string.lower(i)] = v
    end
    return lower
end

---------------------------------------------------------------------------
-- Multipart message source
-----------------------------------------------------------------------------
-- returns a hopefully unique mime boundary
local seqno = 0
local function newboundary()
    seqno = seqno + 1
    return string.format('%s%05d==%05u', os.date('%d%m%Y%H%M%S'),
        math.random(0, 99999), seqno)
end

-- send_message forward declaration
local send_message

-- yield the headers all at once, it's faster
local function send_headers(tosend)
    local canonic = headers.canonic
    local h = "\r\n"
    for f,v in base.pairs(tosend) do
        h = (canonic[f] or f) .. ': ' .. v .. "\r\n" .. h
    end
    coroutine.yield(h)
end

-- yield multipart message body from a multipart message table
local function send_multipart(mesgt)
    -- make sure we have our boundary and send headers
    local bd = newboundary()
    local headers = lower_headers(mesgt.headers or {})
    headers['content-type'] = headers['content-type'] or 'multipart/mixed'
    headers['content-type'] = headers['content-type'] ..
        '; boundary="' ..  bd .. '"'
    send_headers(headers)
    -- send preamble
    if mesgt.body.preamble then
        coroutine.yield(mesgt.body.preamble)
        coroutine.yield("\r\n")
    end
    -- send each part separated by a boundary
    for i, m in base.ipairs(mesgt.body) do
        coroutine.yield("\r\n--" .. bd .. "\r\n")
        send_message(m)
    end
    -- send last boundary
    coroutine.yield("\r\n--" .. bd .. "--\r\n\r\n")
    -- send epilogue
    if mesgt.body.epilogue then
        coroutine.yield(mesgt.body.epilogue)
        coroutine.yield("\r\n")
    end
end

-- yield message body from a source
local function send_source(mesgt)
    -- make sure we have a content-type
    local headers = lower_headers(mesgt.headers or {})
    headers['content-type'] = headers['content-type'] or
        'text/plain; charset="iso-8859-1"'
    send_headers(headers)
    -- send body from source
    while true do
        local chunk, err = mesgt.body()
        if err then coroutine.yield(nil, err)
        elseif chunk then coroutine.yield(chunk)
        else break end
    end
end

-- yield message body from a string
local function send_string(mesgt)
    -- make sure we have a content-type
    local headers = lower_headers(mesgt.headers or {})
    headers['content-type'] = headers['content-type'] or
        'text/plain; charset="iso-8859-1"'
    send_headers(headers)
    -- send body from string
    coroutine.yield(mesgt.body)
end

-- message source
function send_message(mesgt)
    if base.type(mesgt.body) == "table" then send_multipart(mesgt)
    elseif base.type(mesgt.body) == "function" then send_source(mesgt)
    else send_string(mesgt) end
end

-- set defaul headers
local function adjust_headers(mesgt)
    local lower = lower_headers(mesgt.headers)
    lower["date"] = lower["date"] or
        os.date("!%a, %d %b %Y %H:%M:%S ") .. (mesgt.zone or _M.ZONE)
    lower["x-mailer"] = lower["x-mailer"] or socket._VERSION
    -- this can't be overriden
    lower["mime-version"] = "1.0"
    return lower
end

function _M.message(mesgt)
    mesgt.headers = adjust_headers(mesgt)
    -- create and return message source
    local co = coroutine.create(function() send_message(mesgt) end)
    return function()
        local ret, a, b = coroutine.resume(co)
        if ret then return a, b
        else return nil, a end
    end
end

---------------------------------------------------------------------------
-- High level SMTP API
-----------------------------------------------------------------------------
_M.send = socket.protect(function(mailt)
    local s = _M.open(mailt.server, mailt.port, mailt.create)
    local ext = s:greet(mailt.domain)
    s:auth(mailt.user, mailt.password, ext)
    s:send(mailt)
    s:quit()
    return s:close()
end)

return _M
```

`lua/libs/socket/tp.lua`:

```lua
-----------------------------------------------------------------------------
-- Unified SMTP/FTP subsystem
-- LuaSocket toolkit.
-- Author: Diego Nehab
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module and import dependencies
-----------------------------------------------------------------------------
local base = _G
local string = require("string")
local socket = require("socket")
local ltn12 = require("ltn12")

socket.tp = {}
local _M = socket.tp

-----------------------------------------------------------------------------
-- Program constants
-----------------------------------------------------------------------------
_M.TIMEOUT = 60

-----------------------------------------------------------------------------
-- Implementation
-----------------------------------------------------------------------------
-- gets server reply (works for SMTP and FTP)
local function get_reply(c)
    local code, current, sep
    local line, err = c:receive()
    local reply = line
    if err then return nil, err end
    code, sep = socket.skip(2, string.find(line, "^(%d%d%d)(.?)"))
    if not code then return nil, "invalid server reply" end
    if sep == "-" then -- reply is multiline
        repeat
            line, err = c:receive()
            if err then return nil, err end
            current, sep = socket.skip(2, string.find(line, "^(%d%d%d)(.?)"))
            reply = reply .. "\n" .. line
        -- reply ends with same code
        until code == current and sep == " "
    end
    return code, reply
end

-- metatable for sock object
local metat = { __index = {} }

function metat.__index:getpeername()
    return self.c:getpeername()
end

function metat.__index:getsockname()
    return self.c:getpeername()
end

function metat.__index:check(ok)
    local code, reply = get_reply(self.c)
    if not code then return nil, reply end
    if base.type(ok) ~= "function" then
        if base.type(ok) == "table" then
            for i, v in base.ipairs(ok) do
                if string.find(code, v) then
                    return base.tonumber(code), reply
                end
            end
            return nil, reply
        else
            if string.find(code, ok) then return base.tonumber(code), reply
            else return nil, reply end
        end
    else return ok(base.tonumber(code), reply) end
end

function metat.__index:command(cmd, arg)
    cmd = string.upper(cmd)
    if arg then
        return self.c:send(cmd .. " " .. arg.. "\r\n")
    else
        return self.c:send(cmd .. "\r\n")
    end
end

function metat.__index:sink(snk, pat)
    local chunk, err = self.c:receive(pat)
    return snk(chunk, err)
end

function metat.__index:send(data)
    return self.c:send(data)
end

function metat.__index:receive(pat)
    return self.c:receive(pat)
end

function metat.__index:getfd()
    return self.c:getfd()
end

function metat.__index:dirty()
    return self.c:dirty()
end

function metat.__index:getcontrol()
    return self.c
end

function metat.__index:source(source, step)
    local sink = socket.sink("keep-open", self.c)
    local ret, err = ltn12.pump.all(source, sink, step or ltn12.pump.step)
    return ret, err
end

-- closes the underlying c
function metat.__index:close()
    self.c:close()
    return 1
end

-- connect with server and return c object
function _M.connect(host, port, timeout, create)
    local c, e = (create or socket.tcp)()
    if not c then return nil, e end
    c:settimeout(timeout or _M.TIMEOUT)
    local r, e = c:connect(host, port)
    if not r then
        c:close()
        return nil, e
    end
    return base.setmetatable({c = c}, metat)
end

return _M

```

`lua/libs/socket/url.lua`:

```lua
-----------------------------------------------------------------------------
-- URI parsing, composition and relative URL resolution
-- LuaSocket toolkit.
-- Author: Diego Nehab
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module
-----------------------------------------------------------------------------
local string = require("string")
local base = _G
local table = require("table")
local socket = require("socket")

socket.url = {}
local _M = socket.url

-----------------------------------------------------------------------------
-- Module version
-----------------------------------------------------------------------------
_M._VERSION = "URL 1.0.3"

-----------------------------------------------------------------------------
-- Encodes a string into its escaped hexadecimal representation
-- Input
--   s: binary string to be encoded
-- Returns
--   escaped representation of string binary
-----------------------------------------------------------------------------
function _M.escape(s)
    return (string.gsub(s, "([^A-Za-z0-9_])", function(c)
        return string.format("%%%02x", string.byte(c))
    end))
end

-----------------------------------------------------------------------------
-- Protects a path segment, to prevent it from interfering with the
-- url parsing.
-- Input
--   s: binary string to be encoded
-- Returns
--   escaped representation of string binary
-----------------------------------------------------------------------------
local function make_set(t)
    local s = {}
    for i,v in base.ipairs(t) do
        s[t[i]] = 1
    end
    return s
end

-- these are allowed within a path segment, along with alphanum
-- other characters must be escaped
local segment_set = make_set {
    "-", "_", ".", "!", "~", "*", "'", "(",
    ")", ":", "@", "&", "=", "+", "$", ",",
}

local function protect_segment(s)
    return string.gsub(s, "([^A-Za-z0-9_])", function (c)
        if segment_set[c] then return c
        else return string.format("%%%02X", string.byte(c)) end
    end)
end

-----------------------------------------------------------------------------
-- Unencodes a escaped hexadecimal string into its binary representation
-- Input
--   s: escaped hexadecimal string to be unencoded
-- Returns
--   unescaped binary representation of escaped hexadecimal  binary
-----------------------------------------------------------------------------
function _M.unescape(s)
    return (string.gsub(s, "%%(%x%x)", function(hex)
        return string.char(base.tonumber(hex, 16))
    end))
end

-----------------------------------------------------------------------------
-- Removes '..' and '.' components appropriately from a path.
-- Input
--   path
-- Returns
--   dot-normalized path
local function remove_dot_components(path)
    local marker = string.char(1)
    repeat
        local was = path
        path = path:gsub('//', '/'..marker..'/', 1)
    until path == was
    repeat
        local was = path
        path = path:gsub('/%./', '/', 1)
    until path == was
    repeat
        local was = path
        path = path:gsub('[^/]+/%.%./([^/]+)', '%1', 1)
    until path == was
    path = path:gsub('[^/]+/%.%./*$', '')
    path = path:gsub('/%.%.$', '/')
    path = path:gsub('/%.$', '/')
    path = path:gsub('^/%.%./', '/')
    path = path:gsub(marker, '')
    return path
end

-----------------------------------------------------------------------------
-- Builds a path from a base path and a relative path
-- Input
--   base_path
--   relative_path
-- Returns
--   corresponding absolute path
-----------------------------------------------------------------------------
local function absolute_path(base_path, relative_path)
    if string.sub(relative_path, 1, 1) == "/" then
      return remove_dot_components(relative_path) end
    base_path = base_path:gsub("[^/]*$", "")
    if not base_path:find'/$' then base_path = base_path .. '/' end
    local path = base_path .. relative_path
    path = remove_dot_components(path)
    return path
end

-----------------------------------------------------------------------------
-- Parses a url and returns a table with all its parts according to RFC 2396
-- The following grammar describes the names given to the URL parts
-- <url> ::= <scheme>://<authority>/<path>;<params>?<query>#<fragment>
-- <authority> ::= <userinfo>@<host>:<port>
-- <userinfo> ::= <user>[:<password>]
-- <path> :: = {<segment>/}<segment>
-- Input
--   url: uniform resource locator of request
--   default: table with default values for each field
-- Returns
--   table with the following fields, where RFC naming conventions have
--   been preserved:
--     scheme, authority, userinfo, user, password, host, port,
--     path, params, query, fragment
-- Obs:
--   the leading '/' in {/<path>} is considered part of <path>
-----------------------------------------------------------------------------
function _M.parse(url, default)
    -- initialize default parameters
    local parsed = {}
    for i,v in base.pairs(default or parsed) do parsed[i] = v end
    -- empty url is parsed to nil
    if not url or url == "" then return nil, "invalid url" end
    -- remove whitespace
    -- url = string.gsub(url, "%s", "")
    -- get scheme
    url = string.gsub(url, "^([%w][%w%+%-%.]*)%:",
        function(s) parsed.scheme = s; return "" end)
    -- get authority
    url = string.gsub(url, "^//([^/]*)", function(n)
        parsed.authority = n
        return ""
    end)
    -- get fragment
    url = string.gsub(url, "#(.*)$", function(f)
        parsed.fragment = f
        return ""
    end)
    -- get query string
    url = string.gsub(url, "%?(.*)", function(q)
        parsed.query = q
        return ""
    end)
    -- get params
    url = string.gsub(url, "%;(.*)", function(p)
        parsed.params = p
        return ""
    end)
    -- path is whatever was left
    if url ~= "" then parsed.path = url end
    local authority = parsed.authority
    if not authority then return parsed end
    authority = string.gsub(authority,"^([^@]*)@",
        function(u) parsed.userinfo = u; return "" end)
    authority = string.gsub(authority, ":([^:%]]*)$",
        function(p) parsed.port = p; return "" end)
    if authority ~= "" then 
        -- IPv6?
        parsed.host = string.match(authority, "^%[(.+)%]$") or authority 
    end
    local userinfo = parsed.userinfo
    if not userinfo then return parsed end
    userinfo = string.gsub(userinfo, ":([^:]*)$",
        function(p) parsed.password = p; return "" end)
    parsed.user = userinfo
    return parsed
end

-----------------------------------------------------------------------------
-- Rebuilds a parsed URL from its components.
-- Components are protected if any reserved or unallowed characters are found
-- Input
--   parsed: parsed URL, as returned by parse
-- Returns
--   a stringing with the corresponding URL
-----------------------------------------------------------------------------
function _M.build(parsed)
    --local ppath = _M.parse_path(parsed.path or "")
    --local url = _M.build_path(ppath)
    local url = parsed.path or ""
    if parsed.params then url = url .. ";" .. parsed.params end
    if parsed.query then url = url .. "?" .. parsed.query end
    local authority = parsed.authority
    if parsed.host then
        authority = parsed.host
        if string.find(authority, ":") then -- IPv6?
            authority = "[" .. authority .. "]"
        end
        if parsed.port then authority = authority .. ":" .. base.tostring(parsed.port) end
        local userinfo = parsed.userinfo
        if parsed.user then
            userinfo = parsed.user
            if parsed.password then
                userinfo = userinfo .. ":" .. parsed.password
            end
        end
        if userinfo then authority = userinfo .. "@" .. authority end
    end
    if authority then url = "//" .. authority .. url end
    if parsed.scheme then url = parsed.scheme .. ":" .. url end
    if parsed.fragment then url = url .. "#" .. parsed.fragment end
    -- url = string.gsub(url, "%s", "")
    return url
end

-----------------------------------------------------------------------------
-- Builds a absolute URL from a base and a relative URL according to RFC 2396
-- Input
--   base_url
--   relative_url
-- Returns
--   corresponding absolute url
-----------------------------------------------------------------------------
function _M.absolute(base_url, relative_url)
    local base_parsed
    if base.type(base_url) == "table" then
        base_parsed = base_url
        base_url = _M.build(base_parsed)
    else
        base_parsed = _M.parse(base_url)
    end
    local result
    local relative_parsed = _M.parse(relative_url)
    if not base_parsed then
        result = relative_url
    elseif not relative_parsed then
        result = base_url
    elseif relative_parsed.scheme then
        result = relative_url
    else
        relative_parsed.scheme = base_parsed.scheme
        if not relative_parsed.authority then
            relative_parsed.authority = base_parsed.authority
            if not relative_parsed.path then
                relative_parsed.path = base_parsed.path
                if not relative_parsed.params then
                    relative_parsed.params = base_parsed.params
                    if not relative_parsed.query then
                        relative_parsed.query = base_parsed.query
                    end
                end
            else    
                relative_parsed.path = absolute_path(base_parsed.path or "",
                    relative_parsed.path)
            end
        end
        result = _M.build(relative_parsed)
    end
    return remove_dot_components(result)
end

-----------------------------------------------------------------------------
-- Breaks a path into its segments, unescaping the segments
-- Input
--   path
-- Returns
--   segment: a table with one entry per segment
-----------------------------------------------------------------------------
function _M.parse_path(path)
    local parsed = {}
    path = path or ""
    --path = string.gsub(path, "%s", "")
    string.gsub(path, "([^/]+)", function (s) table.insert(parsed, s) end)
    for i = 1, #parsed do
        parsed[i] = _M.unescape(parsed[i])
    end
    if string.sub(path, 1, 1) == "/" then parsed.is_absolute = 1 end
    if string.sub(path, -1, -1) == "/" then parsed.is_directory = 1 end
    return parsed
end

-----------------------------------------------------------------------------
-- Builds a path component from its segments, escaping protected characters.
-- Input
--   parsed: path segments
--   unsafe: if true, segments are not protected before path is built
-- Returns
--   path: corresponding path stringing
-----------------------------------------------------------------------------
function _M.build_path(parsed, unsafe)
    local path = ""
    local n = #parsed
    if unsafe then
        for i = 1, n-1 do
            path = path .. parsed[i]
            path = path .. "/"
        end
        if n > 0 then
            path = path .. parsed[n]
            if parsed.is_directory then path = path .. "/" end
        end
    else
        for i = 1, n-1 do
            path = path .. protect_segment(parsed[i])
            path = path .. "/"
        end
        if n > 0 then
            path = path .. protect_segment(parsed[n])
            if parsed.is_directory then path = path .. "/" end
        end
    end
    if parsed.is_absolute then path = "/" .. path end
    return path
end

return _M

```

`src/Lua/Lua.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="bit\bit.c" />
    <ClCompile Include="lapi.c" />
    <ClCompile Include="lauxlib.c" />
    <ClCompile Include="lbaselib.c" />
    <ClCompile Include="lbitlib.c" />
    <ClCompile Include="lcode.c" />
    <ClCompile Include="lcorolib.c" />
    <ClCompile Include="lctype.c" />
    <ClCompile Include="ldblib.c" />
    <ClCompile Include="ldebug.c" />
    <ClCompile Include="ldo.c" />
    <ClCompile Include="ldump.c" />
    <ClCompile Include="lfunc.c" />
    <ClCompile Include="lgc.c" />
    <ClCompile Include="linit.c" />
    <ClCompile Include="liolib.c" />
    <ClCompile Include="llex.c" />
    <ClCompile Include="lmathlib.c" />
    <ClCompile Include="lmem.c" />
    <ClCompile Include="loadlib.c" />
    <ClCompile Include="lobject.c" />
    <ClCompile Include="lopcodes.c" />
    <ClCompile Include="loslib.c" />
    <ClCompile Include="lparser.c" />
    <ClCompile Include="lstate.c" />
    <ClCompile Include="lstring.c" />
    <ClCompile Include="lstrlib.c" />
    <ClCompile Include="ltable.c" />
    <ClCompile Include="ltablib.c" />
    <ClCompile Include="ltm.c" />
    <ClCompile Include="lundump.c" />
    <ClCompile Include="lutf8lib.c" />
    <ClCompile Include="lvm.c" />
    <ClCompile Include="lzio.c" />
    <ClCompile Include="socket\auxiliar.c" />
    <ClCompile Include="socket\buffer.c" />
    <ClCompile Include="socket\compat.c" />
    <ClCompile Include="socket\except.c" />
    <ClCompile Include="socket\inet.c" />
    <ClCompile Include="socket\io.c" />
    <ClCompile Include="socket\luasocket.c" />
    <ClCompile Include="socket\mime.c" />
    <ClCompile Include="socket\options.c" />
    <ClCompile Include="socket\select.c" />
    <ClCompile Include="socket\tcp.c" />
    <ClCompile Include="socket\timeout.c" />
    <ClCompile Include="socket\udp.c" />
    <ClCompile Include="socket\wsocket.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lapi.h" />
    <ClInclude Include="lauxlib.h" />
    <ClInclude Include="lcode.h" />
    <ClInclude Include="lctype.h" />
    <ClInclude Include="ldebug.h" />
    <ClInclude Include="ldo.h" />
    <ClInclude Include="lfunc.h" />
    <ClInclude Include="lgc.h" />
    <ClInclude Include="llex.h" />
    <ClInclude Include="llimits.h" />
    <ClInclude Include="lmem.h" />
    <ClInclude Include="lobject.h" />
    <ClInclude Include="lopcodes.h" />
    <ClInclude Include="lparser.h" />
    <ClInclude Include="lprefix.h" />
    <ClInclude Include="lstate.h" />
    <ClInclude Include="lstring.h" />
    <ClInclude Include="ltable.h" />
    <ClInclude Include="ltm.h" />
    <ClInclude Include="lua.h" />
    <ClInclude Include="lua.hpp" />
    <ClInclude Include="luaconf.h" />
    <ClInclude Include="lualib.h" />
    <ClInclude Include="lundump.h" />
    <ClInclude Include="lvm.h" />
    <ClInclude Include="lzio.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{6166F81A-7E2E-42D1-B552-9C8763E0A884}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Lua</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)Libs\Lua\x64d\</OutDir>
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)Libs\Lua\x86d\</OutDir>
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)Libs\Lua\x86\</OutDir>
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)Libs\Lua\x64\</OutDir>
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <AdditionalDependencies>ws2_32.lib</AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <AdditionalDependencies>ws2_32.lib</AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <AdditionalDependencies>ws2_32.lib</AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <AdditionalDependencies>ws2_32.lib</AdditionalDependencies>
    </Lib>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/Lua/Lua.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{847fa3ad-8af0-417c-a838-937c5a5edff5}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\socket">
      <UniqueIdentifier>{64a30219-5056-437b-a421-01cc3c7c6344}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\bit">
      <UniqueIdentifier>{11071c71-c603-47fc-bdfb-da87cfa9c781}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="lapi.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lauxlib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lbaselib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lbitlib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lcode.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lcorolib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lctype.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="ldblib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="ldebug.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="ldo.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="ldump.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lfunc.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lgc.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="linit.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="liolib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="llex.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lmathlib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lmem.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="loadlib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lobject.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lopcodes.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="loslib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lparser.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lstate.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lstring.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lstrlib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="ltable.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="ltablib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="ltm.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lundump.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lutf8lib.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lvm.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="lzio.c">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="socket\auxiliar.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\buffer.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\compat.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\except.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\inet.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\io.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\luasocket.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\mime.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\options.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\select.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\tcp.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\timeout.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\udp.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="socket\wsocket.c">
      <Filter>src\socket</Filter>
    </ClCompile>
    <ClCompile Include="bit\bit.c">
      <Filter>src\bit</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lapi.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lauxlib.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lcode.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lctype.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="ldebug.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="ldo.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lfunc.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lgc.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="llex.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="llimits.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lmem.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lobject.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lopcodes.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lparser.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lprefix.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lstate.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lstring.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="ltable.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="ltm.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lua.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lua.hpp">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="luaconf.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lualib.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lundump.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lvm.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="lzio.h">
      <Filter>src</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/Lua/bit/bit.c`:

```c
/*
** Lua BitOp -- a bit operations library for Lua 5.1/5.2.
** http://bitop.luajit.org/
**
** Copyright (C) 2008-2012 Mike Pall. All rights reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining
** a copy of this software and associated documentation files (the
** "Software"), to deal in the Software without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Software, and to
** permit persons to whom the Software is furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be
** included in all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**
** [ MIT license: http://www.opensource.org/licenses/mit-license.php ]
*/

#define LUA_BITOP_VERSION	"1.0.3"

#define LUA_LIB
#include "lua.h"
#include "lauxlib.h"

#ifdef _MSC_VER
/* MSVC is stuck in the last century and doesn't have C99's stdint.h. */
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

typedef int32_t SBits;
typedef uint32_t UBits;

typedef union {
  lua_Number n;
#if defined(LUA_NUMBER_DOUBLE) || defined(LUA_FLOAT_DOUBLE)
  uint64_t b;
#else
  UBits b;
#endif
} BitNum;

/* Convert argument to bit type. */
static UBits barg(lua_State *L, int idx)
{
  BitNum bn;
  UBits b;
#if LUA_VERSION_NUM < 502
  bn.n = lua_tonumber(L, idx);
#else
  bn.n = luaL_checknumber(L, idx);
#endif
#if defined(LUA_NUMBER_DOUBLE) || defined(LUA_FLOAT_DOUBLE)
  bn.n += 6755399441055744.0;  /* 2^52+2^51 */
#ifdef SWAPPED_DOUBLE
  b = (UBits)(bn.b >> 32);
#else
  b = (UBits)bn.b;
#endif
#elif defined(LUA_NUMBER_INT)       || defined(LUA_INT_INT) || \
      defined(LUA_NUMBER_LONG)      || defined(LUA_INT_LONG) || \
      defined(LUA_NUMBER_LONGLONG)  || defined(LUA_INT_LONGLONG) || \
      defined(LUA_NUMBER_LONG_LONG) || defined(LUA_NUMBER_LLONG)
  if (sizeof(UBits) == sizeof(lua_Number))
    b = bn.b;
  else
    b = (UBits)(SBits)bn.n;
#elif defined(LUA_NUMBER_FLOAT) || defined(LUA_FLOAT_FLOAT)
#error "A 'float' lua_Number type is incompatible with this library"
#else
#error "Unknown number type, check LUA_NUMBER_*, LUA_FLOAT_*, LUA_INT_* in luaconf.h"
#endif
#if LUA_VERSION_NUM < 502
  if (b == 0 && !lua_isnumber(L, idx)) {
    luaL_typerror(L, idx, "number");
  }
#endif
  return b;
}

/* Return bit type. */
#if LUA_VERSION_NUM < 503
#define BRET(b)  lua_pushnumber(L, (lua_Number)(SBits)(b)); return 1;
#else
#define BRET(b)  lua_pushinteger(L, (lua_Integer)(SBits)(b)); return 1;
#endif

static int bit_tobit(lua_State *L) { BRET(barg(L, 1)) }
static int bit_bnot(lua_State *L) { BRET(~barg(L, 1)) }

#define BIT_OP(func, opr) \
  static int func(lua_State *L) { int i; UBits b = barg(L, 1); \
    for (i = lua_gettop(L); i > 1; i--) b opr barg(L, i); BRET(b) }
BIT_OP(bit_band, &=)
BIT_OP(bit_bor, |=)
BIT_OP(bit_bxor, ^=)

#define bshl(b, n)  (b << n)
#define bshr(b, n)  (b >> n)
#define bsar(b, n)  ((SBits)b >> n)
#define brol(b, n)  ((b << n) | (b >> (32-n)))
#define bror(b, n)  ((b << (32-n)) | (b >> n))
#define BIT_SH(func, fn) \
  static int func(lua_State *L) { \
    UBits b = barg(L, 1); UBits n = barg(L, 2) & 31; BRET(fn(b, n)) }
BIT_SH(bit_lshift, bshl)
BIT_SH(bit_rshift, bshr)
BIT_SH(bit_arshift, bsar)
BIT_SH(bit_rol, brol)
BIT_SH(bit_ror, bror)

static int bit_bswap(lua_State *L)
{
  UBits b = barg(L, 1);
  b = (b >> 24) | ((b >> 8) & 0xff00) | ((b & 0xff00) << 8) | (b << 24);
  BRET(b)
}

static int bit_tohex(lua_State *L)
{
  UBits b = barg(L, 1);
  SBits n = lua_isnone(L, 2) ? 8 : (SBits)barg(L, 2);
  const char *hexdigits = "0123456789abcdef";
  char buf[8];
  int i;
  if (n < 0) { n = -n; hexdigits = "0123456789ABCDEF"; }
  if (n > 8) n = 8;
  for (i = (int)n; --i >= 0; ) { buf[i] = hexdigits[b & 15]; b >>= 4; }
  lua_pushlstring(L, buf, (size_t)n);
  return 1;
}

static const struct luaL_Reg bit_funcs[] = {
  { "tobit",	bit_tobit },
  { "bnot",	bit_bnot },
  { "band",	bit_band },
  { "bor",	bit_bor },
  { "bxor",	bit_bxor },
  { "lshift",	bit_lshift },
  { "rshift",	bit_rshift },
  { "arshift",	bit_arshift },
  { "rol",	bit_rol },
  { "ror",	bit_ror },
  { "bswap",	bit_bswap },
  { "tohex",	bit_tohex },
  { NULL, NULL }
};

/* Signed right-shifts are implementation-defined per C89/C99.
** But the de facto standard are arithmetic right-shifts on two's
** complement CPUs. This behaviour is required here, so test for it.
*/
#define BAD_SAR		(bsar(-8, 2) != (SBits)-2)

LUALIB_API int luaopen_bit(lua_State *L)
{
  UBits b;
#if LUA_VERSION_NUM < 503
  lua_pushnumber(L, (lua_Number)1437217655L);
#else
  lua_pushinteger(L, (lua_Integer)1437217655L);
#endif
  b = barg(L, -1);
  if (b != (UBits)1437217655L || BAD_SAR) {  /* Perform a simple self-test. */
    const char *msg = "compiled with incompatible luaconf.h";
#if defined(LUA_NUMBER_DOUBLE) || defined(LUA_FLOAT_DOUBLE)
#ifdef _WIN32
    if (b == (UBits)1610612736L)
      msg = "use D3DCREATE_FPU_PRESERVE with DirectX";
#endif
    if (b == (UBits)1127743488L)
      msg = "not compiled with SWAPPED_DOUBLE";
#endif
    if (BAD_SAR)
      msg = "arithmetic right-shift broken";
    luaL_error(L, "bit library self-test failed (%s)", msg);
  }
#if LUA_VERSION_NUM < 502
  luaL_register(L, "bit", bit_funcs);
#else
  luaL_newlib(L, bit_funcs);
#endif
  return 1;
}


```

`src/Lua/lapi.c`:

```c
/*
** $Id: lapi.c,v 2.259 2016/02/29 14:27:14 roberto Exp $
** Lua API
** See Copyright Notice in lua.h
*/

#define lapi_c
#define LUA_CORE

#include "lprefix.h"


#include <stdarg.h>
#include <string.h>

#include "lua.h"

#include "lapi.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lgc.h"
#include "lmem.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"
#include "lundump.h"
#include "lvm.h"



const char lua_ident[] =
  "$LuaVersion: " LUA_COPYRIGHT " $"
  "$LuaAuthors: " LUA_AUTHORS " $";


/* value at a non-valid index */
#define NONVALIDVALUE		cast(TValue *, luaO_nilobject)

/* corresponding test */
#define isvalid(o)	((o) != luaO_nilobject)

/* test for pseudo index */
#define ispseudo(i)		((i) <= LUA_REGISTRYINDEX)

/* test for upvalue */
#define isupvalue(i)		((i) < LUA_REGISTRYINDEX)

/* test for valid but not pseudo index */
#define isstackindex(i, o)	(isvalid(o) && !ispseudo(i))

#define api_checkvalidindex(l,o)  api_check(l, isvalid(o), "invalid index")

#define api_checkstackindex(l, i, o)  \
	api_check(l, isstackindex(i, o), "index not in the stack")


static TValue *index2addr (lua_State *L, int idx) {
  CallInfo *ci = L->ci;
  if (idx > 0) {
    TValue *o = ci->func + idx;
    api_check(L, idx <= ci->top - (ci->func + 1), "unacceptable index");
    if (o >= L->top) return NONVALIDVALUE;
    else return o;
  }
  else if (!ispseudo(idx)) {  /* negative index */
    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
    return L->top + idx;
  }
  else if (idx == LUA_REGISTRYINDEX)
    return &G(L)->l_registry;
  else {  /* upvalues */
    idx = LUA_REGISTRYINDEX - idx;
    api_check(L, idx <= MAXUPVAL + 1, "upvalue index too large");
    if (ttislcf(ci->func))  /* light C function? */
      return NONVALIDVALUE;  /* it has no upvalues */
    else {
      CClosure *func = clCvalue(ci->func);
      return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;
    }
  }
}


/*
** to be called by 'lua_checkstack' in protected mode, to grow stack
** capturing memory errors
*/
static void growstack (lua_State *L, void *ud) {
  int size = *(int *)ud;
  luaD_growstack(L, size);
}


LUA_API int lua_checkstack (lua_State *L, int n) {
  int res;
  CallInfo *ci = L->ci;
  lua_lock(L);
  api_check(L, n >= 0, "negative 'n'");
  if (L->stack_last - L->top > n)  /* stack large enough? */
    res = 1;  /* yes; check is OK */
  else {  /* no; need to grow stack */
    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;
    if (inuse > LUAI_MAXSTACK - n)  /* can grow without overflow? */
      res = 0;  /* no */
    else  /* try to grow stack */
      res = (luaD_rawrunprotected(L, &growstack, &n) == LUA_OK);
  }
  if (res && ci->top < L->top + n)
    ci->top = L->top + n;  /* adjust frame top */
  lua_unlock(L);
  return res;
}


LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
  int i;
  if (from == to) return;
  lua_lock(to);
  api_checknelems(from, n);
  api_check(from, G(from) == G(to), "moving among independent states");
  api_check(from, to->ci->top - to->top >= n, "stack overflow");
  from->top -= n;
  for (i = 0; i < n; i++) {
    setobj2s(to, to->top, from->top + i);
    to->top++;  /* stack already checked by previous 'api_check' */
  }
  lua_unlock(to);
}


LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
  lua_CFunction old;
  lua_lock(L);
  old = G(L)->panic;
  G(L)->panic = panicf;
  lua_unlock(L);
  return old;
}


LUA_API const lua_Number *lua_version (lua_State *L) {
  static const lua_Number version = LUA_VERSION_NUM;
  if (L == NULL) return &version;
  else return G(L)->version;
}



/*
** basic stack manipulation
*/


/*
** convert an acceptable stack index into an absolute index
*/
LUA_API int lua_absindex (lua_State *L, int idx) {
  return (idx > 0 || ispseudo(idx))
         ? idx
         : cast_int(L->top - L->ci->func) + idx;
}


LUA_API int lua_gettop (lua_State *L) {
  return cast_int(L->top - (L->ci->func + 1));
}


LUA_API void lua_settop (lua_State *L, int idx) {
  StkId func = L->ci->func;
  lua_lock(L);
  if (idx >= 0) {
    api_check(L, idx <= L->stack_last - (func + 1), "new top too large");
    while (L->top < (func + 1) + idx)
      setnilvalue(L->top++);
    L->top = (func + 1) + idx;
  }
  else {
    api_check(L, -(idx+1) <= (L->top - (func + 1)), "invalid new top");
    L->top += idx+1;  /* 'subtract' index (index is negative) */
  }
  lua_unlock(L);
}


/*
** Reverse the stack segment from 'from' to 'to'
** (auxiliary to 'lua_rotate')
*/
static void reverse (lua_State *L, StkId from, StkId to) {
  for (; from < to; from++, to--) {
    TValue temp;
    setobj(L, &temp, from);
    setobjs2s(L, from, to);
    setobj2s(L, to, &temp);
  }
}


/*
** Let x = AB, where A is a prefix of length 'n'. Then,
** rotate x n == BA. But BA == (A^r . B^r)^r.
*/
LUA_API void lua_rotate (lua_State *L, int idx, int n) {
  StkId p, t, m;
  lua_lock(L);
  t = L->top - 1;  /* end of stack segment being rotated */
  p = index2addr(L, idx);  /* start of segment */
  api_checkstackindex(L, idx, p);
  api_check(L, (n >= 0 ? n : -n) <= (t - p + 1), "invalid 'n'");
  m = (n >= 0 ? t - n : p - n - 1);  /* end of prefix */
  reverse(L, p, m);  /* reverse the prefix with length 'n' */
  reverse(L, m + 1, t);  /* reverse the suffix */
  reverse(L, p, t);  /* reverse the entire segment */
  lua_unlock(L);
}


LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
  TValue *fr, *to;
  lua_lock(L);
  fr = index2addr(L, fromidx);
  to = index2addr(L, toidx);
  api_checkvalidindex(L, to);
  setobj(L, to, fr);
  if (isupvalue(toidx))  /* function upvalue? */
    luaC_barrier(L, clCvalue(L->ci->func), fr);
  /* LUA_REGISTRYINDEX does not need gc barrier
     (collector revisits it before finishing collection) */
  lua_unlock(L);
}


LUA_API void lua_pushvalue (lua_State *L, int idx) {
  lua_lock(L);
  setobj2s(L, L->top, index2addr(L, idx));
  api_incr_top(L);
  lua_unlock(L);
}



/*
** access functions (stack -> C)
*/


LUA_API int lua_type (lua_State *L, int idx) {
  StkId o = index2addr(L, idx);
  return (isvalid(o) ? ttnov(o) : LUA_TNONE);
}


LUA_API const char *lua_typename (lua_State *L, int t) {
  UNUSED(L);
  api_check(L, LUA_TNONE <= t && t < LUA_NUMTAGS, "invalid tag");
  return ttypename(t);
}


LUA_API int lua_iscfunction (lua_State *L, int idx) {
  StkId o = index2addr(L, idx);
  return (ttislcf(o) || (ttisCclosure(o)));
}


LUA_API int lua_isinteger (lua_State *L, int idx) {
  StkId o = index2addr(L, idx);
  return ttisinteger(o);
}


LUA_API int lua_isnumber (lua_State *L, int idx) {
  lua_Number n;
  const TValue *o = index2addr(L, idx);
  return tonumber(o, &n);
}


LUA_API int lua_isstring (lua_State *L, int idx) {
  const TValue *o = index2addr(L, idx);
  return (ttisstring(o) || cvt2str(o));
}


LUA_API int lua_isuserdata (lua_State *L, int idx) {
  const TValue *o = index2addr(L, idx);
  return (ttisfulluserdata(o) || ttislightuserdata(o));
}


LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
  StkId o1 = index2addr(L, index1);
  StkId o2 = index2addr(L, index2);
  return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;
}


LUA_API void lua_arith (lua_State *L, int op) {
  lua_lock(L);
  if (op != LUA_OPUNM && op != LUA_OPBNOT)
    api_checknelems(L, 2);  /* all other operations expect two operands */
  else {  /* for unary operations, add fake 2nd operand */
    api_checknelems(L, 1);
    setobjs2s(L, L->top, L->top - 1);
    api_incr_top(L);
  }
  /* first operand at top - 2, second at top - 1; result go to top - 2 */
  luaO_arith(L, op, L->top - 2, L->top - 1, L->top - 2);
  L->top--;  /* remove second operand */
  lua_unlock(L);
}


LUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {
  StkId o1, o2;
  int i = 0;
  lua_lock(L);  /* may call tag method */
  o1 = index2addr(L, index1);
  o2 = index2addr(L, index2);
  if (isvalid(o1) && isvalid(o2)) {
    switch (op) {
      case LUA_OPEQ: i = luaV_equalobj(L, o1, o2); break;
      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;
      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;
      default: api_check(L, 0, "invalid option");
    }
  }
  lua_unlock(L);
  return i;
}


LUA_API size_t lua_stringtonumber (lua_State *L, const char *s) {
  size_t sz = luaO_str2num(s, L->top);
  if (sz != 0)
    api_incr_top(L);
  return sz;
}


LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *pisnum) {
  lua_Number n;
  const TValue *o = index2addr(L, idx);
  int isnum = tonumber(o, &n);
  if (!isnum)
    n = 0;  /* call to 'tonumber' may change 'n' even if it fails */
  if (pisnum) *pisnum = isnum;
  return n;
}


LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) {
  lua_Integer res;
  const TValue *o = index2addr(L, idx);
  int isnum = tointeger(o, &res);
  if (!isnum)
    res = 0;  /* call to 'tointeger' may change 'n' even if it fails */
  if (pisnum) *pisnum = isnum;
  return res;
}


LUA_API int lua_toboolean (lua_State *L, int idx) {
  const TValue *o = index2addr(L, idx);
  return !l_isfalse(o);
}


LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
  StkId o = index2addr(L, idx);
  if (!ttisstring(o)) {
    if (!cvt2str(o)) {  /* not convertible? */
      if (len != NULL) *len = 0;
      return NULL;
    }
    lua_lock(L);  /* 'luaO_tostring' may create a new string */
    luaO_tostring(L, o);
    luaC_checkGC(L);
    o = index2addr(L, idx);  /* previous call may reallocate the stack */
    lua_unlock(L);
  }
  if (len != NULL)
    *len = vslen(o);
  return svalue(o);
}


LUA_API size_t lua_rawlen (lua_State *L, int idx) {
  StkId o = index2addr(L, idx);
  switch (ttype(o)) {
    case LUA_TSHRSTR: return tsvalue(o)->shrlen;
    case LUA_TLNGSTR: return tsvalue(o)->u.lnglen;
    case LUA_TUSERDATA: return uvalue(o)->len;
    case LUA_TTABLE: return luaH_getn(hvalue(o));
    default: return 0;
  }
}


LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
  StkId o = index2addr(L, idx);
  if (ttislcf(o)) return fvalue(o);
  else if (ttisCclosure(o))
    return clCvalue(o)->f;
  else return NULL;  /* not a C function */
}


LUA_API void *lua_touserdata (lua_State *L, int idx) {
  StkId o = index2addr(L, idx);
  switch (ttnov(o)) {
    case LUA_TUSERDATA: return getudatamem(uvalue(o));
    case LUA_TLIGHTUSERDATA: return pvalue(o);
    default: return NULL;
  }
}


LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
  StkId o = index2addr(L, idx);
  return (!ttisthread(o)) ? NULL : thvalue(o);
}


LUA_API const void *lua_topointer (lua_State *L, int idx) {
  StkId o = index2addr(L, idx);
  switch (ttype(o)) {
    case LUA_TTABLE: return hvalue(o);
    case LUA_TLCL: return clLvalue(o);
    case LUA_TCCL: return clCvalue(o);
    case LUA_TLCF: return cast(void *, cast(size_t, fvalue(o)));
    case LUA_TTHREAD: return thvalue(o);
    case LUA_TUSERDATA: return getudatamem(uvalue(o));
    case LUA_TLIGHTUSERDATA: return pvalue(o);
    default: return NULL;
  }
}



/*
** push functions (C -> stack)
*/


LUA_API void lua_pushnil (lua_State *L) {
  lua_lock(L);
  setnilvalue(L->top);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
  lua_lock(L);
  setfltvalue(L->top, n);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
  lua_lock(L);
  setivalue(L->top, n);
  api_incr_top(L);
  lua_unlock(L);
}


/*
** Pushes on the stack a string with given length. Avoid using 's' when
** 'len' == 0 (as 's' can be NULL in that case), due to later use of
** 'memcmp' and 'memcpy'.
*/
LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {
  TString *ts;
  lua_lock(L);
  ts = (len == 0) ? luaS_new(L, "") : luaS_newlstr(L, s, len);
  setsvalue2s(L, L->top, ts);
  api_incr_top(L);
  luaC_checkGC(L);
  lua_unlock(L);
  return getstr(ts);
}


LUA_API const char *lua_pushstring (lua_State *L, const char *s) {
  lua_lock(L);
  if (s == NULL)
    setnilvalue(L->top);
  else {
    TString *ts;
    ts = luaS_new(L, s);
    setsvalue2s(L, L->top, ts);
    s = getstr(ts);  /* internal copy's address */
  }
  api_incr_top(L);
  luaC_checkGC(L);
  lua_unlock(L);
  return s;
}


LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
                                      va_list argp) {
  const char *ret;
  lua_lock(L);
  ret = luaO_pushvfstring(L, fmt, argp);
  luaC_checkGC(L);
  lua_unlock(L);
  return ret;
}


LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
  const char *ret;
  va_list argp;
  lua_lock(L);
  va_start(argp, fmt);
  ret = luaO_pushvfstring(L, fmt, argp);
  va_end(argp);
  luaC_checkGC(L);
  lua_unlock(L);
  return ret;
}


LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
  lua_lock(L);
  if (n == 0) {
    setfvalue(L->top, fn);
  }
  else {
    CClosure *cl;
    api_checknelems(L, n);
    api_check(L, n <= MAXUPVAL, "upvalue index too large");
    cl = luaF_newCclosure(L, n);
    cl->f = fn;
    L->top -= n;
    while (n--) {
      setobj2n(L, &cl->upvalue[n], L->top + n);
      /* does not need barrier because closure is white */
    }
    setclCvalue(L, L->top, cl);
  }
  api_incr_top(L);
  luaC_checkGC(L);
  lua_unlock(L);
}


LUA_API void lua_pushboolean (lua_State *L, int b) {
  lua_lock(L);
  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
  lua_lock(L);
  setpvalue(L->top, p);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API int lua_pushthread (lua_State *L) {
  lua_lock(L);
  setthvalue(L, L->top, L);
  api_incr_top(L);
  lua_unlock(L);
  return (G(L)->mainthread == L);
}



/*
** get functions (Lua -> stack)
*/


static int auxgetstr (lua_State *L, const TValue *t, const char *k) {
  const TValue *slot;
  TString *str = luaS_new(L, k);
  if (luaV_fastget(L, t, str, slot, luaH_getstr)) {
    setobj2s(L, L->top, slot);
    api_incr_top(L);
  }
  else {
    setsvalue2s(L, L->top, str);
    api_incr_top(L);
    luaV_finishget(L, t, L->top - 1, L->top - 1, slot);
  }
  lua_unlock(L);
  return ttnov(L->top - 1);
}


LUA_API int lua_getglobal (lua_State *L, const char *name) {
  Table *reg = hvalue(&G(L)->l_registry);
  lua_lock(L);
  return auxgetstr(L, luaH_getint(reg, LUA_RIDX_GLOBALS), name);
}


LUA_API int lua_gettable (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  t = index2addr(L, idx);
  luaV_gettable(L, t, L->top - 1, L->top - 1);
  lua_unlock(L);
  return ttnov(L->top - 1);
}


LUA_API int lua_getfield (lua_State *L, int idx, const char *k) {
  lua_lock(L);
  return auxgetstr(L, index2addr(L, idx), k);
}


LUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {
  StkId t;
  const TValue *slot;
  lua_lock(L);
  t = index2addr(L, idx);
  if (luaV_fastget(L, t, n, slot, luaH_getint)) {
    setobj2s(L, L->top, slot);
    api_incr_top(L);
  }
  else {
    setivalue(L->top, n);
    api_incr_top(L);
    luaV_finishget(L, t, L->top - 1, L->top - 1, slot);
  }
  lua_unlock(L);
  return ttnov(L->top - 1);
}


LUA_API int lua_rawget (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  t = index2addr(L, idx);
  api_check(L, ttistable(t), "table expected");
  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));
  lua_unlock(L);
  return ttnov(L->top - 1);
}


LUA_API int lua_rawgeti (lua_State *L, int idx, lua_Integer n) {
  StkId t;
  lua_lock(L);
  t = index2addr(L, idx);
  api_check(L, ttistable(t), "table expected");
  setobj2s(L, L->top, luaH_getint(hvalue(t), n));
  api_incr_top(L);
  lua_unlock(L);
  return ttnov(L->top - 1);
}


LUA_API int lua_rawgetp (lua_State *L, int idx, const void *p) {
  StkId t;
  TValue k;
  lua_lock(L);
  t = index2addr(L, idx);
  api_check(L, ttistable(t), "table expected");
  setpvalue(&k, cast(void *, p));
  setobj2s(L, L->top, luaH_get(hvalue(t), &k));
  api_incr_top(L);
  lua_unlock(L);
  return ttnov(L->top - 1);
}


LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
  Table *t;
  lua_lock(L);
  t = luaH_new(L);
  sethvalue(L, L->top, t);
  api_incr_top(L);
  if (narray > 0 || nrec > 0)
    luaH_resize(L, t, narray, nrec);
  luaC_checkGC(L);
  lua_unlock(L);
}


LUA_API int lua_getmetatable (lua_State *L, int objindex) {
  const TValue *obj;
  Table *mt;
  int res = 0;
  lua_lock(L);
  obj = index2addr(L, objindex);
  switch (ttnov(obj)) {
    case LUA_TTABLE:
      mt = hvalue(obj)->metatable;
      break;
    case LUA_TUSERDATA:
      mt = uvalue(obj)->metatable;
      break;
    default:
      mt = G(L)->mt[ttnov(obj)];
      break;
  }
  if (mt != NULL) {
    sethvalue(L, L->top, mt);
    api_incr_top(L);
    res = 1;
  }
  lua_unlock(L);
  return res;
}


LUA_API int lua_getuservalue (lua_State *L, int idx) {
  StkId o;
  lua_lock(L);
  o = index2addr(L, idx);
  api_check(L, ttisfulluserdata(o), "full userdata expected");
  getuservalue(L, uvalue(o), L->top);
  api_incr_top(L);
  lua_unlock(L);
  return ttnov(L->top - 1);
}


/*
** set functions (stack -> Lua)
*/

/*
** t[k] = value at the top of the stack (where 'k' is a string)
*/
static void auxsetstr (lua_State *L, const TValue *t, const char *k) {
  const TValue *slot;
  TString *str = luaS_new(L, k);
  api_checknelems(L, 1);
  if (luaV_fastset(L, t, str, slot, luaH_getstr, L->top - 1))
    L->top--;  /* pop value */
  else {
    setsvalue2s(L, L->top, str);  /* push 'str' (to make it a TValue) */
    api_incr_top(L);
    luaV_finishset(L, t, L->top - 1, L->top - 2, slot);
    L->top -= 2;  /* pop value and key */
  }
  lua_unlock(L);  /* lock done by caller */
}


LUA_API void lua_setglobal (lua_State *L, const char *name) {
  Table *reg = hvalue(&G(L)->l_registry);
  lua_lock(L);  /* unlock done in 'auxsetstr' */
  auxsetstr(L, luaH_getint(reg, LUA_RIDX_GLOBALS), name);
}


LUA_API void lua_settable (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  api_checknelems(L, 2);
  t = index2addr(L, idx);
  luaV_settable(L, t, L->top - 2, L->top - 1);
  L->top -= 2;  /* pop index and value */
  lua_unlock(L);
}


LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
  lua_lock(L);  /* unlock done in 'auxsetstr' */
  auxsetstr(L, index2addr(L, idx), k);
}


LUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {
  StkId t;
  const TValue *slot;
  lua_lock(L);
  api_checknelems(L, 1);
  t = index2addr(L, idx);
  if (luaV_fastset(L, t, n, slot, luaH_getint, L->top - 1))
    L->top--;  /* pop value */
  else {
    setivalue(L->top, n);
    api_incr_top(L);
    luaV_finishset(L, t, L->top - 1, L->top - 2, slot);
    L->top -= 2;  /* pop value and key */
  }
  lua_unlock(L);
}


LUA_API void lua_rawset (lua_State *L, int idx) {
  StkId o;
  TValue *slot;
  lua_lock(L);
  api_checknelems(L, 2);
  o = index2addr(L, idx);
  api_check(L, ttistable(o), "table expected");
  slot = luaH_set(L, hvalue(o), L->top - 2);
  setobj2t(L, slot, L->top - 1);
  invalidateTMcache(hvalue(o));
  luaC_barrierback(L, hvalue(o), L->top-1);
  L->top -= 2;
  lua_unlock(L);
}


LUA_API void lua_rawseti (lua_State *L, int idx, lua_Integer n) {
  StkId o;
  lua_lock(L);
  api_checknelems(L, 1);
  o = index2addr(L, idx);
  api_check(L, ttistable(o), "table expected");
  luaH_setint(L, hvalue(o), n, L->top - 1);
  luaC_barrierback(L, hvalue(o), L->top-1);
  L->top--;
  lua_unlock(L);
}


LUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {
  StkId o;
  TValue k, *slot;
  lua_lock(L);
  api_checknelems(L, 1);
  o = index2addr(L, idx);
  api_check(L, ttistable(o), "table expected");
  setpvalue(&k, cast(void *, p));
  slot = luaH_set(L, hvalue(o), &k);
  setobj2t(L, slot, L->top - 1);
  luaC_barrierback(L, hvalue(o), L->top - 1);
  L->top--;
  lua_unlock(L);
}


LUA_API int lua_setmetatable (lua_State *L, int objindex) {
  TValue *obj;
  Table *mt;
  lua_lock(L);
  api_checknelems(L, 1);
  obj = index2addr(L, objindex);
  if (ttisnil(L->top - 1))
    mt = NULL;
  else {
    api_check(L, ttistable(L->top - 1), "table expected");
    mt = hvalue(L->top - 1);
  }
  switch (ttnov(obj)) {
    case LUA_TTABLE: {
      hvalue(obj)->metatable = mt;
      if (mt) {
        luaC_objbarrier(L, gcvalue(obj), mt);
        luaC_checkfinalizer(L, gcvalue(obj), mt);
      }
      break;
    }
    case LUA_TUSERDATA: {
      uvalue(obj)->metatable = mt;
      if (mt) {
        luaC_objbarrier(L, uvalue(obj), mt);
        luaC_checkfinalizer(L, gcvalue(obj), mt);
      }
      break;
    }
    default: {
      G(L)->mt[ttnov(obj)] = mt;
      break;
    }
  }
  L->top--;
  lua_unlock(L);
  return 1;
}


LUA_API void lua_setuservalue (lua_State *L, int idx) {
  StkId o;
  lua_lock(L);
  api_checknelems(L, 1);
  o = index2addr(L, idx);
  api_check(L, ttisfulluserdata(o), "full userdata expected");
  setuservalue(L, uvalue(o), L->top - 1);
  luaC_barrier(L, gcvalue(o), L->top - 1);
  L->top--;
  lua_unlock(L);
}


/*
** 'load' and 'call' functions (run Lua code)
*/


#define checkresults(L,na,nr) \
     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \
	"results from function overflow current stack size")


LUA_API void lua_callk (lua_State *L, int nargs, int nresults,
                        lua_KContext ctx, lua_KFunction k) {
  StkId func;
  lua_lock(L);
  api_check(L, k == NULL || !isLua(L->ci),
    "cannot use continuations inside hooks");
  api_checknelems(L, nargs+1);
  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
  checkresults(L, nargs, nresults);
  func = L->top - (nargs+1);
  if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */
    L->ci->u.c.k = k;  /* save continuation */
    L->ci->u.c.ctx = ctx;  /* save context */
    luaD_call(L, func, nresults);  /* do the call */
  }
  else  /* no continuation or no yieldable */
    luaD_callnoyield(L, func, nresults);  /* just do the call */
  adjustresults(L, nresults);
  lua_unlock(L);
}



/*
** Execute a protected call.
*/
struct CallS {  /* data to 'f_call' */
  StkId func;
  int nresults;
};


static void f_call (lua_State *L, void *ud) {
  struct CallS *c = cast(struct CallS *, ud);
  luaD_callnoyield(L, c->func, c->nresults);
}



LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,
                        lua_KContext ctx, lua_KFunction k) {
  struct CallS c;
  int status;
  ptrdiff_t func;
  lua_lock(L);
  api_check(L, k == NULL || !isLua(L->ci),
    "cannot use continuations inside hooks");
  api_checknelems(L, nargs+1);
  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
  checkresults(L, nargs, nresults);
  if (errfunc == 0)
    func = 0;
  else {
    StkId o = index2addr(L, errfunc);
    api_checkstackindex(L, errfunc, o);
    func = savestack(L, o);
  }
  c.func = L->top - (nargs+1);  /* function to be called */
  if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */
    c.nresults = nresults;  /* do a 'conventional' protected call */
    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
  }
  else {  /* prepare continuation (call is already protected by 'resume') */
    CallInfo *ci = L->ci;
    ci->u.c.k = k;  /* save continuation */
    ci->u.c.ctx = ctx;  /* save context */
    /* save information for error recovery */
    ci->extra = savestack(L, c.func);
    ci->u.c.old_errfunc = L->errfunc;
    L->errfunc = func;
    setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */
    ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */
    luaD_call(L, c.func, nresults);  /* do the call */
    ci->callstatus &= ~CIST_YPCALL;
    L->errfunc = ci->u.c.old_errfunc;
    status = LUA_OK;  /* if it is here, there were no errors */
  }
  adjustresults(L, nresults);
  lua_unlock(L);
  return status;
}


LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
                      const char *chunkname, const char *mode) {
  ZIO z;
  int status;
  lua_lock(L);
  if (!chunkname) chunkname = "?";
  luaZ_init(L, &z, reader, data);
  status = luaD_protectedparser(L, &z, chunkname, mode);
  if (status == LUA_OK) {  /* no errors? */
    LClosure *f = clLvalue(L->top - 1);  /* get newly created function */
    if (f->nupvalues >= 1) {  /* does it have an upvalue? */
      /* get global table from registry */
      Table *reg = hvalue(&G(L)->l_registry);
      const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
      setobj(L, f->upvals[0]->v, gt);
      luaC_upvalbarrier(L, f->upvals[0]);
    }
  }
  lua_unlock(L);
  return status;
}


LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip) {
  int status;
  TValue *o;
  lua_lock(L);
  api_checknelems(L, 1);
  o = L->top - 1;
  if (isLfunction(o))
    status = luaU_dump(L, getproto(o), writer, data, strip);
  else
    status = 1;
  lua_unlock(L);
  return status;
}


LUA_API int lua_status (lua_State *L) {
  return L->status;
}


/*
** Garbage-collection function
*/

LUA_API int lua_gc (lua_State *L, int what, int data) {
  int res = 0;
  global_State *g;
  lua_lock(L);
  g = G(L);
  switch (what) {
    case LUA_GCSTOP: {
      g->gcrunning = 0;
      break;
    }
    case LUA_GCRESTART: {
      luaE_setdebt(g, 0);
      g->gcrunning = 1;
      break;
    }
    case LUA_GCCOLLECT: {
      luaC_fullgc(L, 0);
      break;
    }
    case LUA_GCCOUNT: {
      /* GC values are expressed in Kbytes: #bytes/2^10 */
      res = cast_int(gettotalbytes(g) >> 10);
      break;
    }
    case LUA_GCCOUNTB: {
      res = cast_int(gettotalbytes(g) & 0x3ff);
      break;
    }
    case LUA_GCSTEP: {
      l_mem debt = 1;  /* =1 to signal that it did an actual step */
      lu_byte oldrunning = g->gcrunning;
      g->gcrunning = 1;  /* allow GC to run */
      if (data == 0) {
        luaE_setdebt(g, -GCSTEPSIZE);  /* to do a "small" step */
        luaC_step(L);
      }
      else {  /* add 'data' to total debt */
        debt = cast(l_mem, data) * 1024 + g->GCdebt;
        luaE_setdebt(g, debt);
        luaC_checkGC(L);
      }
      g->gcrunning = oldrunning;  /* restore previous state */
      if (debt > 0 && g->gcstate == GCSpause)  /* end of cycle? */
        res = 1;  /* signal it */
      break;
    }
    case LUA_GCSETPAUSE: {
      res = g->gcpause;
      g->gcpause = data;
      break;
    }
    case LUA_GCSETSTEPMUL: {
      res = g->gcstepmul;
      if (data < 40) data = 40;  /* avoid ridiculous low values (and 0) */
      g->gcstepmul = data;
      break;
    }
    case LUA_GCISRUNNING: {
      res = g->gcrunning;
      break;
    }
    default: res = -1;  /* invalid option */
  }
  lua_unlock(L);
  return res;
}



/*
** miscellaneous functions
*/


LUA_API int lua_error (lua_State *L) {
  lua_lock(L);
  api_checknelems(L, 1);
  luaG_errormsg(L);
  /* code unreachable; will unlock when control actually leaves the kernel */
  return 0;  /* to avoid warnings */
}


LUA_API int lua_next (lua_State *L, int idx) {
  StkId t;
  int more;
  lua_lock(L);
  t = index2addr(L, idx);
  api_check(L, ttistable(t), "table expected");
  more = luaH_next(L, hvalue(t), L->top - 1);
  if (more) {
    api_incr_top(L);
  }
  else  /* no more elements */
    L->top -= 1;  /* remove key */
  lua_unlock(L);
  return more;
}


LUA_API void lua_concat (lua_State *L, int n) {
  lua_lock(L);
  api_checknelems(L, n);
  if (n >= 2) {
    luaV_concat(L, n);
  }
  else if (n == 0) {  /* push empty string */
    setsvalue2s(L, L->top, luaS_newlstr(L, "", 0));
    api_incr_top(L);
  }
  /* else n == 1; nothing to do */
  luaC_checkGC(L);
  lua_unlock(L);
}


LUA_API void lua_len (lua_State *L, int idx) {
  StkId t;
  lua_lock(L);
  t = index2addr(L, idx);
  luaV_objlen(L, L->top, t);
  api_incr_top(L);
  lua_unlock(L);
}


LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
  lua_Alloc f;
  lua_lock(L);
  if (ud) *ud = G(L)->ud;
  f = G(L)->frealloc;
  lua_unlock(L);
  return f;
}


LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
  lua_lock(L);
  G(L)->ud = ud;
  G(L)->frealloc = f;
  lua_unlock(L);
}


LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
  Udata *u;
  lua_lock(L);
  u = luaS_newudata(L, size);
  setuvalue(L, L->top, u);
  api_incr_top(L);
  luaC_checkGC(L);
  lua_unlock(L);
  return getudatamem(u);
}



static const char *aux_upvalue (StkId fi, int n, TValue **val,
                                CClosure **owner, UpVal **uv) {
  switch (ttype(fi)) {
    case LUA_TCCL: {  /* C closure */
      CClosure *f = clCvalue(fi);
      if (!(1 <= n && n <= f->nupvalues)) return NULL;
      *val = &f->upvalue[n-1];
      if (owner) *owner = f;
      return "";
    }
    case LUA_TLCL: {  /* Lua closure */
      LClosure *f = clLvalue(fi);
      TString *name;
      Proto *p = f->p;
      if (!(1 <= n && n <= p->sizeupvalues)) return NULL;
      *val = f->upvals[n-1]->v;
      if (uv) *uv = f->upvals[n - 1];
      name = p->upvalues[n-1].name;
      return (name == NULL) ? "(*no name)" : getstr(name);
    }
    default: return NULL;  /* not a closure */
  }
}


LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val = NULL;  /* to avoid warnings */
  lua_lock(L);
  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL, NULL);
  if (name) {
    setobj2s(L, L->top, val);
    api_incr_top(L);
  }
  lua_unlock(L);
  return name;
}


LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
  const char *name;
  TValue *val = NULL;  /* to avoid warnings */
  CClosure *owner = NULL;
  UpVal *uv = NULL;
  StkId fi;
  lua_lock(L);
  fi = index2addr(L, funcindex);
  api_checknelems(L, 1);
  name = aux_upvalue(fi, n, &val, &owner, &uv);
  if (name) {
    L->top--;
    setobj(L, val, L->top);
    if (owner) { luaC_barrier(L, owner, L->top); }
    else if (uv) { luaC_upvalbarrier(L, uv); }
  }
  lua_unlock(L);
  return name;
}


static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
  LClosure *f;
  StkId fi = index2addr(L, fidx);
  api_check(L, ttisLclosure(fi), "Lua function expected");
  f = clLvalue(fi);
  api_check(L, (1 <= n && n <= f->p->sizeupvalues), "invalid upvalue index");
  if (pf) *pf = f;
  return &f->upvals[n - 1];  /* get its upvalue pointer */
}


LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {
  StkId fi = index2addr(L, fidx);
  switch (ttype(fi)) {
    case LUA_TLCL: {  /* lua closure */
      return *getupvalref(L, fidx, n, NULL);
    }
    case LUA_TCCL: {  /* C closure */
      CClosure *f = clCvalue(fi);
      api_check(L, 1 <= n && n <= f->nupvalues, "invalid upvalue index");
      return &f->upvalue[n - 1];
    }
    default: {
      api_check(L, 0, "closure expected");
      return NULL;
    }
  }
}


LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
                                            int fidx2, int n2) {
  LClosure *f1;
  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
  luaC_upvdeccount(L, *up1);
  *up1 = *up2;
  (*up1)->refcount++;
  if (upisopen(*up1)) (*up1)->u.open.touched = 1;
  luaC_upvalbarrier(L, *up1);
}



```

`src/Lua/lapi.h`:

```h
/*
** $Id: lapi.h,v 2.9 2015/03/06 19:49:50 roberto Exp $
** Auxiliary functions from Lua API
** See Copyright Notice in lua.h
*/

#ifndef lapi_h
#define lapi_h


#include "llimits.h"
#include "lstate.h"

#define api_incr_top(L)   {L->top++; api_check(L, L->top <= L->ci->top, \
				"stack overflow");}

#define adjustresults(L,nres) \
    { if ((nres) == LUA_MULTRET && L->ci->top < L->top) L->ci->top = L->top; }

#define api_checknelems(L,n)	api_check(L, (n) < (L->top - L->ci->func), \
				  "not enough elements in the stack")


#endif

```

`src/Lua/lauxlib.c`:

```c
/*
** $Id: lauxlib.c,v 1.289 2016/12/20 18:37:00 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/

#define lauxlib_c
#define LUA_LIB

#include "lprefix.h"


#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


/*
** This file uses only the official API of Lua.
** Any function declared here could be written as an application function.
*/

#include "lua.h"

#include "lauxlib.h"


/*
** {======================================================
** Traceback
** =======================================================
*/


#define LEVELS1	10	/* size of the first part of the stack */
#define LEVELS2	11	/* size of the second part of the stack */



/*
** search for 'objidx' in table at index -1.
** return 1 + string at top if find a good name.
*/
static int findfield (lua_State *L, int objidx, int level) {
  if (level == 0 || !lua_istable(L, -1))
    return 0;  /* not found */
  lua_pushnil(L);  /* start 'next' loop */
  while (lua_next(L, -2)) {  /* for each pair in table */
    if (lua_type(L, -2) == LUA_TSTRING) {  /* ignore non-string keys */
      if (lua_rawequal(L, objidx, -1)) {  /* found object? */
        lua_pop(L, 1);  /* remove value (but keep name) */
        return 1;
      }
      else if (findfield(L, objidx, level - 1)) {  /* try recursively */
        lua_remove(L, -2);  /* remove table (but keep name) */
        lua_pushliteral(L, ".");
        lua_insert(L, -2);  /* place '.' between the two names */
        lua_concat(L, 3);
        return 1;
      }
    }
    lua_pop(L, 1);  /* remove value */
  }
  return 0;  /* not found */
}


/*
** Search for a name for a function in all loaded modules
*/
static int pushglobalfuncname (lua_State *L, lua_Debug *ar) {
  int top = lua_gettop(L);
  lua_getinfo(L, "f", ar);  /* push function */
  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  if (findfield(L, top + 1, 2)) {
    const char *name = lua_tostring(L, -1);
    if (strncmp(name, "_G.", 3) == 0) {  /* name start with '_G.'? */
      lua_pushstring(L, name + 3);  /* push name without prefix */
      lua_remove(L, -2);  /* remove original name */
    }
    lua_copy(L, -1, top + 1);  /* move name to proper place */
    lua_pop(L, 2);  /* remove pushed values */
    return 1;
  }
  else {
    lua_settop(L, top);  /* remove function and global table */
    return 0;
  }
}


static void pushfuncname (lua_State *L, lua_Debug *ar) {
  if (pushglobalfuncname(L, ar)) {  /* try first a global name */
    lua_pushfstring(L, "function '%s'", lua_tostring(L, -1));
    lua_remove(L, -2);  /* remove name */
  }
  else if (*ar->namewhat != '\0')  /* is there a name from code? */
    lua_pushfstring(L, "%s '%s'", ar->namewhat, ar->name);  /* use it */
  else if (*ar->what == 'm')  /* main? */
      lua_pushliteral(L, "main chunk");
  else if (*ar->what != 'C')  /* for Lua functions, use <file:line> */
    lua_pushfstring(L, "function <%s:%d>", ar->short_src, ar->linedefined);
  else  /* nothing left... */
    lua_pushliteral(L, "?");
}


static int lastlevel (lua_State *L) {
  lua_Debug ar;
  int li = 1, le = 1;
  /* find an upper bound */
  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }
  /* do a binary search */
  while (li < le) {
    int m = (li + le)/2;
    if (lua_getstack(L, m, &ar)) li = m + 1;
    else le = m;
  }
  return le - 1;
}


LUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,
                                const char *msg, int level) {
  lua_Debug ar;
  int top = lua_gettop(L);
  int last = lastlevel(L1);
  int n1 = (last - level > LEVELS1 + LEVELS2) ? LEVELS1 : -1;
  if (msg)
    lua_pushfstring(L, "%s\n", msg);
  luaL_checkstack(L, 10, NULL);
  lua_pushliteral(L, "stack traceback:");
  while (lua_getstack(L1, level++, &ar)) {
    if (n1-- == 0) {  /* too many levels? */
      lua_pushliteral(L, "\n\t...");  /* add a '...' */
      level = last - LEVELS2 + 1;  /* and skip to last ones */
    }
    else {
      lua_getinfo(L1, "Slnt", &ar);
      lua_pushfstring(L, "\n\t%s:", ar.short_src);
      if (ar.currentline > 0)
        lua_pushfstring(L, "%d:", ar.currentline);
      lua_pushliteral(L, " in ");
      pushfuncname(L, &ar);
      if (ar.istailcall)
        lua_pushliteral(L, "\n\t(...tail calls...)");
      lua_concat(L, lua_gettop(L) - top);
    }
  }
  lua_concat(L, lua_gettop(L) - top);
}

/* }====================================================== */


/*
** {======================================================
** Error-report functions
** =======================================================
*/

LUALIB_API int luaL_argerror (lua_State *L, int arg, const char *extramsg) {
  lua_Debug ar;
  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
    return luaL_error(L, "bad argument #%d (%s)", arg, extramsg);
  lua_getinfo(L, "n", &ar);
  if (strcmp(ar.namewhat, "method") == 0) {
    arg--;  /* do not count 'self' */
    if (arg == 0)  /* error is in the self argument itself? */
      return luaL_error(L, "calling '%s' on bad self (%s)",
                           ar.name, extramsg);
  }
  if (ar.name == NULL)
    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : "?";
  return luaL_error(L, "bad argument #%d to '%s' (%s)",
                        arg, ar.name, extramsg);
}


static int typeerror (lua_State *L, int arg, const char *tname) {
  const char *msg;
  const char *typearg;  /* name for the type of the actual argument */
  if (luaL_getmetafield(L, arg, "__name") == LUA_TSTRING)
    typearg = lua_tostring(L, -1);  /* use the given type name */
  else if (lua_type(L, arg) == LUA_TLIGHTUSERDATA)
    typearg = "light userdata";  /* special name for messages */
  else
    typearg = luaL_typename(L, arg);  /* standard name */
  msg = lua_pushfstring(L, "%s expected, got %s", tname, typearg);
  return luaL_argerror(L, arg, msg);
}


static void tag_error (lua_State *L, int arg, int tag) {
  typeerror(L, arg, lua_typename(L, tag));
}


/*
** The use of 'lua_pushfstring' ensures this function does not
** need reserved stack space when called.
*/
LUALIB_API void luaL_where (lua_State *L, int level) {
  lua_Debug ar;
  if (lua_getstack(L, level, &ar)) {  /* check function at level */
    lua_getinfo(L, "Sl", &ar);  /* get info about it */
    if (ar.currentline > 0) {  /* is there info? */
      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
      return;
    }
  }
  lua_pushfstring(L, "");  /* else, no information available... */
}


/*
** Again, the use of 'lua_pushvfstring' ensures this function does
** not need reserved stack space when called. (At worst, it generates
** an error with "stack overflow" instead of the given message.)
*/
LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  luaL_where(L, 1);
  lua_pushvfstring(L, fmt, argp);
  va_end(argp);
  lua_concat(L, 2);
  return lua_error(L);
}


LUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {
  int en = errno;  /* calls to Lua API may change this value */
  if (stat) {
    lua_pushboolean(L, 1);
    return 1;
  }
  else {
    lua_pushnil(L);
    if (fname)
      lua_pushfstring(L, "%s: %s", fname, strerror(en));
    else
      lua_pushstring(L, strerror(en));
    lua_pushinteger(L, en);
    return 3;
  }
}


#if !defined(l_inspectstat)	/* { */

#if defined(LUA_USE_POSIX)

#include <sys/wait.h>

/*
** use appropriate macros to interpret 'pclose' return status
*/
#define l_inspectstat(stat,what)  \
   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \
   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = "signal"; }

#else

#define l_inspectstat(stat,what)  /* no op */

#endif

#endif				/* } */


LUALIB_API int luaL_execresult (lua_State *L, int stat) {
  const char *what = "exit";  /* type of termination */
  if (stat == -1)  /* error? */
    return luaL_fileresult(L, 0, NULL);
  else {
    l_inspectstat(stat, what);  /* interpret result */
    if (*what == 'e' && stat == 0)  /* successful termination? */
      lua_pushboolean(L, 1);
    else
      lua_pushnil(L);
    lua_pushstring(L, what);
    lua_pushinteger(L, stat);
    return 3;  /* return true/nil,what,code */
  }
}

/* }====================================================== */


/*
** {======================================================
** Userdata's metatable manipulation
** =======================================================
*/

LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
  if (luaL_getmetatable(L, tname) != LUA_TNIL)  /* name already in use? */
    return 0;  /* leave previous value on top, but return 0 */
  lua_pop(L, 1);
  lua_createtable(L, 0, 2);  /* create metatable */
  lua_pushstring(L, tname);
  lua_setfield(L, -2, "__name");  /* metatable.__name = tname */
  lua_pushvalue(L, -1);
  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
  return 1;
}


LUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {
  luaL_getmetatable(L, tname);
  lua_setmetatable(L, -2);
}


LUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {
  void *p = lua_touserdata(L, ud);
  if (p != NULL) {  /* value is a userdata? */
    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
      luaL_getmetatable(L, tname);  /* get correct metatable */
      if (!lua_rawequal(L, -1, -2))  /* not the same? */
        p = NULL;  /* value is a userdata with wrong metatable */
      lua_pop(L, 2);  /* remove both metatables */
      return p;
    }
  }
  return NULL;  /* value is not a userdata with a metatable */
}


LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
  void *p = luaL_testudata(L, ud, tname);
  if (p == NULL) typeerror(L, ud, tname);
  return p;
}

/* }====================================================== */


/*
** {======================================================
** Argument check functions
** =======================================================
*/

LUALIB_API int luaL_checkoption (lua_State *L, int arg, const char *def,
                                 const char *const lst[]) {
  const char *name = (def) ? luaL_optstring(L, arg, def) :
                             luaL_checkstring(L, arg);
  int i;
  for (i=0; lst[i]; i++)
    if (strcmp(lst[i], name) == 0)
      return i;
  return luaL_argerror(L, arg,
                       lua_pushfstring(L, "invalid option '%s'", name));
}


/*
** Ensures the stack has at least 'space' extra slots, raising an error
** if it cannot fulfill the request. (The error handling needs a few
** extra slots to format the error message. In case of an error without
** this extra space, Lua will generate the same 'stack overflow' error,
** but without 'msg'.)
*/
LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {
  if (!lua_checkstack(L, space)) {
    if (msg)
      luaL_error(L, "stack overflow (%s)", msg);
    else
      luaL_error(L, "stack overflow");
  }
}


LUALIB_API void luaL_checktype (lua_State *L, int arg, int t) {
  if (lua_type(L, arg) != t)
    tag_error(L, arg, t);
}


LUALIB_API void luaL_checkany (lua_State *L, int arg) {
  if (lua_type(L, arg) == LUA_TNONE)
    luaL_argerror(L, arg, "value expected");
}


LUALIB_API const char *luaL_checklstring (lua_State *L, int arg, size_t *len) {
  const char *s = lua_tolstring(L, arg, len);
  if (!s) tag_error(L, arg, LUA_TSTRING);
  return s;
}


LUALIB_API const char *luaL_optlstring (lua_State *L, int arg,
                                        const char *def, size_t *len) {
  if (lua_isnoneornil(L, arg)) {
    if (len)
      *len = (def ? strlen(def) : 0);
    return def;
  }
  else return luaL_checklstring(L, arg, len);
}


LUALIB_API lua_Number luaL_checknumber (lua_State *L, int arg) {
  int isnum;
  lua_Number d = lua_tonumberx(L, arg, &isnum);
  if (!isnum)
    tag_error(L, arg, LUA_TNUMBER);
  return d;
}


LUALIB_API lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number def) {
  return luaL_opt(L, luaL_checknumber, arg, def);
}


static void interror (lua_State *L, int arg) {
  if (lua_isnumber(L, arg))
    luaL_argerror(L, arg, "number has no integer representation");
  else
    tag_error(L, arg, LUA_TNUMBER);
}


LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int arg) {
  int isnum;
  lua_Integer d = lua_tointegerx(L, arg, &isnum);
  if (!isnum) {
    interror(L, arg);
  }
  return d;
}


LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int arg,
                                                      lua_Integer def) {
  return luaL_opt(L, luaL_checkinteger, arg, def);
}

/* }====================================================== */


/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/

/* userdata to box arbitrary data */
typedef struct UBox {
  void *box;
  size_t bsize;
} UBox;


static void *resizebox (lua_State *L, int idx, size_t newsize) {
  void *ud;
  lua_Alloc allocf = lua_getallocf(L, &ud);
  UBox *box = (UBox *)lua_touserdata(L, idx);
  void *temp = allocf(ud, box->box, box->bsize, newsize);
  if (temp == NULL && newsize > 0) {  /* allocation error? */
    resizebox(L, idx, 0);  /* free buffer */
    luaL_error(L, "not enough memory for buffer allocation");
  }
  box->box = temp;
  box->bsize = newsize;
  return temp;
}


static int boxgc (lua_State *L) {
  resizebox(L, 1, 0);
  return 0;
}


static void *newbox (lua_State *L, size_t newsize) {
  UBox *box = (UBox *)lua_newuserdata(L, sizeof(UBox));
  box->box = NULL;
  box->bsize = 0;
  if (luaL_newmetatable(L, "LUABOX")) {  /* creating metatable? */
    lua_pushcfunction(L, boxgc);
    lua_setfield(L, -2, "__gc");  /* metatable.__gc = boxgc */
  }
  lua_setmetatable(L, -2);
  return resizebox(L, -1, newsize);
}


/*
** check whether buffer is using a userdata on the stack as a temporary
** buffer
*/
#define buffonstack(B)	((B)->b != (B)->initb)


/*
** returns a pointer to a free area with at least 'sz' bytes
*/
LUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {
  lua_State *L = B->L;
  if (B->size - B->n < sz) {  /* not enough space? */
    char *newbuff;
    size_t newsize = B->size * 2;  /* double buffer size */
    if (newsize - B->n < sz)  /* not big enough? */
      newsize = B->n + sz;
    if (newsize < B->n || newsize - B->n < sz)
      luaL_error(L, "buffer too large");
    /* create larger buffer */
    if (buffonstack(B))
      newbuff = (char *)resizebox(L, -1, newsize);
    else {  /* no buffer yet */
      newbuff = (char *)newbox(L, newsize);
      memcpy(newbuff, B->b, B->n * sizeof(char));  /* copy original content */
    }
    B->b = newbuff;
    B->size = newsize;
  }
  return &B->b[B->n];
}


LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
  if (l > 0) {  /* avoid 'memcpy' when 's' can be NULL */
    char *b = luaL_prepbuffsize(B, l);
    memcpy(b, s, l * sizeof(char));
    luaL_addsize(B, l);
  }
}


LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
  luaL_addlstring(B, s, strlen(s));
}


LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
  lua_State *L = B->L;
  lua_pushlstring(L, B->b, B->n);
  if (buffonstack(B)) {
    resizebox(L, -2, 0);  /* delete old buffer */
    lua_remove(L, -2);  /* remove its header from the stack */
  }
}


LUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {
  luaL_addsize(B, sz);
  luaL_pushresult(B);
}


LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
  lua_State *L = B->L;
  size_t l;
  const char *s = lua_tolstring(L, -1, &l);
  if (buffonstack(B))
    lua_insert(L, -2);  /* put value below buffer */
  luaL_addlstring(B, s, l);
  lua_remove(L, (buffonstack(B)) ? -2 : -1);  /* remove value */
}


LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
  B->L = L;
  B->b = B->initb;
  B->n = 0;
  B->size = LUAL_BUFFERSIZE;
}


LUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {
  luaL_buffinit(L, B);
  return luaL_prepbuffsize(B, sz);
}

/* }====================================================== */


/*
** {======================================================
** Reference system
** =======================================================
*/

/* index of free-list header */
#define freelist	0


LUALIB_API int luaL_ref (lua_State *L, int t) {
  int ref;
  if (lua_isnil(L, -1)) {
    lua_pop(L, 1);  /* remove from stack */
    return LUA_REFNIL;  /* 'nil' has a unique fixed reference */
  }
  t = lua_absindex(L, t);
  lua_rawgeti(L, t, freelist);  /* get first free element */
  ref = (int)lua_tointeger(L, -1);  /* ref = t[freelist] */
  lua_pop(L, 1);  /* remove it from stack */
  if (ref != 0) {  /* any free element? */
    lua_rawgeti(L, t, ref);  /* remove it from list */
    lua_rawseti(L, t, freelist);  /* (t[freelist] = t[ref]) */
  }
  else  /* no free elements */
    ref = (int)lua_rawlen(L, t) + 1;  /* get a new reference */
  lua_rawseti(L, t, ref);
  return ref;
}


LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
  if (ref >= 0) {
    t = lua_absindex(L, t);
    lua_rawgeti(L, t, freelist);
    lua_rawseti(L, t, ref);  /* t[ref] = t[freelist] */
    lua_pushinteger(L, ref);
    lua_rawseti(L, t, freelist);  /* t[freelist] = ref */
  }
}

/* }====================================================== */


/*
** {======================================================
** Load functions
** =======================================================
*/

typedef struct LoadF {
  int n;  /* number of pre-read characters */
  FILE *f;  /* file being read */
  char buff[BUFSIZ];  /* area for reading file */
} LoadF;


static const char *getF (lua_State *L, void *ud, size_t *size) {
  LoadF *lf = (LoadF *)ud;
  (void)L;  /* not used */
  if (lf->n > 0) {  /* are there pre-read characters to be read? */
    *size = lf->n;  /* return them (chars already in buffer) */
    lf->n = 0;  /* no more pre-read characters */
  }
  else {  /* read a block from file */
    /* 'fread' can return > 0 *and* set the EOF flag. If next call to
       'getF' called 'fread', it might still wait for user input.
       The next check avoids this problem. */
    if (feof(lf->f)) return NULL;
    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */
  }
  return lf->buff;
}


static int errfile (lua_State *L, const char *what, int fnameindex) {
  const char *serr = strerror(errno);
  const char *filename = lua_tostring(L, fnameindex) + 1;
  lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
  lua_remove(L, fnameindex);
  return LUA_ERRFILE;
}


static int skipBOM (LoadF *lf) {
  const char *p = "\xEF\xBB\xBF";  /* UTF-8 BOM mark */
  int c;
  lf->n = 0;
  do {
    c = getc(lf->f);
    if (c == EOF || c != *(const unsigned char *)p++) return c;
    lf->buff[lf->n++] = c;  /* to be read by the parser */
  } while (*p != '\0');
  lf->n = 0;  /* prefix matched; discard it */
  return getc(lf->f);  /* return next character */
}


/*
** reads the first character of file 'f' and skips an optional BOM mark
** in its beginning plus its first line if it starts with '#'. Returns
** true if it skipped the first line.  In any case, '*cp' has the
** first "valid" character of the file (after the optional BOM and
** a first-line comment).
*/
static int skipcomment (LoadF *lf, int *cp) {
  int c = *cp = skipBOM(lf);
  if (c == '#') {  /* first line is a comment (Unix exec. file)? */
    do {  /* skip first line */
      c = getc(lf->f);
    } while (c != EOF && c != '\n');
    *cp = getc(lf->f);  /* skip end-of-line, if present */
    return 1;  /* there was a comment */
  }
  else return 0;  /* no comment */
}


LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,
                                             const char *mode) {
  LoadF lf;
  int status, readstatus;
  int c;
  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
  if (filename == NULL) {
    lua_pushliteral(L, "=stdin");
    lf.f = stdin;
  }
  else {
    lua_pushfstring(L, "@%s", filename);
    lf.f = fopen(filename, "r");
    if (lf.f == NULL) return errfile(L, "open", fnameindex);
  }
  if (skipcomment(&lf, &c))  /* read initial portion */
    lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
  if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
    lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
    if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
    skipcomment(&lf, &c);  /* re-read initial portion */
  }
  if (c != EOF)
    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
  readstatus = ferror(lf.f);
  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
  if (readstatus) {
    lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */
    return errfile(L, "read", fnameindex);
  }
  lua_remove(L, fnameindex);
  return status;
}


typedef struct LoadS {
  const char *s;
  size_t size;
} LoadS;


static const char *getS (lua_State *L, void *ud, size_t *size) {
  LoadS *ls = (LoadS *)ud;
  (void)L;  /* not used */
  if (ls->size == 0) return NULL;
  *size = ls->size;
  ls->size = 0;
  return ls->s;
}


LUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,
                                 const char *name, const char *mode) {
  LoadS ls;
  ls.s = buff;
  ls.size = size;
  return lua_load(L, getS, &ls, name, mode);
}


LUALIB_API int luaL_loadstring (lua_State *L, const char *s) {
  return luaL_loadbuffer(L, s, strlen(s), s);
}

/* }====================================================== */



LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
  if (!lua_getmetatable(L, obj))  /* no metatable? */
    return LUA_TNIL;
  else {
    int tt;
    lua_pushstring(L, event);
    tt = lua_rawget(L, -2);
    if (tt == LUA_TNIL)  /* is metafield nil? */
      lua_pop(L, 2);  /* remove metatable and metafield */
    else
      lua_remove(L, -2);  /* remove only metatable */
    return tt;  /* return metafield type */
  }
}


LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
  obj = lua_absindex(L, obj);
  if (luaL_getmetafield(L, obj, event) == LUA_TNIL)  /* no metafield? */
    return 0;
  lua_pushvalue(L, obj);
  lua_call(L, 1, 1);
  return 1;
}


LUALIB_API lua_Integer luaL_len (lua_State *L, int idx) {
  lua_Integer l;
  int isnum;
  lua_len(L, idx);
  l = lua_tointegerx(L, -1, &isnum);
  if (!isnum)
    luaL_error(L, "object length is not an integer");
  lua_pop(L, 1);  /* remove object */
  return l;
}


LUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {
  if (luaL_callmeta(L, idx, "__tostring")) {  /* metafield? */
    if (!lua_isstring(L, -1))
      luaL_error(L, "'__tostring' must return a string");
  }
  else {
    switch (lua_type(L, idx)) {
      case LUA_TNUMBER: {
        if (lua_isinteger(L, idx))
          lua_pushfstring(L, "%I", (LUAI_UACINT)lua_tointeger(L, idx));
        else
          lua_pushfstring(L, "%f", (LUAI_UACNUMBER)lua_tonumber(L, idx));
        break;
      }
      case LUA_TSTRING:
        lua_pushvalue(L, idx);
        break;
      case LUA_TBOOLEAN:
        lua_pushstring(L, (lua_toboolean(L, idx) ? "true" : "false"));
        break;
      case LUA_TNIL:
        lua_pushliteral(L, "nil");
        break;
      default: {
        int tt = luaL_getmetafield(L, idx, "__name");  /* try name */
        const char *kind = (tt == LUA_TSTRING) ? lua_tostring(L, -1) :
                                                 luaL_typename(L, idx);
        lua_pushfstring(L, "%s: %p", kind, lua_topointer(L, idx));
        if (tt != LUA_TNIL)
          lua_remove(L, -2);  /* remove '__name' */
        break;
      }
    }
  }
  return lua_tolstring(L, -1, len);
}


/*
** {======================================================
** Compatibility with 5.1 module functions
** =======================================================
*/
#if defined(LUA_COMPAT_MODULE)

static const char *luaL_findtable (lua_State *L, int idx,
                                   const char *fname, int szhint) {
  const char *e;
  if (idx) lua_pushvalue(L, idx);
  do {
    e = strchr(fname, '.');
    if (e == NULL) e = fname + strlen(fname);
    lua_pushlstring(L, fname, e - fname);
    if (lua_rawget(L, -2) == LUA_TNIL) {  /* no such field? */
      lua_pop(L, 1);  /* remove this nil */
      lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */
      lua_pushlstring(L, fname, e - fname);
      lua_pushvalue(L, -2);
      lua_settable(L, -4);  /* set new table into field */
    }
    else if (!lua_istable(L, -1)) {  /* field has a non-table value? */
      lua_pop(L, 2);  /* remove table and value */
      return fname;  /* return problematic part of the name */
    }
    lua_remove(L, -2);  /* remove previous table */
    fname = e + 1;
  } while (*e == '.');
  return NULL;
}


/*
** Count number of elements in a luaL_Reg list.
*/
static int libsize (const luaL_Reg *l) {
  int size = 0;
  for (; l && l->name; l++) size++;
  return size;
}


/*
** Find or create a module table with a given name. The function
** first looks at the LOADED table and, if that fails, try a
** global variable with that name. In any case, leaves on the stack
** the module table.
*/
LUALIB_API void luaL_pushmodule (lua_State *L, const char *modname,
                                 int sizehint) {
  luaL_findtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE, 1);
  if (lua_getfield(L, -1, modname) != LUA_TTABLE) {  /* no LOADED[modname]? */
    lua_pop(L, 1);  /* remove previous result */
    /* try global variable (and create one if it does not exist) */
    lua_pushglobaltable(L);
    if (luaL_findtable(L, 0, modname, sizehint) != NULL)
      luaL_error(L, "name conflict for module '%s'", modname);
    lua_pushvalue(L, -1);
    lua_setfield(L, -3, modname);  /* LOADED[modname] = new table */
  }
  lua_remove(L, -2);  /* remove LOADED table */
}


LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
                               const luaL_Reg *l, int nup) {
  luaL_checkversion(L);
  if (libname) {
    luaL_pushmodule(L, libname, libsize(l));  /* get/create library table */
    lua_insert(L, -(nup + 1));  /* move library table to below upvalues */
  }
  if (l)
    luaL_setfuncs(L, l, nup);
  else
    lua_pop(L, nup);  /* remove upvalues */
}

#endif
/* }====================================================== */

/*
** set functions from list 'l' into table at top - 'nup'; each
** function gets the 'nup' elements at the top as upvalues.
** Returns with only the table at the stack.
*/
LUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {
  luaL_checkstack(L, nup, "too many upvalues");
  for (; l->name != NULL; l++) {  /* fill the table with given functions */
    int i;
    for (i = 0; i < nup; i++)  /* copy upvalues to the top */
      lua_pushvalue(L, -nup);
    lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */
    lua_setfield(L, -(nup + 2), l->name);
  }
  lua_pop(L, nup);  /* remove upvalues */
}


/*
** ensure that stack[idx][fname] has a table and push that table
** into the stack
*/
LUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {
  if (lua_getfield(L, idx, fname) == LUA_TTABLE)
    return 1;  /* table already there */
  else {
    lua_pop(L, 1);  /* remove previous result */
    idx = lua_absindex(L, idx);
    lua_newtable(L);
    lua_pushvalue(L, -1);  /* copy to be left at top */
    lua_setfield(L, idx, fname);  /* assign new table to field */
    return 0;  /* false, because did not find table there */
  }
}


/*
** Stripped-down 'require': After checking "loaded" table, calls 'openf'
** to open a module, registers the result in 'package.loaded' table and,
** if 'glb' is true, also registers the result in the global table.
** Leaves resulting module on the top.
*/
LUALIB_API void luaL_requiref (lua_State *L, const char *modname,
                               lua_CFunction openf, int glb) {
  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  lua_getfield(L, -1, modname);  /* LOADED[modname] */
  if (!lua_toboolean(L, -1)) {  /* package not already loaded? */
    lua_pop(L, 1);  /* remove field */
    lua_pushcfunction(L, openf);
    lua_pushstring(L, modname);  /* argument to open function */
    lua_call(L, 1, 1);  /* call 'openf' to open module */
    lua_pushvalue(L, -1);  /* make copy of module (call result) */
    lua_setfield(L, -3, modname);  /* LOADED[modname] = module */
  }
  lua_remove(L, -2);  /* remove LOADED table */
  if (glb) {
    lua_pushvalue(L, -1);  /* copy of module */
    lua_setglobal(L, modname);  /* _G[modname] = module */
  }
}


LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
                                                               const char *r) {
  const char *wild;
  size_t l = strlen(p);
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  while ((wild = strstr(s, p)) != NULL) {
    luaL_addlstring(&b, s, wild - s);  /* push prefix */
    luaL_addstring(&b, r);  /* push replacement in place of pattern */
    s = wild + l;  /* continue after 'p' */
  }
  luaL_addstring(&b, s);  /* push last suffix */
  luaL_pushresult(&b);
  return lua_tostring(L, -1);
}


static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
  (void)ud; (void)osize;  /* not used */
  if (nsize == 0) {
    free(ptr);
    return NULL;
  }
  else
    return realloc(ptr, nsize);
}


static int panic (lua_State *L) {
  lua_writestringerror("PANIC: unprotected error in call to Lua API (%s)\n",
                        lua_tostring(L, -1));
  return 0;  /* return to Lua to abort */
}


LUALIB_API lua_State *luaL_newstate (void) {
  lua_State *L = lua_newstate(l_alloc, NULL);
  if (L) lua_atpanic(L, &panic);
  return L;
}


LUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver, size_t sz) {
  const lua_Number *v = lua_version(L);
  if (sz != LUAL_NUMSIZES)  /* check numeric types */
    luaL_error(L, "core and library have incompatible numeric types");
  if (v != lua_version(NULL))
    luaL_error(L, "multiple Lua VMs detected");
  else if (*v != ver)
    luaL_error(L, "version mismatch: app. needs %f, Lua core provides %f",
                  (LUAI_UACNUMBER)ver, (LUAI_UACNUMBER)*v);
}


```

`src/Lua/lauxlib.h`:

```h
/*
** $Id: lauxlib.h,v 1.131 2016/12/06 14:54:31 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


#ifndef lauxlib_h
#define lauxlib_h


#include <stddef.h>
#include <stdio.h>

#include "lua.h"



/* extra error code for 'luaL_loadfilex' */
#define LUA_ERRFILE     (LUA_ERRERR+1)


/* key, in the registry, for table of loaded modules */
#define LUA_LOADED_TABLE	"_LOADED"


/* key, in the registry, for table of preloaded loaders */
#define LUA_PRELOAD_TABLE	"_PRELOAD"


typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;


#define LUAL_NUMSIZES	(sizeof(lua_Integer)*16 + sizeof(lua_Number))

LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver, size_t sz);
#define luaL_checkversion(L)  \
	  luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES)

LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
LUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg);
LUALIB_API const char *(luaL_checklstring) (lua_State *L, int arg,
                                                          size_t *l);
LUALIB_API const char *(luaL_optlstring) (lua_State *L, int arg,
                                          const char *def, size_t *l);
LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int arg);
LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int arg, lua_Number def);

LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int arg);
LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int arg,
                                          lua_Integer def);

LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
LUALIB_API void (luaL_checktype) (lua_State *L, int arg, int t);
LUALIB_API void (luaL_checkany) (lua_State *L, int arg);

LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
LUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);
LUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

LUALIB_API void (luaL_where) (lua_State *L, int lvl);
LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);

LUALIB_API int (luaL_checkoption) (lua_State *L, int arg, const char *def,
                                   const char *const lst[]);

LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
LUALIB_API int (luaL_execresult) (lua_State *L, int stat);

/* predefined references */
#define LUA_NOREF       (-2)
#define LUA_REFNIL      (-1)

LUALIB_API int (luaL_ref) (lua_State *L, int t);
LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);

LUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,
                                               const char *mode);

#define luaL_loadfile(L,f)	luaL_loadfilex(L,f,NULL)

LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
                                   const char *name, const char *mode);
LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);

LUALIB_API lua_State *(luaL_newstate) (void);

LUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);

LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

LUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);

LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);

LUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,
                                  const char *msg, int level);

LUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,
                                 lua_CFunction openf, int glb);

/*
** ===============================================================
** some useful macros
** ===============================================================
*/


#define luaL_newlibtable(L,l)	\
  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)

#define luaL_newlib(L,l)  \
  (luaL_checkversion(L), luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))

#define luaL_argcheck(L, cond,arg,extramsg)	\
		((void)((cond) || luaL_argerror(L, (arg), (extramsg))))
#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))

#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))

#define luaL_dofile(L, fn) \
	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_dostring(L, s) \
	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))

#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))

#define luaL_loadbuffer(L,s,sz,n)	luaL_loadbufferx(L,s,sz,n,NULL)


/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/

typedef struct luaL_Buffer {
  char *b;  /* buffer address */
  size_t size;  /* buffer size */
  size_t n;  /* number of characters in buffer */
  lua_State *L;
  char initb[LUAL_BUFFERSIZE];  /* initial buffer */
} luaL_Buffer;


#define luaL_addchar(B,c) \
  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \
   ((B)->b[(B)->n++] = (c)))

#define luaL_addsize(B,s)	((B)->n += (s))

LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
LUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);
LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);
LUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);

#define luaL_prepbuffer(B)	luaL_prepbuffsize(B, LUAL_BUFFERSIZE)

/* }====================================================== */



/*
** {======================================================
** File handles for IO library
** =======================================================
*/

/*
** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and
** initial structure 'luaL_Stream' (it may contain other fields
** after that initial structure).
*/

#define LUA_FILEHANDLE          "FILE*"


typedef struct luaL_Stream {
  FILE *f;  /* stream (NULL for incompletely created streams) */
  lua_CFunction closef;  /* to close stream (NULL for closed streams) */
} luaL_Stream;

/* }====================================================== */



/* compatibility with old module system */
#if defined(LUA_COMPAT_MODULE)

LUALIB_API void (luaL_pushmodule) (lua_State *L, const char *modname,
                                   int sizehint);
LUALIB_API void (luaL_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);

#define luaL_register(L,n,l)	(luaL_openlib(L,(n),(l),0))

#endif


/*
** {==================================================================
** "Abstraction Layer" for basic report of messages and errors
** ===================================================================
*/

/* print a string */
#if !defined(lua_writestring)
#define lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)
#endif

/* print a newline and flush the output */
#if !defined(lua_writeline)
#define lua_writeline()        (lua_writestring("\n", 1), fflush(stdout))
#endif

/* print an error message */
#if !defined(lua_writestringerror)
#define lua_writestringerror(s,p) \
        (fprintf(stderr, (s), (p)), fflush(stderr))
#endif

/* }================================================================== */


/*
** {============================================================
** Compatibility with deprecated conversions
** =============================================================
*/
#if defined(LUA_COMPAT_APIINTCASTS)

#define luaL_checkunsigned(L,a)	((lua_Unsigned)luaL_checkinteger(L,a))
#define luaL_optunsigned(L,a,d)	\
	((lua_Unsigned)luaL_optinteger(L,a,(lua_Integer)(d)))

#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))

#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))

#endif
/* }============================================================ */



#endif



```

`src/Lua/lbaselib.c`:

```c
/*
** $Id: lbaselib.c,v 1.314 2016/09/05 19:06:34 roberto Exp $
** Basic library
** See Copyright Notice in lua.h
*/

#define lbaselib_c
#define LUA_LIB

#include "lprefix.h"


#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


static int luaB_print (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  int i;
  lua_getglobal(L, "tostring");
  for (i=1; i<=n; i++) {
    const char *s;
    size_t l;
    lua_pushvalue(L, -1);  /* function to be called */
    lua_pushvalue(L, i);   /* value to print */
    lua_call(L, 1, 1);
    s = lua_tolstring(L, -1, &l);  /* get result */
    if (s == NULL)
      return luaL_error(L, "'tostring' must return a string to 'print'");
    if (i>1) lua_writestring("\t", 1);
    lua_writestring(s, l);
    lua_pop(L, 1);  /* pop result */
  }
  lua_writeline();
  return 0;
}


#define SPACECHARS	" \f\n\r\t\v"

static const char *b_str2int (const char *s, int base, lua_Integer *pn) {
  lua_Unsigned n = 0;
  int neg = 0;
  s += strspn(s, SPACECHARS);  /* skip initial spaces */
  if (*s == '-') { s++; neg = 1; }  /* handle signal */
  else if (*s == '+') s++;
  if (!isalnum((unsigned char)*s))  /* no digit? */
    return NULL;
  do {
    int digit = (isdigit((unsigned char)*s)) ? *s - '0'
                   : (toupper((unsigned char)*s) - 'A') + 10;
    if (digit >= base) return NULL;  /* invalid numeral */
    n = n * base + digit;
    s++;
  } while (isalnum((unsigned char)*s));
  s += strspn(s, SPACECHARS);  /* skip trailing spaces */
  *pn = (lua_Integer)((neg) ? (0u - n) : n);
  return s;
}


static int luaB_tonumber (lua_State *L) {
  if (lua_isnoneornil(L, 2)) {  /* standard conversion? */
    luaL_checkany(L, 1);
    if (lua_type(L, 1) == LUA_TNUMBER) {  /* already a number? */
      lua_settop(L, 1);  /* yes; return it */
      return 1;
    }
    else {
      size_t l;
      const char *s = lua_tolstring(L, 1, &l);
      if (s != NULL && lua_stringtonumber(L, s) == l + 1)
        return 1;  /* successful conversion to number */
      /* else not a number */
    }
  }
  else {
    size_t l;
    const char *s;
    lua_Integer n = 0;  /* to avoid warnings */
    lua_Integer base = luaL_checkinteger(L, 2);
    luaL_checktype(L, 1, LUA_TSTRING);  /* no numbers as strings */
    s = lua_tolstring(L, 1, &l);
    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
    if (b_str2int(s, (int)base, &n) == s + l) {
      lua_pushinteger(L, n);
      return 1;
    }  /* else not a number */
  }  /* else not a number */
  lua_pushnil(L);  /* not a number */
  return 1;
}


static int luaB_error (lua_State *L) {
  int level = (int)luaL_optinteger(L, 2, 1);
  lua_settop(L, 1);
  if (lua_type(L, 1) == LUA_TSTRING && level > 0) {
    luaL_where(L, level);   /* add extra information */
    lua_pushvalue(L, 1);
    lua_concat(L, 2);
  }
  return lua_error(L);
}


static int luaB_getmetatable (lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);
    return 1;  /* no metatable */
  }
  luaL_getmetafield(L, 1, "__metatable");
  return 1;  /* returns either __metatable field (if present) or metatable */
}


static int luaB_setmetatable (lua_State *L) {
  int t = lua_type(L, 2);
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
                    "nil or table expected");
  if (luaL_getmetafield(L, 1, "__metatable") != LUA_TNIL)
    return luaL_error(L, "cannot change a protected metatable");
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1;
}


static int luaB_rawequal (lua_State *L) {
  luaL_checkany(L, 1);
  luaL_checkany(L, 2);
  lua_pushboolean(L, lua_rawequal(L, 1, 2));
  return 1;
}


static int luaB_rawlen (lua_State *L) {
  int t = lua_type(L, 1);
  luaL_argcheck(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,
                   "table or string expected");
  lua_pushinteger(L, lua_rawlen(L, 1));
  return 1;
}


static int luaB_rawget (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_rawget(L, 1);
  return 1;
}

static int luaB_rawset (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  luaL_checkany(L, 2);
  luaL_checkany(L, 3);
  lua_settop(L, 3);
  lua_rawset(L, 1);
  return 1;
}


static int luaB_collectgarbage (lua_State *L) {
  static const char *const opts[] = {"stop", "restart", "collect",
    "count", "step", "setpause", "setstepmul",
    "isrunning", NULL};
  static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,
    LUA_GCISRUNNING};
  int o = optsnum[luaL_checkoption(L, 1, "collect", opts)];
  int ex = (int)luaL_optinteger(L, 2, 0);
  int res = lua_gc(L, o, ex);
  switch (o) {
    case LUA_GCCOUNT: {
      int b = lua_gc(L, LUA_GCCOUNTB, 0);
      lua_pushnumber(L, (lua_Number)res + ((lua_Number)b/1024));
      return 1;
    }
    case LUA_GCSTEP: case LUA_GCISRUNNING: {
      lua_pushboolean(L, res);
      return 1;
    }
    default: {
      lua_pushinteger(L, res);
      return 1;
    }
  }
}


static int luaB_type (lua_State *L) {
  int t = lua_type(L, 1);
  luaL_argcheck(L, t != LUA_TNONE, 1, "value expected");
  lua_pushstring(L, lua_typename(L, t));
  return 1;
}


static int pairsmeta (lua_State *L, const char *method, int iszero,
                      lua_CFunction iter) {
  luaL_checkany(L, 1);
  if (luaL_getmetafield(L, 1, method) == LUA_TNIL) {  /* no metamethod? */
    lua_pushcfunction(L, iter);  /* will return generator, */
    lua_pushvalue(L, 1);  /* state, */
    if (iszero) lua_pushinteger(L, 0);  /* and initial value */
    else lua_pushnil(L);
  }
  else {
    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */
    lua_call(L, 1, 3);  /* get 3 values from metamethod */
  }
  return 3;
}


static int luaB_next (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
  if (lua_next(L, 1))
    return 2;
  else {
    lua_pushnil(L);
    return 1;
  }
}


static int luaB_pairs (lua_State *L) {
  return pairsmeta(L, "__pairs", 0, luaB_next);
}


/*
** Traversal function for 'ipairs'
*/
static int ipairsaux (lua_State *L) {
  lua_Integer i = luaL_checkinteger(L, 2) + 1;
  lua_pushinteger(L, i);
  return (lua_geti(L, 1, i) == LUA_TNIL) ? 1 : 2;
}


/*
** 'ipairs' function. Returns 'ipairsaux', given "table", 0.
** (The given "table" may not be a table.)
*/
static int luaB_ipairs (lua_State *L) {
#if defined(LUA_COMPAT_IPAIRS)
  return pairsmeta(L, "__ipairs", 1, ipairsaux);
#else
  luaL_checkany(L, 1);
  lua_pushcfunction(L, ipairsaux);  /* iteration function */
  lua_pushvalue(L, 1);  /* state */
  lua_pushinteger(L, 0);  /* initial value */
  return 3;
#endif
}


static int load_aux (lua_State *L, int status, int envidx) {
  if (status == LUA_OK) {
    if (envidx != 0) {  /* 'env' parameter? */
      lua_pushvalue(L, envidx);  /* environment for loaded function */
      if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */
        lua_pop(L, 1);  /* remove 'env' if not used by previous call */
    }
    return 1;
  }
  else {  /* error (message is on top of the stack) */
    lua_pushnil(L);
    lua_insert(L, -2);  /* put before error message */
    return 2;  /* return nil plus error message */
  }
}


static int luaB_loadfile (lua_State *L) {
  const char *fname = luaL_optstring(L, 1, NULL);
  const char *mode = luaL_optstring(L, 2, NULL);
  int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */
  int status = luaL_loadfilex(L, fname, mode);
  return load_aux(L, status, env);
}


/*
** {======================================================
** Generic Read function
** =======================================================
*/


/*
** reserved slot, above all arguments, to hold a copy of the returned
** string to avoid it being collected while parsed. 'load' has four
** optional arguments (chunk, source name, mode, and environment).
*/
#define RESERVEDSLOT	5


/*
** Reader for generic 'load' function: 'lua_load' uses the
** stack for internal stuff, so the reader cannot change the
** stack top. Instead, it keeps its resulting string in a
** reserved slot inside the stack.
*/
static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
  (void)(ud);  /* not used */
  luaL_checkstack(L, 2, "too many nested functions");
  lua_pushvalue(L, 1);  /* get function */
  lua_call(L, 0, 1);  /* call it */
  if (lua_isnil(L, -1)) {
    lua_pop(L, 1);  /* pop result */
    *size = 0;
    return NULL;
  }
  else if (!lua_isstring(L, -1))
    luaL_error(L, "reader function must return a string");
  lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */
  return lua_tolstring(L, RESERVEDSLOT, size);
}


static int luaB_load (lua_State *L) {
  int status;
  size_t l;
  const char *s = lua_tolstring(L, 1, &l);
  const char *mode = luaL_optstring(L, 3, "bt");
  int env = (!lua_isnone(L, 4) ? 4 : 0);  /* 'env' index or 0 if no 'env' */
  if (s != NULL) {  /* loading a string? */
    const char *chunkname = luaL_optstring(L, 2, s);
    status = luaL_loadbufferx(L, s, l, chunkname, mode);
  }
  else {  /* loading from a reader function */
    const char *chunkname = luaL_optstring(L, 2, "=(load)");
    luaL_checktype(L, 1, LUA_TFUNCTION);
    lua_settop(L, RESERVEDSLOT);  /* create reserved slot */
    status = lua_load(L, generic_reader, NULL, chunkname, mode);
  }
  return load_aux(L, status, env);
}

/* }====================================================== */


static int dofilecont (lua_State *L, int d1, lua_KContext d2) {
  (void)d1;  (void)d2;  /* only to match 'lua_Kfunction' prototype */
  return lua_gettop(L) - 1;
}


static int luaB_dofile (lua_State *L) {
  const char *fname = luaL_optstring(L, 1, NULL);
  lua_settop(L, 1);
  if (luaL_loadfile(L, fname) != LUA_OK)
    return lua_error(L);
  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
  return dofilecont(L, 0, 0);
}


static int luaB_assert (lua_State *L) {
  if (lua_toboolean(L, 1))  /* condition is true? */
    return lua_gettop(L);  /* return all arguments */
  else {  /* error */
    luaL_checkany(L, 1);  /* there must be a condition */
    lua_remove(L, 1);  /* remove it */
    lua_pushliteral(L, "assertion failed!");  /* default message */
    lua_settop(L, 1);  /* leave only message (default if no other one) */
    return luaB_error(L);  /* call 'error' */
  }
}


static int luaB_select (lua_State *L) {
  int n = lua_gettop(L);
  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
    lua_pushinteger(L, n-1);
    return 1;
  }
  else {
    lua_Integer i = luaL_checkinteger(L, 1);
    if (i < 0) i = n + i;
    else if (i > n) i = n;
    luaL_argcheck(L, 1 <= i, 1, "index out of range");
    return n - (int)i;
  }
}


/*
** Continuation function for 'pcall' and 'xpcall'. Both functions
** already pushed a 'true' before doing the call, so in case of success
** 'finishpcall' only has to return everything in the stack minus
** 'extra' values (where 'extra' is exactly the number of items to be
** ignored).
*/
static int finishpcall (lua_State *L, int status, lua_KContext extra) {
  if (status != LUA_OK && status != LUA_YIELD) {  /* error? */
    lua_pushboolean(L, 0);  /* first result (false) */
    lua_pushvalue(L, -2);  /* error message */
    return 2;  /* return false, msg */
  }
  else
    return lua_gettop(L) - (int)extra;  /* return all results */
}


static int luaB_pcall (lua_State *L) {
  int status;
  luaL_checkany(L, 1);
  lua_pushboolean(L, 1);  /* first result if no errors */
  lua_insert(L, 1);  /* put it in place */
  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);
  return finishpcall(L, status, 0);
}


/*
** Do a protected call with error handling. After 'lua_rotate', the
** stack will have <f, err, true, f, [args...]>; so, the function passes
** 2 to 'finishpcall' to skip the 2 first values when returning results.
*/
static int luaB_xpcall (lua_State *L) {
  int status;
  int n = lua_gettop(L);
  luaL_checktype(L, 2, LUA_TFUNCTION);  /* check error function */
  lua_pushboolean(L, 1);  /* first result */
  lua_pushvalue(L, 1);  /* function */
  lua_rotate(L, 3, 2);  /* move them below function's arguments */
  status = lua_pcallk(L, n - 2, LUA_MULTRET, 2, 2, finishpcall);
  return finishpcall(L, status, 2);
}


static int luaB_tostring (lua_State *L) {
  luaL_checkany(L, 1);
  luaL_tolstring(L, 1, NULL);
  return 1;
}


static const luaL_Reg base_funcs[] = {
  {"assert", luaB_assert},
  {"collectgarbage", luaB_collectgarbage},
  {"dofile", luaB_dofile},
  {"error", luaB_error},
  {"getmetatable", luaB_getmetatable},
  {"ipairs", luaB_ipairs},
  {"loadfile", luaB_loadfile},
  {"load", luaB_load},
#if defined(LUA_COMPAT_LOADSTRING)
  {"loadstring", luaB_load},
#endif
  {"next", luaB_next},
  {"pairs", luaB_pairs},
  {"pcall", luaB_pcall},
  {"print", luaB_print},
  {"rawequal", luaB_rawequal},
  {"rawlen", luaB_rawlen},
  {"rawget", luaB_rawget},
  {"rawset", luaB_rawset},
  {"select", luaB_select},
  {"setmetatable", luaB_setmetatable},
  {"tonumber", luaB_tonumber},
  {"tostring", luaB_tostring},
  {"type", luaB_type},
  {"xpcall", luaB_xpcall},
  /* placeholders */
  {"_G", NULL},
  {"_VERSION", NULL},
  {NULL, NULL}
};


LUAMOD_API int luaopen_base (lua_State *L) {
  /* open lib into global table */
  lua_pushglobaltable(L);
  luaL_setfuncs(L, base_funcs, 0);
  /* set global _G */
  lua_pushvalue(L, -1);
  lua_setfield(L, -2, "_G");
  /* set global _VERSION */
  lua_pushliteral(L, LUA_VERSION);
  lua_setfield(L, -2, "_VERSION");
  return 1;
}


```

`src/Lua/lbitlib.c`:

```c
/*
** $Id: lbitlib.c,v 1.30 2015/11/11 19:08:09 roberto Exp $
** Standard library for bitwise operations
** See Copyright Notice in lua.h
*/

#define lbitlib_c
#define LUA_LIB

#include "lprefix.h"


#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


#if defined(LUA_COMPAT_BITLIB)		/* { */


#define pushunsigned(L,n)	lua_pushinteger(L, (lua_Integer)(n))
#define checkunsigned(L,i)	((lua_Unsigned)luaL_checkinteger(L,i))


/* number of bits to consider in a number */
#if !defined(LUA_NBITS)
#define LUA_NBITS	32
#endif


/*
** a lua_Unsigned with its first LUA_NBITS bits equal to 1. (Shift must
** be made in two parts to avoid problems when LUA_NBITS is equal to the
** number of bits in a lua_Unsigned.)
*/
#define ALLONES		(~(((~(lua_Unsigned)0) << (LUA_NBITS - 1)) << 1))


/* macro to trim extra bits */
#define trim(x)		((x) & ALLONES)


/* builds a number with 'n' ones (1 <= n <= LUA_NBITS) */
#define mask(n)		(~((ALLONES << 1) << ((n) - 1)))



static lua_Unsigned andaux (lua_State *L) {
  int i, n = lua_gettop(L);
  lua_Unsigned r = ~(lua_Unsigned)0;
  for (i = 1; i <= n; i++)
    r &= checkunsigned(L, i);
  return trim(r);
}


static int b_and (lua_State *L) {
  lua_Unsigned r = andaux(L);
  pushunsigned(L, r);
  return 1;
}


static int b_test (lua_State *L) {
  lua_Unsigned r = andaux(L);
  lua_pushboolean(L, r != 0);
  return 1;
}


static int b_or (lua_State *L) {
  int i, n = lua_gettop(L);
  lua_Unsigned r = 0;
  for (i = 1; i <= n; i++)
    r |= checkunsigned(L, i);
  pushunsigned(L, trim(r));
  return 1;
}


static int b_xor (lua_State *L) {
  int i, n = lua_gettop(L);
  lua_Unsigned r = 0;
  for (i = 1; i <= n; i++)
    r ^= checkunsigned(L, i);
  pushunsigned(L, trim(r));
  return 1;
}


static int b_not (lua_State *L) {
  lua_Unsigned r = ~checkunsigned(L, 1);
  pushunsigned(L, trim(r));
  return 1;
}


static int b_shift (lua_State *L, lua_Unsigned r, lua_Integer i) {
  if (i < 0) {  /* shift right? */
    i = -i;
    r = trim(r);
    if (i >= LUA_NBITS) r = 0;
    else r >>= i;
  }
  else {  /* shift left */
    if (i >= LUA_NBITS) r = 0;
    else r <<= i;
    r = trim(r);
  }
  pushunsigned(L, r);
  return 1;
}


static int b_lshift (lua_State *L) {
  return b_shift(L, checkunsigned(L, 1), luaL_checkinteger(L, 2));
}


static int b_rshift (lua_State *L) {
  return b_shift(L, checkunsigned(L, 1), -luaL_checkinteger(L, 2));
}


static int b_arshift (lua_State *L) {
  lua_Unsigned r = checkunsigned(L, 1);
  lua_Integer i = luaL_checkinteger(L, 2);
  if (i < 0 || !(r & ((lua_Unsigned)1 << (LUA_NBITS - 1))))
    return b_shift(L, r, -i);
  else {  /* arithmetic shift for 'negative' number */
    if (i >= LUA_NBITS) r = ALLONES;
    else
      r = trim((r >> i) | ~(trim(~(lua_Unsigned)0) >> i));  /* add signal bit */
    pushunsigned(L, r);
    return 1;
  }
}


static int b_rot (lua_State *L, lua_Integer d) {
  lua_Unsigned r = checkunsigned(L, 1);
  int i = d & (LUA_NBITS - 1);  /* i = d % NBITS */
  r = trim(r);
  if (i != 0)  /* avoid undefined shift of LUA_NBITS when i == 0 */
    r = (r << i) | (r >> (LUA_NBITS - i));
  pushunsigned(L, trim(r));
  return 1;
}


static int b_lrot (lua_State *L) {
  return b_rot(L, luaL_checkinteger(L, 2));
}


static int b_rrot (lua_State *L) {
  return b_rot(L, -luaL_checkinteger(L, 2));
}


/*
** get field and width arguments for field-manipulation functions,
** checking whether they are valid.
** ('luaL_error' called without 'return' to avoid later warnings about
** 'width' being used uninitialized.)
*/
static int fieldargs (lua_State *L, int farg, int *width) {
  lua_Integer f = luaL_checkinteger(L, farg);
  lua_Integer w = luaL_optinteger(L, farg + 1, 1);
  luaL_argcheck(L, 0 <= f, farg, "field cannot be negative");
  luaL_argcheck(L, 0 < w, farg + 1, "width must be positive");
  if (f + w > LUA_NBITS)
    luaL_error(L, "trying to access non-existent bits");
  *width = (int)w;
  return (int)f;
}


static int b_extract (lua_State *L) {
  int w;
  lua_Unsigned r = trim(checkunsigned(L, 1));
  int f = fieldargs(L, 2, &w);
  r = (r >> f) & mask(w);
  pushunsigned(L, r);
  return 1;
}


static int b_replace (lua_State *L) {
  int w;
  lua_Unsigned r = trim(checkunsigned(L, 1));
  lua_Unsigned v = trim(checkunsigned(L, 2));
  int f = fieldargs(L, 3, &w);
  lua_Unsigned m = mask(w);
  r = (r & ~(m << f)) | ((v & m) << f);
  pushunsigned(L, r);
  return 1;
}


static const luaL_Reg bitlib[] = {
  {"arshift", b_arshift},
  {"band", b_and},
  {"bnot", b_not},
  {"bor", b_or},
  {"bxor", b_xor},
  {"btest", b_test},
  {"extract", b_extract},
  {"lrotate", b_lrot},
  {"lshift", b_lshift},
  {"replace", b_replace},
  {"rrotate", b_rrot},
  {"rshift", b_rshift},
  {NULL, NULL}
};



LUAMOD_API int luaopen_bit32 (lua_State *L) {
  luaL_newlib(L, bitlib);
  return 1;
}


#else					/* }{ */


LUAMOD_API int luaopen_bit32 (lua_State *L) {
  return luaL_error(L, "library 'bit32' has been deprecated");
}

#endif					/* } */

```

`src/Lua/lcode.c`:

```c
/*
** $Id: lcode.c,v 2.112 2016/12/22 13:08:50 roberto Exp $
** Code generator for Lua
** See Copyright Notice in lua.h
*/

#define lcode_c
#define LUA_CORE

#include "lprefix.h"


#include <math.h>
#include <stdlib.h>

#include "lua.h"

#include "lcode.h"
#include "ldebug.h"
#include "ldo.h"
#include "lgc.h"
#include "llex.h"
#include "lmem.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lparser.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"


/* Maximum number of registers in a Lua function (must fit in 8 bits) */
#define MAXREGS		255


#define hasjumps(e)	((e)->t != (e)->f)


/*
** If expression is a numeric constant, fills 'v' with its value
** and returns 1. Otherwise, returns 0.
*/
static int tonumeral(const expdesc *e, TValue *v) {
  if (hasjumps(e))
    return 0;  /* not a numeral */
  switch (e->k) {
    case VKINT:
      if (v) setivalue(v, e->u.ival);
      return 1;
    case VKFLT:
      if (v) setfltvalue(v, e->u.nval);
      return 1;
    default: return 0;
  }
}


/*
** Create a OP_LOADNIL instruction, but try to optimize: if the previous
** instruction is also OP_LOADNIL and ranges are compatible, adjust
** range of previous instruction instead of emitting a new one. (For
** instance, 'local a; local b' will generate a single opcode.)
*/
void luaK_nil (FuncState *fs, int from, int n) {
  Instruction *previous;
  int l = from + n - 1;  /* last register to set nil */
  if (fs->pc > fs->lasttarget) {  /* no jumps to current position? */
    previous = &fs->f->code[fs->pc-1];
    if (GET_OPCODE(*previous) == OP_LOADNIL) {  /* previous is LOADNIL? */
      int pfrom = GETARG_A(*previous);  /* get previous range */
      int pl = pfrom + GETARG_B(*previous);
      if ((pfrom <= from && from <= pl + 1) ||
          (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */
        if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */
        if (pl > l) l = pl;  /* l = max(l, pl) */
        SETARG_A(*previous, from);
        SETARG_B(*previous, l - from);
        return;
      }
    }  /* else go through */
  }
  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */
}


/*
** Gets the destination address of a jump instruction. Used to traverse
** a list of jumps.
*/
static int getjump (FuncState *fs, int pc) {
  int offset = GETARG_sBx(fs->f->code[pc]);
  if (offset == NO_JUMP)  /* point to itself represents end of list */
    return NO_JUMP;  /* end of list */
  else
    return (pc+1)+offset;  /* turn offset into absolute position */
}


/*
** Fix jump instruction at position 'pc' to jump to 'dest'.
** (Jump addresses are relative in Lua)
*/
static void fixjump (FuncState *fs, int pc, int dest) {
  Instruction *jmp = &fs->f->code[pc];
  int offset = dest - (pc + 1);
  lua_assert(dest != NO_JUMP);
  if (abs(offset) > MAXARG_sBx)
    luaX_syntaxerror(fs->ls, "control structure too long");
  SETARG_sBx(*jmp, offset);
}


/*
** Concatenate jump-list 'l2' into jump-list 'l1'
*/
void luaK_concat (FuncState *fs, int *l1, int l2) {
  if (l2 == NO_JUMP) return;  /* nothing to concatenate? */
  else if (*l1 == NO_JUMP)  /* no original list? */
    *l1 = l2;  /* 'l1' points to 'l2' */
  else {
    int list = *l1;
    int next;
    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */
      list = next;
    fixjump(fs, list, l2);  /* last element links to 'l2' */
  }
}


/*
** Create a jump instruction and return its position, so its destination
** can be fixed later (with 'fixjump'). If there are jumps to
** this position (kept in 'jpc'), link them all together so that
** 'patchlistaux' will fix all them directly to the final destination.
*/
int luaK_jump (FuncState *fs) {
  int jpc = fs->jpc;  /* save list of jumps to here */
  int j;
  fs->jpc = NO_JUMP;  /* no more jumps to here */
  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
  luaK_concat(fs, &j, jpc);  /* keep them on hold */
  return j;
}


/*
** Code a 'return' instruction
*/
void luaK_ret (FuncState *fs, int first, int nret) {
  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
}


/*
** Code a "conditional jump", that is, a test or comparison opcode
** followed by a jump. Return jump position.
*/
static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {
  luaK_codeABC(fs, op, A, B, C);
  return luaK_jump(fs);
}


/*
** returns current 'pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
*/
int luaK_getlabel (FuncState *fs) {
  fs->lasttarget = fs->pc;
  return fs->pc;
}


/*
** Returns the position of the instruction "controlling" a given
** jump (that is, its condition), or the jump itself if it is
** unconditional.
*/
static Instruction *getjumpcontrol (FuncState *fs, int pc) {
  Instruction *pi = &fs->f->code[pc];
  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))
    return pi-1;
  else
    return pi;
}


/*
** Patch destination register for a TESTSET instruction.
** If instruction in position 'node' is not a TESTSET, return 0 ("fails").
** Otherwise, if 'reg' is not 'NO_REG', set it as the destination
** register. Otherwise, change instruction to a simple 'TEST' (produces
** no register value)
*/
static int patchtestreg (FuncState *fs, int node, int reg) {
  Instruction *i = getjumpcontrol(fs, node);
  if (GET_OPCODE(*i) != OP_TESTSET)
    return 0;  /* cannot patch other instructions */
  if (reg != NO_REG && reg != GETARG_B(*i))
    SETARG_A(*i, reg);
  else {
     /* no register to put value or register already has the value;
        change instruction to simple test */
    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
  }
  return 1;
}


/*
** Traverse a list of tests ensuring no one produces a value
*/
static void removevalues (FuncState *fs, int list) {
  for (; list != NO_JUMP; list = getjump(fs, list))
      patchtestreg(fs, list, NO_REG);
}


/*
** Traverse a list of tests, patching their destination address and
** registers: tests producing values jump to 'vtarget' (and put their
** values in 'reg'), other tests jump to 'dtarget'.
*/
static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
                          int dtarget) {
  while (list != NO_JUMP) {
    int next = getjump(fs, list);
    if (patchtestreg(fs, list, reg))
      fixjump(fs, list, vtarget);
    else
      fixjump(fs, list, dtarget);  /* jump to default target */
    list = next;
  }
}


/*
** Ensure all pending jumps to current position are fixed (jumping
** to current position with no values) and reset list of pending
** jumps
*/
static void dischargejpc (FuncState *fs) {
  patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc);
  fs->jpc = NO_JUMP;
}


/*
** Add elements in 'list' to list of pending jumps to "here"
** (current position)
*/
void luaK_patchtohere (FuncState *fs, int list) {
  luaK_getlabel(fs);  /* mark "here" as a jump target */
  luaK_concat(fs, &fs->jpc, list);
}


/*
** Path all jumps in 'list' to jump to 'target'.
** (The assert means that we cannot fix a jump to a forward address
** because we only know addresses once code is generated.)
*/
void luaK_patchlist (FuncState *fs, int list, int target) {
  if (target == fs->pc)  /* 'target' is current position? */
    luaK_patchtohere(fs, list);  /* add list to pending jumps */
  else {
    lua_assert(target < fs->pc);
    patchlistaux(fs, list, target, NO_REG, target);
  }
}


/*
** Path all jumps in 'list' to close upvalues up to given 'level'
** (The assertion checks that jumps either were closing nothing
** or were closing higher levels, from inner blocks.)
*/
void luaK_patchclose (FuncState *fs, int list, int level) {
  level++;  /* argument is +1 to reserve 0 as non-op */
  for (; list != NO_JUMP; list = getjump(fs, list)) {
    lua_assert(GET_OPCODE(fs->f->code[list]) == OP_JMP &&
                (GETARG_A(fs->f->code[list]) == 0 ||
                 GETARG_A(fs->f->code[list]) >= level));
    SETARG_A(fs->f->code[list], level);
  }
}


/*
** Emit instruction 'i', checking for array sizes and saving also its
** line information. Return 'i' position.
*/
static int luaK_code (FuncState *fs, Instruction i) {
  Proto *f = fs->f;
  dischargejpc(fs);  /* 'pc' will change */
  /* put new instruction in code array */
  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
                  MAX_INT, "opcodes");
  f->code[fs->pc] = i;
  /* save corresponding line information */
  luaM_growvector(fs->ls->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
                  MAX_INT, "opcodes");
  f->lineinfo[fs->pc] = fs->ls->lastline;
  return fs->pc++;
}


/*
** Format and emit an 'iABC' instruction. (Assertions check consistency
** of parameters versus opcode.)
*/
int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
  lua_assert(getOpMode(o) == iABC);
  lua_assert(getBMode(o) != OpArgN || b == 0);
  lua_assert(getCMode(o) != OpArgN || c == 0);
  lua_assert(a <= MAXARG_A && b <= MAXARG_B && c <= MAXARG_C);
  return luaK_code(fs, CREATE_ABC(o, a, b, c));
}


/*
** Format and emit an 'iABx' instruction.
*/
int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
  lua_assert(getCMode(o) == OpArgN);
  lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);
  return luaK_code(fs, CREATE_ABx(o, a, bc));
}


/*
** Emit an "extra argument" instruction (format 'iAx')
*/
static int codeextraarg (FuncState *fs, int a) {
  lua_assert(a <= MAXARG_Ax);
  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));
}


/*
** Emit a "load constant" instruction, using either 'OP_LOADK'
** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'
** instruction with "extra argument".
*/
int luaK_codek (FuncState *fs, int reg, int k) {
  if (k <= MAXARG_Bx)
    return luaK_codeABx(fs, OP_LOADK, reg, k);
  else {
    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);
    codeextraarg(fs, k);
    return p;
  }
}


/*
** Check register-stack level, keeping track of its maximum size
** in field 'maxstacksize'
*/
void luaK_checkstack (FuncState *fs, int n) {
  int newstack = fs->freereg + n;
  if (newstack > fs->f->maxstacksize) {
    if (newstack >= MAXREGS)
      luaX_syntaxerror(fs->ls,
        "function or expression needs too many registers");
    fs->f->maxstacksize = cast_byte(newstack);
  }
}


/*
** Reserve 'n' registers in register stack
*/
void luaK_reserveregs (FuncState *fs, int n) {
  luaK_checkstack(fs, n);
  fs->freereg += n;
}


/*
** Free register 'reg', if it is neither a constant index nor
** a local variable.
)
*/
static void freereg (FuncState *fs, int reg) {
  if (!ISK(reg) && reg >= fs->nactvar) {
    fs->freereg--;
    lua_assert(reg == fs->freereg);
  }
}


/*
** Free register used by expression 'e' (if any)
*/
static void freeexp (FuncState *fs, expdesc *e) {
  if (e->k == VNONRELOC)
    freereg(fs, e->u.info);
}


/*
** Free registers used by expressions 'e1' and 'e2' (if any) in proper
** order.
*/
static void freeexps (FuncState *fs, expdesc *e1, expdesc *e2) {
  int r1 = (e1->k == VNONRELOC) ? e1->u.info : -1;
  int r2 = (e2->k == VNONRELOC) ? e2->u.info : -1;
  if (r1 > r2) {
    freereg(fs, r1);
    freereg(fs, r2);
  }
  else {
    freereg(fs, r2);
    freereg(fs, r1);
  }
}


/*
** Add constant 'v' to prototype's list of constants (field 'k').
** Use scanner's table to cache position of constants in constant list
** and try to reuse constants. Because some values should not be used
** as keys (nil cannot be a key, integer keys can collapse with float
** keys), the caller must provide a useful 'key' for indexing the cache.
*/
static int addk (FuncState *fs, TValue *key, TValue *v) {
  lua_State *L = fs->ls->L;
  Proto *f = fs->f;
  TValue *idx = luaH_set(L, fs->ls->h, key);  /* index scanner table */
  int k, oldsize;
  if (ttisinteger(idx)) {  /* is there an index there? */
    k = cast_int(ivalue(idx));
    /* correct value? (warning: must distinguish floats from integers!) */
    if (k < fs->nk && ttype(&f->k[k]) == ttype(v) &&
                      luaV_rawequalobj(&f->k[k], v))
      return k;  /* reuse index */
  }
  /* constant not found; create a new entry */
  oldsize = f->sizek;
  k = fs->nk;
  /* numerical value does not need GC barrier;
     table has no metatable, so it does not need to invalidate cache */
  setivalue(idx, k);
  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
  setobj(L, &f->k[k], v);
  fs->nk++;
  luaC_barrier(L, f, v);
  return k;
}


/*
** Add a string to list of constants and return its index.
*/
int luaK_stringK (FuncState *fs, TString *s) {
  TValue o;
  setsvalue(fs->ls->L, &o, s);
  return addk(fs, &o, &o);  /* use string itself as key */
}


/*
** Add an integer to list of constants and return its index.
** Integers use userdata as keys to avoid collision with floats with
** same value; conversion to 'void*' is used only for hashing, so there
** are no "precision" problems.
*/
int luaK_intK (FuncState *fs, lua_Integer n) {
  TValue k, o;
  setpvalue(&k, cast(void*, cast(size_t, n)));
  setivalue(&o, n);
  return addk(fs, &k, &o);
}

/*
** Add a float to list of constants and return its index.
*/
static int luaK_numberK (FuncState *fs, lua_Number r) {
  TValue o;
  setfltvalue(&o, r);
  return addk(fs, &o, &o);  /* use number itself as key */
}


/*
** Add a boolean to list of constants and return its index.
*/
static int boolK (FuncState *fs, int b) {
  TValue o;
  setbvalue(&o, b);
  return addk(fs, &o, &o);  /* use boolean itself as key */
}


/*
** Add nil to list of constants and return its index.
*/
static int nilK (FuncState *fs) {
  TValue k, v;
  setnilvalue(&v);
  /* cannot use nil as key; instead use table itself to represent nil */
  sethvalue(fs->ls->L, &k, fs->ls->h);
  return addk(fs, &k, &v);
}


/*
** Fix an expression to return the number of results 'nresults'.
** Either 'e' is a multi-ret expression (function call or vararg)
** or 'nresults' is LUA_MULTRET (as any expression can satisfy that).
*/
void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
  if (e->k == VCALL) {  /* expression is an open function call? */
    SETARG_C(getinstruction(fs, e), nresults + 1);
  }
  else if (e->k == VVARARG) {
    Instruction *pc = &getinstruction(fs, e);
    SETARG_B(*pc, nresults + 1);
    SETARG_A(*pc, fs->freereg);
    luaK_reserveregs(fs, 1);
  }
  else lua_assert(nresults == LUA_MULTRET);
}


/*
** Fix an expression to return one result.
** If expression is not a multi-ret expression (function call or
** vararg), it already returns one result, so nothing needs to be done.
** Function calls become VNONRELOC expressions (as its result comes
** fixed in the base register of the call), while vararg expressions
** become VRELOCABLE (as OP_VARARG puts its results where it wants).
** (Calls are created returning one result, so that does not need
** to be fixed.)
*/
void luaK_setoneret (FuncState *fs, expdesc *e) {
  if (e->k == VCALL) {  /* expression is an open function call? */
    /* already returns 1 value */
    lua_assert(GETARG_C(getinstruction(fs, e)) == 2);
    e->k = VNONRELOC;  /* result has fixed position */
    e->u.info = GETARG_A(getinstruction(fs, e));
  }
  else if (e->k == VVARARG) {
    SETARG_B(getinstruction(fs, e), 2);
    e->k = VRELOCABLE;  /* can relocate its simple result */
  }
}


/*
** Ensure that expression 'e' is not a variable.
*/
void luaK_dischargevars (FuncState *fs, expdesc *e) {
  switch (e->k) {
    case VLOCAL: {  /* already in a register */
      e->k = VNONRELOC;  /* becomes a non-relocatable value */
      break;
    }
    case VUPVAL: {  /* move value to some (pending) register */
      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);
      e->k = VRELOCABLE;
      break;
    }
    case VINDEXED: {
      OpCode op;
      freereg(fs, e->u.ind.idx);
      if (e->u.ind.vt == VLOCAL) {  /* is 't' in a register? */
        freereg(fs, e->u.ind.t);
        op = OP_GETTABLE;
      }
      else {
        lua_assert(e->u.ind.vt == VUPVAL);
        op = OP_GETTABUP;  /* 't' is in an upvalue */
      }
      e->u.info = luaK_codeABC(fs, op, 0, e->u.ind.t, e->u.ind.idx);
      e->k = VRELOCABLE;
      break;
    }
    case VVARARG: case VCALL: {
      luaK_setoneret(fs, e);
      break;
    }
    default: break;  /* there is one value available (somewhere) */
  }
}


/*
** Ensures expression value is in register 'reg' (and therefore
** 'e' will become a non-relocatable expression).
*/
static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
  luaK_dischargevars(fs, e);
  switch (e->k) {
    case VNIL: {
      luaK_nil(fs, reg, 1);
      break;
    }
    case VFALSE: case VTRUE: {
      luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);
      break;
    }
    case VK: {
      luaK_codek(fs, reg, e->u.info);
      break;
    }
    case VKFLT: {
      luaK_codek(fs, reg, luaK_numberK(fs, e->u.nval));
      break;
    }
    case VKINT: {
      luaK_codek(fs, reg, luaK_intK(fs, e->u.ival));
      break;
    }
    case VRELOCABLE: {
      Instruction *pc = &getinstruction(fs, e);
      SETARG_A(*pc, reg);  /* instruction will put result in 'reg' */
      break;
    }
    case VNONRELOC: {
      if (reg != e->u.info)
        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);
      break;
    }
    default: {
      lua_assert(e->k == VJMP);
      return;  /* nothing to do... */
    }
  }
  e->u.info = reg;
  e->k = VNONRELOC;
}


/*
** Ensures expression value is in any register.
*/
static void discharge2anyreg (FuncState *fs, expdesc *e) {
  if (e->k != VNONRELOC) {  /* no fixed register yet? */
    luaK_reserveregs(fs, 1);  /* get a register */
    discharge2reg(fs, e, fs->freereg-1);  /* put value there */
  }
}


static int code_loadbool (FuncState *fs, int A, int b, int jump) {
  luaK_getlabel(fs);  /* those instructions may be jump targets */
  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
}


/*
** check whether list has any jump that do not produce a value
** or produce an inverted value
*/
static int need_value (FuncState *fs, int list) {
  for (; list != NO_JUMP; list = getjump(fs, list)) {
    Instruction i = *getjumpcontrol(fs, list);
    if (GET_OPCODE(i) != OP_TESTSET) return 1;
  }
  return 0;  /* not found */
}


/*
** Ensures final expression result (including results from its jump
** lists) is in register 'reg'.
** If expression has jumps, need to patch these jumps either to
** its final position or to "load" instructions (for those tests
** that do not produce values).
*/
static void exp2reg (FuncState *fs, expdesc *e, int reg) {
  discharge2reg(fs, e, reg);
  if (e->k == VJMP)  /* expression itself is a test? */
    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in 't' list */
  if (hasjumps(e)) {
    int final;  /* position after whole expression */
    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
    if (need_value(fs, e->t) || need_value(fs, e->f)) {
      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);
      p_f = code_loadbool(fs, reg, 0, 1);
      p_t = code_loadbool(fs, reg, 1, 0);
      luaK_patchtohere(fs, fj);
    }
    final = luaK_getlabel(fs);
    patchlistaux(fs, e->f, final, reg, p_f);
    patchlistaux(fs, e->t, final, reg, p_t);
  }
  e->f = e->t = NO_JUMP;
  e->u.info = reg;
  e->k = VNONRELOC;
}


/*
** Ensures final expression result (including results from its jump
** lists) is in next available register.
*/
void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  freeexp(fs, e);
  luaK_reserveregs(fs, 1);
  exp2reg(fs, e, fs->freereg - 1);
}


/*
** Ensures final expression result (including results from its jump
** lists) is in some (any) register and return that register.
*/
int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  if (e->k == VNONRELOC) {  /* expression already has a register? */
    if (!hasjumps(e))  /* no jumps? */
      return e->u.info;  /* result is already in a register */
    if (e->u.info >= fs->nactvar) {  /* reg. is not a local? */
      exp2reg(fs, e, e->u.info);  /* put final result in it */
      return e->u.info;
    }
  }
  luaK_exp2nextreg(fs, e);  /* otherwise, use next available register */
  return e->u.info;
}


/*
** Ensures final expression result is either in a register or in an
** upvalue.
*/
void luaK_exp2anyregup (FuncState *fs, expdesc *e) {
  if (e->k != VUPVAL || hasjumps(e))
    luaK_exp2anyreg(fs, e);
}


/*
** Ensures final expression result is either in a register or it is
** a constant.
*/
void luaK_exp2val (FuncState *fs, expdesc *e) {
  if (hasjumps(e))
    luaK_exp2anyreg(fs, e);
  else
    luaK_dischargevars(fs, e);
}


/*
** Ensures final expression result is in a valid R/K index
** (that is, it is either in a register or in 'k' with an index
** in the range of R/K indices).
** Returns R/K index.
*/
int luaK_exp2RK (FuncState *fs, expdesc *e) {
  luaK_exp2val(fs, e);
  switch (e->k) {  /* move constants to 'k' */
    case VTRUE: e->u.info = boolK(fs, 1); goto vk;
    case VFALSE: e->u.info = boolK(fs, 0); goto vk;
    case VNIL: e->u.info = nilK(fs); goto vk;
    case VKINT: e->u.info = luaK_intK(fs, e->u.ival); goto vk;
    case VKFLT: e->u.info = luaK_numberK(fs, e->u.nval); goto vk;
    case VK:
     vk:
      e->k = VK;
      if (e->u.info <= MAXINDEXRK)  /* constant fits in 'argC'? */
        return RKASK(e->u.info);
      else break;
    default: break;
  }
  /* not a constant in the right range: put it in a register */
  return luaK_exp2anyreg(fs, e);
}


/*
** Generate code to store result of expression 'ex' into variable 'var'.
*/
void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
  switch (var->k) {
    case VLOCAL: {
      freeexp(fs, ex);
      exp2reg(fs, ex, var->u.info);  /* compute 'ex' into proper place */
      return;
    }
    case VUPVAL: {
      int e = luaK_exp2anyreg(fs, ex);
      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);
      break;
    }
    case VINDEXED: {
      OpCode op = (var->u.ind.vt == VLOCAL) ? OP_SETTABLE : OP_SETTABUP;
      int e = luaK_exp2RK(fs, ex);
      luaK_codeABC(fs, op, var->u.ind.t, var->u.ind.idx, e);
      break;
    }
    default: lua_assert(0);  /* invalid var kind to store */
  }
  freeexp(fs, ex);
}


/*
** Emit SELF instruction (convert expression 'e' into 'e:key(e,').
*/
void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
  int ereg;
  luaK_exp2anyreg(fs, e);
  ereg = e->u.info;  /* register where 'e' was placed */
  freeexp(fs, e);
  e->u.info = fs->freereg;  /* base register for op_self */
  e->k = VNONRELOC;  /* self expression has a fixed register */
  luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */
  luaK_codeABC(fs, OP_SELF, e->u.info, ereg, luaK_exp2RK(fs, key));
  freeexp(fs, key);
}


/*
** Negate condition 'e' (where 'e' is a comparison).
*/
static void negatecondition (FuncState *fs, expdesc *e) {
  Instruction *pc = getjumpcontrol(fs, e->u.info);
  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
                                           GET_OPCODE(*pc) != OP_TEST);
  SETARG_A(*pc, !(GETARG_A(*pc)));
}


/*
** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'
** is true, code will jump if 'e' is true.) Return jump position.
** Optimize when 'e' is 'not' something, inverting the condition
** and removing the 'not'.
*/
static int jumponcond (FuncState *fs, expdesc *e, int cond) {
  if (e->k == VRELOCABLE) {
    Instruction ie = getinstruction(fs, e);
    if (GET_OPCODE(ie) == OP_NOT) {
      fs->pc--;  /* remove previous OP_NOT */
      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, cond);
}


/*
** Emit code to go through if 'e' is true, jump otherwise.
*/
void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;  /* pc of new jump */
  luaK_dischargevars(fs, e);
  switch (e->k) {
    case VJMP: {  /* condition? */
      negatecondition(fs, e);  /* jump when it is false */
      pc = e->u.info;  /* save jump position */
      break;
    }
    case VK: case VKFLT: case VKINT: case VTRUE: {
      pc = NO_JUMP;  /* always true; do nothing */
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);  /* jump when false */
      break;
    }
  }
  luaK_concat(fs, &e->f, pc);  /* insert new jump in false list */
  luaK_patchtohere(fs, e->t);  /* true list jumps to here (to go through) */
  e->t = NO_JUMP;
}


/*
** Emit code to go through if 'e' is false, jump otherwise.
*/
void luaK_goiffalse (FuncState *fs, expdesc *e) {
  int pc;  /* pc of new jump */
  luaK_dischargevars(fs, e);
  switch (e->k) {
    case VJMP: {
      pc = e->u.info;  /* already jump if true */
      break;
    }
    case VNIL: case VFALSE: {
      pc = NO_JUMP;  /* always false; do nothing */
      break;
    }
    default: {
      pc = jumponcond(fs, e, 1);  /* jump if true */
      break;
    }
  }
  luaK_concat(fs, &e->t, pc);  /* insert new jump in 't' list */
  luaK_patchtohere(fs, e->f);  /* false list jumps to here (to go through) */
  e->f = NO_JUMP;
}


/*
** Code 'not e', doing constant folding.
*/
static void codenot (FuncState *fs, expdesc *e) {
  luaK_dischargevars(fs, e);
  switch (e->k) {
    case VNIL: case VFALSE: {
      e->k = VTRUE;  /* true == not nil == not false */
      break;
    }
    case VK: case VKFLT: case VKINT: case VTRUE: {
      e->k = VFALSE;  /* false == not "x" == not 0.5 == not 1 == not true */
      break;
    }
    case VJMP: {
      negatecondition(fs, e);
      break;
    }
    case VRELOCABLE:
    case VNONRELOC: {
      discharge2anyreg(fs, e);
      freeexp(fs, e);
      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);
      e->k = VRELOCABLE;
      break;
    }
    default: lua_assert(0);  /* cannot happen */
  }
  /* interchange true and false lists */
  { int temp = e->f; e->f = e->t; e->t = temp; }
  removevalues(fs, e->f);  /* values are useless when negated */
  removevalues(fs, e->t);
}


/*
** Create expression 't[k]'. 't' must have its final result already in a
** register or upvalue.
*/
void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
  lua_assert(!hasjumps(t) && (vkisinreg(t->k) || t->k == VUPVAL));
  t->u.ind.t = t->u.info;  /* register or upvalue index */
  t->u.ind.idx = luaK_exp2RK(fs, k);  /* R/K index for key */
  t->u.ind.vt = (t->k == VUPVAL) ? VUPVAL : VLOCAL;
  t->k = VINDEXED;
}


/*
** Return false if folding can raise an error.
** Bitwise operations need operands convertible to integers; division
** operations cannot have 0 as divisor.
*/
static int validop (int op, TValue *v1, TValue *v2) {
  switch (op) {
    case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:
    case LUA_OPSHL: case LUA_OPSHR: case LUA_OPBNOT: {  /* conversion errors */
      lua_Integer i;
      return (tointeger(v1, &i) && tointeger(v2, &i));
    }
    case LUA_OPDIV: case LUA_OPIDIV: case LUA_OPMOD:  /* division by 0 */
      return (nvalue(v2) != 0);
    default: return 1;  /* everything else is valid */
  }
}


/*
** Try to "constant-fold" an operation; return 1 iff successful.
** (In this case, 'e1' has the final result.)
*/
static int constfolding (FuncState *fs, int op, expdesc *e1,
                                                const expdesc *e2) {
  TValue v1, v2, res;
  if (!tonumeral(e1, &v1) || !tonumeral(e2, &v2) || !validop(op, &v1, &v2))
    return 0;  /* non-numeric operands or not safe to fold */
  luaO_arith(fs->ls->L, op, &v1, &v2, &res);  /* does operation */
  if (ttisinteger(&res)) {
    e1->k = VKINT;
    e1->u.ival = ivalue(&res);
  }
  else {  /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */
    lua_Number n = fltvalue(&res);
    if (luai_numisnan(n) || n == 0)
      return 0;
    e1->k = VKFLT;
    e1->u.nval = n;
  }
  return 1;
}


/*
** Emit code for unary expressions that "produce values"
** (everything but 'not').
** Expression to produce final result will be encoded in 'e'.
*/
static void codeunexpval (FuncState *fs, OpCode op, expdesc *e, int line) {
  int r = luaK_exp2anyreg(fs, e);  /* opcodes operate only on registers */
  freeexp(fs, e);
  e->u.info = luaK_codeABC(fs, op, 0, r, 0);  /* generate opcode */
  e->k = VRELOCABLE;  /* all those operations are relocatable */
  luaK_fixline(fs, line);
}


/*
** Emit code for binary expressions that "produce values"
** (everything but logical operators 'and'/'or' and comparison
** operators).
** Expression to produce final result will be encoded in 'e1'.
** Because 'luaK_exp2RK' can free registers, its calls must be
** in "stack order" (that is, first on 'e2', which may have more
** recent registers to be released).
*/
static void codebinexpval (FuncState *fs, OpCode op,
                           expdesc *e1, expdesc *e2, int line) {
  int rk2 = luaK_exp2RK(fs, e2);  /* both operands are "RK" */
  int rk1 = luaK_exp2RK(fs, e1);
  freeexps(fs, e1, e2);
  e1->u.info = luaK_codeABC(fs, op, 0, rk1, rk2);  /* generate opcode */
  e1->k = VRELOCABLE;  /* all those operations are relocatable */
  luaK_fixline(fs, line);
}


/*
** Emit code for comparisons.
** 'e1' was already put in R/K form by 'luaK_infix'.
*/
static void codecomp (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {
  int rk1 = (e1->k == VK) ? RKASK(e1->u.info)
                          : check_exp(e1->k == VNONRELOC, e1->u.info);
  int rk2 = luaK_exp2RK(fs, e2);
  freeexps(fs, e1, e2);
  switch (opr) {
    case OPR_NE: {  /* '(a ~= b)' ==> 'not (a == b)' */
      e1->u.info = condjump(fs, OP_EQ, 0, rk1, rk2);
      break;
    }
    case OPR_GT: case OPR_GE: {
      /* '(a > b)' ==> '(b < a)';  '(a >= b)' ==> '(b <= a)' */
      OpCode op = cast(OpCode, (opr - OPR_NE) + OP_EQ);
      e1->u.info = condjump(fs, op, 1, rk2, rk1);  /* invert operands */
      break;
    }
    default: {  /* '==', '<', '<=' use their own opcodes */
      OpCode op = cast(OpCode, (opr - OPR_EQ) + OP_EQ);
      e1->u.info = condjump(fs, op, 1, rk1, rk2);
      break;
    }
  }
  e1->k = VJMP;
}


/*
** Aplly prefix operation 'op' to expression 'e'.
*/
void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
  static const expdesc ef = {VKINT, {0}, NO_JUMP, NO_JUMP};
  switch (op) {
    case OPR_MINUS: case OPR_BNOT:  /* use 'ef' as fake 2nd operand */
      if (constfolding(fs, op + LUA_OPUNM, e, &ef))
        break;
      /* FALLTHROUGH */
    case OPR_LEN:
      codeunexpval(fs, cast(OpCode, op + OP_UNM), e, line);
      break;
    case OPR_NOT: codenot(fs, e); break;
    default: lua_assert(0);
  }
}


/*
** Process 1st operand 'v' of binary operation 'op' before reading
** 2nd operand.
*/
void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
  switch (op) {
    case OPR_AND: {
      luaK_goiftrue(fs, v);  /* go ahead only if 'v' is true */
      break;
    }
    case OPR_OR: {
      luaK_goiffalse(fs, v);  /* go ahead only if 'v' is false */
      break;
    }
    case OPR_CONCAT: {
      luaK_exp2nextreg(fs, v);  /* operand must be on the 'stack' */
      break;
    }
    case OPR_ADD: case OPR_SUB:
    case OPR_MUL: case OPR_DIV: case OPR_IDIV:
    case OPR_MOD: case OPR_POW:
    case OPR_BAND: case OPR_BOR: case OPR_BXOR:
    case OPR_SHL: case OPR_SHR: {
      if (!tonumeral(v, NULL))
        luaK_exp2RK(fs, v);
      /* else keep numeral, which may be folded with 2nd operand */
      break;
    }
    default: {
      luaK_exp2RK(fs, v);
      break;
    }
  }
}


/*
** Finalize code for binary operation, after reading 2nd operand.
** For '(a .. b .. c)' (which is '(a .. (b .. c))', because
** concatenation is right associative), merge second CONCAT into first
** one.
*/
void luaK_posfix (FuncState *fs, BinOpr op,
                  expdesc *e1, expdesc *e2, int line) {
  switch (op) {
    case OPR_AND: {
      lua_assert(e1->t == NO_JUMP);  /* list closed by 'luK_infix' */
      luaK_dischargevars(fs, e2);
      luaK_concat(fs, &e2->f, e1->f);
      *e1 = *e2;
      break;
    }
    case OPR_OR: {
      lua_assert(e1->f == NO_JUMP);  /* list closed by 'luK_infix' */
      luaK_dischargevars(fs, e2);
      luaK_concat(fs, &e2->t, e1->t);
      *e1 = *e2;
      break;
    }
    case OPR_CONCAT: {
      luaK_exp2val(fs, e2);
      if (e2->k == VRELOCABLE &&
          GET_OPCODE(getinstruction(fs, e2)) == OP_CONCAT) {
        lua_assert(e1->u.info == GETARG_B(getinstruction(fs, e2))-1);
        freeexp(fs, e1);
        SETARG_B(getinstruction(fs, e2), e1->u.info);
        e1->k = VRELOCABLE; e1->u.info = e2->u.info;
      }
      else {
        luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */
        codebinexpval(fs, OP_CONCAT, e1, e2, line);
      }
      break;
    }
    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
    case OPR_IDIV: case OPR_MOD: case OPR_POW:
    case OPR_BAND: case OPR_BOR: case OPR_BXOR:
    case OPR_SHL: case OPR_SHR: {
      if (!constfolding(fs, op + LUA_OPADD, e1, e2))
        codebinexpval(fs, cast(OpCode, op + OP_ADD), e1, e2, line);
      break;
    }
    case OPR_EQ: case OPR_LT: case OPR_LE:
    case OPR_NE: case OPR_GT: case OPR_GE: {
      codecomp(fs, op, e1, e2);
      break;
    }
    default: lua_assert(0);
  }
}


/*
** Change line information associated with current position.
*/
void luaK_fixline (FuncState *fs, int line) {
  fs->f->lineinfo[fs->pc - 1] = line;
}


/*
** Emit a SETLIST instruction.
** 'base' is register that keeps table;
** 'nelems' is #table plus those to be stored now;
** 'tostore' is number of values (in registers 'base + 1',...) to add to
** table (or LUA_MULTRET to add up to stack top).
*/
void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
  int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
  int b = (tostore == LUA_MULTRET) ? 0 : tostore;
  lua_assert(tostore != 0 && tostore <= LFIELDS_PER_FLUSH);
  if (c <= MAXARG_C)
    luaK_codeABC(fs, OP_SETLIST, base, b, c);
  else if (c <= MAXARG_Ax) {
    luaK_codeABC(fs, OP_SETLIST, base, b, 0);
    codeextraarg(fs, c);
  }
  else
    luaX_syntaxerror(fs->ls, "constructor too long");
  fs->freereg = base + 1;  /* free registers with list values */
}


```

`src/Lua/lcode.h`:

```h
/*
** $Id: lcode.h,v 1.64 2016/01/05 16:22:37 roberto Exp $
** Code generator for Lua
** See Copyright Notice in lua.h
*/

#ifndef lcode_h
#define lcode_h

#include "llex.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lparser.h"


/*
** Marks the end of a patch list. It is an invalid value both as an absolute
** address, and as a list link (would link an element to itself).
*/
#define NO_JUMP (-1)


/*
** grep "ORDER OPR" if you change these enums  (ORDER OP)
*/
typedef enum BinOpr {
  OPR_ADD, OPR_SUB, OPR_MUL, OPR_MOD, OPR_POW,
  OPR_DIV,
  OPR_IDIV,
  OPR_BAND, OPR_BOR, OPR_BXOR,
  OPR_SHL, OPR_SHR,
  OPR_CONCAT,
  OPR_EQ, OPR_LT, OPR_LE,
  OPR_NE, OPR_GT, OPR_GE,
  OPR_AND, OPR_OR,
  OPR_NOBINOPR
} BinOpr;


typedef enum UnOpr { OPR_MINUS, OPR_BNOT, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;


/* get (pointer to) instruction of given 'expdesc' */
#define getinstruction(fs,e)	((fs)->f->code[(e)->u.info])

#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)

#define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)

#define luaK_jumpto(fs,t)	luaK_patchlist(fs, luaK_jump(fs), t)

LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
LUAI_FUNC int luaK_codek (FuncState *fs, int reg, int k);
LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
LUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);
LUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);
LUAI_FUNC void luaK_checkstack (FuncState *fs, int n);
LUAI_FUNC int luaK_stringK (FuncState *fs, TString *s);
LUAI_FUNC int luaK_intK (FuncState *fs, lua_Integer n);
LUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);
LUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_exp2anyregup (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);
LUAI_FUNC int luaK_exp2RK (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
LUAI_FUNC void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
LUAI_FUNC void luaK_goiftrue (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_goiffalse (FuncState *fs, expdesc *e);
LUAI_FUNC void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
LUAI_FUNC void luaK_setreturns (FuncState *fs, expdesc *e, int nresults);
LUAI_FUNC void luaK_setoneret (FuncState *fs, expdesc *e);
LUAI_FUNC int luaK_jump (FuncState *fs);
LUAI_FUNC void luaK_ret (FuncState *fs, int first, int nret);
LUAI_FUNC void luaK_patchlist (FuncState *fs, int list, int target);
LUAI_FUNC void luaK_patchtohere (FuncState *fs, int list);
LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level);
LUAI_FUNC void luaK_concat (FuncState *fs, int *l1, int l2);
LUAI_FUNC int luaK_getlabel (FuncState *fs);
LUAI_FUNC void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v, int line);
LUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
LUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1,
                            expdesc *v2, int line);
LUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);


#endif

```

`src/Lua/lcorolib.c`:

```c
/*
** $Id: lcorolib.c,v 1.10 2016/04/11 19:19:55 roberto Exp $
** Coroutine Library
** See Copyright Notice in lua.h
*/

#define lcorolib_c
#define LUA_LIB

#include "lprefix.h"


#include <stdlib.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


static lua_State *getco (lua_State *L) {
  lua_State *co = lua_tothread(L, 1);
  luaL_argcheck(L, co, 1, "thread expected");
  return co;
}


static int auxresume (lua_State *L, lua_State *co, int narg) {
  int status;
  if (!lua_checkstack(co, narg)) {
    lua_pushliteral(L, "too many arguments to resume");
    return -1;  /* error flag */
  }
  if (lua_status(co) == LUA_OK && lua_gettop(co) == 0) {
    lua_pushliteral(L, "cannot resume dead coroutine");
    return -1;  /* error flag */
  }
  lua_xmove(L, co, narg);
  status = lua_resume(co, L, narg);
  if (status == LUA_OK || status == LUA_YIELD) {
    int nres = lua_gettop(co);
    if (!lua_checkstack(L, nres + 1)) {
      lua_pop(co, nres);  /* remove results anyway */
      lua_pushliteral(L, "too many results to resume");
      return -1;  /* error flag */
    }
    lua_xmove(co, L, nres);  /* move yielded values */
    return nres;
  }
  else {
    lua_xmove(co, L, 1);  /* move error message */
    return -1;  /* error flag */
  }
}


static int luaB_coresume (lua_State *L) {
  lua_State *co = getco(L);
  int r;
  r = auxresume(L, co, lua_gettop(L) - 1);
  if (r < 0) {
    lua_pushboolean(L, 0);
    lua_insert(L, -2);
    return 2;  /* return false + error message */
  }
  else {
    lua_pushboolean(L, 1);
    lua_insert(L, -(r + 1));
    return r + 1;  /* return true + 'resume' returns */
  }
}


static int luaB_auxwrap (lua_State *L) {
  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
  int r = auxresume(L, co, lua_gettop(L));
  if (r < 0) {
    if (lua_type(L, -1) == LUA_TSTRING) {  /* error object is a string? */
      luaL_where(L, 1);  /* add extra info */
      lua_insert(L, -2);
      lua_concat(L, 2);
    }
    return lua_error(L);  /* propagate error */
  }
  return r;
}


static int luaB_cocreate (lua_State *L) {
  lua_State *NL;
  luaL_checktype(L, 1, LUA_TFUNCTION);
  NL = lua_newthread(L);
  lua_pushvalue(L, 1);  /* move function to top */
  lua_xmove(L, NL, 1);  /* move function from L to NL */
  return 1;
}


static int luaB_cowrap (lua_State *L) {
  luaB_cocreate(L);
  lua_pushcclosure(L, luaB_auxwrap, 1);
  return 1;
}


static int luaB_yield (lua_State *L) {
  return lua_yield(L, lua_gettop(L));
}


static int luaB_costatus (lua_State *L) {
  lua_State *co = getco(L);
  if (L == co) lua_pushliteral(L, "running");
  else {
    switch (lua_status(co)) {
      case LUA_YIELD:
        lua_pushliteral(L, "suspended");
        break;
      case LUA_OK: {
        lua_Debug ar;
        if (lua_getstack(co, 0, &ar) > 0)  /* does it have frames? */
          lua_pushliteral(L, "normal");  /* it is running */
        else if (lua_gettop(co) == 0)
            lua_pushliteral(L, "dead");
        else
          lua_pushliteral(L, "suspended");  /* initial state */
        break;
      }
      default:  /* some error occurred */
        lua_pushliteral(L, "dead");
        break;
    }
  }
  return 1;
}


static int luaB_yieldable (lua_State *L) {
  lua_pushboolean(L, lua_isyieldable(L));
  return 1;
}


static int luaB_corunning (lua_State *L) {
  int ismain = lua_pushthread(L);
  lua_pushboolean(L, ismain);
  return 2;
}


static const luaL_Reg co_funcs[] = {
  {"create", luaB_cocreate},
  {"resume", luaB_coresume},
  {"running", luaB_corunning},
  {"status", luaB_costatus},
  {"wrap", luaB_cowrap},
  {"yield", luaB_yield},
  {"isyieldable", luaB_yieldable},
  {NULL, NULL}
};



LUAMOD_API int luaopen_coroutine (lua_State *L) {
  luaL_newlib(L, co_funcs);
  return 1;
}


```

`src/Lua/lctype.c`:

```c
/*
** $Id: lctype.c,v 1.12 2014/11/02 19:19:04 roberto Exp $
** 'ctype' functions for Lua
** See Copyright Notice in lua.h
*/

#define lctype_c
#define LUA_CORE

#include "lprefix.h"


#include "lctype.h"

#if !LUA_USE_CTYPE	/* { */

#include <limits.h>

LUAI_DDEF const lu_byte luai_ctype_[UCHAR_MAX + 2] = {
  0x00,  /* EOZ */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 0. */
  0x00,  0x08,  0x08,  0x08,  0x08,  0x08,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 1. */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x0c,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,	/* 2. */
  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,	/* 3. */
  0x16,  0x16,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 4. */
  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 5. */
  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x05,
  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 6. */
  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 7. */
  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 8. */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 9. */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* a. */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* b. */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* c. */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* d. */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* e. */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* f. */
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
};

#endif			/* } */

```

`src/Lua/lctype.h`:

```h
/*
** $Id: lctype.h,v 1.12 2011/07/15 12:50:29 roberto Exp $
** 'ctype' functions for Lua
** See Copyright Notice in lua.h
*/

#ifndef lctype_h
#define lctype_h

#include "lua.h"


/*
** WARNING: the functions defined here do not necessarily correspond
** to the similar functions in the standard C ctype.h. They are
** optimized for the specific needs of Lua
*/

#if !defined(LUA_USE_CTYPE)

#if 'A' == 65 && '0' == 48
/* ASCII case: can use its own tables; faster and fixed */
#define LUA_USE_CTYPE	0
#else
/* must use standard C ctype */
#define LUA_USE_CTYPE	1
#endif

#endif


#if !LUA_USE_CTYPE	/* { */

#include <limits.h>

#include "llimits.h"


#define ALPHABIT	0
#define DIGITBIT	1
#define PRINTBIT	2
#define SPACEBIT	3
#define XDIGITBIT	4


#define MASK(B)		(1 << (B))


/*
** add 1 to char to allow index -1 (EOZ)
*/
#define testprop(c,p)	(luai_ctype_[(c)+1] & (p))

/*
** 'lalpha' (Lua alphabetic) and 'lalnum' (Lua alphanumeric) both include '_'
*/
#define lislalpha(c)	testprop(c, MASK(ALPHABIT))
#define lislalnum(c)	testprop(c, (MASK(ALPHABIT) | MASK(DIGITBIT)))
#define lisdigit(c)	testprop(c, MASK(DIGITBIT))
#define lisspace(c)	testprop(c, MASK(SPACEBIT))
#define lisprint(c)	testprop(c, MASK(PRINTBIT))
#define lisxdigit(c)	testprop(c, MASK(XDIGITBIT))

/*
** this 'ltolower' only works for alphabetic characters
*/
#define ltolower(c)	((c) | ('A' ^ 'a'))


/* two more entries for 0 and -1 (EOZ) */
LUAI_DDEC const lu_byte luai_ctype_[UCHAR_MAX + 2];


#else			/* }{ */

/*
** use standard C ctypes
*/

#include <ctype.h>


#define lislalpha(c)	(isalpha(c) || (c) == '_')
#define lislalnum(c)	(isalnum(c) || (c) == '_')
#define lisdigit(c)	(isdigit(c))
#define lisspace(c)	(isspace(c))
#define lisprint(c)	(isprint(c))
#define lisxdigit(c)	(isxdigit(c))

#define ltolower(c)	(tolower(c))

#endif			/* } */

#endif


```

`src/Lua/ldblib.c`:

```c
/*
** $Id: ldblib.c,v 1.151 2015/11/23 11:29:43 roberto Exp $
** Interface from Lua to its debug API
** See Copyright Notice in lua.h
*/

#define ldblib_c
#define LUA_LIB

#include "lprefix.h"


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


/*
** The hook table at registry[&HOOKKEY] maps threads to their current
** hook function. (We only need the unique address of 'HOOKKEY'.)
*/
static const int HOOKKEY = 0;


/*
** If L1 != L, L1 can be in any state, and therefore there are no
** guarantees about its stack space; any push in L1 must be
** checked.
*/
static void checkstack (lua_State *L, lua_State *L1, int n) {
  if (L != L1 && !lua_checkstack(L1, n))
    luaL_error(L, "stack overflow");
}


static int db_getregistry (lua_State *L) {
  lua_pushvalue(L, LUA_REGISTRYINDEX);
  return 1;
}


static int db_getmetatable (lua_State *L) {
  luaL_checkany(L, 1);
  if (!lua_getmetatable(L, 1)) {
    lua_pushnil(L);  /* no metatable */
  }
  return 1;
}


static int db_setmetatable (lua_State *L) {
  int t = lua_type(L, 2);
  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
                    "nil or table expected");
  lua_settop(L, 2);
  lua_setmetatable(L, 1);
  return 1;  /* return 1st argument */
}


static int db_getuservalue (lua_State *L) {
  if (lua_type(L, 1) != LUA_TUSERDATA)
    lua_pushnil(L);
  else
    lua_getuservalue(L, 1);
  return 1;
}


static int db_setuservalue (lua_State *L) {
  luaL_checktype(L, 1, LUA_TUSERDATA);
  luaL_checkany(L, 2);
  lua_settop(L, 2);
  lua_setuservalue(L, 1);
  return 1;
}


/*
** Auxiliary function used by several library functions: check for
** an optional thread as function's first argument and set 'arg' with
** 1 if this argument is present (so that functions can skip it to
** access their other arguments)
*/
static lua_State *getthread (lua_State *L, int *arg) {
  if (lua_isthread(L, 1)) {
    *arg = 1;
    return lua_tothread(L, 1);
  }
  else {
    *arg = 0;
    return L;  /* function will operate over current thread */
  }
}


/*
** Variations of 'lua_settable', used by 'db_getinfo' to put results
** from 'lua_getinfo' into result table. Key is always a string;
** value can be a string, an int, or a boolean.
*/
static void settabss (lua_State *L, const char *k, const char *v) {
  lua_pushstring(L, v);
  lua_setfield(L, -2, k);
}

static void settabsi (lua_State *L, const char *k, int v) {
  lua_pushinteger(L, v);
  lua_setfield(L, -2, k);
}

static void settabsb (lua_State *L, const char *k, int v) {
  lua_pushboolean(L, v);
  lua_setfield(L, -2, k);
}


/*
** In function 'db_getinfo', the call to 'lua_getinfo' may push
** results on the stack; later it creates the result table to put
** these objects. Function 'treatstackoption' puts the result from
** 'lua_getinfo' on top of the result table so that it can call
** 'lua_setfield'.
*/
static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
  if (L == L1)
    lua_rotate(L, -2, 1);  /* exchange object and table */
  else
    lua_xmove(L1, L, 1);  /* move object to the "main" stack */
  lua_setfield(L, -2, fname);  /* put object into table */
}


/*
** Calls 'lua_getinfo' and collects all results in a new table.
** L1 needs stack space for an optional input (function) plus
** two optional outputs (function and line table) from function
** 'lua_getinfo'.
*/
static int db_getinfo (lua_State *L) {
  lua_Debug ar;
  int arg;
  lua_State *L1 = getthread(L, &arg);
  const char *options = luaL_optstring(L, arg+2, "flnStu");
  checkstack(L, L1, 3);
  if (lua_isfunction(L, arg + 1)) {  /* info about a function? */
    options = lua_pushfstring(L, ">%s", options);  /* add '>' to 'options' */
    lua_pushvalue(L, arg + 1);  /* move function to 'L1' stack */
    lua_xmove(L, L1, 1);
  }
  else {  /* stack level */
    if (!lua_getstack(L1, (int)luaL_checkinteger(L, arg + 1), &ar)) {
      lua_pushnil(L);  /* level out of range */
      return 1;
    }
  }
  if (!lua_getinfo(L1, options, &ar))
    return luaL_argerror(L, arg+2, "invalid option");
  lua_newtable(L);  /* table to collect results */
  if (strchr(options, 'S')) {
    settabss(L, "source", ar.source);
    settabss(L, "short_src", ar.short_src);
    settabsi(L, "linedefined", ar.linedefined);
    settabsi(L, "lastlinedefined", ar.lastlinedefined);
    settabss(L, "what", ar.what);
  }
  if (strchr(options, 'l'))
    settabsi(L, "currentline", ar.currentline);
  if (strchr(options, 'u')) {
    settabsi(L, "nups", ar.nups);
    settabsi(L, "nparams", ar.nparams);
    settabsb(L, "isvararg", ar.isvararg);
  }
  if (strchr(options, 'n')) {
    settabss(L, "name", ar.name);
    settabss(L, "namewhat", ar.namewhat);
  }
  if (strchr(options, 't'))
    settabsb(L, "istailcall", ar.istailcall);
  if (strchr(options, 'L'))
    treatstackoption(L, L1, "activelines");
  if (strchr(options, 'f'))
    treatstackoption(L, L1, "func");
  return 1;  /* return table */
}


static int db_getlocal (lua_State *L) {
  int arg;
  lua_State *L1 = getthread(L, &arg);
  lua_Debug ar;
  const char *name;
  int nvar = (int)luaL_checkinteger(L, arg + 2);  /* local-variable index */
  if (lua_isfunction(L, arg + 1)) {  /* function argument? */
    lua_pushvalue(L, arg + 1);  /* push function */
    lua_pushstring(L, lua_getlocal(L, NULL, nvar));  /* push local name */
    return 1;  /* return only name (there is no value) */
  }
  else {  /* stack-level argument */
    int level = (int)luaL_checkinteger(L, arg + 1);
    if (!lua_getstack(L1, level, &ar))  /* out of range? */
      return luaL_argerror(L, arg+1, "level out of range");
    checkstack(L, L1, 1);
    name = lua_getlocal(L1, &ar, nvar);
    if (name) {
      lua_xmove(L1, L, 1);  /* move local value */
      lua_pushstring(L, name);  /* push name */
      lua_rotate(L, -2, 1);  /* re-order */
      return 2;
    }
    else {
      lua_pushnil(L);  /* no name (nor value) */
      return 1;
    }
  }
}


static int db_setlocal (lua_State *L) {
  int arg;
  const char *name;
  lua_State *L1 = getthread(L, &arg);
  lua_Debug ar;
  int level = (int)luaL_checkinteger(L, arg + 1);
  int nvar = (int)luaL_checkinteger(L, arg + 2);
  if (!lua_getstack(L1, level, &ar))  /* out of range? */
    return luaL_argerror(L, arg+1, "level out of range");
  luaL_checkany(L, arg+3);
  lua_settop(L, arg+3);
  checkstack(L, L1, 1);
  lua_xmove(L, L1, 1);
  name = lua_setlocal(L1, &ar, nvar);
  if (name == NULL)
    lua_pop(L1, 1);  /* pop value (if not popped by 'lua_setlocal') */
  lua_pushstring(L, name);
  return 1;
}


/*
** get (if 'get' is true) or set an upvalue from a closure
*/
static int auxupvalue (lua_State *L, int get) {
  const char *name;
  int n = (int)luaL_checkinteger(L, 2);  /* upvalue index */
  luaL_checktype(L, 1, LUA_TFUNCTION);  /* closure */
  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
  if (name == NULL) return 0;
  lua_pushstring(L, name);
  lua_insert(L, -(get+1));  /* no-op if get is false */
  return get + 1;
}


static int db_getupvalue (lua_State *L) {
  return auxupvalue(L, 1);
}


static int db_setupvalue (lua_State *L) {
  luaL_checkany(L, 3);
  return auxupvalue(L, 0);
}


/*
** Check whether a given upvalue from a given closure exists and
** returns its index
*/
static int checkupval (lua_State *L, int argf, int argnup) {
  int nup = (int)luaL_checkinteger(L, argnup);  /* upvalue index */
  luaL_checktype(L, argf, LUA_TFUNCTION);  /* closure */
  luaL_argcheck(L, (lua_getupvalue(L, argf, nup) != NULL), argnup,
                   "invalid upvalue index");
  return nup;
}


static int db_upvalueid (lua_State *L) {
  int n = checkupval(L, 1, 2);
  lua_pushlightuserdata(L, lua_upvalueid(L, 1, n));
  return 1;
}


static int db_upvaluejoin (lua_State *L) {
  int n1 = checkupval(L, 1, 2);
  int n2 = checkupval(L, 3, 4);
  luaL_argcheck(L, !lua_iscfunction(L, 1), 1, "Lua function expected");
  luaL_argcheck(L, !lua_iscfunction(L, 3), 3, "Lua function expected");
  lua_upvaluejoin(L, 1, n1, 3, n2);
  return 0;
}


/*
** Call hook function registered at hook table for the current
** thread (if there is one)
*/
static void hookf (lua_State *L, lua_Debug *ar) {
  static const char *const hooknames[] =
    {"call", "return", "line", "count", "tail call"};
  lua_rawgetp(L, LUA_REGISTRYINDEX, &HOOKKEY);
  lua_pushthread(L);
  if (lua_rawget(L, -2) == LUA_TFUNCTION) {  /* is there a hook function? */
    lua_pushstring(L, hooknames[(int)ar->event]);  /* push event name */
    if (ar->currentline >= 0)
      lua_pushinteger(L, ar->currentline);  /* push current line */
    else lua_pushnil(L);
    lua_assert(lua_getinfo(L, "lS", ar));
    lua_call(L, 2, 0);  /* call hook function */
  }
}


/*
** Convert a string mask (for 'sethook') into a bit mask
*/
static int makemask (const char *smask, int count) {
  int mask = 0;
  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
  if (count > 0) mask |= LUA_MASKCOUNT;
  return mask;
}


/*
** Convert a bit mask (for 'gethook') into a string mask
*/
static char *unmakemask (int mask, char *smask) {
  int i = 0;
  if (mask & LUA_MASKCALL) smask[i++] = 'c';
  if (mask & LUA_MASKRET) smask[i++] = 'r';
  if (mask & LUA_MASKLINE) smask[i++] = 'l';
  smask[i] = '\0';
  return smask;
}


static int db_sethook (lua_State *L) {
  int arg, mask, count;
  lua_Hook func;
  lua_State *L1 = getthread(L, &arg);
  if (lua_isnoneornil(L, arg+1)) {  /* no hook? */
    lua_settop(L, arg+1);
    func = NULL; mask = 0; count = 0;  /* turn off hooks */
  }
  else {
    const char *smask = luaL_checkstring(L, arg+2);
    luaL_checktype(L, arg+1, LUA_TFUNCTION);
    count = (int)luaL_optinteger(L, arg + 3, 0);
    func = hookf; mask = makemask(smask, count);
  }
  if (lua_rawgetp(L, LUA_REGISTRYINDEX, &HOOKKEY) == LUA_TNIL) {
    lua_createtable(L, 0, 2);  /* create a hook table */
    lua_pushvalue(L, -1);
    lua_rawsetp(L, LUA_REGISTRYINDEX, &HOOKKEY);  /* set it in position */
    lua_pushstring(L, "k");
    lua_setfield(L, -2, "__mode");  /** hooktable.__mode = "k" */
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);  /* setmetatable(hooktable) = hooktable */
  }
  checkstack(L, L1, 1);
  lua_pushthread(L1); lua_xmove(L1, L, 1);  /* key (thread) */
  lua_pushvalue(L, arg + 1);  /* value (hook function) */
  lua_rawset(L, -3);  /* hooktable[L1] = new Lua hook */
  lua_sethook(L1, func, mask, count);
  return 0;
}


static int db_gethook (lua_State *L) {
  int arg;
  lua_State *L1 = getthread(L, &arg);
  char buff[5];
  int mask = lua_gethookmask(L1);
  lua_Hook hook = lua_gethook(L1);
  if (hook == NULL)  /* no hook? */
    lua_pushnil(L);
  else if (hook != hookf)  /* external hook? */
    lua_pushliteral(L, "external hook");
  else {  /* hook table must exist */
    lua_rawgetp(L, LUA_REGISTRYINDEX, &HOOKKEY);
    checkstack(L, L1, 1);
    lua_pushthread(L1); lua_xmove(L1, L, 1);
    lua_rawget(L, -2);   /* 1st result = hooktable[L1] */
    lua_remove(L, -2);  /* remove hook table */
  }
  lua_pushstring(L, unmakemask(mask, buff));  /* 2nd result = mask */
  lua_pushinteger(L, lua_gethookcount(L1));  /* 3rd result = count */
  return 3;
}


static int db_debug (lua_State *L) {
  for (;;) {
    char buffer[250];
    lua_writestringerror("%s", "lua_debug> ");
    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
        strcmp(buffer, "cont\n") == 0)
      return 0;
    if (luaL_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
        lua_pcall(L, 0, 0, 0))
      lua_writestringerror("%s\n", lua_tostring(L, -1));
    lua_settop(L, 0);  /* remove eventual returns */
  }
}


static int db_traceback (lua_State *L) {
  int arg;
  lua_State *L1 = getthread(L, &arg);
  const char *msg = lua_tostring(L, arg + 1);
  if (msg == NULL && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */
    lua_pushvalue(L, arg + 1);  /* return it untouched */
  else {
    int level = (int)luaL_optinteger(L, arg + 2, (L == L1) ? 1 : 0);
    luaL_traceback(L, L1, msg, level);
  }
  return 1;
}


static const luaL_Reg dblib[] = {
  {"debug", db_debug},
  {"getuservalue", db_getuservalue},
  {"gethook", db_gethook},
  {"getinfo", db_getinfo},
  {"getlocal", db_getlocal},
  {"getregistry", db_getregistry},
  {"getmetatable", db_getmetatable},
  {"getupvalue", db_getupvalue},
  {"upvaluejoin", db_upvaluejoin},
  {"upvalueid", db_upvalueid},
  {"setuservalue", db_setuservalue},
  {"sethook", db_sethook},
  {"setlocal", db_setlocal},
  {"setmetatable", db_setmetatable},
  {"setupvalue", db_setupvalue},
  {"traceback", db_traceback},
  {NULL, NULL}
};


LUAMOD_API int luaopen_debug (lua_State *L) {
  luaL_newlib(L, dblib);
  return 1;
}


```

`src/Lua/ldebug.c`:

```c
/*
** $Id: ldebug.c,v 2.121 2016/10/19 12:32:10 roberto Exp $
** Debug Interface
** See Copyright Notice in lua.h
*/

#define ldebug_c
#define LUA_CORE

#include "lprefix.h"


#include <stdarg.h>
#include <stddef.h>
#include <string.h>

#include "lua.h"

#include "lapi.h"
#include "lcode.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"
#include "lvm.h"



#define noLuaClosure(f)		((f) == NULL || (f)->c.tt == LUA_TCCL)


/* Active Lua function (given call info) */
#define ci_func(ci)		(clLvalue((ci)->func))


static const char *funcnamefromcode (lua_State *L, CallInfo *ci,
                                    const char **name);


static int currentpc (CallInfo *ci) {
  lua_assert(isLua(ci));
  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);
}


static int currentline (CallInfo *ci) {
  return getfuncline(ci_func(ci)->p, currentpc(ci));
}


/*
** If function yielded, its 'func' can be in the 'extra' field. The
** next function restores 'func' to its correct value for debugging
** purposes. (It exchanges 'func' and 'extra'; so, when called again,
** after debugging, it also "re-restores" ** 'func' to its altered value.
*/
static void swapextra (lua_State *L) {
  if (L->status == LUA_YIELD) {
    CallInfo *ci = L->ci;  /* get function that yielded */
    StkId temp = ci->func;  /* exchange its 'func' and 'extra' values */
    ci->func = restorestack(L, ci->extra);
    ci->extra = savestack(L, temp);
  }
}


/*
** This function can be called asynchronously (e.g. during a signal).
** Fields 'oldpc', 'basehookcount', and 'hookcount' (set by
** 'resethookcount') are for debug only, and it is no problem if they
** get arbitrary values (causes at most one wrong hook call). 'hookmask'
** is an atomic value. We assume that pointers are atomic too (e.g., gcc
** ensures that for all platforms where it runs). Moreover, 'hook' is
** always checked before being called (see 'luaD_hook').
*/
LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
  if (func == NULL || mask == 0) {  /* turn off hooks? */
    mask = 0;
    func = NULL;
  }
  if (isLua(L->ci))
    L->oldpc = L->ci->u.l.savedpc;
  L->hook = func;
  L->basehookcount = count;
  resethookcount(L);
  L->hookmask = cast_byte(mask);
}


LUA_API lua_Hook lua_gethook (lua_State *L) {
  return L->hook;
}


LUA_API int lua_gethookmask (lua_State *L) {
  return L->hookmask;
}


LUA_API int lua_gethookcount (lua_State *L) {
  return L->basehookcount;
}


LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
  int status;
  CallInfo *ci;
  if (level < 0) return 0;  /* invalid (negative) level */
  lua_lock(L);
  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)
    level--;
  if (level == 0 && ci != &L->base_ci) {  /* level found? */
    status = 1;
    ar->i_ci = ci;
  }
  else status = 0;  /* no such level */
  lua_unlock(L);
  return status;
}


static const char *upvalname (Proto *p, int uv) {
  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);
  if (s == NULL) return "?";
  else return getstr(s);
}


static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
  int nparams = clLvalue(ci->func)->p->numparams;
  if (n >= cast_int(ci->u.l.base - ci->func) - nparams)
    return NULL;  /* no such vararg */
  else {
    *pos = ci->func + nparams + n;
    return "(*vararg)";  /* generic name for any vararg */
  }
}


static const char *findlocal (lua_State *L, CallInfo *ci, int n,
                              StkId *pos) {
  const char *name = NULL;
  StkId base;
  if (isLua(ci)) {
    if (n < 0)  /* access to vararg values? */
      return findvararg(ci, -n, pos);
    else {
      base = ci->u.l.base;
      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));
    }
  }
  else
    base = ci->func + 1;
  if (name == NULL) {  /* no 'standard' name? */
    StkId limit = (ci == L->ci) ? L->top : ci->next->func;
    if (limit - base >= n && n > 0)  /* is 'n' inside 'ci' stack? */
      name = "(*temporary)";  /* generic name for any valid slot */
    else
      return NULL;  /* no name */
  }
  *pos = base + (n - 1);
  return name;
}


LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
  const char *name;
  lua_lock(L);
  swapextra(L);
  if (ar == NULL) {  /* information about non-active function? */
    if (!isLfunction(L->top - 1))  /* not a Lua function? */
      name = NULL;
    else  /* consider live variables at function start (parameters) */
      name = luaF_getlocalname(clLvalue(L->top - 1)->p, n, 0);
  }
  else {  /* active function; get information through 'ar' */
    StkId pos = NULL;  /* to avoid warnings */
    name = findlocal(L, ar->i_ci, n, &pos);
    if (name) {
      setobj2s(L, L->top, pos);
      api_incr_top(L);
    }
  }
  swapextra(L);
  lua_unlock(L);
  return name;
}


LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
  StkId pos = NULL;  /* to avoid warnings */
  const char *name;
  lua_lock(L);
  swapextra(L);
  name = findlocal(L, ar->i_ci, n, &pos);
  if (name) {
    setobjs2s(L, pos, L->top - 1);
    L->top--;  /* pop value */
  }
  swapextra(L);
  lua_unlock(L);
  return name;
}


static void funcinfo (lua_Debug *ar, Closure *cl) {
  if (noLuaClosure(cl)) {
    ar->source = "=[C]";
    ar->linedefined = -1;
    ar->lastlinedefined = -1;
    ar->what = "C";
  }
  else {
    Proto *p = cl->l.p;
    ar->source = p->source ? getstr(p->source) : "=?";
    ar->linedefined = p->linedefined;
    ar->lastlinedefined = p->lastlinedefined;
    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
  }
  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
}


static void collectvalidlines (lua_State *L, Closure *f) {
  if (noLuaClosure(f)) {
    setnilvalue(L->top);
    api_incr_top(L);
  }
  else {
    int i;
    TValue v;
    int *lineinfo = f->l.p->lineinfo;
    Table *t = luaH_new(L);  /* new table to store active lines */
    sethvalue(L, L->top, t);  /* push it on stack */
    api_incr_top(L);
    setbvalue(&v, 1);  /* boolean 'true' to be the value of all indices */
    for (i = 0; i < f->l.p->sizelineinfo; i++)  /* for all lines with code */
      luaH_setint(L, t, lineinfo[i], &v);  /* table[line] = true */
  }
}


static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
  if (ci == NULL)  /* no 'ci'? */
    return NULL;  /* no info */
  else if (ci->callstatus & CIST_FIN) {  /* is this a finalizer? */
    *name = "__gc";
    return "metamethod";  /* report it as such */
  }
  /* calling function is a known Lua function? */
  else if (!(ci->callstatus & CIST_TAIL) && isLua(ci->previous))
    return funcnamefromcode(L, ci->previous, name);
  else return NULL;  /* no way to find a name */
}


static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
                       Closure *f, CallInfo *ci) {
  int status = 1;
  for (; *what; what++) {
    switch (*what) {
      case 'S': {
        funcinfo(ar, f);
        break;
      }
      case 'l': {
        ar->currentline = (ci && isLua(ci)) ? currentline(ci) : -1;
        break;
      }
      case 'u': {
        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;
        if (noLuaClosure(f)) {
          ar->isvararg = 1;
          ar->nparams = 0;
        }
        else {
          ar->isvararg = f->l.p->is_vararg;
          ar->nparams = f->l.p->numparams;
        }
        break;
      }
      case 't': {
        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;
        break;
      }
      case 'n': {
        ar->namewhat = getfuncname(L, ci, &ar->name);
        if (ar->namewhat == NULL) {
          ar->namewhat = "";  /* not found */
          ar->name = NULL;
        }
        break;
      }
      case 'L':
      case 'f':  /* handled by lua_getinfo */
        break;
      default: status = 0;  /* invalid option */
    }
  }
  return status;
}


LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
  int status;
  Closure *cl;
  CallInfo *ci;
  StkId func;
  lua_lock(L);
  swapextra(L);
  if (*what == '>') {
    ci = NULL;
    func = L->top - 1;
    api_check(L, ttisfunction(func), "function expected");
    what++;  /* skip the '>' */
    L->top--;  /* pop function */
  }
  else {
    ci = ar->i_ci;
    func = ci->func;
    lua_assert(ttisfunction(ci->func));
  }
  cl = ttisclosure(func) ? clvalue(func) : NULL;
  status = auxgetinfo(L, what, ar, cl, ci);
  if (strchr(what, 'f')) {
    setobjs2s(L, L->top, func);
    api_incr_top(L);
  }
  swapextra(L);  /* correct before option 'L', which can raise a mem. error */
  if (strchr(what, 'L'))
    collectvalidlines(L, cl);
  lua_unlock(L);
  return status;
}


/*
** {======================================================
** Symbolic Execution
** =======================================================
*/

static const char *getobjname (Proto *p, int lastpc, int reg,
                               const char **name);


/*
** find a "name" for the RK value 'c'
*/
static void kname (Proto *p, int pc, int c, const char **name) {
  if (ISK(c)) {  /* is 'c' a constant? */
    TValue *kvalue = &p->k[INDEXK(c)];
    if (ttisstring(kvalue)) {  /* literal constant? */
      *name = svalue(kvalue);  /* it is its own name */
      return;
    }
    /* else no reasonable name found */
  }
  else {  /* 'c' is a register */
    const char *what = getobjname(p, pc, c, name); /* search for 'c' */
    if (what && *what == 'c') {  /* found a constant name? */
      return;  /* 'name' already filled */
    }
    /* else no reasonable name found */
  }
  *name = "?";  /* no reasonable name found */
}


static int filterpc (int pc, int jmptarget) {
  if (pc < jmptarget)  /* is code conditional (inside a jump)? */
    return -1;  /* cannot know who sets that register */
  else return pc;  /* current position sets that register */
}


/*
** try to find last instruction before 'lastpc' that modified register 'reg'
*/
static int findsetreg (Proto *p, int lastpc, int reg) {
  int pc;
  int setreg = -1;  /* keep last instruction that changed 'reg' */
  int jmptarget = 0;  /* any code before this address is conditional */
  for (pc = 0; pc < lastpc; pc++) {
    Instruction i = p->code[pc];
    OpCode op = GET_OPCODE(i);
    int a = GETARG_A(i);
    switch (op) {
      case OP_LOADNIL: {
        int b = GETARG_B(i);
        if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */
          setreg = filterpc(pc, jmptarget);
        break;
      }
      case OP_TFORCALL: {
        if (reg >= a + 2)  /* affect all regs above its base */
          setreg = filterpc(pc, jmptarget);
        break;
      }
      case OP_CALL:
      case OP_TAILCALL: {
        if (reg >= a)  /* affect all registers above base */
          setreg = filterpc(pc, jmptarget);
        break;
      }
      case OP_JMP: {
        int b = GETARG_sBx(i);
        int dest = pc + 1 + b;
        /* jump is forward and do not skip 'lastpc'? */
        if (pc < dest && dest <= lastpc) {
          if (dest > jmptarget)
            jmptarget = dest;  /* update 'jmptarget' */
        }
        break;
      }
      default:
        if (testAMode(op) && reg == a)  /* any instruction that set A */
          setreg = filterpc(pc, jmptarget);
        break;
    }
  }
  return setreg;
}


static const char *getobjname (Proto *p, int lastpc, int reg,
                               const char **name) {
  int pc;
  *name = luaF_getlocalname(p, reg + 1, lastpc);
  if (*name)  /* is a local? */
    return "local";
  /* else try symbolic execution */
  pc = findsetreg(p, lastpc, reg);
  if (pc != -1) {  /* could find instruction? */
    Instruction i = p->code[pc];
    OpCode op = GET_OPCODE(i);
    switch (op) {
      case OP_MOVE: {
        int b = GETARG_B(i);  /* move from 'b' to 'a' */
        if (b < GETARG_A(i))
          return getobjname(p, pc, b, name);  /* get name for 'b' */
        break;
      }
      case OP_GETTABUP:
      case OP_GETTABLE: {
        int k = GETARG_C(i);  /* key index */
        int t = GETARG_B(i);  /* table index */
        const char *vn = (op == OP_GETTABLE)  /* name of indexed variable */
                         ? luaF_getlocalname(p, t + 1, pc)
                         : upvalname(p, t);
        kname(p, pc, k, name);
        return (vn && strcmp(vn, LUA_ENV) == 0) ? "global" : "field";
      }
      case OP_GETUPVAL: {
        *name = upvalname(p, GETARG_B(i));
        return "upvalue";
      }
      case OP_LOADK:
      case OP_LOADKX: {
        int b = (op == OP_LOADK) ? GETARG_Bx(i)
                                 : GETARG_Ax(p->code[pc + 1]);
        if (ttisstring(&p->k[b])) {
          *name = svalue(&p->k[b]);
          return "constant";
        }
        break;
      }
      case OP_SELF: {
        int k = GETARG_C(i);  /* key index */
        kname(p, pc, k, name);
        return "method";
      }
      default: break;  /* go through to return NULL */
    }
  }
  return NULL;  /* could not find reasonable name */
}


/*
** Try to find a name for a function based on the code that called it.
** (Only works when function was called by a Lua function.)
** Returns what the name is (e.g., "for iterator", "method",
** "metamethod") and sets '*name' to point to the name.
*/
static const char *funcnamefromcode (lua_State *L, CallInfo *ci,
                                     const char **name) {
  TMS tm = (TMS)0;  /* (initial value avoids warnings) */
  Proto *p = ci_func(ci)->p;  /* calling function */
  int pc = currentpc(ci);  /* calling instruction index */
  Instruction i = p->code[pc];  /* calling instruction */
  if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */
    *name = "?";
    return "hook";
  }
  switch (GET_OPCODE(i)) {
    case OP_CALL:
    case OP_TAILCALL:
      return getobjname(p, pc, GETARG_A(i), name);  /* get function name */
    case OP_TFORCALL: {  /* for iterator */
      *name = "for iterator";
       return "for iterator";
    }
    /* other instructions can do calls through metamethods */
    case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:
      tm = TM_INDEX;
      break;
    case OP_SETTABUP: case OP_SETTABLE:
      tm = TM_NEWINDEX;
      break;
    case OP_ADD: case OP_SUB: case OP_MUL: case OP_MOD:
    case OP_POW: case OP_DIV: case OP_IDIV: case OP_BAND:
    case OP_BOR: case OP_BXOR: case OP_SHL: case OP_SHR: {
      int offset = cast_int(GET_OPCODE(i)) - cast_int(OP_ADD);  /* ORDER OP */
      tm = cast(TMS, offset + cast_int(TM_ADD));  /* ORDER TM */
      break;
    }
    case OP_UNM: tm = TM_UNM; break;
    case OP_BNOT: tm = TM_BNOT; break;
    case OP_LEN: tm = TM_LEN; break;
    case OP_CONCAT: tm = TM_CONCAT; break;
    case OP_EQ: tm = TM_EQ; break;
    case OP_LT: tm = TM_LT; break;
    case OP_LE: tm = TM_LE; break;
    default:
      return NULL;  /* cannot find a reasonable name */
  }
  *name = getstr(G(L)->tmname[tm]);
  return "metamethod";
}

/* }====================================================== */



/*
** The subtraction of two potentially unrelated pointers is
** not ISO C, but it should not crash a program; the subsequent
** checks are ISO C and ensure a correct result.
*/
static int isinstack (CallInfo *ci, const TValue *o) {
  ptrdiff_t i = o - ci->u.l.base;
  return (0 <= i && i < (ci->top - ci->u.l.base) && ci->u.l.base + i == o);
}


/*
** Checks whether value 'o' came from an upvalue. (That can only happen
** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on
** upvalues.)
*/
static const char *getupvalname (CallInfo *ci, const TValue *o,
                                 const char **name) {
  LClosure *c = ci_func(ci);
  int i;
  for (i = 0; i < c->nupvalues; i++) {
    if (c->upvals[i]->v == o) {
      *name = upvalname(c->p, i);
      return "upvalue";
    }
  }
  return NULL;
}


static const char *varinfo (lua_State *L, const TValue *o) {
  const char *name = NULL;  /* to avoid warnings */
  CallInfo *ci = L->ci;
  const char *kind = NULL;
  if (isLua(ci)) {
    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */
    if (!kind && isinstack(ci, o))  /* no? try a register */
      kind = getobjname(ci_func(ci)->p, currentpc(ci),
                        cast_int(o - ci->u.l.base), &name);
  }
  return (kind) ? luaO_pushfstring(L, " (%s '%s')", kind, name) : "";
}


l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
  const char *t = luaT_objtypename(L, o);
  luaG_runerror(L, "attempt to %s a %s value%s", op, t, varinfo(L, o));
}


l_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {
  if (ttisstring(p1) || cvt2str(p1)) p1 = p2;
  luaG_typeerror(L, p1, "concatenate");
}


l_noret luaG_opinterror (lua_State *L, const TValue *p1,
                         const TValue *p2, const char *msg) {
  lua_Number temp;
  if (!tonumber(p1, &temp))  /* first operand is wrong? */
    p2 = p1;  /* now second is wrong */
  luaG_typeerror(L, p2, msg);
}


/*
** Error when both values are convertible to numbers, but not to integers
*/
l_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {
  lua_Integer temp;
  if (!tointeger(p1, &temp))
    p2 = p1;
  luaG_runerror(L, "number%s has no integer representation", varinfo(L, p2));
}


l_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
  const char *t1 = luaT_objtypename(L, p1);
  const char *t2 = luaT_objtypename(L, p2);
  if (strcmp(t1, t2) == 0)
    luaG_runerror(L, "attempt to compare two %s values", t1);
  else
    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
}


/* add src:line information to 'msg' */
const char *luaG_addinfo (lua_State *L, const char *msg, TString *src,
                                        int line) {
  char buff[LUA_IDSIZE];
  if (src)
    luaO_chunkid(buff, getstr(src), LUA_IDSIZE);
  else {  /* no source available; use "?" instead */
    buff[0] = '?'; buff[1] = '\0';
  }
  return luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
}


l_noret luaG_errormsg (lua_State *L) {
  if (L->errfunc != 0) {  /* is there an error handling function? */
    StkId errfunc = restorestack(L, L->errfunc);
    setobjs2s(L, L->top, L->top - 1);  /* move argument */
    setobjs2s(L, L->top - 1, errfunc);  /* push function */
    L->top++;  /* assume EXTRA_STACK */
    luaD_callnoyield(L, L->top - 2, 1);  /* call it */
  }
  luaD_throw(L, LUA_ERRRUN);
}


l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
  CallInfo *ci = L->ci;
  const char *msg;
  va_list argp;
  va_start(argp, fmt);
  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */
  va_end(argp);
  if (isLua(ci))  /* if Lua function, add source:line information */
    luaG_addinfo(L, msg, ci_func(ci)->p->source, currentline(ci));
  luaG_errormsg(L);
}


void luaG_traceexec (lua_State *L) {
  CallInfo *ci = L->ci;
  lu_byte mask = L->hookmask;
  int counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));
  if (counthook)
    resethookcount(L);  /* reset count */
  else if (!(mask & LUA_MASKLINE))
    return;  /* no line hook and count != 0; nothing to be done */
  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */
    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
    return;  /* do not call hook again (VM yielded, so it did not move) */
  }
  if (counthook)
    luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */
  if (mask & LUA_MASKLINE) {
    Proto *p = ci_func(ci)->p;
    int npc = pcRel(ci->u.l.savedpc, p);
    int newline = getfuncline(p, npc);
    if (npc == 0 ||  /* call linehook when enter a new function, */
        ci->u.l.savedpc <= L->oldpc ||  /* when jump back (loop), or when */
        newline != getfuncline(p, pcRel(L->oldpc, p)))  /* enter a new line */
      luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */
  }
  L->oldpc = ci->u.l.savedpc;
  if (L->status == LUA_YIELD) {  /* did hook yield? */
    if (counthook)
      L->hookcount = 1;  /* undo decrement to zero */
    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */
    ci->func = L->top - 1;  /* protect stack below results */
    luaD_throw(L, LUA_YIELD);
  }
}


```

`src/Lua/ldebug.h`:

```h
/*
** $Id: ldebug.h,v 2.14 2015/05/22 17:45:56 roberto Exp $
** Auxiliary functions from Debug Interface module
** See Copyright Notice in lua.h
*/

#ifndef ldebug_h
#define ldebug_h


#include "lstate.h"


#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)

#define getfuncline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : -1)

#define resethookcount(L)	(L->hookcount = L->basehookcount)


LUAI_FUNC l_noret luaG_typeerror (lua_State *L, const TValue *o,
                                                const char *opname);
LUAI_FUNC l_noret luaG_concaterror (lua_State *L, const TValue *p1,
                                                  const TValue *p2);
LUAI_FUNC l_noret luaG_opinterror (lua_State *L, const TValue *p1,
                                                 const TValue *p2,
                                                 const char *msg);
LUAI_FUNC l_noret luaG_tointerror (lua_State *L, const TValue *p1,
                                                 const TValue *p2);
LUAI_FUNC l_noret luaG_ordererror (lua_State *L, const TValue *p1,
                                                 const TValue *p2);
LUAI_FUNC l_noret luaG_runerror (lua_State *L, const char *fmt, ...);
LUAI_FUNC const char *luaG_addinfo (lua_State *L, const char *msg,
                                                  TString *src, int line);
LUAI_FUNC l_noret luaG_errormsg (lua_State *L);
LUAI_FUNC void luaG_traceexec (lua_State *L);


#endif

```

`src/Lua/ldo.c`:

```c
/*
** $Id: ldo.c,v 2.157 2016/12/13 15:52:21 roberto Exp $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/

#define ldo_c
#define LUA_CORE

#include "lprefix.h"


#include <setjmp.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "lapi.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lgc.h"
#include "lmem.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lparser.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"
#include "lundump.h"
#include "lvm.h"
#include "lzio.h"



#define errorstatus(s)	((s) > LUA_YIELD)


/*
** {======================================================
** Error-recovery functions
** =======================================================
*/

/*
** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By
** default, Lua handles errors with exceptions when compiling as
** C++ code, with _longjmp/_setjmp when asked to use them, and with
** longjmp/setjmp otherwise.
*/
#if !defined(LUAI_THROW)				/* { */

#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)	/* { */

/* C++ exceptions */
#define LUAI_THROW(L,c)		throw(c)
#define LUAI_TRY(L,c,a) \
	try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
#define luai_jmpbuf		int  /* dummy variable */

#elif defined(LUA_USE_POSIX)				/* }{ */

/* in POSIX, try _longjmp/_setjmp (more efficient) */
#define LUAI_THROW(L,c)		_longjmp((c)->b, 1)
#define LUAI_TRY(L,c,a)		if (_setjmp((c)->b) == 0) { a }
#define luai_jmpbuf		jmp_buf

#else							/* }{ */

/* ISO C handling with long jumps */
#define LUAI_THROW(L,c)		longjmp((c)->b, 1)
#define LUAI_TRY(L,c,a)		if (setjmp((c)->b) == 0) { a }
#define luai_jmpbuf		jmp_buf

#endif							/* } */

#endif							/* } */



/* chain list of long jump buffers */
struct lua_longjmp {
  struct lua_longjmp *previous;
  luai_jmpbuf b;
  volatile int status;  /* error code */
};


static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
  switch (errcode) {
    case LUA_ERRMEM: {  /* memory error? */
      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */
      break;
    }
    case LUA_ERRERR: {
      setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
      break;
    }
    default: {
      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */
      break;
    }
  }
  L->top = oldtop + 1;
}


l_noret luaD_throw (lua_State *L, int errcode) {
  if (L->errorJmp) {  /* thread has an error handler? */
    L->errorJmp->status = errcode;  /* set status */
    LUAI_THROW(L, L->errorJmp);  /* jump to it */
  }
  else {  /* thread has no error handler */
    global_State *g = G(L);
    L->status = cast_byte(errcode);  /* mark it as dead */
    if (g->mainthread->errorJmp) {  /* main thread has a handler? */
      setobjs2s(L, g->mainthread->top++, L->top - 1);  /* copy error obj. */
      luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */
    }
    else {  /* no handler at all; abort */
      if (g->panic) {  /* panic function? */
        seterrorobj(L, errcode, L->top);  /* assume EXTRA_STACK */
        if (L->ci->top < L->top)
          L->ci->top = L->top;  /* pushing msg. can break this invariant */
        lua_unlock(L);
        g->panic(L);  /* call panic function (last chance to jump out) */
      }
      abort();
    }
  }
}


int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
  unsigned short oldnCcalls = L->nCcalls;
  struct lua_longjmp lj;
  lj.status = LUA_OK;
  lj.previous = L->errorJmp;  /* chain new error handler */
  L->errorJmp = &lj;
  LUAI_TRY(L, &lj,
    (*f)(L, ud);
  );
  L->errorJmp = lj.previous;  /* restore old error handler */
  L->nCcalls = oldnCcalls;
  return lj.status;
}

/* }====================================================== */


/*
** {==================================================================
** Stack reallocation
** ===================================================================
*/
static void correctstack (lua_State *L, TValue *oldstack) {
  CallInfo *ci;
  UpVal *up;
  L->top = (L->top - oldstack) + L->stack;
  for (up = L->openupval; up != NULL; up = up->u.open.next)
    up->v = (up->v - oldstack) + L->stack;
  for (ci = L->ci; ci != NULL; ci = ci->previous) {
    ci->top = (ci->top - oldstack) + L->stack;
    ci->func = (ci->func - oldstack) + L->stack;
    if (isLua(ci))
      ci->u.l.base = (ci->u.l.base - oldstack) + L->stack;
  }
}


/* some space for error handling */
#define ERRORSTACKSIZE	(LUAI_MAXSTACK + 200)


void luaD_reallocstack (lua_State *L, int newsize) {
  TValue *oldstack = L->stack;
  int lim = L->stacksize;
  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);
  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);
  luaM_reallocvector(L, L->stack, L->stacksize, newsize, TValue);
  for (; lim < newsize; lim++)
    setnilvalue(L->stack + lim); /* erase new segment */
  L->stacksize = newsize;
  L->stack_last = L->stack + newsize - EXTRA_STACK;
  correctstack(L, oldstack);
}


void luaD_growstack (lua_State *L, int n) {
  int size = L->stacksize;
  if (size > LUAI_MAXSTACK)  /* error after extra size? */
    luaD_throw(L, LUA_ERRERR);
  else {
    int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;
    int newsize = 2 * size;
    if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;
    if (newsize < needed) newsize = needed;
    if (newsize > LUAI_MAXSTACK) {  /* stack overflow? */
      luaD_reallocstack(L, ERRORSTACKSIZE);
      luaG_runerror(L, "stack overflow");
    }
    else
      luaD_reallocstack(L, newsize);
  }
}


static int stackinuse (lua_State *L) {
  CallInfo *ci;
  StkId lim = L->top;
  for (ci = L->ci; ci != NULL; ci = ci->previous) {
    if (lim < ci->top) lim = ci->top;
  }
  lua_assert(lim <= L->stack_last);
  return cast_int(lim - L->stack) + 1;  /* part of stack in use */
}


void luaD_shrinkstack (lua_State *L) {
  int inuse = stackinuse(L);
  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;
  if (goodsize > LUAI_MAXSTACK)
    goodsize = LUAI_MAXSTACK;  /* respect stack limit */
  if (L->stacksize > LUAI_MAXSTACK)  /* had been handling stack overflow? */
    luaE_freeCI(L);  /* free all CIs (list grew because of an error) */
  else
    luaE_shrinkCI(L);  /* shrink list */
  /* if thread is currently not handling a stack overflow and its
     good size is smaller than current size, shrink its stack */
  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&
      goodsize < L->stacksize)
    luaD_reallocstack(L, goodsize);
  else  /* don't change stack */
    condmovestack(L,{},{});  /* (change only for debugging) */
}


void luaD_inctop (lua_State *L) {
  luaD_checkstack(L, 1);
  L->top++;
}

/* }================================================================== */


/*
** Call a hook for the given event. Make sure there is a hook to be
** called. (Both 'L->hook' and 'L->hookmask', which triggers this
** function, can be changed asynchronously by signals.)
*/
void luaD_hook (lua_State *L, int event, int line) {
  lua_Hook hook = L->hook;
  if (hook && L->allowhook) {  /* make sure there is a hook */
    CallInfo *ci = L->ci;
    ptrdiff_t top = savestack(L, L->top);
    ptrdiff_t ci_top = savestack(L, ci->top);
    lua_Debug ar;
    ar.event = event;
    ar.currentline = line;
    ar.i_ci = ci;
    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
    ci->top = L->top + LUA_MINSTACK;
    lua_assert(ci->top <= L->stack_last);
    L->allowhook = 0;  /* cannot call hooks inside a hook */
    ci->callstatus |= CIST_HOOKED;
    lua_unlock(L);
    (*hook)(L, &ar);
    lua_lock(L);
    lua_assert(!L->allowhook);
    L->allowhook = 1;
    ci->top = restorestack(L, ci_top);
    L->top = restorestack(L, top);
    ci->callstatus &= ~CIST_HOOKED;
  }
}


static void callhook (lua_State *L, CallInfo *ci) {
  int hook = LUA_HOOKCALL;
  ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */
  if (isLua(ci->previous) &&
      GET_OPCODE(*(ci->previous->u.l.savedpc - 1)) == OP_TAILCALL) {
    ci->callstatus |= CIST_TAIL;
    hook = LUA_HOOKTAILCALL;
  }
  luaD_hook(L, hook, -1);
  ci->u.l.savedpc--;  /* correct 'pc' */
}


static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
  int i;
  int nfixargs = p->numparams;
  StkId base, fixed;
  /* move fixed parameters to final position */
  fixed = L->top - actual;  /* first fixed argument */
  base = L->top;  /* final position of first argument */
  for (i = 0; i < nfixargs && i < actual; i++) {
    setobjs2s(L, L->top++, fixed + i);
    setnilvalue(fixed + i);  /* erase original copy (for GC) */
  }
  for (; i < nfixargs; i++)
    setnilvalue(L->top++);  /* complete missing arguments */
  return base;
}


/*
** Check whether __call metafield of 'func' is a function. If so, put
** it in stack below original 'func' so that 'luaD_precall' can call
** it. Raise an error if __call metafield is not a function.
*/
static void tryfuncTM (lua_State *L, StkId func) {
  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
  StkId p;
  if (!ttisfunction(tm))
    luaG_typeerror(L, func, "call");
  /* Open a hole inside the stack at 'func' */
  for (p = L->top; p > func; p--)
    setobjs2s(L, p, p-1);
  L->top++;  /* slot ensured by caller */
  setobj2s(L, func, tm);  /* tag method is the new function to be called */
}


/*
** Given 'nres' results at 'firstResult', move 'wanted' of them to 'res'.
** Handle most typical cases (zero results for commands, one result for
** expressions, multiple results for tail calls/single parameters)
** separated.
*/
static int moveresults (lua_State *L, const TValue *firstResult, StkId res,
                                      int nres, int wanted) {
  switch (wanted) {  /* handle typical cases separately */
    case 0: break;  /* nothing to move */
    case 1: {  /* one result needed */
      if (nres == 0)   /* no results? */
        firstResult = luaO_nilobject;  /* adjust with nil */
      setobjs2s(L, res, firstResult);  /* move it to proper place */
      break;
    }
    case LUA_MULTRET: {
      int i;
      for (i = 0; i < nres; i++)  /* move all results to correct place */
        setobjs2s(L, res + i, firstResult + i);
      L->top = res + nres;
      return 0;  /* wanted == LUA_MULTRET */
    }
    default: {
      int i;
      if (wanted <= nres) {  /* enough results? */
        for (i = 0; i < wanted; i++)  /* move wanted results to correct place */
          setobjs2s(L, res + i, firstResult + i);
      }
      else {  /* not enough results; use all of them plus nils */
        for (i = 0; i < nres; i++)  /* move all results to correct place */
          setobjs2s(L, res + i, firstResult + i);
        for (; i < wanted; i++)  /* complete wanted number of results */
          setnilvalue(res + i);
      }
      break;
    }
  }
  L->top = res + wanted;  /* top points after the last result */
  return 1;
}


/*
** Finishes a function call: calls hook if necessary, removes CallInfo,
** moves current number of results to proper place; returns 0 iff call
** wanted multiple (variable number of) results.
*/
int luaD_poscall (lua_State *L, CallInfo *ci, StkId firstResult, int nres) {
  StkId res;
  int wanted = ci->nresults;
  if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE)) {
    if (L->hookmask & LUA_MASKRET) {
      ptrdiff_t fr = savestack(L, firstResult);  /* hook may change stack */
      luaD_hook(L, LUA_HOOKRET, -1);
      firstResult = restorestack(L, fr);
    }
    L->oldpc = ci->previous->u.l.savedpc;  /* 'oldpc' for caller function */
  }
  res = ci->func;  /* res == final position of 1st result */
  L->ci = ci->previous;  /* back to caller */
  /* move results to proper place */
  return moveresults(L, firstResult, res, nres, wanted);
}



#define next_ci(L) (L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)))


/* macro to check stack size, preserving 'p' */
#define checkstackp(L,n,p)  \
  luaD_checkstackaux(L, n, \
    ptrdiff_t t__ = savestack(L, p);  /* save 'p' */ \
    luaC_checkGC(L),  /* stack grow uses memory */ \
    p = restorestack(L, t__))  /* 'pos' part: restore 'p' */


/*
** Prepares a function call: checks the stack, creates a new CallInfo
** entry, fills in the relevant information, calls hook if needed.
** If function is a C function, does the call, too. (Otherwise, leave
** the execution ('luaV_execute') to the caller, to allow stackless
** calls.) Returns true iff function has been executed (C function).
*/
int luaD_precall (lua_State *L, StkId func, int nresults) {
  lua_CFunction f;
  CallInfo *ci;
  switch (ttype(func)) {
    case LUA_TCCL:  /* C closure */
      f = clCvalue(func)->f;
      goto Cfunc;
    case LUA_TLCF:  /* light C function */
      f = fvalue(func);
     Cfunc: {
      int n;  /* number of returns */
      checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */
      ci = next_ci(L);  /* now 'enter' new function */
      ci->nresults = nresults;
      ci->func = func;
      ci->top = L->top + LUA_MINSTACK;
      lua_assert(ci->top <= L->stack_last);
      ci->callstatus = 0;
      if (L->hookmask & LUA_MASKCALL)
        luaD_hook(L, LUA_HOOKCALL, -1);
      lua_unlock(L);
      n = (*f)(L);  /* do the actual call */
      lua_lock(L);
      api_checknelems(L, n);
      luaD_poscall(L, ci, L->top - n, n);
      return 1;
    }
    case LUA_TLCL: {  /* Lua function: prepare its call */
      StkId base;
      Proto *p = clLvalue(func)->p;
      int n = cast_int(L->top - func) - 1;  /* number of real arguments */
      int fsize = p->maxstacksize;  /* frame size */
      checkstackp(L, fsize, func);
      if (p->is_vararg)
        base = adjust_varargs(L, p, n);
      else {  /* non vararg function */
        for (; n < p->numparams; n++)
          setnilvalue(L->top++);  /* complete missing arguments */
        base = func + 1;
      }
      ci = next_ci(L);  /* now 'enter' new function */
      ci->nresults = nresults;
      ci->func = func;
      ci->u.l.base = base;
      L->top = ci->top = base + fsize;
      lua_assert(ci->top <= L->stack_last);
      ci->u.l.savedpc = p->code;  /* starting point */
      ci->callstatus = CIST_LUA;
      if (L->hookmask & LUA_MASKCALL)
        callhook(L, ci);
      return 0;
    }
    default: {  /* not a function */
      checkstackp(L, 1, func);  /* ensure space for metamethod */
      tryfuncTM(L, func);  /* try to get '__call' metamethod */
      return luaD_precall(L, func, nresults);  /* now it must be a function */
    }
  }
}


/*
** Check appropriate error for stack overflow ("regular" overflow or
** overflow while handling stack overflow). If 'nCalls' is larger than
** LUAI_MAXCCALLS (which means it is handling a "regular" overflow) but
** smaller than 9/8 of LUAI_MAXCCALLS, does not report an error (to
** allow overflow handling to work)
*/
static void stackerror (lua_State *L) {
  if (L->nCcalls == LUAI_MAXCCALLS)
    luaG_runerror(L, "C stack overflow");
  else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))
    luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
}


/*
** Call a function (C or Lua). The function to be called is at *func.
** The arguments are on the stack, right after the function.
** When returns, all the results are on the stack, starting at the original
** function position.
*/
void luaD_call (lua_State *L, StkId func, int nResults) {
  if (++L->nCcalls >= LUAI_MAXCCALLS)
    stackerror(L);
  if (!luaD_precall(L, func, nResults))  /* is a Lua function? */
    luaV_execute(L);  /* call it */
  L->nCcalls--;
}


/*
** Similar to 'luaD_call', but does not allow yields during the call
*/
void luaD_callnoyield (lua_State *L, StkId func, int nResults) {
  L->nny++;
  luaD_call(L, func, nResults);
  L->nny--;
}


/*
** Completes the execution of an interrupted C function, calling its
** continuation function.
*/
static void finishCcall (lua_State *L, int status) {
  CallInfo *ci = L->ci;
  int n;
  /* must have a continuation and must be able to call it */
  lua_assert(ci->u.c.k != NULL && L->nny == 0);
  /* error status can only happen in a protected call */
  lua_assert((ci->callstatus & CIST_YPCALL) || status == LUA_YIELD);
  if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */
    ci->callstatus &= ~CIST_YPCALL;  /* continuation is also inside it */
    L->errfunc = ci->u.c.old_errfunc;  /* with the same error function */
  }
  /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already
     handled */
  adjustresults(L, ci->nresults);
  lua_unlock(L);
  n = (*ci->u.c.k)(L, status, ci->u.c.ctx);  /* call continuation function */
  lua_lock(L);
  api_checknelems(L, n);
  luaD_poscall(L, ci, L->top - n, n);  /* finish 'luaD_precall' */
}


/*
** Executes "full continuation" (everything in the stack) of a
** previously interrupted coroutine until the stack is empty (or another
** interruption long-jumps out of the loop). If the coroutine is
** recovering from an error, 'ud' points to the error status, which must
** be passed to the first continuation function (otherwise the default
** status is LUA_YIELD).
*/
static void unroll (lua_State *L, void *ud) {
  if (ud != NULL)  /* error status? */
    finishCcall(L, *(int *)ud);  /* finish 'lua_pcallk' callee */
  while (L->ci != &L->base_ci) {  /* something in the stack */
    if (!isLua(L->ci))  /* C function? */
      finishCcall(L, LUA_YIELD);  /* complete its execution */
    else {  /* Lua function */
      luaV_finishOp(L);  /* finish interrupted instruction */
      luaV_execute(L);  /* execute down to higher C 'boundary' */
    }
  }
}


/*
** Try to find a suspended protected call (a "recover point") for the
** given thread.
*/
static CallInfo *findpcall (lua_State *L) {
  CallInfo *ci;
  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */
    if (ci->callstatus & CIST_YPCALL)
      return ci;
  }
  return NULL;  /* no pending pcall */
}


/*
** Recovers from an error in a coroutine. Finds a recover point (if
** there is one) and completes the execution of the interrupted
** 'luaD_pcall'. If there is no recover point, returns zero.
*/
static int recover (lua_State *L, int status) {
  StkId oldtop;
  CallInfo *ci = findpcall(L);
  if (ci == NULL) return 0;  /* no recovery point */
  /* "finish" luaD_pcall */
  oldtop = restorestack(L, ci->extra);
  luaF_close(L, oldtop);
  seterrorobj(L, status, oldtop);
  L->ci = ci;
  L->allowhook = getoah(ci->callstatus);  /* restore original 'allowhook' */
  L->nny = 0;  /* should be zero to be yieldable */
  luaD_shrinkstack(L);
  L->errfunc = ci->u.c.old_errfunc;
  return 1;  /* continue running the coroutine */
}


/*
** Signal an error in the call to 'lua_resume', not in the execution
** of the coroutine itself. (Such errors should not be handled by any
** coroutine error handler and should not kill the coroutine.)
*/
static int resume_error (lua_State *L, const char *msg, int narg) {
  L->top -= narg;  /* remove args from the stack */
  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */
  api_incr_top(L);
  lua_unlock(L);
  return LUA_ERRRUN;
}


/*
** Do the work for 'lua_resume' in protected mode. Most of the work
** depends on the status of the coroutine: initial state, suspended
** inside a hook, or regularly suspended (optionally with a continuation
** function), plus erroneous cases: non-suspended coroutine or dead
** coroutine.
*/
static void resume (lua_State *L, void *ud) {
  int n = *(cast(int*, ud));  /* number of arguments */
  StkId firstArg = L->top - n;  /* first argument */
  CallInfo *ci = L->ci;
  if (L->status == LUA_OK) {  /* starting a coroutine? */
    if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))  /* Lua function? */
      luaV_execute(L);  /* call it */
  }
  else {  /* resuming from previous yield */
    lua_assert(L->status == LUA_YIELD);
    L->status = LUA_OK;  /* mark that it is running (again) */
    ci->func = restorestack(L, ci->extra);
    if (isLua(ci))  /* yielded inside a hook? */
      luaV_execute(L);  /* just continue running Lua code */
    else {  /* 'common' yield */
      if (ci->u.c.k != NULL) {  /* does it have a continuation function? */
        lua_unlock(L);
        n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */
        lua_lock(L);
        api_checknelems(L, n);
        firstArg = L->top - n;  /* yield results come from continuation */
      }
      luaD_poscall(L, ci, firstArg, n);  /* finish 'luaD_precall' */
    }
    unroll(L, NULL);  /* run continuation */
  }
}


LUA_API int lua_resume (lua_State *L, lua_State *from, int nargs) {
  int status;
  unsigned short oldnny = L->nny;  /* save "number of non-yieldable" calls */
  lua_lock(L);
  if (L->status == LUA_OK) {  /* may be starting a coroutine */
    if (L->ci != &L->base_ci)  /* not in base level? */
      return resume_error(L, "cannot resume non-suspended coroutine", nargs);
  }
  else if (L->status != LUA_YIELD)
    return resume_error(L, "cannot resume dead coroutine", nargs);
  L->nCcalls = (from) ? from->nCcalls + 1 : 1;
  if (L->nCcalls >= LUAI_MAXCCALLS)
    return resume_error(L, "C stack overflow", nargs);
  luai_userstateresume(L, nargs);
  L->nny = 0;  /* allow yields */
  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);
  status = luaD_rawrunprotected(L, resume, &nargs);
  if (status == -1)  /* error calling 'lua_resume'? */
    status = LUA_ERRRUN;
  else {  /* continue running after recoverable errors */
    while (errorstatus(status) && recover(L, status)) {
      /* unroll continuation */
      status = luaD_rawrunprotected(L, unroll, &status);
    }
    if (errorstatus(status)) {  /* unrecoverable error? */
      L->status = cast_byte(status);  /* mark thread as 'dead' */
      seterrorobj(L, status, L->top);  /* push error message */
      L->ci->top = L->top;
    }
    else lua_assert(status == L->status);  /* normal end or yield */
  }
  L->nny = oldnny;  /* restore 'nny' */
  L->nCcalls--;
  lua_assert(L->nCcalls == ((from) ? from->nCcalls : 0));
  lua_unlock(L);
  return status;
}


LUA_API int lua_isyieldable (lua_State *L) {
  return (L->nny == 0);
}


LUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,
                        lua_KFunction k) {
  CallInfo *ci = L->ci;
  luai_userstateyield(L, nresults);
  lua_lock(L);
  api_checknelems(L, nresults);
  if (L->nny > 0) {
    if (L != G(L)->mainthread)
      luaG_runerror(L, "attempt to yield across a C-call boundary");
    else
      luaG_runerror(L, "attempt to yield from outside a coroutine");
  }
  L->status = LUA_YIELD;
  ci->extra = savestack(L, ci->func);  /* save current 'func' */
  if (isLua(ci)) {  /* inside a hook? */
    api_check(L, k == NULL, "hooks cannot continue after yielding");
  }
  else {
    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */
      ci->u.c.ctx = ctx;  /* save context */
    ci->func = L->top - nresults - 1;  /* protect stack below results */
    luaD_throw(L, LUA_YIELD);
  }
  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */
  lua_unlock(L);
  return 0;  /* return to 'luaD_hook' */
}


int luaD_pcall (lua_State *L, Pfunc func, void *u,
                ptrdiff_t old_top, ptrdiff_t ef) {
  int status;
  CallInfo *old_ci = L->ci;
  lu_byte old_allowhooks = L->allowhook;
  unsigned short old_nny = L->nny;
  ptrdiff_t old_errfunc = L->errfunc;
  L->errfunc = ef;
  status = luaD_rawrunprotected(L, func, u);
  if (status != LUA_OK) {  /* an error occurred? */
    StkId oldtop = restorestack(L, old_top);
    luaF_close(L, oldtop);  /* close possible pending closures */
    seterrorobj(L, status, oldtop);
    L->ci = old_ci;
    L->allowhook = old_allowhooks;
    L->nny = old_nny;
    luaD_shrinkstack(L);
  }
  L->errfunc = old_errfunc;
  return status;
}



/*
** Execute a protected parser.
*/
struct SParser {  /* data to 'f_parser' */
  ZIO *z;
  Mbuffer buff;  /* dynamic structure used by the scanner */
  Dyndata dyd;  /* dynamic structures used by the parser */
  const char *mode;
  const char *name;
};


static void checkmode (lua_State *L, const char *mode, const char *x) {
  if (mode && strchr(mode, x[0]) == NULL) {
    luaO_pushfstring(L,
       "attempt to load a %s chunk (mode is '%s')", x, mode);
    luaD_throw(L, LUA_ERRSYNTAX);
  }
}


static void f_parser (lua_State *L, void *ud) {
  LClosure *cl;
  struct SParser *p = cast(struct SParser *, ud);
  int c = zgetc(p->z);  /* read first character */
  if (c == LUA_SIGNATURE[0]) {
    checkmode(L, p->mode, "binary");
    cl = luaU_undump(L, p->z, p->name);
  }
  else {
    checkmode(L, p->mode, "text");
    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
  }
  lua_assert(cl->nupvalues == cl->p->sizeupvalues);
  luaF_initupvals(L, cl);
}


int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
                                        const char *mode) {
  struct SParser p;
  int status;
  L->nny++;  /* cannot yield during parsing */
  p.z = z; p.name = name; p.mode = mode;
  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;
  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;
  p.dyd.label.arr = NULL; p.dyd.label.size = 0;
  luaZ_initbuffer(L, &p.buff);
  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);
  luaZ_freebuffer(L, &p.buff);
  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);
  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);
  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);
  L->nny--;
  return status;
}



```

`src/Lua/ldo.h`:

```h
/*
** $Id: ldo.h,v 2.29 2015/12/21 13:02:14 roberto Exp $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/

#ifndef ldo_h
#define ldo_h


#include "lobject.h"
#include "lstate.h"
#include "lzio.h"


/*
** Macro to check stack size and grow stack if needed.  Parameters
** 'pre'/'pos' allow the macro to preserve a pointer into the
** stack across reallocations, doing the work only when needed.
** 'condmovestack' is used in heavy tests to force a stack reallocation
** at every check.
*/
#define luaD_checkstackaux(L,n,pre,pos)  \
	if (L->stack_last - L->top <= (n)) \
	  { pre; luaD_growstack(L, n); pos; } else { condmovestack(L,pre,pos); }

/* In general, 'pre'/'pos' are empty (nothing to save) */
#define luaD_checkstack(L,n)	luaD_checkstackaux(L,n,(void)0,(void)0)



#define savestack(L,p)		((char *)(p) - (char *)L->stack)
#define restorestack(L,n)	((TValue *)((char *)L->stack + (n)))


/* type of protected functions, to be ran by 'runprotected' */
typedef void (*Pfunc) (lua_State *L, void *ud);

LUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
                                                  const char *mode);
LUAI_FUNC void luaD_hook (lua_State *L, int event, int line);
LUAI_FUNC int luaD_precall (lua_State *L, StkId func, int nresults);
LUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults);
LUAI_FUNC void luaD_callnoyield (lua_State *L, StkId func, int nResults);
LUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,
                                        ptrdiff_t oldtop, ptrdiff_t ef);
LUAI_FUNC int luaD_poscall (lua_State *L, CallInfo *ci, StkId firstResult,
                                          int nres);
LUAI_FUNC void luaD_reallocstack (lua_State *L, int newsize);
LUAI_FUNC void luaD_growstack (lua_State *L, int n);
LUAI_FUNC void luaD_shrinkstack (lua_State *L);
LUAI_FUNC void luaD_inctop (lua_State *L);

LUAI_FUNC l_noret luaD_throw (lua_State *L, int errcode);
LUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);

#endif


```

`src/Lua/ldump.c`:

```c
/*
** $Id: ldump.c,v 2.37 2015/10/08 15:53:49 roberto Exp $
** save precompiled Lua chunks
** See Copyright Notice in lua.h
*/

#define ldump_c
#define LUA_CORE

#include "lprefix.h"


#include <stddef.h>

#include "lua.h"

#include "lobject.h"
#include "lstate.h"
#include "lundump.h"


typedef struct {
  lua_State *L;
  lua_Writer writer;
  void *data;
  int strip;
  int status;
} DumpState;


/*
** All high-level dumps go through DumpVector; you can change it to
** change the endianness of the result
*/
#define DumpVector(v,n,D)	DumpBlock(v,(n)*sizeof((v)[0]),D)

#define DumpLiteral(s,D)	DumpBlock(s, sizeof(s) - sizeof(char), D)


static void DumpBlock (const void *b, size_t size, DumpState *D) {
  if (D->status == 0 && size > 0) {
    lua_unlock(D->L);
    D->status = (*D->writer)(D->L, b, size, D->data);
    lua_lock(D->L);
  }
}


#define DumpVar(x,D)		DumpVector(&x,1,D)


static void DumpByte (int y, DumpState *D) {
  lu_byte x = (lu_byte)y;
  DumpVar(x, D);
}


static void DumpInt (int x, DumpState *D) {
  DumpVar(x, D);
}


static void DumpNumber (lua_Number x, DumpState *D) {
  DumpVar(x, D);
}


static void DumpInteger (lua_Integer x, DumpState *D) {
  DumpVar(x, D);
}


static void DumpString (const TString *s, DumpState *D) {
  if (s == NULL)
    DumpByte(0, D);
  else {
    size_t size = tsslen(s) + 1;  /* include trailing '\0' */
    const char *str = getstr(s);
    if (size < 0xFF)
      DumpByte(cast_int(size), D);
    else {
      DumpByte(0xFF, D);
      DumpVar(size, D);
    }
    DumpVector(str, size - 1, D);  /* no need to save '\0' */
  }
}


static void DumpCode (const Proto *f, DumpState *D) {
  DumpInt(f->sizecode, D);
  DumpVector(f->code, f->sizecode, D);
}


static void DumpFunction(const Proto *f, TString *psource, DumpState *D);

static void DumpConstants (const Proto *f, DumpState *D) {
  int i;
  int n = f->sizek;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    const TValue *o = &f->k[i];
    DumpByte(ttype(o), D);
    switch (ttype(o)) {
    case LUA_TNIL:
      break;
    case LUA_TBOOLEAN:
      DumpByte(bvalue(o), D);
      break;
    case LUA_TNUMFLT:
      DumpNumber(fltvalue(o), D);
      break;
    case LUA_TNUMINT:
      DumpInteger(ivalue(o), D);
      break;
    case LUA_TSHRSTR:
    case LUA_TLNGSTR:
      DumpString(tsvalue(o), D);
      break;
    default:
      lua_assert(0);
    }
  }
}


static void DumpProtos (const Proto *f, DumpState *D) {
  int i;
  int n = f->sizep;
  DumpInt(n, D);
  for (i = 0; i < n; i++)
    DumpFunction(f->p[i], f->source, D);
}


static void DumpUpvalues (const Proto *f, DumpState *D) {
  int i, n = f->sizeupvalues;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    DumpByte(f->upvalues[i].instack, D);
    DumpByte(f->upvalues[i].idx, D);
  }
}


static void DumpDebug (const Proto *f, DumpState *D) {
  int i, n;
  n = (D->strip) ? 0 : f->sizelineinfo;
  DumpInt(n, D);
  DumpVector(f->lineinfo, n, D);
  n = (D->strip) ? 0 : f->sizelocvars;
  DumpInt(n, D);
  for (i = 0; i < n; i++) {
    DumpString(f->locvars[i].varname, D);
    DumpInt(f->locvars[i].startpc, D);
    DumpInt(f->locvars[i].endpc, D);
  }
  n = (D->strip) ? 0 : f->sizeupvalues;
  DumpInt(n, D);
  for (i = 0; i < n; i++)
    DumpString(f->upvalues[i].name, D);
}


static void DumpFunction (const Proto *f, TString *psource, DumpState *D) {
  if (D->strip || f->source == psource)
    DumpString(NULL, D);  /* no debug info or same source as its parent */
  else
    DumpString(f->source, D);
  DumpInt(f->linedefined, D);
  DumpInt(f->lastlinedefined, D);
  DumpByte(f->numparams, D);
  DumpByte(f->is_vararg, D);
  DumpByte(f->maxstacksize, D);
  DumpCode(f, D);
  DumpConstants(f, D);
  DumpUpvalues(f, D);
  DumpProtos(f, D);
  DumpDebug(f, D);
}


static void DumpHeader (DumpState *D) {
  DumpLiteral(LUA_SIGNATURE, D);
  DumpByte(LUAC_VERSION, D);
  DumpByte(LUAC_FORMAT, D);
  DumpLiteral(LUAC_DATA, D);
  DumpByte(sizeof(int), D);
  DumpByte(sizeof(size_t), D);
  DumpByte(sizeof(Instruction), D);
  DumpByte(sizeof(lua_Integer), D);
  DumpByte(sizeof(lua_Number), D);
  DumpInteger(LUAC_INT, D);
  DumpNumber(LUAC_NUM, D);
}


/*
** dump Lua function as precompiled chunk
*/
int luaU_dump(lua_State *L, const Proto *f, lua_Writer w, void *data,
              int strip) {
  DumpState D;
  D.L = L;
  D.writer = w;
  D.data = data;
  D.strip = strip;
  D.status = 0;
  DumpHeader(&D);
  DumpByte(f->sizeupvalues, &D);
  DumpFunction(f, NULL, &D);
  return D.status;
}


```

`src/Lua/lfunc.c`:

```c
/*
** $Id: lfunc.c,v 2.45 2014/11/02 19:19:04 roberto Exp $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/

#define lfunc_c
#define LUA_CORE

#include "lprefix.h"


#include <stddef.h>

#include "lua.h"

#include "lfunc.h"
#include "lgc.h"
#include "lmem.h"
#include "lobject.h"
#include "lstate.h"



CClosure *luaF_newCclosure (lua_State *L, int n) {
  GCObject *o = luaC_newobj(L, LUA_TCCL, sizeCclosure(n));
  CClosure *c = gco2ccl(o);
  c->nupvalues = cast_byte(n);
  return c;
}


LClosure *luaF_newLclosure (lua_State *L, int n) {
  GCObject *o = luaC_newobj(L, LUA_TLCL, sizeLclosure(n));
  LClosure *c = gco2lcl(o);
  c->p = NULL;
  c->nupvalues = cast_byte(n);
  while (n--) c->upvals[n] = NULL;
  return c;
}

/*
** fill a closure with new closed upvalues
*/
void luaF_initupvals (lua_State *L, LClosure *cl) {
  int i;
  for (i = 0; i < cl->nupvalues; i++) {
    UpVal *uv = luaM_new(L, UpVal);
    uv->refcount = 1;
    uv->v = &uv->u.value;  /* make it closed */
    setnilvalue(uv->v);
    cl->upvals[i] = uv;
  }
}


UpVal *luaF_findupval (lua_State *L, StkId level) {
  UpVal **pp = &L->openupval;
  UpVal *p;
  UpVal *uv;
  lua_assert(isintwups(L) || L->openupval == NULL);
  while (*pp != NULL && (p = *pp)->v >= level) {
    lua_assert(upisopen(p));
    if (p->v == level)  /* found a corresponding upvalue? */
      return p;  /* return it */
    pp = &p->u.open.next;
  }
  /* not found: create a new upvalue */
  uv = luaM_new(L, UpVal);
  uv->refcount = 0;
  uv->u.open.next = *pp;  /* link it to list of open upvalues */
  uv->u.open.touched = 1;
  *pp = uv;
  uv->v = level;  /* current value lives in the stack */
  if (!isintwups(L)) {  /* thread not in list of threads with upvalues? */
    L->twups = G(L)->twups;  /* link it to the list */
    G(L)->twups = L;
  }
  return uv;
}


void luaF_close (lua_State *L, StkId level) {
  UpVal *uv;
  while (L->openupval != NULL && (uv = L->openupval)->v >= level) {
    lua_assert(upisopen(uv));
    L->openupval = uv->u.open.next;  /* remove from 'open' list */
    if (uv->refcount == 0)  /* no references? */
      luaM_free(L, uv);  /* free upvalue */
    else {
      setobj(L, &uv->u.value, uv->v);  /* move value to upvalue slot */
      uv->v = &uv->u.value;  /* now current value lives here */
      luaC_upvalbarrier(L, uv);
    }
  }
}


Proto *luaF_newproto (lua_State *L) {
  GCObject *o = luaC_newobj(L, LUA_TPROTO, sizeof(Proto));
  Proto *f = gco2p(o);
  f->k = NULL;
  f->sizek = 0;
  f->p = NULL;
  f->sizep = 0;
  f->code = NULL;
  f->cache = NULL;
  f->sizecode = 0;
  f->lineinfo = NULL;
  f->sizelineinfo = 0;
  f->upvalues = NULL;
  f->sizeupvalues = 0;
  f->numparams = 0;
  f->is_vararg = 0;
  f->maxstacksize = 0;
  f->locvars = NULL;
  f->sizelocvars = 0;
  f->linedefined = 0;
  f->lastlinedefined = 0;
  f->source = NULL;
  return f;
}


void luaF_freeproto (lua_State *L, Proto *f) {
  luaM_freearray(L, f->code, f->sizecode);
  luaM_freearray(L, f->p, f->sizep);
  luaM_freearray(L, f->k, f->sizek);
  luaM_freearray(L, f->lineinfo, f->sizelineinfo);
  luaM_freearray(L, f->locvars, f->sizelocvars);
  luaM_freearray(L, f->upvalues, f->sizeupvalues);
  luaM_free(L, f);
}


/*
** Look for n-th local variable at line 'line' in function 'func'.
** Returns NULL if not found.
*/
const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
  int i;
  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
    if (pc < f->locvars[i].endpc) {  /* is variable active? */
      local_number--;
      if (local_number == 0)
        return getstr(f->locvars[i].varname);
    }
  }
  return NULL;  /* not found */
}


```

`src/Lua/lfunc.h`:

```h
/*
** $Id: lfunc.h,v 2.15 2015/01/13 15:49:11 roberto Exp $
** Auxiliary functions to manipulate prototypes and closures
** See Copyright Notice in lua.h
*/

#ifndef lfunc_h
#define lfunc_h


#include "lobject.h"


#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
                         cast(int, sizeof(TValue)*((n)-1)))

#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
                         cast(int, sizeof(TValue *)*((n)-1)))


/* test whether thread is in 'twups' list */
#define isintwups(L)	(L->twups != L)


/*
** maximum number of upvalues in a closure (both C and Lua). (Value
** must fit in a VM register.)
*/
#define MAXUPVAL	255


/*
** Upvalues for Lua closures
*/
struct UpVal {
  TValue *v;  /* points to stack or to its own value */
  lu_mem refcount;  /* reference counter */
  union {
    struct {  /* (when open) */
      UpVal *next;  /* linked list */
      int touched;  /* mark to avoid cycles with dead threads */
    } open;
    TValue value;  /* the value (when closed) */
  } u;
};

#define upisopen(up)	((up)->v != &(up)->u.value)


LUAI_FUNC Proto *luaF_newproto (lua_State *L);
LUAI_FUNC CClosure *luaF_newCclosure (lua_State *L, int nelems);
LUAI_FUNC LClosure *luaF_newLclosure (lua_State *L, int nelems);
LUAI_FUNC void luaF_initupvals (lua_State *L, LClosure *cl);
LUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);
LUAI_FUNC void luaF_close (lua_State *L, StkId level);
LUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);
LUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,
                                         int pc);


#endif

```

`src/Lua/lgc.c`:

```c
/*
** $Id: lgc.c,v 2.215 2016/12/22 13:08:50 roberto Exp $
** Garbage Collector
** See Copyright Notice in lua.h
*/

#define lgc_c
#define LUA_CORE

#include "lprefix.h"


#include <string.h>

#include "lua.h"

#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lgc.h"
#include "lmem.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"


/*
** internal state for collector while inside the atomic phase. The
** collector should never be in this state while running regular code.
*/
#define GCSinsideatomic		(GCSpause + 1)

/*
** cost of sweeping one element (the size of a small object divided
** by some adjust for the sweep speed)
*/
#define GCSWEEPCOST	((sizeof(TString) + 4) / 4)

/* maximum number of elements to sweep in each single step */
#define GCSWEEPMAX	(cast_int((GCSTEPSIZE / GCSWEEPCOST) / 4))

/* cost of calling one finalizer */
#define GCFINALIZECOST	GCSWEEPCOST


/*
** macro to adjust 'stepmul': 'stepmul' is actually used like
** 'stepmul / STEPMULADJ' (value chosen by tests)
*/
#define STEPMULADJ		200


/*
** macro to adjust 'pause': 'pause' is actually used like
** 'pause / PAUSEADJ' (value chosen by tests)
*/
#define PAUSEADJ		100


/*
** 'makewhite' erases all color bits then sets only the current white
** bit
*/
#define maskcolors	(~(bitmask(BLACKBIT) | WHITEBITS))
#define makewhite(g,x)	\
 (x->marked = cast_byte((x->marked & maskcolors) | luaC_white(g)))

#define white2gray(x)	resetbits(x->marked, WHITEBITS)
#define black2gray(x)	resetbit(x->marked, BLACKBIT)


#define valiswhite(x)   (iscollectable(x) && iswhite(gcvalue(x)))

#define checkdeadkey(n)	lua_assert(!ttisdeadkey(gkey(n)) || ttisnil(gval(n)))


#define checkconsistency(obj)  \
  lua_longassert(!iscollectable(obj) || righttt(obj))


#define markvalue(g,o) { checkconsistency(o); \
  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }

#define markobject(g,t)	{ if (iswhite(t)) reallymarkobject(g, obj2gco(t)); }

/*
** mark an object that can be NULL (either because it is really optional,
** or it was stripped as debug info, or inside an uncompleted structure)
*/
#define markobjectN(g,t)	{ if (t) markobject(g,t); }

static void reallymarkobject (global_State *g, GCObject *o);


/*
** {======================================================
** Generic functions
** =======================================================
*/


/*
** one after last element in a hash array
*/
#define gnodelast(h)	gnode(h, cast(size_t, sizenode(h)))


/*
** link collectable object 'o' into list pointed by 'p'
*/
#define linkgclist(o,p)	((o)->gclist = (p), (p) = obj2gco(o))


/*
** If key is not marked, mark its entry as dead. This allows key to be
** collected, but keeps its entry in the table.  A dead node is needed
** when Lua looks up for a key (it may be part of a chain) and when
** traversing a weak table (key might be removed from the table during
** traversal). Other places never manipulate dead keys, because its
** associated nil value is enough to signal that the entry is logically
** empty.
*/
static void removeentry (Node *n) {
  lua_assert(ttisnil(gval(n)));
  if (valiswhite(gkey(n)))
    setdeadvalue(wgkey(n));  /* unused and unmarked key; remove it */
}


/*
** tells whether a key or value can be cleared from a weak
** table. Non-collectable objects are never removed from weak
** tables. Strings behave as 'values', so are never removed too. for
** other objects: if really collected, cannot keep them; for objects
** being finalized, keep them in keys, but not in values
*/
static int iscleared (global_State *g, const TValue *o) {
  if (!iscollectable(o)) return 0;
  else if (ttisstring(o)) {
    markobject(g, tsvalue(o));  /* strings are 'values', so are never weak */
    return 0;
  }
  else return iswhite(gcvalue(o));
}


/*
** barrier that moves collector forward, that is, mark the white object
** being pointed by a black object. (If in sweep phase, clear the black
** object to white [sweep it] to avoid other barrier calls for this
** same object.)
*/
void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
  global_State *g = G(L);
  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
  if (keepinvariant(g))  /* must keep invariant? */
    reallymarkobject(g, v);  /* restore invariant */
  else {  /* sweep phase */
    lua_assert(issweepphase(g));
    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */
  }
}


/*
** barrier that moves collector backward, that is, mark the black object
** pointing to a white object as gray again.
*/
void luaC_barrierback_ (lua_State *L, Table *t) {
  global_State *g = G(L);
  lua_assert(isblack(t) && !isdead(g, t));
  black2gray(t);  /* make table gray (again) */
  linkgclist(t, g->grayagain);
}


/*
** barrier for assignments to closed upvalues. Because upvalues are
** shared among closures, it is impossible to know the color of all
** closures pointing to it. So, we assume that the object being assigned
** must be marked.
*/
void luaC_upvalbarrier_ (lua_State *L, UpVal *uv) {
  global_State *g = G(L);
  GCObject *o = gcvalue(uv->v);
  lua_assert(!upisopen(uv));  /* ensured by macro luaC_upvalbarrier */
  if (keepinvariant(g))
    markobject(g, o);
}


void luaC_fix (lua_State *L, GCObject *o) {
  global_State *g = G(L);
  lua_assert(g->allgc == o);  /* object must be 1st in 'allgc' list! */
  white2gray(o);  /* they will be gray forever */
  g->allgc = o->next;  /* remove object from 'allgc' list */
  o->next = g->fixedgc;  /* link it to 'fixedgc' list */
  g->fixedgc = o;
}


/*
** create a new collectable object (with given type and size) and link
** it to 'allgc' list.
*/
GCObject *luaC_newobj (lua_State *L, int tt, size_t sz) {
  global_State *g = G(L);
  GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));
  o->marked = luaC_white(g);
  o->tt = tt;
  o->next = g->allgc;
  g->allgc = o;
  return o;
}

/* }====================================================== */



/*
** {======================================================
** Mark functions
** =======================================================
*/


/*
** mark an object. Userdata, strings, and closed upvalues are visited
** and turned black here. Other objects are marked gray and added
** to appropriate list to be visited (and turned black) later. (Open
** upvalues are already linked in 'headuv' list.)
*/
static void reallymarkobject (global_State *g, GCObject *o) {
 reentry:
  white2gray(o);
  switch (o->tt) {
    case LUA_TSHRSTR: {
      gray2black(o);
      g->GCmemtrav += sizelstring(gco2ts(o)->shrlen);
      break;
    }
    case LUA_TLNGSTR: {
      gray2black(o);
      g->GCmemtrav += sizelstring(gco2ts(o)->u.lnglen);
      break;
    }
    case LUA_TUSERDATA: {
      TValue uvalue;
      markobjectN(g, gco2u(o)->metatable);  /* mark its metatable */
      gray2black(o);
      g->GCmemtrav += sizeudata(gco2u(o));
      getuservalue(g->mainthread, gco2u(o), &uvalue);
      if (valiswhite(&uvalue)) {  /* markvalue(g, &uvalue); */
        o = gcvalue(&uvalue);
        goto reentry;
      }
      break;
    }
    case LUA_TLCL: {
      linkgclist(gco2lcl(o), g->gray);
      break;
    }
    case LUA_TCCL: {
      linkgclist(gco2ccl(o), g->gray);
      break;
    }
    case LUA_TTABLE: {
      linkgclist(gco2t(o), g->gray);
      break;
    }
    case LUA_TTHREAD: {
      linkgclist(gco2th(o), g->gray);
      break;
    }
    case LUA_TPROTO: {
      linkgclist(gco2p(o), g->gray);
      break;
    }
    default: lua_assert(0); break;
  }
}


/*
** mark metamethods for basic types
*/
static void markmt (global_State *g) {
  int i;
  for (i=0; i < LUA_NUMTAGS; i++)
    markobjectN(g, g->mt[i]);
}


/*
** mark all objects in list of being-finalized
*/
static void markbeingfnz (global_State *g) {
  GCObject *o;
  for (o = g->tobefnz; o != NULL; o = o->next)
    markobject(g, o);
}


/*
** Mark all values stored in marked open upvalues from non-marked threads.
** (Values from marked threads were already marked when traversing the
** thread.) Remove from the list threads that no longer have upvalues and
** not-marked threads.
*/
static void remarkupvals (global_State *g) {
  lua_State *thread;
  lua_State **p = &g->twups;
  while ((thread = *p) != NULL) {
    lua_assert(!isblack(thread));  /* threads are never black */
    if (isgray(thread) && thread->openupval != NULL)
      p = &thread->twups;  /* keep marked thread with upvalues in the list */
    else {  /* thread is not marked or without upvalues */
      UpVal *uv;
      *p = thread->twups;  /* remove thread from the list */
      thread->twups = thread;  /* mark that it is out of list */
      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {
        if (uv->u.open.touched) {
          markvalue(g, uv->v);  /* remark upvalue's value */
          uv->u.open.touched = 0;
        }
      }
    }
  }
}


/*
** mark root set and reset all gray lists, to start a new collection
*/
static void restartcollection (global_State *g) {
  g->gray = g->grayagain = NULL;
  g->weak = g->allweak = g->ephemeron = NULL;
  markobject(g, g->mainthread);
  markvalue(g, &g->l_registry);
  markmt(g);
  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */
}

/* }====================================================== */


/*
** {======================================================
** Traverse functions
** =======================================================
*/

/*
** Traverse a table with weak values and link it to proper list. During
** propagate phase, keep it in 'grayagain' list, to be revisited in the
** atomic phase. In the atomic phase, if table has any white value,
** put it in 'weak' list, to be cleared.
*/
static void traverseweakvalue (global_State *g, Table *h) {
  Node *n, *limit = gnodelast(h);
  /* if there is array part, assume it may have white values (it is not
     worth traversing it now just to check) */
  int hasclears = (h->sizearray > 0);
  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
    checkdeadkey(n);
    if (ttisnil(gval(n)))  /* entry is empty? */
      removeentry(n);  /* remove it */
    else {
      lua_assert(!ttisnil(gkey(n)));
      markvalue(g, gkey(n));  /* mark key */
      if (!hasclears && iscleared(g, gval(n)))  /* is there a white value? */
        hasclears = 1;  /* table will have to be cleared */
    }
  }
  if (g->gcstate == GCSpropagate)
    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */
  else if (hasclears)
    linkgclist(h, g->weak);  /* has to be cleared later */
}


/*
** Traverse an ephemeron table and link it to proper list. Returns true
** iff any object was marked during this traversal (which implies that
** convergence has to continue). During propagation phase, keep table
** in 'grayagain' list, to be visited again in the atomic phase. In
** the atomic phase, if table has any white->white entry, it has to
** be revisited during ephemeron convergence (as that key may turn
** black). Otherwise, if it has any white key, table has to be cleared
** (in the atomic phase).
*/
static int traverseephemeron (global_State *g, Table *h) {
  int marked = 0;  /* true if an object is marked in this traversal */
  int hasclears = 0;  /* true if table has white keys */
  int hasww = 0;  /* true if table has entry "white-key -> white-value" */
  Node *n, *limit = gnodelast(h);
  unsigned int i;
  /* traverse array part */
  for (i = 0; i < h->sizearray; i++) {
    if (valiswhite(&h->array[i])) {
      marked = 1;
      reallymarkobject(g, gcvalue(&h->array[i]));
    }
  }
  /* traverse hash part */
  for (n = gnode(h, 0); n < limit; n++) {
    checkdeadkey(n);
    if (ttisnil(gval(n)))  /* entry is empty? */
      removeentry(n);  /* remove it */
    else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */
      hasclears = 1;  /* table must be cleared */
      if (valiswhite(gval(n)))  /* value not marked yet? */
        hasww = 1;  /* white-white entry */
    }
    else if (valiswhite(gval(n))) {  /* value not marked yet? */
      marked = 1;
      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */
    }
  }
  /* link table into proper list */
  if (g->gcstate == GCSpropagate)
    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */
  else if (hasww)  /* table has white->white entries? */
    linkgclist(h, g->ephemeron);  /* have to propagate again */
  else if (hasclears)  /* table has white keys? */
    linkgclist(h, g->allweak);  /* may have to clean white keys */
  return marked;
}


static void traversestrongtable (global_State *g, Table *h) {
  Node *n, *limit = gnodelast(h);
  unsigned int i;
  for (i = 0; i < h->sizearray; i++)  /* traverse array part */
    markvalue(g, &h->array[i]);
  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
    checkdeadkey(n);
    if (ttisnil(gval(n)))  /* entry is empty? */
      removeentry(n);  /* remove it */
    else {
      lua_assert(!ttisnil(gkey(n)));
      markvalue(g, gkey(n));  /* mark key */
      markvalue(g, gval(n));  /* mark value */
    }
  }
}


static lu_mem traversetable (global_State *g, Table *h) {
  const char *weakkey, *weakvalue;
  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);
  markobjectN(g, h->metatable);
  if (mode && ttisstring(mode) &&  /* is there a weak mode? */
      ((weakkey = strchr(svalue(mode), 'k')),
       (weakvalue = strchr(svalue(mode), 'v')),
       (weakkey || weakvalue))) {  /* is really weak? */
    black2gray(h);  /* keep table gray */
    if (!weakkey)  /* strong keys? */
      traverseweakvalue(g, h);
    else if (!weakvalue)  /* strong values? */
      traverseephemeron(g, h);
    else  /* all weak */
      linkgclist(h, g->allweak);  /* nothing to traverse now */
  }
  else  /* not weak */
    traversestrongtable(g, h);
  return sizeof(Table) + sizeof(TValue) * h->sizearray +
                         sizeof(Node) * cast(size_t, allocsizenode(h));
}


/*
** Traverse a prototype. (While a prototype is being build, its
** arrays can be larger than needed; the extra slots are filled with
** NULL, so the use of 'markobjectN')
*/
static int traverseproto (global_State *g, Proto *f) {
  int i;
  if (f->cache && iswhite(f->cache))
    f->cache = NULL;  /* allow cache to be collected */
  markobjectN(g, f->source);
  for (i = 0; i < f->sizek; i++)  /* mark literals */
    markvalue(g, &f->k[i]);
  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */
    markobjectN(g, f->upvalues[i].name);
  for (i = 0; i < f->sizep; i++)  /* mark nested protos */
    markobjectN(g, f->p[i]);
  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */
    markobjectN(g, f->locvars[i].varname);
  return sizeof(Proto) + sizeof(Instruction) * f->sizecode +
                         sizeof(Proto *) * f->sizep +
                         sizeof(TValue) * f->sizek +
                         sizeof(int) * f->sizelineinfo +
                         sizeof(LocVar) * f->sizelocvars +
                         sizeof(Upvaldesc) * f->sizeupvalues;
}


static lu_mem traverseCclosure (global_State *g, CClosure *cl) {
  int i;
  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
    markvalue(g, &cl->upvalue[i]);
  return sizeCclosure(cl->nupvalues);
}

/*
** open upvalues point to values in a thread, so those values should
** be marked when the thread is traversed except in the atomic phase
** (because then the value cannot be changed by the thread and the
** thread may not be traversed again)
*/
static lu_mem traverseLclosure (global_State *g, LClosure *cl) {
  int i;
  markobjectN(g, cl->p);  /* mark its prototype */
  for (i = 0; i < cl->nupvalues; i++) {  /* mark its upvalues */
    UpVal *uv = cl->upvals[i];
    if (uv != NULL) {
      if (upisopen(uv) && g->gcstate != GCSinsideatomic)
        uv->u.open.touched = 1;  /* can be marked in 'remarkupvals' */
      else
        markvalue(g, uv->v);
    }
  }
  return sizeLclosure(cl->nupvalues);
}


static lu_mem traversethread (global_State *g, lua_State *th) {
  StkId o = th->stack;
  if (o == NULL)
    return 1;  /* stack not completely built yet */
  lua_assert(g->gcstate == GCSinsideatomic ||
             th->openupval == NULL || isintwups(th));
  for (; o < th->top; o++)  /* mark live elements in the stack */
    markvalue(g, o);
  if (g->gcstate == GCSinsideatomic) {  /* final traversal? */
    StkId lim = th->stack + th->stacksize;  /* real end of stack */
    for (; o < lim; o++)  /* clear not-marked stack slice */
      setnilvalue(o);
    /* 'remarkupvals' may have removed thread from 'twups' list */
    if (!isintwups(th) && th->openupval != NULL) {
      th->twups = g->twups;  /* link it back to the list */
      g->twups = th;
    }
  }
  else if (g->gckind != KGC_EMERGENCY)
    luaD_shrinkstack(th); /* do not change stack in emergency cycle */
  return (sizeof(lua_State) + sizeof(TValue) * th->stacksize +
          sizeof(CallInfo) * th->nci);
}


/*
** traverse one gray object, turning it to black (except for threads,
** which are always gray).
*/
static void propagatemark (global_State *g) {
  lu_mem size;
  GCObject *o = g->gray;
  lua_assert(isgray(o));
  gray2black(o);
  switch (o->tt) {
    case LUA_TTABLE: {
      Table *h = gco2t(o);
      g->gray = h->gclist;  /* remove from 'gray' list */
      size = traversetable(g, h);
      break;
    }
    case LUA_TLCL: {
      LClosure *cl = gco2lcl(o);
      g->gray = cl->gclist;  /* remove from 'gray' list */
      size = traverseLclosure(g, cl);
      break;
    }
    case LUA_TCCL: {
      CClosure *cl = gco2ccl(o);
      g->gray = cl->gclist;  /* remove from 'gray' list */
      size = traverseCclosure(g, cl);
      break;
    }
    case LUA_TTHREAD: {
      lua_State *th = gco2th(o);
      g->gray = th->gclist;  /* remove from 'gray' list */
      linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */
      black2gray(o);
      size = traversethread(g, th);
      break;
    }
    case LUA_TPROTO: {
      Proto *p = gco2p(o);
      g->gray = p->gclist;  /* remove from 'gray' list */
      size = traverseproto(g, p);
      break;
    }
    default: lua_assert(0); return;
  }
  g->GCmemtrav += size;
}


static void propagateall (global_State *g) {
  while (g->gray) propagatemark(g);
}


static void convergeephemerons (global_State *g) {
  int changed;
  do {
    GCObject *w;
    GCObject *next = g->ephemeron;  /* get ephemeron list */
    g->ephemeron = NULL;  /* tables may return to this list when traversed */
    changed = 0;
    while ((w = next) != NULL) {
      next = gco2t(w)->gclist;
      if (traverseephemeron(g, gco2t(w))) {  /* traverse marked some value? */
        propagateall(g);  /* propagate changes */
        changed = 1;  /* will have to revisit all ephemeron tables */
      }
    }
  } while (changed);
}

/* }====================================================== */


/*
** {======================================================
** Sweep Functions
** =======================================================
*/


/*
** clear entries with unmarked keys from all weaktables in list 'l' up
** to element 'f'
*/
static void clearkeys (global_State *g, GCObject *l, GCObject *f) {
  for (; l != f; l = gco2t(l)->gclist) {
    Table *h = gco2t(l);
    Node *n, *limit = gnodelast(h);
    for (n = gnode(h, 0); n < limit; n++) {
      if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {
        setnilvalue(gval(n));  /* remove value ... */
        removeentry(n);  /* and remove entry from table */
      }
    }
  }
}


/*
** clear entries with unmarked values from all weaktables in list 'l' up
** to element 'f'
*/
static void clearvalues (global_State *g, GCObject *l, GCObject *f) {
  for (; l != f; l = gco2t(l)->gclist) {
    Table *h = gco2t(l);
    Node *n, *limit = gnodelast(h);
    unsigned int i;
    for (i = 0; i < h->sizearray; i++) {
      TValue *o = &h->array[i];
      if (iscleared(g, o))  /* value was collected? */
        setnilvalue(o);  /* remove value */
    }
    for (n = gnode(h, 0); n < limit; n++) {
      if (!ttisnil(gval(n)) && iscleared(g, gval(n))) {
        setnilvalue(gval(n));  /* remove value ... */
        removeentry(n);  /* and remove entry from table */
      }
    }
  }
}


void luaC_upvdeccount (lua_State *L, UpVal *uv) {
  lua_assert(uv->refcount > 0);
  uv->refcount--;
  if (uv->refcount == 0 && !upisopen(uv))
    luaM_free(L, uv);
}


static void freeLclosure (lua_State *L, LClosure *cl) {
  int i;
  for (i = 0; i < cl->nupvalues; i++) {
    UpVal *uv = cl->upvals[i];
    if (uv)
      luaC_upvdeccount(L, uv);
  }
  luaM_freemem(L, cl, sizeLclosure(cl->nupvalues));
}


static void freeobj (lua_State *L, GCObject *o) {
  switch (o->tt) {
    case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;
    case LUA_TLCL: {
      freeLclosure(L, gco2lcl(o));
      break;
    }
    case LUA_TCCL: {
      luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));
      break;
    }
    case LUA_TTABLE: luaH_free(L, gco2t(o)); break;
    case LUA_TTHREAD: luaE_freethread(L, gco2th(o)); break;
    case LUA_TUSERDATA: luaM_freemem(L, o, sizeudata(gco2u(o))); break;
    case LUA_TSHRSTR:
      luaS_remove(L, gco2ts(o));  /* remove it from hash table */
      luaM_freemem(L, o, sizelstring(gco2ts(o)->shrlen));
      break;
    case LUA_TLNGSTR: {
      luaM_freemem(L, o, sizelstring(gco2ts(o)->u.lnglen));
      break;
    }
    default: lua_assert(0);
  }
}


#define sweepwholelist(L,p)	sweeplist(L,p,MAX_LUMEM)
static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count);


/*
** sweep at most 'count' elements from a list of GCObjects erasing dead
** objects, where a dead object is one marked with the old (non current)
** white; change all non-dead objects back to white, preparing for next
** collection cycle. Return where to continue the traversal or NULL if
** list is finished.
*/
static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
  global_State *g = G(L);
  int ow = otherwhite(g);
  int white = luaC_white(g);  /* current white */
  while (*p != NULL && count-- > 0) {
    GCObject *curr = *p;
    int marked = curr->marked;
    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */
      *p = curr->next;  /* remove 'curr' from list */
      freeobj(L, curr);  /* erase 'curr' */
    }
    else {  /* change mark to 'white' */
      curr->marked = cast_byte((marked & maskcolors) | white);
      p = &curr->next;  /* go to next element */
    }
  }
  return (*p == NULL) ? NULL : p;
}


/*
** sweep a list until a live object (or end of list)
*/
static GCObject **sweeptolive (lua_State *L, GCObject **p) {
  GCObject **old = p;
  do {
    p = sweeplist(L, p, 1);
  } while (p == old);
  return p;
}

/* }====================================================== */


/*
** {======================================================
** Finalization
** =======================================================
*/

/*
** If possible, shrink string table
*/
static void checkSizes (lua_State *L, global_State *g) {
  if (g->gckind != KGC_EMERGENCY) {
    l_mem olddebt = g->GCdebt;
    if (g->strt.nuse < g->strt.size / 4)  /* string table too big? */
      luaS_resize(L, g->strt.size / 2);  /* shrink it a little */
    g->GCestimate += g->GCdebt - olddebt;  /* update estimate */
  }
}


static GCObject *udata2finalize (global_State *g) {
  GCObject *o = g->tobefnz;  /* get first element */
  lua_assert(tofinalize(o));
  g->tobefnz = o->next;  /* remove it from 'tobefnz' list */
  o->next = g->allgc;  /* return it to 'allgc' list */
  g->allgc = o;
  resetbit(o->marked, FINALIZEDBIT);  /* object is "normal" again */
  if (issweepphase(g))
    makewhite(g, o);  /* "sweep" object */
  return o;
}


static void dothecall (lua_State *L, void *ud) {
  UNUSED(ud);
  luaD_callnoyield(L, L->top - 2, 0);
}


static void GCTM (lua_State *L, int propagateerrors) {
  global_State *g = G(L);
  const TValue *tm;
  TValue v;
  setgcovalue(L, &v, udata2finalize(g));
  tm = luaT_gettmbyobj(L, &v, TM_GC);
  if (tm != NULL && ttisfunction(tm)) {  /* is there a finalizer? */
    int status;
    lu_byte oldah = L->allowhook;
    int running  = g->gcrunning;
    L->allowhook = 0;  /* stop debug hooks during GC metamethod */
    g->gcrunning = 0;  /* avoid GC steps */
    setobj2s(L, L->top, tm);  /* push finalizer... */
    setobj2s(L, L->top + 1, &v);  /* ... and its argument */
    L->top += 2;  /* and (next line) call the finalizer */
    L->ci->callstatus |= CIST_FIN;  /* will run a finalizer */
    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);
    L->ci->callstatus &= ~CIST_FIN;  /* not running a finalizer anymore */
    L->allowhook = oldah;  /* restore hooks */
    g->gcrunning = running;  /* restore state */
    if (status != LUA_OK && propagateerrors) {  /* error while running __gc? */
      if (status == LUA_ERRRUN) {  /* is there an error object? */
        const char *msg = (ttisstring(L->top - 1))
                            ? svalue(L->top - 1)
                            : "no message";
        luaO_pushfstring(L, "error in __gc metamethod (%s)", msg);
        status = LUA_ERRGCMM;  /* error in __gc metamethod */
      }
      luaD_throw(L, status);  /* re-throw error */
    }
  }
}


/*
** call a few (up to 'g->gcfinnum') finalizers
*/
static int runafewfinalizers (lua_State *L) {
  global_State *g = G(L);
  unsigned int i;
  lua_assert(!g->tobefnz || g->gcfinnum > 0);
  for (i = 0; g->tobefnz && i < g->gcfinnum; i++)
    GCTM(L, 1);  /* call one finalizer */
  g->gcfinnum = (!g->tobefnz) ? 0  /* nothing more to finalize? */
                    : g->gcfinnum * 2;  /* else call a few more next time */
  return i;
}


/*
** call all pending finalizers
*/
static void callallpendingfinalizers (lua_State *L) {
  global_State *g = G(L);
  while (g->tobefnz)
    GCTM(L, 0);
}


/*
** find last 'next' field in list 'p' list (to add elements in its end)
*/
static GCObject **findlast (GCObject **p) {
  while (*p != NULL)
    p = &(*p)->next;
  return p;
}


/*
** move all unreachable objects (or 'all' objects) that need
** finalization from list 'finobj' to list 'tobefnz' (to be finalized)
*/
static void separatetobefnz (global_State *g, int all) {
  GCObject *curr;
  GCObject **p = &g->finobj;
  GCObject **lastnext = findlast(&g->tobefnz);
  while ((curr = *p) != NULL) {  /* traverse all finalizable objects */
    lua_assert(tofinalize(curr));
    if (!(iswhite(curr) || all))  /* not being collected? */
      p = &curr->next;  /* don't bother with it */
    else {
      *p = curr->next;  /* remove 'curr' from 'finobj' list */
      curr->next = *lastnext;  /* link at the end of 'tobefnz' list */
      *lastnext = curr;
      lastnext = &curr->next;
    }
  }
}


/*
** if object 'o' has a finalizer, remove it from 'allgc' list (must
** search the list to find it) and link it in 'finobj' list.
*/
void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {
  global_State *g = G(L);
  if (tofinalize(o) ||                 /* obj. is already marked... */
      gfasttm(g, mt, TM_GC) == NULL)   /* or has no finalizer? */
    return;  /* nothing to be done */
  else {  /* move 'o' to 'finobj' list */
    GCObject **p;
    if (issweepphase(g)) {
      makewhite(g, o);  /* "sweep" object 'o' */
      if (g->sweepgc == &o->next)  /* should not remove 'sweepgc' object */
        g->sweepgc = sweeptolive(L, g->sweepgc);  /* change 'sweepgc' */
    }
    /* search for pointer pointing to 'o' */
    for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }
    *p = o->next;  /* remove 'o' from 'allgc' list */
    o->next = g->finobj;  /* link it in 'finobj' list */
    g->finobj = o;
    l_setbit(o->marked, FINALIZEDBIT);  /* mark it as such */
  }
}

/* }====================================================== */



/*
** {======================================================
** GC control
** =======================================================
*/


/*
** Set a reasonable "time" to wait before starting a new GC cycle; cycle
** will start when memory use hits threshold. (Division by 'estimate'
** should be OK: it cannot be zero (because Lua cannot even start with
** less than PAUSEADJ bytes).
*/
static void setpause (global_State *g) {
  l_mem threshold, debt;
  l_mem estimate = g->GCestimate / PAUSEADJ;  /* adjust 'estimate' */
  lua_assert(estimate > 0);
  threshold = (g->gcpause < MAX_LMEM / estimate)  /* overflow? */
            ? estimate * g->gcpause  /* no overflow */
            : MAX_LMEM;  /* overflow; truncate to maximum */
  debt = gettotalbytes(g) - threshold;
  luaE_setdebt(g, debt);
}


/*
** Enter first sweep phase.
** The call to 'sweeplist' tries to make pointer point to an object
** inside the list (instead of to the header), so that the real sweep do
** not need to skip objects created between "now" and the start of the
** real sweep.
*/
static void entersweep (lua_State *L) {
  global_State *g = G(L);
  g->gcstate = GCSswpallgc;
  lua_assert(g->sweepgc == NULL);
  g->sweepgc = sweeplist(L, &g->allgc, 1);
}


void luaC_freeallobjects (lua_State *L) {
  global_State *g = G(L);
  separatetobefnz(g, 1);  /* separate all objects with finalizers */
  lua_assert(g->finobj == NULL);
  callallpendingfinalizers(L);
  lua_assert(g->tobefnz == NULL);
  g->currentwhite = WHITEBITS; /* this "white" makes all objects look dead */
  g->gckind = KGC_NORMAL;
  sweepwholelist(L, &g->finobj);
  sweepwholelist(L, &g->allgc);
  sweepwholelist(L, &g->fixedgc);  /* collect fixed objects */
  lua_assert(g->strt.nuse == 0);
}


static l_mem atomic (lua_State *L) {
  global_State *g = G(L);
  l_mem work;
  GCObject *origweak, *origall;
  GCObject *grayagain = g->grayagain;  /* save original list */
  lua_assert(g->ephemeron == NULL && g->weak == NULL);
  lua_assert(!iswhite(g->mainthread));
  g->gcstate = GCSinsideatomic;
  g->GCmemtrav = 0;  /* start counting work */
  markobject(g, L);  /* mark running thread */
  /* registry and global metatables may be changed by API */
  markvalue(g, &g->l_registry);
  markmt(g);  /* mark global metatables */
  /* remark occasional upvalues of (maybe) dead threads */
  remarkupvals(g);
  propagateall(g);  /* propagate changes */
  work = g->GCmemtrav;  /* stop counting (do not recount 'grayagain') */
  g->gray = grayagain;
  propagateall(g);  /* traverse 'grayagain' list */
  g->GCmemtrav = 0;  /* restart counting */
  convergeephemerons(g);
  /* at this point, all strongly accessible objects are marked. */
  /* Clear values from weak tables, before checking finalizers */
  clearvalues(g, g->weak, NULL);
  clearvalues(g, g->allweak, NULL);
  origweak = g->weak; origall = g->allweak;
  work += g->GCmemtrav;  /* stop counting (objects being finalized) */
  separatetobefnz(g, 0);  /* separate objects to be finalized */
  g->gcfinnum = 1;  /* there may be objects to be finalized */
  markbeingfnz(g);  /* mark objects that will be finalized */
  propagateall(g);  /* remark, to propagate 'resurrection' */
  g->GCmemtrav = 0;  /* restart counting */
  convergeephemerons(g);
  /* at this point, all resurrected objects are marked. */
  /* remove dead objects from weak tables */
  clearkeys(g, g->ephemeron, NULL);  /* clear keys from all ephemeron tables */
  clearkeys(g, g->allweak, NULL);  /* clear keys from all 'allweak' tables */
  /* clear values from resurrected weak tables */
  clearvalues(g, g->weak, origweak);
  clearvalues(g, g->allweak, origall);
  luaS_clearcache(g);
  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */
  work += g->GCmemtrav;  /* complete counting */
  return work;  /* estimate of memory marked by 'atomic' */
}


static lu_mem sweepstep (lua_State *L, global_State *g,
                         int nextstate, GCObject **nextlist) {
  if (g->sweepgc) {
    l_mem olddebt = g->GCdebt;
    g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
    g->GCestimate += g->GCdebt - olddebt;  /* update estimate */
    if (g->sweepgc)  /* is there still something to sweep? */
      return (GCSWEEPMAX * GCSWEEPCOST);
  }
  /* else enter next state */
  g->gcstate = nextstate;
  g->sweepgc = nextlist;
  return 0;
}


static lu_mem singlestep (lua_State *L) {
  global_State *g = G(L);
  switch (g->gcstate) {
    case GCSpause: {
      g->GCmemtrav = g->strt.size * sizeof(GCObject*);
      restartcollection(g);
      g->gcstate = GCSpropagate;
      return g->GCmemtrav;
    }
    case GCSpropagate: {
      g->GCmemtrav = 0;
      lua_assert(g->gray);
      propagatemark(g);
       if (g->gray == NULL)  /* no more gray objects? */
        g->gcstate = GCSatomic;  /* finish propagate phase */
      return g->GCmemtrav;  /* memory traversed in this step */
    }
    case GCSatomic: {
      lu_mem work;
      propagateall(g);  /* make sure gray list is empty */
      work = atomic(L);  /* work is what was traversed by 'atomic' */
      entersweep(L);
      g->GCestimate = gettotalbytes(g);  /* first estimate */;
      return work;
    }
    case GCSswpallgc: {  /* sweep "regular" objects */
      return sweepstep(L, g, GCSswpfinobj, &g->finobj);
    }
    case GCSswpfinobj: {  /* sweep objects with finalizers */
      return sweepstep(L, g, GCSswptobefnz, &g->tobefnz);
    }
    case GCSswptobefnz: {  /* sweep objects to be finalized */
      return sweepstep(L, g, GCSswpend, NULL);
    }
    case GCSswpend: {  /* finish sweeps */
      makewhite(g, g->mainthread);  /* sweep main thread */
      checkSizes(L, g);
      g->gcstate = GCScallfin;
      return 0;
    }
    case GCScallfin: {  /* call remaining finalizers */
      if (g->tobefnz && g->gckind != KGC_EMERGENCY) {
        int n = runafewfinalizers(L);
        return (n * GCFINALIZECOST);
      }
      else {  /* emergency mode or no more finalizers */
        g->gcstate = GCSpause;  /* finish collection */
        return 0;
      }
    }
    default: lua_assert(0); return 0;
  }
}


/*
** advances the garbage collector until it reaches a state allowed
** by 'statemask'
*/
void luaC_runtilstate (lua_State *L, int statesmask) {
  global_State *g = G(L);
  while (!testbit(statesmask, g->gcstate))
    singlestep(L);
}


/*
** get GC debt and convert it from Kb to 'work units' (avoid zero debt
** and overflows)
*/
static l_mem getdebt (global_State *g) {
  l_mem debt = g->GCdebt;
  int stepmul = g->gcstepmul;
  if (debt <= 0) return 0;  /* minimal debt */
  else {
    debt = (debt / STEPMULADJ) + 1;
    debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;
    return debt;
  }
}

/*
** performs a basic GC step when collector is running
*/
void luaC_step (lua_State *L) {
  global_State *g = G(L);
  l_mem debt = getdebt(g);  /* GC deficit (be paid now) */
  if (!g->gcrunning) {  /* not running? */
    luaE_setdebt(g, -GCSTEPSIZE * 10);  /* avoid being called too often */
    return;
  }
  do {  /* repeat until pause or enough "credit" (negative debt) */
    lu_mem work = singlestep(L);  /* perform one single step */
    debt -= work;
  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);
  if (g->gcstate == GCSpause)
    setpause(g);  /* pause until next cycle */
  else {
    debt = (debt / g->gcstepmul) * STEPMULADJ;  /* convert 'work units' to Kb */
    luaE_setdebt(g, debt);
    runafewfinalizers(L);
  }
}


/*
** Performs a full GC cycle; if 'isemergency', set a flag to avoid
** some operations which could change the interpreter state in some
** unexpected ways (running finalizers and shrinking some structures).
** Before running the collection, check 'keepinvariant'; if it is true,
** there may be some objects marked as black, so the collector has
** to sweep all objects to turn them back to white (as white has not
** changed, nothing will be collected).
*/
void luaC_fullgc (lua_State *L, int isemergency) {
  global_State *g = G(L);
  lua_assert(g->gckind == KGC_NORMAL);
  if (isemergency) g->gckind = KGC_EMERGENCY;  /* set flag */
  if (keepinvariant(g)) {  /* black objects? */
    entersweep(L); /* sweep everything to turn them back to white */
  }
  /* finish any pending sweep phase to start a new cycle */
  luaC_runtilstate(L, bitmask(GCSpause));
  luaC_runtilstate(L, ~bitmask(GCSpause));  /* start new collection */
  luaC_runtilstate(L, bitmask(GCScallfin));  /* run up to finalizers */
  /* estimate must be correct after a full GC cycle */
  lua_assert(g->GCestimate == gettotalbytes(g));
  luaC_runtilstate(L, bitmask(GCSpause));  /* finish collection */
  g->gckind = KGC_NORMAL;
  setpause(g);
}

/* }====================================================== */



```

`src/Lua/lgc.h`:

```h
/*
** $Id: lgc.h,v 2.91 2015/12/21 13:02:14 roberto Exp $
** Garbage Collector
** See Copyright Notice in lua.h
*/

#ifndef lgc_h
#define lgc_h


#include "lobject.h"
#include "lstate.h"

/*
** Collectable objects may have one of three colors: white, which
** means the object is not marked; gray, which means the
** object is marked, but its references may be not marked; and
** black, which means that the object and all its references are marked.
** The main invariant of the garbage collector, while marking objects,
** is that a black object can never point to a white one. Moreover,
** any gray object must be in a "gray list" (gray, grayagain, weak,
** allweak, ephemeron) so that it can be visited again before finishing
** the collection cycle. These lists have no meaning when the invariant
** is not being enforced (e.g., sweep phase).
*/



/* how much to allocate before next GC step */
#if !defined(GCSTEPSIZE)
/* ~100 small strings */
#define GCSTEPSIZE	(cast_int(100 * sizeof(TString)))
#endif


/*
** Possible states of the Garbage Collector
*/
#define GCSpropagate	0
#define GCSatomic	1
#define GCSswpallgc	2
#define GCSswpfinobj	3
#define GCSswptobefnz	4
#define GCSswpend	5
#define GCScallfin	6
#define GCSpause	7


#define issweepphase(g)  \
	(GCSswpallgc <= (g)->gcstate && (g)->gcstate <= GCSswpend)


/*
** macro to tell when main invariant (white objects cannot point to black
** ones) must be kept. During a collection, the sweep
** phase may break the invariant, as objects turned white may point to
** still-black objects. The invariant is restored when sweep ends and
** all objects are white again.
*/

#define keepinvariant(g)	((g)->gcstate <= GCSatomic)


/*
** some useful bit tricks
*/
#define resetbits(x,m)		((x) &= cast(lu_byte, ~(m)))
#define setbits(x,m)		((x) |= (m))
#define testbits(x,m)		((x) & (m))
#define bitmask(b)		(1<<(b))
#define bit2mask(b1,b2)		(bitmask(b1) | bitmask(b2))
#define l_setbit(x,b)		setbits(x, bitmask(b))
#define resetbit(x,b)		resetbits(x, bitmask(b))
#define testbit(x,b)		testbits(x, bitmask(b))


/* Layout for bit use in 'marked' field: */
#define WHITE0BIT	0  /* object is white (type 0) */
#define WHITE1BIT	1  /* object is white (type 1) */
#define BLACKBIT	2  /* object is black */
#define FINALIZEDBIT	3  /* object has been marked for finalization */
/* bit 7 is currently used by tests (luaL_checkmemory) */

#define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)


#define iswhite(x)      testbits((x)->marked, WHITEBITS)
#define isblack(x)      testbit((x)->marked, BLACKBIT)
#define isgray(x)  /* neither white nor black */  \
	(!testbits((x)->marked, WHITEBITS | bitmask(BLACKBIT)))

#define tofinalize(x)	testbit((x)->marked, FINALIZEDBIT)

#define otherwhite(g)	((g)->currentwhite ^ WHITEBITS)
#define isdeadm(ow,m)	(!(((m) ^ WHITEBITS) & (ow)))
#define isdead(g,v)	isdeadm(otherwhite(g), (v)->marked)

#define changewhite(x)	((x)->marked ^= WHITEBITS)
#define gray2black(x)	l_setbit((x)->marked, BLACKBIT)

#define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)


/*
** Does one step of collection when debt becomes positive. 'pre'/'pos'
** allows some adjustments to be done only when needed. macro
** 'condchangemem' is used only for heavy tests (forcing a full
** GC cycle on every opportunity)
*/
#define luaC_condGC(L,pre,pos) \
	{ if (G(L)->GCdebt > 0) { pre; luaC_step(L); pos;}; \
	  condchangemem(L,pre,pos); }

/* more often than not, 'pre'/'pos' are empty */
#define luaC_checkGC(L)		luaC_condGC(L,(void)0,(void)0)


#define luaC_barrier(L,p,v) (  \
	(iscollectable(v) && isblack(p) && iswhite(gcvalue(v))) ?  \
	luaC_barrier_(L,obj2gco(p),gcvalue(v)) : cast_void(0))

#define luaC_barrierback(L,p,v) (  \
	(iscollectable(v) && isblack(p) && iswhite(gcvalue(v))) ? \
	luaC_barrierback_(L,p) : cast_void(0))

#define luaC_objbarrier(L,p,o) (  \
	(isblack(p) && iswhite(o)) ? \
	luaC_barrier_(L,obj2gco(p),obj2gco(o)) : cast_void(0))

#define luaC_upvalbarrier(L,uv) ( \
	(iscollectable((uv)->v) && !upisopen(uv)) ? \
         luaC_upvalbarrier_(L,uv) : cast_void(0))

LUAI_FUNC void luaC_fix (lua_State *L, GCObject *o);
LUAI_FUNC void luaC_freeallobjects (lua_State *L);
LUAI_FUNC void luaC_step (lua_State *L);
LUAI_FUNC void luaC_runtilstate (lua_State *L, int statesmask);
LUAI_FUNC void luaC_fullgc (lua_State *L, int isemergency);
LUAI_FUNC GCObject *luaC_newobj (lua_State *L, int tt, size_t sz);
LUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);
LUAI_FUNC void luaC_barrierback_ (lua_State *L, Table *o);
LUAI_FUNC void luaC_upvalbarrier_ (lua_State *L, UpVal *uv);
LUAI_FUNC void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt);
LUAI_FUNC void luaC_upvdeccount (lua_State *L, UpVal *uv);


#endif

```

`src/Lua/linit.c`:

```c
/*
** $Id: linit.c,v 1.39 2016/12/04 20:17:24 roberto Exp $
** Initialization of libraries for lua.c and other clients
** See Copyright Notice in lua.h
*/


#define linit_c
#define LUA_LIB

/*
** If you embed Lua in your program and need to open the standard
** libraries, call luaL_openlibs in your program. If you need a
** different set of libraries, copy this file to your project and edit
** it to suit your needs.
**
** You can also *preload* libraries, so that a later 'require' can
** open the library, which is already linked to the application.
** For that, do the following code:
**
**  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);
**  lua_pushcfunction(L, luaopen_modname);
**  lua_setfield(L, -2, modname);
**  lua_pop(L, 1);  // remove PRELOAD table
*/

#include "lprefix.h"


#include <stddef.h>

#include "lua.h"

#include "lualib.h"
#include "lauxlib.h"


/*
** these libs are loaded by lua.c and are readily available to any Lua
** program
*/
static const luaL_Reg loadedlibs[] = {
  {"_G", luaopen_base},
  {LUA_LOADLIBNAME, luaopen_package},
  {LUA_COLIBNAME, luaopen_coroutine},
  {LUA_TABLIBNAME, luaopen_table},
  {LUA_IOLIBNAME, luaopen_io},
  {LUA_OSLIBNAME, luaopen_os},
  {LUA_STRLIBNAME, luaopen_string},
  {LUA_MATHLIBNAME, luaopen_math},
  {LUA_UTF8LIBNAME, luaopen_utf8},
  {LUA_DBLIBNAME, luaopen_debug},
#if defined(LUA_COMPAT_BITLIB)
  {LUA_BITLIBNAME, luaopen_bit32},
#endif
  {NULL, NULL}
};


LUALIB_API void luaL_openlibs (lua_State *L) {
  const luaL_Reg *lib;
  /* "require" functions from 'loadedlibs' and set results to global table */
  for (lib = loadedlibs; lib->func; lib++) {
    luaL_requiref(L, lib->name, lib->func, 1);
    lua_pop(L, 1);  /* remove lib */
  }
}


```

`src/Lua/liolib.c`:

```c
/*
** $Id: liolib.c,v 2.151 2016/12/20 18:37:00 roberto Exp $
** Standard I/O (and system) library
** See Copyright Notice in lua.h
*/

#define liolib_c
#define LUA_LIB

#include "lprefix.h"


#include <ctype.h>
#include <errno.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"




/*
** Change this macro to accept other modes for 'fopen' besides
** the standard ones.
*/
#if !defined(l_checkmode)

/* accepted extensions to 'mode' in 'fopen' */
#if !defined(L_MODEEXT)
#define L_MODEEXT	"b"
#endif

/* Check whether 'mode' matches '[rwa]%+?[L_MODEEXT]*' */
static int l_checkmode (const char *mode) {
  return (*mode != '\0' && strchr("rwa", *(mode++)) != NULL &&
         (*mode != '+' || (++mode, 1)) &&  /* skip if char is '+' */
         (strspn(mode, L_MODEEXT) == strlen(mode)));  /* check extensions */
}

#endif

/*
** {======================================================
** l_popen spawns a new process connected to the current
** one through the file streams.
** =======================================================
*/

#if !defined(l_popen)		/* { */

#if defined(LUA_USE_POSIX)	/* { */

#define l_popen(L,c,m)		(fflush(NULL), popen(c,m))
#define l_pclose(L,file)	(pclose(file))

#elif defined(LUA_USE_WINDOWS)	/* }{ */

#define l_popen(L,c,m)		(_popen(c,m))
#define l_pclose(L,file)	(_pclose(file))

#else				/* }{ */

/* ISO C definitions */
#define l_popen(L,c,m)  \
	  ((void)((void)c, m), \
	  luaL_error(L, "'popen' not supported"), \
	  (FILE*)0)
#define l_pclose(L,file)		((void)L, (void)file, -1)

#endif				/* } */

#endif				/* } */

/* }====================================================== */


#if !defined(l_getc)		/* { */

#if defined(LUA_USE_POSIX)
#define l_getc(f)		getc_unlocked(f)
#define l_lockfile(f)		flockfile(f)
#define l_unlockfile(f)		funlockfile(f)
#else
#define l_getc(f)		getc(f)
#define l_lockfile(f)		((void)0)
#define l_unlockfile(f)		((void)0)
#endif

#endif				/* } */


/*
** {======================================================
** l_fseek: configuration for longer offsets
** =======================================================
*/

#if !defined(l_fseek)		/* { */

#if defined(LUA_USE_POSIX)	/* { */

#include <sys/types.h>

#define l_fseek(f,o,w)		fseeko(f,o,w)
#define l_ftell(f)		ftello(f)
#define l_seeknum		off_t

#elif defined(LUA_USE_WINDOWS) && !defined(_CRTIMP_TYPEINFO) \
   && defined(_MSC_VER) && (_MSC_VER >= 1400)	/* }{ */

/* Windows (but not DDK) and Visual C++ 2005 or higher */
#define l_fseek(f,o,w)		_fseeki64(f,o,w)
#define l_ftell(f)		_ftelli64(f)
#define l_seeknum		__int64

#else				/* }{ */

/* ISO C definitions */
#define l_fseek(f,o,w)		fseek(f,o,w)
#define l_ftell(f)		ftell(f)
#define l_seeknum		long

#endif				/* } */

#endif				/* } */

/* }====================================================== */


#define IO_PREFIX	"_IO_"
#define IOPREF_LEN	(sizeof(IO_PREFIX)/sizeof(char) - 1)
#define IO_INPUT	(IO_PREFIX "input")
#define IO_OUTPUT	(IO_PREFIX "output")


typedef luaL_Stream LStream;


#define tolstream(L)	((LStream *)luaL_checkudata(L, 1, LUA_FILEHANDLE))

#define isclosed(p)	((p)->closef == NULL)


static int io_type (lua_State *L) {
  LStream *p;
  luaL_checkany(L, 1);
  p = (LStream *)luaL_testudata(L, 1, LUA_FILEHANDLE);
  if (p == NULL)
    lua_pushnil(L);  /* not a file */
  else if (isclosed(p))
    lua_pushliteral(L, "closed file");
  else
    lua_pushliteral(L, "file");
  return 1;
}


static int f_tostring (lua_State *L) {
  LStream *p = tolstream(L);
  if (isclosed(p))
    lua_pushliteral(L, "file (closed)");
  else
    lua_pushfstring(L, "file (%p)", p->f);
  return 1;
}


static FILE *tofile (lua_State *L) {
  LStream *p = tolstream(L);
  if (isclosed(p))
    luaL_error(L, "attempt to use a closed file");
  lua_assert(p->f);
  return p->f;
}


/*
** When creating file handles, always creates a 'closed' file handle
** before opening the actual file; so, if there is a memory error, the
** handle is in a consistent state.
*/
static LStream *newprefile (lua_State *L) {
  LStream *p = (LStream *)lua_newuserdata(L, sizeof(LStream));
  p->closef = NULL;  /* mark file handle as 'closed' */
  luaL_setmetatable(L, LUA_FILEHANDLE);
  return p;
}


/*
** Calls the 'close' function from a file handle. The 'volatile' avoids
** a bug in some versions of the Clang compiler (e.g., clang 3.0 for
** 32 bits).
*/
static int aux_close (lua_State *L) {
  LStream *p = tolstream(L);
  volatile lua_CFunction cf = p->closef;
  p->closef = NULL;  /* mark stream as closed */
  return (*cf)(L);  /* close it */
}


static int io_close (lua_State *L) {
  if (lua_isnone(L, 1))  /* no argument? */
    lua_getfield(L, LUA_REGISTRYINDEX, IO_OUTPUT);  /* use standard output */
  tofile(L);  /* make sure argument is an open stream */
  return aux_close(L);
}


static int f_gc (lua_State *L) {
  LStream *p = tolstream(L);
  if (!isclosed(p) && p->f != NULL)
    aux_close(L);  /* ignore closed and incompletely open files */
  return 0;
}


/*
** function to close regular files
*/
static int io_fclose (lua_State *L) {
  LStream *p = tolstream(L);
  int res = fclose(p->f);
  return luaL_fileresult(L, (res == 0), NULL);
}


static LStream *newfile (lua_State *L) {
  LStream *p = newprefile(L);
  p->f = NULL;
  p->closef = &io_fclose;
  return p;
}


static void opencheck (lua_State *L, const char *fname, const char *mode) {
  LStream *p = newfile(L);
  p->f = fopen(fname, mode);
  if (p->f == NULL)
    luaL_error(L, "cannot open file '%s' (%s)", fname, strerror(errno));
}


static int io_open (lua_State *L) {
  const char *filename = luaL_checkstring(L, 1);
  const char *mode = luaL_optstring(L, 2, "r");
  LStream *p = newfile(L);
  const char *md = mode;  /* to traverse/check mode */
  luaL_argcheck(L, l_checkmode(md), 2, "invalid mode");
  p->f = fopen(filename, mode);
  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
}


/*
** function to close 'popen' files
*/
static int io_pclose (lua_State *L) {
  LStream *p = tolstream(L);
  return luaL_execresult(L, l_pclose(L, p->f));
}


static int io_popen (lua_State *L) {
  const char *filename = luaL_checkstring(L, 1);
  const char *mode = luaL_optstring(L, 2, "r");
  LStream *p = newprefile(L);
  p->f = l_popen(L, filename, mode);
  p->closef = &io_pclose;
  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
}


static int io_tmpfile (lua_State *L) {
  LStream *p = newfile(L);
  p->f = tmpfile();
  return (p->f == NULL) ? luaL_fileresult(L, 0, NULL) : 1;
}


static FILE *getiofile (lua_State *L, const char *findex) {
  LStream *p;
  lua_getfield(L, LUA_REGISTRYINDEX, findex);
  p = (LStream *)lua_touserdata(L, -1);
  if (isclosed(p))
    luaL_error(L, "standard %s file is closed", findex + IOPREF_LEN);
  return p->f;
}


static int g_iofile (lua_State *L, const char *f, const char *mode) {
  if (!lua_isnoneornil(L, 1)) {
    const char *filename = lua_tostring(L, 1);
    if (filename)
      opencheck(L, filename, mode);
    else {
      tofile(L);  /* check that it's a valid file handle */
      lua_pushvalue(L, 1);
    }
    lua_setfield(L, LUA_REGISTRYINDEX, f);
  }
  /* return current value */
  lua_getfield(L, LUA_REGISTRYINDEX, f);
  return 1;
}


static int io_input (lua_State *L) {
  return g_iofile(L, IO_INPUT, "r");
}


static int io_output (lua_State *L) {
  return g_iofile(L, IO_OUTPUT, "w");
}


static int io_readline (lua_State *L);


/*
** maximum number of arguments to 'f:lines'/'io.lines' (it + 3 must fit
** in the limit for upvalues of a closure)
*/
#define MAXARGLINE	250

static void aux_lines (lua_State *L, int toclose) {
  int n = lua_gettop(L) - 1;  /* number of arguments to read */
  luaL_argcheck(L, n <= MAXARGLINE, MAXARGLINE + 2, "too many arguments");
  lua_pushinteger(L, n);  /* number of arguments to read */
  lua_pushboolean(L, toclose);  /* close/not close file when finished */
  lua_rotate(L, 2, 2);  /* move 'n' and 'toclose' to their positions */
  lua_pushcclosure(L, io_readline, 3 + n);
}


static int f_lines (lua_State *L) {
  tofile(L);  /* check that it's a valid file handle */
  aux_lines(L, 0);
  return 1;
}


static int io_lines (lua_State *L) {
  int toclose;
  if (lua_isnone(L, 1)) lua_pushnil(L);  /* at least one argument */
  if (lua_isnil(L, 1)) {  /* no file name? */
    lua_getfield(L, LUA_REGISTRYINDEX, IO_INPUT);  /* get default input */
    lua_replace(L, 1);  /* put it at index 1 */
    tofile(L);  /* check that it's a valid file handle */
    toclose = 0;  /* do not close it after iteration */
  }
  else {  /* open a new file */
    const char *filename = luaL_checkstring(L, 1);
    opencheck(L, filename, "r");
    lua_replace(L, 1);  /* put file at index 1 */
    toclose = 1;  /* close it after iteration */
  }
  aux_lines(L, toclose);
  return 1;
}


/*
** {======================================================
** READ
** =======================================================
*/


/* maximum length of a numeral */
#if !defined (L_MAXLENNUM)
#define L_MAXLENNUM     200
#endif


/* auxiliary structure used by 'read_number' */
typedef struct {
  FILE *f;  /* file being read */
  int c;  /* current character (look ahead) */
  int n;  /* number of elements in buffer 'buff' */
  char buff[L_MAXLENNUM + 1];  /* +1 for ending '\0' */
} RN;


/*
** Add current char to buffer (if not out of space) and read next one
*/
static int nextc (RN *rn) {
  if (rn->n >= L_MAXLENNUM) {  /* buffer overflow? */
    rn->buff[0] = '\0';  /* invalidate result */
    return 0;  /* fail */
  }
  else {
    rn->buff[rn->n++] = rn->c;  /* save current char */
    rn->c = l_getc(rn->f);  /* read next one */
    return 1;
  }
}


/*
** Accept current char if it is in 'set' (of size 2)
*/
static int test2 (RN *rn, const char *set) {
  if (rn->c == set[0] || rn->c == set[1])
    return nextc(rn);
  else return 0;
}


/*
** Read a sequence of (hex)digits
*/
static int readdigits (RN *rn, int hex) {
  int count = 0;
  while ((hex ? isxdigit(rn->c) : isdigit(rn->c)) && nextc(rn))
    count++;
  return count;
}


/*
** Read a number: first reads a valid prefix of a numeral into a buffer.
** Then it calls 'lua_stringtonumber' to check whether the format is
** correct and to convert it to a Lua number
*/
static int read_number (lua_State *L, FILE *f) {
  RN rn;
  int count = 0;
  int hex = 0;
  char decp[2];
  rn.f = f; rn.n = 0;
  decp[0] = lua_getlocaledecpoint();  /* get decimal point from locale */
  decp[1] = '.';  /* always accept a dot */
  l_lockfile(rn.f);
  do { rn.c = l_getc(rn.f); } while (isspace(rn.c));  /* skip spaces */
  test2(&rn, "-+");  /* optional signal */
  if (test2(&rn, "00")) {
    if (test2(&rn, "xX")) hex = 1;  /* numeral is hexadecimal */
    else count = 1;  /* count initial '0' as a valid digit */
  }
  count += readdigits(&rn, hex);  /* integral part */
  if (test2(&rn, decp))  /* decimal point? */
    count += readdigits(&rn, hex);  /* fractional part */
  if (count > 0 && test2(&rn, (hex ? "pP" : "eE"))) {  /* exponent mark? */
    test2(&rn, "-+");  /* exponent signal */
    readdigits(&rn, 0);  /* exponent digits */
  }
  ungetc(rn.c, rn.f);  /* unread look-ahead char */
  l_unlockfile(rn.f);
  rn.buff[rn.n] = '\0';  /* finish string */
  if (lua_stringtonumber(L, rn.buff))  /* is this a valid number? */
    return 1;  /* ok */
  else {  /* invalid format */
   lua_pushnil(L);  /* "result" to be removed */
   return 0;  /* read fails */
  }
}


static int test_eof (lua_State *L, FILE *f) {
  int c = getc(f);
  ungetc(c, f);  /* no-op when c == EOF */
  lua_pushliteral(L, "");
  return (c != EOF);
}


static int read_line (lua_State *L, FILE *f, int chop) {
  luaL_Buffer b;
  int c = '\0';
  luaL_buffinit(L, &b);
  while (c != EOF && c != '\n') {  /* repeat until end of line */
    char *buff = luaL_prepbuffer(&b);  /* preallocate buffer */
    int i = 0;
    l_lockfile(f);  /* no memory errors can happen inside the lock */
    while (i < LUAL_BUFFERSIZE && (c = l_getc(f)) != EOF && c != '\n')
      buff[i++] = c;
    l_unlockfile(f);
    luaL_addsize(&b, i);
  }
  if (!chop && c == '\n')  /* want a newline and have one? */
    luaL_addchar(&b, c);  /* add ending newline to result */
  luaL_pushresult(&b);  /* close buffer */
  /* return ok if read something (either a newline or something else) */
  return (c == '\n' || lua_rawlen(L, -1) > 0);
}


static void read_all (lua_State *L, FILE *f) {
  size_t nr;
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  do {  /* read file in chunks of LUAL_BUFFERSIZE bytes */
    char *p = luaL_prepbuffer(&b);
    nr = fread(p, sizeof(char), LUAL_BUFFERSIZE, f);
    luaL_addsize(&b, nr);
  } while (nr == LUAL_BUFFERSIZE);
  luaL_pushresult(&b);  /* close buffer */
}


static int read_chars (lua_State *L, FILE *f, size_t n) {
  size_t nr;  /* number of chars actually read */
  char *p;
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  p = luaL_prepbuffsize(&b, n);  /* prepare buffer to read whole block */
  nr = fread(p, sizeof(char), n, f);  /* try to read 'n' chars */
  luaL_addsize(&b, nr);
  luaL_pushresult(&b);  /* close buffer */
  return (nr > 0);  /* true iff read something */
}


static int g_read (lua_State *L, FILE *f, int first) {
  int nargs = lua_gettop(L) - 1;
  int success;
  int n;
  clearerr(f);
  if (nargs == 0) {  /* no arguments? */
    success = read_line(L, f, 1);
    n = first+1;  /* to return 1 result */
  }
  else {  /* ensure stack space for all results and for auxlib's buffer */
    luaL_checkstack(L, nargs+LUA_MINSTACK, "too many arguments");
    success = 1;
    for (n = first; nargs-- && success; n++) {
      if (lua_type(L, n) == LUA_TNUMBER) {
        size_t l = (size_t)luaL_checkinteger(L, n);
        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
      }
      else {
        const char *p = luaL_checkstring(L, n);
        if (*p == '*') p++;  /* skip optional '*' (for compatibility) */
        switch (*p) {
          case 'n':  /* number */
            success = read_number(L, f);
            break;
          case 'l':  /* line */
            success = read_line(L, f, 1);
            break;
          case 'L':  /* line with end-of-line */
            success = read_line(L, f, 0);
            break;
          case 'a':  /* file */
            read_all(L, f);  /* read entire file */
            success = 1; /* always success */
            break;
          default:
            return luaL_argerror(L, n, "invalid format");
        }
      }
    }
  }
  if (ferror(f))
    return luaL_fileresult(L, 0, NULL);
  if (!success) {
    lua_pop(L, 1);  /* remove last result */
    lua_pushnil(L);  /* push nil instead */
  }
  return n - first;
}


static int io_read (lua_State *L) {
  return g_read(L, getiofile(L, IO_INPUT), 1);
}


static int f_read (lua_State *L) {
  return g_read(L, tofile(L), 2);
}


static int io_readline (lua_State *L) {
  LStream *p = (LStream *)lua_touserdata(L, lua_upvalueindex(1));
  int i;
  int n = (int)lua_tointeger(L, lua_upvalueindex(2));
  if (isclosed(p))  /* file is already closed? */
    return luaL_error(L, "file is already closed");
  lua_settop(L , 1);
  luaL_checkstack(L, n, "too many arguments");
  for (i = 1; i <= n; i++)  /* push arguments to 'g_read' */
    lua_pushvalue(L, lua_upvalueindex(3 + i));
  n = g_read(L, p->f, 2);  /* 'n' is number of results */
  lua_assert(n > 0);  /* should return at least a nil */
  if (lua_toboolean(L, -n))  /* read at least one value? */
    return n;  /* return them */
  else {  /* first result is nil: EOF or error */
    if (n > 1) {  /* is there error information? */
      /* 2nd result is error message */
      return luaL_error(L, "%s", lua_tostring(L, -n + 1));
    }
    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */
      lua_settop(L, 0);
      lua_pushvalue(L, lua_upvalueindex(1));
      aux_close(L);  /* close it */
    }
    return 0;
  }
}

/* }====================================================== */


static int g_write (lua_State *L, FILE *f, int arg) {
  int nargs = lua_gettop(L) - arg;
  int status = 1;
  for (; nargs--; arg++) {
    if (lua_type(L, arg) == LUA_TNUMBER) {
      /* optimization: could be done exactly as for strings */
      int len = lua_isinteger(L, arg)
                ? fprintf(f, LUA_INTEGER_FMT,
                             (LUAI_UACINT)lua_tointeger(L, arg))
                : fprintf(f, LUA_NUMBER_FMT,
                             (LUAI_UACNUMBER)lua_tonumber(L, arg));
      status = status && (len > 0);
    }
    else {
      size_t l;
      const char *s = luaL_checklstring(L, arg, &l);
      status = status && (fwrite(s, sizeof(char), l, f) == l);
    }
  }
  if (status) return 1;  /* file handle already on stack top */
  else return luaL_fileresult(L, status, NULL);
}


static int io_write (lua_State *L) {
  return g_write(L, getiofile(L, IO_OUTPUT), 1);
}


static int f_write (lua_State *L) {
  FILE *f = tofile(L);
  lua_pushvalue(L, 1);  /* push file at the stack top (to be returned) */
  return g_write(L, f, 2);
}


static int f_seek (lua_State *L) {
  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
  static const char *const modenames[] = {"set", "cur", "end", NULL};
  FILE *f = tofile(L);
  int op = luaL_checkoption(L, 2, "cur", modenames);
  lua_Integer p3 = luaL_optinteger(L, 3, 0);
  l_seeknum offset = (l_seeknum)p3;
  luaL_argcheck(L, (lua_Integer)offset == p3, 3,
                  "not an integer in proper range");
  op = l_fseek(f, offset, mode[op]);
  if (op)
    return luaL_fileresult(L, 0, NULL);  /* error */
  else {
    lua_pushinteger(L, (lua_Integer)l_ftell(f));
    return 1;
  }
}


static int f_setvbuf (lua_State *L) {
  static const int mode[] = {_IONBF, _IOFBF, _IOLBF};
  static const char *const modenames[] = {"no", "full", "line", NULL};
  FILE *f = tofile(L);
  int op = luaL_checkoption(L, 2, NULL, modenames);
  lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
  int res = setvbuf(f, NULL, mode[op], (size_t)sz);
  return luaL_fileresult(L, res == 0, NULL);
}



static int io_flush (lua_State *L) {
  return luaL_fileresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
}


static int f_flush (lua_State *L) {
  return luaL_fileresult(L, fflush(tofile(L)) == 0, NULL);
}


/*
** functions for 'io' library
*/
static const luaL_Reg iolib[] = {
  {"close", io_close},
  {"flush", io_flush},
  {"input", io_input},
  {"lines", io_lines},
  {"open", io_open},
  {"output", io_output},
  {"popen", io_popen},
  {"read", io_read},
  {"tmpfile", io_tmpfile},
  {"type", io_type},
  {"write", io_write},
  {NULL, NULL}
};


/*
** methods for file handles
*/
static const luaL_Reg flib[] = {
  {"close", io_close},
  {"flush", f_flush},
  {"lines", f_lines},
  {"read", f_read},
  {"seek", f_seek},
  {"setvbuf", f_setvbuf},
  {"write", f_write},
  {"__gc", f_gc},
  {"__tostring", f_tostring},
  {NULL, NULL}
};


static void createmeta (lua_State *L) {
  luaL_newmetatable(L, LUA_FILEHANDLE);  /* create metatable for file handles */
  lua_pushvalue(L, -1);  /* push metatable */
  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
  luaL_setfuncs(L, flib, 0);  /* add file methods to new metatable */
  lua_pop(L, 1);  /* pop new metatable */
}


/*
** function to (not) close the standard files stdin, stdout, and stderr
*/
static int io_noclose (lua_State *L) {
  LStream *p = tolstream(L);
  p->closef = &io_noclose;  /* keep file opened */
  lua_pushnil(L);
  lua_pushliteral(L, "cannot close standard file");
  return 2;
}


static void createstdfile (lua_State *L, FILE *f, const char *k,
                           const char *fname) {
  LStream *p = newprefile(L);
  p->f = f;
  p->closef = &io_noclose;
  if (k != NULL) {
    lua_pushvalue(L, -1);
    lua_setfield(L, LUA_REGISTRYINDEX, k);  /* add file to registry */
  }
  lua_setfield(L, -2, fname);  /* add file to module */
}


LUAMOD_API int luaopen_io (lua_State *L) {
  luaL_newlib(L, iolib);  /* new module */
  createmeta(L);
  /* create (and set) default files */
  createstdfile(L, stdin, IO_INPUT, "stdin");
  createstdfile(L, stdout, IO_OUTPUT, "stdout");
  createstdfile(L, stderr, NULL, "stderr");
  return 1;
}


```

`src/Lua/llex.c`:

```c
/*
** $Id: llex.c,v 2.96 2016/05/02 14:02:12 roberto Exp $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/

#define llex_c
#define LUA_CORE

#include "lprefix.h"


#include <locale.h>
#include <string.h>

#include "lua.h"

#include "lctype.h"
#include "ldebug.h"
#include "ldo.h"
#include "lgc.h"
#include "llex.h"
#include "lobject.h"
#include "lparser.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lzio.h"



#define next(ls) (ls->current = zgetc(ls->z))



#define currIsNewline(ls)	(ls->current == '\n' || ls->current == '\r')


/* ORDER RESERVED */
static const char *const luaX_tokens [] = {
    "and", "break", "do", "else", "elseif",
    "end", "false", "for", "function", "goto", "if",
    "in", "local", "nil", "not", "or", "repeat",
    "return", "then", "true", "until", "while",
    "//", "..", "...", "==", ">=", "<=", "~=",
    "<<", ">>", "::", "<eof>",
    "<number>", "<integer>", "<name>", "<string>"
};


#define save_and_next(ls) (save(ls, ls->current), next(ls))


static l_noret lexerror (LexState *ls, const char *msg, int token);


static void save (LexState *ls, int c) {
  Mbuffer *b = ls->buff;
  if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {
    size_t newsize;
    if (luaZ_sizebuffer(b) >= MAX_SIZE/2)
      lexerror(ls, "lexical element too long", 0);
    newsize = luaZ_sizebuffer(b) * 2;
    luaZ_resizebuffer(ls->L, b, newsize);
  }
  b->buffer[luaZ_bufflen(b)++] = cast(char, c);
}


void luaX_init (lua_State *L) {
  int i;
  TString *e = luaS_newliteral(L, LUA_ENV);  /* create env name */
  luaC_fix(L, obj2gco(e));  /* never collect this name */
  for (i=0; i<NUM_RESERVED; i++) {
    TString *ts = luaS_new(L, luaX_tokens[i]);
    luaC_fix(L, obj2gco(ts));  /* reserved words are never collected */
    ts->extra = cast_byte(i+1);  /* reserved word */
  }
}


const char *luaX_token2str (LexState *ls, int token) {
  if (token < FIRST_RESERVED) {  /* single-byte symbols? */
    lua_assert(token == cast_uchar(token));
    return luaO_pushfstring(ls->L, "'%c'", token);
  }
  else {
    const char *s = luaX_tokens[token - FIRST_RESERVED];
    if (token < TK_EOS)  /* fixed format (symbols and reserved words)? */
      return luaO_pushfstring(ls->L, "'%s'", s);
    else  /* names, strings, and numerals */
      return s;
  }
}


static const char *txtToken (LexState *ls, int token) {
  switch (token) {
    case TK_NAME: case TK_STRING:
    case TK_FLT: case TK_INT:
      save(ls, '\0');
      return luaO_pushfstring(ls->L, "'%s'", luaZ_buffer(ls->buff));
    default:
      return luaX_token2str(ls, token);
  }
}


static l_noret lexerror (LexState *ls, const char *msg, int token) {
  msg = luaG_addinfo(ls->L, msg, ls->source, ls->linenumber);
  if (token)
    luaO_pushfstring(ls->L, "%s near %s", msg, txtToken(ls, token));
  luaD_throw(ls->L, LUA_ERRSYNTAX);
}


l_noret luaX_syntaxerror (LexState *ls, const char *msg) {
  lexerror(ls, msg, ls->t.token);
}


/*
** creates a new string and anchors it in scanner's table so that
** it will not be collected until the end of the compilation
** (by that time it should be anchored somewhere)
*/
TString *luaX_newstring (LexState *ls, const char *str, size_t l) {
  lua_State *L = ls->L;
  TValue *o;  /* entry for 'str' */
  TString *ts = luaS_newlstr(L, str, l);  /* create new string */
  setsvalue2s(L, L->top++, ts);  /* temporarily anchor it in stack */
  o = luaH_set(L, ls->h, L->top - 1);
  if (ttisnil(o)) {  /* not in use yet? */
    /* boolean value does not need GC barrier;
       table has no metatable, so it does not need to invalidate cache */
    setbvalue(o, 1);  /* t[string] = true */
    luaC_checkGC(L);
  }
  else {  /* string already present */
    ts = tsvalue(keyfromval(o));  /* re-use value previously stored */
  }
  L->top--;  /* remove string from stack */
  return ts;
}


/*
** increment line number and skips newline sequence (any of
** \n, \r, \n\r, or \r\n)
*/
static void inclinenumber (LexState *ls) {
  int old = ls->current;
  lua_assert(currIsNewline(ls));
  next(ls);  /* skip '\n' or '\r' */
  if (currIsNewline(ls) && ls->current != old)
    next(ls);  /* skip '\n\r' or '\r\n' */
  if (++ls->linenumber >= MAX_INT)
    lexerror(ls, "chunk has too many lines", 0);
}


void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
                    int firstchar) {
  ls->t.token = 0;
  ls->L = L;
  ls->current = firstchar;
  ls->lookahead.token = TK_EOS;  /* no look-ahead token */
  ls->z = z;
  ls->fs = NULL;
  ls->linenumber = 1;
  ls->lastline = 1;
  ls->source = source;
  ls->envn = luaS_newliteral(L, LUA_ENV);  /* get env name */
  luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  /* initialize buffer */
}



/*
** =======================================================
** LEXICAL ANALYZER
** =======================================================
*/


static int check_next1 (LexState *ls, int c) {
  if (ls->current == c) {
    next(ls);
    return 1;
  }
  else return 0;
}


/*
** Check whether current char is in set 'set' (with two chars) and
** saves it
*/
static int check_next2 (LexState *ls, const char *set) {
  lua_assert(set[2] == '\0');
  if (ls->current == set[0] || ls->current == set[1]) {
    save_and_next(ls);
    return 1;
  }
  else return 0;
}


/* LUA_NUMBER */
/*
** this function is quite liberal in what it accepts, as 'luaO_str2num'
** will reject ill-formed numerals.
*/
static int read_numeral (LexState *ls, SemInfo *seminfo) {
  TValue obj;
  const char *expo = "Ee";
  int first = ls->current;
  lua_assert(lisdigit(ls->current));
  save_and_next(ls);
  if (first == '0' && check_next2(ls, "xX"))  /* hexadecimal? */
    expo = "Pp";
  for (;;) {
    if (check_next2(ls, expo))  /* exponent part? */
      check_next2(ls, "-+");  /* optional exponent sign */
    if (lisxdigit(ls->current))
      save_and_next(ls);
    else if (ls->current == '.')
      save_and_next(ls);
    else break;
  }
  save(ls, '\0');
  if (luaO_str2num(luaZ_buffer(ls->buff), &obj) == 0)  /* format error? */
    lexerror(ls, "malformed number", TK_FLT);
  if (ttisinteger(&obj)) {
    seminfo->i = ivalue(&obj);
    return TK_INT;
  }
  else {
    lua_assert(ttisfloat(&obj));
    seminfo->r = fltvalue(&obj);
    return TK_FLT;
  }
}


/*
** skip a sequence '[=*[' or ']=*]'; if sequence is well formed, return
** its number of '='s; otherwise, return a negative number (-1 iff there
** are no '='s after initial bracket)
*/
static int skip_sep (LexState *ls) {
  int count = 0;
  int s = ls->current;
  lua_assert(s == '[' || s == ']');
  save_and_next(ls);
  while (ls->current == '=') {
    save_and_next(ls);
    count++;
  }
  return (ls->current == s) ? count : (-count) - 1;
}


static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {
  int line = ls->linenumber;  /* initial line (for error message) */
  save_and_next(ls);  /* skip 2nd '[' */
  if (currIsNewline(ls))  /* string starts with a newline? */
    inclinenumber(ls);  /* skip it */
  for (;;) {
    switch (ls->current) {
      case EOZ: {  /* error */
        const char *what = (seminfo ? "string" : "comment");
        const char *msg = luaO_pushfstring(ls->L,
                     "unfinished long %s (starting at line %d)", what, line);
        lexerror(ls, msg, TK_EOS);
        break;  /* to avoid warnings */
      }
      case ']': {
        if (skip_sep(ls) == sep) {
          save_and_next(ls);  /* skip 2nd ']' */
          goto endloop;
        }
        break;
      }
      case '\n': case '\r': {
        save(ls, '\n');
        inclinenumber(ls);
        if (!seminfo) luaZ_resetbuffer(ls->buff);  /* avoid wasting space */
        break;
      }
      default: {
        if (seminfo) save_and_next(ls);
        else next(ls);
      }
    }
  } endloop:
  if (seminfo)
    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + (2 + sep),
                                     luaZ_bufflen(ls->buff) - 2*(2 + sep));
}


static void esccheck (LexState *ls, int c, const char *msg) {
  if (!c) {
    if (ls->current != EOZ)
      save_and_next(ls);  /* add current to buffer for error message */
    lexerror(ls, msg, TK_STRING);
  }
}


static int gethexa (LexState *ls) {
  save_and_next(ls);
  esccheck (ls, lisxdigit(ls->current), "hexadecimal digit expected");
  return luaO_hexavalue(ls->current);
}


static int readhexaesc (LexState *ls) {
  int r = gethexa(ls);
  r = (r << 4) + gethexa(ls);
  luaZ_buffremove(ls->buff, 2);  /* remove saved chars from buffer */
  return r;
}


static unsigned long readutf8esc (LexState *ls) {
  unsigned long r;
  int i = 4;  /* chars to be removed: '\', 'u', '{', and first digit */
  save_and_next(ls);  /* skip 'u' */
  esccheck(ls, ls->current == '{', "missing '{'");
  r = gethexa(ls);  /* must have at least one digit */
  while ((save_and_next(ls), lisxdigit(ls->current))) {
    i++;
    r = (r << 4) + luaO_hexavalue(ls->current);
    esccheck(ls, r <= 0x10FFFF, "UTF-8 value too large");
  }
  esccheck(ls, ls->current == '}', "missing '}'");
  next(ls);  /* skip '}' */
  luaZ_buffremove(ls->buff, i);  /* remove saved chars from buffer */
  return r;
}


static void utf8esc (LexState *ls) {
  char buff[UTF8BUFFSZ];
  int n = luaO_utf8esc(buff, readutf8esc(ls));
  for (; n > 0; n--)  /* add 'buff' to string */
    save(ls, buff[UTF8BUFFSZ - n]);
}


static int readdecesc (LexState *ls) {
  int i;
  int r = 0;  /* result accumulator */
  for (i = 0; i < 3 && lisdigit(ls->current); i++) {  /* read up to 3 digits */
    r = 10*r + ls->current - '0';
    save_and_next(ls);
  }
  esccheck(ls, r <= UCHAR_MAX, "decimal escape too large");
  luaZ_buffremove(ls->buff, i);  /* remove read digits from buffer */
  return r;
}


static void read_string (LexState *ls, int del, SemInfo *seminfo) {
  save_and_next(ls);  /* keep delimiter (for error messages) */
  while (ls->current != del) {
    switch (ls->current) {
      case EOZ:
        lexerror(ls, "unfinished string", TK_EOS);
        break;  /* to avoid warnings */
      case '\n':
      case '\r':
        lexerror(ls, "unfinished string", TK_STRING);
        break;  /* to avoid warnings */
      case '\\': {  /* escape sequences */
        int c;  /* final character to be saved */
        save_and_next(ls);  /* keep '\\' for error messages */
        switch (ls->current) {
          case 'a': c = '\a'; goto read_save;
          case 'b': c = '\b'; goto read_save;
          case 'f': c = '\f'; goto read_save;
          case 'n': c = '\n'; goto read_save;
          case 'r': c = '\r'; goto read_save;
          case 't': c = '\t'; goto read_save;
          case 'v': c = '\v'; goto read_save;
          case 'x': c = readhexaesc(ls); goto read_save;
          case 'u': utf8esc(ls);  goto no_save;
          case '\n': case '\r':
            inclinenumber(ls); c = '\n'; goto only_save;
          case '\\': case '\"': case '\'':
            c = ls->current; goto read_save;
          case EOZ: goto no_save;  /* will raise an error next loop */
          case 'z': {  /* zap following span of spaces */
            luaZ_buffremove(ls->buff, 1);  /* remove '\\' */
            next(ls);  /* skip the 'z' */
            while (lisspace(ls->current)) {
              if (currIsNewline(ls)) inclinenumber(ls);
              else next(ls);
            }
            goto no_save;
          }
          default: {
            esccheck(ls, lisdigit(ls->current), "invalid escape sequence");
            c = readdecesc(ls);  /* digital escape '\ddd' */
            goto only_save;
          }
        }
       read_save:
         next(ls);
         /* go through */
       only_save:
         luaZ_buffremove(ls->buff, 1);  /* remove '\\' */
         save(ls, c);
         /* go through */
       no_save: break;
      }
      default:
        save_and_next(ls);
    }
  }
  save_and_next(ls);  /* skip delimiter */
  seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,
                                   luaZ_bufflen(ls->buff) - 2);
}


static int llex (LexState *ls, SemInfo *seminfo) {
  luaZ_resetbuffer(ls->buff);
  for (;;) {
    switch (ls->current) {
      case '\n': case '\r': {  /* line breaks */
        inclinenumber(ls);
        break;
      }
      case ' ': case '\f': case '\t': case '\v': {  /* spaces */
        next(ls);
        break;
      }
      case '-': {  /* '-' or '--' (comment) */
        next(ls);
        if (ls->current != '-') return '-';
        /* else is a comment */
        next(ls);
        if (ls->current == '[') {  /* long comment? */
          int sep = skip_sep(ls);
          luaZ_resetbuffer(ls->buff);  /* 'skip_sep' may dirty the buffer */
          if (sep >= 0) {
            read_long_string(ls, NULL, sep);  /* skip long comment */
            luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */
            break;
          }
        }
        /* else short comment */
        while (!currIsNewline(ls) && ls->current != EOZ)
          next(ls);  /* skip until end of line (or end of file) */
        break;
      }
      case '[': {  /* long string or simply '[' */
        int sep = skip_sep(ls);
        if (sep >= 0) {
          read_long_string(ls, seminfo, sep);
          return TK_STRING;
        }
        else if (sep != -1)  /* '[=...' missing second bracket */
          lexerror(ls, "invalid long string delimiter", TK_STRING);
        return '[';
      }
      case '=': {
        next(ls);
        if (check_next1(ls, '=')) return TK_EQ;
        else return '=';
      }
      case '<': {
        next(ls);
        if (check_next1(ls, '=')) return TK_LE;
        else if (check_next1(ls, '<')) return TK_SHL;
        else return '<';
      }
      case '>': {
        next(ls);
        if (check_next1(ls, '=')) return TK_GE;
        else if (check_next1(ls, '>')) return TK_SHR;
        else return '>';
      }
      case '/': {
        next(ls);
        if (check_next1(ls, '/')) return TK_IDIV;
        else return '/';
      }
      case '~': {
        next(ls);
        if (check_next1(ls, '=')) return TK_NE;
        else return '~';
      }
      case ':': {
        next(ls);
        if (check_next1(ls, ':')) return TK_DBCOLON;
        else return ':';
      }
      case '"': case '\'': {  /* short literal strings */
        read_string(ls, ls->current, seminfo);
        return TK_STRING;
      }
      case '.': {  /* '.', '..', '...', or number */
        save_and_next(ls);
        if (check_next1(ls, '.')) {
          if (check_next1(ls, '.'))
            return TK_DOTS;   /* '...' */
          else return TK_CONCAT;   /* '..' */
        }
        else if (!lisdigit(ls->current)) return '.';
        else return read_numeral(ls, seminfo);
      }
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9': {
        return read_numeral(ls, seminfo);
      }
      case EOZ: {
        return TK_EOS;
      }
      default: {
        if (lislalpha(ls->current)) {  /* identifier or reserved word? */
          TString *ts;
          do {
            save_and_next(ls);
          } while (lislalnum(ls->current));
          ts = luaX_newstring(ls, luaZ_buffer(ls->buff),
                                  luaZ_bufflen(ls->buff));
          seminfo->ts = ts;
          if (isreserved(ts))  /* reserved word? */
            return ts->extra - 1 + FIRST_RESERVED;
          else {
            return TK_NAME;
          }
        }
        else {  /* single-char tokens (+ - / ...) */
          int c = ls->current;
          next(ls);
          return c;
        }
      }
    }
  }
}


void luaX_next (LexState *ls) {
  ls->lastline = ls->linenumber;
  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
    ls->t = ls->lookahead;  /* use this one */
    ls->lookahead.token = TK_EOS;  /* and discharge it */
  }
  else
    ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */
}


int luaX_lookahead (LexState *ls) {
  lua_assert(ls->lookahead.token == TK_EOS);
  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);
  return ls->lookahead.token;
}


```

`src/Lua/llex.h`:

```h
/*
** $Id: llex.h,v 1.79 2016/05/02 14:02:12 roberto Exp $
** Lexical Analyzer
** See Copyright Notice in lua.h
*/

#ifndef llex_h
#define llex_h

#include "lobject.h"
#include "lzio.h"


#define FIRST_RESERVED	257


#if !defined(LUA_ENV)
#define LUA_ENV		"_ENV"
#endif


/*
* WARNING: if you change the order of this enumeration,
* grep "ORDER RESERVED"
*/
enum RESERVED {
  /* terminal symbols denoted by reserved words */
  TK_AND = FIRST_RESERVED, TK_BREAK,
  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
  TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
  /* other terminal symbols */
  TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,
  TK_SHL, TK_SHR,
  TK_DBCOLON, TK_EOS,
  TK_FLT, TK_INT, TK_NAME, TK_STRING
};

/* number of reserved words */
#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))


typedef union {
  lua_Number r;
  lua_Integer i;
  TString *ts;
} SemInfo;  /* semantics information */


typedef struct Token {
  int token;
  SemInfo seminfo;
} Token;


/* state of the lexer plus state of the parser when shared by all
   functions */
typedef struct LexState {
  int current;  /* current character (charint) */
  int linenumber;  /* input line counter */
  int lastline;  /* line of last token 'consumed' */
  Token t;  /* current token */
  Token lookahead;  /* look ahead token */
  struct FuncState *fs;  /* current function (parser) */
  struct lua_State *L;
  ZIO *z;  /* input stream */
  Mbuffer *buff;  /* buffer for tokens */
  Table *h;  /* to avoid collection/reuse strings */
  struct Dyndata *dyd;  /* dynamic structures used by the parser */
  TString *source;  /* current source name */
  TString *envn;  /* environment variable name */
} LexState;


LUAI_FUNC void luaX_init (lua_State *L);
LUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,
                              TString *source, int firstchar);
LUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);
LUAI_FUNC void luaX_next (LexState *ls);
LUAI_FUNC int luaX_lookahead (LexState *ls);
LUAI_FUNC l_noret luaX_syntaxerror (LexState *ls, const char *s);
LUAI_FUNC const char *luaX_token2str (LexState *ls, int token);


#endif

```

`src/Lua/llimits.h`:

```h
/*
** $Id: llimits.h,v 1.141 2015/11/19 19:16:22 roberto Exp $
** Limits, basic types, and some other 'installation-dependent' definitions
** See Copyright Notice in lua.h
*/

#ifndef llimits_h
#define llimits_h


#include <limits.h>
#include <stddef.h>


#include "lua.h"

/*
** 'lu_mem' and 'l_mem' are unsigned/signed integers big enough to count
** the total memory used by Lua (in bytes). Usually, 'size_t' and
** 'ptrdiff_t' should work, but we use 'long' for 16-bit machines.
*/
#if defined(LUAI_MEM)		/* { external definitions? */
typedef LUAI_UMEM lu_mem;
typedef LUAI_MEM l_mem;
#elif LUAI_BITSINT >= 32	/* }{ */
typedef size_t lu_mem;
typedef ptrdiff_t l_mem;
#else  /* 16-bit ints */	/* }{ */
typedef unsigned long lu_mem;
typedef long l_mem;
#endif				/* } */


/* chars used as small naturals (so that 'char' is reserved for characters) */
typedef unsigned char lu_byte;


/* maximum value for size_t */
#define MAX_SIZET	((size_t)(~(size_t)0))

/* maximum size visible for Lua (must be representable in a lua_Integer */
#define MAX_SIZE	(sizeof(size_t) < sizeof(lua_Integer) ? MAX_SIZET \
                          : (size_t)(LUA_MAXINTEGER))


#define MAX_LUMEM	((lu_mem)(~(lu_mem)0))

#define MAX_LMEM	((l_mem)(MAX_LUMEM >> 1))


#define MAX_INT		INT_MAX  /* maximum value of an int */


/*
** conversion of pointer to unsigned integer:
** this is for hashing only; there is no problem if the integer
** cannot hold the whole pointer value
*/
#define point2uint(p)	((unsigned int)((size_t)(p) & UINT_MAX))



/* type to ensure maximum alignment */
#if defined(LUAI_USER_ALIGNMENT_T)
typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;
#else
typedef union {
  lua_Number n;
  double u;
  void *s;
  lua_Integer i;
  long l;
} L_Umaxalign;
#endif



/* types of 'usual argument conversions' for lua_Number and lua_Integer */
typedef LUAI_UACNUMBER l_uacNumber;
typedef LUAI_UACINT l_uacInt;


/* internal assertions for in-house debugging */
#if defined(lua_assert)
#define check_exp(c,e)		(lua_assert(c), (e))
/* to avoid problems with conditions too long */
#define lua_longassert(c)	((c) ? (void)0 : lua_assert(0))
#else
#define lua_assert(c)		((void)0)
#define check_exp(c,e)		(e)
#define lua_longassert(c)	((void)0)
#endif

/*
** assertion for checking API calls
*/
#if !defined(luai_apicheck)
#define luai_apicheck(l,e)	lua_assert(e)
#endif

#define api_check(l,e,msg)	luai_apicheck(l,(e) && msg)


/* macro to avoid warnings about unused variables */
#if !defined(UNUSED)
#define UNUSED(x)	((void)(x))
#endif


/* type casts (a macro highlights casts in the code) */
#define cast(t, exp)	((t)(exp))

#define cast_void(i)	cast(void, (i))
#define cast_byte(i)	cast(lu_byte, (i))
#define cast_num(i)	cast(lua_Number, (i))
#define cast_int(i)	cast(int, (i))
#define cast_uchar(i)	cast(unsigned char, (i))


/* cast a signed lua_Integer to lua_Unsigned */
#if !defined(l_castS2U)
#define l_castS2U(i)	((lua_Unsigned)(i))
#endif

/*
** cast a lua_Unsigned to a signed lua_Integer; this cast is
** not strict ISO C, but two-complement architectures should
** work fine.
*/
#if !defined(l_castU2S)
#define l_castU2S(i)	((lua_Integer)(i))
#endif


/*
** non-return type
*/
#if defined(__GNUC__)
#define l_noret		void __attribute__((noreturn))
#elif defined(_MSC_VER) && _MSC_VER >= 1200
#define l_noret		void __declspec(noreturn)
#else
#define l_noret		void
#endif



/*
** maximum depth for nested C calls and syntactical nested non-terminals
** in a program. (Value must fit in an unsigned short int.)
*/
#if !defined(LUAI_MAXCCALLS)
#define LUAI_MAXCCALLS		200
#endif



/*
** type for virtual-machine instructions;
** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
*/
#if LUAI_BITSINT >= 32
typedef unsigned int Instruction;
#else
typedef unsigned long Instruction;
#endif



/*
** Maximum length for short strings, that is, strings that are
** internalized. (Cannot be smaller than reserved words or tags for
** metamethods, as these strings must be internalized;
** #("function") = 8, #("__newindex") = 10.)
*/
#if !defined(LUAI_MAXSHORTLEN)
#define LUAI_MAXSHORTLEN	40
#endif


/*
** Initial size for the string table (must be power of 2).
** The Lua core alone registers ~50 strings (reserved words +
** metaevent keys + a few others). Libraries would typically add
** a few dozens more.
*/
#if !defined(MINSTRTABSIZE)
#define MINSTRTABSIZE	128
#endif


/*
** Size of cache for strings in the API. 'N' is the number of
** sets (better be a prime) and "M" is the size of each set (M == 1
** makes a direct cache.)
*/
#if !defined(STRCACHE_N)
#define STRCACHE_N		53
#define STRCACHE_M		2
#endif


/* minimum size for string buffer */
#if !defined(LUA_MINBUFFER)
#define LUA_MINBUFFER	32
#endif


/*
** macros that are executed whenever program enters the Lua core
** ('lua_lock') and leaves the core ('lua_unlock')
*/
#if !defined(lua_lock)
#define lua_lock(L)	((void) 0)
#define lua_unlock(L)	((void) 0)
#endif

/*
** macro executed during Lua functions at points where the
** function can yield.
*/
#if !defined(luai_threadyield)
#define luai_threadyield(L)	{lua_unlock(L); lua_lock(L);}
#endif


/*
** these macros allow user-specific actions on threads when you defined
** LUAI_EXTRASPACE and need to do something extra when a thread is
** created/deleted/resumed/yielded.
*/
#if !defined(luai_userstateopen)
#define luai_userstateopen(L)		((void)L)
#endif

#if !defined(luai_userstateclose)
#define luai_userstateclose(L)		((void)L)
#endif

#if !defined(luai_userstatethread)
#define luai_userstatethread(L,L1)	((void)L)
#endif

#if !defined(luai_userstatefree)
#define luai_userstatefree(L,L1)	((void)L)
#endif

#if !defined(luai_userstateresume)
#define luai_userstateresume(L,n)	((void)L)
#endif

#if !defined(luai_userstateyield)
#define luai_userstateyield(L,n)	((void)L)
#endif



/*
** The luai_num* macros define the primitive operations over numbers.
*/

/* floor division (defined as 'floor(a/b)') */
#if !defined(luai_numidiv)
#define luai_numidiv(L,a,b)     ((void)L, l_floor(luai_numdiv(L,a,b)))
#endif

/* float division */
#if !defined(luai_numdiv)
#define luai_numdiv(L,a,b)      ((a)/(b))
#endif

/*
** modulo: defined as 'a - floor(a/b)*b'; this definition gives NaN when
** 'b' is huge, but the result should be 'a'. 'fmod' gives the result of
** 'a - trunc(a/b)*b', and therefore must be corrected when 'trunc(a/b)
** ~= floor(a/b)'. That happens when the division has a non-integer
** negative result, which is equivalent to the test below.
*/
#if !defined(luai_nummod)
#define luai_nummod(L,a,b,m)  \
  { (m) = l_mathop(fmod)(a,b); if ((m)*(b) < 0) (m) += (b); }
#endif

/* exponentiation */
#if !defined(luai_numpow)
#define luai_numpow(L,a,b)      ((void)L, l_mathop(pow)(a,b))
#endif

/* the others are quite standard operations */
#if !defined(luai_numadd)
#define luai_numadd(L,a,b)      ((a)+(b))
#define luai_numsub(L,a,b)      ((a)-(b))
#define luai_nummul(L,a,b)      ((a)*(b))
#define luai_numunm(L,a)        (-(a))
#define luai_numeq(a,b)         ((a)==(b))
#define luai_numlt(a,b)         ((a)<(b))
#define luai_numle(a,b)         ((a)<=(b))
#define luai_numisnan(a)        (!luai_numeq((a), (a)))
#endif





/*
** macro to control inclusion of some hard tests on stack reallocation
*/
#if !defined(HARDSTACKTESTS)
#define condmovestack(L,pre,pos)	((void)0)
#else
/* realloc stack keeping its size */
#define condmovestack(L,pre,pos)  \
	{ int sz_ = (L)->stacksize; pre; luaD_reallocstack((L), sz_); pos; }
#endif

#if !defined(HARDMEMTESTS)
#define condchangemem(L,pre,pos)	((void)0)
#else
#define condchangemem(L,pre,pos)  \
	{ if (G(L)->gcrunning) { pre; luaC_fullgc(L, 0); pos; } }
#endif

#endif

```

`src/Lua/lmathlib.c`:

```c
/*
** $Id: lmathlib.c,v 1.119 2016/12/22 13:08:50 roberto Exp $
** Standard mathematical library
** See Copyright Notice in lua.h
*/

#define lmathlib_c
#define LUA_LIB

#include "lprefix.h"


#include <stdlib.h>
#include <math.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


#undef PI
#define PI	(l_mathop(3.141592653589793238462643383279502884))


#if !defined(l_rand)		/* { */
#if defined(LUA_USE_POSIX)
#define l_rand()	random()
#define l_srand(x)	srandom(x)
#define L_RANDMAX	2147483647	/* (2^31 - 1), following POSIX */
#else
#define l_rand()	rand()
#define l_srand(x)	srand(x)
#define L_RANDMAX	RAND_MAX
#endif
#endif				/* } */


static int math_abs (lua_State *L) {
  if (lua_isinteger(L, 1)) {
    lua_Integer n = lua_tointeger(L, 1);
    if (n < 0) n = (lua_Integer)(0u - (lua_Unsigned)n);
    lua_pushinteger(L, n);
  }
  else
    lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_sin (lua_State *L) {
  lua_pushnumber(L, l_mathop(sin)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_cos (lua_State *L) {
  lua_pushnumber(L, l_mathop(cos)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_tan (lua_State *L) {
  lua_pushnumber(L, l_mathop(tan)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_asin (lua_State *L) {
  lua_pushnumber(L, l_mathop(asin)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_acos (lua_State *L) {
  lua_pushnumber(L, l_mathop(acos)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_atan (lua_State *L) {
  lua_Number y = luaL_checknumber(L, 1);
  lua_Number x = luaL_optnumber(L, 2, 1);
  lua_pushnumber(L, l_mathop(atan2)(y, x));
  return 1;
}


static int math_toint (lua_State *L) {
  int valid;
  lua_Integer n = lua_tointegerx(L, 1, &valid);
  if (valid)
    lua_pushinteger(L, n);
  else {
    luaL_checkany(L, 1);
    lua_pushnil(L);  /* value is not convertible to integer */
  }
  return 1;
}


static void pushnumint (lua_State *L, lua_Number d) {
  lua_Integer n;
  if (lua_numbertointeger(d, &n))  /* does 'd' fit in an integer? */
    lua_pushinteger(L, n);  /* result is integer */
  else
    lua_pushnumber(L, d);  /* result is float */
}


static int math_floor (lua_State *L) {
  if (lua_isinteger(L, 1))
    lua_settop(L, 1);  /* integer is its own floor */
  else {
    lua_Number d = l_mathop(floor)(luaL_checknumber(L, 1));
    pushnumint(L, d);
  }
  return 1;
}


static int math_ceil (lua_State *L) {
  if (lua_isinteger(L, 1))
    lua_settop(L, 1);  /* integer is its own ceil */
  else {
    lua_Number d = l_mathop(ceil)(luaL_checknumber(L, 1));
    pushnumint(L, d);
  }
  return 1;
}


static int math_fmod (lua_State *L) {
  if (lua_isinteger(L, 1) && lua_isinteger(L, 2)) {
    lua_Integer d = lua_tointeger(L, 2);
    if ((lua_Unsigned)d + 1u <= 1u) {  /* special cases: -1 or 0 */
      luaL_argcheck(L, d != 0, 2, "zero");
      lua_pushinteger(L, 0);  /* avoid overflow with 0x80000... / -1 */
    }
    else
      lua_pushinteger(L, lua_tointeger(L, 1) % d);
  }
  else
    lua_pushnumber(L, l_mathop(fmod)(luaL_checknumber(L, 1),
                                     luaL_checknumber(L, 2)));
  return 1;
}


/*
** next function does not use 'modf', avoiding problems with 'double*'
** (which is not compatible with 'float*') when lua_Number is not
** 'double'.
*/
static int math_modf (lua_State *L) {
  if (lua_isinteger(L ,1)) {
    lua_settop(L, 1);  /* number is its own integer part */
    lua_pushnumber(L, 0);  /* no fractional part */
  }
  else {
    lua_Number n = luaL_checknumber(L, 1);
    /* integer part (rounds toward zero) */
    lua_Number ip = (n < 0) ? l_mathop(ceil)(n) : l_mathop(floor)(n);
    pushnumint(L, ip);
    /* fractional part (test needed for inf/-inf) */
    lua_pushnumber(L, (n == ip) ? l_mathop(0.0) : (n - ip));
  }
  return 2;
}


static int math_sqrt (lua_State *L) {
  lua_pushnumber(L, l_mathop(sqrt)(luaL_checknumber(L, 1)));
  return 1;
}


static int math_ult (lua_State *L) {
  lua_Integer a = luaL_checkinteger(L, 1);
  lua_Integer b = luaL_checkinteger(L, 2);
  lua_pushboolean(L, (lua_Unsigned)a < (lua_Unsigned)b);
  return 1;
}

static int math_log (lua_State *L) {
  lua_Number x = luaL_checknumber(L, 1);
  lua_Number res;
  if (lua_isnoneornil(L, 2))
    res = l_mathop(log)(x);
  else {
    lua_Number base = luaL_checknumber(L, 2);
#if !defined(LUA_USE_C89)
    if (base == l_mathop(2.0))
      res = l_mathop(log2)(x); else
#endif
    if (base == l_mathop(10.0))
      res = l_mathop(log10)(x);
    else
      res = l_mathop(log)(x)/l_mathop(log)(base);
  }
  lua_pushnumber(L, res);
  return 1;
}

static int math_exp (lua_State *L) {
  lua_pushnumber(L, l_mathop(exp)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_deg (lua_State *L) {
  lua_pushnumber(L, luaL_checknumber(L, 1) * (l_mathop(180.0) / PI));
  return 1;
}

static int math_rad (lua_State *L) {
  lua_pushnumber(L, luaL_checknumber(L, 1) * (PI / l_mathop(180.0)));
  return 1;
}


static int math_min (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  int imin = 1;  /* index of current minimum value */
  int i;
  luaL_argcheck(L, n >= 1, 1, "value expected");
  for (i = 2; i <= n; i++) {
    if (lua_compare(L, i, imin, LUA_OPLT))
      imin = i;
  }
  lua_pushvalue(L, imin);
  return 1;
}


static int math_max (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  int imax = 1;  /* index of current maximum value */
  int i;
  luaL_argcheck(L, n >= 1, 1, "value expected");
  for (i = 2; i <= n; i++) {
    if (lua_compare(L, imax, i, LUA_OPLT))
      imax = i;
  }
  lua_pushvalue(L, imax);
  return 1;
}

/*
** This function uses 'double' (instead of 'lua_Number') to ensure that
** all bits from 'l_rand' can be represented, and that 'RANDMAX + 1.0'
** will keep full precision (ensuring that 'r' is always less than 1.0.)
*/
static int math_random (lua_State *L) {
  lua_Integer low, up;
  double r = (double)l_rand() * (1.0 / ((double)L_RANDMAX + 1.0));
  switch (lua_gettop(L)) {  /* check number of arguments */
    case 0: {  /* no arguments */
      lua_pushnumber(L, (lua_Number)r);  /* Number between 0 and 1 */
      return 1;
    }
    case 1: {  /* only upper limit */
      low = 1;
      up = luaL_checkinteger(L, 1);
      break;
    }
    case 2: {  /* lower and upper limits */
      low = luaL_checkinteger(L, 1);
      up = luaL_checkinteger(L, 2);
      break;
    }
    default: return luaL_error(L, "wrong number of arguments");
  }
  /* random integer in the interval [low, up] */
  luaL_argcheck(L, low <= up, 1, "interval is empty");
  luaL_argcheck(L, low >= 0 || up <= LUA_MAXINTEGER + low, 1,
                   "interval too large");
  r *= (double)(up - low) + 1.0;
  lua_pushinteger(L, (lua_Integer)r + low);
  return 1;
}


static int math_randomseed (lua_State *L) {
  l_srand((unsigned int)(lua_Integer)luaL_checknumber(L, 1));
  (void)l_rand(); /* discard first value to avoid undesirable correlations */
  return 0;
}


static int math_type (lua_State *L) {
  if (lua_type(L, 1) == LUA_TNUMBER) {
      if (lua_isinteger(L, 1))
        lua_pushliteral(L, "integer");
      else
        lua_pushliteral(L, "float");
  }
  else {
    luaL_checkany(L, 1);
    lua_pushnil(L);
  }
  return 1;
}


/*
** {==================================================================
** Deprecated functions (for compatibility only)
** ===================================================================
*/
#if defined(LUA_COMPAT_MATHLIB)

static int math_cosh (lua_State *L) {
  lua_pushnumber(L, l_mathop(cosh)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_sinh (lua_State *L) {
  lua_pushnumber(L, l_mathop(sinh)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_tanh (lua_State *L) {
  lua_pushnumber(L, l_mathop(tanh)(luaL_checknumber(L, 1)));
  return 1;
}

static int math_pow (lua_State *L) {
  lua_Number x = luaL_checknumber(L, 1);
  lua_Number y = luaL_checknumber(L, 2);
  lua_pushnumber(L, l_mathop(pow)(x, y));
  return 1;
}

static int math_frexp (lua_State *L) {
  int e;
  lua_pushnumber(L, l_mathop(frexp)(luaL_checknumber(L, 1), &e));
  lua_pushinteger(L, e);
  return 2;
}

static int math_ldexp (lua_State *L) {
  lua_Number x = luaL_checknumber(L, 1);
  int ep = (int)luaL_checkinteger(L, 2);
  lua_pushnumber(L, l_mathop(ldexp)(x, ep));
  return 1;
}

static int math_log10 (lua_State *L) {
  lua_pushnumber(L, l_mathop(log10)(luaL_checknumber(L, 1)));
  return 1;
}

#endif
/* }================================================================== */



static const luaL_Reg mathlib[] = {
  {"abs",   math_abs},
  {"acos",  math_acos},
  {"asin",  math_asin},
  {"atan",  math_atan},
  {"ceil",  math_ceil},
  {"cos",   math_cos},
  {"deg",   math_deg},
  {"exp",   math_exp},
  {"tointeger", math_toint},
  {"floor", math_floor},
  {"fmod",   math_fmod},
  {"ult",   math_ult},
  {"log",   math_log},
  {"max",   math_max},
  {"min",   math_min},
  {"modf",   math_modf},
  {"rad",   math_rad},
  {"random",     math_random},
  {"randomseed", math_randomseed},
  {"sin",   math_sin},
  {"sqrt",  math_sqrt},
  {"tan",   math_tan},
  {"type", math_type},
#if defined(LUA_COMPAT_MATHLIB)
  {"atan2", math_atan},
  {"cosh",   math_cosh},
  {"sinh",   math_sinh},
  {"tanh",   math_tanh},
  {"pow",   math_pow},
  {"frexp", math_frexp},
  {"ldexp", math_ldexp},
  {"log10", math_log10},
#endif
  /* placeholders */
  {"pi", NULL},
  {"huge", NULL},
  {"maxinteger", NULL},
  {"mininteger", NULL},
  {NULL, NULL}
};


/*
** Open math library
*/
LUAMOD_API int luaopen_math (lua_State *L) {
  luaL_newlib(L, mathlib);
  lua_pushnumber(L, PI);
  lua_setfield(L, -2, "pi");
  lua_pushnumber(L, (lua_Number)HUGE_VAL);
  lua_setfield(L, -2, "huge");
  lua_pushinteger(L, LUA_MAXINTEGER);
  lua_setfield(L, -2, "maxinteger");
  lua_pushinteger(L, LUA_MININTEGER);
  lua_setfield(L, -2, "mininteger");
  return 1;
}


```

`src/Lua/lmem.c`:

```c
/*
** $Id: lmem.c,v 1.91 2015/03/06 19:45:54 roberto Exp $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/

#define lmem_c
#define LUA_CORE

#include "lprefix.h"


#include <stddef.h>

#include "lua.h"

#include "ldebug.h"
#include "ldo.h"
#include "lgc.h"
#include "lmem.h"
#include "lobject.h"
#include "lstate.h"



/*
** About the realloc function:
** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
** ('osize' is the old size, 'nsize' is the new size)
**
** * frealloc(ud, NULL, x, s) creates a new block of size 's' (no
** matter 'x').
**
** * frealloc(ud, p, x, 0) frees the block 'p'
** (in this specific case, frealloc must return NULL);
** particularly, frealloc(ud, NULL, 0, 0) does nothing
** (which is equivalent to free(NULL) in ISO C)
**
** frealloc returns NULL if it cannot create or reallocate the area
** (any reallocation to an equal or smaller size cannot fail!)
*/



#define MINSIZEARRAY	4


void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
                     int limit, const char *what) {
  void *newblock;
  int newsize;
  if (*size >= limit/2) {  /* cannot double it? */
    if (*size >= limit)  /* cannot grow even a little? */
      luaG_runerror(L, "too many %s (limit is %d)", what, limit);
    newsize = limit;  /* still have at least one free place */
  }
  else {
    newsize = (*size)*2;
    if (newsize < MINSIZEARRAY)
      newsize = MINSIZEARRAY;  /* minimum size */
  }
  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
  *size = newsize;  /* update only when everything else is OK */
  return newblock;
}


l_noret luaM_toobig (lua_State *L) {
  luaG_runerror(L, "memory allocation error: block too big");
}



/*
** generic allocation routine.
*/
void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
  void *newblock;
  global_State *g = G(L);
  size_t realosize = (block) ? osize : 0;
  lua_assert((realosize == 0) == (block == NULL));
#if defined(HARDMEMTESTS)
  if (nsize > realosize && g->gcrunning)
    luaC_fullgc(L, 1);  /* force a GC whenever possible */
#endif
  newblock = (*g->frealloc)(g->ud, block, osize, nsize);
  if (newblock == NULL && nsize > 0) {
    lua_assert(nsize > realosize);  /* cannot fail when shrinking a block */
    if (g->version) {  /* is state fully built? */
      luaC_fullgc(L, 1);  /* try to free some memory... */
      newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */
    }
    if (newblock == NULL)
      luaD_throw(L, LUA_ERRMEM);
  }
  lua_assert((nsize == 0) == (newblock == NULL));
  g->GCdebt = (g->GCdebt + nsize) - realosize;
  return newblock;
}


```

`src/Lua/lmem.h`:

```h
/*
** $Id: lmem.h,v 1.43 2014/12/19 17:26:14 roberto Exp $
** Interface to Memory Manager
** See Copyright Notice in lua.h
*/

#ifndef lmem_h
#define lmem_h


#include <stddef.h>

#include "llimits.h"
#include "lua.h"


/*
** This macro reallocs a vector 'b' from 'on' to 'n' elements, where
** each element has size 'e'. In case of arithmetic overflow of the
** product 'n'*'e', it raises an error (calling 'luaM_toobig'). Because
** 'e' is always constant, it avoids the runtime division MAX_SIZET/(e).
**
** (The macro is somewhat complex to avoid warnings:  The 'sizeof'
** comparison avoids a runtime comparison when overflow cannot occur.
** The compiler should be able to optimize the real test by itself, but
** when it does it, it may give a warning about "comparison is always
** false due to limited range of data type"; the +1 tricks the compiler,
** avoiding this warning but also this optimization.)
*/
#define luaM_reallocv(L,b,on,n,e) \
  (((sizeof(n) >= sizeof(size_t) && cast(size_t, (n)) + 1 > MAX_SIZET/(e)) \
      ? luaM_toobig(L) : cast_void(0)) , \
   luaM_realloc_(L, (b), (on)*(e), (n)*(e)))

/*
** Arrays of chars do not need any test
*/
#define luaM_reallocvchar(L,b,on,n)  \
    cast(char *, luaM_realloc_(L, (b), (on)*sizeof(char), (n)*sizeof(char)))

#define luaM_freemem(L, b, s)	luaM_realloc_(L, (b), (s), 0)
#define luaM_free(L, b)		luaM_realloc_(L, (b), sizeof(*(b)), 0)
#define luaM_freearray(L, b, n)   luaM_realloc_(L, (b), (n)*sizeof(*(b)), 0)

#define luaM_malloc(L,s)	luaM_realloc_(L, NULL, 0, (s))
#define luaM_new(L,t)		cast(t *, luaM_malloc(L, sizeof(t)))
#define luaM_newvector(L,n,t) \
		cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))

#define luaM_newobject(L,tag,s)	luaM_realloc_(L, NULL, tag, (s))

#define luaM_growvector(L,v,nelems,size,t,limit,e) \
          if ((nelems)+1 > (size)) \
            ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))

#define luaM_reallocvector(L, v,oldn,n,t) \
   ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))

LUAI_FUNC l_noret luaM_toobig (lua_State *L);

/* not to be called directly */
LUAI_FUNC void *luaM_realloc_ (lua_State *L, void *block, size_t oldsize,
                                                          size_t size);
LUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int *size,
                               size_t size_elem, int limit,
                               const char *what);

#endif


```

`src/Lua/loadlib.c`:

```c
/*
** $Id: loadlib.c,v 1.130 2017/01/12 17:14:26 roberto Exp $
** Dynamic library loader for Lua
** See Copyright Notice in lua.h
**
** This module contains an implementation of loadlib for Unix systems
** that have dlfcn, an implementation for Windows, and a stub for other
** systems.
*/

#define loadlib_c
#define LUA_LIB

#include "lprefix.h"


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


/*
** LUA_IGMARK is a mark to ignore all before it when building the
** luaopen_ function name.
*/
#if !defined (LUA_IGMARK)
#define LUA_IGMARK		"-"
#endif


/*
** LUA_CSUBSEP is the character that replaces dots in submodule names
** when searching for a C loader.
** LUA_LSUBSEP is the character that replaces dots in submodule names
** when searching for a Lua loader.
*/
#if !defined(LUA_CSUBSEP)
#define LUA_CSUBSEP		LUA_DIRSEP
#endif

#if !defined(LUA_LSUBSEP)
#define LUA_LSUBSEP		LUA_DIRSEP
#endif


/* prefix for open functions in C libraries */
#define LUA_POF		"luaopen_"

/* separator for open functions in C libraries */
#define LUA_OFSEP	"_"


/*
** unique key for table in the registry that keeps handles
** for all loaded C libraries
*/
static const int CLIBS = 0;

#define LIB_FAIL	"open"


#define setprogdir(L)           ((void)0)


/*
** system-dependent functions
*/

/*
** unload library 'lib'
*/
static void lsys_unloadlib (void *lib);

/*
** load C library in file 'path'. If 'seeglb', load with all names in
** the library global.
** Returns the library; in case of error, returns NULL plus an
** error string in the stack.
*/
static void *lsys_load (lua_State *L, const char *path, int seeglb);

/*
** Try to find a function named 'sym' in library 'lib'.
** Returns the function; in case of error, returns NULL plus an
** error string in the stack.
*/
static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym);




#if defined(LUA_USE_DLOPEN)	/* { */
/*
** {========================================================================
** This is an implementation of loadlib based on the dlfcn interface.
** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
** as an emulation layer on top of native functions.
** =========================================================================
*/

#include <dlfcn.h>

/*
** Macro to convert pointer-to-void* to pointer-to-function. This cast
** is undefined according to ISO C, but POSIX assumes that it works.
** (The '__extension__' in gnu compilers is only to avoid warnings.)
*/
#if defined(__GNUC__)
#define cast_func(p) (__extension__ (lua_CFunction)(p))
#else
#define cast_func(p) ((lua_CFunction)(p))
#endif


static void lsys_unloadlib (void *lib) {
  dlclose(lib);
}


static void *lsys_load (lua_State *L, const char *path, int seeglb) {
  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));
  if (lib == NULL) lua_pushstring(L, dlerror());
  return lib;
}


static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {
  lua_CFunction f = cast_func(dlsym(lib, sym));
  if (f == NULL) lua_pushstring(L, dlerror());
  return f;
}

/* }====================================================== */



#elif defined(LUA_DL_DLL)	/* }{ */
/*
** {======================================================================
** This is an implementation of loadlib for Windows using native functions.
** =======================================================================
*/

#include <windows.h>


/*
** optional flags for LoadLibraryEx
*/
#if !defined(LUA_LLE_FLAGS)
#define LUA_LLE_FLAGS	0
#endif


#undef setprogdir


/*
** Replace in the path (on the top of the stack) any occurrence
** of LUA_EXEC_DIR with the executable's path.
*/
static void setprogdir (lua_State *L) {
  char buff[MAX_PATH + 1];
  char *lb;
  DWORD nsize = sizeof(buff)/sizeof(char);
  DWORD n = GetModuleFileNameA(NULL, buff, nsize);  /* get exec. name */
  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\')) == NULL)
    luaL_error(L, "unable to get ModuleFileName");
  else {
    *lb = '\0';  /* cut name on the last '\\' to get the path */
    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);
    lua_remove(L, -2);  /* remove original string */
  }
}




static void pusherror (lua_State *L) {
  int error = GetLastError();
  char buffer[128];
  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))
    lua_pushstring(L, buffer);
  else
    lua_pushfstring(L, "system error %d\n", error);
}

static void lsys_unloadlib (void *lib) {
  FreeLibrary((HMODULE)lib);
}


static void *lsys_load (lua_State *L, const char *path, int seeglb) {
  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);
  (void)(seeglb);  /* not used: symbols are 'global' by default */
  if (lib == NULL) pusherror(L);
  return lib;
}


static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {
  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);
  if (f == NULL) pusherror(L);
  return f;
}

/* }====================================================== */


#else				/* }{ */
/*
** {======================================================
** Fallback for other systems
** =======================================================
*/

#undef LIB_FAIL
#define LIB_FAIL	"absent"


#define DLMSG	"dynamic libraries not enabled; check your Lua installation"


static void lsys_unloadlib (void *lib) {
  (void)(lib);  /* not used */
}


static void *lsys_load (lua_State *L, const char *path, int seeglb) {
  (void)(path); (void)(seeglb);  /* not used */
  lua_pushliteral(L, DLMSG);
  return NULL;
}


static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {
  (void)(lib); (void)(sym);  /* not used */
  lua_pushliteral(L, DLMSG);
  return NULL;
}

/* }====================================================== */
#endif				/* } */


/*
** {==================================================================
** Set Paths
** ===================================================================
*/

/*
** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment
** variables that Lua check to set its paths.
*/
#if !defined(LUA_PATH_VAR)
#define LUA_PATH_VAR    "LUA_PATH"
#endif

#if !defined(LUA_CPATH_VAR)
#define LUA_CPATH_VAR   "LUA_CPATH"
#endif


#define AUXMARK         "\1"	/* auxiliary mark */


/*
** return registry.LUA_NOENV as a boolean
*/
static int noenv (lua_State *L) {
  int b;
  lua_getfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
  b = lua_toboolean(L, -1);
  lua_pop(L, 1);  /* remove value */
  return b;
}


/*
** Set a path
*/
static void setpath (lua_State *L, const char *fieldname,
                                   const char *envname,
                                   const char *dft) {
  const char *nver = lua_pushfstring(L, "%s%s", envname, LUA_VERSUFFIX);
  const char *path = getenv(nver);  /* use versioned name */
  if (path == NULL)  /* no environment variable? */
    path = getenv(envname);  /* try unversioned name */
  if (path == NULL || noenv(L))  /* no environment variable? */
    lua_pushstring(L, dft);  /* use default */
  else {
    /* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,
                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);
    luaL_gsub(L, path, AUXMARK, dft);
    lua_remove(L, -2); /* remove result from 1st 'gsub' */
  }
  setprogdir(L);
  lua_setfield(L, -3, fieldname);  /* package[fieldname] = path value */
  lua_pop(L, 1);  /* pop versioned variable name */
}

/* }================================================================== */


/*
** return registry.CLIBS[path]
*/
static void *checkclib (lua_State *L, const char *path) {
  void *plib;
  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);
  lua_getfield(L, -1, path);
  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */
  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */
  return plib;
}


/*
** registry.CLIBS[path] = plib        -- for queries
** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries
*/
static void addtoclib (lua_State *L, const char *path, void *plib) {
  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);
  lua_pushlightuserdata(L, plib);
  lua_pushvalue(L, -1);
  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */
  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */
  lua_pop(L, 1);  /* pop CLIBS table */
}


/*
** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib
** handles in list CLIBS
*/
static int gctm (lua_State *L) {
  lua_Integer n = luaL_len(L, 1);
  for (; n >= 1; n--) {  /* for each handle, in reverse order */
    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */
    lsys_unloadlib(lua_touserdata(L, -1));
    lua_pop(L, 1);  /* pop handle */
  }
  return 0;
}



/* error codes for 'lookforfunc' */
#define ERRLIB		1
#define ERRFUNC		2

/*
** Look for a C function named 'sym' in a dynamically loaded library
** 'path'.
** First, check whether the library is already loaded; if not, try
** to load it.
** Then, if 'sym' is '*', return true (as library has been loaded).
** Otherwise, look for symbol 'sym' in the library and push a
** C function with that symbol.
** Return 0 and 'true' or a function in the stack; in case of
** errors, return an error code and an error message in the stack.
*/
static int lookforfunc (lua_State *L, const char *path, const char *sym) {
  void *reg = checkclib(L, path);  /* check loaded C libraries */
  if (reg == NULL) {  /* must load library? */
    reg = lsys_load(L, path, *sym == '*');  /* global symbols if 'sym'=='*' */
    if (reg == NULL) return ERRLIB;  /* unable to load library */
    addtoclib(L, path, reg);
  }
  if (*sym == '*') {  /* loading only library (no function)? */
    lua_pushboolean(L, 1);  /* return 'true' */
    return 0;  /* no errors */
  }
  else {
    lua_CFunction f = lsys_sym(L, reg, sym);
    if (f == NULL)
      return ERRFUNC;  /* unable to find function */
    lua_pushcfunction(L, f);  /* else create new function */
    return 0;  /* no errors */
  }
}


static int ll_loadlib (lua_State *L) {
  const char *path = luaL_checkstring(L, 1);
  const char *init = luaL_checkstring(L, 2);
  int stat = lookforfunc(L, path, init);
  if (stat == 0)  /* no errors? */
    return 1;  /* return the loaded function */
  else {  /* error; error message is on stack top */
    lua_pushnil(L);
    lua_insert(L, -2);
    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : "init");
    return 3;  /* return nil, error message, and where */
  }
}



/*
** {======================================================
** 'require' function
** =======================================================
*/


static int readable (const char *filename) {
  FILE *f = fopen(filename, "r");  /* try to open file */
  if (f == NULL) return 0;  /* open failed */
  fclose(f);
  return 1;
}


static const char *pushnexttemplate (lua_State *L, const char *path) {
  const char *l;
  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */
  if (*path == '\0') return NULL;  /* no more templates */
  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */
  if (l == NULL) l = path + strlen(path);
  lua_pushlstring(L, path, l - path);  /* template */
  return l;
}


static const char *searchpath (lua_State *L, const char *name,
                                             const char *path,
                                             const char *sep,
                                             const char *dirsep) {
  luaL_Buffer msg;  /* to build error message */
  luaL_buffinit(L, &msg);
  if (*sep != '\0')  /* non-empty separator? */
    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */
  while ((path = pushnexttemplate(L, path)) != NULL) {
    const char *filename = luaL_gsub(L, lua_tostring(L, -1),
                                     LUA_PATH_MARK, name);
    lua_remove(L, -2);  /* remove path template */
    if (readable(filename))  /* does file exist and is readable? */
      return filename;  /* return that file name */
    lua_pushfstring(L, "\n\tno file '%s'", filename);
    lua_remove(L, -2);  /* remove file name */
    luaL_addvalue(&msg);  /* concatenate error msg. entry */
  }
  luaL_pushresult(&msg);  /* create error message */
  return NULL;  /* not found */
}


static int ll_searchpath (lua_State *L) {
  const char *f = searchpath(L, luaL_checkstring(L, 1),
                                luaL_checkstring(L, 2),
                                luaL_optstring(L, 3, "."),
                                luaL_optstring(L, 4, LUA_DIRSEP));
  if (f != NULL) return 1;
  else {  /* error message is on top of the stack */
    lua_pushnil(L);
    lua_insert(L, -2);
    return 2;  /* return nil + error message */
  }
}


static const char *findfile (lua_State *L, const char *name,
                                           const char *pname,
                                           const char *dirsep) {
  const char *path;
  lua_getfield(L, lua_upvalueindex(1), pname);
  path = lua_tostring(L, -1);
  if (path == NULL)
    luaL_error(L, "'package.%s' must be a string", pname);
  return searchpath(L, name, path, ".", dirsep);
}


static int checkload (lua_State *L, int stat, const char *filename) {
  if (stat) {  /* module loaded successfully? */
    lua_pushstring(L, filename);  /* will be 2nd argument to module */
    return 2;  /* return open function and file name */
  }
  else
    return luaL_error(L, "error loading module '%s' from file '%s':\n\t%s",
                          lua_tostring(L, 1), filename, lua_tostring(L, -1));
}


static int searcher_Lua (lua_State *L) {
  const char *filename;
  const char *name = luaL_checkstring(L, 1);
  filename = findfile(L, name, "path", LUA_LSUBSEP);
  if (filename == NULL) return 1;  /* module not found in this path */
  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);
}


/*
** Try to find a load function for module 'modname' at file 'filename'.
** First, change '.' to '_' in 'modname'; then, if 'modname' has
** the form X-Y (that is, it has an "ignore mark"), build a function
** name "luaopen_X" and look for it. (For compatibility, if that
** fails, it also tries "luaopen_Y".) If there is no ignore mark,
** look for a function named "luaopen_modname".
*/
static int loadfunc (lua_State *L, const char *filename, const char *modname) {
  const char *openfunc;
  const char *mark;
  modname = luaL_gsub(L, modname, ".", LUA_OFSEP);
  mark = strchr(modname, *LUA_IGMARK);
  if (mark) {
    int stat;
    openfunc = lua_pushlstring(L, modname, mark - modname);
    openfunc = lua_pushfstring(L, LUA_POF"%s", openfunc);
    stat = lookforfunc(L, filename, openfunc);
    if (stat != ERRFUNC) return stat;
    modname = mark + 1;  /* else go ahead and try old-style name */
  }
  openfunc = lua_pushfstring(L, LUA_POF"%s", modname);
  return lookforfunc(L, filename, openfunc);
}


static int searcher_C (lua_State *L) {
  const char *name = luaL_checkstring(L, 1);
  const char *filename = findfile(L, name, "cpath", LUA_CSUBSEP);
  if (filename == NULL) return 1;  /* module not found in this path */
  return checkload(L, (loadfunc(L, filename, name) == 0), filename);
}


static int searcher_Croot (lua_State *L) {
  const char *filename;
  const char *name = luaL_checkstring(L, 1);
  const char *p = strchr(name, '.');
  int stat;
  if (p == NULL) return 0;  /* is root */
  lua_pushlstring(L, name, p - name);
  filename = findfile(L, lua_tostring(L, -1), "cpath", LUA_CSUBSEP);
  if (filename == NULL) return 1;  /* root not found */
  if ((stat = loadfunc(L, filename, name)) != 0) {
    if (stat != ERRFUNC)
      return checkload(L, 0, filename);  /* real error */
    else {  /* open function not found */
      lua_pushfstring(L, "\n\tno module '%s' in file '%s'", name, filename);
      return 1;
    }
  }
  lua_pushstring(L, filename);  /* will be 2nd argument to module */
  return 2;
}


static int searcher_preload (lua_State *L) {
  const char *name = luaL_checkstring(L, 1);
  lua_getfield(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);
  if (lua_getfield(L, -1, name) == LUA_TNIL)  /* not found? */
    lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
  return 1;
}


static void findloader (lua_State *L, const char *name) {
  int i;
  luaL_Buffer msg;  /* to build error message */
  luaL_buffinit(L, &msg);
  /* push 'package.searchers' to index 3 in the stack */
  if (lua_getfield(L, lua_upvalueindex(1), "searchers") != LUA_TTABLE)
    luaL_error(L, "'package.searchers' must be a table");
  /*  iterate over available searchers to find a loader */
  for (i = 1; ; i++) {
    if (lua_rawgeti(L, 3, i) == LUA_TNIL) {  /* no more searchers? */
      lua_pop(L, 1);  /* remove nil */
      luaL_pushresult(&msg);  /* create error message */
      luaL_error(L, "module '%s' not found:%s", name, lua_tostring(L, -1));
    }
    lua_pushstring(L, name);
    lua_call(L, 1, 2);  /* call it */
    if (lua_isfunction(L, -2))  /* did it find a loader? */
      return;  /* module loader found */
    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */
      lua_pop(L, 1);  /* remove extra return */
      luaL_addvalue(&msg);  /* concatenate error message */
    }
    else
      lua_pop(L, 2);  /* remove both returns */
  }
}


static int ll_require (lua_State *L) {
  const char *name = luaL_checkstring(L, 1);
  lua_settop(L, 1);  /* LOADED table will be at index 2 */
  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  lua_getfield(L, 2, name);  /* LOADED[name] */
  if (lua_toboolean(L, -1))  /* is it there? */
    return 1;  /* package is already loaded */
  /* else must load package */
  lua_pop(L, 1);  /* remove 'getfield' result */
  findloader(L, name);
  lua_pushstring(L, name);  /* pass name as argument to module loader */
  lua_insert(L, -2);  /* name is 1st argument (before search data) */
  lua_call(L, 2, 1);  /* run loader to load module */
  if (!lua_isnil(L, -1))  /* non-nil return? */
    lua_setfield(L, 2, name);  /* LOADED[name] = returned value */
  if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */
    lua_pushboolean(L, 1);  /* use true as result */
    lua_pushvalue(L, -1);  /* extra copy to be returned */
    lua_setfield(L, 2, name);  /* LOADED[name] = true */
  }
  return 1;
}

/* }====================================================== */



/*
** {======================================================
** 'module' function
** =======================================================
*/
#if defined(LUA_COMPAT_MODULE)

/*
** changes the environment variable of calling function
*/
static void set_env (lua_State *L) {
  lua_Debug ar;
  if (lua_getstack(L, 1, &ar) == 0 ||
      lua_getinfo(L, "f", &ar) == 0 ||  /* get calling function */
      lua_iscfunction(L, -1))
    luaL_error(L, "'module' not called from a Lua function");
  lua_pushvalue(L, -2);  /* copy new environment table to top */
  lua_setupvalue(L, -2, 1);
  lua_pop(L, 1);  /* remove function */
}


static void dooptions (lua_State *L, int n) {
  int i;
  for (i = 2; i <= n; i++) {
    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */
      lua_pushvalue(L, i);  /* get option (a function) */
      lua_pushvalue(L, -2);  /* module */
      lua_call(L, 1, 0);
    }
  }
}


static void modinit (lua_State *L, const char *modname) {
  const char *dot;
  lua_pushvalue(L, -1);
  lua_setfield(L, -2, "_M");  /* module._M = module */
  lua_pushstring(L, modname);
  lua_setfield(L, -2, "_NAME");
  dot = strrchr(modname, '.');  /* look for last dot in module name */
  if (dot == NULL) dot = modname;
  else dot++;
  /* set _PACKAGE as package name (full module name minus last part) */
  lua_pushlstring(L, modname, dot - modname);
  lua_setfield(L, -2, "_PACKAGE");
}


static int ll_module (lua_State *L) {
  const char *modname = luaL_checkstring(L, 1);
  int lastarg = lua_gettop(L);  /* last parameter */
  luaL_pushmodule(L, modname, 1);  /* get/create module table */
  /* check whether table already has a _NAME field */
  if (lua_getfield(L, -1, "_NAME") != LUA_TNIL)
    lua_pop(L, 1);  /* table is an initialized module */
  else {  /* no; initialize it */
    lua_pop(L, 1);
    modinit(L, modname);
  }
  lua_pushvalue(L, -1);
  set_env(L);
  dooptions(L, lastarg);
  return 1;
}


static int ll_seeall (lua_State *L) {
  luaL_checktype(L, 1, LUA_TTABLE);
  if (!lua_getmetatable(L, 1)) {
    lua_createtable(L, 0, 1); /* create new metatable */
    lua_pushvalue(L, -1);
    lua_setmetatable(L, 1);
  }
  lua_pushglobaltable(L);
  lua_setfield(L, -2, "__index");  /* mt.__index = _G */
  return 0;
}

#endif
/* }====================================================== */



static const luaL_Reg pk_funcs[] = {
  {"loadlib", ll_loadlib},
  {"searchpath", ll_searchpath},
#if defined(LUA_COMPAT_MODULE)
  {"seeall", ll_seeall},
#endif
  /* placeholders */
  {"preload", NULL},
  {"cpath", NULL},
  {"path", NULL},
  {"searchers", NULL},
  {"loaded", NULL},
  {NULL, NULL}
};


static const luaL_Reg ll_funcs[] = {
#if defined(LUA_COMPAT_MODULE)
  {"module", ll_module},
#endif
  {"require", ll_require},
  {NULL, NULL}
};


static void createsearcherstable (lua_State *L) {
  static const lua_CFunction searchers[] =
    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};
  int i;
  /* create 'searchers' table */
  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);
  /* fill it with predefined searchers */
  for (i=0; searchers[i] != NULL; i++) {
    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */
    lua_pushcclosure(L, searchers[i], 1);
    lua_rawseti(L, -2, i+1);
  }
#if defined(LUA_COMPAT_LOADERS)
  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */
  lua_setfield(L, -3, "loaders");  /* put it in field 'loaders' */
#endif
  lua_setfield(L, -2, "searchers");  /* put it in field 'searchers' */
}


/*
** create table CLIBS to keep track of loaded C libraries,
** setting a finalizer to close all libraries when closing state.
*/
static void createclibstable (lua_State *L) {
  lua_newtable(L);  /* create CLIBS table */
  lua_createtable(L, 0, 1);  /* create metatable for CLIBS */
  lua_pushcfunction(L, gctm);
  lua_setfield(L, -2, "__gc");  /* set finalizer for CLIBS table */
  lua_setmetatable(L, -2);
  lua_rawsetp(L, LUA_REGISTRYINDEX, &CLIBS);  /* set CLIBS table in registry */
}


LUAMOD_API int luaopen_package (lua_State *L) {
  createclibstable(L);
  luaL_newlib(L, pk_funcs);  /* create 'package' table */
  createsearcherstable(L);
  /* set paths */
  setpath(L, "path", LUA_PATH_VAR, LUA_PATH_DEFAULT);
  setpath(L, "cpath", LUA_CPATH_VAR, LUA_CPATH_DEFAULT);
  /* store config information */
  lua_pushliteral(L, LUA_DIRSEP "\n" LUA_PATH_SEP "\n" LUA_PATH_MARK "\n"
                     LUA_EXEC_DIR "\n" LUA_IGMARK "\n");
  lua_setfield(L, -2, "config");
  /* set field 'loaded' */
  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  lua_setfield(L, -2, "loaded");
  /* set field 'preload' */
  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);
  lua_setfield(L, -2, "preload");
  lua_pushglobaltable(L);
  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */
  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */
  lua_pop(L, 1);  /* pop global table */
  return 1;  /* return 'package' table */
}


```

`src/Lua/lobject.c`:

```c
/*
** $Id: lobject.c,v 2.113 2016/12/22 13:08:50 roberto Exp $
** Some generic functions over Lua objects
** See Copyright Notice in lua.h
*/

#define lobject_c
#define LUA_CORE

#include "lprefix.h"


#include <locale.h>
#include <math.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "lctype.h"
#include "ldebug.h"
#include "ldo.h"
#include "lmem.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "lvm.h"



LUAI_DDEF const TValue luaO_nilobject_ = {NILCONSTANT};


/*
** converts an integer to a "floating point byte", represented as
** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
** eeeee != 0 and (xxx) otherwise.
*/
int luaO_int2fb (unsigned int x) {
  int e = 0;  /* exponent */
  if (x < 8) return x;
  while (x >= (8 << 4)) {  /* coarse steps */
    x = (x + 0xf) >> 4;  /* x = ceil(x / 16) */
    e += 4;
  }
  while (x >= (8 << 1)) {  /* fine steps */
    x = (x + 1) >> 1;  /* x = ceil(x / 2) */
    e++;
  }
  return ((e+1) << 3) | (cast_int(x) - 8);
}


/* converts back */
int luaO_fb2int (int x) {
  return (x < 8) ? x : ((x & 7) + 8) << ((x >> 3) - 1);
}


/*
** Computes ceil(log2(x))
*/
int luaO_ceillog2 (unsigned int x) {
  static const lu_byte log_2[256] = {  /* log_2[i] = ceil(log2(i - 1)) */
    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
  };
  int l = 0;
  x--;
  while (x >= 256) { l += 8; x >>= 8; }
  return l + log_2[x];
}


static lua_Integer intarith (lua_State *L, int op, lua_Integer v1,
                                                   lua_Integer v2) {
  switch (op) {
    case LUA_OPADD: return intop(+, v1, v2);
    case LUA_OPSUB:return intop(-, v1, v2);
    case LUA_OPMUL:return intop(*, v1, v2);
    case LUA_OPMOD: return luaV_mod(L, v1, v2);
    case LUA_OPIDIV: return luaV_div(L, v1, v2);
    case LUA_OPBAND: return intop(&, v1, v2);
    case LUA_OPBOR: return intop(|, v1, v2);
    case LUA_OPBXOR: return intop(^, v1, v2);
    case LUA_OPSHL: return luaV_shiftl(v1, v2);
    case LUA_OPSHR: return luaV_shiftl(v1, -v2);
    case LUA_OPUNM: return intop(-, 0, v1);
    case LUA_OPBNOT: return intop(^, ~l_castS2U(0), v1);
    default: lua_assert(0); return 0;
  }
}


static lua_Number numarith (lua_State *L, int op, lua_Number v1,
                                                  lua_Number v2) {
  switch (op) {
    case LUA_OPADD: return luai_numadd(L, v1, v2);
    case LUA_OPSUB: return luai_numsub(L, v1, v2);
    case LUA_OPMUL: return luai_nummul(L, v1, v2);
    case LUA_OPDIV: return luai_numdiv(L, v1, v2);
    case LUA_OPPOW: return luai_numpow(L, v1, v2);
    case LUA_OPIDIV: return luai_numidiv(L, v1, v2);
    case LUA_OPUNM: return luai_numunm(L, v1);
    case LUA_OPMOD: {
      lua_Number m;
      luai_nummod(L, v1, v2, m);
      return m;
    }
    default: lua_assert(0); return 0;
  }
}


void luaO_arith (lua_State *L, int op, const TValue *p1, const TValue *p2,
                 TValue *res) {
  switch (op) {
    case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:
    case LUA_OPSHL: case LUA_OPSHR:
    case LUA_OPBNOT: {  /* operate only on integers */
      lua_Integer i1; lua_Integer i2;
      if (tointeger(p1, &i1) && tointeger(p2, &i2)) {
        setivalue(res, intarith(L, op, i1, i2));
        return;
      }
      else break;  /* go to the end */
    }
    case LUA_OPDIV: case LUA_OPPOW: {  /* operate only on floats */
      lua_Number n1; lua_Number n2;
      if (tonumber(p1, &n1) && tonumber(p2, &n2)) {
        setfltvalue(res, numarith(L, op, n1, n2));
        return;
      }
      else break;  /* go to the end */
    }
    default: {  /* other operations */
      lua_Number n1; lua_Number n2;
      if (ttisinteger(p1) && ttisinteger(p2)) {
        setivalue(res, intarith(L, op, ivalue(p1), ivalue(p2)));
        return;
      }
      else if (tonumber(p1, &n1) && tonumber(p2, &n2)) {
        setfltvalue(res, numarith(L, op, n1, n2));
        return;
      }
      else break;  /* go to the end */
    }
  }
  /* could not perform raw operation; try metamethod */
  lua_assert(L != NULL);  /* should not fail when folding (compile time) */
  luaT_trybinTM(L, p1, p2, res, cast(TMS, (op - LUA_OPADD) + TM_ADD));
}


int luaO_hexavalue (int c) {
  if (lisdigit(c)) return c - '0';
  else return (ltolower(c) - 'a') + 10;
}


static int isneg (const char **s) {
  if (**s == '-') { (*s)++; return 1; }
  else if (**s == '+') (*s)++;
  return 0;
}



/*
** {==================================================================
** Lua's implementation for 'lua_strx2number'
** ===================================================================
*/

#if !defined(lua_strx2number)

/* maximum number of significant digits to read (to avoid overflows
   even with single floats) */
#define MAXSIGDIG	30

/*
** convert an hexadecimal numeric string to a number, following
** C99 specification for 'strtod'
*/
static lua_Number lua_strx2number (const char *s, char **endptr) {
  int dot = lua_getlocaledecpoint();
  lua_Number r = 0.0;  /* result (accumulator) */
  int sigdig = 0;  /* number of significant digits */
  int nosigdig = 0;  /* number of non-significant digits */
  int e = 0;  /* exponent correction */
  int neg;  /* 1 if number is negative */
  int hasdot = 0;  /* true after seen a dot */
  *endptr = cast(char *, s);  /* nothing is valid yet */
  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
  neg = isneg(&s);  /* check signal */
  if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */
    return 0.0;  /* invalid format (no '0x') */
  for (s += 2; ; s++) {  /* skip '0x' and read numeral */
    if (*s == dot) {
      if (hasdot) break;  /* second dot? stop loop */
      else hasdot = 1;
    }
    else if (lisxdigit(cast_uchar(*s))) {
      if (sigdig == 0 && *s == '0')  /* non-significant digit (zero)? */
        nosigdig++;
      else if (++sigdig <= MAXSIGDIG)  /* can read it without overflow? */
          r = (r * cast_num(16.0)) + luaO_hexavalue(*s);
      else e++; /* too many digits; ignore, but still count for exponent */
      if (hasdot) e--;  /* decimal digit? correct exponent */
    }
    else break;  /* neither a dot nor a digit */
  }
  if (nosigdig + sigdig == 0)  /* no digits? */
    return 0.0;  /* invalid format */
  *endptr = cast(char *, s);  /* valid up to here */
  e *= 4;  /* each digit multiplies/divides value by 2^4 */
  if (*s == 'p' || *s == 'P') {  /* exponent part? */
    int exp1 = 0;  /* exponent value */
    int neg1;  /* exponent signal */
    s++;  /* skip 'p' */
    neg1 = isneg(&s);  /* signal */
    if (!lisdigit(cast_uchar(*s)))
      return 0.0;  /* invalid; must have at least one digit */
    while (lisdigit(cast_uchar(*s)))  /* read exponent */
      exp1 = exp1 * 10 + *(s++) - '0';
    if (neg1) exp1 = -exp1;
    e += exp1;
    *endptr = cast(char *, s);  /* valid up to here */
  }
  if (neg) r = -r;
  return l_mathop(ldexp)(r, e);
}

#endif
/* }====================================================== */


/* maximum length of a numeral */
#if !defined (L_MAXLENNUM)
#define L_MAXLENNUM	200
#endif

static const char *l_str2dloc (const char *s, lua_Number *result, int mode) {
  char *endptr;
  *result = (mode == 'x') ? lua_strx2number(s, &endptr)  /* try to convert */
                          : lua_str2number(s, &endptr);
  if (endptr == s) return NULL;  /* nothing recognized? */
  while (lisspace(cast_uchar(*endptr))) endptr++;  /* skip trailing spaces */
  return (*endptr == '\0') ? endptr : NULL;  /* OK if no trailing characters */
}


/*
** Convert string 's' to a Lua number (put in 'result'). Return NULL
** on fail or the address of the ending '\0' on success.
** 'pmode' points to (and 'mode' contains) special things in the string:
** - 'x'/'X' means an hexadecimal numeral
** - 'n'/'N' means 'inf' or 'nan' (which should be rejected)
** - '.' just optimizes the search for the common case (nothing special)
** This function accepts both the current locale or a dot as the radix
** mark. If the convertion fails, it may mean number has a dot but
** locale accepts something else. In that case, the code copies 's'
** to a buffer (because 's' is read-only), changes the dot to the
** current locale radix mark, and tries to convert again.
*/
static const char *l_str2d (const char *s, lua_Number *result) {
  const char *endptr;
  const char *pmode = strpbrk(s, ".xXnN");
  int mode = pmode ? ltolower(cast_uchar(*pmode)) : 0;
  if (mode == 'n')  /* reject 'inf' and 'nan' */
    return NULL;
  endptr = l_str2dloc(s, result, mode);  /* try to convert */
  if (endptr == NULL) {  /* failed? may be a different locale */
    char buff[L_MAXLENNUM + 1];
    const char *pdot = strchr(s, '.');
    if (strlen(s) > L_MAXLENNUM || pdot == NULL)
      return NULL;  /* string too long or no dot; fail */
    strcpy(buff, s);  /* copy string to buffer */
    buff[pdot - s] = lua_getlocaledecpoint();  /* correct decimal point */
    endptr = l_str2dloc(buff, result, mode);  /* try again */
    if (endptr != NULL)
      endptr = s + (endptr - buff);  /* make relative to 's' */
  }
  return endptr;
}


#define MAXBY10		cast(lua_Unsigned, LUA_MAXINTEGER / 10)
#define MAXLASTD	cast_int(LUA_MAXINTEGER % 10)

static const char *l_str2int (const char *s, lua_Integer *result) {
  lua_Unsigned a = 0;
  int empty = 1;
  int neg;
  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
  neg = isneg(&s);
  if (s[0] == '0' &&
      (s[1] == 'x' || s[1] == 'X')) {  /* hex? */
    s += 2;  /* skip '0x' */
    for (; lisxdigit(cast_uchar(*s)); s++) {
      a = a * 16 + luaO_hexavalue(*s);
      empty = 0;
    }
  }
  else {  /* decimal */
    for (; lisdigit(cast_uchar(*s)); s++) {
      int d = *s - '0';
      if (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))  /* overflow? */
        return NULL;  /* do not accept it (as integer) */
      a = a * 10 + d;
      empty = 0;
    }
  }
  while (lisspace(cast_uchar(*s))) s++;  /* skip trailing spaces */
  if (empty || *s != '\0') return NULL;  /* something wrong in the numeral */
  else {
    *result = l_castU2S((neg) ? 0u - a : a);
    return s;
  }
}


size_t luaO_str2num (const char *s, TValue *o) {
  lua_Integer i; lua_Number n;
  const char *e;
  if ((e = l_str2int(s, &i)) != NULL) {  /* try as an integer */
    setivalue(o, i);
  }
  else if ((e = l_str2d(s, &n)) != NULL) {  /* else try as a float */
    setfltvalue(o, n);
  }
  else
    return 0;  /* conversion failed */
  return (e - s) + 1;  /* success; return string size */
}


int luaO_utf8esc (char *buff, unsigned long x) {
  int n = 1;  /* number of bytes put in buffer (backwards) */
  lua_assert(x <= 0x10FFFF);
  if (x < 0x80)  /* ascii? */
    buff[UTF8BUFFSZ - 1] = cast(char, x);
  else {  /* need continuation bytes */
    unsigned int mfb = 0x3f;  /* maximum that fits in first byte */
    do {  /* add continuation bytes */
      buff[UTF8BUFFSZ - (n++)] = cast(char, 0x80 | (x & 0x3f));
      x >>= 6;  /* remove added bits */
      mfb >>= 1;  /* now there is one less bit available in first byte */
    } while (x > mfb);  /* still needs continuation byte? */
    buff[UTF8BUFFSZ - n] = cast(char, (~mfb << 1) | x);  /* add first byte */
  }
  return n;
}


/* maximum length of the conversion of a number to a string */
#define MAXNUMBER2STR	50


/*
** Convert a number object to a string
*/
void luaO_tostring (lua_State *L, StkId obj) {
  char buff[MAXNUMBER2STR];
  size_t len;
  lua_assert(ttisnumber(obj));
  if (ttisinteger(obj))
    len = lua_integer2str(buff, sizeof(buff), ivalue(obj));
  else {
    len = lua_number2str(buff, sizeof(buff), fltvalue(obj));
#if !defined(LUA_COMPAT_FLOATSTRING)
    if (buff[strspn(buff, "-0123456789")] == '\0') {  /* looks like an int? */
      buff[len++] = lua_getlocaledecpoint();
      buff[len++] = '0';  /* adds '.0' to result */
    }
#endif
  }
  setsvalue2s(L, obj, luaS_newlstr(L, buff, len));
}


static void pushstr (lua_State *L, const char *str, size_t l) {
  setsvalue2s(L, L->top, luaS_newlstr(L, str, l));
  luaD_inctop(L);
}


/*
** this function handles only '%d', '%c', '%f', '%p', and '%s'
   conventional formats, plus Lua-specific '%I' and '%U'
*/
const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
  int n = 0;
  for (;;) {
    const char *e = strchr(fmt, '%');
    if (e == NULL) break;
    pushstr(L, fmt, e - fmt);
    switch (*(e+1)) {
      case 's': {  /* zero-terminated string */
        const char *s = va_arg(argp, char *);
        if (s == NULL) s = "(null)";
        pushstr(L, s, strlen(s));
        break;
      }
      case 'c': {  /* an 'int' as a character */
        char buff = cast(char, va_arg(argp, int));
        if (lisprint(cast_uchar(buff)))
          pushstr(L, &buff, 1);
        else  /* non-printable character; print its code */
          luaO_pushfstring(L, "<\\%d>", cast_uchar(buff));
        break;
      }
      case 'd': {  /* an 'int' */
        setivalue(L->top, va_arg(argp, int));
        goto top2str;
      }
      case 'I': {  /* a 'lua_Integer' */
        setivalue(L->top, cast(lua_Integer, va_arg(argp, l_uacInt)));
        goto top2str;
      }
      case 'f': {  /* a 'lua_Number' */
        setfltvalue(L->top, cast_num(va_arg(argp, l_uacNumber)));
      top2str:  /* convert the top element to a string */
        luaD_inctop(L);
        luaO_tostring(L, L->top - 1);
        break;
      }
      case 'p': {  /* a pointer */
        char buff[4*sizeof(void *) + 8]; /* should be enough space for a '%p' */
        int l = l_sprintf(buff, sizeof(buff), "%p", va_arg(argp, void *));
        pushstr(L, buff, l);
        break;
      }
      case 'U': {  /* an 'int' as a UTF-8 sequence */
        char buff[UTF8BUFFSZ];
        int l = luaO_utf8esc(buff, cast(long, va_arg(argp, long)));
        pushstr(L, buff + UTF8BUFFSZ - l, l);
        break;
      }
      case '%': {
        pushstr(L, "%", 1);
        break;
      }
      default: {
        luaG_runerror(L, "invalid option '%%%c' to 'lua_pushfstring'",
                         *(e + 1));
      }
    }
    n += 2;
    fmt = e+2;
  }
  luaD_checkstack(L, 1);
  pushstr(L, fmt, strlen(fmt));
  if (n > 0) luaV_concat(L, n + 1);
  return svalue(L->top - 1);
}


const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
  const char *msg;
  va_list argp;
  va_start(argp, fmt);
  msg = luaO_pushvfstring(L, fmt, argp);
  va_end(argp);
  return msg;
}


/* number of chars of a literal string without the ending \0 */
#define LL(x)	(sizeof(x)/sizeof(char) - 1)

#define RETS	"..."
#define PRE	"[string \""
#define POS	"\"]"

#define addstr(a,b,l)	( memcpy(a,b,(l) * sizeof(char)), a += (l) )

void luaO_chunkid (char *out, const char *source, size_t bufflen) {
  size_t l = strlen(source);
  if (*source == '=') {  /* 'literal' source */
    if (l <= bufflen)  /* small enough? */
      memcpy(out, source + 1, l * sizeof(char));
    else {  /* truncate it */
      addstr(out, source + 1, bufflen - 1);
      *out = '\0';
    }
  }
  else if (*source == '@') {  /* file name */
    if (l <= bufflen)  /* small enough? */
      memcpy(out, source + 1, l * sizeof(char));
    else {  /* add '...' before rest of name */
      addstr(out, RETS, LL(RETS));
      bufflen -= LL(RETS);
      memcpy(out, source + 1 + l - bufflen, bufflen * sizeof(char));
    }
  }
  else {  /* string; format as [string "source"] */
    const char *nl = strchr(source, '\n');  /* find first new line (if any) */
    addstr(out, PRE, LL(PRE));  /* add prefix */
    bufflen -= LL(PRE RETS POS) + 1;  /* save space for prefix+suffix+'\0' */
    if (l < bufflen && nl == NULL) {  /* small one-line source? */
      addstr(out, source, l);  /* keep it */
    }
    else {
      if (nl != NULL) l = nl - source;  /* stop at first newline */
      if (l > bufflen) l = bufflen;
      addstr(out, source, l);
      addstr(out, RETS, LL(RETS));
    }
    memcpy(out, POS, (LL(POS) + 1) * sizeof(char));
  }
}


```

`src/Lua/lobject.h`:

```h
/*
** $Id: lobject.h,v 2.117 2016/08/01 19:51:24 roberto Exp $
** Type definitions for Lua objects
** See Copyright Notice in lua.h
*/


#ifndef lobject_h
#define lobject_h


#include <stdarg.h>


#include "llimits.h"
#include "lua.h"


/*
** Extra tags for non-values
*/
#define LUA_TPROTO	LUA_NUMTAGS		/* function prototypes */
#define LUA_TDEADKEY	(LUA_NUMTAGS+1)		/* removed keys in tables */

/*
** number of all possible tags (including LUA_TNONE but excluding DEADKEY)
*/
#define LUA_TOTALTAGS	(LUA_TPROTO + 2)


/*
** tags for Tagged Values have the following use of bits:
** bits 0-3: actual tag (a LUA_T* value)
** bits 4-5: variant bits
** bit 6: whether value is collectable
*/


/*
** LUA_TFUNCTION variants:
** 0 - Lua function
** 1 - light C function
** 2 - regular C function (closure)
*/

/* Variant tags for functions */
#define LUA_TLCL	(LUA_TFUNCTION | (0 << 4))  /* Lua closure */
#define LUA_TLCF	(LUA_TFUNCTION | (1 << 4))  /* light C function */
#define LUA_TCCL	(LUA_TFUNCTION | (2 << 4))  /* C closure */


/* Variant tags for strings */
#define LUA_TSHRSTR	(LUA_TSTRING | (0 << 4))  /* short strings */
#define LUA_TLNGSTR	(LUA_TSTRING | (1 << 4))  /* long strings */


/* Variant tags for numbers */
#define LUA_TNUMFLT	(LUA_TNUMBER | (0 << 4))  /* float numbers */
#define LUA_TNUMINT	(LUA_TNUMBER | (1 << 4))  /* integer numbers */


/* Bit mark for collectable types */
#define BIT_ISCOLLECTABLE	(1 << 6)

/* mark a tag as collectable */
#define ctb(t)			((t) | BIT_ISCOLLECTABLE)


/*
** Common type for all collectable objects
*/
typedef struct GCObject GCObject;


/*
** Common Header for all collectable objects (in macro form, to be
** included in other objects)
*/
#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked


/*
** Common type has only the common header
*/
struct GCObject {
  CommonHeader;
};




/*
** Tagged Values. This is the basic representation of values in Lua,
** an actual value plus a tag with its type.
*/

/*
** Union of all Lua values
*/
typedef union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Integer i;   /* integer numbers */
  lua_Number n;    /* float numbers */
} Value;


#define TValuefields	Value value_; int tt_


typedef struct lua_TValue {
  TValuefields;
} TValue;



/* macro defining a nil value */
#define NILCONSTANT	{NULL}, LUA_TNIL


#define val_(o)		((o)->value_)


/* raw type tag of a TValue */
#define rttype(o)	((o)->tt_)

/* tag with no variants (bits 0-3) */
#define novariant(x)	((x) & 0x0F)

/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */
#define ttype(o)	(rttype(o) & 0x3F)

/* type tag of a TValue with no variants (bits 0-3) */
#define ttnov(o)	(novariant(rttype(o)))


/* Macros to test type */
#define checktag(o,t)		(rttype(o) == (t))
#define checktype(o,t)		(ttnov(o) == (t))
#define ttisnumber(o)		checktype((o), LUA_TNUMBER)
#define ttisfloat(o)		checktag((o), LUA_TNUMFLT)
#define ttisinteger(o)		checktag((o), LUA_TNUMINT)
#define ttisnil(o)		checktag((o), LUA_TNIL)
#define ttisboolean(o)		checktag((o), LUA_TBOOLEAN)
#define ttislightuserdata(o)	checktag((o), LUA_TLIGHTUSERDATA)
#define ttisstring(o)		checktype((o), LUA_TSTRING)
#define ttisshrstring(o)	checktag((o), ctb(LUA_TSHRSTR))
#define ttislngstring(o)	checktag((o), ctb(LUA_TLNGSTR))
#define ttistable(o)		checktag((o), ctb(LUA_TTABLE))
#define ttisfunction(o)		checktype(o, LUA_TFUNCTION)
#define ttisclosure(o)		((rttype(o) & 0x1F) == LUA_TFUNCTION)
#define ttisCclosure(o)		checktag((o), ctb(LUA_TCCL))
#define ttisLclosure(o)		checktag((o), ctb(LUA_TLCL))
#define ttislcf(o)		checktag((o), LUA_TLCF)
#define ttisfulluserdata(o)	checktag((o), ctb(LUA_TUSERDATA))
#define ttisthread(o)		checktag((o), ctb(LUA_TTHREAD))
#define ttisdeadkey(o)		checktag((o), LUA_TDEADKEY)


/* Macros to access values */
#define ivalue(o)	check_exp(ttisinteger(o), val_(o).i)
#define fltvalue(o)	check_exp(ttisfloat(o), val_(o).n)
#define nvalue(o)	check_exp(ttisnumber(o), \
	(ttisinteger(o) ? cast_num(ivalue(o)) : fltvalue(o)))
#define gcvalue(o)	check_exp(iscollectable(o), val_(o).gc)
#define pvalue(o)	check_exp(ttislightuserdata(o), val_(o).p)
#define tsvalue(o)	check_exp(ttisstring(o), gco2ts(val_(o).gc))
#define uvalue(o)	check_exp(ttisfulluserdata(o), gco2u(val_(o).gc))
#define clvalue(o)	check_exp(ttisclosure(o), gco2cl(val_(o).gc))
#define clLvalue(o)	check_exp(ttisLclosure(o), gco2lcl(val_(o).gc))
#define clCvalue(o)	check_exp(ttisCclosure(o), gco2ccl(val_(o).gc))
#define fvalue(o)	check_exp(ttislcf(o), val_(o).f)
#define hvalue(o)	check_exp(ttistable(o), gco2t(val_(o).gc))
#define bvalue(o)	check_exp(ttisboolean(o), val_(o).b)
#define thvalue(o)	check_exp(ttisthread(o), gco2th(val_(o).gc))
/* a dead value may get the 'gc' field, but cannot access its contents */
#define deadvalue(o)	check_exp(ttisdeadkey(o), cast(void *, val_(o).gc))

#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))


#define iscollectable(o)	(rttype(o) & BIT_ISCOLLECTABLE)


/* Macros for internal tests */
#define righttt(obj)		(ttype(obj) == gcvalue(obj)->tt)

#define checkliveness(L,obj) \
	lua_longassert(!iscollectable(obj) || \
		(righttt(obj) && (L == NULL || !isdead(G(L),gcvalue(obj)))))


/* Macros to set values */
#define settt_(o,t)	((o)->tt_=(t))

#define setfltvalue(obj,x) \
  { TValue *io=(obj); val_(io).n=(x); settt_(io, LUA_TNUMFLT); }

#define chgfltvalue(obj,x) \
  { TValue *io=(obj); lua_assert(ttisfloat(io)); val_(io).n=(x); }

#define setivalue(obj,x) \
  { TValue *io=(obj); val_(io).i=(x); settt_(io, LUA_TNUMINT); }

#define chgivalue(obj,x) \
  { TValue *io=(obj); lua_assert(ttisinteger(io)); val_(io).i=(x); }

#define setnilvalue(obj) settt_(obj, LUA_TNIL)

#define setfvalue(obj,x) \
  { TValue *io=(obj); val_(io).f=(x); settt_(io, LUA_TLCF); }

#define setpvalue(obj,x) \
  { TValue *io=(obj); val_(io).p=(x); settt_(io, LUA_TLIGHTUSERDATA); }

#define setbvalue(obj,x) \
  { TValue *io=(obj); val_(io).b=(x); settt_(io, LUA_TBOOLEAN); }

#define setgcovalue(L,obj,x) \
  { TValue *io = (obj); GCObject *i_g=(x); \
    val_(io).gc = i_g; settt_(io, ctb(i_g->tt)); }

#define setsvalue(L,obj,x) \
  { TValue *io = (obj); TString *x_ = (x); \
    val_(io).gc = obj2gco(x_); settt_(io, ctb(x_->tt)); \
    checkliveness(L,io); }

#define setuvalue(L,obj,x) \
  { TValue *io = (obj); Udata *x_ = (x); \
    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TUSERDATA)); \
    checkliveness(L,io); }

#define setthvalue(L,obj,x) \
  { TValue *io = (obj); lua_State *x_ = (x); \
    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TTHREAD)); \
    checkliveness(L,io); }

#define setclLvalue(L,obj,x) \
  { TValue *io = (obj); LClosure *x_ = (x); \
    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TLCL)); \
    checkliveness(L,io); }

#define setclCvalue(L,obj,x) \
  { TValue *io = (obj); CClosure *x_ = (x); \
    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TCCL)); \
    checkliveness(L,io); }

#define sethvalue(L,obj,x) \
  { TValue *io = (obj); Table *x_ = (x); \
    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_TTABLE)); \
    checkliveness(L,io); }

#define setdeadvalue(obj)	settt_(obj, LUA_TDEADKEY)



#define setobj(L,obj1,obj2) \
	{ TValue *io1=(obj1); *io1 = *(obj2); \
	  (void)L; checkliveness(L,io1); }


/*
** different types of assignments, according to destination
*/

/* from stack to (same) stack */
#define setobjs2s	setobj
/* to stack (not from same stack) */
#define setobj2s	setobj
#define setsvalue2s	setsvalue
#define sethvalue2s	sethvalue
#define setptvalue2s	setptvalue
/* from table to same table */
#define setobjt2t	setobj
/* to new object */
#define setobj2n	setobj
#define setsvalue2n	setsvalue

/* to table (define it as an expression to be used in macros) */
#define setobj2t(L,o1,o2)  ((void)L, *(o1)=*(o2), checkliveness(L,(o1)))




/*
** {======================================================
** types and prototypes
** =======================================================
*/


typedef TValue *StkId;  /* index to stack elements */




/*
** Header for string value; string bytes follow the end of this structure
** (aligned according to 'UTString'; see next).
*/
typedef struct TString {
  CommonHeader;
  lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
  lu_byte shrlen;  /* length for short strings */
  unsigned int hash;
  union {
    size_t lnglen;  /* length for long strings */
    struct TString *hnext;  /* linked list for hash table */
  } u;
} TString;


/*
** Ensures that address after this type is always fully aligned.
*/
typedef union UTString {
  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
  TString tsv;
} UTString;


/*
** Get the actual string (array of bytes) from a 'TString'.
** (Access to 'extra' ensures that value is really a 'TString'.)
*/
#define getstr(ts)  \
  check_exp(sizeof((ts)->extra), cast(char *, (ts)) + sizeof(UTString))


/* get the actual string (array of bytes) from a Lua value */
#define svalue(o)       getstr(tsvalue(o))

/* get string length from 'TString *s' */
#define tsslen(s)	((s)->tt == LUA_TSHRSTR ? (s)->shrlen : (s)->u.lnglen)

/* get string length from 'TValue *o' */
#define vslen(o)	tsslen(tsvalue(o))


/*
** Header for userdata; memory area follows the end of this structure
** (aligned according to 'UUdata'; see next).
*/
typedef struct Udata {
  CommonHeader;
  lu_byte ttuv_;  /* user value's tag */
  struct Table *metatable;
  size_t len;  /* number of bytes */
  union Value user_;  /* user value */
} Udata;


/*
** Ensures that address after this type is always fully aligned.
*/
typedef union UUdata {
  L_Umaxalign dummy;  /* ensures maximum alignment for 'local' udata */
  Udata uv;
} UUdata;


/*
**  Get the address of memory block inside 'Udata'.
** (Access to 'ttuv_' ensures that value is really a 'Udata'.)
*/
#define getudatamem(u)  \
  check_exp(sizeof((u)->ttuv_), (cast(char*, (u)) + sizeof(UUdata)))

#define setuservalue(L,u,o) \
	{ const TValue *io=(o); Udata *iu = (u); \
	  iu->user_ = io->value_; iu->ttuv_ = rttype(io); \
	  checkliveness(L,io); }


#define getuservalue(L,u,o) \
	{ TValue *io=(o); const Udata *iu = (u); \
	  io->value_ = iu->user_; settt_(io, iu->ttuv_); \
	  checkliveness(L,io); }


/*
** Description of an upvalue for function prototypes
*/
typedef struct Upvaldesc {
  TString *name;  /* upvalue name (for debug information) */
  lu_byte instack;  /* whether it is in stack (register) */
  lu_byte idx;  /* index of upvalue (in stack or in outer function's list) */
} Upvaldesc;


/*
** Description of a local variable for function prototypes
** (used for debug information)
*/
typedef struct LocVar {
  TString *varname;
  int startpc;  /* first point where variable is active */
  int endpc;    /* first point where variable is dead */
} LocVar;


/*
** Function Prototypes
*/
typedef struct Proto {
  CommonHeader;
  lu_byte numparams;  /* number of fixed parameters */
  lu_byte is_vararg;
  lu_byte maxstacksize;  /* number of registers needed by this function */
  int sizeupvalues;  /* size of 'upvalues' */
  int sizek;  /* size of 'k' */
  int sizecode;
  int sizelineinfo;
  int sizep;  /* size of 'p' */
  int sizelocvars;
  int linedefined;  /* debug information  */
  int lastlinedefined;  /* debug information  */
  TValue *k;  /* constants used by the function */
  Instruction *code;  /* opcodes */
  struct Proto **p;  /* functions defined inside the function */
  int *lineinfo;  /* map from opcodes to source lines (debug information) */
  LocVar *locvars;  /* information about local variables (debug information) */
  Upvaldesc *upvalues;  /* upvalue information */
  struct LClosure *cache;  /* last-created closure with this prototype */
  TString  *source;  /* used for debug information */
  GCObject *gclist;
} Proto;



/*
** Lua Upvalues
*/
typedef struct UpVal UpVal;


/*
** Closures
*/

#define ClosureHeader \
	CommonHeader; lu_byte nupvalues; GCObject *gclist

typedef struct CClosure {
  ClosureHeader;
  lua_CFunction f;
  TValue upvalue[1];  /* list of upvalues */
} CClosure;


typedef struct LClosure {
  ClosureHeader;
  struct Proto *p;
  UpVal *upvals[1];  /* list of upvalues */
} LClosure;


typedef union Closure {
  CClosure c;
  LClosure l;
} Closure;


#define isLfunction(o)	ttisLclosure(o)

#define getproto(o)	(clLvalue(o)->p)


/*
** Tables
*/

typedef union TKey {
  struct {
    TValuefields;
    int next;  /* for chaining (offset for next node) */
  } nk;
  TValue tvk;
} TKey;


/* copy a value into a key without messing up field 'next' */
#define setnodekey(L,key,obj) \
	{ TKey *k_=(key); const TValue *io_=(obj); \
	  k_->nk.value_ = io_->value_; k_->nk.tt_ = io_->tt_; \
	  (void)L; checkliveness(L,io_); }


typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
  lu_byte lsizenode;  /* log2 of size of 'node' array */
  unsigned int sizearray;  /* size of 'array' array */
  TValue *array;  /* array part */
  Node *node;
  Node *lastfree;  /* any free position is before this position */
  struct Table *metatable;
  GCObject *gclist;
} Table;



/*
** 'module' operation for hashing (size is always a power of 2)
*/
#define lmod(s,size) \
	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))


#define twoto(x)	(1<<(x))
#define sizenode(t)	(twoto((t)->lsizenode))


/*
** (address of) a fixed nil value
*/
#define luaO_nilobject		(&luaO_nilobject_)


LUAI_DDEC const TValue luaO_nilobject_;

/* size of buffer for 'luaO_utf8esc' function */
#define UTF8BUFFSZ	8

LUAI_FUNC int luaO_int2fb (unsigned int x);
LUAI_FUNC int luaO_fb2int (int x);
LUAI_FUNC int luaO_utf8esc (char *buff, unsigned long x);
LUAI_FUNC int luaO_ceillog2 (unsigned int x);
LUAI_FUNC void luaO_arith (lua_State *L, int op, const TValue *p1,
                           const TValue *p2, TValue *res);
LUAI_FUNC size_t luaO_str2num (const char *s, TValue *o);
LUAI_FUNC int luaO_hexavalue (int c);
LUAI_FUNC void luaO_tostring (lua_State *L, StkId obj);
LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
                                                       va_list argp);
LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
LUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);


#endif


```

`src/Lua/lopcodes.c`:

```c
/*
** $Id: lopcodes.c,v 1.55 2015/01/05 13:48:33 roberto Exp $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/

#define lopcodes_c
#define LUA_CORE

#include "lprefix.h"


#include <stddef.h>

#include "lopcodes.h"


/* ORDER OP */

LUAI_DDEF const char *const luaP_opnames[NUM_OPCODES+1] = {
  "MOVE",
  "LOADK",
  "LOADKX",
  "LOADBOOL",
  "LOADNIL",
  "GETUPVAL",
  "GETTABUP",
  "GETTABLE",
  "SETTABUP",
  "SETUPVAL",
  "SETTABLE",
  "NEWTABLE",
  "SELF",
  "ADD",
  "SUB",
  "MUL",
  "MOD",
  "POW",
  "DIV",
  "IDIV",
  "BAND",
  "BOR",
  "BXOR",
  "SHL",
  "SHR",
  "UNM",
  "BNOT",
  "NOT",
  "LEN",
  "CONCAT",
  "JMP",
  "EQ",
  "LT",
  "LE",
  "TEST",
  "TESTSET",
  "CALL",
  "TAILCALL",
  "RETURN",
  "FORLOOP",
  "FORPREP",
  "TFORCALL",
  "TFORLOOP",
  "SETLIST",
  "CLOSURE",
  "VARARG",
  "EXTRAARG",
  NULL
};


#define opmode(t,a,b,c,m) (((t)<<7) | ((a)<<6) | ((b)<<4) | ((c)<<2) | (m))

LUAI_DDEF const lu_byte luaP_opmodes[NUM_OPCODES] = {
/*       T  A    B       C     mode		   opcode	*/
  opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_MOVE */
 ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_LOADK */
 ,opmode(0, 1, OpArgN, OpArgN, iABx)		/* OP_LOADKX */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_LOADBOOL */
 ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_LOADNIL */
 ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_GETUPVAL */
 ,opmode(0, 1, OpArgU, OpArgK, iABC)		/* OP_GETTABUP */
 ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_GETTABLE */
 ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABUP */
 ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_SETUPVAL */
 ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABLE */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_NEWTABLE */
 ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_SELF */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_IDIV */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BAND */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BOR */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_BXOR */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SHL */
 ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SHR */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_BNOT */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
 ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
 ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
 ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_JMP */
 ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_EQ */
 ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LT */
 ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LE */
 ,opmode(1, 0, OpArgN, OpArgU, iABC)		/* OP_TEST */
 ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TESTSET */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_CALL */
 ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_TAILCALL */
 ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_RETURN */
 ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORLOOP */
 ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORPREP */
 ,opmode(0, 0, OpArgN, OpArgU, iABC)		/* OP_TFORCALL */
 ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_TFORLOOP */
 ,opmode(0, 0, OpArgU, OpArgU, iABC)		/* OP_SETLIST */
 ,opmode(0, 1, OpArgU, OpArgN, iABx)		/* OP_CLOSURE */
 ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_VARARG */
 ,opmode(0, 0, OpArgU, OpArgU, iAx)		/* OP_EXTRAARG */
};


```

`src/Lua/lopcodes.h`:

```h
/*
** $Id: lopcodes.h,v 1.149 2016/07/19 17:12:21 roberto Exp $
** Opcodes for Lua virtual machine
** See Copyright Notice in lua.h
*/

#ifndef lopcodes_h
#define lopcodes_h

#include "llimits.h"


/*===========================================================================
  We assume that instructions are unsigned numbers.
  All instructions have an opcode in the first 6 bits.
  Instructions can have the following fields:
	'A' : 8 bits
	'B' : 9 bits
	'C' : 9 bits
	'Ax' : 26 bits ('A', 'B', and 'C' together)
	'Bx' : 18 bits ('B' and 'C' together)
	'sBx' : signed Bx

  A signed argument is represented in excess K; that is, the number
  value is the unsigned value minus K. K is exactly the maximum value
  for that argument (so that -max is represented by 0, and +max is
  represented by 2*max), which is half the maximum for the corresponding
  unsigned argument.
===========================================================================*/


enum OpMode {iABC, iABx, iAsBx, iAx};  /* basic instruction format */


/*
** size and position of opcode arguments.
*/
#define SIZE_C		9
#define SIZE_B		9
#define SIZE_Bx		(SIZE_C + SIZE_B)
#define SIZE_A		8
#define SIZE_Ax		(SIZE_C + SIZE_B + SIZE_A)

#define SIZE_OP		6

#define POS_OP		0
#define POS_A		(POS_OP + SIZE_OP)
#define POS_C		(POS_A + SIZE_A)
#define POS_B		(POS_C + SIZE_C)
#define POS_Bx		POS_C
#define POS_Ax		POS_A


/*
** limits for opcode arguments.
** we use (signed) int to manipulate most arguments,
** so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
*/
#if SIZE_Bx < LUAI_BITSINT-1
#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
#define MAXARG_sBx        (MAXARG_Bx>>1)         /* 'sBx' is signed */
#else
#define MAXARG_Bx        MAX_INT
#define MAXARG_sBx        MAX_INT
#endif

#if SIZE_Ax < LUAI_BITSINT-1
#define MAXARG_Ax	((1<<SIZE_Ax)-1)
#else
#define MAXARG_Ax	MAX_INT
#endif


#define MAXARG_A        ((1<<SIZE_A)-1)
#define MAXARG_B        ((1<<SIZE_B)-1)
#define MAXARG_C        ((1<<SIZE_C)-1)


/* creates a mask with 'n' 1 bits at position 'p' */
#define MASK1(n,p)	((~((~(Instruction)0)<<(n)))<<(p))

/* creates a mask with 'n' 0 bits at position 'p' */
#define MASK0(n,p)	(~MASK1(n,p))

/*
** the following macros help to manipulate instructions
*/

#define GET_OPCODE(i)	(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
		((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))

#define getarg(i,pos,size)	(cast(int, ((i)>>pos) & MASK1(size,0)))
#define setarg(i,v,pos,size)	((i) = (((i)&MASK0(size,pos)) | \
                ((cast(Instruction, v)<<pos)&MASK1(size,pos))))

#define GETARG_A(i)	getarg(i, POS_A, SIZE_A)
#define SETARG_A(i,v)	setarg(i, v, POS_A, SIZE_A)

#define GETARG_B(i)	getarg(i, POS_B, SIZE_B)
#define SETARG_B(i,v)	setarg(i, v, POS_B, SIZE_B)

#define GETARG_C(i)	getarg(i, POS_C, SIZE_C)
#define SETARG_C(i,v)	setarg(i, v, POS_C, SIZE_C)

#define GETARG_Bx(i)	getarg(i, POS_Bx, SIZE_Bx)
#define SETARG_Bx(i,v)	setarg(i, v, POS_Bx, SIZE_Bx)

#define GETARG_Ax(i)	getarg(i, POS_Ax, SIZE_Ax)
#define SETARG_Ax(i,v)	setarg(i, v, POS_Ax, SIZE_Ax)

#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))


#define CREATE_ABC(o,a,b,c)	((cast(Instruction, o)<<POS_OP) \
			| (cast(Instruction, a)<<POS_A) \
			| (cast(Instruction, b)<<POS_B) \
			| (cast(Instruction, c)<<POS_C))

#define CREATE_ABx(o,a,bc)	((cast(Instruction, o)<<POS_OP) \
			| (cast(Instruction, a)<<POS_A) \
			| (cast(Instruction, bc)<<POS_Bx))

#define CREATE_Ax(o,a)		((cast(Instruction, o)<<POS_OP) \
			| (cast(Instruction, a)<<POS_Ax))


/*
** Macros to operate RK indices
*/

/* this bit 1 means constant (0 means register) */
#define BITRK		(1 << (SIZE_B - 1))

/* test whether value is a constant */
#define ISK(x)		((x) & BITRK)

/* gets the index of the constant */
#define INDEXK(r)	((int)(r) & ~BITRK)

#if !defined(MAXINDEXRK)  /* (for debugging only) */
#define MAXINDEXRK	(BITRK - 1)
#endif

/* code a constant index as a RK value */
#define RKASK(x)	((x) | BITRK)


/*
** invalid register that fits in 8 bits
*/
#define NO_REG		MAXARG_A


/*
** R(x) - register
** Kst(x) - constant (in constant table)
** RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
*/


/*
** grep "ORDER OP" if you change these enums
*/

typedef enum {
/*----------------------------------------------------------------------
name		args	description
------------------------------------------------------------------------*/
OP_MOVE,/*	A B	R(A) := R(B)					*/
OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
OP_LOADKX,/*	A 	R(A) := Kst(extra arg)				*/
OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) pc++			*/
OP_LOADNIL,/*	A B	R(A), R(A+1), ..., R(A+B) := nil		*/
OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/

OP_GETTABUP,/*	A B C	R(A) := UpValue[B][RK(C)]			*/
OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/

OP_SETTABUP,/*	A B C	UpValue[A][RK(B)] := RK(C)			*/
OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/

OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/

OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/

OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
OP_IDIV,/*	A B C	R(A) := RK(B) // RK(C)				*/
OP_BAND,/*	A B C	R(A) := RK(B) & RK(C)				*/
OP_BOR,/*	A B C	R(A) := RK(B) | RK(C)				*/
OP_BXOR,/*	A B C	R(A) := RK(B) ~ RK(C)				*/
OP_SHL,/*	A B C	R(A) := RK(B) << RK(C)				*/
OP_SHR,/*	A B C	R(A) := RK(B) >> RK(C)				*/
OP_UNM,/*	A B	R(A) := -R(B)					*/
OP_BNOT,/*	A B	R(A) := ~R(B)					*/
OP_NOT,/*	A B	R(A) := not R(B)				*/
OP_LEN,/*	A B	R(A) := length of R(B)				*/

OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/

OP_JMP,/*	A sBx	pc+=sBx; if (A) close all upvalues >= R(A - 1)	*/
OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++		*/
OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++		*/

OP_TEST,/*	A C	if not (R(A) <=> C) then pc++			*/
OP_TESTSET,/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*/

OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/

OP_FORLOOP,/*	A sBx	R(A)+=R(A+2);
			if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/
OP_FORPREP,/*	A sBx	R(A)-=R(A+2); pc+=sBx				*/

OP_TFORCALL,/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));	*/
OP_TFORLOOP,/*	A sBx	if R(A+1) ~= nil then { R(A)=R(A+1); pc += sBx }*/

OP_SETLIST,/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B	*/

OP_CLOSURE,/*	A Bx	R(A) := closure(KPROTO[Bx])			*/

OP_VARARG,/*	A B	R(A), R(A+1), ..., R(A+B-2) = vararg		*/

OP_EXTRAARG/*	Ax	extra (larger) argument for previous opcode	*/
} OpCode;


#define NUM_OPCODES	(cast(int, OP_EXTRAARG) + 1)



/*===========================================================================
  Notes:
  (*) In OP_CALL, if (B == 0) then B = top. If (C == 0), then 'top' is
  set to last_result+1, so next open instruction (OP_CALL, OP_RETURN,
  OP_SETLIST) may use 'top'.

  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
  set top (like in OP_CALL with C == 0).

  (*) In OP_RETURN, if (B == 0) then return up to 'top'.

  (*) In OP_SETLIST, if (B == 0) then B = 'top'; if (C == 0) then next
  'instruction' is EXTRAARG(real C).

  (*) In OP_LOADKX, the next 'instruction' is always EXTRAARG.

  (*) For comparisons, A specifies what condition the test should accept
  (true or false).

  (*) All 'skips' (pc++) assume that next instruction is a jump.

===========================================================================*/


/*
** masks for instruction properties. The format is:
** bits 0-1: op mode
** bits 2-3: C arg mode
** bits 4-5: B arg mode
** bit 6: instruction set register A
** bit 7: operator is a test (next instruction must be a jump)
*/

enum OpArgMask {
  OpArgN,  /* argument is not used */
  OpArgU,  /* argument is used */
  OpArgR,  /* argument is a register or a jump offset */
  OpArgK   /* argument is a constant or register/constant */
};

LUAI_DDEC const lu_byte luaP_opmodes[NUM_OPCODES];

#define getOpMode(m)	(cast(enum OpMode, luaP_opmodes[m] & 3))
#define getBMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
#define getCMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
#define testAMode(m)	(luaP_opmodes[m] & (1 << 6))
#define testTMode(m)	(luaP_opmodes[m] & (1 << 7))


LUAI_DDEC const char *const luaP_opnames[NUM_OPCODES+1];  /* opcode names */


/* number of list items to accumulate before a SETLIST instruction */
#define LFIELDS_PER_FLUSH	50


#endif

```

`src/Lua/loslib.c`:

```c
/*
** $Id: loslib.c,v 1.65 2016/07/18 17:58:58 roberto Exp $
** Standard Operating System library
** See Copyright Notice in lua.h
*/

#define loslib_c
#define LUA_LIB

#include "lprefix.h"


#include <errno.h>
#include <locale.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


/*
** {==================================================================
** List of valid conversion specifiers for the 'strftime' function;
** options are grouped by length; group of length 2 start with '||'.
** ===================================================================
*/
#if !defined(LUA_STRFTIMEOPTIONS)	/* { */

/* options for ANSI C 89 (only 1-char options) */
#define L_STRFTIMEC89		"aAbBcdHIjmMpSUwWxXyYZ%"

/* options for ISO C 99 and POSIX */
#define L_STRFTIMEC99 "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%" \
    "||" "EcECExEXEyEY" "OdOeOHOIOmOMOSOuOUOVOwOWOy"  /* two-char options */

/* options for Windows */
#define L_STRFTIMEWIN "aAbBcdHIjmMpSUwWxXyYzZ%" \
    "||" "#c#x#d#H#I#j#m#M#S#U#w#W#y#Y"  /* two-char options */

#if defined(LUA_USE_WINDOWS)
#define LUA_STRFTIMEOPTIONS	L_STRFTIMEWIN
#elif defined(LUA_USE_C89)
#define LUA_STRFTIMEOPTIONS	L_STRFTIMEC89
#else  /* C99 specification */
#define LUA_STRFTIMEOPTIONS	L_STRFTIMEC99
#endif

#endif					/* } */
/* }================================================================== */


/*
** {==================================================================
** Configuration for time-related stuff
** ===================================================================
*/

#if !defined(l_time_t)		/* { */
/*
** type to represent time_t in Lua
*/
#define l_timet			lua_Integer
#define l_pushtime(L,t)		lua_pushinteger(L,(lua_Integer)(t))

static time_t l_checktime (lua_State *L, int arg) {
  lua_Integer t = luaL_checkinteger(L, arg);
  luaL_argcheck(L, (time_t)t == t, arg, "time out-of-bounds");
  return (time_t)t;
}

#endif				/* } */


#if !defined(l_gmtime)		/* { */
/*
** By default, Lua uses gmtime/localtime, except when POSIX is available,
** where it uses gmtime_r/localtime_r
*/

#if defined(LUA_USE_POSIX)	/* { */

#define l_gmtime(t,r)		gmtime_r(t,r)
#define l_localtime(t,r)	localtime_r(t,r)

#else				/* }{ */

/* ISO C definitions */
#define l_gmtime(t,r)		((void)(r)->tm_sec, gmtime(t))
#define l_localtime(t,r)  	((void)(r)->tm_sec, localtime(t))

#endif				/* } */

#endif				/* } */

/* }================================================================== */


/*
** {==================================================================
** Configuration for 'tmpnam':
** By default, Lua uses tmpnam except when POSIX is available, where
** it uses mkstemp.
** ===================================================================
*/
#if !defined(lua_tmpnam)	/* { */

#if defined(LUA_USE_POSIX)	/* { */

#include <unistd.h>

#define LUA_TMPNAMBUFSIZE	32

#if !defined(LUA_TMPNAMTEMPLATE)
#define LUA_TMPNAMTEMPLATE	"/tmp/lua_XXXXXX"
#endif

#define lua_tmpnam(b,e) { \
        strcpy(b, LUA_TMPNAMTEMPLATE); \
        e = mkstemp(b); \
        if (e != -1) close(e); \
        e = (e == -1); }

#else				/* }{ */

/* ISO C definitions */
#define LUA_TMPNAMBUFSIZE	L_tmpnam
#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }

#endif				/* } */

#endif				/* } */
/* }================================================================== */




static int os_execute (lua_State *L) {
  const char *cmd = luaL_optstring(L, 1, NULL);
  int stat = system(cmd);
  if (cmd != NULL)
    return luaL_execresult(L, stat);
  else {
    lua_pushboolean(L, stat);  /* true if there is a shell */
    return 1;
  }
}


static int os_remove (lua_State *L) {
  const char *filename = luaL_checkstring(L, 1);
  return luaL_fileresult(L, remove(filename) == 0, filename);
}


static int os_rename (lua_State *L) {
  const char *fromname = luaL_checkstring(L, 1);
  const char *toname = luaL_checkstring(L, 2);
  return luaL_fileresult(L, rename(fromname, toname) == 0, NULL);
}


static int os_tmpname (lua_State *L) {
  char buff[LUA_TMPNAMBUFSIZE];
  int err;
  lua_tmpnam(buff, err);
  if (err)
    return luaL_error(L, "unable to generate a unique filename");
  lua_pushstring(L, buff);
  return 1;
}


static int os_getenv (lua_State *L) {
  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
  return 1;
}


static int os_clock (lua_State *L) {
  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
  return 1;
}


/*
** {======================================================
** Time/Date operations
** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
**   wday=%w+1, yday=%j, isdst=? }
** =======================================================
*/

static void setfield (lua_State *L, const char *key, int value) {
  lua_pushinteger(L, value);
  lua_setfield(L, -2, key);
}

static void setboolfield (lua_State *L, const char *key, int value) {
  if (value < 0)  /* undefined? */
    return;  /* does not set field */
  lua_pushboolean(L, value);
  lua_setfield(L, -2, key);
}


/*
** Set all fields from structure 'tm' in the table on top of the stack
*/
static void setallfields (lua_State *L, struct tm *stm) {
  setfield(L, "sec", stm->tm_sec);
  setfield(L, "min", stm->tm_min);
  setfield(L, "hour", stm->tm_hour);
  setfield(L, "day", stm->tm_mday);
  setfield(L, "month", stm->tm_mon + 1);
  setfield(L, "year", stm->tm_year + 1900);
  setfield(L, "wday", stm->tm_wday + 1);
  setfield(L, "yday", stm->tm_yday + 1);
  setboolfield(L, "isdst", stm->tm_isdst);
}


static int getboolfield (lua_State *L, const char *key) {
  int res;
  res = (lua_getfield(L, -1, key) == LUA_TNIL) ? -1 : lua_toboolean(L, -1);
  lua_pop(L, 1);
  return res;
}


/* maximum value for date fields (to avoid arithmetic overflows with 'int') */
#if !defined(L_MAXDATEFIELD)
#define L_MAXDATEFIELD	(INT_MAX / 2)
#endif

static int getfield (lua_State *L, const char *key, int d, int delta) {
  int isnum;
  int t = lua_getfield(L, -1, key);  /* get field and its type */
  lua_Integer res = lua_tointegerx(L, -1, &isnum);
  if (!isnum) {  /* field is not an integer? */
    if (t != LUA_TNIL)  /* some other value? */
      return luaL_error(L, "field '%s' is not an integer", key);
    else if (d < 0)  /* absent field; no default? */
      return luaL_error(L, "field '%s' missing in date table", key);
    res = d;
  }
  else {
    if (!(-L_MAXDATEFIELD <= res && res <= L_MAXDATEFIELD))
      return luaL_error(L, "field '%s' is out-of-bound", key);
    res -= delta;
  }
  lua_pop(L, 1);
  return (int)res;
}


static const char *checkoption (lua_State *L, const char *conv,
                                ptrdiff_t convlen, char *buff) {
  const char *option = LUA_STRFTIMEOPTIONS;
  int oplen = 1;  /* length of options being checked */
  for (; *option != '\0' && oplen <= convlen; option += oplen) {
    if (*option == '|')  /* next block? */
      oplen++;  /* will check options with next length (+1) */
    else if (memcmp(conv, option, oplen) == 0) {  /* match? */
      memcpy(buff, conv, oplen);  /* copy valid option to buffer */
      buff[oplen] = '\0';
      return conv + oplen;  /* return next item */
    }
  }
  luaL_argerror(L, 1,
    lua_pushfstring(L, "invalid conversion specifier '%%%s'", conv));
  return conv;  /* to avoid warnings */
}


/* maximum size for an individual 'strftime' item */
#define SIZETIMEFMT	250


static int os_date (lua_State *L) {
  size_t slen;
  const char *s = luaL_optlstring(L, 1, "%c", &slen);
  time_t t = luaL_opt(L, l_checktime, 2, time(NULL));
  const char *se = s + slen;  /* 's' end */
  struct tm tmr, *stm;
  if (*s == '!') {  /* UTC? */
    stm = l_gmtime(&t, &tmr);
    s++;  /* skip '!' */
  }
  else
    stm = l_localtime(&t, &tmr);
  if (stm == NULL)  /* invalid date? */
    luaL_error(L, "time result cannot be represented in this installation");
  if (strcmp(s, "*t") == 0) {
    lua_createtable(L, 0, 9);  /* 9 = number of fields */
    setallfields(L, stm);
  }
  else {
    char cc[4];  /* buffer for individual conversion specifiers */
    luaL_Buffer b;
    cc[0] = '%';
    luaL_buffinit(L, &b);
    while (s < se) {
      if (*s != '%')  /* not a conversion specifier? */
        luaL_addchar(&b, *s++);
      else {
        size_t reslen;
        char *buff = luaL_prepbuffsize(&b, SIZETIMEFMT);
        s++;  /* skip '%' */
        s = checkoption(L, s, se - s, cc + 1);  /* copy specifier to 'cc' */
        reslen = strftime(buff, SIZETIMEFMT, cc, stm);
        luaL_addsize(&b, reslen);
      }
    }
    luaL_pushresult(&b);
  }
  return 1;
}


static int os_time (lua_State *L) {
  time_t t;
  if (lua_isnoneornil(L, 1))  /* called without args? */
    t = time(NULL);  /* get current time */
  else {
    struct tm ts;
    luaL_checktype(L, 1, LUA_TTABLE);
    lua_settop(L, 1);  /* make sure table is at the top */
    ts.tm_sec = getfield(L, "sec", 0, 0);
    ts.tm_min = getfield(L, "min", 0, 0);
    ts.tm_hour = getfield(L, "hour", 12, 0);
    ts.tm_mday = getfield(L, "day", -1, 0);
    ts.tm_mon = getfield(L, "month", -1, 1);
    ts.tm_year = getfield(L, "year", -1, 1900);
    ts.tm_isdst = getboolfield(L, "isdst");
    t = mktime(&ts);
    setallfields(L, &ts);  /* update fields with normalized values */
  }
  if (t != (time_t)(l_timet)t || t == (time_t)(-1))
    luaL_error(L, "time result cannot be represented in this installation");
  l_pushtime(L, t);
  return 1;
}


static int os_difftime (lua_State *L) {
  time_t t1 = l_checktime(L, 1);
  time_t t2 = l_checktime(L, 2);
  lua_pushnumber(L, (lua_Number)difftime(t1, t2));
  return 1;
}

/* }====================================================== */


static int os_setlocale (lua_State *L) {
  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
                      LC_NUMERIC, LC_TIME};
  static const char *const catnames[] = {"all", "collate", "ctype", "monetary",
     "numeric", "time", NULL};
  const char *l = luaL_optstring(L, 1, NULL);
  int op = luaL_checkoption(L, 2, "all", catnames);
  lua_pushstring(L, setlocale(cat[op], l));
  return 1;
}


static int os_exit (lua_State *L) {
  int status;
  if (lua_isboolean(L, 1))
    status = (lua_toboolean(L, 1) ? EXIT_SUCCESS : EXIT_FAILURE);
  else
    status = (int)luaL_optinteger(L, 1, EXIT_SUCCESS);
  if (lua_toboolean(L, 2))
    lua_close(L);
  if (L) exit(status);  /* 'if' to avoid warnings for unreachable 'return' */
  return 0;
}


static const luaL_Reg syslib[] = {
  {"clock",     os_clock},
  {"date",      os_date},
  {"difftime",  os_difftime},
  {"execute",   os_execute},
  {"exit",      os_exit},
  {"getenv",    os_getenv},
  {"remove",    os_remove},
  {"rename",    os_rename},
  {"setlocale", os_setlocale},
  {"time",      os_time},
  {"tmpname",   os_tmpname},
  {NULL, NULL}
};

/* }====================================================== */



LUAMOD_API int luaopen_os (lua_State *L) {
  luaL_newlib(L, syslib);
  return 1;
}


```

`src/Lua/lparser.c`:

```c
/*
** $Id: lparser.c,v 2.155 2016/08/01 19:51:24 roberto Exp $
** Lua Parser
** See Copyright Notice in lua.h
*/

#define lparser_c
#define LUA_CORE

#include "lprefix.h"


#include <string.h>

#include "lua.h"

#include "lcode.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "llex.h"
#include "lmem.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lparser.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"



/* maximum number of local variables per function (must be smaller
   than 250, due to the bytecode format) */
#define MAXVARS		200


#define hasmultret(k)		((k) == VCALL || (k) == VVARARG)


/* because all strings are unified by the scanner, the parser
   can use pointer equality for string equality */
#define eqstr(a,b)	((a) == (b))


/*
** nodes for block list (list of active blocks)
*/
typedef struct BlockCnt {
  struct BlockCnt *previous;  /* chain */
  int firstlabel;  /* index of first label in this block */
  int firstgoto;  /* index of first pending goto in this block */
  lu_byte nactvar;  /* # active locals outside the block */
  lu_byte upval;  /* true if some variable in the block is an upvalue */
  lu_byte isloop;  /* true if 'block' is a loop */
} BlockCnt;



/*
** prototypes for recursive non-terminal functions
*/
static void statement (LexState *ls);
static void expr (LexState *ls, expdesc *v);


/* semantic error */
static l_noret semerror (LexState *ls, const char *msg) {
  ls->t.token = 0;  /* remove "near <token>" from final message */
  luaX_syntaxerror(ls, msg);
}


static l_noret error_expected (LexState *ls, int token) {
  luaX_syntaxerror(ls,
      luaO_pushfstring(ls->L, "%s expected", luaX_token2str(ls, token)));
}


static l_noret errorlimit (FuncState *fs, int limit, const char *what) {
  lua_State *L = fs->ls->L;
  const char *msg;
  int line = fs->f->linedefined;
  const char *where = (line == 0)
                      ? "main function"
                      : luaO_pushfstring(L, "function at line %d", line);
  msg = luaO_pushfstring(L, "too many %s (limit is %d) in %s",
                             what, limit, where);
  luaX_syntaxerror(fs->ls, msg);
}


static void checklimit (FuncState *fs, int v, int l, const char *what) {
  if (v > l) errorlimit(fs, l, what);
}


static int testnext (LexState *ls, int c) {
  if (ls->t.token == c) {
    luaX_next(ls);
    return 1;
  }
  else return 0;
}


static void check (LexState *ls, int c) {
  if (ls->t.token != c)
    error_expected(ls, c);
}


static void checknext (LexState *ls, int c) {
  check(ls, c);
  luaX_next(ls);
}


#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }



static void check_match (LexState *ls, int what, int who, int where) {
  if (!testnext(ls, what)) {
    if (where == ls->linenumber)
      error_expected(ls, what);
    else {
      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
             "%s expected (to close %s at line %d)",
              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
    }
  }
}


static TString *str_checkname (LexState *ls) {
  TString *ts;
  check(ls, TK_NAME);
  ts = ls->t.seminfo.ts;
  luaX_next(ls);
  return ts;
}


static void init_exp (expdesc *e, expkind k, int i) {
  e->f = e->t = NO_JUMP;
  e->k = k;
  e->u.info = i;
}


static void codestring (LexState *ls, expdesc *e, TString *s) {
  init_exp(e, VK, luaK_stringK(ls->fs, s));
}


static void checkname (LexState *ls, expdesc *e) {
  codestring(ls, e, str_checkname(ls));
}


static int registerlocalvar (LexState *ls, TString *varname) {
  FuncState *fs = ls->fs;
  Proto *f = fs->f;
  int oldsize = f->sizelocvars;
  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
                  LocVar, SHRT_MAX, "local variables");
  while (oldsize < f->sizelocvars)
    f->locvars[oldsize++].varname = NULL;
  f->locvars[fs->nlocvars].varname = varname;
  luaC_objbarrier(ls->L, f, varname);
  return fs->nlocvars++;
}


static void new_localvar (LexState *ls, TString *name) {
  FuncState *fs = ls->fs;
  Dyndata *dyd = ls->dyd;
  int reg = registerlocalvar(ls, name);
  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,
                  MAXVARS, "local variables");
  luaM_growvector(ls->L, dyd->actvar.arr, dyd->actvar.n + 1,
                  dyd->actvar.size, Vardesc, MAX_INT, "local variables");
  dyd->actvar.arr[dyd->actvar.n++].idx = cast(short, reg);
}


static void new_localvarliteral_ (LexState *ls, const char *name, size_t sz) {
  new_localvar(ls, luaX_newstring(ls, name, sz));
}

#define new_localvarliteral(ls,v) \
	new_localvarliteral_(ls, "" v, (sizeof(v)/sizeof(char))-1)


static LocVar *getlocvar (FuncState *fs, int i) {
  int idx = fs->ls->dyd->actvar.arr[fs->firstlocal + i].idx;
  lua_assert(idx < fs->nlocvars);
  return &fs->f->locvars[idx];
}


static void adjustlocalvars (LexState *ls, int nvars) {
  FuncState *fs = ls->fs;
  fs->nactvar = cast_byte(fs->nactvar + nvars);
  for (; nvars; nvars--) {
    getlocvar(fs, fs->nactvar - nvars)->startpc = fs->pc;
  }
}


static void removevars (FuncState *fs, int tolevel) {
  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);
  while (fs->nactvar > tolevel)
    getlocvar(fs, --fs->nactvar)->endpc = fs->pc;
}


static int searchupvalue (FuncState *fs, TString *name) {
  int i;
  Upvaldesc *up = fs->f->upvalues;
  for (i = 0; i < fs->nups; i++) {
    if (eqstr(up[i].name, name)) return i;
  }
  return -1;  /* not found */
}


static int newupvalue (FuncState *fs, TString *name, expdesc *v) {
  Proto *f = fs->f;
  int oldsize = f->sizeupvalues;
  checklimit(fs, fs->nups + 1, MAXUPVAL, "upvalues");
  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,
                  Upvaldesc, MAXUPVAL, "upvalues");
  while (oldsize < f->sizeupvalues)
    f->upvalues[oldsize++].name = NULL;
  f->upvalues[fs->nups].instack = (v->k == VLOCAL);
  f->upvalues[fs->nups].idx = cast_byte(v->u.info);
  f->upvalues[fs->nups].name = name;
  luaC_objbarrier(fs->ls->L, f, name);
  return fs->nups++;
}


static int searchvar (FuncState *fs, TString *n) {
  int i;
  for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {
    if (eqstr(n, getlocvar(fs, i)->varname))
      return i;
  }
  return -1;  /* not found */
}


/*
  Mark block where variable at given level was defined
  (to emit close instructions later).
*/
static void markupval (FuncState *fs, int level) {
  BlockCnt *bl = fs->bl;
  while (bl->nactvar > level)
    bl = bl->previous;
  bl->upval = 1;
}


/*
  Find variable with given name 'n'. If it is an upvalue, add this
  upvalue into all intermediate functions.
*/
static void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
  if (fs == NULL)  /* no more levels? */
    init_exp(var, VVOID, 0);  /* default is global */
  else {
    int v = searchvar(fs, n);  /* look up locals at current level */
    if (v >= 0) {  /* found? */
      init_exp(var, VLOCAL, v);  /* variable is local */
      if (!base)
        markupval(fs, v);  /* local will be used as an upval */
    }
    else {  /* not found as local at current level; try upvalues */
      int idx = searchupvalue(fs, n);  /* try existing upvalues */
      if (idx < 0) {  /* not found? */
        singlevaraux(fs->prev, n, var, 0);  /* try upper levels */
        if (var->k == VVOID)  /* not found? */
          return;  /* it is a global */
        /* else was LOCAL or UPVAL */
        idx  = newupvalue(fs, n, var);  /* will be a new upvalue */
      }
      init_exp(var, VUPVAL, idx);  /* new or old upvalue */
    }
  }
}


static void singlevar (LexState *ls, expdesc *var) {
  TString *varname = str_checkname(ls);
  FuncState *fs = ls->fs;
  singlevaraux(fs, varname, var, 1);
  if (var->k == VVOID) {  /* global name? */
    expdesc key;
    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */
    lua_assert(var->k != VVOID);  /* this one must exist */
    codestring(ls, &key, varname);  /* key is variable name */
    luaK_indexed(fs, var, &key);  /* env[varname] */
  }
}


static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
  FuncState *fs = ls->fs;
  int extra = nvars - nexps;
  if (hasmultret(e->k)) {
    extra++;  /* includes call itself */
    if (extra < 0) extra = 0;
    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */
    if (extra > 1) luaK_reserveregs(fs, extra-1);
  }
  else {
    if (e->k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
    if (extra > 0) {
      int reg = fs->freereg;
      luaK_reserveregs(fs, extra);
      luaK_nil(fs, reg, extra);
    }
  }
  if (nexps > nvars)
    ls->fs->freereg -= nexps - nvars;  /* remove extra values */
}


static void enterlevel (LexState *ls) {
  lua_State *L = ls->L;
  ++L->nCcalls;
  checklimit(ls->fs, L->nCcalls, LUAI_MAXCCALLS, "C levels");
}


#define leavelevel(ls)	((ls)->L->nCcalls--)


static void closegoto (LexState *ls, int g, Labeldesc *label) {
  int i;
  FuncState *fs = ls->fs;
  Labellist *gl = &ls->dyd->gt;
  Labeldesc *gt = &gl->arr[g];
  lua_assert(eqstr(gt->name, label->name));
  if (gt->nactvar < label->nactvar) {
    TString *vname = getlocvar(fs, gt->nactvar)->varname;
    const char *msg = luaO_pushfstring(ls->L,
      "<goto %s> at line %d jumps into the scope of local '%s'",
      getstr(gt->name), gt->line, getstr(vname));
    semerror(ls, msg);
  }
  luaK_patchlist(fs, gt->pc, label->pc);
  /* remove goto from pending list */
  for (i = g; i < gl->n - 1; i++)
    gl->arr[i] = gl->arr[i + 1];
  gl->n--;
}


/*
** try to close a goto with existing labels; this solves backward jumps
*/
static int findlabel (LexState *ls, int g) {
  int i;
  BlockCnt *bl = ls->fs->bl;
  Dyndata *dyd = ls->dyd;
  Labeldesc *gt = &dyd->gt.arr[g];
  /* check labels in current block for a match */
  for (i = bl->firstlabel; i < dyd->label.n; i++) {
    Labeldesc *lb = &dyd->label.arr[i];
    if (eqstr(lb->name, gt->name)) {  /* correct label? */
      if (gt->nactvar > lb->nactvar &&
          (bl->upval || dyd->label.n > bl->firstlabel))
        luaK_patchclose(ls->fs, gt->pc, lb->nactvar);
      closegoto(ls, g, lb);  /* close it */
      return 1;
    }
  }
  return 0;  /* label not found; cannot close goto */
}


static int newlabelentry (LexState *ls, Labellist *l, TString *name,
                          int line, int pc) {
  int n = l->n;
  luaM_growvector(ls->L, l->arr, n, l->size,
                  Labeldesc, SHRT_MAX, "labels/gotos");
  l->arr[n].name = name;
  l->arr[n].line = line;
  l->arr[n].nactvar = ls->fs->nactvar;
  l->arr[n].pc = pc;
  l->n = n + 1;
  return n;
}


/*
** check whether new label 'lb' matches any pending gotos in current
** block; solves forward jumps
*/
static void findgotos (LexState *ls, Labeldesc *lb) {
  Labellist *gl = &ls->dyd->gt;
  int i = ls->fs->bl->firstgoto;
  while (i < gl->n) {
    if (eqstr(gl->arr[i].name, lb->name))
      closegoto(ls, i, lb);
    else
      i++;
  }
}


/*
** export pending gotos to outer level, to check them against
** outer labels; if the block being exited has upvalues, and
** the goto exits the scope of any variable (which can be the
** upvalue), close those variables being exited.
*/
static void movegotosout (FuncState *fs, BlockCnt *bl) {
  int i = bl->firstgoto;
  Labellist *gl = &fs->ls->dyd->gt;
  /* correct pending gotos to current block and try to close it
     with visible labels */
  while (i < gl->n) {
    Labeldesc *gt = &gl->arr[i];
    if (gt->nactvar > bl->nactvar) {
      if (bl->upval)
        luaK_patchclose(fs, gt->pc, bl->nactvar);
      gt->nactvar = bl->nactvar;
    }
    if (!findlabel(fs->ls, i))
      i++;  /* move to next one */
  }
}


static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {
  bl->isloop = isloop;
  bl->nactvar = fs->nactvar;
  bl->firstlabel = fs->ls->dyd->label.n;
  bl->firstgoto = fs->ls->dyd->gt.n;
  bl->upval = 0;
  bl->previous = fs->bl;
  fs->bl = bl;
  lua_assert(fs->freereg == fs->nactvar);
}


/*
** create a label named 'break' to resolve break statements
*/
static void breaklabel (LexState *ls) {
  TString *n = luaS_new(ls->L, "break");
  int l = newlabelentry(ls, &ls->dyd->label, n, 0, ls->fs->pc);
  findgotos(ls, &ls->dyd->label.arr[l]);
}

/*
** generates an error for an undefined 'goto'; choose appropriate
** message when label name is a reserved word (which can only be 'break')
*/
static l_noret undefgoto (LexState *ls, Labeldesc *gt) {
  const char *msg = isreserved(gt->name)
                    ? "<%s> at line %d not inside a loop"
                    : "no visible label '%s' for <goto> at line %d";
  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);
  semerror(ls, msg);
}


static void leaveblock (FuncState *fs) {
  BlockCnt *bl = fs->bl;
  LexState *ls = fs->ls;
  if (bl->previous && bl->upval) {
    /* create a 'jump to here' to close upvalues */
    int j = luaK_jump(fs);
    luaK_patchclose(fs, j, bl->nactvar);
    luaK_patchtohere(fs, j);
  }
  if (bl->isloop)
    breaklabel(ls);  /* close pending breaks */
  fs->bl = bl->previous;
  removevars(fs, bl->nactvar);
  lua_assert(bl->nactvar == fs->nactvar);
  fs->freereg = fs->nactvar;  /* free registers */
  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */
  if (bl->previous)  /* inner block? */
    movegotosout(fs, bl);  /* update pending gotos to outer block */
  else if (bl->firstgoto < ls->dyd->gt.n)  /* pending gotos in outer block? */
    undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */
}


/*
** adds a new prototype into list of prototypes
*/
static Proto *addprototype (LexState *ls) {
  Proto *clp;
  lua_State *L = ls->L;
  FuncState *fs = ls->fs;
  Proto *f = fs->f;  /* prototype of current function */
  if (fs->np >= f->sizep) {
    int oldsize = f->sizep;
    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, "functions");
    while (oldsize < f->sizep)
      f->p[oldsize++] = NULL;
  }
  f->p[fs->np++] = clp = luaF_newproto(L);
  luaC_objbarrier(L, f, clp);
  return clp;
}


/*
** codes instruction to create new closure in parent function.
** The OP_CLOSURE instruction must use the last available register,
** so that, if it invokes the GC, the GC knows which registers
** are in use at that time.
*/
static void codeclosure (LexState *ls, expdesc *v) {
  FuncState *fs = ls->fs->prev;
  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));
  luaK_exp2nextreg(fs, v);  /* fix it at the last register */
}


static void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {
  Proto *f;
  fs->prev = ls->fs;  /* linked list of funcstates */
  fs->ls = ls;
  ls->fs = fs;
  fs->pc = 0;
  fs->lasttarget = 0;
  fs->jpc = NO_JUMP;
  fs->freereg = 0;
  fs->nk = 0;
  fs->np = 0;
  fs->nups = 0;
  fs->nlocvars = 0;
  fs->nactvar = 0;
  fs->firstlocal = ls->dyd->actvar.n;
  fs->bl = NULL;
  f = fs->f;
  f->source = ls->source;
  f->maxstacksize = 2;  /* registers 0/1 are always valid */
  enterblock(fs, bl, 0);
}


static void close_func (LexState *ls) {
  lua_State *L = ls->L;
  FuncState *fs = ls->fs;
  Proto *f = fs->f;
  luaK_ret(fs, 0, 0);  /* final return */
  leaveblock(fs);
  luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);
  f->sizecode = fs->pc;
  luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);
  f->sizelineinfo = fs->pc;
  luaM_reallocvector(L, f->k, f->sizek, fs->nk, TValue);
  f->sizek = fs->nk;
  luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);
  f->sizep = fs->np;
  luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);
  f->sizelocvars = fs->nlocvars;
  luaM_reallocvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);
  f->sizeupvalues = fs->nups;
  lua_assert(fs->bl == NULL);
  ls->fs = fs->prev;
  luaC_checkGC(L);
}



/*============================================================*/
/* GRAMMAR RULES */
/*============================================================*/


/*
** check whether current token is in the follow set of a block.
** 'until' closes syntactical blocks, but do not close scope,
** so it is handled in separate.
*/
static int block_follow (LexState *ls, int withuntil) {
  switch (ls->t.token) {
    case TK_ELSE: case TK_ELSEIF:
    case TK_END: case TK_EOS:
      return 1;
    case TK_UNTIL: return withuntil;
    default: return 0;
  }
}


static void statlist (LexState *ls) {
  /* statlist -> { stat [';'] } */
  while (!block_follow(ls, 1)) {
    if (ls->t.token == TK_RETURN) {
      statement(ls);
      return;  /* 'return' must be last statement */
    }
    statement(ls);
  }
}


static void fieldsel (LexState *ls, expdesc *v) {
  /* fieldsel -> ['.' | ':'] NAME */
  FuncState *fs = ls->fs;
  expdesc key;
  luaK_exp2anyregup(fs, v);
  luaX_next(ls);  /* skip the dot or colon */
  checkname(ls, &key);
  luaK_indexed(fs, v, &key);
}


static void yindex (LexState *ls, expdesc *v) {
  /* index -> '[' expr ']' */
  luaX_next(ls);  /* skip the '[' */
  expr(ls, v);
  luaK_exp2val(ls->fs, v);
  checknext(ls, ']');
}


/*
** {======================================================================
** Rules for Constructors
** =======================================================================
*/


struct ConsControl {
  expdesc v;  /* last list item read */
  expdesc *t;  /* table descriptor */
  int nh;  /* total number of 'record' elements */
  int na;  /* total number of array elements */
  int tostore;  /* number of array elements pending to be stored */
};


static void recfield (LexState *ls, struct ConsControl *cc) {
  /* recfield -> (NAME | '['exp1']') = exp1 */
  FuncState *fs = ls->fs;
  int reg = ls->fs->freereg;
  expdesc key, val;
  int rkkey;
  if (ls->t.token == TK_NAME) {
    checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
    checkname(ls, &key);
  }
  else  /* ls->t.token == '[' */
    yindex(ls, &key);
  cc->nh++;
  checknext(ls, '=');
  rkkey = luaK_exp2RK(fs, &key);
  expr(ls, &val);
  luaK_codeABC(fs, OP_SETTABLE, cc->t->u.info, rkkey, luaK_exp2RK(fs, &val));
  fs->freereg = reg;  /* free registers */
}


static void closelistfield (FuncState *fs, struct ConsControl *cc) {
  if (cc->v.k == VVOID) return;  /* there is no list item */
  luaK_exp2nextreg(fs, &cc->v);
  cc->v.k = VVOID;
  if (cc->tostore == LFIELDS_PER_FLUSH) {
    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */
    cc->tostore = 0;  /* no more items pending */
  }
}


static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
  if (cc->tostore == 0) return;
  if (hasmultret(cc->v.k)) {
    luaK_setmultret(fs, &cc->v);
    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
    cc->na--;  /* do not count last expression (unknown number of elements) */
  }
  else {
    if (cc->v.k != VVOID)
      luaK_exp2nextreg(fs, &cc->v);
    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
  }
}


static void listfield (LexState *ls, struct ConsControl *cc) {
  /* listfield -> exp */
  expr(ls, &cc->v);
  checklimit(ls->fs, cc->na, MAX_INT, "items in a constructor");
  cc->na++;
  cc->tostore++;
}


static void field (LexState *ls, struct ConsControl *cc) {
  /* field -> listfield | recfield */
  switch(ls->t.token) {
    case TK_NAME: {  /* may be 'listfield' or 'recfield' */
      if (luaX_lookahead(ls) != '=')  /* expression? */
        listfield(ls, cc);
      else
        recfield(ls, cc);
      break;
    }
    case '[': {
      recfield(ls, cc);
      break;
    }
    default: {
      listfield(ls, cc);
      break;
    }
  }
}


static void constructor (LexState *ls, expdesc *t) {
  /* constructor -> '{' [ field { sep field } [sep] ] '}'
     sep -> ',' | ';' */
  FuncState *fs = ls->fs;
  int line = ls->linenumber;
  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
  struct ConsControl cc;
  cc.na = cc.nh = cc.tostore = 0;
  cc.t = t;
  init_exp(t, VRELOCABLE, pc);
  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */
  luaK_exp2nextreg(ls->fs, t);  /* fix it at stack top */
  checknext(ls, '{');
  do {
    lua_assert(cc.v.k == VVOID || cc.tostore > 0);
    if (ls->t.token == '}') break;
    closelistfield(fs, &cc);
    field(ls, &cc);
  } while (testnext(ls, ',') || testnext(ls, ';'));
  check_match(ls, '}', '{', line);
  lastlistfield(fs, &cc);
  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
  SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
}

/* }====================================================================== */



static void parlist (LexState *ls) {
  /* parlist -> [ param { ',' param } ] */
  FuncState *fs = ls->fs;
  Proto *f = fs->f;
  int nparams = 0;
  f->is_vararg = 0;
  if (ls->t.token != ')') {  /* is 'parlist' not empty? */
    do {
      switch (ls->t.token) {
        case TK_NAME: {  /* param -> NAME */
          new_localvar(ls, str_checkname(ls));
          nparams++;
          break;
        }
        case TK_DOTS: {  /* param -> '...' */
          luaX_next(ls);
          f->is_vararg = 1;  /* declared vararg */
          break;
        }
        default: luaX_syntaxerror(ls, "<name> or '...' expected");
      }
    } while (!f->is_vararg && testnext(ls, ','));
  }
  adjustlocalvars(ls, nparams);
  f->numparams = cast_byte(fs->nactvar);
  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */
}


static void body (LexState *ls, expdesc *e, int ismethod, int line) {
  /* body ->  '(' parlist ')' block END */
  FuncState new_fs;
  BlockCnt bl;
  new_fs.f = addprototype(ls);
  new_fs.f->linedefined = line;
  open_func(ls, &new_fs, &bl);
  checknext(ls, '(');
  if (ismethod) {
    new_localvarliteral(ls, "self");  /* create 'self' parameter */
    adjustlocalvars(ls, 1);
  }
  parlist(ls);
  checknext(ls, ')');
  statlist(ls);
  new_fs.f->lastlinedefined = ls->linenumber;
  check_match(ls, TK_END, TK_FUNCTION, line);
  codeclosure(ls, e);
  close_func(ls);
}


static int explist (LexState *ls, expdesc *v) {
  /* explist -> expr { ',' expr } */
  int n = 1;  /* at least one expression */
  expr(ls, v);
  while (testnext(ls, ',')) {
    luaK_exp2nextreg(ls->fs, v);
    expr(ls, v);
    n++;
  }
  return n;
}


static void funcargs (LexState *ls, expdesc *f, int line) {
  FuncState *fs = ls->fs;
  expdesc args;
  int base, nparams;
  switch (ls->t.token) {
    case '(': {  /* funcargs -> '(' [ explist ] ')' */
      luaX_next(ls);
      if (ls->t.token == ')')  /* arg list is empty? */
        args.k = VVOID;
      else {
        explist(ls, &args);
        luaK_setmultret(fs, &args);
      }
      check_match(ls, ')', '(', line);
      break;
    }
    case '{': {  /* funcargs -> constructor */
      constructor(ls, &args);
      break;
    }
    case TK_STRING: {  /* funcargs -> STRING */
      codestring(ls, &args, ls->t.seminfo.ts);
      luaX_next(ls);  /* must use 'seminfo' before 'next' */
      break;
    }
    default: {
      luaX_syntaxerror(ls, "function arguments expected");
    }
  }
  lua_assert(f->k == VNONRELOC);
  base = f->u.info;  /* base register for call */
  if (hasmultret(args.k))
    nparams = LUA_MULTRET;  /* open call */
  else {
    if (args.k != VVOID)
      luaK_exp2nextreg(fs, &args);  /* close last argument */
    nparams = fs->freereg - (base+1);
  }
  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
  luaK_fixline(fs, line);
  fs->freereg = base+1;  /* call remove function and arguments and leaves
                            (unless changed) one result */
}




/*
** {======================================================================
** Expression parsing
** =======================================================================
*/


static void primaryexp (LexState *ls, expdesc *v) {
  /* primaryexp -> NAME | '(' expr ')' */
  switch (ls->t.token) {
    case '(': {
      int line = ls->linenumber;
      luaX_next(ls);
      expr(ls, v);
      check_match(ls, ')', '(', line);
      luaK_dischargevars(ls->fs, v);
      return;
    }
    case TK_NAME: {
      singlevar(ls, v);
      return;
    }
    default: {
      luaX_syntaxerror(ls, "unexpected symbol");
    }
  }
}


static void suffixedexp (LexState *ls, expdesc *v) {
  /* suffixedexp ->
       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */
  FuncState *fs = ls->fs;
  int line = ls->linenumber;
  primaryexp(ls, v);
  for (;;) {
    switch (ls->t.token) {
      case '.': {  /* fieldsel */
        fieldsel(ls, v);
        break;
      }
      case '[': {  /* '[' exp1 ']' */
        expdesc key;
        luaK_exp2anyregup(fs, v);
        yindex(ls, &key);
        luaK_indexed(fs, v, &key);
        break;
      }
      case ':': {  /* ':' NAME funcargs */
        expdesc key;
        luaX_next(ls);
        checkname(ls, &key);
        luaK_self(fs, v, &key);
        funcargs(ls, v, line);
        break;
      }
      case '(': case TK_STRING: case '{': {  /* funcargs */
        luaK_exp2nextreg(fs, v);
        funcargs(ls, v, line);
        break;
      }
      default: return;
    }
  }
}


static void simpleexp (LexState *ls, expdesc *v) {
  /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
                  constructor | FUNCTION body | suffixedexp */
  switch (ls->t.token) {
    case TK_FLT: {
      init_exp(v, VKFLT, 0);
      v->u.nval = ls->t.seminfo.r;
      break;
    }
    case TK_INT: {
      init_exp(v, VKINT, 0);
      v->u.ival = ls->t.seminfo.i;
      break;
    }
    case TK_STRING: {
      codestring(ls, v, ls->t.seminfo.ts);
      break;
    }
    case TK_NIL: {
      init_exp(v, VNIL, 0);
      break;
    }
    case TK_TRUE: {
      init_exp(v, VTRUE, 0);
      break;
    }
    case TK_FALSE: {
      init_exp(v, VFALSE, 0);
      break;
    }
    case TK_DOTS: {  /* vararg */
      FuncState *fs = ls->fs;
      check_condition(ls, fs->f->is_vararg,
                      "cannot use '...' outside a vararg function");
      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
      break;
    }
    case '{': {  /* constructor */
      constructor(ls, v);
      return;
    }
    case TK_FUNCTION: {
      luaX_next(ls);
      body(ls, v, 0, ls->linenumber);
      return;
    }
    default: {
      suffixedexp(ls, v);
      return;
    }
  }
  luaX_next(ls);
}


static UnOpr getunopr (int op) {
  switch (op) {
    case TK_NOT: return OPR_NOT;
    case '-': return OPR_MINUS;
    case '~': return OPR_BNOT;
    case '#': return OPR_LEN;
    default: return OPR_NOUNOPR;
  }
}


static BinOpr getbinopr (int op) {
  switch (op) {
    case '+': return OPR_ADD;
    case '-': return OPR_SUB;
    case '*': return OPR_MUL;
    case '%': return OPR_MOD;
    case '^': return OPR_POW;
    case '/': return OPR_DIV;
    case TK_IDIV: return OPR_IDIV;
    case '&': return OPR_BAND;
    case '|': return OPR_BOR;
    case '~': return OPR_BXOR;
    case TK_SHL: return OPR_SHL;
    case TK_SHR: return OPR_SHR;
    case TK_CONCAT: return OPR_CONCAT;
    case TK_NE: return OPR_NE;
    case TK_EQ: return OPR_EQ;
    case '<': return OPR_LT;
    case TK_LE: return OPR_LE;
    case '>': return OPR_GT;
    case TK_GE: return OPR_GE;
    case TK_AND: return OPR_AND;
    case TK_OR: return OPR_OR;
    default: return OPR_NOBINOPR;
  }
}


static const struct {
  lu_byte left;  /* left priority for each binary operator */
  lu_byte right; /* right priority */
} priority[] = {  /* ORDER OPR */
   {10, 10}, {10, 10},           /* '+' '-' */
   {11, 11}, {11, 11},           /* '*' '%' */
   {14, 13},                  /* '^' (right associative) */
   {11, 11}, {11, 11},           /* '/' '//' */
   {6, 6}, {4, 4}, {5, 5},   /* '&' '|' '~' */
   {7, 7}, {7, 7},           /* '<<' '>>' */
   {9, 8},                   /* '..' (right associative) */
   {3, 3}, {3, 3}, {3, 3},   /* ==, <, <= */
   {3, 3}, {3, 3}, {3, 3},   /* ~=, >, >= */
   {2, 2}, {1, 1}            /* and, or */
};

#define UNARY_PRIORITY	12  /* priority for unary operators */


/*
** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
** where 'binop' is any binary operator with a priority higher than 'limit'
*/
static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
  BinOpr op;
  UnOpr uop;
  enterlevel(ls);
  uop = getunopr(ls->t.token);
  if (uop != OPR_NOUNOPR) {
    int line = ls->linenumber;
    luaX_next(ls);
    subexpr(ls, v, UNARY_PRIORITY);
    luaK_prefix(ls->fs, uop, v, line);
  }
  else simpleexp(ls, v);
  /* expand while operators have priorities higher than 'limit' */
  op = getbinopr(ls->t.token);
  while (op != OPR_NOBINOPR && priority[op].left > limit) {
    expdesc v2;
    BinOpr nextop;
    int line = ls->linenumber;
    luaX_next(ls);
    luaK_infix(ls->fs, op, v);
    /* read sub-expression with higher priority */
    nextop = subexpr(ls, &v2, priority[op].right);
    luaK_posfix(ls->fs, op, v, &v2, line);
    op = nextop;
  }
  leavelevel(ls);
  return op;  /* return first untreated operator */
}


static void expr (LexState *ls, expdesc *v) {
  subexpr(ls, v, 0);
}

/* }==================================================================== */



/*
** {======================================================================
** Rules for Statements
** =======================================================================
*/


static void block (LexState *ls) {
  /* block -> statlist */
  FuncState *fs = ls->fs;
  BlockCnt bl;
  enterblock(fs, &bl, 0);
  statlist(ls);
  leaveblock(fs);
}


/*
** structure to chain all variables in the left-hand side of an
** assignment
*/
struct LHS_assign {
  struct LHS_assign *prev;
  expdesc v;  /* variable (global, local, upvalue, or indexed) */
};


/*
** check whether, in an assignment to an upvalue/local variable, the
** upvalue/local variable is begin used in a previous assignment to a
** table. If so, save original upvalue/local value in a safe place and
** use this safe copy in the previous assignment.
*/
static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
  FuncState *fs = ls->fs;
  int extra = fs->freereg;  /* eventual position to save local variable */
  int conflict = 0;
  for (; lh; lh = lh->prev) {  /* check all previous assignments */
    if (lh->v.k == VINDEXED) {  /* assigning to a table? */
      /* table is the upvalue/local being assigned now? */
      if (lh->v.u.ind.vt == v->k && lh->v.u.ind.t == v->u.info) {
        conflict = 1;
        lh->v.u.ind.vt = VLOCAL;
        lh->v.u.ind.t = extra;  /* previous assignment will use safe copy */
      }
      /* index is the local being assigned? (index cannot be upvalue) */
      if (v->k == VLOCAL && lh->v.u.ind.idx == v->u.info) {
        conflict = 1;
        lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */
      }
    }
  }
  if (conflict) {
    /* copy upvalue/local value to a temporary (in position 'extra') */
    OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
    luaK_codeABC(fs, op, extra, v->u.info, 0);
    luaK_reserveregs(fs, 1);
  }
}


static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
  expdesc e;
  check_condition(ls, vkisvar(lh->v.k), "syntax error");
  if (testnext(ls, ',')) {  /* assignment -> ',' suffixedexp assignment */
    struct LHS_assign nv;
    nv.prev = lh;
    suffixedexp(ls, &nv.v);
    if (nv.v.k != VINDEXED)
      check_conflict(ls, lh, &nv.v);
    checklimit(ls->fs, nvars + ls->L->nCcalls, LUAI_MAXCCALLS,
                    "C levels");
    assignment(ls, &nv, nvars+1);
  }
  else {  /* assignment -> '=' explist */
    int nexps;
    checknext(ls, '=');
    nexps = explist(ls, &e);
    if (nexps != nvars)
      adjust_assign(ls, nvars, nexps, &e);
    else {
      luaK_setoneret(ls->fs, &e);  /* close last expression */
      luaK_storevar(ls->fs, &lh->v, &e);
      return;  /* avoid default */
    }
  }
  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
  luaK_storevar(ls->fs, &lh->v, &e);
}


static int cond (LexState *ls) {
  /* cond -> exp */
  expdesc v;
  expr(ls, &v);  /* read condition */
  if (v.k == VNIL) v.k = VFALSE;  /* 'falses' are all equal here */
  luaK_goiftrue(ls->fs, &v);
  return v.f;
}


static void gotostat (LexState *ls, int pc) {
  int line = ls->linenumber;
  TString *label;
  int g;
  if (testnext(ls, TK_GOTO))
    label = str_checkname(ls);
  else {
    luaX_next(ls);  /* skip break */
    label = luaS_new(ls->L, "break");
  }
  g = newlabelentry(ls, &ls->dyd->gt, label, line, pc);
  findlabel(ls, g);  /* close it if label already defined */
}


/* check for repeated labels on the same block */
static void checkrepeated (FuncState *fs, Labellist *ll, TString *label) {
  int i;
  for (i = fs->bl->firstlabel; i < ll->n; i++) {
    if (eqstr(label, ll->arr[i].name)) {
      const char *msg = luaO_pushfstring(fs->ls->L,
                          "label '%s' already defined on line %d",
                          getstr(label), ll->arr[i].line);
      semerror(fs->ls, msg);
    }
  }
}


/* skip no-op statements */
static void skipnoopstat (LexState *ls) {
  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)
    statement(ls);
}


static void labelstat (LexState *ls, TString *label, int line) {
  /* label -> '::' NAME '::' */
  FuncState *fs = ls->fs;
  Labellist *ll = &ls->dyd->label;
  int l;  /* index of new label being created */
  checkrepeated(fs, ll, label);  /* check for repeated labels */
  checknext(ls, TK_DBCOLON);  /* skip double colon */
  /* create new entry for this label */
  l = newlabelentry(ls, ll, label, line, luaK_getlabel(fs));
  skipnoopstat(ls);  /* skip other no-op statements */
  if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */
    /* assume that locals are already out of scope */
    ll->arr[l].nactvar = fs->bl->nactvar;
  }
  findgotos(ls, &ll->arr[l]);
}


static void whilestat (LexState *ls, int line) {
  /* whilestat -> WHILE cond DO block END */
  FuncState *fs = ls->fs;
  int whileinit;
  int condexit;
  BlockCnt bl;
  luaX_next(ls);  /* skip WHILE */
  whileinit = luaK_getlabel(fs);
  condexit = cond(ls);
  enterblock(fs, &bl, 1);
  checknext(ls, TK_DO);
  block(ls);
  luaK_jumpto(fs, whileinit);
  check_match(ls, TK_END, TK_WHILE, line);
  leaveblock(fs);
  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
}


static void repeatstat (LexState *ls, int line) {
  /* repeatstat -> REPEAT block UNTIL cond */
  int condexit;
  FuncState *fs = ls->fs;
  int repeat_init = luaK_getlabel(fs);
  BlockCnt bl1, bl2;
  enterblock(fs, &bl1, 1);  /* loop block */
  enterblock(fs, &bl2, 0);  /* scope block */
  luaX_next(ls);  /* skip REPEAT */
  statlist(ls);
  check_match(ls, TK_UNTIL, TK_REPEAT, line);
  condexit = cond(ls);  /* read condition (inside scope block) */
  if (bl2.upval)  /* upvalues? */
    luaK_patchclose(fs, condexit, bl2.nactvar);
  leaveblock(fs);  /* finish scope */
  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */
  leaveblock(fs);  /* finish loop */
}


static int exp1 (LexState *ls) {
  expdesc e;
  int reg;
  expr(ls, &e);
  luaK_exp2nextreg(ls->fs, &e);
  lua_assert(e.k == VNONRELOC);
  reg = e.u.info;
  return reg;
}


static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
  /* forbody -> DO block */
  BlockCnt bl;
  FuncState *fs = ls->fs;
  int prep, endfor;
  adjustlocalvars(ls, 3);  /* control variables */
  checknext(ls, TK_DO);
  prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
  enterblock(fs, &bl, 0);  /* scope for declared variables */
  adjustlocalvars(ls, nvars);
  luaK_reserveregs(fs, nvars);
  block(ls);
  leaveblock(fs);  /* end of scope for declared variables */
  luaK_patchtohere(fs, prep);
  if (isnum)  /* numeric for? */
    endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);
  else {  /* generic for */
    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);
    luaK_fixline(fs, line);
    endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);
  }
  luaK_patchlist(fs, endfor, prep + 1);
  luaK_fixline(fs, line);
}


static void fornum (LexState *ls, TString *varname, int line) {
  /* fornum -> NAME = exp1,exp1[,exp1] forbody */
  FuncState *fs = ls->fs;
  int base = fs->freereg;
  new_localvarliteral(ls, "(for index)");
  new_localvarliteral(ls, "(for limit)");
  new_localvarliteral(ls, "(for step)");
  new_localvar(ls, varname);
  checknext(ls, '=');
  exp1(ls);  /* initial value */
  checknext(ls, ',');
  exp1(ls);  /* limit */
  if (testnext(ls, ','))
    exp1(ls);  /* optional step */
  else {  /* default step = 1 */
    luaK_codek(fs, fs->freereg, luaK_intK(fs, 1));
    luaK_reserveregs(fs, 1);
  }
  forbody(ls, base, line, 1, 1);
}


static void forlist (LexState *ls, TString *indexname) {
  /* forlist -> NAME {,NAME} IN explist forbody */
  FuncState *fs = ls->fs;
  expdesc e;
  int nvars = 4;  /* gen, state, control, plus at least one declared var */
  int line;
  int base = fs->freereg;
  /* create control variables */
  new_localvarliteral(ls, "(for generator)");
  new_localvarliteral(ls, "(for state)");
  new_localvarliteral(ls, "(for control)");
  /* create declared variables */
  new_localvar(ls, indexname);
  while (testnext(ls, ',')) {
    new_localvar(ls, str_checkname(ls));
    nvars++;
  }
  checknext(ls, TK_IN);
  line = ls->linenumber;
  adjust_assign(ls, 3, explist(ls, &e), &e);
  luaK_checkstack(fs, 3);  /* extra space to call generator */
  forbody(ls, base, line, nvars - 3, 0);
}


static void forstat (LexState *ls, int line) {
  /* forstat -> FOR (fornum | forlist) END */
  FuncState *fs = ls->fs;
  TString *varname;
  BlockCnt bl;
  enterblock(fs, &bl, 1);  /* scope for loop and control variables */
  luaX_next(ls);  /* skip 'for' */
  varname = str_checkname(ls);  /* first variable name */
  switch (ls->t.token) {
    case '=': fornum(ls, varname, line); break;
    case ',': case TK_IN: forlist(ls, varname); break;
    default: luaX_syntaxerror(ls, "'=' or 'in' expected");
  }
  check_match(ls, TK_END, TK_FOR, line);
  leaveblock(fs);  /* loop scope ('break' jumps to this point) */
}


static void test_then_block (LexState *ls, int *escapelist) {
  /* test_then_block -> [IF | ELSEIF] cond THEN block */
  BlockCnt bl;
  FuncState *fs = ls->fs;
  expdesc v;
  int jf;  /* instruction to skip 'then' code (if condition is false) */
  luaX_next(ls);  /* skip IF or ELSEIF */
  expr(ls, &v);  /* read condition */
  checknext(ls, TK_THEN);
  if (ls->t.token == TK_GOTO || ls->t.token == TK_BREAK) {
    luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */
    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */
    gotostat(ls, v.t);  /* handle goto/break */
    skipnoopstat(ls);  /* skip other no-op statements */
    if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */
      leaveblock(fs);
      return;  /* and that is it */
    }
    else  /* must skip over 'then' part if condition is false */
      jf = luaK_jump(fs);
  }
  else {  /* regular case (not goto/break) */
    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */
    enterblock(fs, &bl, 0);
    jf = v.f;
  }
  statlist(ls);  /* 'then' part */
  leaveblock(fs);
  if (ls->t.token == TK_ELSE ||
      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */
    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */
  luaK_patchtohere(fs, jf);
}


static void ifstat (LexState *ls, int line) {
  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  FuncState *fs = ls->fs;
  int escapelist = NO_JUMP;  /* exit list for finished parts */
  test_then_block(ls, &escapelist);  /* IF cond THEN block */
  while (ls->t.token == TK_ELSEIF)
    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */
  if (testnext(ls, TK_ELSE))
    block(ls);  /* 'else' part */
  check_match(ls, TK_END, TK_IF, line);
  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */
}


static void localfunc (LexState *ls) {
  expdesc b;
  FuncState *fs = ls->fs;
  new_localvar(ls, str_checkname(ls));  /* new local variable */
  adjustlocalvars(ls, 1);  /* enter its scope */
  body(ls, &b, 0, ls->linenumber);  /* function created in next register */
  /* debug information will only see the variable after this point! */
  getlocvar(fs, b.u.info)->startpc = fs->pc;
}


static void localstat (LexState *ls) {
  /* stat -> LOCAL NAME {',' NAME} ['=' explist] */
  int nvars = 0;
  int nexps;
  expdesc e;
  do {
    new_localvar(ls, str_checkname(ls));
    nvars++;
  } while (testnext(ls, ','));
  if (testnext(ls, '='))
    nexps = explist(ls, &e);
  else {
    e.k = VVOID;
    nexps = 0;
  }
  adjust_assign(ls, nvars, nexps, &e);
  adjustlocalvars(ls, nvars);
}


static int funcname (LexState *ls, expdesc *v) {
  /* funcname -> NAME {fieldsel} [':' NAME] */
  int ismethod = 0;
  singlevar(ls, v);
  while (ls->t.token == '.')
    fieldsel(ls, v);
  if (ls->t.token == ':') {
    ismethod = 1;
    fieldsel(ls, v);
  }
  return ismethod;
}


static void funcstat (LexState *ls, int line) {
  /* funcstat -> FUNCTION funcname body */
  int ismethod;
  expdesc v, b;
  luaX_next(ls);  /* skip FUNCTION */
  ismethod = funcname(ls, &v);
  body(ls, &b, ismethod, line);
  luaK_storevar(ls->fs, &v, &b);
  luaK_fixline(ls->fs, line);  /* definition "happens" in the first line */
}


static void exprstat (LexState *ls) {
  /* stat -> func | assignment */
  FuncState *fs = ls->fs;
  struct LHS_assign v;
  suffixedexp(ls, &v.v);
  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */
    v.prev = NULL;
    assignment(ls, &v, 1);
  }
  else {  /* stat -> func */
    check_condition(ls, v.v.k == VCALL, "syntax error");
    SETARG_C(getinstruction(fs, &v.v), 1);  /* call statement uses no results */
  }
}


static void retstat (LexState *ls) {
  /* stat -> RETURN [explist] [';'] */
  FuncState *fs = ls->fs;
  expdesc e;
  int first, nret;  /* registers with returned values */
  if (block_follow(ls, 1) || ls->t.token == ';')
    first = nret = 0;  /* return no values */
  else {
    nret = explist(ls, &e);  /* optional return values */
    if (hasmultret(e.k)) {
      luaK_setmultret(fs, &e);
      if (e.k == VCALL && nret == 1) {  /* tail call? */
        SET_OPCODE(getinstruction(fs,&e), OP_TAILCALL);
        lua_assert(GETARG_A(getinstruction(fs,&e)) == fs->nactvar);
      }
      first = fs->nactvar;
      nret = LUA_MULTRET;  /* return all values */
    }
    else {
      if (nret == 1)  /* only one single value? */
        first = luaK_exp2anyreg(fs, &e);
      else {
        luaK_exp2nextreg(fs, &e);  /* values must go to the stack */
        first = fs->nactvar;  /* return all active values */
        lua_assert(nret == fs->freereg - first);
      }
    }
  }
  luaK_ret(fs, first, nret);
  testnext(ls, ';');  /* skip optional semicolon */
}


static void statement (LexState *ls) {
  int line = ls->linenumber;  /* may be needed for error messages */
  enterlevel(ls);
  switch (ls->t.token) {
    case ';': {  /* stat -> ';' (empty statement) */
      luaX_next(ls);  /* skip ';' */
      break;
    }
    case TK_IF: {  /* stat -> ifstat */
      ifstat(ls, line);
      break;
    }
    case TK_WHILE: {  /* stat -> whilestat */
      whilestat(ls, line);
      break;
    }
    case TK_DO: {  /* stat -> DO block END */
      luaX_next(ls);  /* skip DO */
      block(ls);
      check_match(ls, TK_END, TK_DO, line);
      break;
    }
    case TK_FOR: {  /* stat -> forstat */
      forstat(ls, line);
      break;
    }
    case TK_REPEAT: {  /* stat -> repeatstat */
      repeatstat(ls, line);
      break;
    }
    case TK_FUNCTION: {  /* stat -> funcstat */
      funcstat(ls, line);
      break;
    }
    case TK_LOCAL: {  /* stat -> localstat */
      luaX_next(ls);  /* skip LOCAL */
      if (testnext(ls, TK_FUNCTION))  /* local function? */
        localfunc(ls);
      else
        localstat(ls);
      break;
    }
    case TK_DBCOLON: {  /* stat -> label */
      luaX_next(ls);  /* skip double colon */
      labelstat(ls, str_checkname(ls), line);
      break;
    }
    case TK_RETURN: {  /* stat -> retstat */
      luaX_next(ls);  /* skip RETURN */
      retstat(ls);
      break;
    }
    case TK_BREAK:   /* stat -> breakstat */
    case TK_GOTO: {  /* stat -> 'goto' NAME */
      gotostat(ls, luaK_jump(ls->fs));
      break;
    }
    default: {  /* stat -> func | assignment */
      exprstat(ls);
      break;
    }
  }
  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&
             ls->fs->freereg >= ls->fs->nactvar);
  ls->fs->freereg = ls->fs->nactvar;  /* free registers */
  leavelevel(ls);
}

/* }====================================================================== */


/*
** compiles the main function, which is a regular vararg function with an
** upvalue named LUA_ENV
*/
static void mainfunc (LexState *ls, FuncState *fs) {
  BlockCnt bl;
  expdesc v;
  open_func(ls, fs, &bl);
  fs->f->is_vararg = 1;  /* main function is always declared vararg */
  init_exp(&v, VLOCAL, 0);  /* create and... */
  newupvalue(fs, ls->envn, &v);  /* ...set environment upvalue */
  luaX_next(ls);  /* read first token */
  statlist(ls);  /* parse main body */
  check(ls, TK_EOS);
  close_func(ls);
}


LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
                       Dyndata *dyd, const char *name, int firstchar) {
  LexState lexstate;
  FuncState funcstate;
  LClosure *cl = luaF_newLclosure(L, 1);  /* create main closure */
  setclLvalue(L, L->top, cl);  /* anchor it (to avoid being collected) */
  luaD_inctop(L);
  lexstate.h = luaH_new(L);  /* create table for scanner */
  sethvalue(L, L->top, lexstate.h);  /* anchor it */
  luaD_inctop(L);
  funcstate.f = cl->p = luaF_newproto(L);
  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */
  lua_assert(iswhite(funcstate.f));  /* do not need barrier here */
  lexstate.buff = buff;
  lexstate.dyd = dyd;
  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);
  mainfunc(&lexstate, &funcstate);
  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);
  /* all scopes should be correctly finished */
  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);
  L->top--;  /* remove scanner's table */
  return cl;  /* closure is on the stack, too */
}


```

`src/Lua/lparser.h`:

```h
/*
** $Id: lparser.h,v 1.76 2015/12/30 18:16:13 roberto Exp $
** Lua Parser
** See Copyright Notice in lua.h
*/

#ifndef lparser_h
#define lparser_h

#include "llimits.h"
#include "lobject.h"
#include "lzio.h"


/*
** Expression and variable descriptor.
** Code generation for variables and expressions can be delayed to allow
** optimizations; An 'expdesc' structure describes a potentially-delayed
** variable/expression. It has a description of its "main" value plus a
** list of conditional jumps that can also produce its value (generated
** by short-circuit operators 'and'/'or').
*/

/* kinds of variables/expressions */
typedef enum {
  VVOID,  /* when 'expdesc' describes the last expression a list,
             this kind means an empty list (so, no expression) */
  VNIL,  /* constant nil */
  VTRUE,  /* constant true */
  VFALSE,  /* constant false */
  VK,  /* constant in 'k'; info = index of constant in 'k' */
  VKFLT,  /* floating constant; nval = numerical float value */
  VKINT,  /* integer constant; nval = numerical integer value */
  VNONRELOC,  /* expression has its value in a fixed register;
                 info = result register */
  VLOCAL,  /* local variable; info = local register */
  VUPVAL,  /* upvalue variable; info = index of upvalue in 'upvalues' */
  VINDEXED,  /* indexed variable;
                ind.vt = whether 't' is register or upvalue;
                ind.t = table register or upvalue;
                ind.idx = key's R/K index */
  VJMP,  /* expression is a test/comparison;
            info = pc of corresponding jump instruction */
  VRELOCABLE,  /* expression can put result in any register;
                  info = instruction pc */
  VCALL,  /* expression is a function call; info = instruction pc */
  VVARARG  /* vararg expression; info = instruction pc */
} expkind;


#define vkisvar(k)	(VLOCAL <= (k) && (k) <= VINDEXED)
#define vkisinreg(k)	((k) == VNONRELOC || (k) == VLOCAL)

typedef struct expdesc {
  expkind k;
  union {
    lua_Integer ival;    /* for VKINT */
    lua_Number nval;  /* for VKFLT */
    int info;  /* for generic use */
    struct {  /* for indexed variables (VINDEXED) */
      short idx;  /* index (R/K) */
      lu_byte t;  /* table (register or upvalue) */
      lu_byte vt;  /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */
    } ind;
  } u;
  int t;  /* patch list of 'exit when true' */
  int f;  /* patch list of 'exit when false' */
} expdesc;


/* description of active local variable */
typedef struct Vardesc {
  short idx;  /* variable index in stack */
} Vardesc;


/* description of pending goto statements and label statements */
typedef struct Labeldesc {
  TString *name;  /* label identifier */
  int pc;  /* position in code */
  int line;  /* line where it appeared */
  lu_byte nactvar;  /* local level where it appears in current block */
} Labeldesc;


/* list of labels or gotos */
typedef struct Labellist {
  Labeldesc *arr;  /* array */
  int n;  /* number of entries in use */
  int size;  /* array size */
} Labellist;


/* dynamic structures used by the parser */
typedef struct Dyndata {
  struct {  /* list of active local variables */
    Vardesc *arr;
    int n;
    int size;
  } actvar;
  Labellist gt;  /* list of pending gotos */
  Labellist label;   /* list of active labels */
} Dyndata;


/* control of blocks */
struct BlockCnt;  /* defined in lparser.c */


/* state needed to generate code for a given function */
typedef struct FuncState {
  Proto *f;  /* current function header */
  struct FuncState *prev;  /* enclosing function */
  struct LexState *ls;  /* lexical state */
  struct BlockCnt *bl;  /* chain of current blocks */
  int pc;  /* next position to code (equivalent to 'ncode') */
  int lasttarget;   /* 'label' of last 'jump label' */
  int jpc;  /* list of pending jumps to 'pc' */
  int nk;  /* number of elements in 'k' */
  int np;  /* number of elements in 'p' */
  int firstlocal;  /* index of first local var (in Dyndata array) */
  short nlocvars;  /* number of elements in 'f->locvars' */
  lu_byte nactvar;  /* number of active local variables */
  lu_byte nups;  /* number of upvalues */
  lu_byte freereg;  /* first free register */
} FuncState;


LUAI_FUNC LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
                                 Dyndata *dyd, const char *name, int firstchar);


#endif

```

`src/Lua/lprefix.h`:

```h
/*
** $Id: lprefix.h,v 1.2 2014/12/29 16:54:13 roberto Exp $
** Definitions for Lua code that must come before any other header file
** See Copyright Notice in lua.h
*/

#ifndef lprefix_h
#define lprefix_h


/*
** Allows POSIX/XSI stuff
*/
#if !defined(LUA_USE_C89)	/* { */

#if !defined(_XOPEN_SOURCE)
#define _XOPEN_SOURCE           600
#elif _XOPEN_SOURCE == 0
#undef _XOPEN_SOURCE  /* use -D_XOPEN_SOURCE=0 to undefine it */
#endif

/*
** Allows manipulation of large files in gcc and some other compilers
*/
#if !defined(LUA_32BITS) && !defined(_FILE_OFFSET_BITS)
#define _LARGEFILE_SOURCE       1
#define _FILE_OFFSET_BITS       64
#endif

#endif				/* } */


/*
** Windows stuff
*/
#if defined(_WIN32) 	/* { */

#if !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS  /* avoid warnings about ISO C functions */
#endif

#endif			/* } */

#endif


```

`src/Lua/lstate.c`:

```c
/*
** $Id: lstate.c,v 2.133 2015/11/13 12:16:51 roberto Exp $
** Global State
** See Copyright Notice in lua.h
*/

#define lstate_c
#define LUA_CORE

#include "lprefix.h"


#include <stddef.h>
#include <string.h>

#include "lua.h"

#include "lapi.h"
#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lgc.h"
#include "llex.h"
#include "lmem.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"


#if !defined(LUAI_GCPAUSE)
#define LUAI_GCPAUSE	200  /* 200% */
#endif

#if !defined(LUAI_GCMUL)
#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */
#endif


/*
** a macro to help the creation of a unique random seed when a state is
** created; the seed is used to randomize hashes.
*/
#if !defined(luai_makeseed)
#include <time.h>
#define luai_makeseed()		cast(unsigned int, time(NULL))
#endif



/*
** thread state + extra space
*/
typedef struct LX {
  lu_byte extra_[LUA_EXTRASPACE];
  lua_State l;
} LX;


/*
** Main thread combines a thread state and the global state
*/
typedef struct LG {
  LX l;
  global_State g;
} LG;



#define fromstate(L)	(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))


/*
** Compute an initial seed as random as possible. Rely on Address Space
** Layout Randomization (if present) to increase randomness..
*/
#define addbuff(b,p,e) \
  { size_t t = cast(size_t, e); \
    memcpy(b + p, &t, sizeof(t)); p += sizeof(t); }

static unsigned int makeseed (lua_State *L) {
  char buff[4 * sizeof(size_t)];
  unsigned int h = luai_makeseed();
  int p = 0;
  addbuff(buff, p, L);  /* heap variable */
  addbuff(buff, p, &h);  /* local variable */
  addbuff(buff, p, luaO_nilobject);  /* global variable */
  addbuff(buff, p, &lua_newstate);  /* public function */
  lua_assert(p == sizeof(buff));
  return luaS_hash(buff, p, h);
}


/*
** set GCdebt to a new value keeping the value (totalbytes + GCdebt)
** invariant (and avoiding underflows in 'totalbytes')
*/
void luaE_setdebt (global_State *g, l_mem debt) {
  l_mem tb = gettotalbytes(g);
  lua_assert(tb > 0);
  if (debt < tb - MAX_LMEM)
    debt = tb - MAX_LMEM;  /* will make 'totalbytes == MAX_LMEM' */
  g->totalbytes = tb - debt;
  g->GCdebt = debt;
}


CallInfo *luaE_extendCI (lua_State *L) {
  CallInfo *ci = luaM_new(L, CallInfo);
  lua_assert(L->ci->next == NULL);
  L->ci->next = ci;
  ci->previous = L->ci;
  ci->next = NULL;
  L->nci++;
  return ci;
}


/*
** free all CallInfo structures not in use by a thread
*/
void luaE_freeCI (lua_State *L) {
  CallInfo *ci = L->ci;
  CallInfo *next = ci->next;
  ci->next = NULL;
  while ((ci = next) != NULL) {
    next = ci->next;
    luaM_free(L, ci);
    L->nci--;
  }
}


/*
** free half of the CallInfo structures not in use by a thread
*/
void luaE_shrinkCI (lua_State *L) {
  CallInfo *ci = L->ci;
  CallInfo *next2;  /* next's next */
  /* while there are two nexts */
  while (ci->next != NULL && (next2 = ci->next->next) != NULL) {
    luaM_free(L, ci->next);  /* free next */
    L->nci--;
    ci->next = next2;  /* remove 'next' from the list */
    next2->previous = ci;
    ci = next2;  /* keep next's next */
  }
}


static void stack_init (lua_State *L1, lua_State *L) {
  int i; CallInfo *ci;
  /* initialize stack array */
  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE, TValue);
  L1->stacksize = BASIC_STACK_SIZE;
  for (i = 0; i < BASIC_STACK_SIZE; i++)
    setnilvalue(L1->stack + i);  /* erase new stack */
  L1->top = L1->stack;
  L1->stack_last = L1->stack + L1->stacksize - EXTRA_STACK;
  /* initialize first ci */
  ci = &L1->base_ci;
  ci->next = ci->previous = NULL;
  ci->callstatus = 0;
  ci->func = L1->top;
  setnilvalue(L1->top++);  /* 'function' entry for this 'ci' */
  ci->top = L1->top + LUA_MINSTACK;
  L1->ci = ci;
}


static void freestack (lua_State *L) {
  if (L->stack == NULL)
    return;  /* stack not completely built yet */
  L->ci = &L->base_ci;  /* free the entire 'ci' list */
  luaE_freeCI(L);
  lua_assert(L->nci == 0);
  luaM_freearray(L, L->stack, L->stacksize);  /* free stack array */
}


/*
** Create registry table and its predefined values
*/
static void init_registry (lua_State *L, global_State *g) {
  TValue temp;
  /* create registry */
  Table *registry = luaH_new(L);
  sethvalue(L, &g->l_registry, registry);
  luaH_resize(L, registry, LUA_RIDX_LAST, 0);
  /* registry[LUA_RIDX_MAINTHREAD] = L */
  setthvalue(L, &temp, L);  /* temp = L */
  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &temp);
  /* registry[LUA_RIDX_GLOBALS] = table of globals */
  sethvalue(L, &temp, luaH_new(L));  /* temp = new table (global table) */
  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &temp);
}


/*
** open parts of the state that may cause memory-allocation errors.
** ('g->version' != NULL flags that the state was completely build)
*/
static void f_luaopen (lua_State *L, void *ud) {
  global_State *g = G(L);
  UNUSED(ud);
  stack_init(L, L);  /* init stack */
  init_registry(L, g);
  luaS_init(L);
  luaT_init(L);
  luaX_init(L);
  g->gcrunning = 1;  /* allow gc */
  g->version = lua_version(NULL);
  luai_userstateopen(L);
}


/*
** preinitialize a thread with consistent values without allocating
** any memory (to avoid errors)
*/
static void preinit_thread (lua_State *L, global_State *g) {
  G(L) = g;
  L->stack = NULL;
  L->ci = NULL;
  L->nci = 0;
  L->stacksize = 0;
  L->twups = L;  /* thread has no upvalues */
  L->errorJmp = NULL;
  L->nCcalls = 0;
  L->hook = NULL;
  L->hookmask = 0;
  L->basehookcount = 0;
  L->allowhook = 1;
  resethookcount(L);
  L->openupval = NULL;
  L->nny = 1;
  L->status = LUA_OK;
  L->errfunc = 0;
}


static void close_state (lua_State *L) {
  global_State *g = G(L);
  luaF_close(L, L->stack);  /* close all upvalues for this thread */
  luaC_freeallobjects(L);  /* collect all objects */
  if (g->version)  /* closing a fully built state? */
    luai_userstateclose(L);
  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);
  freestack(L);
  lua_assert(gettotalbytes(g) == sizeof(LG));
  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */
}


LUA_API lua_State *lua_newthread (lua_State *L) {
  global_State *g = G(L);
  lua_State *L1;
  lua_lock(L);
  luaC_checkGC(L);
  /* create new thread */
  L1 = &cast(LX *, luaM_newobject(L, LUA_TTHREAD, sizeof(LX)))->l;
  L1->marked = luaC_white(g);
  L1->tt = LUA_TTHREAD;
  /* link it on list 'allgc' */
  L1->next = g->allgc;
  g->allgc = obj2gco(L1);
  /* anchor it on L stack */
  setthvalue(L, L->top, L1);
  api_incr_top(L);
  preinit_thread(L1, g);
  L1->hookmask = L->hookmask;
  L1->basehookcount = L->basehookcount;
  L1->hook = L->hook;
  resethookcount(L1);
  /* initialize L1 extra space */
  memcpy(lua_getextraspace(L1), lua_getextraspace(g->mainthread),
         LUA_EXTRASPACE);
  luai_userstatethread(L, L1);
  stack_init(L1, L);  /* init stack */
  lua_unlock(L);
  return L1;
}


void luaE_freethread (lua_State *L, lua_State *L1) {
  LX *l = fromstate(L1);
  luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
  lua_assert(L1->openupval == NULL);
  luai_userstatefree(L, L1);
  freestack(L1);
  luaM_free(L, l);
}


LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
  int i;
  lua_State *L;
  global_State *g;
  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
  if (l == NULL) return NULL;
  L = &l->l.l;
  g = &l->g;
  L->next = NULL;
  L->tt = LUA_TTHREAD;
  g->currentwhite = bitmask(WHITE0BIT);
  L->marked = luaC_white(g);
  preinit_thread(L, g);
  g->frealloc = f;
  g->ud = ud;
  g->mainthread = L;
  g->seed = makeseed(L);
  g->gcrunning = 0;  /* no GC while building state */
  g->GCestimate = 0;
  g->strt.size = g->strt.nuse = 0;
  g->strt.hash = NULL;
  setnilvalue(&g->l_registry);
  g->panic = NULL;
  g->version = NULL;
  g->gcstate = GCSpause;
  g->gckind = KGC_NORMAL;
  g->allgc = g->finobj = g->tobefnz = g->fixedgc = NULL;
  g->sweepgc = NULL;
  g->gray = g->grayagain = NULL;
  g->weak = g->ephemeron = g->allweak = NULL;
  g->twups = NULL;
  g->totalbytes = sizeof(LG);
  g->GCdebt = 0;
  g->gcfinnum = 0;
  g->gcpause = LUAI_GCPAUSE;
  g->gcstepmul = LUAI_GCMUL;
  for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;
  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
    /* memory allocation error: free partial state */
    close_state(L);
    L = NULL;
  }
  return L;
}


LUA_API void lua_close (lua_State *L) {
  L = G(L)->mainthread;  /* only the main thread can be closed */
  lua_lock(L);
  close_state(L);
}



```

`src/Lua/lstate.h`:

```h
/*
** $Id: lstate.h,v 2.133 2016/12/22 13:08:50 roberto Exp $
** Global State
** See Copyright Notice in lua.h
*/

#ifndef lstate_h
#define lstate_h

#include "lua.h"

#include "lobject.h"
#include "ltm.h"
#include "lzio.h"


/*

** Some notes about garbage-collected objects: All objects in Lua must
** be kept somehow accessible until being freed, so all objects always
** belong to one (and only one) of these lists, using field 'next' of
** the 'CommonHeader' for the link:
**
** 'allgc': all objects not marked for finalization;
** 'finobj': all objects marked for finalization;
** 'tobefnz': all objects ready to be finalized;
** 'fixedgc': all objects that are not to be collected (currently
** only small strings, such as reserved words).

*/


struct lua_longjmp;  /* defined in ldo.c */


/*
** Atomic type (relative to signals) to better ensure that 'lua_sethook'
** is thread safe
*/
#if !defined(l_signalT)
#include <signal.h>
#define l_signalT	sig_atomic_t
#endif


/* extra stack space to handle TM calls and some other extras */
#define EXTRA_STACK   5


#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)


/* kinds of Garbage Collection */
#define KGC_NORMAL	0
#define KGC_EMERGENCY	1	/* gc was forced by an allocation failure */


typedef struct stringtable {
  TString **hash;
  int nuse;  /* number of elements */
  int size;
} stringtable;


/*
** Information about a call.
** When a thread yields, 'func' is adjusted to pretend that the
** top function has only the yielded values in its stack; in that
** case, the actual 'func' value is saved in field 'extra'.
** When a function calls another with a continuation, 'extra' keeps
** the function index so that, in case of errors, the continuation
** function can be called with the correct top.
*/
typedef struct CallInfo {
  StkId func;  /* function index in the stack */
  StkId	top;  /* top for this function */
  struct CallInfo *previous, *next;  /* dynamic call link */
  union {
    struct {  /* only for Lua functions */
      StkId base;  /* base for this function */
      const Instruction *savedpc;
    } l;
    struct {  /* only for C functions */
      lua_KFunction k;  /* continuation in case of yields */
      ptrdiff_t old_errfunc;
      lua_KContext ctx;  /* context info. in case of yields */
    } c;
  } u;
  ptrdiff_t extra;
  short nresults;  /* expected number of results from this function */
  unsigned short callstatus;
} CallInfo;


/*
** Bits in CallInfo status
*/
#define CIST_OAH	(1<<0)	/* original value of 'allowhook' */
#define CIST_LUA	(1<<1)	/* call is running a Lua function */
#define CIST_HOOKED	(1<<2)	/* call is running a debug hook */
#define CIST_FRESH	(1<<3)	/* call is running on a fresh invocation
                                   of luaV_execute */
#define CIST_YPCALL	(1<<4)	/* call is a yieldable protected call */
#define CIST_TAIL	(1<<5)	/* call was tail called */
#define CIST_HOOKYIELD	(1<<6)	/* last hook called yielded */
#define CIST_LEQ	(1<<7)  /* using __lt for __le */
#define CIST_FIN	(1<<8)  /* call is running a finalizer */

#define isLua(ci)	((ci)->callstatus & CIST_LUA)

/* assume that CIST_OAH has offset 0 and that 'v' is strictly 0/1 */
#define setoah(st,v)	((st) = ((st) & ~CIST_OAH) | (v))
#define getoah(st)	((st) & CIST_OAH)


/*
** 'global state', shared by all threads of this state
*/
typedef struct global_State {
  lua_Alloc frealloc;  /* function to reallocate memory */
  void *ud;         /* auxiliary data to 'frealloc' */
  l_mem totalbytes;  /* number of bytes currently allocated - GCdebt */
  l_mem GCdebt;  /* bytes allocated not yet compensated by the collector */
  lu_mem GCmemtrav;  /* memory traversed by the GC */
  lu_mem GCestimate;  /* an estimate of the non-garbage memory in use */
  stringtable strt;  /* hash table for strings */
  TValue l_registry;
  unsigned int seed;  /* randomized seed for hashes */
  lu_byte currentwhite;
  lu_byte gcstate;  /* state of garbage collector */
  lu_byte gckind;  /* kind of GC running */
  lu_byte gcrunning;  /* true if GC is running */
  GCObject *allgc;  /* list of all collectable objects */
  GCObject **sweepgc;  /* current position of sweep in list */
  GCObject *finobj;  /* list of collectable objects with finalizers */
  GCObject *gray;  /* list of gray objects */
  GCObject *grayagain;  /* list of objects to be traversed atomically */
  GCObject *weak;  /* list of tables with weak values */
  GCObject *ephemeron;  /* list of ephemeron tables (weak keys) */
  GCObject *allweak;  /* list of all-weak tables */
  GCObject *tobefnz;  /* list of userdata to be GC */
  GCObject *fixedgc;  /* list of objects not to be collected */
  struct lua_State *twups;  /* list of threads with open upvalues */
  unsigned int gcfinnum;  /* number of finalizers to call in each GC step */
  int gcpause;  /* size of pause between successive GCs */
  int gcstepmul;  /* GC 'granularity' */
  lua_CFunction panic;  /* to be called in unprotected errors */
  struct lua_State *mainthread;
  const lua_Number *version;  /* pointer to version number */
  TString *memerrmsg;  /* memory-error message */
  TString *tmname[TM_N];  /* array with tag-method names */
  struct Table *mt[LUA_NUMTAGS];  /* metatables for basic types */
  TString *strcache[STRCACHE_N][STRCACHE_M];  /* cache for strings in API */
} global_State;


/*
** 'per thread' state
*/
struct lua_State {
  CommonHeader;
  unsigned short nci;  /* number of items in 'ci' list */
  lu_byte status;
  StkId top;  /* first free slot in the stack */
  global_State *l_G;
  CallInfo *ci;  /* call info for current function */
  const Instruction *oldpc;  /* last pc traced */
  StkId stack_last;  /* last free slot in the stack */
  StkId stack;  /* stack base */
  UpVal *openupval;  /* list of open upvalues in this stack */
  GCObject *gclist;
  struct lua_State *twups;  /* list of threads with open upvalues */
  struct lua_longjmp *errorJmp;  /* current error recover point */
  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
  volatile lua_Hook hook;
  ptrdiff_t errfunc;  /* current error handling function (stack index) */
  int stacksize;
  int basehookcount;
  int hookcount;
  unsigned short nny;  /* number of non-yieldable calls in stack */
  unsigned short nCcalls;  /* number of nested C calls */
  l_signalT hookmask;
  lu_byte allowhook;
};


#define G(L)	(L->l_G)


/*
** Union of all collectable objects (only for conversions)
*/
union GCUnion {
  GCObject gc;  /* common header */
  struct TString ts;
  struct Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct lua_State th;  /* thread */
};


#define cast_u(o)	cast(union GCUnion *, (o))

/* macros to convert a GCObject into a specific value */
#define gco2ts(o)  \
	check_exp(novariant((o)->tt) == LUA_TSTRING, &((cast_u(o))->ts))
#define gco2u(o)  check_exp((o)->tt == LUA_TUSERDATA, &((cast_u(o))->u))
#define gco2lcl(o)  check_exp((o)->tt == LUA_TLCL, &((cast_u(o))->cl.l))
#define gco2ccl(o)  check_exp((o)->tt == LUA_TCCL, &((cast_u(o))->cl.c))
#define gco2cl(o)  \
	check_exp(novariant((o)->tt) == LUA_TFUNCTION, &((cast_u(o))->cl))
#define gco2t(o)  check_exp((o)->tt == LUA_TTABLE, &((cast_u(o))->h))
#define gco2p(o)  check_exp((o)->tt == LUA_TPROTO, &((cast_u(o))->p))
#define gco2th(o)  check_exp((o)->tt == LUA_TTHREAD, &((cast_u(o))->th))


/* macro to convert a Lua object into a GCObject */
#define obj2gco(v) \
	check_exp(novariant((v)->tt) < LUA_TDEADKEY, (&(cast_u(v)->gc)))


/* actual number of total bytes allocated */
#define gettotalbytes(g)	cast(lu_mem, (g)->totalbytes + (g)->GCdebt)

LUAI_FUNC void luaE_setdebt (global_State *g, l_mem debt);
LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);
LUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);
LUAI_FUNC void luaE_freeCI (lua_State *L);
LUAI_FUNC void luaE_shrinkCI (lua_State *L);


#endif


```

`src/Lua/lstring.c`:

```c
/*
** $Id: lstring.c,v 2.56 2015/11/23 11:32:51 roberto Exp $
** String table (keeps all strings handled by Lua)
** See Copyright Notice in lua.h
*/

#define lstring_c
#define LUA_CORE

#include "lprefix.h"


#include <string.h>

#include "lua.h"

#include "ldebug.h"
#include "ldo.h"
#include "lmem.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"


#define MEMERRMSG       "not enough memory"


/*
** Lua will use at most ~(2^LUAI_HASHLIMIT) bytes from a string to
** compute its hash
*/
#if !defined(LUAI_HASHLIMIT)
#define LUAI_HASHLIMIT		5
#endif


/*
** equality for long strings
*/
int luaS_eqlngstr (TString *a, TString *b) {
  size_t len = a->u.lnglen;
  lua_assert(a->tt == LUA_TLNGSTR && b->tt == LUA_TLNGSTR);
  return (a == b) ||  /* same instance or... */
    ((len == b->u.lnglen) &&  /* equal length and ... */
     (memcmp(getstr(a), getstr(b), len) == 0));  /* equal contents */
}


unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {
  unsigned int h = seed ^ cast(unsigned int, l);
  size_t step = (l >> LUAI_HASHLIMIT) + 1;
  for (; l >= step; l -= step)
    h ^= ((h<<5) + (h>>2) + cast_byte(str[l - 1]));
  return h;
}


unsigned int luaS_hashlongstr (TString *ts) {
  lua_assert(ts->tt == LUA_TLNGSTR);
  if (ts->extra == 0) {  /* no hash? */
    ts->hash = luaS_hash(getstr(ts), ts->u.lnglen, ts->hash);
    ts->extra = 1;  /* now it has its hash */
  }
  return ts->hash;
}


/*
** resizes the string table
*/
void luaS_resize (lua_State *L, int newsize) {
  int i;
  stringtable *tb = &G(L)->strt;
  if (newsize > tb->size) {  /* grow table if needed */
    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString *);
    for (i = tb->size; i < newsize; i++)
      tb->hash[i] = NULL;
  }
  for (i = 0; i < tb->size; i++) {  /* rehash */
    TString *p = tb->hash[i];
    tb->hash[i] = NULL;
    while (p) {  /* for each node in the list */
      TString *hnext = p->u.hnext;  /* save next */
      unsigned int h = lmod(p->hash, newsize);  /* new position */
      p->u.hnext = tb->hash[h];  /* chain it */
      tb->hash[h] = p;
      p = hnext;
    }
  }
  if (newsize < tb->size) {  /* shrink table if needed */
    /* vanishing slice should be empty */
    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);
    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString *);
  }
  tb->size = newsize;
}


/*
** Clear API string cache. (Entries cannot be empty, so fill them with
** a non-collectable string.)
*/
void luaS_clearcache (global_State *g) {
  int i, j;
  for (i = 0; i < STRCACHE_N; i++)
    for (j = 0; j < STRCACHE_M; j++) {
    if (iswhite(g->strcache[i][j]))  /* will entry be collected? */
      g->strcache[i][j] = g->memerrmsg;  /* replace it with something fixed */
    }
}


/*
** Initialize the string table and the string cache
*/
void luaS_init (lua_State *L) {
  global_State *g = G(L);
  int i, j;
  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
  /* pre-create memory-error message */
  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);
  luaC_fix(L, obj2gco(g->memerrmsg));  /* it should never be collected */
  for (i = 0; i < STRCACHE_N; i++)  /* fill cache with valid strings */
    for (j = 0; j < STRCACHE_M; j++)
      g->strcache[i][j] = g->memerrmsg;
}



/*
** creates a new string object
*/
static TString *createstrobj (lua_State *L, size_t l, int tag, unsigned int h) {
  TString *ts;
  GCObject *o;
  size_t totalsize;  /* total size of TString object */
  totalsize = sizelstring(l);
  o = luaC_newobj(L, tag, totalsize);
  ts = gco2ts(o);
  ts->hash = h;
  ts->extra = 0;
  getstr(ts)[l] = '\0';  /* ending 0 */
  return ts;
}


TString *luaS_createlngstrobj (lua_State *L, size_t l) {
  TString *ts = createstrobj(L, l, LUA_TLNGSTR, G(L)->seed);
  ts->u.lnglen = l;
  return ts;
}


void luaS_remove (lua_State *L, TString *ts) {
  stringtable *tb = &G(L)->strt;
  TString **p = &tb->hash[lmod(ts->hash, tb->size)];
  while (*p != ts)  /* find previous element */
    p = &(*p)->u.hnext;
  *p = (*p)->u.hnext;  /* remove element from its list */
  tb->nuse--;
}


/*
** checks whether short string exists and reuses it or creates a new one
*/
static TString *internshrstr (lua_State *L, const char *str, size_t l) {
  TString *ts;
  global_State *g = G(L);
  unsigned int h = luaS_hash(str, l, g->seed);
  TString **list = &g->strt.hash[lmod(h, g->strt.size)];
  lua_assert(str != NULL);  /* otherwise 'memcmp'/'memcpy' are undefined */
  for (ts = *list; ts != NULL; ts = ts->u.hnext) {
    if (l == ts->shrlen &&
        (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {
      /* found! */
      if (isdead(g, ts))  /* dead (but not collected yet)? */
        changewhite(ts);  /* resurrect it */
      return ts;
    }
  }
  if (g->strt.nuse >= g->strt.size && g->strt.size <= MAX_INT/2) {
    luaS_resize(L, g->strt.size * 2);
    list = &g->strt.hash[lmod(h, g->strt.size)];  /* recompute with new size */
  }
  ts = createstrobj(L, l, LUA_TSHRSTR, h);
  memcpy(getstr(ts), str, l * sizeof(char));
  ts->shrlen = cast_byte(l);
  ts->u.hnext = *list;
  *list = ts;
  g->strt.nuse++;
  return ts;
}


/*
** new string (with explicit length)
*/
TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
  if (l <= LUAI_MAXSHORTLEN)  /* short string? */
    return internshrstr(L, str, l);
  else {
    TString *ts;
    if (l >= (MAX_SIZE - sizeof(TString))/sizeof(char))
      luaM_toobig(L);
    ts = luaS_createlngstrobj(L, l);
    memcpy(getstr(ts), str, l * sizeof(char));
    return ts;
  }
}


/*
** Create or reuse a zero-terminated string, first checking in the
** cache (using the string address as a key). The cache can contain
** only zero-terminated strings, so it is safe to use 'strcmp' to
** check hits.
*/
TString *luaS_new (lua_State *L, const char *str) {
  unsigned int i = point2uint(str) % STRCACHE_N;  /* hash */
  int j;
  TString **p = G(L)->strcache[i];
  for (j = 0; j < STRCACHE_M; j++) {
    if (strcmp(str, getstr(p[j])) == 0)  /* hit? */
      return p[j];  /* that is it */
  }
  /* normal route */
  for (j = STRCACHE_M - 1; j > 0; j--)
    p[j] = p[j - 1];  /* move out last element */
  /* new element is first in the list */
  p[0] = luaS_newlstr(L, str, strlen(str));
  return p[0];
}


Udata *luaS_newudata (lua_State *L, size_t s) {
  Udata *u;
  GCObject *o;
  if (s > MAX_SIZE - sizeof(Udata))
    luaM_toobig(L);
  o = luaC_newobj(L, LUA_TUSERDATA, sizeludata(s));
  u = gco2u(o);
  u->len = s;
  u->metatable = NULL;
  setuservalue(L, u, luaO_nilobject);
  return u;
}


```

`src/Lua/lstring.h`:

```h
/*
** $Id: lstring.h,v 1.61 2015/11/03 15:36:01 roberto Exp $
** String table (keep all strings handled by Lua)
** See Copyright Notice in lua.h
*/

#ifndef lstring_h
#define lstring_h

#include "lgc.h"
#include "lobject.h"
#include "lstate.h"


#define sizelstring(l)  (sizeof(union UTString) + ((l) + 1) * sizeof(char))

#define sizeludata(l)	(sizeof(union UUdata) + (l))
#define sizeudata(u)	sizeludata((u)->len)

#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
                                 (sizeof(s)/sizeof(char))-1))


/*
** test whether a string is a reserved word
*/
#define isreserved(s)	((s)->tt == LUA_TSHRSTR && (s)->extra > 0)


/*
** equality for short strings, which are always internalized
*/
#define eqshrstr(a,b)	check_exp((a)->tt == LUA_TSHRSTR, (a) == (b))


LUAI_FUNC unsigned int luaS_hash (const char *str, size_t l, unsigned int seed);
LUAI_FUNC unsigned int luaS_hashlongstr (TString *ts);
LUAI_FUNC int luaS_eqlngstr (TString *a, TString *b);
LUAI_FUNC void luaS_resize (lua_State *L, int newsize);
LUAI_FUNC void luaS_clearcache (global_State *g);
LUAI_FUNC void luaS_init (lua_State *L);
LUAI_FUNC void luaS_remove (lua_State *L, TString *ts);
LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s);
LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
LUAI_FUNC TString *luaS_new (lua_State *L, const char *str);
LUAI_FUNC TString *luaS_createlngstrobj (lua_State *L, size_t l);


#endif

```

`src/Lua/lstrlib.c`:

```c
/*
** $Id: lstrlib.c,v 1.254 2016/12/22 13:08:50 roberto Exp $
** Standard library for string operations and pattern-matching
** See Copyright Notice in lua.h
*/

#define lstrlib_c
#define LUA_LIB

#include "lprefix.h"


#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <locale.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


/*
** maximum number of captures that a pattern can do during
** pattern-matching. This limit is arbitrary, but must fit in
** an unsigned char.
*/
#if !defined(LUA_MAXCAPTURES)
#define LUA_MAXCAPTURES		32
#endif


/* macro to 'unsign' a character */
#define uchar(c)	((unsigned char)(c))


/*
** Some sizes are better limited to fit in 'int', but must also fit in
** 'size_t'. (We assume that 'lua_Integer' cannot be smaller than 'int'.)
*/
#define MAX_SIZET	((size_t)(~(size_t)0))

#define MAXSIZE  \
	(sizeof(size_t) < sizeof(int) ? MAX_SIZET : (size_t)(INT_MAX))




static int str_len (lua_State *L) {
  size_t l;
  luaL_checklstring(L, 1, &l);
  lua_pushinteger(L, (lua_Integer)l);
  return 1;
}


/* translate a relative string position: negative means back from end */
static lua_Integer posrelat (lua_Integer pos, size_t len) {
  if (pos >= 0) return pos;
  else if (0u - (size_t)pos > len) return 0;
  else return (lua_Integer)len + pos + 1;
}


static int str_sub (lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &l);
  lua_Integer start = posrelat(luaL_checkinteger(L, 2), l);
  lua_Integer end = posrelat(luaL_optinteger(L, 3, -1), l);
  if (start < 1) start = 1;
  if (end > (lua_Integer)l) end = l;
  if (start <= end)
    lua_pushlstring(L, s + start - 1, (size_t)(end - start) + 1);
  else lua_pushliteral(L, "");
  return 1;
}


static int str_reverse (lua_State *L) {
  size_t l, i;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &l);
  char *p = luaL_buffinitsize(L, &b, l);
  for (i = 0; i < l; i++)
    p[i] = s[l - i - 1];
  luaL_pushresultsize(&b, l);
  return 1;
}


static int str_lower (lua_State *L) {
  size_t l;
  size_t i;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &l);
  char *p = luaL_buffinitsize(L, &b, l);
  for (i=0; i<l; i++)
    p[i] = tolower(uchar(s[i]));
  luaL_pushresultsize(&b, l);
  return 1;
}


static int str_upper (lua_State *L) {
  size_t l;
  size_t i;
  luaL_Buffer b;
  const char *s = luaL_checklstring(L, 1, &l);
  char *p = luaL_buffinitsize(L, &b, l);
  for (i=0; i<l; i++)
    p[i] = toupper(uchar(s[i]));
  luaL_pushresultsize(&b, l);
  return 1;
}


static int str_rep (lua_State *L) {
  size_t l, lsep;
  const char *s = luaL_checklstring(L, 1, &l);
  lua_Integer n = luaL_checkinteger(L, 2);
  const char *sep = luaL_optlstring(L, 3, "", &lsep);
  if (n <= 0) lua_pushliteral(L, "");
  else if (l + lsep < l || l + lsep > MAXSIZE / n)  /* may overflow? */
    return luaL_error(L, "resulting string too large");
  else {
    size_t totallen = (size_t)n * l + (size_t)(n - 1) * lsep;
    luaL_Buffer b;
    char *p = luaL_buffinitsize(L, &b, totallen);
    while (n-- > 1) {  /* first n-1 copies (followed by separator) */
      memcpy(p, s, l * sizeof(char)); p += l;
      if (lsep > 0) {  /* empty 'memcpy' is not that cheap */
        memcpy(p, sep, lsep * sizeof(char));
        p += lsep;
      }
    }
    memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */
    luaL_pushresultsize(&b, totallen);
  }
  return 1;
}


static int str_byte (lua_State *L) {
  size_t l;
  const char *s = luaL_checklstring(L, 1, &l);
  lua_Integer posi = posrelat(luaL_optinteger(L, 2, 1), l);
  lua_Integer pose = posrelat(luaL_optinteger(L, 3, posi), l);
  int n, i;
  if (posi < 1) posi = 1;
  if (pose > (lua_Integer)l) pose = l;
  if (posi > pose) return 0;  /* empty interval; return no values */
  if (pose - posi >= INT_MAX)  /* arithmetic overflow? */
    return luaL_error(L, "string slice too long");
  n = (int)(pose -  posi) + 1;
  luaL_checkstack(L, n, "string slice too long");
  for (i=0; i<n; i++)
    lua_pushinteger(L, uchar(s[posi+i-1]));
  return n;
}


static int str_char (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  int i;
  luaL_Buffer b;
  char *p = luaL_buffinitsize(L, &b, n);
  for (i=1; i<=n; i++) {
    lua_Integer c = luaL_checkinteger(L, i);
    luaL_argcheck(L, uchar(c) == c, i, "value out of range");
    p[i - 1] = uchar(c);
  }
  luaL_pushresultsize(&b, n);
  return 1;
}


static int writer (lua_State *L, const void *b, size_t size, void *B) {
  (void)L;
  luaL_addlstring((luaL_Buffer *) B, (const char *)b, size);
  return 0;
}


static int str_dump (lua_State *L) {
  luaL_Buffer b;
  int strip = lua_toboolean(L, 2);
  luaL_checktype(L, 1, LUA_TFUNCTION);
  lua_settop(L, 1);
  luaL_buffinit(L,&b);
  if (lua_dump(L, writer, &b, strip) != 0)
    return luaL_error(L, "unable to dump given function");
  luaL_pushresult(&b);
  return 1;
}



/*
** {======================================================
** PATTERN MATCHING
** =======================================================
*/


#define CAP_UNFINISHED	(-1)
#define CAP_POSITION	(-2)


typedef struct MatchState {
  const char *src_init;  /* init of source string */
  const char *src_end;  /* end ('\0') of source string */
  const char *p_end;  /* end ('\0') of pattern */
  lua_State *L;
  int matchdepth;  /* control for recursive depth (to avoid C stack overflow) */
  unsigned char level;  /* total number of captures (finished or unfinished) */
  struct {
    const char *init;
    ptrdiff_t len;
  } capture[LUA_MAXCAPTURES];
} MatchState;


/* recursive function */
static const char *match (MatchState *ms, const char *s, const char *p);


/* maximum recursion depth for 'match' */
#if !defined(MAXCCALLS)
#define MAXCCALLS	200
#endif


#define L_ESC		'%'
#define SPECIALS	"^$*+?.([%-"


static int check_capture (MatchState *ms, int l) {
  l -= '1';
  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
    return luaL_error(ms->L, "invalid capture index %%%d", l + 1);
  return l;
}


static int capture_to_close (MatchState *ms) {
  int level = ms->level;
  for (level--; level>=0; level--)
    if (ms->capture[level].len == CAP_UNFINISHED) return level;
  return luaL_error(ms->L, "invalid pattern capture");
}


static const char *classend (MatchState *ms, const char *p) {
  switch (*p++) {
    case L_ESC: {
      if (p == ms->p_end)
        luaL_error(ms->L, "malformed pattern (ends with '%%')");
      return p+1;
    }
    case '[': {
      if (*p == '^') p++;
      do {  /* look for a ']' */
        if (p == ms->p_end)
          luaL_error(ms->L, "malformed pattern (missing ']')");
        if (*(p++) == L_ESC && p < ms->p_end)
          p++;  /* skip escapes (e.g. '%]') */
      } while (*p != ']');
      return p+1;
    }
    default: {
      return p;
    }
  }
}


static int match_class (int c, int cl) {
  int res;
  switch (tolower(cl)) {
    case 'a' : res = isalpha(c); break;
    case 'c' : res = iscntrl(c); break;
    case 'd' : res = isdigit(c); break;
    case 'g' : res = isgraph(c); break;
    case 'l' : res = islower(c); break;
    case 'p' : res = ispunct(c); break;
    case 's' : res = isspace(c); break;
    case 'u' : res = isupper(c); break;
    case 'w' : res = isalnum(c); break;
    case 'x' : res = isxdigit(c); break;
    case 'z' : res = (c == 0); break;  /* deprecated option */
    default: return (cl == c);
  }
  return (islower(cl) ? res : !res);
}


static int matchbracketclass (int c, const char *p, const char *ec) {
  int sig = 1;
  if (*(p+1) == '^') {
    sig = 0;
    p++;  /* skip the '^' */
  }
  while (++p < ec) {
    if (*p == L_ESC) {
      p++;
      if (match_class(c, uchar(*p)))
        return sig;
    }
    else if ((*(p+1) == '-') && (p+2 < ec)) {
      p+=2;
      if (uchar(*(p-2)) <= c && c <= uchar(*p))
        return sig;
    }
    else if (uchar(*p) == c) return sig;
  }
  return !sig;
}


static int singlematch (MatchState *ms, const char *s, const char *p,
                        const char *ep) {
  if (s >= ms->src_end)
    return 0;
  else {
    int c = uchar(*s);
    switch (*p) {
      case '.': return 1;  /* matches any char */
      case L_ESC: return match_class(c, uchar(*(p+1)));
      case '[': return matchbracketclass(c, p, ep-1);
      default:  return (uchar(*p) == c);
    }
  }
}


static const char *matchbalance (MatchState *ms, const char *s,
                                   const char *p) {
  if (p >= ms->p_end - 1)
    luaL_error(ms->L, "malformed pattern (missing arguments to '%%b')");
  if (*s != *p) return NULL;
  else {
    int b = *p;
    int e = *(p+1);
    int cont = 1;
    while (++s < ms->src_end) {
      if (*s == e) {
        if (--cont == 0) return s+1;
      }
      else if (*s == b) cont++;
    }
  }
  return NULL;  /* string ends out of balance */
}


static const char *max_expand (MatchState *ms, const char *s,
                                 const char *p, const char *ep) {
  ptrdiff_t i = 0;  /* counts maximum expand for item */
  while (singlematch(ms, s + i, p, ep))
    i++;
  /* keeps trying to match with the maximum repetitions */
  while (i>=0) {
    const char *res = match(ms, (s+i), ep+1);
    if (res) return res;
    i--;  /* else didn't match; reduce 1 repetition to try again */
  }
  return NULL;
}


static const char *min_expand (MatchState *ms, const char *s,
                                 const char *p, const char *ep) {
  for (;;) {
    const char *res = match(ms, s, ep+1);
    if (res != NULL)
      return res;
    else if (singlematch(ms, s, p, ep))
      s++;  /* try with one more repetition */
    else return NULL;
  }
}


static const char *start_capture (MatchState *ms, const char *s,
                                    const char *p, int what) {
  const char *res;
  int level = ms->level;
  if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, "too many captures");
  ms->capture[level].init = s;
  ms->capture[level].len = what;
  ms->level = level+1;
  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
    ms->level--;  /* undo capture */
  return res;
}


static const char *end_capture (MatchState *ms, const char *s,
                                  const char *p) {
  int l = capture_to_close(ms);
  const char *res;
  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
  return res;
}


static const char *match_capture (MatchState *ms, const char *s, int l) {
  size_t len;
  l = check_capture(ms, l);
  len = ms->capture[l].len;
  if ((size_t)(ms->src_end-s) >= len &&
      memcmp(ms->capture[l].init, s, len) == 0)
    return s+len;
  else return NULL;
}


static const char *match (MatchState *ms, const char *s, const char *p) {
  if (ms->matchdepth-- == 0)
    luaL_error(ms->L, "pattern too complex");
  init: /* using goto's to optimize tail recursion */
  if (p != ms->p_end) {  /* end of pattern? */
    switch (*p) {
      case '(': {  /* start capture */
        if (*(p + 1) == ')')  /* position capture? */
          s = start_capture(ms, s, p + 2, CAP_POSITION);
        else
          s = start_capture(ms, s, p + 1, CAP_UNFINISHED);
        break;
      }
      case ')': {  /* end capture */
        s = end_capture(ms, s, p + 1);
        break;
      }
      case '$': {
        if ((p + 1) != ms->p_end)  /* is the '$' the last char in pattern? */
          goto dflt;  /* no; go to default */
        s = (s == ms->src_end) ? s : NULL;  /* check end of string */
        break;
      }
      case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */
        switch (*(p + 1)) {
          case 'b': {  /* balanced string? */
            s = matchbalance(ms, s, p + 2);
            if (s != NULL) {
              p += 4; goto init;  /* return match(ms, s, p + 4); */
            }  /* else fail (s == NULL) */
            break;
          }
          case 'f': {  /* frontier? */
            const char *ep; char previous;
            p += 2;
            if (*p != '[')
              luaL_error(ms->L, "missing '[' after '%%f' in pattern");
            ep = classend(ms, p);  /* points to what is next */
            previous = (s == ms->src_init) ? '\0' : *(s - 1);
            if (!matchbracketclass(uchar(previous), p, ep - 1) &&
               matchbracketclass(uchar(*s), p, ep - 1)) {
              p = ep; goto init;  /* return match(ms, s, ep); */
            }
            s = NULL;  /* match failed */
            break;
          }
          case '0': case '1': case '2': case '3':
          case '4': case '5': case '6': case '7':
          case '8': case '9': {  /* capture results (%0-%9)? */
            s = match_capture(ms, s, uchar(*(p + 1)));
            if (s != NULL) {
              p += 2; goto init;  /* return match(ms, s, p + 2) */
            }
            break;
          }
          default: goto dflt;
        }
        break;
      }
      default: dflt: {  /* pattern class plus optional suffix */
        const char *ep = classend(ms, p);  /* points to optional suffix */
        /* does not match at least once? */
        if (!singlematch(ms, s, p, ep)) {
          if (*ep == '*' || *ep == '?' || *ep == '-') {  /* accept empty? */
            p = ep + 1; goto init;  /* return match(ms, s, ep + 1); */
          }
          else  /* '+' or no suffix */
            s = NULL;  /* fail */
        }
        else {  /* matched once */
          switch (*ep) {  /* handle optional suffix */
            case '?': {  /* optional */
              const char *res;
              if ((res = match(ms, s + 1, ep + 1)) != NULL)
                s = res;
              else {
                p = ep + 1; goto init;  /* else return match(ms, s, ep + 1); */
              }
              break;
            }
            case '+':  /* 1 or more repetitions */
              s++;  /* 1 match already done */
              /* FALLTHROUGH */
            case '*':  /* 0 or more repetitions */
              s = max_expand(ms, s, p, ep);
              break;
            case '-':  /* 0 or more repetitions (minimum) */
              s = min_expand(ms, s, p, ep);
              break;
            default:  /* no suffix */
              s++; p = ep; goto init;  /* return match(ms, s + 1, ep); */
          }
        }
        break;
      }
    }
  }
  ms->matchdepth++;
  return s;
}



static const char *lmemfind (const char *s1, size_t l1,
                               const char *s2, size_t l2) {
  if (l2 == 0) return s1;  /* empty strings are everywhere */
  else if (l2 > l1) return NULL;  /* avoids a negative 'l1' */
  else {
    const char *init;  /* to search for a '*s2' inside 's1' */
    l2--;  /* 1st char will be checked by 'memchr' */
    l1 = l1-l2;  /* 's2' cannot be found after that */
    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
      init++;   /* 1st char is already checked */
      if (memcmp(init, s2+1, l2) == 0)
        return init-1;
      else {  /* correct 'l1' and 's1' to try again */
        l1 -= init-s1;
        s1 = init;
      }
    }
    return NULL;  /* not found */
  }
}


static void push_onecapture (MatchState *ms, int i, const char *s,
                                                    const char *e) {
  if (i >= ms->level) {
    if (i == 0)  /* ms->level == 0, too */
      lua_pushlstring(ms->L, s, e - s);  /* add whole match */
    else
      luaL_error(ms->L, "invalid capture index %%%d", i + 1);
  }
  else {
    ptrdiff_t l = ms->capture[i].len;
    if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
    if (l == CAP_POSITION)
      lua_pushinteger(ms->L, (ms->capture[i].init - ms->src_init) + 1);
    else
      lua_pushlstring(ms->L, ms->capture[i].init, l);
  }
}


static int push_captures (MatchState *ms, const char *s, const char *e) {
  int i;
  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
  luaL_checkstack(ms->L, nlevels, "too many captures");
  for (i = 0; i < nlevels; i++)
    push_onecapture(ms, i, s, e);
  return nlevels;  /* number of strings pushed */
}


/* check whether pattern has no special characters */
static int nospecials (const char *p, size_t l) {
  size_t upto = 0;
  do {
    if (strpbrk(p + upto, SPECIALS))
      return 0;  /* pattern has a special character */
    upto += strlen(p + upto) + 1;  /* may have more after \0 */
  } while (upto <= l);
  return 1;  /* no special chars found */
}


static void prepstate (MatchState *ms, lua_State *L,
                       const char *s, size_t ls, const char *p, size_t lp) {
  ms->L = L;
  ms->matchdepth = MAXCCALLS;
  ms->src_init = s;
  ms->src_end = s + ls;
  ms->p_end = p + lp;
}


static void reprepstate (MatchState *ms) {
  ms->level = 0;
  lua_assert(ms->matchdepth == MAXCCALLS);
}


static int str_find_aux (lua_State *L, int find) {
  size_t ls, lp;
  const char *s = luaL_checklstring(L, 1, &ls);
  const char *p = luaL_checklstring(L, 2, &lp);
  lua_Integer init = posrelat(luaL_optinteger(L, 3, 1), ls);
  if (init < 1) init = 1;
  else if (init > (lua_Integer)ls + 1) {  /* start after string's end? */
    lua_pushnil(L);  /* cannot find anything */
    return 1;
  }
  /* explicit request or no special characters? */
  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {
    /* do a plain search */
    const char *s2 = lmemfind(s + init - 1, ls - (size_t)init + 1, p, lp);
    if (s2) {
      lua_pushinteger(L, (s2 - s) + 1);
      lua_pushinteger(L, (s2 - s) + lp);
      return 2;
    }
  }
  else {
    MatchState ms;
    const char *s1 = s + init - 1;
    int anchor = (*p == '^');
    if (anchor) {
      p++; lp--;  /* skip anchor character */
    }
    prepstate(&ms, L, s, ls, p, lp);
    do {
      const char *res;
      reprepstate(&ms);
      if ((res=match(&ms, s1, p)) != NULL) {
        if (find) {
          lua_pushinteger(L, (s1 - s) + 1);  /* start */
          lua_pushinteger(L, res - s);   /* end */
          return push_captures(&ms, NULL, 0) + 2;
        }
        else
          return push_captures(&ms, s1, res);
      }
    } while (s1++ < ms.src_end && !anchor);
  }
  lua_pushnil(L);  /* not found */
  return 1;
}


static int str_find (lua_State *L) {
  return str_find_aux(L, 1);
}


static int str_match (lua_State *L) {
  return str_find_aux(L, 0);
}


/* state for 'gmatch' */
typedef struct GMatchState {
  const char *src;  /* current position */
  const char *p;  /* pattern */
  const char *lastmatch;  /* end of last match */
  MatchState ms;  /* match state */
} GMatchState;


static int gmatch_aux (lua_State *L) {
  GMatchState *gm = (GMatchState *)lua_touserdata(L, lua_upvalueindex(3));
  const char *src;
  gm->ms.L = L;
  for (src = gm->src; src <= gm->ms.src_end; src++) {
    const char *e;
    reprepstate(&gm->ms);
    if ((e = match(&gm->ms, src, gm->p)) != NULL && e != gm->lastmatch) {
      gm->src = gm->lastmatch = e;
      return push_captures(&gm->ms, src, e);
    }
  }
  return 0;  /* not found */
}


static int gmatch (lua_State *L) {
  size_t ls, lp;
  const char *s = luaL_checklstring(L, 1, &ls);
  const char *p = luaL_checklstring(L, 2, &lp);
  GMatchState *gm;
  lua_settop(L, 2);  /* keep them on closure to avoid being collected */
  gm = (GMatchState *)lua_newuserdata(L, sizeof(GMatchState));
  prepstate(&gm->ms, L, s, ls, p, lp);
  gm->src = s; gm->p = p; gm->lastmatch = NULL;
  lua_pushcclosure(L, gmatch_aux, 3);
  return 1;
}


static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
                                                   const char *e) {
  size_t l, i;
  lua_State *L = ms->L;
  const char *news = lua_tolstring(L, 3, &l);
  for (i = 0; i < l; i++) {
    if (news[i] != L_ESC)
      luaL_addchar(b, news[i]);
    else {
      i++;  /* skip ESC */
      if (!isdigit(uchar(news[i]))) {
        if (news[i] != L_ESC)
          luaL_error(L, "invalid use of '%c' in replacement string", L_ESC);
        luaL_addchar(b, news[i]);
      }
      else if (news[i] == '0')
          luaL_addlstring(b, s, e - s);
      else {
        push_onecapture(ms, news[i] - '1', s, e);
        luaL_tolstring(L, -1, NULL);  /* if number, convert it to string */
        lua_remove(L, -2);  /* remove original value */
        luaL_addvalue(b);  /* add capture to accumulated result */
      }
    }
  }
}


static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
                                       const char *e, int tr) {
  lua_State *L = ms->L;
  switch (tr) {
    case LUA_TFUNCTION: {
      int n;
      lua_pushvalue(L, 3);
      n = push_captures(ms, s, e);
      lua_call(L, n, 1);
      break;
    }
    case LUA_TTABLE: {
      push_onecapture(ms, 0, s, e);
      lua_gettable(L, 3);
      break;
    }
    default: {  /* LUA_TNUMBER or LUA_TSTRING */
      add_s(ms, b, s, e);
      return;
    }
  }
  if (!lua_toboolean(L, -1)) {  /* nil or false? */
    lua_pop(L, 1);
    lua_pushlstring(L, s, e - s);  /* keep original text */
  }
  else if (!lua_isstring(L, -1))
    luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1));
  luaL_addvalue(b);  /* add result to accumulator */
}


static int str_gsub (lua_State *L) {
  size_t srcl, lp;
  const char *src = luaL_checklstring(L, 1, &srcl);  /* subject */
  const char *p = luaL_checklstring(L, 2, &lp);  /* pattern */
  const char *lastmatch = NULL;  /* end of last match */
  int tr = lua_type(L, 3);  /* replacement type */
  lua_Integer max_s = luaL_optinteger(L, 4, srcl + 1);  /* max replacements */
  int anchor = (*p == '^');
  lua_Integer n = 0;  /* replacement count */
  MatchState ms;
  luaL_Buffer b;
  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
                      "string/function/table expected");
  luaL_buffinit(L, &b);
  if (anchor) {
    p++; lp--;  /* skip anchor character */
  }
  prepstate(&ms, L, src, srcl, p, lp);
  while (n < max_s) {
    const char *e;
    reprepstate(&ms);  /* (re)prepare state for new match */
    if ((e = match(&ms, src, p)) != NULL && e != lastmatch) {  /* match? */
      n++;
      add_value(&ms, &b, src, e, tr);  /* add replacement to buffer */
      src = lastmatch = e;
    }
    else if (src < ms.src_end)  /* otherwise, skip one character */
      luaL_addchar(&b, *src++);
    else break;  /* end of subject */
    if (anchor) break;
  }
  luaL_addlstring(&b, src, ms.src_end-src);
  luaL_pushresult(&b);
  lua_pushinteger(L, n);  /* number of substitutions */
  return 2;
}

/* }====================================================== */



/*
** {======================================================
** STRING FORMAT
** =======================================================
*/

#if !defined(lua_number2strx)	/* { */

/*
** Hexadecimal floating-point formatter
*/

#include <math.h>

#define SIZELENMOD	(sizeof(LUA_NUMBER_FRMLEN)/sizeof(char))


/*
** Number of bits that goes into the first digit. It can be any value
** between 1 and 4; the following definition tries to align the number
** to nibble boundaries by making what is left after that first digit a
** multiple of 4.
*/
#define L_NBFD		((l_mathlim(MANT_DIG) - 1)%4 + 1)


/*
** Add integer part of 'x' to buffer and return new 'x'
*/
static lua_Number adddigit (char *buff, int n, lua_Number x) {
  lua_Number dd = l_mathop(floor)(x);  /* get integer part from 'x' */
  int d = (int)dd;
  buff[n] = (d < 10 ? d + '0' : d - 10 + 'a');  /* add to buffer */
  return x - dd;  /* return what is left */
}


static int num2straux (char *buff, int sz, lua_Number x) {
  /* if 'inf' or 'NaN', format it like '%g' */
  if (x != x || x == (lua_Number)HUGE_VAL || x == -(lua_Number)HUGE_VAL)
    return l_sprintf(buff, sz, LUA_NUMBER_FMT, (LUAI_UACNUMBER)x);
  else if (x == 0) {  /* can be -0... */
    /* create "0" or "-0" followed by exponent */
    return l_sprintf(buff, sz, LUA_NUMBER_FMT "x0p+0", (LUAI_UACNUMBER)x);
  }
  else {
    int e;
    lua_Number m = l_mathop(frexp)(x, &e);  /* 'x' fraction and exponent */
    int n = 0;  /* character count */
    if (m < 0) {  /* is number negative? */
      buff[n++] = '-';  /* add signal */
      m = -m;  /* make it positive */
    }
    buff[n++] = '0'; buff[n++] = 'x';  /* add "0x" */
    m = adddigit(buff, n++, m * (1 << L_NBFD));  /* add first digit */
    e -= L_NBFD;  /* this digit goes before the radix point */
    if (m > 0) {  /* more digits? */
      buff[n++] = lua_getlocaledecpoint();  /* add radix point */
      do {  /* add as many digits as needed */
        m = adddigit(buff, n++, m * 16);
      } while (m > 0);
    }
    n += l_sprintf(buff + n, sz - n, "p%+d", e);  /* add exponent */
    lua_assert(n < sz);
    return n;
  }
}


static int lua_number2strx (lua_State *L, char *buff, int sz,
                            const char *fmt, lua_Number x) {
  int n = num2straux(buff, sz, x);
  if (fmt[SIZELENMOD] == 'A') {
    int i;
    for (i = 0; i < n; i++)
      buff[i] = toupper(uchar(buff[i]));
  }
  else if (fmt[SIZELENMOD] != 'a')
    luaL_error(L, "modifiers for format '%%a'/'%%A' not implemented");
  return n;
}

#endif				/* } */


/*
** Maximum size of each formatted item. This maximum size is produced
** by format('%.99f', -maxfloat), and is equal to 99 + 3 ('-', '.',
** and '\0') + number of decimal digits to represent maxfloat (which
** is maximum exponent + 1). (99+3+1 then rounded to 120 for "extra
** expenses", such as locale-dependent stuff)
*/
#define MAX_ITEM        (120 + l_mathlim(MAX_10_EXP))


/* valid flags in a format specification */
#define FLAGS	"-+ #0"

/*
** maximum size of each format specification (such as "%-099.99d")
*/
#define MAX_FORMAT	32


static void addquoted (luaL_Buffer *b, const char *s, size_t len) {
  luaL_addchar(b, '"');
  while (len--) {
    if (*s == '"' || *s == '\\' || *s == '\n') {
      luaL_addchar(b, '\\');
      luaL_addchar(b, *s);
    }
    else if (iscntrl(uchar(*s))) {
      char buff[10];
      if (!isdigit(uchar(*(s+1))))
        l_sprintf(buff, sizeof(buff), "\\%d", (int)uchar(*s));
      else
        l_sprintf(buff, sizeof(buff), "\\%03d", (int)uchar(*s));
      luaL_addstring(b, buff);
    }
    else
      luaL_addchar(b, *s);
    s++;
  }
  luaL_addchar(b, '"');
}


/*
** Ensures the 'buff' string uses a dot as the radix character.
*/
static void checkdp (char *buff, int nb) {
  if (memchr(buff, '.', nb) == NULL) {  /* no dot? */
    char point = lua_getlocaledecpoint();  /* try locale point */
    char *ppoint = (char *)memchr(buff, point, nb);
    if (ppoint) *ppoint = '.';  /* change it to a dot */
  }
}


static void addliteral (lua_State *L, luaL_Buffer *b, int arg) {
  switch (lua_type(L, arg)) {
    case LUA_TSTRING: {
      size_t len;
      const char *s = lua_tolstring(L, arg, &len);
      addquoted(b, s, len);
      break;
    }
    case LUA_TNUMBER: {
      char *buff = luaL_prepbuffsize(b, MAX_ITEM);
      int nb;
      if (!lua_isinteger(L, arg)) {  /* float? */
        lua_Number n = lua_tonumber(L, arg);  /* write as hexa ('%a') */
        nb = lua_number2strx(L, buff, MAX_ITEM, "%" LUA_NUMBER_FRMLEN "a", n);
        checkdp(buff, nb);  /* ensure it uses a dot */
      }
      else {  /* integers */
        lua_Integer n = lua_tointeger(L, arg);
        const char *format = (n == LUA_MININTEGER)  /* corner case? */
                           ? "0x%" LUA_INTEGER_FRMLEN "x"  /* use hexa */
                           : LUA_INTEGER_FMT;  /* else use default format */
        nb = l_sprintf(buff, MAX_ITEM, format, (LUAI_UACINT)n);
      }
      luaL_addsize(b, nb);
      break;
    }
    case LUA_TNIL: case LUA_TBOOLEAN: {
      luaL_tolstring(L, arg, NULL);
      luaL_addvalue(b);
      break;
    }
    default: {
      luaL_argerror(L, arg, "value has no literal form");
    }
  }
}


static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
  const char *p = strfrmt;
  while (*p != '\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */
  if ((size_t)(p - strfrmt) >= sizeof(FLAGS)/sizeof(char))
    luaL_error(L, "invalid format (repeated flags)");
  if (isdigit(uchar(*p))) p++;  /* skip width */
  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
  if (*p == '.') {
    p++;
    if (isdigit(uchar(*p))) p++;  /* skip precision */
    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
  }
  if (isdigit(uchar(*p)))
    luaL_error(L, "invalid format (width or precision too long)");
  *(form++) = '%';
  memcpy(form, strfrmt, ((p - strfrmt) + 1) * sizeof(char));
  form += (p - strfrmt) + 1;
  *form = '\0';
  return p;
}


/*
** add length modifier into formats
*/
static void addlenmod (char *form, const char *lenmod) {
  size_t l = strlen(form);
  size_t lm = strlen(lenmod);
  char spec = form[l - 1];
  strcpy(form + l - 1, lenmod);
  form[l + lm - 1] = spec;
  form[l + lm] = '\0';
}


static int str_format (lua_State *L) {
  int top = lua_gettop(L);
  int arg = 1;
  size_t sfl;
  const char *strfrmt = luaL_checklstring(L, arg, &sfl);
  const char *strfrmt_end = strfrmt+sfl;
  luaL_Buffer b;
  luaL_buffinit(L, &b);
  while (strfrmt < strfrmt_end) {
    if (*strfrmt != L_ESC)
      luaL_addchar(&b, *strfrmt++);
    else if (*++strfrmt == L_ESC)
      luaL_addchar(&b, *strfrmt++);  /* %% */
    else { /* format item */
      char form[MAX_FORMAT];  /* to store the format ('%...') */
      char *buff = luaL_prepbuffsize(&b, MAX_ITEM);  /* to put formatted item */
      int nb = 0;  /* number of bytes in added item */
      if (++arg > top)
        luaL_argerror(L, arg, "no value");
      strfrmt = scanformat(L, strfrmt, form);
      switch (*strfrmt++) {
        case 'c': {
          nb = l_sprintf(buff, MAX_ITEM, form, (int)luaL_checkinteger(L, arg));
          break;
        }
        case 'd': case 'i':
        case 'o': case 'u': case 'x': case 'X': {
          lua_Integer n = luaL_checkinteger(L, arg);
          addlenmod(form, LUA_INTEGER_FRMLEN);
          nb = l_sprintf(buff, MAX_ITEM, form, (LUAI_UACINT)n);
          break;
        }
        case 'a': case 'A':
          addlenmod(form, LUA_NUMBER_FRMLEN);
          nb = lua_number2strx(L, buff, MAX_ITEM, form,
                                  luaL_checknumber(L, arg));
          break;
        case 'e': case 'E': case 'f':
        case 'g': case 'G': {
          lua_Number n = luaL_checknumber(L, arg);
          addlenmod(form, LUA_NUMBER_FRMLEN);
          nb = l_sprintf(buff, MAX_ITEM, form, (LUAI_UACNUMBER)n);
          break;
        }
        case 'q': {
          addliteral(L, &b, arg);
          break;
        }
        case 's': {
          size_t l;
          const char *s = luaL_tolstring(L, arg, &l);
          if (form[2] == '\0')  /* no modifiers? */
            luaL_addvalue(&b);  /* keep entire string */
          else {
            luaL_argcheck(L, l == strlen(s), arg, "string contains zeros");
            if (!strchr(form, '.') && l >= 100) {
              /* no precision and string is too long to be formatted */
              luaL_addvalue(&b);  /* keep entire string */
            }
            else {  /* format the string into 'buff' */
              nb = l_sprintf(buff, MAX_ITEM, form, s);
              lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */
            }
          }
          break;
        }
        default: {  /* also treat cases 'pnLlh' */
          return luaL_error(L, "invalid option '%%%c' to 'format'",
                               *(strfrmt - 1));
        }
      }
      lua_assert(nb < MAX_ITEM);
      luaL_addsize(&b, nb);
    }
  }
  luaL_pushresult(&b);
  return 1;
}

/* }====================================================== */


/*
** {======================================================
** PACK/UNPACK
** =======================================================
*/


/* value used for padding */
#if !defined(LUAL_PACKPADBYTE)
#define LUAL_PACKPADBYTE		0x00
#endif

/* maximum size for the binary representation of an integer */
#define MAXINTSIZE	16

/* number of bits in a character */
#define NB	CHAR_BIT

/* mask for one character (NB 1's) */
#define MC	((1 << NB) - 1)

/* size of a lua_Integer */
#define SZINT	((int)sizeof(lua_Integer))


/* dummy union to get native endianness */
static const union {
  int dummy;
  char little;  /* true iff machine is little endian */
} nativeendian = {1};


/* dummy structure to get native alignment requirements */
struct cD {
  char c;
  union { double d; void *p; lua_Integer i; lua_Number n; } u;
};

#define MAXALIGN	(offsetof(struct cD, u))


/*
** Union for serializing floats
*/
typedef union Ftypes {
  float f;
  double d;
  lua_Number n;
  char buff[5 * sizeof(lua_Number)];  /* enough for any float type */
} Ftypes;


/*
** information to pack/unpack stuff
*/
typedef struct Header {
  lua_State *L;
  int islittle;
  int maxalign;
} Header;


/*
** options for pack/unpack
*/
typedef enum KOption {
  Kint,		/* signed integers */
  Kuint,	/* unsigned integers */
  Kfloat,	/* floating-point numbers */
  Kchar,	/* fixed-length strings */
  Kstring,	/* strings with prefixed length */
  Kzstr,	/* zero-terminated strings */
  Kpadding,	/* padding */
  Kpaddalign,	/* padding for alignment */
  Knop		/* no-op (configuration or spaces) */
} KOption;


/*
** Read an integer numeral from string 'fmt' or return 'df' if
** there is no numeral
*/
static int digit (int c) { return '0' <= c && c <= '9'; }

static int getnum (const char **fmt, int df) {
  if (!digit(**fmt))  /* no number? */
    return df;  /* return default value */
  else {
    int a = 0;
    do {
      a = a*10 + (*((*fmt)++) - '0');
    } while (digit(**fmt) && a <= ((int)MAXSIZE - 9)/10);
    return a;
  }
}


/*
** Read an integer numeral and raises an error if it is larger
** than the maximum size for integers.
*/
static int getnumlimit (Header *h, const char **fmt, int df) {
  int sz = getnum(fmt, df);
  if (sz > MAXINTSIZE || sz <= 0)
    luaL_error(h->L, "integral size (%d) out of limits [1,%d]",
                     sz, MAXINTSIZE);
  return sz;
}


/*
** Initialize Header
*/
static void initheader (lua_State *L, Header *h) {
  h->L = L;
  h->islittle = nativeendian.little;
  h->maxalign = 1;
}


/*
** Read and classify next option. 'size' is filled with option's size.
*/
static KOption getoption (Header *h, const char **fmt, int *size) {
  int opt = *((*fmt)++);
  *size = 0;  /* default */
  switch (opt) {
    case 'b': *size = sizeof(char); return Kint;
    case 'B': *size = sizeof(char); return Kuint;
    case 'h': *size = sizeof(short); return Kint;
    case 'H': *size = sizeof(short); return Kuint;
    case 'l': *size = sizeof(long); return Kint;
    case 'L': *size = sizeof(long); return Kuint;
    case 'j': *size = sizeof(lua_Integer); return Kint;
    case 'J': *size = sizeof(lua_Integer); return Kuint;
    case 'T': *size = sizeof(size_t); return Kuint;
    case 'f': *size = sizeof(float); return Kfloat;
    case 'd': *size = sizeof(double); return Kfloat;
    case 'n': *size = sizeof(lua_Number); return Kfloat;
    case 'i': *size = getnumlimit(h, fmt, sizeof(int)); return Kint;
    case 'I': *size = getnumlimit(h, fmt, sizeof(int)); return Kuint;
    case 's': *size = getnumlimit(h, fmt, sizeof(size_t)); return Kstring;
    case 'c':
      *size = getnum(fmt, -1);
      if (*size == -1)
        luaL_error(h->L, "missing size for format option 'c'");
      return Kchar;
    case 'z': return Kzstr;
    case 'x': *size = 1; return Kpadding;
    case 'X': return Kpaddalign;
    case ' ': break;
    case '<': h->islittle = 1; break;
    case '>': h->islittle = 0; break;
    case '=': h->islittle = nativeendian.little; break;
    case '!': h->maxalign = getnumlimit(h, fmt, MAXALIGN); break;
    default: luaL_error(h->L, "invalid format option '%c'", opt);
  }
  return Knop;
}


/*
** Read, classify, and fill other details about the next option.
** 'psize' is filled with option's size, 'notoalign' with its
** alignment requirements.
** Local variable 'size' gets the size to be aligned. (Kpadal option
** always gets its full alignment, other options are limited by
** the maximum alignment ('maxalign'). Kchar option needs no alignment
** despite its size.
*/
static KOption getdetails (Header *h, size_t totalsize,
                           const char **fmt, int *psize, int *ntoalign) {
  KOption opt = getoption(h, fmt, psize);
  int align = *psize;  /* usually, alignment follows size */
  if (opt == Kpaddalign) {  /* 'X' gets alignment from following option */
    if (**fmt == '\0' || getoption(h, fmt, &align) == Kchar || align == 0)
      luaL_argerror(h->L, 1, "invalid next option for option 'X'");
  }
  if (align <= 1 || opt == Kchar)  /* need no alignment? */
    *ntoalign = 0;
  else {
    if (align > h->maxalign)  /* enforce maximum alignment */
      align = h->maxalign;
    if ((align & (align - 1)) != 0)  /* is 'align' not a power of 2? */
      luaL_argerror(h->L, 1, "format asks for alignment not power of 2");
    *ntoalign = (align - (int)(totalsize & (align - 1))) & (align - 1);
  }
  return opt;
}


/*
** Pack integer 'n' with 'size' bytes and 'islittle' endianness.
** The final 'if' handles the case when 'size' is larger than
** the size of a Lua integer, correcting the extra sign-extension
** bytes if necessary (by default they would be zeros).
*/
static void packint (luaL_Buffer *b, lua_Unsigned n,
                     int islittle, int size, int neg) {
  char *buff = luaL_prepbuffsize(b, size);
  int i;
  buff[islittle ? 0 : size - 1] = (char)(n & MC);  /* first byte */
  for (i = 1; i < size; i++) {
    n >>= NB;
    buff[islittle ? i : size - 1 - i] = (char)(n & MC);
  }
  if (neg && size > SZINT) {  /* negative number need sign extension? */
    for (i = SZINT; i < size; i++)  /* correct extra bytes */
      buff[islittle ? i : size - 1 - i] = (char)MC;
  }
  luaL_addsize(b, size);  /* add result to buffer */
}


/*
** Copy 'size' bytes from 'src' to 'dest', correcting endianness if
** given 'islittle' is different from native endianness.
*/
static void copywithendian (volatile char *dest, volatile const char *src,
                            int size, int islittle) {
  if (islittle == nativeendian.little) {
    while (size-- != 0)
      *(dest++) = *(src++);
  }
  else {
    dest += size - 1;
    while (size-- != 0)
      *(dest--) = *(src++);
  }
}


static int str_pack (lua_State *L) {
  luaL_Buffer b;
  Header h;
  const char *fmt = luaL_checkstring(L, 1);  /* format string */
  int arg = 1;  /* current argument to pack */
  size_t totalsize = 0;  /* accumulate total size of result */
  initheader(L, &h);
  lua_pushnil(L);  /* mark to separate arguments from string buffer */
  luaL_buffinit(L, &b);
  while (*fmt != '\0') {
    int size, ntoalign;
    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);
    totalsize += ntoalign + size;
    while (ntoalign-- > 0)
     luaL_addchar(&b, LUAL_PACKPADBYTE);  /* fill alignment */
    arg++;
    switch (opt) {
      case Kint: {  /* signed integers */
        lua_Integer n = luaL_checkinteger(L, arg);
        if (size < SZINT) {  /* need overflow check? */
          lua_Integer lim = (lua_Integer)1 << ((size * NB) - 1);
          luaL_argcheck(L, -lim <= n && n < lim, arg, "integer overflow");
        }
        packint(&b, (lua_Unsigned)n, h.islittle, size, (n < 0));
        break;
      }
      case Kuint: {  /* unsigned integers */
        lua_Integer n = luaL_checkinteger(L, arg);
        if (size < SZINT)  /* need overflow check? */
          luaL_argcheck(L, (lua_Unsigned)n < ((lua_Unsigned)1 << (size * NB)),
                           arg, "unsigned overflow");
        packint(&b, (lua_Unsigned)n, h.islittle, size, 0);
        break;
      }
      case Kfloat: {  /* floating-point options */
        volatile Ftypes u;
        char *buff = luaL_prepbuffsize(&b, size);
        lua_Number n = luaL_checknumber(L, arg);  /* get argument */
        if (size == sizeof(u.f)) u.f = (float)n;  /* copy it into 'u' */
        else if (size == sizeof(u.d)) u.d = (double)n;
        else u.n = n;
        /* move 'u' to final result, correcting endianness if needed */
        copywithendian(buff, u.buff, size, h.islittle);
        luaL_addsize(&b, size);
        break;
      }
      case Kchar: {  /* fixed-size string */
        size_t len;
        const char *s = luaL_checklstring(L, arg, &len);
        luaL_argcheck(L, len <= (size_t)size, arg,
                         "string longer than given size");
        luaL_addlstring(&b, s, len);  /* add string */
        while (len++ < (size_t)size)  /* pad extra space */
          luaL_addchar(&b, LUAL_PACKPADBYTE);
        break;
      }
      case Kstring: {  /* strings with length count */
        size_t len;
        const char *s = luaL_checklstring(L, arg, &len);
        luaL_argcheck(L, size >= (int)sizeof(size_t) ||
                         len < ((size_t)1 << (size * NB)),
                         arg, "string length does not fit in given size");
        packint(&b, (lua_Unsigned)len, h.islittle, size, 0);  /* pack length */
        luaL_addlstring(&b, s, len);
        totalsize += len;
        break;
      }
      case Kzstr: {  /* zero-terminated string */
        size_t len;
        const char *s = luaL_checklstring(L, arg, &len);
        luaL_argcheck(L, strlen(s) == len, arg, "string contains zeros");
        luaL_addlstring(&b, s, len);
        luaL_addchar(&b, '\0');  /* add zero at the end */
        totalsize += len + 1;
        break;
      }
      case Kpadding: luaL_addchar(&b, LUAL_PACKPADBYTE);  /* FALLTHROUGH */
      case Kpaddalign: case Knop:
        arg--;  /* undo increment */
        break;
    }
  }
  luaL_pushresult(&b);
  return 1;
}


static int str_packsize (lua_State *L) {
  Header h;
  const char *fmt = luaL_checkstring(L, 1);  /* format string */
  size_t totalsize = 0;  /* accumulate total size of result */
  initheader(L, &h);
  while (*fmt != '\0') {
    int size, ntoalign;
    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);
    size += ntoalign;  /* total space used by option */
    luaL_argcheck(L, totalsize <= MAXSIZE - size, 1,
                     "format result too large");
    totalsize += size;
    switch (opt) {
      case Kstring:  /* strings with length count */
      case Kzstr:    /* zero-terminated string */
        luaL_argerror(L, 1, "variable-length format");
        /* call never return, but to avoid warnings: *//* FALLTHROUGH */
      default:  break;
    }
  }
  lua_pushinteger(L, (lua_Integer)totalsize);
  return 1;
}


/*
** Unpack an integer with 'size' bytes and 'islittle' endianness.
** If size is smaller than the size of a Lua integer and integer
** is signed, must do sign extension (propagating the sign to the
** higher bits); if size is larger than the size of a Lua integer,
** it must check the unread bytes to see whether they do not cause an
** overflow.
*/
static lua_Integer unpackint (lua_State *L, const char *str,
                              int islittle, int size, int issigned) {
  lua_Unsigned res = 0;
  int i;
  int limit = (size  <= SZINT) ? size : SZINT;
  for (i = limit - 1; i >= 0; i--) {
    res <<= NB;
    res |= (lua_Unsigned)(unsigned char)str[islittle ? i : size - 1 - i];
  }
  if (size < SZINT) {  /* real size smaller than lua_Integer? */
    if (issigned) {  /* needs sign extension? */
      lua_Unsigned mask = (lua_Unsigned)1 << (size*NB - 1);
      res = ((res ^ mask) - mask);  /* do sign extension */
    }
  }
  else if (size > SZINT) {  /* must check unread bytes */
    int mask = (!issigned || (lua_Integer)res >= 0) ? 0 : MC;
    for (i = limit; i < size; i++) {
      if ((unsigned char)str[islittle ? i : size - 1 - i] != mask)
        luaL_error(L, "%d-byte integer does not fit into Lua Integer", size);
    }
  }
  return (lua_Integer)res;
}


static int str_unpack (lua_State *L) {
  Header h;
  const char *fmt = luaL_checkstring(L, 1);
  size_t ld;
  const char *data = luaL_checklstring(L, 2, &ld);
  size_t pos = (size_t)posrelat(luaL_optinteger(L, 3, 1), ld) - 1;
  int n = 0;  /* number of results */
  luaL_argcheck(L, pos <= ld, 3, "initial position out of string");
  initheader(L, &h);
  while (*fmt != '\0') {
    int size, ntoalign;
    KOption opt = getdetails(&h, pos, &fmt, &size, &ntoalign);
    if ((size_t)ntoalign + size > ~pos || pos + ntoalign + size > ld)
      luaL_argerror(L, 2, "data string too short");
    pos += ntoalign;  /* skip alignment */
    /* stack space for item + next position */
    luaL_checkstack(L, 2, "too many results");
    n++;
    switch (opt) {
      case Kint:
      case Kuint: {
        lua_Integer res = unpackint(L, data + pos, h.islittle, size,
                                       (opt == Kint));
        lua_pushinteger(L, res);
        break;
      }
      case Kfloat: {
        volatile Ftypes u;
        lua_Number num;
        copywithendian(u.buff, data + pos, size, h.islittle);
        if (size == sizeof(u.f)) num = (lua_Number)u.f;
        else if (size == sizeof(u.d)) num = (lua_Number)u.d;
        else num = u.n;
        lua_pushnumber(L, num);
        break;
      }
      case Kchar: {
        lua_pushlstring(L, data + pos, size);
        break;
      }
      case Kstring: {
        size_t len = (size_t)unpackint(L, data + pos, h.islittle, size, 0);
        luaL_argcheck(L, pos + len + size <= ld, 2, "data string too short");
        lua_pushlstring(L, data + pos + size, len);
        pos += len;  /* skip string */
        break;
      }
      case Kzstr: {
        size_t len = (int)strlen(data + pos);
        lua_pushlstring(L, data + pos, len);
        pos += len + 1;  /* skip string plus final '\0' */
        break;
      }
      case Kpaddalign: case Kpadding: case Knop:
        n--;  /* undo increment */
        break;
    }
    pos += size;
  }
  lua_pushinteger(L, pos + 1);  /* next position */
  return n + 1;
}

/* }====================================================== */


static const luaL_Reg strlib[] = {
  {"byte", str_byte},
  {"char", str_char},
  {"dump", str_dump},
  {"find", str_find},
  {"format", str_format},
  {"gmatch", gmatch},
  {"gsub", str_gsub},
  {"len", str_len},
  {"lower", str_lower},
  {"match", str_match},
  {"rep", str_rep},
  {"reverse", str_reverse},
  {"sub", str_sub},
  {"upper", str_upper},
  {"pack", str_pack},
  {"packsize", str_packsize},
  {"unpack", str_unpack},
  {NULL, NULL}
};


static void createmetatable (lua_State *L) {
  lua_createtable(L, 0, 1);  /* table to be metatable for strings */
  lua_pushliteral(L, "");  /* dummy string */
  lua_pushvalue(L, -2);  /* copy table */
  lua_setmetatable(L, -2);  /* set table as metatable for strings */
  lua_pop(L, 1);  /* pop dummy string */
  lua_pushvalue(L, -2);  /* get string library */
  lua_setfield(L, -2, "__index");  /* metatable.__index = string */
  lua_pop(L, 1);  /* pop metatable */
}


/*
** Open string library
*/
LUAMOD_API int luaopen_string (lua_State *L) {
  luaL_newlib(L, strlib);
  createmetatable(L);
  return 1;
}


```

`src/Lua/ltable.c`:

```c
/*
** $Id: ltable.c,v 2.118 2016/11/07 12:38:35 roberto Exp $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/

#define ltable_c
#define LUA_CORE

#include "lprefix.h"


/*
** Implementation of tables (aka arrays, objects, or hash tables).
** Tables keep its elements in two parts: an array part and a hash part.
** Non-negative integer keys are all candidates to be kept in the array
** part. The actual size of the array is the largest 'n' such that
** more than half the slots between 1 and n are in use.
** Hash uses a mix of chained scatter table with Brent's variation.
** A main invariant of these tables is that, if an element is not
** in its main position (i.e. the 'original' position that its hash gives
** to it), then the colliding element is in its own main position.
** Hence even when the load factor reaches 100%, performance remains good.
*/

#include <math.h>
#include <limits.h>

#include "lua.h"

#include "ldebug.h"
#include "ldo.h"
#include "lgc.h"
#include "lmem.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"


/*
** Maximum size of array part (MAXASIZE) is 2^MAXABITS. MAXABITS is
** the largest integer such that MAXASIZE fits in an unsigned int.
*/
#define MAXABITS	cast_int(sizeof(int) * CHAR_BIT - 1)
#define MAXASIZE	(1u << MAXABITS)

/*
** Maximum size of hash part is 2^MAXHBITS. MAXHBITS is the largest
** integer such that 2^MAXHBITS fits in a signed int. (Note that the
** maximum number of elements in a table, 2^MAXABITS + 2^MAXHBITS, still
** fits comfortably in an unsigned int.)
*/
#define MAXHBITS	(MAXABITS - 1)


#define hashpow2(t,n)		(gnode(t, lmod((n), sizenode(t))))

#define hashstr(t,str)		hashpow2(t, (str)->hash)
#define hashboolean(t,p)	hashpow2(t, p)
#define hashint(t,i)		hashpow2(t, i)


/*
** for some types, it is better to avoid modulus by power of 2, as
** they tend to have many 2 factors.
*/
#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))


#define hashpointer(t,p)	hashmod(t, point2uint(p))


#define dummynode		(&dummynode_)

static const Node dummynode_ = {
  {NILCONSTANT},  /* value */
  {{NILCONSTANT, 0}}  /* key */
};


/*
** Hash for floating-point numbers.
** The main computation should be just
**     n = frexp(n, &i); return (n * INT_MAX) + i
** but there are some numerical subtleties.
** In a two-complement representation, INT_MAX does not has an exact
** representation as a float, but INT_MIN does; because the absolute
** value of 'frexp' is smaller than 1 (unless 'n' is inf/NaN), the
** absolute value of the product 'frexp * -INT_MIN' is smaller or equal
** to INT_MAX. Next, the use of 'unsigned int' avoids overflows when
** adding 'i'; the use of '~u' (instead of '-u') avoids problems with
** INT_MIN.
*/
#if !defined(l_hashfloat)
static int l_hashfloat (lua_Number n) {
  int i;
  lua_Integer ni;
  n = l_mathop(frexp)(n, &i) * -cast_num(INT_MIN);
  if (!lua_numbertointeger(n, &ni)) {  /* is 'n' inf/-inf/NaN? */
    lua_assert(luai_numisnan(n) || l_mathop(fabs)(n) == cast_num(HUGE_VAL));
    return 0;
  }
  else {  /* normal case */
    unsigned int u = cast(unsigned int, i) + cast(unsigned int, ni);
    return cast_int(u <= cast(unsigned int, INT_MAX) ? u : ~u);
  }
}
#endif


/*
** returns the 'main' position of an element in a table (that is, the index
** of its hash value)
*/
static Node *mainposition (const Table *t, const TValue *key) {
  switch (ttype(key)) {
    case LUA_TNUMINT:
      return hashint(t, ivalue(key));
    case LUA_TNUMFLT:
      return hashmod(t, l_hashfloat(fltvalue(key)));
    case LUA_TSHRSTR:
      return hashstr(t, tsvalue(key));
    case LUA_TLNGSTR:
      return hashpow2(t, luaS_hashlongstr(tsvalue(key)));
    case LUA_TBOOLEAN:
      return hashboolean(t, bvalue(key));
    case LUA_TLIGHTUSERDATA:
      return hashpointer(t, pvalue(key));
    case LUA_TLCF:
      return hashpointer(t, fvalue(key));
    default:
      lua_assert(!ttisdeadkey(key));
      return hashpointer(t, gcvalue(key));
  }
}


/*
** returns the index for 'key' if 'key' is an appropriate key to live in
** the array part of the table, 0 otherwise.
*/
static unsigned int arrayindex (const TValue *key) {
  if (ttisinteger(key)) {
    lua_Integer k = ivalue(key);
    if (0 < k && (lua_Unsigned)k <= MAXASIZE)
      return cast(unsigned int, k);  /* 'key' is an appropriate array index */
  }
  return 0;  /* 'key' did not match some condition */
}


/*
** returns the index of a 'key' for table traversals. First goes all
** elements in the array part, then elements in the hash part. The
** beginning of a traversal is signaled by 0.
*/
static unsigned int findindex (lua_State *L, Table *t, StkId key) {
  unsigned int i;
  if (ttisnil(key)) return 0;  /* first iteration */
  i = arrayindex(key);
  if (i != 0 && i <= t->sizearray)  /* is 'key' inside array part? */
    return i;  /* yes; that's the index */
  else {
    int nx;
    Node *n = mainposition(t, key);
    for (;;) {  /* check whether 'key' is somewhere in the chain */
      /* key may be dead already, but it is ok to use it in 'next' */
      if (luaV_rawequalobj(gkey(n), key) ||
            (ttisdeadkey(gkey(n)) && iscollectable(key) &&
             deadvalue(gkey(n)) == gcvalue(key))) {
        i = cast_int(n - gnode(t, 0));  /* key index in hash table */
        /* hash elements are numbered after array ones */
        return (i + 1) + t->sizearray;
      }
      nx = gnext(n);
      if (nx == 0)
        luaG_runerror(L, "invalid key to 'next'");  /* key not found */
      else n += nx;
    }
  }
}


int luaH_next (lua_State *L, Table *t, StkId key) {
  unsigned int i = findindex(L, t, key);  /* find original element */
  for (; i < t->sizearray; i++) {  /* try first array part */
    if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
      setivalue(key, i + 1);
      setobj2s(L, key+1, &t->array[i]);
      return 1;
    }
  }
  for (i -= t->sizearray; cast_int(i) < sizenode(t); i++) {  /* hash part */
    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
      setobj2s(L, key, gkey(gnode(t, i)));
      setobj2s(L, key+1, gval(gnode(t, i)));
      return 1;
    }
  }
  return 0;  /* no more elements */
}


/*
** {=============================================================
** Rehash
** ==============================================================
*/

/*
** Compute the optimal size for the array part of table 't'. 'nums' is a
** "count array" where 'nums[i]' is the number of integers in the table
** between 2^(i - 1) + 1 and 2^i. 'pna' enters with the total number of
** integer keys in the table and leaves with the number of keys that
** will go to the array part; return the optimal size.
*/
static unsigned int computesizes (unsigned int nums[], unsigned int *pna) {
  int i;
  unsigned int twotoi;  /* 2^i (candidate for optimal size) */
  unsigned int a = 0;  /* number of elements smaller than 2^i */
  unsigned int na = 0;  /* number of elements to go to array part */
  unsigned int optimal = 0;  /* optimal size for array part */
  /* loop while keys can fill more than half of total size */
  for (i = 0, twotoi = 1; *pna > twotoi / 2; i++, twotoi *= 2) {
    if (nums[i] > 0) {
      a += nums[i];
      if (a > twotoi/2) {  /* more than half elements present? */
        optimal = twotoi;  /* optimal size (till now) */
        na = a;  /* all elements up to 'optimal' will go to array part */
      }
    }
  }
  lua_assert((optimal == 0 || optimal / 2 < na) && na <= optimal);
  *pna = na;
  return optimal;
}


static int countint (const TValue *key, unsigned int *nums) {
  unsigned int k = arrayindex(key);
  if (k != 0) {  /* is 'key' an appropriate array index? */
    nums[luaO_ceillog2(k)]++;  /* count as such */
    return 1;
  }
  else
    return 0;
}


/*
** Count keys in array part of table 't': Fill 'nums[i]' with
** number of keys that will go into corresponding slice and return
** total number of non-nil keys.
*/
static unsigned int numusearray (const Table *t, unsigned int *nums) {
  int lg;
  unsigned int ttlg;  /* 2^lg */
  unsigned int ause = 0;  /* summation of 'nums' */
  unsigned int i = 1;  /* count to traverse all array keys */
  /* traverse each slice */
  for (lg = 0, ttlg = 1; lg <= MAXABITS; lg++, ttlg *= 2) {
    unsigned int lc = 0;  /* counter */
    unsigned int lim = ttlg;
    if (lim > t->sizearray) {
      lim = t->sizearray;  /* adjust upper limit */
      if (i > lim)
        break;  /* no more elements to count */
    }
    /* count elements in range (2^(lg - 1), 2^lg] */
    for (; i <= lim; i++) {
      if (!ttisnil(&t->array[i-1]))
        lc++;
    }
    nums[lg] += lc;
    ause += lc;
  }
  return ause;
}


static int numusehash (const Table *t, unsigned int *nums, unsigned int *pna) {
  int totaluse = 0;  /* total number of elements */
  int ause = 0;  /* elements added to 'nums' (can go to array part) */
  int i = sizenode(t);
  while (i--) {
    Node *n = &t->node[i];
    if (!ttisnil(gval(n))) {
      ause += countint(gkey(n), nums);
      totaluse++;
    }
  }
  *pna += ause;
  return totaluse;
}


static void setarrayvector (lua_State *L, Table *t, unsigned int size) {
  unsigned int i;
  luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
  for (i=t->sizearray; i<size; i++)
     setnilvalue(&t->array[i]);
  t->sizearray = size;
}


static void setnodevector (lua_State *L, Table *t, unsigned int size) {
  if (size == 0) {  /* no elements to hash part? */
    t->node = cast(Node *, dummynode);  /* use common 'dummynode' */
    t->lsizenode = 0;
    t->lastfree = NULL;  /* signal that it is using dummy node */
  }
  else {
    int i;
    int lsize = luaO_ceillog2(size);
    if (lsize > MAXHBITS)
      luaG_runerror(L, "table overflow");
    size = twoto(lsize);
    t->node = luaM_newvector(L, size, Node);
    for (i = 0; i < (int)size; i++) {
      Node *n = gnode(t, i);
      gnext(n) = 0;
      setnilvalue(wgkey(n));
      setnilvalue(gval(n));
    }
    t->lsizenode = cast_byte(lsize);
    t->lastfree = gnode(t, size);  /* all positions are free */
  }
}


void luaH_resize (lua_State *L, Table *t, unsigned int nasize,
                                          unsigned int nhsize) {
  unsigned int i;
  int j;
  unsigned int oldasize = t->sizearray;
  int oldhsize = allocsizenode(t);
  Node *nold = t->node;  /* save old hash ... */
  if (nasize > oldasize)  /* array part must grow? */
    setarrayvector(L, t, nasize);
  /* create new hash part with appropriate size */
  setnodevector(L, t, nhsize);
  if (nasize < oldasize) {  /* array part must shrink? */
    t->sizearray = nasize;
    /* re-insert elements from vanishing slice */
    for (i=nasize; i<oldasize; i++) {
      if (!ttisnil(&t->array[i]))
        luaH_setint(L, t, i + 1, &t->array[i]);
    }
    /* shrink array */
    luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
  }
  /* re-insert elements from hash part */
  for (j = oldhsize - 1; j >= 0; j--) {
    Node *old = nold + j;
    if (!ttisnil(gval(old))) {
      /* doesn't need barrier/invalidate cache, as entry was
         already present in the table */
      setobjt2t(L, luaH_set(L, t, gkey(old)), gval(old));
    }
  }
  if (oldhsize > 0)  /* not the dummy node? */
    luaM_freearray(L, nold, cast(size_t, oldhsize)); /* free old hash */
}


void luaH_resizearray (lua_State *L, Table *t, unsigned int nasize) {
  int nsize = allocsizenode(t);
  luaH_resize(L, t, nasize, nsize);
}

/*
** nums[i] = number of keys 'k' where 2^(i - 1) < k <= 2^i
*/
static void rehash (lua_State *L, Table *t, const TValue *ek) {
  unsigned int asize;  /* optimal size for array part */
  unsigned int na;  /* number of keys in the array part */
  unsigned int nums[MAXABITS + 1];
  int i;
  int totaluse;
  for (i = 0; i <= MAXABITS; i++) nums[i] = 0;  /* reset counts */
  na = numusearray(t, nums);  /* count keys in array part */
  totaluse = na;  /* all those keys are integer keys */
  totaluse += numusehash(t, nums, &na);  /* count keys in hash part */
  /* count extra key */
  na += countint(ek, nums);
  totaluse++;
  /* compute new size for array part */
  asize = computesizes(nums, &na);
  /* resize the table to new computed sizes */
  luaH_resize(L, t, asize, totaluse - na);
}



/*
** }=============================================================
*/


Table *luaH_new (lua_State *L) {
  GCObject *o = luaC_newobj(L, LUA_TTABLE, sizeof(Table));
  Table *t = gco2t(o);
  t->metatable = NULL;
  t->flags = cast_byte(~0);
  t->array = NULL;
  t->sizearray = 0;
  setnodevector(L, t, 0);
  return t;
}


void luaH_free (lua_State *L, Table *t) {
  if (!isdummy(t))
    luaM_freearray(L, t->node, cast(size_t, sizenode(t)));
  luaM_freearray(L, t->array, t->sizearray);
  luaM_free(L, t);
}


static Node *getfreepos (Table *t) {
  if (!isdummy(t)) {
    while (t->lastfree > t->node) {
      t->lastfree--;
      if (ttisnil(gkey(t->lastfree)))
        return t->lastfree;
    }
  }
  return NULL;  /* could not find a free place */
}



/*
** inserts a new key into a hash table; first, check whether key's main
** position is free. If not, check whether colliding node is in its main
** position or not: if it is not, move colliding node to an empty place and
** put new key in its main position; otherwise (colliding node is in its main
** position), new key goes to an empty position.
*/
TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
  Node *mp;
  TValue aux;
  if (ttisnil(key)) luaG_runerror(L, "table index is nil");
  else if (ttisfloat(key)) {
    lua_Integer k;
    if (luaV_tointeger(key, &k, 0)) {  /* does index fit in an integer? */
      setivalue(&aux, k);
      key = &aux;  /* insert it as an integer */
    }
    else if (luai_numisnan(fltvalue(key)))
      luaG_runerror(L, "table index is NaN");
  }
  mp = mainposition(t, key);
  if (!ttisnil(gval(mp)) || isdummy(t)) {  /* main position is taken? */
    Node *othern;
    Node *f = getfreepos(t);  /* get a free place */
    if (f == NULL) {  /* cannot find a free place? */
      rehash(L, t, key);  /* grow table */
      /* whatever called 'newkey' takes care of TM cache */
      return luaH_set(L, t, key);  /* insert key into grown table */
    }
    lua_assert(!isdummy(t));
    othern = mainposition(t, gkey(mp));
    if (othern != mp) {  /* is colliding node out of its main position? */
      /* yes; move colliding node into free position */
      while (othern + gnext(othern) != mp)  /* find previous */
        othern += gnext(othern);
      gnext(othern) = cast_int(f - othern);  /* rechain to point to 'f' */
      *f = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
      if (gnext(mp) != 0) {
        gnext(f) += cast_int(mp - f);  /* correct 'next' */
        gnext(mp) = 0;  /* now 'mp' is free */
      }
      setnilvalue(gval(mp));
    }
    else {  /* colliding node is in its own main position */
      /* new node will go into free position */
      if (gnext(mp) != 0)
        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */
      else lua_assert(gnext(f) == 0);
      gnext(mp) = cast_int(f - mp);
      mp = f;
    }
  }
  setnodekey(L, &mp->i_key, key);
  luaC_barrierback(L, t, key);
  lua_assert(ttisnil(gval(mp)));
  return gval(mp);
}


/*
** search function for integers
*/
const TValue *luaH_getint (Table *t, lua_Integer key) {
  /* (1 <= key && key <= t->sizearray) */
  if (l_castS2U(key) - 1 < t->sizearray)
    return &t->array[key - 1];
  else {
    Node *n = hashint(t, key);
    for (;;) {  /* check whether 'key' is somewhere in the chain */
      if (ttisinteger(gkey(n)) && ivalue(gkey(n)) == key)
        return gval(n);  /* that's it */
      else {
        int nx = gnext(n);
        if (nx == 0) break;
        n += nx;
      }
    }
    return luaO_nilobject;
  }
}


/*
** search function for short strings
*/
const TValue *luaH_getshortstr (Table *t, TString *key) {
  Node *n = hashstr(t, key);
  lua_assert(key->tt == LUA_TSHRSTR);
  for (;;) {  /* check whether 'key' is somewhere in the chain */
    const TValue *k = gkey(n);
    if (ttisshrstring(k) && eqshrstr(tsvalue(k), key))
      return gval(n);  /* that's it */
    else {
      int nx = gnext(n);
      if (nx == 0)
        return luaO_nilobject;  /* not found */
      n += nx;
    }
  }
}


/*
** "Generic" get version. (Not that generic: not valid for integers,
** which may be in array part, nor for floats with integral values.)
*/
static const TValue *getgeneric (Table *t, const TValue *key) {
  Node *n = mainposition(t, key);
  for (;;) {  /* check whether 'key' is somewhere in the chain */
    if (luaV_rawequalobj(gkey(n), key))
      return gval(n);  /* that's it */
    else {
      int nx = gnext(n);
      if (nx == 0)
        return luaO_nilobject;  /* not found */
      n += nx;
    }
  }
}


const TValue *luaH_getstr (Table *t, TString *key) {
  if (key->tt == LUA_TSHRSTR)
    return luaH_getshortstr(t, key);
  else {  /* for long strings, use generic case */
    TValue ko;
    setsvalue(cast(lua_State *, NULL), &ko, key);
    return getgeneric(t, &ko);
  }
}


/*
** main search function
*/
const TValue *luaH_get (Table *t, const TValue *key) {
  switch (ttype(key)) {
    case LUA_TSHRSTR: return luaH_getshortstr(t, tsvalue(key));
    case LUA_TNUMINT: return luaH_getint(t, ivalue(key));
    case LUA_TNIL: return luaO_nilobject;
    case LUA_TNUMFLT: {
      lua_Integer k;
      if (luaV_tointeger(key, &k, 0)) /* index is int? */
        return luaH_getint(t, k);  /* use specialized version */
      /* else... */
    }  /* FALLTHROUGH */
    default:
      return getgeneric(t, key);
  }
}


/*
** beware: when using this function you probably need to check a GC
** barrier and invalidate the TM cache.
*/
TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {
  const TValue *p = luaH_get(t, key);
  if (p != luaO_nilobject)
    return cast(TValue *, p);
  else return luaH_newkey(L, t, key);
}


void luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) {
  const TValue *p = luaH_getint(t, key);
  TValue *cell;
  if (p != luaO_nilobject)
    cell = cast(TValue *, p);
  else {
    TValue k;
    setivalue(&k, key);
    cell = luaH_newkey(L, t, &k);
  }
  setobj2t(L, cell, value);
}


static int unbound_search (Table *t, unsigned int j) {
  unsigned int i = j;  /* i is zero or a present index */
  j++;
  /* find 'i' and 'j' such that i is present and j is not */
  while (!ttisnil(luaH_getint(t, j))) {
    i = j;
    if (j > cast(unsigned int, MAX_INT)/2) {  /* overflow? */
      /* table was built with bad purposes: resort to linear search */
      i = 1;
      while (!ttisnil(luaH_getint(t, i))) i++;
      return i - 1;
    }
    j *= 2;
  }
  /* now do a binary search between them */
  while (j - i > 1) {
    unsigned int m = (i+j)/2;
    if (ttisnil(luaH_getint(t, m))) j = m;
    else i = m;
  }
  return i;
}


/*
** Try to find a boundary in table 't'. A 'boundary' is an integer index
** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
*/
int luaH_getn (Table *t) {
  unsigned int j = t->sizearray;
  if (j > 0 && ttisnil(&t->array[j - 1])) {
    /* there is a boundary in the array part: (binary) search for it */
    unsigned int i = 0;
    while (j - i > 1) {
      unsigned int m = (i+j)/2;
      if (ttisnil(&t->array[m - 1])) j = m;
      else i = m;
    }
    return i;
  }
  /* else must find a boundary in hash part */
  else if (isdummy(t))  /* hash part is empty? */
    return j;  /* that is easy... */
  else return unbound_search(t, j);
}



#if defined(LUA_DEBUG)

Node *luaH_mainposition (const Table *t, const TValue *key) {
  return mainposition(t, key);
}

int luaH_isdummy (const Table *t) { return isdummy(t); }

#endif

```

`src/Lua/ltable.h`:

```h
/*
** $Id: ltable.h,v 2.23 2016/12/22 13:08:50 roberto Exp $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/

#ifndef ltable_h
#define ltable_h

#include "lobject.h"


#define gnode(t,i)	(&(t)->node[i])
#define gval(n)		(&(n)->i_val)
#define gnext(n)	((n)->i_key.nk.next)


/* 'const' to avoid wrong writings that can mess up field 'next' */
#define gkey(n)		cast(const TValue*, (&(n)->i_key.tvk))

/*
** writable version of 'gkey'; allows updates to individual fields,
** but not to the whole (which has incompatible type)
*/
#define wgkey(n)		(&(n)->i_key.nk)

#define invalidateTMcache(t)	((t)->flags = 0)


/* true when 't' is using 'dummynode' as its hash part */
#define isdummy(t)		((t)->lastfree == NULL)


/* allocated size for hash nodes */
#define allocsizenode(t)	(isdummy(t) ? 0 : sizenode(t))


/* returns the key, given the value of a table entry */
#define keyfromval(v) \
  (gkey(cast(Node *, cast(char *, (v)) - offsetof(Node, i_val))))


LUAI_FUNC const TValue *luaH_getint (Table *t, lua_Integer key);
LUAI_FUNC void luaH_setint (lua_State *L, Table *t, lua_Integer key,
                                                    TValue *value);
LUAI_FUNC const TValue *luaH_getshortstr (Table *t, TString *key);
LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);
LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);
LUAI_FUNC TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key);
LUAI_FUNC TValue *luaH_set (lua_State *L, Table *t, const TValue *key);
LUAI_FUNC Table *luaH_new (lua_State *L);
LUAI_FUNC void luaH_resize (lua_State *L, Table *t, unsigned int nasize,
                                                    unsigned int nhsize);
LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, unsigned int nasize);
LUAI_FUNC void luaH_free (lua_State *L, Table *t);
LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);
LUAI_FUNC int luaH_getn (Table *t);


#if defined(LUA_DEBUG)
LUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);
LUAI_FUNC int luaH_isdummy (const Table *t);
#endif


#endif

```

`src/Lua/ltablib.c`:

```c
/*
** $Id: ltablib.c,v 1.93 2016/02/25 19:41:54 roberto Exp $
** Library for Table Manipulation
** See Copyright Notice in lua.h
*/

#define ltablib_c
#define LUA_LIB

#include "lprefix.h"


#include <limits.h>
#include <stddef.h>
#include <string.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"


/*
** Operations that an object must define to mimic a table
** (some functions only need some of them)
*/
#define TAB_R	1			/* read */
#define TAB_W	2			/* write */
#define TAB_L	4			/* length */
#define TAB_RW	(TAB_R | TAB_W)		/* read/write */


#define aux_getn(L,n,w)	(checktab(L, n, (w) | TAB_L), luaL_len(L, n))


static int checkfield (lua_State *L, const char *key, int n) {
  lua_pushstring(L, key);
  return (lua_rawget(L, -n) != LUA_TNIL);
}


/*
** Check that 'arg' either is a table or can behave like one (that is,
** has a metatable with the required metamethods)
*/
static void checktab (lua_State *L, int arg, int what) {
  if (lua_type(L, arg) != LUA_TTABLE) {  /* is it not a table? */
    int n = 1;  /* number of elements to pop */
    if (lua_getmetatable(L, arg) &&  /* must have metatable */
        (!(what & TAB_R) || checkfield(L, "__index", ++n)) &&
        (!(what & TAB_W) || checkfield(L, "__newindex", ++n)) &&
        (!(what & TAB_L) || checkfield(L, "__len", ++n))) {
      lua_pop(L, n);  /* pop metatable and tested metamethods */
    }
    else
      luaL_checktype(L, arg, LUA_TTABLE);  /* force an error */
  }
}


#if defined(LUA_COMPAT_MAXN)
static int maxn (lua_State *L) {
  lua_Number max = 0;
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_pushnil(L);  /* first key */
  while (lua_next(L, 1)) {
    lua_pop(L, 1);  /* remove value */
    if (lua_type(L, -1) == LUA_TNUMBER) {
      lua_Number v = lua_tonumber(L, -1);
      if (v > max) max = v;
    }
  }
  lua_pushnumber(L, max);
  return 1;
}
#endif


static int tinsert (lua_State *L) {
  lua_Integer e = aux_getn(L, 1, TAB_RW) + 1;  /* first empty element */
  lua_Integer pos;  /* where to insert new element */
  switch (lua_gettop(L)) {
    case 2: {  /* called with only 2 arguments */
      pos = e;  /* insert new element at the end */
      break;
    }
    case 3: {
      lua_Integer i;
      pos = luaL_checkinteger(L, 2);  /* 2nd argument is the position */
      luaL_argcheck(L, 1 <= pos && pos <= e, 2, "position out of bounds");
      for (i = e; i > pos; i--) {  /* move up elements */
        lua_geti(L, 1, i - 1);
        lua_seti(L, 1, i);  /* t[i] = t[i - 1] */
      }
      break;
    }
    default: {
      return luaL_error(L, "wrong number of arguments to 'insert'");
    }
  }
  lua_seti(L, 1, pos);  /* t[pos] = v */
  return 0;
}


static int tremove (lua_State *L) {
  lua_Integer size = aux_getn(L, 1, TAB_RW);
  lua_Integer pos = luaL_optinteger(L, 2, size);
  if (pos != size)  /* validate 'pos' if given */
    luaL_argcheck(L, 1 <= pos && pos <= size + 1, 1, "position out of bounds");
  lua_geti(L, 1, pos);  /* result = t[pos] */
  for ( ; pos < size; pos++) {
    lua_geti(L, 1, pos + 1);
    lua_seti(L, 1, pos);  /* t[pos] = t[pos + 1] */
  }
  lua_pushnil(L);
  lua_seti(L, 1, pos);  /* t[pos] = nil */
  return 1;
}


/*
** Copy elements (1[f], ..., 1[e]) into (tt[t], tt[t+1], ...). Whenever
** possible, copy in increasing order, which is better for rehashing.
** "possible" means destination after original range, or smaller
** than origin, or copying to another table.
*/
static int tmove (lua_State *L) {
  lua_Integer f = luaL_checkinteger(L, 2);
  lua_Integer e = luaL_checkinteger(L, 3);
  lua_Integer t = luaL_checkinteger(L, 4);
  int tt = !lua_isnoneornil(L, 5) ? 5 : 1;  /* destination table */
  checktab(L, 1, TAB_R);
  checktab(L, tt, TAB_W);
  if (e >= f) {  /* otherwise, nothing to move */
    lua_Integer n, i;
    luaL_argcheck(L, f > 0 || e < LUA_MAXINTEGER + f, 3,
                  "too many elements to move");
    n = e - f + 1;  /* number of elements to move */
    luaL_argcheck(L, t <= LUA_MAXINTEGER - n + 1, 4,
                  "destination wrap around");
    if (t > e || t <= f || (tt != 1 && !lua_compare(L, 1, tt, LUA_OPEQ))) {
      for (i = 0; i < n; i++) {
        lua_geti(L, 1, f + i);
        lua_seti(L, tt, t + i);
      }
    }
    else {
      for (i = n - 1; i >= 0; i--) {
        lua_geti(L, 1, f + i);
        lua_seti(L, tt, t + i);
      }
    }
  }
  lua_pushvalue(L, tt);  /* return destination table */
  return 1;
}


static void addfield (lua_State *L, luaL_Buffer *b, lua_Integer i) {
  lua_geti(L, 1, i);
  if (!lua_isstring(L, -1))
    luaL_error(L, "invalid value (%s) at index %d in table for 'concat'",
                  luaL_typename(L, -1), i);
  luaL_addvalue(b);
}


static int tconcat (lua_State *L) {
  luaL_Buffer b;
  lua_Integer last = aux_getn(L, 1, TAB_R);
  size_t lsep;
  const char *sep = luaL_optlstring(L, 2, "", &lsep);
  lua_Integer i = luaL_optinteger(L, 3, 1);
  last = luaL_optinteger(L, 4, last);
  luaL_buffinit(L, &b);
  for (; i < last; i++) {
    addfield(L, &b, i);
    luaL_addlstring(&b, sep, lsep);
  }
  if (i == last)  /* add last value (if interval was not empty) */
    addfield(L, &b, i);
  luaL_pushresult(&b);
  return 1;
}


/*
** {======================================================
** Pack/unpack
** =======================================================
*/

static int pack (lua_State *L) {
  int i;
  int n = lua_gettop(L);  /* number of elements to pack */
  lua_createtable(L, n, 1);  /* create result table */
  lua_insert(L, 1);  /* put it at index 1 */
  for (i = n; i >= 1; i--)  /* assign elements */
    lua_seti(L, 1, i);
  lua_pushinteger(L, n);
  lua_setfield(L, 1, "n");  /* t.n = number of elements */
  return 1;  /* return table */
}


static int unpack (lua_State *L) {
  lua_Unsigned n;
  lua_Integer i = luaL_optinteger(L, 2, 1);
  lua_Integer e = luaL_opt(L, luaL_checkinteger, 3, luaL_len(L, 1));
  if (i > e) return 0;  /* empty range */
  n = (lua_Unsigned)e - i;  /* number of elements minus 1 (avoid overflows) */
  if (n >= (unsigned int)INT_MAX  || !lua_checkstack(L, (int)(++n)))
    return luaL_error(L, "too many results to unpack");
  for (; i < e; i++) {  /* push arg[i..e - 1] (to avoid overflows) */
    lua_geti(L, 1, i);
  }
  lua_geti(L, 1, e);  /* push last element */
  return (int)n;
}

/* }====================================================== */



/*
** {======================================================
** Quicksort
** (based on 'Algorithms in MODULA-3', Robert Sedgewick;
**  Addison-Wesley, 1993.)
** =======================================================
*/


/* type for array indices */
typedef unsigned int IdxT;


/*
** Produce a "random" 'unsigned int' to randomize pivot choice. This
** macro is used only when 'sort' detects a big imbalance in the result
** of a partition. (If you don't want/need this "randomness", ~0 is a
** good choice.)
*/
#if !defined(l_randomizePivot)		/* { */

#include <time.h>

/* size of 'e' measured in number of 'unsigned int's */
#define sof(e)		(sizeof(e) / sizeof(unsigned int))

/*
** Use 'time' and 'clock' as sources of "randomness". Because we don't
** know the types 'clock_t' and 'time_t', we cannot cast them to
** anything without risking overflows. A safe way to use their values
** is to copy them to an array of a known type and use the array values.
*/
static unsigned int l_randomizePivot (void) {
  clock_t c = clock();
  time_t t = time(NULL);
  unsigned int buff[sof(c) + sof(t)];
  unsigned int i, rnd = 0;
  memcpy(buff, &c, sof(c) * sizeof(unsigned int));
  memcpy(buff + sof(c), &t, sof(t) * sizeof(unsigned int));
  for (i = 0; i < sof(buff); i++)
    rnd += buff[i];
  return rnd;
}

#endif					/* } */


/* arrays larger than 'RANLIMIT' may use randomized pivots */
#define RANLIMIT	100u


static void set2 (lua_State *L, IdxT i, IdxT j) {
  lua_seti(L, 1, i);
  lua_seti(L, 1, j);
}


/*
** Return true iff value at stack index 'a' is less than the value at
** index 'b' (according to the order of the sort).
*/
static int sort_comp (lua_State *L, int a, int b) {
  if (lua_isnil(L, 2))  /* no function? */
    return lua_compare(L, a, b, LUA_OPLT);  /* a < b */
  else {  /* function */
    int res;
    lua_pushvalue(L, 2);    /* push function */
    lua_pushvalue(L, a-1);  /* -1 to compensate function */
    lua_pushvalue(L, b-2);  /* -2 to compensate function and 'a' */
    lua_call(L, 2, 1);      /* call function */
    res = lua_toboolean(L, -1);  /* get result */
    lua_pop(L, 1);          /* pop result */
    return res;
  }
}


/*
** Does the partition: Pivot P is at the top of the stack.
** precondition: a[lo] <= P == a[up-1] <= a[up],
** so it only needs to do the partition from lo + 1 to up - 2.
** Pos-condition: a[lo .. i - 1] <= a[i] == P <= a[i + 1 .. up]
** returns 'i'.
*/
static IdxT partition (lua_State *L, IdxT lo, IdxT up) {
  IdxT i = lo;  /* will be incremented before first use */
  IdxT j = up - 1;  /* will be decremented before first use */
  /* loop invariant: a[lo .. i] <= P <= a[j .. up] */
  for (;;) {
    /* next loop: repeat ++i while a[i] < P */
    while (lua_geti(L, 1, ++i), sort_comp(L, -1, -2)) {
      if (i == up - 1)  /* a[i] < P  but a[up - 1] == P  ?? */
        luaL_error(L, "invalid order function for sorting");
      lua_pop(L, 1);  /* remove a[i] */
    }
    /* after the loop, a[i] >= P and a[lo .. i - 1] < P */
    /* next loop: repeat --j while P < a[j] */
    while (lua_geti(L, 1, --j), sort_comp(L, -3, -1)) {
      if (j < i)  /* j < i  but  a[j] > P ?? */
        luaL_error(L, "invalid order function for sorting");
      lua_pop(L, 1);  /* remove a[j] */
    }
    /* after the loop, a[j] <= P and a[j + 1 .. up] >= P */
    if (j < i) {  /* no elements out of place? */
      /* a[lo .. i - 1] <= P <= a[j + 1 .. i .. up] */
      lua_pop(L, 1);  /* pop a[j] */
      /* swap pivot (a[up - 1]) with a[i] to satisfy pos-condition */
      set2(L, up - 1, i);
      return i;
    }
    /* otherwise, swap a[i] - a[j] to restore invariant and repeat */
    set2(L, i, j);
  }
}


/*
** Choose an element in the middle (2nd-3th quarters) of [lo,up]
** "randomized" by 'rnd'
*/
static IdxT choosePivot (IdxT lo, IdxT up, unsigned int rnd) {
  IdxT r4 = (up - lo) / 4;  /* range/4 */
  IdxT p = rnd % (r4 * 2) + (lo + r4);
  lua_assert(lo + r4 <= p && p <= up - r4);
  return p;
}


/*
** QuickSort algorithm (recursive function)
*/
static void auxsort (lua_State *L, IdxT lo, IdxT up,
                                   unsigned int rnd) {
  while (lo < up) {  /* loop for tail recursion */
    IdxT p;  /* Pivot index */
    IdxT n;  /* to be used later */
    /* sort elements 'lo', 'p', and 'up' */
    lua_geti(L, 1, lo);
    lua_geti(L, 1, up);
    if (sort_comp(L, -1, -2))  /* a[up] < a[lo]? */
      set2(L, lo, up);  /* swap a[lo] - a[up] */
    else
      lua_pop(L, 2);  /* remove both values */
    if (up - lo == 1)  /* only 2 elements? */
      return;  /* already sorted */
    if (up - lo < RANLIMIT || rnd == 0)  /* small interval or no randomize? */
      p = (lo + up)/2;  /* middle element is a good pivot */
    else  /* for larger intervals, it is worth a random pivot */
      p = choosePivot(lo, up, rnd);
    lua_geti(L, 1, p);
    lua_geti(L, 1, lo);
    if (sort_comp(L, -2, -1))  /* a[p] < a[lo]? */
      set2(L, p, lo);  /* swap a[p] - a[lo] */
    else {
      lua_pop(L, 1);  /* remove a[lo] */
      lua_geti(L, 1, up);
      if (sort_comp(L, -1, -2))  /* a[up] < a[p]? */
        set2(L, p, up);  /* swap a[up] - a[p] */
      else
        lua_pop(L, 2);
    }
    if (up - lo == 2)  /* only 3 elements? */
      return;  /* already sorted */
    lua_geti(L, 1, p);  /* get middle element (Pivot) */
    lua_pushvalue(L, -1);  /* push Pivot */
    lua_geti(L, 1, up - 1);  /* push a[up - 1] */
    set2(L, p, up - 1);  /* swap Pivot (a[p]) with a[up - 1] */
    p = partition(L, lo, up);
    /* a[lo .. p - 1] <= a[p] == P <= a[p + 1 .. up] */
    if (p - lo < up - p) {  /* lower interval is smaller? */
      auxsort(L, lo, p - 1, rnd);  /* call recursively for lower interval */
      n = p - lo;  /* size of smaller interval */
      lo = p + 1;  /* tail call for [p + 1 .. up] (upper interval) */
    }
    else {
      auxsort(L, p + 1, up, rnd);  /* call recursively for upper interval */
      n = up - p;  /* size of smaller interval */
      up = p - 1;  /* tail call for [lo .. p - 1]  (lower interval) */
    }
    if ((up - lo) / 128 > n) /* partition too imbalanced? */
      rnd = l_randomizePivot();  /* try a new randomization */
  }  /* tail call auxsort(L, lo, up, rnd) */
}


static int sort (lua_State *L) {
  lua_Integer n = aux_getn(L, 1, TAB_RW);
  if (n > 1) {  /* non-trivial interval? */
    luaL_argcheck(L, n < INT_MAX, 1, "array too big");
    if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
      luaL_checktype(L, 2, LUA_TFUNCTION);  /* must be a function */
    lua_settop(L, 2);  /* make sure there are two arguments */
    auxsort(L, 1, (IdxT)n, 0);
  }
  return 0;
}

/* }====================================================== */


static const luaL_Reg tab_funcs[] = {
  {"concat", tconcat},
#if defined(LUA_COMPAT_MAXN)
  {"maxn", maxn},
#endif
  {"insert", tinsert},
  {"pack", pack},
  {"unpack", unpack},
  {"remove", tremove},
  {"move", tmove},
  {"sort", sort},
  {NULL, NULL}
};


LUAMOD_API int luaopen_table (lua_State *L) {
  luaL_newlib(L, tab_funcs);
#if defined(LUA_COMPAT_UNPACK)
  /* _G.unpack = table.unpack */
  lua_getfield(L, -1, "unpack");
  lua_setglobal(L, "unpack");
#endif
  return 1;
}


```

`src/Lua/ltm.c`:

```c
/*
** $Id: ltm.c,v 2.38 2016/12/22 13:08:50 roberto Exp $
** Tag methods
** See Copyright Notice in lua.h
*/

#define ltm_c
#define LUA_CORE

#include "lprefix.h"


#include <string.h>

#include "lua.h"

#include "ldebug.h"
#include "ldo.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"
#include "lvm.h"


static const char udatatypename[] = "userdata";

LUAI_DDEF const char *const luaT_typenames_[LUA_TOTALTAGS] = {
  "no value",
  "nil", "boolean", udatatypename, "number",
  "string", "table", "function", udatatypename, "thread",
  "proto" /* this last case is used for tests only */
};


void luaT_init (lua_State *L) {
  static const char *const luaT_eventname[] = {  /* ORDER TM */
    "__index", "__newindex",
    "__gc", "__mode", "__len", "__eq",
    "__add", "__sub", "__mul", "__mod", "__pow",
    "__div", "__idiv",
    "__band", "__bor", "__bxor", "__shl", "__shr",
    "__unm", "__bnot", "__lt", "__le",
    "__concat", "__call"
  };
  int i;
  for (i=0; i<TM_N; i++) {
    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
    luaC_fix(L, obj2gco(G(L)->tmname[i]));  /* never collect these names */
  }
}


/*
** function to be used with macro "fasttm": optimized for absence of
** tag methods
*/
const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
  const TValue *tm = luaH_getshortstr(events, ename);
  lua_assert(event <= TM_EQ);
  if (ttisnil(tm)) {  /* no tag method? */
    events->flags |= cast_byte(1u<<event);  /* cache this fact */
    return NULL;
  }
  else return tm;
}


const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
  Table *mt;
  switch (ttnov(o)) {
    case LUA_TTABLE:
      mt = hvalue(o)->metatable;
      break;
    case LUA_TUSERDATA:
      mt = uvalue(o)->metatable;
      break;
    default:
      mt = G(L)->mt[ttnov(o)];
  }
  return (mt ? luaH_getshortstr(mt, G(L)->tmname[event]) : luaO_nilobject);
}


/*
** Return the name of the type of an object. For tables and userdata
** with metatable, use their '__name' metafield, if present.
*/
const char *luaT_objtypename (lua_State *L, const TValue *o) {
  Table *mt;
  if ((ttistable(o) && (mt = hvalue(o)->metatable) != NULL) ||
      (ttisfulluserdata(o) && (mt = uvalue(o)->metatable) != NULL)) {
    const TValue *name = luaH_getshortstr(mt, luaS_new(L, "__name"));
    if (ttisstring(name))  /* is '__name' a string? */
      return getstr(tsvalue(name));  /* use it as type name */
  }
  return ttypename(ttnov(o));  /* else use standard type name */
}


void luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,
                  const TValue *p2, TValue *p3, int hasres) {
  ptrdiff_t result = savestack(L, p3);
  StkId func = L->top;
  setobj2s(L, func, f);  /* push function (assume EXTRA_STACK) */
  setobj2s(L, func + 1, p1);  /* 1st argument */
  setobj2s(L, func + 2, p2);  /* 2nd argument */
  L->top += 3;
  if (!hasres)  /* no result? 'p3' is third argument */
    setobj2s(L, L->top++, p3);  /* 3rd argument */
  /* metamethod may yield only when called from Lua code */
  if (isLua(L->ci))
    luaD_call(L, func, hasres);
  else
    luaD_callnoyield(L, func, hasres);
  if (hasres) {  /* if has result, move it to its place */
    p3 = restorestack(L, result);
    setobjs2s(L, p3, --L->top);
  }
}


int luaT_callbinTM (lua_State *L, const TValue *p1, const TValue *p2,
                    StkId res, TMS event) {
  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
  if (ttisnil(tm))
    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
  if (ttisnil(tm)) return 0;
  luaT_callTM(L, tm, p1, p2, res, 1);
  return 1;
}


void luaT_trybinTM (lua_State *L, const TValue *p1, const TValue *p2,
                    StkId res, TMS event) {
  if (!luaT_callbinTM(L, p1, p2, res, event)) {
    switch (event) {
      case TM_CONCAT:
        luaG_concaterror(L, p1, p2);
      /* call never returns, but to avoid warnings: *//* FALLTHROUGH */
      case TM_BAND: case TM_BOR: case TM_BXOR:
      case TM_SHL: case TM_SHR: case TM_BNOT: {
        lua_Number dummy;
        if (tonumber(p1, &dummy) && tonumber(p2, &dummy))
          luaG_tointerror(L, p1, p2);
        else
          luaG_opinterror(L, p1, p2, "perform bitwise operation on");
      }
      /* calls never return, but to avoid warnings: *//* FALLTHROUGH */
      default:
        luaG_opinterror(L, p1, p2, "perform arithmetic on");
    }
  }
}


int luaT_callorderTM (lua_State *L, const TValue *p1, const TValue *p2,
                      TMS event) {
  if (!luaT_callbinTM(L, p1, p2, L->top, event))
    return -1;  /* no metamethod */
  else
    return !l_isfalse(L->top);
}


```

`src/Lua/ltm.h`:

```h
/*
** $Id: ltm.h,v 2.22 2016/02/26 19:20:15 roberto Exp $
** Tag methods
** See Copyright Notice in lua.h
*/

#ifndef ltm_h
#define ltm_h


#include "lobject.h"


/*
* WARNING: if you change the order of this enumeration,
* grep "ORDER TM" and "ORDER OP"
*/
typedef enum {
  TM_INDEX,
  TM_NEWINDEX,
  TM_GC,
  TM_MODE,
  TM_LEN,
  TM_EQ,  /* last tag method with fast access */
  TM_ADD,
  TM_SUB,
  TM_MUL,
  TM_MOD,
  TM_POW,
  TM_DIV,
  TM_IDIV,
  TM_BAND,
  TM_BOR,
  TM_BXOR,
  TM_SHL,
  TM_SHR,
  TM_UNM,
  TM_BNOT,
  TM_LT,
  TM_LE,
  TM_CONCAT,
  TM_CALL,
  TM_N		/* number of elements in the enum */
} TMS;



#define gfasttm(g,et,e) ((et) == NULL ? NULL : \
  ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))

#define fasttm(l,et,e)	gfasttm(G(l), et, e)

#define ttypename(x)	luaT_typenames_[(x) + 1]

LUAI_DDEC const char *const luaT_typenames_[LUA_TOTALTAGS];


LUAI_FUNC const char *luaT_objtypename (lua_State *L, const TValue *o);

LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
                                                       TMS event);
LUAI_FUNC void luaT_init (lua_State *L);

LUAI_FUNC void luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,
                            const TValue *p2, TValue *p3, int hasres);
LUAI_FUNC int luaT_callbinTM (lua_State *L, const TValue *p1, const TValue *p2,
                              StkId res, TMS event);
LUAI_FUNC void luaT_trybinTM (lua_State *L, const TValue *p1, const TValue *p2,
                              StkId res, TMS event);
LUAI_FUNC int luaT_callorderTM (lua_State *L, const TValue *p1,
                                const TValue *p2, TMS event);



#endif

```

`src/Lua/lua.h`:

```h
/*
** $Id: lua.h,v 1.332 2016/12/22 15:51:20 roberto Exp $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/


#ifndef lua_h
#define lua_h

#include <stdarg.h>
#include <stddef.h>


#include "luaconf.h"


#define LUA_VERSION_MAJOR	"5"
#define LUA_VERSION_MINOR	"3"
#define LUA_VERSION_NUM		503
#define LUA_VERSION_RELEASE	"4"

#define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
#define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2017 Lua.org, PUC-Rio"
#define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"


/* mark for precompiled code ('<esc>Lua') */
#define LUA_SIGNATURE	"\x1bLua"

/* option for multiple returns in 'lua_pcall' and 'lua_call' */
#define LUA_MULTRET	(-1)


/*
** Pseudo-indices
** (-LUAI_MAXSTACK is the minimum valid index; we keep some free empty
** space after that to help overflow detection)
*/
#define LUA_REGISTRYINDEX	(-LUAI_MAXSTACK - 1000)
#define lua_upvalueindex(i)	(LUA_REGISTRYINDEX - (i))


/* thread status */
#define LUA_OK		0
#define LUA_YIELD	1
#define LUA_ERRRUN	2
#define LUA_ERRSYNTAX	3
#define LUA_ERRMEM	4
#define LUA_ERRGCMM	5
#define LUA_ERRERR	6


typedef struct lua_State lua_State;


/*
** basic types
*/
#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8

#define LUA_NUMTAGS		9



/* minimum Lua stack available to a C function */
#define LUA_MINSTACK	20


/* predefined values in the registry */
#define LUA_RIDX_MAINTHREAD	1
#define LUA_RIDX_GLOBALS	2
#define LUA_RIDX_LAST		LUA_RIDX_GLOBALS


/* type of numbers in Lua */
typedef LUA_NUMBER lua_Number;


/* type for integer functions */
typedef LUA_INTEGER lua_Integer;

/* unsigned integer type */
typedef LUA_UNSIGNED lua_Unsigned;

/* type for continuation-function contexts */
typedef LUA_KCONTEXT lua_KContext;


/*
** Type for C functions registered with Lua
*/
typedef int (*lua_CFunction) (lua_State *L);

/*
** Type for continuation functions
*/
typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);


/*
** Type for functions that read/write blocks when loading/dumping Lua chunks
*/
typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void *p, size_t sz, void *ud);


/*
** Type for memory-allocation functions
*/
typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);



/*
** generic extra include file
*/
#if defined(LUA_USER_H)
#include LUA_USER_H
#endif


/*
** RCS ident string
*/
extern const char lua_ident[];


/*
** state manipulation
*/
LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
LUA_API void       (lua_close) (lua_State *L);
LUA_API lua_State *(lua_newthread) (lua_State *L);

LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);


LUA_API const lua_Number *(lua_version) (lua_State *L);


/*
** basic stack manipulation
*/
LUA_API int   (lua_absindex) (lua_State *L, int idx);
LUA_API int   (lua_gettop) (lua_State *L);
LUA_API void  (lua_settop) (lua_State *L, int idx);
LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
LUA_API void  (lua_rotate) (lua_State *L, int idx, int n);
LUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);
LUA_API int   (lua_checkstack) (lua_State *L, int n);

LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);


/*
** access functions (stack -> C)
*/

LUA_API int             (lua_isnumber) (lua_State *L, int idx);
LUA_API int             (lua_isstring) (lua_State *L, int idx);
LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
LUA_API int             (lua_isinteger) (lua_State *L, int idx);
LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
LUA_API int             (lua_type) (lua_State *L, int idx);
LUA_API const char     *(lua_typename) (lua_State *L, int tp);

LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);
LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);
LUA_API int             (lua_toboolean) (lua_State *L, int idx);
LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);
LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
LUA_API const void     *(lua_topointer) (lua_State *L, int idx);


/*
** Comparison and arithmetic functions
*/

#define LUA_OPADD	0	/* ORDER TM, ORDER OP */
#define LUA_OPSUB	1
#define LUA_OPMUL	2
#define LUA_OPMOD	3
#define LUA_OPPOW	4
#define LUA_OPDIV	5
#define LUA_OPIDIV	6
#define LUA_OPBAND	7
#define LUA_OPBOR	8
#define LUA_OPBXOR	9
#define LUA_OPSHL	10
#define LUA_OPSHR	11
#define LUA_OPUNM	12
#define LUA_OPBNOT	13

LUA_API void  (lua_arith) (lua_State *L, int op);

#define LUA_OPEQ	0
#define LUA_OPLT	1
#define LUA_OPLE	2

LUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);
LUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);


/*
** push functions (C -> stack)
*/
LUA_API void        (lua_pushnil) (lua_State *L);
LUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);
LUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);
LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len);
LUA_API const char *(lua_pushstring) (lua_State *L, const char *s);
LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
LUA_API void  (lua_pushboolean) (lua_State *L, int b);
LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
LUA_API int   (lua_pushthread) (lua_State *L);


/*
** get functions (Lua -> stack)
*/
LUA_API int (lua_getglobal) (lua_State *L, const char *name);
LUA_API int (lua_gettable) (lua_State *L, int idx);
LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);
LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);
LUA_API int (lua_rawget) (lua_State *L, int idx);
LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n);
LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p);

LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
LUA_API int  (lua_getuservalue) (lua_State *L, int idx);


/*
** set functions (stack -> Lua)
*/
LUA_API void  (lua_setglobal) (lua_State *L, const char *name);
LUA_API void  (lua_settable) (lua_State *L, int idx);
LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_seti) (lua_State *L, int idx, lua_Integer n);
LUA_API void  (lua_rawset) (lua_State *L, int idx);
LUA_API void  (lua_rawseti) (lua_State *L, int idx, lua_Integer n);
LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);
LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
LUA_API void  (lua_setuservalue) (lua_State *L, int idx);


/*
** 'load' and 'call' functions (load and run Lua code)
*/
LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults,
                           lua_KContext ctx, lua_KFunction k);
#define lua_call(L,n,r)		lua_callk(L, (n), (r), 0, NULL)

LUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,
                            lua_KContext ctx, lua_KFunction k);
#define lua_pcall(L,n,r,f)	lua_pcallk(L, (n), (r), (f), 0, NULL)

LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                          const char *chunkname, const char *mode);

LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip);


/*
** coroutine functions
*/
LUA_API int  (lua_yieldk)     (lua_State *L, int nresults, lua_KContext ctx,
                               lua_KFunction k);
LUA_API int  (lua_resume)     (lua_State *L, lua_State *from, int narg);
LUA_API int  (lua_status)     (lua_State *L);
LUA_API int (lua_isyieldable) (lua_State *L);

#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)


/*
** garbage-collection function and options
*/

#define LUA_GCSTOP		0
#define LUA_GCRESTART		1
#define LUA_GCCOLLECT		2
#define LUA_GCCOUNT		3
#define LUA_GCCOUNTB		4
#define LUA_GCSTEP		5
#define LUA_GCSETPAUSE		6
#define LUA_GCSETSTEPMUL	7
#define LUA_GCISRUNNING		9

LUA_API int (lua_gc) (lua_State *L, int what, int data);


/*
** miscellaneous functions
*/

LUA_API int   (lua_error) (lua_State *L);

LUA_API int   (lua_next) (lua_State *L, int idx);

LUA_API void  (lua_concat) (lua_State *L, int n);
LUA_API void  (lua_len)    (lua_State *L, int idx);

LUA_API size_t   (lua_stringtonumber) (lua_State *L, const char *s);

LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);



/*
** {==============================================================
** some useful macros
** ===============================================================
*/

#define lua_getextraspace(L)	((void *)((char *)(L) - LUA_EXTRASPACE))

#define lua_tonumber(L,i)	lua_tonumberx(L,(i),NULL)
#define lua_tointeger(L,i)	lua_tointegerx(L,(i),NULL)

#define lua_pop(L,n)		lua_settop(L, -(n)-1)

#define lua_newtable(L)		lua_createtable(L, 0, 0)

#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))

#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)

#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)

#define lua_pushliteral(L, s)	lua_pushstring(L, "" s)

#define lua_pushglobaltable(L)  \
	((void)lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS))

#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)


#define lua_insert(L,idx)	lua_rotate(L, (idx), 1)

#define lua_remove(L,idx)	(lua_rotate(L, (idx), -1), lua_pop(L, 1))

#define lua_replace(L,idx)	(lua_copy(L, -1, (idx)), lua_pop(L, 1))

/* }============================================================== */


/*
** {==============================================================
** compatibility macros for unsigned conversions
** ===============================================================
*/
#if defined(LUA_COMPAT_APIINTCASTS)

#define lua_pushunsigned(L,n)	lua_pushinteger(L, (lua_Integer)(n))
#define lua_tounsignedx(L,i,is)	((lua_Unsigned)lua_tointegerx(L,i,is))
#define lua_tounsigned(L,i)	lua_tounsignedx(L,(i),NULL)

#endif
/* }============================================================== */

/*
** {======================================================================
** Debug API
** =======================================================================
*/


/*
** Event codes
*/
#define LUA_HOOKCALL	0
#define LUA_HOOKRET	1
#define LUA_HOOKLINE	2
#define LUA_HOOKCOUNT	3
#define LUA_HOOKTAILCALL 4


/*
** Event masks
*/
#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
#define LUA_MASKRET	(1 << LUA_HOOKRET)
#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)

typedef struct lua_Debug lua_Debug;  /* activation record */


/* Functions to be called by the debugger in specific events */
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


LUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);
LUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);
LUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);
LUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);

LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
                                               int fidx2, int n2);

LUA_API void (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
LUA_API lua_Hook (lua_gethook) (lua_State *L);
LUA_API int (lua_gethookmask) (lua_State *L);
LUA_API int (lua_gethookcount) (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;	/* (n) */
  const char *namewhat;	/* (n) 'global', 'local', 'field', 'method' */
  const char *what;	/* (S) 'Lua', 'C', 'main', 'tail' */
  const char *source;	/* (S) */
  int currentline;	/* (l) */
  int linedefined;	/* (S) */
  int lastlinedefined;	/* (S) */
  unsigned char nups;	/* (u) number of upvalues */
  unsigned char nparams;/* (u) number of parameters */
  char isvararg;        /* (u) */
  char istailcall;	/* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  struct CallInfo *i_ci;  /* active function */
};

/* }====================================================================== */


/******************************************************************************
* Copyright (C) 1994-2017 Lua.org, PUC-Rio.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/


#endif

```

`src/Lua/lua.hpp`:

```hpp
// lua.hpp
// Lua header files for C++
// <<extern "C">> not supplied automatically because Lua also compiles as C++

extern "C" {
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}

```

`src/Lua/luaconf.h`:

```h
/*
** $Id: luaconf.h,v 1.259 2016/12/22 13:08:50 roberto Exp $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/


#ifndef luaconf_h
#define luaconf_h

#include <limits.h>
#include <stddef.h>


/*
** ===================================================================
** Search for "@@" to find all configurable definitions.
** ===================================================================
*/


/*
** {====================================================================
** System Configuration: macros to adapt (if needed) Lua to some
** particular platform, for instance compiling it with 32-bit numbers or
** restricting it to C89.
** =====================================================================
*/

/*
@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats. You
** can also define LUA_32BITS in the make file, but changing here you
** ensure that all software connected to Lua will be compiled with the
** same configuration.
*/
/* #define LUA_32BITS */


/*
@@ LUA_USE_C89 controls the use of non-ISO-C89 features.
** Define it if you want Lua to avoid the use of a few C99 features
** or Windows-specific features on Windows.
*/
/* #define LUA_USE_C89 */


/*
** By default, Lua on Windows use (some) specific Windows features
*/
#if !defined(LUA_USE_C89) && defined(_WIN32) && !defined(_WIN32_WCE)
#define LUA_USE_WINDOWS  /* enable goodies for regular Windows */
#endif


#if defined(LUA_USE_WINDOWS)
#define LUA_DL_DLL	/* enable support for DLL */
#define LUA_USE_C89	/* broadly, Windows is C89 */
#endif


#if defined(LUA_USE_LINUX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
#define LUA_USE_READLINE	/* needs some extra libraries */
#endif


#if defined(LUA_USE_MACOSX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* MacOS does not need -ldl */
#define LUA_USE_READLINE	/* needs an extra library: -lreadline */
#endif


/*
@@ LUA_C89_NUMBERS ensures that Lua uses the largest types available for
** C89 ('long' and 'double'); Windows always has '__int64', so it does
** not need to use this case.
*/
#if defined(LUA_USE_C89) && !defined(LUA_USE_WINDOWS)
#define LUA_C89_NUMBERS
#endif



/*
@@ LUAI_BITSINT defines the (minimum) number of bits in an 'int'.
*/
/* avoid undefined shifts */
#if ((INT_MAX >> 15) >> 15) >= 1
#define LUAI_BITSINT	32
#else
/* 'int' always must have at least 16 bits */
#define LUAI_BITSINT	16
#endif


/*
@@ LUA_INT_TYPE defines the type for Lua integers.
@@ LUA_FLOAT_TYPE defines the type for Lua floats.
** Lua should work fine with any mix of these options (if supported
** by your C compiler). The usual configurations are 64-bit integers
** and 'double' (the default), 32-bit integers and 'float' (for
** restricted platforms), and 'long'/'double' (for C compilers not
** compliant with C99, which may not have support for 'long long').
*/

/* predefined options for LUA_INT_TYPE */
#define LUA_INT_INT		1
#define LUA_INT_LONG		2
#define LUA_INT_LONGLONG	3

/* predefined options for LUA_FLOAT_TYPE */
#define LUA_FLOAT_FLOAT		1
#define LUA_FLOAT_DOUBLE	2
#define LUA_FLOAT_LONGDOUBLE	3

#if defined(LUA_32BITS)		/* { */
/*
** 32-bit integers and 'float'
*/
#if LUAI_BITSINT >= 32  /* use 'int' if big enough */
#define LUA_INT_TYPE	LUA_INT_INT
#else  /* otherwise use 'long' */
#define LUA_INT_TYPE	LUA_INT_LONG
#endif
#define LUA_FLOAT_TYPE	LUA_FLOAT_FLOAT

#elif defined(LUA_C89_NUMBERS)	/* }{ */
/*
** largest types available for C89 ('long' and 'double')
*/
#define LUA_INT_TYPE	LUA_INT_LONG
#define LUA_FLOAT_TYPE	LUA_FLOAT_DOUBLE

#endif				/* } */


/*
** default configuration for 64-bit Lua ('long long' and 'double')
*/
#if !defined(LUA_INT_TYPE)
#define LUA_INT_TYPE	LUA_INT_LONGLONG
#endif

#if !defined(LUA_FLOAT_TYPE)
#define LUA_FLOAT_TYPE	LUA_FLOAT_DOUBLE
#endif

/* }================================================================== */




/*
** {==================================================================
** Configuration for Paths.
** ===================================================================
*/

/*
** LUA_PATH_SEP is the character that separates templates in a path.
** LUA_PATH_MARK is the string that marks the substitution points in a
** template.
** LUA_EXEC_DIR in a Windows path is replaced by the executable's
** directory.
*/
#define LUA_PATH_SEP            ";"
#define LUA_PATH_MARK           "?"
#define LUA_EXEC_DIR            "!"


/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
** Lua libraries.
@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
** C libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/
#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
#if defined(_WIN32)	/* { */
/*
** In Windows, any exclamation mark ('!') in the path is replaced by the
** path of the directory of the executable file of the current process.
*/
#ifdef _WIN64
#define libx "x64"
#else
#define libx "x32"
#endif
#define LUA_LDIR	"!\\lua\\"
#define LUA_CDIR	"!\\..\\lua\\"
#define LUA_SHRDIR	"!\\..\\lua\\"
#define LUA_PATH_DEFAULT  \
		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" \
		LUA_SHRDIR"?.lua;" LUA_SHRDIR"?\\init.lua;" \
        LUA_SHRDIR"libs\\?.lua;" LUA_SHRDIR"?\\libs\\init.lua;" \
		".\\?.lua;" ".\\?\\init.lua"
#define LUA_CPATH_DEFAULT \
		LUA_CDIR"?.dll;" \
        LUA_CDIR"dll\\" libx "\\?.dll;" \
		LUA_CDIR"libs\\dll\\" libx "\\?.dll;" \
		LUA_CDIR"loadall.dll;" ".\\?.dll"

#else			/* }{ */

#define LUA_ROOT	"/usr/local/"
#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR "/"
#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR "/"
#define LUA_PATH_DEFAULT  \
		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" \
		"./?.lua;" "./?/init.lua"
#define LUA_CPATH_DEFAULT \
		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so"
#endif			/* } */


/*
@@ LUA_DIRSEP is the directory separator (for submodules).
** CHANGE it if your machine does not use "/" as the directory separator
** and is not Windows. (On Windows Lua automatically uses "\".)
*/
#if defined(_WIN32)
#define LUA_DIRSEP	"\\"
#else
#define LUA_DIRSEP	"/"
#endif

/* }================================================================== */


/*
** {==================================================================
** Marks for exported symbols in the C code
** ===================================================================
*/

/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all auxiliary library functions.
@@ LUAMOD_API is a mark for all standard library opening functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
#if defined(LUA_BUILD_AS_DLL)	/* { */

#if defined(LUA_CORE) || defined(LUA_LIB)	/* { */
#define LUA_API __declspec(dllexport)
#else						/* }{ */
#define LUA_API __declspec(dllimport)
#endif						/* } */

#else				/* }{ */

#define LUA_API		extern

#endif				/* } */


/* more often than not the libs go together with the core */
#define LUALIB_API	LUA_API
#define LUAMOD_API	LUALIB_API


/*
@@ LUAI_FUNC is a mark for all extern functions that are not to be
** exported to outside modules.
@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables
** that are not to be exported to outside modules (LUAI_DDEF for
** definitions and LUAI_DDEC for declarations).
** CHANGE them if you need to mark them in some special way. Elf/gcc
** (versions 3.2 and later) mark them as "hidden" to optimize access
** when Lua is compiled as a shared library. Not all elf targets support
** this attribute. Unfortunately, gcc does not offer a way to check
** whether the target offers that support, and those without support
** give a warning about it. To avoid these warnings, change to the
** default definition.
*/
#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
    defined(__ELF__)		/* { */
#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
#else				/* }{ */
#define LUAI_FUNC	extern
#endif				/* } */

#define LUAI_DDEC	LUAI_FUNC
#define LUAI_DDEF	/* empty */

/* }================================================================== */


/*
** {==================================================================
** Compatibility with previous versions
** ===================================================================
*/

/*
@@ LUA_COMPAT_5_2 controls other macros for compatibility with Lua 5.2.
@@ LUA_COMPAT_5_1 controls other macros for compatibility with Lua 5.1.
** You can define it to get all options, or change specific options
** to fit your specific needs.
*/
#if defined(LUA_COMPAT_5_2)	/* { */

/*
@@ LUA_COMPAT_MATHLIB controls the presence of several deprecated
** functions in the mathematical library.
*/
#define LUA_COMPAT_MATHLIB

/*
@@ LUA_COMPAT_BITLIB controls the presence of library 'bit32'.
*/
#define LUA_COMPAT_BITLIB

/*
@@ LUA_COMPAT_IPAIRS controls the effectiveness of the __ipairs metamethod.
*/
#define LUA_COMPAT_IPAIRS

/*
@@ LUA_COMPAT_APIINTCASTS controls the presence of macros for
** manipulating other integer types (lua_pushunsigned, lua_tounsigned,
** luaL_checkint, luaL_checklong, etc.)
*/
#define LUA_COMPAT_APIINTCASTS

#endif				/* } */


#if defined(LUA_COMPAT_5_1)	/* { */

/* Incompatibilities from 5.2 -> 5.3 */
#define LUA_COMPAT_MATHLIB
#define LUA_COMPAT_APIINTCASTS

/*
@@ LUA_COMPAT_UNPACK controls the presence of global 'unpack'.
** You can replace it with 'table.unpack'.
*/
#define LUA_COMPAT_UNPACK

/*
@@ LUA_COMPAT_LOADERS controls the presence of table 'package.loaders'.
** You can replace it with 'package.searchers'.
*/
#define LUA_COMPAT_LOADERS

/*
@@ macro 'lua_cpcall' emulates deprecated function lua_cpcall.
** You can call your C function directly (with light C functions).
*/
#define lua_cpcall(L,f,u)  \
	(lua_pushcfunction(L, (f)), \
	 lua_pushlightuserdata(L,(u)), \
	 lua_pcall(L,1,0,0))


/*
@@ LUA_COMPAT_LOG10 defines the function 'log10' in the math library.
** You can rewrite 'log10(x)' as 'log(x, 10)'.
*/
#define LUA_COMPAT_LOG10

/*
@@ LUA_COMPAT_LOADSTRING defines the function 'loadstring' in the base
** library. You can rewrite 'loadstring(s)' as 'load(s)'.
*/
#define LUA_COMPAT_LOADSTRING

/*
@@ LUA_COMPAT_MAXN defines the function 'maxn' in the table library.
*/
#define LUA_COMPAT_MAXN

/*
@@ The following macros supply trivial compatibility for some
** changes in the API. The macros themselves document how to
** change your code to avoid using them.
*/
#define lua_strlen(L,i)		lua_rawlen(L, (i))

#define lua_objlen(L,i)		lua_rawlen(L, (i))

#define lua_equal(L,idx1,idx2)		lua_compare(L,(idx1),(idx2),LUA_OPEQ)
#define lua_lessthan(L,idx1,idx2)	lua_compare(L,(idx1),(idx2),LUA_OPLT)

/*
@@ LUA_COMPAT_MODULE controls compatibility with previous
** module functions 'module' (Lua) and 'luaL_register' (C).
*/
#define LUA_COMPAT_MODULE

#endif				/* } */


/*
@@ LUA_COMPAT_FLOATSTRING makes Lua format integral floats without a
@@ a float mark ('.0').
** This macro is not on by default even in compatibility mode,
** because this is not really an incompatibility.
*/
/* #define LUA_COMPAT_FLOATSTRING */

/* }================================================================== */



/*
** {==================================================================
** Configuration for Numbers.
** Change these definitions if no predefined LUA_FLOAT_* / LUA_INT_*
** satisfy your needs.
** ===================================================================
*/

/*
@@ LUA_NUMBER is the floating-point type used by Lua.
@@ LUAI_UACNUMBER is the result of a 'default argument promotion'
@@ over a floating number.
@@ l_mathlim(x) corrects limit name 'x' to the proper float type
** by prefixing it with one of FLT/DBL/LDBL.
@@ LUA_NUMBER_FRMLEN is the length modifier for writing floats.
@@ LUA_NUMBER_FMT is the format for writing floats.
@@ lua_number2str converts a float to a string.
@@ l_mathop allows the addition of an 'l' or 'f' to all math operations.
@@ l_floor takes the floor of a float.
@@ lua_str2number converts a decimal numeric string to a number.
*/


/* The following definitions are good for most cases here */

#define l_floor(x)		(l_mathop(floor)(x))

#define lua_number2str(s,sz,n)  \
	l_sprintf((s), sz, LUA_NUMBER_FMT, (LUAI_UACNUMBER)(n))

/*
@@ lua_numbertointeger converts a float number to an integer, or
** returns 0 if float is not within the range of a lua_Integer.
** (The range comparisons are tricky because of rounding. The tests
** here assume a two-complement representation, where MININTEGER always
** has an exact representation as a float; MAXINTEGER may not have one,
** and therefore its conversion to float may have an ill-defined value.)
*/
#define lua_numbertointeger(n,p) \
  ((n) >= (LUA_NUMBER)(LUA_MININTEGER) && \
   (n) < -(LUA_NUMBER)(LUA_MININTEGER) && \
      (*(p) = (LUA_INTEGER)(n), 1))


/* now the variable definitions */

#if LUA_FLOAT_TYPE == LUA_FLOAT_FLOAT		/* { single float */

#define LUA_NUMBER	float

#define l_mathlim(n)		(FLT_##n)

#define LUAI_UACNUMBER	double

#define LUA_NUMBER_FRMLEN	""
#define LUA_NUMBER_FMT		"%.7g"

#define l_mathop(op)		op##f

#define lua_str2number(s,p)	strtof((s), (p))


#elif LUA_FLOAT_TYPE == LUA_FLOAT_LONGDOUBLE	/* }{ long double */

#define LUA_NUMBER	long double

#define l_mathlim(n)		(LDBL_##n)

#define LUAI_UACNUMBER	long double

#define LUA_NUMBER_FRMLEN	"L"
#define LUA_NUMBER_FMT		"%.19Lg"

#define l_mathop(op)		op##l

#define lua_str2number(s,p)	strtold((s), (p))

#elif LUA_FLOAT_TYPE == LUA_FLOAT_DOUBLE	/* }{ double */

#define LUA_NUMBER	double

#define l_mathlim(n)		(DBL_##n)

#define LUAI_UACNUMBER	double

#define LUA_NUMBER_FRMLEN	""
#define LUA_NUMBER_FMT		"%.14g"

#define l_mathop(op)		op

#define lua_str2number(s,p)	strtod((s), (p))

#else						/* }{ */

#error "numeric float type not defined"

#endif					/* } */



/*
@@ LUA_INTEGER is the integer type used by Lua.
**
@@ LUA_UNSIGNED is the unsigned version of LUA_INTEGER.
**
@@ LUAI_UACINT is the result of a 'default argument promotion'
@@ over a lUA_INTEGER.
@@ LUA_INTEGER_FRMLEN is the length modifier for reading/writing integers.
@@ LUA_INTEGER_FMT is the format for writing integers.
@@ LUA_MAXINTEGER is the maximum value for a LUA_INTEGER.
@@ LUA_MININTEGER is the minimum value for a LUA_INTEGER.
@@ lua_integer2str converts an integer to a string.
*/


/* The following definitions are good for most cases here */

#define LUA_INTEGER_FMT		"%" LUA_INTEGER_FRMLEN "d"

#define LUAI_UACINT		LUA_INTEGER

#define lua_integer2str(s,sz,n)  \
	l_sprintf((s), sz, LUA_INTEGER_FMT, (LUAI_UACINT)(n))

/*
** use LUAI_UACINT here to avoid problems with promotions (which
** can turn a comparison between unsigneds into a signed comparison)
*/
#define LUA_UNSIGNED		unsigned LUAI_UACINT


/* now the variable definitions */

#if LUA_INT_TYPE == LUA_INT_INT		/* { int */

#define LUA_INTEGER		int
#define LUA_INTEGER_FRMLEN	""

#define LUA_MAXINTEGER		INT_MAX
#define LUA_MININTEGER		INT_MIN

#elif LUA_INT_TYPE == LUA_INT_LONG	/* }{ long */

#define LUA_INTEGER		long
#define LUA_INTEGER_FRMLEN	"l"

#define LUA_MAXINTEGER		LONG_MAX
#define LUA_MININTEGER		LONG_MIN

#elif LUA_INT_TYPE == LUA_INT_LONGLONG	/* }{ long long */

/* use presence of macro LLONG_MAX as proxy for C99 compliance */
#if defined(LLONG_MAX)		/* { */
/* use ISO C99 stuff */

#define LUA_INTEGER		long long
#define LUA_INTEGER_FRMLEN	"ll"

#define LUA_MAXINTEGER		LLONG_MAX
#define LUA_MININTEGER		LLONG_MIN

#elif defined(LUA_USE_WINDOWS) /* }{ */
/* in Windows, can use specific Windows types */

#define LUA_INTEGER		__int64
#define LUA_INTEGER_FRMLEN	"I64"

#define LUA_MAXINTEGER		_I64_MAX
#define LUA_MININTEGER		_I64_MIN

#else				/* }{ */

#error "Compiler does not support 'long long'. Use option '-DLUA_32BITS' \
  or '-DLUA_C89_NUMBERS' (see file 'luaconf.h' for details)"

#endif				/* } */

#else				/* }{ */

#error "numeric integer type not defined"

#endif				/* } */

/* }================================================================== */


/*
** {==================================================================
** Dependencies with C99 and other C details
** ===================================================================
*/

/*
@@ l_sprintf is equivalent to 'snprintf' or 'sprintf' in C89.
** (All uses in Lua have only one format item.)
*/
#if !defined(LUA_USE_C89)
#define l_sprintf(s,sz,f,i)	snprintf(s,sz,f,i)
#else
#define l_sprintf(s,sz,f,i)	((void)(sz), sprintf(s,f,i))
#endif


/*
@@ lua_strx2number converts an hexadecimal numeric string to a number.
** In C99, 'strtod' does that conversion. Otherwise, you can
** leave 'lua_strx2number' undefined and Lua will provide its own
** implementation.
*/
#if !defined(LUA_USE_C89)
#define lua_strx2number(s,p)		lua_str2number(s,p)
#endif


/*
@@ lua_number2strx converts a float to an hexadecimal numeric string.
** In C99, 'sprintf' (with format specifiers '%a'/'%A') does that.
** Otherwise, you can leave 'lua_number2strx' undefined and Lua will
** provide its own implementation.
*/
#if !defined(LUA_USE_C89)
#define lua_number2strx(L,b,sz,f,n)  \
	((void)L, l_sprintf(b,sz,f,(LUAI_UACNUMBER)(n)))
#endif


/*
** 'strtof' and 'opf' variants for math functions are not valid in
** C89. Otherwise, the macro 'HUGE_VALF' is a good proxy for testing the
** availability of these variants. ('math.h' is already included in
** all files that use these macros.)
*/
#if defined(LUA_USE_C89) || (defined(HUGE_VAL) && !defined(HUGE_VALF))
#undef l_mathop  /* variants not available */
#undef lua_str2number
#define l_mathop(op)		(lua_Number)op  /* no variant */
#define lua_str2number(s,p)	((lua_Number)strtod((s), (p)))
#endif


/*
@@ LUA_KCONTEXT is the type of the context ('ctx') for continuation
** functions.  It must be a numerical type; Lua will use 'intptr_t' if
** available, otherwise it will use 'ptrdiff_t' (the nearest thing to
** 'intptr_t' in C89)
*/
#define LUA_KCONTEXT	ptrdiff_t

#if !defined(LUA_USE_C89) && defined(__STDC_VERSION__) && \
    __STDC_VERSION__ >= 199901L
#include <stdint.h>
#if defined(INTPTR_MAX)  /* even in C99 this type is optional */
#undef LUA_KCONTEXT
#define LUA_KCONTEXT	intptr_t
#endif
#endif


/*
@@ lua_getlocaledecpoint gets the locale "radix character" (decimal point).
** Change that if you do not want to use C locales. (Code using this
** macro must include header 'locale.h'.)
*/
#if !defined(lua_getlocaledecpoint)
#define lua_getlocaledecpoint()		(localeconv()->decimal_point[0])
#endif

/* }================================================================== */


/*
** {==================================================================
** Language Variations
** =====================================================================
*/

/*
@@ LUA_NOCVTN2S/LUA_NOCVTS2N control how Lua performs some
** coercions. Define LUA_NOCVTN2S to turn off automatic coercion from
** numbers to strings. Define LUA_NOCVTS2N to turn off automatic
** coercion from strings to numbers.
*/
/* #define LUA_NOCVTN2S */
/* #define LUA_NOCVTS2N */


/*
@@ LUA_USE_APICHECK turns on several consistency checks on the C API.
** Define it as a help when debugging C code.
*/
#if defined(LUA_USE_APICHECK)
#include <assert.h>
#define luai_apicheck(l,e)	assert(e)
#endif

/* }================================================================== */


/*
** {==================================================================
** Macros that affect the API and must be stable (that is, must be the
** same when you compile Lua and when you compile code that links to
** Lua). You probably do not want/need to change them.
** =====================================================================
*/

/*
@@ LUAI_MAXSTACK limits the size of the Lua stack.
** CHANGE it if you need a different limit. This limit is arbitrary;
** its only purpose is to stop Lua from consuming unlimited stack
** space (and to reserve some numbers for pseudo-indices).
*/
#if LUAI_BITSINT >= 32
#define LUAI_MAXSTACK		1000000
#else
#define LUAI_MAXSTACK		15000
#endif


/*
@@ LUA_EXTRASPACE defines the size of a raw memory area associated with
** a Lua state with very fast access.
** CHANGE it if you need a different size.
*/
#define LUA_EXTRASPACE		(sizeof(void *))


/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@@ of a function in debug information.
** CHANGE it if you want a different size.
*/
#define LUA_IDSIZE	60


/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
** CHANGE it if it uses too much C-stack space. (For long double,
** 'string.format("%.99f", -1e4932)' needs 5034 bytes, so a
** smaller buffer would force a memory allocation for each call to
** 'string.format'.)
*/
#if LUA_FLOAT_TYPE == LUA_FLOAT_LONGDOUBLE
#define LUAL_BUFFERSIZE		8192
#else
#define LUAL_BUFFERSIZE   ((int)(0x80 * sizeof(void*) * sizeof(lua_Integer)))
#endif

/* }================================================================== */


/*
@@ LUA_QL describes how error messages quote program elements.
** Lua does not use these macros anymore; they are here for
** compatibility only.
*/
#define LUA_QL(x)	"'" x "'"
#define LUA_QS		LUA_QL("%s")




/* =================================================================== */

/*
** Local configuration. You can use this space to add your redefinitions
** without modifying the main part of the file.
*/





#endif


```

`src/Lua/lualib.h`:

```h
/*
** $Id: lualib.h,v 1.45 2017/01/12 17:14:26 roberto Exp $
** Lua standard libraries
** See Copyright Notice in lua.h
*/


#ifndef lualib_h
#define lualib_h

#include "lua.h"


/* version suffix for environment variable names */
#define LUA_VERSUFFIX          "_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR


LUAMOD_API int (luaopen_base) (lua_State *L);

#define LUA_COLIBNAME	"coroutine"
LUAMOD_API int (luaopen_coroutine) (lua_State *L);

#define LUA_TABLIBNAME	"table"
LUAMOD_API int (luaopen_table) (lua_State *L);

#define LUA_IOLIBNAME	"io"
LUAMOD_API int (luaopen_io) (lua_State *L);

#define LUA_OSLIBNAME	"os"
LUAMOD_API int (luaopen_os) (lua_State *L);

#define LUA_STRLIBNAME	"string"
LUAMOD_API int (luaopen_string) (lua_State *L);

#define LUA_UTF8LIBNAME	"utf8"
LUAMOD_API int (luaopen_utf8) (lua_State *L);

#define LUA_BITLIBNAME	"bit32"
LUAMOD_API int (luaopen_bit32) (lua_State *L);

#define LUA_MATHLIBNAME	"math"
LUAMOD_API int (luaopen_math) (lua_State *L);

#define LUA_DBLIBNAME	"debug"
LUAMOD_API int (luaopen_debug) (lua_State *L);

#define LUA_LOADLIBNAME	"package"
LUAMOD_API int (luaopen_package) (lua_State *L);


/* open all previous libraries */
LUALIB_API void (luaL_openlibs) (lua_State *L);



#if !defined(lua_assert)
#define lua_assert(x)	((void)0)
#endif


#endif

```

`src/Lua/lundump.c`:

```c
/*
** $Id: lundump.c,v 2.44 2015/11/02 16:09:30 roberto Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/

#define lundump_c
#define LUA_CORE

#include "lprefix.h"


#include <string.h>

#include "lua.h"

#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lmem.h"
#include "lobject.h"
#include "lstring.h"
#include "lundump.h"
#include "lzio.h"


#if !defined(luai_verifycode)
#define luai_verifycode(L,b,f)  /* empty */
#endif


typedef struct {
  lua_State *L;
  ZIO *Z;
  const char *name;
} LoadState;


static l_noret error(LoadState *S, const char *why) {
  luaO_pushfstring(S->L, "%s: %s precompiled chunk", S->name, why);
  luaD_throw(S->L, LUA_ERRSYNTAX);
}


/*
** All high-level loads go through LoadVector; you can change it to
** adapt to the endianness of the input
*/
#define LoadVector(S,b,n)	LoadBlock(S,b,(n)*sizeof((b)[0]))

static void LoadBlock (LoadState *S, void *b, size_t size) {
  if (luaZ_read(S->Z, b, size) != 0)
    error(S, "truncated");
}


#define LoadVar(S,x)		LoadVector(S,&x,1)


static lu_byte LoadByte (LoadState *S) {
  lu_byte x;
  LoadVar(S, x);
  return x;
}


static int LoadInt (LoadState *S) {
  int x;
  LoadVar(S, x);
  return x;
}


static lua_Number LoadNumber (LoadState *S) {
  lua_Number x;
  LoadVar(S, x);
  return x;
}


static lua_Integer LoadInteger (LoadState *S) {
  lua_Integer x;
  LoadVar(S, x);
  return x;
}


static TString *LoadString (LoadState *S) {
  size_t size = LoadByte(S);
  if (size == 0xFF)
    LoadVar(S, size);
  if (size == 0)
    return NULL;
  else if (--size <= LUAI_MAXSHORTLEN) {  /* short string? */
    char buff[LUAI_MAXSHORTLEN];
    LoadVector(S, buff, size);
    return luaS_newlstr(S->L, buff, size);
  }
  else {  /* long string */
    TString *ts = luaS_createlngstrobj(S->L, size);
    LoadVector(S, getstr(ts), size);  /* load directly in final place */
    return ts;
  }
}


static void LoadCode (LoadState *S, Proto *f) {
  int n = LoadInt(S);
  f->code = luaM_newvector(S->L, n, Instruction);
  f->sizecode = n;
  LoadVector(S, f->code, n);
}


static void LoadFunction(LoadState *S, Proto *f, TString *psource);


static void LoadConstants (LoadState *S, Proto *f) {
  int i;
  int n = LoadInt(S);
  f->k = luaM_newvector(S->L, n, TValue);
  f->sizek = n;
  for (i = 0; i < n; i++)
    setnilvalue(&f->k[i]);
  for (i = 0; i < n; i++) {
    TValue *o = &f->k[i];
    int t = LoadByte(S);
    switch (t) {
    case LUA_TNIL:
      setnilvalue(o);
      break;
    case LUA_TBOOLEAN:
      setbvalue(o, LoadByte(S));
      break;
    case LUA_TNUMFLT:
      setfltvalue(o, LoadNumber(S));
      break;
    case LUA_TNUMINT:
      setivalue(o, LoadInteger(S));
      break;
    case LUA_TSHRSTR:
    case LUA_TLNGSTR:
      setsvalue2n(S->L, o, LoadString(S));
      break;
    default:
      lua_assert(0);
    }
  }
}


static void LoadProtos (LoadState *S, Proto *f) {
  int i;
  int n = LoadInt(S);
  f->p = luaM_newvector(S->L, n, Proto *);
  f->sizep = n;
  for (i = 0; i < n; i++)
    f->p[i] = NULL;
  for (i = 0; i < n; i++) {
    f->p[i] = luaF_newproto(S->L);
    LoadFunction(S, f->p[i], f->source);
  }
}


static void LoadUpvalues (LoadState *S, Proto *f) {
  int i, n;
  n = LoadInt(S);
  f->upvalues = luaM_newvector(S->L, n, Upvaldesc);
  f->sizeupvalues = n;
  for (i = 0; i < n; i++)
    f->upvalues[i].name = NULL;
  for (i = 0; i < n; i++) {
    f->upvalues[i].instack = LoadByte(S);
    f->upvalues[i].idx = LoadByte(S);
  }
}


static void LoadDebug (LoadState *S, Proto *f) {
  int i, n;
  n = LoadInt(S);
  f->lineinfo = luaM_newvector(S->L, n, int);
  f->sizelineinfo = n;
  LoadVector(S, f->lineinfo, n);
  n = LoadInt(S);
  f->locvars = luaM_newvector(S->L, n, LocVar);
  f->sizelocvars = n;
  for (i = 0; i < n; i++)
    f->locvars[i].varname = NULL;
  for (i = 0; i < n; i++) {
    f->locvars[i].varname = LoadString(S);
    f->locvars[i].startpc = LoadInt(S);
    f->locvars[i].endpc = LoadInt(S);
  }
  n = LoadInt(S);
  for (i = 0; i < n; i++)
    f->upvalues[i].name = LoadString(S);
}


static void LoadFunction (LoadState *S, Proto *f, TString *psource) {
  f->source = LoadString(S);
  if (f->source == NULL)  /* no source in dump? */
    f->source = psource;  /* reuse parent's source */
  f->linedefined = LoadInt(S);
  f->lastlinedefined = LoadInt(S);
  f->numparams = LoadByte(S);
  f->is_vararg = LoadByte(S);
  f->maxstacksize = LoadByte(S);
  LoadCode(S, f);
  LoadConstants(S, f);
  LoadUpvalues(S, f);
  LoadProtos(S, f);
  LoadDebug(S, f);
}


static void checkliteral (LoadState *S, const char *s, const char *msg) {
  char buff[sizeof(LUA_SIGNATURE) + sizeof(LUAC_DATA)]; /* larger than both */
  size_t len = strlen(s);
  LoadVector(S, buff, len);
  if (memcmp(s, buff, len) != 0)
    error(S, msg);
}


static void fchecksize (LoadState *S, size_t size, const char *tname) {
  if (LoadByte(S) != size)
    error(S, luaO_pushfstring(S->L, "%s size mismatch in", tname));
}


#define checksize(S,t)	fchecksize(S,sizeof(t),#t)

static void checkHeader (LoadState *S) {
  checkliteral(S, LUA_SIGNATURE + 1, "not a");  /* 1st char already checked */
  if (LoadByte(S) != LUAC_VERSION)
    error(S, "version mismatch in");
  if (LoadByte(S) != LUAC_FORMAT)
    error(S, "format mismatch in");
  checkliteral(S, LUAC_DATA, "corrupted");
  checksize(S, int);
  checksize(S, size_t);
  checksize(S, Instruction);
  checksize(S, lua_Integer);
  checksize(S, lua_Number);
  if (LoadInteger(S) != LUAC_INT)
    error(S, "endianness mismatch in");
  if (LoadNumber(S) != LUAC_NUM)
    error(S, "float format mismatch in");
}


/*
** load precompiled chunk
*/
LClosure *luaU_undump(lua_State *L, ZIO *Z, const char *name) {
  LoadState S;
  LClosure *cl;
  if (*name == '@' || *name == '=')
    S.name = name + 1;
  else if (*name == LUA_SIGNATURE[0])
    S.name = "binary string";
  else
    S.name = name;
  S.L = L;
  S.Z = Z;
  checkHeader(&S);
  cl = luaF_newLclosure(L, LoadByte(&S));
  setclLvalue(L, L->top, cl);
  luaD_inctop(L);
  cl->p = luaF_newproto(L);
  LoadFunction(&S, cl->p, NULL);
  lua_assert(cl->nupvalues == cl->p->sizeupvalues);
  luai_verifycode(L, buff, cl->p);
  return cl;
}


```

`src/Lua/lundump.h`:

```h
/*
** $Id: lundump.h,v 1.45 2015/09/08 15:41:05 roberto Exp $
** load precompiled Lua chunks
** See Copyright Notice in lua.h
*/

#ifndef lundump_h
#define lundump_h

#include "llimits.h"
#include "lobject.h"
#include "lzio.h"


/* data to catch conversion errors */
#define LUAC_DATA	"\x19\x93\r\n\x1a\n"

#define LUAC_INT	0x5678
#define LUAC_NUM	cast_num(370.5)

#define MYINT(s)	(s[0]-'0')
#define LUAC_VERSION	(MYINT(LUA_VERSION_MAJOR)*16+MYINT(LUA_VERSION_MINOR))
#define LUAC_FORMAT	0	/* this is the official format */

/* load one chunk; from lundump.c */
LUAI_FUNC LClosure* luaU_undump (lua_State* L, ZIO* Z, const char* name);

/* dump one chunk; from ldump.c */
LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w,
                         void* data, int strip);

#endif

```

`src/Lua/lutf8lib.c`:

```c
/*
** $Id: lutf8lib.c,v 1.16 2016/12/22 13:08:50 roberto Exp $
** Standard library for UTF-8 manipulation
** See Copyright Notice in lua.h
*/

#define lutf8lib_c
#define LUA_LIB

#include "lprefix.h"


#include <assert.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"

#define MAXUNICODE	0x10FFFF

#define iscont(p)	((*(p) & 0xC0) == 0x80)


/* from strlib */
/* translate a relative string position: negative means back from end */
static lua_Integer u_posrelat (lua_Integer pos, size_t len) {
  if (pos >= 0) return pos;
  else if (0u - (size_t)pos > len) return 0;
  else return (lua_Integer)len + pos + 1;
}


/*
** Decode one UTF-8 sequence, returning NULL if byte sequence is invalid.
*/
static const char *utf8_decode (const char *o, int *val) {
  static const unsigned int limits[] = {0xFF, 0x7F, 0x7FF, 0xFFFF};
  const unsigned char *s = (const unsigned char *)o;
  unsigned int c = s[0];
  unsigned int res = 0;  /* final result */
  if (c < 0x80)  /* ascii? */
    res = c;
  else {
    int count = 0;  /* to count number of continuation bytes */
    while (c & 0x40) {  /* still have continuation bytes? */
      int cc = s[++count];  /* read next byte */
      if ((cc & 0xC0) != 0x80)  /* not a continuation byte? */
        return NULL;  /* invalid byte sequence */
      res = (res << 6) | (cc & 0x3F);  /* add lower 6 bits from cont. byte */
      c <<= 1;  /* to test next bit */
    }
    res |= ((c & 0x7F) << (count * 5));  /* add first byte */
    if (count > 3 || res > MAXUNICODE || res <= limits[count])
      return NULL;  /* invalid byte sequence */
    s += count;  /* skip continuation bytes read */
  }
  if (val) *val = res;
  return (const char *)s + 1;  /* +1 to include first byte */
}


/*
** utf8len(s [, i [, j]]) --> number of characters that start in the
** range [i,j], or nil + current position if 's' is not well formed in
** that interval
*/
static int utflen (lua_State *L) {
  int n = 0;
  size_t len;
  const char *s = luaL_checklstring(L, 1, &len);
  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);
  lua_Integer posj = u_posrelat(luaL_optinteger(L, 3, -1), len);
  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 2,
                   "initial position out of string");
  luaL_argcheck(L, --posj < (lua_Integer)len, 3,
                   "final position out of string");
  while (posi <= posj) {
    const char *s1 = utf8_decode(s + posi, NULL);
    if (s1 == NULL) {  /* conversion error? */
      lua_pushnil(L);  /* return nil ... */
      lua_pushinteger(L, posi + 1);  /* ... and current position */
      return 2;
    }
    posi = s1 - s;
    n++;
  }
  lua_pushinteger(L, n);
  return 1;
}


/*
** codepoint(s, [i, [j]])  -> returns codepoints for all characters
** that start in the range [i,j]
*/
static int codepoint (lua_State *L) {
  size_t len;
  const char *s = luaL_checklstring(L, 1, &len);
  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);
  lua_Integer pose = u_posrelat(luaL_optinteger(L, 3, posi), len);
  int n;
  const char *se;
  luaL_argcheck(L, posi >= 1, 2, "out of range");
  luaL_argcheck(L, pose <= (lua_Integer)len, 3, "out of range");
  if (posi > pose) return 0;  /* empty interval; return no values */
  if (pose - posi >= INT_MAX)  /* (lua_Integer -> int) overflow? */
    return luaL_error(L, "string slice too long");
  n = (int)(pose -  posi) + 1;
  luaL_checkstack(L, n, "string slice too long");
  n = 0;
  se = s + pose;
  for (s += posi - 1; s < se;) {
    int code;
    s = utf8_decode(s, &code);
    if (s == NULL)
      return luaL_error(L, "invalid UTF-8 code");
    lua_pushinteger(L, code);
    n++;
  }
  return n;
}


static void pushutfchar (lua_State *L, int arg) {
  lua_Integer code = luaL_checkinteger(L, arg);
  luaL_argcheck(L, 0 <= code && code <= MAXUNICODE, arg, "value out of range");
  lua_pushfstring(L, "%U", (long)code);
}


/*
** utfchar(n1, n2, ...)  -> char(n1)..char(n2)...
*/
static int utfchar (lua_State *L) {
  int n = lua_gettop(L);  /* number of arguments */
  if (n == 1)  /* optimize common case of single char */
    pushutfchar(L, 1);
  else {
    int i;
    luaL_Buffer b;
    luaL_buffinit(L, &b);
    for (i = 1; i <= n; i++) {
      pushutfchar(L, i);
      luaL_addvalue(&b);
    }
    luaL_pushresult(&b);
  }
  return 1;
}


/*
** offset(s, n, [i])  -> index where n-th character counting from
**   position 'i' starts; 0 means character at 'i'.
*/
static int byteoffset (lua_State *L) {
  size_t len;
  const char *s = luaL_checklstring(L, 1, &len);
  lua_Integer n  = luaL_checkinteger(L, 2);
  lua_Integer posi = (n >= 0) ? 1 : len + 1;
  posi = u_posrelat(luaL_optinteger(L, 3, posi), len);
  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 3,
                   "position out of range");
  if (n == 0) {
    /* find beginning of current byte sequence */
    while (posi > 0 && iscont(s + posi)) posi--;
  }
  else {
    if (iscont(s + posi))
      luaL_error(L, "initial position is a continuation byte");
    if (n < 0) {
       while (n < 0 && posi > 0) {  /* move back */
         do {  /* find beginning of previous character */
           posi--;
         } while (posi > 0 && iscont(s + posi));
         n++;
       }
     }
     else {
       n--;  /* do not move for 1st character */
       while (n > 0 && posi < (lua_Integer)len) {
         do {  /* find beginning of next character */
           posi++;
         } while (iscont(s + posi));  /* (cannot pass final '\0') */
         n--;
       }
     }
  }
  if (n == 0)  /* did it find given character? */
    lua_pushinteger(L, posi + 1);
  else  /* no such character */
    lua_pushnil(L);
  return 1;
}


static int iter_aux (lua_State *L) {
  size_t len;
  const char *s = luaL_checklstring(L, 1, &len);
  lua_Integer n = lua_tointeger(L, 2) - 1;
  if (n < 0)  /* first iteration? */
    n = 0;  /* start from here */
  else if (n < (lua_Integer)len) {
    n++;  /* skip current byte */
    while (iscont(s + n)) n++;  /* and its continuations */
  }
  if (n >= (lua_Integer)len)
    return 0;  /* no more codepoints */
  else {
    int code;
    const char *next = utf8_decode(s + n, &code);
    if (next == NULL || iscont(next))
      return luaL_error(L, "invalid UTF-8 code");
    lua_pushinteger(L, n + 1);
    lua_pushinteger(L, code);
    return 2;
  }
}


static int iter_codes (lua_State *L) {
  luaL_checkstring(L, 1);
  lua_pushcfunction(L, iter_aux);
  lua_pushvalue(L, 1);
  lua_pushinteger(L, 0);
  return 3;
}


/* pattern to match a single UTF-8 character */
#define UTF8PATT	"[\0-\x7F\xC2-\xF4][\x80-\xBF]*"


static const luaL_Reg funcs[] = {
  {"offset", byteoffset},
  {"codepoint", codepoint},
  {"char", utfchar},
  {"len", utflen},
  {"codes", iter_codes},
  /* placeholders */
  {"charpattern", NULL},
  {NULL, NULL}
};


LUAMOD_API int luaopen_utf8 (lua_State *L) {
  luaL_newlib(L, funcs);
  lua_pushlstring(L, UTF8PATT, sizeof(UTF8PATT)/sizeof(char) - 1);
  lua_setfield(L, -2, "charpattern");
  return 1;
}


```

`src/Lua/lvm.c`:

```c
/*
** $Id: lvm.c,v 2.268 2016/02/05 19:59:14 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

#define lvm_c
#define LUA_CORE

#include "lprefix.h"

#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "lua.h"

#include "ldebug.h"
#include "ldo.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lopcodes.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "ltm.h"
#include "lvm.h"


/* limit for table tag-method chains (to avoid loops) */
#define MAXTAGLOOP	2000



/*
** 'l_intfitsf' checks whether a given integer can be converted to a
** float without rounding. Used in comparisons. Left undefined if
** all integers fit in a float precisely.
*/
#if !defined(l_intfitsf)

/* number of bits in the mantissa of a float */
#define NBM		(l_mathlim(MANT_DIG))

/*
** Check whether some integers may not fit in a float, that is, whether
** (maxinteger >> NBM) > 0 (that implies (1 << NBM) <= maxinteger).
** (The shifts are done in parts to avoid shifting by more than the size
** of an integer. In a worst case, NBM == 113 for long double and
** sizeof(integer) == 32.)
*/
#if ((((LUA_MAXINTEGER >> (NBM / 4)) >> (NBM / 4)) >> (NBM / 4)) \
	>> (NBM - (3 * (NBM / 4))))  >  0

#define l_intfitsf(i)  \
  (-((lua_Integer)1 << NBM) <= (i) && (i) <= ((lua_Integer)1 << NBM))

#endif

#endif



/*
** Try to convert a value to a float. The float case is already handled
** by the macro 'tonumber'.
*/
int luaV_tonumber_ (const TValue *obj, lua_Number *n) {
  TValue v;
  if (ttisinteger(obj)) {
    *n = cast_num(ivalue(obj));
    return 1;
  }
  else if (cvt2num(obj) &&  /* string convertible to number? */
            luaO_str2num(svalue(obj), &v) == vslen(obj) + 1) {
    *n = nvalue(&v);  /* convert result of 'luaO_str2num' to a float */
    return 1;
  }
  else
    return 0;  /* conversion failed */
}


/*
** try to convert a value to an integer, rounding according to 'mode':
** mode == 0: accepts only integral values
** mode == 1: takes the floor of the number
** mode == 2: takes the ceil of the number
*/
int luaV_tointeger (const TValue *obj, lua_Integer *p, int mode) {
  TValue v;
 again:
  if (ttisfloat(obj)) {
    lua_Number n = fltvalue(obj);
    lua_Number f = l_floor(n);
    if (n != f) {  /* not an integral value? */
      if (mode == 0) return 0;  /* fails if mode demands integral value */
      else if (mode > 1)  /* needs ceil? */
        f += 1;  /* convert floor to ceil (remember: n != f) */
    }
    return lua_numbertointeger(f, p);
  }
  else if (ttisinteger(obj)) {
    *p = ivalue(obj);
    return 1;
  }
  else if (cvt2num(obj) &&
            luaO_str2num(svalue(obj), &v) == vslen(obj) + 1) {
    obj = &v;
    goto again;  /* convert result from 'luaO_str2num' to an integer */
  }
  return 0;  /* conversion failed */
}


/*
** Try to convert a 'for' limit to an integer, preserving the
** semantics of the loop.
** (The following explanation assumes a non-negative step; it is valid
** for negative steps mutatis mutandis.)
** If the limit can be converted to an integer, rounding down, that is
** it.
** Otherwise, check whether the limit can be converted to a number.  If
** the number is too large, it is OK to set the limit as LUA_MAXINTEGER,
** which means no limit.  If the number is too negative, the loop
** should not run, because any initial integer value is larger than the
** limit. So, it sets the limit to LUA_MININTEGER. 'stopnow' corrects
** the extreme case when the initial value is LUA_MININTEGER, in which
** case the LUA_MININTEGER limit would still run the loop once.
*/
static int forlimit (const TValue *obj, lua_Integer *p, lua_Integer step,
                     int *stopnow) {
  *stopnow = 0;  /* usually, let loops run */
  if (!luaV_tointeger(obj, p, (step < 0 ? 2 : 1))) {  /* not fit in integer? */
    lua_Number n;  /* try to convert to float */
    if (!tonumber(obj, &n)) /* cannot convert to float? */
      return 0;  /* not a number */
    if (luai_numlt(0, n)) {  /* if true, float is larger than max integer */
      *p = LUA_MAXINTEGER;
      if (step < 0) *stopnow = 1;
    }
    else {  /* float is smaller than min integer */
      *p = LUA_MININTEGER;
      if (step >= 0) *stopnow = 1;
    }
  }
  return 1;
}


/*
** Finish the table access 'val = t[key]'.
** if 'slot' is NULL, 't' is not a table; otherwise, 'slot' points to
** t[k] entry (which must be nil).
*/
void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  int loop;  /* counter to avoid infinite loops */
  const TValue *tm;  /* metamethod */
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    if (slot == NULL) {  /* 't' is not a table? */
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (ttisnil(tm))
        luaG_typeerror(L, t, "index");  /* no metamethod */
      /* else will try the metamethod */
    }
    else {  /* 't' is a table */
      lua_assert(ttisnil(slot));
      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);  /* table's metamethod */
      if (tm == NULL) {  /* no metamethod? */
        setnilvalue(val);  /* result is nil */
        return;
      }
      /* else will try the metamethod */
    }
    if (ttisfunction(tm)) {  /* is metamethod a function? */
      luaT_callTM(L, tm, t, key, val, 1);  /* call it */
      return;
    }
    t = tm;  /* else try to access 'tm[key]' */
    if (luaV_fastget(L,t,key,slot,luaH_get)) {  /* fast track? */
      setobj2s(L, val, slot);  /* done */
      return;
    }
    /* else repeat (tail call 'luaV_finishget') */
  }
  luaG_runerror(L, "'__index' chain too long; possible loop");
}


/*
** Finish a table assignment 't[key] = val'.
** If 'slot' is NULL, 't' is not a table.  Otherwise, 'slot' points
** to the entry 't[key]', or to 'luaO_nilobject' if there is no such
** entry.  (The value at 'slot' must be nil, otherwise 'luaV_fastset'
** would have done the job.)
*/
void luaV_finishset (lua_State *L, const TValue *t, TValue *key,
                     StkId val, const TValue *slot) {
  int loop;  /* counter to avoid infinite loops */
  for (loop = 0; loop < MAXTAGLOOP; loop++) {
    const TValue *tm;  /* '__newindex' metamethod */
    if (slot != NULL) {  /* is 't' a table? */
      Table *h = hvalue(t);  /* save 't' table */
      lua_assert(ttisnil(slot));  /* old value must be nil */
      tm = fasttm(L, h->metatable, TM_NEWINDEX);  /* get metamethod */
      if (tm == NULL) {  /* no metamethod? */
        if (slot == luaO_nilobject)  /* no previous entry? */
          slot = luaH_newkey(L, h, key);  /* create one */
        /* no metamethod and (now) there is an entry with given key */
        setobj2t(L, cast(TValue *, slot), val);  /* set its new value */
        invalidateTMcache(h);
        luaC_barrierback(L, h, val);
        return;
      }
      /* else will try the metamethod */
    }
    else {  /* not a table; check metamethod */
      if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
        luaG_typeerror(L, t, "index");
    }
    /* try the metamethod */
    if (ttisfunction(tm)) {
      luaT_callTM(L, tm, t, key, val, 0);
      return;
    }
    t = tm;  /* else repeat assignment over 'tm' */
    if (luaV_fastset(L, t, key, slot, luaH_get, val))
      return;  /* done */
    /* else loop */
  }
  luaG_runerror(L, "'__newindex' chain too long; possible loop");
}


/*
** Compare two strings 'ls' x 'rs', returning an integer smaller-equal-
** -larger than zero if 'ls' is smaller-equal-larger than 'rs'.
** The code is a little tricky because it allows '\0' in the strings
** and it uses 'strcoll' (to respect locales) for each segments
** of the strings.
*/
static int l_strcmp (const TString *ls, const TString *rs) {
  const char *l = getstr(ls);
  size_t ll = tsslen(ls);
  const char *r = getstr(rs);
  size_t lr = tsslen(rs);
  for (;;) {  /* for each segment */
    int temp = strcoll(l, r);
    if (temp != 0)  /* not equal? */
      return temp;  /* done */
    else {  /* strings are equal up to a '\0' */
      size_t len = strlen(l);  /* index of first '\0' in both strings */
      if (len == lr)  /* 'rs' is finished? */
        return (len == ll) ? 0 : 1;  /* check 'ls' */
      else if (len == ll)  /* 'ls' is finished? */
        return -1;  /* 'ls' is smaller than 'rs' ('rs' is not finished) */
      /* both strings longer than 'len'; go on comparing after the '\0' */
      len++;
      l += len; ll -= len; r += len; lr -= len;
    }
  }
}


/*
** Check whether integer 'i' is less than float 'f'. If 'i' has an
** exact representation as a float ('l_intfitsf'), compare numbers as
** floats. Otherwise, if 'f' is outside the range for integers, result
** is trivial. Otherwise, compare them as integers. (When 'i' has no
** float representation, either 'f' is "far away" from 'i' or 'f' has
** no precision left for a fractional part; either way, how 'f' is
** truncated is irrelevant.) When 'f' is NaN, comparisons must result
** in false.
*/
static int LTintfloat (lua_Integer i, lua_Number f) {
#if defined(l_intfitsf)
  if (!l_intfitsf(i)) {
    if (f >= -cast_num(LUA_MININTEGER))  /* -minint == maxint + 1 */
      return 1;  /* f >= maxint + 1 > i */
    else if (f > cast_num(LUA_MININTEGER))  /* minint < f <= maxint ? */
      return (i < cast(lua_Integer, f));  /* compare them as integers */
    else  /* f <= minint <= i (or 'f' is NaN)  -->  not(i < f) */
      return 0;
  }
#endif
  return luai_numlt(cast_num(i), f);  /* compare them as floats */
}


/*
** Check whether integer 'i' is less than or equal to float 'f'.
** See comments on previous function.
*/
static int LEintfloat (lua_Integer i, lua_Number f) {
#if defined(l_intfitsf)
  if (!l_intfitsf(i)) {
    if (f >= -cast_num(LUA_MININTEGER))  /* -minint == maxint + 1 */
      return 1;  /* f >= maxint + 1 > i */
    else if (f >= cast_num(LUA_MININTEGER))  /* minint <= f <= maxint ? */
      return (i <= cast(lua_Integer, f));  /* compare them as integers */
    else  /* f < minint <= i (or 'f' is NaN)  -->  not(i <= f) */
      return 0;
  }
#endif
  return luai_numle(cast_num(i), f);  /* compare them as floats */
}


/*
** Return 'l < r', for numbers.
*/
static int LTnum (const TValue *l, const TValue *r) {
  if (ttisinteger(l)) {
    lua_Integer li = ivalue(l);
    if (ttisinteger(r))
      return li < ivalue(r);  /* both are integers */
    else  /* 'l' is int and 'r' is float */
      return LTintfloat(li, fltvalue(r));  /* l < r ? */
  }
  else {
    lua_Number lf = fltvalue(l);  /* 'l' must be float */
    if (ttisfloat(r))
      return luai_numlt(lf, fltvalue(r));  /* both are float */
    else if (luai_numisnan(lf))  /* 'r' is int and 'l' is float */
      return 0;  /* NaN < i is always false */
    else  /* without NaN, (l < r)  <-->  not(r <= l) */
      return !LEintfloat(ivalue(r), lf);  /* not (r <= l) ? */
  }
}


/*
** Return 'l <= r', for numbers.
*/
static int LEnum (const TValue *l, const TValue *r) {
  if (ttisinteger(l)) {
    lua_Integer li = ivalue(l);
    if (ttisinteger(r))
      return li <= ivalue(r);  /* both are integers */
    else  /* 'l' is int and 'r' is float */
      return LEintfloat(li, fltvalue(r));  /* l <= r ? */
  }
  else {
    lua_Number lf = fltvalue(l);  /* 'l' must be float */
    if (ttisfloat(r))
      return luai_numle(lf, fltvalue(r));  /* both are float */
    else if (luai_numisnan(lf))  /* 'r' is int and 'l' is float */
      return 0;  /*  NaN <= i is always false */
    else  /* without NaN, (l <= r)  <-->  not(r < l) */
      return !LTintfloat(ivalue(r), lf);  /* not (r < l) ? */
  }
}


/*
** Main operation less than; return 'l < r'.
*/
int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
  int res;
  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */
    return LTnum(l, r);
  else if (ttisstring(l) && ttisstring(r))  /* both are strings? */
    return l_strcmp(tsvalue(l), tsvalue(r)) < 0;
  else if ((res = luaT_callorderTM(L, l, r, TM_LT)) < 0)  /* no metamethod? */
    luaG_ordererror(L, l, r);  /* error */
  return res;
}


/*
** Main operation less than or equal to; return 'l <= r'. If it needs
** a metamethod and there is no '__le', try '__lt', based on
** l <= r iff !(r < l) (assuming a total order). If the metamethod
** yields during this substitution, the continuation has to know
** about it (to negate the result of r<l); bit CIST_LEQ in the call
** status keeps that information.
*/
int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {
  int res;
  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */
    return LEnum(l, r);
  else if (ttisstring(l) && ttisstring(r))  /* both are strings? */
    return l_strcmp(tsvalue(l), tsvalue(r)) <= 0;
  else if ((res = luaT_callorderTM(L, l, r, TM_LE)) >= 0)  /* try 'le' */
    return res;
  else {  /* try 'lt': */
    L->ci->callstatus |= CIST_LEQ;  /* mark it is doing 'lt' for 'le' */
    res = luaT_callorderTM(L, r, l, TM_LT);
    L->ci->callstatus ^= CIST_LEQ;  /* clear mark */
    if (res < 0)
      luaG_ordererror(L, l, r);
    return !res;  /* result is negated */
  }
}


/*
** Main operation for equality of Lua values; return 't1 == t2'.
** L == NULL means raw equality (no metamethods)
*/
int luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2) {
  const TValue *tm;
  if (ttype(t1) != ttype(t2)) {  /* not the same variant? */
    if (ttnov(t1) != ttnov(t2) || ttnov(t1) != LUA_TNUMBER)
      return 0;  /* only numbers can be equal with different variants */
    else {  /* two numbers with different variants */
      lua_Integer i1, i2;  /* compare them as integers */
      return (tointeger(t1, &i1) && tointeger(t2, &i2) && i1 == i2);
    }
  }
  /* values have same type and same variant */
  switch (ttype(t1)) {
    case LUA_TNIL: return 1;
    case LUA_TNUMINT: return (ivalue(t1) == ivalue(t2));
    case LUA_TNUMFLT: return luai_numeq(fltvalue(t1), fltvalue(t2));
    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
    case LUA_TLCF: return fvalue(t1) == fvalue(t2);
    case LUA_TSHRSTR: return eqshrstr(tsvalue(t1), tsvalue(t2));
    case LUA_TLNGSTR: return luaS_eqlngstr(tsvalue(t1), tsvalue(t2));
    case LUA_TUSERDATA: {
      if (uvalue(t1) == uvalue(t2)) return 1;
      else if (L == NULL) return 0;
      tm = fasttm(L, uvalue(t1)->metatable, TM_EQ);
      if (tm == NULL)
        tm = fasttm(L, uvalue(t2)->metatable, TM_EQ);
      break;  /* will try TM */
    }
    case LUA_TTABLE: {
      if (hvalue(t1) == hvalue(t2)) return 1;
      else if (L == NULL) return 0;
      tm = fasttm(L, hvalue(t1)->metatable, TM_EQ);
      if (tm == NULL)
        tm = fasttm(L, hvalue(t2)->metatable, TM_EQ);
      break;  /* will try TM */
    }
    default:
      return gcvalue(t1) == gcvalue(t2);
  }
  if (tm == NULL)  /* no TM? */
    return 0;  /* objects are different */
  luaT_callTM(L, tm, t1, t2, L->top, 1);  /* call TM */
  return !l_isfalse(L->top);
}


/* macro used by 'luaV_concat' to ensure that element at 'o' is a string */
#define tostring(L,o)  \
	(ttisstring(o) || (cvt2str(o) && (luaO_tostring(L, o), 1)))

#define isemptystr(o)	(ttisshrstring(o) && tsvalue(o)->shrlen == 0)

/* copy strings in stack from top - n up to top - 1 to buffer */
static void copy2buff (StkId top, int n, char *buff) {
  size_t tl = 0;  /* size already copied */
  do {
    size_t l = vslen(top - n);  /* length of string being copied */
    memcpy(buff + tl, svalue(top - n), l * sizeof(char));
    tl += l;
  } while (--n > 0);
}


/*
** Main operation for concatenation: concat 'total' values in the stack,
** from 'L->top - total' up to 'L->top - 1'.
*/
void luaV_concat (lua_State *L, int total) {
  lua_assert(total >= 2);
  do {
    StkId top = L->top;
    int n = 2;  /* number of elements handled in this pass (at least 2) */
    if (!(ttisstring(top-2) || cvt2str(top-2)) || !tostring(L, top-1))
      luaT_trybinTM(L, top-2, top-1, top-2, TM_CONCAT);
    else if (isemptystr(top - 1))  /* second operand is empty? */
      cast_void(tostring(L, top - 2));  /* result is first operand */
    else if (isemptystr(top - 2)) {  /* first operand is an empty string? */
      setobjs2s(L, top - 2, top - 1);  /* result is second op. */
    }
    else {
      /* at least two non-empty string values; get as many as possible */
      size_t tl = vslen(top - 1);
      TString *ts;
      /* collect total length and number of strings */
      for (n = 1; n < total && tostring(L, top - n - 1); n++) {
        size_t l = vslen(top - n - 1);
        if (l >= (MAX_SIZE/sizeof(char)) - tl)
          luaG_runerror(L, "string length overflow");
        tl += l;
      }
      if (tl <= LUAI_MAXSHORTLEN) {  /* is result a short string? */
        char buff[LUAI_MAXSHORTLEN];
        copy2buff(top, n, buff);  /* copy strings to buffer */
        ts = luaS_newlstr(L, buff, tl);
      }
      else {  /* long string; copy strings directly to final result */
        ts = luaS_createlngstrobj(L, tl);
        copy2buff(top, n, getstr(ts));
      }
      setsvalue2s(L, top - n, ts);  /* create result */
    }
    total -= n-1;  /* got 'n' strings to create 1 new */
    L->top -= n-1;  /* popped 'n' strings and pushed one */
  } while (total > 1);  /* repeat until only 1 result left */
}


/*
** Main operation 'ra' = #rb'.
*/
void luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {
  const TValue *tm;
  switch (ttype(rb)) {
    case LUA_TTABLE: {
      Table *h = hvalue(rb);
      tm = fasttm(L, h->metatable, TM_LEN);
      if (tm) break;  /* metamethod? break switch to call it */
      setivalue(ra, luaH_getn(h));  /* else primitive len */
      return;
    }
    case LUA_TSHRSTR: {
      setivalue(ra, tsvalue(rb)->shrlen);
      return;
    }
    case LUA_TLNGSTR: {
      setivalue(ra, tsvalue(rb)->u.lnglen);
      return;
    }
    default: {  /* try metamethod */
      tm = luaT_gettmbyobj(L, rb, TM_LEN);
      if (ttisnil(tm))  /* no metamethod? */
        luaG_typeerror(L, rb, "get length of");
      break;
    }
  }
  luaT_callTM(L, tm, rb, rb, ra, 1);
}


/*
** Integer division; return 'm // n', that is, floor(m/n).
** C division truncates its result (rounds towards zero).
** 'floor(q) == trunc(q)' when 'q >= 0' or when 'q' is integer,
** otherwise 'floor(q) == trunc(q) - 1'.
*/
lua_Integer luaV_div (lua_State *L, lua_Integer m, lua_Integer n) {
  if (l_castS2U(n) + 1u <= 1u) {  /* special cases: -1 or 0 */
    if (n == 0)
      luaG_runerror(L, "attempt to divide by zero");
    return intop(-, 0, m);   /* n==-1; avoid overflow with 0x80000...//-1 */
  }
  else {
    lua_Integer q = m / n;  /* perform C division */
    if ((m ^ n) < 0 && m % n != 0)  /* 'm/n' would be negative non-integer? */
      q -= 1;  /* correct result for different rounding */
    return q;
  }
}


/*
** Integer modulus; return 'm % n'. (Assume that C '%' with
** negative operands follows C99 behavior. See previous comment
** about luaV_div.)
*/
lua_Integer luaV_mod (lua_State *L, lua_Integer m, lua_Integer n) {
  if (l_castS2U(n) + 1u <= 1u) {  /* special cases: -1 or 0 */
    if (n == 0)
      luaG_runerror(L, "attempt to perform 'n%%0'");
    return 0;   /* m % -1 == 0; avoid overflow with 0x80000...%-1 */
  }
  else {
    lua_Integer r = m % n;
    if (r != 0 && (m ^ n) < 0)  /* 'm/n' would be non-integer negative? */
      r += n;  /* correct result for different rounding */
    return r;
  }
}


/* number of bits in an integer */
#define NBITS	cast_int(sizeof(lua_Integer) * CHAR_BIT)

/*
** Shift left operation. (Shift right just negates 'y'.)
*/
lua_Integer luaV_shiftl (lua_Integer x, lua_Integer y) {
  if (y < 0) {  /* shift right? */
    if (y <= -NBITS) return 0;
    else return intop(>>, x, -y);
  }
  else {  /* shift left */
    if (y >= NBITS) return 0;
    else return intop(<<, x, y);
  }
}


/*
** check whether cached closure in prototype 'p' may be reused, that is,
** whether there is a cached closure with the same upvalues needed by
** new closure to be created.
*/
static LClosure *getcached (Proto *p, UpVal **encup, StkId base) {
  LClosure *c = p->cache;
  if (c != NULL) {  /* is there a cached closure? */
    int nup = p->sizeupvalues;
    Upvaldesc *uv = p->upvalues;
    int i;
    for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */
      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;
      if (c->upvals[i]->v != v)
        return NULL;  /* wrong upvalue; cannot reuse closure */
    }
  }
  return c;  /* return cached closure (or NULL if no cached closure) */
}


/*
** create a new Lua closure, push it in the stack, and initialize
** its upvalues. Note that the closure is not cached if prototype is
** already black (which means that 'cache' was already cleared by the
** GC).
*/
static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,
                         StkId ra) {
  int nup = p->sizeupvalues;
  Upvaldesc *uv = p->upvalues;
  int i;
  LClosure *ncl = luaF_newLclosure(L, nup);
  ncl->p = p;
  setclLvalue(L, ra, ncl);  /* anchor new closure in stack */
  for (i = 0; i < nup; i++) {  /* fill in its upvalues */
    if (uv[i].instack)  /* upvalue refers to local variable? */
      ncl->upvals[i] = luaF_findupval(L, base + uv[i].idx);
    else  /* get upvalue from enclosing function */
      ncl->upvals[i] = encup[uv[i].idx];
    ncl->upvals[i]->refcount++;
    /* new closure is white, so we do not need a barrier here */
  }
  if (!isblack(p))  /* cache will not break GC invariant? */
    p->cache = ncl;  /* save it on cache for reuse */
}


/*
** finish execution of an opcode interrupted by an yield
*/
void luaV_finishOp (lua_State *L) {
  CallInfo *ci = L->ci;
  StkId base = ci->u.l.base;
  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */
  OpCode op = GET_OPCODE(inst);
  switch (op) {  /* finish its execution */
    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV: case OP_IDIV:
    case OP_BAND: case OP_BOR: case OP_BXOR: case OP_SHL: case OP_SHR:
    case OP_MOD: case OP_POW:
    case OP_UNM: case OP_BNOT: case OP_LEN:
    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {
      setobjs2s(L, base + GETARG_A(inst), --L->top);
      break;
    }
    case OP_LE: case OP_LT: case OP_EQ: {
      int res = !l_isfalse(L->top - 1);
      L->top--;
      if (ci->callstatus & CIST_LEQ) {  /* "<=" using "<" instead? */
        lua_assert(op == OP_LE);
        ci->callstatus ^= CIST_LEQ;  /* clear mark */
        res = !res;  /* negate result */
      }
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);
      if (res != GETARG_A(inst))  /* condition failed? */
        ci->u.l.savedpc++;  /* skip jump instruction */
      break;
    }
    case OP_CONCAT: {
      StkId top = L->top - 1;  /* top when 'luaT_trybinTM' was called */
      int b = GETARG_B(inst);      /* first element to concatenate */
      int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */
      setobj2s(L, top - 2, top);  /* put TM result in proper position */
      if (total > 1) {  /* are there elements to concat? */
        L->top = top - 1;  /* top is one after last element (at top-2) */
        luaV_concat(L, total);  /* concat them (may yield again) */
      }
      /* move final result to final position */
      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);
      L->top = ci->top;  /* restore top */
      break;
    }
    case OP_TFORCALL: {
      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);
      L->top = ci->top;  /* correct top */
      break;
    }
    case OP_CALL: {
      if (GETARG_C(inst) - 1 >= 0)  /* nresults >= 0? */
        L->top = ci->top;  /* adjust results */
      break;
    }
    case OP_TAILCALL: case OP_SETTABUP: case OP_SETTABLE:
      break;
    default: lua_assert(0);
  }
}




/*
** {==================================================================
** Function 'luaV_execute': main interpreter loop
** ===================================================================
*/


/*
** some macros for common tasks in 'luaV_execute'
*/


#define RA(i)	(base+GETARG_A(i))
#define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
#define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
#define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
#define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))


/* execute a jump instruction */
#define dojump(ci,i,e) \
  { int a = GETARG_A(i); \
    if (a != 0) luaF_close(L, ci->u.l.base + a - 1); \
    ci->u.l.savedpc += GETARG_sBx(i) + e; }

/* for test instructions, execute the jump instruction that follows it */
#define donextjump(ci)	{ i = *ci->u.l.savedpc; dojump(ci, i, 1); }


#define Protect(x)	{ {x;}; base = ci->u.l.base; }

#define checkGC(L,c)  \
	{ luaC_condGC(L, L->top = (c),  /* limit of live values */ \
                         Protect(L->top = ci->top));  /* restore top */ \
           luai_threadyield(L); }


/* fetch an instruction and prepare its execution */
#define vmfetch()	{ \
  i = *(ci->u.l.savedpc++); \
  if (L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) \
    Protect(luaG_traceexec(L)); \
  ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */ \
  lua_assert(base == ci->u.l.base); \
  lua_assert(base <= L->top && L->top < L->stack + L->stacksize); \
}

#define vmdispatch(o)	switch(o)
#define vmcase(l)	case l:
#define vmbreak		break


/*
** copy of 'luaV_gettable', but protecting the call to potential
** metamethod (which can reallocate the stack)
*/
#define gettableProtected(L,t,k,v)  { const TValue *slot; \
  if (luaV_fastget(L,t,k,slot,luaH_get)) { setobj2s(L, v, slot); } \
  else Protect(luaV_finishget(L,t,k,v,slot)); }


/* same for 'luaV_settable' */
#define settableProtected(L,t,k,v) { const TValue *slot; \
  if (!luaV_fastset(L,t,k,slot,luaH_get,v)) \
    Protect(luaV_finishset(L,t,k,v,slot)); }



void luaV_execute (lua_State *L) {
  CallInfo *ci = L->ci;
  LClosure *cl;
  TValue *k;
  StkId base;
  ci->callstatus |= CIST_FRESH;  /* fresh invocation of 'luaV_execute" */
 newframe:  /* reentry point when frame changes (call/return) */
  lua_assert(ci == L->ci);
  cl = clLvalue(ci->func);  /* local reference to function's closure */
  k = cl->p->k;  /* local reference to function's constant table */
  base = ci->u.l.base;  /* local copy of function's base */
  /* main loop of interpreter */
  for (;;) {
    Instruction i;
    StkId ra;
    vmfetch();
    vmdispatch (GET_OPCODE(i)) {
      vmcase(OP_MOVE) {
        setobjs2s(L, ra, RB(i));
        vmbreak;
      }
      vmcase(OP_LOADK) {
        TValue *rb = k + GETARG_Bx(i);
        setobj2s(L, ra, rb);
        vmbreak;
      }
      vmcase(OP_LOADKX) {
        TValue *rb;
        lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
        rb = k + GETARG_Ax(*ci->u.l.savedpc++);
        setobj2s(L, ra, rb);
        vmbreak;
      }
      vmcase(OP_LOADBOOL) {
        setbvalue(ra, GETARG_B(i));
        if (GETARG_C(i)) ci->u.l.savedpc++;  /* skip next instruction (if C) */
        vmbreak;
      }
      vmcase(OP_LOADNIL) {
        int b = GETARG_B(i);
        do {
          setnilvalue(ra++);
        } while (b--);
        vmbreak;
      }
      vmcase(OP_GETUPVAL) {
        int b = GETARG_B(i);
        setobj2s(L, ra, cl->upvals[b]->v);
        vmbreak;
      }
      vmcase(OP_GETTABUP) {
        TValue *upval = cl->upvals[GETARG_B(i)]->v;
        TValue *rc = RKC(i);
        gettableProtected(L, upval, rc, ra);
        vmbreak;
      }
      vmcase(OP_GETTABLE) {
        StkId rb = RB(i);
        TValue *rc = RKC(i);
        gettableProtected(L, rb, rc, ra);
        vmbreak;
      }
      vmcase(OP_SETTABUP) {
        TValue *upval = cl->upvals[GETARG_A(i)]->v;
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        settableProtected(L, upval, rb, rc);
        vmbreak;
      }
      vmcase(OP_SETUPVAL) {
        UpVal *uv = cl->upvals[GETARG_B(i)];
        setobj(L, uv->v, ra);
        luaC_upvalbarrier(L, uv);
        vmbreak;
      }
      vmcase(OP_SETTABLE) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        settableProtected(L, ra, rb, rc);
        vmbreak;
      }
      vmcase(OP_NEWTABLE) {
        int b = GETARG_B(i);
        int c = GETARG_C(i);
        Table *t = luaH_new(L);
        sethvalue(L, ra, t);
        if (b != 0 || c != 0)
          luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
        checkGC(L, ra + 1);
        vmbreak;
      }
      vmcase(OP_SELF) {
        const TValue *aux;
        StkId rb = RB(i);
        TValue *rc = RKC(i);
        TString *key = tsvalue(rc);  /* key must be a string */
        setobjs2s(L, ra + 1, rb);
        if (luaV_fastget(L, rb, key, aux, luaH_getstr)) {
          setobj2s(L, ra, aux);
        }
        else Protect(luaV_finishget(L, rb, rc, ra, aux));
        vmbreak;
      }
      vmcase(OP_ADD) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Number nb; lua_Number nc;
        if (ttisinteger(rb) && ttisinteger(rc)) {
          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
          setivalue(ra, intop(+, ib, ic));
        }
        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
          setfltvalue(ra, luai_numadd(L, nb, nc));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_ADD)); }
        vmbreak;
      }
      vmcase(OP_SUB) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Number nb; lua_Number nc;
        if (ttisinteger(rb) && ttisinteger(rc)) {
          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
          setivalue(ra, intop(-, ib, ic));
        }
        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
          setfltvalue(ra, luai_numsub(L, nb, nc));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SUB)); }
        vmbreak;
      }
      vmcase(OP_MUL) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Number nb; lua_Number nc;
        if (ttisinteger(rb) && ttisinteger(rc)) {
          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
          setivalue(ra, intop(*, ib, ic));
        }
        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
          setfltvalue(ra, luai_nummul(L, nb, nc));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_MUL)); }
        vmbreak;
      }
      vmcase(OP_DIV) {  /* float division (always with floats) */
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Number nb; lua_Number nc;
        if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
          setfltvalue(ra, luai_numdiv(L, nb, nc));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_DIV)); }
        vmbreak;
      }
      vmcase(OP_BAND) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Integer ib; lua_Integer ic;
        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
          setivalue(ra, intop(&, ib, ic));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_BAND)); }
        vmbreak;
      }
      vmcase(OP_BOR) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Integer ib; lua_Integer ic;
        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
          setivalue(ra, intop(|, ib, ic));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_BOR)); }
        vmbreak;
      }
      vmcase(OP_BXOR) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Integer ib; lua_Integer ic;
        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
          setivalue(ra, intop(^, ib, ic));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_BXOR)); }
        vmbreak;
      }
      vmcase(OP_SHL) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Integer ib; lua_Integer ic;
        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
          setivalue(ra, luaV_shiftl(ib, ic));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SHL)); }
        vmbreak;
      }
      vmcase(OP_SHR) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Integer ib; lua_Integer ic;
        if (tointeger(rb, &ib) && tointeger(rc, &ic)) {
          setivalue(ra, luaV_shiftl(ib, -ic));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_SHR)); }
        vmbreak;
      }
      vmcase(OP_MOD) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Number nb; lua_Number nc;
        if (ttisinteger(rb) && ttisinteger(rc)) {
          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
          setivalue(ra, luaV_mod(L, ib, ic));
        }
        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
          lua_Number m;
          luai_nummod(L, nb, nc, m);
          setfltvalue(ra, m);
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_MOD)); }
        vmbreak;
      }
      vmcase(OP_IDIV) {  /* floor division */
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Number nb; lua_Number nc;
        if (ttisinteger(rb) && ttisinteger(rc)) {
          lua_Integer ib = ivalue(rb); lua_Integer ic = ivalue(rc);
          setivalue(ra, luaV_div(L, ib, ic));
        }
        else if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
          setfltvalue(ra, luai_numidiv(L, nb, nc));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_IDIV)); }
        vmbreak;
      }
      vmcase(OP_POW) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        lua_Number nb; lua_Number nc;
        if (tonumber(rb, &nb) && tonumber(rc, &nc)) {
          setfltvalue(ra, luai_numpow(L, nb, nc));
        }
        else { Protect(luaT_trybinTM(L, rb, rc, ra, TM_POW)); }
        vmbreak;
      }
      vmcase(OP_UNM) {
        TValue *rb = RB(i);
        lua_Number nb;
        if (ttisinteger(rb)) {
          lua_Integer ib = ivalue(rb);
          setivalue(ra, intop(-, 0, ib));
        }
        else if (tonumber(rb, &nb)) {
          setfltvalue(ra, luai_numunm(L, nb));
        }
        else {
          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));
        }
        vmbreak;
      }
      vmcase(OP_BNOT) {
        TValue *rb = RB(i);
        lua_Integer ib;
        if (tointeger(rb, &ib)) {
          setivalue(ra, intop(^, ~l_castS2U(0), ib));
        }
        else {
          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));
        }
        vmbreak;
      }
      vmcase(OP_NOT) {
        TValue *rb = RB(i);
        int res = l_isfalse(rb);  /* next assignment may change this value */
        setbvalue(ra, res);
        vmbreak;
      }
      vmcase(OP_LEN) {
        Protect(luaV_objlen(L, ra, RB(i)));
        vmbreak;
      }
      vmcase(OP_CONCAT) {
        int b = GETARG_B(i);
        int c = GETARG_C(i);
        StkId rb;
        L->top = base + c + 1;  /* mark the end of concat operands */
        Protect(luaV_concat(L, c - b + 1));
        ra = RA(i);  /* 'luaV_concat' may invoke TMs and move the stack */
        rb = base + b;
        setobjs2s(L, ra, rb);
        checkGC(L, (ra >= rb ? ra + 1 : rb));
        L->top = ci->top;  /* restore top */
        vmbreak;
      }
      vmcase(OP_JMP) {
        dojump(ci, i, 0);
        vmbreak;
      }
      vmcase(OP_EQ) {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        Protect(
          if (luaV_equalobj(L, rb, rc) != GETARG_A(i))
            ci->u.l.savedpc++;
          else
            donextjump(ci);
        )
        vmbreak;
      }
      vmcase(OP_LT) {
        Protect(
          if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i))
            ci->u.l.savedpc++;
          else
            donextjump(ci);
        )
        vmbreak;
      }
      vmcase(OP_LE) {
        Protect(
          if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i))
            ci->u.l.savedpc++;
          else
            donextjump(ci);
        )
        vmbreak;
      }
      vmcase(OP_TEST) {
        if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra))
            ci->u.l.savedpc++;
          else
          donextjump(ci);
        vmbreak;
      }
      vmcase(OP_TESTSET) {
        TValue *rb = RB(i);
        if (GETARG_C(i) ? l_isfalse(rb) : !l_isfalse(rb))
          ci->u.l.savedpc++;
        else {
          setobjs2s(L, ra, rb);
          donextjump(ci);
        }
        vmbreak;
      }
      vmcase(OP_CALL) {
        int b = GETARG_B(i);
        int nresults = GETARG_C(i) - 1;
        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
        if (luaD_precall(L, ra, nresults)) {  /* C function? */
          if (nresults >= 0)
            L->top = ci->top;  /* adjust results */
          Protect((void)0);  /* update 'base' */
        }
        else {  /* Lua function */
          ci = L->ci;
          goto newframe;  /* restart luaV_execute over new Lua function */
        }
        vmbreak;
      }
      vmcase(OP_TAILCALL) {
        int b = GETARG_B(i);
        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
        if (luaD_precall(L, ra, LUA_MULTRET)) {  /* C function? */
          Protect((void)0);  /* update 'base' */
        }
        else {
          /* tail call: put called frame (n) in place of caller one (o) */
          CallInfo *nci = L->ci;  /* called frame */
          CallInfo *oci = nci->previous;  /* caller frame */
          StkId nfunc = nci->func;  /* called function */
          StkId ofunc = oci->func;  /* caller function */
          /* last stack slot filled by 'precall' */
          StkId lim = nci->u.l.base + getproto(nfunc)->numparams;
          int aux;
          /* close all upvalues from previous call */
          if (cl->p->sizep > 0) luaF_close(L, oci->u.l.base);
          /* move new frame into old one */
          for (aux = 0; nfunc + aux < lim; aux++)
            setobjs2s(L, ofunc + aux, nfunc + aux);
          oci->u.l.base = ofunc + (nci->u.l.base - nfunc);  /* correct base */
          oci->top = L->top = ofunc + (L->top - nfunc);  /* correct top */
          oci->u.l.savedpc = nci->u.l.savedpc;
          oci->callstatus |= CIST_TAIL;  /* function was tail called */
          ci = L->ci = oci;  /* remove new frame */
          lua_assert(L->top == oci->u.l.base + getproto(ofunc)->maxstacksize);
          goto newframe;  /* restart luaV_execute over new Lua function */
        }
        vmbreak;
      }
      vmcase(OP_RETURN) {
        int b = GETARG_B(i);
        if (cl->p->sizep > 0) luaF_close(L, base);
        b = luaD_poscall(L, ci, ra, (b != 0 ? b - 1 : cast_int(L->top - ra)));
        if (ci->callstatus & CIST_FRESH)  /* local 'ci' still from callee */
          return;  /* external invocation: return */
        else {  /* invocation via reentry: continue execution */
          ci = L->ci;
          if (b) L->top = ci->top;
          lua_assert(isLua(ci));
          lua_assert(GET_OPCODE(*((ci)->u.l.savedpc - 1)) == OP_CALL);
          goto newframe;  /* restart luaV_execute over new Lua function */
        }
      }
      vmcase(OP_FORLOOP) {
        if (ttisinteger(ra)) {  /* integer loop? */
          lua_Integer step = ivalue(ra + 2);
          lua_Integer idx = intop(+, ivalue(ra), step); /* increment index */
          lua_Integer limit = ivalue(ra + 1);
          if ((0 < step) ? (idx <= limit) : (limit <= idx)) {
            ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
            chgivalue(ra, idx);  /* update internal index... */
            setivalue(ra + 3, idx);  /* ...and external index */
          }
        }
        else {  /* floating loop */
          lua_Number step = fltvalue(ra + 2);
          lua_Number idx = luai_numadd(L, fltvalue(ra), step); /* inc. index */
          lua_Number limit = fltvalue(ra + 1);
          if (luai_numlt(0, step) ? luai_numle(idx, limit)
                                  : luai_numle(limit, idx)) {
            ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
            chgfltvalue(ra, idx);  /* update internal index... */
            setfltvalue(ra + 3, idx);  /* ...and external index */
          }
        }
        vmbreak;
      }
      vmcase(OP_FORPREP) {
        TValue *init = ra;
        TValue *plimit = ra + 1;
        TValue *pstep = ra + 2;
        lua_Integer ilimit;
        int stopnow;
        if (ttisinteger(init) && ttisinteger(pstep) &&
            forlimit(plimit, &ilimit, ivalue(pstep), &stopnow)) {
          /* all values are integer */
          lua_Integer initv = (stopnow ? 0 : ivalue(init));
          setivalue(plimit, ilimit);
          setivalue(init, intop(-, initv, ivalue(pstep)));
        }
        else {  /* try making all values floats */
          lua_Number ninit; lua_Number nlimit; lua_Number nstep;
          if (!tonumber(plimit, &nlimit))
            luaG_runerror(L, "'for' limit must be a number");
          setfltvalue(plimit, nlimit);
          if (!tonumber(pstep, &nstep))
            luaG_runerror(L, "'for' step must be a number");
          setfltvalue(pstep, nstep);
          if (!tonumber(init, &ninit))
            luaG_runerror(L, "'for' initial value must be a number");
          setfltvalue(init, luai_numsub(L, ninit, nstep));
        }
        ci->u.l.savedpc += GETARG_sBx(i);
        vmbreak;
      }
      vmcase(OP_TFORCALL) {
        StkId cb = ra + 3;  /* call base */
        setobjs2s(L, cb+2, ra+2);
        setobjs2s(L, cb+1, ra+1);
        setobjs2s(L, cb, ra);
        L->top = cb + 3;  /* func. + 2 args (state and index) */
        Protect(luaD_call(L, cb, GETARG_C(i)));
        L->top = ci->top;
        i = *(ci->u.l.savedpc++);  /* go to next instruction */
        ra = RA(i);
        lua_assert(GET_OPCODE(i) == OP_TFORLOOP);
        goto l_tforloop;
      }
      vmcase(OP_TFORLOOP) {
        l_tforloop:
        if (!ttisnil(ra + 1)) {  /* continue loop? */
          setobjs2s(L, ra, ra + 1);  /* save control variable */
           ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
        }
        vmbreak;
      }
      vmcase(OP_SETLIST) {
        int n = GETARG_B(i);
        int c = GETARG_C(i);
        unsigned int last;
        Table *h;
        if (n == 0) n = cast_int(L->top - ra) - 1;
        if (c == 0) {
          lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
          c = GETARG_Ax(*ci->u.l.savedpc++);
        }
        h = hvalue(ra);
        last = ((c-1)*LFIELDS_PER_FLUSH) + n;
        if (last > h->sizearray)  /* needs more space? */
          luaH_resizearray(L, h, last);  /* preallocate it at once */
        for (; n > 0; n--) {
          TValue *val = ra+n;
          luaH_setint(L, h, last--, val);
          luaC_barrierback(L, h, val);
        }
        L->top = ci->top;  /* correct top (in case of previous open call) */
        vmbreak;
      }
      vmcase(OP_CLOSURE) {
        Proto *p = cl->p->p[GETARG_Bx(i)];
        LClosure *ncl = getcached(p, cl->upvals, base);  /* cached closure */
        if (ncl == NULL)  /* no match? */
          pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
        else
          setclLvalue(L, ra, ncl);  /* push cashed closure */
        checkGC(L, ra + 1);
        vmbreak;
      }
      vmcase(OP_VARARG) {
        int b = GETARG_B(i) - 1;  /* required results */
        int j;
        int n = cast_int(base - ci->func) - cl->p->numparams - 1;
        if (n < 0)  /* less arguments than parameters? */
          n = 0;  /* no vararg arguments */
        if (b < 0) {  /* B == 0? */
          b = n;  /* get all var. arguments */
          Protect(luaD_checkstack(L, n));
          ra = RA(i);  /* previous call may change the stack */
          L->top = ra + n;
        }
        for (j = 0; j < b && j < n; j++)
          setobjs2s(L, ra + j, base - n + j);
        for (; j < b; j++)  /* complete required results with nil */
          setnilvalue(ra + j);
        vmbreak;
      }
      vmcase(OP_EXTRAARG) {
        lua_assert(0);
        vmbreak;
      }
    }
  }
}

/* }================================================================== */


```

`src/Lua/lvm.h`:

```h
/*
** $Id: lvm.h,v 2.41 2016/12/22 13:08:50 roberto Exp $
** Lua virtual machine
** See Copyright Notice in lua.h
*/

#ifndef lvm_h
#define lvm_h


#include "ldo.h"
#include "lobject.h"
#include "ltm.h"


#if !defined(LUA_NOCVTN2S)
#define cvt2str(o)	ttisnumber(o)
#else
#define cvt2str(o)	0	/* no conversion from numbers to strings */
#endif


#if !defined(LUA_NOCVTS2N)
#define cvt2num(o)	ttisstring(o)
#else
#define cvt2num(o)	0	/* no conversion from strings to numbers */
#endif


/*
** You can define LUA_FLOORN2I if you want to convert floats to integers
** by flooring them (instead of raising an error if they are not
** integral values)
*/
#if !defined(LUA_FLOORN2I)
#define LUA_FLOORN2I		0
#endif


#define tonumber(o,n) \
	(ttisfloat(o) ? (*(n) = fltvalue(o), 1) : luaV_tonumber_(o,n))

#define tointeger(o,i) \
    (ttisinteger(o) ? (*(i) = ivalue(o), 1) : luaV_tointeger(o,i,LUA_FLOORN2I))

#define intop(op,v1,v2) l_castU2S(l_castS2U(v1) op l_castS2U(v2))

#define luaV_rawequalobj(t1,t2)		luaV_equalobj(NULL,t1,t2)


/*
** fast track for 'gettable': if 't' is a table and 't[k]' is not nil,
** return 1 with 'slot' pointing to 't[k]' (final result).  Otherwise,
** return 0 (meaning it will have to check metamethod) with 'slot'
** pointing to a nil 't[k]' (if 't' is a table) or NULL (otherwise).
** 'f' is the raw get function to use.
*/
#define luaV_fastget(L,t,k,slot,f) \
  (!ttistable(t)  \
   ? (slot = NULL, 0)  /* not a table; 'slot' is NULL and result is 0 */  \
   : (slot = f(hvalue(t), k),  /* else, do raw access */  \
      !ttisnil(slot)))  /* result not nil? */

/*
** standard implementation for 'gettable'
*/
#define luaV_gettable(L,t,k,v) { const TValue *slot; \
  if (luaV_fastget(L,t,k,slot,luaH_get)) { setobj2s(L, v, slot); } \
  else luaV_finishget(L,t,k,v,slot); }


/*
** Fast track for set table. If 't' is a table and 't[k]' is not nil,
** call GC barrier, do a raw 't[k]=v', and return true; otherwise,
** return false with 'slot' equal to NULL (if 't' is not a table) or
** 'nil'. (This is needed by 'luaV_finishget'.) Note that, if the macro
** returns true, there is no need to 'invalidateTMcache', because the
** call is not creating a new entry.
*/
#define luaV_fastset(L,t,k,slot,f,v) \
  (!ttistable(t) \
   ? (slot = NULL, 0) \
   : (slot = f(hvalue(t), k), \
     ttisnil(slot) ? 0 \
     : (luaC_barrierback(L, hvalue(t), v), \
        setobj2t(L, cast(TValue *,slot), v), \
        1)))


#define luaV_settable(L,t,k,v) { const TValue *slot; \
  if (!luaV_fastset(L,t,k,slot,luaH_get,v)) \
    luaV_finishset(L,t,k,v,slot); }



LUAI_FUNC int luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2);
LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
LUAI_FUNC int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r);
LUAI_FUNC int luaV_tonumber_ (const TValue *obj, lua_Number *n);
LUAI_FUNC int luaV_tointeger (const TValue *obj, lua_Integer *p, int mode);
LUAI_FUNC void luaV_finishget (lua_State *L, const TValue *t, TValue *key,
                               StkId val, const TValue *slot);
LUAI_FUNC void luaV_finishset (lua_State *L, const TValue *t, TValue *key,
                               StkId val, const TValue *slot);
LUAI_FUNC void luaV_finishOp (lua_State *L);
LUAI_FUNC void luaV_execute (lua_State *L);
LUAI_FUNC void luaV_concat (lua_State *L, int total);
LUAI_FUNC lua_Integer luaV_div (lua_State *L, lua_Integer x, lua_Integer y);
LUAI_FUNC lua_Integer luaV_mod (lua_State *L, lua_Integer x, lua_Integer y);
LUAI_FUNC lua_Integer luaV_shiftl (lua_Integer x, lua_Integer y);
LUAI_FUNC void luaV_objlen (lua_State *L, StkId ra, const TValue *rb);

#endif

```

`src/Lua/lzio.c`:

```c
/*
** $Id: lzio.c,v 1.37 2015/09/08 15:41:05 roberto Exp $
** Buffered streams
** See Copyright Notice in lua.h
*/

#define lzio_c
#define LUA_CORE

#include "lprefix.h"


#include <string.h>

#include "lua.h"

#include "llimits.h"
#include "lmem.h"
#include "lstate.h"
#include "lzio.h"


int luaZ_fill (ZIO *z) {
  size_t size;
  lua_State *L = z->L;
  const char *buff;
  lua_unlock(L);
  buff = z->reader(L, z->data, &size);
  lua_lock(L);
  if (buff == NULL || size == 0)
    return EOZ;
  z->n = size - 1;  /* discount char being returned */
  z->p = buff;
  return cast_uchar(*(z->p++));
}


void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
  z->L = L;
  z->reader = reader;
  z->data = data;
  z->n = 0;
  z->p = NULL;
}


/* --------------------------------------------------------------- read --- */
size_t luaZ_read (ZIO *z, void *b, size_t n) {
  while (n) {
    size_t m;
    if (z->n == 0) {  /* no bytes in buffer? */
      if (luaZ_fill(z) == EOZ)  /* try to read more */
        return n;  /* no more input; return number of missing bytes */
      else {
        z->n++;  /* luaZ_fill consumed first byte; put it back */
        z->p--;
      }
    }
    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
    memcpy(b, z->p, m);
    z->n -= m;
    z->p += m;
    b = (char *)b + m;
    n -= m;
  }
  return 0;
}


```

`src/Lua/lzio.h`:

```h
/*
** $Id: lzio.h,v 1.31 2015/09/08 15:41:05 roberto Exp $
** Buffered streams
** See Copyright Notice in lua.h
*/


#ifndef lzio_h
#define lzio_h

#include "lua.h"

#include "lmem.h"


#define EOZ	(-1)			/* end of stream */

typedef struct Zio ZIO;

#define zgetc(z)  (((z)->n--)>0 ?  cast_uchar(*(z)->p++) : luaZ_fill(z))


typedef struct Mbuffer {
  char *buffer;
  size_t n;
  size_t buffsize;
} Mbuffer;

#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)

#define luaZ_buffer(buff)	((buff)->buffer)
#define luaZ_sizebuffer(buff)	((buff)->buffsize)
#define luaZ_bufflen(buff)	((buff)->n)

#define luaZ_buffremove(buff,i)	((buff)->n -= (i))
#define luaZ_resetbuffer(buff) ((buff)->n = 0)


#define luaZ_resizebuffer(L, buff, size) \
	((buff)->buffer = luaM_reallocvchar(L, (buff)->buffer, \
				(buff)->buffsize, size), \
	(buff)->buffsize = size)

#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)


LUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,
                                        void *data);
LUAI_FUNC size_t luaZ_read (ZIO* z, void *b, size_t n);	/* read next n bytes */



/* --------- Private Part ------------------ */

struct Zio {
  size_t n;			/* bytes still unread */
  const char *p;		/* current position in buffer */
  lua_Reader reader;		/* reader function */
  void *data;			/* additional data */
  lua_State *L;			/* Lua state (for reader) */
};


LUAI_FUNC int luaZ_fill (ZIO *z);

#endif

```

`src/Lua/socket/LICENSE`:

```
LuaSocket 3.0 license
Copyright © 2004-2013 Diego Nehab

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

```

`src/Lua/socket/README`:

```
This is the LuaSocket 3.0-rc1. It has been tested on Windows 7, Mac OS X,
and Linux. 

Please use the project page at GitHub 

    https://github.com/diegonehab/luasocket

to file bug reports or propose changes. 

Have fun,
Diego Nehab.

```

`src/Lua/socket/auxiliar.c`:

```c
/*=========================================================================*\
* Auxiliar routines for class hierarchy manipulation
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"
#include "auxiliar.h"
#include <string.h>
#include <stdio.h>

/*-------------------------------------------------------------------------*\
* Initializes the module
\*-------------------------------------------------------------------------*/
int auxiliar_open(lua_State *L) {
    (void) L;
    return 0;
}

/*-------------------------------------------------------------------------*\
* Creates a new class with given methods
* Methods whose names start with __ are passed directly to the metatable.
\*-------------------------------------------------------------------------*/
void auxiliar_newclass(lua_State *L, const char *classname, luaL_Reg *func) {
    luaL_newmetatable(L, classname); /* mt */
    /* create __index table to place methods */
    lua_pushstring(L, "__index");    /* mt,"__index" */
    lua_newtable(L);                 /* mt,"__index",it */
    /* put class name into class metatable */
    lua_pushstring(L, "class");      /* mt,"__index",it,"class" */
    lua_pushstring(L, classname);    /* mt,"__index",it,"class",classname */
    lua_rawset(L, -3);               /* mt,"__index",it */
    /* pass all methods that start with _ to the metatable, and all others
     * to the index table */
    for (; func->name; func++) {     /* mt,"__index",it */
        lua_pushstring(L, func->name);
        lua_pushcfunction(L, func->func);
        lua_rawset(L, func->name[0] == '_' ? -5: -3);
    }
    lua_rawset(L, -3);               /* mt */
    lua_pop(L, 1);
}

/*-------------------------------------------------------------------------*\
* Prints the value of a class in a nice way
\*-------------------------------------------------------------------------*/
int auxiliar_tostring(lua_State *L) {
    char buf[32];
    if (!lua_getmetatable(L, 1)) goto error;
    lua_pushstring(L, "__index");
    lua_gettable(L, -2);
    if (!lua_istable(L, -1)) goto error;
    lua_pushstring(L, "class");
    lua_gettable(L, -2);
    if (!lua_isstring(L, -1)) goto error;
    sprintf(buf, "%p", lua_touserdata(L, 1));
    lua_pushfstring(L, "%s: %s", lua_tostring(L, -1), buf);
    return 1;
error:
    lua_pushstring(L, "invalid object passed to 'auxiliar.c:__tostring'");
    lua_error(L);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Insert class into group
\*-------------------------------------------------------------------------*/
void auxiliar_add2group(lua_State *L, const char *classname, const char *groupname) {
    luaL_getmetatable(L, classname);
    lua_pushstring(L, groupname);
    lua_pushboolean(L, 1);
    lua_rawset(L, -3);
    lua_pop(L, 1);
}

/*-------------------------------------------------------------------------*\
* Make sure argument is a boolean
\*-------------------------------------------------------------------------*/
int auxiliar_checkboolean(lua_State *L, int objidx) {
    if (!lua_isboolean(L, objidx))
        auxiliar_typeerror(L, objidx, lua_typename(L, LUA_TBOOLEAN));
    return lua_toboolean(L, objidx);
}

/*-------------------------------------------------------------------------*\
* Return userdata pointer if object belongs to a given class, abort with
* error otherwise
\*-------------------------------------------------------------------------*/
void *auxiliar_checkclass(lua_State *L, const char *classname, int objidx) {
    void *data = auxiliar_getclassudata(L, classname, objidx);
    if (!data) {
        char msg[45];
        sprintf(msg, "%.35s expected", classname);
        luaL_argerror(L, objidx, msg);
    }
    return data;
}

/*-------------------------------------------------------------------------*\
* Return userdata pointer if object belongs to a given group, abort with
* error otherwise
\*-------------------------------------------------------------------------*/
void *auxiliar_checkgroup(lua_State *L, const char *groupname, int objidx) {
    void *data = auxiliar_getgroupudata(L, groupname, objidx);
    if (!data) {
        char msg[45];
        sprintf(msg, "%.35s expected", groupname);
        luaL_argerror(L, objidx, msg);
    }
    return data;
}

/*-------------------------------------------------------------------------*\
* Set object class
\*-------------------------------------------------------------------------*/
void auxiliar_setclass(lua_State *L, const char *classname, int objidx) {
    luaL_getmetatable(L, classname);
    if (objidx < 0) objidx--;
    lua_setmetatable(L, objidx);
}

/*-------------------------------------------------------------------------*\
* Get a userdata pointer if object belongs to a given group. Return NULL
* otherwise
\*-------------------------------------------------------------------------*/
void *auxiliar_getgroupudata(lua_State *L, const char *groupname, int objidx) {
    if (!lua_getmetatable(L, objidx))
        return NULL;
    lua_pushstring(L, groupname);
    lua_rawget(L, -2);
    if (lua_isnil(L, -1)) {
        lua_pop(L, 2);
        return NULL;
    } else {
        lua_pop(L, 2);
        return lua_touserdata(L, objidx);
    }
}

/*-------------------------------------------------------------------------*\
* Get a userdata pointer if object belongs to a given class. Return NULL
* otherwise
\*-------------------------------------------------------------------------*/
void *auxiliar_getclassudata(lua_State *L, const char *classname, int objidx) {
    return luaL_testudata(L, objidx, classname);
}

/*-------------------------------------------------------------------------*\
* Throws error when argument does not have correct type.
* Used to be part of lauxlib in Lua 5.1, was dropped from 5.2.
\*-------------------------------------------------------------------------*/
int auxiliar_typeerror (lua_State *L, int narg, const char *tname) {
  const char *msg = lua_pushfstring(L, "%s expected, got %s", tname,
      luaL_typename(L, narg));
  return luaL_argerror(L, narg, msg);
}

```

`src/Lua/socket/auxiliar.h`:

```h
#ifndef AUXILIAR_H
#define AUXILIAR_H
/*=========================================================================*\
* Auxiliar routines for class hierarchy manipulation
* LuaSocket toolkit (but completely independent of other LuaSocket modules)
*
* A LuaSocket class is a name associated with Lua metatables. A LuaSocket
* group is a name associated with a class. A class can belong to any number
* of groups. This module provides the functionality to:
*
*   - create new classes
*   - add classes to groups
*   - set the class of objects
*   - check if an object belongs to a given class or group
*   - get the userdata associated to objects
*   - print objects in a pretty way
*
* LuaSocket class names follow the convention <module>{<class>}. Modules
* can define any number of classes and groups. The module tcp.c, for
* example, defines the classes tcp{master}, tcp{client} and tcp{server} and
* the groups tcp{client,server} and tcp{any}. Module functions can then
* perform type-checking on their arguments by either class or group.
*
* LuaSocket metatables define the __index metamethod as being a table. This
* table has one field for each method supported by the class, and a field
* "class" with the class name.
*
* The mapping from class name to the corresponding metatable and the
* reverse mapping are done using lauxlib.
\*=========================================================================*/

#include "luasocket.h"

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int auxiliar_open(lua_State *L);
void auxiliar_newclass(lua_State *L, const char *classname, luaL_Reg *func);
int auxiliar_tostring(lua_State *L);
void auxiliar_add2group(lua_State *L, const char *classname, const char *group);
int auxiliar_checkboolean(lua_State *L, int objidx);
void *auxiliar_checkclass(lua_State *L, const char *classname, int objidx);
void *auxiliar_checkgroup(lua_State *L, const char *groupname, int objidx);
void auxiliar_setclass(lua_State *L, const char *classname, int objidx);
void *auxiliar_getgroupudata(lua_State *L, const char *groupname, int objidx);
void *auxiliar_getclassudata(lua_State *L, const char *groupname, int objidx);
int auxiliar_typeerror(lua_State *L, int narg, const char *tname);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* AUXILIAR_H */

```

`src/Lua/socket/buffer.c`:

```c
/*=========================================================================*\
* Input/Output interface for Lua programs
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"
#include "buffer.h"

/*=========================================================================*\
* Internal function prototypes
\*=========================================================================*/
static int recvraw(p_buffer buf, size_t wanted, luaL_Buffer *b);
static int recvline(p_buffer buf, luaL_Buffer *b);
static int recvall(p_buffer buf, luaL_Buffer *b);
static int buffer_get(p_buffer buf, const char **data, size_t *count);
static void buffer_skip(p_buffer buf, size_t count);
static int sendraw(p_buffer buf, const char *data, size_t count, size_t *sent);

/* min and max macros */
#ifndef MIN
#define MIN(x, y) ((x) < (y) ? x : y)
#endif
#ifndef MAX
#define MAX(x, y) ((x) > (y) ? x : y)
#endif

/*=========================================================================*\
* Exported functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Initializes module
\*-------------------------------------------------------------------------*/
int buffer_open(lua_State *L) {
    (void) L;
    return 0;
}

/*-------------------------------------------------------------------------*\
* Initializes C structure
\*-------------------------------------------------------------------------*/
void buffer_init(p_buffer buf, p_io io, p_timeout tm) {
    buf->first = buf->last = 0;
    buf->io = io;
    buf->tm = tm;
    buf->received = buf->sent = 0;
    buf->birthday = timeout_gettime();
}

/*-------------------------------------------------------------------------*\
* object:getstats() interface
\*-------------------------------------------------------------------------*/
int buffer_meth_getstats(lua_State *L, p_buffer buf) {
    lua_pushnumber(L, (lua_Number) buf->received);
    lua_pushnumber(L, (lua_Number) buf->sent);
    lua_pushnumber(L, timeout_gettime() - buf->birthday);
    return 3;
}

/*-------------------------------------------------------------------------*\
* object:setstats() interface
\*-------------------------------------------------------------------------*/
int buffer_meth_setstats(lua_State *L, p_buffer buf) {
    buf->received = (long) luaL_optnumber(L, 2, (lua_Number) buf->received);
    buf->sent = (long) luaL_optnumber(L, 3, (lua_Number) buf->sent);
    if (lua_isnumber(L, 4)) buf->birthday = timeout_gettime() - lua_tonumber(L, 4);
    lua_pushnumber(L, 1);
    return 1;
}

/*-------------------------------------------------------------------------*\
* object:send() interface
\*-------------------------------------------------------------------------*/
int buffer_meth_send(lua_State *L, p_buffer buf) {
    int top = lua_gettop(L);
    int err = IO_DONE;
    size_t size = 0, sent = 0;
    const char *data = luaL_checklstring(L, 2, &size);
    long start = (long) luaL_optnumber(L, 3, 1);
    long end = (long) luaL_optnumber(L, 4, -1);
    timeout_markstart(buf->tm);
    if (start < 0) start = (long) (size+start+1);
    if (end < 0) end = (long) (size+end+1);
    if (start < 1) start = (long) 1;
    if (end > (long) size) end = (long) size;
    if (start <= end) err = sendraw(buf, data+start-1, end-start+1, &sent);
    /* check if there was an error */
    if (err != IO_DONE) {
        lua_pushnil(L);
        lua_pushstring(L, buf->io->error(buf->io->ctx, err));
        lua_pushnumber(L, (lua_Number) (sent+start-1));
    } else {
        lua_pushnumber(L, (lua_Number) (sent+start-1));
        lua_pushnil(L);
        lua_pushnil(L);
    }
#ifdef LUASOCKET_DEBUG
    /* push time elapsed during operation as the last return value */
    lua_pushnumber(L, timeout_gettime() - timeout_getstart(buf->tm));
#endif
    return lua_gettop(L) - top;
}

/*-------------------------------------------------------------------------*\
* object:receive() interface
\*-------------------------------------------------------------------------*/
int buffer_meth_receive(lua_State *L, p_buffer buf) {
    int err = IO_DONE, top = lua_gettop(L);
    luaL_Buffer b;
    size_t size;
    const char *part = luaL_optlstring(L, 3, "", &size);
    timeout_markstart(buf->tm);
    /* initialize buffer with optional extra prefix
     * (useful for concatenating previous partial results) */
    luaL_buffinit(L, &b);
    luaL_addlstring(&b, part, size);
    /* receive new patterns */
    if (!lua_isnumber(L, 2)) {
        const char *p= luaL_optstring(L, 2, "*l");
        if (p[0] == '*' && p[1] == 'l') err = recvline(buf, &b);
        else if (p[0] == '*' && p[1] == 'a') err = recvall(buf, &b);
        else luaL_argcheck(L, 0, 2, "invalid receive pattern");
    /* get a fixed number of bytes (minus what was already partially
     * received) */
    } else {
        double n = lua_tonumber(L, 2);
        size_t wanted = (size_t) n;
        luaL_argcheck(L, n >= 0, 2, "invalid receive pattern");
        if (size == 0 || wanted > size)
            err = recvraw(buf, wanted-size, &b);
    }
    /* check if there was an error */
    if (err != IO_DONE) {
        /* we can't push anyting in the stack before pushing the
         * contents of the buffer. this is the reason for the complication */
        luaL_pushresult(&b);
        lua_pushstring(L, buf->io->error(buf->io->ctx, err));
        lua_pushvalue(L, -2);
        lua_pushnil(L);
        lua_replace(L, -4);
    } else {
        luaL_pushresult(&b);
        lua_pushnil(L);
        lua_pushnil(L);
    }
#ifdef LUASOCKET_DEBUG
    /* push time elapsed during operation as the last return value */
    lua_pushnumber(L, timeout_gettime() - timeout_getstart(buf->tm));
#endif
    return lua_gettop(L) - top;
}

/*-------------------------------------------------------------------------*\
* Determines if there is any data in the read buffer
\*-------------------------------------------------------------------------*/
int buffer_isempty(p_buffer buf) {
    return buf->first >= buf->last;
}

/*=========================================================================*\
* Internal functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Sends a block of data (unbuffered)
\*-------------------------------------------------------------------------*/
#define STEPSIZE 8192
static int sendraw(p_buffer buf, const char *data, size_t count, size_t *sent) {
    p_io io = buf->io;
    p_timeout tm = buf->tm;
    size_t total = 0;
    int err = IO_DONE;
    while (total < count && err == IO_DONE) {
        size_t done = 0;
        size_t step = (count-total <= STEPSIZE)? count-total: STEPSIZE;
        err = io->send(io->ctx, data+total, step, &done, tm);
        total += done;
    }
    *sent = total;
    buf->sent += total;
    return err;
}

/*-------------------------------------------------------------------------*\
* Reads a fixed number of bytes (buffered)
\*-------------------------------------------------------------------------*/
static int recvraw(p_buffer buf, size_t wanted, luaL_Buffer *b) {
    int err = IO_DONE;
    size_t total = 0;
    while (err == IO_DONE) {
        size_t count; const char *data;
        err = buffer_get(buf, &data, &count);
        count = MIN(count, wanted - total);
        luaL_addlstring(b, data, count);
        buffer_skip(buf, count);
        total += count;
        if (total >= wanted) break;
    }
    return err;
}

/*-------------------------------------------------------------------------*\
* Reads everything until the connection is closed (buffered)
\*-------------------------------------------------------------------------*/
static int recvall(p_buffer buf, luaL_Buffer *b) {
    int err = IO_DONE;
    size_t total = 0;
    while (err == IO_DONE) {
        const char *data; size_t count;
        err = buffer_get(buf, &data, &count);
        total += count;
        luaL_addlstring(b, data, count);
        buffer_skip(buf, count);
    }
    if (err == IO_CLOSED) {
        if (total > 0) return IO_DONE;
        else return IO_CLOSED;
    } else return err;
}

/*-------------------------------------------------------------------------*\
* Reads a line terminated by a CR LF pair or just by a LF. The CR and LF
* are not returned by the function and are discarded from the buffer
\*-------------------------------------------------------------------------*/
static int recvline(p_buffer buf, luaL_Buffer *b) {
    int err = IO_DONE;
    while (err == IO_DONE) {
        size_t count, pos; const char *data;
        err = buffer_get(buf, &data, &count);
        pos = 0;
        while (pos < count && data[pos] != '\n') {
            /* we ignore all \r's */
            if (data[pos] != '\r') luaL_addchar(b, data[pos]);
            pos++;
        }
        if (pos < count) { /* found '\n' */
            buffer_skip(buf, pos+1); /* skip '\n' too */
            break; /* we are done */
        } else /* reached the end of the buffer */
            buffer_skip(buf, pos);
    }
    return err;
}

/*-------------------------------------------------------------------------*\
* Skips a given number of bytes from read buffer. No data is read from the
* transport layer
\*-------------------------------------------------------------------------*/
static void buffer_skip(p_buffer buf, size_t count) {
    buf->received += count;
    buf->first += count;
    if (buffer_isempty(buf))
        buf->first = buf->last = 0;
}

/*-------------------------------------------------------------------------*\
* Return any data available in buffer, or get more data from transport layer
* if buffer is empty
\*-------------------------------------------------------------------------*/
static int buffer_get(p_buffer buf, const char **data, size_t *count) {
    int err = IO_DONE;
    p_io io = buf->io;
    p_timeout tm = buf->tm;
    if (buffer_isempty(buf)) {
        size_t got;
        err = io->recv(io->ctx, buf->data, BUF_SIZE, &got, tm);
        buf->first = 0;
        buf->last = got;
    }
    *count = buf->last - buf->first;
    *data = buf->data + buf->first;
    return err;
}

```

`src/Lua/socket/buffer.h`:

```h
#ifndef BUF_H
#define BUF_H 
/*=========================================================================*\
* Input/Output interface for Lua programs
* LuaSocket toolkit
*
* Line patterns require buffering. Reading one character at a time involves
* too many system calls and is very slow. This module implements the
* LuaSocket interface for input/output on connected objects, as seen by 
* Lua programs. 
*
* Input is buffered. Output is *not* buffered because there was no simple
* way of making sure the buffered output data would ever be sent.
*
* The module is built on top of the I/O abstraction defined in io.h and the
* timeout management is done with the timeout.h interface.
\*=========================================================================*/
#include "luasocket.h"
#include "io.h"
#include "timeout.h"

/* buffer size in bytes */
#define BUF_SIZE 8192

/* buffer control structure */
typedef struct t_buffer_ {
    double birthday;        /* throttle support info: creation time, */
    size_t sent, received;  /* bytes sent, and bytes received */
    p_io io;                /* IO driver used for this buffer */
    p_timeout tm;           /* timeout management for this buffer */
    size_t first, last;     /* index of first and last bytes of stored data */
    char data[BUF_SIZE];    /* storage space for buffer data */
} t_buffer;
typedef t_buffer *p_buffer;

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int buffer_open(lua_State *L);
void buffer_init(p_buffer buf, p_io io, p_timeout tm);
int buffer_meth_getstats(lua_State *L, p_buffer buf);
int buffer_meth_setstats(lua_State *L, p_buffer buf);
int buffer_meth_send(lua_State *L, p_buffer buf);
int buffer_meth_receive(lua_State *L, p_buffer buf);
int buffer_isempty(p_buffer buf);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* BUF_H */

```

`src/Lua/socket/compat.c`:

```c
#include "luasocket.h"
#include "compat.h"

#if LUA_VERSION_NUM==501

/*
** Adapted from Lua 5.2
*/
void luasocket_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {
  luaL_checkstack(L, nup+1, "too many upvalues");
  for (; l->name != NULL; l++) {  /* fill the table with given functions */
    int i;
    lua_pushstring(L, l->name);
    for (i = 0; i < nup; i++)  /* copy upvalues to the top */
      lua_pushvalue(L, -(nup+1));
    lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */
    lua_settable(L, -(nup + 3));
  }
  lua_pop(L, nup);  /* remove upvalues */
}

/*
** Duplicated from Lua 5.2
*/
void *luasocket_testudata (lua_State *L, int ud, const char *tname) {
  void *p = lua_touserdata(L, ud);
  if (p != NULL) {  /* value is a userdata? */
    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
      luaL_getmetatable(L, tname);  /* get correct metatable */
      if (!lua_rawequal(L, -1, -2))  /* not the same? */
        p = NULL;  /* value is a userdata with wrong metatable */
      lua_pop(L, 2);  /* remove both metatables */
      return p;
    }
  }
  return NULL;  /* value is not a userdata with a metatable */
}

#endif

```

`src/Lua/socket/compat.h`:

```h
#ifndef COMPAT_H
#define COMPAT_H

#if LUA_VERSION_NUM==501

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

void luasocket_setfuncs (lua_State *L, const luaL_Reg *l, int nup);
void *luasocket_testudata ( lua_State *L, int arg, const char *tname);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#define luaL_setfuncs luasocket_setfuncs
#define luaL_testudata luasocket_testudata

#endif

#endif

```

`src/Lua/socket/except.c`:

```c
/*=========================================================================*\
* Simple exception support
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"
#include "except.h"
#include <stdio.h>

#if LUA_VERSION_NUM < 502
#define lua_pcallk(L, na, nr, err, ctx, cont) \
    (((void)ctx),((void)cont),lua_pcall(L, na, nr, err))
#endif

#if LUA_VERSION_NUM < 503
typedef int lua_KContext;
#endif

/*=========================================================================*\
* Internal function prototypes.
\*=========================================================================*/
static int global_protect(lua_State *L);
static int global_newtry(lua_State *L);
static int protected_(lua_State *L);
static int finalize(lua_State *L);
static int do_nothing(lua_State *L);

/* except functions */
static luaL_Reg func[] = {
    {"newtry",    global_newtry},
    {"protect",   global_protect},
    {NULL,        NULL}
};

/*-------------------------------------------------------------------------*\
* Try factory
\*-------------------------------------------------------------------------*/
static void wrap(lua_State *L) {
    lua_createtable(L, 1, 0);
    lua_pushvalue(L, -2);
    lua_rawseti(L, -2, 1);
    lua_pushvalue(L, lua_upvalueindex(1));
    lua_setmetatable(L, -2);
}

static int finalize(lua_State *L) {
    if (!lua_toboolean(L, 1)) {
        lua_pushvalue(L, lua_upvalueindex(2));
        lua_call(L, 0, 0);
        lua_settop(L, 2);
        wrap(L);
        lua_error(L);
        return 0;
    } else return lua_gettop(L);
}

static int do_nothing(lua_State *L) {
    (void) L;
    return 0;
}

static int global_newtry(lua_State *L) {
    lua_settop(L, 1);
    if (lua_isnil(L, 1)) lua_pushcfunction(L, do_nothing);
    lua_pushvalue(L, lua_upvalueindex(1));
    lua_insert(L, -2);
    lua_pushcclosure(L, finalize, 2);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Protect factory
\*-------------------------------------------------------------------------*/
static int unwrap(lua_State *L) {
    if (lua_istable(L, -1) && lua_getmetatable(L, -1)) {
        int r = lua_rawequal(L, -1, lua_upvalueindex(1));
        lua_pop(L, 1);
        if (r) {
            lua_pushnil(L);
            lua_rawgeti(L, -2, 1);
            return 1;
        }
    }
    return 0;
}

static int protected_finish(lua_State *L, int status, lua_KContext ctx) {
    (void)ctx;
    if (status != 0 && status != LUA_YIELD) {
        if (unwrap(L)) return 2;
        else return lua_error(L);
    } else return lua_gettop(L);
}

#if LUA_VERSION_NUM == 502
static int protected_cont(lua_State *L) {
    int ctx = 0;
    int status = lua_getctx(L, &ctx);
    return protected_finish(L, status, ctx);
}
#else
#define protected_cont protected_finish
#endif

static int protected_(lua_State *L) {
    int status;
    lua_pushvalue(L, lua_upvalueindex(2));
    lua_insert(L, 1);
    status = lua_pcallk(L, lua_gettop(L) - 1, LUA_MULTRET, 0, 0, protected_cont);
    return protected_finish(L, status, 0);
}

static int global_protect(lua_State *L) {
    lua_settop(L, 1);
    lua_pushvalue(L, lua_upvalueindex(1));
    lua_insert(L, 1);
    lua_pushcclosure(L, protected_, 2);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Init module
\*-------------------------------------------------------------------------*/
int except_open(lua_State *L) {
    lua_newtable(L); /* metatable for wrapped exceptions */
    lua_pushboolean(L, 0);
    lua_setfield(L, -2, "__metatable");
    luaL_setfuncs(L, func, 1);
    return 0;
}

```

`src/Lua/socket/except.h`:

```h
#ifndef EXCEPT_H
#define EXCEPT_H
/*=========================================================================*\
* Exception control
* LuaSocket toolkit (but completely independent from other modules)
*
* This provides support for simple exceptions in Lua. During the
* development of the HTTP/FTP/SMTP support, it became aparent that
* error checking was taking a substantial amount of the coding. These
* function greatly simplify the task of checking errors.
*
* The main idea is that functions should return nil as their first return
* values when they find an error, and return an error message (or value)
* following nil. In case of success, as long as the first value is not nil,
* the other values don't matter.
*
* The idea is to nest function calls with the "try" function. This function
* checks the first value, and, if it's falsy, wraps the second value in a
* table with metatable and calls "error" on it. Otherwise, it returns all
* values it received. Basically, it works like the Lua "assert" function,
* but it creates errors targeted specifically at "protect".
*
* The "newtry" function is a factory for "try" functions that call a
* finalizer in protected mode before calling "error".
*
* The "protect" function returns a new function that behaves exactly like
* the function it receives, but the new function catches exceptions thrown
* by "try" functions and returns nil followed by the error message instead.
*
* With these three functions, it's easy to write functions that throw
* exceptions on error, but that don't interrupt the user script.
\*=========================================================================*/

#include "luasocket.h"

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int except_open(lua_State *L);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif

```

`src/Lua/socket/inet.c`:

```c
/*=========================================================================*\
* Internet domain functions
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"
#include "inet.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*=========================================================================*\
* Internal function prototypes.
\*=========================================================================*/
static int inet_global_toip(lua_State *L);
static int inet_global_getaddrinfo(lua_State *L);
static int inet_global_tohostname(lua_State *L);
static int inet_global_getnameinfo(lua_State *L);
static void inet_pushresolved(lua_State *L, struct hostent *hp);
static int inet_global_gethostname(lua_State *L);

/* DNS functions */
static luaL_Reg func[] = {
    { "toip", inet_global_toip},
    { "getaddrinfo", inet_global_getaddrinfo},
    { "tohostname", inet_global_tohostname},
    { "getnameinfo", inet_global_getnameinfo},
    { "gethostname", inet_global_gethostname},
    { NULL, NULL}
};

/*-------------------------------------------------------------------------*\
* Initializes module
\*-------------------------------------------------------------------------*/
int inet_open(lua_State *L)
{
    lua_pushstring(L, "dns");
    lua_newtable(L);
    luaL_setfuncs(L, func, 0);
    lua_settable(L, -3);
    return 0;
}

/*=========================================================================*\
* Global Lua functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Returns all information provided by the resolver given a host name
* or ip address
\*-------------------------------------------------------------------------*/
static int inet_gethost(const char *address, struct hostent **hp) {
    struct in_addr addr;
    if (inet_aton(address, &addr))
        return socket_gethostbyaddr((char *) &addr, sizeof(addr), hp);
    else
        return socket_gethostbyname(address, hp);
}

/*-------------------------------------------------------------------------*\
* Returns all information provided by the resolver given a host name
* or ip address
\*-------------------------------------------------------------------------*/
static int inet_global_tohostname(lua_State *L) {
    const char *address = luaL_checkstring(L, 1);
    struct hostent *hp = NULL;
    int err = inet_gethost(address, &hp);
    if (err != IO_DONE) {
        lua_pushnil(L);
        lua_pushstring(L, socket_hoststrerror(err));
        return 2;
    }
    lua_pushstring(L, hp->h_name);
    inet_pushresolved(L, hp);
    return 2;
}

static int inet_global_getnameinfo(lua_State *L) {
    char hbuf[NI_MAXHOST];
    char sbuf[NI_MAXSERV];
    int i, ret;
    struct addrinfo hints;
    struct addrinfo *resolved, *iter;
    const char *host = luaL_optstring(L, 1, NULL);
    const char *serv = luaL_optstring(L, 2, NULL);

    if (!(host || serv))
        luaL_error(L, "host and serv cannot be both nil");

    memset(&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_UNSPEC;

    ret = getaddrinfo(host, serv, &hints, &resolved);
    if (ret != 0) {
        lua_pushnil(L);
        lua_pushstring(L, socket_gaistrerror(ret));
        return 2;
    }

    lua_newtable(L);
    for (i = 1, iter = resolved; iter; i++, iter = iter->ai_next) {
        getnameinfo(iter->ai_addr, (socklen_t) iter->ai_addrlen,
            hbuf, host? (socklen_t) sizeof(hbuf): 0,
            sbuf, serv? (socklen_t) sizeof(sbuf): 0, 0);
        if (host) {
            lua_pushnumber(L, i);
            lua_pushstring(L, hbuf);
            lua_settable(L, -3);
        }
    }
    freeaddrinfo(resolved);

    if (serv) {
        lua_pushstring(L, sbuf);
        return 2;
    } else {
        return 1;
    }
}

/*-------------------------------------------------------------------------*\
* Returns all information provided by the resolver given a host name
* or ip address
\*-------------------------------------------------------------------------*/
static int inet_global_toip(lua_State *L)
{
    const char *address = luaL_checkstring(L, 1);
    struct hostent *hp = NULL;
    int err = inet_gethost(address, &hp);
    if (err != IO_DONE) {
        lua_pushnil(L);
        lua_pushstring(L, socket_hoststrerror(err));
        return 2;
    }
    lua_pushstring(L, inet_ntoa(*((struct in_addr *) hp->h_addr)));
    inet_pushresolved(L, hp);
    return 2;
}

int inet_optfamily(lua_State* L, int narg, const char* def)
{
    static const char* optname[] = { "unspec", "inet", "inet6", NULL };
    static int optvalue[] = { AF_UNSPEC, AF_INET, AF_INET6, 0 };

    return optvalue[luaL_checkoption(L, narg, def, optname)];
}

int inet_optsocktype(lua_State* L, int narg, const char* def)
{
    static const char* optname[] = { "stream", "dgram", NULL };
    static int optvalue[] = { SOCK_STREAM, SOCK_DGRAM, 0 };

    return optvalue[luaL_checkoption(L, narg, def, optname)];
}

static int inet_global_getaddrinfo(lua_State *L)
{
    const char *hostname = luaL_checkstring(L, 1);
    struct addrinfo *iterator = NULL, *resolved = NULL;
    struct addrinfo hints;
    int i = 1, ret = 0;
    memset(&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_UNSPEC;
    ret = getaddrinfo(hostname, NULL, &hints, &resolved);
    if (ret != 0) {
        lua_pushnil(L);
        lua_pushstring(L, socket_gaistrerror(ret));
        return 2;
    }
    lua_newtable(L);
    for (iterator = resolved; iterator; iterator = iterator->ai_next) {
        char hbuf[NI_MAXHOST];
        ret = getnameinfo(iterator->ai_addr, (socklen_t) iterator->ai_addrlen,
            hbuf, (socklen_t) sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
        if (ret){
          freeaddrinfo(resolved);
          lua_pushnil(L);
          lua_pushstring(L, socket_gaistrerror(ret));
          return 2;
        }
        lua_pushnumber(L, i);
        lua_newtable(L);
        switch (iterator->ai_family) {
            case AF_INET:
                lua_pushliteral(L, "family");
                lua_pushliteral(L, "inet");
                lua_settable(L, -3);
                break;
            case AF_INET6:
                lua_pushliteral(L, "family");
                lua_pushliteral(L, "inet6");
                lua_settable(L, -3);
                break;
            case AF_UNSPEC:
                lua_pushliteral(L, "family");
                lua_pushliteral(L, "unspec");
                lua_settable(L, -3);
                break;
            default:
                lua_pushliteral(L, "family");
                lua_pushliteral(L, "unknown");
                lua_settable(L, -3);
                break;
        }
        lua_pushliteral(L, "addr");
        lua_pushstring(L, hbuf);
        lua_settable(L, -3);
        lua_settable(L, -3);
        i++;
    }
    freeaddrinfo(resolved);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Gets the host name
\*-------------------------------------------------------------------------*/
static int inet_global_gethostname(lua_State *L)
{
    char name[257];
    name[256] = '\0';
    if (gethostname(name, 256) < 0) {
        lua_pushnil(L);
        lua_pushstring(L, socket_strerror(errno));
        return 2;
    } else {
        lua_pushstring(L, name);
        return 1;
    }
}

/*=========================================================================*\
* Lua methods
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Retrieves socket peer name
\*-------------------------------------------------------------------------*/
int inet_meth_getpeername(lua_State *L, p_socket ps, int family)
{
    int err;
    struct sockaddr_storage peer;
    socklen_t peer_len = sizeof(peer);
    char name[INET6_ADDRSTRLEN];
    char port[6]; /* 65535 = 5 bytes + 0 to terminate it */
    if (getpeername(*ps, (SA *) &peer, &peer_len) < 0) {
        lua_pushnil(L);
        lua_pushstring(L, socket_strerror(errno));
        return 2;
    }
	err = getnameinfo((struct sockaddr *) &peer, peer_len,
        name, INET6_ADDRSTRLEN,
        port, sizeof(port), NI_NUMERICHOST | NI_NUMERICSERV);
    if (err) {
        lua_pushnil(L);
        lua_pushstring(L, gai_strerror(err));
        return 2;
    }
    lua_pushstring(L, name);
    lua_pushinteger(L, (int) strtol(port, (char **) NULL, 10));
    switch (family) {
        case AF_INET: lua_pushliteral(L, "inet"); break;
        case AF_INET6: lua_pushliteral(L, "inet6"); break;
        case AF_UNSPEC: lua_pushliteral(L, "unspec"); break;
        default: lua_pushliteral(L, "unknown"); break;
    }
    return 3;
}

/*-------------------------------------------------------------------------*\
* Retrieves socket local name
\*-------------------------------------------------------------------------*/
int inet_meth_getsockname(lua_State *L, p_socket ps, int family)
{
    int err;
    struct sockaddr_storage peer;
    socklen_t peer_len = sizeof(peer);
    char name[INET6_ADDRSTRLEN];
    char port[6]; /* 65535 = 5 bytes + 0 to terminate it */
    if (getsockname(*ps, (SA *) &peer, &peer_len) < 0) {
        lua_pushnil(L);
        lua_pushstring(L, socket_strerror(errno));
        return 2;
    }
	err=getnameinfo((struct sockaddr *)&peer, peer_len,
		name, INET6_ADDRSTRLEN, port, 6, NI_NUMERICHOST | NI_NUMERICSERV);
    if (err) {
        lua_pushnil(L);
        lua_pushstring(L, gai_strerror(err));
        return 2;
    }
    lua_pushstring(L, name);
    lua_pushstring(L, port);
    switch (family) {
        case AF_INET: lua_pushliteral(L, "inet"); break;
        case AF_INET6: lua_pushliteral(L, "inet6"); break;
        case AF_UNSPEC: lua_pushliteral(L, "unspec"); break;
        default: lua_pushliteral(L, "unknown"); break;
    }
    return 3;
}

/*=========================================================================*\
* Internal functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Passes all resolver information to Lua as a table
\*-------------------------------------------------------------------------*/
static void inet_pushresolved(lua_State *L, struct hostent *hp)
{
    char **alias;
    struct in_addr **addr;
    int i, resolved;
    lua_newtable(L); resolved = lua_gettop(L);
    lua_pushstring(L, "name");
    lua_pushstring(L, hp->h_name);
    lua_settable(L, resolved);
    lua_pushstring(L, "ip");
    lua_pushstring(L, "alias");
    i = 1;
    alias = hp->h_aliases;
    lua_newtable(L);
    if (alias) {
        while (*alias) {
            lua_pushnumber(L, i);
            lua_pushstring(L, *alias);
            lua_settable(L, -3);
            i++; alias++;
        }
    }
    lua_settable(L, resolved);
    i = 1;
    lua_newtable(L);
    addr = (struct in_addr **) hp->h_addr_list;
    if (addr) {
        while (*addr) {
            lua_pushnumber(L, i);
            lua_pushstring(L, inet_ntoa(**addr));
            lua_settable(L, -3);
            i++; addr++;
        }
    }
    lua_settable(L, resolved);
}

/*-------------------------------------------------------------------------*\
* Tries to create a new inet socket
\*-------------------------------------------------------------------------*/
const char *inet_trycreate(p_socket ps, int family, int type, int protocol) {
    const char *err = socket_strerror(socket_create(ps, family, type, protocol));
    if (err == NULL && family == AF_INET6) {
        int yes = 1;
        setsockopt(*ps, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&yes, sizeof(yes));
    }
    return err;
}

/*-------------------------------------------------------------------------*\
* "Disconnects" a DGRAM socket
\*-------------------------------------------------------------------------*/
const char *inet_trydisconnect(p_socket ps, int family, p_timeout tm)
{
    switch (family) {
        case AF_INET: {
            struct sockaddr_in sin;
            memset((char *) &sin, 0, sizeof(sin));
            sin.sin_family = AF_UNSPEC;
            sin.sin_addr.s_addr = INADDR_ANY;
            return socket_strerror(socket_connect(ps, (SA *) &sin,
                sizeof(sin), tm));
        }
        case AF_INET6: {
            struct sockaddr_in6 sin6;
            struct in6_addr addrany = IN6ADDR_ANY_INIT;
            memset((char *) &sin6, 0, sizeof(sin6));
            sin6.sin6_family = AF_UNSPEC;
            sin6.sin6_addr = addrany;
            return socket_strerror(socket_connect(ps, (SA *) &sin6,
                sizeof(sin6), tm));
        }
    }
    return NULL;
}

/*-------------------------------------------------------------------------*\
* Tries to connect to remote address (address, port)
\*-------------------------------------------------------------------------*/
const char *inet_tryconnect(p_socket ps, int *family, const char *address,
        const char *serv, p_timeout tm, struct addrinfo *connecthints)
{
    struct addrinfo *iterator = NULL, *resolved = NULL;
    const char *err = NULL;
    int current_family = *family;
    /* try resolving */
    err = socket_gaistrerror(getaddrinfo(address, serv,
                connecthints, &resolved));
    if (err != NULL) {
        if (resolved) freeaddrinfo(resolved);
        return err;
    }
    for (iterator = resolved; iterator; iterator = iterator->ai_next) {
        timeout_markstart(tm);
        /* create new socket if necessary. if there was no
         * bind, we need to create one for every new family
         * that shows up while iterating. if there was a
         * bind, all families will be the same and we will
         * not enter this branch. */
        if (current_family != iterator->ai_family || *ps == SOCKET_INVALID) {
            socket_destroy(ps);
            err = inet_trycreate(ps, iterator->ai_family,
                iterator->ai_socktype, iterator->ai_protocol);
            if (err) continue;
            current_family = iterator->ai_family;
            /* set non-blocking before connect */
            socket_setnonblocking(ps);
        }
        /* try connecting to remote address */
        err = socket_strerror(socket_connect(ps, (SA *) iterator->ai_addr,
            (socklen_t) iterator->ai_addrlen, tm));
        /* if success or timeout is zero, break out of loop */
        if (err == NULL || timeout_iszero(tm)) {
            *family = current_family;
            break;
        }
    }
    freeaddrinfo(resolved);
    /* here, if err is set, we failed */
    return err;
}

/*-------------------------------------------------------------------------*\
* Tries to accept a socket
\*-------------------------------------------------------------------------*/
const char *inet_tryaccept(p_socket server, int family, p_socket client,
    p_timeout tm) {
	socklen_t len;
	t_sockaddr_storage addr;
    switch (family) {
        case AF_INET6: len = sizeof(struct sockaddr_in6); break;
        case AF_INET: len = sizeof(struct sockaddr_in); break;
        default: len = sizeof(addr); break;
    }
	return socket_strerror(socket_accept(server, client, (SA *) &addr,
        &len, tm));
}

/*-------------------------------------------------------------------------*\
* Tries to bind socket to (address, port)
\*-------------------------------------------------------------------------*/
const char *inet_trybind(p_socket ps, int *family, const char *address,
    const char *serv, struct addrinfo *bindhints) {
    struct addrinfo *iterator = NULL, *resolved = NULL;
    const char *err = NULL;
    int current_family = *family;
    /* translate luasocket special values to C */
    if (strcmp(address, "*") == 0) address = NULL;
    if (!serv) serv = "0";
    /* try resolving */
    err = socket_gaistrerror(getaddrinfo(address, serv, bindhints, &resolved));
    if (err) {
        if (resolved) freeaddrinfo(resolved);
        return err;
    }
    /* iterate over resolved addresses until one is good */
    for (iterator = resolved; iterator; iterator = iterator->ai_next) {
        if (current_family != iterator->ai_family || *ps == SOCKET_INVALID) {
            socket_destroy(ps);
            err = inet_trycreate(ps, iterator->ai_family,
                        iterator->ai_socktype, iterator->ai_protocol);
            if (err) continue;
            current_family = iterator->ai_family;
        }
        /* try binding to local address */
        err = socket_strerror(socket_bind(ps, (SA *) iterator->ai_addr,
            (socklen_t) iterator->ai_addrlen));
        /* keep trying unless bind succeeded */
        if (err == NULL) {
            *family = current_family;
            /* set to non-blocking after bind */
            socket_setnonblocking(ps);
            break;
        }
    }
    /* cleanup and return error */
    freeaddrinfo(resolved);
    /* here, if err is set, we failed */
    return err;
}

/*-------------------------------------------------------------------------*\
* Some systems do not provide these so that we provide our own.
\*-------------------------------------------------------------------------*/
#ifdef LUASOCKET_INET_ATON
int inet_aton(const char *cp, struct in_addr *inp)
{
    unsigned int a = 0, b = 0, c = 0, d = 0;
    int n = 0, r;
    unsigned long int addr = 0;
    r = sscanf(cp, "%u.%u.%u.%u%n", &a, &b, &c, &d, &n);
    if (r == 0 || n == 0) return 0;
    cp += n;
    if (*cp) return 0;
    if (a > 255 || b > 255 || c > 255 || d > 255) return 0;
    if (inp) {
        addr += a; addr <<= 8;
        addr += b; addr <<= 8;
        addr += c; addr <<= 8;
        addr += d;
        inp->s_addr = htonl(addr);
    }
    return 1;
}
#endif

#ifdef LUASOCKET_INET_PTON
int inet_pton(int af, const char *src, void *dst)
{
    struct addrinfo hints, *res;
    int ret = 1;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = af;
    hints.ai_flags = AI_NUMERICHOST;
    if (getaddrinfo(src, NULL, &hints, &res) != 0) return -1;
    if (af == AF_INET) {
        struct sockaddr_in *in = (struct sockaddr_in *) res->ai_addr;
        memcpy(dst, &in->sin_addr, sizeof(in->sin_addr));
    } else if (af == AF_INET6) {
        struct sockaddr_in6 *in = (struct sockaddr_in6 *) res->ai_addr;
        memcpy(dst, &in->sin6_addr, sizeof(in->sin6_addr));
    } else {
        ret = -1;
    }
    freeaddrinfo(res);
    return ret;
}

#endif

```

`src/Lua/socket/inet.h`:

```h
#ifndef INET_H
#define INET_H
/*=========================================================================*\
* Internet domain functions
* LuaSocket toolkit
*
* This module implements the creation and connection of internet domain
* sockets, on top of the socket.h interface, and the interface of with the
* resolver.
*
* The function inet_aton is provided for the platforms where it is not
* available. The module also implements the interface of the internet
* getpeername and getsockname functions as seen by Lua programs.
*
* The Lua functions toip and tohostname are also implemented here.
\*=========================================================================*/
#include "luasocket.h"
#include "socket.h"
#include "timeout.h"

#ifdef _WIN32
#define LUASOCKET_INET_ATON
#endif

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int inet_open(lua_State *L);

int inet_optfamily(lua_State* L, int narg, const char* def);
int inet_optsocktype(lua_State* L, int narg, const char* def);

int inet_meth_getpeername(lua_State *L, p_socket ps, int family);
int inet_meth_getsockname(lua_State *L, p_socket ps, int family);

const char *inet_trycreate(p_socket ps, int family, int type, int protocol);
const char *inet_trydisconnect(p_socket ps, int family, p_timeout tm);
const char *inet_tryconnect(p_socket ps, int *family, const char *address, const char *serv, p_timeout tm, struct addrinfo *connecthints);
const char *inet_tryaccept(p_socket server, int family, p_socket client, p_timeout tm);
const char *inet_trybind(p_socket ps, int *family, const char *address, const char *serv, struct addrinfo *bindhints);

#ifdef LUASOCKET_INET_ATON
int inet_aton(const char *cp, struct in_addr *inp);
#endif

#ifdef LUASOCKET_INET_PTON
const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt);
int inet_pton(int af, const char *src, void *dst);
#endif

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* INET_H */

```

`src/Lua/socket/io.c`:

```c
/*=========================================================================*\
* Input/Output abstraction
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"
#include "io.h"

/*-------------------------------------------------------------------------*\
* Initializes C structure
\*-------------------------------------------------------------------------*/
void io_init(p_io io, p_send send, p_recv recv, p_error error, void *ctx) {
    io->send = send;
    io->recv = recv;
    io->error = error;
    io->ctx = ctx;
}

/*-------------------------------------------------------------------------*\
* I/O error strings
\*-------------------------------------------------------------------------*/
const char *io_strerror(int err) {
    switch (err) {
        case IO_DONE: return NULL;
        case IO_CLOSED: return "closed";
        case IO_TIMEOUT: return "timeout";
        default: return "unknown error";
    }
}

```

`src/Lua/socket/io.h`:

```h
#ifndef IO_H
#define IO_H
/*=========================================================================*\
* Input/Output abstraction
* LuaSocket toolkit
*
* This module defines the interface that LuaSocket expects from the
* transport layer for streamed input/output. The idea is that if any
* transport implements this interface, then the buffer.c functions
* automatically work on it.
*
* The module socket.h implements this interface, and thus the module tcp.h
* is very simple.
\*=========================================================================*/
#include "luasocket.h"
#include "timeout.h"

/* IO error codes */
enum {
    IO_DONE = 0,        /* operation completed successfully */
    IO_TIMEOUT = -1,    /* operation timed out */
    IO_CLOSED = -2,     /* the connection has been closed */
	IO_UNKNOWN = -3
};

/* interface to error message function */
typedef const char *(*p_error) (
    void *ctx,          /* context needed by send */
    int err             /* error code */
);

/* interface to send function */
typedef int (*p_send) (
    void *ctx,          /* context needed by send */
    const char *data,   /* pointer to buffer with data to send */
    size_t count,       /* number of bytes to send from buffer */
    size_t *sent,       /* number of bytes sent uppon return */
    p_timeout tm        /* timeout control */
);

/* interface to recv function */
typedef int (*p_recv) (
    void *ctx,          /* context needed by recv */
    char *data,         /* pointer to buffer where data will be writen */
    size_t count,       /* number of bytes to receive into buffer */
    size_t *got,        /* number of bytes received uppon return */
    p_timeout tm        /* timeout control */
);

/* IO driver definition */
typedef struct t_io_ {
    void *ctx;          /* context needed by send/recv */
    p_send send;        /* send function pointer */
    p_recv recv;        /* receive function pointer */
    p_error error;      /* strerror function */
} t_io;
typedef t_io *p_io;

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

void io_init(p_io io, p_send send, p_recv recv, p_error error, void *ctx);
const char *io_strerror(int err);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* IO_H */

```

`src/Lua/socket/luasocket.c`:

```c
/*=========================================================================*\
* LuaSocket toolkit
* Networking support for the Lua language
* Diego Nehab
* 26/11/1999
*
* This library is part of an  effort to progressively increase the network
* connectivity  of  the Lua  language.  The  Lua interface  to  networking
* functions follows the Sockets API  closely, trying to simplify all tasks
* involved in setting up both  client and server connections. The provided
* IO routines, however, follow the Lua  style, being very similar  to the
* standard Lua read and write functions.
\*=========================================================================*/

#include "luasocket.h"
#include "auxiliar.h"
#include "except.h"
#include "timeout.h"
#include "buffer.h"
#include "inet.h"
#include "tcp.h"
#include "udp.h"
#include "select.h"

/*-------------------------------------------------------------------------*\
* Internal function prototypes
\*-------------------------------------------------------------------------*/
static int global_skip(lua_State *L);
static int global_unload(lua_State *L);
static int base_open(lua_State *L);

/*-------------------------------------------------------------------------*\
* Modules and functions
\*-------------------------------------------------------------------------*/
static const luaL_Reg mod[] = {
    {"auxiliar", auxiliar_open},
    {"except", except_open},
    {"timeout", timeout_open},
    {"buffer", buffer_open},
    {"inet", inet_open},
    {"tcp", tcp_open},
    {"udp", udp_open},
    {"select", select_open},
    {NULL, NULL}
};

static luaL_Reg func[] = {
    {"skip",      global_skip},
    {"__unload",  global_unload},
    {NULL,        NULL}
};

/*-------------------------------------------------------------------------*\
* Skip a few arguments
\*-------------------------------------------------------------------------*/
static int global_skip(lua_State *L) {
    int amount = (int) luaL_checkinteger(L, 1);
    int ret = lua_gettop(L) - amount - 1;
    return ret >= 0 ? ret : 0;
}

/*-------------------------------------------------------------------------*\
* Unloads the library
\*-------------------------------------------------------------------------*/
static int global_unload(lua_State *L) {
    (void) L;
    socket_close();
    return 0;
}

/*-------------------------------------------------------------------------*\
* Setup basic stuff.
\*-------------------------------------------------------------------------*/
static int base_open(lua_State *L) {
    if (socket_open()) {
        /* export functions (and leave namespace table on top of stack) */
        lua_newtable(L);
        luaL_setfuncs(L, func, 0);
#ifdef LUASOCKET_DEBUG
        lua_pushstring(L, "_DEBUG");
        lua_pushboolean(L, 1);
        lua_rawset(L, -3);
#endif
        /* make version string available to scripts */
        lua_pushstring(L, "_VERSION");
        lua_pushstring(L, LUASOCKET_VERSION);
        lua_rawset(L, -3);
        return 1;
    } else {
        lua_pushstring(L, "unable to initialize library");
        lua_error(L);
        return 0;
    }
}

/*-------------------------------------------------------------------------*\
* Initializes all library modules.
\*-------------------------------------------------------------------------*/
LUASOCKET_API int luaopen_socket_core(lua_State *L) {
    int i;
    base_open(L);
    for (i = 0; mod[i].name; i++) mod[i].func(L);
    return 1;
}

```

`src/Lua/socket/luasocket.h`:

```h
#ifndef LUASOCKET_H
#define LUASOCKET_H
/*=========================================================================*\
* LuaSocket toolkit
* Networking support for the Lua language
* Diego Nehab
* 9/11/1999
\*=========================================================================*/

/*-------------------------------------------------------------------------* \
* Current socket library version
\*-------------------------------------------------------------------------*/
#define LUASOCKET_VERSION    "LuaSocket 3.0-rc1"
#define LUASOCKET_COPYRIGHT  "Copyright (C) 1999-2013 Diego Nehab"

/*-------------------------------------------------------------------------*\
* This macro prefixes all exported API functions
\*-------------------------------------------------------------------------*/
#ifndef LUASOCKET_API
#ifdef _WIN32
#define LUASOCKET_API __declspec(dllexport)
#else
#define LUASOCKET_API __attribute__ ((visibility ("default")))
#endif
#endif

#include "lua.h"
#include "lauxlib.h"
#include "compat.h"

/*-------------------------------------------------------------------------*\
* Initializes the library.
\*-------------------------------------------------------------------------*/
LUASOCKET_API int luaopen_socket_core(lua_State *L);

#endif /* LUASOCKET_H */

```

`src/Lua/socket/mime.c`:

```c
/*=========================================================================*\
* MIME support functions
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"
#include "mime.h"
#include <string.h>
#include <ctype.h>

/*=========================================================================*\
* Don't want to trust escape character constants
\*=========================================================================*/
typedef unsigned char UC;
static const char CRLF[] = "\r\n";
static const char EQCRLF[] = "=\r\n";

/*=========================================================================*\
* Internal function prototypes.
\*=========================================================================*/
static int mime_global_wrp(lua_State *L);
static int mime_global_b64(lua_State *L);
static int mime_global_unb64(lua_State *L);
static int mime_global_qp(lua_State *L);
static int mime_global_unqp(lua_State *L);
static int mime_global_qpwrp(lua_State *L);
static int mime_global_eol(lua_State *L);
static int mime_global_dot(lua_State *L);

static size_t dot(int c, size_t state, luaL_Buffer *buffer);
//static void b64setup(UC *base);
static size_t b64encode(UC c, UC *input, size_t size, luaL_Buffer *buffer);
static size_t b64pad(const UC *input, size_t size, luaL_Buffer *buffer);
static size_t b64decode(UC c, UC *input, size_t size, luaL_Buffer *buffer);

//static void qpsetup(UC *class, UC *unbase);
static void qpquote(UC c, luaL_Buffer *buffer);
static size_t qpdecode(UC c, UC *input, size_t size, luaL_Buffer *buffer);
static size_t qpencode(UC c, UC *input, size_t size,
        const char *marker, luaL_Buffer *buffer);
static size_t qppad(UC *input, size_t size, luaL_Buffer *buffer);

/* code support functions */
static luaL_Reg func[] = {
    { "dot", mime_global_dot },
    { "b64", mime_global_b64 },
    { "eol", mime_global_eol },
    { "qp", mime_global_qp },
    { "qpwrp", mime_global_qpwrp },
    { "unb64", mime_global_unb64 },
    { "unqp", mime_global_unqp },
    { "wrp", mime_global_wrp },
    { NULL, NULL }
};

/*-------------------------------------------------------------------------*\
* Quoted-printable globals
\*-------------------------------------------------------------------------*/
enum {QP_PLAIN, QP_QUOTED, QP_CR, QP_IF_LAST};

static const UC qpclass[] = {
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_IF_LAST, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_CR, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_IF_LAST, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_QUOTED, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN, QP_PLAIN,
    QP_PLAIN, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED,
    QP_QUOTED, QP_QUOTED, QP_QUOTED, QP_QUOTED
};

static const UC qpbase[] = "0123456789ABCDEF";

static const UC qpunbase[] = {
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 255,
    255, 255, 255, 255, 255, 255, 10, 11, 12, 13, 14, 15,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 10, 11, 12, 13, 14, 15, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255
};

/*-------------------------------------------------------------------------*\
* Base64 globals
\*-------------------------------------------------------------------------*/
static const UC b64base[] =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static const UC b64unbase[] = {
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63,
    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0,
    255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
    14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255,
    255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
    36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
    51, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255
};

/*=========================================================================*\
* Exported functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Initializes module
\*-------------------------------------------------------------------------*/
LUASOCKET_API int luaopen_mime_core(lua_State *L)
{
    lua_newtable(L);
    luaL_setfuncs(L, func, 0);
    /* make version string available to scripts */
    lua_pushstring(L, "_VERSION");
    lua_pushstring(L, MIME_VERSION);
    lua_rawset(L, -3);
    /* initialize lookup tables */
    // qpsetup(qpclass, qpunbase);
    // b64setup(b64unbase);
    return 1;
}

/*=========================================================================*\
* Global Lua functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Incrementaly breaks a string into lines. The string can have CRLF breaks.
* A, n = wrp(l, B, length)
* A is a copy of B, broken into lines of at most 'length' bytes.
* 'l' is how many bytes are left for the first line of B.
* 'n' is the number of bytes left in the last line of A.
\*-------------------------------------------------------------------------*/
static int mime_global_wrp(lua_State *L)
{
    size_t size = 0;
    int left = (int) luaL_checknumber(L, 1);
    const UC *input = (const UC *) luaL_optlstring(L, 2, NULL, &size);
    const UC *last = input + size;
    int length = (int) luaL_optnumber(L, 3, 76);
    luaL_Buffer buffer;
    /* end of input black-hole */
    if (!input) {
        /* if last line has not been terminated, add a line break */
        if (left < length) lua_pushstring(L, CRLF);
        /* otherwise, we are done */
        else lua_pushnil(L);
        lua_pushnumber(L, length);
        return 2;
    }
    luaL_buffinit(L, &buffer);
    while (input < last) {
        switch (*input) {
            case '\r':
                break;
            case '\n':
                luaL_addstring(&buffer, CRLF);
                left = length;
                break;
            default:
                if (left <= 0) {
                    left = length;
                    luaL_addstring(&buffer, CRLF);
                }
                luaL_addchar(&buffer, *input);
                left--;
                break;
        }
        input++;
    }
    luaL_pushresult(&buffer);
    lua_pushnumber(L, left);
    return 2;
}

#if 0
/*-------------------------------------------------------------------------*\
* Fill base64 decode map.
\*-------------------------------------------------------------------------*/
static void b64setup(UC *unbase)
{
    int i;
    for (i = 0; i <= 255; i++) unbase[i] = (UC) 255;
    for (i = 0; i < 64; i++) unbase[b64base[i]] = (UC) i;
    unbase['='] = 0;

    printf("static const UC b64unbase[] = {\n");
    for (int i = 0; i < 256; i++) {
        printf("%d, ", unbase[i]);
    }
    printf("\n}\n;");
}
#endif

/*-------------------------------------------------------------------------*\
* Acumulates bytes in input buffer until 3 bytes are available.
* Translate the 3 bytes into Base64 form and append to buffer.
* Returns new number of bytes in buffer.
\*-------------------------------------------------------------------------*/
static size_t b64encode(UC c, UC *input, size_t size,
        luaL_Buffer *buffer)
{
    input[size++] = c;
    if (size == 3) {
        UC code[4];
        unsigned long value = 0;
        value += input[0]; value <<= 8;
        value += input[1]; value <<= 8;
        value += input[2];
        code[3] = b64base[value & 0x3f]; value >>= 6;
        code[2] = b64base[value & 0x3f]; value >>= 6;
        code[1] = b64base[value & 0x3f]; value >>= 6;
        code[0] = b64base[value];
        luaL_addlstring(buffer, (char *) code, 4);
        size = 0;
    }
    return size;
}

/*-------------------------------------------------------------------------*\
* Encodes the Base64 last 1 or 2 bytes and adds padding '='
* Result, if any, is appended to buffer.
* Returns 0.
\*-------------------------------------------------------------------------*/
static size_t b64pad(const UC *input, size_t size,
        luaL_Buffer *buffer)
{
    unsigned long value = 0;
    UC code[4] = {'=', '=', '=', '='};
    switch (size) {
        case 1:
            value = input[0] << 4;
            code[1] = b64base[value & 0x3f]; value >>= 6;
            code[0] = b64base[value];
            luaL_addlstring(buffer, (char *) code, 4);
            break;
        case 2:
            value = input[0]; value <<= 8;
            value |= input[1]; value <<= 2;
            code[2] = b64base[value & 0x3f]; value >>= 6;
            code[1] = b64base[value & 0x3f]; value >>= 6;
            code[0] = b64base[value];
            luaL_addlstring(buffer, (char *) code, 4);
            break;
        default:
            break;
    }
    return 0;
}

/*-------------------------------------------------------------------------*\
* Acumulates bytes in input buffer until 4 bytes are available.
* Translate the 4 bytes from Base64 form and append to buffer.
* Returns new number of bytes in buffer.
\*-------------------------------------------------------------------------*/
static size_t b64decode(UC c, UC *input, size_t size,
        luaL_Buffer *buffer)
{
    /* ignore invalid characters */
    if (b64unbase[c] > 64) return size;
    input[size++] = c;
    /* decode atom */
    if (size == 4) {
        UC decoded[3];
        int valid, value = 0;
        value =  b64unbase[input[0]]; value <<= 6;
        value |= b64unbase[input[1]]; value <<= 6;
        value |= b64unbase[input[2]]; value <<= 6;
        value |= b64unbase[input[3]];
        decoded[2] = (UC) (value & 0xff); value >>= 8;
        decoded[1] = (UC) (value & 0xff); value >>= 8;
        decoded[0] = (UC) value;
        /* take care of paddding */
        valid = (input[2] == '=') ? 1 : (input[3] == '=') ? 2 : 3;
        luaL_addlstring(buffer, (char *) decoded, valid);
        return 0;
    /* need more data */
    } else return size;
}

/*-------------------------------------------------------------------------*\
* Incrementally applies the Base64 transfer content encoding to a string
* A, B = b64(C, D)
* A is the encoded version of the largest prefix of C .. D that is
* divisible by 3. B has the remaining bytes of C .. D, *without* encoding.
* The easiest thing would be to concatenate the two strings and
* encode the result, but we can't afford that or Lua would dupplicate
* every chunk we received.
\*-------------------------------------------------------------------------*/
static int mime_global_b64(lua_State *L)
{
    UC atom[3];
    size_t isize = 0, asize = 0;
    const UC *input = (const UC *) luaL_optlstring(L, 1, NULL, &isize);
    const UC *last = input + isize;
    luaL_Buffer buffer;
    /* end-of-input blackhole */
    if (!input) {
        lua_pushnil(L);
        lua_pushnil(L);
        return 2;
    }
    /* make sure we don't confuse buffer stuff with arguments */
    lua_settop(L, 2);
    /* process first part of the input */
    luaL_buffinit(L, &buffer);
    while (input < last)
        asize = b64encode(*input++, atom, asize, &buffer);
    input = (const UC *) luaL_optlstring(L, 2, NULL, &isize);
    /* if second part is nil, we are done */
    if (!input) {
        size_t osize = 0;
        asize = b64pad(atom, asize, &buffer);
        luaL_pushresult(&buffer);
        /* if the output is empty  and the input is nil, return nil */
        lua_tolstring(L, -1, &osize);
        if (osize == 0) lua_pushnil(L);
        lua_pushnil(L);
        return 2;
    }
    /* otherwise process the second part */
    last = input + isize;
    while (input < last)
        asize = b64encode(*input++, atom, asize, &buffer);
    luaL_pushresult(&buffer);
    lua_pushlstring(L, (char *) atom, asize);
    return 2;
}

/*-------------------------------------------------------------------------*\
* Incrementally removes the Base64 transfer content encoding from a string
* A, B = b64(C, D)
* A is the encoded version of the largest prefix of C .. D that is
* divisible by 4. B has the remaining bytes of C .. D, *without* encoding.
\*-------------------------------------------------------------------------*/
static int mime_global_unb64(lua_State *L)
{
    UC atom[4];
    size_t isize = 0, asize = 0;
    const UC *input = (const UC *) luaL_optlstring(L, 1, NULL, &isize);
    const UC *last = input + isize;
    luaL_Buffer buffer;
    /* end-of-input blackhole */
    if (!input) {
        lua_pushnil(L);
        lua_pushnil(L);
        return 2;
    }
    /* make sure we don't confuse buffer stuff with arguments */
    lua_settop(L, 2);
    /* process first part of the input */
    luaL_buffinit(L, &buffer);
    while (input < last)
        asize = b64decode(*input++, atom, asize, &buffer);
    input = (const UC *) luaL_optlstring(L, 2, NULL, &isize);
    /* if second is nil, we are done */
    if (!input) {
        size_t osize = 0;
        luaL_pushresult(&buffer);
        /* if the output is empty  and the input is nil, return nil */
        lua_tolstring(L, -1, &osize);
        if (osize == 0) lua_pushnil(L);
        lua_pushnil(L);
        return 2;
    }
    /* otherwise, process the rest of the input */
    last = input + isize;
    while (input < last)
        asize = b64decode(*input++, atom, asize, &buffer);
    luaL_pushresult(&buffer);
    lua_pushlstring(L, (char *) atom, asize);
    return 2;
}

/*-------------------------------------------------------------------------*\
* Quoted-printable encoding scheme
* all (except CRLF in text) can be =XX
* CLRL in not text must be =XX=XX
* 33 through 60 inclusive can be plain
* 62 through 126 inclusive can be plain
* 9 and 32 can be plain, unless in the end of a line, where must be =XX
* encoded lines must be no longer than 76 not counting CRLF
* soft line-break are =CRLF
* To encode one byte, we need to see the next two.
* Worst case is when we see a space, and wonder if a CRLF is comming
\*-------------------------------------------------------------------------*/
#if 0
/*-------------------------------------------------------------------------*\
* Split quoted-printable characters into classes
* Precompute reverse map for encoding
\*-------------------------------------------------------------------------*/
static void qpsetup(UC *cl, UC *unbase)
{

    int i;
    for (i = 0; i < 256; i++) cl[i] = QP_QUOTED;
    for (i = 33; i <= 60; i++) cl[i] = QP_PLAIN;
    for (i = 62; i <= 126; i++) cl[i] = QP_PLAIN;
    cl['\t'] = QP_IF_LAST;
    cl[' '] = QP_IF_LAST;
    cl['\r'] = QP_CR;
    for (i = 0; i < 256; i++) unbase[i] = 255;
    unbase['0'] = 0; unbase['1'] = 1; unbase['2'] = 2;
    unbase['3'] = 3; unbase['4'] = 4; unbase['5'] = 5;
    unbase['6'] = 6; unbase['7'] = 7; unbase['8'] = 8;
    unbase['9'] = 9; unbase['A'] = 10; unbase['a'] = 10;
    unbase['B'] = 11; unbase['b'] = 11; unbase['C'] = 12;
    unbase['c'] = 12; unbase['D'] = 13; unbase['d'] = 13;
    unbase['E'] = 14; unbase['e'] = 14; unbase['F'] = 15;
    unbase['f'] = 15;

printf("static UC qpclass[] = {");
    for (int i = 0; i < 256; i++) {
        if (i % 6 == 0) {
            printf("\n    ");
        }
        switch(cl[i]) {
            case QP_QUOTED:
                printf("QP_QUOTED, ");
                break;
            case QP_PLAIN:
                printf("QP_PLAIN, ");
                break;
            case QP_CR:
                printf("QP_CR, ");
                break;
            case QP_IF_LAST:
                printf("QP_IF_LAST, ");
                break;
        }
    }
printf("\n};\n");

printf("static const UC qpunbase[] = {");
    for (int i = 0; i < 256; i++) {
        int c = qpunbase[i];
        printf("%d, ", c);
    }
printf("\";\n");
}
#endif

/*-------------------------------------------------------------------------*\
* Output one character in form =XX
\*-------------------------------------------------------------------------*/
static void qpquote(UC c, luaL_Buffer *buffer)
{
    luaL_addchar(buffer, '=');
    luaL_addchar(buffer, qpbase[c >> 4]);
    luaL_addchar(buffer, qpbase[c & 0x0F]);
}

/*-------------------------------------------------------------------------*\
* Accumulate characters until we are sure about how to deal with them.
* Once we are sure, output to the buffer, in the correct form.
\*-------------------------------------------------------------------------*/
static size_t qpencode(UC c, UC *input, size_t size,
        const char *marker, luaL_Buffer *buffer)
{
    input[size++] = c;
    /* deal with all characters we can have */
    while (size > 0) {
        switch (qpclass[input[0]]) {
            /* might be the CR of a CRLF sequence */
            case QP_CR:
                if (size < 2) return size;
                if (input[1] == '\n') {
                    luaL_addstring(buffer, marker);
                    return 0;
                } else qpquote(input[0], buffer);
                break;
            /* might be a space and that has to be quoted if last in line */
            case QP_IF_LAST:
                if (size < 3) return size;
                /* if it is the last, quote it and we are done */
                if (input[1] == '\r' && input[2] == '\n') {
                    qpquote(input[0], buffer);
                    luaL_addstring(buffer, marker);
                    return 0;
                } else luaL_addchar(buffer, input[0]);
                break;
                /* might have to be quoted always */
            case QP_QUOTED:
                qpquote(input[0], buffer);
                break;
                /* might never have to be quoted */
            default:
                luaL_addchar(buffer, input[0]);
                break;
        }
        input[0] = input[1]; input[1] = input[2];
        size--;
    }
    return 0;
}

/*-------------------------------------------------------------------------*\
* Deal with the final characters
\*-------------------------------------------------------------------------*/
static size_t qppad(UC *input, size_t size, luaL_Buffer *buffer)
{
    size_t i;
    for (i = 0; i < size; i++) {
        if (qpclass[input[i]] == QP_PLAIN) luaL_addchar(buffer, input[i]);
        else qpquote(input[i], buffer);
    }
    if (size > 0) luaL_addstring(buffer, EQCRLF);
    return 0;
}

/*-------------------------------------------------------------------------*\
* Incrementally converts a string to quoted-printable
* A, B = qp(C, D, marker)
* Marker is the text to be used to replace CRLF sequences found in A.
* A is the encoded version of the largest prefix of C .. D that
* can be encoded without doubts.
* B has the remaining bytes of C .. D, *without* encoding.
\*-------------------------------------------------------------------------*/
static int mime_global_qp(lua_State *L)
{
    size_t asize = 0, isize = 0;
    UC atom[3];
    const UC *input = (const UC *) luaL_optlstring(L, 1, NULL, &isize);
    const UC *last = input + isize;
    const char *marker = luaL_optstring(L, 3, CRLF);
    luaL_Buffer buffer;
    /* end-of-input blackhole */
    if (!input) {
        lua_pushnil(L);
        lua_pushnil(L);
        return 2;
    }
    /* make sure we don't confuse buffer stuff with arguments */
    lua_settop(L, 3);
    /* process first part of input */
    luaL_buffinit(L, &buffer);
    while (input < last)
        asize = qpencode(*input++, atom, asize, marker, &buffer);
    input = (const UC *) luaL_optlstring(L, 2, NULL, &isize);
    /* if second part is nil, we are done */
    if (!input) {
        asize = qppad(atom, asize, &buffer);
        luaL_pushresult(&buffer);
        if (!(*lua_tostring(L, -1))) lua_pushnil(L);
        lua_pushnil(L);
        return 2;
    }
    /* otherwise process rest of input */
    last = input + isize;
    while (input < last)
        asize = qpencode(*input++, atom, asize, marker, &buffer);
    luaL_pushresult(&buffer);
    lua_pushlstring(L, (char *) atom, asize);
    return 2;
}

/*-------------------------------------------------------------------------*\
* Accumulate characters until we are sure about how to deal with them.
* Once we are sure, output the to the buffer, in the correct form.
\*-------------------------------------------------------------------------*/
static size_t qpdecode(UC c, UC *input, size_t size, luaL_Buffer *buffer) {
    int d;
    input[size++] = c;
    /* deal with all characters we can deal */
    switch (input[0]) {
        /* if we have an escape character */
        case '=':
            if (size < 3) return size;
            /* eliminate soft line break */
            if (input[1] == '\r' && input[2] == '\n') return 0;
            /* decode quoted representation */
            c = qpunbase[input[1]]; d = qpunbase[input[2]];
            /* if it is an invalid, do not decode */
            if (c > 15 || d > 15) luaL_addlstring(buffer, (char *)input, 3);
            else luaL_addchar(buffer, (char) ((c << 4) + d));
            return 0;
        case '\r':
            if (size < 2) return size;
            if (input[1] == '\n') luaL_addlstring(buffer, (char *)input, 2);
            return 0;
        default:
            if (input[0] == '\t' || (input[0] > 31 && input[0] < 127))
                luaL_addchar(buffer, input[0]);
            return 0;
    }
}

/*-------------------------------------------------------------------------*\
* Incrementally decodes a string in quoted-printable
* A, B = qp(C, D)
* A is the decoded version of the largest prefix of C .. D that
* can be decoded without doubts.
* B has the remaining bytes of C .. D, *without* decoding.
\*-------------------------------------------------------------------------*/
static int mime_global_unqp(lua_State *L)
{
    size_t asize = 0, isize = 0;
    UC atom[3];
    const UC *input = (const UC *) luaL_optlstring(L, 1, NULL, &isize);
    const UC *last = input + isize;
    luaL_Buffer buffer;
    /* end-of-input blackhole */
    if (!input) {
        lua_pushnil(L);
        lua_pushnil(L);
        return 2;
    }
    /* make sure we don't confuse buffer stuff with arguments */
    lua_settop(L, 2);
    /* process first part of input */
    luaL_buffinit(L, &buffer);
    while (input < last)
        asize = qpdecode(*input++, atom, asize, &buffer);
    input = (const UC *) luaL_optlstring(L, 2, NULL, &isize);
    /* if second part is nil, we are done */
    if (!input) {
        luaL_pushresult(&buffer);
        if (!(*lua_tostring(L, -1))) lua_pushnil(L);
        lua_pushnil(L);
        return 2;
    }
    /* otherwise process rest of input */
    last = input + isize;
    while (input < last)
        asize = qpdecode(*input++, atom, asize, &buffer);
    luaL_pushresult(&buffer);
    lua_pushlstring(L, (char *) atom, asize);
    return 2;
}

/*-------------------------------------------------------------------------*\
* Incrementally breaks a quoted-printed string into lines
* A, n = qpwrp(l, B, length)
* A is a copy of B, broken into lines of at most 'length' bytes.
* 'l' is how many bytes are left for the first line of B.
* 'n' is the number of bytes left in the last line of A.
* There are two complications: lines can't be broken in the middle
* of an encoded =XX, and there might be line breaks already
\*-------------------------------------------------------------------------*/
static int mime_global_qpwrp(lua_State *L)
{
    size_t size = 0;
    int left = (int) luaL_checknumber(L, 1);
    const UC *input = (const UC *) luaL_optlstring(L, 2, NULL, &size);
    const UC *last = input + size;
    int length = (int) luaL_optnumber(L, 3, 76);
    luaL_Buffer buffer;
    /* end-of-input blackhole */
    if (!input) {
        if (left < length) lua_pushstring(L, EQCRLF);
        else lua_pushnil(L);
        lua_pushnumber(L, length);
        return 2;
    }
    /* process all input */
    luaL_buffinit(L, &buffer);
    while (input < last) {
        switch (*input) {
            case '\r':
                break;
            case '\n':
                left = length;
                luaL_addstring(&buffer, CRLF);
                break;
            case '=':
                if (left <= 3) {
                    left = length;
                    luaL_addstring(&buffer, EQCRLF);
                }
                luaL_addchar(&buffer, *input);
                left--;
                break;
            default:
                if (left <= 1) {
                    left = length;
                    luaL_addstring(&buffer, EQCRLF);
                }
                luaL_addchar(&buffer, *input);
                left--;
                break;
        }
        input++;
    }
    luaL_pushresult(&buffer);
    lua_pushnumber(L, left);
    return 2;
}

/*-------------------------------------------------------------------------*\
* Here is what we do: \n, and \r are considered candidates for line
* break. We issue *one* new line marker if any of them is seen alone, or
* followed by a different one. That is, \n\n and \r\r will issue two
* end of line markers each, but \r\n, \n\r etc will only issue *one*
* marker.  This covers Mac OS, Mac OS X, VMS, Unix and DOS, as well as
* probably other more obscure conventions.
*
* c is the current character being processed
* last is the previous character
\*-------------------------------------------------------------------------*/
#define eolcandidate(c) (c == '\r' || c == '\n')
static int eolprocess(int c, int last, const char *marker,
        luaL_Buffer *buffer)
{
    if (eolcandidate(c)) {
        if (eolcandidate(last)) {
            if (c == last) luaL_addstring(buffer, marker);
            return 0;
        } else {
            luaL_addstring(buffer, marker);
            return c;
        }
    } else {
        luaL_addchar(buffer, (char) c);
        return 0;
    }
}

/*-------------------------------------------------------------------------*\
* Converts a string to uniform EOL convention.
* A, n = eol(o, B, marker)
* A is the converted version of the largest prefix of B that can be
* converted unambiguously. 'o' is the context returned by the previous
* call. 'n' is the new context.
\*-------------------------------------------------------------------------*/
static int mime_global_eol(lua_State *L)
{
    int ctx = (int) luaL_checkinteger(L, 1);
    size_t isize = 0;
    const char *input = luaL_optlstring(L, 2, NULL, &isize);
    const char *last = input + isize;
    const char *marker = luaL_optstring(L, 3, CRLF);
    luaL_Buffer buffer;
    luaL_buffinit(L, &buffer);
    /* end of input blackhole */
    if (!input) {
       lua_pushnil(L);
       lua_pushnumber(L, 0);
       return 2;
    }
    /* process all input */
    while (input < last)
        ctx = eolprocess(*input++, ctx, marker, &buffer);
    luaL_pushresult(&buffer);
    lua_pushnumber(L, ctx);
    return 2;
}

/*-------------------------------------------------------------------------*\
* Takes one byte and stuff it if needed.
\*-------------------------------------------------------------------------*/
static size_t dot(int c, size_t state, luaL_Buffer *buffer)
{
    luaL_addchar(buffer, (char) c);
    switch (c) {
        case '\r':
            return 1;
        case '\n':
            return (state == 1)? 2: 0;
        case '.':
            if (state == 2)
                luaL_addchar(buffer, '.');
            /* Falls through. */
        default:
            return 0;
    }
}

/*-------------------------------------------------------------------------*\
* Incrementally applies smtp stuffing to a string
* A, n = dot(l, D)
\*-------------------------------------------------------------------------*/
static int mime_global_dot(lua_State *L)
{
    size_t isize = 0, state = (size_t) luaL_checknumber(L, 1);
    const char *input = luaL_optlstring(L, 2, NULL, &isize);
    const char *last = input + isize;
    luaL_Buffer buffer;
    /* end-of-input blackhole */
    if (!input) {
        lua_pushnil(L);
        lua_pushnumber(L, 2);
        return 2;
    }
    /* process all input */
    luaL_buffinit(L, &buffer);
    while (input < last)
        state = dot(*input++, state, &buffer);
    luaL_pushresult(&buffer);
    lua_pushnumber(L, (lua_Number) state);
    return 2;
}


```

`src/Lua/socket/mime.h`:

```h
#ifndef MIME_H 
#define MIME_H 
/*=========================================================================*\
* Core MIME support
* LuaSocket toolkit
*
* This module provides functions to implement transfer content encodings
* and formatting conforming to RFC 2045. It is used by mime.lua, which
* provide a higher level interface to this functionality. 
\*=========================================================================*/
#include "luasocket.h"

/*-------------------------------------------------------------------------*\
* Current MIME library version
\*-------------------------------------------------------------------------*/
#define MIME_VERSION    "MIME 1.0.3"
#define MIME_COPYRIGHT  "Copyright (C) 2004-2013 Diego Nehab"
#define MIME_AUTHORS    "Diego Nehab"

LUASOCKET_API int luaopen_mime_core(lua_State *L);

#endif /* MIME_H */

```

`src/Lua/socket/options.c`:

```c
/*=========================================================================*\
* Common option interface
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"
#include "auxiliar.h"
#include "options.h"
#include "inet.h"
#include <string.h>

/*=========================================================================*\
* Internal functions prototypes
\*=========================================================================*/
static int opt_setmembership(lua_State *L, p_socket ps, int level, int name);
static int opt_ip6_setmembership(lua_State *L, p_socket ps, int level, int name);
static int opt_setboolean(lua_State *L, p_socket ps, int level, int name);
static int opt_getboolean(lua_State *L, p_socket ps, int level, int name);
static int opt_setint(lua_State *L, p_socket ps, int level, int name);
static int opt_getint(lua_State *L, p_socket ps, int level, int name);
static int opt_set(lua_State *L, p_socket ps, int level, int name,
        void *val, int len);
static int opt_get(lua_State *L, p_socket ps, int level, int name,
        void *val, int* len);

/*=========================================================================*\
* Exported functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Calls appropriate option handler
\*-------------------------------------------------------------------------*/
int opt_meth_setoption(lua_State *L, p_opt opt, p_socket ps)
{
    const char *name = luaL_checkstring(L, 2);      /* obj, name, ... */
    while (opt->name && strcmp(name, opt->name))
        opt++;
    if (!opt->func) {
        char msg[57];
        sprintf(msg, "unsupported option `%.35s'", name);
        luaL_argerror(L, 2, msg);
    }
    return opt->func(L, ps);
}

int opt_meth_getoption(lua_State *L, p_opt opt, p_socket ps)
{
    const char *name = luaL_checkstring(L, 2);      /* obj, name, ... */
    while (opt->name && strcmp(name, opt->name))
        opt++;
    if (!opt->func) {
        char msg[57];
        sprintf(msg, "unsupported option `%.35s'", name);
        luaL_argerror(L, 2, msg);
    }
    return opt->func(L, ps);
}

// -------------------------------------------------------
/* enables reuse of local address */
int opt_set_reuseaddr(lua_State *L, p_socket ps)
{
    return opt_setboolean(L, ps, SOL_SOCKET, SO_REUSEADDR);
}

int opt_get_reuseaddr(lua_State *L, p_socket ps)
{
    return opt_getboolean(L, ps, SOL_SOCKET, SO_REUSEADDR);
}

// -------------------------------------------------------
/* enables reuse of local port */
int opt_set_reuseport(lua_State *L, p_socket ps)
{
    return opt_setboolean(L, ps, SOL_SOCKET, SO_REUSEPORT);
}

int opt_get_reuseport(lua_State *L, p_socket ps)
{
    return opt_getboolean(L, ps, SOL_SOCKET, SO_REUSEPORT);
}

// -------------------------------------------------------
/* disables the Nagle algorithm */
int opt_set_tcp_nodelay(lua_State *L, p_socket ps)
{
    return opt_setboolean(L, ps, IPPROTO_TCP, TCP_NODELAY);
}

int opt_get_tcp_nodelay(lua_State *L, p_socket ps)
{
    return opt_getboolean(L, ps, IPPROTO_TCP, TCP_NODELAY);
}

// -------------------------------------------------------
#ifdef TCP_KEEPIDLE

int opt_get_tcp_keepidle(lua_State *L, p_socket ps)
{
    return opt_getint(L, ps, IPPROTO_TCP, TCP_KEEPIDLE);
}

int opt_set_tcp_keepidle(lua_State *L, p_socket ps)
{
    return opt_setint(L, ps, IPPROTO_TCP, TCP_KEEPIDLE);
}

#endif

// -------------------------------------------------------
#ifdef TCP_KEEPCNT

int opt_get_tcp_keepcnt(lua_State *L, p_socket ps)
{
    return opt_getint(L, ps, IPPROTO_TCP, TCP_KEEPCNT);
}

int opt_set_tcp_keepcnt(lua_State *L, p_socket ps)
{
    return opt_setint(L, ps, IPPROTO_TCP, TCP_KEEPCNT);
}

#endif

// -------------------------------------------------------
#ifdef TCP_KEEPINTVL

int opt_get_tcp_keepintvl(lua_State *L, p_socket ps)
{
    return opt_getint(L, ps, IPPROTO_TCP, TCP_KEEPINTVL);
}

int opt_set_tcp_keepintvl(lua_State *L, p_socket ps)
{
    return opt_setint(L, ps, IPPROTO_TCP, TCP_KEEPINTVL);
}

#endif

// -------------------------------------------------------
int opt_set_keepalive(lua_State *L, p_socket ps)
{
    return opt_setboolean(L, ps, SOL_SOCKET, SO_KEEPALIVE);
}

int opt_get_keepalive(lua_State *L, p_socket ps)
{
    return opt_getboolean(L, ps, SOL_SOCKET, SO_KEEPALIVE);
}

// -------------------------------------------------------
int opt_set_dontroute(lua_State *L, p_socket ps)
{
    return opt_setboolean(L, ps, SOL_SOCKET, SO_DONTROUTE);
}

int opt_get_dontroute(lua_State *L, p_socket ps)
{
    return opt_getboolean(L, ps, SOL_SOCKET, SO_DONTROUTE);
}

// -------------------------------------------------------
int opt_set_broadcast(lua_State *L, p_socket ps)
{
    return opt_setboolean(L, ps, SOL_SOCKET, SO_BROADCAST);
}

int opt_get_broadcast(lua_State *L, p_socket ps)
{
    return opt_getboolean(L, ps, SOL_SOCKET, SO_BROADCAST);
}

// -------------------------------------------------------
int opt_set_recv_buf_size(lua_State *L, p_socket ps)
{
	return opt_setint(L, ps, SOL_SOCKET, SO_RCVBUF);
}

int opt_get_recv_buf_size(lua_State *L, p_socket ps)
{
	return opt_getint(L, ps, SOL_SOCKET, SO_RCVBUF);
}

// -------------------------------------------------------
int opt_get_send_buf_size(lua_State *L, p_socket ps)
{
	return opt_getint(L, ps, SOL_SOCKET, SO_SNDBUF);
}

int opt_set_send_buf_size(lua_State *L, p_socket ps)
{
	return opt_setint(L, ps, SOL_SOCKET, SO_SNDBUF);
}

// -------------------------------------------------------
int opt_set_ip6_unicast_hops(lua_State *L, p_socket ps)
{
  return opt_setint(L, ps, IPPROTO_IPV6, IPV6_UNICAST_HOPS);
}

int opt_get_ip6_unicast_hops(lua_State *L, p_socket ps)
{
  return opt_getint(L, ps, IPPROTO_IPV6, IPV6_UNICAST_HOPS);
}

// -------------------------------------------------------
int opt_set_ip6_multicast_hops(lua_State *L, p_socket ps)
{
  return opt_setint(L, ps, IPPROTO_IPV6, IPV6_MULTICAST_HOPS);
}

int opt_get_ip6_multicast_hops(lua_State *L, p_socket ps)
{
  return opt_getint(L, ps, IPPROTO_IPV6, IPV6_MULTICAST_HOPS);
}

// -------------------------------------------------------
int opt_set_ip_multicast_loop(lua_State *L, p_socket ps)
{
    return opt_setboolean(L, ps, IPPROTO_IP, IP_MULTICAST_LOOP);
}

int opt_get_ip_multicast_loop(lua_State *L, p_socket ps)
{
    return opt_getboolean(L, ps, IPPROTO_IP, IP_MULTICAST_LOOP);
}

// -------------------------------------------------------
int opt_set_ip6_multicast_loop(lua_State *L, p_socket ps)
{
    return opt_setboolean(L, ps, IPPROTO_IPV6, IPV6_MULTICAST_LOOP);
}

int opt_get_ip6_multicast_loop(lua_State *L, p_socket ps)
{
    return opt_getboolean(L, ps, IPPROTO_IPV6, IPV6_MULTICAST_LOOP);
}

// -------------------------------------------------------
int opt_set_linger(lua_State *L, p_socket ps)
{
    struct linger li;                      /* obj, name, table */
    if (!lua_istable(L, 3)) auxiliar_typeerror(L,3,lua_typename(L, LUA_TTABLE));
    lua_pushstring(L, "on");
    lua_gettable(L, 3);
    if (!lua_isboolean(L, -1))
        luaL_argerror(L, 3, "boolean 'on' field expected");
    li.l_onoff = (u_short) lua_toboolean(L, -1);
    lua_pushstring(L, "timeout");
    lua_gettable(L, 3);
    if (!lua_isnumber(L, -1))
        luaL_argerror(L, 3, "number 'timeout' field expected");
    li.l_linger = (u_short) lua_tonumber(L, -1);
    return opt_set(L, ps, SOL_SOCKET, SO_LINGER, (char *) &li, sizeof(li));
}

int opt_get_linger(lua_State *L, p_socket ps)
{
    struct linger li;                      /* obj, name */
    int len = sizeof(li);
    int err = opt_get(L, ps, SOL_SOCKET, SO_LINGER, (char *) &li, &len);
    if (err)
        return err;
    lua_newtable(L);
    lua_pushboolean(L, li.l_onoff);
    lua_setfield(L, -2, "on");
    lua_pushinteger(L, li.l_linger);
    lua_setfield(L, -2, "timeout");
    return 1;
}

// -------------------------------------------------------
int opt_set_ip_multicast_ttl(lua_State *L, p_socket ps)
{
    return opt_setint(L, ps, IPPROTO_IP, IP_MULTICAST_TTL);
}

// -------------------------------------------------------
int opt_set_ip_multicast_if(lua_State *L, p_socket ps)
{
    const char *address = luaL_checkstring(L, 3);    /* obj, name, ip */
    struct in_addr val;
    val.s_addr = htonl(INADDR_ANY);
    if (strcmp(address, "*") && !inet_aton(address, &val))
        luaL_argerror(L, 3, "ip expected");
    return opt_set(L, ps, IPPROTO_IP, IP_MULTICAST_IF,
        (char *) &val, sizeof(val));
}

int opt_get_ip_multicast_if(lua_State *L, p_socket ps)
{
    struct in_addr val;
    socklen_t len = sizeof(val);
    if (getsockopt(*ps, IPPROTO_IP, IP_MULTICAST_IF, (char *) &val, &len) < 0) {
        lua_pushnil(L);
        lua_pushstring(L, "getsockopt failed");
        return 2;
    }
    lua_pushstring(L, inet_ntoa(val));
    return 1;
}

// -------------------------------------------------------
int opt_set_ip_add_membership(lua_State *L, p_socket ps)
{
    return opt_setmembership(L, ps, IPPROTO_IP, IP_ADD_MEMBERSHIP);
}

int opt_set_ip_drop_membersip(lua_State *L, p_socket ps)
{
    return opt_setmembership(L, ps, IPPROTO_IP, IP_DROP_MEMBERSHIP);
}

// -------------------------------------------------------
int opt_set_ip6_add_membership(lua_State *L, p_socket ps)
{
    return opt_ip6_setmembership(L, ps, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP);
}

int opt_set_ip6_drop_membersip(lua_State *L, p_socket ps)
{
    return opt_ip6_setmembership(L, ps, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP);
}
// -------------------------------------------------------
int opt_get_ip6_v6only(lua_State *L, p_socket ps)
{
    return opt_getboolean(L, ps, IPPROTO_IPV6, IPV6_V6ONLY);
}

int opt_set_ip6_v6only(lua_State *L, p_socket ps)
{
    return opt_setboolean(L, ps, IPPROTO_IPV6, IPV6_V6ONLY);
}

// -------------------------------------------------------
int opt_get_error(lua_State *L, p_socket ps)
{
    int val = 0;
    socklen_t len = sizeof(val);
    if (getsockopt(*ps, SOL_SOCKET, SO_ERROR, (char *) &val, &len) < 0) {
        lua_pushnil(L);
        lua_pushstring(L, "getsockopt failed");
        return 2;
    }
    lua_pushstring(L, socket_strerror(val));
    return 1;
}

/*=========================================================================*\
* Auxiliar functions
\*=========================================================================*/
static int opt_setmembership(lua_State *L, p_socket ps, int level, int name)
{
    struct ip_mreq val;                   /* obj, name, table */
    if (!lua_istable(L, 3)) auxiliar_typeerror(L,3,lua_typename(L, LUA_TTABLE));
    lua_pushstring(L, "multiaddr");
    lua_gettable(L, 3);
    if (!lua_isstring(L, -1))
        luaL_argerror(L, 3, "string 'multiaddr' field expected");
    if (!inet_aton(lua_tostring(L, -1), &val.imr_multiaddr))
        luaL_argerror(L, 3, "invalid 'multiaddr' ip address");
    lua_pushstring(L, "interface");
    lua_gettable(L, 3);
    if (!lua_isstring(L, -1))
        luaL_argerror(L, 3, "string 'interface' field expected");
    val.imr_interface.s_addr = htonl(INADDR_ANY);
    if (strcmp(lua_tostring(L, -1), "*") &&
            !inet_aton(lua_tostring(L, -1), &val.imr_interface))
        luaL_argerror(L, 3, "invalid 'interface' ip address");
    return opt_set(L, ps, level, name, (char *) &val, sizeof(val));
}

static int opt_ip6_setmembership(lua_State *L, p_socket ps, int level, int name)
{
    struct ipv6_mreq val;                   /* obj, opt-name, table */
    memset(&val, 0, sizeof(val));
    if (!lua_istable(L, 3)) auxiliar_typeerror(L,3,lua_typename(L, LUA_TTABLE));
    lua_pushstring(L, "multiaddr");
    lua_gettable(L, 3);
    if (!lua_isstring(L, -1))
        luaL_argerror(L, 3, "string 'multiaddr' field expected");
    if (!inet_pton(AF_INET6, lua_tostring(L, -1), &val.ipv6mr_multiaddr))
        luaL_argerror(L, 3, "invalid 'multiaddr' ip address");
    lua_pushstring(L, "interface");
    lua_gettable(L, 3);
    /* By default we listen to interface on default route
     * (sigh). However, interface= can override it. We should
     * support either number, or name for it. Waiting for
     * windows port of if_nametoindex */
    if (!lua_isnil(L, -1)) {
        if (lua_isnumber(L, -1)) {
            val.ipv6mr_interface = (unsigned int) lua_tonumber(L, -1);
        } else
          luaL_argerror(L, -1, "number 'interface' field expected");
    }
    return opt_set(L, ps, level, name, (char *) &val, sizeof(val));
}

static
int opt_get(lua_State *L, p_socket ps, int level, int name, void *val, int* len)
{
    socklen_t socklen = *len;
    if (getsockopt(*ps, level, name, (char *) val, &socklen) < 0) {
        lua_pushnil(L);
        lua_pushstring(L, "getsockopt failed");
        return 2;
    }
    *len = socklen;
    return 0;
}

static
int opt_set(lua_State *L, p_socket ps, int level, int name, void *val, int len)
{
    if (setsockopt(*ps, level, name, (char *) val, len) < 0) {
        lua_pushnil(L);
        lua_pushstring(L, "setsockopt failed");
        return 2;
    }
    lua_pushnumber(L, 1);
    return 1;
}

static int opt_getboolean(lua_State *L, p_socket ps, int level, int name)
{
    int val = 0;
    int len = sizeof(val);
    int err = opt_get(L, ps, level, name, (char *) &val, &len);
    if (err)
        return err;
    lua_pushboolean(L, val);
    return 1;
}

static int opt_setboolean(lua_State *L, p_socket ps, int level, int name)
{
    int val = auxiliar_checkboolean(L, 3);             /* obj, name, bool */
    return opt_set(L, ps, level, name, (char *) &val, sizeof(val));
}

static int opt_getint(lua_State *L, p_socket ps, int level, int name)
{
    int val = 0;
    int len = sizeof(val);
    int err = opt_get(L, ps, level, name, (char *) &val, &len);
    if (err)
        return err;
    lua_pushnumber(L, val);
    return 1;
}

static int opt_setint(lua_State *L, p_socket ps, int level, int name)
{
    int val = (int) lua_tonumber(L, 3);             /* obj, name, int */
    return opt_set(L, ps, level, name, (char *) &val, sizeof(val));
}

```

`src/Lua/socket/options.h`:

```h
#ifndef OPTIONS_H
#define OPTIONS_H
/*=========================================================================*\
* Common option interface 
* LuaSocket toolkit
*
* This module provides a common interface to socket options, used mainly by
* modules UDP and TCP. 
\*=========================================================================*/

#include "luasocket.h"
#include "socket.h"

/* option registry */
typedef struct t_opt {
  const char *name;
  int (*func)(lua_State *L, p_socket ps);
} t_opt;
typedef t_opt *p_opt;

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int opt_meth_setoption(lua_State *L, p_opt opt, p_socket ps);
int opt_meth_getoption(lua_State *L, p_opt opt, p_socket ps);

int opt_set_reuseaddr(lua_State *L, p_socket ps);
int opt_get_reuseaddr(lua_State *L, p_socket ps);

int opt_set_reuseport(lua_State *L, p_socket ps);
int opt_get_reuseport(lua_State *L, p_socket ps);

int opt_set_tcp_nodelay(lua_State *L, p_socket ps);
int opt_get_tcp_nodelay(lua_State *L, p_socket ps);

#ifdef TCP_KEEPIDLE
int opt_set_tcp_keepidle(lua_State *L, p_socket ps);
int opt_get_tcp_keepidle(lua_State *L, p_socket ps);
#endif

#ifdef TCP_KEEPCNT
int opt_set_tcp_keepcnt(lua_State *L, p_socket ps);
int opt_get_tcp_keepcnt(lua_State *L, p_socket ps);
#endif

#ifdef TCP_KEEPINTVL
int opt_set_tcp_keepintvl(lua_State *L, p_socket ps);
int opt_get_tcp_keepintvl(lua_State *L, p_socket ps);
#endif

int opt_set_keepalive(lua_State *L, p_socket ps);
int opt_get_keepalive(lua_State *L, p_socket ps);

int opt_set_dontroute(lua_State *L, p_socket ps);
int opt_get_dontroute(lua_State *L, p_socket ps);

int opt_set_broadcast(lua_State *L, p_socket ps);
int opt_get_broadcast(lua_State *L, p_socket ps);

int opt_set_recv_buf_size(lua_State *L, p_socket ps);
int opt_get_recv_buf_size(lua_State *L, p_socket ps);

int opt_set_send_buf_size(lua_State *L, p_socket ps);
int opt_get_send_buf_size(lua_State *L, p_socket ps);

int opt_set_ip6_unicast_hops(lua_State *L, p_socket ps);
int opt_get_ip6_unicast_hops(lua_State *L, p_socket ps);

int opt_set_ip6_multicast_hops(lua_State *L, p_socket ps);
int opt_get_ip6_multicast_hops(lua_State *L, p_socket ps);

int opt_set_ip_multicast_loop(lua_State *L, p_socket ps);
int opt_get_ip_multicast_loop(lua_State *L, p_socket ps);

int opt_set_ip6_multicast_loop(lua_State *L, p_socket ps);
int opt_get_ip6_multicast_loop(lua_State *L, p_socket ps);

int opt_set_linger(lua_State *L, p_socket ps);
int opt_get_linger(lua_State *L, p_socket ps);

int opt_set_ip_multicast_ttl(lua_State *L, p_socket ps);

int opt_set_ip_multicast_if(lua_State *L, p_socket ps);
int opt_get_ip_multicast_if(lua_State *L, p_socket ps);

int opt_set_ip_add_membership(lua_State *L, p_socket ps);
int opt_set_ip_drop_membersip(lua_State *L, p_socket ps);

int opt_set_ip6_add_membership(lua_State *L, p_socket ps);
int opt_set_ip6_drop_membersip(lua_State *L, p_socket ps);

int opt_set_ip6_v6only(lua_State *L, p_socket ps);
int opt_get_ip6_v6only(lua_State *L, p_socket ps);

int opt_get_error(lua_State *L, p_socket ps);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif

```

`src/Lua/socket/pierror.h`:

```h
#ifndef PIERROR_H
#define PIERROR_H
/*=========================================================================*\
* Error messages
* Defines platform independent error messages
\*=========================================================================*/

#define PIE_HOST_NOT_FOUND "host not found"
#define PIE_ADDRINUSE      "address already in use"
#define PIE_ISCONN         "already connected"
#define PIE_ACCESS         "permission denied"
#define PIE_CONNREFUSED    "connection refused"
#define PIE_CONNABORTED    "closed"
#define PIE_CONNRESET      "closed"
#define PIE_TIMEDOUT       "timeout"
#define PIE_AGAIN          "temporary failure in name resolution"
#define PIE_BADFLAGS       "invalid value for ai_flags"
#define PIE_BADHINTS       "invalid value for hints"
#define PIE_FAIL           "non-recoverable failure in name resolution"
#define PIE_FAMILY         "ai_family not supported"
#define PIE_MEMORY         "memory allocation failure"
#define PIE_NONAME         "host or service not provided, or not known"
#define PIE_OVERFLOW       "argument buffer overflow"
#define PIE_PROTOCOL       "resolved protocol is unknown"
#define PIE_SERVICE        "service not supported for socket type"
#define PIE_SOCKTYPE       "ai_socktype not supported"

#endif

```

`src/Lua/socket/select.c`:

```c
/*=========================================================================*\
* Select implementation
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"

#include "socket.h"
#include "timeout.h"
#include "select.h"

#include <string.h>

/*=========================================================================*\
* Internal function prototypes.
\*=========================================================================*/
static t_socket getfd(lua_State *L);
static int dirty(lua_State *L);
static void collect_fd(lua_State *L, int tab, int itab,
        fd_set *set, t_socket *max_fd);
static int check_dirty(lua_State *L, int tab, int dtab, fd_set *set);
static void return_fd(lua_State *L, fd_set *set, t_socket max_fd,
        int itab, int tab, int start);
static void make_assoc(lua_State *L, int tab);
static int global_select(lua_State *L);

/* functions in library namespace */
static luaL_Reg func[] = {
    {"select", global_select},
    {NULL,     NULL}
};

/*-------------------------------------------------------------------------*\
* Initializes module
\*-------------------------------------------------------------------------*/
int select_open(lua_State *L) {
    lua_pushstring(L, "_SETSIZE");
    lua_pushinteger(L, FD_SETSIZE);
    lua_rawset(L, -3);
    lua_pushstring(L, "_SOCKETINVALID");
    lua_pushinteger(L, SOCKET_INVALID);
    lua_rawset(L, -3);
    luaL_setfuncs(L, func, 0);
    return 0;
}

/*=========================================================================*\
* Global Lua functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Waits for a set of sockets until a condition is met or timeout.
\*-------------------------------------------------------------------------*/
static int global_select(lua_State *L) {
    int rtab, wtab, itab, ret, ndirty;
    t_socket max_fd = SOCKET_INVALID;
    fd_set rset, wset;
    t_timeout tm;
    double t = luaL_optnumber(L, 3, -1);
    FD_ZERO(&rset); FD_ZERO(&wset);
    lua_settop(L, 3);
    lua_newtable(L); itab = lua_gettop(L);
    lua_newtable(L); rtab = lua_gettop(L);
    lua_newtable(L); wtab = lua_gettop(L);
    collect_fd(L, 1, itab, &rset, &max_fd);
    collect_fd(L, 2, itab, &wset, &max_fd);
    ndirty = check_dirty(L, 1, rtab, &rset);
    t = ndirty > 0? 0.0: t;
    timeout_init(&tm, t, -1);
    timeout_markstart(&tm);
    ret = socket_select(max_fd+1, &rset, &wset, NULL, &tm);
    if (ret > 0 || ndirty > 0) {
        return_fd(L, &rset, max_fd+1, itab, rtab, ndirty);
        return_fd(L, &wset, max_fd+1, itab, wtab, 0);
        make_assoc(L, rtab);
        make_assoc(L, wtab);
        return 2;
    } else if (ret == 0) {
        lua_pushstring(L, "timeout");
        return 3;
    } else {
        luaL_error(L, "select failed");
        return 3;
    }
}

/*=========================================================================*\
* Internal functions
\*=========================================================================*/
static t_socket getfd(lua_State *L) {
    t_socket fd = SOCKET_INVALID;
    lua_pushstring(L, "getfd");
    lua_gettable(L, -2);
    if (!lua_isnil(L, -1)) {
        lua_pushvalue(L, -2);
        lua_call(L, 1, 1);
        if (lua_isnumber(L, -1)) {
            double numfd = lua_tonumber(L, -1);
            fd = (numfd >= 0.0)? (t_socket) numfd: SOCKET_INVALID;
        }
    }
    lua_pop(L, 1);
    return fd;
}

static int dirty(lua_State *L) {
    int is = 0;
    lua_pushstring(L, "dirty");
    lua_gettable(L, -2);
    if (!lua_isnil(L, -1)) {
        lua_pushvalue(L, -2);
        lua_call(L, 1, 1);
        is = lua_toboolean(L, -1);
    }
    lua_pop(L, 1);
    return is;
}

static void collect_fd(lua_State *L, int tab, int itab,
        fd_set *set, t_socket *max_fd) {
    int i = 1, n = 0;
    /* nil is the same as an empty table */
    if (lua_isnil(L, tab)) return;
    /* otherwise we need it to be a table */
    luaL_checktype(L, tab, LUA_TTABLE);
    for ( ;; ) {
        t_socket fd;
        lua_pushnumber(L, i);
        lua_gettable(L, tab);
        if (lua_isnil(L, -1)) {
            lua_pop(L, 1);
            break;
        }
        /* getfd figures out if this is a socket */
        fd = getfd(L);
        if (fd != SOCKET_INVALID) {
            /* make sure we don't overflow the fd_set */
#ifdef _WIN32
            if (n >= FD_SETSIZE)
                luaL_argerror(L, tab, "too many sockets");
#else
            if (fd >= FD_SETSIZE)
                luaL_argerror(L, tab, "descriptor too large for set size");
#endif
            FD_SET(fd, set);
            n++;
            /* keep track of the largest descriptor so far */
            if (*max_fd == SOCKET_INVALID || *max_fd < fd)
                *max_fd = fd;
            /* make sure we can map back from descriptor to the object */
            lua_pushnumber(L, (lua_Number) fd);
            lua_pushvalue(L, -2);
            lua_settable(L, itab);
        }
        lua_pop(L, 1);
        i = i + 1;
    }
}

static int check_dirty(lua_State *L, int tab, int dtab, fd_set *set) {
    int ndirty = 0, i = 1;
    if (lua_isnil(L, tab))
        return 0;
    for ( ;; ) {
        t_socket fd;
        lua_pushnumber(L, i);
        lua_gettable(L, tab);
        if (lua_isnil(L, -1)) {
            lua_pop(L, 1);
            break;
        }
        fd = getfd(L);
        if (fd != SOCKET_INVALID && dirty(L)) {
            lua_pushnumber(L, ++ndirty);
            lua_pushvalue(L, -2);
            lua_settable(L, dtab);
            FD_CLR(fd, set);
        }
        lua_pop(L, 1);
        i = i + 1;
    }
    return ndirty;
}

static void return_fd(lua_State *L, fd_set *set, t_socket max_fd,
        int itab, int tab, int start) {
    t_socket fd;
    for (fd = 0; fd < max_fd; fd++) {
        if (FD_ISSET(fd, set)) {
            lua_pushnumber(L, ++start);
            lua_pushnumber(L, (lua_Number) fd);
            lua_gettable(L, itab);
            lua_settable(L, tab);
        }
    }
}

static void make_assoc(lua_State *L, int tab) {
    int i = 1, atab;
    lua_newtable(L); atab = lua_gettop(L);
    for ( ;; ) {
        lua_pushnumber(L, i);
        lua_gettable(L, tab);
        if (!lua_isnil(L, -1)) {
            lua_pushnumber(L, i);
            lua_pushvalue(L, -2);
            lua_settable(L, atab);
            lua_pushnumber(L, i);
            lua_settable(L, atab);
        } else {
            lua_pop(L, 1);
            break;
        }
        i = i+1;
    }
}

```

`src/Lua/socket/select.h`:

```h
#ifndef SELECT_H
#define SELECT_H
/*=========================================================================*\
* Select implementation
* LuaSocket toolkit
*
* Each object that can be passed to the select function has to export 
* method getfd() which returns the descriptor to be passed to the
* underlying select function. Another method, dirty(), should return 
* true if there is data ready for reading (required for buffered input).
\*=========================================================================*/

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int select_open(lua_State *L);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* SELECT_H */

```

`src/Lua/socket/socket.h`:

```h
#ifndef SOCKET_H
#define SOCKET_H
/*=========================================================================*\
* Socket compatibilization module
* LuaSocket toolkit
*
* BSD Sockets and WinSock are similar, but there are a few irritating
* differences. Also, not all *nix platforms behave the same. This module
* (and the associated usocket.h and wsocket.h) factor these differences and
* creates a interface compatible with the io.h module.
\*=========================================================================*/
#include "io.h"

/*=========================================================================*\
* Platform specific compatibilization
\*=========================================================================*/
#ifdef _WIN32
#include "wsocket.h"
#else
#include "usocket.h"
#endif

/*=========================================================================*\
* The connect and accept functions accept a timeout and their
* implementations are somewhat complicated. We chose to move
* the timeout control into this module for these functions in
* order to simplify the modules that use them. 
\*=========================================================================*/
#include "timeout.h"

/* convenient shorthand */
typedef struct sockaddr SA;

/*=========================================================================*\
* Functions bellow implement a comfortable platform independent 
* interface to sockets
\*=========================================================================*/

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int socket_waitfd(p_socket ps, int sw, p_timeout tm);
int socket_open(void);
int socket_close(void);
void socket_destroy(p_socket ps);
int socket_select(t_socket n, fd_set *rfds, fd_set *wfds, fd_set *efds, p_timeout tm);
int socket_create(p_socket ps, int domain, int type, int protocol);
int socket_bind(p_socket ps, SA *addr, socklen_t addr_len); 
int socket_listen(p_socket ps, int backlog);
void socket_shutdown(p_socket ps, int how); 
int socket_connect(p_socket ps, SA *addr, socklen_t addr_len, p_timeout tm); 
int socket_accept(p_socket ps, p_socket pa, SA *addr, socklen_t *addr_len, p_timeout tm);
int socket_send(p_socket ps, const char *data, size_t count, size_t *sent, p_timeout tm);
int socket_sendto(p_socket ps, const char *data, size_t count, size_t *sent, SA *addr, socklen_t addr_len, p_timeout tm);
int socket_recv(p_socket ps, char *data, size_t count, size_t *got, p_timeout tm);
int socket_recvfrom(p_socket ps, char *data, size_t count, size_t *got, SA *addr, socklen_t *addr_len, p_timeout tm);
int socket_write(p_socket ps, const char *data, size_t count, size_t *sent, p_timeout tm);
int socket_read(p_socket ps, char *data, size_t count, size_t *got, p_timeout tm);
void socket_setblocking(p_socket ps);
void socket_setnonblocking(p_socket ps);
int socket_gethostbyaddr(const char *addr, socklen_t len, struct hostent **hp);
int socket_gethostbyname(const char *addr, struct hostent **hp);
const char *socket_hoststrerror(int err);
const char *socket_strerror(int err);
const char *socket_ioerror(p_socket ps, int err);
const char *socket_gaistrerror(int err);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* SOCKET_H */

```

`src/Lua/socket/tcp.c`:

```c
/*=========================================================================*\
* TCP object
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"

#include "auxiliar.h"
#include "socket.h"
#include "inet.h"
#include "options.h"
#include "tcp.h"

#include <string.h>

/*=========================================================================*\
* Internal function prototypes
\*=========================================================================*/
static int global_create(lua_State *L);
static int global_create4(lua_State *L);
static int global_create6(lua_State *L);
static int global_connect(lua_State *L);
static int meth_connect(lua_State *L);
static int meth_listen(lua_State *L);
static int meth_getfamily(lua_State *L);
static int meth_bind(lua_State *L);
static int meth_send(lua_State *L);
static int meth_getstats(lua_State *L);
static int meth_setstats(lua_State *L);
static int meth_getsockname(lua_State *L);
static int meth_getpeername(lua_State *L);
static int meth_shutdown(lua_State *L);
static int meth_receive(lua_State *L);
static int meth_accept(lua_State *L);
static int meth_close(lua_State *L);
static int meth_getoption(lua_State *L);
static int meth_setoption(lua_State *L);
static int meth_gettimeout(lua_State *L);
static int meth_settimeout(lua_State *L);
static int meth_getfd(lua_State *L);
static int meth_setfd(lua_State *L);
static int meth_dirty(lua_State *L);

/* tcp object methods */
static luaL_Reg tcp_methods[] = {
    {"__gc",        meth_close},
    {"__tostring",  auxiliar_tostring},
    {"accept",      meth_accept},
    {"bind",        meth_bind},
    {"close",       meth_close},
    {"connect",     meth_connect},
    {"dirty",       meth_dirty},
    {"getfamily",   meth_getfamily},
    {"getfd",       meth_getfd},
    {"getoption",   meth_getoption},
    {"getpeername", meth_getpeername},
    {"getsockname", meth_getsockname},
    {"getstats",    meth_getstats},
    {"setstats",    meth_setstats},
    {"listen",      meth_listen},
    {"receive",     meth_receive},
    {"send",        meth_send},
    {"setfd",       meth_setfd},
    {"setoption",   meth_setoption},
    {"setpeername", meth_connect},
    {"setsockname", meth_bind},
    {"settimeout",  meth_settimeout},
    {"gettimeout",  meth_gettimeout},
    {"shutdown",    meth_shutdown},
    {NULL,          NULL}
};

/* socket option handlers */
static t_opt optget[] = {
    {"keepalive",   opt_get_keepalive},
    {"reuseaddr",   opt_get_reuseaddr},
    {"reuseport",   opt_get_reuseport},
    {"tcp-nodelay", opt_get_tcp_nodelay},
#ifdef TCP_KEEPIDLE
    {"tcp-keepidle", opt_get_tcp_keepidle},
#endif
#ifdef TCP_KEEPCNT
    {"tcp-keepcnt", opt_get_tcp_keepcnt},
#endif
#ifdef TCP_KEEPINTVL
    {"tcp-keepintvl", opt_get_tcp_keepintvl},
#endif
    {"linger",      opt_get_linger},
    {"error",       opt_get_error},
	{"recv-buffer-size",     opt_get_recv_buf_size},
	{"send-buffer-size",     opt_get_send_buf_size},
    {NULL,          NULL}
};

static t_opt optset[] = {
    {"keepalive",   opt_set_keepalive},
    {"reuseaddr",   opt_set_reuseaddr},
    {"reuseport",   opt_set_reuseport},
    {"tcp-nodelay", opt_set_tcp_nodelay},
#ifdef TCP_KEEPIDLE
    {"tcp-keepidle", opt_set_tcp_keepidle},
#endif
#ifdef TCP_KEEPCNT
    {"tcp-keepcnt", opt_set_tcp_keepcnt},
#endif
#ifdef TCP_KEEPINTVL
    {"tcp-keepintvl", opt_set_tcp_keepintvl},
#endif
    {"ipv6-v6only", opt_set_ip6_v6only},
    {"linger",      opt_set_linger},
	{"recv-buffer-size",     opt_set_recv_buf_size},
	{"send-buffer-size",     opt_set_send_buf_size},
    {NULL,          NULL}
};

/* functions in library namespace */
static luaL_Reg func[] = {
    {"tcp", global_create},
    {"tcp4", global_create4},
    {"tcp6", global_create6},
    {"connect", global_connect},
    {NULL, NULL}
};

/*-------------------------------------------------------------------------*\
* Initializes module
\*-------------------------------------------------------------------------*/
int tcp_open(lua_State *L)
{
    /* create classes */
    auxiliar_newclass(L, "tcp{master}", tcp_methods);
    auxiliar_newclass(L, "tcp{client}", tcp_methods);
    auxiliar_newclass(L, "tcp{server}", tcp_methods);
    /* create class groups */
    auxiliar_add2group(L, "tcp{master}", "tcp{any}");
    auxiliar_add2group(L, "tcp{client}", "tcp{any}");
    auxiliar_add2group(L, "tcp{server}", "tcp{any}");
    /* define library functions */
    luaL_setfuncs(L, func, 0);
    return 0;
}

/*=========================================================================*\
* Lua methods
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Just call buffered IO methods
\*-------------------------------------------------------------------------*/
static int meth_send(lua_State *L) {
    p_tcp tcp = (p_tcp) auxiliar_checkclass(L, "tcp{client}", 1);
    return buffer_meth_send(L, &tcp->buf);
}

static int meth_receive(lua_State *L) {
    p_tcp tcp = (p_tcp) auxiliar_checkclass(L, "tcp{client}", 1);
    return buffer_meth_receive(L, &tcp->buf);
}

static int meth_getstats(lua_State *L) {
    p_tcp tcp = (p_tcp) auxiliar_checkclass(L, "tcp{client}", 1);
    return buffer_meth_getstats(L, &tcp->buf);
}

static int meth_setstats(lua_State *L) {
    p_tcp tcp = (p_tcp) auxiliar_checkclass(L, "tcp{client}", 1);
    return buffer_meth_setstats(L, &tcp->buf);
}

/*-------------------------------------------------------------------------*\
* Just call option handler
\*-------------------------------------------------------------------------*/
static int meth_getoption(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    return opt_meth_getoption(L, optget, &tcp->sock);
}

static int meth_setoption(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    return opt_meth_setoption(L, optset, &tcp->sock);
}

/*-------------------------------------------------------------------------*\
* Select support methods
\*-------------------------------------------------------------------------*/
static int meth_getfd(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    lua_pushnumber(L, (int) tcp->sock);
    return 1;
}

/* this is very dangerous, but can be handy for those that are brave enough */
static int meth_setfd(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    tcp->sock = (t_socket) luaL_checknumber(L, 2);
    return 0;
}

static int meth_dirty(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    lua_pushboolean(L, !buffer_isempty(&tcp->buf));
    return 1;
}

/*-------------------------------------------------------------------------*\
* Waits for and returns a client object attempting connection to the
* server object
\*-------------------------------------------------------------------------*/
static int meth_accept(lua_State *L)
{
    p_tcp server = (p_tcp) auxiliar_checkclass(L, "tcp{server}", 1);
    p_timeout tm = timeout_markstart(&server->tm);
    t_socket sock;
    const char *err = inet_tryaccept(&server->sock, server->family, &sock, tm);
    /* if successful, push client socket */
    if (err == NULL) {
        p_tcp clnt = (p_tcp) lua_newuserdata(L, sizeof(t_tcp));
        auxiliar_setclass(L, "tcp{client}", -1);
        /* initialize structure fields */
        memset(clnt, 0, sizeof(t_tcp));
        socket_setnonblocking(&sock);
        clnt->sock = sock;
        io_init(&clnt->io, (p_send) socket_send, (p_recv) socket_recv,
                (p_error) socket_ioerror, &clnt->sock);
        timeout_init(&clnt->tm, -1, -1);
        buffer_init(&clnt->buf, &clnt->io, &clnt->tm);
        clnt->family = server->family;
        return 1;
    } else {
        lua_pushnil(L);
        lua_pushstring(L, err);
        return 2;
    }
}

/*-------------------------------------------------------------------------*\
* Binds an object to an address
\*-------------------------------------------------------------------------*/
static int meth_bind(lua_State *L) {
    p_tcp tcp = (p_tcp) auxiliar_checkclass(L, "tcp{master}", 1);
    const char *address =  luaL_checkstring(L, 2);
    const char *port = luaL_checkstring(L, 3);
    const char *err;
    struct addrinfo bindhints;
    memset(&bindhints, 0, sizeof(bindhints));
    bindhints.ai_socktype = SOCK_STREAM;
    bindhints.ai_family = tcp->family;
    bindhints.ai_flags = AI_PASSIVE;
    err = inet_trybind(&tcp->sock, &tcp->family, address, port, &bindhints);
    if (err) {
        lua_pushnil(L);
        lua_pushstring(L, err);
        return 2;
    }
    lua_pushnumber(L, 1);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Turns a master tcp object into a client object.
\*-------------------------------------------------------------------------*/
static int meth_connect(lua_State *L) {
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    const char *address =  luaL_checkstring(L, 2);
    const char *port = luaL_checkstring(L, 3);
    struct addrinfo connecthints;
    const char *err;
    memset(&connecthints, 0, sizeof(connecthints));
    connecthints.ai_socktype = SOCK_STREAM;
    /* make sure we try to connect only to the same family */
    connecthints.ai_family = tcp->family;
    timeout_markstart(&tcp->tm);
    err = inet_tryconnect(&tcp->sock, &tcp->family, address, port,
        &tcp->tm, &connecthints);
    /* have to set the class even if it failed due to non-blocking connects */
    auxiliar_setclass(L, "tcp{client}", 1);
    if (err) {
        lua_pushnil(L);
        lua_pushstring(L, err);
        return 2;
    }
    lua_pushnumber(L, 1);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Closes socket used by object
\*-------------------------------------------------------------------------*/
static int meth_close(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    socket_destroy(&tcp->sock);
    lua_pushnumber(L, 1);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Returns family as string
\*-------------------------------------------------------------------------*/
static int meth_getfamily(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    if (tcp->family == AF_INET6) {
        lua_pushliteral(L, "inet6");
        return 1;
    } else if (tcp->family == AF_INET) {
        lua_pushliteral(L, "inet4");
        return 1;
    } else {
        lua_pushliteral(L, "inet4");
        return 1;
    }
}

/*-------------------------------------------------------------------------*\
* Puts the sockt in listen mode
\*-------------------------------------------------------------------------*/
static int meth_listen(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkclass(L, "tcp{master}", 1);
    int backlog = (int) luaL_optnumber(L, 2, 32);
    int err = socket_listen(&tcp->sock, backlog);
    if (err != IO_DONE) {
        lua_pushnil(L);
        lua_pushstring(L, socket_strerror(err));
        return 2;
    }
    /* turn master object into a server object */
    auxiliar_setclass(L, "tcp{server}", 1);
    lua_pushnumber(L, 1);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Shuts the connection down partially
\*-------------------------------------------------------------------------*/
static int meth_shutdown(lua_State *L)
{
    /* SHUT_RD,  SHUT_WR,  SHUT_RDWR  have  the value 0, 1, 2, so we can use method index directly */
    static const char* methods[] = { "receive", "send", "both", NULL };
    p_tcp tcp = (p_tcp) auxiliar_checkclass(L, "tcp{client}", 1);
    int how = luaL_checkoption(L, 2, "both", methods);
    socket_shutdown(&tcp->sock, how);
    lua_pushnumber(L, 1);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Just call inet methods
\*-------------------------------------------------------------------------*/
static int meth_getpeername(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    return inet_meth_getpeername(L, &tcp->sock, tcp->family);
}

static int meth_getsockname(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    return inet_meth_getsockname(L, &tcp->sock, tcp->family);
}

/*-------------------------------------------------------------------------*\
* Just call tm methods
\*-------------------------------------------------------------------------*/
static int meth_settimeout(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    return timeout_meth_settimeout(L, &tcp->tm);
}

static int meth_gettimeout(lua_State *L)
{
    p_tcp tcp = (p_tcp) auxiliar_checkgroup(L, "tcp{any}", 1);
    return timeout_meth_gettimeout(L, &tcp->tm);
}

/*=========================================================================*\
* Library functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Creates a master tcp object
\*-------------------------------------------------------------------------*/
static int tcp_create(lua_State *L, int family) {
    p_tcp tcp = (p_tcp) lua_newuserdata(L, sizeof(t_tcp));
    memset(tcp, 0, sizeof(t_tcp));
    /* set its type as master object */
    auxiliar_setclass(L, "tcp{master}", -1);
    /* if family is AF_UNSPEC, we leave the socket invalid and
     * store AF_UNSPEC into family. This will allow it to later be
     * replaced with an AF_INET6 or AF_INET socket upon first use. */
    tcp->sock = SOCKET_INVALID;
    tcp->family = family;
    io_init(&tcp->io, (p_send) socket_send, (p_recv) socket_recv,
            (p_error) socket_ioerror, &tcp->sock);
    timeout_init(&tcp->tm, -1, -1);
    buffer_init(&tcp->buf, &tcp->io, &tcp->tm);
    if (family != AF_UNSPEC) {
        const char *err = inet_trycreate(&tcp->sock, family, SOCK_STREAM, 0);
        if (err != NULL) {
            lua_pushnil(L);
            lua_pushstring(L, err);
            return 2;
        }
        socket_setnonblocking(&tcp->sock);
    }
    return 1;
}

static int global_create(lua_State *L) {
    return tcp_create(L, AF_UNSPEC);
}

static int global_create4(lua_State *L) {
    return tcp_create(L, AF_INET);
}

static int global_create6(lua_State *L) {
    return tcp_create(L, AF_INET6);
}

static int global_connect(lua_State *L) {
    const char *remoteaddr = luaL_checkstring(L, 1);
    const char *remoteserv = luaL_checkstring(L, 2);
    const char *localaddr  = luaL_optstring(L, 3, NULL);
    const char *localserv  = luaL_optstring(L, 4, "0");
    int family = inet_optfamily(L, 5, "unspec");
    p_tcp tcp = (p_tcp) lua_newuserdata(L, sizeof(t_tcp));
    struct addrinfo bindhints, connecthints;
    const char *err = NULL;
    /* initialize tcp structure */
    memset(tcp, 0, sizeof(t_tcp));
    io_init(&tcp->io, (p_send) socket_send, (p_recv) socket_recv,
            (p_error) socket_ioerror, &tcp->sock);
    timeout_init(&tcp->tm, -1, -1);
    buffer_init(&tcp->buf, &tcp->io, &tcp->tm);
    tcp->sock = SOCKET_INVALID;
    tcp->family = AF_UNSPEC;
    /* allow user to pick local address and port */
    memset(&bindhints, 0, sizeof(bindhints));
    bindhints.ai_socktype = SOCK_STREAM;
    bindhints.ai_family = family;
    bindhints.ai_flags = AI_PASSIVE;
    if (localaddr) {
        err = inet_trybind(&tcp->sock, &tcp->family, localaddr,
            localserv, &bindhints);
        if (err) {
            lua_pushnil(L);
            lua_pushstring(L, err);
            return 2;
        }
    }
    /* try to connect to remote address and port */
    memset(&connecthints, 0, sizeof(connecthints));
    connecthints.ai_socktype = SOCK_STREAM;
    /* make sure we try to connect only to the same family */
    connecthints.ai_family = tcp->family;
    err = inet_tryconnect(&tcp->sock, &tcp->family, remoteaddr, remoteserv,
         &tcp->tm, &connecthints);
    if (err) {
        socket_destroy(&tcp->sock);
        lua_pushnil(L);
        lua_pushstring(L, err);
        return 2;
    }
    auxiliar_setclass(L, "tcp{client}", -1);
    return 1;
}

```

`src/Lua/socket/tcp.h`:

```h
#ifndef TCP_H
#define TCP_H
/*=========================================================================*\
* TCP object
* LuaSocket toolkit
*
* The tcp.h module is basicly a glue that puts together modules buffer.h,
* timeout.h socket.h and inet.h to provide the LuaSocket TCP (AF_INET,
* SOCK_STREAM) support.
*
* Three classes are defined: master, client and server. The master class is
* a newly created tcp object, that has not been bound or connected. Server
* objects are tcp objects bound to some local address. Client objects are
* tcp objects either connected to some address or returned by the accept
* method of a server object.
\*=========================================================================*/
#include "luasocket.h"

#include "buffer.h"
#include "timeout.h"
#include "socket.h"

typedef struct t_tcp_ {
    t_socket sock;
    t_io io;
    t_buffer buf;
    t_timeout tm;
    int family;
} t_tcp;

typedef t_tcp *p_tcp;

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int tcp_open(lua_State *L);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* TCP_H */

```

`src/Lua/socket/timeout.c`:

```c
/*=========================================================================*\
* Timeout management functions
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"

#include "auxiliar.h"
#include "timeout.h"

#include <stdio.h>
#include <limits.h>
#include <float.h>

#ifdef _WIN32
#include <windows.h>
#else
#include <time.h>
#include <sys/time.h>
#endif

/* min and max macros */
#ifndef MIN
#define MIN(x, y) ((x) < (y) ? x : y)
#endif
#ifndef MAX
#define MAX(x, y) ((x) > (y) ? x : y)
#endif

/*=========================================================================*\
* Internal function prototypes
\*=========================================================================*/
static int timeout_lua_gettime(lua_State *L);
static int timeout_lua_sleep(lua_State *L);

static luaL_Reg func[] = {
    { "gettime", timeout_lua_gettime },
    { "sleep", timeout_lua_sleep },
    { NULL, NULL }
};

/*=========================================================================*\
* Exported functions.
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Initialize structure
\*-------------------------------------------------------------------------*/
void timeout_init(p_timeout tm, double block, double total) {
    tm->block = block;
    tm->total = total;
}

/*-------------------------------------------------------------------------*\
* Determines how much time we have left for the next system call,
* if the previous call was successful
* Input
*   tm: timeout control structure
* Returns
*   the number of ms left or -1 if there is no time limit
\*-------------------------------------------------------------------------*/
double timeout_get(p_timeout tm) {
    if (tm->block < 0.0 && tm->total < 0.0) {
        return -1;
    } else if (tm->block < 0.0) {
        double t = tm->total - timeout_gettime() + tm->start;
        return MAX(t, 0.0);
    } else if (tm->total < 0.0) {
        return tm->block;
    } else {
        double t = tm->total - timeout_gettime() + tm->start;
        return MIN(tm->block, MAX(t, 0.0));
    }
}

/*-------------------------------------------------------------------------*\
* Returns time since start of operation
* Input
*   tm: timeout control structure
* Returns
*   start field of structure
\*-------------------------------------------------------------------------*/
double timeout_getstart(p_timeout tm) {
    return tm->start;
}

/*-------------------------------------------------------------------------*\
* Determines how much time we have left for the next system call,
* if the previous call was a failure
* Input
*   tm: timeout control structure
* Returns
*   the number of ms left or -1 if there is no time limit
\*-------------------------------------------------------------------------*/
double timeout_getretry(p_timeout tm) {
    if (tm->block < 0.0 && tm->total < 0.0) {
        return -1;
    } else if (tm->block < 0.0) {
        double t = tm->total - timeout_gettime() + tm->start;
        return MAX(t, 0.0);
    } else if (tm->total < 0.0) {
        double t = tm->block - timeout_gettime() + tm->start;
        return MAX(t, 0.0);
    } else {
        double t = tm->total - timeout_gettime() + tm->start;
        return MIN(tm->block, MAX(t, 0.0));
    }
}

/*-------------------------------------------------------------------------*\
* Marks the operation start time in structure
* Input
*   tm: timeout control structure
\*-------------------------------------------------------------------------*/
p_timeout timeout_markstart(p_timeout tm) {
    tm->start = timeout_gettime();
    return tm;
}

/*-------------------------------------------------------------------------*\
* Gets time in s, relative to January 1, 1970 (UTC)
* Returns
*   time in s.
\*-------------------------------------------------------------------------*/
#ifdef _WIN32
double timeout_gettime(void) {
    FILETIME ft;
    double t;
    GetSystemTimeAsFileTime(&ft);
    /* Windows file time (time since January 1, 1601 (UTC)) */
    t  = ft.dwLowDateTime/1.0e7 + ft.dwHighDateTime*(4294967296.0/1.0e7);
    /* convert to Unix Epoch time (time since January 1, 1970 (UTC)) */
    return (t - 11644473600.0);
}
#else
double timeout_gettime(void) {
    struct timeval v;
    gettimeofday(&v, (struct timezone *) NULL);
    /* Unix Epoch time (time since January 1, 1970 (UTC)) */
    return v.tv_sec + v.tv_usec/1.0e6;
}
#endif

/*-------------------------------------------------------------------------*\
* Initializes module
\*-------------------------------------------------------------------------*/
int timeout_open(lua_State *L) {
    luaL_setfuncs(L, func, 0);
    return 0;
}

/*-------------------------------------------------------------------------*\
* Sets timeout values for IO operations
* Lua Input: base, time [, mode]
*   time: time out value in seconds
*   mode: "b" for block timeout, "t" for total timeout. (default: b)
\*-------------------------------------------------------------------------*/
int timeout_meth_settimeout(lua_State *L, p_timeout tm) {
    double t = luaL_optnumber(L, 2, -1);
    const char *mode = luaL_optstring(L, 3, "b");
    switch (*mode) {
        case 'b':
            tm->block = t;
            break;
        case 'r': case 't':
            tm->total = t;
            break;
        default:
            luaL_argcheck(L, 0, 3, "invalid timeout mode");
            break;
    }
    lua_pushnumber(L, 1);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Gets timeout values for IO operations
* Lua Output: block, total
\*-------------------------------------------------------------------------*/
int timeout_meth_gettimeout(lua_State *L, p_timeout tm) {
    lua_pushnumber(L, tm->block);
    lua_pushnumber(L, tm->total);
    return 2;
}

/*=========================================================================*\
* Test support functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Returns the time the system has been up, in secconds.
\*-------------------------------------------------------------------------*/
static int timeout_lua_gettime(lua_State *L)
{
    lua_pushnumber(L, timeout_gettime());
    return 1;
}

/*-------------------------------------------------------------------------*\
* Sleep for n seconds.
\*-------------------------------------------------------------------------*/
#ifdef _WIN32
int timeout_lua_sleep(lua_State *L)
{
    double n = luaL_checknumber(L, 1);
    if (n < 0.0) n = 0.0;
    if (n < DBL_MAX/1000.0) n *= 1000.0;
    if (n > INT_MAX) n = INT_MAX;
    Sleep((int)n);
    return 0;
}
#else
int timeout_lua_sleep(lua_State *L)
{
    double n = luaL_checknumber(L, 1);
    struct timespec t, r;
    if (n < 0.0) n = 0.0;
    if (n > INT_MAX) n = INT_MAX;
    t.tv_sec = (int) n;
    n -= t.tv_sec;
    t.tv_nsec = (int) (n * 1000000000);
    if (t.tv_nsec >= 1000000000) t.tv_nsec = 999999999;
    while (nanosleep(&t, &r) != 0) {
        t.tv_sec = r.tv_sec;
        t.tv_nsec = r.tv_nsec;
    }
    return 0;
}
#endif

```

`src/Lua/socket/timeout.h`:

```h
#ifndef TIMEOUT_H
#define TIMEOUT_H
/*=========================================================================*\
* Timeout management functions
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"

/* timeout control structure */
typedef struct t_timeout_ {
    double block;          /* maximum time for blocking calls */
    double total;          /* total number of miliseconds for operation */
    double start;          /* time of start of operation */
} t_timeout;
typedef t_timeout *p_timeout;

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

void timeout_init(p_timeout tm, double block, double total);
double timeout_get(p_timeout tm);
double timeout_getstart(p_timeout tm);
double timeout_getretry(p_timeout tm);
p_timeout timeout_markstart(p_timeout tm);

double timeout_gettime(void);

int timeout_open(lua_State *L);

int timeout_meth_settimeout(lua_State *L, p_timeout tm);
int timeout_meth_gettimeout(lua_State *L, p_timeout tm);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#define timeout_iszero(tm)   ((tm)->block == 0.0)

#endif /* TIMEOUT_H */

```

`src/Lua/socket/udp.c`:

```c
/*=========================================================================*\
* UDP object
* LuaSocket toolkit
\*=========================================================================*/
#include "luasocket.h"

#include "auxiliar.h"
#include "socket.h"
#include "inet.h"
#include "options.h"
#include "udp.h"

#include <string.h>
#include <stdlib.h>

/* min and max macros */
#ifndef MIN
#define MIN(x, y) ((x) < (y) ? x : y)
#endif
#ifndef MAX
#define MAX(x, y) ((x) > (y) ? x : y)
#endif

/*=========================================================================*\
* Internal function prototypes
\*=========================================================================*/
static int global_create(lua_State *L);
static int global_create4(lua_State *L);
static int global_create6(lua_State *L);
static int meth_send(lua_State *L);
static int meth_sendto(lua_State *L);
static int meth_receive(lua_State *L);
static int meth_receivefrom(lua_State *L);
static int meth_getfamily(lua_State *L);
static int meth_getsockname(lua_State *L);
static int meth_getpeername(lua_State *L);
static int meth_gettimeout(lua_State *L);
static int meth_setsockname(lua_State *L);
static int meth_setpeername(lua_State *L);
static int meth_close(lua_State *L);
static int meth_setoption(lua_State *L);
static int meth_getoption(lua_State *L);
static int meth_settimeout(lua_State *L);
static int meth_getfd(lua_State *L);
static int meth_setfd(lua_State *L);
static int meth_dirty(lua_State *L);

/* udp object methods */
static luaL_Reg udp_methods[] = {
    {"__gc",        meth_close},
    {"__tostring",  auxiliar_tostring},
    {"close",       meth_close},
    {"dirty",       meth_dirty},
    {"getfamily",   meth_getfamily},
    {"getfd",       meth_getfd},
    {"getpeername", meth_getpeername},
    {"getsockname", meth_getsockname},
    {"receive",     meth_receive},
    {"receivefrom", meth_receivefrom},
    {"send",        meth_send},
    {"sendto",      meth_sendto},
    {"setfd",       meth_setfd},
    {"setoption",   meth_setoption},
    {"getoption",   meth_getoption},
    {"setpeername", meth_setpeername},
    {"setsockname", meth_setsockname},
    {"settimeout",  meth_settimeout},
    {"gettimeout",  meth_gettimeout},
    {NULL,          NULL}
};

/* socket options for setoption */
static t_opt optset[] = {
    {"dontroute",            opt_set_dontroute},
    {"broadcast",            opt_set_broadcast},
    {"reuseaddr",            opt_set_reuseaddr},
    {"reuseport",            opt_set_reuseport},
    {"ip-multicast-if",      opt_set_ip_multicast_if},
    {"ip-multicast-ttl",     opt_set_ip_multicast_ttl},
    {"ip-multicast-loop",    opt_set_ip_multicast_loop},
    {"ip-add-membership",    opt_set_ip_add_membership},
    {"ip-drop-membership",   opt_set_ip_drop_membersip},
    {"ipv6-unicast-hops",    opt_set_ip6_unicast_hops},
    {"ipv6-multicast-hops",  opt_set_ip6_unicast_hops},
    {"ipv6-multicast-loop",  opt_set_ip6_multicast_loop},
    {"ipv6-add-membership",  opt_set_ip6_add_membership},
    {"ipv6-drop-membership", opt_set_ip6_drop_membersip},
    {"ipv6-v6only",          opt_set_ip6_v6only},
	{"recv-buffer-size",     opt_set_recv_buf_size},
	{"send-buffer-size",     opt_set_send_buf_size},
    {NULL,                   NULL}
};

/* socket options for getoption */
static t_opt optget[] = {
    {"dontroute",            opt_get_dontroute},
    {"broadcast",            opt_get_broadcast},
    {"reuseaddr",            opt_get_reuseaddr},
    {"reuseport",            opt_get_reuseport},
    {"ip-multicast-if",      opt_get_ip_multicast_if},
    {"ip-multicast-loop",    opt_get_ip_multicast_loop},
    {"error",                opt_get_error},
    {"ipv6-unicast-hops",    opt_get_ip6_unicast_hops},
    {"ipv6-multicast-hops",  opt_get_ip6_unicast_hops},
    {"ipv6-multicast-loop",  opt_get_ip6_multicast_loop},
    {"ipv6-v6only",          opt_get_ip6_v6only},
	{"recv-buffer-size",     opt_get_recv_buf_size},
	{"send-buffer-size",     opt_get_send_buf_size},
    {NULL,                   NULL}
};

/* functions in library namespace */
static luaL_Reg func[] = {
    {"udp", global_create},
    {"udp4", global_create4},
    {"udp6", global_create6},
    {NULL, NULL}
};

/*-------------------------------------------------------------------------*\
* Initializes module
\*-------------------------------------------------------------------------*/
int udp_open(lua_State *L) {
    /* create classes */
    auxiliar_newclass(L, "udp{connected}", udp_methods);
    auxiliar_newclass(L, "udp{unconnected}", udp_methods);
    /* create class groups */
    auxiliar_add2group(L, "udp{connected}",   "udp{any}");
    auxiliar_add2group(L, "udp{unconnected}", "udp{any}");
    auxiliar_add2group(L, "udp{connected}",   "select{able}");
    auxiliar_add2group(L, "udp{unconnected}", "select{able}");
    /* define library functions */
    luaL_setfuncs(L, func, 0);
    /* export default UDP size */
    lua_pushliteral(L, "_DATAGRAMSIZE");
    lua_pushinteger(L, UDP_DATAGRAMSIZE);
    lua_rawset(L, -3);
    return 0;
}

/*=========================================================================*\
* Lua methods
\*=========================================================================*/
static const char *udp_strerror(int err) {
    /* a 'closed' error on an unconnected means the target address was not
     * accepted by the transport layer */
    if (err == IO_CLOSED) return "refused";
    else return socket_strerror(err);
}

/*-------------------------------------------------------------------------*\
* Send data through connected udp socket
\*-------------------------------------------------------------------------*/
static int meth_send(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkclass(L, "udp{connected}", 1);
    p_timeout tm = &udp->tm;
    size_t count, sent = 0;
    int err;
    const char *data = luaL_checklstring(L, 2, &count);
    timeout_markstart(tm);
    err = socket_send(&udp->sock, data, count, &sent, tm);
    if (err != IO_DONE) {
        lua_pushnil(L);
        lua_pushstring(L, udp_strerror(err));
        return 2;
    }
    lua_pushnumber(L, (lua_Number) sent);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Send data through unconnected udp socket
\*-------------------------------------------------------------------------*/
static int meth_sendto(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkclass(L, "udp{unconnected}", 1);
    size_t count, sent = 0;
    const char *data = luaL_checklstring(L, 2, &count);
    const char *ip = luaL_checkstring(L, 3);
    const char *port = luaL_checkstring(L, 4);
    p_timeout tm = &udp->tm;
    int err;
    struct addrinfo aihint;
    struct addrinfo *ai;
    memset(&aihint, 0, sizeof(aihint));
    aihint.ai_family = udp->family;
    aihint.ai_socktype = SOCK_DGRAM;
    aihint.ai_flags = AI_NUMERICHOST;
#ifdef AI_NUMERICSERV
    aihint.ai_flags |= AI_NUMERICSERV;
#endif
    err = getaddrinfo(ip, port, &aihint, &ai);
	if (err) {
        lua_pushnil(L);
        lua_pushstring(L, gai_strerror(err));
        return 2;
    }

    /* create socket if on first sendto if AF_UNSPEC was set */
    if (udp->family == AF_UNSPEC && udp->sock == SOCKET_INVALID) {
        struct addrinfo *ap;
        const char *errstr = NULL;
        for (ap = ai; ap != NULL; ap = ap->ai_next) {
            errstr = inet_trycreate(&udp->sock, ap->ai_family, SOCK_DGRAM, 0);
            if (errstr == NULL) {
                socket_setnonblocking(&udp->sock);
                udp->family = ap->ai_family;
                break;
            }
        }
        if (errstr != NULL) {
            lua_pushnil(L);
            lua_pushstring(L, errstr);
            freeaddrinfo(ai);
            return 2;
        }
    }

    timeout_markstart(tm);
    err = socket_sendto(&udp->sock, data, count, &sent, ai->ai_addr,
        (socklen_t) ai->ai_addrlen, tm);
    freeaddrinfo(ai);
    if (err != IO_DONE) {
        lua_pushnil(L);
        lua_pushstring(L, udp_strerror(err));
        return 2;
    }
    lua_pushnumber(L, (lua_Number) sent);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Receives data from a UDP socket
\*-------------------------------------------------------------------------*/
static int meth_receive(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    char buf[UDP_DATAGRAMSIZE];
    size_t got, wanted = (size_t) luaL_optnumber(L, 2, sizeof(buf));
    char *dgram = wanted > sizeof(buf)? (char *) malloc(wanted): buf;
    int err;
    p_timeout tm = &udp->tm;
    timeout_markstart(tm);
    if (!dgram) {
        lua_pushnil(L);
        lua_pushliteral(L, "out of memory");
        return 2;
    }
    err = socket_recv(&udp->sock, dgram, wanted, &got, tm);
    /* Unlike TCP, recv() of zero is not closed, but a zero-length packet. */
    if (err != IO_DONE && err != IO_CLOSED) {
        lua_pushnil(L);
        lua_pushstring(L, udp_strerror(err));
        if (wanted > sizeof(buf)) free(dgram);
        return 2;
    }
    lua_pushlstring(L, dgram, got);
    if (wanted > sizeof(buf)) free(dgram);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Receives data and sender from a UDP socket
\*-------------------------------------------------------------------------*/
static int meth_receivefrom(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkclass(L, "udp{unconnected}", 1);
    char buf[UDP_DATAGRAMSIZE];
    size_t got, wanted = (size_t) luaL_optnumber(L, 2, sizeof(buf));
    char *dgram = wanted > sizeof(buf)? (char *) malloc(wanted): buf;
    struct sockaddr_storage addr;
    socklen_t addr_len = sizeof(addr);
    char addrstr[INET6_ADDRSTRLEN];
    char portstr[6];
    int err;
    p_timeout tm = &udp->tm;
    timeout_markstart(tm);
    if (!dgram) {
        lua_pushnil(L);
        lua_pushliteral(L, "out of memory");
        return 2;
    }
    err = socket_recvfrom(&udp->sock, dgram, wanted, &got, (SA *) &addr,
            &addr_len, tm);
    /* Unlike TCP, recv() of zero is not closed, but a zero-length packet. */
    if (err != IO_DONE && err != IO_CLOSED) {
        lua_pushnil(L);
        lua_pushstring(L, udp_strerror(err));
        if (wanted > sizeof(buf)) free(dgram);
        return 2;
    }
    err = getnameinfo((struct sockaddr *)&addr, addr_len, addrstr,
        INET6_ADDRSTRLEN, portstr, 6, NI_NUMERICHOST | NI_NUMERICSERV);
	if (err) {
        lua_pushnil(L);
        lua_pushstring(L, gai_strerror(err));
        if (wanted > sizeof(buf)) free(dgram);
        return 2;
    }
    lua_pushlstring(L, dgram, got);
    lua_pushstring(L, addrstr);
    lua_pushinteger(L, (int) strtol(portstr, (char **) NULL, 10));
    if (wanted > sizeof(buf)) free(dgram);
    return 3;
}

/*-------------------------------------------------------------------------*\
* Returns family as string
\*-------------------------------------------------------------------------*/
static int meth_getfamily(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    if (udp->family == AF_INET6) {
        lua_pushliteral(L, "inet6");
        return 1;
    } else {
        lua_pushliteral(L, "inet4");
        return 1;
    }
}

/*-------------------------------------------------------------------------*\
* Select support methods
\*-------------------------------------------------------------------------*/
static int meth_getfd(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    lua_pushnumber(L, (int) udp->sock);
    return 1;
}

/* this is very dangerous, but can be handy for those that are brave enough */
static int meth_setfd(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    udp->sock = (t_socket) luaL_checknumber(L, 2);
    return 0;
}

static int meth_dirty(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    (void) udp;
    lua_pushboolean(L, 0);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Just call inet methods
\*-------------------------------------------------------------------------*/
static int meth_getpeername(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkclass(L, "udp{connected}", 1);
    return inet_meth_getpeername(L, &udp->sock, udp->family);
}

static int meth_getsockname(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    return inet_meth_getsockname(L, &udp->sock, udp->family);
}

/*-------------------------------------------------------------------------*\
* Just call option handler
\*-------------------------------------------------------------------------*/
static int meth_setoption(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    return opt_meth_setoption(L, optset, &udp->sock);
}

/*-------------------------------------------------------------------------*\
* Just call option handler
\*-------------------------------------------------------------------------*/
static int meth_getoption(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    return opt_meth_getoption(L, optget, &udp->sock);
}

/*-------------------------------------------------------------------------*\
* Just call tm methods
\*-------------------------------------------------------------------------*/
static int meth_settimeout(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    return timeout_meth_settimeout(L, &udp->tm);
}

static int meth_gettimeout(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    return timeout_meth_gettimeout(L, &udp->tm);
}

/*-------------------------------------------------------------------------*\
* Turns a master udp object into a client object.
\*-------------------------------------------------------------------------*/
static int meth_setpeername(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    p_timeout tm = &udp->tm;
    const char *address = luaL_checkstring(L, 2);
    int connecting = strcmp(address, "*");
    const char *port = connecting? luaL_checkstring(L, 3): "0";
    struct addrinfo connecthints;
    const char *err;
    memset(&connecthints, 0, sizeof(connecthints));
    connecthints.ai_socktype = SOCK_DGRAM;
    /* make sure we try to connect only to the same family */
    connecthints.ai_family = udp->family;
    if (connecting) {
        err = inet_tryconnect(&udp->sock, &udp->family, address,
            port, tm, &connecthints);
        if (err) {
            lua_pushnil(L);
            lua_pushstring(L, err);
            return 2;
        }
        auxiliar_setclass(L, "udp{connected}", 1);
    } else {
        /* we ignore possible errors because Mac OS X always
         * returns EAFNOSUPPORT */
        inet_trydisconnect(&udp->sock, udp->family, tm);
        auxiliar_setclass(L, "udp{unconnected}", 1);
    }
    lua_pushnumber(L, 1);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Closes socket used by object
\*-------------------------------------------------------------------------*/
static int meth_close(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkgroup(L, "udp{any}", 1);
    socket_destroy(&udp->sock);
    lua_pushnumber(L, 1);
    return 1;
}

/*-------------------------------------------------------------------------*\
* Turns a master object into a server object
\*-------------------------------------------------------------------------*/
static int meth_setsockname(lua_State *L) {
    p_udp udp = (p_udp) auxiliar_checkclass(L, "udp{unconnected}", 1);
    const char *address =  luaL_checkstring(L, 2);
    const char *port = luaL_checkstring(L, 3);
    const char *err;
    struct addrinfo bindhints;
    memset(&bindhints, 0, sizeof(bindhints));
    bindhints.ai_socktype = SOCK_DGRAM;
    bindhints.ai_family = udp->family;
    bindhints.ai_flags = AI_PASSIVE;
    err = inet_trybind(&udp->sock, &udp->family, address, port, &bindhints);
    if (err) {
        lua_pushnil(L);
        lua_pushstring(L, err);
        return 2;
    }
    lua_pushnumber(L, 1);
    return 1;
}

/*=========================================================================*\
* Library functions
\*=========================================================================*/
/*-------------------------------------------------------------------------*\
* Creates a master udp object
\*-------------------------------------------------------------------------*/
static int udp_create(lua_State *L, int family) {
    /* allocate udp object */
    p_udp udp = (p_udp) lua_newuserdata(L, sizeof(t_udp));
    auxiliar_setclass(L, "udp{unconnected}", -1);
    /* if family is AF_UNSPEC, we leave the socket invalid and
     * store AF_UNSPEC into family. This will allow it to later be
     * replaced with an AF_INET6 or AF_INET socket upon first use. */
    udp->sock = SOCKET_INVALID;
    timeout_init(&udp->tm, -1, -1);
    udp->family = family;
    if (family != AF_UNSPEC) {
        const char *err = inet_trycreate(&udp->sock, family, SOCK_DGRAM, 0);
        if (err != NULL) {
            lua_pushnil(L);
            lua_pushstring(L, err);
            return 2;
        }
        socket_setnonblocking(&udp->sock);
    }
    return 1;
}

static int global_create(lua_State *L) {
    return udp_create(L, AF_UNSPEC);
}

static int global_create4(lua_State *L) {
    return udp_create(L, AF_INET);
}

static int global_create6(lua_State *L) {
    return udp_create(L, AF_INET6);
}

```

`src/Lua/socket/udp.h`:

```h
#ifndef UDP_H
#define UDP_H
/*=========================================================================*\
* UDP object
* LuaSocket toolkit
*
* The udp.h module provides LuaSocket with support for UDP protocol
* (AF_INET, SOCK_DGRAM).
*
* Two classes are defined: connected and unconnected. UDP objects are
* originally unconnected. They can be "connected" to a given address
* with a call to the setpeername function. The same function can be used to
* break the connection.
\*=========================================================================*/
#include "luasocket.h"

#include "timeout.h"
#include "socket.h"

#define UDP_DATAGRAMSIZE 8192

typedef struct t_udp_ {
    t_socket sock;
    t_timeout tm;
    int family;
} t_udp;
typedef t_udp *p_udp;

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int udp_open(lua_State *L);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* UDP_H */

```

`src/Lua/socket/unix.h`:

```h
#ifndef UNIX_H
#define UNIX_H
/*=========================================================================*\
* Unix domain object
* LuaSocket toolkit
*
* This module is just an example of how to extend LuaSocket with a new 
* domain.
\*=========================================================================*/
#include "luasocket.h"

#include "buffer.h"
#include "timeout.h"
#include "socket.h"

typedef struct t_unix_ {
    t_socket sock;
    t_io io;
    t_buffer buf;
    t_timeout tm;
} t_unix;
typedef t_unix *p_unix;

LUASOCKET_API int luaopen_socket_unix(lua_State *L);

#endif /* UNIX_H */

```

`src/Lua/socket/unixdgram.h`:

```h
#ifndef UNIXDGRAM_H
#define UNIXDGRAM_H
/*=========================================================================*\
* DGRAM object
* LuaSocket toolkit
*
* The dgram.h module provides LuaSocket with support for DGRAM protocol
* (AF_INET, SOCK_DGRAM).
*
* Two classes are defined: connected and unconnected. DGRAM objects are
* originally unconnected. They can be "connected" to a given address
* with a call to the setpeername function. The same function can be used to
* break the connection.
\*=========================================================================*/

#include "unix.h"

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int unixdgram_open(lua_State *L);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* UNIXDGRAM_H */

```

`src/Lua/socket/unixstream.h`:

```h
#ifndef UNIXSTREAM_H
#define UNIXSTREAM_H
/*=========================================================================*\
* UNIX STREAM object
* LuaSocket toolkit
*
* The unixstream.h module is basicly a glue that puts together modules buffer.h,
* timeout.h socket.h and inet.h to provide the LuaSocket UNIX STREAM (AF_UNIX,
* SOCK_STREAM) support.
*
* Three classes are defined: master, client and server. The master class is
* a newly created unixstream object, that has not been bound or connected. Server
* objects are unixstream objects bound to some local address. Client objects are
* unixstream objects either connected to some address or returned by the accept
* method of a server object.
\*=========================================================================*/
#include "unix.h"

#ifndef _WIN32
#pragma GCC visibility push(hidden)
#endif

int unixstream_open(lua_State *L);

#ifndef _WIN32
#pragma GCC visibility pop
#endif

#endif /* UNIXSTREAM_H */

```

`src/Lua/socket/usocket.h`:

```h
#ifndef USOCKET_H
#define USOCKET_H
/*=========================================================================*\
* Socket compatibilization module for Unix
* LuaSocket toolkit
\*=========================================================================*/

/*=========================================================================*\
* BSD include files
\*=========================================================================*/
/* error codes */
#include <errno.h>
/* close function */
#include <unistd.h>
/* fnctnl function and associated constants */
#include <fcntl.h>
/* struct sockaddr */
#include <sys/types.h>
/* socket function */
#include <sys/socket.h>
/* struct timeval */
#include <sys/time.h>
/* gethostbyname and gethostbyaddr functions */
#include <netdb.h>
/* sigpipe handling */
#include <signal.h>
/* IP stuff*/
#include <netinet/in.h>
#include <arpa/inet.h>
/* TCP options (nagle algorithm disable) */
#include <netinet/tcp.h>
#include <net/if.h>

#ifndef SO_REUSEPORT
#define SO_REUSEPORT SO_REUSEADDR
#endif

/* Some platforms use IPV6_JOIN_GROUP instead if
 * IPV6_ADD_MEMBERSHIP. The semantics are same, though. */
#ifndef IPV6_ADD_MEMBERSHIP
#ifdef IPV6_JOIN_GROUP
#define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
#endif /* IPV6_JOIN_GROUP */
#endif /* !IPV6_ADD_MEMBERSHIP */

/* Same with IPV6_DROP_MEMBERSHIP / IPV6_LEAVE_GROUP. */
#ifndef IPV6_DROP_MEMBERSHIP
#ifdef IPV6_LEAVE_GROUP
#define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP
#endif /* IPV6_LEAVE_GROUP */
#endif /* !IPV6_DROP_MEMBERSHIP */

typedef int t_socket;
typedef t_socket *p_socket;
typedef struct sockaddr_storage t_sockaddr_storage;

#define SOCKET_INVALID (-1)

#endif /* USOCKET_H */

```

`src/Lua/socket/wsocket.c`:

```c
/*=========================================================================*\
* Socket compatibilization module for Win32
* LuaSocket toolkit
*
* The penalty of calling select to avoid busy-wait is only paid when
* the I/O call fail in the first place.
\*=========================================================================*/
#include "luasocket.h"

#include <string.h>

#include "socket.h"
#include "pierror.h"

/* WinSock doesn't have a strerror... */
static const char *wstrerror(int err);

/*-------------------------------------------------------------------------*\
* Initializes module
\*-------------------------------------------------------------------------*/
int socket_open(void) {
    WSADATA wsaData;
    WORD wVersionRequested = MAKEWORD(2, 0);
    int err = WSAStartup(wVersionRequested, &wsaData );
    if (err != 0) return 0;
    if ((LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 0) &&
        (LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1)) {
        WSACleanup();
        return 0;
    }
    return 1;
}

/*-------------------------------------------------------------------------*\
* Close module
\*-------------------------------------------------------------------------*/
int socket_close(void) {
    WSACleanup();
    return 1;
}

/*-------------------------------------------------------------------------*\
* Wait for readable/writable/connected socket with timeout
\*-------------------------------------------------------------------------*/
#define WAITFD_R        1
#define WAITFD_W        2
#define WAITFD_E        4
#define WAITFD_C        (WAITFD_E|WAITFD_W)

int socket_waitfd(p_socket ps, int sw, p_timeout tm) {
    int ret;
    fd_set rfds, wfds, efds, *rp = NULL, *wp = NULL, *ep = NULL;
    struct timeval tv, *tp = NULL;
    double t;
    if (timeout_iszero(tm)) return IO_TIMEOUT;  /* optimize timeout == 0 case */
    if (sw & WAITFD_R) {
        FD_ZERO(&rfds);
        FD_SET(*ps, &rfds);
        rp = &rfds;
    }
    if (sw & WAITFD_W) { FD_ZERO(&wfds); FD_SET(*ps, &wfds); wp = &wfds; }
    if (sw & WAITFD_C) { FD_ZERO(&efds); FD_SET(*ps, &efds); ep = &efds; }
    if ((t = timeout_get(tm)) >= 0.0) {
        tv.tv_sec = (int) t;
        tv.tv_usec = (int) ((t-tv.tv_sec)*1.0e6);
        tp = &tv;
    }
    ret = select(0, rp, wp, ep, tp);
    if (ret == -1) return WSAGetLastError();
    if (ret == 0) return IO_TIMEOUT;
    if (sw == WAITFD_C && FD_ISSET(*ps, &efds)) return IO_CLOSED;
    return IO_DONE;
}

/*-------------------------------------------------------------------------*\
* Select with int timeout in ms
\*-------------------------------------------------------------------------*/
int socket_select(t_socket n, fd_set *rfds, fd_set *wfds, fd_set *efds,
        p_timeout tm) {
    struct timeval tv;
    double t = timeout_get(tm);
    tv.tv_sec = (int) t;
    tv.tv_usec = (int) ((t - tv.tv_sec) * 1.0e6);
    if (n <= 0) {
        Sleep((DWORD) (1000*t));
        return 0;
    } else return select(0, rfds, wfds, efds, t >= 0.0? &tv: NULL);
}

/*-------------------------------------------------------------------------*\
* Close and inutilize socket
\*-------------------------------------------------------------------------*/
void socket_destroy(p_socket ps) {
    if (*ps != SOCKET_INVALID) {
        socket_setblocking(ps); /* close can take a long time on WIN32 */
        closesocket(*ps);
        *ps = SOCKET_INVALID;
    }
}

/*-------------------------------------------------------------------------*\
*
\*-------------------------------------------------------------------------*/
void socket_shutdown(p_socket ps, int how) {
    socket_setblocking(ps);
    shutdown(*ps, how);
    socket_setnonblocking(ps);
}

/*-------------------------------------------------------------------------*\
* Creates and sets up a socket
\*-------------------------------------------------------------------------*/
int socket_create(p_socket ps, int domain, int type, int protocol) {
    *ps = socket(domain, type, protocol);
    if (*ps != SOCKET_INVALID) return IO_DONE;
    else return WSAGetLastError();
}

/*-------------------------------------------------------------------------*\
* Connects or returns error message
\*-------------------------------------------------------------------------*/
int socket_connect(p_socket ps, SA *addr, socklen_t len, p_timeout tm) {
    int err;
    /* don't call on closed socket */
    if (*ps == SOCKET_INVALID) return IO_CLOSED;
    /* ask system to connect */
    if (connect(*ps, addr, len) == 0) return IO_DONE;
    /* make sure the system is trying to connect */
    err = WSAGetLastError();
    if (err != WSAEWOULDBLOCK && err != WSAEINPROGRESS) return err;
    /* zero timeout case optimization */
    if (timeout_iszero(tm)) return IO_TIMEOUT;
    /* we wait until something happens */
    err = socket_waitfd(ps, WAITFD_C, tm);
    if (err == IO_CLOSED) {
        int elen = sizeof(err);
        /* give windows time to set the error (yes, disgusting) */
        Sleep(10);
        /* find out why we failed */
        getsockopt(*ps, SOL_SOCKET, SO_ERROR, (char *)&err, &elen);
        /* we KNOW there was an error. if 'why' is 0, we will return
        * "unknown error", but it's not really our fault */
        return err > 0? err: IO_UNKNOWN;
    } else return err;

}

/*-------------------------------------------------------------------------*\
* Binds or returns error message
\*-------------------------------------------------------------------------*/
int socket_bind(p_socket ps, SA *addr, socklen_t len) {
    int err = IO_DONE;
    socket_setblocking(ps);
    if (bind(*ps, addr, len) < 0) err = WSAGetLastError();
    socket_setnonblocking(ps);
    return err;
}

/*-------------------------------------------------------------------------*\
*
\*-------------------------------------------------------------------------*/
int socket_listen(p_socket ps, int backlog) {
    int err = IO_DONE;
    socket_setblocking(ps);
    if (listen(*ps, backlog) < 0) err = WSAGetLastError();
    socket_setnonblocking(ps);
    return err;
}

/*-------------------------------------------------------------------------*\
* Accept with timeout
\*-------------------------------------------------------------------------*/
int socket_accept(p_socket ps, p_socket pa, SA *addr, socklen_t *len,
        p_timeout tm) {
    if (*ps == SOCKET_INVALID) return IO_CLOSED;
    for ( ;; ) {
        int err;
        /* try to get client socket */
        if ((*pa = accept(*ps, addr, len)) != SOCKET_INVALID) return IO_DONE;
        /* find out why we failed */
        err = WSAGetLastError();
        /* if we failed because there was no connectoin, keep trying */
        if (err != WSAEWOULDBLOCK && err != WSAECONNABORTED) return err;
        /* call select to avoid busy wait */
        if ((err = socket_waitfd(ps, WAITFD_R, tm)) != IO_DONE) return err;
    }
}

/*-------------------------------------------------------------------------*\
* Send with timeout
* On windows, if you try to send 10MB, the OS will buffer EVERYTHING
* this can take an awful lot of time and we will end up blocked.
* Therefore, whoever calls this function should not pass a huge buffer.
\*-------------------------------------------------------------------------*/
int socket_send(p_socket ps, const char *data, size_t count,
        size_t *sent, p_timeout tm)
{
    int err;
    *sent = 0;
    /* avoid making system calls on closed sockets */
    if (*ps == SOCKET_INVALID) return IO_CLOSED;
    /* loop until we send something or we give up on error */
    for ( ;; ) {
        /* try to send something */
        int put = send(*ps, data, (int) count, 0);
        /* if we sent something, we are done */
        if (put > 0) {
            *sent = put;
            return IO_DONE;
        }
        /* deal with failure */
        err = WSAGetLastError();
        /* we can only proceed if there was no serious error */
        if (err != WSAEWOULDBLOCK) return err;
        /* avoid busy wait */
        if ((err = socket_waitfd(ps, WAITFD_W, tm)) != IO_DONE) return err;
    }
}

/*-------------------------------------------------------------------------*\
* Sendto with timeout
\*-------------------------------------------------------------------------*/
int socket_sendto(p_socket ps, const char *data, size_t count, size_t *sent,
        SA *addr, socklen_t len, p_timeout tm)
{
    int err;
    *sent = 0;
    if (*ps == SOCKET_INVALID) return IO_CLOSED;
    for ( ;; ) {
        int put = sendto(*ps, data, (int) count, 0, addr, len);
        if (put > 0) {
            *sent = put;
            return IO_DONE;
        }
        err = WSAGetLastError();
        if (err != WSAEWOULDBLOCK) return err;
        if ((err = socket_waitfd(ps, WAITFD_W, tm)) != IO_DONE) return err;
    }
}

/*-------------------------------------------------------------------------*\
* Receive with timeout
\*-------------------------------------------------------------------------*/
int socket_recv(p_socket ps, char *data, size_t count, size_t *got,
        p_timeout tm)
{
    int err, prev = IO_DONE;
    *got = 0;
    if (*ps == SOCKET_INVALID) return IO_CLOSED;
    for ( ;; ) {
        int taken = recv(*ps, data, (int) count, 0);
        if (taken > 0) {
            *got = taken;
            return IO_DONE;
        }
        if (taken == 0) return IO_CLOSED;
        err = WSAGetLastError();
        /* On UDP, a connreset simply means the previous send failed.
         * So we try again.
         * On TCP, it means our socket is now useless, so the error passes.
         * (We will loop again, exiting because the same error will happen) */
        if (err != WSAEWOULDBLOCK) {
            if (err != WSAECONNRESET || prev == WSAECONNRESET) return err;
            prev = err;
        }
        if ((err = socket_waitfd(ps, WAITFD_R, tm)) != IO_DONE) return err;
    }
}

/*-------------------------------------------------------------------------*\
* Recvfrom with timeout
\*-------------------------------------------------------------------------*/
int socket_recvfrom(p_socket ps, char *data, size_t count, size_t *got,
        SA *addr, socklen_t *len, p_timeout tm)
{
    int err, prev = IO_DONE;
    *got = 0;
    if (*ps == SOCKET_INVALID) return IO_CLOSED;
    for ( ;; ) {
        int taken = recvfrom(*ps, data, (int) count, 0, addr, len);
        if (taken > 0) {
            *got = taken;
            return IO_DONE;
        }
        if (taken == 0) return IO_CLOSED;
        err = WSAGetLastError();
        /* On UDP, a connreset simply means the previous send failed.
         * So we try again.
         * On TCP, it means our socket is now useless, so the error passes.
         * (We will loop again, exiting because the same error will happen) */
        if (err != WSAEWOULDBLOCK) {
            if (err != WSAECONNRESET || prev == WSAECONNRESET) return err;
            prev = err;
        }
        if ((err = socket_waitfd(ps, WAITFD_R, tm)) != IO_DONE) return err;
    }
}

/*-------------------------------------------------------------------------*\
* Put socket into blocking mode
\*-------------------------------------------------------------------------*/
void socket_setblocking(p_socket ps) {
    u_long argp = 0;
    ioctlsocket(*ps, FIONBIO, &argp);
}

/*-------------------------------------------------------------------------*\
* Put socket into non-blocking mode
\*-------------------------------------------------------------------------*/
void socket_setnonblocking(p_socket ps) {
    u_long argp = 1;
    ioctlsocket(*ps, FIONBIO, &argp);
}

/*-------------------------------------------------------------------------*\
* DNS helpers
\*-------------------------------------------------------------------------*/
int socket_gethostbyaddr(const char *addr, socklen_t len, struct hostent **hp) {
    *hp = gethostbyaddr(addr, len, AF_INET);
    if (*hp) return IO_DONE;
    else return WSAGetLastError();
}

int socket_gethostbyname(const char *addr, struct hostent **hp) {
    *hp = gethostbyname(addr);
    if (*hp) return IO_DONE;
    else return  WSAGetLastError();
}

/*-------------------------------------------------------------------------*\
* Error translation functions
\*-------------------------------------------------------------------------*/
const char *socket_hoststrerror(int err) {
    if (err <= 0) return io_strerror(err);
    switch (err) {
        case WSAHOST_NOT_FOUND: return PIE_HOST_NOT_FOUND;
        default: return wstrerror(err);
    }
}

const char *socket_strerror(int err) {
    if (err <= 0) return io_strerror(err);
    switch (err) {
        case WSAEADDRINUSE: return PIE_ADDRINUSE;
        case WSAECONNREFUSED : return PIE_CONNREFUSED;
        case WSAEISCONN: return PIE_ISCONN;
        case WSAEACCES: return PIE_ACCESS;
        case WSAECONNABORTED: return PIE_CONNABORTED;
        case WSAECONNRESET: return PIE_CONNRESET;
        case WSAETIMEDOUT: return PIE_TIMEDOUT;
        default: return wstrerror(err);
    }
}

const char *socket_ioerror(p_socket ps, int err) {
    (void) ps;
    return socket_strerror(err);
}

static const char *wstrerror(int err) {
    switch (err) {
        case WSAEINTR: return "Interrupted function call";
        case WSAEACCES: return PIE_ACCESS; // "Permission denied";
        case WSAEFAULT: return "Bad address";
        case WSAEINVAL: return "Invalid argument";
        case WSAEMFILE: return "Too many open files";
        case WSAEWOULDBLOCK: return "Resource temporarily unavailable";
        case WSAEINPROGRESS: return "Operation now in progress";
        case WSAEALREADY: return "Operation already in progress";
        case WSAENOTSOCK: return "Socket operation on nonsocket";
        case WSAEDESTADDRREQ: return "Destination address required";
        case WSAEMSGSIZE: return "Message too long";
        case WSAEPROTOTYPE: return "Protocol wrong type for socket";
        case WSAENOPROTOOPT: return "Bad protocol option";
        case WSAEPROTONOSUPPORT: return "Protocol not supported";
        case WSAESOCKTNOSUPPORT: return PIE_SOCKTYPE; // "Socket type not supported";
        case WSAEOPNOTSUPP: return "Operation not supported";
        case WSAEPFNOSUPPORT: return "Protocol family not supported";
        case WSAEAFNOSUPPORT: return PIE_FAMILY; // "Address family not supported by protocol family";
        case WSAEADDRINUSE: return PIE_ADDRINUSE; // "Address already in use";
        case WSAEADDRNOTAVAIL: return "Cannot assign requested address";
        case WSAENETDOWN: return "Network is down";
        case WSAENETUNREACH: return "Network is unreachable";
        case WSAENETRESET: return "Network dropped connection on reset";
        case WSAECONNABORTED: return "Software caused connection abort";
        case WSAECONNRESET: return PIE_CONNRESET; // "Connection reset by peer";
        case WSAENOBUFS: return "No buffer space available";
        case WSAEISCONN: return PIE_ISCONN; // "Socket is already connected";
        case WSAENOTCONN: return "Socket is not connected";
        case WSAESHUTDOWN: return "Cannot send after socket shutdown";
        case WSAETIMEDOUT: return PIE_TIMEDOUT; // "Connection timed out";
        case WSAECONNREFUSED: return PIE_CONNREFUSED; // "Connection refused";
        case WSAEHOSTDOWN: return "Host is down";
        case WSAEHOSTUNREACH: return "No route to host";
        case WSAEPROCLIM: return "Too many processes";
        case WSASYSNOTREADY: return "Network subsystem is unavailable";
        case WSAVERNOTSUPPORTED: return "Winsock.dll version out of range";
        case WSANOTINITIALISED:
            return "Successful WSAStartup not yet performed";
        case WSAEDISCON: return "Graceful shutdown in progress";
        case WSAHOST_NOT_FOUND: return PIE_HOST_NOT_FOUND; // "Host not found";
        case WSATRY_AGAIN: return "Nonauthoritative host not found";
        case WSANO_RECOVERY: return PIE_FAIL; // "Nonrecoverable name lookup error";
        case WSANO_DATA: return "Valid name, no data record of requested type";
        default: return "Unknown error";
    }
}

const char *socket_gaistrerror(int err) {
    if (err == 0) return NULL;
    switch (err) {
        case EAI_AGAIN: return PIE_AGAIN;
        case EAI_BADFLAGS: return PIE_BADFLAGS;
#ifdef EAI_BADHINTS
        case EAI_BADHINTS: return PIE_BADHINTS;
#endif
        case EAI_FAIL: return PIE_FAIL;
        case EAI_FAMILY: return PIE_FAMILY;
        case EAI_MEMORY: return PIE_MEMORY;
        case EAI_NONAME: return PIE_NONAME;
#ifdef EAI_OVERFLOW
        case EAI_OVERFLOW: return PIE_OVERFLOW;
#endif
#ifdef EAI_PROTOCOL
        case EAI_PROTOCOL: return PIE_PROTOCOL;
#endif
        case EAI_SERVICE: return PIE_SERVICE;
        case EAI_SOCKTYPE: return PIE_SOCKTYPE;
#ifdef EAI_SYSTEM
        case EAI_SYSTEM: return strerror(errno);
#endif
        default: return gai_strerror(err);
    }
}

```

`src/Lua/socket/wsocket.h`:

```h
#ifndef WSOCKET_H
#define WSOCKET_H
/*=========================================================================*\
* Socket compatibilization module for Win32
* LuaSocket toolkit
\*=========================================================================*/

/*=========================================================================*\
* WinSock include files
\*=========================================================================*/
#include <winsock2.h>
#include <ws2tcpip.h>

typedef int socklen_t;
typedef SOCKADDR_STORAGE t_sockaddr_storage;
typedef SOCKET t_socket;
typedef t_socket *p_socket;

#ifndef IPV6_V6ONLY
#define IPV6_V6ONLY 27
#endif

#define SOCKET_INVALID (INVALID_SOCKET)

#ifndef SO_REUSEPORT
#define SO_REUSEPORT SO_REUSEADDR
#endif

#ifndef AI_NUMERICSERV
#define AI_NUMERICSERV (0)
#endif

#endif /* WSOCKET_H */

```

`src/TestingProject/TestingProject.cpp`:

```cpp
#include "pch.h"

void debugPrint(const char* format, ...)
{
    char buffer[1024]{};

    va_list argptr;
    va_start(argptr, format);
    vsprintf_s(buffer, format, argptr);
    va_end(argptr);

    printf("%s", buffer);

    // Remove newline.
    size_t len = strlen(buffer);
    if (len >= 1 && buffer[len - 1] == '\n')
    {
        buffer[len - 1] = '\0';
    }
    OutputDebugStringA(buffer);
}

#pragma optimize("", off)
extern "C" __declspec(noinline) void loop_function()
{
    for (int i = 0; i < 100; i++)
    {
        __nop();
    }
}
#pragma optimize("", on)

int main(int argc, const char* argv[])
{
    for (int i = 0; i < argc; i++)
    {
        debugPrint("argv[%d] = %s\n", i, argv[i]);
    }
    
    char currentDir[MAX_PATH]{};
    GetCurrentDirectoryA(sizeof(currentDir), currentDir);
    debugPrint("cwd: %s\n", currentDir);

    loop_function();
}

```

`src/TestingProject/TestingProject.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>TestingProject</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)..\bin\x64d\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)..\bin\x32d\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)..\bin\x32\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)..\bin\x64\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="TestingProject.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/TestingProject/TestingProject.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TestingProject.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`src/TestingProject/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`src/TestingProject/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#include <iostream>
#include <varargs.h>
#include <stdint.h>
#include <intrin.h>

#endif //PCH_H

```

`src/luasocketforwarder/luasocketforwarder.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.40629.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "luasocketforwarder", "luasocketforwarder\luasocketforwarder.vcxproj", "{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}.Debug|Win32.ActiveCfg = Debug|Win32
		{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}.Debug|Win32.Build.0 = Debug|Win32
		{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}.Debug|x64.ActiveCfg = Debug|x64
		{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}.Debug|x64.Build.0 = Debug|x64
		{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}.Release|Win32.ActiveCfg = Release|Win32
		{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}.Release|Win32.Build.0 = Release|Win32
		{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}.Release|x64.ActiveCfg = Release|x64
		{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`src/luasocketforwarder/luasocketforwarder/luasocketforwarder.cpp`:

```cpp
#ifdef _WIN64
#pragma comment(linker, "/export:luaopen_socket_core=x64dbgPlaytime.dp64.luaopen_socket_core")
#pragma comment(linker, "/export:luaopen_mime_core=x64dbgPlaytime.dp64.luaopen_mime_core")
#pragma comment(linker, "/export:luaopen_bit=x64dbgPlaytime.dp64.luaopen_bit")
#else
#pragma comment(linker, "/export:luaopen_socket_core=x64dbgPlaytime.dp32.luaopen_socket_core")
#pragma comment(linker, "/export:luaopen_mime_core=x64dbgPlaytime.dp32.luaopen_mime_core")
#pragma comment(linker, "/export:luaopen_bit=x64dbgPlaytime.dp32.luaopen_bit")
#endif //_WIN64
```

`src/luasocketforwarder/luasocketforwarder/luasocketforwarder.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{6AE7E08E-4AC4-4BA8-A641-D2B8FB720DFF}</ProjectGuid>
    <RootNamespace>luasocketforwarder</RootNamespace>
    <ProjectName>core</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Windows</SubSystem>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Windows</SubSystem>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Windows</SubSystem>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <SubSystem>Windows</SubSystem>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="luasocketforwarder.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/luasocketforwarder/luasocketforwarder/luasocketforwarder.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="luasocketforwarder.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`src/x64dbgPlaytime.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27130.2026
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "x64dbgPlaytime", "x64dbgPlaytime\x64dbgPlaytime.vcxproj", "{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}"
	ProjectSection(ProjectDependencies) = postProject
		{6166F81A-7E2E-42D1-B552-9C8763E0A884} = {6166F81A-7E2E-42D1-B552-9C8763E0A884}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Lua", "Lua\Lua.vcxproj", "{6166F81A-7E2E-42D1-B552-9C8763E0A884}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestingProject", "TestingProject\TestingProject.vcxproj", "{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Debug|x64.ActiveCfg = Debug|x64
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Debug|x64.Build.0 = Debug|x64
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Debug|x86.ActiveCfg = Debug|Win32
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Debug|x86.Build.0 = Debug|Win32
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Release|x64.ActiveCfg = Release|x64
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Release|x64.Build.0 = Release|x64
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Release|x86.ActiveCfg = Release|Win32
		{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}.Release|x86.Build.0 = Release|Win32
		{6166F81A-7E2E-42D1-B552-9C8763E0A884}.Debug|x64.ActiveCfg = Debug|x64
		{6166F81A-7E2E-42D1-B552-9C8763E0A884}.Debug|x64.Build.0 = Debug|x64
		{6166F81A-7E2E-42D1-B552-9C8763E0A884}.Debug|x86.ActiveCfg = Debug|Win32
		{6166F81A-7E2E-42D1-B552-9C8763E0A884}.Debug|x86.Build.0 = Debug|Win32
		{6166F81A-7E2E-42D1-B552-9C8763E0A884}.Release|x64.ActiveCfg = Release|x64
		{6166F81A-7E2E-42D1-B552-9C8763E0A884}.Release|x64.Build.0 = Release|x64
		{6166F81A-7E2E-42D1-B552-9C8763E0A884}.Release|x86.ActiveCfg = Release|Win32
		{6166F81A-7E2E-42D1-B552-9C8763E0A884}.Release|x86.Build.0 = Release|Win32
		{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}.Debug|x64.ActiveCfg = Debug|x64
		{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}.Debug|x64.Build.0 = Debug|x64
		{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}.Debug|x86.ActiveCfg = Debug|Win32
		{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}.Debug|x86.Build.0 = Debug|Win32
		{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}.Release|x64.ActiveCfg = Release|x64
		{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}.Release|x64.Build.0 = Release|x64
		{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}.Release|x86.ActiveCfg = Release|Win32
		{D870EFCB-6D0F-4988-A656-D1EA6017A2AF}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7CBE0759-B87E-4C61-AC7C-E816435EE215}
	EndGlobalSection
EndGlobal

```

`src/x64dbgPlaytime/lua_assembler.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"

#include <windows.h>

static int lua_assembler_encode(lua_State *L)
{
    duint addr = (duint)lua_tointeger(L, 1);
    const char *instr = lua_tostring(L, 2);

    uint8_t dest[16];
    int outputSize = 0;
    char error[MAX_ERROR_SIZE];

    if (Script::Assembler::AssembleEx(addr, dest, &outputSize, instr, error))
    {
        lua_pushlstring(L, (const char*)dest, outputSize);
        lua_pushnil(L);
    }
    else
    {
        lua_pushnil(L);
        lua_pushstring(L, error);
    }

    return 2;
}

static const luaL_Reg lua_assembler[] =
{
    { "encode", lua_assembler_encode },
    { nullptr, nullptr },
};

bool luaopen_assembler(lua_State *L, bool debugState)
{
    luaL_newlib(L, lua_assembler);
    lua_setglobal(L, "assembler");

    return true;
}

```

`src/x64dbgPlaytime/lua_bootstrap.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"
#include "utils.h"

static constexpr const char* CoreScripts[] =
{
    "core\\init.lua",
};

bool luaopen_x64dbg_bootstrap(lua_State *L, bool debugState)
{
    std::string basePath = g_pLuaContext->getBasePath();

    bool res = true;

    const uint32_t countCoreFiles = _countof(CoreScripts);
    dprintf("Loading %u core scripts\n", countCoreFiles);

    for (uint32_t i = 0; i < countCoreFiles; i++)
    {
        const char *coreScript = CoreScripts[i];

        std::string scriptPath = Utils::pathCombine(basePath, coreScript);

        res = g_pLuaContext->runFile(scriptPath.c_str(), true);
    }

    return res;
}

```

`src/x64dbgPlaytime/lua_bps.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"

#include <windows.h>

static int lua_bps_add(lua_State *L)
{
    duint addr = lua_tointeger(L, 1);

    bool res = Script::Debug::SetBreakpoint(addr);
    lua_pushboolean(L, res);

    return 1;
}

static int lua_bps_remove(lua_State *L)
{
    duint addr = lua_tointeger(L, 1);

    bool res = Script::Debug::DeleteBreakpoint(addr);
    lua_pushboolean(L, res);

    return 1;
}

static int lua_bps_disable(lua_State *L)
{
    duint addr = lua_tointeger(L, 1);

    bool res = Script::Debug::DisableBreakpoint(addr);
    lua_pushboolean(L, res);

    return 1;
}

static const luaL_Reg lua_bps[] =
{
    { "add", lua_bps_add },
    { "remove", lua_bps_remove },
    { "disable", lua_bps_disable },
    { nullptr, nullptr },
};

bool luaopen_bps(lua_State *L, bool debugState)
{
    luaL_newlib(L, lua_bps);
    lua_setglobal(L, "bps");

    return true;
}

```

`src/x64dbgPlaytime/lua_constants.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"
#include "pluginsdk/_scriptapi_memory.h"

static void define_constant(lua_State *L, const char *name, lua_Integer val)
{
    lua_pushinteger(L, val);
    lua_setglobal(L, name);
}

static void define_constant_bool(lua_State *L, const char *name, bool val)
{
    lua_pushboolean(L, val);
    lua_setglobal(L, name);
}

bool luaopen_constants(lua_State *L, bool debugState)
{
    // Flags
    define_constant(L, "EFL_C", 1 << 0);
    define_constant(L, "EFL_P", 1 << 2);
    define_constant(L, "EFL_A", 1 << 4);
    define_constant(L, "EFL_Z", 1 << 6);
    define_constant(L, "EFL_S", 1 << 7);
    define_constant(L, "EFL_T", 1 << 8);
    define_constant(L, "EFL_I", 1 << 9);
    define_constant(L, "EFL_D", 1 << 10);
    define_constant(L, "EFL_O", 1 << 11);

    define_constant_bool(L, "IS_DEBUGGING", debugState);

    return true;
}

```

`src/x64dbgPlaytime/lua_context.cpp`:

```cpp
#include "lua_context.hpp"
#include "plugin.h"
#include "utils.h"

// Global instance.
LuaContext* g_pLuaContext = nullptr;

LuaContext::LuaContext()
    : _globalState(nullptr),
    _scriptState(LuaScriptState::IDLE)
{
}

LuaContext::~LuaContext()
{
    shutdownGlobalState();
}

void LuaContext::update()
{
}

void LuaContext::setBasePath(const std::string& path)
{
    _basePath = path;
}

const std::string& LuaContext::getBasePath() const
{
    return _basePath;
}

bool LuaContext::openLibraries(bool debugState)
{
    extern bool luaopen_registers(lua_State *L, bool debugState);
    extern bool luaopen_x64dbgprint(lua_State *L, bool debugState);
    extern bool luaopen_debugger(lua_State *L, bool debugState);
    extern bool luaopen_memory(lua_State *L, bool debugState);
    extern bool luaopen_constants(lua_State *L, bool debugState);
    extern bool luaopen_utils(lua_State *L, bool debugState);
    extern bool luaopen_labels(lua_State *L, bool debugState);
    extern bool luaopen_modules(lua_State *L, bool debugState);
    extern bool luaopen_xrefs(lua_State *L, bool debugState);
    extern bool luaopen_bps(lua_State *L, bool debugState);
    extern bool luaopen_globals(lua_State *L, bool debugState);
    extern bool luaopen_assembler(lua_State *L, bool debugState);

    luaopen_debugger(_globalState, debugState);
    luaopen_constants(_globalState, debugState);
    luaopen_x64dbgprint(_globalState, debugState);
    luaopen_registers(_globalState, debugState);
    luaopen_utils(_globalState, debugState);
    luaopen_memory(_globalState, debugState);
    luaopen_labels(_globalState, debugState);
    luaopen_modules(_globalState, debugState);
    luaopen_xrefs(_globalState, debugState);
    luaopen_bps(_globalState, debugState);
    luaopen_globals(_globalState, debugState);
    luaopen_assembler(_globalState, debugState);
    loadCoreScripts();

    return true;
}

bool LuaContext::loadCoreScripts()
{
    extern bool luaopen_x64dbg_bootstrap(lua_State *L, bool debugState);

    if (!luaopen_x64dbg_bootstrap(_globalState, false))
    {
        return false;
    }

    return true;
}

bool LuaContext::createGlobalState()
{
    if(_globalState != nullptr)
        return false;

    _globalState = luaL_newstate();
    //lua_sethook(_globalState, LuaContext::luaDebugCallback, LUA_MASKCALL | LUA_MASKCOUNT | LUA_MASKLINE| LUA_MASKRET, 0);

    if(!_globalState)
        return false;

    luaL_openlibs(_globalState);

    // x64dbg specific.
    openLibraries(false);

    return true;
}

bool LuaContext::shutdownGlobalState()
{
    if (_globalState)
    {
        lua_close(_globalState);
        _globalState = nullptr;

        return true;
    }

    return false;
}

bool LuaContext::createDebugState(uint32_t processId)
{
    openLibraries(true);
    return true;
}

bool LuaContext::shutdownDebugState(uint32_t processId)
{
    openLibraries(false);
    return true;
}

bool LuaContext::runFile(const char *file, bool registerAutoupdate /* = false*/)
{
    if (!_globalState)
        return false;

    std::vector<uint8_t> scriptData;

    dprintf("Loading script: %s\n", file);

    if (!Utils::readFileContents(file, "rt", scriptData))
    {
        dprintf("Unable to open file: %s\n", file);
        return false;
    }

    // Make sure the string is null terminated.
    scriptData.push_back(0);

    std::string path = Utils::removeFileNameFromPath(file);
    std::string fileName = Utils::getFileNameFromPath(file);

    return runString((const char*)scriptData.data(), path.c_str(), fileName.c_str());
}

bool LuaContext::runString(const char *lua, const char *path, const char *scriptName)
{
    std::string fullPath = "@" + Utils::pathCombine(path, scriptName);
    std::string currentPath;
    std::string currentScript;

    int res = luaL_loadbuffer(_globalState, lua, strlen(lua), fullPath.c_str());
    if (!processError(res, _globalState))
    {
        return false;
    }

    // Retrieve current path/name.
    {
        lua_getglobal(_globalState, "_SCRIPT_PATH");
        currentPath = lua_isstring(_globalState, -1) ? lua_tostring(_globalState, -1) : "";

        lua_getglobal(_globalState, "_SCRIPT_NAME");
        currentScript = lua_isstring(_globalState, -1) ? lua_tostring(_globalState, -1) : "";

        lua_pop(_globalState, 2);
    }

    // Assign new current path/name
    {
        lua_pushstring(_globalState, path);
        lua_setglobal(_globalState, "_SCRIPT_PATH");

        lua_pushstring(_globalState, scriptName);
        lua_setglobal(_globalState, "_SCRIPT_NAME");
    }
    
    // Execute.
    res = protectedLuaCall() ? 1 : 0;

    // Restore previous path/name
    {
        lua_pushstring(_globalState, currentPath.c_str());
        lua_setglobal(_globalState, "_SCRIPT_PATH");

        lua_pushstring(_globalState, currentScript.c_str());
        lua_setglobal(_globalState, "_SCRIPT_NAME");
    }

    return res == 1;
}

bool LuaContext::protectedLuaCall(int numArgs /*= 0*/, int numReturns /*= 0*/)
{
    _scriptState = LuaScriptState::RUNNING;

    int res = lua_pcall(_globalState, numArgs, numReturns, 0);
    if (!processError(res, _globalState))
    {
        _scriptState = LuaScriptState::IDLE;
        return false;
    }

    _scriptState = LuaScriptState::IDLE;

    return true;
}

bool LuaContext::processError(int res, lua_State *L)
{
    bool isError = (res != 0);

    if (isError)
    {
        const char *pszError = lua_tostring(L, -1);
        if (pszError)
        {
            dprintf("Lua Error: %s\n", pszError);
        }

        // Get rid of the error on stack.
        lua_pop(L, 1);

        return false;
    }

    return true;
}

void LuaContext::debugHook(lua_State *L, lua_Debug *debug)
{
    switch (debug->event)
    {
    case LUA_HOOKLINE:
    case LUA_HOOKCALL:
    case LUA_HOOKRET:
        break;
    }
}

void LuaContext::panic(lua_State *L)
{
    const char* pszError = lua_tostring(L, 1);
    if (pszError)
    {
        dprintf("Lua Panic: %s\n", pszError);
    }
}

bool LuaContext::executeAutorunScripts()
{
    std::vector<std::string> loadQueue;

    std::string autorunPath = Utils::pathCombine(_basePath, "autorun");

    // Queue up all single lua files.
    std::vector<Utils::DirectoryEntry_t> luaFiles = Utils::readDirectory(autorunPath, "*.lua");
    for (const auto& file : luaFiles)
    {
        loadQueue.push_back(file.fullFilePath);
    }

    // Queue up directory ones.
    std::vector<Utils::DirectoryEntry_t> luaDirs = Utils::readDirectory(autorunPath, "*.*");
    for (const auto& file : luaDirs)
    {
        if (file.isDirectory)
        {
            loadQueue.push_back(Utils::pathCombine(file.fullFilePath, "init.lua"));
        }
    }

    dprintf("Loading %u autostart scripts\n", (uint32_t)loadQueue.size());

    for (auto& queued : loadQueue)
    {
        runFile(queued.c_str(), true);
    }

    return true;
}

```

`src/x64dbgPlaytime/lua_context.hpp`:

```hpp
#ifndef LUA_CONTEXT_HPP
#define LUA_CONTEXT_HPP

#include "lua.hpp"

#include <stdint.h>
#include <string>
#include <vector>

class LuaContext;

extern LuaContext* g_pLuaContext;

enum class LuaScriptState : uint8_t
{
    IDLE = 0,
    RUNNING,
};

struct LuaDebugState
{
    uint32_t processId;
    lua_State *L;
};

class LuaContext
{
private:
    lua_State* _globalState;
    LuaScriptState _scriptState;
    std::string _basePath;

 public:
    LuaContext();
    ~LuaContext();

    void update();
    void setBasePath(const std::string& path);
    const std::string& getBasePath() const;

    bool openLibraries(bool debugState);
    bool loadCoreScripts();

    bool createGlobalState();
    bool shutdownGlobalState();

    bool createDebugState(uint32_t processId);
    bool shutdownDebugState(uint32_t processId);

    bool runFile(const char *file, bool registerAutoupdate = false);
    bool runString(const char *lua, const char *path = "", const char *scriptName = "RUNSTRING");
    bool executeAutorunScripts();
    bool protectedLuaCall(int numParams = 0, int numReturns = 0);

    LuaScriptState getScriptState()
    {
        return _scriptState;
    }

private:
    static void luaDebugCallback(lua_State *L, lua_Debug *Debug)
    {
        g_pLuaContext->debugHook(L, Debug);
    }

    static void luaPanicCallback(lua_State *L)
    {
        g_pLuaContext->panic(L);
    }

private:
    bool processError(int res, lua_State *L);
    void debugHook(lua_State *L, lua_Debug *debug);
    void panic(lua_State *L);
};

#define luaL_checktable(L,n)      (luaL_checktype(L, (n), LUA_TTABLE))

#endif // LUA_CONTEXT_HPP

```

`src/x64dbgPlaytime/lua_debugger.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "lua_table_utils.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"
#include "utils.h"

#include <windows.h>
#include <unordered_map>
#include <stdint.h>
#include <string>
#include <functional>
#include <algorithm>

static int lua_debugger_stepOver(lua_State *L)
{
    bool waitForPause = lua_isboolean(L, 1) ? lua_toboolean(L, 1) : true;
    bool res = DbgCmdExecDirect("sto");

    if (res && waitForPause)
        _plugin_waituntilpaused();

    lua_pushboolean(L, res);
    return 0;
}

static int lua_debugger_stepIn(lua_State *L)
{
    bool waitForPause = lua_isboolean(L, 1) ? lua_toboolean(L, 1) : true;
    bool res = DbgCmdExecDirect("sti");

    if (res && waitForPause)
        _plugin_waituntilpaused();

    lua_pushboolean(L, res);
    return 0;
}

static int lua_debugger_run(lua_State *L)
{
    bool waitForPause = lua_isboolean(L, 1) ? lua_toboolean(L, 1) : true;
    bool res = DbgCmdExecDirect("run");

    if (res && waitForPause)
        _plugin_waituntilpaused();

    lua_pushboolean(L, res);
    return 1;
}

static int lua_debugger_isRunning(lua_State *L)
{
    lua_pushboolean(L, DbgIsRunning());
    return 1;
}

static int lua_debugger_wait(lua_State *L)
{
    _plugin_waituntilpaused();
    return 0;
}

static int lua_debugger_switchThread(lua_State *L)
{
    lua_Integer threadId = lua_tointeger(L, 1);

    char cmd[128] = {};
    sprintf_s(cmd, "switchthread %X", (uint32_t)threadId);

    bool res = DbgCmdExecDirect(cmd);
    lua_pushboolean(L, res);

    return 1;
}

static int lua_debugger_start(lua_State *L)
{
    if (lua_istable(L, 1) == false)
    {
        luaL_error(L, "Table expected for paramter 1");
    }

    lua_pushvalue(L, 1);
    std::string executable = lua_table_getfield_string(L, "executable");
    std::string arguments = lua_table_haskey(L, "arguments") ? lua_table_getfield_string(L, "arguments") : "";
    std::string directory = lua_table_haskey(L, "directory") ? lua_table_getfield_string(L, "directory") : "";
    bool waitForPause = lua_table_haskey(L, "wait") ? lua_table_getfield_boolean(L, "wait") : false;
    lua_pop(L, 1);

    std::string cmd = "InitDebug \"" + executable + "\"";
    if (arguments.empty() == false)
    {
        cmd += ",\"" + Utils::escapeQuotes(arguments) + "\"";
    }
    if (directory.empty() == false)
    {
        cmd += ",\"" + directory + "\"";
    }

    bool res = DbgCmdExec(cmd.c_str());

    if (res && waitForPause)
        _plugin_waituntilpaused();

    lua_pushboolean(L, res);

    return 1;
}

static int lua_debugger_stop(lua_State *L)
{
    bool res = DbgCmdExecDirect("stop");
    lua_pushboolean(L, res);

    return 1;
}

static const luaL_Reg lua_debugger_global[] =
{
    { "start", lua_debugger_start },
    { nullptr, nullptr },
};

static const luaL_Reg lua_debugger[] =
{
    { "stepOver", lua_debugger_stepOver },
    { "stepIn", lua_debugger_stepIn },
    { "run", lua_debugger_run },
    { "wait", lua_debugger_wait },
    { "isRunning", lua_debugger_isRunning },
    { "switchThread", lua_debugger_switchThread },
    { "stop", lua_debugger_stop },
    { nullptr, nullptr },
};

bool luaopen_debugger(lua_State *L, bool debugState)
{
    if(debugState)
        luaL_newlib(L, lua_debugger);
    else
        luaL_newlib(L, lua_debugger_global);
    lua_setglobal(L, "debugger");
    return true;
}

```

`src/x64dbgPlaytime/lua_globals.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"
#include "utils.h"

static int lua_include(lua_State *L)
{
    std::string includeFile = lua_tostring(L, 1);

    lua_getglobal(L, "_SCRIPT_PATH");
    std::string currentPath = lua_isstring(L, -1) ? lua_tostring(L, -1) : "";

    if(currentPath.empty())
        currentPath = g_pLuaContext->getBasePath();

    std::string includeFilePath = Utils::pathCombine(currentPath, includeFile);

    bool res = g_pLuaContext->runFile(includeFilePath.c_str(), true);
    lua_pushboolean(L, res);

    return 1;
}

bool luaopen_globals(lua_State *L, bool debugState)
{
    lua_pushcfunction(L, lua_include);
    lua_setglobal(L, "include");

    return true;
}

```

`src/x64dbgPlaytime/lua_labels.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"
#include "pluginsdk/_scriptapi_label.h"

/*
SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
SCRIPT_EXPORT bool Set(const LabelInfo* info);
SCRIPT_EXPORT bool FromString(const char* label, duint* addr);
SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_LABEL_SIZE]
SCRIPT_EXPORT bool GetInfo(duint addr, LabelInfo* info);
SCRIPT_EXPORT bool Delete(duint addr);
SCRIPT_EXPORT void DeleteRange(duint start, duint end);
SCRIPT_EXPORT void Clear();
SCRIPT_EXPORT bool GetList(ListOf(LabelInfo) list); //caller has the responsibility to free the list
*/

static int lua_label_setname(lua_State *L)
{
    lua_Integer addr = lua_tointeger(L, 1);
    const char *name = lua_tostring(L, 2);
    bool manual = false;
    if(lua_isboolean(L, 3))
        manual = lua_toboolean(L, 3);

    bool res = Script::Label::Set((duint)addr, name, manual);

    if (res)
    {
        GuiUpdateAllViews();
    }

    lua_pushboolean(L, res);
    return 1;
}

static int lua_label_getname(lua_State *L)
{
    lua_Integer addr = lua_tointeger(L, 1);

    char name[MAX_LABEL_SIZE] = {};
    bool res = Script::Label::Get((duint)addr, name);
    if(res)
        lua_pushstring(L, name);
    else
        lua_pushnil(L);
    return 1;
}

static int lua_push_labelinfo(lua_State *L, const Script::Label::LabelInfo& info)
{
    lua_newtable(L);
    lua_pushstring(L, "module"); lua_pushstring(L, info.mod);
    lua_rawset(L, -3);
    lua_pushstring(L, "rva"); lua_pushinteger(L, info.rva);
    lua_rawset(L, -3);
    lua_pushstring(L, "text"); lua_pushstring(L, info.text);
    lua_rawset(L, -3);
    lua_pushstring(L, "manual"); lua_pushboolean(L, info.manual);
    lua_rawset(L, -3);
    return 1;
}

static int lua_label_getinfo(lua_State *L)
{
    lua_Integer addr = lua_tointeger(L, 1);

    Script::Label::LabelInfo info = {};
    bool res = Script::Label::GetInfo((duint)addr, &info);
    if (res)
    {
        lua_push_labelinfo(L, info);
    }
    else
    {
        lua_pushnil(L);
    }
    return 1;
}

static int lua_label_remove(lua_State *L)
{
    bool res = false;

    lua_Integer addr = lua_tointeger(L, 1);
    if (lua_isinteger(L, 2))
    {
        lua_Integer addrEnd = lua_tointeger(L, 2);
        Script::Label::DeleteRange((duint)addr, (duint)addrEnd);
        res = true; // Hmm
    }
    else
    {
        res = Script::Label::Delete((duint)addr);
    }

    if (res)
    {
        GuiUpdateAllViews();
    }

    lua_pushboolean(L, res);
    return 1;
}

static int lua_label_getList(lua_State *L)
{
    BridgeList<Script::Label::LabelInfo> list;

    bool res = Script::Label::GetList(&list);
    lua_newtable(L);
    if (res)
    {
        for (int32_t i = 0; i < list.Count(); i++)
        {
            const Script::Label::LabelInfo& info = list[i];
            lua_pushinteger(L, i + 1);
            lua_push_labelinfo(L, info);
            lua_rawset(L, -3);
        }
    }

    return 1;
}

static const luaL_Reg lua_labels[] =
{
    { "setName", lua_label_setname },
    { "getName", lua_label_getname },
    { "getInfo", lua_label_getinfo },
    { "remove", lua_label_remove },
    { "getList", lua_label_getList },
    { nullptr, nullptr },
};

bool luaopen_labels(lua_State *L, bool debugState)
{
    luaL_newlib(L, lua_labels);
    lua_setglobal(L, "labels");

    return true;
}

```

`src/x64dbgPlaytime/lua_memory.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"
#include "pluginsdk/_scriptapi_memory.h"

#include <memory>

static int lua_memory_read(lua_State *L)
{
    lua_Integer addr = lua_tointeger(L, 1);
    lua_Integer len = lua_tointeger(L, 2);

    std::unique_ptr<uint8_t[]> buf(new uint8_t[(size_t)len]);

    duint dataRead = 0;
    if (!Script::Memory::Read(addr, buf.get(), (duint)len, &dataRead))
    {
        lua_pushnil(L);
        lua_pushinteger(L, 0);
    }
    else
    {
        lua_pushlstring(L, (const char*)buf.get(), dataRead);
        lua_pushinteger(L, dataRead);
    }

    return 2;
}

static int lua_memory_write(lua_State *L)
{
    size_t dataSize;
    lua_Integer addr = lua_tointeger(L, 1);
    const char *buf = luaL_tolstring(L, 2, &dataSize);

    duint dataWritten = 0;
    if (!Script::Memory::Write((duint)addr, buf, dataSize, &dataWritten))
    {
        lua_pushinteger(L, 0);
    }
    else
    {
        lua_pushinteger(L, dataWritten);
    }

    return 1;
}

template<typename T>
static int TypePtrMeta_Index(lua_State *L)
{
    luaL_checktable(L, 1);
    lua_Integer addr = lua_tointeger(L, 2);

    T res = 0;

    duint dataRead = 0;
    if (!Script::Memory::Read((duint)addr, &res, sizeof(T), &dataRead) || dataRead != sizeof(T))
    {
        lua_pushnil(L);
    }
    else
    {
        lua_pushinteger(L, res);
    }

    return 1;
}

template<typename T>
static int TypePtrMeta_NewIndex(lua_State *L)
{
    luaL_checktable(L, 1);

    lua_Integer addr = lua_tointeger(L, 2);
    lua_Integer val = lua_tointeger(L, 3);

    T ulValue = static_cast<T>(val);

    duint dataWritten = 0;
    if (!Script::Memory::Write((duint)addr, &ulValue, sizeof(T), &dataWritten) || dataWritten != sizeof(T))
    {
        // HMM
    }

    GuiUpdateMemoryView();
    GuiUpdateDisassemblyView();

    return 0;
}

static const luaL_Reg lua_memory[] =
{
    { "read", lua_memory_read },
    { "write", lua_memory_write },
    { nullptr, nullptr },
};

bool luaopen_memory(lua_State *L, bool debugState)
{
    luaL_newlib(L, lua_memory);
    lua_setglobal(L, "memory");

    // QWORD_PTR Metatable
    lua_newtable(L);
    {
        lua_pushvalue(L, -1);	// Backup of table.

        luaL_newmetatable(L, "qword_ptr");
        {
            lua_pushstring(L, "__index");
            lua_pushcfunction(L, TypePtrMeta_Index<uint64_t>);
            lua_settable(L, -3);

            lua_pushstring(L, "__newindex");
            lua_pushcfunction(L, TypePtrMeta_NewIndex<uint64_t>);
            lua_settable(L, -3);

        } lua_setmetatable(L, -2);	// Pops the table.

    } lua_setglobal(L, "qword_ptr"); // Make table global, pops it again.

    // DWORD_PTR Metatable
    lua_newtable(L);
    {
        lua_pushvalue(L, -1);	// Backup of table.

        luaL_newmetatable(L, "dword_ptr");
        {
            lua_pushstring(L, "__index");
            lua_pushcfunction(L, TypePtrMeta_Index<uint32_t>);
            lua_settable(L, -3);

            lua_pushstring(L, "__newindex");
            lua_pushcfunction(L, TypePtrMeta_NewIndex<uint32_t>);
            lua_settable(L, -3);

        } lua_setmetatable(L, -2);	// Pops the table.

    } lua_setglobal(L, "dword_ptr"); // Make table global, pops it again.

    // WORD_PTR Metatable
    lua_newtable(L);
    {
        lua_pushvalue(L, -1);	// Backup of table.

        luaL_newmetatable(L, "word_ptr");
        {
            lua_pushstring(L, "__index");
            lua_pushcfunction(L, TypePtrMeta_Index<uint16_t>);
            lua_settable(L, -3);

            lua_pushstring(L, "__newindex");
            lua_pushcfunction(L, TypePtrMeta_NewIndex<uint16_t>);
            lua_settable(L, -3);

        } lua_setmetatable(L, -2);	// Pops the table.

    } lua_setglobal(L, "word_ptr"); // Make table global, pops it again.

    // BYTE_PTR Metatable
    lua_newtable(L);
    {
        lua_pushvalue(L, -1);	// Backup of table.

        luaL_newmetatable(L, "byte_ptr");
        {
            lua_pushstring(L, "__index");
            lua_pushcfunction(L, TypePtrMeta_Index<uint8_t>);
            lua_settable(L, -3);

            lua_pushstring(L, "__newindex");
            lua_pushcfunction(L, TypePtrMeta_NewIndex<uint8_t>);
            lua_settable(L, -3);

        } lua_setmetatable(L, -2);	// Pops the table.

    } lua_setglobal(L, "byte_ptr"); // Make table global, pops it again.

    return true;
}

```

`src/x64dbgPlaytime/lua_modules.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"
#include "pluginsdk/_scriptapi_module.h"

static int lua_push_modulesectioninfo(lua_State *L, const Script::Module::ModuleSectionInfo& info)
{
    lua_newtable(L);
    lua_pushstring(L, "base"); lua_pushinteger(L, info.addr);
    lua_rawset(L, -3);
    lua_pushstring(L, "size"); lua_pushinteger(L, info.size);
    lua_rawset(L, -3);
    lua_pushstring(L, "name"); lua_pushstring(L, info.name);
    lua_rawset(L, -3);
    return 1;
}

static int lua_push_moduleinfo(lua_State *L, const Script::Module::ModuleInfo& info, bool includeSections = false)
{
    lua_newtable(L);
    lua_pushstring(L, "base"); lua_pushinteger(L, info.base);
    lua_rawset(L, -3);
    lua_pushstring(L, "size"); lua_pushinteger(L, info.size);
    lua_rawset(L, -3);
    lua_pushstring(L, "entrypoint"); lua_pushinteger(L, info.entry);
    lua_rawset(L, -3);
    lua_pushstring(L, "name"); lua_pushstring(L, info.name);
    lua_rawset(L, -3);
    lua_pushstring(L, "path"); lua_pushstring(L, info.path);
    lua_rawset(L, -3);

    if (includeSections == true)
    {
        lua_pushstring(L, "sections");
        lua_newtable(L);
        {
            BridgeList<Script::Module::ModuleSectionInfo> list;
            if (Script::Module::SectionListFromAddr(info.base, &list))
            {
                for (int32_t i = 0; i < list.Count(); i++)
                {
                    const Script::Module::ModuleSectionInfo& info = list[i];
                    lua_pushinteger(L, i + 1);
                    lua_push_modulesectioninfo(L, info);
                    lua_rawset(L, -3);
                }
            }
        }
        lua_rawset(L, -3);
    }

    return 1;
}

/*
static int lua_modules_getSectionList(lua_State *L)
{
    BridgeList<Script::Module::ModuleSectionInfo> list;

    lua_Integer addr = lua_tointeger(L, 1);

    bool res = Script::Module::SectionListFromAddr(addr, &list);
    lua_newtable(L);
    if (res)
    {
        for (int32_t i = 0; i < list.Count(); i++)
        {
            const Script::Module::ModuleSectionInfo& info = list[i];
            lua_pushinteger(L, i + 1);
            lua_push_modulesectioninfo(L, info);
            lua_rawset(L, -3);
        }
    }

    return 1;
}
*/

static int lua_modules_getMain(lua_State *L)
{
    const char *name = lua_tostring(L, 1);

    Script::Module::ModuleInfo info = {};
    bool res = Script::Module::GetMainModuleInfo(&info);
    if (res)
    {
        lua_push_moduleinfo(L, info, true);
    }
    else
    {
        lua_pushnil(L);
    }
    return 1;
}

static int lua_modules_findByAddress(lua_State *L)
{
    lua_Integer addr = lua_tointeger(L, 1);

    Script::Module::ModuleInfo info = {};
    bool res = Script::Module::InfoFromAddr((duint)addr, &info);
    if (res)
    {
        lua_push_moduleinfo(L, info, true);
    }
    else
    {
        lua_pushnil(L);
    }
    return 1;
}

static int lua_modules_findByName(lua_State *L)
{
    const char *name = lua_tostring(L, 1);

    Script::Module::ModuleInfo info = {};
    bool res = Script::Module::InfoFromName(name, &info);
    if (res)
    {
        lua_push_moduleinfo(L, info, true);
    }
    else
    {
        lua_pushnil(L);
    }
    return 1;
}

static int lua_modules_getList(lua_State *L)
{
    BridgeList<Script::Module::ModuleInfo> list;

    bool res = Script::Module::GetList(&list);
    lua_newtable(L);
    if (res)
    {
        for (int32_t i = 0; i < list.Count(); i++)
        {
            const Script::Module::ModuleInfo& info = list[i];
            lua_pushinteger(L, i + 1);
            lua_push_moduleinfo(L, info, true);
            lua_rawset(L, -3);
        }
    }

    return 1;
}

static const luaL_Reg lua_modules[] =
{
    { "getMain", lua_modules_getMain },
    { "findByAddress", lua_modules_findByAddress },
    { "findByName", lua_modules_findByName },
    { "getList", lua_modules_getList },
    { nullptr, nullptr },
};

bool luaopen_modules(lua_State *L, bool debugState)
{
    luaL_newlib(L, lua_modules);
    lua_setglobal(L, "modules");

    return true;
}

```

`src/x64dbgPlaytime/lua_print.cpp`:

```cpp
#include "lua_context.hpp"
#include "plugin.h"

int lua_print(lua_State* L)
{
    int nargs = lua_gettop(L);

    for (int i = 1; i <= nargs; i++)
    {
        if(i > 1)
            _plugin_logprintf("%s", "\t");

        if (lua_isstring(L, i))
        {
            const char *pszStr = lua_tostring(L, i);
            _plugin_logprintf("%s", pszStr);
        }
        else if (lua_isinteger(L, i))
        {
            _plugin_logprintf("%u", lua_tointeger(L, i));
        }
        else if (lua_isnumber(L, i))
        {
            _plugin_logprintf("%f", lua_tonumber(L, i));
        }
        else if (lua_isboolean(L, i))
        {
            _plugin_logprintf("%s", lua_toboolean(L, i) == 1 ? "true" : "false");
        }
        else if (lua_istable(L, i))
        {
            _plugin_logprintf("table(%p)", lua_topointer(L, i));
        }
        else if (lua_isnil(L, i))
        {
            _plugin_logprintf("%s", "<nil>");
        }
        else if (lua_isfunction(L, i))
        {
            _plugin_logprintf("function(%p)", lua_topointer(L, i));
        }
    }

    _plugin_logprintf("\n");

    return 0;
}

bool luaopen_x64dbgprint(lua_State *L, bool debugState)
{
    lua_getglobal(L, "_G");

    lua_pushcfunction(L, lua_print);
    lua_setfield(L, -2, "print");

    lua_setmetatable(L, -2);

    return true;
}

```

`src/x64dbgPlaytime/lua_registers.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"

#include <windows.h>
#include <unordered_map>
#include <stdint.h>
#include <string>
#include <functional>
#include <algorithm>

struct RegisterData_t
{
    size_t offset;
    size_t readSize;
    size_t writeSize;
};

#define REGISTER_RECORD(name, reg, offset, readSize, writeSize) \
    { name, { offsetof(CONTEXT, ##reg##) + offset, readSize, writeSize} }

static const std::unordered_map<std::string, RegisterData_t> RegisterOffsetMap =
{
#ifdef _WIN64
    REGISTER_RECORD("rax", Rax, 0, 64, 64),
    REGISTER_RECORD("eax", Rax, 0, 32, 64),
    REGISTER_RECORD("ax", Rax, 0, 16, 16),
    REGISTER_RECORD("ah", Rax, 1, 8, 8),
    REGISTER_RECORD("al", Rax, 0, 8, 8),

    REGISTER_RECORD("rbx", Rbx, 0, 64, 64),
    REGISTER_RECORD("ebx", Rbx, 0, 32, 64),
    REGISTER_RECORD("bx", Rbx, 0, 16, 16),
    REGISTER_RECORD("bh", Rbx, 1, 8, 8),
    REGISTER_RECORD("bl", Rbx, 0, 8, 8),

    REGISTER_RECORD("rcx", Rcx, 0, 64, 64),
    REGISTER_RECORD("ecx", Rcx, 0, 32, 64),
    REGISTER_RECORD("cx", Rcx, 0, 16, 16),
    REGISTER_RECORD("ch", Rcx, 1, 8, 8),
    REGISTER_RECORD("cl", Rcx, 0, 8, 8),

    REGISTER_RECORD("rdx", Rdx, 0, 64, 64),
    REGISTER_RECORD("edx", Rdx, 0, 32, 64),
    REGISTER_RECORD("dx", Rdx, 0, 16, 16),
    REGISTER_RECORD("dh", Rdx, 1, 8, 8),
    REGISTER_RECORD("dl", Rdx, 0, 8, 8),

    REGISTER_RECORD("rdi", Rdi, 0, 64, 64),
    REGISTER_RECORD("edi", Rdi, 0, 32, 64),
    REGISTER_RECORD("di", Rdi, 0, 16, 16),
    REGISTER_RECORD("dil", Rdi, 0, 8, 8),

    REGISTER_RECORD("rsi", Rsi, 0, 64, 64),
    REGISTER_RECORD("esi", Rsi, 0, 32, 64),
    REGISTER_RECORD("si", Rsi, 0, 16, 16),
    REGISTER_RECORD("sil", Rsi, 0, 8, 8),

    REGISTER_RECORD("rbp", Rbp, 0, 64, 64),
    REGISTER_RECORD("ebp", Rbp, 0, 32, 64),
    REGISTER_RECORD("bp", Rbp, 0, 16, 16),
    REGISTER_RECORD("bpl", Rbp, 0, 8, 8),

    REGISTER_RECORD("rsp", Rsp, 0, 64, 64),
    REGISTER_RECORD("esp", Rsp, 0, 32, 64),
    REGISTER_RECORD("sp", Rsp, 0, 16, 16),
    REGISTER_RECORD("spl", Rsp, 0, 8, 8),

    REGISTER_RECORD("rip", Rip, 0, 64, 64),
    REGISTER_RECORD("eip", Rip, 0, 32, 64),

    REGISTER_RECORD("r8", R8, 0, 64, 64),
    REGISTER_RECORD("r8d", R8, 0, 32, 64),
    REGISTER_RECORD("r8w", R8, 0, 16, 16),
    REGISTER_RECORD("r8b", R8, 0, 8, 8),

    REGISTER_RECORD("r9", R9, 0, 64, 64),
    REGISTER_RECORD("r9d", R9, 0, 32, 64),
    REGISTER_RECORD("r9w", R9, 0, 16, 16),
    REGISTER_RECORD("r9b", R9, 0, 8, 8),

    REGISTER_RECORD("r10", R10, 0, 64, 64),
    REGISTER_RECORD("r10d", R10, 0, 32, 64),
    REGISTER_RECORD("r10w", R10, 0, 16, 16),
    REGISTER_RECORD("r10b", R10, 0, 8, 8),

    REGISTER_RECORD("r11", R11, 0, 64, 64),
    REGISTER_RECORD("r11d", R11, 0, 32, 64),
    REGISTER_RECORD("r11w", R11, 0, 16, 16),
    REGISTER_RECORD("r11b", R11, 0, 8, 8),

    REGISTER_RECORD("r12", R12, 0, 64, 64),
    REGISTER_RECORD("r12d", R12, 0, 32, 64),
    REGISTER_RECORD("r12w", R12, 0, 16, 16),
    REGISTER_RECORD("r12b", R12, 0, 8, 8),

    REGISTER_RECORD("r13", R13, 0, 64, 64),
    REGISTER_RECORD("r13d", R13, 0, 32, 64),
    REGISTER_RECORD("r13w", R13, 0, 16, 16),
    REGISTER_RECORD("r13b", R13, 0, 8, 8),

    REGISTER_RECORD("r14", R14, 0, 64, 64),
    REGISTER_RECORD("r14d", R14, 0, 32, 64),
    REGISTER_RECORD("r14w", R14, 0, 16, 16),
    REGISTER_RECORD("r14b", R14, 0, 8, 8),

    REGISTER_RECORD("r15", R15, 0, 64, 64),
    REGISTER_RECORD("r15d", R15, 0, 32, 64),
    REGISTER_RECORD("r15w", R15, 0, 16, 16),
    REGISTER_RECORD("r15b", R15, 0, 8, 8),

    REGISTER_RECORD("eflags", EFlags, 0, 32, 32),
    REGISTER_RECORD("rflags", EFlags, 0, 32, 32),
#else
    REGISTER_RECORD("eax", Eax, 0, 32, 32),
    REGISTER_RECORD("ax", Eax, 0, 16, 16),
    REGISTER_RECORD("ah", Eax, 1, 8, 8),
    REGISTER_RECORD("al", Eax, 0, 8, 8),

    REGISTER_RECORD("ebx", Ebx, 0, 32, 32),
    REGISTER_RECORD("bx", Ebx, 0, 16, 16),
    REGISTER_RECORD("bh", Ebx, 1, 8, 8),
    REGISTER_RECORD("bl", Ebx, 0, 8, 8),

    REGISTER_RECORD("ecx", Ecx, 0, 32, 32),
    REGISTER_RECORD("cx", Ecx, 0, 16, 16),
    REGISTER_RECORD("ch", Ecx, 1, 8, 8),
    REGISTER_RECORD("cl", Ecx, 0, 8, 8),

    REGISTER_RECORD("edx", Edx, 0, 32, 32),
    REGISTER_RECORD("dx", Edx, 0, 16, 16),
    REGISTER_RECORD("dh", Edx, 1, 8, 8),
    REGISTER_RECORD("dl", Edx, 0, 8, 8),

    REGISTER_RECORD("edi", Edi, 0, 32, 32),
    REGISTER_RECORD("di", Edi, 0, 16, 16),
    REGISTER_RECORD("dil", Edi, 0, 8, 8),

    REGISTER_RECORD("esi", Esi, 0, 32, 32),
    REGISTER_RECORD("si", Esi, 0, 16, 16),
    REGISTER_RECORD("sil", Esi, 0, 8, 8),

    REGISTER_RECORD("ebp", Ebp, 0, 32, 32),
    REGISTER_RECORD("bp", Ebp, 0, 16, 16),
    REGISTER_RECORD("bpl", Ebp, 0, 8, 8),

    REGISTER_RECORD("esp", Esp, 0, 32, 32),
    REGISTER_RECORD("sp", Esp, 0, 16, 16),
    REGISTER_RECORD("spl", Esp, 0, 8, 8),

    REGISTER_RECORD("eip", Eip, 0, 32, 32),

    REGISTER_RECORD("eflags", EFlags, 0, 32, 32),
#endif
};

static uint64_t readRegister(const CONTEXT& ctx, const RegisterData_t& regData)
{
    const uint8_t *ctxBase = reinterpret_cast<const uint8_t*>(&ctx);

    switch (regData.readSize)
    {
    case 64:
        return *(uint64_t*)(ctxBase + regData.offset);
    case 32:
        return *(uint32_t*)(ctxBase + regData.offset);
    case 16:
        return *(uint16_t*)(ctxBase + regData.offset);
    case 8:
        return *(uint8_t*)(ctxBase + regData.offset);
    }

    return 0;
}

static void writeRegister(CONTEXT& ctx, const RegisterData_t& regData, uint64_t value)
{
    uint8_t *ctxBase = reinterpret_cast<uint8_t*>(&ctx);

    switch (regData.writeSize)
    {
    case 64:
        *(uint64_t*)(ctxBase + regData.offset) = value;
        break;
    case 32:
        *(uint32_t*)(ctxBase + regData.offset) = (uint32_t)value;
        break;
    case 16:
        *(uint16_t*)(ctxBase + regData.offset) = (uint16_t)value;
        break;
    case 8:
        *(uint8_t*)(ctxBase + regData.offset) = (uint8_t)value;
        break;
    }
}

static int lua_register_read(lua_State *L)
{
    if (DbgIsDebugging() == false)
    {
        lua_pushnil(L);
        return 1;
    }

    if (lua_isstring(L, 1))
    {
        std::string regName = lua_tostring(L, 1);
        std::transform(regName.begin(), regName.end(), regName.begin(), tolower);

        auto regData = RegisterOffsetMap.find(regName);
        if (regData == RegisterOffsetMap.end())
        {
            lua_pushnil(L);
            return 1;
        }

        HANDLE hThread = DbgGetThreadHandle();

        CONTEXT ctx;
        ctx.ContextFlags = CONTEXT_FULL;
        if (GetThreadContext(hThread, &ctx) == FALSE)
        {
            DWORD lastError = GetLastError();
            dprintf("ERROR: Unable to get thread context: %08X\n", lastError);
            return 0;
        }

        lua_pushinteger(L, readRegister(ctx, regData->second));
    }
    // TODO: Check if thread object and read from there.

    return 1;
}

static int lua_register_write(lua_State *L)
{
    if (DbgIsDebugging() == false)
    {
        return 0;
    }

    if (lua_isstring(L, 1) && lua_isinteger(L, 2))
    {
        std::string regName = lua_tostring(L, 1);
        std::transform(regName.begin(), regName.end(), regName.begin(), tolower);

        const auto regData = RegisterOffsetMap.find(regName);
        if (regData == RegisterOffsetMap.end())
        {
            lua_pushnil(L);
            return 1;
        }

        uint64_t val = lua_tointeger(L, 2);

        HANDLE hThread = DbgGetThreadHandle();

        CONTEXT ctx;
        ctx.ContextFlags = CONTEXT_FULL;
        if (GetThreadContext(hThread, &ctx) == FALSE)
        {
            DWORD lastError = GetLastError();
            dprintf("ERROR: Unable to get thread context: %08X\n", lastError);
            return 0;
        }

        if (readRegister(ctx, regData->second) != val)
        {
            writeRegister(ctx, regData->second, val);

            if (SetThreadContext(hThread, &ctx) == FALSE)
            {
                DWORD lastError = GetLastError();
                dprintf("ERROR: Unable to set thread context: %08X\n", lastError);
                return 0;
            }

            GuiUpdateRegisterView();
        }
    }
    // TODO: Check if thread object and read from there.

    return 0;
}

static const luaL_Reg lua_registers[] =
{
    { "read", lua_register_read },
    { "write", lua_register_write },
    { nullptr, nullptr },
};

bool luaopen_registers(lua_State *L, bool debugState)
{
    luaL_newlib(L, lua_registers);
    lua_setglobal(L, "registers");

    return true;
}

```

`src/x64dbgPlaytime/lua_table_utils.h`:

```h
#pragma once

#include "lua.hpp"
#include <string>

/* Returns 0 if the key is not found otherwise 1, expects table to be on top of stack */
static bool lua_table_haskey(lua_State *L, const char* key)
{
    if (lua_istable(L, -1) == false)
        luaL_error(L, "Table expected, got: %s", luaL_typename(L, -1));

    lua_pushstring(L, key);
    lua_gettable(L, -2);

    bool res = lua_isnil(L, -1) == false;

    lua_pop(L, 1);
    return res;
}

/* Returns 0 if the key is not found otherwise 1, expects table to be on top of stack */
static int lua_table_haskey(lua_State *L, lua_Number key)
{
    if (lua_istable(L, -1) == false)
        luaL_error(L, "Table expected, got: %s", luaL_typename(L, -1));

    lua_pushnumber(L, key);
    lua_gettable(L, -2);

    bool res = lua_isnil(L, -1) == false;

    lua_pop(L, 1);
    return res;
}

/* Returns 0 if the key is not found otherwise 1, expects table to be on top of stack */
static int lua_table_haskey(lua_State *L, lua_Integer key)
{
    if (lua_istable(L, -1) == false)
        luaL_error(L, "Table expected, got: %s", luaL_typename(L, -1));

    lua_pushinteger(L, key);
    lua_gettable(L, -2);

    bool res = lua_isnil(L, -1) == false;

    lua_pop(L, 1);
    return res;
}

/* Gets the member value of a table, expects table to be on top of stack */
static lua_Number lua_table_getfield_number(lua_State *L, const char* key)
{
    if (lua_istable(L, -1) == false)
        luaL_error(L, "Table expected, got: %s", luaL_typename(L, -1));

    lua_pushstring(L, key);
    lua_gettable(L, -2);

    if (!lua_isnumber(L, -1))
        luaL_error(L, "%s expected as number", key);

    lua_Number res = lua_tonumber(L, -1);
    lua_pop(L, 1);

    return res;
}

/* Gets the member value of a table, expects table to be on top of stack */
static lua_Integer lua_table_getfield_integer(lua_State *L, const char* key)
{
    if (lua_istable(L, -1) == false)
        luaL_error(L, "Table expected, got: %s", luaL_typename(L, -1));

    lua_pushstring(L, key);
    lua_gettable(L, -2);

    if (!lua_isinteger(L, -1))
        luaL_error(L, "%s expected as integer", key);

    lua_Integer res = lua_tointeger(L, -1);
    lua_pop(L, 1);

    return res;
}

/* Gets the member value of a table, expects table to be on top of stack */
static std::string lua_table_getfield_string(lua_State *L, const char* key)
{
    if (lua_istable(L, -1) == false)
        luaL_error(L, "Table expected, got: %s", luaL_typename(L, -1));

    lua_pushstring(L, key);
    lua_gettable(L, -2);

    if (!lua_isstring(L, -1))
        luaL_error(L, "%s expected as string", key);

    std::string res = lua_tostring(L, -1);
    lua_pop(L, 1);

    return res;
}

/* Gets the member value of a table, expects table to be on top of stack */
static bool lua_table_getfield_boolean(lua_State *L, const char* key)
{
    if (lua_istable(L, -1) == false)
        luaL_error(L, "Table expected, got: %s", luaL_typename(L, -1));

    lua_pushstring(L, key);
    lua_gettable(L, -2);

    if (!lua_isboolean(L, -1))
        luaL_error(L, "%s expected as boolean", key);

    bool res = lua_toboolean(L, -1);
    lua_pop(L, 1);

    return res;
}

```

`src/x64dbgPlaytime/lua_utils.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"

#include <windows.h>

static int lua_utils_alert(lua_State *L)
{
    const char *str = lua_tostring(L, 1);
    const char *title = lua_tostring(L, 2);

    MessageBox(nullptr, str, title, MB_OK|MB_ICONWARNING);
    return 0;
}

static int lua_utils_question(lua_State *L)
{
    const char *str = lua_tostring(L, 1);
    const char *title = lua_tostring(L, 2);

    int res = MessageBox(nullptr, str, title, MB_YESNO | MB_ICONWARNING);
    lua_pushboolean(L, res == IDYES);
    
    return 1;
}

static const luaL_Reg lua_utils[] =
{
    { "alert", lua_utils_alert },
    { "question", lua_utils_question },
    { nullptr, nullptr },
};

bool luaopen_utils(lua_State *L, bool debugState)
{
    luaL_newlib(L, lua_utils);
    lua_setglobal(L, "utils");

    return true;
}

```

`src/x64dbgPlaytime/lua_xrefs.cpp`:

```cpp
#include "lua_context.hpp"
#include "lauxlib.h"
#include "pluginsdk/bridgemain.h"
#include "plugin.h"

#include <windows.h>

static int lua_xrefs_analyze(lua_State *L)
{
    bool block = lua_isboolean(L, 1) ? lua_toboolean(L, 1) : false;
    bool res;

    if(block)
        res = DbgCmdExecDirect("analx");
    else
        res = DbgCmdExec("analx");

    lua_pushboolean(L, res);
    return 1;
}

static int lua_xrefs_get(lua_State *L)
{
    duint addr = lua_tointeger(L, 1);
    bool extended = lua_isboolean(L, 2) ? lua_toboolean(L, 2) : false;

    XREF_INFO info {};

    lua_newtable(L);

    if (DbgXrefGet(addr, &info))
    {
        for (duint i = 0; i < info.refcount; i++)
        {
            lua_pushinteger(L, i + 1);
            if (extended)
            {
                lua_newtable(L);
                lua_pushstring(L, "address");
                lua_pushinteger(L, info.references[i].addr);
                lua_rawset(L, -3);

                lua_pushstring(L, "type");
                lua_pushinteger(L, info.references[i].type);
                lua_rawset(L, -3);
            }
            else
            {
                lua_pushinteger(L, info.references[i].addr);
            }
            lua_rawset(L, -3);
        }
    }

    return 1;
}

static int lua_xrefs_add(lua_State *L)
{
    duint addr = lua_tointeger(L, 1);
    duint from = lua_tointeger(L, 2);

    bool res = DbgXrefAdd(addr, from);
    lua_pushboolean(L, res);

    return 1;
}

static int lua_xrefs_remove(lua_State *L)
{
    duint addr = lua_tointeger(L, 1);

    bool res = DbgXrefDelAll(addr);
    lua_pushboolean(L, res);

    return 1;
}

static const luaL_Reg lua_xrefs[] =
{
    { "analyze", lua_xrefs_analyze },
    { "get", lua_xrefs_get },
    { "add", lua_xrefs_add },
    { "remove", lua_xrefs_remove },
    { nullptr, nullptr },
};

bool luaopen_xrefs(lua_State *L, bool debugState)
{
    luaL_newlib(L, lua_xrefs);
    lua_setglobal(L, "xrefs");

    return true;
}

```

`src/x64dbgPlaytime/plugin.cpp`:

```cpp
#include "plugin.h"
#include "lua_context.hpp"
#include "utils.h"

enum
{
    MENU_LOAD_LUA_FILE,
};

static bool cbLuaCommand(int argc, char* argv[])
{
    const char *luaCode = argv[0] + 4;

    dprintf("> %s\n", luaCode);

    return g_pLuaContext->runString(luaCode);
}

static duint exprZero(int argc, duint* argv, void* userdata)
{
    return 0;
}

PLUG_EXPORT void CBINITDEBUG(CBTYPE cbType, PLUG_CB_INITDEBUG* info)
{
    dprintf("Debugging of %s started!\n", info->szFileName);
    g_pLuaContext->createDebugState(0);
}

PLUG_EXPORT void CBSTOPDEBUG(CBTYPE cbType, PLUG_CB_STOPDEBUG* info)
{
    dputs("Debugging stopped!");
    g_pLuaContext->shutdownDebugState(0);
}

PLUG_EXPORT void CBEXCEPTION(CBTYPE cbType, PLUG_CB_EXCEPTION* info)
{
    dprintf("ExceptionRecord.ExceptionCode: %08X\n", info->Exception->ExceptionRecord.ExceptionCode);
}

PLUG_EXPORT void CBPAUSEDEBUG(CBTYPE cbType, PLUG_CB_PAUSEDEBUG *info)
{
}

PLUG_EXPORT void CBRESUMEDEBUG(CBTYPE cbType, PLUG_CB_RESUMEDEBUG *info)
{
}

PLUG_EXPORT void CBSTEPPED(CBTYPE cbType, PLUG_CB_STEPPED *info)
{
}

PLUG_EXPORT void CBDEBUGEVENT(CBTYPE cbType, PLUG_CB_DEBUGEVENT* info)
{
    if(info->DebugEvent->dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
    {
        dprintf("DebugEvent->EXCEPTION_DEBUG_EVENT->%.8X\n", info->DebugEvent->u.Exception.ExceptionRecord.ExceptionCode);
    }
}

void plugin_menu_load_lua_file()
{
    OPENFILENAMEA ofn = {};       // common dialog box structure
    char szFile[260] = {};       // if using TCHAR macros

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = nullptr;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFilter = "Lua\0*.lua\0All\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    if (GetOpenFileName(&ofn) == TRUE)
    {
        g_pLuaContext->runFile(ofn.lpstrFile);
    }
}

PLUG_EXPORT void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info)
{
    switch(info->hEntry)
    {
    case MENU_LOAD_LUA_FILE:
        plugin_menu_load_lua_file();
        break;
    default:
        break;
    }
}

bool cbLuaExecuteScript(const char* text)
{
    dprintf("> %s\n", text);

    return g_pLuaContext->runString(text);
}

void cbLuaScriptComplete(const char* text, char** entries, int* entryCount)
{
    if(entryCount)
        *entryCount = 0;
}

bool pluginScriptInit()
{
    SCRIPTTYPEINFO sti = {};
    sti.execute = cbLuaExecuteScript;
    sti.id = 'L' + 'u' + 'a' + '5' + '3';
    strcpy_s(sti.name, "Playtime");

    GuiRegisterScriptLanguage(&sti);

    return true;
}

//Initialize your plugin data here.
bool pluginInit(PLUG_INITSTRUCT* initStruct)
{
    _plugin_registercommand(pluginHandle, "lua", cbLuaCommand, false);

    if (g_pLuaContext != nullptr)
    {
        // Double init?
        return false;
    }

    std::string basePath = Utils::getx64DbgBasePath();
    dprintf("Base Path: %s\n", basePath.c_str());

    std::string luaBasePath = Utils::pathCombine(basePath, "lua");
    dprintf("Lua Base Path: %s\n", luaBasePath.c_str());

    g_pLuaContext = new LuaContext();
    g_pLuaContext->setBasePath(luaBasePath);

    dprintf("Lua context created\n");

    if (!g_pLuaContext->createGlobalState())
    {
        dprintf("Unable to register lua libraries.\n");
    }
    else
    {
        dprintf("Registered lua libraries.\n");
    }

    if (!g_pLuaContext->executeAutorunScripts())
    {
        dprintf("One ore multiple scripts failed.\n");
    }

    pluginScriptInit();

    return true; //Return false to cancel loading the plugin.
}

//Deinitialize your plugin data here.
void pluginStop()
{
    if (g_pLuaContext)
    {
        dprintf("Shutting down lua environment");

        delete g_pLuaContext;
        g_pLuaContext = nullptr;
    }
}

//Do GUI/Menu related things here.
void pluginSetup()
{
    _plugin_menuaddentry(hMenu, MENU_LOAD_LUA_FILE, "&Load Lua File");
}

```

`src/x64dbgPlaytime/plugin.h`:

```h
#pragma once

#include "pluginmain.h"

//plugin data
#define PLUGIN_NAME "x64dbgPlaytime"
#define PLUGIN_VERSION 1

//functions
bool pluginInit(PLUG_INITSTRUCT* initStruct);
void pluginStop();
void pluginSetup();

void getX64DbgBasePath(char *buffer, size_t len);

```

`src/x64dbgPlaytime/pluginmain.cpp`:

```cpp
#include "pluginmain.h"
#include "plugin.h"

int pluginHandle;
HWND hwndDlg;
int hMenu;
int hMenuDisasm;
int hMenuDump;
int hMenuStack;

PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
    initStruct->pluginVersion = PLUGIN_VERSION;
    initStruct->sdkVersion = PLUG_SDKVERSION;
    strncpy_s(initStruct->pluginName, PLUGIN_NAME, _TRUNCATE);
    pluginHandle = initStruct->pluginHandle;
    return pluginInit(initStruct);
}

PLUG_EXPORT bool plugstop()
{
    pluginStop();
    return true;
}

PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
    hwndDlg = setupStruct->hwndDlg;
    hMenu = setupStruct->hMenu;
    hMenuDisasm = setupStruct->hMenuDisasm;
    hMenuDump = setupStruct->hMenuDump;
    hMenuStack = setupStruct->hMenuStack;
    pluginSetup();
}
```

`src/x64dbgPlaytime/pluginmain.h`:

```h
#pragma once

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"

#include "pluginsdk/_scriptapi_argument.h"
#include "pluginsdk/_scriptapi_assembler.h"
#include "pluginsdk/_scriptapi_bookmark.h"
#include "pluginsdk/_scriptapi_comment.h"
#include "pluginsdk/_scriptapi_debug.h"
#include "pluginsdk/_scriptapi_flag.h"
#include "pluginsdk/_scriptapi_function.h"
#include "pluginsdk/_scriptapi_gui.h"
#include "pluginsdk/_scriptapi_label.h"
#include "pluginsdk/_scriptapi_memory.h"
#include "pluginsdk/_scriptapi_misc.h"
#include "pluginsdk/_scriptapi_module.h"
#include "pluginsdk/_scriptapi_pattern.h"
#include "pluginsdk/_scriptapi_register.h"
#include "pluginsdk/_scriptapi_stack.h"
#include "pluginsdk/_scriptapi_symbol.h"

#include "pluginsdk/capstone/capstone.h"
#include "pluginsdk/DeviceNameResolver/DeviceNameResolver.h"
#include "pluginsdk/jansson/jansson.h"
#include "pluginsdk/lz4/lz4file.h"
#include "pluginsdk/TitanEngine/TitanEngine.h"
#include "pluginsdk/XEDParse/XEDParse.h"
#include "pluginsdk/yara/yara.h"

#ifdef _WIN64
#pragma comment(lib, "pluginsdk/x64dbg.lib")
#pragma comment(lib, "pluginsdk/x64bridge.lib")
#pragma comment(lib, "pluginsdk/capstone/capstone_x64.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x64.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x64.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x64.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x64.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x64.lib")
#pragma comment(lib, "pluginsdk/yara/yara_x64.lib")
#else
#pragma comment(lib, "pluginsdk/x32dbg.lib")
#pragma comment(lib, "pluginsdk/x32bridge.lib")
#pragma comment(lib, "pluginsdk/capstone/capstone_x86.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x86.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x86.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x86.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x86.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x86.lib")
#pragma comment(lib, "pluginsdk/yara/yara_x86.lib")
#endif //_WIN64

#define Cmd(x) DbgCmdExecDirect(x)
#define Eval(x) DbgValFromString(x)
#define dprintf(x, ...) _plugin_logprintf("[" PLUGIN_NAME "] " x, __VA_ARGS__)
#define dputs(x) _plugin_logputs("[" PLUGIN_NAME "] " x)
#define PLUG_EXPORT extern "C" __declspec(dllexport)

//superglobal variables
extern int pluginHandle;
extern HWND hwndDlg;
extern int hMenu;
extern int hMenuDisasm;
extern int hMenuDump;
extern int hMenuStack;
```

`src/x64dbgPlaytime/pluginsdk/DeviceNameResolver/DeviceNameResolver.h`:

```h
#ifndef _DEVICENAMERESOLVER_H
#define _DEVICENAMERESOLVER_H

#include <windows.h>

#ifdef __cplusplus
extern "C"
{
#endif

__declspec(dllexport) bool DevicePathToPathW(const wchar_t* szDevicePath, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathToPathA(const char* szDevicePath, char* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleW(HANDLE hFile, wchar_t* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleA(HANDLE hFile, char* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleW(HANDLE hFile, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleA(HANDLE hFile, char* szPath, size_t nSizeInChars);

#ifdef __cplusplus
}
#endif

#endif // _DEVICENAMERESOLVER_H

```

`src/x64dbgPlaytime/pluginsdk/TitanEngine/TitanEngine.h`:

```h
#ifndef TITANENGINE
#define TITANENGINE

#define TITCALL

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <stdint.h>

#pragma pack(push, 1)

// Global.Constant.Structure.Declaration:
// Engine.External:
#define UE_STRUCT_PE32STRUCT 1
#define UE_STRUCT_PE64STRUCT 2
#define UE_STRUCT_PESTRUCT 3
#define UE_STRUCT_IMPORTENUMDATA 4
#define UE_STRUCT_THREAD_ITEM_DATA 5
#define UE_STRUCT_LIBRARY_ITEM_DATA 6
#define UE_STRUCT_LIBRARY_ITEM_DATAW 7
#define UE_STRUCT_PROCESS_ITEM_DATA 8
#define UE_STRUCT_HANDLERARRAY 9
#define UE_STRUCT_PLUGININFORMATION 10
#define UE_STRUCT_HOOK_ENTRY 11
#define UE_STRUCT_FILE_STATUS_INFO 12
#define UE_STRUCT_FILE_FIX_INFO 13
#define UE_STRUCT_X87FPUREGISTER 14
#define UE_STRUCT_X87FPU 15
#define UE_STRUCT_TITAN_ENGINE_CONTEXT 16

#define UE_ACCESS_READ 0
#define UE_ACCESS_WRITE 1
#define UE_ACCESS_ALL 2

#define UE_HIDE_PEBONLY 0
#define UE_HIDE_BASIC 1

#define UE_PLUGIN_CALL_REASON_PREDEBUG 1
#define UE_PLUGIN_CALL_REASON_EXCEPTION 2
#define UE_PLUGIN_CALL_REASON_POSTDEBUG 3
#define UE_PLUGIN_CALL_REASON_UNHANDLEDEXCEPTION 4

#define TEE_HOOK_NRM_JUMP 1
#define TEE_HOOK_NRM_CALL 3
#define TEE_HOOK_IAT 5

#define UE_ENGINE_ALOW_MODULE_LOADING 1
#define UE_ENGINE_AUTOFIX_FORWARDERS 2
#define UE_ENGINE_PASS_ALL_EXCEPTIONS 3
#define UE_ENGINE_NO_CONSOLE_WINDOW 4
#define UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS 5
#define UE_ENGINE_CALL_PLUGIN_CALLBACK 6
#define UE_ENGINE_RESET_CUSTOM_HANDLER 7
#define UE_ENGINE_CALL_PLUGIN_DEBUG_CALLBACK 8
#define UE_ENGINE_SET_DEBUG_PRIVILEGE 9

#define UE_OPTION_REMOVEALL 1
#define UE_OPTION_DISABLEALL 2
#define UE_OPTION_REMOVEALLDISABLED 3
#define UE_OPTION_REMOVEALLENABLED 4

#define UE_STATIC_DECRYPTOR_XOR 1
#define UE_STATIC_DECRYPTOR_SUB 2
#define UE_STATIC_DECRYPTOR_ADD 3

#define UE_STATIC_DECRYPTOR_FOREWARD 1
#define UE_STATIC_DECRYPTOR_BACKWARD 2

#define UE_STATIC_KEY_SIZE_1 1
#define UE_STATIC_KEY_SIZE_2 2
#define UE_STATIC_KEY_SIZE_4 4
#define UE_STATIC_KEY_SIZE_8 8

#define UE_STATIC_APLIB 1
#define UE_STATIC_APLIB_DEPACK 2
#define UE_STATIC_LZMA 3

#define UE_STATIC_HASH_MD5 1
#define UE_STATIC_HASH_SHA1 2
#define UE_STATIC_HASH_CRC32 3

#define UE_RESOURCE_LANGUAGE_ANY -1

#define UE_PE_OFFSET 0
#define UE_IMAGEBASE 1
#define UE_OEP 2
#define UE_SIZEOFIMAGE 3
#define UE_SIZEOFHEADERS 4
#define UE_SIZEOFOPTIONALHEADER 5
#define UE_SECTIONALIGNMENT 6
#define UE_IMPORTTABLEADDRESS 7
#define UE_IMPORTTABLESIZE 8
#define UE_RESOURCETABLEADDRESS 9
#define UE_RESOURCETABLESIZE 10
#define UE_EXPORTTABLEADDRESS 11
#define UE_EXPORTTABLESIZE 12
#define UE_TLSTABLEADDRESS 13
#define UE_TLSTABLESIZE 14
#define UE_RELOCATIONTABLEADDRESS 15
#define UE_RELOCATIONTABLESIZE 16
#define UE_TIMEDATESTAMP 17
#define UE_SECTIONNUMBER 18
#define UE_CHECKSUM 19
#define UE_SUBSYSTEM 20
#define UE_CHARACTERISTICS 21
#define UE_NUMBEROFRVAANDSIZES 22
#define UE_BASEOFCODE 23
#define UE_BASEOFDATA 24
#define UE_DLLCHARACTERISTICS 25
//leaving some enum space here for future additions
#define UE_SECTIONNAME 40
#define UE_SECTIONVIRTUALOFFSET 41
#define UE_SECTIONVIRTUALSIZE 42
#define UE_SECTIONRAWOFFSET 43
#define UE_SECTIONRAWSIZE 44
#define UE_SECTIONFLAGS 45

#define UE_VANOTFOUND = -2;

#define UE_CH_BREAKPOINT 1
#define UE_CH_SINGLESTEP 2
#define UE_CH_ACCESSVIOLATION 3
#define UE_CH_ILLEGALINSTRUCTION 4
#define UE_CH_NONCONTINUABLEEXCEPTION 5
#define UE_CH_ARRAYBOUNDSEXCEPTION 6
#define UE_CH_FLOATDENORMALOPERAND 7
#define UE_CH_FLOATDEVIDEBYZERO 8
#define UE_CH_INTEGERDEVIDEBYZERO 9
#define UE_CH_INTEGEROVERFLOW 10
#define UE_CH_PRIVILEGEDINSTRUCTION 11
#define UE_CH_PAGEGUARD 12
#define UE_CH_EVERYTHINGELSE 13
#define UE_CH_CREATETHREAD 14
#define UE_CH_EXITTHREAD 15
#define UE_CH_CREATEPROCESS 16
#define UE_CH_EXITPROCESS 17
#define UE_CH_LOADDLL 18
#define UE_CH_UNLOADDLL 19
#define UE_CH_OUTPUTDEBUGSTRING 20
#define UE_CH_AFTEREXCEPTIONPROCESSING 21
#define UE_CH_SYSTEMBREAKPOINT 23
#define UE_CH_UNHANDLEDEXCEPTION 24
#define UE_CH_RIPEVENT 25
#define UE_CH_DEBUGEVENT 26

#define UE_OPTION_HANDLER_RETURN_HANDLECOUNT 1
#define UE_OPTION_HANDLER_RETURN_ACCESS 2
#define UE_OPTION_HANDLER_RETURN_FLAGS 3
#define UE_OPTION_HANDLER_RETURN_TYPENAME 4

#define UE_BREAKPOINT_INT3 1
#define UE_BREAKPOINT_LONG_INT3 2
#define UE_BREAKPOINT_UD2 3

#define UE_BPXREMOVED 0
#define UE_BPXACTIVE 1
#define UE_BPXINACTIVE 2

#define UE_BREAKPOINT 0
#define UE_SINGLESHOOT 1
#define UE_HARDWARE 2
#define UE_MEMORY 3
#define UE_MEMORY_READ 4
#define UE_MEMORY_WRITE 5
#define UE_MEMORY_EXECUTE 6
#define UE_BREAKPOINT_TYPE_INT3 0x10000000
#define UE_BREAKPOINT_TYPE_LONG_INT3 0x20000000
#define UE_BREAKPOINT_TYPE_UD2 0x30000000

#define UE_HARDWARE_EXECUTE 4
#define UE_HARDWARE_WRITE 5
#define UE_HARDWARE_READWRITE 6

#define UE_HARDWARE_SIZE_1 7
#define UE_HARDWARE_SIZE_2 8
#define UE_HARDWARE_SIZE_4 9
#define UE_HARDWARE_SIZE_8 10

#define UE_ON_LIB_LOAD 1
#define UE_ON_LIB_UNLOAD 2
#define UE_ON_LIB_ALL 3

#define UE_APISTART 0
#define UE_APIEND 1

#define UE_PLATFORM_x86 1
#define UE_PLATFORM_x64 2
#define UE_PLATFORM_ALL 3

#define UE_FUNCTION_STDCALL 1
#define UE_FUNCTION_CCALL 2
#define UE_FUNCTION_FASTCALL 3
#define UE_FUNCTION_STDCALL_RET 4
#define UE_FUNCTION_CCALL_RET 5
#define UE_FUNCTION_FASTCALL_RET 6
#define UE_FUNCTION_STDCALL_CALL 7
#define UE_FUNCTION_CCALL_CALL 8
#define UE_FUNCTION_FASTCALL_CALL 9
#define UE_PARAMETER_BYTE 0
#define UE_PARAMETER_WORD 1
#define UE_PARAMETER_DWORD 2
#define UE_PARAMETER_QWORD 3
#define UE_PARAMETER_PTR_BYTE 4
#define UE_PARAMETER_PTR_WORD 5
#define UE_PARAMETER_PTR_DWORD 6
#define UE_PARAMETER_PTR_QWORD 7
#define UE_PARAMETER_STRING 8
#define UE_PARAMETER_UNICODE 9

#define UE_EAX 1
#define UE_EBX 2
#define UE_ECX 3
#define UE_EDX 4
#define UE_EDI 5
#define UE_ESI 6
#define UE_EBP 7
#define UE_ESP 8
#define UE_EIP 9
#define UE_EFLAGS 10
#define UE_DR0 11
#define UE_DR1 12
#define UE_DR2 13
#define UE_DR3 14
#define UE_DR6 15
#define UE_DR7 16
#define UE_RAX 17
#define UE_RBX 18
#define UE_RCX 19
#define UE_RDX 20
#define UE_RDI 21
#define UE_RSI 22
#define UE_RBP 23
#define UE_RSP 24
#define UE_RIP 25
#define UE_RFLAGS 26
#define UE_R8 27
#define UE_R9 28
#define UE_R10 29
#define UE_R11 30
#define UE_R12 31
#define UE_R13 32
#define UE_R14 33
#define UE_R15 34
#define UE_CIP 35
#define UE_CSP 36
#ifdef _WIN64
#define UE_CFLAGS UE_RFLAGS
#else
#define UE_CFLAGS UE_EFLAGS
#endif
#define UE_SEG_GS 37
#define UE_SEG_FS 38
#define UE_SEG_ES 39
#define UE_SEG_DS 40
#define UE_SEG_CS 41
#define UE_SEG_SS 42
#define UE_x87_r0 43
#define UE_x87_r1 44
#define UE_x87_r2 45
#define UE_x87_r3 46
#define UE_x87_r4 47
#define UE_x87_r5 48
#define UE_x87_r6 49
#define UE_x87_r7 50
#define UE_X87_STATUSWORD 51
#define UE_X87_CONTROLWORD 52
#define UE_X87_TAGWORD 53
#define UE_MXCSR 54
#define UE_MMX0 55
#define UE_MMX1 56
#define UE_MMX2 57
#define UE_MMX3 58
#define UE_MMX4 59
#define UE_MMX5 60
#define UE_MMX6 61
#define UE_MMX7 62
#define UE_XMM0 63
#define UE_XMM1 64
#define UE_XMM2 65
#define UE_XMM3 66
#define UE_XMM4 67
#define UE_XMM5 68
#define UE_XMM6 69
#define UE_XMM7 70
#define UE_XMM8 71
#define UE_XMM9 72
#define UE_XMM10 73
#define UE_XMM11 74
#define UE_XMM12 75
#define UE_XMM13 76
#define UE_XMM14 77
#define UE_XMM15 78
#define UE_x87_ST0 79
#define UE_x87_ST1 80
#define UE_x87_ST2 81
#define UE_x87_ST3 82
#define UE_x87_ST4 83
#define UE_x87_ST5 84
#define UE_x87_ST6 85
#define UE_x87_ST7 86
#define UE_YMM0 87
#define UE_YMM1 88
#define UE_YMM2 89
#define UE_YMM3 90
#define UE_YMM4 91
#define UE_YMM5 92
#define UE_YMM6 93
#define UE_YMM7 94
#define UE_YMM8 95
#define UE_YMM9 96
#define UE_YMM10 97
#define UE_YMM11 98
#define UE_YMM12 99
#define UE_YMM13 100
#define UE_YMM14 101
#define UE_YMM15 102

#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

typedef struct
{
    DWORD PE32Offset;
    DWORD ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE32Struct, *PPE32Struct;

typedef struct
{
    DWORD PE64Offset;
    DWORD64 ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE64Struct, *PPE64Struct;

#if defined(_WIN64)
typedef PE64Struct PEStruct;
#else
typedef PE32Struct PEStruct;
#endif

typedef struct
{
    bool NewDll;
    int NumberOfImports;
    ULONG_PTR ImageBase;
    ULONG_PTR BaseImportThunk;
    ULONG_PTR ImportThunk;
    char* APIName;
    char* DLLName;
} ImportEnumData, *PImportEnumData;

typedef struct
{
    HANDLE hThread;
    DWORD dwThreadId;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
    void* TebAddress;
    ULONG WaitTime;
    LONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} THREAD_ITEM_DATA, *PTHREAD_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    char szLibraryPath[MAX_PATH];
    char szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATA, *PLIBRARY_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    wchar_t szLibraryPath[MAX_PATH];
    wchar_t szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATAW, *PLIBRARY_ITEM_DATAW;

typedef struct
{
    HANDLE hProcess;
    DWORD dwProcessId;
    HANDLE hThread;
    DWORD dwThreadId;
    HANDLE hFile;
    void* BaseOfImage;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
} PROCESS_ITEM_DATA, *PPROCESS_ITEM_DATA;

typedef struct
{
    ULONG ProcessId;
    HANDLE hHandle;
} HandlerArray, *PHandlerArray;

typedef struct
{
    char PluginName[64];
    DWORD PluginMajorVersion;
    DWORD PluginMinorVersion;
    HMODULE PluginBaseAddress;
    void* TitanDebuggingCallBack;
    void* TitanRegisterPlugin;
    void* TitanReleasePlugin;
    void* TitanResetPlugin;
    bool PluginDisabled;
} PluginInformation, *PPluginInformation;

#define TEE_MAXIMUM_HOOK_SIZE 14
#define TEE_MAXIMUM_HOOK_RELOCS 7
#if defined(_WIN64)
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 14
#else
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 5
#endif

typedef struct HOOK_ENTRY
{
    bool IATHook;
    BYTE HookType;
    DWORD HookSize;
    void* HookAddress;
    void* RedirectionAddress;
    BYTE HookBytes[TEE_MAXIMUM_HOOK_SIZE];
    BYTE OriginalBytes[TEE_MAXIMUM_HOOK_SIZE];
    void* IATHookModuleBase;
    DWORD IATHookNameHash;
    bool HookIsEnabled;
    bool HookIsRemote;
    void* PatchedEntry;
    DWORD RelocationInfo[TEE_MAXIMUM_HOOK_RELOCS];
    int RelocationCount;
} HOOK_ENTRY, *PHOOK_ENTRY;

#define UE_DEPTH_SURFACE 0
#define UE_DEPTH_DEEP 1

#define UE_UNPACKER_CONDITION_SEARCH_FROM_EP 1

#define UE_UNPACKER_CONDITION_LOADLIBRARY 1
#define UE_UNPACKER_CONDITION_GETPROCADDRESS 2
#define UE_UNPACKER_CONDITION_ENTRYPOINTBREAK 3
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT1 4
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT2 5

#define UE_FIELD_OK 0
#define UE_FIELD_BROKEN_NON_FIXABLE 1
#define UE_FIELD_BROKEN_NON_CRITICAL 2
#define UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE 3
#define UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED 4
#define UE_FIELD_FIXABLE_NON_CRITICAL 5
#define UE_FIELD_FIXABLE_CRITICAL 6
#define UE_FIELD_NOT_PRESET 7
#define UE_FIELD_NOT_PRESET_WARNING 8

#define UE_RESULT_FILE_OK 10
#define UE_RESULT_FILE_INVALID_BUT_FIXABLE 11
#define UE_RESULT_FILE_INVALID_AND_NON_FIXABLE 12
#define UE_RESULT_FILE_INVALID_FORMAT 13

typedef struct
{
    BYTE OveralEvaluation;
    bool EvaluationTerminatedByException;
    bool FileIs64Bit;
    bool FileIsDLL;
    bool FileIsConsole;
    bool MissingDependencies;
    bool MissingDeclaredAPIs;
    BYTE SignatureMZ;
    BYTE SignaturePE;
    BYTE EntryPoint;
    BYTE ImageBase;
    BYTE SizeOfImage;
    BYTE FileAlignment;
    BYTE SectionAlignment;
    BYTE ExportTable;
    BYTE RelocationTable;
    BYTE ImportTable;
    BYTE ImportTableSection;
    BYTE ImportTableData;
    BYTE IATTable;
    BYTE TLSTable;
    BYTE LoadConfigTable;
    BYTE BoundImportTable;
    BYTE COMHeaderTable;
    BYTE ResourceTable;
    BYTE ResourceData;
    BYTE SectionTable;
} FILE_STATUS_INFO, *PFILE_STATUS_INFO;

typedef struct
{
    BYTE OveralEvaluation;
    bool FixingTerminatedByException;
    bool FileFixPerformed;
    bool StrippedRelocation;
    bool DontFixRelocations;
    DWORD OriginalRelocationTableAddress;
    DWORD OriginalRelocationTableSize;
    bool StrippedExports;
    bool DontFixExports;
    DWORD OriginalExportTableAddress;
    DWORD OriginalExportTableSize;
    bool StrippedResources;
    bool DontFixResources;
    DWORD OriginalResourceTableAddress;
    DWORD OriginalResourceTableSize;
    bool StrippedTLS;
    bool DontFixTLS;
    DWORD OriginalTLSTableAddress;
    DWORD OriginalTLSTableSize;
    bool StrippedLoadConfig;
    bool DontFixLoadConfig;
    DWORD OriginalLoadConfigTableAddress;
    DWORD OriginalLoadConfigTableSize;
    bool StrippedBoundImports;
    bool DontFixBoundImports;
    DWORD OriginalBoundImportTableAddress;
    DWORD OriginalBoundImportTableSize;
    bool StrippedIAT;
    bool DontFixIAT;
    DWORD OriginalImportAddressTableAddress;
    DWORD OriginalImportAddressTableSize;
    bool StrippedCOM;
    bool DontFixCOM;
    DWORD OriginalCOMTableAddress;
    DWORD OriginalCOMTableSize;
} FILE_FIX_INFO, *PFILE_FIX_INFO;

typedef struct DECLSPEC_ALIGN(16) _XmmRegister_t
{
    ULONGLONG Low;
    LONGLONG High;
} XmmRegister_t;

typedef struct
{
    XmmRegister_t Low; //XMM/SSE part
    XmmRegister_t High; //AVX part
} YmmRegister_t;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} x87FPURegister_t;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} x87FPU_t;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    x87FPU_t x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XmmRegister_t XmmRegisters[16];
    YmmRegister_t YmmRegisters[16];
#else // x86
    XmmRegister_t XmmRegisters[8];
    YmmRegister_t YmmRegisters[8];
#endif
} TITAN_ENGINE_CONTEXT_t;

#ifdef __cplusplus
extern "C"
{
#endif

// Global.Function.Declaration:
// TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, const char* szDebuggedFileName);
__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDebuggedFileName);
__declspec(dllexport) bool TITCALL ExtractSection(const char* szFileName, const char* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ExtractSectionW(const wchar_t* szFileName, const wchar_t* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ResortFileSections(const char* szFileName);
__declspec(dllexport) bool TITCALL ResortFileSectionsW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL FindOverlay(const char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL FindOverlayW(const wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL ExtractOverlay(const char* szFileName, const char* szExtactedFileName);
__declspec(dllexport) bool TITCALL ExtractOverlayW(const wchar_t* szFileName, const wchar_t* szExtactedFileName);
__declspec(dllexport) bool TITCALL AddOverlay(const char* szFileName, const char* szOverlayFileName);
__declspec(dllexport) bool TITCALL AddOverlayW(const wchar_t* szFileName, const wchar_t* szOverlayFileName);
__declspec(dllexport) bool TITCALL CopyOverlay(const char* szInFileName, const char* szOutFileName);
__declspec(dllexport) bool TITCALL CopyOverlayW(const wchar_t* szInFileName, const wchar_t* szOutFileName);
__declspec(dllexport) bool TITCALL RemoveOverlay(const char* szFileName);
__declspec(dllexport) bool TITCALL RemoveOverlayW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(const char* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL AddNewSectionEx(const char* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSectionExW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSection(const char* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) long TITCALL AddNewSectionW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) bool TITCALL ResizeLastSection(const char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) bool TITCALL ResizeLastSectionW(const wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) void TITCALL SetSharedOverlay(const char* szFileName);
__declspec(dllexport) void TITCALL SetSharedOverlayW(const wchar_t* szFileName);
__declspec(dllexport) char* TITCALL GetSharedOverlay();
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW();
__declspec(dllexport) bool TITCALL DeleteLastSection(const char* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionEx(const char* szFileName, DWORD NumberOfSections);
__declspec(dllexport) bool TITCALL DeleteLastSectionExW(const wchar_t* szFileName, DWORD NumberOfSections);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(const char* szFileName);
__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode);
__declspec(dllexport) long TITCALL RealignPEEx(const char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) long TITCALL RealignPEExW(const wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) bool TITCALL WipeSection(const char* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL WipeSectionW(const wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL IsPE32FileValidEx(const char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL IsPE32FileValidExW(const wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(const char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(const wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL IsFileDLL(const char* szFileName, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL IsFileDLLW(const wchar_t* szFileName, ULONG_PTR FileMapVA);
// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread);
__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread);
__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup();
__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase);
__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState);
__declspec(dllexport) long TITCALL RelocaterEstimatedSize();
__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(const char* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(const wchar_t* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, const char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, const wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const char* szDumpFile1, const char* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const wchar_t* szDumpFile1, const wchar_t* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(const char* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(const wchar_t* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(const char* szFileName);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(const wchar_t* szFileName);
// TitanEngine.Resourcer.functions:
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUse(const char* szFileName);
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUseW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(HMODULE hFile, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(const char* szFileName, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(const wchar_t* szFileName, char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerFindResource(const char* szFileName, const char* szResourceType, DWORD ResourceType, const char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceW(const wchar_t* szFileName, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) void TITCALL ResourcerEnumerateResource(const char* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(const wchar_t* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack);
// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId);
__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId);
__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack);
__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode);
__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning);
__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused);
__declspec(dllexport) bool TITCALL ThreaderPauseProcess();
__declspec(dllexport) bool TITCALL ThreaderResumeProcess();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack);
__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive();
__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread();
// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType);
__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugEx(const char* szFileName, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDebugExW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebug(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebugW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL StopDebug();
__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType);
__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory);
__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) void TITCALL Getx87FPURegisters(x87FPURegister_t x87FPURegisters[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL GetMMXRegisters(uint64_t mmx[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) ULONG_PTR TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister);
__declspec(dllexport) ULONG_PTR TITCALL GetContextData(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL GetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL ClearExceptionNumber();
__declspec(dllexport) long TITCALL CurrentExceptionNumber();
__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) ULONG_PTR TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
extern "C" __declspec(dllexport) ULONG_PTR TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) void* TITCALL GetDebugData();
__declspec(dllexport) void* TITCALL GetTerminationData();
__declspec(dllexport) long TITCALL GetExitCode();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedDLLBaseAddress();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedFileBaseAddress();
__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize);
__declspec(dllexport) ULONG_PTR TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute();
__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack);
__declspec(dllexport) void TITCALL ForceClose();
__declspec(dllexport) void TITCALL StepInto(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOver(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal);
__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack);
__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex);
__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister);
__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption);
__declspec(dllexport) PROCESS_INFORMATION* TITCALL TitanGetProcessInformation();
__declspec(dllexport) STARTUPINFOW* TITCALL TitanGetStartupInformation();
__declspec(dllexport) void TITCALL DebugLoop();
__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut);
__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode);
__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack);
__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId);
__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId);
__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut);
__declspec(dllexport) void TITCALL AutoDebugEx(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) void TITCALL AutoDebugExW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL IsFileBeingDebugged();
__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages);
// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit();
__declspec(dllexport) bool TITCALL FindOEPGenerically(const char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(const wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(const char* szDLLName, ULONG_PTR FirstThunk);
__declspec(dllexport) void TITCALL ImporterAddNewAPI(const char* szAPIName, ULONG_PTR ThunkValue);
__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue);
__declspec(dllexport) long TITCALL ImporterGetAddedDllCount();
__declspec(dllexport) long TITCALL ImporterGetAddedAPICount();
__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap);
__declspec(dllexport) long TITCALL ImporterEstimatedSize();
__declspec(dllexport) bool TITCALL ImporterExportIATEx(const char* szDumpFileName, const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterExportIATExW(const wchar_t* szDumpFileName, const wchar_t* szExportFileName, const wchar_t* szSectionName = L".RL!TEv2");
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIWriteLocation(const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddressEx(const char* szDLLName, const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, const char* szModuleName);
__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, const wchar_t* szModuleName);
__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(const char* szOriginalFile, const char* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(const char* szOriginalFile, const char* szDumpFile, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile, const char* szSectionName);
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, const char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessIds, const wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack);
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, const char* szDumpedFile, const char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, const wchar_t* szDumpedFile, const wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, const char* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, const wchar_t* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr);
// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress);
__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(const char* szModuleName, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(const char* szModuleName, const char* szHookFunction, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(const char* szModuleName, const char* szHookFunction, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(const char* szModuleName, const char* szHookFunction, bool EnableAll);
__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx();
// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit();
__declspec(dllexport) ULONG_PTR TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions);
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixRedirectionViaModule(HMODULE hModuleHandle, HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD IdParameter);
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, const char* szPluginName, ULONG_PTR AddressToTrace);
// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup();
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase);
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, const char* szExportModuleName);
__declspec(dllexport) bool TITCALL ExporterAddNewExport(const char* szExportName, DWORD ExportRelativeAddress);
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress);
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount();
__declspec(dllexport) long TITCALL ExporterEstimatedSize();
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(const wchar_t* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(const wchar_t* szFileName);
// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(const char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(const char* szLibraryName, DWORD bpxType);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(const char* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(const wchar_t* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack);
// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(const char* szImageName);
__declspec(dllexport) long TITCALL GetActiveProcessIdW(const wchar_t* szImageName);
__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(const char* szLibraryName, void* EnumFunction);
__declspec(dllexport) HANDLE TITCALL TitanOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId);
__declspec(dllexport) HANDLE TITCALL TitanOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId);
// TitanEngine.TLSFixer.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSGrabCallBackData(const char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(const wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(const char* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(const wchar_t* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSRemoveCallback(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTable(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupData(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupDataW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRestoreData();
__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(const char* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(const wchar_t* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(const char* szNativeName);
__declspec(dllexport) void* TITCALL TranslateNativeNameW(const wchar_t* szNativeName);
// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId);
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle);
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn);
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, const char* szMutexString);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, const wchar_t* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(const char* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(const wchar_t* szMutexString);
// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode);
// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(const char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileLoadW(const wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnload(const char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnloadW(const wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileOpen(const char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileOpenW(const wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size);
__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle);
__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFileW(const wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFile(const char* szFileName, char* HashDigest, bool OutputString, int Algorithm);
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(const char* szFileName, const char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(const wchar_t* szFileName, const wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2);
__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress);
__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking();
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(const char* szFileName, const char* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(const wchar_t* szFileName, const wchar_t* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess);
__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies();
__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(const char* WindowUnpackerTitle, const char* WindowUnpackerLongTitle, const char* WindowUnpackerName, const char* WindowUnpackerAuthor, void* StartUnpackingCallBack);
__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(const char* szLogMessage);
__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize);
// Global.Engine.Extension.Functions:
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginLoaded(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginEnabled(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerDisableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerDisablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerEnableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerEnablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadPlugin(const char* szPluginName);
__declspec(dllexport) void* TITCALL ExtensionManagerGetPluginInfo(const char* szPluginName);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif /*TITANENGINE*/

```

`src/x64dbgPlaytime/pluginsdk/XEDParse/XEDParse.h`:

```h
#ifndef _XEDPARSE_H
#define _XEDPARSE_H

#include <windows.h>

//XEDParse defines
#ifdef XEDPARSE_BUILD
#define XEDPARSE_EXPORT __declspec(dllexport)
#else
#define XEDPARSE_EXPORT __declspec(dllimport)
#endif //XEDPARSE_BUILD

#define XEDPARSE_CALL //calling convention

#define XEDPARSE_MAXBUFSIZE 256
#define XEDPARSE_MAXASMSIZE 16

//typedefs
typedef bool (XEDPARSE_CALL* CBXEDPARSE_UNKNOWN)(const char* text, ULONGLONG* value);

//XEDParse enums
enum XEDPARSE_STATUS
{
    XEDPARSE_ERROR = 0,
    XEDPARSE_OK = 1
};

//XEDParse structs
#pragma pack(push,8)
struct XEDPARSE
{
    bool x64; // use 64-bit instructions
    ULONGLONG cip; //instruction pointer (for relative addressing)
    unsigned int dest_size; //destination size (returned by XEDParse)
    CBXEDPARSE_UNKNOWN cbUnknown; //unknown operand callback
    unsigned char dest[XEDPARSE_MAXASMSIZE]; //destination buffer
    char instr[XEDPARSE_MAXBUFSIZE]; //instruction text
    char error[XEDPARSE_MAXBUFSIZE]; //error text (in case of an error)
};
#pragma pack(pop)

#ifdef __cplusplus
extern "C"
{
#endif

XEDPARSE_EXPORT XEDPARSE_STATUS XEDPARSE_CALL XEDParseAssemble(XEDPARSE* XEDParse);

#ifdef __cplusplus
}
#endif

#endif // _XEDPARSE_H

```

`src/x64dbgPlaytime/pluginsdk/_dbgfunctions.h`:

```h
#ifndef _DBGFUNCTIONS_H
#define _DBGFUNCTIONS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

typedef struct
{
    char mod[MAX_MODULE_SIZE];
    duint addr;
    unsigned char oldbyte;
    unsigned char newbyte;
} DBGPATCHINFO;

typedef struct
{
    duint addr;
    duint from;
    duint to;
    char comment[MAX_COMMENT_SIZE];
} DBGCALLSTACKENTRY;

typedef struct
{
    int total;
    DBGCALLSTACKENTRY* entries;
} DBGCALLSTACK;

typedef struct
{
    duint addr;
    duint handler;
} DBGSEHRECORD;

typedef struct
{
    duint total;
    DBGSEHRECORD* records;
} DBGSEHCHAIN;

typedef struct
{
    DWORD dwProcessId;
    char szExeFile[MAX_PATH];
    char szExeMainWindowTitle[MAX_PATH];
    char szExeArgs[MAX_COMMAND_LINE_SIZE];
} DBGPROCESSINFO;

typedef struct
{
    DWORD rva;
    BYTE type;
    WORD size;
} DBGRELOCATIONINFO;

typedef enum
{
    InstructionBody = 0,
    InstructionHeading = 1,
    InstructionTailing = 2,
    InstructionOverlapped = 3, // The byte was executed with differing instruction base addresses
    DataByte,  // This and the following is not implemented yet.
    DataWord,
    DataDWord,
    DataQWord,
    DataFloat,
    DataDouble,
    DataLongDouble,
    DataXMM,
    DataYMM,
    DataMMX,
    DataMixed, //the byte is accessed in multiple ways
    InstructionDataMixed //the byte is both executed and written
} TRACERECORDBYTETYPE;

typedef enum
{
    TraceRecordNone,
    TraceRecordBitExec,
    TraceRecordByteWithExecTypeAndCounter,
    TraceRecordWordWithExecTypeAndCounter
} TRACERECORDTYPE;

typedef struct
{
    duint Handle;
    unsigned char TypeNumber;
    unsigned int GrantedAccess;
} HANDLEINFO;

// The longest ip address is 1234:6789:1234:6789:1234:6789:123.567.901.345 (46 bytes)
#define TCP_ADDR_SIZE 50

typedef struct
{
    char RemoteAddress[TCP_ADDR_SIZE];
    unsigned short RemotePort;
    char LocalAddress[TCP_ADDR_SIZE];
    unsigned short LocalPort;
    char StateText[TCP_ADDR_SIZE];
    unsigned int State;
} TCPCONNECTIONINFO;

typedef struct
{
    duint handle;
    duint parent;
    DWORD threadId;
    DWORD style;
    DWORD styleEx;
    duint wndProc;
    bool enabled;
    RECT position;
    char windowTitle[MAX_COMMENT_SIZE];
    char windowClass[MAX_COMMENT_SIZE];
} WINDOW_INFO;

typedef struct
{
    duint addr;
    duint size;
    duint flags;
} HEAPINFO;

typedef struct
{
    const char* name;
    duint value;
} CONSTANTINFO;

typedef bool (*ASSEMBLEATEX)(duint addr, const char* instruction, char* error, bool fillnop);
typedef bool (*SECTIONFROMADDR)(duint addr, char* section);
typedef bool (*MODNAMEFROMADDR)(duint addr, char* modname, bool extension);
typedef duint(*MODBASEFROMADDR)(duint addr);
typedef duint(*MODBASEFROMNAME)(const char* modname);
typedef duint(*MODSIZEFROMADDR)(duint addr);
typedef bool (*ASSEMBLE)(duint addr, unsigned char* dest, int* size, const char* instruction, char* error);
typedef bool (*PATCHGET)(duint addr);
typedef bool (*PATCHINRANGE)(duint start, duint end);
typedef bool (*MEMPATCH)(duint va, const unsigned char* src, duint size);
typedef void (*PATCHRESTORERANGE)(duint start, duint end);
typedef bool (*PATCHENUM)(DBGPATCHINFO* patchlist, size_t* cbsize);
typedef bool (*PATCHRESTORE)(duint addr);
typedef int (*PATCHFILE)(DBGPATCHINFO* patchlist, int count, const char* szFileName, char* error);
typedef int (*MODPATHFROMADDR)(duint addr, char* path, int size);
typedef int (*MODPATHFROMNAME)(const char* modname, char* path, int size);
typedef bool (*DISASMFAST)(const unsigned char* data, duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
typedef void (*MEMUPDATEMAP)();
typedef void (*GETCALLSTACK)(DBGCALLSTACK* callstack);
typedef void (*GETSEHCHAIN)(DBGSEHCHAIN* sehchain);
typedef void (*SYMBOLDOWNLOADALLSYMBOLS)(const char* szSymbolStore);
typedef bool (*GETJIT)(char* jit, bool x64);
typedef bool (*GETJITAUTO)(bool* jitauto);
typedef bool (*GETDEFJIT)(char* defjit);
typedef bool (*GETPROCESSLIST)(DBGPROCESSINFO** entries, int* count);
typedef bool (*GETPAGERIGHTS)(duint addr, char* rights);
typedef bool (*SETPAGERIGHTS)(duint addr, const char* rights);
typedef bool (*PAGERIGHTSTOSTRING)(DWORD protect, char* rights);
typedef bool (*ISPROCESSELEVATED)();
typedef bool (*GETCMDLINE)(char* cmdline, size_t* cbsize);
typedef bool (*SETCMDLINE)(const char* cmdline);
typedef duint(*FILEOFFSETTOVA)(const char* modname, duint offset);
typedef duint(*VATOFILEOFFSET)(duint va);
typedef duint(*GETADDRFROMLINE)(const char* szSourceFile, int line, duint* displacement);
typedef bool (*GETSOURCEFROMADDR)(duint addr, char* szSourceFile, int* line);
typedef bool (*VALFROMSTRING)(const char* string, duint* value);
typedef bool (*PATCHGETEX)(duint addr, DBGPATCHINFO* info);
typedef bool (*GETBRIDGEBP)(BPXTYPE type, duint addr, BRIDGEBP* bp);
typedef bool (*STRINGFORMATINLINE)(const char* format, size_t resultSize, char* result);
typedef void (*GETMNEMONICBRIEF)(const char* mnem, size_t resultSize, char* result);
typedef unsigned int (*GETTRACERECORDHITCOUNT)(duint address);
typedef TRACERECORDBYTETYPE(*GETTRACERECORDBYTETYPE)(duint address);
typedef bool (*SETTRACERECORDTYPE)(duint pageAddress, TRACERECORDTYPE type);
typedef TRACERECORDTYPE(*GETTRACERECORDTYPE)(duint pageAddress);
typedef bool (*ENUMHANDLES)(ListOf(HANDLEINFO) handles);
typedef bool (*GETHANDLENAME)(duint handle, char* name, size_t nameSize, char* typeName, size_t typeNameSize);
typedef bool (*ENUMTCPCONNECTIONS)(ListOf(TCPCONNECTIONINFO) connections);
typedef duint(*GETDBGEVENTS)();
typedef int (*MODGETPARTY)(duint base);
typedef void (*MODSETPARTY)(duint base, int party);
typedef bool(*WATCHISWATCHDOGTRIGGERED)(unsigned int id);
typedef bool(*MEMISCODEPAGE)(duint addr, bool refresh);
typedef bool(*ANIMATECOMMAND)(const char* command);
typedef void(*DBGSETDEBUGGEEINITSCRIPT)(const char* fileName);
typedef const char* (*DBGGETDEBUGGEEINITSCRIPT)();
typedef bool(*HANDLESENUMWINDOWS)(ListOf(WINDOW_INFO) windows);
typedef bool(*HANDLESENUMHEAPS)(ListOf(HEAPINFO) heaps);
typedef bool(*THREADGETNAME)(DWORD tid, char* name);
typedef bool(*ISDEPENABLED)();
typedef void(*GETCALLSTACKEX)(DBGCALLSTACK* callstack, bool cache);
typedef bool(*GETUSERCOMMENT)(duint addr, char* comment);
typedef void(*ENUMCONSTANTS)(ListOf(CONSTANTINFO) constants);
typedef duint(*MEMBPSIZE)(duint addr);
typedef bool(*MODRELOCATIONSFROMADDR)(duint addr, ListOf(DBGRELOCATIONINFO) relocations);
typedef bool(*MODRELOCATIONATADDR)(duint addr, DBGRELOCATIONINFO* relocation);
typedef bool(*MODRELOCATIONSINRANGE)(duint addr, duint size, ListOf(DBGRELOCATIONINFO) relocations);

//The list of all the DbgFunctions() return value.
//WARNING: This list is append only. Do not insert things in the middle or plugins would break.
typedef struct DBGFUNCTIONS_
{
    ASSEMBLEATEX AssembleAtEx;
    SECTIONFROMADDR SectionFromAddr;
    MODNAMEFROMADDR ModNameFromAddr;
    MODBASEFROMADDR ModBaseFromAddr;
    MODBASEFROMNAME ModBaseFromName;
    MODSIZEFROMADDR ModSizeFromAddr;
    ASSEMBLE Assemble;
    PATCHGET PatchGet;
    PATCHINRANGE PatchInRange;
    MEMPATCH MemPatch;
    PATCHRESTORERANGE PatchRestoreRange;
    PATCHENUM PatchEnum;
    PATCHRESTORE PatchRestore;
    PATCHFILE PatchFile;
    MODPATHFROMADDR ModPathFromAddr;
    MODPATHFROMNAME ModPathFromName;
    DISASMFAST DisasmFast;
    MEMUPDATEMAP MemUpdateMap;
    GETCALLSTACK GetCallStack;
    GETSEHCHAIN GetSEHChain;
    SYMBOLDOWNLOADALLSYMBOLS SymbolDownloadAllSymbols;
    GETJITAUTO GetJitAuto;
    GETJIT GetJit;
    GETDEFJIT GetDefJit;
    GETPROCESSLIST GetProcessList;
    GETPAGERIGHTS GetPageRights;
    SETPAGERIGHTS SetPageRights;
    PAGERIGHTSTOSTRING PageRightsToString;
    ISPROCESSELEVATED IsProcessElevated;
    GETCMDLINE GetCmdline;
    SETCMDLINE SetCmdline;
    FILEOFFSETTOVA FileOffsetToVa;
    VATOFILEOFFSET VaToFileOffset;
    GETADDRFROMLINE GetAddrFromLine;
    GETSOURCEFROMADDR GetSourceFromAddr;
    VALFROMSTRING ValFromString;
    PATCHGETEX PatchGetEx;
    GETBRIDGEBP GetBridgeBp;
    STRINGFORMATINLINE StringFormatInline;
    GETMNEMONICBRIEF GetMnemonicBrief;
    GETTRACERECORDHITCOUNT GetTraceRecordHitCount;
    GETTRACERECORDBYTETYPE GetTraceRecordByteType;
    SETTRACERECORDTYPE SetTraceRecordType;
    GETTRACERECORDTYPE GetTraceRecordType;
    ENUMHANDLES EnumHandles;
    GETHANDLENAME GetHandleName;
    ENUMTCPCONNECTIONS EnumTcpConnections;
    GETDBGEVENTS GetDbgEvents;
    MODGETPARTY ModGetParty;
    MODSETPARTY ModSetParty;
    WATCHISWATCHDOGTRIGGERED WatchIsWatchdogTriggered;
    MEMISCODEPAGE MemIsCodePage;
    ANIMATECOMMAND AnimateCommand;
    DBGSETDEBUGGEEINITSCRIPT DbgSetDebuggeeInitScript;
    DBGGETDEBUGGEEINITSCRIPT DbgGetDebuggeeInitScript;
    HANDLESENUMWINDOWS EnumWindows;
    HANDLESENUMHEAPS EnumHeaps;
    THREADGETNAME ThreadGetName;
    ISDEPENABLED IsDepEnabled;
    GETCALLSTACKEX GetCallStackEx;
    GETUSERCOMMENT GetUserComment;
    ENUMCONSTANTS EnumConstants;
    ENUMCONSTANTS EnumErrorCodes;
    ENUMCONSTANTS EnumExceptions;
    MEMBPSIZE MemBpSize;
    MODRELOCATIONSFROMADDR ModRelocationsFromAddr;
    MODRELOCATIONATADDR ModRelocationAtAddr;
    MODRELOCATIONSINRANGE ModRelocationsInRange;
} DBGFUNCTIONS;

#ifdef BUILD_DBG

const DBGFUNCTIONS* dbgfunctionsget();
void dbgfunctionsinit();

#endif //BUILD_DBG

#endif //_DBGFUNCTIONS_H

```

`src/x64dbgPlaytime/pluginsdk/_plugin_types.h`:

```h
#ifndef _PLUGIN_DATA_H
#define _PLUGIN_DATA_H

#ifdef BUILD_DBG

#include "_global.h"
#include "jansson/jansson.h"
#include <dbghelp.h>

#else

#ifdef __GNUC__
#include "dbghelp/dbghelp.h"
#else
#pragma warning(push)
#pragma warning(disable:4091)
#include <dbghelp.h>
#pragma warning(pop)
#endif // __GNUC__

#ifndef deflen
#define deflen 1024
#endif // deflen

#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "jansson/jansson.h"

#endif // BUILD_DBG

#endif // _PLUGIN_DATA_H

```

`src/x64dbgPlaytime/pluginsdk/_plugins.h`:

```h
#ifndef _PLUGINS_H
#define _PLUGINS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifndef PLUG_IMPEXP
#ifdef BUILD_DBG
#define PLUG_IMPEXP __declspec(dllexport)
#else
#define PLUG_IMPEXP __declspec(dllimport)
#endif //BUILD_DBG
#endif //PLUG_IMPEXP

#include "_plugin_types.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

//defines
#define PLUG_SDKVERSION 1

#define PLUG_DB_LOADSAVE_DATA 1
#define PLUG_DB_LOADSAVE_ALL 2

//structures
typedef struct
{
    //provided by the debugger
    int pluginHandle;
    //provided by the pluginit function
    int sdkVersion;
    int pluginVersion;
    char pluginName[256];
} PLUG_INITSTRUCT;

typedef struct
{
    //provided by the debugger
    HWND hwndDlg; //gui window handle
    int hMenu; //plugin menu handle
    int hMenuDisasm; //plugin disasm menu handle
    int hMenuDump; //plugin dump menu handle
    int hMenuStack; //plugin stack menu handle
} PLUG_SETUPSTRUCT;

typedef struct
{
    void* data; //user data
} PLUG_SCRIPTSTRUCT;

//callback structures
typedef struct
{
    const char* szFileName;
} PLUG_CB_INITDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPDEBUG;

typedef struct
{
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
    void* modInfo;
    const char* DebugFileName;
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_CREATEPROCESS;

typedef struct
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess;
} PLUG_CB_EXITPROCESS;

typedef struct
{
    CREATE_THREAD_DEBUG_INFO* CreateThread;
    DWORD dwThreadId;
} PLUG_CB_CREATETHREAD;

typedef struct
{
    EXIT_THREAD_DEBUG_INFO* ExitThread;
    DWORD dwThreadId;
} PLUG_CB_EXITTHREAD;

typedef struct
{
    void* reserved;
} PLUG_CB_SYSTEMBREAKPOINT;

typedef struct
{
    LOAD_DLL_DEBUG_INFO* LoadDll;
    void* modInfo;
    const char* modname;
} PLUG_CB_LOADDLL;

typedef struct
{
    UNLOAD_DLL_DEBUG_INFO* UnloadDll;
} PLUG_CB_UNLOADDLL;

typedef struct
{
    OUTPUT_DEBUG_STRING_INFO* DebugString;
} PLUG_CB_OUTPUTDEBUGSTRING;

typedef struct
{
    EXCEPTION_DEBUG_INFO* Exception;
} PLUG_CB_EXCEPTION;

typedef struct
{
    BRIDGEBP* breakpoint;
} PLUG_CB_BREAKPOINT;

typedef struct
{
    void* reserved;
} PLUG_CB_PAUSEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_RESUMEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STEPPED;

typedef struct
{
    DWORD dwProcessId;
} PLUG_CB_ATTACH;

typedef struct
{
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_DETACH;

typedef struct
{
    DEBUG_EVENT* DebugEvent;
} PLUG_CB_DEBUGEVENT;

typedef struct
{
    int hEntry;
} PLUG_CB_MENUENTRY;

typedef struct
{
    MSG* message;
    long* result;
    bool retval;
} PLUG_CB_WINEVENT;

typedef struct
{
    MSG* message;
    bool retval;
} PLUG_CB_WINEVENTGLOBAL;

typedef struct
{
    json_t* root;
    int loadSaveType;
} PLUG_CB_LOADSAVEDB;

typedef struct
{
    const char* symbol;
    bool retval;
} PLUG_CB_FILTERSYMBOL;

typedef struct
{
    duint cip;
    bool stop;
} PLUG_CB_TRACEEXECUTE;

typedef struct
{
    int hWindow;
    duint VA;
} PLUG_CB_SELCHANGED;

typedef struct
{
    BridgeCFGraphList graph;
} PLUG_CB_ANALYZE;

typedef struct
{
    duint addr;
    BRIDGE_ADDRINFO* addrinfo;
    bool retval;
} PLUG_CB_ADDRINFO;

typedef struct
{
    const char* string;
    duint value;
    int* value_size;
    bool* isvar;
    bool* hexonly;
    bool retval;
} PLUG_CB_VALFROMSTRING;

typedef struct
{
    const char* string;
    duint value;
    bool retval;
} PLUG_CB_VALTOSTRING;

typedef struct
{
    int hMenu;
} PLUG_CB_MENUPREPARE;

//enums
typedef enum
{
    CB_INITDEBUG, //PLUG_CB_INITDEBUG
    CB_STOPDEBUG, //PLUG_CB_STOPDEBUG
    CB_CREATEPROCESS, //PLUG_CB_CREATEPROCESS
    CB_EXITPROCESS, //PLUG_CB_EXITPROCESS
    CB_CREATETHREAD, //PLUG_CB_CREATETHREAD
    CB_EXITTHREAD, //PLUG_CB_EXITTHREAD
    CB_SYSTEMBREAKPOINT, //PLUG_CB_SYSTEMBREAKPOINT
    CB_LOADDLL, //PLUG_CB_LOADDLL
    CB_UNLOADDLL, //PLUG_CB_UNLOADDLL
    CB_OUTPUTDEBUGSTRING, //PLUG_CB_OUTPUTDEBUGSTRING
    CB_EXCEPTION, //PLUG_CB_EXCEPTION
    CB_BREAKPOINT, //PLUG_CB_BREAKPOINT
    CB_PAUSEDEBUG, //PLUG_CB_PAUSEDEBUG
    CB_RESUMEDEBUG, //PLUG_CB_RESUMEDEBUG
    CB_STEPPED, //PLUG_CB_STEPPED
    CB_ATTACH, //PLUG_CB_ATTACHED (before attaching, after CB_INITDEBUG)
    CB_DETACH, //PLUG_CB_DETACH (before detaching, before CB_STOPDEBUG)
    CB_DEBUGEVENT, //PLUG_CB_DEBUGEVENT (called on any debug event)
    CB_MENUENTRY, //PLUG_CB_MENUENTRY
    CB_WINEVENT, //PLUG_CB_WINEVENT
    CB_WINEVENTGLOBAL, //PLUG_CB_WINEVENTGLOBAL
    CB_LOADDB, //PLUG_CB_LOADSAVEDB
    CB_SAVEDB, //PLUG_CB_LOADSAVEDB
    CB_FILTERSYMBOL, //PLUG_CB_FILTERSYMBOL
    CB_TRACEEXECUTE, //PLUG_CB_TRACEEXECUTE
    CB_SELCHANGED, //PLUG_CB_SELCHANGED
    CB_ANALYZE, //PLUG_CB_ANALYZE
    CB_ADDRINFO, //PLUG_CB_ADDRINFO
    CB_VALFROMSTRING, //PLUG_CB_VALFROMSTRING
    CB_VALTOSTRING, //PLUG_CB_VALTOSTRING
    CB_MENUPREPARE, //PLUG_CB_MENUPREPARE
    CB_LAST
} CBTYPE;

typedef enum
{
    FORMAT_ERROR, //generic failure (no message)
    FORMAT_SUCCESS, //success
    FORMAT_ERROR_MESSAGE, //formatting failed but an error was put in the buffer (there are always at least 511 characters available).
    FORMAT_BUFFER_TOO_SMALL //buffer too small (x64dbg will retry until the buffer is big enough)
} FORMATRESULT;

//typedefs
typedef void (*CBPLUGIN)(CBTYPE cbType, void* callbackInfo);
typedef bool (*CBPLUGINCOMMAND)(int argc, char** argv);
typedef void (*CBPLUGINSCRIPT)();
typedef duint(*CBPLUGINEXPRFUNCTION)(int argc, duint* argv, void* userdata);
typedef FORMATRESULT(*CBPLUGINFORMATFUNCTION)(char* dest, size_t destCount, int argc, char* argv[], duint value, void* userdata);
typedef bool (*CBPLUGINPREDICATE)(void* userdata);

//exports
#ifdef __cplusplus
extern "C"
{
#endif

PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
PLUG_IMPEXP bool _plugin_unregistercallback(int pluginHandle, CBTYPE cbType);
PLUG_IMPEXP bool _plugin_registercommand(int pluginHandle, const char* command, CBPLUGINCOMMAND cbCommand, bool debugonly);
PLUG_IMPEXP bool _plugin_unregistercommand(int pluginHandle, const char* command);
PLUG_IMPEXP void _plugin_logprintf(const char* format, ...);
PLUG_IMPEXP void _plugin_logputs(const char* text);
PLUG_IMPEXP void _plugin_logprint(const char* text);
PLUG_IMPEXP void _plugin_debugpause();
PLUG_IMPEXP void _plugin_debugskipexceptions(bool skip);
PLUG_IMPEXP int _plugin_menuadd(int hMenu, const char* title);
PLUG_IMPEXP bool _plugin_menuaddentry(int hMenu, int hEntry, const char* title);
PLUG_IMPEXP bool _plugin_menuaddseparator(int hMenu);
PLUG_IMPEXP bool _plugin_menuclear(int hMenu);
PLUG_IMPEXP void _plugin_menuseticon(int hMenu, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentryseticon(int pluginHandle, int hEntry, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentrysetchecked(int pluginHandle, int hEntry, bool checked);
PLUG_IMPEXP void _plugin_menusetvisible(int pluginHandle, int hMenu, bool visible);
PLUG_IMPEXP void _plugin_menuentrysetvisible(int pluginHandle, int hEntry, bool visible);
PLUG_IMPEXP void _plugin_menusetname(int pluginHandle, int hMenu, const char* name);
PLUG_IMPEXP void _plugin_menuentrysetname(int pluginHandle, int hEntry, const char* name);
PLUG_IMPEXP void _plugin_menuentrysethotkey(int pluginHandle, int hEntry, const char* hotkey);
PLUG_IMPEXP bool _plugin_menuremove(int hMenu);
PLUG_IMPEXP bool _plugin_menuentryremove(int pluginHandle, int hEntry);
PLUG_IMPEXP void _plugin_startscript(CBPLUGINSCRIPT cbScript);
PLUG_IMPEXP bool _plugin_waituntilpaused();
PLUG_IMPEXP bool _plugin_registerexprfunction(int pluginHandle, const char* name, int argc, CBPLUGINEXPRFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterexprfunction(int pluginHandle, const char* name);
PLUG_IMPEXP bool _plugin_unload(const char* pluginName);
PLUG_IMPEXP bool _plugin_load(const char* pluginName);
PLUG_IMPEXP duint _plugin_hash(const void* data, duint size);
PLUG_IMPEXP bool _plugin_registerformatfunction(int pluginHandle, const char* type, CBPLUGINFORMATFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterformatfunction(int pluginHandle, const char* type);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _PLUGINS_H

```

`src/x64dbgPlaytime/pluginsdk/_scriptapi.h`:

```h
#ifndef _SCRIPT_API_H
#define _SCRIPT_API_H

#include "_plugins.h"

#define SCRIPT_EXPORT PLUG_IMPEXP

#endif //_SCRIPT_API_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_argument.h`:

```h
#ifndef _SCRIPTAPI_ARGUMENT_H
#define _SCRIPTAPI_ARGUMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Argument
    {
        struct ArgumentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const ArgumentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, ArgumentInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual = false);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(ArgumentInfo) list); //caller has the responsibility to free the list
    }; //Argument
}; //Script

#endif //_SCRIPTAPI_ARGUMENT_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_assembler.h`:

```h
#ifndef _SCRIPTAPI_ASSEMBLER_H
#define _SCRIPTAPI_ASSEMBLER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Assembler
    {
        SCRIPT_EXPORT bool Assemble(duint addr, unsigned char* dest, int* size, const char* instruction); //dest[16]
        SCRIPT_EXPORT bool AssembleEx(duint addr, unsigned char* dest, int* size, const char* instruction, char* error); //dest[16], error[MAX_ERROR_SIZE]
        SCRIPT_EXPORT bool AssembleMem(duint addr, const char* instruction);
        SCRIPT_EXPORT bool AssembleMemEx(duint addr, const char* instruction, int* size, char* error, bool fillnop); //error[MAX_ERROR_SIZE]
    }; //Assembler
}; //Script

#endif //_SCRIPTAPI_ASSEMBLER_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_bookmark.h`:

```h
#ifndef _SCRIPTAPI_BOOKMARK_H
#define _SCRIPTAPI_BOOKMARK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Bookmark
    {
        struct BookmarkInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, bool manual = false);
        SCRIPT_EXPORT bool Set(const BookmarkInfo* info);
        SCRIPT_EXPORT bool Get(duint addr);
        SCRIPT_EXPORT bool GetInfo(duint addr, BookmarkInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(BookmarkInfo) list); //caller has the responsibility to free the list
    }; //Bookmark
}; //Script

#endif //_SCRIPTAPI_BOOKMARK_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_comment.h`:

```h
#ifndef _SCRIPTAPI_COMMENT_H
#define _SCRIPTAPI_COMMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Comment
    {
        struct CommentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const CommentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_COMMENT_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, CommentInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(CommentInfo) list); //caller has the responsibility to free the list
    }; //Comment
}; //Script

#endif //_SCRIPTAPI_COMMENT_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_debug.h`:

```h
#ifndef _SCRIPTAPI_DEBUG_H
#define _SCRIPTAPI_DEBUG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Debug
    {
        enum HardwareType
        {
            HardwareAccess,
            HardwareWrite,
            HardwareExecute
        };

        SCRIPT_EXPORT void Wait();
        SCRIPT_EXPORT void Run();
        SCRIPT_EXPORT void Pause();
        SCRIPT_EXPORT void Stop();
        SCRIPT_EXPORT void StepIn();
        SCRIPT_EXPORT void StepOver();
        SCRIPT_EXPORT void StepOut();
        SCRIPT_EXPORT bool SetBreakpoint(duint address);
        SCRIPT_EXPORT bool DeleteBreakpoint(duint address);
        SCRIPT_EXPORT bool DisableBreakpoint(duint address);
        SCRIPT_EXPORT bool SetHardwareBreakpoint(duint address, HardwareType type = HardwareExecute);
        SCRIPT_EXPORT bool DeleteHardwareBreakpoint(duint address);
    }; //Debug
}; //Script

#endif //_SCRIPTAPI_DEBUG_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_flag.h`:

```h
#ifndef _SCRIPTAPI_FLAG_H
#define _SCRIPTAPI_FLAG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Flag
    {
        enum FlagEnum
        {
            ZF,
            OF,
            CF,
            PF,
            SF,
            TF,
            AF,
            DF,
            IF
        };

        SCRIPT_EXPORT bool Get(FlagEnum flag);
        SCRIPT_EXPORT bool Set(FlagEnum flag, bool value);

        SCRIPT_EXPORT bool GetZF();
        SCRIPT_EXPORT bool SetZF(bool value);
        SCRIPT_EXPORT bool GetOF();
        SCRIPT_EXPORT bool SetOF(bool value);
        SCRIPT_EXPORT bool GetCF();
        SCRIPT_EXPORT bool SetCF(bool value);
        SCRIPT_EXPORT bool GetPF();
        SCRIPT_EXPORT bool SetPF(bool value);
        SCRIPT_EXPORT bool GetSF();
        SCRIPT_EXPORT bool SetSF(bool value);
        SCRIPT_EXPORT bool GetTF();
        SCRIPT_EXPORT bool SetTF(bool value);
        SCRIPT_EXPORT bool GetAF();
        SCRIPT_EXPORT bool SetAF(bool value);
        SCRIPT_EXPORT bool GetDF();
        SCRIPT_EXPORT bool SetDF(bool value);
        SCRIPT_EXPORT bool GetIF();
        SCRIPT_EXPORT bool SetIF(bool value);
    };
};

#endif //_SCRIPTAPI_FLAG_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_function.h`:

```h
#ifndef _SCRIPTAPI_FUNCTION_H
#define _SCRIPTAPI_FUNCTION_H

#include "_scriptapi.h"

namespace Script
{
    namespace Function
    {
        struct FunctionInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const FunctionInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, FunctionInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(FunctionInfo) list); //caller has the responsibility to free the list
    }; //Function
}; //Script

#endif //_SCRIPTAPI_FUNCTION_H

```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_gui.h`:

```h
#ifndef _SCRIPTAPI_GUI_H
#define _SCRIPTAPI_GUI_H

#include "_scriptapi.h"

namespace Script
{
    namespace Gui
    {
        namespace Disassembly
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Disassembly

        namespace Dump
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Dump

        namespace Stack
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Stack

        namespace Graph
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //Graph

        namespace MemMap
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //MemoryMap

        namespace SymMod
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //SymMod
    }; //Gui

    namespace Gui
    {
        enum Window
        {
            DisassemblyWindow,
            DumpWindow,
            StackWindow,
            GraphWindow,
            MemMapWindow,
            SymModWindow
        };

        SCRIPT_EXPORT bool SelectionGet(Window window, duint* start, duint* end);
        SCRIPT_EXPORT bool SelectionSet(Window window, duint start, duint end);
        SCRIPT_EXPORT duint SelectionGetStart(Window window);
        SCRIPT_EXPORT duint SelectionGetEnd(Window window);
        SCRIPT_EXPORT void Message(const char* message);
        SCRIPT_EXPORT bool MessageYesNo(const char* message);
        SCRIPT_EXPORT bool InputLine(const char* title, char* text); //text[GUI_MAX_LINE_SIZE]
        SCRIPT_EXPORT bool InputValue(const char* title, duint* value);
        SCRIPT_EXPORT void Refresh();
        SCRIPT_EXPORT void AddQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void ShowQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void CloseQWidgetTab(void* qWidget);

    }; //Gui
}; //Script

#endif //_SCRIPTAPI_GUI_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_label.h`:

```h
#ifndef _SCRIPTAPI_LABEL_H
#define _SCRIPTAPI_LABEL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Label
    {
        struct LabelInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const LabelInfo* info);
        SCRIPT_EXPORT bool FromString(const char* label, duint* addr);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_LABEL_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, LabelInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(LabelInfo) list); //caller has the responsibility to free the list
    }; //Label
}; //Script

#endif //_SCRIPTAPI_LABEL_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_memory.h`:

```h
#ifndef _SCRIPTAPI_MEMORY_H
#define _SCRIPTAPI_MEMORY_H

#include "_scriptapi.h"

namespace Script
{
    namespace Memory
    {
        SCRIPT_EXPORT bool Read(duint addr, void* data, duint size, duint* sizeRead);
        SCRIPT_EXPORT bool Write(duint addr, const void* data, duint size, duint* sizeWritten);
        SCRIPT_EXPORT bool IsValidPtr(duint addr);
        SCRIPT_EXPORT duint RemoteAlloc(duint addr, duint size);
        SCRIPT_EXPORT bool RemoteFree(duint addr);
        SCRIPT_EXPORT unsigned int GetProtect(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetBase(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetSize(duint addr, bool reserved = false, bool cache = true);

        SCRIPT_EXPORT unsigned char ReadByte(duint addr);
        SCRIPT_EXPORT bool WriteByte(duint addr, unsigned char data);
        SCRIPT_EXPORT unsigned short ReadWord(duint addr);
        SCRIPT_EXPORT bool WriteWord(duint addr, unsigned short data);
        SCRIPT_EXPORT unsigned int ReadDword(duint addr);
        SCRIPT_EXPORT bool WriteDword(duint addr, unsigned int data);
        SCRIPT_EXPORT unsigned long long ReadQword(duint addr);
        SCRIPT_EXPORT bool WriteQword(duint addr, unsigned long long data);
        SCRIPT_EXPORT duint ReadPtr(duint addr);
        SCRIPT_EXPORT bool WritePtr(duint addr, duint data);
    }; //Memory
}; //Script

#endif //_SCRIPTAPI_MEMORY_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_misc.h`:

```h
#ifndef _SCRIPTAPI_MISC_H
#define _SCRIPTAPI_MISC_H

#include "_scriptapi.h"

namespace Script
{
    namespace Misc
    {
        SCRIPT_EXPORT bool ParseExpression(const char* expression, duint* value);
        SCRIPT_EXPORT duint RemoteGetProcAddress(const char* module, const char* api);
        SCRIPT_EXPORT duint ResolveLabel(const char* label);
        SCRIPT_EXPORT void* Alloc(duint size);
        SCRIPT_EXPORT void Free(void* ptr);
    }; //Misc
}; //Script

#endif //_SCRIPTAPI_MISC_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_module.h`:

```h
#ifndef _SCRIPTAPI_MODULE_H
#define _SCRIPTAPI_MODULE_H

#include "_scriptapi.h"

namespace Script
{
    namespace Module
    {
        struct ModuleInfo
        {
            duint base;
            duint size;
            duint entry;
            int sectionCount;
            char name[MAX_MODULE_SIZE];
            char path[MAX_PATH];
        };

        struct ModuleSectionInfo
        {
            duint addr;
            duint size;
            char name[MAX_SECTION_SIZE * 5];
        };

        SCRIPT_EXPORT bool InfoFromAddr(duint addr, ModuleInfo* info);
        SCRIPT_EXPORT bool InfoFromName(const char* name, ModuleInfo* info);
        SCRIPT_EXPORT duint BaseFromAddr(duint addr);
        SCRIPT_EXPORT duint BaseFromName(const char* name);
        SCRIPT_EXPORT duint SizeFromAddr(duint addr);
        SCRIPT_EXPORT duint SizeFromName(const char* name);
        SCRIPT_EXPORT bool NameFromAddr(duint addr, char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool PathFromAddr(duint addr, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool PathFromName(const char* name, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT duint EntryFromAddr(duint addr);
        SCRIPT_EXPORT duint EntryFromName(const char* name);
        SCRIPT_EXPORT int SectionCountFromAddr(duint addr);
        SCRIPT_EXPORT int SectionCountFromName(const char* name);
        SCRIPT_EXPORT bool SectionFromAddr(duint addr, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionFromName(const char* name, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionListFromAddr(duint addr, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool SectionListFromName(const char* name, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool GetMainModuleInfo(ModuleInfo* info);
        SCRIPT_EXPORT duint GetMainModuleBase();
        SCRIPT_EXPORT duint GetMainModuleSize();
        SCRIPT_EXPORT duint GetMainModuleEntry();
        SCRIPT_EXPORT int GetMainModuleSectionCount();
        SCRIPT_EXPORT bool GetMainModuleName(char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool GetMainModulePath(char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool GetMainModuleSectionList(ListOf(ModuleSectionInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetList(ListOf(ModuleInfo) list); //caller has the responsibility to free the list
    }; //Module
}; //Script

#endif //_SCRIPTAPI_MODULE_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_pattern.h`:

```h
#ifndef _SCRIPTAPI_PATTERN_H
#define _SCRIPTAPI_PATTERN_H

#include "_scriptapi.h"

namespace Script
{
    namespace Pattern
    {
        SCRIPT_EXPORT duint Find(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT duint FindMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT void Write(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT void WriteMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT bool SearchAndReplace(unsigned char* data, duint datasize, const char* searchpattern, const char* replacepattern);
        SCRIPT_EXPORT bool SearchAndReplaceMem(duint start, duint size, const char* searchpattern, const char* replacepattern);
    };
};

#endif //_SCRIPTAPI_FIND_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_register.h`:

```h
#ifndef _SCRIPTAPI_REGISTER_H
#define _SCRIPTAPI_REGISTER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Register
    {
        enum RegisterEnum
        {
            DR0,
            DR1,
            DR2,
            DR3,
            DR6,
            DR7,

            EAX,
            AX,
            AH,
            AL,
            EBX,
            BX,
            BH,
            BL,
            ECX,
            CX,
            CH,
            CL,
            EDX,
            DX,
            DH,
            DL,
            EDI,
            DI,
            ESI,
            SI,
            EBP,
            BP,
            ESP,
            SP,
            EIP,

#ifdef _WIN64
            RAX,
            RBX,
            RCX,
            RDX,
            RSI,
            SIL,
            RDI,
            DIL,
            RBP,
            BPL,
            RSP,
            SPL,
            RIP,
            R8,
            R8D,
            R8W,
            R8B,
            R9,
            R9D,
            R9W,
            R9B,
            R10,
            R10D,
            R10W,
            R10B,
            R11,
            R11D,
            R11W,
            R11B,
            R12,
            R12D,
            R12W,
            R12B,
            R13,
            R13D,
            R13W,
            R13B,
            R14,
            R14D,
            R14W,
            R14B,
            R15,
            R15D,
            R15W,
            R15B,
#endif //_WIN64

            CIP,
            CSP,
            CAX,
            CBX,
            CCX,
            CDX,
            CDI,
            CSI,
            CBP,
            CFLAGS
        }; //RegisterEnum

        SCRIPT_EXPORT duint Get(RegisterEnum reg);
        SCRIPT_EXPORT bool Set(RegisterEnum reg, duint value);
        SCRIPT_EXPORT int Size(); //gets architecture register size in bytes

        SCRIPT_EXPORT duint GetDR0();
        SCRIPT_EXPORT bool SetDR0(duint value);
        SCRIPT_EXPORT duint GetDR1();
        SCRIPT_EXPORT bool SetDR1(duint value);
        SCRIPT_EXPORT duint GetDR2();
        SCRIPT_EXPORT bool SetDR2(duint value);
        SCRIPT_EXPORT duint GetDR3();
        SCRIPT_EXPORT bool SetDR3(duint value);
        SCRIPT_EXPORT duint GetDR6();
        SCRIPT_EXPORT bool SetDR6(duint value);
        SCRIPT_EXPORT duint GetDR7();
        SCRIPT_EXPORT bool SetDR7(duint value);

        SCRIPT_EXPORT unsigned int GetEAX();
        SCRIPT_EXPORT bool SetEAX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetAX();
        SCRIPT_EXPORT bool SetAX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetAH();
        SCRIPT_EXPORT bool SetAH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetAL();
        SCRIPT_EXPORT bool SetAL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEBX();
        SCRIPT_EXPORT bool SetEBX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBX();
        SCRIPT_EXPORT bool SetBX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetBH();
        SCRIPT_EXPORT bool SetBH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetBL();
        SCRIPT_EXPORT bool SetBL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetECX();
        SCRIPT_EXPORT bool SetECX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetCX();
        SCRIPT_EXPORT bool SetCX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetCH();
        SCRIPT_EXPORT bool SetCH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetCL();
        SCRIPT_EXPORT bool SetCL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDX();
        SCRIPT_EXPORT bool SetEDX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDX();
        SCRIPT_EXPORT bool SetDX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetDH();
        SCRIPT_EXPORT bool SetDH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetDL();
        SCRIPT_EXPORT bool SetDL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDI();
        SCRIPT_EXPORT bool SetEDI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDI();
        SCRIPT_EXPORT bool SetDI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESI();
        SCRIPT_EXPORT bool SetESI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSI();
        SCRIPT_EXPORT bool SetSI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEBP();
        SCRIPT_EXPORT bool SetEBP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBP();
        SCRIPT_EXPORT bool SetBP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESP();
        SCRIPT_EXPORT bool SetESP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSP();
        SCRIPT_EXPORT bool SetSP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEIP();
        SCRIPT_EXPORT bool SetEIP(unsigned int value);

#ifdef _WIN64
        SCRIPT_EXPORT unsigned long long GetRAX();
        SCRIPT_EXPORT bool SetRAX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRBX();
        SCRIPT_EXPORT bool SetRBX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRCX();
        SCRIPT_EXPORT bool SetRCX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRDX();
        SCRIPT_EXPORT bool SetRDX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRSI();
        SCRIPT_EXPORT bool SetRSI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSIL();
        SCRIPT_EXPORT bool SetSIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRDI();
        SCRIPT_EXPORT bool SetRDI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetDIL();
        SCRIPT_EXPORT bool SetDIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRBP();
        SCRIPT_EXPORT bool SetRBP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetBPL();
        SCRIPT_EXPORT bool SetBPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRSP();
        SCRIPT_EXPORT bool SetRSP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSPL();
        SCRIPT_EXPORT bool SetSPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRIP();
        SCRIPT_EXPORT bool SetRIP(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetR8();
        SCRIPT_EXPORT bool SetR8(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR8D();
        SCRIPT_EXPORT bool SetR8D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR8W();
        SCRIPT_EXPORT bool SetR8W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR8B();
        SCRIPT_EXPORT bool SetR8B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR9();
        SCRIPT_EXPORT bool SetR9(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR9D();
        SCRIPT_EXPORT bool SetR9D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR9W();
        SCRIPT_EXPORT bool SetR9W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR9B();
        SCRIPT_EXPORT bool SetR9B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR10();
        SCRIPT_EXPORT bool SetR10(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR10D();
        SCRIPT_EXPORT bool SetR10D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR10W();
        SCRIPT_EXPORT bool SetR10W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR10B();
        SCRIPT_EXPORT bool SetR10B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR11();
        SCRIPT_EXPORT bool SetR11(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR11D();
        SCRIPT_EXPORT bool SetR11D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR11W();
        SCRIPT_EXPORT bool SetR11W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR11B();
        SCRIPT_EXPORT bool SetR11B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR12();
        SCRIPT_EXPORT bool SetR12(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR12D();
        SCRIPT_EXPORT bool SetR12D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR12W();
        SCRIPT_EXPORT bool SetR12W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR12B();
        SCRIPT_EXPORT bool SetR12B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR13();
        SCRIPT_EXPORT bool SetR13(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR13D();
        SCRIPT_EXPORT bool SetR13D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR13W();
        SCRIPT_EXPORT bool SetR13W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR13B();
        SCRIPT_EXPORT bool SetR13B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR14();
        SCRIPT_EXPORT bool SetR14(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR14D();
        SCRIPT_EXPORT bool SetR14D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR14W();
        SCRIPT_EXPORT bool SetR14W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR14B();
        SCRIPT_EXPORT bool SetR14B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR15();
        SCRIPT_EXPORT bool SetR15(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR15D();
        SCRIPT_EXPORT bool SetR15D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR15W();
        SCRIPT_EXPORT bool SetR15W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR15B();
        SCRIPT_EXPORT bool SetR15B(unsigned char value);
#endif //_WIN64

        SCRIPT_EXPORT duint GetCAX();
        SCRIPT_EXPORT bool SetCAX(duint value);
        SCRIPT_EXPORT duint GetCBX();
        SCRIPT_EXPORT bool SetCBX(duint value);
        SCRIPT_EXPORT duint GetCCX();
        SCRIPT_EXPORT bool SetCCX(duint value);
        SCRIPT_EXPORT duint GetCDX();
        SCRIPT_EXPORT bool SetCDX(duint value);
        SCRIPT_EXPORT duint GetCDI();
        SCRIPT_EXPORT bool SetCDI(duint value);
        SCRIPT_EXPORT duint GetCSI();
        SCRIPT_EXPORT bool SetCSI(duint value);
        SCRIPT_EXPORT duint GetCBP();
        SCRIPT_EXPORT bool SetCBP(duint value);
        SCRIPT_EXPORT duint GetCSP();
        SCRIPT_EXPORT bool SetCSP(duint value);
        SCRIPT_EXPORT duint GetCIP();
        SCRIPT_EXPORT bool SetCIP(duint value);
        SCRIPT_EXPORT duint GetCFLAGS();
        SCRIPT_EXPORT bool SetCFLAGS(duint value);
    }; //Register
}; //Script

#endif //_SCRIPTAPI_REGISTER_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_stack.h`:

```h
#ifndef _SCRIPTAPI_STACK_H
#define _SCRIPTAPI_STACK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Stack
    {
        SCRIPT_EXPORT duint Pop();
        SCRIPT_EXPORT duint Push(duint value); //returns the previous top, equal to Peek(1)
        SCRIPT_EXPORT duint Peek(int offset = 0); //offset is in multiples of Register::Size(), for easy x32/x64 portability
    }; //Stack
}; //Script

#endif //_SCRIPTAPI_STACK_H
```

`src/x64dbgPlaytime/pluginsdk/_scriptapi_symbol.h`:

```h
#ifndef _SCRIPTAPI_SYMBOL_H
#define _SCRIPTAPI_SYMBOL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Symbol
    {
        enum SymbolType
        {
            Function, //user-defined function
            Import, //IAT entry
            Export //export
        };

        struct SymbolInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char name[MAX_LABEL_SIZE];
            bool manual;
            SymbolType type;
        };

        SCRIPT_EXPORT bool GetList(ListOf(SymbolInfo) list); //caller has the responsibility to free the list
    }; //Symbol
}; //Script

#endif //_SCRIPTAPI_SYMBOL_H
```

`src/x64dbgPlaytime/pluginsdk/bridgegraph.h`:

```h
#ifndef _GRAPH_H
#define _GRAPH_H

typedef struct
{
    duint addr; //virtual address of the instruction
    unsigned char data[15]; //instruction bytes
} BridgeCFInstruction;

typedef struct
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    ListInfo exits; //exits (including brtrue and brfalse, duint)
    ListInfo instrs; //block instructions
} BridgeCFNodeList;

typedef struct
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    ListInfo nodes; //graph nodes (BridgeCFNodeList)
} BridgeCFGraphList;

#ifdef __cplusplus
#if _MSC_VER >= 1700 && !defined(NO_CPP11)

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <utility>

struct BridgeCFNode
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    std::vector<duint> exits; //exits (including brtrue and brfalse)
    std::vector<BridgeCFInstruction> instrs; //block instructions

    static void Free(const BridgeCFNodeList* nodeList)
    {
        if(!BridgeList<duint>::Free(&nodeList->exits))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::Free(&nodeList->instrs))
            __debugbreak();
    }

    explicit BridgeCFNode(const BridgeCFNodeList* nodeList, bool freedata)
    {
        if(!nodeList)
            __debugbreak();
        parentGraph = nodeList->parentGraph;
        start = nodeList->start;
        end = nodeList->end;
        brtrue = nodeList->brtrue;
        brfalse = nodeList->brfalse;
        icount = nodeList->icount;
        terminal = nodeList->terminal;
        indirectcall = nodeList->indirectcall;
        split = nodeList->split;
        userdata = nodeList->userdata;
        if(!BridgeList<duint>::ToVector(&nodeList->exits, exits, freedata))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::ToVector(&nodeList->instrs, instrs, freedata))
            __debugbreak();
    }

    explicit BridgeCFNode(duint parentGraph, duint start, duint end)
        : parentGraph(parentGraph),
          start(start),
          end(end),
          brtrue(0),
          brfalse(0),
          icount(0),
          terminal(false),
          indirectcall(false),
          split(false),
          userdata(nullptr)
    {
    }

    explicit BridgeCFNode()
        : parentGraph(0),
          start(0),
          end(0),
          brtrue(0),
          brfalse(0),
          icount(0),
          terminal(false),
          split(false),
          userdata(nullptr)
    {
    }

    BridgeCFNodeList ToNodeList() const
    {
        BridgeCFNodeList out;
        out.parentGraph = parentGraph;
        out.start = start;
        out.end = end;
        out.brtrue = brtrue;
        out.brfalse = brfalse;
        out.icount = icount;
        out.terminal = terminal;
        out.indirectcall = indirectcall;
        out.split = split;
        out.userdata = userdata;
        BridgeList<duint>::CopyData(&out.exits, exits);
        BridgeList<BridgeCFInstruction>::CopyData(&out.instrs, instrs);
        return std::move(out);
    }
};

struct BridgeCFGraph
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    std::unordered_map<duint, BridgeCFNode> nodes; //CFNode.start -> CFNode
    std::unordered_map<duint, std::unordered_set<duint>> parents; //CFNode.start -> parents

    static void Free(const BridgeCFGraphList* graphList)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            BridgeCFNode::Free(&data[i]);
        BridgeFree(data);
    }

    explicit BridgeCFGraph(const BridgeCFGraphList* graphList, bool freedata)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        entryPoint = graphList->entryPoint;
        userdata = graphList->userdata;
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            AddNode(BridgeCFNode(&data[i], freedata));
        if(freedata && data)
            BridgeFree(data);
    }

    explicit BridgeCFGraph(duint entryPoint)
        : entryPoint(entryPoint),
          userdata(nullptr)
    {
    }

    void AddNode(const BridgeCFNode & node)
    {
        nodes[node.start] = node;
        AddParent(node.start, node.brtrue);
        AddParent(node.start, node.brfalse);
    }

    void AddParent(duint child, duint parent)
    {
        if(!child || !parent)
            return;
        auto found = parents.find(child);
        if(found == parents.end())
        {
            parents[child] = std::unordered_set<duint>();
            parents[child].insert(parent);
        }
        else
            found->second.insert(parent);
    }

    BridgeCFGraphList ToGraphList() const
    {
        BridgeCFGraphList out;
        out.entryPoint = entryPoint;
        out.userdata = userdata;
        std::vector<BridgeCFNodeList> nodeList;
        nodeList.reserve(nodes.size());
        for(const auto & nodeIt : nodes)
            nodeList.push_back(nodeIt.second.ToNodeList());
        BridgeList<BridgeCFNodeList>::CopyData(&out.nodes, nodeList);
        return std::move(out);
    }
};

#endif //_MSC_VER
#endif //__cplusplus

#endif //_GRAPH_H
```

`src/x64dbgPlaytime/pluginsdk/bridgelist.h`:

```h
#ifndef _LIST_H
#define _LIST_H

typedef struct
{
    int count; //Number of element in the list.
    size_t size; //Size of list in bytes (used for type checking).
    void* data; //Pointer to the list contents. Must be deleted by the caller using BridgeFree (or BridgeList::Free).
} ListInfo;

#define ListOf(Type) ListInfo*

#ifdef __cplusplus

#include <vector>

/**
\brief A list object. This object is NOT thread safe.
\tparam Type BridgeList contents type.
*/
template<typename Type>
class BridgeList
{
public:
    /**
    \brief BridgeList constructor.
    \param _freeData (Optional) the free function.
    */
    explicit BridgeList()
    {
        memset(&_listInfo, 0, sizeof(_listInfo));
    }

    /**
    \brief BridgeList destructor.
    */
    ~BridgeList()
    {
        Cleanup();
    }

    /**
    \brief Gets the list data.
    \return Returns ListInfo->data. Can be null if the list was never initialized. Will be destroyed once this object goes out of scope!
    */
    Type* Data() const
    {
        return reinterpret_cast<Type*>(_listInfo.data);
    }

    /**
    \brief Gets the number of elements in the list. This will crash the program if the data is not consistent with the specified template argument.
    \return The number of elements in the list.
    */
    int Count() const
    {
        if(_listInfo.size != _listInfo.count * sizeof(Type)) //make sure the user is using the correct type.
            __debugbreak();
        return _listInfo.count;
    }

    /**
    \brief Cleans up the list, freeing the list data when it is not null.
    */
    void Cleanup()
    {
        if(_listInfo.data)
        {
            BridgeFree(_listInfo.data);
            _listInfo.data = nullptr;
        }
    }

    /**
    \brief Reference operator (cleans up the previous list)
    \return Pointer to the ListInfo.
    */
    ListInfo* operator&()
    {
        Cleanup();
        return &_listInfo;
    }

    /**
    \brief Array indexer operator. This will crash if you try to access out-of-bounds.
    \param index Zero-based index of the item you want to get.
    \return Reference to a value at that index.
    */
    Type & operator[](size_t index) const
    {
        if(index >= size_t(Count())) //make sure the out-of-bounds access is caught as soon as possible.
            __debugbreak();
        return Data()[index];
    }

    /**
    \brief Copies data to a ListInfo structure..
    \param [out] listInfo If non-null, information describing the list.
    \param listData Data to copy in the ListInfo structure.
    \return true if it succeeds, false if it fails.
    */
    static bool CopyData(ListInfo* listInfo, const std::vector<Type> & listData)
    {
        if(!listInfo)
            return false;
        listInfo->count = int(listData.size());
        listInfo->size = listInfo->count * sizeof(Type);
        if(listInfo->count)
        {
            listInfo->data = BridgeAlloc(listInfo->size);
            Type* curItem = reinterpret_cast<Type*>(listInfo->data);
            for(const auto & item : listData)
            {
                *curItem = item;
                ++curItem;
            }
        }
        else
            listInfo->data = nullptr;
        return true;
    }

    static bool Free(const ListInfo* listInfo)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        BridgeFree(listInfo->data);
        return true;
    }

    static bool ToVector(const ListInfo* listInfo, std::vector<Type> & listData, bool freedata = true)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        listData.resize(listInfo->count);
        for(int i = 0; i < listInfo->count; i++)
            listData[i] = ((Type*)listInfo->data)[i];
        if(freedata && listInfo->data)
            BridgeFree(listInfo->data);
        return true;
    }

private:
    ListInfo _listInfo;
};

#endif //__cplusplus

#endif //_LIST_H
```

`src/x64dbgPlaytime/pluginsdk/bridgemain.h`:

```h
#ifndef _BRIDGEMAIN_H_
#define _BRIDGEMAIN_H_

#include <windows.h>

#ifndef __cplusplus
#include <stdbool.h>
#endif

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

#ifdef _WIN64
typedef unsigned long long duint;
typedef signed long long dsint;
#else
typedef unsigned long duint;
typedef signed long dsint;
#endif //_WIN64

#ifndef BRIDGE_IMPEXP
#ifdef BUILD_BRIDGE
#define BRIDGE_IMPEXP __declspec(dllexport)
#else
#define BRIDGE_IMPEXP __declspec(dllimport)
#endif //BUILD_BRIDGE
#endif //BRIDGE_IMPEXP

#ifdef __cplusplus
extern "C"
{
#endif

//Bridge defines
#define MAX_SETTING_SIZE 65536
#define DBG_VERSION 25

//Bridge functions

/// <summary>
/// Initialize the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeInit();

/// <summary>
/// Start the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeStart();

/// <summary>
/// Allocate buffer. Use BridgeFree to free the buffer.
/// </summary>
/// <param name="size">Size in bytes of the buffer to allocate.</param>
/// <returns>A pointer to the allocated buffer. This function will trigger a crash dump if unsuccessful.</returns>
BRIDGE_IMPEXP void* BridgeAlloc(size_t size);

/// <summary>
/// Free buffer allocated by BridgeAlloc.
/// </summary>
/// <param name="ptr">Buffer to free.</param>
BRIDGE_IMPEXP void BridgeFree(void* ptr);

/// <summary>
/// Get a string setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output buffer for the value. Should be of MAX_SETTING_SIZE. Cannot be null.</param>
/// <returns>True if the setting was found and copied in the value parameter.</returns>
BRIDGE_IMPEXP bool BridgeSettingGet(const char* section, const char* key, char* value);

/// <summary>
/// Get an integer setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output value.</param>
/// <returns>True if the setting was found and successfully converted to an integer.</returns>
BRIDGE_IMPEXP bool BridgeSettingGetUint(const char* section, const char* key, duint* value);

/// <summary>
/// Set a string setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value. Set to null to remove the key from the section.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSet(const char* section, const char* key, const char* value);

/// <summary>
/// Set an integer setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSetUint(const char* section, const char* key, duint value);

/// <summary>
/// Flush the in-memory setting store to disk.
/// </summary>
/// <returns></returns>
BRIDGE_IMPEXP bool BridgeSettingFlush();

/// <summary>
/// Read the in-memory setting store from disk.
/// </summary>
/// <param name="errorLine">Line where the error occurred. Set to null to ignore this.</param>
/// <returns>True if the setting were read and parsed correctly.</returns>
BRIDGE_IMPEXP bool BridgeSettingRead(int* errorLine);

/// <summary>
/// Get the debugger version.
/// </summary>
/// <returns>25</returns>
BRIDGE_IMPEXP int BridgeGetDbgVersion();

#ifdef __cplusplus
}
#endif

//list structure (and C++ wrapper)
#include "bridgelist.h"

#include "bridgegraph.h"

#ifdef __cplusplus
extern "C"
{
#endif

//Debugger defines
#define MAX_LABEL_SIZE 256
#define MAX_COMMENT_SIZE 512
#define MAX_MODULE_SIZE 256
#define MAX_IMPORT_SIZE 65536
#define MAX_BREAKPOINT_SIZE 256
#define MAX_CONDITIONAL_EXPR_SIZE 256
#define MAX_CONDITIONAL_TEXT_SIZE 256
#define MAX_SCRIPT_LINE_SIZE 2048
#define MAX_THREAD_NAME_SIZE 256
#define MAX_WATCH_NAME_SIZE 256
#define MAX_STRING_SIZE 512
#define MAX_ERROR_SIZE 512
#define RIGHTS_STRING_SIZE (sizeof("ERWCG") + 1)
#define MAX_SECTION_SIZE 10
#define MAX_COMMAND_LINE_SIZE 256
#define MAX_MNEMONIC_SIZE 64
#define PAGE_SIZE 0x1000

//Debugger enums
typedef enum
{
    initialized,
    paused,
    running,
    stopped
} DBGSTATE;

typedef enum
{
    SEG_DEFAULT,
    SEG_ES,
    SEG_DS,
    SEG_FS,
    SEG_GS,
    SEG_CS,
    SEG_SS
} SEGMENTREG;

typedef enum
{
    flagmodule = 0x1,
    flaglabel = 0x2,
    flagcomment = 0x4,
    flagbookmark = 0x8,
    flagfunction = 0x10,
    flagloop = 0x20,
    flagargs = 0x40,
    flagNoFuncOffset = 0x80
} ADDRINFOFLAGS;

typedef enum
{
    bp_none = 0,
    bp_normal = 1,
    bp_hardware = 2,
    bp_memory = 4,
    bp_dll = 8,
    bp_exception = 16
} BPXTYPE;

typedef enum
{
    FUNC_NONE,
    FUNC_BEGIN,
    FUNC_MIDDLE,
    FUNC_END,
    FUNC_SINGLE
} FUNCTYPE;

typedef enum
{
    LOOP_NONE,
    LOOP_BEGIN,
    LOOP_MIDDLE,
    LOOP_ENTRY,
    LOOP_END,
    LOOP_SINGLE
} LOOPTYPE;

//order by most important type last
typedef enum
{
    XREF_NONE,
    XREF_DATA,
    XREF_JMP,
    XREF_CALL
} XREFTYPE;

typedef enum
{
    ARG_NONE,
    ARG_BEGIN,
    ARG_MIDDLE,
    ARG_END,
    ARG_SINGLE
} ARGTYPE;

typedef enum
{
    DBG_SCRIPT_LOAD,                // param1=const char* filename,      param2=unused
    DBG_SCRIPT_UNLOAD,              // param1=unused,                    param2=unused
    DBG_SCRIPT_RUN,                 // param1=int destline,              param2=unused
    DBG_SCRIPT_STEP,                // param1=unused,                    param2=unused
    DBG_SCRIPT_BPTOGGLE,            // param1=int line,                  param2=unused
    DBG_SCRIPT_BPGET,               // param1=int line,                  param2=unused
    DBG_SCRIPT_CMDEXEC,             // param1=const char* command,       param2=unused
    DBG_SCRIPT_ABORT,               // param1=unused,                    param2=unused
    DBG_SCRIPT_GETLINETYPE,         // param1=int line,                  param2=unused
    DBG_SCRIPT_SETIP,               // param1=int line,                  param2=unused
    DBG_SCRIPT_GETBRANCHINFO,       // param1=int line,                  param2=SCRIPTBRANCH* info
    DBG_SYMBOL_ENUM,                // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_ASSEMBLE_AT,                // param1=duint addr,                param2=const char* instruction
    DBG_MODBASE_FROM_NAME,          // param1=const char* modname,       param2=unused
    DBG_DISASM_AT,                  // param1=duint addr,                 param2=DISASM_INSTR* instr
    DBG_STACK_COMMENT_GET,          // param1=duint addr,                param2=STACK_COMMENT* comment
    DBG_GET_THREAD_LIST,            // param1=THREADALLINFO* list,       param2=unused
    DBG_SETTINGS_UPDATED,           // param1=unused,                    param2=unused
    DBG_DISASM_FAST_AT,             // param1=duint addr,                param2=BASIC_INSTRUCTION_INFO* basicinfo
    DBG_MENU_ENTRY_CLICKED,         // param1=int hEntry,                param2=unused
    DBG_FUNCTION_GET,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_OVERLAPS,          // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_ADD,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_DEL,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_GET,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_OVERLAPS,              // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_ADD,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_DEL,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_IS_RUN_LOCKED,              // param1=unused,                    param2=unused
    DBG_IS_BP_DISABLED,             // param1=duint addr,                param2=unused
    DBG_SET_AUTO_COMMENT_AT,        // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_COMMENT_RANGE,  // param1=duint start,               param2=duint end
    DBG_SET_AUTO_LABEL_AT,          // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_LABEL_RANGE,    // param1=duint start,               param2=duint end
    DBG_SET_AUTO_BOOKMARK_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_BOOKMARK_RANGE, // param1=duint start,               param2=duint end
    DBG_SET_AUTO_FUNCTION_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_FUNCTION_RANGE, // param1=duint start,               param2=duint end
    DBG_GET_STRING_AT,              // param1=duint addr,                param2=unused
    DBG_GET_FUNCTIONS,              // param1=unused,                    param2=unused
    DBG_WIN_EVENT,                  // param1=MSG* message,              param2=long* result
    DBG_WIN_EVENT_GLOBAL,           // param1=MSG* message,              param2=unused
    DBG_INITIALIZE_LOCKS,           // param1=unused,                    param2=unused
    DBG_DEINITIALIZE_LOCKS,         // param1=unused,                    param2=unused
    DBG_GET_TIME_WASTED_COUNTER,    // param1=unused,                    param2=unused
    DBG_SYMBOL_ENUM_FROMCACHE,      // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_DELETE_COMMENT_RANGE,       // param1=duint start,               param2=duint end
    DBG_DELETE_LABEL_RANGE,         // param1=duint start,               param2=duint end
    DBG_DELETE_BOOKMARK_RANGE,      // param1=duint start,               param2=duint end
    DBG_GET_XREF_COUNT_AT,          // param1=duint addr,                param2=unused
    DBG_GET_XREF_TYPE_AT,           // param1=duint addr,                param2=unused
    DBG_XREF_ADD,                   // param1=duint addr,                param2=duint from
    DBG_XREF_DEL_ALL,               // param1=duint addr,                param2=unused
    DBG_XREF_GET,                   // param1=duint addr,                param2=XREF_INFO* info
    DBG_GET_ENCODE_TYPE_BUFFER,     // param1=duint addr,                param2=unused
    DBG_ENCODE_TYPE_GET,            // param1=duint addr,                param2=duint size
    DBG_DELETE_ENCODE_TYPE_RANGE,   // param1=duint start,               param2=duint end
    DBG_ENCODE_SIZE_GET,            // param1=duint addr,                param2=duint codesize
    DBG_DELETE_ENCODE_TYPE_SEG,     // param1=duint addr,                param2=unused
    DBG_RELEASE_ENCODE_TYPE_BUFFER, // param1=void* buffer,              param2=unused
    DBG_ARGUMENT_GET,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_OVERLAPS,          // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_ADD,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_DEL,               // param1=FUNCTION* info,            param2=unused
    DBG_GET_WATCH_LIST,             // param1=ListOf(WATCHINFO),         param2=unused
    DBG_SELCHANGED,                 // param1=hWindow,                   param2=VA
    DBG_GET_PROCESS_HANDLE,         // param1=unused,                    param2=unused
    DBG_GET_THREAD_HANDLE,          // param1=unused,                    param2=unused
    DBG_GET_PROCESS_ID,             // param1=unused,                    param2=unused
    DBG_GET_THREAD_ID,              // param1=unused,                    param2=unused
    DBG_GET_PEB_ADDRESS,            // param1=DWORD ProcessId,           param2=unused
    DBG_GET_TEB_ADDRESS,            // param1=DWORD ThreadId,            param2=unused
    DBG_ANALYZE_FUNCTION,           // param1=BridgeCFGraphList* graph,  param2=duint entry
    DBG_MENU_PREPARE,               // param1=int hMenu,                 param2=unused
} DBGMSG;

typedef enum
{
    linecommand,
    linebranch,
    linelabel,
    linecomment,
    lineempty,
} SCRIPTLINETYPE;

typedef enum
{
    scriptnobranch,
    scriptjmp,
    scriptjnejnz,
    scriptjejz,
    scriptjbjl,
    scriptjajg,
    scriptjbejle,
    scriptjaejge,
    scriptcall
} SCRIPTBRANCHTYPE;

typedef enum
{
    instr_normal,
    instr_branch,
    instr_stack
} DISASM_INSTRTYPE;

typedef enum
{
    arg_normal,
    arg_memory
} DISASM_ARGTYPE;

typedef enum
{
    str_none,
    str_ascii,
    str_unicode
} STRING_TYPE;

typedef enum
{
    _PriorityIdle = -15,
    _PriorityAboveNormal = 1,
    _PriorityBelowNormal = -1,
    _PriorityHighest = 2,
    _PriorityLowest = -2,
    _PriorityNormal = 0,
    _PriorityTimeCritical = 15,
    _PriorityUnknown = 0x7FFFFFFF
} THREADPRIORITY;

typedef enum
{
    _Executive = 0,
    _FreePage = 1,
    _PageIn = 2,
    _PoolAllocation = 3,
    _DelayExecution = 4,
    _Suspended = 5,
    _UserRequest = 6,
    _WrExecutive = 7,
    _WrFreePage = 8,
    _WrPageIn = 9,
    _WrPoolAllocation = 10,
    _WrDelayExecution = 11,
    _WrSuspended = 12,
    _WrUserRequest = 13,
    _WrEventPair = 14,
    _WrQueue = 15,
    _WrLpcReceive = 16,
    _WrLpcReply = 17,
    _WrVirtualMemory = 18,
    _WrPageOut = 19,
    _WrRendezvous = 20,
    _Spare2 = 21,
    _Spare3 = 22,
    _Spare4 = 23,
    _Spare5 = 24,
    _WrCalloutStack = 25,
    _WrKernel = 26,
    _WrResource = 27,
    _WrPushLock = 28,
    _WrMutex = 29,
    _WrQuantumEnd = 30,
    _WrDispatchInt = 31,
    _WrPreempted = 32,
    _WrYieldExecution = 33,
    _WrFastMutex = 34,
    _WrGuardedMutex = 35,
    _WrRundown = 36,
} THREADWAITREASON;

typedef enum
{
    size_byte = 1,
    size_word = 2,
    size_dword = 4,
    size_qword = 8
} MEMORY_SIZE;

typedef enum
{
    enc_unknown,  //must be 0
    enc_byte,     //1 byte
    enc_word,     //2 bytes
    enc_dword,    //4 bytes
    enc_fword,    //6 bytes
    enc_qword,    //8 bytes
    enc_tbyte,    //10 bytes
    enc_oword,    //16 bytes
    enc_mmword,   //8 bytes
    enc_xmmword,  //16 bytes
    enc_ymmword,  //32 bytes
    enc_zmmword,  //64 bytes avx512 not supported
    enc_real4,    //4 byte float
    enc_real8,    //8 byte double
    enc_real10,   //10 byte decimal
    enc_ascii,    //ascii sequence
    enc_unicode,  //unicode sequence
    enc_code,     //start of code
    enc_junk,     //junk code
    enc_middle    //middle of data
} ENCODETYPE;

typedef enum
{
    TYPE_UINT, // unsigned integer
    TYPE_INT,  // signed integer
    TYPE_FLOAT,// single precision floating point value
    TYPE_ASCII, // ascii string
    TYPE_UNICODE, // unicode string
    TYPE_INVALID // invalid watch expression or data type
} WATCHVARTYPE;

typedef enum
{
    MODE_DISABLED, // watchdog is disabled
    MODE_ISTRUE,   // alert if expression is not 0
    MODE_ISFALSE,  // alert if expression is 0
    MODE_CHANGED,  // alert if expression is changed
    MODE_UNCHANGED // alert if expression is not changed
} WATCHDOGMODE;

typedef enum
{
    hw_access,
    hw_write,
    hw_execute
} BPHWTYPE;

typedef enum
{
    mem_access,
    mem_read,
    mem_write,
    mem_execute
} BPMEMTYPE;

typedef enum
{
    dll_load = 1,
    dll_unload,
    dll_all
} BPDLLTYPE;

typedef enum
{
    ex_firstchance = 1,
    ex_secondchance,
    ex_all
} BPEXTYPE;

typedef enum
{
    hw_byte,
    hw_word,
    hw_dword,
    hw_qword
} BPHWSIZE;

//Debugger typedefs
typedef MEMORY_SIZE VALUE_SIZE;
typedef struct SYMBOLINFO_ SYMBOLINFO;
typedef struct DBGFUNCTIONS_ DBGFUNCTIONS;

typedef void (*CBSYMBOLENUM)(SYMBOLINFO* symbol, void* user);

//Debugger structs
typedef struct
{
    MEMORY_BASIC_INFORMATION mbi;
    char info[MAX_MODULE_SIZE];
} MEMPAGE;

typedef struct
{
    int count;
    MEMPAGE* page;
} MEMMAP;

typedef struct
{
    BPXTYPE type;
    duint addr;
    bool enabled;
    bool singleshoot;
    bool active;
    char name[MAX_BREAKPOINT_SIZE];
    char mod[MAX_MODULE_SIZE];
    unsigned short slot;
    // extended part
    unsigned char typeEx; //BPHWTYPE/BPMEMTYPE/BPDLLTYPE/BPEXTYPE
    unsigned char hwSize; //BPHWSIZE
    unsigned int hitCount;
    bool fastResume;
    bool silent;
    char breakCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char logText[MAX_CONDITIONAL_TEXT_SIZE];
    char logCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char commandText[MAX_CONDITIONAL_TEXT_SIZE];
    char commandCondition[MAX_CONDITIONAL_EXPR_SIZE];
} BRIDGEBP;

typedef struct
{
    int count;
    BRIDGEBP* bp;
} BPMAP;

typedef struct
{
    char WatchName[MAX_WATCH_NAME_SIZE];
    char Expression[MAX_CONDITIONAL_EXPR_SIZE];
    unsigned int window;
    unsigned int id;
    WATCHVARTYPE varType;
    WATCHDOGMODE watchdogMode;
    duint value;
    bool watchdogTriggered;
} WATCHINFO;

typedef struct
{
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} FUNCTION;

typedef struct
{
    int depth; //IN
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} LOOP;

typedef struct
{
    int flags; //ADDRINFOFLAGS (IN)
    char module[MAX_MODULE_SIZE]; //module the address is in
    char label[MAX_LABEL_SIZE];
    char comment[MAX_COMMENT_SIZE];
    bool isbookmark;
    FUNCTION function;
    LOOP loop;
    FUNCTION args;
} BRIDGE_ADDRINFO;

struct SYMBOLINFO_
{
    duint addr;
    char* decoratedSymbol;
    char* undecoratedSymbol;
    bool isImported;
};

typedef struct
{
    duint base;
    char name[MAX_MODULE_SIZE];
} SYMBOLMODULEINFO;

typedef struct
{
    duint base;
    CBSYMBOLENUM cbSymbolEnum;
    void* user;
} SYMBOLCBINFO;

typedef struct
{
    bool c;
    bool p;
    bool a;
    bool z;
    bool s;
    bool t;
    bool i;
    bool d;
    bool o;
} FLAGS;

typedef struct
{
    bool FZ;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool IM;
    bool DM;
    bool DAZ;
    bool PE;
    bool UE;
    bool OE;
    bool ZE;
    bool DE;
    bool IE;

    unsigned short RC;
} MXCSRFIELDS;

typedef struct
{
    bool B;
    bool C3;
    bool C2;
    bool C1;
    bool C0;
    bool ES;
    bool SF;
    bool P;
    bool U;
    bool O;
    bool Z;
    bool D;
    bool I;

    unsigned short TOP;

} X87STATUSWORDFIELDS;

typedef struct
{
    bool IC;
    bool IEM;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool DM;
    bool IM;

    unsigned short RC;
    unsigned short PC;

} X87CONTROLWORDFIELDS;

typedef struct DECLSPEC_ALIGN(16) _XMMREGISTER
{
    ULONGLONG Low;
    LONGLONG High;
} XMMREGISTER;

typedef struct
{
    XMMREGISTER Low; //XMM/SSE part
    XMMREGISTER High; //AVX part
} YMMREGISTER;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} X87FPUREGISTER;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} X87FPU;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    X87FPU x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XMMREGISTER XmmRegisters[16];
    YMMREGISTER YmmRegisters[16];
#else // x86
    XMMREGISTER XmmRegisters[8];
    YMMREGISTER YmmRegisters[8];
#endif
} REGISTERCONTEXT;

typedef struct
{
    DWORD code;
    char name[128];
} LASTERROR;

typedef struct
{
    REGISTERCONTEXT regcontext;
    FLAGS flags;
    X87FPUREGISTER x87FPURegisters[8];
    unsigned long long mmx[8];
    MXCSRFIELDS MxCsrFields;
    X87STATUSWORDFIELDS x87StatusWordFields;
    X87CONTROLWORDFIELDS x87ControlWordFields;
    LASTERROR lastError;
} REGDUMP;

typedef struct
{
    DISASM_ARGTYPE type; //normal/memory
    SEGMENTREG segment;
    char mnemonic[64];
    duint constant; //constant in the instruction (imm/disp)
    duint value; //equal to constant or equal to the register value
    duint memvalue; //memsize:[value]
} DISASM_ARG;

typedef struct
{
    char instruction[64];
    DISASM_INSTRTYPE type;
    int argcount;
    int instr_size;
    DISASM_ARG arg[3];
} DISASM_INSTR;

typedef struct
{
    char color[8]; //hex color-code
    char comment[MAX_COMMENT_SIZE];
} STACK_COMMENT;

typedef struct
{
    int ThreadNumber;
    HANDLE Handle;
    DWORD ThreadId;
    duint ThreadStartAddress;
    duint ThreadLocalBase;
    char threadName[MAX_THREAD_NAME_SIZE];
} THREADINFO;

typedef struct
{
    THREADINFO BasicInfo;
    duint ThreadCip;
    DWORD SuspendCount;
    THREADPRIORITY Priority;
    THREADWAITREASON WaitReason;
    DWORD LastError;
    FILETIME UserTime;
    FILETIME KernelTime;
    FILETIME CreationTime;
    ULONG64 Cycles; // Windows Vista or greater
} THREADALLINFO;

typedef struct
{
    int count;
    THREADALLINFO* list;
    int CurrentThread;
} THREADLIST;

typedef struct
{
    duint value; //displacement / addrvalue (rip-relative)
    MEMORY_SIZE size; //byte/word/dword/qword
    char mnemonic[MAX_MNEMONIC_SIZE];
} MEMORY_INFO;

typedef struct
{
    duint value;
    VALUE_SIZE size;
} VALUE_INFO;

//definitions for BASIC_INSTRUCTION_INFO.type
#define TYPE_VALUE 1
#define TYPE_MEMORY 2
#define TYPE_ADDR 4

typedef struct
{
    DWORD type; //value|memory|addr
    VALUE_INFO value; //immediat
    MEMORY_INFO memory;
    duint addr; //addrvalue (jumps + calls)
    bool branch; //jumps/calls
    bool call; //instruction is a call
    int size;
    char instruction[MAX_MNEMONIC_SIZE * 4];
} BASIC_INSTRUCTION_INFO;

typedef struct
{
    SCRIPTBRANCHTYPE type;
    int dest;
    char branchlabel[256];
} SCRIPTBRANCH;

typedef struct
{
    duint addr;
    duint start;
    duint end;
    bool manual;
    int depth;
} FUNCTION_LOOP_INFO;

typedef struct
{
    duint addr;
    XREFTYPE type;
} XREF_RECORD;

typedef struct
{
    duint refcount;
    XREF_RECORD* references;
} XREF_INFO;

//Debugger functions
BRIDGE_IMPEXP const char* DbgInit();
BRIDGE_IMPEXP void DbgExit();
BRIDGE_IMPEXP bool DbgMemRead(duint va, void* dest, duint size);
BRIDGE_IMPEXP bool DbgMemWrite(duint va, const void* src, duint size);
BRIDGE_IMPEXP duint DbgMemGetPageSize(duint base);
BRIDGE_IMPEXP duint DbgMemFindBaseAddr(duint addr, duint* size);
BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd);
BRIDGE_IMPEXP bool DbgCmdExecDirect(const char* cmd);
BRIDGE_IMPEXP bool DbgMemMap(MEMMAP* memmap);
BRIDGE_IMPEXP bool DbgIsValidExpression(const char* expression);
BRIDGE_IMPEXP bool DbgIsDebugging();
BRIDGE_IMPEXP bool DbgIsJumpGoingToExecute(duint addr);
BRIDGE_IMPEXP bool DbgGetLabelAt(duint addr, SEGMENTREG segment, char* text);
BRIDGE_IMPEXP bool DbgSetLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetCommentAt(duint addr, char* text);
BRIDGE_IMPEXP bool DbgSetCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetBookmarkAt(duint addr);
BRIDGE_IMPEXP bool DbgSetBookmarkAt(duint addr, bool isbookmark);
BRIDGE_IMPEXP void DbgClearBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetModuleAt(duint addr, char* text);
BRIDGE_IMPEXP BPXTYPE DbgGetBpxTypeAt(duint addr);
BRIDGE_IMPEXP duint DbgValFromString(const char* string);
BRIDGE_IMPEXP bool DbgGetRegDump(REGDUMP* regdump);
BRIDGE_IMPEXP bool DbgValToString(const char* string, duint value);
BRIDGE_IMPEXP bool DbgMemIsValidReadPtr(duint addr);
BRIDGE_IMPEXP int DbgGetBpList(BPXTYPE type, BPMAP* list);
BRIDGE_IMPEXP FUNCTYPE DbgGetFunctionTypeAt(duint addr);
BRIDGE_IMPEXP LOOPTYPE DbgGetLoopTypeAt(duint addr, int depth);
BRIDGE_IMPEXP duint DbgGetBranchDestination(duint addr);
BRIDGE_IMPEXP void DbgScriptLoad(const char* filename);
BRIDGE_IMPEXP void DbgScriptUnload();
BRIDGE_IMPEXP void DbgScriptRun(int destline);
BRIDGE_IMPEXP void DbgScriptStep();
BRIDGE_IMPEXP bool DbgScriptBpToggle(int line);
BRIDGE_IMPEXP bool DbgScriptBpGet(int line);
BRIDGE_IMPEXP bool DbgScriptCmdExec(const char* command);
BRIDGE_IMPEXP void DbgScriptAbort();
BRIDGE_IMPEXP SCRIPTLINETYPE DbgScriptGetLineType(int line);
BRIDGE_IMPEXP void DbgScriptSetIp(int line);
BRIDGE_IMPEXP bool DbgScriptGetBranchInfo(int line, SCRIPTBRANCH* info);
BRIDGE_IMPEXP void DbgSymbolEnum(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP void DbgSymbolEnumFromCache(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgAssembleAt(duint addr, const char* instruction);
BRIDGE_IMPEXP duint DbgModBaseFromName(const char* name);
BRIDGE_IMPEXP void DbgDisasmAt(duint addr, DISASM_INSTR* instr);
BRIDGE_IMPEXP bool DbgStackCommentGet(duint addr, STACK_COMMENT* comment);
BRIDGE_IMPEXP void DbgGetThreadList(THREADLIST* list);
BRIDGE_IMPEXP void DbgSettingsUpdated();
BRIDGE_IMPEXP void DbgDisasmFastAt(duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
BRIDGE_IMPEXP void DbgMenuEntryClicked(int hEntry);
BRIDGE_IMPEXP bool DbgFunctionGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgFunctionOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionDel(duint addr);
BRIDGE_IMPEXP bool DbgArgumentGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgArgumentOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentDel(duint addr);
BRIDGE_IMPEXP bool DbgLoopGet(int depth, duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgLoopOverlaps(int depth, duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopDel(int depth, duint addr);
BRIDGE_IMPEXP bool DbgXrefAdd(duint addr, duint from);
BRIDGE_IMPEXP bool DbgXrefDelAll(duint addr);
BRIDGE_IMPEXP bool DbgXrefGet(duint addr, XREF_INFO* info);
BRIDGE_IMPEXP size_t DbgGetXrefCountAt(duint addr);
BRIDGE_IMPEXP XREFTYPE DbgGetXrefTypeAt(duint addr);
BRIDGE_IMPEXP bool DbgIsRunLocked();
BRIDGE_IMPEXP bool DbgIsBpDisabled(duint addr);
BRIDGE_IMPEXP bool DbgSetAutoCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoBookmarkAt(duint addr);
BRIDGE_IMPEXP void DbgClearAutoBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoFunctionAt(duint start, duint end);
BRIDGE_IMPEXP void DbgClearAutoFunctionRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetStringAt(duint addr, char* text);
BRIDGE_IMPEXP const DBGFUNCTIONS* DbgFunctions();
BRIDGE_IMPEXP bool DbgWinEvent(MSG* message, long* result);
BRIDGE_IMPEXP bool DbgWinEventGlobal(MSG* message);
BRIDGE_IMPEXP bool DbgIsRunning();
BRIDGE_IMPEXP duint DbgGetTimeWastedCounter();
BRIDGE_IMPEXP ARGTYPE DbgGetArgTypeAt(duint addr);
BRIDGE_IMPEXP void* DbgGetEncodeTypeBuffer(duint addr, duint* size);
BRIDGE_IMPEXP void DbgReleaseEncodeTypeBuffer(void* buffer);
BRIDGE_IMPEXP ENCODETYPE DbgGetEncodeTypeAt(duint addr, duint size);
BRIDGE_IMPEXP duint DbgGetEncodeSizeAt(duint addr, duint codesize);
BRIDGE_IMPEXP bool DbgSetEncodeType(duint addr, duint size, ENCODETYPE type);
BRIDGE_IMPEXP void DbgDelEncodeTypeRange(duint start, duint end);
BRIDGE_IMPEXP void DbgDelEncodeTypeSegment(duint start);
BRIDGE_IMPEXP bool DbgGetWatchList(ListOf(WATCHINFO) list);
BRIDGE_IMPEXP void DbgSelChanged(int hWindow, duint VA);
BRIDGE_IMPEXP HANDLE DbgGetProcessHandle();
BRIDGE_IMPEXP HANDLE DbgGetThreadHandle();
BRIDGE_IMPEXP DWORD DbgGetProcessId();
BRIDGE_IMPEXP DWORD DbgGetThreadId();
BRIDGE_IMPEXP duint DbgGetPebAddress(DWORD ProcessId);
BRIDGE_IMPEXP duint DbgGetTebAddress(DWORD ThreadId);
BRIDGE_IMPEXP bool DbgAnalyzeFunction(duint entry, BridgeCFGraphList* graph);
BRIDGE_IMPEXP duint DbgEval(const char* expression, bool* success = 0);
BRIDGE_IMPEXP void DbgMenuPrepare(int hMenu);

//Gui defines
#define GUI_PLUGIN_MENU 0
#define GUI_DISASM_MENU 1
#define GUI_DUMP_MENU 2
#define GUI_STACK_MENU 3

#define GUI_DISASSEMBLY 0
#define GUI_DUMP 1
#define GUI_STACK 2
#define GUI_GRAPH 3
#define GUI_MEMMAP 4
#define GUI_SYMMOD 5

#define GUI_MAX_LINE_SIZE 65536
#define GUI_MAX_DISASSEMBLY_SIZE 2048

//Gui enums
typedef enum
{
    GUI_DISASSEMBLE_AT,             // param1=(duint)va,            param2=(duint)cip
    GUI_SET_DEBUG_STATE,            // param1=(DBGSTATE)state,      param2=unused
    GUI_ADD_MSG_TO_LOG,             // param1=(const char*)msg,     param2=unused
    GUI_CLEAR_LOG,                  // param1=unused,               param2=unused
    GUI_UPDATE_REGISTER_VIEW,       // param1=unused,               param2=unused
    GUI_UPDATE_DISASSEMBLY_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_BREAKPOINTS_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_WINDOW_TITLE,        // param1=(const char*)file,    param2=unused
    GUI_GET_WINDOW_HANDLE,          // param1=unused,               param2=unused
    GUI_DUMP_AT,                    // param1=(duint)va             param2=unused
    GUI_SCRIPT_ADD,                 // param1=int count,            param2=const char** lines
    GUI_SCRIPT_CLEAR,               // param1=unused,               param2=unused
    GUI_SCRIPT_SETIP,               // param1=int line,             param2=unused
    GUI_SCRIPT_ERROR,               // param1=int line,             param2=const char* message
    GUI_SCRIPT_SETTITLE,            // param1=const char* title,    param2=unused
    GUI_SCRIPT_SETINFOLINE,         // param1=int line,             param2=const char* info
    GUI_SCRIPT_MESSAGE,             // param1=const char* message,  param2=unused
    GUI_SCRIPT_MSGYN,               // param1=const char* message,  param2=unused
    GUI_SYMBOL_LOG_ADD,             // param1(const char*)msg,      param2=unused
    GUI_SYMBOL_LOG_CLEAR,           // param1=unused,               param2=unused
    GUI_SYMBOL_SET_PROGRESS,        // param1=int percent           param2=unused
    GUI_SYMBOL_UPDATE_MODULE_LIST,  // param1=int count,            param2=SYMBOLMODULEINFO* modules
    GUI_REF_ADDCOLUMN,              // param1=int width,            param2=(const char*)title
    GUI_REF_SETROWCOUNT,            // param1=int rows,             param2=unused
    GUI_REF_GETROWCOUNT,            // param1=unused,               param2=unused
    GUI_REF_DELETEALLCOLUMNS,       // param1=unused,               param2=unused
    GUI_REF_SETCELLCONTENT,         // param1=(CELLINFO*)info,      param2=unused
    GUI_REF_GETCELLCONTENT,         // param1=int row,              param2=int col
    GUI_REF_RELOADDATA,             // param1=unused,               param2=unused
    GUI_REF_SETSINGLESELECTION,     // param1=int index,            param2=bool scroll
    GUI_REF_SETPROGRESS,            // param1=int progress,         param2=unused
    GUI_REF_SETCURRENTTASKPROGRESS, // param1=int progress,         param2=const char* taskTitle
    GUI_REF_SETSEARCHSTARTCOL,      // param1=int col               param2=unused
    GUI_STACK_DUMP_AT,              // param1=duint addr,           param2=duint csp
    GUI_UPDATE_DUMP_VIEW,           // param1=unused,               param2=unused
    GUI_UPDATE_THREAD_VIEW,         // param1=unused,               param2=unused
    GUI_ADD_RECENT_FILE,            // param1=(const char*)file,    param2=unused
    GUI_SET_LAST_EXCEPTION,         // param1=unsigned int code,    param2=unused
    GUI_GET_DISASSEMBLY,            // param1=duint addr,           param2=char* text
    GUI_MENU_ADD,                   // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_ENTRY,             // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_SEPARATOR,         // param1=int hMenu,            param2=unused
    GUI_MENU_CLEAR,                 // param1=int hMenu,            param2=unused
    GUI_SELECTION_GET,              // param1=int hWindow,          param2=SELECTIONDATA* selection
    GUI_SELECTION_SET,              // param1=int hWindow,          param2=const SELECTIONDATA* selection
    GUI_GETLINE_WINDOW,             // param1=const char* title,    param2=char* text
    GUI_AUTOCOMPLETE_ADDCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_DELCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_CLEARALL,      // param1=unused,               param2=unused
    GUI_SCRIPT_ENABLEHIGHLIGHTING,  // param1=bool enable,          param2=unused
    GUI_ADD_MSG_TO_STATUSBAR,       // param1=const char* msg,      param2=unused
    GUI_UPDATE_SIDEBAR,             // param1=unused,               param2=unused
    GUI_REPAINT_TABLE_VIEW,         // param1=unused,               param2=unused
    GUI_UPDATE_PATCHES,             // param1=unused,               param2=unused
    GUI_UPDATE_CALLSTACK,           // param1=unused,               param2=unused
    GUI_UPDATE_SEHCHAIN,            // param1=unused,               param2=unused
    GUI_SYMBOL_REFRESH_CURRENT,     // param1=unused,               param2=unused
    GUI_UPDATE_MEMORY_VIEW,         // param1=unused,               param2=unused
    GUI_REF_INITIALIZE,             // param1=const char* name,     param2=unused
    GUI_LOAD_SOURCE_FILE,           // param1=const char* path,     param2=line
    GUI_MENU_SET_ICON,              // param1=int hMenu,            param2=ICONINFO*
    GUI_MENU_SET_ENTRY_ICON,        // param1=int hEntry,           param2=ICONINFO*
    GUI_SHOW_CPU,                   // param1=unused,               param2=unused
    GUI_ADD_QWIDGET_TAB,            // param1=QWidget*,             param2=unused
    GUI_SHOW_QWIDGET_TAB,           // param1=QWidget*,             param2=unused
    GUI_CLOSE_QWIDGET_TAB,          // param1=QWidget*,             param2=unused
    GUI_EXECUTE_ON_GUI_THREAD,      // param1=GUICALLBACK,          param2=unused
    GUI_UPDATE_TIME_WASTED_COUNTER, // param1=unused,               param2=unused
    GUI_SET_GLOBAL_NOTES,           // param1=const char* text,     param2=unused
    GUI_GET_GLOBAL_NOTES,           // param1=char** text,          param2=unused
    GUI_SET_DEBUGGEE_NOTES,         // param1=const char* text,     param2=unused
    GUI_GET_DEBUGGEE_NOTES,         // param1=char** text,          param2=unused
    GUI_DUMP_AT_N,                  // param1=int index,            param2=duint va
    GUI_DISPLAY_WARNING,            // param1=const char *text,     param2=unused
    GUI_REGISTER_SCRIPT_LANG,       // param1=SCRIPTTYPEINFO* info, param2=unused
    GUI_UNREGISTER_SCRIPT_LANG,     // param1=int id,               param2=unused
    GUI_UPDATE_ARGUMENT_VIEW,       // param1=unused,               param2=unused
    GUI_FOCUS_VIEW,                 // param1=int hWindow,          param2=unused
    GUI_UPDATE_WATCH_VIEW,          // param1=unused,               param2=unused
    GUI_LOAD_GRAPH,                 // param1=BridgeCFGraphList*    param2=unused
    GUI_GRAPH_AT,                   // param1=duint addr            param2=unused
    GUI_UPDATE_GRAPH_VIEW,          // param1=unused,               param2=unused
    GUI_SET_LOG_ENABLED,            // param1=bool isEnabled        param2=unused
    GUI_ADD_FAVOURITE_TOOL,         // param1=const char* name      param2=const char* description
    GUI_ADD_FAVOURITE_COMMAND,      // param1=const char* command   param2=const char* shortcut
    GUI_SET_FAVOURITE_TOOL_SHORTCUT,// param1=const char* name      param2=const char* shortcut
    GUI_FOLD_DISASSEMBLY,           // param1=duint startAddress    param2=duint length
    GUI_SELECT_IN_MEMORY_MAP,       // param1=duint addr,           param2=unused
    GUI_GET_ACTIVE_VIEW,            // param1=ACTIVEVIEW*,          param2=unused
    GUI_MENU_SET_ENTRY_CHECKED,     // param1=int hEntry,           param2=bool checked
    GUI_ADD_INFO_LINE,              // param1=const char* infoline, param2=unused
    GUI_PROCESS_EVENTS,             // param1=unused,               param2=unused
    GUI_TYPE_ADDNODE,               // param1=void* parent,         param2=TYPEDESCRIPTOR* type
    GUI_TYPE_CLEAR,                 // param1=unused,               param2=unused
    GUI_UPDATE_TYPE_WIDGET,         // param1=unused,               param2=unused
    GUI_CLOSE_APPLICATION,          // param1=unused,               param2=unused
    GUI_MENU_SET_VISIBLE,           // param1=int hMenu,            param2=bool visible
    GUI_MENU_SET_ENTRY_VISIBLE,     // param1=int hEntry,           param2=bool visible
    GUI_MENU_SET_NAME,              // param1=int hMenu,            param2=const char* name
    GUI_MENU_SET_ENTRY_NAME,        // param1=int hEntry,           param2=const char* name
    GUI_FLUSH_LOG,                  // param1=unused,               param2=unused
    GUI_MENU_SET_ENTRY_HOTKEY,      // param1=int hEntry,           param2=const char* hack
    GUI_REF_SEARCH_GETROWCOUNT,     // param1=unused,               param2=unused
    GUI_REF_SEARCH_GETCELLCONTENT,  // param1=int row,              param2=int col
    GUI_MENU_REMOVE,                // param1=int hEntryMenu,       param2=unused
    GUI_REF_ADDCOMMAND              // param1=const char* title,    param2=const char* command
} GUIMSG;

//GUI Typedefs
struct _TYPEDESCRIPTOR;

typedef void (*GUICALLBACK)();
typedef bool (*GUISCRIPTEXECUTE)(const char* text);
typedef void (*GUISCRIPTCOMPLETER)(const char* text, char** entries, int* entryCount);
typedef bool (*TYPETOSTRING)(const struct _TYPEDESCRIPTOR* type, char* dest, size_t* destCount); //don't change destCount for final failure

//GUI structures
typedef struct
{
    int row;
    int col;
    const char* str;
} CELLINFO;

typedef struct
{
    duint start;
    duint end;
} SELECTIONDATA;

typedef struct
{
    const void* data;
    duint size;
} ICONDATA;

typedef struct
{
    char name[64];
    int id;
    GUISCRIPTEXECUTE execute;
    GUISCRIPTCOMPLETER completeCommand;
} SCRIPTTYPEINFO;

typedef struct
{
    void* titleHwnd;
    void* classHwnd;
    char title[MAX_STRING_SIZE];
    char className[MAX_STRING_SIZE];
} ACTIVEVIEW;

typedef struct _TYPEDESCRIPTOR
{
    bool expanded; //is the type node expanded?
    bool reverse; //big endian?
    const char* name; //type name (int b)
    duint addr; //virtual address
    duint offset; //offset to addr for the actual location
    int id; //type id
    int size; //sizeof(type)
    TYPETOSTRING callback; //convert to string
    void* userdata; //user data
} TYPEDESCRIPTOR;

//GUI functions
//code page is utf8
BRIDGE_IMPEXP const char* GuiTranslateText(const char* Source);
BRIDGE_IMPEXP void GuiDisasmAt(duint addr, duint cip);
BRIDGE_IMPEXP void GuiSetDebugState(DBGSTATE state);
BRIDGE_IMPEXP void GuiSetDebugStateFast(DBGSTATE state);
BRIDGE_IMPEXP void GuiAddLogMessage(const char* msg);
BRIDGE_IMPEXP void GuiLogClear();
BRIDGE_IMPEXP void GuiUpdateAllViews();
BRIDGE_IMPEXP void GuiUpdateRegisterView();
BRIDGE_IMPEXP void GuiUpdateDisassemblyView();
BRIDGE_IMPEXP void GuiUpdateBreakpointsView();
BRIDGE_IMPEXP void GuiUpdateWindowTitle(const char* filename);
BRIDGE_IMPEXP HWND GuiGetWindowHandle();
BRIDGE_IMPEXP void GuiDumpAt(duint va);
BRIDGE_IMPEXP void GuiScriptAdd(int count, const char** lines);
BRIDGE_IMPEXP void GuiScriptClear();
BRIDGE_IMPEXP void GuiScriptSetIp(int line);
BRIDGE_IMPEXP void GuiScriptError(int line, const char* message);
BRIDGE_IMPEXP void GuiScriptSetTitle(const char* title);
BRIDGE_IMPEXP void GuiScriptSetInfoLine(int line, const char* info);
BRIDGE_IMPEXP void GuiScriptMessage(const char* message);
BRIDGE_IMPEXP int GuiScriptMsgyn(const char* message);
BRIDGE_IMPEXP void GuiScriptEnableHighlighting(bool enable);
BRIDGE_IMPEXP void GuiSymbolLogAdd(const char* message);
BRIDGE_IMPEXP void GuiSymbolLogClear();
BRIDGE_IMPEXP void GuiSymbolSetProgress(int percent);
BRIDGE_IMPEXP void GuiSymbolUpdateModuleList(int count, SYMBOLMODULEINFO* modules);
BRIDGE_IMPEXP void GuiSymbolRefreshCurrent();
BRIDGE_IMPEXP void GuiReferenceAddColumn(int width, const char* title);
BRIDGE_IMPEXP void GuiReferenceSetRowCount(int count);
BRIDGE_IMPEXP int GuiReferenceGetRowCount();
BRIDGE_IMPEXP int GuiReferenceSearchGetRowCount();
BRIDGE_IMPEXP void GuiReferenceDeleteAllColumns();
BRIDGE_IMPEXP void GuiReferenceInitialize(const char* name);
BRIDGE_IMPEXP void GuiReferenceSetCellContent(int row, int col, const char* str);
BRIDGE_IMPEXP char* GuiReferenceGetCellContent(int row, int col);
BRIDGE_IMPEXP char* GuiReferenceSearchGetCellContent(int row, int col);
BRIDGE_IMPEXP void GuiReferenceReloadData();
BRIDGE_IMPEXP void GuiReferenceSetSingleSelection(int index, bool scroll);
BRIDGE_IMPEXP void GuiReferenceSetProgress(int progress);
BRIDGE_IMPEXP void GuiReferenceSetCurrentTaskProgress(int progress, const char* taskTitle);
BRIDGE_IMPEXP void GuiReferenceSetSearchStartCol(int col);
BRIDGE_IMPEXP void GuiStackDumpAt(duint addr, duint csp);
BRIDGE_IMPEXP void GuiUpdateDumpView();
BRIDGE_IMPEXP void GuiUpdateWatchView();
BRIDGE_IMPEXP void GuiUpdateThreadView();
BRIDGE_IMPEXP void GuiUpdateMemoryView();
BRIDGE_IMPEXP void GuiAddRecentFile(const char* file);
BRIDGE_IMPEXP void GuiSetLastException(unsigned int exception);
BRIDGE_IMPEXP bool GuiGetDisassembly(duint addr, char* text);
BRIDGE_IMPEXP int GuiMenuAdd(int hMenu, const char* title);
BRIDGE_IMPEXP int GuiMenuAddEntry(int hMenu, const char* title);
BRIDGE_IMPEXP void GuiMenuAddSeparator(int hMenu);
BRIDGE_IMPEXP void GuiMenuClear(int hMenu);
BRIDGE_IMPEXP void GuiMenuRemove(int hEntryMenu);
BRIDGE_IMPEXP bool GuiSelectionGet(int hWindow, SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiSelectionSet(int hWindow, const SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiGetLineWindow(const char* title, char* text);
BRIDGE_IMPEXP void GuiAutoCompleteAddCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteDelCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteClearAll();
BRIDGE_IMPEXP void GuiAddStatusBarMessage(const char* msg);
BRIDGE_IMPEXP void GuiUpdateSideBar();
BRIDGE_IMPEXP void GuiRepaintTableView();
BRIDGE_IMPEXP void GuiUpdatePatches();
BRIDGE_IMPEXP void GuiUpdateCallStack();
BRIDGE_IMPEXP void GuiUpdateSEHChain();
BRIDGE_IMPEXP void GuiLoadSourceFile(const char* path, int line);
BRIDGE_IMPEXP void GuiMenuSetIcon(int hMenu, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryIcon(int hEntry, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryChecked(int hEntry, bool checked);
BRIDGE_IMPEXP void GuiMenuSetVisible(int hMenu, bool visible);
BRIDGE_IMPEXP void GuiMenuSetEntryVisible(int hEntry, bool visible);
BRIDGE_IMPEXP void GuiMenuSetName(int hMenu, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryName(int hEntry, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryHotkey(int hEntry, const char* hack);
BRIDGE_IMPEXP void GuiShowCpu();
BRIDGE_IMPEXP void GuiAddQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiShowQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiCloseQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiExecuteOnGuiThread(GUICALLBACK cbGuiThread);
BRIDGE_IMPEXP void GuiUpdateTimeWastedCounter();
BRIDGE_IMPEXP void GuiSetGlobalNotes(const char* text);
BRIDGE_IMPEXP void GuiGetGlobalNotes(char** text);
BRIDGE_IMPEXP void GuiSetDebuggeeNotes(const char* text);
BRIDGE_IMPEXP void GuiGetDebuggeeNotes(char** text);
BRIDGE_IMPEXP void GuiDumpAtN(duint va, int index);
BRIDGE_IMPEXP void GuiDisplayWarning(const char* title, const char* text);
BRIDGE_IMPEXP void GuiRegisterScriptLanguage(SCRIPTTYPEINFO* info);
BRIDGE_IMPEXP void GuiUnregisterScriptLanguage(int id);
BRIDGE_IMPEXP void GuiUpdateArgumentWidget();
BRIDGE_IMPEXP void GuiFocusView(int hWindow);
BRIDGE_IMPEXP bool GuiIsUpdateDisabled();
BRIDGE_IMPEXP void GuiUpdateEnable(bool updateNow);
BRIDGE_IMPEXP void GuiUpdateDisable();
BRIDGE_IMPEXP bool GuiLoadGraph(BridgeCFGraphList* graph, duint addr);
BRIDGE_IMPEXP duint GuiGraphAt(duint addr);
BRIDGE_IMPEXP void GuiUpdateGraphView();
BRIDGE_IMPEXP void GuiDisableLog();
BRIDGE_IMPEXP void GuiEnableLog();
BRIDGE_IMPEXP void GuiAddFavouriteTool(const char* name, const char* description);
BRIDGE_IMPEXP void GuiAddFavouriteCommand(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiFoldDisassembly(duint startAddress, duint length);
BRIDGE_IMPEXP void GuiSelectInMemoryMap(duint addr);
BRIDGE_IMPEXP void GuiGetActiveView(ACTIVEVIEW* activeView);
BRIDGE_IMPEXP void GuiAddInfoLine(const char* infoLine);
BRIDGE_IMPEXP void GuiProcessEvents();
BRIDGE_IMPEXP void* GuiTypeAddNode(void* parent, const TYPEDESCRIPTOR* type);
BRIDGE_IMPEXP bool GuiTypeClear();
BRIDGE_IMPEXP void GuiUpdateTypeWidget();
BRIDGE_IMPEXP void GuiCloseApplication();
BRIDGE_IMPEXP void GuiFlushLog();
BRIDGE_IMPEXP void GuiReferenceAddCommand(const char* title, const char* command);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _BRIDGEMAIN_H_

```

`src/x64dbgPlaytime/pluginsdk/capstone/arm.h`:

```h
#ifndef CAPSTONE_ARM_H
#define CAPSTONE_ARM_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM shift type
typedef enum arm_shifter
{
    ARM_SFT_INVALID = 0,
    ARM_SFT_ASR,    // shift with immediate const
    ARM_SFT_LSL,    // shift with immediate const
    ARM_SFT_LSR,    // shift with immediate const
    ARM_SFT_ROR,    // shift with immediate const
    ARM_SFT_RRX,    // shift with immediate const
    ARM_SFT_ASR_REG,    // shift with register
    ARM_SFT_LSL_REG,    // shift with register
    ARM_SFT_LSR_REG,    // shift with register
    ARM_SFT_ROR_REG,    // shift with register
    ARM_SFT_RRX_REG,    // shift with register
} arm_shifter;

//> ARM condition code
typedef enum arm_cc
{
    ARM_CC_INVALID = 0,
    ARM_CC_EQ,            // Equal                      Equal
    ARM_CC_NE,            // Not equal                  Not equal, or unordered
    ARM_CC_HS,            // Carry set                  >, ==, or unordered
    ARM_CC_LO,            // Carry clear                Less than
    ARM_CC_MI,            // Minus, negative            Less than
    ARM_CC_PL,            // Plus, positive or zero     >, ==, or unordered
    ARM_CC_VS,            // Overflow                   Unordered
    ARM_CC_VC,            // No overflow                Not unordered
    ARM_CC_HI,            // Unsigned higher            Greater than, or unordered
    ARM_CC_LS,            // Unsigned lower or same     Less than or equal
    ARM_CC_GE,            // Greater than or equal      Greater than or equal
    ARM_CC_LT,            // Less than                  Less than, or unordered
    ARM_CC_GT,            // Greater than               Greater than
    ARM_CC_LE,            // Less than or equal         <, ==, or unordered
    ARM_CC_AL             // Always (unconditional)     Always (unconditional)
} arm_cc;

typedef enum arm_sysreg
{
    //> Special registers for MSR
    ARM_SYSREG_INVALID = 0,

    // SPSR* registers can be OR combined
    ARM_SYSREG_SPSR_C = 1,
    ARM_SYSREG_SPSR_X = 2,
    ARM_SYSREG_SPSR_S = 4,
    ARM_SYSREG_SPSR_F = 8,

    // CPSR* registers can be OR combined
    ARM_SYSREG_CPSR_C = 16,
    ARM_SYSREG_CPSR_X = 32,
    ARM_SYSREG_CPSR_S = 64,
    ARM_SYSREG_CPSR_F = 128,

    // independent registers
    ARM_SYSREG_APSR = 256,
    ARM_SYSREG_APSR_G,
    ARM_SYSREG_APSR_NZCVQ,
    ARM_SYSREG_APSR_NZCVQG,

    ARM_SYSREG_IAPSR,
    ARM_SYSREG_IAPSR_G,
    ARM_SYSREG_IAPSR_NZCVQG,
    ARM_SYSREG_IAPSR_NZCVQ,

    ARM_SYSREG_EAPSR,
    ARM_SYSREG_EAPSR_G,
    ARM_SYSREG_EAPSR_NZCVQG,
    ARM_SYSREG_EAPSR_NZCVQ,

    ARM_SYSREG_XPSR,
    ARM_SYSREG_XPSR_G,
    ARM_SYSREG_XPSR_NZCVQG,
    ARM_SYSREG_XPSR_NZCVQ,

    ARM_SYSREG_IPSR,
    ARM_SYSREG_EPSR,
    ARM_SYSREG_IEPSR,

    ARM_SYSREG_MSP,
    ARM_SYSREG_PSP,
    ARM_SYSREG_PRIMASK,
    ARM_SYSREG_BASEPRI,
    ARM_SYSREG_BASEPRI_MAX,
    ARM_SYSREG_FAULTMASK,
    ARM_SYSREG_CONTROL,

    // Banked Registers
    ARM_SYSREG_R8_USR,
    ARM_SYSREG_R9_USR,
    ARM_SYSREG_R10_USR,
    ARM_SYSREG_R11_USR,
    ARM_SYSREG_R12_USR,
    ARM_SYSREG_SP_USR,
    ARM_SYSREG_LR_USR,
    ARM_SYSREG_R8_FIQ,
    ARM_SYSREG_R9_FIQ,
    ARM_SYSREG_R10_FIQ,
    ARM_SYSREG_R11_FIQ,
    ARM_SYSREG_R12_FIQ,
    ARM_SYSREG_SP_FIQ,
    ARM_SYSREG_LR_FIQ,
    ARM_SYSREG_LR_IRQ,
    ARM_SYSREG_SP_IRQ,
    ARM_SYSREG_LR_SVC,
    ARM_SYSREG_SP_SVC,
    ARM_SYSREG_LR_ABT,
    ARM_SYSREG_SP_ABT,
    ARM_SYSREG_LR_UND,
    ARM_SYSREG_SP_UND,
    ARM_SYSREG_LR_MON,
    ARM_SYSREG_SP_MON,
    ARM_SYSREG_ELR_HYP,
    ARM_SYSREG_SP_HYP,

    ARM_SYSREG_SPSR_FIQ,
    ARM_SYSREG_SPSR_IRQ,
    ARM_SYSREG_SPSR_SVC,
    ARM_SYSREG_SPSR_ABT,
    ARM_SYSREG_SPSR_UND,
    ARM_SYSREG_SPSR_MON,
    ARM_SYSREG_SPSR_HYP,
} arm_sysreg;

//> The memory barrier constants map directly to the 4-bit encoding of
//> the option field for Memory Barrier operations.
typedef enum arm_mem_barrier
{
    ARM_MB_INVALID = 0,
    ARM_MB_RESERVED_0,
    ARM_MB_OSHLD,
    ARM_MB_OSHST,
    ARM_MB_OSH,
    ARM_MB_RESERVED_4,
    ARM_MB_NSHLD,
    ARM_MB_NSHST,
    ARM_MB_NSH,
    ARM_MB_RESERVED_8,
    ARM_MB_ISHLD,
    ARM_MB_ISHST,
    ARM_MB_ISH,
    ARM_MB_RESERVED_12,
    ARM_MB_LD,
    ARM_MB_ST,
    ARM_MB_SY,
} arm_mem_barrier;

//> Operand type for instruction's operands
typedef enum arm_op_type
{
    ARM_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    ARM_OP_REG, // = CS_OP_REG (Register operand).
    ARM_OP_IMM, // = CS_OP_IMM (Immediate operand).
    ARM_OP_MEM, // = CS_OP_MEM (Memory operand).
    ARM_OP_FP,  // = CS_OP_FP (Floating-Point operand).
    ARM_OP_CIMM = 64, // C-Immediate (coprocessor registers)
    ARM_OP_PIMM, // P-Immediate (coprocessor registers)
    ARM_OP_SETEND,  // operand for SETEND instruction
    ARM_OP_SYSREG,  // MSR/MRS special register operand
} arm_op_type;

//> Operand type for SETEND instruction
typedef enum arm_setend_type
{
    ARM_SETEND_INVALID = 0, // Uninitialized.
    ARM_SETEND_BE,  // BE operand.
    ARM_SETEND_LE, // LE operand
} arm_setend_type;

typedef enum arm_cpsmode_type
{
    ARM_CPSMODE_INVALID = 0,
    ARM_CPSMODE_IE = 2,
    ARM_CPSMODE_ID = 3
} arm_cpsmode_type;

//> Operand type for SETEND instruction
typedef enum arm_cpsflag_type
{
    ARM_CPSFLAG_INVALID = 0,
    ARM_CPSFLAG_F = 1,
    ARM_CPSFLAG_I = 2,
    ARM_CPSFLAG_A = 4,
    ARM_CPSFLAG_NONE = 16,  // no flag
} arm_cpsflag_type;

//> Data type for elements of vector instructions.
typedef enum arm_vectordata_type
{
    ARM_VECTORDATA_INVALID = 0,

    // Integer type
    ARM_VECTORDATA_I8,
    ARM_VECTORDATA_I16,
    ARM_VECTORDATA_I32,
    ARM_VECTORDATA_I64,

    // Signed integer type
    ARM_VECTORDATA_S8,
    ARM_VECTORDATA_S16,
    ARM_VECTORDATA_S32,
    ARM_VECTORDATA_S64,

    // Unsigned integer type
    ARM_VECTORDATA_U8,
    ARM_VECTORDATA_U16,
    ARM_VECTORDATA_U32,
    ARM_VECTORDATA_U64,

    // Data type for VMUL/VMULL
    ARM_VECTORDATA_P8,

    // Floating type
    ARM_VECTORDATA_F32,
    ARM_VECTORDATA_F64,

    // Convert float <-> float
    ARM_VECTORDATA_F16F64,  // f16.f64
    ARM_VECTORDATA_F64F16,  // f64.f16
    ARM_VECTORDATA_F32F16,  // f32.f16
    ARM_VECTORDATA_F16F32,  // f32.f16
    ARM_VECTORDATA_F64F32,  // f64.f32
    ARM_VECTORDATA_F32F64,  // f32.f64

    // Convert integer <-> float
    ARM_VECTORDATA_S32F32,  // s32.f32
    ARM_VECTORDATA_U32F32,  // u32.f32
    ARM_VECTORDATA_F32S32,  // f32.s32
    ARM_VECTORDATA_F32U32,  // f32.u32
    ARM_VECTORDATA_F64S16,  // f64.s16
    ARM_VECTORDATA_F32S16,  // f32.s16
    ARM_VECTORDATA_F64S32,  // f64.s32
    ARM_VECTORDATA_S16F64,  // s16.f64
    ARM_VECTORDATA_S16F32,  // s16.f64
    ARM_VECTORDATA_S32F64,  // s32.f64
    ARM_VECTORDATA_U16F64,  // u16.f64
    ARM_VECTORDATA_U16F32,  // u16.f32
    ARM_VECTORDATA_U32F64,  // u32.f64
    ARM_VECTORDATA_F64U16,  // f64.u16
    ARM_VECTORDATA_F32U16,  // f32.u16
    ARM_VECTORDATA_F64U32,  // f64.u32
} arm_vectordata_type;

//> ARM registers
typedef enum arm_reg
{
    ARM_REG_INVALID = 0,
    ARM_REG_APSR,
    ARM_REG_APSR_NZCV,
    ARM_REG_CPSR,
    ARM_REG_FPEXC,
    ARM_REG_FPINST,
    ARM_REG_FPSCR,
    ARM_REG_FPSCR_NZCV,
    ARM_REG_FPSID,
    ARM_REG_ITSTATE,
    ARM_REG_LR,
    ARM_REG_PC,
    ARM_REG_SP,
    ARM_REG_SPSR,
    ARM_REG_D0,
    ARM_REG_D1,
    ARM_REG_D2,
    ARM_REG_D3,
    ARM_REG_D4,
    ARM_REG_D5,
    ARM_REG_D6,
    ARM_REG_D7,
    ARM_REG_D8,
    ARM_REG_D9,
    ARM_REG_D10,
    ARM_REG_D11,
    ARM_REG_D12,
    ARM_REG_D13,
    ARM_REG_D14,
    ARM_REG_D15,
    ARM_REG_D16,
    ARM_REG_D17,
    ARM_REG_D18,
    ARM_REG_D19,
    ARM_REG_D20,
    ARM_REG_D21,
    ARM_REG_D22,
    ARM_REG_D23,
    ARM_REG_D24,
    ARM_REG_D25,
    ARM_REG_D26,
    ARM_REG_D27,
    ARM_REG_D28,
    ARM_REG_D29,
    ARM_REG_D30,
    ARM_REG_D31,
    ARM_REG_FPINST2,
    ARM_REG_MVFR0,
    ARM_REG_MVFR1,
    ARM_REG_MVFR2,
    ARM_REG_Q0,
    ARM_REG_Q1,
    ARM_REG_Q2,
    ARM_REG_Q3,
    ARM_REG_Q4,
    ARM_REG_Q5,
    ARM_REG_Q6,
    ARM_REG_Q7,
    ARM_REG_Q8,
    ARM_REG_Q9,
    ARM_REG_Q10,
    ARM_REG_Q11,
    ARM_REG_Q12,
    ARM_REG_Q13,
    ARM_REG_Q14,
    ARM_REG_Q15,
    ARM_REG_R0,
    ARM_REG_R1,
    ARM_REG_R2,
    ARM_REG_R3,
    ARM_REG_R4,
    ARM_REG_R5,
    ARM_REG_R6,
    ARM_REG_R7,
    ARM_REG_R8,
    ARM_REG_R9,
    ARM_REG_R10,
    ARM_REG_R11,
    ARM_REG_R12,
    ARM_REG_S0,
    ARM_REG_S1,
    ARM_REG_S2,
    ARM_REG_S3,
    ARM_REG_S4,
    ARM_REG_S5,
    ARM_REG_S6,
    ARM_REG_S7,
    ARM_REG_S8,
    ARM_REG_S9,
    ARM_REG_S10,
    ARM_REG_S11,
    ARM_REG_S12,
    ARM_REG_S13,
    ARM_REG_S14,
    ARM_REG_S15,
    ARM_REG_S16,
    ARM_REG_S17,
    ARM_REG_S18,
    ARM_REG_S19,
    ARM_REG_S20,
    ARM_REG_S21,
    ARM_REG_S22,
    ARM_REG_S23,
    ARM_REG_S24,
    ARM_REG_S25,
    ARM_REG_S26,
    ARM_REG_S27,
    ARM_REG_S28,
    ARM_REG_S29,
    ARM_REG_S30,
    ARM_REG_S31,

    ARM_REG_ENDING,     // <-- mark the end of the list or registers

    //> alias registers
    ARM_REG_R13 = ARM_REG_SP,
    ARM_REG_R14 = ARM_REG_LR,
    ARM_REG_R15 = ARM_REG_PC,

    ARM_REG_SB = ARM_REG_R9,
    ARM_REG_SL = ARM_REG_R10,
    ARM_REG_FP = ARM_REG_R11,
    ARM_REG_IP = ARM_REG_R12,
} arm_reg;

// Instruction's operand referring to memory
// This is associated with ARM_OP_MEM operand type above
typedef struct arm_op_mem
{
    arm_reg base;   // base register
    arm_reg index;  // index register
    int scale;  // scale for index register (can be 1, or -1)
    int disp;   // displacement/offset value
    int lshift; // left-shift on index register, or 0 if irrelevant.
} arm_op_mem;

// Instruction operand
typedef struct cs_arm_op
{
    int vector_index;   // Vector Index for some vector operands (or -1 if irrelevant)

    struct
    {
        arm_shifter type;
        unsigned int value;
    } shift;

    arm_op_type type;   // operand type

    union
    {
        int reg;    // register value for REG/SYSREG operand
        int32_t imm;            // immediate value for C-IMM, P-IMM or IMM operand
        double fp;          // floating point value for FP operand
        arm_op_mem mem;     // base/index/scale/disp value for MEM operand
        arm_setend_type setend; // SETEND instruction's operand type
    };

    // in some instructions, an operand can be subtracted or added to
    // the base register,
    bool subtracted; // if TRUE, this operand is subtracted. otherwise, it is added.

    // How is this operand accessed? (READ, WRITE or READ|WRITE)
    // This field is combined of cs_ac_type.
    // NOTE: this field is irrelevant if engine is compiled in DIET mode.
    uint8_t access;

    // Neon lane index for NEON instructions (or -1 if irrelevant)
    int8_t neon_lane;
} cs_arm_op;

// Instruction structure
typedef struct cs_arm
{
    bool usermode;  // User-mode registers to be loaded (for LDM/STM instructions)
    int vector_size;    // Scalar size for vector instructions
    arm_vectordata_type vector_data; // Data type for elements of vector instructions
    arm_cpsmode_type cps_mode;  // CPS mode for CPS instruction
    arm_cpsflag_type cps_flag;  // CPS mode for CPS instruction
    arm_cc cc;          // conditional code for this insn
    bool update_flags;  // does this insn update flags?
    bool writeback;     // does this insn write-back?
    arm_mem_barrier mem_barrier;    // Option for some memory barrier instructions

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;

    cs_arm_op operands[36]; // operands for this instruction.
} cs_arm;

//> ARM instruction
typedef enum arm_insn
{
    ARM_INS_INVALID = 0,

    ARM_INS_ADC,
    ARM_INS_ADD,
    ARM_INS_ADR,
    ARM_INS_AESD,
    ARM_INS_AESE,
    ARM_INS_AESIMC,
    ARM_INS_AESMC,
    ARM_INS_AND,
    ARM_INS_BFC,
    ARM_INS_BFI,
    ARM_INS_BIC,
    ARM_INS_BKPT,
    ARM_INS_BL,
    ARM_INS_BLX,
    ARM_INS_BX,
    ARM_INS_BXJ,
    ARM_INS_B,
    ARM_INS_CDP,
    ARM_INS_CDP2,
    ARM_INS_CLREX,
    ARM_INS_CLZ,
    ARM_INS_CMN,
    ARM_INS_CMP,
    ARM_INS_CPS,
    ARM_INS_CRC32B,
    ARM_INS_CRC32CB,
    ARM_INS_CRC32CH,
    ARM_INS_CRC32CW,
    ARM_INS_CRC32H,
    ARM_INS_CRC32W,
    ARM_INS_DBG,
    ARM_INS_DMB,
    ARM_INS_DSB,
    ARM_INS_EOR,
    ARM_INS_ERET,
    ARM_INS_VMOV,
    ARM_INS_FLDMDBX,
    ARM_INS_FLDMIAX,
    ARM_INS_VMRS,
    ARM_INS_FSTMDBX,
    ARM_INS_FSTMIAX,
    ARM_INS_HINT,
    ARM_INS_HLT,
    ARM_INS_HVC,
    ARM_INS_ISB,
    ARM_INS_LDA,
    ARM_INS_LDAB,
    ARM_INS_LDAEX,
    ARM_INS_LDAEXB,
    ARM_INS_LDAEXD,
    ARM_INS_LDAEXH,
    ARM_INS_LDAH,
    ARM_INS_LDC2L,
    ARM_INS_LDC2,
    ARM_INS_LDCL,
    ARM_INS_LDC,
    ARM_INS_LDMDA,
    ARM_INS_LDMDB,
    ARM_INS_LDM,
    ARM_INS_LDMIB,
    ARM_INS_LDRBT,
    ARM_INS_LDRB,
    ARM_INS_LDRD,
    ARM_INS_LDREX,
    ARM_INS_LDREXB,
    ARM_INS_LDREXD,
    ARM_INS_LDREXH,
    ARM_INS_LDRH,
    ARM_INS_LDRHT,
    ARM_INS_LDRSB,
    ARM_INS_LDRSBT,
    ARM_INS_LDRSH,
    ARM_INS_LDRSHT,
    ARM_INS_LDRT,
    ARM_INS_LDR,
    ARM_INS_MCR,
    ARM_INS_MCR2,
    ARM_INS_MCRR,
    ARM_INS_MCRR2,
    ARM_INS_MLA,
    ARM_INS_MLS,
    ARM_INS_MOV,
    ARM_INS_MOVT,
    ARM_INS_MOVW,
    ARM_INS_MRC,
    ARM_INS_MRC2,
    ARM_INS_MRRC,
    ARM_INS_MRRC2,
    ARM_INS_MRS,
    ARM_INS_MSR,
    ARM_INS_MUL,
    ARM_INS_MVN,
    ARM_INS_ORR,
    ARM_INS_PKHBT,
    ARM_INS_PKHTB,
    ARM_INS_PLDW,
    ARM_INS_PLD,
    ARM_INS_PLI,
    ARM_INS_QADD,
    ARM_INS_QADD16,
    ARM_INS_QADD8,
    ARM_INS_QASX,
    ARM_INS_QDADD,
    ARM_INS_QDSUB,
    ARM_INS_QSAX,
    ARM_INS_QSUB,
    ARM_INS_QSUB16,
    ARM_INS_QSUB8,
    ARM_INS_RBIT,
    ARM_INS_REV,
    ARM_INS_REV16,
    ARM_INS_REVSH,
    ARM_INS_RFEDA,
    ARM_INS_RFEDB,
    ARM_INS_RFEIA,
    ARM_INS_RFEIB,
    ARM_INS_RSB,
    ARM_INS_RSC,
    ARM_INS_SADD16,
    ARM_INS_SADD8,
    ARM_INS_SASX,
    ARM_INS_SBC,
    ARM_INS_SBFX,
    ARM_INS_SDIV,
    ARM_INS_SEL,
    ARM_INS_SETEND,
    ARM_INS_SHA1C,
    ARM_INS_SHA1H,
    ARM_INS_SHA1M,
    ARM_INS_SHA1P,
    ARM_INS_SHA1SU0,
    ARM_INS_SHA1SU1,
    ARM_INS_SHA256H,
    ARM_INS_SHA256H2,
    ARM_INS_SHA256SU0,
    ARM_INS_SHA256SU1,
    ARM_INS_SHADD16,
    ARM_INS_SHADD8,
    ARM_INS_SHASX,
    ARM_INS_SHSAX,
    ARM_INS_SHSUB16,
    ARM_INS_SHSUB8,
    ARM_INS_SMC,
    ARM_INS_SMLABB,
    ARM_INS_SMLABT,
    ARM_INS_SMLAD,
    ARM_INS_SMLADX,
    ARM_INS_SMLAL,
    ARM_INS_SMLALBB,
    ARM_INS_SMLALBT,
    ARM_INS_SMLALD,
    ARM_INS_SMLALDX,
    ARM_INS_SMLALTB,
    ARM_INS_SMLALTT,
    ARM_INS_SMLATB,
    ARM_INS_SMLATT,
    ARM_INS_SMLAWB,
    ARM_INS_SMLAWT,
    ARM_INS_SMLSD,
    ARM_INS_SMLSDX,
    ARM_INS_SMLSLD,
    ARM_INS_SMLSLDX,
    ARM_INS_SMMLA,
    ARM_INS_SMMLAR,
    ARM_INS_SMMLS,
    ARM_INS_SMMLSR,
    ARM_INS_SMMUL,
    ARM_INS_SMMULR,
    ARM_INS_SMUAD,
    ARM_INS_SMUADX,
    ARM_INS_SMULBB,
    ARM_INS_SMULBT,
    ARM_INS_SMULL,
    ARM_INS_SMULTB,
    ARM_INS_SMULTT,
    ARM_INS_SMULWB,
    ARM_INS_SMULWT,
    ARM_INS_SMUSD,
    ARM_INS_SMUSDX,
    ARM_INS_SRSDA,
    ARM_INS_SRSDB,
    ARM_INS_SRSIA,
    ARM_INS_SRSIB,
    ARM_INS_SSAT,
    ARM_INS_SSAT16,
    ARM_INS_SSAX,
    ARM_INS_SSUB16,
    ARM_INS_SSUB8,
    ARM_INS_STC2L,
    ARM_INS_STC2,
    ARM_INS_STCL,
    ARM_INS_STC,
    ARM_INS_STL,
    ARM_INS_STLB,
    ARM_INS_STLEX,
    ARM_INS_STLEXB,
    ARM_INS_STLEXD,
    ARM_INS_STLEXH,
    ARM_INS_STLH,
    ARM_INS_STMDA,
    ARM_INS_STMDB,
    ARM_INS_STM,
    ARM_INS_STMIB,
    ARM_INS_STRBT,
    ARM_INS_STRB,
    ARM_INS_STRD,
    ARM_INS_STREX,
    ARM_INS_STREXB,
    ARM_INS_STREXD,
    ARM_INS_STREXH,
    ARM_INS_STRH,
    ARM_INS_STRHT,
    ARM_INS_STRT,
    ARM_INS_STR,
    ARM_INS_SUB,
    ARM_INS_SVC,
    ARM_INS_SWP,
    ARM_INS_SWPB,
    ARM_INS_SXTAB,
    ARM_INS_SXTAB16,
    ARM_INS_SXTAH,
    ARM_INS_SXTB,
    ARM_INS_SXTB16,
    ARM_INS_SXTH,
    ARM_INS_TEQ,
    ARM_INS_TRAP,
    ARM_INS_TST,
    ARM_INS_UADD16,
    ARM_INS_UADD8,
    ARM_INS_UASX,
    ARM_INS_UBFX,
    ARM_INS_UDF,
    ARM_INS_UDIV,
    ARM_INS_UHADD16,
    ARM_INS_UHADD8,
    ARM_INS_UHASX,
    ARM_INS_UHSAX,
    ARM_INS_UHSUB16,
    ARM_INS_UHSUB8,
    ARM_INS_UMAAL,
    ARM_INS_UMLAL,
    ARM_INS_UMULL,
    ARM_INS_UQADD16,
    ARM_INS_UQADD8,
    ARM_INS_UQASX,
    ARM_INS_UQSAX,
    ARM_INS_UQSUB16,
    ARM_INS_UQSUB8,
    ARM_INS_USAD8,
    ARM_INS_USADA8,
    ARM_INS_USAT,
    ARM_INS_USAT16,
    ARM_INS_USAX,
    ARM_INS_USUB16,
    ARM_INS_USUB8,
    ARM_INS_UXTAB,
    ARM_INS_UXTAB16,
    ARM_INS_UXTAH,
    ARM_INS_UXTB,
    ARM_INS_UXTB16,
    ARM_INS_UXTH,
    ARM_INS_VABAL,
    ARM_INS_VABA,
    ARM_INS_VABDL,
    ARM_INS_VABD,
    ARM_INS_VABS,
    ARM_INS_VACGE,
    ARM_INS_VACGT,
    ARM_INS_VADD,
    ARM_INS_VADDHN,
    ARM_INS_VADDL,
    ARM_INS_VADDW,
    ARM_INS_VAND,
    ARM_INS_VBIC,
    ARM_INS_VBIF,
    ARM_INS_VBIT,
    ARM_INS_VBSL,
    ARM_INS_VCEQ,
    ARM_INS_VCGE,
    ARM_INS_VCGT,
    ARM_INS_VCLE,
    ARM_INS_VCLS,
    ARM_INS_VCLT,
    ARM_INS_VCLZ,
    ARM_INS_VCMP,
    ARM_INS_VCMPE,
    ARM_INS_VCNT,
    ARM_INS_VCVTA,
    ARM_INS_VCVTB,
    ARM_INS_VCVT,
    ARM_INS_VCVTM,
    ARM_INS_VCVTN,
    ARM_INS_VCVTP,
    ARM_INS_VCVTT,
    ARM_INS_VDIV,
    ARM_INS_VDUP,
    ARM_INS_VEOR,
    ARM_INS_VEXT,
    ARM_INS_VFMA,
    ARM_INS_VFMS,
    ARM_INS_VFNMA,
    ARM_INS_VFNMS,
    ARM_INS_VHADD,
    ARM_INS_VHSUB,
    ARM_INS_VLD1,
    ARM_INS_VLD2,
    ARM_INS_VLD3,
    ARM_INS_VLD4,
    ARM_INS_VLDMDB,
    ARM_INS_VLDMIA,
    ARM_INS_VLDR,
    ARM_INS_VMAXNM,
    ARM_INS_VMAX,
    ARM_INS_VMINNM,
    ARM_INS_VMIN,
    ARM_INS_VMLA,
    ARM_INS_VMLAL,
    ARM_INS_VMLS,
    ARM_INS_VMLSL,
    ARM_INS_VMOVL,
    ARM_INS_VMOVN,
    ARM_INS_VMSR,
    ARM_INS_VMUL,
    ARM_INS_VMULL,
    ARM_INS_VMVN,
    ARM_INS_VNEG,
    ARM_INS_VNMLA,
    ARM_INS_VNMLS,
    ARM_INS_VNMUL,
    ARM_INS_VORN,
    ARM_INS_VORR,
    ARM_INS_VPADAL,
    ARM_INS_VPADDL,
    ARM_INS_VPADD,
    ARM_INS_VPMAX,
    ARM_INS_VPMIN,
    ARM_INS_VQABS,
    ARM_INS_VQADD,
    ARM_INS_VQDMLAL,
    ARM_INS_VQDMLSL,
    ARM_INS_VQDMULH,
    ARM_INS_VQDMULL,
    ARM_INS_VQMOVUN,
    ARM_INS_VQMOVN,
    ARM_INS_VQNEG,
    ARM_INS_VQRDMULH,
    ARM_INS_VQRSHL,
    ARM_INS_VQRSHRN,
    ARM_INS_VQRSHRUN,
    ARM_INS_VQSHL,
    ARM_INS_VQSHLU,
    ARM_INS_VQSHRN,
    ARM_INS_VQSHRUN,
    ARM_INS_VQSUB,
    ARM_INS_VRADDHN,
    ARM_INS_VRECPE,
    ARM_INS_VRECPS,
    ARM_INS_VREV16,
    ARM_INS_VREV32,
    ARM_INS_VREV64,
    ARM_INS_VRHADD,
    ARM_INS_VRINTA,
    ARM_INS_VRINTM,
    ARM_INS_VRINTN,
    ARM_INS_VRINTP,
    ARM_INS_VRINTR,
    ARM_INS_VRINTX,
    ARM_INS_VRINTZ,
    ARM_INS_VRSHL,
    ARM_INS_VRSHRN,
    ARM_INS_VRSHR,
    ARM_INS_VRSQRTE,
    ARM_INS_VRSQRTS,
    ARM_INS_VRSRA,
    ARM_INS_VRSUBHN,
    ARM_INS_VSELEQ,
    ARM_INS_VSELGE,
    ARM_INS_VSELGT,
    ARM_INS_VSELVS,
    ARM_INS_VSHLL,
    ARM_INS_VSHL,
    ARM_INS_VSHRN,
    ARM_INS_VSHR,
    ARM_INS_VSLI,
    ARM_INS_VSQRT,
    ARM_INS_VSRA,
    ARM_INS_VSRI,
    ARM_INS_VST1,
    ARM_INS_VST2,
    ARM_INS_VST3,
    ARM_INS_VST4,
    ARM_INS_VSTMDB,
    ARM_INS_VSTMIA,
    ARM_INS_VSTR,
    ARM_INS_VSUB,
    ARM_INS_VSUBHN,
    ARM_INS_VSUBL,
    ARM_INS_VSUBW,
    ARM_INS_VSWP,
    ARM_INS_VTBL,
    ARM_INS_VTBX,
    ARM_INS_VCVTR,
    ARM_INS_VTRN,
    ARM_INS_VTST,
    ARM_INS_VUZP,
    ARM_INS_VZIP,
    ARM_INS_ADDW,
    ARM_INS_ASR,
    ARM_INS_DCPS1,
    ARM_INS_DCPS2,
    ARM_INS_DCPS3,
    ARM_INS_IT,
    ARM_INS_LSL,
    ARM_INS_LSR,
    ARM_INS_ORN,
    ARM_INS_ROR,
    ARM_INS_RRX,
    ARM_INS_SUBW,
    ARM_INS_TBB,
    ARM_INS_TBH,
    ARM_INS_CBNZ,
    ARM_INS_CBZ,
    ARM_INS_POP,
    ARM_INS_PUSH,

    // special instructions
    ARM_INS_NOP,
    ARM_INS_YIELD,
    ARM_INS_WFE,
    ARM_INS_WFI,
    ARM_INS_SEV,
    ARM_INS_SEVL,
    ARM_INS_VPUSH,
    ARM_INS_VPOP,

    ARM_INS_ENDING, // <-- mark the end of the list of instructions
} arm_insn;

//> Group of ARM instructions
typedef enum arm_insn_group
{
    ARM_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    ARM_GRP_JUMP,   // = CS_GRP_JUMP
    ARM_GRP_CALL,   // = CS_GRP_CALL
    ARM_GRP_INT = 4, // = CS_GRP_INT
    ARM_GRP_PRIVILEGE = 6, // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    ARM_GRP_CRYPTO = 128,
    ARM_GRP_DATABARRIER,
    ARM_GRP_DIVIDE,
    ARM_GRP_FPARMV8,
    ARM_GRP_MULTPRO,
    ARM_GRP_NEON,
    ARM_GRP_T2EXTRACTPACK,
    ARM_GRP_THUMB2DSP,
    ARM_GRP_TRUSTZONE,
    ARM_GRP_V4T,
    ARM_GRP_V5T,
    ARM_GRP_V5TE,
    ARM_GRP_V6,
    ARM_GRP_V6T2,
    ARM_GRP_V7,
    ARM_GRP_V8,
    ARM_GRP_VFP2,
    ARM_GRP_VFP3,
    ARM_GRP_VFP4,
    ARM_GRP_ARM,
    ARM_GRP_MCLASS,
    ARM_GRP_NOTMCLASS,
    ARM_GRP_THUMB,
    ARM_GRP_THUMB1ONLY,
    ARM_GRP_THUMB2,
    ARM_GRP_PREV8,
    ARM_GRP_FPVMLX,
    ARM_GRP_MULOPS,
    ARM_GRP_CRC,
    ARM_GRP_DPVFP,
    ARM_GRP_V6M,
    ARM_GRP_VIRTUALIZATION,

    ARM_GRP_ENDING,
} arm_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/arm64.h`:

```h
#ifndef CAPSTONE_ARM64_H
#define CAPSTONE_ARM64_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM64 shift type
typedef enum arm64_shifter
{
    ARM64_SFT_INVALID = 0,
    ARM64_SFT_LSL = 1,
    ARM64_SFT_MSL = 2,
    ARM64_SFT_LSR = 3,
    ARM64_SFT_ASR = 4,
    ARM64_SFT_ROR = 5,
} arm64_shifter;

//> ARM64 extender type
typedef enum arm64_extender
{
    ARM64_EXT_INVALID = 0,
    ARM64_EXT_UXTB = 1,
    ARM64_EXT_UXTH = 2,
    ARM64_EXT_UXTW = 3,
    ARM64_EXT_UXTX = 4,
    ARM64_EXT_SXTB = 5,
    ARM64_EXT_SXTH = 6,
    ARM64_EXT_SXTW = 7,
    ARM64_EXT_SXTX = 8,
} arm64_extender;

//> ARM64 condition code
typedef enum arm64_cc
{
    ARM64_CC_INVALID = 0,
    ARM64_CC_EQ = 1,     // Equal
    ARM64_CC_NE = 2,     // Not equal:                 Not equal, or unordered
    ARM64_CC_HS = 3,     // Unsigned higher or same:   >, ==, or unordered
    ARM64_CC_LO = 4,     // Unsigned lower or same:    Less than
    ARM64_CC_MI = 5,     // Minus, negative:           Less than
    ARM64_CC_PL = 6,     // Plus, positive or zero:    >, ==, or unordered
    ARM64_CC_VS = 7,     // Overflow:                  Unordered
    ARM64_CC_VC = 8,     // No overflow:               Ordered
    ARM64_CC_HI = 9,     // Unsigned higher:           Greater than, or unordered
    ARM64_CC_LS = 10,     // Unsigned lower or same:    Less than or equal
    ARM64_CC_GE = 11,     // Greater than or equal:     Greater than or equal
    ARM64_CC_LT = 12,     // Less than:                 Less than, or unordered
    ARM64_CC_GT = 13,     // Signed greater than:       Greater than
    ARM64_CC_LE = 14,     // Signed less than or equal: <, ==, or unordered
    ARM64_CC_AL = 15,     // Always (unconditional):    Always (unconditional)
    ARM64_CC_NV = 16,     // Always (unconditional):   Always (unconditional)
    // Note the NV exists purely to disassemble 0b1111. Execution
    // is "always".
} arm64_cc;

//> System registers
typedef enum arm64_sysreg
{
    //> System registers for MRS
    ARM64_SYSREG_INVALID           = 0,
    ARM64_SYSREG_MDCCSR_EL0        = 0x9808, // 10  011  0000  0001  000
    ARM64_SYSREG_DBGDTRRX_EL0      = 0x9828, // 10  011  0000  0101  000
    ARM64_SYSREG_MDRAR_EL1         = 0x8080, // 10  000  0001  0000  000
    ARM64_SYSREG_OSLSR_EL1         = 0x808c, // 10  000  0001  0001  100
    ARM64_SYSREG_DBGAUTHSTATUS_EL1 = 0x83f6, // 10  000  0111  1110  110
    ARM64_SYSREG_PMCEID0_EL0       = 0xdce6, // 11  011  1001  1100  110
    ARM64_SYSREG_PMCEID1_EL0       = 0xdce7, // 11  011  1001  1100  111
    ARM64_SYSREG_MIDR_EL1          = 0xc000, // 11  000  0000  0000  000
    ARM64_SYSREG_CCSIDR_EL1        = 0xc800, // 11  001  0000  0000  000
    ARM64_SYSREG_CLIDR_EL1         = 0xc801, // 11  001  0000  0000  001
    ARM64_SYSREG_CTR_EL0           = 0xd801, // 11  011  0000  0000  001
    ARM64_SYSREG_MPIDR_EL1         = 0xc005, // 11  000  0000  0000  101
    ARM64_SYSREG_REVIDR_EL1        = 0xc006, // 11  000  0000  0000  110
    ARM64_SYSREG_AIDR_EL1          = 0xc807, // 11  001  0000  0000  111
    ARM64_SYSREG_DCZID_EL0         = 0xd807, // 11  011  0000  0000  111
    ARM64_SYSREG_ID_PFR0_EL1       = 0xc008, // 11  000  0000  0001  000
    ARM64_SYSREG_ID_PFR1_EL1       = 0xc009, // 11  000  0000  0001  001
    ARM64_SYSREG_ID_DFR0_EL1       = 0xc00a, // 11  000  0000  0001  010
    ARM64_SYSREG_ID_AFR0_EL1       = 0xc00b, // 11  000  0000  0001  011
    ARM64_SYSREG_ID_MMFR0_EL1      = 0xc00c, // 11  000  0000  0001  100
    ARM64_SYSREG_ID_MMFR1_EL1      = 0xc00d, // 11  000  0000  0001  101
    ARM64_SYSREG_ID_MMFR2_EL1      = 0xc00e, // 11  000  0000  0001  110
    ARM64_SYSREG_ID_MMFR3_EL1      = 0xc00f, // 11  000  0000  0001  111
    ARM64_SYSREG_ID_ISAR0_EL1      = 0xc010, // 11  000  0000  0010  000
    ARM64_SYSREG_ID_ISAR1_EL1      = 0xc011, // 11  000  0000  0010  001
    ARM64_SYSREG_ID_ISAR2_EL1      = 0xc012, // 11  000  0000  0010  010
    ARM64_SYSREG_ID_ISAR3_EL1      = 0xc013, // 11  000  0000  0010  011
    ARM64_SYSREG_ID_ISAR4_EL1      = 0xc014, // 11  000  0000  0010  100
    ARM64_SYSREG_ID_ISAR5_EL1      = 0xc015, // 11  000  0000  0010  101
    ARM64_SYSREG_ID_A64PFR0_EL1   = 0xc020, // 11  000  0000  0100  000
    ARM64_SYSREG_ID_A64PFR1_EL1   = 0xc021, // 11  000  0000  0100  001
    ARM64_SYSREG_ID_A64DFR0_EL1   = 0xc028, // 11  000  0000  0101  000
    ARM64_SYSREG_ID_A64DFR1_EL1   = 0xc029, // 11  000  0000  0101  001
    ARM64_SYSREG_ID_A64AFR0_EL1   = 0xc02c, // 11  000  0000  0101  100
    ARM64_SYSREG_ID_A64AFR1_EL1   = 0xc02d, // 11  000  0000  0101  101
    ARM64_SYSREG_ID_A64ISAR0_EL1  = 0xc030, // 11  000  0000  0110  000
    ARM64_SYSREG_ID_A64ISAR1_EL1  = 0xc031, // 11  000  0000  0110  001
    ARM64_SYSREG_ID_A64MMFR0_EL1  = 0xc038, // 11  000  0000  0111  000
    ARM64_SYSREG_ID_A64MMFR1_EL1  = 0xc039, // 11  000  0000  0111  001
    ARM64_SYSREG_MVFR0_EL1         = 0xc018, // 11  000  0000  0011  000
    ARM64_SYSREG_MVFR1_EL1         = 0xc019, // 11  000  0000  0011  001
    ARM64_SYSREG_MVFR2_EL1         = 0xc01a, // 11  000  0000  0011  010
    ARM64_SYSREG_RVBAR_EL1         = 0xc601, // 11  000  1100  0000  001
    ARM64_SYSREG_RVBAR_EL2         = 0xe601, // 11  100  1100  0000  001
    ARM64_SYSREG_RVBAR_EL3         = 0xf601, // 11  110  1100  0000  001
    ARM64_SYSREG_ISR_EL1           = 0xc608, // 11  000  1100  0001  000
    ARM64_SYSREG_CNTPCT_EL0        = 0xdf01, // 11  011  1110  0000  001
    ARM64_SYSREG_CNTVCT_EL0        = 0xdf02,  // 11  011  1110  0000  010

    // Trace registers
    ARM64_SYSREG_TRCSTATR          = 0x8818, // 10  001  0000  0011  000
    ARM64_SYSREG_TRCIDR8           = 0x8806, // 10  001  0000  0000  110
    ARM64_SYSREG_TRCIDR9           = 0x880e, // 10  001  0000  0001  110
    ARM64_SYSREG_TRCIDR10          = 0x8816, // 10  001  0000  0010  110
    ARM64_SYSREG_TRCIDR11          = 0x881e, // 10  001  0000  0011  110
    ARM64_SYSREG_TRCIDR12          = 0x8826, // 10  001  0000  0100  110
    ARM64_SYSREG_TRCIDR13          = 0x882e, // 10  001  0000  0101  110
    ARM64_SYSREG_TRCIDR0           = 0x8847, // 10  001  0000  1000  111
    ARM64_SYSREG_TRCIDR1           = 0x884f, // 10  001  0000  1001  111
    ARM64_SYSREG_TRCIDR2           = 0x8857, // 10  001  0000  1010  111
    ARM64_SYSREG_TRCIDR3           = 0x885f, // 10  001  0000  1011  111
    ARM64_SYSREG_TRCIDR4           = 0x8867, // 10  001  0000  1100  111
    ARM64_SYSREG_TRCIDR5           = 0x886f, // 10  001  0000  1101  111
    ARM64_SYSREG_TRCIDR6           = 0x8877, // 10  001  0000  1110  111
    ARM64_SYSREG_TRCIDR7           = 0x887f, // 10  001  0000  1111  111
    ARM64_SYSREG_TRCOSLSR          = 0x888c, // 10  001  0001  0001  100
    ARM64_SYSREG_TRCPDSR           = 0x88ac, // 10  001  0001  0101  100
    ARM64_SYSREG_TRCDEVAFF0        = 0x8bd6, // 10  001  0111  1010  110
    ARM64_SYSREG_TRCDEVAFF1        = 0x8bde, // 10  001  0111  1011  110
    ARM64_SYSREG_TRCLSR            = 0x8bee, // 10  001  0111  1101  110
    ARM64_SYSREG_TRCAUTHSTATUS     = 0x8bf6, // 10  001  0111  1110  110
    ARM64_SYSREG_TRCDEVARCH        = 0x8bfe, // 10  001  0111  1111  110
    ARM64_SYSREG_TRCDEVID          = 0x8b97, // 10  001  0111  0010  111
    ARM64_SYSREG_TRCDEVTYPE        = 0x8b9f, // 10  001  0111  0011  111
    ARM64_SYSREG_TRCPIDR4          = 0x8ba7, // 10  001  0111  0100  111
    ARM64_SYSREG_TRCPIDR5          = 0x8baf, // 10  001  0111  0101  111
    ARM64_SYSREG_TRCPIDR6          = 0x8bb7, // 10  001  0111  0110  111
    ARM64_SYSREG_TRCPIDR7          = 0x8bbf, // 10  001  0111  0111  111
    ARM64_SYSREG_TRCPIDR0          = 0x8bc7, // 10  001  0111  1000  111
    ARM64_SYSREG_TRCPIDR1          = 0x8bcf, // 10  001  0111  1001  111
    ARM64_SYSREG_TRCPIDR2          = 0x8bd7, // 10  001  0111  1010  111
    ARM64_SYSREG_TRCPIDR3          = 0x8bdf, // 10  001  0111  1011  111
    ARM64_SYSREG_TRCCIDR0          = 0x8be7, // 10  001  0111  1100  111
    ARM64_SYSREG_TRCCIDR1          = 0x8bef, // 10  001  0111  1101  111
    ARM64_SYSREG_TRCCIDR2          = 0x8bf7, // 10  001  0111  1110  111
    ARM64_SYSREG_TRCCIDR3          = 0x8bff, // 10  001  0111  1111  111

    // GICv3 registers
    ARM64_SYSREG_ICC_IAR1_EL1      = 0xc660, // 11  000  1100  1100  000
    ARM64_SYSREG_ICC_IAR0_EL1      = 0xc640, // 11  000  1100  1000  000
    ARM64_SYSREG_ICC_HPPIR1_EL1    = 0xc662, // 11  000  1100  1100  010
    ARM64_SYSREG_ICC_HPPIR0_EL1    = 0xc642, // 11  000  1100  1000  010
    ARM64_SYSREG_ICC_RPR_EL1       = 0xc65b, // 11  000  1100  1011  011
    ARM64_SYSREG_ICH_VTR_EL2       = 0xe659, // 11  100  1100  1011  001
    ARM64_SYSREG_ICH_EISR_EL2      = 0xe65b, // 11  100  1100  1011  011
    ARM64_SYSREG_ICH_ELSR_EL2      = 0xe65d, // 11  100  1100  1011  101
} arm64_sysreg;

typedef enum arm64_msr_reg
{
    //> System registers for MSR
    ARM64_SYSREG_DBGDTRTX_EL0      = 0x9828, // 10  011  0000  0101  000
    ARM64_SYSREG_OSLAR_EL1         = 0x8084, // 10  000  0001  0000  100
    ARM64_SYSREG_PMSWINC_EL0       = 0xdce4,  // 11  011  1001  1100  100

    // Trace Registers
    ARM64_SYSREG_TRCOSLAR          = 0x8884, // 10  001  0001  0000  100
    ARM64_SYSREG_TRCLAR            = 0x8be6, // 10  001  0111  1100  110

    // GICv3 registers
    ARM64_SYSREG_ICC_EOIR1_EL1     = 0xc661, // 11  000  1100  1100  001
    ARM64_SYSREG_ICC_EOIR0_EL1     = 0xc641, // 11  000  1100  1000  001
    ARM64_SYSREG_ICC_DIR_EL1       = 0xc659, // 11  000  1100  1011  001
    ARM64_SYSREG_ICC_SGI1R_EL1     = 0xc65d, // 11  000  1100  1011  101
    ARM64_SYSREG_ICC_ASGI1R_EL1    = 0xc65e, // 11  000  1100  1011  110
    ARM64_SYSREG_ICC_SGI0R_EL1     = 0xc65f, // 11  000  1100  1011  111
} arm64_msr_reg;

//> System PState Field (MSR instruction)
typedef enum arm64_pstate
{
    ARM64_PSTATE_INVALID = 0,
    ARM64_PSTATE_SPSEL = 0x05,
    ARM64_PSTATE_DAIFSET = 0x1e,
    ARM64_PSTATE_DAIFCLR = 0x1f
} arm64_pstate;

//> Vector arrangement specifier (for FloatingPoint/Advanced SIMD insn)
typedef enum arm64_vas
{
    ARM64_VAS_INVALID = 0,
    ARM64_VAS_8B,
    ARM64_VAS_16B,
    ARM64_VAS_4H,
    ARM64_VAS_8H,
    ARM64_VAS_2S,
    ARM64_VAS_4S,
    ARM64_VAS_1D,
    ARM64_VAS_2D,
    ARM64_VAS_1Q,
} arm64_vas;

//> Vector element size specifier
typedef enum arm64_vess
{
    ARM64_VESS_INVALID = 0,
    ARM64_VESS_B,
    ARM64_VESS_H,
    ARM64_VESS_S,
    ARM64_VESS_D,
} arm64_vess;

//> Memory barrier operands
typedef enum arm64_barrier_op
{
    ARM64_BARRIER_INVALID = 0,
    ARM64_BARRIER_OSHLD = 0x1,
    ARM64_BARRIER_OSHST = 0x2,
    ARM64_BARRIER_OSH =   0x3,
    ARM64_BARRIER_NSHLD = 0x5,
    ARM64_BARRIER_NSHST = 0x6,
    ARM64_BARRIER_NSH =   0x7,
    ARM64_BARRIER_ISHLD = 0x9,
    ARM64_BARRIER_ISHST = 0xa,
    ARM64_BARRIER_ISH =   0xb,
    ARM64_BARRIER_LD =    0xd,
    ARM64_BARRIER_ST =    0xe,
    ARM64_BARRIER_SY =    0xf
} arm64_barrier_op;

//> Operand type for instruction's operands
typedef enum arm64_op_type
{
    ARM64_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    ARM64_OP_REG, // = CS_OP_REG (Register operand).
    ARM64_OP_IMM, // = CS_OP_IMM (Immediate operand).
    ARM64_OP_MEM, // = CS_OP_MEM (Memory operand).
    ARM64_OP_FP,  // = CS_OP_FP (Floating-Point operand).
    ARM64_OP_CIMM = 64, // C-Immediate
    ARM64_OP_REG_MRS, // MRS register operand.
    ARM64_OP_REG_MSR, // MSR register operand.
    ARM64_OP_PSTATE, // PState operand.
    ARM64_OP_SYS, // SYS operand for IC/DC/AT/TLBI instructions.
    ARM64_OP_PREFETCH, // Prefetch operand (PRFM).
    ARM64_OP_BARRIER, // Memory barrier operand (ISB/DMB/DSB instructions).
} arm64_op_type;

//> TLBI operations
typedef enum arm64_tlbi_op
{
    ARM64_TLBI_INVALID = 0,
    ARM64_TLBI_VMALLE1IS,
    ARM64_TLBI_VAE1IS,
    ARM64_TLBI_ASIDE1IS,
    ARM64_TLBI_VAAE1IS,
    ARM64_TLBI_VALE1IS,
    ARM64_TLBI_VAALE1IS,
    ARM64_TLBI_ALLE2IS,
    ARM64_TLBI_VAE2IS,
    ARM64_TLBI_ALLE1IS,
    ARM64_TLBI_VALE2IS,
    ARM64_TLBI_VMALLS12E1IS,
    ARM64_TLBI_ALLE3IS,
    ARM64_TLBI_VAE3IS,
    ARM64_TLBI_VALE3IS,
    ARM64_TLBI_IPAS2E1IS,
    ARM64_TLBI_IPAS2LE1IS,
    ARM64_TLBI_IPAS2E1,
    ARM64_TLBI_IPAS2LE1,
    ARM64_TLBI_VMALLE1,
    ARM64_TLBI_VAE1,
    ARM64_TLBI_ASIDE1,
    ARM64_TLBI_VAAE1,
    ARM64_TLBI_VALE1,
    ARM64_TLBI_VAALE1,
    ARM64_TLBI_ALLE2,
    ARM64_TLBI_VAE2,
    ARM64_TLBI_ALLE1,
    ARM64_TLBI_VALE2,
    ARM64_TLBI_VMALLS12E1,
    ARM64_TLBI_ALLE3,
    ARM64_TLBI_VAE3,
    ARM64_TLBI_VALE3,
} arm64_tlbi_op;

//> AT operations
typedef enum arm64_at_op
{
    ARM64_AT_S1E1R,
    ARM64_AT_S1E1W,
    ARM64_AT_S1E0R,
    ARM64_AT_S1E0W,
    ARM64_AT_S1E2R,
    ARM64_AT_S1E2W,
    ARM64_AT_S12E1R,
    ARM64_AT_S12E1W,
    ARM64_AT_S12E0R,
    ARM64_AT_S12E0W,
    ARM64_AT_S1E3R,
    ARM64_AT_S1E3W,
} arm64_at_op;

//> DC operations
typedef enum arm64_dc_op
{
    ARM64_DC_INVALID = 0,
    ARM64_DC_ZVA,
    ARM64_DC_IVAC,
    ARM64_DC_ISW,
    ARM64_DC_CVAC,
    ARM64_DC_CSW,
    ARM64_DC_CVAU,
    ARM64_DC_CIVAC,
    ARM64_DC_CISW,
} arm64_dc_op;

//> IC operations
typedef enum arm64_ic_op
{
    ARM64_IC_INVALID = 0,
    ARM64_IC_IALLUIS,
    ARM64_IC_IALLU,
    ARM64_IC_IVAU,
} arm64_ic_op;

//> Prefetch operations (PRFM)
typedef enum arm64_prefetch_op
{
    ARM64_PRFM_INVALID = 0,
    ARM64_PRFM_PLDL1KEEP = 0x00 + 1,
    ARM64_PRFM_PLDL1STRM = 0x01 + 1,
    ARM64_PRFM_PLDL2KEEP = 0x02 + 1,
    ARM64_PRFM_PLDL2STRM = 0x03 + 1,
    ARM64_PRFM_PLDL3KEEP = 0x04 + 1,
    ARM64_PRFM_PLDL3STRM = 0x05 + 1,
    ARM64_PRFM_PLIL1KEEP = 0x08 + 1,
    ARM64_PRFM_PLIL1STRM = 0x09 + 1,
    ARM64_PRFM_PLIL2KEEP = 0x0a + 1,
    ARM64_PRFM_PLIL2STRM = 0x0b + 1,
    ARM64_PRFM_PLIL3KEEP = 0x0c + 1,
    ARM64_PRFM_PLIL3STRM = 0x0d + 1,
    ARM64_PRFM_PSTL1KEEP = 0x10 + 1,
    ARM64_PRFM_PSTL1STRM = 0x11 + 1,
    ARM64_PRFM_PSTL2KEEP = 0x12 + 1,
    ARM64_PRFM_PSTL2STRM = 0x13 + 1,
    ARM64_PRFM_PSTL3KEEP = 0x14 + 1,
    ARM64_PRFM_PSTL3STRM = 0x15 + 1,
} arm64_prefetch_op;


//> ARM64 registers
typedef enum arm64_reg
{
    ARM64_REG_INVALID = 0,

    ARM64_REG_X29,
    ARM64_REG_X30,
    ARM64_REG_NZCV,
    ARM64_REG_SP,
    ARM64_REG_WSP,
    ARM64_REG_WZR,
    ARM64_REG_XZR,
    ARM64_REG_B0,
    ARM64_REG_B1,
    ARM64_REG_B2,
    ARM64_REG_B3,
    ARM64_REG_B4,
    ARM64_REG_B5,
    ARM64_REG_B6,
    ARM64_REG_B7,
    ARM64_REG_B8,
    ARM64_REG_B9,
    ARM64_REG_B10,
    ARM64_REG_B11,
    ARM64_REG_B12,
    ARM64_REG_B13,
    ARM64_REG_B14,
    ARM64_REG_B15,
    ARM64_REG_B16,
    ARM64_REG_B17,
    ARM64_REG_B18,
    ARM64_REG_B19,
    ARM64_REG_B20,
    ARM64_REG_B21,
    ARM64_REG_B22,
    ARM64_REG_B23,
    ARM64_REG_B24,
    ARM64_REG_B25,
    ARM64_REG_B26,
    ARM64_REG_B27,
    ARM64_REG_B28,
    ARM64_REG_B29,
    ARM64_REG_B30,
    ARM64_REG_B31,
    ARM64_REG_D0,
    ARM64_REG_D1,
    ARM64_REG_D2,
    ARM64_REG_D3,
    ARM64_REG_D4,
    ARM64_REG_D5,
    ARM64_REG_D6,
    ARM64_REG_D7,
    ARM64_REG_D8,
    ARM64_REG_D9,
    ARM64_REG_D10,
    ARM64_REG_D11,
    ARM64_REG_D12,
    ARM64_REG_D13,
    ARM64_REG_D14,
    ARM64_REG_D15,
    ARM64_REG_D16,
    ARM64_REG_D17,
    ARM64_REG_D18,
    ARM64_REG_D19,
    ARM64_REG_D20,
    ARM64_REG_D21,
    ARM64_REG_D22,
    ARM64_REG_D23,
    ARM64_REG_D24,
    ARM64_REG_D25,
    ARM64_REG_D26,
    ARM64_REG_D27,
    ARM64_REG_D28,
    ARM64_REG_D29,
    ARM64_REG_D30,
    ARM64_REG_D31,
    ARM64_REG_H0,
    ARM64_REG_H1,
    ARM64_REG_H2,
    ARM64_REG_H3,
    ARM64_REG_H4,
    ARM64_REG_H5,
    ARM64_REG_H6,
    ARM64_REG_H7,
    ARM64_REG_H8,
    ARM64_REG_H9,
    ARM64_REG_H10,
    ARM64_REG_H11,
    ARM64_REG_H12,
    ARM64_REG_H13,
    ARM64_REG_H14,
    ARM64_REG_H15,
    ARM64_REG_H16,
    ARM64_REG_H17,
    ARM64_REG_H18,
    ARM64_REG_H19,
    ARM64_REG_H20,
    ARM64_REG_H21,
    ARM64_REG_H22,
    ARM64_REG_H23,
    ARM64_REG_H24,
    ARM64_REG_H25,
    ARM64_REG_H26,
    ARM64_REG_H27,
    ARM64_REG_H28,
    ARM64_REG_H29,
    ARM64_REG_H30,
    ARM64_REG_H31,
    ARM64_REG_Q0,
    ARM64_REG_Q1,
    ARM64_REG_Q2,
    ARM64_REG_Q3,
    ARM64_REG_Q4,
    ARM64_REG_Q5,
    ARM64_REG_Q6,
    ARM64_REG_Q7,
    ARM64_REG_Q8,
    ARM64_REG_Q9,
    ARM64_REG_Q10,
    ARM64_REG_Q11,
    ARM64_REG_Q12,
    ARM64_REG_Q13,
    ARM64_REG_Q14,
    ARM64_REG_Q15,
    ARM64_REG_Q16,
    ARM64_REG_Q17,
    ARM64_REG_Q18,
    ARM64_REG_Q19,
    ARM64_REG_Q20,
    ARM64_REG_Q21,
    ARM64_REG_Q22,
    ARM64_REG_Q23,
    ARM64_REG_Q24,
    ARM64_REG_Q25,
    ARM64_REG_Q26,
    ARM64_REG_Q27,
    ARM64_REG_Q28,
    ARM64_REG_Q29,
    ARM64_REG_Q30,
    ARM64_REG_Q31,
    ARM64_REG_S0,
    ARM64_REG_S1,
    ARM64_REG_S2,
    ARM64_REG_S3,
    ARM64_REG_S4,
    ARM64_REG_S5,
    ARM64_REG_S6,
    ARM64_REG_S7,
    ARM64_REG_S8,
    ARM64_REG_S9,
    ARM64_REG_S10,
    ARM64_REG_S11,
    ARM64_REG_S12,
    ARM64_REG_S13,
    ARM64_REG_S14,
    ARM64_REG_S15,
    ARM64_REG_S16,
    ARM64_REG_S17,
    ARM64_REG_S18,
    ARM64_REG_S19,
    ARM64_REG_S20,
    ARM64_REG_S21,
    ARM64_REG_S22,
    ARM64_REG_S23,
    ARM64_REG_S24,
    ARM64_REG_S25,
    ARM64_REG_S26,
    ARM64_REG_S27,
    ARM64_REG_S28,
    ARM64_REG_S29,
    ARM64_REG_S30,
    ARM64_REG_S31,
    ARM64_REG_W0,
    ARM64_REG_W1,
    ARM64_REG_W2,
    ARM64_REG_W3,
    ARM64_REG_W4,
    ARM64_REG_W5,
    ARM64_REG_W6,
    ARM64_REG_W7,
    ARM64_REG_W8,
    ARM64_REG_W9,
    ARM64_REG_W10,
    ARM64_REG_W11,
    ARM64_REG_W12,
    ARM64_REG_W13,
    ARM64_REG_W14,
    ARM64_REG_W15,
    ARM64_REG_W16,
    ARM64_REG_W17,
    ARM64_REG_W18,
    ARM64_REG_W19,
    ARM64_REG_W20,
    ARM64_REG_W21,
    ARM64_REG_W22,
    ARM64_REG_W23,
    ARM64_REG_W24,
    ARM64_REG_W25,
    ARM64_REG_W26,
    ARM64_REG_W27,
    ARM64_REG_W28,
    ARM64_REG_W29,
    ARM64_REG_W30,
    ARM64_REG_X0,
    ARM64_REG_X1,
    ARM64_REG_X2,
    ARM64_REG_X3,
    ARM64_REG_X4,
    ARM64_REG_X5,
    ARM64_REG_X6,
    ARM64_REG_X7,
    ARM64_REG_X8,
    ARM64_REG_X9,
    ARM64_REG_X10,
    ARM64_REG_X11,
    ARM64_REG_X12,
    ARM64_REG_X13,
    ARM64_REG_X14,
    ARM64_REG_X15,
    ARM64_REG_X16,
    ARM64_REG_X17,
    ARM64_REG_X18,
    ARM64_REG_X19,
    ARM64_REG_X20,
    ARM64_REG_X21,
    ARM64_REG_X22,
    ARM64_REG_X23,
    ARM64_REG_X24,
    ARM64_REG_X25,
    ARM64_REG_X26,
    ARM64_REG_X27,
    ARM64_REG_X28,

    ARM64_REG_V0,
    ARM64_REG_V1,
    ARM64_REG_V2,
    ARM64_REG_V3,
    ARM64_REG_V4,
    ARM64_REG_V5,
    ARM64_REG_V6,
    ARM64_REG_V7,
    ARM64_REG_V8,
    ARM64_REG_V9,
    ARM64_REG_V10,
    ARM64_REG_V11,
    ARM64_REG_V12,
    ARM64_REG_V13,
    ARM64_REG_V14,
    ARM64_REG_V15,
    ARM64_REG_V16,
    ARM64_REG_V17,
    ARM64_REG_V18,
    ARM64_REG_V19,
    ARM64_REG_V20,
    ARM64_REG_V21,
    ARM64_REG_V22,
    ARM64_REG_V23,
    ARM64_REG_V24,
    ARM64_REG_V25,
    ARM64_REG_V26,
    ARM64_REG_V27,
    ARM64_REG_V28,
    ARM64_REG_V29,
    ARM64_REG_V30,
    ARM64_REG_V31,

    ARM64_REG_ENDING,       // <-- mark the end of the list of registers

    //> alias registers

    ARM64_REG_IP1 = ARM64_REG_X16,
    ARM64_REG_IP0 = ARM64_REG_X17,
    ARM64_REG_FP = ARM64_REG_X29,
    ARM64_REG_LR = ARM64_REG_X30,
} arm64_reg;

// Instruction's operand referring to memory
// This is associated with ARM64_OP_MEM operand type above
typedef struct arm64_op_mem
{
    arm64_reg base; // base register
    arm64_reg index;    // index register
    int32_t disp;   // displacement/offset value
} arm64_op_mem;

// Instruction operand
typedef struct cs_arm64_op
{
    int vector_index;   // Vector Index for some vector operands (or -1 if irrelevant)
    arm64_vas vas;      // Vector Arrangement Specifier
    arm64_vess vess;    // Vector Element Size Specifier
    struct
    {
        arm64_shifter type; // shifter type of this operand
        unsigned int value; // shifter value of this operand
    } shift;
    arm64_extender ext;     // extender type of this operand
    arm64_op_type type; // operand type
    union
    {
        arm64_reg reg;  // register value for REG operand
        int64_t imm;        // immediate value, or index for C-IMM or IMM operand
        double fp;          // floating point value for FP operand
        arm64_op_mem mem;       // base/index/scale/disp value for MEM operand
        arm64_pstate pstate;        // PState field of MSR instruction.
        unsigned int sys;  // IC/DC/AT/TLBI operation (see arm64_ic_op, arm64_dc_op, arm64_at_op, arm64_tlbi_op)
        arm64_prefetch_op prefetch;  // PRFM operation.
        arm64_barrier_op barrier;  // Memory barrier operation (ISB/DMB/DSB instructions).
    };

    // How is this operand accessed? (READ, WRITE or READ|WRITE)
    // This field is combined of cs_ac_type.
    // NOTE: this field is irrelevant if engine is compiled in DIET mode.
    uint8_t access;
} cs_arm64_op;

// Instruction structure
typedef struct cs_arm64
{
    arm64_cc cc;    // conditional code for this insn
    bool update_flags;  // does this insn update flags?
    bool writeback; // does this insn request writeback? 'True' means 'yes'

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;

    cs_arm64_op operands[8]; // operands for this instruction.
} cs_arm64;

//> ARM64 instruction
typedef enum arm64_insn
{
    ARM64_INS_INVALID = 0,

    ARM64_INS_ABS,
    ARM64_INS_ADC,
    ARM64_INS_ADDHN,
    ARM64_INS_ADDHN2,
    ARM64_INS_ADDP,
    ARM64_INS_ADD,
    ARM64_INS_ADDV,
    ARM64_INS_ADR,
    ARM64_INS_ADRP,
    ARM64_INS_AESD,
    ARM64_INS_AESE,
    ARM64_INS_AESIMC,
    ARM64_INS_AESMC,
    ARM64_INS_AND,
    ARM64_INS_ASR,
    ARM64_INS_B,
    ARM64_INS_BFM,
    ARM64_INS_BIC,
    ARM64_INS_BIF,
    ARM64_INS_BIT,
    ARM64_INS_BL,
    ARM64_INS_BLR,
    ARM64_INS_BR,
    ARM64_INS_BRK,
    ARM64_INS_BSL,
    ARM64_INS_CBNZ,
    ARM64_INS_CBZ,
    ARM64_INS_CCMN,
    ARM64_INS_CCMP,
    ARM64_INS_CLREX,
    ARM64_INS_CLS,
    ARM64_INS_CLZ,
    ARM64_INS_CMEQ,
    ARM64_INS_CMGE,
    ARM64_INS_CMGT,
    ARM64_INS_CMHI,
    ARM64_INS_CMHS,
    ARM64_INS_CMLE,
    ARM64_INS_CMLT,
    ARM64_INS_CMTST,
    ARM64_INS_CNT,
    ARM64_INS_MOV,
    ARM64_INS_CRC32B,
    ARM64_INS_CRC32CB,
    ARM64_INS_CRC32CH,
    ARM64_INS_CRC32CW,
    ARM64_INS_CRC32CX,
    ARM64_INS_CRC32H,
    ARM64_INS_CRC32W,
    ARM64_INS_CRC32X,
    ARM64_INS_CSEL,
    ARM64_INS_CSINC,
    ARM64_INS_CSINV,
    ARM64_INS_CSNEG,
    ARM64_INS_DCPS1,
    ARM64_INS_DCPS2,
    ARM64_INS_DCPS3,
    ARM64_INS_DMB,
    ARM64_INS_DRPS,
    ARM64_INS_DSB,
    ARM64_INS_DUP,
    ARM64_INS_EON,
    ARM64_INS_EOR,
    ARM64_INS_ERET,
    ARM64_INS_EXTR,
    ARM64_INS_EXT,
    ARM64_INS_FABD,
    ARM64_INS_FABS,
    ARM64_INS_FACGE,
    ARM64_INS_FACGT,
    ARM64_INS_FADD,
    ARM64_INS_FADDP,
    ARM64_INS_FCCMP,
    ARM64_INS_FCCMPE,
    ARM64_INS_FCMEQ,
    ARM64_INS_FCMGE,
    ARM64_INS_FCMGT,
    ARM64_INS_FCMLE,
    ARM64_INS_FCMLT,
    ARM64_INS_FCMP,
    ARM64_INS_FCMPE,
    ARM64_INS_FCSEL,
    ARM64_INS_FCVTAS,
    ARM64_INS_FCVTAU,
    ARM64_INS_FCVT,
    ARM64_INS_FCVTL,
    ARM64_INS_FCVTL2,
    ARM64_INS_FCVTMS,
    ARM64_INS_FCVTMU,
    ARM64_INS_FCVTNS,
    ARM64_INS_FCVTNU,
    ARM64_INS_FCVTN,
    ARM64_INS_FCVTN2,
    ARM64_INS_FCVTPS,
    ARM64_INS_FCVTPU,
    ARM64_INS_FCVTXN,
    ARM64_INS_FCVTXN2,
    ARM64_INS_FCVTZS,
    ARM64_INS_FCVTZU,
    ARM64_INS_FDIV,
    ARM64_INS_FMADD,
    ARM64_INS_FMAX,
    ARM64_INS_FMAXNM,
    ARM64_INS_FMAXNMP,
    ARM64_INS_FMAXNMV,
    ARM64_INS_FMAXP,
    ARM64_INS_FMAXV,
    ARM64_INS_FMIN,
    ARM64_INS_FMINNM,
    ARM64_INS_FMINNMP,
    ARM64_INS_FMINNMV,
    ARM64_INS_FMINP,
    ARM64_INS_FMINV,
    ARM64_INS_FMLA,
    ARM64_INS_FMLS,
    ARM64_INS_FMOV,
    ARM64_INS_FMSUB,
    ARM64_INS_FMUL,
    ARM64_INS_FMULX,
    ARM64_INS_FNEG,
    ARM64_INS_FNMADD,
    ARM64_INS_FNMSUB,
    ARM64_INS_FNMUL,
    ARM64_INS_FRECPE,
    ARM64_INS_FRECPS,
    ARM64_INS_FRECPX,
    ARM64_INS_FRINTA,
    ARM64_INS_FRINTI,
    ARM64_INS_FRINTM,
    ARM64_INS_FRINTN,
    ARM64_INS_FRINTP,
    ARM64_INS_FRINTX,
    ARM64_INS_FRINTZ,
    ARM64_INS_FRSQRTE,
    ARM64_INS_FRSQRTS,
    ARM64_INS_FSQRT,
    ARM64_INS_FSUB,
    ARM64_INS_HINT,
    ARM64_INS_HLT,
    ARM64_INS_HVC,
    ARM64_INS_INS,

    ARM64_INS_ISB,
    ARM64_INS_LD1,
    ARM64_INS_LD1R,
    ARM64_INS_LD2R,
    ARM64_INS_LD2,
    ARM64_INS_LD3R,
    ARM64_INS_LD3,
    ARM64_INS_LD4,
    ARM64_INS_LD4R,

    ARM64_INS_LDARB,
    ARM64_INS_LDARH,
    ARM64_INS_LDAR,
    ARM64_INS_LDAXP,
    ARM64_INS_LDAXRB,
    ARM64_INS_LDAXRH,
    ARM64_INS_LDAXR,
    ARM64_INS_LDNP,
    ARM64_INS_LDP,
    ARM64_INS_LDPSW,
    ARM64_INS_LDRB,
    ARM64_INS_LDR,
    ARM64_INS_LDRH,
    ARM64_INS_LDRSB,
    ARM64_INS_LDRSH,
    ARM64_INS_LDRSW,
    ARM64_INS_LDTRB,
    ARM64_INS_LDTRH,
    ARM64_INS_LDTRSB,

    ARM64_INS_LDTRSH,
    ARM64_INS_LDTRSW,
    ARM64_INS_LDTR,
    ARM64_INS_LDURB,
    ARM64_INS_LDUR,
    ARM64_INS_LDURH,
    ARM64_INS_LDURSB,
    ARM64_INS_LDURSH,
    ARM64_INS_LDURSW,
    ARM64_INS_LDXP,
    ARM64_INS_LDXRB,
    ARM64_INS_LDXRH,
    ARM64_INS_LDXR,
    ARM64_INS_LSL,
    ARM64_INS_LSR,
    ARM64_INS_MADD,
    ARM64_INS_MLA,
    ARM64_INS_MLS,
    ARM64_INS_MOVI,
    ARM64_INS_MOVK,
    ARM64_INS_MOVN,
    ARM64_INS_MOVZ,
    ARM64_INS_MRS,
    ARM64_INS_MSR,
    ARM64_INS_MSUB,
    ARM64_INS_MUL,
    ARM64_INS_MVNI,
    ARM64_INS_NEG,
    ARM64_INS_NOT,
    ARM64_INS_ORN,
    ARM64_INS_ORR,
    ARM64_INS_PMULL2,
    ARM64_INS_PMULL,
    ARM64_INS_PMUL,
    ARM64_INS_PRFM,
    ARM64_INS_PRFUM,
    ARM64_INS_RADDHN,
    ARM64_INS_RADDHN2,
    ARM64_INS_RBIT,
    ARM64_INS_RET,
    ARM64_INS_REV16,
    ARM64_INS_REV32,
    ARM64_INS_REV64,
    ARM64_INS_REV,
    ARM64_INS_ROR,
    ARM64_INS_RSHRN2,
    ARM64_INS_RSHRN,
    ARM64_INS_RSUBHN,
    ARM64_INS_RSUBHN2,
    ARM64_INS_SABAL2,
    ARM64_INS_SABAL,

    ARM64_INS_SABA,
    ARM64_INS_SABDL2,
    ARM64_INS_SABDL,
    ARM64_INS_SABD,
    ARM64_INS_SADALP,
    ARM64_INS_SADDLP,
    ARM64_INS_SADDLV,
    ARM64_INS_SADDL2,
    ARM64_INS_SADDL,
    ARM64_INS_SADDW2,
    ARM64_INS_SADDW,
    ARM64_INS_SBC,
    ARM64_INS_SBFM,
    ARM64_INS_SCVTF,
    ARM64_INS_SDIV,
    ARM64_INS_SHA1C,
    ARM64_INS_SHA1H,
    ARM64_INS_SHA1M,
    ARM64_INS_SHA1P,
    ARM64_INS_SHA1SU0,
    ARM64_INS_SHA1SU1,
    ARM64_INS_SHA256H2,
    ARM64_INS_SHA256H,
    ARM64_INS_SHA256SU0,
    ARM64_INS_SHA256SU1,
    ARM64_INS_SHADD,
    ARM64_INS_SHLL2,
    ARM64_INS_SHLL,
    ARM64_INS_SHL,
    ARM64_INS_SHRN2,
    ARM64_INS_SHRN,
    ARM64_INS_SHSUB,
    ARM64_INS_SLI,
    ARM64_INS_SMADDL,
    ARM64_INS_SMAXP,
    ARM64_INS_SMAXV,
    ARM64_INS_SMAX,
    ARM64_INS_SMC,
    ARM64_INS_SMINP,
    ARM64_INS_SMINV,
    ARM64_INS_SMIN,
    ARM64_INS_SMLAL2,
    ARM64_INS_SMLAL,
    ARM64_INS_SMLSL2,
    ARM64_INS_SMLSL,
    ARM64_INS_SMOV,
    ARM64_INS_SMSUBL,
    ARM64_INS_SMULH,
    ARM64_INS_SMULL2,
    ARM64_INS_SMULL,
    ARM64_INS_SQABS,
    ARM64_INS_SQADD,
    ARM64_INS_SQDMLAL,
    ARM64_INS_SQDMLAL2,
    ARM64_INS_SQDMLSL,
    ARM64_INS_SQDMLSL2,
    ARM64_INS_SQDMULH,
    ARM64_INS_SQDMULL,
    ARM64_INS_SQDMULL2,
    ARM64_INS_SQNEG,
    ARM64_INS_SQRDMULH,
    ARM64_INS_SQRSHL,
    ARM64_INS_SQRSHRN,
    ARM64_INS_SQRSHRN2,
    ARM64_INS_SQRSHRUN,
    ARM64_INS_SQRSHRUN2,
    ARM64_INS_SQSHLU,
    ARM64_INS_SQSHL,
    ARM64_INS_SQSHRN,
    ARM64_INS_SQSHRN2,
    ARM64_INS_SQSHRUN,
    ARM64_INS_SQSHRUN2,
    ARM64_INS_SQSUB,
    ARM64_INS_SQXTN2,
    ARM64_INS_SQXTN,
    ARM64_INS_SQXTUN2,
    ARM64_INS_SQXTUN,
    ARM64_INS_SRHADD,
    ARM64_INS_SRI,
    ARM64_INS_SRSHL,
    ARM64_INS_SRSHR,
    ARM64_INS_SRSRA,
    ARM64_INS_SSHLL2,
    ARM64_INS_SSHLL,
    ARM64_INS_SSHL,
    ARM64_INS_SSHR,
    ARM64_INS_SSRA,
    ARM64_INS_SSUBL2,
    ARM64_INS_SSUBL,
    ARM64_INS_SSUBW2,
    ARM64_INS_SSUBW,
    ARM64_INS_ST1,
    ARM64_INS_ST2,
    ARM64_INS_ST3,
    ARM64_INS_ST4,
    ARM64_INS_STLRB,
    ARM64_INS_STLRH,
    ARM64_INS_STLR,
    ARM64_INS_STLXP,
    ARM64_INS_STLXRB,
    ARM64_INS_STLXRH,
    ARM64_INS_STLXR,
    ARM64_INS_STNP,
    ARM64_INS_STP,
    ARM64_INS_STRB,
    ARM64_INS_STR,
    ARM64_INS_STRH,
    ARM64_INS_STTRB,
    ARM64_INS_STTRH,
    ARM64_INS_STTR,
    ARM64_INS_STURB,
    ARM64_INS_STUR,
    ARM64_INS_STURH,
    ARM64_INS_STXP,
    ARM64_INS_STXRB,
    ARM64_INS_STXRH,
    ARM64_INS_STXR,
    ARM64_INS_SUBHN,
    ARM64_INS_SUBHN2,
    ARM64_INS_SUB,
    ARM64_INS_SUQADD,
    ARM64_INS_SVC,
    ARM64_INS_SYSL,
    ARM64_INS_SYS,
    ARM64_INS_TBL,
    ARM64_INS_TBNZ,
    ARM64_INS_TBX,
    ARM64_INS_TBZ,
    ARM64_INS_TRN1,
    ARM64_INS_TRN2,
    ARM64_INS_UABAL2,
    ARM64_INS_UABAL,
    ARM64_INS_UABA,
    ARM64_INS_UABDL2,
    ARM64_INS_UABDL,
    ARM64_INS_UABD,
    ARM64_INS_UADALP,
    ARM64_INS_UADDLP,
    ARM64_INS_UADDLV,
    ARM64_INS_UADDL2,
    ARM64_INS_UADDL,
    ARM64_INS_UADDW2,
    ARM64_INS_UADDW,
    ARM64_INS_UBFM,
    ARM64_INS_UCVTF,
    ARM64_INS_UDIV,
    ARM64_INS_UHADD,
    ARM64_INS_UHSUB,
    ARM64_INS_UMADDL,
    ARM64_INS_UMAXP,
    ARM64_INS_UMAXV,
    ARM64_INS_UMAX,
    ARM64_INS_UMINP,
    ARM64_INS_UMINV,
    ARM64_INS_UMIN,
    ARM64_INS_UMLAL2,
    ARM64_INS_UMLAL,
    ARM64_INS_UMLSL2,
    ARM64_INS_UMLSL,
    ARM64_INS_UMOV,
    ARM64_INS_UMSUBL,
    ARM64_INS_UMULH,
    ARM64_INS_UMULL2,
    ARM64_INS_UMULL,
    ARM64_INS_UQADD,
    ARM64_INS_UQRSHL,
    ARM64_INS_UQRSHRN,
    ARM64_INS_UQRSHRN2,
    ARM64_INS_UQSHL,
    ARM64_INS_UQSHRN,
    ARM64_INS_UQSHRN2,
    ARM64_INS_UQSUB,
    ARM64_INS_UQXTN2,
    ARM64_INS_UQXTN,
    ARM64_INS_URECPE,
    ARM64_INS_URHADD,
    ARM64_INS_URSHL,
    ARM64_INS_URSHR,
    ARM64_INS_URSQRTE,
    ARM64_INS_URSRA,
    ARM64_INS_USHLL2,
    ARM64_INS_USHLL,
    ARM64_INS_USHL,
    ARM64_INS_USHR,
    ARM64_INS_USQADD,
    ARM64_INS_USRA,
    ARM64_INS_USUBL2,
    ARM64_INS_USUBL,
    ARM64_INS_USUBW2,
    ARM64_INS_USUBW,
    ARM64_INS_UZP1,
    ARM64_INS_UZP2,
    ARM64_INS_XTN2,
    ARM64_INS_XTN,
    ARM64_INS_ZIP1,
    ARM64_INS_ZIP2,

    // alias insn
    ARM64_INS_MNEG,
    ARM64_INS_UMNEGL,
    ARM64_INS_SMNEGL,
    ARM64_INS_NOP,
    ARM64_INS_YIELD,
    ARM64_INS_WFE,
    ARM64_INS_WFI,
    ARM64_INS_SEV,
    ARM64_INS_SEVL,
    ARM64_INS_NGC,
    ARM64_INS_SBFIZ,
    ARM64_INS_UBFIZ,
    ARM64_INS_SBFX,
    ARM64_INS_UBFX,
    ARM64_INS_BFI,
    ARM64_INS_BFXIL,
    ARM64_INS_CMN,
    ARM64_INS_MVN,
    ARM64_INS_TST,
    ARM64_INS_CSET,
    ARM64_INS_CINC,
    ARM64_INS_CSETM,
    ARM64_INS_CINV,
    ARM64_INS_CNEG,
    ARM64_INS_SXTB,
    ARM64_INS_SXTH,
    ARM64_INS_SXTW,
    ARM64_INS_CMP,
    ARM64_INS_UXTB,
    ARM64_INS_UXTH,
    ARM64_INS_UXTW,
    ARM64_INS_IC,
    ARM64_INS_DC,
    ARM64_INS_AT,
    ARM64_INS_TLBI,

    ARM64_INS_NEGS,
    ARM64_INS_NGCS,

    ARM64_INS_ENDING,  // <-- mark the end of the list of insn
} arm64_insn;

//> Group of ARM64 instructions
typedef enum arm64_insn_group
{
    ARM64_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    ARM64_GRP_JUMP, // = CS_GRP_JUMP
    ARM64_GRP_CALL,
    ARM64_GRP_RET,
    ARM64_GRP_INT,
    ARM64_GRP_PRIVILEGE = 6, // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    ARM64_GRP_CRYPTO = 128,
    ARM64_GRP_FPARMV8,
    ARM64_GRP_NEON,
    ARM64_GRP_CRC,

    ARM64_GRP_ENDING,  // <-- mark the end of the list of groups
} arm64_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/capstone.h`:

```h
#ifndef CAPSTONE_ENGINE_H
#define CAPSTONE_ENGINE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2016 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

#if defined(CAPSTONE_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#pragma warning(disable:4100)
#define CAPSTONE_API __cdecl
#ifdef CAPSTONE_SHARED
#define CAPSTONE_EXPORT __declspec(dllexport)
#else    // defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT
#endif
#else
#define CAPSTONE_API
#ifdef __GNUC__
#define CAPSTONE_EXPORT __attribute__((visibility("default")))
#else
#define CAPSTONE_EXPORT
#endif
#endif

#ifdef __GNUC__
#define CAPSTONE_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define CAPSTONE_DEPRECATED __declspec(deprecated)
#else
#pragma message("WARNING: You need to implement CAPSTONE_DEPRECATED for this compiler")
#define CAPSTONE_DEPRECATED
#endif

// Capstone API version
#define CS_API_MAJOR 4
#define CS_API_MINOR 0

// Version for bleeding edge code of the Github's "next" branch.
// Use this if you want the absolutely latest developement code.
// This version number will be bumped up whenever we have a new major change.
#define CS_NEXT_VERSION 4

// Capstone package version
#define CS_VERSION_MAJOR CS_API_MAJOR
#define CS_VERSION_MINOR CS_API_MINOR
#define CS_VERSION_EXTRA 0

// Macro to create combined version which can be compared to
// result of cs_version() API.
#define CS_MAKE_VERSION(major, minor) ((major << 8) + minor)

// Maximum size of an instruction mnemonic string.
#define CS_MNEMONIC_SIZE 32

// Handle using with all API
typedef size_t csh;

// Architecture type
typedef enum cs_arch
{
    CS_ARCH_ARM = 0,    // ARM architecture (including Thumb, Thumb-2)
    CS_ARCH_ARM64,      // ARM-64, also called AArch64
    CS_ARCH_MIPS,       // Mips architecture
    CS_ARCH_X86,        // X86 architecture (including x86 & x86-64)
    CS_ARCH_PPC,        // PowerPC architecture
    CS_ARCH_SPARC,      // Sparc architecture
    CS_ARCH_SYSZ,       // SystemZ architecture
    CS_ARCH_XCORE,      // XCore architecture
    CS_ARCH_M68K,       // 68K architecture
    CS_ARCH_MAX,
    CS_ARCH_ALL = 0xFFFF, // All architectures - for cs_support()
} cs_arch;

// Support value to verify diet mode of the engine.
// If cs_support(CS_SUPPORT_DIET) return True, the engine was compiled
// in diet mode.
#define CS_SUPPORT_DIET (CS_ARCH_ALL + 1)

// Support value to verify X86 reduce mode of the engine.
// If cs_support(CS_SUPPORT_X86_REDUCE) return True, the engine was compiled
// in X86 reduce mode.
#define CS_SUPPORT_X86_REDUCE (CS_ARCH_ALL + 2)

// Mode type
typedef enum cs_mode
{
    CS_MODE_LITTLE_ENDIAN = 0,  // little-endian mode (default mode)
    CS_MODE_ARM = 0,    // 32-bit ARM
    CS_MODE_16 = 1 << 1,    // 16-bit mode (X86)
    CS_MODE_32 = 1 << 2,    // 32-bit mode (X86)
    CS_MODE_64 = 1 << 3,    // 64-bit mode (X86, PPC)
    CS_MODE_THUMB = 1 << 4, // ARM's Thumb mode, including Thumb-2
    CS_MODE_MCLASS = 1 << 5,    // ARM's Cortex-M series
    CS_MODE_V8 = 1 << 6,    // ARMv8 A32 encodings for ARM
    CS_MODE_MICRO = 1 << 4, // MicroMips mode (MIPS)
    CS_MODE_MIPS3 = 1 << 5, // Mips III ISA
    CS_MODE_MIPS32R6 = 1 << 6, // Mips32r6 ISA
    CS_MODE_V9 = 1 << 4, // SparcV9 mode (Sparc)
    CS_MODE_QPX = 1 << 4, // Quad Processing eXtensions mode (PPC)
    CS_MODE_M68K_000 = 1 << 1, // M68K 68000 mode
    CS_MODE_M68K_010 = 1 << 2, // M68K 68010 mode
    CS_MODE_M68K_020 = 1 << 3, // M68K 68020 mode
    CS_MODE_M68K_030 = 1 << 4, // M68K 68030 mode
    CS_MODE_M68K_040 = 1 << 5, // M68K 68040 mode
    CS_MODE_M68K_060 = 1 << 6, // M68K 68060 mode
    CS_MODE_BIG_ENDIAN = 1 << 31,   // big-endian mode
    CS_MODE_MIPS32 = CS_MODE_32,    // Mips32 ISA (Mips)
    CS_MODE_MIPS64 = CS_MODE_64,    // Mips64 ISA (Mips)
} cs_mode;

typedef void* (CAPSTONE_API* cs_malloc_t)(size_t size);
typedef void* (CAPSTONE_API* cs_calloc_t)(size_t nmemb, size_t size);
typedef void* (CAPSTONE_API* cs_realloc_t)(void* ptr, size_t size);
typedef void (CAPSTONE_API* cs_free_t)(void* ptr);
typedef int (CAPSTONE_API* cs_vsnprintf_t)(char* str, size_t size, const char* format, va_list ap);


// User-defined dynamic memory related functions: malloc/calloc/realloc/free/vsnprintf()
// By default, Capstone uses system's malloc(), calloc(), realloc(), free() & vsnprintf().
typedef struct cs_opt_mem
{
    cs_malloc_t malloc;
    cs_calloc_t calloc;
    cs_realloc_t realloc;
    cs_free_t free;
    cs_vsnprintf_t vsnprintf;
} cs_opt_mem;

// Customize mnemonic for instructions with alternative name.
// To reset existing customized instruction to its default mnemonic,
// call cs_option(CS_OPT_MNEMONIC) again with the same @id and NULL value
// for @mnemonic.
typedef struct cs_opt_mnem
{
    // ID of instruction to be customized.
    unsigned int id;
    // Customized instruction mnemonic.
    const char* mnemonic;
} cs_opt_mnem;

// Runtime option for the disassembled engine
typedef enum cs_opt_type
{
    CS_OPT_INVALID = 0, // No option specified
    CS_OPT_SYNTAX,  // Assembly output syntax
    CS_OPT_DETAIL,  // Break down instruction structure into details
    CS_OPT_MODE,    // Change engine's mode at run-time
    CS_OPT_MEM, // User-defined dynamic memory related functions
    CS_OPT_SKIPDATA, // Skip data when disassembling. Then engine is in SKIPDATA mode.
    CS_OPT_SKIPDATA_SETUP, // Setup user-defined function for SKIPDATA option
    CS_OPT_MNEMONIC, // Customize instruction mnemonic
    CS_OPT_UNSIGNED, // print immediate operands in unsigned form
} cs_opt_type;

// Runtime option value (associated with option type above)
typedef enum cs_opt_value
{
    CS_OPT_OFF = 0,  // Turn OFF an option - default for CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.
    CS_OPT_ON = 3, // Turn ON an option (CS_OPT_DETAIL, CS_OPT_SKIPDATA).
    CS_OPT_SYNTAX_DEFAULT = 0, // Default asm syntax (CS_OPT_SYNTAX).
    CS_OPT_SYNTAX_INTEL, // X86 Intel asm syntax - default on X86 (CS_OPT_SYNTAX).
    CS_OPT_SYNTAX_ATT,   // X86 ATT asm syntax (CS_OPT_SYNTAX).
    CS_OPT_SYNTAX_NOREGNAME, // Prints register name with only number (CS_OPT_SYNTAX)
    CS_OPT_SYNTAX_MASM, // X86 Intel Masm syntax (CS_OPT_SYNTAX).
} cs_opt_value;

//> Common instruction operand types - to be consistent across all architectures.
typedef enum cs_op_type
{
    CS_OP_INVALID = 0,  // uninitialized/invalid operand.
    CS_OP_REG,          // Register operand.
    CS_OP_IMM,          // Immediate operand.
    CS_OP_MEM,          // Memory operand.
    CS_OP_FP,           // Floating-Point operand.
} cs_op_type;

//> Common instruction operand access types - to be consistent across all architectures.
//> It is possible to combine access types, for example: CS_AC_READ | CS_AC_WRITE
typedef enum cs_ac_type
{
    CS_AC_INVALID = 0,        // Uninitialized/invalid access type.
    CS_AC_READ    = 1 << 0,   // Operand read from memory or register.
    CS_AC_WRITE   = 1 << 1,   // Operand write to memory or register.
} cs_ac_type;

//> Common instruction groups - to be consistent across all architectures.
typedef enum cs_group_type
{
    CS_GRP_INVALID = 0,  // uninitialized/invalid group.
    CS_GRP_JUMP,    // all jump instructions (conditional+direct+indirect jumps)
    CS_GRP_CALL,    // all call instructions
    CS_GRP_RET,     // all return instructions
    CS_GRP_INT,     // all interrupt instructions (int+syscall)
    CS_GRP_IRET,    // all interrupt return instructions
    CS_GRP_PRIVILEGE,    // all privileged instructions
} cs_group_type;

/*
 User-defined callback function for SKIPDATA option.
 See tests/test_skipdata.c for sample code demonstrating this API.

 @code: the input buffer containing code to be disassembled.
        This is the same buffer passed to cs_disasm().
 @code_size: size (in bytes) of the above @code buffer.
 @offset: the position of the currently-examining byte in the input
      buffer @code mentioned above.
 @user_data: user-data passed to cs_option() via @user_data field in
      cs_opt_skipdata struct below.

 @return: return number of bytes to skip, or 0 to immediately stop disassembling.
*/
typedef size_t (CAPSTONE_API* cs_skipdata_cb_t)(const uint8_t* code, size_t code_size, size_t offset, void* user_data);

// User-customized setup for SKIPDATA option
typedef struct cs_opt_skipdata
{
    // Capstone considers data to skip as special "instructions".
    // User can specify the string for this instruction's "mnemonic" here.
    // By default (if @mnemonic is NULL), Capstone use ".byte".
    const char* mnemonic;

    // User-defined callback function to be called when Capstone hits data.
    // If the returned value from this callback is positive (>0), Capstone
    // will skip exactly that number of bytes & continue. Otherwise, if
    // the callback returns 0, Capstone stops disassembling and returns
    // immediately from cs_disasm()
    // NOTE: if this callback pointer is NULL, Capstone would skip a number
    // of bytes depending on architectures, as following:
    // Arm:     2 bytes (Thumb mode) or 4 bytes.
    // Arm64:   4 bytes.
    // Mips:    4 bytes.
    // PowerPC: 4 bytes.
    // Sparc:   4 bytes.
    // SystemZ: 2 bytes.
    // X86:     1 bytes.
    // XCore:   2 bytes.
    cs_skipdata_cb_t callback;  // default value is NULL

    // User-defined data to be passed to @callback function pointer.
    void* user_data;
} cs_opt_skipdata;


#include "arm.h"
#include "arm64.h"
#include "m68k.h"
#include "mips.h"
#include "ppc.h"
#include "sparc.h"
#include "systemz.h"
#include "x86.h"
#include "xcore.h"

// NOTE: All information in cs_detail is only available when CS_OPT_DETAIL = CS_OPT_ON
typedef struct cs_detail
{
    uint16_t regs_read[12]; // list of implicit registers read by this insn
    uint8_t regs_read_count; // number of implicit registers read by this insn

    uint16_t regs_write[20]; // list of implicit registers modified by this insn
    uint8_t regs_write_count; // number of implicit registers modified by this insn

    uint8_t groups[8]; // list of group this instruction belong to
    uint8_t groups_count; // number of groups this insn belongs to

    // Architecture-specific instruction info
    union
    {
        cs_x86 x86; // X86 architecture, including 16-bit, 32-bit & 64-bit mode
        cs_arm64 arm64; // ARM64 architecture (aka AArch64)
        cs_arm arm;     // ARM architecture (including Thumb/Thumb2)
        cs_m68k m68k;   // M68K architecture
        cs_mips mips;   // MIPS architecture
        cs_ppc ppc; // PowerPC architecture
        cs_sparc sparc; // Sparc architecture
        cs_sysz sysz;   // SystemZ architecture
        cs_xcore xcore; // XCore architecture
    };
} cs_detail;

// Detail information of disassembled instruction
typedef struct cs_insn
{
    // Instruction ID (basically a numeric ID for the instruction mnemonic)
    // Find the instruction id in the '[ARCH]_insn' enum in the header file
    // of corresponding architecture, such as 'arm_insn' in arm.h for ARM,
    // 'x86_insn' in x86.h for X86, etc...
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    // NOTE: in Skipdata mode, "data" instruction has 0 for this id field.
    unsigned int id;

    // Address (EIP) of this instruction
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    uint64_t address;

    // Size of this instruction
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    uint16_t size;

    // Machine bytes of this instruction, with number of bytes indicated by @size above
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    uint8_t bytes[16];

    // Ascii text of instruction mnemonic
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    char mnemonic[CS_MNEMONIC_SIZE];

    // Ascii text of instruction operands
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    char op_str[160];

    // Pointer to cs_detail.
    // NOTE: detail pointer is only valid when both requirements below are met:
    // (1) CS_OP_DETAIL = CS_OPT_ON
    // (2) Engine is not in Skipdata mode (CS_OP_SKIPDATA option set to CS_OPT_ON)
    //
    // NOTE 2: when in Skipdata mode, or when detail mode is OFF, even if this pointer
    //     is not NULL, its content is still irrelevant.
    cs_detail* detail;
} cs_insn;


// Calculate the offset of a disassembled instruction in its buffer, given its position
// in its array of disassembled insn
// NOTE: this macro works with position (>=1), not index
#define CS_INSN_OFFSET(insns, post) (insns[post - 1].address - insns[0].address)


// All type of errors encountered by Capstone API.
// These are values returned by cs_errno()
typedef enum cs_err
{
    CS_ERR_OK = 0,   // No error: everything was fine
    CS_ERR_MEM,      // Out-Of-Memory error: cs_open(), cs_disasm(), cs_disasm_iter()
    CS_ERR_ARCH,     // Unsupported architecture: cs_open()
    CS_ERR_HANDLE,   // Invalid handle: cs_op_count(), cs_op_index()
    CS_ERR_CSH,      // Invalid csh argument: cs_close(), cs_errno(), cs_option()
    CS_ERR_MODE,     // Invalid/unsupported mode: cs_open()
    CS_ERR_OPTION,   // Invalid/unsupported option: cs_option()
    CS_ERR_DETAIL,   // Information is unavailable because detail option is OFF
    CS_ERR_MEMSETUP, // Dynamic memory management uninitialized (see CS_OPT_MEM)
    CS_ERR_VERSION,  // Unsupported version (bindings)
    CS_ERR_DIET,     // Access irrelevant data in "diet" engine
    CS_ERR_SKIPDATA, // Access irrelevant data for "data" instruction in SKIPDATA mode
    CS_ERR_X86_ATT,  // X86 AT&T syntax is unsupported (opt-out at compile time)
    CS_ERR_X86_INTEL, // X86 Intel syntax is unsupported (opt-out at compile time)
    CS_ERR_X86_MASM, // X86 Intel syntax is unsupported (opt-out at compile time)
} cs_err;

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
     major & minor versions.
     NOTE: This returned value can be compared with version number made
     with macro CS_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
CAPSTONE_EXPORT
unsigned int CAPSTONE_API cs_version(int* major, int* minor);


/*
 This API can be used to either ask for archs supported by this library,
 or check to see if the library was compile with 'diet' option (or called
 in 'diet' mode).

 To check if a particular arch is supported by this library, set @query to
 arch mode (CS_ARCH_* value).
 To verify if this library supports all the archs, use CS_ARCH_ALL.

 To check if this library is in 'diet' mode, set @query to CS_SUPPORT_DIET.

 @return True if this library supports the given arch, or in 'diet' mode.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_support(int query);

/*
 Initialize CS handle: this must be done before any usage of CS.

 @arch: architecture type (CS_ARCH_*)
 @mode: hardware mode. This is combined of CS_MODE_*
 @handle: pointer to handle, which will be updated at return time

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh* handle);

/*
 Close CS handle: MUST do to release the handle when it is not used anymore.
 NOTE: this must be only called when there is no longer usage of Capstone,
 not even access to cs_insn array. The reason is the this API releases some
 cached memory, thus access to any Capstone API after cs_close() might crash
 your application.

 In fact,this API invalidate @handle by ZERO out its value (i.e *handle = 0).

 @handle: pointer to a handle returned by cs_open()

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_close(csh* handle);

/*
 Set option for disassembling engine at runtime

 @handle: handle returned by cs_open()
 @type: type of option to be set
 @value: option value corresponding with @type

 @return: CS_ERR_OK on success, or other value on failure.
 Refer to cs_err enum for detailed error.

 NOTE: in the case of CS_OPT_MEM, handle's value can be anything,
 so that cs_option(handle, CS_OPT_MEM, value) can (i.e must) be called
 even before cs_open()
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_option(csh handle, cs_opt_type type, size_t value);

/*
 Report the last error number when some API function fail.
 Like glibc's errno, cs_errno might not retain its old value once accessed.

 @handle: handle returned by cs_open()

 @return: error code of cs_err enum type (CS_ERR_*, see above)
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_errno(csh handle);


/*
 Return a string describing given error code.

 @code: error code (see CS_ERR_* above)

 @return: returns a pointer to a string that describes the error code
    passed in the argument @code
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_strerror(cs_err code);

/*
 Disassemble binary code, given the code buffer, size, address and number
 of instructions to be decoded.
 This API dynamically allocate memory to contain disassembled instruction.
 Resulted instructions will be put into @*insn

 NOTE 1: this API will automatically determine memory needed to contain
 output disassembled instructions in @insn.

 NOTE 2: caller must free the allocated memory itself to avoid memory leaking.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, the API cs_disasm_iter() might be a better choice than
 cs_disasm(). The reason is that with cs_disasm(), based on limited available
 memory, we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case @count=0,
 when cs_disasm() runs uncontrollably (until either end of input buffer, or
 when it encounters an invalid instruction).

 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled.
 @code_size: size of the above code buffer.
 @address: address of the first instruction in given raw code buffer.
 @insn: array of instructions filled in by this API.
       NOTE: @insn will be allocated by this function, and should be freed
       with cs_free() API.
 @count: number of instructions to be disassembled, or 0 to get all of them

 @return: the number of successfully disassembled instructions,
 or 0 if this function failed to disassemble the given code

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
size_t CAPSTONE_API cs_disasm(csh handle,
                              const uint8_t* code, size_t code_size,
                              uint64_t address,
                              size_t count,
                              cs_insn** insn);

/*
  Deprecated function - to be retired in the next version!
  Use cs_disasm() instead of cs_disasm_ex()
*/
CAPSTONE_EXPORT
CAPSTONE_DEPRECATED
size_t CAPSTONE_API cs_disasm_ex(csh handle,
                                 const uint8_t* code, size_t code_size,
                                 uint64_t address,
                                 size_t count,
                                 cs_insn** insn);

/*
 Free memory allocated by cs_malloc() or cs_disasm() (argument @insn)

 @insn: pointer returned by @insn argument in cs_disasm() or cs_malloc()
 @count: number of cs_insn structures returned by cs_disasm(), or 1
     to free memory allocated by cs_malloc().
*/
CAPSTONE_EXPORT
void CAPSTONE_API cs_free(cs_insn* insn, size_t count);


/*
 Allocate memory for 1 instruction to be used by cs_disasm_iter().

 @handle: handle returned by cs_open()

 NOTE: when no longer in use, you can reclaim the memory allocated for
 this instruction with cs_free(insn, 1)
*/
CAPSTONE_EXPORT
cs_insn* CAPSTONE_API cs_malloc(csh handle);

/*
 Fast API to disassemble binary code, given the code buffer, size, address
 and number of instructions to be decoded.
 This API put the resulted instruction into a given cache in @insn.
 See tests/test_iter.c for sample code demonstrating this API.

 NOTE 1: this API will update @code, @size & @address to point to the next
 instruction in the input buffer. Therefore, it is convenient to use
 cs_disasm_iter() inside a loop to quickly iterate all the instructions.
 While decoding one instruction at a time can also be achieved with
 cs_disasm(count=1), some benchmarks shown that cs_disasm_iter() can be 30%
 faster on random input.

 NOTE 2: the cache in @insn can be created with cs_malloc() API.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, this API is recommended over cs_disasm(), which
 allocates memory based on the number of instructions to be disassembled.
 The reason is that with cs_disasm(), based on limited available memory,
 we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case
 @count=0, when cs_disasm() runs uncontrollably (until either end of input
 buffer, or when it encounters an invalid instruction).

 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled
 @code_size: size of above code
 @address: address of the first insn in given raw code buffer
 @insn: pointer to instruction to be filled in by this API.

 @return: true if this API successfully decode 1 instruction,
 or false otherwise.

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_disasm_iter(csh handle,
                                 const uint8_t** code, size_t* size,
                                 uint64_t* address, cs_insn* insn);

/*
 Return friendly name of register in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM,
 x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store register name.

 @handle: handle returned by cs_open()
 @reg_id: register id

 @return: string name of the register, or NULL if @reg_id is invalid.
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_reg_name(csh handle, unsigned int reg_id);

/*
 Return friendly name of an instruction in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store instruction name.

 @handle: handle returned by cs_open()
 @insn_id: instruction id

 @return: string name of the instruction, or NULL if @insn_id is invalid.
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_insn_name(csh handle, unsigned int insn_id);

/*
 Return friendly name of a group id (that an instruction can belong to)
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store group name.

 @handle: handle returned by cs_open()
 @group_id: group id

 @return: string name of the group, or NULL if @group_id is invalid.
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_group_name(csh handle, unsigned int group_id);

/*
 Check if a disassembled instruction belong to a particular group.
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @group_id matches any member of insn->groups array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default).

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @groups array.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @group_id: group that you want to check if this instruction belong to.

 @return: true if this instruction indeed belongs to aboved group, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_insn_group(csh handle, const cs_insn* insn, unsigned int group_id);

/*
 Check if a disassembled instruction IMPLICITLY used a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_read array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_read array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction used it.

 @return: true if this instruction indeed implicitly used aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_read(csh handle, const cs_insn* insn, unsigned int reg_id);

/*
 Check if a disassembled instruction IMPLICITLY modified a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_write array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_write array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction modified it.

 @return: true if this instruction indeed implicitly modified aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_write(csh handle, const cs_insn* insn, unsigned int reg_id);

/*
 Count the number of operands of a given type.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.

 @return: number of operands of given type @op_type in instruction @insn,
 or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_count(csh handle, const cs_insn* insn, unsigned int op_type);

/*
 Retrieve the position of operand of given type in <arch>.operands[] array.
 Later, the operand can be accessed using the returned position.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.
 @position: position of the operand to be found. This must be in the range
            [1, cs_op_count(handle, insn, op_type)]

 @return: index of operand of given type @op_type in <arch>.operands[] array
 in instruction @insn, or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_index(csh handle, const cs_insn* insn, unsigned int op_type,
                             unsigned int position);

// Type of array to keep the list of registers
typedef uint16_t cs_regs[64];

/*
 Retrieve all the registers accessed by an instruction, either explicitly or
 implicitly.

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store registers.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure returned from cs_disasm() or cs_disasm_iter()
 @regs_read: on return, this array contains all registers read by instruction.
 @regs_read_count: number of registers kept inside @regs_read array.
 @regs_write: on return, this array contains all registers written by instruction.
 @regs_write_count: number of registers kept inside @regs_write array.

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_regs_access(csh handle, const cs_insn* insn,
                                   cs_regs regs_read, uint8_t* regs_read_count,
                                   cs_regs regs_write, uint8_t* regs_write_count);

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/m68k.h`:

```h
#ifndef CAPSTONE_M68K_H
#define CAPSTONE_M68K_H

/* Capstone Disassembly Engine */
/* By Daniel Collin <daniel@collin.com>, 2015-2016 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

#define M68K_OPERAND_COUNT 4

//> M68K registers and special registers
typedef enum m68k_reg
{
    M68K_REG_INVALID = 0,

    M68K_REG_D0,
    M68K_REG_D1,
    M68K_REG_D2,
    M68K_REG_D3,
    M68K_REG_D4,
    M68K_REG_D5,
    M68K_REG_D6,
    M68K_REG_D7,

    M68K_REG_A0,
    M68K_REG_A1,
    M68K_REG_A2,
    M68K_REG_A3,
    M68K_REG_A4,
    M68K_REG_A5,
    M68K_REG_A6,
    M68K_REG_A7,

    M68K_REG_FP0,
    M68K_REG_FP1,
    M68K_REG_FP2,
    M68K_REG_FP3,
    M68K_REG_FP4,
    M68K_REG_FP5,
    M68K_REG_FP6,
    M68K_REG_FP7,

    M68K_REG_PC,

    M68K_REG_SR,
    M68K_REG_CCR,
    M68K_REG_SFC,
    M68K_REG_DFC,
    M68K_REG_USP,
    M68K_REG_VBR,
    M68K_REG_CACR,
    M68K_REG_CAAR,
    M68K_REG_MSP,
    M68K_REG_ISP,
    M68K_REG_TC,
    M68K_REG_ITT0,
    M68K_REG_ITT1,
    M68K_REG_DTT0,
    M68K_REG_DTT1,
    M68K_REG_MMUSR,
    M68K_REG_URP,
    M68K_REG_SRP,

    M68K_REG_FPCR,
    M68K_REG_FPSR,
    M68K_REG_FPIAR,

    M68K_REG_ENDING,   // <-- mark the end of the list of registers
} m68k_reg;

//> M68K Addressing Modes
typedef enum m68k_address_mode
{
    M68K_AM_NONE = 0,           // No address mode.

    M68K_AM_REG_DIRECT_DATA,        // Register Direct - Data
    M68K_AM_REG_DIRECT_ADDR,        // Register Direct - Address

    M68K_AM_REGI_ADDR,              // Register Indirect - Address
    M68K_AM_REGI_ADDR_POST_INC,     // Register Indirect - Address with Postincrement
    M68K_AM_REGI_ADDR_PRE_DEC,      // Register Indirect - Address with Predecrement
    M68K_AM_REGI_ADDR_DISP,         // Register Indirect - Address with Displacement

    M68K_AM_AREGI_INDEX_8_BIT_DISP, // Address Register Indirect With Index- 8-bit displacement
    M68K_AM_AREGI_INDEX_BASE_DISP,  // Address Register Indirect With Index- Base displacement

    M68K_AM_MEMI_POST_INDEX,        // Memory indirect - Postindex
    M68K_AM_MEMI_PRE_INDEX,         // Memory indirect - Preindex

    M68K_AM_PCI_DISP,               // Program Counter Indirect - with Displacement

    M68K_AM_PCI_INDEX_8_BIT_DISP,   // Program Counter Indirect with Index - with 8-Bit Displacement
    M68K_AM_PCI_INDEX_BASE_DISP,    // Program Counter Indirect with Index - with Base Displacement

    M68K_AM_PC_MEMI_POST_INDEX,     // Program Counter Memory Indirect - Postindexed
    M68K_AM_PC_MEMI_PRE_INDEX,      // Program Counter Memory Indirect - Preindexed

    M68K_AM_ABSOLUTE_DATA_SHORT,    // Absolute Data Addressing  - Short
    M68K_AM_ABSOLUTE_DATA_LONG,     // Absolute Data Addressing  - Long
    M68K_AM_IMMEDIATE,              // Immediate value
} m68k_address_mode;

//> Operand type for instruction's operands
typedef enum m68k_op_type
{
    M68K_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    M68K_OP_REG,         // = CS_OP_REG (Register operand).
    M68K_OP_IMM,         // = CS_OP_IMM (Immediate operand).
    M68K_OP_MEM,         // = CS_OP_MEM (Memory operand).
    M68K_OP_FP_SINGLE,   // single precision Floating-Point operand
    M68K_OP_FP_DOUBLE,   // double precision Floating-Point operand
    M68K_OP_REG_BITS,    // Register bits move
    M68K_OP_REG_PAIR,    // Register pair in the same op (upper 4 bits for first reg, lower for second)
} m68k_op_type;

// Instruction's operand referring to memory
// This is associated with M68K_OP_MEM operand type above
typedef struct m68k_op_mem
{
    m68k_reg base_reg;      // base register (or M68K_REG_INVALID if irrelevant)
    m68k_reg index_reg;     // index register (or M68K_REG_INVALID if irrelevant)
    m68k_reg in_base_reg;   // indirect base register (or M68K_REG_INVALID if irrelevant)
    uint32_t in_disp;       // indirect displacement
    uint32_t out_disp;      // other displacement
    int16_t disp;           // displacement value
    uint8_t scale;          // scale for index register
    uint8_t bitfield;       // set to true if the two values below should be used
    uint8_t width;          // used for bf* instructions
    uint8_t offset;         // used for bf* instructions
    uint8_t index_size;     // 0 = w, 1 = l
} m68k_op_mem;

// Instruction operand
typedef struct cs_m68k_op
{
    union
    {
        uint64_t imm;               // immediate value for IMM operand
        double dimm;            // double imm
        float simm;             // float imm
        m68k_reg reg;           // register value for REG operand
        struct              // register pair in one operand
        {
            m68k_reg reg_0;
            m68k_reg reg_1;
        } reg_pair;
        m68k_op_mem mem;        // data when operand is targeting memory
        uint32_t register_bits; // register bits for movem etc. (always in d0-d7, a0-a7, fp0 - fp7 order)
    };
    m68k_op_type type;
    m68k_address_mode address_mode; // M68K addressing mode for this op
} cs_m68k_op;

// Operation size of the CPU instructions
typedef enum m68k_cpu_size
{
    M68K_CPU_SIZE_NONE = 0,     // unsized or unspecified
    M68K_CPU_SIZE_BYTE = 1,     // 1 byte in size
    M68K_CPU_SIZE_WORD = 2,     // 2 bytes in size
    M68K_CPU_SIZE_LONG = 4,     // 4 bytes in size
} m68k_cpu_size;

// Operation size of the FPU instructions (Notice that FPU instruction can also use CPU sizes if needed)
typedef enum m68k_fpu_size
{
    M68K_FPU_SIZE_NONE = 0,     // unsized like fsave/frestore
    M68K_FPU_SIZE_SINGLE = 4,       // 4 byte in size (single float)
    M68K_FPU_SIZE_DOUBLE = 8,       // 8 byte in size (double)
    M68K_FPU_SIZE_EXTENDED = 12,    // 12 byte in size (extended real format)
} m68k_fpu_size;

// Type of size that is being used for the current instruction
typedef enum m68k_size_type
{
    M68K_SIZE_TYPE_INVALID = 0,

    M68K_SIZE_TYPE_CPU,
    M68K_SIZE_TYPE_FPU,
} m68k_size_type;

// Operation size of the current instruction (NOT the actually size of instruction)
typedef struct m68k_op_size
{
    m68k_size_type type;
    union
    {
        m68k_cpu_size cpu_size;
        m68k_fpu_size fpu_size;
    };
} m68k_op_size;

// The M68K instruction and it's operands
typedef struct cs_m68k
{
    // Number of operands of this instruction or 0 when instruction has no operand.
    cs_m68k_op operands[M68K_OPERAND_COUNT]; // operands for this instruction.
    m68k_op_size op_size;   // size of data operand works on in bytes (.b, .w, .l, etc)
    uint8_t op_count; // number of operands for the instruction
} cs_m68k;

//> M68K instruction
typedef enum m68k_insn
{
    M68K_INS_INVALID = 0,

    M68K_INS_ABCD,
    M68K_INS_ADD,
    M68K_INS_ADDA,
    M68K_INS_ADDI,
    M68K_INS_ADDQ,
    M68K_INS_ADDX,
    M68K_INS_AND,
    M68K_INS_ANDI,
    M68K_INS_ASL,
    M68K_INS_ASR,
    M68K_INS_BHS,
    M68K_INS_BLO,
    M68K_INS_BHI,
    M68K_INS_BLS,
    M68K_INS_BCC,
    M68K_INS_BCS,
    M68K_INS_BNE,
    M68K_INS_BEQ,
    M68K_INS_BVC,
    M68K_INS_BVS,
    M68K_INS_BPL,
    M68K_INS_BMI,
    M68K_INS_BGE,
    M68K_INS_BLT,
    M68K_INS_BGT,
    M68K_INS_BLE,
    M68K_INS_BRA,
    M68K_INS_BSR,
    M68K_INS_BCHG,
    M68K_INS_BCLR,
    M68K_INS_BSET,
    M68K_INS_BTST,
    M68K_INS_BFCHG,
    M68K_INS_BFCLR,
    M68K_INS_BFEXTS,
    M68K_INS_BFEXTU,
    M68K_INS_BFFFO,
    M68K_INS_BFINS,
    M68K_INS_BFSET,
    M68K_INS_BFTST,
    M68K_INS_BKPT,
    M68K_INS_CALLM,
    M68K_INS_CAS,
    M68K_INS_CAS2,
    M68K_INS_CHK,
    M68K_INS_CHK2,
    M68K_INS_CLR,
    M68K_INS_CMP,
    M68K_INS_CMPA,
    M68K_INS_CMPI,
    M68K_INS_CMPM,
    M68K_INS_CMP2,
    M68K_INS_CINVL,
    M68K_INS_CINVP,
    M68K_INS_CINVA,
    M68K_INS_CPUSHL,
    M68K_INS_CPUSHP,
    M68K_INS_CPUSHA,
    M68K_INS_DBT,
    M68K_INS_DBF,
    M68K_INS_DBHI,
    M68K_INS_DBLS,
    M68K_INS_DBCC,
    M68K_INS_DBCS,
    M68K_INS_DBNE,
    M68K_INS_DBEQ,
    M68K_INS_DBVC,
    M68K_INS_DBVS,
    M68K_INS_DBPL,
    M68K_INS_DBMI,
    M68K_INS_DBGE,
    M68K_INS_DBLT,
    M68K_INS_DBGT,
    M68K_INS_DBLE,
    M68K_INS_DBRA,
    M68K_INS_DIVS,
    M68K_INS_DIVSL,
    M68K_INS_DIVU,
    M68K_INS_DIVUL,
    M68K_INS_EOR,
    M68K_INS_EORI,
    M68K_INS_EXG,
    M68K_INS_EXT,
    M68K_INS_EXTB,
    M68K_INS_FABS,
    M68K_INS_FSABS,
    M68K_INS_FDABS,
    M68K_INS_FACOS,
    M68K_INS_FADD,
    M68K_INS_FSADD,
    M68K_INS_FDADD,
    M68K_INS_FASIN,
    M68K_INS_FATAN,
    M68K_INS_FATANH,
    M68K_INS_FBF,
    M68K_INS_FBEQ,
    M68K_INS_FBOGT,
    M68K_INS_FBOGE,
    M68K_INS_FBOLT,
    M68K_INS_FBOLE,
    M68K_INS_FBOGL,
    M68K_INS_FBOR,
    M68K_INS_FBUN,
    M68K_INS_FBUEQ,
    M68K_INS_FBUGT,
    M68K_INS_FBUGE,
    M68K_INS_FBULT,
    M68K_INS_FBULE,
    M68K_INS_FBNE,
    M68K_INS_FBT,
    M68K_INS_FBSF,
    M68K_INS_FBSEQ,
    M68K_INS_FBGT,
    M68K_INS_FBGE,
    M68K_INS_FBLT,
    M68K_INS_FBLE,
    M68K_INS_FBGL,
    M68K_INS_FBGLE,
    M68K_INS_FBNGLE,
    M68K_INS_FBNGL,
    M68K_INS_FBNLE,
    M68K_INS_FBNLT,
    M68K_INS_FBNGE,
    M68K_INS_FBNGT,
    M68K_INS_FBSNE,
    M68K_INS_FBST,
    M68K_INS_FCMP,
    M68K_INS_FCOS,
    M68K_INS_FCOSH,
    M68K_INS_FDBF,
    M68K_INS_FDBEQ,
    M68K_INS_FDBOGT,
    M68K_INS_FDBOGE,
    M68K_INS_FDBOLT,
    M68K_INS_FDBOLE,
    M68K_INS_FDBOGL,
    M68K_INS_FDBOR,
    M68K_INS_FDBUN,
    M68K_INS_FDBUEQ,
    M68K_INS_FDBUGT,
    M68K_INS_FDBUGE,
    M68K_INS_FDBULT,
    M68K_INS_FDBULE,
    M68K_INS_FDBNE,
    M68K_INS_FDBT,
    M68K_INS_FDBSF,
    M68K_INS_FDBSEQ,
    M68K_INS_FDBGT,
    M68K_INS_FDBGE,
    M68K_INS_FDBLT,
    M68K_INS_FDBLE,
    M68K_INS_FDBGL,
    M68K_INS_FDBGLE,
    M68K_INS_FDBNGLE,
    M68K_INS_FDBNGL,
    M68K_INS_FDBNLE,
    M68K_INS_FDBNLT,
    M68K_INS_FDBNGE,
    M68K_INS_FDBNGT,
    M68K_INS_FDBSNE,
    M68K_INS_FDBST,
    M68K_INS_FDIV,
    M68K_INS_FSDIV,
    M68K_INS_FDDIV,
    M68K_INS_FETOX,
    M68K_INS_FETOXM1,
    M68K_INS_FGETEXP,
    M68K_INS_FGETMAN,
    M68K_INS_FINT,
    M68K_INS_FINTRZ,
    M68K_INS_FLOG10,
    M68K_INS_FLOG2,
    M68K_INS_FLOGN,
    M68K_INS_FLOGNP1,
    M68K_INS_FMOD,
    M68K_INS_FMOVE,
    M68K_INS_FSMOVE,
    M68K_INS_FDMOVE,
    M68K_INS_FMOVECR,
    M68K_INS_FMOVEM,
    M68K_INS_FMUL,
    M68K_INS_FSMUL,
    M68K_INS_FDMUL,
    M68K_INS_FNEG,
    M68K_INS_FSNEG,
    M68K_INS_FDNEG,
    M68K_INS_FNOP,
    M68K_INS_FREM,
    M68K_INS_FRESTORE,
    M68K_INS_FSAVE,
    M68K_INS_FSCALE,
    M68K_INS_FSGLDIV,
    M68K_INS_FSGLMUL,
    M68K_INS_FSIN,
    M68K_INS_FSINCOS,
    M68K_INS_FSINH,
    M68K_INS_FSQRT,
    M68K_INS_FSSQRT,
    M68K_INS_FDSQRT,
    M68K_INS_FSF,
    M68K_INS_FSBEQ,
    M68K_INS_FSOGT,
    M68K_INS_FSOGE,
    M68K_INS_FSOLT,
    M68K_INS_FSOLE,
    M68K_INS_FSOGL,
    M68K_INS_FSOR,
    M68K_INS_FSUN,
    M68K_INS_FSUEQ,
    M68K_INS_FSUGT,
    M68K_INS_FSUGE,
    M68K_INS_FSULT,
    M68K_INS_FSULE,
    M68K_INS_FSNE,
    M68K_INS_FST,
    M68K_INS_FSSF,
    M68K_INS_FSSEQ,
    M68K_INS_FSGT,
    M68K_INS_FSGE,
    M68K_INS_FSLT,
    M68K_INS_FSLE,
    M68K_INS_FSGL,
    M68K_INS_FSGLE,
    M68K_INS_FSNGLE,
    M68K_INS_FSNGL,
    M68K_INS_FSNLE,
    M68K_INS_FSNLT,
    M68K_INS_FSNGE,
    M68K_INS_FSNGT,
    M68K_INS_FSSNE,
    M68K_INS_FSST,
    M68K_INS_FSUB,
    M68K_INS_FSSUB,
    M68K_INS_FDSUB,
    M68K_INS_FTAN,
    M68K_INS_FTANH,
    M68K_INS_FTENTOX,
    M68K_INS_FTRAPF,
    M68K_INS_FTRAPEQ,
    M68K_INS_FTRAPOGT,
    M68K_INS_FTRAPOGE,
    M68K_INS_FTRAPOLT,
    M68K_INS_FTRAPOLE,
    M68K_INS_FTRAPOGL,
    M68K_INS_FTRAPOR,
    M68K_INS_FTRAPUN,
    M68K_INS_FTRAPUEQ,
    M68K_INS_FTRAPUGT,
    M68K_INS_FTRAPUGE,
    M68K_INS_FTRAPULT,
    M68K_INS_FTRAPULE,
    M68K_INS_FTRAPNE,
    M68K_INS_FTRAPT,
    M68K_INS_FTRAPSF,
    M68K_INS_FTRAPSEQ,
    M68K_INS_FTRAPGT,
    M68K_INS_FTRAPGE,
    M68K_INS_FTRAPLT,
    M68K_INS_FTRAPLE,
    M68K_INS_FTRAPGL,
    M68K_INS_FTRAPGLE,
    M68K_INS_FTRAPNGLE,
    M68K_INS_FTRAPNGL,
    M68K_INS_FTRAPNLE,
    M68K_INS_FTRAPNLT,
    M68K_INS_FTRAPNGE,
    M68K_INS_FTRAPNGT,
    M68K_INS_FTRAPSNE,
    M68K_INS_FTRAPST,
    M68K_INS_FTST,
    M68K_INS_FTWOTOX,
    M68K_INS_HALT,
    M68K_INS_ILLEGAL,
    M68K_INS_JMP,
    M68K_INS_JSR,
    M68K_INS_LEA,
    M68K_INS_LINK,
    M68K_INS_LPSTOP,
    M68K_INS_LSL,
    M68K_INS_LSR,
    M68K_INS_MOVE,
    M68K_INS_MOVEA,
    M68K_INS_MOVEC,
    M68K_INS_MOVEM,
    M68K_INS_MOVEP,
    M68K_INS_MOVEQ,
    M68K_INS_MOVES,
    M68K_INS_MOVE16,
    M68K_INS_MULS,
    M68K_INS_MULU,
    M68K_INS_NBCD,
    M68K_INS_NEG,
    M68K_INS_NEGX,
    M68K_INS_NOP,
    M68K_INS_NOT,
    M68K_INS_OR,
    M68K_INS_ORI,
    M68K_INS_PACK,
    M68K_INS_PEA,
    M68K_INS_PFLUSH,
    M68K_INS_PFLUSHA,
    M68K_INS_PFLUSHAN,
    M68K_INS_PFLUSHN,
    M68K_INS_PLOADR,
    M68K_INS_PLOADW,
    M68K_INS_PLPAR,
    M68K_INS_PLPAW,
    M68K_INS_PMOVE,
    M68K_INS_PMOVEFD,
    M68K_INS_PTESTR,
    M68K_INS_PTESTW,
    M68K_INS_PULSE,
    M68K_INS_REMS,
    M68K_INS_REMU,
    M68K_INS_RESET,
    M68K_INS_ROL,
    M68K_INS_ROR,
    M68K_INS_ROXL,
    M68K_INS_ROXR,
    M68K_INS_RTD,
    M68K_INS_RTE,
    M68K_INS_RTM,
    M68K_INS_RTR,
    M68K_INS_RTS,
    M68K_INS_SBCD,
    M68K_INS_ST,
    M68K_INS_SF,
    M68K_INS_SHI,
    M68K_INS_SLS,
    M68K_INS_SCC,
    M68K_INS_SHS,
    M68K_INS_SCS,
    M68K_INS_SLO,
    M68K_INS_SNE,
    M68K_INS_SEQ,
    M68K_INS_SVC,
    M68K_INS_SVS,
    M68K_INS_SPL,
    M68K_INS_SMI,
    M68K_INS_SGE,
    M68K_INS_SLT,
    M68K_INS_SGT,
    M68K_INS_SLE,
    M68K_INS_STOP,
    M68K_INS_SUB,
    M68K_INS_SUBA,
    M68K_INS_SUBI,
    M68K_INS_SUBQ,
    M68K_INS_SUBX,
    M68K_INS_SWAP,
    M68K_INS_TAS,
    M68K_INS_TRAP,
    M68K_INS_TRAPV,
    M68K_INS_TRAPT,
    M68K_INS_TRAPF,
    M68K_INS_TRAPHI,
    M68K_INS_TRAPLS,
    M68K_INS_TRAPCC,
    M68K_INS_TRAPHS,
    M68K_INS_TRAPCS,
    M68K_INS_TRAPLO,
    M68K_INS_TRAPNE,
    M68K_INS_TRAPEQ,
    M68K_INS_TRAPVC,
    M68K_INS_TRAPVS,
    M68K_INS_TRAPPL,
    M68K_INS_TRAPMI,
    M68K_INS_TRAPGE,
    M68K_INS_TRAPLT,
    M68K_INS_TRAPGT,
    M68K_INS_TRAPLE,
    M68K_INS_TST,
    M68K_INS_UNLK,
    M68K_INS_UNPK,
    M68K_INS_ENDING,   // <-- mark the end of the list of instructions

} m68k_insn;

//> Group of M68K instructions
typedef enum m68k_group_type
{
    M68K_GRP_INVALID = 0,  // CS_GRUP_INVALID
    M68K_GRP_JUMP,  // = CS_GRP_JUMP
    M68K_GRP_RET = 3,  // = CS_GRP_RET
    M68K_GRP_IRET = 5, // = CS_GRP_IRET

    M68K_GRP_ENDING,// <-- mark the end of the list of groups
} m68k_group_type;

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/mips.h`:

```h
#ifndef CAPSTONE_MIPS_H
#define CAPSTONE_MIPS_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum mips_op_type
{
    MIPS_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    MIPS_OP_REG, // = CS_OP_REG (Register operand).
    MIPS_OP_IMM, // = CS_OP_IMM (Immediate operand).
    MIPS_OP_MEM, // = CS_OP_MEM (Memory operand).
} mips_op_type;

//> MIPS registers
typedef enum mips_reg
{
    MIPS_REG_INVALID = 0,
    //> General purpose registers
    MIPS_REG_PC,

    MIPS_REG_0,
    MIPS_REG_1,
    MIPS_REG_2,
    MIPS_REG_3,
    MIPS_REG_4,
    MIPS_REG_5,
    MIPS_REG_6,
    MIPS_REG_7,
    MIPS_REG_8,
    MIPS_REG_9,
    MIPS_REG_10,
    MIPS_REG_11,
    MIPS_REG_12,
    MIPS_REG_13,
    MIPS_REG_14,
    MIPS_REG_15,
    MIPS_REG_16,
    MIPS_REG_17,
    MIPS_REG_18,
    MIPS_REG_19,
    MIPS_REG_20,
    MIPS_REG_21,
    MIPS_REG_22,
    MIPS_REG_23,
    MIPS_REG_24,
    MIPS_REG_25,
    MIPS_REG_26,
    MIPS_REG_27,
    MIPS_REG_28,
    MIPS_REG_29,
    MIPS_REG_30,
    MIPS_REG_31,

    //> DSP registers
    MIPS_REG_DSPCCOND,
    MIPS_REG_DSPCARRY,
    MIPS_REG_DSPEFI,
    MIPS_REG_DSPOUTFLAG,
    MIPS_REG_DSPOUTFLAG16_19,
    MIPS_REG_DSPOUTFLAG20,
    MIPS_REG_DSPOUTFLAG21,
    MIPS_REG_DSPOUTFLAG22,
    MIPS_REG_DSPOUTFLAG23,
    MIPS_REG_DSPPOS,
    MIPS_REG_DSPSCOUNT,

    //> ACC registers
    MIPS_REG_AC0,
    MIPS_REG_AC1,
    MIPS_REG_AC2,
    MIPS_REG_AC3,

    //> COP registers
    MIPS_REG_CC0,
    MIPS_REG_CC1,
    MIPS_REG_CC2,
    MIPS_REG_CC3,
    MIPS_REG_CC4,
    MIPS_REG_CC5,
    MIPS_REG_CC6,
    MIPS_REG_CC7,

    //> FPU registers
    MIPS_REG_F0,
    MIPS_REG_F1,
    MIPS_REG_F2,
    MIPS_REG_F3,
    MIPS_REG_F4,
    MIPS_REG_F5,
    MIPS_REG_F6,
    MIPS_REG_F7,
    MIPS_REG_F8,
    MIPS_REG_F9,
    MIPS_REG_F10,
    MIPS_REG_F11,
    MIPS_REG_F12,
    MIPS_REG_F13,
    MIPS_REG_F14,
    MIPS_REG_F15,
    MIPS_REG_F16,
    MIPS_REG_F17,
    MIPS_REG_F18,
    MIPS_REG_F19,
    MIPS_REG_F20,
    MIPS_REG_F21,
    MIPS_REG_F22,
    MIPS_REG_F23,
    MIPS_REG_F24,
    MIPS_REG_F25,
    MIPS_REG_F26,
    MIPS_REG_F27,
    MIPS_REG_F28,
    MIPS_REG_F29,
    MIPS_REG_F30,
    MIPS_REG_F31,

    MIPS_REG_FCC0,
    MIPS_REG_FCC1,
    MIPS_REG_FCC2,
    MIPS_REG_FCC3,
    MIPS_REG_FCC4,
    MIPS_REG_FCC5,
    MIPS_REG_FCC6,
    MIPS_REG_FCC7,

    //> AFPR128
    MIPS_REG_W0,
    MIPS_REG_W1,
    MIPS_REG_W2,
    MIPS_REG_W3,
    MIPS_REG_W4,
    MIPS_REG_W5,
    MIPS_REG_W6,
    MIPS_REG_W7,
    MIPS_REG_W8,
    MIPS_REG_W9,
    MIPS_REG_W10,
    MIPS_REG_W11,
    MIPS_REG_W12,
    MIPS_REG_W13,
    MIPS_REG_W14,
    MIPS_REG_W15,
    MIPS_REG_W16,
    MIPS_REG_W17,
    MIPS_REG_W18,
    MIPS_REG_W19,
    MIPS_REG_W20,
    MIPS_REG_W21,
    MIPS_REG_W22,
    MIPS_REG_W23,
    MIPS_REG_W24,
    MIPS_REG_W25,
    MIPS_REG_W26,
    MIPS_REG_W27,
    MIPS_REG_W28,
    MIPS_REG_W29,
    MIPS_REG_W30,
    MIPS_REG_W31,

    MIPS_REG_HI,
    MIPS_REG_LO,

    MIPS_REG_P0,
    MIPS_REG_P1,
    MIPS_REG_P2,

    MIPS_REG_MPL0,
    MIPS_REG_MPL1,
    MIPS_REG_MPL2,

    MIPS_REG_ENDING,    // <-- mark the end of the list or registers

    // alias registers
    MIPS_REG_ZERO = MIPS_REG_0,
    MIPS_REG_AT = MIPS_REG_1,
    MIPS_REG_V0 = MIPS_REG_2,
    MIPS_REG_V1 = MIPS_REG_3,
    MIPS_REG_A0 = MIPS_REG_4,
    MIPS_REG_A1 = MIPS_REG_5,
    MIPS_REG_A2 = MIPS_REG_6,
    MIPS_REG_A3 = MIPS_REG_7,
    MIPS_REG_T0 = MIPS_REG_8,
    MIPS_REG_T1 = MIPS_REG_9,
    MIPS_REG_T2 = MIPS_REG_10,
    MIPS_REG_T3 = MIPS_REG_11,
    MIPS_REG_T4 = MIPS_REG_12,
    MIPS_REG_T5 = MIPS_REG_13,
    MIPS_REG_T6 = MIPS_REG_14,
    MIPS_REG_T7 = MIPS_REG_15,
    MIPS_REG_S0 = MIPS_REG_16,
    MIPS_REG_S1 = MIPS_REG_17,
    MIPS_REG_S2 = MIPS_REG_18,
    MIPS_REG_S3 = MIPS_REG_19,
    MIPS_REG_S4 = MIPS_REG_20,
    MIPS_REG_S5 = MIPS_REG_21,
    MIPS_REG_S6 = MIPS_REG_22,
    MIPS_REG_S7 = MIPS_REG_23,
    MIPS_REG_T8 = MIPS_REG_24,
    MIPS_REG_T9 = MIPS_REG_25,
    MIPS_REG_K0 = MIPS_REG_26,
    MIPS_REG_K1 = MIPS_REG_27,
    MIPS_REG_GP = MIPS_REG_28,
    MIPS_REG_SP = MIPS_REG_29,
    MIPS_REG_FP = MIPS_REG_30, MIPS_REG_S8 = MIPS_REG_30,
    MIPS_REG_RA = MIPS_REG_31,

    MIPS_REG_HI0 = MIPS_REG_AC0,
    MIPS_REG_HI1 = MIPS_REG_AC1,
    MIPS_REG_HI2 = MIPS_REG_AC2,
    MIPS_REG_HI3 = MIPS_REG_AC3,

    MIPS_REG_LO0 = MIPS_REG_HI0,
    MIPS_REG_LO1 = MIPS_REG_HI1,
    MIPS_REG_LO2 = MIPS_REG_HI2,
    MIPS_REG_LO3 = MIPS_REG_HI3,
} mips_reg;

// Instruction's operand referring to memory
// This is associated with MIPS_OP_MEM operand type above
typedef struct mips_op_mem
{
    mips_reg base;  // base register
    int64_t disp;   // displacement/offset value
} mips_op_mem;

// Instruction operand
typedef struct cs_mips_op
{
    mips_op_type type;  // operand type
    union
    {
        mips_reg reg;       // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        mips_op_mem mem;    // base/index/scale/disp value for MEM operand
    };
} cs_mips_op;

// Instruction structure
typedef struct cs_mips
{
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_mips_op operands[8]; // operands for this instruction.
} cs_mips;

//> MIPS instruction
typedef enum mips_insn
{
    MIPS_INS_INVALID = 0,

    MIPS_INS_ABSQ_S,
    MIPS_INS_ADD,
    MIPS_INS_ADDIUPC,
    MIPS_INS_ADDIUR1SP,
    MIPS_INS_ADDIUR2,
    MIPS_INS_ADDIUS5,
    MIPS_INS_ADDIUSP,
    MIPS_INS_ADDQH,
    MIPS_INS_ADDQH_R,
    MIPS_INS_ADDQ,
    MIPS_INS_ADDQ_S,
    MIPS_INS_ADDSC,
    MIPS_INS_ADDS_A,
    MIPS_INS_ADDS_S,
    MIPS_INS_ADDS_U,
    MIPS_INS_ADDU16,
    MIPS_INS_ADDUH,
    MIPS_INS_ADDUH_R,
    MIPS_INS_ADDU,
    MIPS_INS_ADDU_S,
    MIPS_INS_ADDVI,
    MIPS_INS_ADDV,
    MIPS_INS_ADDWC,
    MIPS_INS_ADD_A,
    MIPS_INS_ADDI,
    MIPS_INS_ADDIU,
    MIPS_INS_ALIGN,
    MIPS_INS_ALUIPC,
    MIPS_INS_AND,
    MIPS_INS_AND16,
    MIPS_INS_ANDI16,
    MIPS_INS_ANDI,
    MIPS_INS_APPEND,
    MIPS_INS_ASUB_S,
    MIPS_INS_ASUB_U,
    MIPS_INS_AUI,
    MIPS_INS_AUIPC,
    MIPS_INS_AVER_S,
    MIPS_INS_AVER_U,
    MIPS_INS_AVE_S,
    MIPS_INS_AVE_U,
    MIPS_INS_B16,
    MIPS_INS_BADDU,
    MIPS_INS_BAL,
    MIPS_INS_BALC,
    MIPS_INS_BALIGN,
    MIPS_INS_BBIT0,
    MIPS_INS_BBIT032,
    MIPS_INS_BBIT1,
    MIPS_INS_BBIT132,
    MIPS_INS_BC,
    MIPS_INS_BC0F,
    MIPS_INS_BC0FL,
    MIPS_INS_BC0T,
    MIPS_INS_BC0TL,
    MIPS_INS_BC1EQZ,
    MIPS_INS_BC1F,
    MIPS_INS_BC1FL,
    MIPS_INS_BC1NEZ,
    MIPS_INS_BC1T,
    MIPS_INS_BC1TL,
    MIPS_INS_BC2EQZ,
    MIPS_INS_BC2F,
    MIPS_INS_BC2FL,
    MIPS_INS_BC2NEZ,
    MIPS_INS_BC2T,
    MIPS_INS_BC2TL,
    MIPS_INS_BC3F,
    MIPS_INS_BC3FL,
    MIPS_INS_BC3T,
    MIPS_INS_BC3TL,
    MIPS_INS_BCLRI,
    MIPS_INS_BCLR,
    MIPS_INS_BEQ,
    MIPS_INS_BEQC,
    MIPS_INS_BEQL,
    MIPS_INS_BEQZ16,
    MIPS_INS_BEQZALC,
    MIPS_INS_BEQZC,
    MIPS_INS_BGEC,
    MIPS_INS_BGEUC,
    MIPS_INS_BGEZ,
    MIPS_INS_BGEZAL,
    MIPS_INS_BGEZALC,
    MIPS_INS_BGEZALL,
    MIPS_INS_BGEZALS,
    MIPS_INS_BGEZC,
    MIPS_INS_BGEZL,
    MIPS_INS_BGTZ,
    MIPS_INS_BGTZALC,
    MIPS_INS_BGTZC,
    MIPS_INS_BGTZL,
    MIPS_INS_BINSLI,
    MIPS_INS_BINSL,
    MIPS_INS_BINSRI,
    MIPS_INS_BINSR,
    MIPS_INS_BITREV,
    MIPS_INS_BITSWAP,
    MIPS_INS_BLEZ,
    MIPS_INS_BLEZALC,
    MIPS_INS_BLEZC,
    MIPS_INS_BLEZL,
    MIPS_INS_BLTC,
    MIPS_INS_BLTUC,
    MIPS_INS_BLTZ,
    MIPS_INS_BLTZAL,
    MIPS_INS_BLTZALC,
    MIPS_INS_BLTZALL,
    MIPS_INS_BLTZALS,
    MIPS_INS_BLTZC,
    MIPS_INS_BLTZL,
    MIPS_INS_BMNZI,
    MIPS_INS_BMNZ,
    MIPS_INS_BMZI,
    MIPS_INS_BMZ,
    MIPS_INS_BNE,
    MIPS_INS_BNEC,
    MIPS_INS_BNEGI,
    MIPS_INS_BNEG,
    MIPS_INS_BNEL,
    MIPS_INS_BNEZ16,
    MIPS_INS_BNEZALC,
    MIPS_INS_BNEZC,
    MIPS_INS_BNVC,
    MIPS_INS_BNZ,
    MIPS_INS_BOVC,
    MIPS_INS_BPOSGE32,
    MIPS_INS_BREAK,
    MIPS_INS_BREAK16,
    MIPS_INS_BSELI,
    MIPS_INS_BSEL,
    MIPS_INS_BSETI,
    MIPS_INS_BSET,
    MIPS_INS_BZ,
    MIPS_INS_BEQZ,
    MIPS_INS_B,
    MIPS_INS_BNEZ,
    MIPS_INS_BTEQZ,
    MIPS_INS_BTNEZ,
    MIPS_INS_CACHE,
    MIPS_INS_CEIL,
    MIPS_INS_CEQI,
    MIPS_INS_CEQ,
    MIPS_INS_CFC1,
    MIPS_INS_CFCMSA,
    MIPS_INS_CINS,
    MIPS_INS_CINS32,
    MIPS_INS_CLASS,
    MIPS_INS_CLEI_S,
    MIPS_INS_CLEI_U,
    MIPS_INS_CLE_S,
    MIPS_INS_CLE_U,
    MIPS_INS_CLO,
    MIPS_INS_CLTI_S,
    MIPS_INS_CLTI_U,
    MIPS_INS_CLT_S,
    MIPS_INS_CLT_U,
    MIPS_INS_CLZ,
    MIPS_INS_CMPGDU,
    MIPS_INS_CMPGU,
    MIPS_INS_CMPU,
    MIPS_INS_CMP,
    MIPS_INS_COPY_S,
    MIPS_INS_COPY_U,
    MIPS_INS_CTC1,
    MIPS_INS_CTCMSA,
    MIPS_INS_CVT,
    MIPS_INS_C,
    MIPS_INS_CMPI,
    MIPS_INS_DADD,
    MIPS_INS_DADDI,
    MIPS_INS_DADDIU,
    MIPS_INS_DADDU,
    MIPS_INS_DAHI,
    MIPS_INS_DALIGN,
    MIPS_INS_DATI,
    MIPS_INS_DAUI,
    MIPS_INS_DBITSWAP,
    MIPS_INS_DCLO,
    MIPS_INS_DCLZ,
    MIPS_INS_DDIV,
    MIPS_INS_DDIVU,
    MIPS_INS_DERET,
    MIPS_INS_DEXT,
    MIPS_INS_DEXTM,
    MIPS_INS_DEXTU,
    MIPS_INS_DI,
    MIPS_INS_DINS,
    MIPS_INS_DINSM,
    MIPS_INS_DINSU,
    MIPS_INS_DIV,
    MIPS_INS_DIVU,
    MIPS_INS_DIV_S,
    MIPS_INS_DIV_U,
    MIPS_INS_DLSA,
    MIPS_INS_DMFC0,
    MIPS_INS_DMFC1,
    MIPS_INS_DMFC2,
    MIPS_INS_DMOD,
    MIPS_INS_DMODU,
    MIPS_INS_DMTC0,
    MIPS_INS_DMTC1,
    MIPS_INS_DMTC2,
    MIPS_INS_DMUH,
    MIPS_INS_DMUHU,
    MIPS_INS_DMUL,
    MIPS_INS_DMULT,
    MIPS_INS_DMULTU,
    MIPS_INS_DMULU,
    MIPS_INS_DOTP_S,
    MIPS_INS_DOTP_U,
    MIPS_INS_DPADD_S,
    MIPS_INS_DPADD_U,
    MIPS_INS_DPAQX_SA,
    MIPS_INS_DPAQX_S,
    MIPS_INS_DPAQ_SA,
    MIPS_INS_DPAQ_S,
    MIPS_INS_DPAU,
    MIPS_INS_DPAX,
    MIPS_INS_DPA,
    MIPS_INS_DPOP,
    MIPS_INS_DPSQX_SA,
    MIPS_INS_DPSQX_S,
    MIPS_INS_DPSQ_SA,
    MIPS_INS_DPSQ_S,
    MIPS_INS_DPSUB_S,
    MIPS_INS_DPSUB_U,
    MIPS_INS_DPSU,
    MIPS_INS_DPSX,
    MIPS_INS_DPS,
    MIPS_INS_DROTR,
    MIPS_INS_DROTR32,
    MIPS_INS_DROTRV,
    MIPS_INS_DSBH,
    MIPS_INS_DSHD,
    MIPS_INS_DSLL,
    MIPS_INS_DSLL32,
    MIPS_INS_DSLLV,
    MIPS_INS_DSRA,
    MIPS_INS_DSRA32,
    MIPS_INS_DSRAV,
    MIPS_INS_DSRL,
    MIPS_INS_DSRL32,
    MIPS_INS_DSRLV,
    MIPS_INS_DSUB,
    MIPS_INS_DSUBU,
    MIPS_INS_EHB,
    MIPS_INS_EI,
    MIPS_INS_ERET,
    MIPS_INS_EXT,
    MIPS_INS_EXTP,
    MIPS_INS_EXTPDP,
    MIPS_INS_EXTPDPV,
    MIPS_INS_EXTPV,
    MIPS_INS_EXTRV_RS,
    MIPS_INS_EXTRV_R,
    MIPS_INS_EXTRV_S,
    MIPS_INS_EXTRV,
    MIPS_INS_EXTR_RS,
    MIPS_INS_EXTR_R,
    MIPS_INS_EXTR_S,
    MIPS_INS_EXTR,
    MIPS_INS_EXTS,
    MIPS_INS_EXTS32,
    MIPS_INS_ABS,
    MIPS_INS_FADD,
    MIPS_INS_FCAF,
    MIPS_INS_FCEQ,
    MIPS_INS_FCLASS,
    MIPS_INS_FCLE,
    MIPS_INS_FCLT,
    MIPS_INS_FCNE,
    MIPS_INS_FCOR,
    MIPS_INS_FCUEQ,
    MIPS_INS_FCULE,
    MIPS_INS_FCULT,
    MIPS_INS_FCUNE,
    MIPS_INS_FCUN,
    MIPS_INS_FDIV,
    MIPS_INS_FEXDO,
    MIPS_INS_FEXP2,
    MIPS_INS_FEXUPL,
    MIPS_INS_FEXUPR,
    MIPS_INS_FFINT_S,
    MIPS_INS_FFINT_U,
    MIPS_INS_FFQL,
    MIPS_INS_FFQR,
    MIPS_INS_FILL,
    MIPS_INS_FLOG2,
    MIPS_INS_FLOOR,
    MIPS_INS_FMADD,
    MIPS_INS_FMAX_A,
    MIPS_INS_FMAX,
    MIPS_INS_FMIN_A,
    MIPS_INS_FMIN,
    MIPS_INS_MOV,
    MIPS_INS_FMSUB,
    MIPS_INS_FMUL,
    MIPS_INS_MUL,
    MIPS_INS_NEG,
    MIPS_INS_FRCP,
    MIPS_INS_FRINT,
    MIPS_INS_FRSQRT,
    MIPS_INS_FSAF,
    MIPS_INS_FSEQ,
    MIPS_INS_FSLE,
    MIPS_INS_FSLT,
    MIPS_INS_FSNE,
    MIPS_INS_FSOR,
    MIPS_INS_FSQRT,
    MIPS_INS_SQRT,
    MIPS_INS_FSUB,
    MIPS_INS_SUB,
    MIPS_INS_FSUEQ,
    MIPS_INS_FSULE,
    MIPS_INS_FSULT,
    MIPS_INS_FSUNE,
    MIPS_INS_FSUN,
    MIPS_INS_FTINT_S,
    MIPS_INS_FTINT_U,
    MIPS_INS_FTQ,
    MIPS_INS_FTRUNC_S,
    MIPS_INS_FTRUNC_U,
    MIPS_INS_HADD_S,
    MIPS_INS_HADD_U,
    MIPS_INS_HSUB_S,
    MIPS_INS_HSUB_U,
    MIPS_INS_ILVEV,
    MIPS_INS_ILVL,
    MIPS_INS_ILVOD,
    MIPS_INS_ILVR,
    MIPS_INS_INS,
    MIPS_INS_INSERT,
    MIPS_INS_INSV,
    MIPS_INS_INSVE,
    MIPS_INS_J,
    MIPS_INS_JAL,
    MIPS_INS_JALR,
    MIPS_INS_JALRS16,
    MIPS_INS_JALRS,
    MIPS_INS_JALS,
    MIPS_INS_JALX,
    MIPS_INS_JIALC,
    MIPS_INS_JIC,
    MIPS_INS_JR,
    MIPS_INS_JR16,
    MIPS_INS_JRADDIUSP,
    MIPS_INS_JRC,
    MIPS_INS_JALRC,
    MIPS_INS_LB,
    MIPS_INS_LBU16,
    MIPS_INS_LBUX,
    MIPS_INS_LBU,
    MIPS_INS_LD,
    MIPS_INS_LDC1,
    MIPS_INS_LDC2,
    MIPS_INS_LDC3,
    MIPS_INS_LDI,
    MIPS_INS_LDL,
    MIPS_INS_LDPC,
    MIPS_INS_LDR,
    MIPS_INS_LDXC1,
    MIPS_INS_LH,
    MIPS_INS_LHU16,
    MIPS_INS_LHX,
    MIPS_INS_LHU,
    MIPS_INS_LI16,
    MIPS_INS_LL,
    MIPS_INS_LLD,
    MIPS_INS_LSA,
    MIPS_INS_LUXC1,
    MIPS_INS_LUI,
    MIPS_INS_LW,
    MIPS_INS_LW16,
    MIPS_INS_LWC1,
    MIPS_INS_LWC2,
    MIPS_INS_LWC3,
    MIPS_INS_LWL,
    MIPS_INS_LWM16,
    MIPS_INS_LWM32,
    MIPS_INS_LWPC,
    MIPS_INS_LWP,
    MIPS_INS_LWR,
    MIPS_INS_LWUPC,
    MIPS_INS_LWU,
    MIPS_INS_LWX,
    MIPS_INS_LWXC1,
    MIPS_INS_LWXS,
    MIPS_INS_LI,
    MIPS_INS_MADD,
    MIPS_INS_MADDF,
    MIPS_INS_MADDR_Q,
    MIPS_INS_MADDU,
    MIPS_INS_MADDV,
    MIPS_INS_MADD_Q,
    MIPS_INS_MAQ_SA,
    MIPS_INS_MAQ_S,
    MIPS_INS_MAXA,
    MIPS_INS_MAXI_S,
    MIPS_INS_MAXI_U,
    MIPS_INS_MAX_A,
    MIPS_INS_MAX,
    MIPS_INS_MAX_S,
    MIPS_INS_MAX_U,
    MIPS_INS_MFC0,
    MIPS_INS_MFC1,
    MIPS_INS_MFC2,
    MIPS_INS_MFHC1,
    MIPS_INS_MFHI,
    MIPS_INS_MFLO,
    MIPS_INS_MINA,
    MIPS_INS_MINI_S,
    MIPS_INS_MINI_U,
    MIPS_INS_MIN_A,
    MIPS_INS_MIN,
    MIPS_INS_MIN_S,
    MIPS_INS_MIN_U,
    MIPS_INS_MOD,
    MIPS_INS_MODSUB,
    MIPS_INS_MODU,
    MIPS_INS_MOD_S,
    MIPS_INS_MOD_U,
    MIPS_INS_MOVE,
    MIPS_INS_MOVEP,
    MIPS_INS_MOVF,
    MIPS_INS_MOVN,
    MIPS_INS_MOVT,
    MIPS_INS_MOVZ,
    MIPS_INS_MSUB,
    MIPS_INS_MSUBF,
    MIPS_INS_MSUBR_Q,
    MIPS_INS_MSUBU,
    MIPS_INS_MSUBV,
    MIPS_INS_MSUB_Q,
    MIPS_INS_MTC0,
    MIPS_INS_MTC1,
    MIPS_INS_MTC2,
    MIPS_INS_MTHC1,
    MIPS_INS_MTHI,
    MIPS_INS_MTHLIP,
    MIPS_INS_MTLO,
    MIPS_INS_MTM0,
    MIPS_INS_MTM1,
    MIPS_INS_MTM2,
    MIPS_INS_MTP0,
    MIPS_INS_MTP1,
    MIPS_INS_MTP2,
    MIPS_INS_MUH,
    MIPS_INS_MUHU,
    MIPS_INS_MULEQ_S,
    MIPS_INS_MULEU_S,
    MIPS_INS_MULQ_RS,
    MIPS_INS_MULQ_S,
    MIPS_INS_MULR_Q,
    MIPS_INS_MULSAQ_S,
    MIPS_INS_MULSA,
    MIPS_INS_MULT,
    MIPS_INS_MULTU,
    MIPS_INS_MULU,
    MIPS_INS_MULV,
    MIPS_INS_MUL_Q,
    MIPS_INS_MUL_S,
    MIPS_INS_NLOC,
    MIPS_INS_NLZC,
    MIPS_INS_NMADD,
    MIPS_INS_NMSUB,
    MIPS_INS_NOR,
    MIPS_INS_NORI,
    MIPS_INS_NOT16,
    MIPS_INS_NOT,
    MIPS_INS_OR,
    MIPS_INS_OR16,
    MIPS_INS_ORI,
    MIPS_INS_PACKRL,
    MIPS_INS_PAUSE,
    MIPS_INS_PCKEV,
    MIPS_INS_PCKOD,
    MIPS_INS_PCNT,
    MIPS_INS_PICK,
    MIPS_INS_POP,
    MIPS_INS_PRECEQU,
    MIPS_INS_PRECEQ,
    MIPS_INS_PRECEU,
    MIPS_INS_PRECRQU_S,
    MIPS_INS_PRECRQ,
    MIPS_INS_PRECRQ_RS,
    MIPS_INS_PRECR,
    MIPS_INS_PRECR_SRA,
    MIPS_INS_PRECR_SRA_R,
    MIPS_INS_PREF,
    MIPS_INS_PREPEND,
    MIPS_INS_RADDU,
    MIPS_INS_RDDSP,
    MIPS_INS_RDHWR,
    MIPS_INS_REPLV,
    MIPS_INS_REPL,
    MIPS_INS_RINT,
    MIPS_INS_ROTR,
    MIPS_INS_ROTRV,
    MIPS_INS_ROUND,
    MIPS_INS_SAT_S,
    MIPS_INS_SAT_U,
    MIPS_INS_SB,
    MIPS_INS_SB16,
    MIPS_INS_SC,
    MIPS_INS_SCD,
    MIPS_INS_SD,
    MIPS_INS_SDBBP,
    MIPS_INS_SDBBP16,
    MIPS_INS_SDC1,
    MIPS_INS_SDC2,
    MIPS_INS_SDC3,
    MIPS_INS_SDL,
    MIPS_INS_SDR,
    MIPS_INS_SDXC1,
    MIPS_INS_SEB,
    MIPS_INS_SEH,
    MIPS_INS_SELEQZ,
    MIPS_INS_SELNEZ,
    MIPS_INS_SEL,
    MIPS_INS_SEQ,
    MIPS_INS_SEQI,
    MIPS_INS_SH,
    MIPS_INS_SH16,
    MIPS_INS_SHF,
    MIPS_INS_SHILO,
    MIPS_INS_SHILOV,
    MIPS_INS_SHLLV,
    MIPS_INS_SHLLV_S,
    MIPS_INS_SHLL,
    MIPS_INS_SHLL_S,
    MIPS_INS_SHRAV,
    MIPS_INS_SHRAV_R,
    MIPS_INS_SHRA,
    MIPS_INS_SHRA_R,
    MIPS_INS_SHRLV,
    MIPS_INS_SHRL,
    MIPS_INS_SLDI,
    MIPS_INS_SLD,
    MIPS_INS_SLL,
    MIPS_INS_SLL16,
    MIPS_INS_SLLI,
    MIPS_INS_SLLV,
    MIPS_INS_SLT,
    MIPS_INS_SLTI,
    MIPS_INS_SLTIU,
    MIPS_INS_SLTU,
    MIPS_INS_SNE,
    MIPS_INS_SNEI,
    MIPS_INS_SPLATI,
    MIPS_INS_SPLAT,
    MIPS_INS_SRA,
    MIPS_INS_SRAI,
    MIPS_INS_SRARI,
    MIPS_INS_SRAR,
    MIPS_INS_SRAV,
    MIPS_INS_SRL,
    MIPS_INS_SRL16,
    MIPS_INS_SRLI,
    MIPS_INS_SRLRI,
    MIPS_INS_SRLR,
    MIPS_INS_SRLV,
    MIPS_INS_SSNOP,
    MIPS_INS_ST,
    MIPS_INS_SUBQH,
    MIPS_INS_SUBQH_R,
    MIPS_INS_SUBQ,
    MIPS_INS_SUBQ_S,
    MIPS_INS_SUBSUS_U,
    MIPS_INS_SUBSUU_S,
    MIPS_INS_SUBS_S,
    MIPS_INS_SUBS_U,
    MIPS_INS_SUBU16,
    MIPS_INS_SUBUH,
    MIPS_INS_SUBUH_R,
    MIPS_INS_SUBU,
    MIPS_INS_SUBU_S,
    MIPS_INS_SUBVI,
    MIPS_INS_SUBV,
    MIPS_INS_SUXC1,
    MIPS_INS_SW,
    MIPS_INS_SW16,
    MIPS_INS_SWC1,
    MIPS_INS_SWC2,
    MIPS_INS_SWC3,
    MIPS_INS_SWL,
    MIPS_INS_SWM16,
    MIPS_INS_SWM32,
    MIPS_INS_SWP,
    MIPS_INS_SWR,
    MIPS_INS_SWXC1,
    MIPS_INS_SYNC,
    MIPS_INS_SYNCI,
    MIPS_INS_SYSCALL,
    MIPS_INS_TEQ,
    MIPS_INS_TEQI,
    MIPS_INS_TGE,
    MIPS_INS_TGEI,
    MIPS_INS_TGEIU,
    MIPS_INS_TGEU,
    MIPS_INS_TLBP,
    MIPS_INS_TLBR,
    MIPS_INS_TLBWI,
    MIPS_INS_TLBWR,
    MIPS_INS_TLT,
    MIPS_INS_TLTI,
    MIPS_INS_TLTIU,
    MIPS_INS_TLTU,
    MIPS_INS_TNE,
    MIPS_INS_TNEI,
    MIPS_INS_TRUNC,
    MIPS_INS_V3MULU,
    MIPS_INS_VMM0,
    MIPS_INS_VMULU,
    MIPS_INS_VSHF,
    MIPS_INS_WAIT,
    MIPS_INS_WRDSP,
    MIPS_INS_WSBH,
    MIPS_INS_XOR,
    MIPS_INS_XOR16,
    MIPS_INS_XORI,

    //> some alias instructions
    MIPS_INS_NOP,
    MIPS_INS_NEGU,

    //> special instructions
    MIPS_INS_JALR_HB,   // jump and link with Hazard Barrier
    MIPS_INS_JR_HB,     // jump register with Hazard Barrier

    MIPS_INS_ENDING,
} mips_insn;

//> Group of MIPS instructions
typedef enum mips_insn_group
{
    MIPS_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    MIPS_GRP_JUMP,  // = CS_GRP_JUMP
    // all call instructions
    MIPS_GRP_CALL,  // = CS_GRP_CALL
    // all return instructions
    MIPS_GRP_RET,   // = CS_GRP_RET
    // all interrupt instructions (int+syscall)
    MIPS_GRP_INT,   // = CS_GRP_INT
    // all interrupt return instructions
    MIPS_GRP_IRET,  // = CS_GRP_IRET
    // all privileged instructions
    MIPS_GRP_PRIVILEGE, // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    MIPS_GRP_BITCOUNT = 128,
    MIPS_GRP_DSP,
    MIPS_GRP_DSPR2,
    MIPS_GRP_FPIDX,
    MIPS_GRP_MSA,
    MIPS_GRP_MIPS32R2,
    MIPS_GRP_MIPS64,
    MIPS_GRP_MIPS64R2,
    MIPS_GRP_SEINREG,
    MIPS_GRP_STDENC,
    MIPS_GRP_SWAP,
    MIPS_GRP_MICROMIPS,
    MIPS_GRP_MIPS16MODE,
    MIPS_GRP_FP64BIT,
    MIPS_GRP_NONANSFPMATH,
    MIPS_GRP_NOTFP64BIT,
    MIPS_GRP_NOTINMICROMIPS,
    MIPS_GRP_NOTNACL,
    MIPS_GRP_NOTMIPS32R6,
    MIPS_GRP_NOTMIPS64R6,
    MIPS_GRP_CNMIPS,
    MIPS_GRP_MIPS32,
    MIPS_GRP_MIPS32R6,
    MIPS_GRP_MIPS64R6,
    MIPS_GRP_MIPS2,
    MIPS_GRP_MIPS3,
    MIPS_GRP_MIPS3_32,
    MIPS_GRP_MIPS3_32R2,
    MIPS_GRP_MIPS4_32,
    MIPS_GRP_MIPS4_32R2,
    MIPS_GRP_MIPS5_32R2,
    MIPS_GRP_GP32BIT,
    MIPS_GRP_GP64BIT,

    MIPS_GRP_ENDING,
} mips_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/platform.h`:

```h
/* Capstone Disassembly Engine */
/* By Axel Souchet & Nguyen Anh Quynh, 2014 */

#ifndef CAPSTONE_PLATFORM_H
#define CAPSTONE_PLATFORM_H


// handle C99 issue (for pre-2013 VisualStudio)
#if !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < 1800) || defined(_KERNEL_MODE)
// this system does not have stdbool.h
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif  // __cplusplus

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif  // (_MSC_VER < 1800) || defined(_KERNEL_MODE)

#else
// not MSVC -> C99 is supported
#include <stdbool.h>
#endif  // !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))


// handle inttypes.h / stdint.h compatibility
#if defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)
#include "windowsce/stdint.h"
#endif  // defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)

#if defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))
// this system does not have inttypes.h

#if defined(_MSC_VER) && (_MSC_VER < 1600 || defined(_KERNEL_MODE))
// this system does not have stdint.h
typedef signed char  int8_t;
typedef signed short int16_t;
typedef signed int   int32_t;
typedef unsigned char  uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int   uint32_t;
typedef signed long long   int64_t;
typedef unsigned long long uint64_t;

#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64
#endif  // defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE))

#define __PRI_8_LENGTH_MODIFIER__ "hh"
#define __PRI_64_LENGTH_MODIFIER__ "ll"

#define PRId8         __PRI_8_LENGTH_MODIFIER__ "d"
#define PRIi8         __PRI_8_LENGTH_MODIFIER__ "i"
#define PRIo8         __PRI_8_LENGTH_MODIFIER__ "o"
#define PRIu8         __PRI_8_LENGTH_MODIFIER__ "u"
#define PRIx8         __PRI_8_LENGTH_MODIFIER__ "x"
#define PRIX8         __PRI_8_LENGTH_MODIFIER__ "X"

#define PRId16        "hd"
#define PRIi16        "hi"
#define PRIo16        "ho"
#define PRIu16        "hu"
#define PRIx16        "hx"
#define PRIX16        "hX"

#if defined(_MSC_VER) && _MSC_VER <= 1700
#define PRId32        "ld"
#define PRIi32        "li"
#define PRIo32        "lo"
#define PRIu32        "lu"
#define PRIx32        "lx"
#define PRIX32        "lX"
#else   // OSX
#define PRId32        "d"
#define PRIi32        "i"
#define PRIo32        "o"
#define PRIu32        "u"
#define PRIx32        "x"
#define PRIX32        "X"
#endif  // defined(_MSC_VER) && _MSC_VER <= 1700

#if defined(_MSC_VER) && _MSC_VER <= 1700
// redefine functions from inttypes.h used in cstool
#define strtoull _strtoui64
#endif

#define PRId64        __PRI_64_LENGTH_MODIFIER__ "d"
#define PRIi64        __PRI_64_LENGTH_MODIFIER__ "i"
#define PRIo64        __PRI_64_LENGTH_MODIFIER__ "o"
#define PRIu64        __PRI_64_LENGTH_MODIFIER__ "u"
#define PRIx64        __PRI_64_LENGTH_MODIFIER__ "x"
#define PRIX64        __PRI_64_LENGTH_MODIFIER__ "X"

#else
// this system has inttypes.h by default
#include <inttypes.h>
#endif  // defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/ppc.h`:

```h
#ifndef CAPSTONE_PPC_H
#define CAPSTONE_PPC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> PPC branch codes for some branch instructions
typedef enum ppc_bc
{
    PPC_BC_INVALID  = 0,
    PPC_BC_LT       = (0 << 5) | 12,
    PPC_BC_LE       = (1 << 5) |  4,
    PPC_BC_EQ       = (2 << 5) | 12,
    PPC_BC_GE       = (0 << 5) |  4,
    PPC_BC_GT       = (1 << 5) | 12,
    PPC_BC_NE       = (2 << 5) |  4,
    PPC_BC_UN       = (3 << 5) | 12,
    PPC_BC_NU       = (3 << 5) |  4,

    // extra conditions
    PPC_BC_SO = (4 << 5) | 12,  // summary overflow
    PPC_BC_NS = (4 << 5) | 4,   // not summary overflow
} ppc_bc;

//> PPC branch hint for some branch instructions
typedef enum ppc_bh
{
    PPC_BH_INVALID = 0, // no hint
    PPC_BH_PLUS,    // PLUS hint
    PPC_BH_MINUS,   // MINUS hint
} ppc_bh;

//> Operand type for instruction's operands
typedef enum ppc_op_type
{
    PPC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    PPC_OP_REG, // = CS_OP_REG (Register operand).
    PPC_OP_IMM, // = CS_OP_IMM (Immediate operand).
    PPC_OP_MEM, // = CS_OP_MEM (Memory operand).
    PPC_OP_CRX = 64,    // Condition Register field
} ppc_op_type;

//> PPC registers
typedef enum ppc_reg
{
    PPC_REG_INVALID = 0,

    PPC_REG_CARRY,
    PPC_REG_CR0,
    PPC_REG_CR1,
    PPC_REG_CR2,
    PPC_REG_CR3,
    PPC_REG_CR4,
    PPC_REG_CR5,
    PPC_REG_CR6,
    PPC_REG_CR7,
    PPC_REG_CTR,
    PPC_REG_F0,
    PPC_REG_F1,
    PPC_REG_F2,
    PPC_REG_F3,
    PPC_REG_F4,
    PPC_REG_F5,
    PPC_REG_F6,
    PPC_REG_F7,
    PPC_REG_F8,
    PPC_REG_F9,
    PPC_REG_F10,
    PPC_REG_F11,
    PPC_REG_F12,
    PPC_REG_F13,
    PPC_REG_F14,
    PPC_REG_F15,
    PPC_REG_F16,
    PPC_REG_F17,
    PPC_REG_F18,
    PPC_REG_F19,
    PPC_REG_F20,
    PPC_REG_F21,
    PPC_REG_F22,
    PPC_REG_F23,
    PPC_REG_F24,
    PPC_REG_F25,
    PPC_REG_F26,
    PPC_REG_F27,
    PPC_REG_F28,
    PPC_REG_F29,
    PPC_REG_F30,
    PPC_REG_F31,
    PPC_REG_LR,
    PPC_REG_R0,
    PPC_REG_R1,
    PPC_REG_R2,
    PPC_REG_R3,
    PPC_REG_R4,
    PPC_REG_R5,
    PPC_REG_R6,
    PPC_REG_R7,
    PPC_REG_R8,
    PPC_REG_R9,
    PPC_REG_R10,
    PPC_REG_R11,
    PPC_REG_R12,
    PPC_REG_R13,
    PPC_REG_R14,
    PPC_REG_R15,
    PPC_REG_R16,
    PPC_REG_R17,
    PPC_REG_R18,
    PPC_REG_R19,
    PPC_REG_R20,
    PPC_REG_R21,
    PPC_REG_R22,
    PPC_REG_R23,
    PPC_REG_R24,
    PPC_REG_R25,
    PPC_REG_R26,
    PPC_REG_R27,
    PPC_REG_R28,
    PPC_REG_R29,
    PPC_REG_R30,
    PPC_REG_R31,
    PPC_REG_V0,
    PPC_REG_V1,
    PPC_REG_V2,
    PPC_REG_V3,
    PPC_REG_V4,
    PPC_REG_V5,
    PPC_REG_V6,
    PPC_REG_V7,
    PPC_REG_V8,
    PPC_REG_V9,
    PPC_REG_V10,
    PPC_REG_V11,
    PPC_REG_V12,
    PPC_REG_V13,
    PPC_REG_V14,
    PPC_REG_V15,
    PPC_REG_V16,
    PPC_REG_V17,
    PPC_REG_V18,
    PPC_REG_V19,
    PPC_REG_V20,
    PPC_REG_V21,
    PPC_REG_V22,
    PPC_REG_V23,
    PPC_REG_V24,
    PPC_REG_V25,
    PPC_REG_V26,
    PPC_REG_V27,
    PPC_REG_V28,
    PPC_REG_V29,
    PPC_REG_V30,
    PPC_REG_V31,
    PPC_REG_VRSAVE,
    PPC_REG_VS0,
    PPC_REG_VS1,
    PPC_REG_VS2,
    PPC_REG_VS3,
    PPC_REG_VS4,
    PPC_REG_VS5,
    PPC_REG_VS6,
    PPC_REG_VS7,
    PPC_REG_VS8,
    PPC_REG_VS9,
    PPC_REG_VS10,
    PPC_REG_VS11,
    PPC_REG_VS12,
    PPC_REG_VS13,
    PPC_REG_VS14,
    PPC_REG_VS15,
    PPC_REG_VS16,
    PPC_REG_VS17,
    PPC_REG_VS18,
    PPC_REG_VS19,
    PPC_REG_VS20,
    PPC_REG_VS21,
    PPC_REG_VS22,
    PPC_REG_VS23,
    PPC_REG_VS24,
    PPC_REG_VS25,
    PPC_REG_VS26,
    PPC_REG_VS27,
    PPC_REG_VS28,
    PPC_REG_VS29,
    PPC_REG_VS30,
    PPC_REG_VS31,
    PPC_REG_VS32,
    PPC_REG_VS33,
    PPC_REG_VS34,
    PPC_REG_VS35,
    PPC_REG_VS36,
    PPC_REG_VS37,
    PPC_REG_VS38,
    PPC_REG_VS39,
    PPC_REG_VS40,
    PPC_REG_VS41,
    PPC_REG_VS42,
    PPC_REG_VS43,
    PPC_REG_VS44,
    PPC_REG_VS45,
    PPC_REG_VS46,
    PPC_REG_VS47,
    PPC_REG_VS48,
    PPC_REG_VS49,
    PPC_REG_VS50,
    PPC_REG_VS51,
    PPC_REG_VS52,
    PPC_REG_VS53,
    PPC_REG_VS54,
    PPC_REG_VS55,
    PPC_REG_VS56,
    PPC_REG_VS57,
    PPC_REG_VS58,
    PPC_REG_VS59,
    PPC_REG_VS60,
    PPC_REG_VS61,
    PPC_REG_VS62,
    PPC_REG_VS63,
    PPC_REG_Q0,
    PPC_REG_Q1,
    PPC_REG_Q2,
    PPC_REG_Q3,
    PPC_REG_Q4,
    PPC_REG_Q5,
    PPC_REG_Q6,
    PPC_REG_Q7,
    PPC_REG_Q8,
    PPC_REG_Q9,
    PPC_REG_Q10,
    PPC_REG_Q11,
    PPC_REG_Q12,
    PPC_REG_Q13,
    PPC_REG_Q14,
    PPC_REG_Q15,
    PPC_REG_Q16,
    PPC_REG_Q17,
    PPC_REG_Q18,
    PPC_REG_Q19,
    PPC_REG_Q20,
    PPC_REG_Q21,
    PPC_REG_Q22,
    PPC_REG_Q23,
    PPC_REG_Q24,
    PPC_REG_Q25,
    PPC_REG_Q26,
    PPC_REG_Q27,
    PPC_REG_Q28,
    PPC_REG_Q29,
    PPC_REG_Q30,
    PPC_REG_Q31,

    // extra registers for PPCMapping.c
    PPC_REG_RM,
    PPC_REG_CTR8,
    PPC_REG_LR8,
    PPC_REG_CR1EQ,
    PPC_REG_X2,

    PPC_REG_ENDING,   // <-- mark the end of the list of registers
} ppc_reg;

// Instruction's operand referring to memory
// This is associated with PPC_OP_MEM operand type above
typedef struct ppc_op_mem
{
    ppc_reg base;   // base register
    int32_t disp;   // displacement/offset value
} ppc_op_mem;

typedef struct ppc_op_crx
{
    unsigned int scale;
    ppc_reg reg;
    ppc_bc cond;
} ppc_op_crx;

// Instruction operand
typedef struct cs_ppc_op
{
    ppc_op_type type;   // operand type
    union
    {
        ppc_reg reg;    // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        ppc_op_mem mem;     // base/disp value for MEM operand
        ppc_op_crx crx;     // operand with condition register
    };
} cs_ppc_op;

// Instruction structure
typedef struct cs_ppc
{
    // branch code for branch instructions
    ppc_bc bc;

    // branch hint for branch instructions
    ppc_bh bh;

    // if update_cr0 = True, then this 'dot' insn updates CR0
    bool update_cr0;

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_ppc_op operands[8]; // operands for this instruction.
} cs_ppc;

//> PPC instruction
typedef enum ppc_insn
{
    PPC_INS_INVALID = 0,

    PPC_INS_ADD,
    PPC_INS_ADDC,
    PPC_INS_ADDE,
    PPC_INS_ADDI,
    PPC_INS_ADDIC,
    PPC_INS_ADDIS,
    PPC_INS_ADDME,
    PPC_INS_ADDZE,
    PPC_INS_AND,
    PPC_INS_ANDC,
    PPC_INS_ANDIS,
    PPC_INS_ANDI,
    PPC_INS_ATTN,
    PPC_INS_B,
    PPC_INS_BA,
    PPC_INS_BC,
    PPC_INS_BCCTR,
    PPC_INS_BCCTRL,
    PPC_INS_BCL,
    PPC_INS_BCLR,
    PPC_INS_BCLRL,
    PPC_INS_BCTR,
    PPC_INS_BCTRL,
    PPC_INS_BCT,
    PPC_INS_BDNZ,
    PPC_INS_BDNZA,
    PPC_INS_BDNZL,
    PPC_INS_BDNZLA,
    PPC_INS_BDNZLR,
    PPC_INS_BDNZLRL,
    PPC_INS_BDZ,
    PPC_INS_BDZA,
    PPC_INS_BDZL,
    PPC_INS_BDZLA,
    PPC_INS_BDZLR,
    PPC_INS_BDZLRL,
    PPC_INS_BL,
    PPC_INS_BLA,
    PPC_INS_BLR,
    PPC_INS_BLRL,
    PPC_INS_BRINC,
    PPC_INS_CMPB,
    PPC_INS_CMPD,
    PPC_INS_CMPDI,
    PPC_INS_CMPLD,
    PPC_INS_CMPLDI,
    PPC_INS_CMPLW,
    PPC_INS_CMPLWI,
    PPC_INS_CMPW,
    PPC_INS_CMPWI,
    PPC_INS_CNTLZD,
    PPC_INS_CNTLZW,
    PPC_INS_CREQV,
    PPC_INS_CRXOR,
    PPC_INS_CRAND,
    PPC_INS_CRANDC,
    PPC_INS_CRNAND,
    PPC_INS_CRNOR,
    PPC_INS_CROR,
    PPC_INS_CRORC,
    PPC_INS_DCBA,
    PPC_INS_DCBF,
    PPC_INS_DCBI,
    PPC_INS_DCBST,
    PPC_INS_DCBT,
    PPC_INS_DCBTST,
    PPC_INS_DCBZ,
    PPC_INS_DCBZL,
    PPC_INS_DCCCI,
    PPC_INS_DIVD,
    PPC_INS_DIVDU,
    PPC_INS_DIVW,
    PPC_INS_DIVWU,
    PPC_INS_DSS,
    PPC_INS_DSSALL,
    PPC_INS_DST,
    PPC_INS_DSTST,
    PPC_INS_DSTSTT,
    PPC_INS_DSTT,
    PPC_INS_EQV,
    PPC_INS_EVABS,
    PPC_INS_EVADDIW,
    PPC_INS_EVADDSMIAAW,
    PPC_INS_EVADDSSIAAW,
    PPC_INS_EVADDUMIAAW,
    PPC_INS_EVADDUSIAAW,
    PPC_INS_EVADDW,
    PPC_INS_EVAND,
    PPC_INS_EVANDC,
    PPC_INS_EVCMPEQ,
    PPC_INS_EVCMPGTS,
    PPC_INS_EVCMPGTU,
    PPC_INS_EVCMPLTS,
    PPC_INS_EVCMPLTU,
    PPC_INS_EVCNTLSW,
    PPC_INS_EVCNTLZW,
    PPC_INS_EVDIVWS,
    PPC_INS_EVDIVWU,
    PPC_INS_EVEQV,
    PPC_INS_EVEXTSB,
    PPC_INS_EVEXTSH,
    PPC_INS_EVLDD,
    PPC_INS_EVLDDX,
    PPC_INS_EVLDH,
    PPC_INS_EVLDHX,
    PPC_INS_EVLDW,
    PPC_INS_EVLDWX,
    PPC_INS_EVLHHESPLAT,
    PPC_INS_EVLHHESPLATX,
    PPC_INS_EVLHHOSSPLAT,
    PPC_INS_EVLHHOSSPLATX,
    PPC_INS_EVLHHOUSPLAT,
    PPC_INS_EVLHHOUSPLATX,
    PPC_INS_EVLWHE,
    PPC_INS_EVLWHEX,
    PPC_INS_EVLWHOS,
    PPC_INS_EVLWHOSX,
    PPC_INS_EVLWHOU,
    PPC_INS_EVLWHOUX,
    PPC_INS_EVLWHSPLAT,
    PPC_INS_EVLWHSPLATX,
    PPC_INS_EVLWWSPLAT,
    PPC_INS_EVLWWSPLATX,
    PPC_INS_EVMERGEHI,
    PPC_INS_EVMERGEHILO,
    PPC_INS_EVMERGELO,
    PPC_INS_EVMERGELOHI,
    PPC_INS_EVMHEGSMFAA,
    PPC_INS_EVMHEGSMFAN,
    PPC_INS_EVMHEGSMIAA,
    PPC_INS_EVMHEGSMIAN,
    PPC_INS_EVMHEGUMIAA,
    PPC_INS_EVMHEGUMIAN,
    PPC_INS_EVMHESMF,
    PPC_INS_EVMHESMFA,
    PPC_INS_EVMHESMFAAW,
    PPC_INS_EVMHESMFANW,
    PPC_INS_EVMHESMI,
    PPC_INS_EVMHESMIA,
    PPC_INS_EVMHESMIAAW,
    PPC_INS_EVMHESMIANW,
    PPC_INS_EVMHESSF,
    PPC_INS_EVMHESSFA,
    PPC_INS_EVMHESSFAAW,
    PPC_INS_EVMHESSFANW,
    PPC_INS_EVMHESSIAAW,
    PPC_INS_EVMHESSIANW,
    PPC_INS_EVMHEUMI,
    PPC_INS_EVMHEUMIA,
    PPC_INS_EVMHEUMIAAW,
    PPC_INS_EVMHEUMIANW,
    PPC_INS_EVMHEUSIAAW,
    PPC_INS_EVMHEUSIANW,
    PPC_INS_EVMHOGSMFAA,
    PPC_INS_EVMHOGSMFAN,
    PPC_INS_EVMHOGSMIAA,
    PPC_INS_EVMHOGSMIAN,
    PPC_INS_EVMHOGUMIAA,
    PPC_INS_EVMHOGUMIAN,
    PPC_INS_EVMHOSMF,
    PPC_INS_EVMHOSMFA,
    PPC_INS_EVMHOSMFAAW,
    PPC_INS_EVMHOSMFANW,
    PPC_INS_EVMHOSMI,
    PPC_INS_EVMHOSMIA,
    PPC_INS_EVMHOSMIAAW,
    PPC_INS_EVMHOSMIANW,
    PPC_INS_EVMHOSSF,
    PPC_INS_EVMHOSSFA,
    PPC_INS_EVMHOSSFAAW,
    PPC_INS_EVMHOSSFANW,
    PPC_INS_EVMHOSSIAAW,
    PPC_INS_EVMHOSSIANW,
    PPC_INS_EVMHOUMI,
    PPC_INS_EVMHOUMIA,
    PPC_INS_EVMHOUMIAAW,
    PPC_INS_EVMHOUMIANW,
    PPC_INS_EVMHOUSIAAW,
    PPC_INS_EVMHOUSIANW,
    PPC_INS_EVMRA,
    PPC_INS_EVMWHSMF,
    PPC_INS_EVMWHSMFA,
    PPC_INS_EVMWHSMI,
    PPC_INS_EVMWHSMIA,
    PPC_INS_EVMWHSSF,
    PPC_INS_EVMWHSSFA,
    PPC_INS_EVMWHUMI,
    PPC_INS_EVMWHUMIA,
    PPC_INS_EVMWLSMIAAW,
    PPC_INS_EVMWLSMIANW,
    PPC_INS_EVMWLSSIAAW,
    PPC_INS_EVMWLSSIANW,
    PPC_INS_EVMWLUMI,
    PPC_INS_EVMWLUMIA,
    PPC_INS_EVMWLUMIAAW,
    PPC_INS_EVMWLUMIANW,
    PPC_INS_EVMWLUSIAAW,
    PPC_INS_EVMWLUSIANW,
    PPC_INS_EVMWSMF,
    PPC_INS_EVMWSMFA,
    PPC_INS_EVMWSMFAA,
    PPC_INS_EVMWSMFAN,
    PPC_INS_EVMWSMI,
    PPC_INS_EVMWSMIA,
    PPC_INS_EVMWSMIAA,
    PPC_INS_EVMWSMIAN,
    PPC_INS_EVMWSSF,
    PPC_INS_EVMWSSFA,
    PPC_INS_EVMWSSFAA,
    PPC_INS_EVMWSSFAN,
    PPC_INS_EVMWUMI,
    PPC_INS_EVMWUMIA,
    PPC_INS_EVMWUMIAA,
    PPC_INS_EVMWUMIAN,
    PPC_INS_EVNAND,
    PPC_INS_EVNEG,
    PPC_INS_EVNOR,
    PPC_INS_EVOR,
    PPC_INS_EVORC,
    PPC_INS_EVRLW,
    PPC_INS_EVRLWI,
    PPC_INS_EVRNDW,
    PPC_INS_EVSLW,
    PPC_INS_EVSLWI,
    PPC_INS_EVSPLATFI,
    PPC_INS_EVSPLATI,
    PPC_INS_EVSRWIS,
    PPC_INS_EVSRWIU,
    PPC_INS_EVSRWS,
    PPC_INS_EVSRWU,
    PPC_INS_EVSTDD,
    PPC_INS_EVSTDDX,
    PPC_INS_EVSTDH,
    PPC_INS_EVSTDHX,
    PPC_INS_EVSTDW,
    PPC_INS_EVSTDWX,
    PPC_INS_EVSTWHE,
    PPC_INS_EVSTWHEX,
    PPC_INS_EVSTWHO,
    PPC_INS_EVSTWHOX,
    PPC_INS_EVSTWWE,
    PPC_INS_EVSTWWEX,
    PPC_INS_EVSTWWO,
    PPC_INS_EVSTWWOX,
    PPC_INS_EVSUBFSMIAAW,
    PPC_INS_EVSUBFSSIAAW,
    PPC_INS_EVSUBFUMIAAW,
    PPC_INS_EVSUBFUSIAAW,
    PPC_INS_EVSUBFW,
    PPC_INS_EVSUBIFW,
    PPC_INS_EVXOR,
    PPC_INS_EXTSB,
    PPC_INS_EXTSH,
    PPC_INS_EXTSW,
    PPC_INS_EIEIO,
    PPC_INS_FABS,
    PPC_INS_FADD,
    PPC_INS_FADDS,
    PPC_INS_FCFID,
    PPC_INS_FCFIDS,
    PPC_INS_FCFIDU,
    PPC_INS_FCFIDUS,
    PPC_INS_FCMPU,
    PPC_INS_FCPSGN,
    PPC_INS_FCTID,
    PPC_INS_FCTIDUZ,
    PPC_INS_FCTIDZ,
    PPC_INS_FCTIW,
    PPC_INS_FCTIWUZ,
    PPC_INS_FCTIWZ,
    PPC_INS_FDIV,
    PPC_INS_FDIVS,
    PPC_INS_FMADD,
    PPC_INS_FMADDS,
    PPC_INS_FMR,
    PPC_INS_FMSUB,
    PPC_INS_FMSUBS,
    PPC_INS_FMUL,
    PPC_INS_FMULS,
    PPC_INS_FNABS,
    PPC_INS_FNEG,
    PPC_INS_FNMADD,
    PPC_INS_FNMADDS,
    PPC_INS_FNMSUB,
    PPC_INS_FNMSUBS,
    PPC_INS_FRE,
    PPC_INS_FRES,
    PPC_INS_FRIM,
    PPC_INS_FRIN,
    PPC_INS_FRIP,
    PPC_INS_FRIZ,
    PPC_INS_FRSP,
    PPC_INS_FRSQRTE,
    PPC_INS_FRSQRTES,
    PPC_INS_FSEL,
    PPC_INS_FSQRT,
    PPC_INS_FSQRTS,
    PPC_INS_FSUB,
    PPC_INS_FSUBS,
    PPC_INS_ICBI,
    PPC_INS_ICBT,
    PPC_INS_ICCCI,
    PPC_INS_ISEL,
    PPC_INS_ISYNC,
    PPC_INS_LA,
    PPC_INS_LBZ,
    PPC_INS_LBZCIX,
    PPC_INS_LBZU,
    PPC_INS_LBZUX,
    PPC_INS_LBZX,
    PPC_INS_LD,
    PPC_INS_LDARX,
    PPC_INS_LDBRX,
    PPC_INS_LDCIX,
    PPC_INS_LDU,
    PPC_INS_LDUX,
    PPC_INS_LDX,
    PPC_INS_LFD,
    PPC_INS_LFDU,
    PPC_INS_LFDUX,
    PPC_INS_LFDX,
    PPC_INS_LFIWAX,
    PPC_INS_LFIWZX,
    PPC_INS_LFS,
    PPC_INS_LFSU,
    PPC_INS_LFSUX,
    PPC_INS_LFSX,
    PPC_INS_LHA,
    PPC_INS_LHAU,
    PPC_INS_LHAUX,
    PPC_INS_LHAX,
    PPC_INS_LHBRX,
    PPC_INS_LHZ,
    PPC_INS_LHZCIX,
    PPC_INS_LHZU,
    PPC_INS_LHZUX,
    PPC_INS_LHZX,
    PPC_INS_LI,
    PPC_INS_LIS,
    PPC_INS_LMW,
    PPC_INS_LSWI,
    PPC_INS_LVEBX,
    PPC_INS_LVEHX,
    PPC_INS_LVEWX,
    PPC_INS_LVSL,
    PPC_INS_LVSR,
    PPC_INS_LVX,
    PPC_INS_LVXL,
    PPC_INS_LWA,
    PPC_INS_LWARX,
    PPC_INS_LWAUX,
    PPC_INS_LWAX,
    PPC_INS_LWBRX,
    PPC_INS_LWZ,
    PPC_INS_LWZCIX,
    PPC_INS_LWZU,
    PPC_INS_LWZUX,
    PPC_INS_LWZX,
    PPC_INS_LXSDX,
    PPC_INS_LXVD2X,
    PPC_INS_LXVDSX,
    PPC_INS_LXVW4X,
    PPC_INS_MBAR,
    PPC_INS_MCRF,
    PPC_INS_MCRFS,
    PPC_INS_MFCR,
    PPC_INS_MFCTR,
    PPC_INS_MFDCR,
    PPC_INS_MFFS,
    PPC_INS_MFLR,
    PPC_INS_MFMSR,
    PPC_INS_MFOCRF,
    PPC_INS_MFSPR,
    PPC_INS_MFSR,
    PPC_INS_MFSRIN,
    PPC_INS_MFTB,
    PPC_INS_MFVSCR,
    PPC_INS_MSYNC,
    PPC_INS_MTCRF,
    PPC_INS_MTCTR,
    PPC_INS_MTDCR,
    PPC_INS_MTFSB0,
    PPC_INS_MTFSB1,
    PPC_INS_MTFSF,
    PPC_INS_MTFSFI,
    PPC_INS_MTLR,
    PPC_INS_MTMSR,
    PPC_INS_MTMSRD,
    PPC_INS_MTOCRF,
    PPC_INS_MTSPR,
    PPC_INS_MTSR,
    PPC_INS_MTSRIN,
    PPC_INS_MTVSCR,
    PPC_INS_MULHD,
    PPC_INS_MULHDU,
    PPC_INS_MULHW,
    PPC_INS_MULHWU,
    PPC_INS_MULLD,
    PPC_INS_MULLI,
    PPC_INS_MULLW,
    PPC_INS_NAND,
    PPC_INS_NEG,
    PPC_INS_NOP,
    PPC_INS_ORI,
    PPC_INS_NOR,
    PPC_INS_OR,
    PPC_INS_ORC,
    PPC_INS_ORIS,
    PPC_INS_POPCNTD,
    PPC_INS_POPCNTW,
    PPC_INS_QVALIGNI,
    PPC_INS_QVESPLATI,
    PPC_INS_QVFABS,
    PPC_INS_QVFADD,
    PPC_INS_QVFADDS,
    PPC_INS_QVFCFID,
    PPC_INS_QVFCFIDS,
    PPC_INS_QVFCFIDU,
    PPC_INS_QVFCFIDUS,
    PPC_INS_QVFCMPEQ,
    PPC_INS_QVFCMPGT,
    PPC_INS_QVFCMPLT,
    PPC_INS_QVFCPSGN,
    PPC_INS_QVFCTID,
    PPC_INS_QVFCTIDU,
    PPC_INS_QVFCTIDUZ,
    PPC_INS_QVFCTIDZ,
    PPC_INS_QVFCTIW,
    PPC_INS_QVFCTIWU,
    PPC_INS_QVFCTIWUZ,
    PPC_INS_QVFCTIWZ,
    PPC_INS_QVFLOGICAL,
    PPC_INS_QVFMADD,
    PPC_INS_QVFMADDS,
    PPC_INS_QVFMR,
    PPC_INS_QVFMSUB,
    PPC_INS_QVFMSUBS,
    PPC_INS_QVFMUL,
    PPC_INS_QVFMULS,
    PPC_INS_QVFNABS,
    PPC_INS_QVFNEG,
    PPC_INS_QVFNMADD,
    PPC_INS_QVFNMADDS,
    PPC_INS_QVFNMSUB,
    PPC_INS_QVFNMSUBS,
    PPC_INS_QVFPERM,
    PPC_INS_QVFRE,
    PPC_INS_QVFRES,
    PPC_INS_QVFRIM,
    PPC_INS_QVFRIN,
    PPC_INS_QVFRIP,
    PPC_INS_QVFRIZ,
    PPC_INS_QVFRSP,
    PPC_INS_QVFRSQRTE,
    PPC_INS_QVFRSQRTES,
    PPC_INS_QVFSEL,
    PPC_INS_QVFSUB,
    PPC_INS_QVFSUBS,
    PPC_INS_QVFTSTNAN,
    PPC_INS_QVFXMADD,
    PPC_INS_QVFXMADDS,
    PPC_INS_QVFXMUL,
    PPC_INS_QVFXMULS,
    PPC_INS_QVFXXCPNMADD,
    PPC_INS_QVFXXCPNMADDS,
    PPC_INS_QVFXXMADD,
    PPC_INS_QVFXXMADDS,
    PPC_INS_QVFXXNPMADD,
    PPC_INS_QVFXXNPMADDS,
    PPC_INS_QVGPCI,
    PPC_INS_QVLFCDUX,
    PPC_INS_QVLFCDUXA,
    PPC_INS_QVLFCDX,
    PPC_INS_QVLFCDXA,
    PPC_INS_QVLFCSUX,
    PPC_INS_QVLFCSUXA,
    PPC_INS_QVLFCSX,
    PPC_INS_QVLFCSXA,
    PPC_INS_QVLFDUX,
    PPC_INS_QVLFDUXA,
    PPC_INS_QVLFDX,
    PPC_INS_QVLFDXA,
    PPC_INS_QVLFIWAX,
    PPC_INS_QVLFIWAXA,
    PPC_INS_QVLFIWZX,
    PPC_INS_QVLFIWZXA,
    PPC_INS_QVLFSUX,
    PPC_INS_QVLFSUXA,
    PPC_INS_QVLFSX,
    PPC_INS_QVLFSXA,
    PPC_INS_QVLPCLDX,
    PPC_INS_QVLPCLSX,
    PPC_INS_QVLPCRDX,
    PPC_INS_QVLPCRSX,
    PPC_INS_QVSTFCDUX,
    PPC_INS_QVSTFCDUXA,
    PPC_INS_QVSTFCDUXI,
    PPC_INS_QVSTFCDUXIA,
    PPC_INS_QVSTFCDX,
    PPC_INS_QVSTFCDXA,
    PPC_INS_QVSTFCDXI,
    PPC_INS_QVSTFCDXIA,
    PPC_INS_QVSTFCSUX,
    PPC_INS_QVSTFCSUXA,
    PPC_INS_QVSTFCSUXI,
    PPC_INS_QVSTFCSUXIA,
    PPC_INS_QVSTFCSX,
    PPC_INS_QVSTFCSXA,
    PPC_INS_QVSTFCSXI,
    PPC_INS_QVSTFCSXIA,
    PPC_INS_QVSTFDUX,
    PPC_INS_QVSTFDUXA,
    PPC_INS_QVSTFDUXI,
    PPC_INS_QVSTFDUXIA,
    PPC_INS_QVSTFDX,
    PPC_INS_QVSTFDXA,
    PPC_INS_QVSTFDXI,
    PPC_INS_QVSTFDXIA,
    PPC_INS_QVSTFIWX,
    PPC_INS_QVSTFIWXA,
    PPC_INS_QVSTFSUX,
    PPC_INS_QVSTFSUXA,
    PPC_INS_QVSTFSUXI,
    PPC_INS_QVSTFSUXIA,
    PPC_INS_QVSTFSX,
    PPC_INS_QVSTFSXA,
    PPC_INS_QVSTFSXI,
    PPC_INS_QVSTFSXIA,
    PPC_INS_RFCI,
    PPC_INS_RFDI,
    PPC_INS_RFI,
    PPC_INS_RFID,
    PPC_INS_RFMCI,
    PPC_INS_RLDCL,
    PPC_INS_RLDCR,
    PPC_INS_RLDIC,
    PPC_INS_RLDICL,
    PPC_INS_RLDICR,
    PPC_INS_RLDIMI,
    PPC_INS_RLWIMI,
    PPC_INS_RLWINM,
    PPC_INS_RLWNM,
    PPC_INS_SC,
    PPC_INS_SLBIA,
    PPC_INS_SLBIE,
    PPC_INS_SLBMFEE,
    PPC_INS_SLBMTE,
    PPC_INS_SLD,
    PPC_INS_SLW,
    PPC_INS_SRAD,
    PPC_INS_SRADI,
    PPC_INS_SRAW,
    PPC_INS_SRAWI,
    PPC_INS_SRD,
    PPC_INS_SRW,
    PPC_INS_STB,
    PPC_INS_STBCIX,
    PPC_INS_STBU,
    PPC_INS_STBUX,
    PPC_INS_STBX,
    PPC_INS_STD,
    PPC_INS_STDBRX,
    PPC_INS_STDCIX,
    PPC_INS_STDCX,
    PPC_INS_STDU,
    PPC_INS_STDUX,
    PPC_INS_STDX,
    PPC_INS_STFD,
    PPC_INS_STFDU,
    PPC_INS_STFDUX,
    PPC_INS_STFDX,
    PPC_INS_STFIWX,
    PPC_INS_STFS,
    PPC_INS_STFSU,
    PPC_INS_STFSUX,
    PPC_INS_STFSX,
    PPC_INS_STH,
    PPC_INS_STHBRX,
    PPC_INS_STHCIX,
    PPC_INS_STHU,
    PPC_INS_STHUX,
    PPC_INS_STHX,
    PPC_INS_STMW,
    PPC_INS_STSWI,
    PPC_INS_STVEBX,
    PPC_INS_STVEHX,
    PPC_INS_STVEWX,
    PPC_INS_STVX,
    PPC_INS_STVXL,
    PPC_INS_STW,
    PPC_INS_STWBRX,
    PPC_INS_STWCIX,
    PPC_INS_STWCX,
    PPC_INS_STWU,
    PPC_INS_STWUX,
    PPC_INS_STWX,
    PPC_INS_STXSDX,
    PPC_INS_STXVD2X,
    PPC_INS_STXVW4X,
    PPC_INS_SUBF,
    PPC_INS_SUBFC,
    PPC_INS_SUBFE,
    PPC_INS_SUBFIC,
    PPC_INS_SUBFME,
    PPC_INS_SUBFZE,
    PPC_INS_SYNC,
    PPC_INS_TD,
    PPC_INS_TDI,
    PPC_INS_TLBIA,
    PPC_INS_TLBIE,
    PPC_INS_TLBIEL,
    PPC_INS_TLBIVAX,
    PPC_INS_TLBLD,
    PPC_INS_TLBLI,
    PPC_INS_TLBRE,
    PPC_INS_TLBSX,
    PPC_INS_TLBSYNC,
    PPC_INS_TLBWE,
    PPC_INS_TRAP,
    PPC_INS_TW,
    PPC_INS_TWI,
    PPC_INS_VADDCUW,
    PPC_INS_VADDFP,
    PPC_INS_VADDSBS,
    PPC_INS_VADDSHS,
    PPC_INS_VADDSWS,
    PPC_INS_VADDUBM,
    PPC_INS_VADDUBS,
    PPC_INS_VADDUDM,
    PPC_INS_VADDUHM,
    PPC_INS_VADDUHS,
    PPC_INS_VADDUWM,
    PPC_INS_VADDUWS,
    PPC_INS_VAND,
    PPC_INS_VANDC,
    PPC_INS_VAVGSB,
    PPC_INS_VAVGSH,
    PPC_INS_VAVGSW,
    PPC_INS_VAVGUB,
    PPC_INS_VAVGUH,
    PPC_INS_VAVGUW,
    PPC_INS_VCFSX,
    PPC_INS_VCFUX,
    PPC_INS_VCLZB,
    PPC_INS_VCLZD,
    PPC_INS_VCLZH,
    PPC_INS_VCLZW,
    PPC_INS_VCMPBFP,
    PPC_INS_VCMPEQFP,
    PPC_INS_VCMPEQUB,
    PPC_INS_VCMPEQUD,
    PPC_INS_VCMPEQUH,
    PPC_INS_VCMPEQUW,
    PPC_INS_VCMPGEFP,
    PPC_INS_VCMPGTFP,
    PPC_INS_VCMPGTSB,
    PPC_INS_VCMPGTSD,
    PPC_INS_VCMPGTSH,
    PPC_INS_VCMPGTSW,
    PPC_INS_VCMPGTUB,
    PPC_INS_VCMPGTUD,
    PPC_INS_VCMPGTUH,
    PPC_INS_VCMPGTUW,
    PPC_INS_VCTSXS,
    PPC_INS_VCTUXS,
    PPC_INS_VEQV,
    PPC_INS_VEXPTEFP,
    PPC_INS_VLOGEFP,
    PPC_INS_VMADDFP,
    PPC_INS_VMAXFP,
    PPC_INS_VMAXSB,
    PPC_INS_VMAXSD,
    PPC_INS_VMAXSH,
    PPC_INS_VMAXSW,
    PPC_INS_VMAXUB,
    PPC_INS_VMAXUD,
    PPC_INS_VMAXUH,
    PPC_INS_VMAXUW,
    PPC_INS_VMHADDSHS,
    PPC_INS_VMHRADDSHS,
    PPC_INS_VMINUD,
    PPC_INS_VMINFP,
    PPC_INS_VMINSB,
    PPC_INS_VMINSD,
    PPC_INS_VMINSH,
    PPC_INS_VMINSW,
    PPC_INS_VMINUB,
    PPC_INS_VMINUH,
    PPC_INS_VMINUW,
    PPC_INS_VMLADDUHM,
    PPC_INS_VMRGHB,
    PPC_INS_VMRGHH,
    PPC_INS_VMRGHW,
    PPC_INS_VMRGLB,
    PPC_INS_VMRGLH,
    PPC_INS_VMRGLW,
    PPC_INS_VMSUMMBM,
    PPC_INS_VMSUMSHM,
    PPC_INS_VMSUMSHS,
    PPC_INS_VMSUMUBM,
    PPC_INS_VMSUMUHM,
    PPC_INS_VMSUMUHS,
    PPC_INS_VMULESB,
    PPC_INS_VMULESH,
    PPC_INS_VMULESW,
    PPC_INS_VMULEUB,
    PPC_INS_VMULEUH,
    PPC_INS_VMULEUW,
    PPC_INS_VMULOSB,
    PPC_INS_VMULOSH,
    PPC_INS_VMULOSW,
    PPC_INS_VMULOUB,
    PPC_INS_VMULOUH,
    PPC_INS_VMULOUW,
    PPC_INS_VMULUWM,
    PPC_INS_VNAND,
    PPC_INS_VNMSUBFP,
    PPC_INS_VNOR,
    PPC_INS_VOR,
    PPC_INS_VORC,
    PPC_INS_VPERM,
    PPC_INS_VPKPX,
    PPC_INS_VPKSHSS,
    PPC_INS_VPKSHUS,
    PPC_INS_VPKSWSS,
    PPC_INS_VPKSWUS,
    PPC_INS_VPKUHUM,
    PPC_INS_VPKUHUS,
    PPC_INS_VPKUWUM,
    PPC_INS_VPKUWUS,
    PPC_INS_VPOPCNTB,
    PPC_INS_VPOPCNTD,
    PPC_INS_VPOPCNTH,
    PPC_INS_VPOPCNTW,
    PPC_INS_VREFP,
    PPC_INS_VRFIM,
    PPC_INS_VRFIN,
    PPC_INS_VRFIP,
    PPC_INS_VRFIZ,
    PPC_INS_VRLB,
    PPC_INS_VRLD,
    PPC_INS_VRLH,
    PPC_INS_VRLW,
    PPC_INS_VRSQRTEFP,
    PPC_INS_VSEL,
    PPC_INS_VSL,
    PPC_INS_VSLB,
    PPC_INS_VSLD,
    PPC_INS_VSLDOI,
    PPC_INS_VSLH,
    PPC_INS_VSLO,
    PPC_INS_VSLW,
    PPC_INS_VSPLTB,
    PPC_INS_VSPLTH,
    PPC_INS_VSPLTISB,
    PPC_INS_VSPLTISH,
    PPC_INS_VSPLTISW,
    PPC_INS_VSPLTW,
    PPC_INS_VSR,
    PPC_INS_VSRAB,
    PPC_INS_VSRAD,
    PPC_INS_VSRAH,
    PPC_INS_VSRAW,
    PPC_INS_VSRB,
    PPC_INS_VSRD,
    PPC_INS_VSRH,
    PPC_INS_VSRO,
    PPC_INS_VSRW,
    PPC_INS_VSUBCUW,
    PPC_INS_VSUBFP,
    PPC_INS_VSUBSBS,
    PPC_INS_VSUBSHS,
    PPC_INS_VSUBSWS,
    PPC_INS_VSUBUBM,
    PPC_INS_VSUBUBS,
    PPC_INS_VSUBUDM,
    PPC_INS_VSUBUHM,
    PPC_INS_VSUBUHS,
    PPC_INS_VSUBUWM,
    PPC_INS_VSUBUWS,
    PPC_INS_VSUM2SWS,
    PPC_INS_VSUM4SBS,
    PPC_INS_VSUM4SHS,
    PPC_INS_VSUM4UBS,
    PPC_INS_VSUMSWS,
    PPC_INS_VUPKHPX,
    PPC_INS_VUPKHSB,
    PPC_INS_VUPKHSH,
    PPC_INS_VUPKLPX,
    PPC_INS_VUPKLSB,
    PPC_INS_VUPKLSH,
    PPC_INS_VXOR,
    PPC_INS_WAIT,
    PPC_INS_WRTEE,
    PPC_INS_WRTEEI,
    PPC_INS_XOR,
    PPC_INS_XORI,
    PPC_INS_XORIS,
    PPC_INS_XSABSDP,
    PPC_INS_XSADDDP,
    PPC_INS_XSCMPODP,
    PPC_INS_XSCMPUDP,
    PPC_INS_XSCPSGNDP,
    PPC_INS_XSCVDPSP,
    PPC_INS_XSCVDPSXDS,
    PPC_INS_XSCVDPSXWS,
    PPC_INS_XSCVDPUXDS,
    PPC_INS_XSCVDPUXWS,
    PPC_INS_XSCVSPDP,
    PPC_INS_XSCVSXDDP,
    PPC_INS_XSCVUXDDP,
    PPC_INS_XSDIVDP,
    PPC_INS_XSMADDADP,
    PPC_INS_XSMADDMDP,
    PPC_INS_XSMAXDP,
    PPC_INS_XSMINDP,
    PPC_INS_XSMSUBADP,
    PPC_INS_XSMSUBMDP,
    PPC_INS_XSMULDP,
    PPC_INS_XSNABSDP,
    PPC_INS_XSNEGDP,
    PPC_INS_XSNMADDADP,
    PPC_INS_XSNMADDMDP,
    PPC_INS_XSNMSUBADP,
    PPC_INS_XSNMSUBMDP,
    PPC_INS_XSRDPI,
    PPC_INS_XSRDPIC,
    PPC_INS_XSRDPIM,
    PPC_INS_XSRDPIP,
    PPC_INS_XSRDPIZ,
    PPC_INS_XSREDP,
    PPC_INS_XSRSQRTEDP,
    PPC_INS_XSSQRTDP,
    PPC_INS_XSSUBDP,
    PPC_INS_XSTDIVDP,
    PPC_INS_XSTSQRTDP,
    PPC_INS_XVABSDP,
    PPC_INS_XVABSSP,
    PPC_INS_XVADDDP,
    PPC_INS_XVADDSP,
    PPC_INS_XVCMPEQDP,
    PPC_INS_XVCMPEQSP,
    PPC_INS_XVCMPGEDP,
    PPC_INS_XVCMPGESP,
    PPC_INS_XVCMPGTDP,
    PPC_INS_XVCMPGTSP,
    PPC_INS_XVCPSGNDP,
    PPC_INS_XVCPSGNSP,
    PPC_INS_XVCVDPSP,
    PPC_INS_XVCVDPSXDS,
    PPC_INS_XVCVDPSXWS,
    PPC_INS_XVCVDPUXDS,
    PPC_INS_XVCVDPUXWS,
    PPC_INS_XVCVSPDP,
    PPC_INS_XVCVSPSXDS,
    PPC_INS_XVCVSPSXWS,
    PPC_INS_XVCVSPUXDS,
    PPC_INS_XVCVSPUXWS,
    PPC_INS_XVCVSXDDP,
    PPC_INS_XVCVSXDSP,
    PPC_INS_XVCVSXWDP,
    PPC_INS_XVCVSXWSP,
    PPC_INS_XVCVUXDDP,
    PPC_INS_XVCVUXDSP,
    PPC_INS_XVCVUXWDP,
    PPC_INS_XVCVUXWSP,
    PPC_INS_XVDIVDP,
    PPC_INS_XVDIVSP,
    PPC_INS_XVMADDADP,
    PPC_INS_XVMADDASP,
    PPC_INS_XVMADDMDP,
    PPC_INS_XVMADDMSP,
    PPC_INS_XVMAXDP,
    PPC_INS_XVMAXSP,
    PPC_INS_XVMINDP,
    PPC_INS_XVMINSP,
    PPC_INS_XVMSUBADP,
    PPC_INS_XVMSUBASP,
    PPC_INS_XVMSUBMDP,
    PPC_INS_XVMSUBMSP,
    PPC_INS_XVMULDP,
    PPC_INS_XVMULSP,
    PPC_INS_XVNABSDP,
    PPC_INS_XVNABSSP,
    PPC_INS_XVNEGDP,
    PPC_INS_XVNEGSP,
    PPC_INS_XVNMADDADP,
    PPC_INS_XVNMADDASP,
    PPC_INS_XVNMADDMDP,
    PPC_INS_XVNMADDMSP,
    PPC_INS_XVNMSUBADP,
    PPC_INS_XVNMSUBASP,
    PPC_INS_XVNMSUBMDP,
    PPC_INS_XVNMSUBMSP,
    PPC_INS_XVRDPI,
    PPC_INS_XVRDPIC,
    PPC_INS_XVRDPIM,
    PPC_INS_XVRDPIP,
    PPC_INS_XVRDPIZ,
    PPC_INS_XVREDP,
    PPC_INS_XVRESP,
    PPC_INS_XVRSPI,
    PPC_INS_XVRSPIC,
    PPC_INS_XVRSPIM,
    PPC_INS_XVRSPIP,
    PPC_INS_XVRSPIZ,
    PPC_INS_XVRSQRTEDP,
    PPC_INS_XVRSQRTESP,
    PPC_INS_XVSQRTDP,
    PPC_INS_XVSQRTSP,
    PPC_INS_XVSUBDP,
    PPC_INS_XVSUBSP,
    PPC_INS_XVTDIVDP,
    PPC_INS_XVTDIVSP,
    PPC_INS_XVTSQRTDP,
    PPC_INS_XVTSQRTSP,
    PPC_INS_XXLAND,
    PPC_INS_XXLANDC,
    PPC_INS_XXLEQV,
    PPC_INS_XXLNAND,
    PPC_INS_XXLNOR,
    PPC_INS_XXLOR,
    PPC_INS_XXLORC,
    PPC_INS_XXLXOR,
    PPC_INS_XXMRGHW,
    PPC_INS_XXMRGLW,
    PPC_INS_XXPERMDI,
    PPC_INS_XXSEL,
    PPC_INS_XXSLDWI,
    PPC_INS_XXSPLTW,
    PPC_INS_BCA,
    PPC_INS_BCLA,

    // extra & alias instructions
    PPC_INS_SLWI,
    PPC_INS_SRWI,
    PPC_INS_SLDI,

    PPC_INS_BTA,
    PPC_INS_CRSET,
    PPC_INS_CRNOT,
    PPC_INS_CRMOVE,
    PPC_INS_CRCLR,
    PPC_INS_MFBR0,
    PPC_INS_MFBR1,
    PPC_INS_MFBR2,
    PPC_INS_MFBR3,
    PPC_INS_MFBR4,
    PPC_INS_MFBR5,
    PPC_INS_MFBR6,
    PPC_INS_MFBR7,
    PPC_INS_MFXER,
    PPC_INS_MFRTCU,
    PPC_INS_MFRTCL,
    PPC_INS_MFDSCR,
    PPC_INS_MFDSISR,
    PPC_INS_MFDAR,
    PPC_INS_MFSRR2,
    PPC_INS_MFSRR3,
    PPC_INS_MFCFAR,
    PPC_INS_MFAMR,
    PPC_INS_MFPID,
    PPC_INS_MFTBLO,
    PPC_INS_MFTBHI,
    PPC_INS_MFDBATU,
    PPC_INS_MFDBATL,
    PPC_INS_MFIBATU,
    PPC_INS_MFIBATL,
    PPC_INS_MFDCCR,
    PPC_INS_MFICCR,
    PPC_INS_MFDEAR,
    PPC_INS_MFESR,
    PPC_INS_MFSPEFSCR,
    PPC_INS_MFTCR,
    PPC_INS_MFASR,
    PPC_INS_MFPVR,
    PPC_INS_MFTBU,
    PPC_INS_MTCR,
    PPC_INS_MTBR0,
    PPC_INS_MTBR1,
    PPC_INS_MTBR2,
    PPC_INS_MTBR3,
    PPC_INS_MTBR4,
    PPC_INS_MTBR5,
    PPC_INS_MTBR6,
    PPC_INS_MTBR7,
    PPC_INS_MTXER,
    PPC_INS_MTDSCR,
    PPC_INS_MTDSISR,
    PPC_INS_MTDAR,
    PPC_INS_MTSRR2,
    PPC_INS_MTSRR3,
    PPC_INS_MTCFAR,
    PPC_INS_MTAMR,
    PPC_INS_MTPID,
    PPC_INS_MTTBL,
    PPC_INS_MTTBU,
    PPC_INS_MTTBLO,
    PPC_INS_MTTBHI,
    PPC_INS_MTDBATU,
    PPC_INS_MTDBATL,
    PPC_INS_MTIBATU,
    PPC_INS_MTIBATL,
    PPC_INS_MTDCCR,
    PPC_INS_MTICCR,
    PPC_INS_MTDEAR,
    PPC_INS_MTESR,
    PPC_INS_MTSPEFSCR,
    PPC_INS_MTTCR,
    PPC_INS_NOT,
    PPC_INS_MR,
    PPC_INS_ROTLD,
    PPC_INS_ROTLDI,
    PPC_INS_CLRLDI,
    PPC_INS_ROTLWI,
    PPC_INS_CLRLWI,
    PPC_INS_ROTLW,
    PPC_INS_SUB,
    PPC_INS_SUBC,
    PPC_INS_LWSYNC,
    PPC_INS_PTESYNC,
    PPC_INS_TDLT,
    PPC_INS_TDEQ,
    PPC_INS_TDGT,
    PPC_INS_TDNE,
    PPC_INS_TDLLT,
    PPC_INS_TDLGT,
    PPC_INS_TDU,
    PPC_INS_TDLTI,
    PPC_INS_TDEQI,
    PPC_INS_TDGTI,
    PPC_INS_TDNEI,
    PPC_INS_TDLLTI,
    PPC_INS_TDLGTI,
    PPC_INS_TDUI,
    PPC_INS_TLBREHI,
    PPC_INS_TLBRELO,
    PPC_INS_TLBWEHI,
    PPC_INS_TLBWELO,
    PPC_INS_TWLT,
    PPC_INS_TWEQ,
    PPC_INS_TWGT,
    PPC_INS_TWNE,
    PPC_INS_TWLLT,
    PPC_INS_TWLGT,
    PPC_INS_TWU,
    PPC_INS_TWLTI,
    PPC_INS_TWEQI,
    PPC_INS_TWGTI,
    PPC_INS_TWNEI,
    PPC_INS_TWLLTI,
    PPC_INS_TWLGTI,
    PPC_INS_TWUI,
    PPC_INS_WAITRSV,
    PPC_INS_WAITIMPL,
    PPC_INS_XNOP,
    PPC_INS_XVMOVDP,
    PPC_INS_XVMOVSP,
    PPC_INS_XXSPLTD,
    PPC_INS_XXMRGHD,
    PPC_INS_XXMRGLD,
    PPC_INS_XXSWAPD,
    PPC_INS_BT,
    PPC_INS_BF,
    PPC_INS_BDNZT,
    PPC_INS_BDNZF,
    PPC_INS_BDZF,
    PPC_INS_BDZT,
    PPC_INS_BFA,
    PPC_INS_BDNZTA,
    PPC_INS_BDNZFA,
    PPC_INS_BDZTA,
    PPC_INS_BDZFA,
    PPC_INS_BTCTR,
    PPC_INS_BFCTR,
    PPC_INS_BTCTRL,
    PPC_INS_BFCTRL,
    PPC_INS_BTL,
    PPC_INS_BFL,
    PPC_INS_BDNZTL,
    PPC_INS_BDNZFL,
    PPC_INS_BDZTL,
    PPC_INS_BDZFL,
    PPC_INS_BTLA,
    PPC_INS_BFLA,
    PPC_INS_BDNZTLA,
    PPC_INS_BDNZFLA,
    PPC_INS_BDZTLA,
    PPC_INS_BDZFLA,
    PPC_INS_BTLR,
    PPC_INS_BFLR,
    PPC_INS_BDNZTLR,
    PPC_INS_BDZTLR,
    PPC_INS_BDZFLR,
    PPC_INS_BTLRL,
    PPC_INS_BFLRL,
    PPC_INS_BDNZTLRL,
    PPC_INS_BDNZFLRL,
    PPC_INS_BDZTLRL,
    PPC_INS_BDZFLRL,

    // QPX
    PPC_INS_QVFAND,
    PPC_INS_QVFCLR,
    PPC_INS_QVFANDC,
    PPC_INS_QVFCTFB,
    PPC_INS_QVFXOR,
    PPC_INS_QVFOR,
    PPC_INS_QVFNOR,
    PPC_INS_QVFEQU,
    PPC_INS_QVFNOT,
    PPC_INS_QVFORC,
    PPC_INS_QVFNAND,
    PPC_INS_QVFSET,

    PPC_INS_ENDING,   // <-- mark the end of the list of instructions
} ppc_insn;

//> Group of PPC instructions
typedef enum ppc_insn_group
{
    PPC_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    PPC_GRP_JUMP,   // = CS_GRP_JUMP

    //> Architecture-specific groups
    PPC_GRP_ALTIVEC = 128,
    PPC_GRP_MODE32,
    PPC_GRP_MODE64,
    PPC_GRP_BOOKE,
    PPC_GRP_NOTBOOKE,
    PPC_GRP_SPE,
    PPC_GRP_VSX,
    PPC_GRP_E500,
    PPC_GRP_PPC4XX,
    PPC_GRP_PPC6XX,
    PPC_GRP_ICBT,
    PPC_GRP_P8ALTIVEC,
    PPC_GRP_P8VECTOR,
    PPC_GRP_QPX,

    PPC_GRP_ENDING,   // <-- mark the end of the list of groups
} ppc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/sparc.h`:

```h
#ifndef CAPSTONE_SPARC_H
#define CAPSTONE_SPARC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to Sparc condition codes, both icc's and fcc's.
typedef enum sparc_cc
{
    SPARC_CC_INVALID = 0,   // invalid CC (default)
    //> Integer condition codes
    SPARC_CC_ICC_A   =  8 + 256, // Always
    SPARC_CC_ICC_N   =  0 + 256, // Never
    SPARC_CC_ICC_NE  =  9 + 256, // Not Equal
    SPARC_CC_ICC_E   =  1 + 256, // Equal
    SPARC_CC_ICC_G   = 10 + 256, // Greater
    SPARC_CC_ICC_LE  =  2 + 256, // Less or Equal
    SPARC_CC_ICC_GE  = 11 + 256, // Greater or Equal
    SPARC_CC_ICC_L   =  3 + 256, // Less
    SPARC_CC_ICC_GU  = 12 + 256, // Greater Unsigned
    SPARC_CC_ICC_LEU =  4 + 256, // Less or Equal Unsigned
    SPARC_CC_ICC_CC  = 13 + 256, // Carry Clear/Great or Equal Unsigned
    SPARC_CC_ICC_CS  =  5 + 256, // Carry Set/Less Unsigned
    SPARC_CC_ICC_POS = 14 + 256, // Positive
    SPARC_CC_ICC_NEG =  6 + 256, // Negative
    SPARC_CC_ICC_VC  = 15 + 256, // Overflow Clear
    SPARC_CC_ICC_VS  =  7 + 256, // Overflow Set

    //> Floating condition codes
    SPARC_CC_FCC_A   =  8 + 16 + 256, // Always
    SPARC_CC_FCC_N   =  0 + 16 + 256, // Never
    SPARC_CC_FCC_U   =  7 + 16 + 256, // Unordered
    SPARC_CC_FCC_G   =  6 + 16 + 256, // Greater
    SPARC_CC_FCC_UG  =  5 + 16 + 256, // Unordered or Greater
    SPARC_CC_FCC_L   =  4 + 16 + 256, // Less
    SPARC_CC_FCC_UL  =  3 + 16 + 256, // Unordered or Less
    SPARC_CC_FCC_LG  =  2 + 16 + 256, // Less or Greater
    SPARC_CC_FCC_NE  =  1 + 16 + 256, // Not Equal
    SPARC_CC_FCC_E   =  9 + 16 + 256, // Equal
    SPARC_CC_FCC_UE  = 10 + 16 + 256, // Unordered or Equal
    SPARC_CC_FCC_GE  = 11 + 16 + 256, // Greater or Equal
    SPARC_CC_FCC_UGE = 12 + 16 + 256, // Unordered or Greater or Equal
    SPARC_CC_FCC_LE  = 13 + 16 + 256, // Less or Equal
    SPARC_CC_FCC_ULE = 14 + 16 + 256, // Unordered or Less or Equal
    SPARC_CC_FCC_O   = 15 + 16 + 256, // Ordered
} sparc_cc;

//> Branch hint
typedef enum sparc_hint
{
    SPARC_HINT_INVALID = 0, // no hint
    SPARC_HINT_A    = 1 << 0,   // annul delay slot instruction
    SPARC_HINT_PT   = 1 << 1,   // branch taken
    SPARC_HINT_PN   = 1 << 2,   // branch NOT taken
} sparc_hint;

//> Operand type for instruction's operands
typedef enum sparc_op_type
{
    SPARC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    SPARC_OP_REG, // = CS_OP_REG (Register operand).
    SPARC_OP_IMM, // = CS_OP_IMM (Immediate operand).
    SPARC_OP_MEM, // = CS_OP_MEM (Memory operand).
} sparc_op_type;

//> SPARC registers
typedef enum sparc_reg
{
    SPARC_REG_INVALID = 0,

    SPARC_REG_F0,
    SPARC_REG_F1,
    SPARC_REG_F2,
    SPARC_REG_F3,
    SPARC_REG_F4,
    SPARC_REG_F5,
    SPARC_REG_F6,
    SPARC_REG_F7,
    SPARC_REG_F8,
    SPARC_REG_F9,
    SPARC_REG_F10,
    SPARC_REG_F11,
    SPARC_REG_F12,
    SPARC_REG_F13,
    SPARC_REG_F14,
    SPARC_REG_F15,
    SPARC_REG_F16,
    SPARC_REG_F17,
    SPARC_REG_F18,
    SPARC_REG_F19,
    SPARC_REG_F20,
    SPARC_REG_F21,
    SPARC_REG_F22,
    SPARC_REG_F23,
    SPARC_REG_F24,
    SPARC_REG_F25,
    SPARC_REG_F26,
    SPARC_REG_F27,
    SPARC_REG_F28,
    SPARC_REG_F29,
    SPARC_REG_F30,
    SPARC_REG_F31,
    SPARC_REG_F32,
    SPARC_REG_F34,
    SPARC_REG_F36,
    SPARC_REG_F38,
    SPARC_REG_F40,
    SPARC_REG_F42,
    SPARC_REG_F44,
    SPARC_REG_F46,
    SPARC_REG_F48,
    SPARC_REG_F50,
    SPARC_REG_F52,
    SPARC_REG_F54,
    SPARC_REG_F56,
    SPARC_REG_F58,
    SPARC_REG_F60,
    SPARC_REG_F62,
    SPARC_REG_FCC0, // Floating condition codes
    SPARC_REG_FCC1,
    SPARC_REG_FCC2,
    SPARC_REG_FCC3,
    SPARC_REG_FP,
    SPARC_REG_G0,
    SPARC_REG_G1,
    SPARC_REG_G2,
    SPARC_REG_G3,
    SPARC_REG_G4,
    SPARC_REG_G5,
    SPARC_REG_G6,
    SPARC_REG_G7,
    SPARC_REG_I0,
    SPARC_REG_I1,
    SPARC_REG_I2,
    SPARC_REG_I3,
    SPARC_REG_I4,
    SPARC_REG_I5,
    SPARC_REG_I7,
    SPARC_REG_ICC,  // Integer condition codes
    SPARC_REG_L0,
    SPARC_REG_L1,
    SPARC_REG_L2,
    SPARC_REG_L3,
    SPARC_REG_L4,
    SPARC_REG_L5,
    SPARC_REG_L6,
    SPARC_REG_L7,
    SPARC_REG_O0,
    SPARC_REG_O1,
    SPARC_REG_O2,
    SPARC_REG_O3,
    SPARC_REG_O4,
    SPARC_REG_O5,
    SPARC_REG_O7,
    SPARC_REG_SP,
    SPARC_REG_Y,

    // special register
    SPARC_REG_XCC,

    SPARC_REG_ENDING,   // <-- mark the end of the list of registers

    // extras
    SPARC_REG_O6 = SPARC_REG_SP,
    SPARC_REG_I6 = SPARC_REG_FP,
} sparc_reg;

// Instruction's operand referring to memory
// This is associated with SPARC_OP_MEM operand type above
typedef struct sparc_op_mem
{
    uint8_t base;       // base register, can be safely interpreted as
    // a value of type `sparc_reg`, but it is only
    // one byte wide
    uint8_t index;      // index register, same conditions apply here
    int32_t disp;       // displacement/offset value
} sparc_op_mem;

// Instruction operand
typedef struct cs_sparc_op
{
    sparc_op_type type; // operand type
    union
    {
        sparc_reg reg;  // register value for REG operand
        int32_t imm;        // immediate value for IMM operand
        sparc_op_mem mem;       // base/disp value for MEM operand
    };
} cs_sparc_op;

// Instruction structure
typedef struct cs_sparc
{
    sparc_cc cc;    // code condition for this insn
    sparc_hint hint;    // branch hint: encoding as bitwise OR of sparc_hint.
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_sparc_op operands[4]; // operands for this instruction.
} cs_sparc;

//> SPARC instruction
typedef enum sparc_insn
{
    SPARC_INS_INVALID = 0,

    SPARC_INS_ADDCC,
    SPARC_INS_ADDX,
    SPARC_INS_ADDXCC,
    SPARC_INS_ADDXC,
    SPARC_INS_ADDXCCC,
    SPARC_INS_ADD,
    SPARC_INS_ALIGNADDR,
    SPARC_INS_ALIGNADDRL,
    SPARC_INS_ANDCC,
    SPARC_INS_ANDNCC,
    SPARC_INS_ANDN,
    SPARC_INS_AND,
    SPARC_INS_ARRAY16,
    SPARC_INS_ARRAY32,
    SPARC_INS_ARRAY8,
    SPARC_INS_B,
    SPARC_INS_JMP,
    SPARC_INS_BMASK,
    SPARC_INS_FB,
    SPARC_INS_BRGEZ,
    SPARC_INS_BRGZ,
    SPARC_INS_BRLEZ,
    SPARC_INS_BRLZ,
    SPARC_INS_BRNZ,
    SPARC_INS_BRZ,
    SPARC_INS_BSHUFFLE,
    SPARC_INS_CALL,
    SPARC_INS_CASX,
    SPARC_INS_CAS,
    SPARC_INS_CMASK16,
    SPARC_INS_CMASK32,
    SPARC_INS_CMASK8,
    SPARC_INS_CMP,
    SPARC_INS_EDGE16,
    SPARC_INS_EDGE16L,
    SPARC_INS_EDGE16LN,
    SPARC_INS_EDGE16N,
    SPARC_INS_EDGE32,
    SPARC_INS_EDGE32L,
    SPARC_INS_EDGE32LN,
    SPARC_INS_EDGE32N,
    SPARC_INS_EDGE8,
    SPARC_INS_EDGE8L,
    SPARC_INS_EDGE8LN,
    SPARC_INS_EDGE8N,
    SPARC_INS_FABSD,
    SPARC_INS_FABSQ,
    SPARC_INS_FABSS,
    SPARC_INS_FADDD,
    SPARC_INS_FADDQ,
    SPARC_INS_FADDS,
    SPARC_INS_FALIGNDATA,
    SPARC_INS_FAND,
    SPARC_INS_FANDNOT1,
    SPARC_INS_FANDNOT1S,
    SPARC_INS_FANDNOT2,
    SPARC_INS_FANDNOT2S,
    SPARC_INS_FANDS,
    SPARC_INS_FCHKSM16,
    SPARC_INS_FCMPD,
    SPARC_INS_FCMPEQ16,
    SPARC_INS_FCMPEQ32,
    SPARC_INS_FCMPGT16,
    SPARC_INS_FCMPGT32,
    SPARC_INS_FCMPLE16,
    SPARC_INS_FCMPLE32,
    SPARC_INS_FCMPNE16,
    SPARC_INS_FCMPNE32,
    SPARC_INS_FCMPQ,
    SPARC_INS_FCMPS,
    SPARC_INS_FDIVD,
    SPARC_INS_FDIVQ,
    SPARC_INS_FDIVS,
    SPARC_INS_FDMULQ,
    SPARC_INS_FDTOI,
    SPARC_INS_FDTOQ,
    SPARC_INS_FDTOS,
    SPARC_INS_FDTOX,
    SPARC_INS_FEXPAND,
    SPARC_INS_FHADDD,
    SPARC_INS_FHADDS,
    SPARC_INS_FHSUBD,
    SPARC_INS_FHSUBS,
    SPARC_INS_FITOD,
    SPARC_INS_FITOQ,
    SPARC_INS_FITOS,
    SPARC_INS_FLCMPD,
    SPARC_INS_FLCMPS,
    SPARC_INS_FLUSHW,
    SPARC_INS_FMEAN16,
    SPARC_INS_FMOVD,
    SPARC_INS_FMOVQ,
    SPARC_INS_FMOVRDGEZ,
    SPARC_INS_FMOVRQGEZ,
    SPARC_INS_FMOVRSGEZ,
    SPARC_INS_FMOVRDGZ,
    SPARC_INS_FMOVRQGZ,
    SPARC_INS_FMOVRSGZ,
    SPARC_INS_FMOVRDLEZ,
    SPARC_INS_FMOVRQLEZ,
    SPARC_INS_FMOVRSLEZ,
    SPARC_INS_FMOVRDLZ,
    SPARC_INS_FMOVRQLZ,
    SPARC_INS_FMOVRSLZ,
    SPARC_INS_FMOVRDNZ,
    SPARC_INS_FMOVRQNZ,
    SPARC_INS_FMOVRSNZ,
    SPARC_INS_FMOVRDZ,
    SPARC_INS_FMOVRQZ,
    SPARC_INS_FMOVRSZ,
    SPARC_INS_FMOVS,
    SPARC_INS_FMUL8SUX16,
    SPARC_INS_FMUL8ULX16,
    SPARC_INS_FMUL8X16,
    SPARC_INS_FMUL8X16AL,
    SPARC_INS_FMUL8X16AU,
    SPARC_INS_FMULD,
    SPARC_INS_FMULD8SUX16,
    SPARC_INS_FMULD8ULX16,
    SPARC_INS_FMULQ,
    SPARC_INS_FMULS,
    SPARC_INS_FNADDD,
    SPARC_INS_FNADDS,
    SPARC_INS_FNAND,
    SPARC_INS_FNANDS,
    SPARC_INS_FNEGD,
    SPARC_INS_FNEGQ,
    SPARC_INS_FNEGS,
    SPARC_INS_FNHADDD,
    SPARC_INS_FNHADDS,
    SPARC_INS_FNOR,
    SPARC_INS_FNORS,
    SPARC_INS_FNOT1,
    SPARC_INS_FNOT1S,
    SPARC_INS_FNOT2,
    SPARC_INS_FNOT2S,
    SPARC_INS_FONE,
    SPARC_INS_FONES,
    SPARC_INS_FOR,
    SPARC_INS_FORNOT1,
    SPARC_INS_FORNOT1S,
    SPARC_INS_FORNOT2,
    SPARC_INS_FORNOT2S,
    SPARC_INS_FORS,
    SPARC_INS_FPACK16,
    SPARC_INS_FPACK32,
    SPARC_INS_FPACKFIX,
    SPARC_INS_FPADD16,
    SPARC_INS_FPADD16S,
    SPARC_INS_FPADD32,
    SPARC_INS_FPADD32S,
    SPARC_INS_FPADD64,
    SPARC_INS_FPMERGE,
    SPARC_INS_FPSUB16,
    SPARC_INS_FPSUB16S,
    SPARC_INS_FPSUB32,
    SPARC_INS_FPSUB32S,
    SPARC_INS_FQTOD,
    SPARC_INS_FQTOI,
    SPARC_INS_FQTOS,
    SPARC_INS_FQTOX,
    SPARC_INS_FSLAS16,
    SPARC_INS_FSLAS32,
    SPARC_INS_FSLL16,
    SPARC_INS_FSLL32,
    SPARC_INS_FSMULD,
    SPARC_INS_FSQRTD,
    SPARC_INS_FSQRTQ,
    SPARC_INS_FSQRTS,
    SPARC_INS_FSRA16,
    SPARC_INS_FSRA32,
    SPARC_INS_FSRC1,
    SPARC_INS_FSRC1S,
    SPARC_INS_FSRC2,
    SPARC_INS_FSRC2S,
    SPARC_INS_FSRL16,
    SPARC_INS_FSRL32,
    SPARC_INS_FSTOD,
    SPARC_INS_FSTOI,
    SPARC_INS_FSTOQ,
    SPARC_INS_FSTOX,
    SPARC_INS_FSUBD,
    SPARC_INS_FSUBQ,
    SPARC_INS_FSUBS,
    SPARC_INS_FXNOR,
    SPARC_INS_FXNORS,
    SPARC_INS_FXOR,
    SPARC_INS_FXORS,
    SPARC_INS_FXTOD,
    SPARC_INS_FXTOQ,
    SPARC_INS_FXTOS,
    SPARC_INS_FZERO,
    SPARC_INS_FZEROS,
    SPARC_INS_JMPL,
    SPARC_INS_LDD,
    SPARC_INS_LD,
    SPARC_INS_LDQ,
    SPARC_INS_LDSB,
    SPARC_INS_LDSH,
    SPARC_INS_LDSW,
    SPARC_INS_LDUB,
    SPARC_INS_LDUH,
    SPARC_INS_LDX,
    SPARC_INS_LZCNT,
    SPARC_INS_MEMBAR,
    SPARC_INS_MOVDTOX,
    SPARC_INS_MOV,
    SPARC_INS_MOVRGEZ,
    SPARC_INS_MOVRGZ,
    SPARC_INS_MOVRLEZ,
    SPARC_INS_MOVRLZ,
    SPARC_INS_MOVRNZ,
    SPARC_INS_MOVRZ,
    SPARC_INS_MOVSTOSW,
    SPARC_INS_MOVSTOUW,
    SPARC_INS_MULX,
    SPARC_INS_NOP,
    SPARC_INS_ORCC,
    SPARC_INS_ORNCC,
    SPARC_INS_ORN,
    SPARC_INS_OR,
    SPARC_INS_PDIST,
    SPARC_INS_PDISTN,
    SPARC_INS_POPC,
    SPARC_INS_RD,
    SPARC_INS_RESTORE,
    SPARC_INS_RETT,
    SPARC_INS_SAVE,
    SPARC_INS_SDIVCC,
    SPARC_INS_SDIVX,
    SPARC_INS_SDIV,
    SPARC_INS_SETHI,
    SPARC_INS_SHUTDOWN,
    SPARC_INS_SIAM,
    SPARC_INS_SLLX,
    SPARC_INS_SLL,
    SPARC_INS_SMULCC,
    SPARC_INS_SMUL,
    SPARC_INS_SRAX,
    SPARC_INS_SRA,
    SPARC_INS_SRLX,
    SPARC_INS_SRL,
    SPARC_INS_STBAR,
    SPARC_INS_STB,
    SPARC_INS_STD,
    SPARC_INS_ST,
    SPARC_INS_STH,
    SPARC_INS_STQ,
    SPARC_INS_STX,
    SPARC_INS_SUBCC,
    SPARC_INS_SUBX,
    SPARC_INS_SUBXCC,
    SPARC_INS_SUB,
    SPARC_INS_SWAP,
    SPARC_INS_TADDCCTV,
    SPARC_INS_TADDCC,
    SPARC_INS_T,
    SPARC_INS_TSUBCCTV,
    SPARC_INS_TSUBCC,
    SPARC_INS_UDIVCC,
    SPARC_INS_UDIVX,
    SPARC_INS_UDIV,
    SPARC_INS_UMULCC,
    SPARC_INS_UMULXHI,
    SPARC_INS_UMUL,
    SPARC_INS_UNIMP,
    SPARC_INS_FCMPED,
    SPARC_INS_FCMPEQ,
    SPARC_INS_FCMPES,
    SPARC_INS_WR,
    SPARC_INS_XMULX,
    SPARC_INS_XMULXHI,
    SPARC_INS_XNORCC,
    SPARC_INS_XNOR,
    SPARC_INS_XORCC,
    SPARC_INS_XOR,

    // alias instructions
    SPARC_INS_RET,
    SPARC_INS_RETL,

    SPARC_INS_ENDING,   // <-- mark the end of the list of instructions
} sparc_insn;

//> Group of SPARC instructions
typedef enum sparc_insn_group
{
    SPARC_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    SPARC_GRP_JUMP, // = CS_GRP_JUMP

    //> Architecture-specific groups
    SPARC_GRP_HARDQUAD = 128,
    SPARC_GRP_V9,
    SPARC_GRP_VIS,
    SPARC_GRP_VIS2,
    SPARC_GRP_VIS3,
    SPARC_GRP_32BIT,
    SPARC_GRP_64BIT,

    SPARC_GRP_ENDING,   // <-- mark the end of the list of groups
} sparc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/systemz.h`:

```h
#ifndef CAPSTONE_SYSTEMZ_H
#define CAPSTONE_SYSTEMZ_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to SystemZ condition codes
typedef enum sysz_cc
{
    SYSZ_CC_INVALID = 0,    // invalid CC (default)

    SYSZ_CC_O,
    SYSZ_CC_H,
    SYSZ_CC_NLE,
    SYSZ_CC_L,
    SYSZ_CC_NHE,
    SYSZ_CC_LH,
    SYSZ_CC_NE,
    SYSZ_CC_E,
    SYSZ_CC_NLH,
    SYSZ_CC_HE,
    SYSZ_CC_NL,
    SYSZ_CC_LE,
    SYSZ_CC_NH,
    SYSZ_CC_NO,
} sysz_cc;

//> Operand type for instruction's operands
typedef enum sysz_op_type
{
    SYSZ_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    SYSZ_OP_REG, // = CS_OP_REG (Register operand).
    SYSZ_OP_IMM, // = CS_OP_IMM (Immediate operand).
    SYSZ_OP_MEM, // = CS_OP_MEM (Memory operand).
    SYSZ_OP_ACREG = 64, // Access register operand.
} sysz_op_type;

//> SystemZ registers
typedef enum sysz_reg
{
    SYSZ_REG_INVALID = 0,

    SYSZ_REG_0,
    SYSZ_REG_1,
    SYSZ_REG_2,
    SYSZ_REG_3,
    SYSZ_REG_4,
    SYSZ_REG_5,
    SYSZ_REG_6,
    SYSZ_REG_7,
    SYSZ_REG_8,
    SYSZ_REG_9,
    SYSZ_REG_10,
    SYSZ_REG_11,
    SYSZ_REG_12,
    SYSZ_REG_13,
    SYSZ_REG_14,
    SYSZ_REG_15,
    SYSZ_REG_CC,
    SYSZ_REG_F0,
    SYSZ_REG_F1,
    SYSZ_REG_F2,
    SYSZ_REG_F3,
    SYSZ_REG_F4,
    SYSZ_REG_F5,
    SYSZ_REG_F6,
    SYSZ_REG_F7,
    SYSZ_REG_F8,
    SYSZ_REG_F9,
    SYSZ_REG_F10,
    SYSZ_REG_F11,
    SYSZ_REG_F12,
    SYSZ_REG_F13,
    SYSZ_REG_F14,
    SYSZ_REG_F15,

    SYSZ_REG_R0L,

    SYSZ_REG_ENDING,
} sysz_reg;

// Instruction's operand referring to memory
// This is associated with SYSZ_OP_MEM operand type above
typedef struct sysz_op_mem
{
    uint8_t base;       // base register, can be safely interpreted as
    // a value of type `sysz_reg`, but it is only
    // one byte wide
    uint8_t index;      // index register, same conditions apply here
    uint64_t length;    // BDLAddr operand
    int64_t disp;   // displacement/offset value
} sysz_op_mem;

// Instruction operand
typedef struct cs_sysz_op
{
    sysz_op_type type;  // operand type
    union
    {
        sysz_reg reg;       // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        sysz_op_mem mem;    // base/disp value for MEM operand
    };
} cs_sysz_op;

// Instruction structure
typedef struct cs_sysz
{
    sysz_cc cc;     // Code condition
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_sysz_op operands[6]; // operands for this instruction.
} cs_sysz;

//> SystemZ instruction
typedef enum sysz_insn
{
    SYSZ_INS_INVALID = 0,

    SYSZ_INS_A,
    SYSZ_INS_ADB,
    SYSZ_INS_ADBR,
    SYSZ_INS_AEB,
    SYSZ_INS_AEBR,
    SYSZ_INS_AFI,
    SYSZ_INS_AG,
    SYSZ_INS_AGF,
    SYSZ_INS_AGFI,
    SYSZ_INS_AGFR,
    SYSZ_INS_AGHI,
    SYSZ_INS_AGHIK,
    SYSZ_INS_AGR,
    SYSZ_INS_AGRK,
    SYSZ_INS_AGSI,
    SYSZ_INS_AH,
    SYSZ_INS_AHI,
    SYSZ_INS_AHIK,
    SYSZ_INS_AHY,
    SYSZ_INS_AIH,
    SYSZ_INS_AL,
    SYSZ_INS_ALC,
    SYSZ_INS_ALCG,
    SYSZ_INS_ALCGR,
    SYSZ_INS_ALCR,
    SYSZ_INS_ALFI,
    SYSZ_INS_ALG,
    SYSZ_INS_ALGF,
    SYSZ_INS_ALGFI,
    SYSZ_INS_ALGFR,
    SYSZ_INS_ALGHSIK,
    SYSZ_INS_ALGR,
    SYSZ_INS_ALGRK,
    SYSZ_INS_ALHSIK,
    SYSZ_INS_ALR,
    SYSZ_INS_ALRK,
    SYSZ_INS_ALY,
    SYSZ_INS_AR,
    SYSZ_INS_ARK,
    SYSZ_INS_ASI,
    SYSZ_INS_AXBR,
    SYSZ_INS_AY,
    SYSZ_INS_BCR,
    SYSZ_INS_BRC,
    SYSZ_INS_BRCL,
    SYSZ_INS_CGIJ,
    SYSZ_INS_CGRJ,
    SYSZ_INS_CIJ,
    SYSZ_INS_CLGIJ,
    SYSZ_INS_CLGRJ,
    SYSZ_INS_CLIJ,
    SYSZ_INS_CLRJ,
    SYSZ_INS_CRJ,
    SYSZ_INS_BER,
    SYSZ_INS_JE,
    SYSZ_INS_JGE,
    SYSZ_INS_LOCE,
    SYSZ_INS_LOCGE,
    SYSZ_INS_LOCGRE,
    SYSZ_INS_LOCRE,
    SYSZ_INS_STOCE,
    SYSZ_INS_STOCGE,
    SYSZ_INS_BHR,
    SYSZ_INS_BHER,
    SYSZ_INS_JHE,
    SYSZ_INS_JGHE,
    SYSZ_INS_LOCHE,
    SYSZ_INS_LOCGHE,
    SYSZ_INS_LOCGRHE,
    SYSZ_INS_LOCRHE,
    SYSZ_INS_STOCHE,
    SYSZ_INS_STOCGHE,
    SYSZ_INS_JH,
    SYSZ_INS_JGH,
    SYSZ_INS_LOCH,
    SYSZ_INS_LOCGH,
    SYSZ_INS_LOCGRH,
    SYSZ_INS_LOCRH,
    SYSZ_INS_STOCH,
    SYSZ_INS_STOCGH,
    SYSZ_INS_CGIJNLH,
    SYSZ_INS_CGRJNLH,
    SYSZ_INS_CIJNLH,
    SYSZ_INS_CLGIJNLH,
    SYSZ_INS_CLGRJNLH,
    SYSZ_INS_CLIJNLH,
    SYSZ_INS_CLRJNLH,
    SYSZ_INS_CRJNLH,
    SYSZ_INS_CGIJE,
    SYSZ_INS_CGRJE,
    SYSZ_INS_CIJE,
    SYSZ_INS_CLGIJE,
    SYSZ_INS_CLGRJE,
    SYSZ_INS_CLIJE,
    SYSZ_INS_CLRJE,
    SYSZ_INS_CRJE,
    SYSZ_INS_CGIJNLE,
    SYSZ_INS_CGRJNLE,
    SYSZ_INS_CIJNLE,
    SYSZ_INS_CLGIJNLE,
    SYSZ_INS_CLGRJNLE,
    SYSZ_INS_CLIJNLE,
    SYSZ_INS_CLRJNLE,
    SYSZ_INS_CRJNLE,
    SYSZ_INS_CGIJH,
    SYSZ_INS_CGRJH,
    SYSZ_INS_CIJH,
    SYSZ_INS_CLGIJH,
    SYSZ_INS_CLGRJH,
    SYSZ_INS_CLIJH,
    SYSZ_INS_CLRJH,
    SYSZ_INS_CRJH,
    SYSZ_INS_CGIJNL,
    SYSZ_INS_CGRJNL,
    SYSZ_INS_CIJNL,
    SYSZ_INS_CLGIJNL,
    SYSZ_INS_CLGRJNL,
    SYSZ_INS_CLIJNL,
    SYSZ_INS_CLRJNL,
    SYSZ_INS_CRJNL,
    SYSZ_INS_CGIJHE,
    SYSZ_INS_CGRJHE,
    SYSZ_INS_CIJHE,
    SYSZ_INS_CLGIJHE,
    SYSZ_INS_CLGRJHE,
    SYSZ_INS_CLIJHE,
    SYSZ_INS_CLRJHE,
    SYSZ_INS_CRJHE,
    SYSZ_INS_CGIJNHE,
    SYSZ_INS_CGRJNHE,
    SYSZ_INS_CIJNHE,
    SYSZ_INS_CLGIJNHE,
    SYSZ_INS_CLGRJNHE,
    SYSZ_INS_CLIJNHE,
    SYSZ_INS_CLRJNHE,
    SYSZ_INS_CRJNHE,
    SYSZ_INS_CGIJL,
    SYSZ_INS_CGRJL,
    SYSZ_INS_CIJL,
    SYSZ_INS_CLGIJL,
    SYSZ_INS_CLGRJL,
    SYSZ_INS_CLIJL,
    SYSZ_INS_CLRJL,
    SYSZ_INS_CRJL,
    SYSZ_INS_CGIJNH,
    SYSZ_INS_CGRJNH,
    SYSZ_INS_CIJNH,
    SYSZ_INS_CLGIJNH,
    SYSZ_INS_CLGRJNH,
    SYSZ_INS_CLIJNH,
    SYSZ_INS_CLRJNH,
    SYSZ_INS_CRJNH,
    SYSZ_INS_CGIJLE,
    SYSZ_INS_CGRJLE,
    SYSZ_INS_CIJLE,
    SYSZ_INS_CLGIJLE,
    SYSZ_INS_CLGRJLE,
    SYSZ_INS_CLIJLE,
    SYSZ_INS_CLRJLE,
    SYSZ_INS_CRJLE,
    SYSZ_INS_CGIJNE,
    SYSZ_INS_CGRJNE,
    SYSZ_INS_CIJNE,
    SYSZ_INS_CLGIJNE,
    SYSZ_INS_CLGRJNE,
    SYSZ_INS_CLIJNE,
    SYSZ_INS_CLRJNE,
    SYSZ_INS_CRJNE,
    SYSZ_INS_CGIJLH,
    SYSZ_INS_CGRJLH,
    SYSZ_INS_CIJLH,
    SYSZ_INS_CLGIJLH,
    SYSZ_INS_CLGRJLH,
    SYSZ_INS_CLIJLH,
    SYSZ_INS_CLRJLH,
    SYSZ_INS_CRJLH,
    SYSZ_INS_BLR,
    SYSZ_INS_BLER,
    SYSZ_INS_JLE,
    SYSZ_INS_JGLE,
    SYSZ_INS_LOCLE,
    SYSZ_INS_LOCGLE,
    SYSZ_INS_LOCGRLE,
    SYSZ_INS_LOCRLE,
    SYSZ_INS_STOCLE,
    SYSZ_INS_STOCGLE,
    SYSZ_INS_BLHR,
    SYSZ_INS_JLH,
    SYSZ_INS_JGLH,
    SYSZ_INS_LOCLH,
    SYSZ_INS_LOCGLH,
    SYSZ_INS_LOCGRLH,
    SYSZ_INS_LOCRLH,
    SYSZ_INS_STOCLH,
    SYSZ_INS_STOCGLH,
    SYSZ_INS_JL,
    SYSZ_INS_JGL,
    SYSZ_INS_LOCL,
    SYSZ_INS_LOCGL,
    SYSZ_INS_LOCGRL,
    SYSZ_INS_LOCRL,
    SYSZ_INS_LOC,
    SYSZ_INS_LOCG,
    SYSZ_INS_LOCGR,
    SYSZ_INS_LOCR,
    SYSZ_INS_STOCL,
    SYSZ_INS_STOCGL,
    SYSZ_INS_BNER,
    SYSZ_INS_JNE,
    SYSZ_INS_JGNE,
    SYSZ_INS_LOCNE,
    SYSZ_INS_LOCGNE,
    SYSZ_INS_LOCGRNE,
    SYSZ_INS_LOCRNE,
    SYSZ_INS_STOCNE,
    SYSZ_INS_STOCGNE,
    SYSZ_INS_BNHR,
    SYSZ_INS_BNHER,
    SYSZ_INS_JNHE,
    SYSZ_INS_JGNHE,
    SYSZ_INS_LOCNHE,
    SYSZ_INS_LOCGNHE,
    SYSZ_INS_LOCGRNHE,
    SYSZ_INS_LOCRNHE,
    SYSZ_INS_STOCNHE,
    SYSZ_INS_STOCGNHE,
    SYSZ_INS_JNH,
    SYSZ_INS_JGNH,
    SYSZ_INS_LOCNH,
    SYSZ_INS_LOCGNH,
    SYSZ_INS_LOCGRNH,
    SYSZ_INS_LOCRNH,
    SYSZ_INS_STOCNH,
    SYSZ_INS_STOCGNH,
    SYSZ_INS_BNLR,
    SYSZ_INS_BNLER,
    SYSZ_INS_JNLE,
    SYSZ_INS_JGNLE,
    SYSZ_INS_LOCNLE,
    SYSZ_INS_LOCGNLE,
    SYSZ_INS_LOCGRNLE,
    SYSZ_INS_LOCRNLE,
    SYSZ_INS_STOCNLE,
    SYSZ_INS_STOCGNLE,
    SYSZ_INS_BNLHR,
    SYSZ_INS_JNLH,
    SYSZ_INS_JGNLH,
    SYSZ_INS_LOCNLH,
    SYSZ_INS_LOCGNLH,
    SYSZ_INS_LOCGRNLH,
    SYSZ_INS_LOCRNLH,
    SYSZ_INS_STOCNLH,
    SYSZ_INS_STOCGNLH,
    SYSZ_INS_JNL,
    SYSZ_INS_JGNL,
    SYSZ_INS_LOCNL,
    SYSZ_INS_LOCGNL,
    SYSZ_INS_LOCGRNL,
    SYSZ_INS_LOCRNL,
    SYSZ_INS_STOCNL,
    SYSZ_INS_STOCGNL,
    SYSZ_INS_BNOR,
    SYSZ_INS_JNO,
    SYSZ_INS_JGNO,
    SYSZ_INS_LOCNO,
    SYSZ_INS_LOCGNO,
    SYSZ_INS_LOCGRNO,
    SYSZ_INS_LOCRNO,
    SYSZ_INS_STOCNO,
    SYSZ_INS_STOCGNO,
    SYSZ_INS_BOR,
    SYSZ_INS_JO,
    SYSZ_INS_JGO,
    SYSZ_INS_LOCO,
    SYSZ_INS_LOCGO,
    SYSZ_INS_LOCGRO,
    SYSZ_INS_LOCRO,
    SYSZ_INS_STOCO,
    SYSZ_INS_STOCGO,
    SYSZ_INS_STOC,
    SYSZ_INS_STOCG,
    SYSZ_INS_BASR,
    SYSZ_INS_BR,
    SYSZ_INS_BRAS,
    SYSZ_INS_BRASL,
    SYSZ_INS_J,
    SYSZ_INS_JG,
    SYSZ_INS_BRCT,
    SYSZ_INS_BRCTG,
    SYSZ_INS_C,
    SYSZ_INS_CDB,
    SYSZ_INS_CDBR,
    SYSZ_INS_CDFBR,
    SYSZ_INS_CDGBR,
    SYSZ_INS_CDLFBR,
    SYSZ_INS_CDLGBR,
    SYSZ_INS_CEB,
    SYSZ_INS_CEBR,
    SYSZ_INS_CEFBR,
    SYSZ_INS_CEGBR,
    SYSZ_INS_CELFBR,
    SYSZ_INS_CELGBR,
    SYSZ_INS_CFDBR,
    SYSZ_INS_CFEBR,
    SYSZ_INS_CFI,
    SYSZ_INS_CFXBR,
    SYSZ_INS_CG,
    SYSZ_INS_CGDBR,
    SYSZ_INS_CGEBR,
    SYSZ_INS_CGF,
    SYSZ_INS_CGFI,
    SYSZ_INS_CGFR,
    SYSZ_INS_CGFRL,
    SYSZ_INS_CGH,
    SYSZ_INS_CGHI,
    SYSZ_INS_CGHRL,
    SYSZ_INS_CGHSI,
    SYSZ_INS_CGR,
    SYSZ_INS_CGRL,
    SYSZ_INS_CGXBR,
    SYSZ_INS_CH,
    SYSZ_INS_CHF,
    SYSZ_INS_CHHSI,
    SYSZ_INS_CHI,
    SYSZ_INS_CHRL,
    SYSZ_INS_CHSI,
    SYSZ_INS_CHY,
    SYSZ_INS_CIH,
    SYSZ_INS_CL,
    SYSZ_INS_CLC,
    SYSZ_INS_CLFDBR,
    SYSZ_INS_CLFEBR,
    SYSZ_INS_CLFHSI,
    SYSZ_INS_CLFI,
    SYSZ_INS_CLFXBR,
    SYSZ_INS_CLG,
    SYSZ_INS_CLGDBR,
    SYSZ_INS_CLGEBR,
    SYSZ_INS_CLGF,
    SYSZ_INS_CLGFI,
    SYSZ_INS_CLGFR,
    SYSZ_INS_CLGFRL,
    SYSZ_INS_CLGHRL,
    SYSZ_INS_CLGHSI,
    SYSZ_INS_CLGR,
    SYSZ_INS_CLGRL,
    SYSZ_INS_CLGXBR,
    SYSZ_INS_CLHF,
    SYSZ_INS_CLHHSI,
    SYSZ_INS_CLHRL,
    SYSZ_INS_CLI,
    SYSZ_INS_CLIH,
    SYSZ_INS_CLIY,
    SYSZ_INS_CLR,
    SYSZ_INS_CLRL,
    SYSZ_INS_CLST,
    SYSZ_INS_CLY,
    SYSZ_INS_CPSDR,
    SYSZ_INS_CR,
    SYSZ_INS_CRL,
    SYSZ_INS_CS,
    SYSZ_INS_CSG,
    SYSZ_INS_CSY,
    SYSZ_INS_CXBR,
    SYSZ_INS_CXFBR,
    SYSZ_INS_CXGBR,
    SYSZ_INS_CXLFBR,
    SYSZ_INS_CXLGBR,
    SYSZ_INS_CY,
    SYSZ_INS_DDB,
    SYSZ_INS_DDBR,
    SYSZ_INS_DEB,
    SYSZ_INS_DEBR,
    SYSZ_INS_DL,
    SYSZ_INS_DLG,
    SYSZ_INS_DLGR,
    SYSZ_INS_DLR,
    SYSZ_INS_DSG,
    SYSZ_INS_DSGF,
    SYSZ_INS_DSGFR,
    SYSZ_INS_DSGR,
    SYSZ_INS_DXBR,
    SYSZ_INS_EAR,
    SYSZ_INS_FIDBR,
    SYSZ_INS_FIDBRA,
    SYSZ_INS_FIEBR,
    SYSZ_INS_FIEBRA,
    SYSZ_INS_FIXBR,
    SYSZ_INS_FIXBRA,
    SYSZ_INS_FLOGR,
    SYSZ_INS_IC,
    SYSZ_INS_ICY,
    SYSZ_INS_IIHF,
    SYSZ_INS_IIHH,
    SYSZ_INS_IIHL,
    SYSZ_INS_IILF,
    SYSZ_INS_IILH,
    SYSZ_INS_IILL,
    SYSZ_INS_IPM,
    SYSZ_INS_L,
    SYSZ_INS_LA,
    SYSZ_INS_LAA,
    SYSZ_INS_LAAG,
    SYSZ_INS_LAAL,
    SYSZ_INS_LAALG,
    SYSZ_INS_LAN,
    SYSZ_INS_LANG,
    SYSZ_INS_LAO,
    SYSZ_INS_LAOG,
    SYSZ_INS_LARL,
    SYSZ_INS_LAX,
    SYSZ_INS_LAXG,
    SYSZ_INS_LAY,
    SYSZ_INS_LB,
    SYSZ_INS_LBH,
    SYSZ_INS_LBR,
    SYSZ_INS_LCDBR,
    SYSZ_INS_LCEBR,
    SYSZ_INS_LCGFR,
    SYSZ_INS_LCGR,
    SYSZ_INS_LCR,
    SYSZ_INS_LCXBR,
    SYSZ_INS_LD,
    SYSZ_INS_LDEB,
    SYSZ_INS_LDEBR,
    SYSZ_INS_LDGR,
    SYSZ_INS_LDR,
    SYSZ_INS_LDXBR,
    SYSZ_INS_LDXBRA,
    SYSZ_INS_LDY,
    SYSZ_INS_LE,
    SYSZ_INS_LEDBR,
    SYSZ_INS_LEDBRA,
    SYSZ_INS_LER,
    SYSZ_INS_LEXBR,
    SYSZ_INS_LEXBRA,
    SYSZ_INS_LEY,
    SYSZ_INS_LFH,
    SYSZ_INS_LG,
    SYSZ_INS_LGB,
    SYSZ_INS_LGBR,
    SYSZ_INS_LGDR,
    SYSZ_INS_LGF,
    SYSZ_INS_LGFI,
    SYSZ_INS_LGFR,
    SYSZ_INS_LGFRL,
    SYSZ_INS_LGH,
    SYSZ_INS_LGHI,
    SYSZ_INS_LGHR,
    SYSZ_INS_LGHRL,
    SYSZ_INS_LGR,
    SYSZ_INS_LGRL,
    SYSZ_INS_LH,
    SYSZ_INS_LHH,
    SYSZ_INS_LHI,
    SYSZ_INS_LHR,
    SYSZ_INS_LHRL,
    SYSZ_INS_LHY,
    SYSZ_INS_LLC,
    SYSZ_INS_LLCH,
    SYSZ_INS_LLCR,
    SYSZ_INS_LLGC,
    SYSZ_INS_LLGCR,
    SYSZ_INS_LLGF,
    SYSZ_INS_LLGFR,
    SYSZ_INS_LLGFRL,
    SYSZ_INS_LLGH,
    SYSZ_INS_LLGHR,
    SYSZ_INS_LLGHRL,
    SYSZ_INS_LLH,
    SYSZ_INS_LLHH,
    SYSZ_INS_LLHR,
    SYSZ_INS_LLHRL,
    SYSZ_INS_LLIHF,
    SYSZ_INS_LLIHH,
    SYSZ_INS_LLIHL,
    SYSZ_INS_LLILF,
    SYSZ_INS_LLILH,
    SYSZ_INS_LLILL,
    SYSZ_INS_LMG,
    SYSZ_INS_LNDBR,
    SYSZ_INS_LNEBR,
    SYSZ_INS_LNGFR,
    SYSZ_INS_LNGR,
    SYSZ_INS_LNR,
    SYSZ_INS_LNXBR,
    SYSZ_INS_LPDBR,
    SYSZ_INS_LPEBR,
    SYSZ_INS_LPGFR,
    SYSZ_INS_LPGR,
    SYSZ_INS_LPR,
    SYSZ_INS_LPXBR,
    SYSZ_INS_LR,
    SYSZ_INS_LRL,
    SYSZ_INS_LRV,
    SYSZ_INS_LRVG,
    SYSZ_INS_LRVGR,
    SYSZ_INS_LRVR,
    SYSZ_INS_LT,
    SYSZ_INS_LTDBR,
    SYSZ_INS_LTEBR,
    SYSZ_INS_LTG,
    SYSZ_INS_LTGF,
    SYSZ_INS_LTGFR,
    SYSZ_INS_LTGR,
    SYSZ_INS_LTR,
    SYSZ_INS_LTXBR,
    SYSZ_INS_LXDB,
    SYSZ_INS_LXDBR,
    SYSZ_INS_LXEB,
    SYSZ_INS_LXEBR,
    SYSZ_INS_LXR,
    SYSZ_INS_LY,
    SYSZ_INS_LZDR,
    SYSZ_INS_LZER,
    SYSZ_INS_LZXR,
    SYSZ_INS_MADB,
    SYSZ_INS_MADBR,
    SYSZ_INS_MAEB,
    SYSZ_INS_MAEBR,
    SYSZ_INS_MDB,
    SYSZ_INS_MDBR,
    SYSZ_INS_MDEB,
    SYSZ_INS_MDEBR,
    SYSZ_INS_MEEB,
    SYSZ_INS_MEEBR,
    SYSZ_INS_MGHI,
    SYSZ_INS_MH,
    SYSZ_INS_MHI,
    SYSZ_INS_MHY,
    SYSZ_INS_MLG,
    SYSZ_INS_MLGR,
    SYSZ_INS_MS,
    SYSZ_INS_MSDB,
    SYSZ_INS_MSDBR,
    SYSZ_INS_MSEB,
    SYSZ_INS_MSEBR,
    SYSZ_INS_MSFI,
    SYSZ_INS_MSG,
    SYSZ_INS_MSGF,
    SYSZ_INS_MSGFI,
    SYSZ_INS_MSGFR,
    SYSZ_INS_MSGR,
    SYSZ_INS_MSR,
    SYSZ_INS_MSY,
    SYSZ_INS_MVC,
    SYSZ_INS_MVGHI,
    SYSZ_INS_MVHHI,
    SYSZ_INS_MVHI,
    SYSZ_INS_MVI,
    SYSZ_INS_MVIY,
    SYSZ_INS_MVST,
    SYSZ_INS_MXBR,
    SYSZ_INS_MXDB,
    SYSZ_INS_MXDBR,
    SYSZ_INS_N,
    SYSZ_INS_NC,
    SYSZ_INS_NG,
    SYSZ_INS_NGR,
    SYSZ_INS_NGRK,
    SYSZ_INS_NI,
    SYSZ_INS_NIHF,
    SYSZ_INS_NIHH,
    SYSZ_INS_NIHL,
    SYSZ_INS_NILF,
    SYSZ_INS_NILH,
    SYSZ_INS_NILL,
    SYSZ_INS_NIY,
    SYSZ_INS_NR,
    SYSZ_INS_NRK,
    SYSZ_INS_NY,
    SYSZ_INS_O,
    SYSZ_INS_OC,
    SYSZ_INS_OG,
    SYSZ_INS_OGR,
    SYSZ_INS_OGRK,
    SYSZ_INS_OI,
    SYSZ_INS_OIHF,
    SYSZ_INS_OIHH,
    SYSZ_INS_OIHL,
    SYSZ_INS_OILF,
    SYSZ_INS_OILH,
    SYSZ_INS_OILL,
    SYSZ_INS_OIY,
    SYSZ_INS_OR,
    SYSZ_INS_ORK,
    SYSZ_INS_OY,
    SYSZ_INS_PFD,
    SYSZ_INS_PFDRL,
    SYSZ_INS_RISBG,
    SYSZ_INS_RISBHG,
    SYSZ_INS_RISBLG,
    SYSZ_INS_RLL,
    SYSZ_INS_RLLG,
    SYSZ_INS_RNSBG,
    SYSZ_INS_ROSBG,
    SYSZ_INS_RXSBG,
    SYSZ_INS_S,
    SYSZ_INS_SDB,
    SYSZ_INS_SDBR,
    SYSZ_INS_SEB,
    SYSZ_INS_SEBR,
    SYSZ_INS_SG,
    SYSZ_INS_SGF,
    SYSZ_INS_SGFR,
    SYSZ_INS_SGR,
    SYSZ_INS_SGRK,
    SYSZ_INS_SH,
    SYSZ_INS_SHY,
    SYSZ_INS_SL,
    SYSZ_INS_SLB,
    SYSZ_INS_SLBG,
    SYSZ_INS_SLBR,
    SYSZ_INS_SLFI,
    SYSZ_INS_SLG,
    SYSZ_INS_SLBGR,
    SYSZ_INS_SLGF,
    SYSZ_INS_SLGFI,
    SYSZ_INS_SLGFR,
    SYSZ_INS_SLGR,
    SYSZ_INS_SLGRK,
    SYSZ_INS_SLL,
    SYSZ_INS_SLLG,
    SYSZ_INS_SLLK,
    SYSZ_INS_SLR,
    SYSZ_INS_SLRK,
    SYSZ_INS_SLY,
    SYSZ_INS_SQDB,
    SYSZ_INS_SQDBR,
    SYSZ_INS_SQEB,
    SYSZ_INS_SQEBR,
    SYSZ_INS_SQXBR,
    SYSZ_INS_SR,
    SYSZ_INS_SRA,
    SYSZ_INS_SRAG,
    SYSZ_INS_SRAK,
    SYSZ_INS_SRK,
    SYSZ_INS_SRL,
    SYSZ_INS_SRLG,
    SYSZ_INS_SRLK,
    SYSZ_INS_SRST,
    SYSZ_INS_ST,
    SYSZ_INS_STC,
    SYSZ_INS_STCH,
    SYSZ_INS_STCY,
    SYSZ_INS_STD,
    SYSZ_INS_STDY,
    SYSZ_INS_STE,
    SYSZ_INS_STEY,
    SYSZ_INS_STFH,
    SYSZ_INS_STG,
    SYSZ_INS_STGRL,
    SYSZ_INS_STH,
    SYSZ_INS_STHH,
    SYSZ_INS_STHRL,
    SYSZ_INS_STHY,
    SYSZ_INS_STMG,
    SYSZ_INS_STRL,
    SYSZ_INS_STRV,
    SYSZ_INS_STRVG,
    SYSZ_INS_STY,
    SYSZ_INS_SXBR,
    SYSZ_INS_SY,
    SYSZ_INS_TM,
    SYSZ_INS_TMHH,
    SYSZ_INS_TMHL,
    SYSZ_INS_TMLH,
    SYSZ_INS_TMLL,
    SYSZ_INS_TMY,
    SYSZ_INS_X,
    SYSZ_INS_XC,
    SYSZ_INS_XG,
    SYSZ_INS_XGR,
    SYSZ_INS_XGRK,
    SYSZ_INS_XI,
    SYSZ_INS_XIHF,
    SYSZ_INS_XILF,
    SYSZ_INS_XIY,
    SYSZ_INS_XR,
    SYSZ_INS_XRK,
    SYSZ_INS_XY,

    SYSZ_INS_ENDING,   // <-- mark the end of the list of instructions
} sysz_insn;

//> Group of SystemZ instructions
typedef enum sysz_insn_group
{
    SYSZ_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    SYSZ_GRP_JUMP,  // = CS_GRP_JUMP

    //> Architecture-specific groups
    SYSZ_GRP_DISTINCTOPS = 128,
    SYSZ_GRP_FPEXTENSION,
    SYSZ_GRP_HIGHWORD,
    SYSZ_GRP_INTERLOCKEDACCESS1,
    SYSZ_GRP_LOADSTOREONCOND,

    SYSZ_GRP_ENDING,   // <-- mark the end of the list of groups
} sysz_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/x86.h`:

```h
#ifndef CAPSTONE_X86_H
#define CAPSTONE_X86_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// Calculate relative address for X86-64, given cs_insn structure
#define X86_REL_ADDR(insn) (((insn).detail->x86.operands[0].type == X86_OP_IMM) \
    ? (uint64_t)((insn).detail->x86.operands[0].imm) \
    : (((insn).address + (insn).size) + (uint64_t)(insn).detail->x86.disp))

//> X86 registers
typedef enum x86_reg
{
    X86_REG_INVALID = 0,
    X86_REG_AH, X86_REG_AL, X86_REG_AX, X86_REG_BH, X86_REG_BL,
    X86_REG_BP, X86_REG_BPL, X86_REG_BX, X86_REG_CH, X86_REG_CL,
    X86_REG_CS, X86_REG_CX, X86_REG_DH, X86_REG_DI, X86_REG_DIL,
    X86_REG_DL, X86_REG_DS, X86_REG_DX, X86_REG_EAX, X86_REG_EBP,
    X86_REG_EBX, X86_REG_ECX, X86_REG_EDI, X86_REG_EDX, X86_REG_EFLAGS,
    X86_REG_EIP, X86_REG_EIZ, X86_REG_ES, X86_REG_ESI, X86_REG_ESP,
    X86_REG_FPSW, X86_REG_FS, X86_REG_GS, X86_REG_IP, X86_REG_RAX,
    X86_REG_RBP, X86_REG_RBX, X86_REG_RCX, X86_REG_RDI, X86_REG_RDX,
    X86_REG_RIP, X86_REG_RIZ, X86_REG_RSI, X86_REG_RSP, X86_REG_SI,
    X86_REG_SIL, X86_REG_SP, X86_REG_SPL, X86_REG_SS, X86_REG_CR0,
    X86_REG_CR1, X86_REG_CR2, X86_REG_CR3, X86_REG_CR4, X86_REG_CR5,
    X86_REG_CR6, X86_REG_CR7, X86_REG_CR8, X86_REG_CR9, X86_REG_CR10,
    X86_REG_CR11, X86_REG_CR12, X86_REG_CR13, X86_REG_CR14, X86_REG_CR15,
    X86_REG_DR0, X86_REG_DR1, X86_REG_DR2, X86_REG_DR3, X86_REG_DR4,
    X86_REG_DR5, X86_REG_DR6, X86_REG_DR7, X86_REG_DR8, X86_REG_DR9,
    X86_REG_DR10, X86_REG_DR11, X86_REG_DR12, X86_REG_DR13, X86_REG_DR14,
    X86_REG_DR15, X86_REG_FP0, X86_REG_FP1, X86_REG_FP2, X86_REG_FP3,
    X86_REG_FP4, X86_REG_FP5, X86_REG_FP6, X86_REG_FP7,
    X86_REG_K0, X86_REG_K1, X86_REG_K2, X86_REG_K3, X86_REG_K4,
    X86_REG_K5, X86_REG_K6, X86_REG_K7, X86_REG_MM0, X86_REG_MM1,
    X86_REG_MM2, X86_REG_MM3, X86_REG_MM4, X86_REG_MM5, X86_REG_MM6,
    X86_REG_MM7, X86_REG_R8, X86_REG_R9, X86_REG_R10, X86_REG_R11,
    X86_REG_R12, X86_REG_R13, X86_REG_R14, X86_REG_R15,
    X86_REG_ST0, X86_REG_ST1, X86_REG_ST2, X86_REG_ST3,
    X86_REG_ST4, X86_REG_ST5, X86_REG_ST6, X86_REG_ST7,
    X86_REG_XMM0, X86_REG_XMM1, X86_REG_XMM2, X86_REG_XMM3, X86_REG_XMM4,
    X86_REG_XMM5, X86_REG_XMM6, X86_REG_XMM7, X86_REG_XMM8, X86_REG_XMM9,
    X86_REG_XMM10, X86_REG_XMM11, X86_REG_XMM12, X86_REG_XMM13, X86_REG_XMM14,
    X86_REG_XMM15, X86_REG_XMM16, X86_REG_XMM17, X86_REG_XMM18, X86_REG_XMM19,
    X86_REG_XMM20, X86_REG_XMM21, X86_REG_XMM22, X86_REG_XMM23, X86_REG_XMM24,
    X86_REG_XMM25, X86_REG_XMM26, X86_REG_XMM27, X86_REG_XMM28, X86_REG_XMM29,
    X86_REG_XMM30, X86_REG_XMM31, X86_REG_YMM0, X86_REG_YMM1, X86_REG_YMM2,
    X86_REG_YMM3, X86_REG_YMM4, X86_REG_YMM5, X86_REG_YMM6, X86_REG_YMM7,
    X86_REG_YMM8, X86_REG_YMM9, X86_REG_YMM10, X86_REG_YMM11, X86_REG_YMM12,
    X86_REG_YMM13, X86_REG_YMM14, X86_REG_YMM15, X86_REG_YMM16, X86_REG_YMM17,
    X86_REG_YMM18, X86_REG_YMM19, X86_REG_YMM20, X86_REG_YMM21, X86_REG_YMM22,
    X86_REG_YMM23, X86_REG_YMM24, X86_REG_YMM25, X86_REG_YMM26, X86_REG_YMM27,
    X86_REG_YMM28, X86_REG_YMM29, X86_REG_YMM30, X86_REG_YMM31, X86_REG_ZMM0,
    X86_REG_ZMM1, X86_REG_ZMM2, X86_REG_ZMM3, X86_REG_ZMM4, X86_REG_ZMM5,
    X86_REG_ZMM6, X86_REG_ZMM7, X86_REG_ZMM8, X86_REG_ZMM9, X86_REG_ZMM10,
    X86_REG_ZMM11, X86_REG_ZMM12, X86_REG_ZMM13, X86_REG_ZMM14, X86_REG_ZMM15,
    X86_REG_ZMM16, X86_REG_ZMM17, X86_REG_ZMM18, X86_REG_ZMM19, X86_REG_ZMM20,
    X86_REG_ZMM21, X86_REG_ZMM22, X86_REG_ZMM23, X86_REG_ZMM24, X86_REG_ZMM25,
    X86_REG_ZMM26, X86_REG_ZMM27, X86_REG_ZMM28, X86_REG_ZMM29, X86_REG_ZMM30,
    X86_REG_ZMM31, X86_REG_R8B, X86_REG_R9B, X86_REG_R10B, X86_REG_R11B,
    X86_REG_R12B, X86_REG_R13B, X86_REG_R14B, X86_REG_R15B, X86_REG_R8D,
    X86_REG_R9D, X86_REG_R10D, X86_REG_R11D, X86_REG_R12D, X86_REG_R13D,
    X86_REG_R14D, X86_REG_R15D, X86_REG_R8W, X86_REG_R9W, X86_REG_R10W,
    X86_REG_R11W, X86_REG_R12W, X86_REG_R13W, X86_REG_R14W, X86_REG_R15W,

    X86_REG_ENDING      // <-- mark the end of the list of registers
} x86_reg;

//> Sub-flags of EFLAGS
#define X86_EFLAGS_MODIFY_AF (1ULL << 0)
#define X86_EFLAGS_MODIFY_CF (1ULL << 1)
#define X86_EFLAGS_MODIFY_SF (1ULL << 2)
#define X86_EFLAGS_MODIFY_ZF (1ULL << 3)
#define X86_EFLAGS_MODIFY_PF (1ULL << 4)
#define X86_EFLAGS_MODIFY_OF (1ULL << 5)
#define X86_EFLAGS_MODIFY_TF (1ULL << 6)
#define X86_EFLAGS_MODIFY_IF (1ULL << 7)
#define X86_EFLAGS_MODIFY_DF (1ULL << 8)
#define X86_EFLAGS_MODIFY_NT (1ULL << 9)
#define X86_EFLAGS_MODIFY_RF (1ULL << 10)
#define X86_EFLAGS_PRIOR_OF (1ULL << 11)
#define X86_EFLAGS_PRIOR_SF (1ULL << 12)
#define X86_EFLAGS_PRIOR_ZF (1ULL << 13)
#define X86_EFLAGS_PRIOR_AF (1ULL << 14)
#define X86_EFLAGS_PRIOR_PF (1ULL << 15)
#define X86_EFLAGS_PRIOR_CF (1ULL << 16)
#define X86_EFLAGS_PRIOR_TF (1ULL << 17)
#define X86_EFLAGS_PRIOR_IF (1ULL << 18)
#define X86_EFLAGS_PRIOR_DF (1ULL << 19)
#define X86_EFLAGS_PRIOR_NT (1ULL << 20)
#define X86_EFLAGS_RESET_OF (1ULL << 21)
#define X86_EFLAGS_RESET_CF (1ULL << 22)
#define X86_EFLAGS_RESET_DF (1ULL << 23)
#define X86_EFLAGS_RESET_IF (1ULL << 24)
#define X86_EFLAGS_RESET_SF (1ULL << 25)
#define X86_EFLAGS_RESET_AF (1ULL << 26)
#define X86_EFLAGS_RESET_TF (1ULL << 27)
#define X86_EFLAGS_RESET_NT (1ULL << 28)
#define X86_EFLAGS_RESET_PF (1ULL << 29)
#define X86_EFLAGS_SET_CF (1ULL << 30)
#define X86_EFLAGS_SET_DF (1ULL << 31)
#define X86_EFLAGS_SET_IF (1ULL << 32)
#define X86_EFLAGS_TEST_OF (1ULL << 33)
#define X86_EFLAGS_TEST_SF (1ULL << 34)
#define X86_EFLAGS_TEST_ZF (1ULL << 35)
#define X86_EFLAGS_TEST_PF (1ULL << 36)
#define X86_EFLAGS_TEST_CF (1ULL << 37)
#define X86_EFLAGS_TEST_NT (1ULL << 38)
#define X86_EFLAGS_TEST_DF (1ULL << 39)
#define X86_EFLAGS_UNDEFINED_OF (1ULL << 40)
#define X86_EFLAGS_UNDEFINED_SF (1ULL << 41)
#define X86_EFLAGS_UNDEFINED_ZF (1ULL << 42)
#define X86_EFLAGS_UNDEFINED_PF (1ULL << 43)
#define X86_EFLAGS_UNDEFINED_AF (1ULL << 44)
#define X86_EFLAGS_UNDEFINED_CF (1ULL << 45)

//> Operand type for instruction's operands
typedef enum x86_op_type
{
    X86_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    X86_OP_REG, // = CS_OP_REG (Register operand).
    X86_OP_IMM, // = CS_OP_IMM (Immediate operand).
    X86_OP_MEM, // = CS_OP_MEM (Memory operand).
} x86_op_type;

//> XOP Code Condition type
typedef enum x86_xop_cc
{
    X86_XOP_CC_INVALID = 0, // Uninitialized.
    X86_XOP_CC_LT,
    X86_XOP_CC_LE,
    X86_XOP_CC_GT,
    X86_XOP_CC_GE,
    X86_XOP_CC_EQ,
    X86_XOP_CC_NEQ,
    X86_XOP_CC_FALSE,
    X86_XOP_CC_TRUE,
} x86_xop_cc;

//> AVX broadcast type
typedef enum x86_avx_bcast
{
    X86_AVX_BCAST_INVALID = 0,  // Uninitialized.
    X86_AVX_BCAST_2,    // AVX512 broadcast type {1to2}
    X86_AVX_BCAST_4,    // AVX512 broadcast type {1to4}
    X86_AVX_BCAST_8,    // AVX512 broadcast type {1to8}
    X86_AVX_BCAST_16,   // AVX512 broadcast type {1to16}
} x86_avx_bcast;

//> SSE Code Condition type
typedef enum x86_sse_cc
{
    X86_SSE_CC_INVALID = 0, // Uninitialized.
    X86_SSE_CC_EQ,
    X86_SSE_CC_LT,
    X86_SSE_CC_LE,
    X86_SSE_CC_UNORD,
    X86_SSE_CC_NEQ,
    X86_SSE_CC_NLT,
    X86_SSE_CC_NLE,
    X86_SSE_CC_ORD,
} x86_sse_cc;

//> AVX Code Condition type
typedef enum x86_avx_cc
{
    X86_AVX_CC_INVALID = 0, // Uninitialized.
    X86_AVX_CC_EQ,
    X86_AVX_CC_LT,
    X86_AVX_CC_LE,
    X86_AVX_CC_UNORD,
    X86_AVX_CC_NEQ,
    X86_AVX_CC_NLT,
    X86_AVX_CC_NLE,
    X86_AVX_CC_ORD,
    X86_AVX_CC_EQ_UQ,
    X86_AVX_CC_NGE,
    X86_AVX_CC_NGT,
    X86_AVX_CC_FALSE,
    X86_AVX_CC_NEQ_OQ,
    X86_AVX_CC_GE,
    X86_AVX_CC_GT,
    X86_AVX_CC_TRUE,
    X86_AVX_CC_EQ_OS,
    X86_AVX_CC_LT_OQ,
    X86_AVX_CC_LE_OQ,
    X86_AVX_CC_UNORD_S,
    X86_AVX_CC_NEQ_US,
    X86_AVX_CC_NLT_UQ,
    X86_AVX_CC_NLE_UQ,
    X86_AVX_CC_ORD_S,
    X86_AVX_CC_EQ_US,
    X86_AVX_CC_NGE_UQ,
    X86_AVX_CC_NGT_UQ,
    X86_AVX_CC_FALSE_OS,
    X86_AVX_CC_NEQ_OS,
    X86_AVX_CC_GE_OQ,
    X86_AVX_CC_GT_OQ,
    X86_AVX_CC_TRUE_US,
} x86_avx_cc;

//> AVX static rounding mode type
typedef enum x86_avx_rm
{
    X86_AVX_RM_INVALID = 0, // Uninitialized.
    X86_AVX_RM_RN,  // Round to nearest
    X86_AVX_RM_RD,  // Round down
    X86_AVX_RM_RU,  // Round up
    X86_AVX_RM_RZ,  // Round toward zero
} x86_avx_rm;

//> Instruction prefixes - to be used in cs_x86.prefix[]
typedef enum x86_prefix
{
    X86_PREFIX_LOCK     =   0xf0,   // lock (cs_x86.prefix[0]
    X86_PREFIX_REP      =   0xf3,   // rep (cs_x86.prefix[0]
    X86_PREFIX_REPE     =   0xf3,   // repe/repz (cs_x86.prefix[0]
    X86_PREFIX_REPNE    =   0xf2,   // repne/repnz (cs_x86.prefix[0]

    X86_PREFIX_CS       =   0x2e,   // segment override CS (cs_x86.prefix[1]
    X86_PREFIX_SS       =   0x36,   // segment override SS (cs_x86.prefix[1]
    X86_PREFIX_DS       =   0x3e,   // segment override DS (cs_x86.prefix[1]
    X86_PREFIX_ES       =   0x26,   // segment override ES (cs_x86.prefix[1]
    X86_PREFIX_FS       =   0x64,   // segment override FS (cs_x86.prefix[1]
    X86_PREFIX_GS       =   0x65,   // segment override GS (cs_x86.prefix[1]

    X86_PREFIX_OPSIZE   =   0x66,   // operand-size override (cs_x86.prefix[2]
    X86_PREFIX_ADDRSIZE =   0x67,   // address-size override (cs_x86.prefix[3]
} x86_prefix;

// Instruction's operand referring to memory
// This is associated with X86_OP_MEM operand type above
typedef struct x86_op_mem
{
    x86_reg segment; // segment register (or X86_REG_INVALID if irrelevant)
    x86_reg base;   // base register (or X86_REG_INVALID if irrelevant)
    x86_reg index;  // index register (or X86_REG_INVALID if irrelevant)
    int scale;  // scale for index register
    int64_t disp;   // displacement value
} x86_op_mem;

// Instruction operand
typedef struct cs_x86_op
{
    x86_op_type type;   // operand type
    union
    {
        x86_reg reg;      // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        x86_op_mem mem;     // base/index/scale/disp value for MEM operand
    };

    // size of this operand (in bytes).
    uint8_t size;

    // How is this operand accessed? (READ, WRITE or READ|WRITE)
    // This field is combined of cs_ac_type.
    // NOTE: this field is irrelevant if engine is compiled in DIET mode.
    uint8_t access;

    // AVX broadcast type, or 0 if irrelevant
    x86_avx_bcast avx_bcast;

    // AVX zero opmask {z}
    bool avx_zero_opmask;
} cs_x86_op;

// Instruction structure
typedef struct cs_x86
{
    // Instruction prefix, which can be up to 4 bytes.
    // A prefix byte gets value 0 when irrelevant.
    // prefix[0] indicates REP/REPNE/LOCK prefix (See X86_PREFIX_REP/REPNE/LOCK above)
    // prefix[1] indicates segment override (irrelevant for x86_64):
    // See X86_PREFIX_CS/SS/DS/ES/FS/GS above.
    // prefix[2] indicates operand-size override (X86_PREFIX_OPSIZE)
    // prefix[3] indicates address-size override (X86_PREFIX_ADDRSIZE)
    uint8_t prefix[4];

    // Instruction opcode, which can be from 1 to 4 bytes in size.
    // This contains VEX opcode as well.
    // An trailing opcode byte gets value 0 when irrelevant.
    uint8_t opcode[4];

    // REX prefix: only a non-zero value is relevant for x86_64
    uint8_t rex;

    // Address size, which can be overridden with above prefix[5].
    uint8_t addr_size;

    // ModR/M byte
    uint8_t modrm;

    // SIB value, or 0 when irrelevant.
    uint8_t sib;

    // Displacement value, or 0 when irrelevant.
    int32_t disp;

    /* SIB state */
    // SIB index register, or X86_REG_INVALID when irrelevant.
    x86_reg sib_index;
    // SIB scale. only applicable if sib_index is relevant.
    int8_t sib_scale;
    // SIB base register, or X86_REG_INVALID when irrelevant.
    x86_reg sib_base;

    // XOP Code Condition
    x86_xop_cc xop_cc;

    // SSE Code Condition
    x86_sse_cc sse_cc;

    // AVX Code Condition
    x86_avx_cc avx_cc;

    // AVX Suppress all Exception
    bool avx_sae;

    // AVX static rounding mode
    x86_avx_rm avx_rm;

    // EFLAGS updated by this instruction.
    // This can be formed from OR combination of X86_EFLAGS_* symbols in x86.h
    uint64_t eflags;

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;

    cs_x86_op operands[8];  // operands for this instruction.
} cs_x86;

//> X86 instructions
typedef enum x86_insn
{
    X86_INS_INVALID = 0,

    X86_INS_AAA,
    X86_INS_AAD,
    X86_INS_AAM,
    X86_INS_AAS,
    X86_INS_FABS,
    X86_INS_ADC,
    X86_INS_ADCX,
    X86_INS_ADD,
    X86_INS_ADDPD,
    X86_INS_ADDPS,
    X86_INS_ADDSD,
    X86_INS_ADDSS,
    X86_INS_ADDSUBPD,
    X86_INS_ADDSUBPS,
    X86_INS_FADD,
    X86_INS_FIADD,
    X86_INS_FADDP,
    X86_INS_ADOX,
    X86_INS_AESDECLAST,
    X86_INS_AESDEC,
    X86_INS_AESENCLAST,
    X86_INS_AESENC,
    X86_INS_AESIMC,
    X86_INS_AESKEYGENASSIST,
    X86_INS_AND,
    X86_INS_ANDN,
    X86_INS_ANDNPD,
    X86_INS_ANDNPS,
    X86_INS_ANDPD,
    X86_INS_ANDPS,
    X86_INS_ARPL,
    X86_INS_BEXTR,
    X86_INS_BLCFILL,
    X86_INS_BLCI,
    X86_INS_BLCIC,
    X86_INS_BLCMSK,
    X86_INS_BLCS,
    X86_INS_BLENDPD,
    X86_INS_BLENDPS,
    X86_INS_BLENDVPD,
    X86_INS_BLENDVPS,
    X86_INS_BLSFILL,
    X86_INS_BLSI,
    X86_INS_BLSIC,
    X86_INS_BLSMSK,
    X86_INS_BLSR,
    X86_INS_BOUND,
    X86_INS_BSF,
    X86_INS_BSR,
    X86_INS_BSWAP,
    X86_INS_BT,
    X86_INS_BTC,
    X86_INS_BTR,
    X86_INS_BTS,
    X86_INS_BZHI,
    X86_INS_CALL,
    X86_INS_CBW,
    X86_INS_CDQ,
    X86_INS_CDQE,
    X86_INS_FCHS,
    X86_INS_CLAC,
    X86_INS_CLC,
    X86_INS_CLD,
    X86_INS_CLFLUSH,
    X86_INS_CLFLUSHOPT,
    X86_INS_CLGI,
    X86_INS_CLI,
    X86_INS_CLTS,
    X86_INS_CLWB,
    X86_INS_CMC,
    X86_INS_CMOVA,
    X86_INS_CMOVAE,
    X86_INS_CMOVB,
    X86_INS_CMOVBE,
    X86_INS_FCMOVBE,
    X86_INS_FCMOVB,
    X86_INS_CMOVE,
    X86_INS_FCMOVE,
    X86_INS_CMOVG,
    X86_INS_CMOVGE,
    X86_INS_CMOVL,
    X86_INS_CMOVLE,
    X86_INS_FCMOVNBE,
    X86_INS_FCMOVNB,
    X86_INS_CMOVNE,
    X86_INS_FCMOVNE,
    X86_INS_CMOVNO,
    X86_INS_CMOVNP,
    X86_INS_FCMOVNU,
    X86_INS_CMOVNS,
    X86_INS_CMOVO,
    X86_INS_CMOVP,
    X86_INS_FCMOVU,
    X86_INS_CMOVS,
    X86_INS_CMP,
    X86_INS_CMPSB,
    X86_INS_CMPSQ,
    X86_INS_CMPSW,
    X86_INS_CMPXCHG16B,
    X86_INS_CMPXCHG,
    X86_INS_CMPXCHG8B,
    X86_INS_COMISD,
    X86_INS_COMISS,
    X86_INS_FCOMP,
    X86_INS_FCOMIP,
    X86_INS_FCOMI,
    X86_INS_FCOM,
    X86_INS_FCOS,
    X86_INS_CPUID,
    X86_INS_CQO,
    X86_INS_CRC32,
    X86_INS_CVTDQ2PD,
    X86_INS_CVTDQ2PS,
    X86_INS_CVTPD2DQ,
    X86_INS_CVTPD2PS,
    X86_INS_CVTPS2DQ,
    X86_INS_CVTPS2PD,
    X86_INS_CVTSD2SI,
    X86_INS_CVTSD2SS,
    X86_INS_CVTSI2SD,
    X86_INS_CVTSI2SS,
    X86_INS_CVTSS2SD,
    X86_INS_CVTSS2SI,
    X86_INS_CVTTPD2DQ,
    X86_INS_CVTTPS2DQ,
    X86_INS_CVTTSD2SI,
    X86_INS_CVTTSS2SI,
    X86_INS_CWD,
    X86_INS_CWDE,
    X86_INS_DAA,
    X86_INS_DAS,
    X86_INS_DATA16,
    X86_INS_DEC,
    X86_INS_DIV,
    X86_INS_DIVPD,
    X86_INS_DIVPS,
    X86_INS_FDIVR,
    X86_INS_FIDIVR,
    X86_INS_FDIVRP,
    X86_INS_DIVSD,
    X86_INS_DIVSS,
    X86_INS_FDIV,
    X86_INS_FIDIV,
    X86_INS_FDIVP,
    X86_INS_DPPD,
    X86_INS_DPPS,
    X86_INS_RET,
    X86_INS_ENCLS,
    X86_INS_ENCLU,
    X86_INS_ENTER,
    X86_INS_EXTRACTPS,
    X86_INS_EXTRQ,
    X86_INS_F2XM1,
    X86_INS_LCALL,
    X86_INS_LJMP,
    X86_INS_FBLD,
    X86_INS_FBSTP,
    X86_INS_FCOMPP,
    X86_INS_FDECSTP,
    X86_INS_FEMMS,
    X86_INS_FFREE,
    X86_INS_FICOM,
    X86_INS_FICOMP,
    X86_INS_FINCSTP,
    X86_INS_FLDCW,
    X86_INS_FLDENV,
    X86_INS_FLDL2E,
    X86_INS_FLDL2T,
    X86_INS_FLDLG2,
    X86_INS_FLDLN2,
    X86_INS_FLDPI,
    X86_INS_FNCLEX,
    X86_INS_FNINIT,
    X86_INS_FNOP,
    X86_INS_FNSTCW,
    X86_INS_FNSTSW,
    X86_INS_FPATAN,
    X86_INS_FPREM,
    X86_INS_FPREM1,
    X86_INS_FPTAN,
    X86_INS_FFREEP,
    X86_INS_FRNDINT,
    X86_INS_FRSTOR,
    X86_INS_FNSAVE,
    X86_INS_FSCALE,
    X86_INS_FSETPM,
    X86_INS_FSINCOS,
    X86_INS_FNSTENV,
    X86_INS_FXAM,
    X86_INS_FXRSTOR,
    X86_INS_FXRSTOR64,
    X86_INS_FXSAVE,
    X86_INS_FXSAVE64,
    X86_INS_FXTRACT,
    X86_INS_FYL2X,
    X86_INS_FYL2XP1,
    X86_INS_MOVAPD,
    X86_INS_MOVAPS,
    X86_INS_ORPD,
    X86_INS_ORPS,
    X86_INS_VMOVAPD,
    X86_INS_VMOVAPS,
    X86_INS_XORPD,
    X86_INS_XORPS,
    X86_INS_GETSEC,
    X86_INS_HADDPD,
    X86_INS_HADDPS,
    X86_INS_HLT,
    X86_INS_HSUBPD,
    X86_INS_HSUBPS,
    X86_INS_IDIV,
    X86_INS_FILD,
    X86_INS_IMUL,
    X86_INS_IN,
    X86_INS_INC,
    X86_INS_INSB,
    X86_INS_INSERTPS,
    X86_INS_INSERTQ,
    X86_INS_INSD,
    X86_INS_INSW,
    X86_INS_INT,
    X86_INS_INT1,
    X86_INS_INT3,
    X86_INS_INTO,
    X86_INS_INVD,
    X86_INS_INVEPT,
    X86_INS_INVLPG,
    X86_INS_INVLPGA,
    X86_INS_INVPCID,
    X86_INS_INVVPID,
    X86_INS_IRET,
    X86_INS_IRETD,
    X86_INS_IRETQ,
    X86_INS_FISTTP,
    X86_INS_FIST,
    X86_INS_FISTP,
    X86_INS_UCOMISD,
    X86_INS_UCOMISS,
    X86_INS_VCOMISD,
    X86_INS_VCOMISS,
    X86_INS_VCVTSD2SS,
    X86_INS_VCVTSI2SD,
    X86_INS_VCVTSI2SS,
    X86_INS_VCVTSS2SD,
    X86_INS_VCVTTSD2SI,
    X86_INS_VCVTTSD2USI,
    X86_INS_VCVTTSS2SI,
    X86_INS_VCVTTSS2USI,
    X86_INS_VCVTUSI2SD,
    X86_INS_VCVTUSI2SS,
    X86_INS_VUCOMISD,
    X86_INS_VUCOMISS,
    X86_INS_JAE,
    X86_INS_JA,
    X86_INS_JBE,
    X86_INS_JB,
    X86_INS_JCXZ,
    X86_INS_JECXZ,
    X86_INS_JE,
    X86_INS_JGE,
    X86_INS_JG,
    X86_INS_JLE,
    X86_INS_JL,
    X86_INS_JMP,
    X86_INS_JNE,
    X86_INS_JNO,
    X86_INS_JNP,
    X86_INS_JNS,
    X86_INS_JO,
    X86_INS_JP,
    X86_INS_JRCXZ,
    X86_INS_JS,
    X86_INS_KANDB,
    X86_INS_KANDD,
    X86_INS_KANDNB,
    X86_INS_KANDND,
    X86_INS_KANDNQ,
    X86_INS_KANDNW,
    X86_INS_KANDQ,
    X86_INS_KANDW,
    X86_INS_KMOVB,
    X86_INS_KMOVD,
    X86_INS_KMOVQ,
    X86_INS_KMOVW,
    X86_INS_KNOTB,
    X86_INS_KNOTD,
    X86_INS_KNOTQ,
    X86_INS_KNOTW,
    X86_INS_KORB,
    X86_INS_KORD,
    X86_INS_KORQ,
    X86_INS_KORTESTB,
    X86_INS_KORTESTD,
    X86_INS_KORTESTQ,
    X86_INS_KORTESTW,
    X86_INS_KORW,
    X86_INS_KSHIFTLB,
    X86_INS_KSHIFTLD,
    X86_INS_KSHIFTLQ,
    X86_INS_KSHIFTLW,
    X86_INS_KSHIFTRB,
    X86_INS_KSHIFTRD,
    X86_INS_KSHIFTRQ,
    X86_INS_KSHIFTRW,
    X86_INS_KUNPCKBW,
    X86_INS_KXNORB,
    X86_INS_KXNORD,
    X86_INS_KXNORQ,
    X86_INS_KXNORW,
    X86_INS_KXORB,
    X86_INS_KXORD,
    X86_INS_KXORQ,
    X86_INS_KXORW,
    X86_INS_LAHF,
    X86_INS_LAR,
    X86_INS_LDDQU,
    X86_INS_LDMXCSR,
    X86_INS_LDS,
    X86_INS_FLDZ,
    X86_INS_FLD1,
    X86_INS_FLD,
    X86_INS_LEA,
    X86_INS_LEAVE,
    X86_INS_LES,
    X86_INS_LFENCE,
    X86_INS_LFS,
    X86_INS_LGDT,
    X86_INS_LGS,
    X86_INS_LIDT,
    X86_INS_LLDT,
    X86_INS_LMSW,
    X86_INS_OR,
    X86_INS_SUB,
    X86_INS_XOR,
    X86_INS_LODSB,
    X86_INS_LODSD,
    X86_INS_LODSQ,
    X86_INS_LODSW,
    X86_INS_LOOP,
    X86_INS_LOOPE,
    X86_INS_LOOPNE,
    X86_INS_RETF,
    X86_INS_RETFQ,
    X86_INS_LSL,
    X86_INS_LSS,
    X86_INS_LTR,
    X86_INS_XADD,
    X86_INS_LZCNT,
    X86_INS_MASKMOVDQU,
    X86_INS_MAXPD,
    X86_INS_MAXPS,
    X86_INS_MAXSD,
    X86_INS_MAXSS,
    X86_INS_MFENCE,
    X86_INS_MINPD,
    X86_INS_MINPS,
    X86_INS_MINSD,
    X86_INS_MINSS,
    X86_INS_CVTPD2PI,
    X86_INS_CVTPI2PD,
    X86_INS_CVTPI2PS,
    X86_INS_CVTPS2PI,
    X86_INS_CVTTPD2PI,
    X86_INS_CVTTPS2PI,
    X86_INS_EMMS,
    X86_INS_MASKMOVQ,
    X86_INS_MOVD,
    X86_INS_MOVDQ2Q,
    X86_INS_MOVNTQ,
    X86_INS_MOVQ2DQ,
    X86_INS_MOVQ,
    X86_INS_PABSB,
    X86_INS_PABSD,
    X86_INS_PABSW,
    X86_INS_PACKSSDW,
    X86_INS_PACKSSWB,
    X86_INS_PACKUSWB,
    X86_INS_PADDB,
    X86_INS_PADDD,
    X86_INS_PADDQ,
    X86_INS_PADDSB,
    X86_INS_PADDSW,
    X86_INS_PADDUSB,
    X86_INS_PADDUSW,
    X86_INS_PADDW,
    X86_INS_PALIGNR,
    X86_INS_PANDN,
    X86_INS_PAND,
    X86_INS_PAVGB,
    X86_INS_PAVGW,
    X86_INS_PCMPEQB,
    X86_INS_PCMPEQD,
    X86_INS_PCMPEQW,
    X86_INS_PCMPGTB,
    X86_INS_PCMPGTD,
    X86_INS_PCMPGTW,
    X86_INS_PEXTRW,
    X86_INS_PHADDSW,
    X86_INS_PHADDW,
    X86_INS_PHADDD,
    X86_INS_PHSUBD,
    X86_INS_PHSUBSW,
    X86_INS_PHSUBW,
    X86_INS_PINSRW,
    X86_INS_PMADDUBSW,
    X86_INS_PMADDWD,
    X86_INS_PMAXSW,
    X86_INS_PMAXUB,
    X86_INS_PMINSW,
    X86_INS_PMINUB,
    X86_INS_PMOVMSKB,
    X86_INS_PMULHRSW,
    X86_INS_PMULHUW,
    X86_INS_PMULHW,
    X86_INS_PMULLW,
    X86_INS_PMULUDQ,
    X86_INS_POR,
    X86_INS_PSADBW,
    X86_INS_PSHUFB,
    X86_INS_PSHUFW,
    X86_INS_PSIGNB,
    X86_INS_PSIGND,
    X86_INS_PSIGNW,
    X86_INS_PSLLD,
    X86_INS_PSLLQ,
    X86_INS_PSLLW,
    X86_INS_PSRAD,
    X86_INS_PSRAW,
    X86_INS_PSRLD,
    X86_INS_PSRLQ,
    X86_INS_PSRLW,
    X86_INS_PSUBB,
    X86_INS_PSUBD,
    X86_INS_PSUBQ,
    X86_INS_PSUBSB,
    X86_INS_PSUBSW,
    X86_INS_PSUBUSB,
    X86_INS_PSUBUSW,
    X86_INS_PSUBW,
    X86_INS_PUNPCKHBW,
    X86_INS_PUNPCKHDQ,
    X86_INS_PUNPCKHWD,
    X86_INS_PUNPCKLBW,
    X86_INS_PUNPCKLDQ,
    X86_INS_PUNPCKLWD,
    X86_INS_PXOR,
    X86_INS_MONITOR,
    X86_INS_MONTMUL,
    X86_INS_MOV,
    X86_INS_MOVABS,
    X86_INS_MOVBE,
    X86_INS_MOVDDUP,
    X86_INS_MOVDQA,
    X86_INS_MOVDQU,
    X86_INS_MOVHLPS,
    X86_INS_MOVHPD,
    X86_INS_MOVHPS,
    X86_INS_MOVLHPS,
    X86_INS_MOVLPD,
    X86_INS_MOVLPS,
    X86_INS_MOVMSKPD,
    X86_INS_MOVMSKPS,
    X86_INS_MOVNTDQA,
    X86_INS_MOVNTDQ,
    X86_INS_MOVNTI,
    X86_INS_MOVNTPD,
    X86_INS_MOVNTPS,
    X86_INS_MOVNTSD,
    X86_INS_MOVNTSS,
    X86_INS_MOVSB,
    X86_INS_MOVSD,
    X86_INS_MOVSHDUP,
    X86_INS_MOVSLDUP,
    X86_INS_MOVSQ,
    X86_INS_MOVSS,
    X86_INS_MOVSW,
    X86_INS_MOVSX,
    X86_INS_MOVSXD,
    X86_INS_MOVUPD,
    X86_INS_MOVUPS,
    X86_INS_MOVZX,
    X86_INS_MPSADBW,
    X86_INS_MUL,
    X86_INS_MULPD,
    X86_INS_MULPS,
    X86_INS_MULSD,
    X86_INS_MULSS,
    X86_INS_MULX,
    X86_INS_FMUL,
    X86_INS_FIMUL,
    X86_INS_FMULP,
    X86_INS_MWAIT,
    X86_INS_NEG,
    X86_INS_NOP,
    X86_INS_NOT,
    X86_INS_OUT,
    X86_INS_OUTSB,
    X86_INS_OUTSD,
    X86_INS_OUTSW,
    X86_INS_PACKUSDW,
    X86_INS_PAUSE,
    X86_INS_PAVGUSB,
    X86_INS_PBLENDVB,
    X86_INS_PBLENDW,
    X86_INS_PCLMULQDQ,
    X86_INS_PCMPEQQ,
    X86_INS_PCMPESTRI,
    X86_INS_PCMPESTRM,
    X86_INS_PCMPGTQ,
    X86_INS_PCMPISTRI,
    X86_INS_PCMPISTRM,
    X86_INS_PCOMMIT,
    X86_INS_PDEP,
    X86_INS_PEXT,
    X86_INS_PEXTRB,
    X86_INS_PEXTRD,
    X86_INS_PEXTRQ,
    X86_INS_PF2ID,
    X86_INS_PF2IW,
    X86_INS_PFACC,
    X86_INS_PFADD,
    X86_INS_PFCMPEQ,
    X86_INS_PFCMPGE,
    X86_INS_PFCMPGT,
    X86_INS_PFMAX,
    X86_INS_PFMIN,
    X86_INS_PFMUL,
    X86_INS_PFNACC,
    X86_INS_PFPNACC,
    X86_INS_PFRCPIT1,
    X86_INS_PFRCPIT2,
    X86_INS_PFRCP,
    X86_INS_PFRSQIT1,
    X86_INS_PFRSQRT,
    X86_INS_PFSUBR,
    X86_INS_PFSUB,
    X86_INS_PHMINPOSUW,
    X86_INS_PI2FD,
    X86_INS_PI2FW,
    X86_INS_PINSRB,
    X86_INS_PINSRD,
    X86_INS_PINSRQ,
    X86_INS_PMAXSB,
    X86_INS_PMAXSD,
    X86_INS_PMAXUD,
    X86_INS_PMAXUW,
    X86_INS_PMINSB,
    X86_INS_PMINSD,
    X86_INS_PMINUD,
    X86_INS_PMINUW,
    X86_INS_PMOVSXBD,
    X86_INS_PMOVSXBQ,
    X86_INS_PMOVSXBW,
    X86_INS_PMOVSXDQ,
    X86_INS_PMOVSXWD,
    X86_INS_PMOVSXWQ,
    X86_INS_PMOVZXBD,
    X86_INS_PMOVZXBQ,
    X86_INS_PMOVZXBW,
    X86_INS_PMOVZXDQ,
    X86_INS_PMOVZXWD,
    X86_INS_PMOVZXWQ,
    X86_INS_PMULDQ,
    X86_INS_PMULHRW,
    X86_INS_PMULLD,
    X86_INS_POP,
    X86_INS_POPAW,
    X86_INS_POPAL,
    X86_INS_POPCNT,
    X86_INS_POPF,
    X86_INS_POPFD,
    X86_INS_POPFQ,
    X86_INS_PREFETCH,
    X86_INS_PREFETCHNTA,
    X86_INS_PREFETCHT0,
    X86_INS_PREFETCHT1,
    X86_INS_PREFETCHT2,
    X86_INS_PREFETCHW,
    X86_INS_PSHUFD,
    X86_INS_PSHUFHW,
    X86_INS_PSHUFLW,
    X86_INS_PSLLDQ,
    X86_INS_PSRLDQ,
    X86_INS_PSWAPD,
    X86_INS_PTEST,
    X86_INS_PUNPCKHQDQ,
    X86_INS_PUNPCKLQDQ,
    X86_INS_PUSH,
    X86_INS_PUSHAW,
    X86_INS_PUSHAL,
    X86_INS_PUSHF,
    X86_INS_PUSHFD,
    X86_INS_PUSHFQ,
    X86_INS_RCL,
    X86_INS_RCPPS,
    X86_INS_RCPSS,
    X86_INS_RCR,
    X86_INS_RDFSBASE,
    X86_INS_RDGSBASE,
    X86_INS_RDMSR,
    X86_INS_RDPMC,
    X86_INS_RDRAND,
    X86_INS_RDSEED,
    X86_INS_RDTSC,
    X86_INS_RDTSCP,
    X86_INS_ROL,
    X86_INS_ROR,
    X86_INS_RORX,
    X86_INS_ROUNDPD,
    X86_INS_ROUNDPS,
    X86_INS_ROUNDSD,
    X86_INS_ROUNDSS,
    X86_INS_RSM,
    X86_INS_RSQRTPS,
    X86_INS_RSQRTSS,
    X86_INS_SAHF,
    X86_INS_SAL,
    X86_INS_SALC,
    X86_INS_SAR,
    X86_INS_SARX,
    X86_INS_SBB,
    X86_INS_SCASB,
    X86_INS_SCASD,
    X86_INS_SCASQ,
    X86_INS_SCASW,
    X86_INS_SETAE,
    X86_INS_SETA,
    X86_INS_SETBE,
    X86_INS_SETB,
    X86_INS_SETE,
    X86_INS_SETGE,
    X86_INS_SETG,
    X86_INS_SETLE,
    X86_INS_SETL,
    X86_INS_SETNE,
    X86_INS_SETNO,
    X86_INS_SETNP,
    X86_INS_SETNS,
    X86_INS_SETO,
    X86_INS_SETP,
    X86_INS_SETS,
    X86_INS_SFENCE,
    X86_INS_SGDT,
    X86_INS_SHA1MSG1,
    X86_INS_SHA1MSG2,
    X86_INS_SHA1NEXTE,
    X86_INS_SHA1RNDS4,
    X86_INS_SHA256MSG1,
    X86_INS_SHA256MSG2,
    X86_INS_SHA256RNDS2,
    X86_INS_SHL,
    X86_INS_SHLD,
    X86_INS_SHLX,
    X86_INS_SHR,
    X86_INS_SHRD,
    X86_INS_SHRX,
    X86_INS_SHUFPD,
    X86_INS_SHUFPS,
    X86_INS_SIDT,
    X86_INS_FSIN,
    X86_INS_SKINIT,
    X86_INS_SLDT,
    X86_INS_SMSW,
    X86_INS_SQRTPD,
    X86_INS_SQRTPS,
    X86_INS_SQRTSD,
    X86_INS_SQRTSS,
    X86_INS_FSQRT,
    X86_INS_STAC,
    X86_INS_STC,
    X86_INS_STD,
    X86_INS_STGI,
    X86_INS_STI,
    X86_INS_STMXCSR,
    X86_INS_STOSB,
    X86_INS_STOSD,
    X86_INS_STOSQ,
    X86_INS_STOSW,
    X86_INS_STR,
    X86_INS_FST,
    X86_INS_FSTP,
    X86_INS_FSTPNCE,
    X86_INS_FXCH,
    X86_INS_SUBPD,
    X86_INS_SUBPS,
    X86_INS_FSUBR,
    X86_INS_FISUBR,
    X86_INS_FSUBRP,
    X86_INS_SUBSD,
    X86_INS_SUBSS,
    X86_INS_FSUB,
    X86_INS_FISUB,
    X86_INS_FSUBP,
    X86_INS_SWAPGS,
    X86_INS_SYSCALL,
    X86_INS_SYSENTER,
    X86_INS_SYSEXIT,
    X86_INS_SYSRET,
    X86_INS_T1MSKC,
    X86_INS_TEST,
    X86_INS_UD2,
    X86_INS_FTST,
    X86_INS_TZCNT,
    X86_INS_TZMSK,
    X86_INS_FUCOMIP,
    X86_INS_FUCOMI,
    X86_INS_FUCOMPP,
    X86_INS_FUCOMP,
    X86_INS_FUCOM,
    X86_INS_UD2B,
    X86_INS_UNPCKHPD,
    X86_INS_UNPCKHPS,
    X86_INS_UNPCKLPD,
    X86_INS_UNPCKLPS,
    X86_INS_VADDPD,
    X86_INS_VADDPS,
    X86_INS_VADDSD,
    X86_INS_VADDSS,
    X86_INS_VADDSUBPD,
    X86_INS_VADDSUBPS,
    X86_INS_VAESDECLAST,
    X86_INS_VAESDEC,
    X86_INS_VAESENCLAST,
    X86_INS_VAESENC,
    X86_INS_VAESIMC,
    X86_INS_VAESKEYGENASSIST,
    X86_INS_VALIGND,
    X86_INS_VALIGNQ,
    X86_INS_VANDNPD,
    X86_INS_VANDNPS,
    X86_INS_VANDPD,
    X86_INS_VANDPS,
    X86_INS_VBLENDMPD,
    X86_INS_VBLENDMPS,
    X86_INS_VBLENDPD,
    X86_INS_VBLENDPS,
    X86_INS_VBLENDVPD,
    X86_INS_VBLENDVPS,
    X86_INS_VBROADCASTF128,
    X86_INS_VBROADCASTI32X4,
    X86_INS_VBROADCASTI64X4,
    X86_INS_VBROADCASTSD,
    X86_INS_VBROADCASTSS,
    X86_INS_VCOMPRESSPD,
    X86_INS_VCOMPRESSPS,
    X86_INS_VCVTDQ2PD,
    X86_INS_VCVTDQ2PS,
    X86_INS_VCVTPD2DQX,
    X86_INS_VCVTPD2DQ,
    X86_INS_VCVTPD2PSX,
    X86_INS_VCVTPD2PS,
    X86_INS_VCVTPD2UDQ,
    X86_INS_VCVTPH2PS,
    X86_INS_VCVTPS2DQ,
    X86_INS_VCVTPS2PD,
    X86_INS_VCVTPS2PH,
    X86_INS_VCVTPS2UDQ,
    X86_INS_VCVTSD2SI,
    X86_INS_VCVTSD2USI,
    X86_INS_VCVTSS2SI,
    X86_INS_VCVTSS2USI,
    X86_INS_VCVTTPD2DQX,
    X86_INS_VCVTTPD2DQ,
    X86_INS_VCVTTPD2UDQ,
    X86_INS_VCVTTPS2DQ,
    X86_INS_VCVTTPS2UDQ,
    X86_INS_VCVTUDQ2PD,
    X86_INS_VCVTUDQ2PS,
    X86_INS_VDIVPD,
    X86_INS_VDIVPS,
    X86_INS_VDIVSD,
    X86_INS_VDIVSS,
    X86_INS_VDPPD,
    X86_INS_VDPPS,
    X86_INS_VERR,
    X86_INS_VERW,
    X86_INS_VEXP2PD,
    X86_INS_VEXP2PS,
    X86_INS_VEXPANDPD,
    X86_INS_VEXPANDPS,
    X86_INS_VEXTRACTF128,
    X86_INS_VEXTRACTF32X4,
    X86_INS_VEXTRACTF64X4,
    X86_INS_VEXTRACTI128,
    X86_INS_VEXTRACTI32X4,
    X86_INS_VEXTRACTI64X4,
    X86_INS_VEXTRACTPS,
    X86_INS_VFMADD132PD,
    X86_INS_VFMADD132PS,
    X86_INS_VFMADDPD,
    X86_INS_VFMADD213PD,
    X86_INS_VFMADD231PD,
    X86_INS_VFMADDPS,
    X86_INS_VFMADD213PS,
    X86_INS_VFMADD231PS,
    X86_INS_VFMADDSD,
    X86_INS_VFMADD213SD,
    X86_INS_VFMADD132SD,
    X86_INS_VFMADD231SD,
    X86_INS_VFMADDSS,
    X86_INS_VFMADD213SS,
    X86_INS_VFMADD132SS,
    X86_INS_VFMADD231SS,
    X86_INS_VFMADDSUB132PD,
    X86_INS_VFMADDSUB132PS,
    X86_INS_VFMADDSUBPD,
    X86_INS_VFMADDSUB213PD,
    X86_INS_VFMADDSUB231PD,
    X86_INS_VFMADDSUBPS,
    X86_INS_VFMADDSUB213PS,
    X86_INS_VFMADDSUB231PS,
    X86_INS_VFMSUB132PD,
    X86_INS_VFMSUB132PS,
    X86_INS_VFMSUBADD132PD,
    X86_INS_VFMSUBADD132PS,
    X86_INS_VFMSUBADDPD,
    X86_INS_VFMSUBADD213PD,
    X86_INS_VFMSUBADD231PD,
    X86_INS_VFMSUBADDPS,
    X86_INS_VFMSUBADD213PS,
    X86_INS_VFMSUBADD231PS,
    X86_INS_VFMSUBPD,
    X86_INS_VFMSUB213PD,
    X86_INS_VFMSUB231PD,
    X86_INS_VFMSUBPS,
    X86_INS_VFMSUB213PS,
    X86_INS_VFMSUB231PS,
    X86_INS_VFMSUBSD,
    X86_INS_VFMSUB213SD,
    X86_INS_VFMSUB132SD,
    X86_INS_VFMSUB231SD,
    X86_INS_VFMSUBSS,
    X86_INS_VFMSUB213SS,
    X86_INS_VFMSUB132SS,
    X86_INS_VFMSUB231SS,
    X86_INS_VFNMADD132PD,
    X86_INS_VFNMADD132PS,
    X86_INS_VFNMADDPD,
    X86_INS_VFNMADD213PD,
    X86_INS_VFNMADD231PD,
    X86_INS_VFNMADDPS,
    X86_INS_VFNMADD213PS,
    X86_INS_VFNMADD231PS,
    X86_INS_VFNMADDSD,
    X86_INS_VFNMADD213SD,
    X86_INS_VFNMADD132SD,
    X86_INS_VFNMADD231SD,
    X86_INS_VFNMADDSS,
    X86_INS_VFNMADD213SS,
    X86_INS_VFNMADD132SS,
    X86_INS_VFNMADD231SS,
    X86_INS_VFNMSUB132PD,
    X86_INS_VFNMSUB132PS,
    X86_INS_VFNMSUBPD,
    X86_INS_VFNMSUB213PD,
    X86_INS_VFNMSUB231PD,
    X86_INS_VFNMSUBPS,
    X86_INS_VFNMSUB213PS,
    X86_INS_VFNMSUB231PS,
    X86_INS_VFNMSUBSD,
    X86_INS_VFNMSUB213SD,
    X86_INS_VFNMSUB132SD,
    X86_INS_VFNMSUB231SD,
    X86_INS_VFNMSUBSS,
    X86_INS_VFNMSUB213SS,
    X86_INS_VFNMSUB132SS,
    X86_INS_VFNMSUB231SS,
    X86_INS_VFRCZPD,
    X86_INS_VFRCZPS,
    X86_INS_VFRCZSD,
    X86_INS_VFRCZSS,
    X86_INS_VORPD,
    X86_INS_VORPS,
    X86_INS_VXORPD,
    X86_INS_VXORPS,
    X86_INS_VGATHERDPD,
    X86_INS_VGATHERDPS,
    X86_INS_VGATHERPF0DPD,
    X86_INS_VGATHERPF0DPS,
    X86_INS_VGATHERPF0QPD,
    X86_INS_VGATHERPF0QPS,
    X86_INS_VGATHERPF1DPD,
    X86_INS_VGATHERPF1DPS,
    X86_INS_VGATHERPF1QPD,
    X86_INS_VGATHERPF1QPS,
    X86_INS_VGATHERQPD,
    X86_INS_VGATHERQPS,
    X86_INS_VHADDPD,
    X86_INS_VHADDPS,
    X86_INS_VHSUBPD,
    X86_INS_VHSUBPS,
    X86_INS_VINSERTF128,
    X86_INS_VINSERTF32X4,
    X86_INS_VINSERTF32X8,
    X86_INS_VINSERTF64X2,
    X86_INS_VINSERTF64X4,
    X86_INS_VINSERTI128,
    X86_INS_VINSERTI32X4,
    X86_INS_VINSERTI32X8,
    X86_INS_VINSERTI64X2,
    X86_INS_VINSERTI64X4,
    X86_INS_VINSERTPS,
    X86_INS_VLDDQU,
    X86_INS_VLDMXCSR,
    X86_INS_VMASKMOVDQU,
    X86_INS_VMASKMOVPD,
    X86_INS_VMASKMOVPS,
    X86_INS_VMAXPD,
    X86_INS_VMAXPS,
    X86_INS_VMAXSD,
    X86_INS_VMAXSS,
    X86_INS_VMCALL,
    X86_INS_VMCLEAR,
    X86_INS_VMFUNC,
    X86_INS_VMINPD,
    X86_INS_VMINPS,
    X86_INS_VMINSD,
    X86_INS_VMINSS,
    X86_INS_VMLAUNCH,
    X86_INS_VMLOAD,
    X86_INS_VMMCALL,
    X86_INS_VMOVQ,
    X86_INS_VMOVDDUP,
    X86_INS_VMOVD,
    X86_INS_VMOVDQA32,
    X86_INS_VMOVDQA64,
    X86_INS_VMOVDQA,
    X86_INS_VMOVDQU16,
    X86_INS_VMOVDQU32,
    X86_INS_VMOVDQU64,
    X86_INS_VMOVDQU8,
    X86_INS_VMOVDQU,
    X86_INS_VMOVHLPS,
    X86_INS_VMOVHPD,
    X86_INS_VMOVHPS,
    X86_INS_VMOVLHPS,
    X86_INS_VMOVLPD,
    X86_INS_VMOVLPS,
    X86_INS_VMOVMSKPD,
    X86_INS_VMOVMSKPS,
    X86_INS_VMOVNTDQA,
    X86_INS_VMOVNTDQ,
    X86_INS_VMOVNTPD,
    X86_INS_VMOVNTPS,
    X86_INS_VMOVSD,
    X86_INS_VMOVSHDUP,
    X86_INS_VMOVSLDUP,
    X86_INS_VMOVSS,
    X86_INS_VMOVUPD,
    X86_INS_VMOVUPS,
    X86_INS_VMPSADBW,
    X86_INS_VMPTRLD,
    X86_INS_VMPTRST,
    X86_INS_VMREAD,
    X86_INS_VMRESUME,
    X86_INS_VMRUN,
    X86_INS_VMSAVE,
    X86_INS_VMULPD,
    X86_INS_VMULPS,
    X86_INS_VMULSD,
    X86_INS_VMULSS,
    X86_INS_VMWRITE,
    X86_INS_VMXOFF,
    X86_INS_VMXON,
    X86_INS_VPABSB,
    X86_INS_VPABSD,
    X86_INS_VPABSQ,
    X86_INS_VPABSW,
    X86_INS_VPACKSSDW,
    X86_INS_VPACKSSWB,
    X86_INS_VPACKUSDW,
    X86_INS_VPACKUSWB,
    X86_INS_VPADDB,
    X86_INS_VPADDD,
    X86_INS_VPADDQ,
    X86_INS_VPADDSB,
    X86_INS_VPADDSW,
    X86_INS_VPADDUSB,
    X86_INS_VPADDUSW,
    X86_INS_VPADDW,
    X86_INS_VPALIGNR,
    X86_INS_VPANDD,
    X86_INS_VPANDND,
    X86_INS_VPANDNQ,
    X86_INS_VPANDN,
    X86_INS_VPANDQ,
    X86_INS_VPAND,
    X86_INS_VPAVGB,
    X86_INS_VPAVGW,
    X86_INS_VPBLENDD,
    X86_INS_VPBLENDMB,
    X86_INS_VPBLENDMD,
    X86_INS_VPBLENDMQ,
    X86_INS_VPBLENDMW,
    X86_INS_VPBLENDVB,
    X86_INS_VPBLENDW,
    X86_INS_VPBROADCASTB,
    X86_INS_VPBROADCASTD,
    X86_INS_VPBROADCASTMB2Q,
    X86_INS_VPBROADCASTMW2D,
    X86_INS_VPBROADCASTQ,
    X86_INS_VPBROADCASTW,
    X86_INS_VPCLMULQDQ,
    X86_INS_VPCMOV,
    X86_INS_VPCMPB,
    X86_INS_VPCMPD,
    X86_INS_VPCMPEQB,
    X86_INS_VPCMPEQD,
    X86_INS_VPCMPEQQ,
    X86_INS_VPCMPEQW,
    X86_INS_VPCMPESTRI,
    X86_INS_VPCMPESTRM,
    X86_INS_VPCMPGTB,
    X86_INS_VPCMPGTD,
    X86_INS_VPCMPGTQ,
    X86_INS_VPCMPGTW,
    X86_INS_VPCMPISTRI,
    X86_INS_VPCMPISTRM,
    X86_INS_VPCMPQ,
    X86_INS_VPCMPUB,
    X86_INS_VPCMPUD,
    X86_INS_VPCMPUQ,
    X86_INS_VPCMPUW,
    X86_INS_VPCMPW,
    X86_INS_VPCOMB,
    X86_INS_VPCOMD,
    X86_INS_VPCOMPRESSD,
    X86_INS_VPCOMPRESSQ,
    X86_INS_VPCOMQ,
    X86_INS_VPCOMUB,
    X86_INS_VPCOMUD,
    X86_INS_VPCOMUQ,
    X86_INS_VPCOMUW,
    X86_INS_VPCOMW,
    X86_INS_VPCONFLICTD,
    X86_INS_VPCONFLICTQ,
    X86_INS_VPERM2F128,
    X86_INS_VPERM2I128,
    X86_INS_VPERMD,
    X86_INS_VPERMI2D,
    X86_INS_VPERMI2PD,
    X86_INS_VPERMI2PS,
    X86_INS_VPERMI2Q,
    X86_INS_VPERMIL2PD,
    X86_INS_VPERMIL2PS,
    X86_INS_VPERMILPD,
    X86_INS_VPERMILPS,
    X86_INS_VPERMPD,
    X86_INS_VPERMPS,
    X86_INS_VPERMQ,
    X86_INS_VPERMT2D,
    X86_INS_VPERMT2PD,
    X86_INS_VPERMT2PS,
    X86_INS_VPERMT2Q,
    X86_INS_VPEXPANDD,
    X86_INS_VPEXPANDQ,
    X86_INS_VPEXTRB,
    X86_INS_VPEXTRD,
    X86_INS_VPEXTRQ,
    X86_INS_VPEXTRW,
    X86_INS_VPGATHERDD,
    X86_INS_VPGATHERDQ,
    X86_INS_VPGATHERQD,
    X86_INS_VPGATHERQQ,
    X86_INS_VPHADDBD,
    X86_INS_VPHADDBQ,
    X86_INS_VPHADDBW,
    X86_INS_VPHADDDQ,
    X86_INS_VPHADDD,
    X86_INS_VPHADDSW,
    X86_INS_VPHADDUBD,
    X86_INS_VPHADDUBQ,
    X86_INS_VPHADDUBW,
    X86_INS_VPHADDUDQ,
    X86_INS_VPHADDUWD,
    X86_INS_VPHADDUWQ,
    X86_INS_VPHADDWD,
    X86_INS_VPHADDWQ,
    X86_INS_VPHADDW,
    X86_INS_VPHMINPOSUW,
    X86_INS_VPHSUBBW,
    X86_INS_VPHSUBDQ,
    X86_INS_VPHSUBD,
    X86_INS_VPHSUBSW,
    X86_INS_VPHSUBWD,
    X86_INS_VPHSUBW,
    X86_INS_VPINSRB,
    X86_INS_VPINSRD,
    X86_INS_VPINSRQ,
    X86_INS_VPINSRW,
    X86_INS_VPLZCNTD,
    X86_INS_VPLZCNTQ,
    X86_INS_VPMACSDD,
    X86_INS_VPMACSDQH,
    X86_INS_VPMACSDQL,
    X86_INS_VPMACSSDD,
    X86_INS_VPMACSSDQH,
    X86_INS_VPMACSSDQL,
    X86_INS_VPMACSSWD,
    X86_INS_VPMACSSWW,
    X86_INS_VPMACSWD,
    X86_INS_VPMACSWW,
    X86_INS_VPMADCSSWD,
    X86_INS_VPMADCSWD,
    X86_INS_VPMADDUBSW,
    X86_INS_VPMADDWD,
    X86_INS_VPMASKMOVD,
    X86_INS_VPMASKMOVQ,
    X86_INS_VPMAXSB,
    X86_INS_VPMAXSD,
    X86_INS_VPMAXSQ,
    X86_INS_VPMAXSW,
    X86_INS_VPMAXUB,
    X86_INS_VPMAXUD,
    X86_INS_VPMAXUQ,
    X86_INS_VPMAXUW,
    X86_INS_VPMINSB,
    X86_INS_VPMINSD,
    X86_INS_VPMINSQ,
    X86_INS_VPMINSW,
    X86_INS_VPMINUB,
    X86_INS_VPMINUD,
    X86_INS_VPMINUQ,
    X86_INS_VPMINUW,
    X86_INS_VPMOVDB,
    X86_INS_VPMOVDW,
    X86_INS_VPMOVM2B,
    X86_INS_VPMOVM2D,
    X86_INS_VPMOVM2Q,
    X86_INS_VPMOVM2W,
    X86_INS_VPMOVMSKB,
    X86_INS_VPMOVQB,
    X86_INS_VPMOVQD,
    X86_INS_VPMOVQW,
    X86_INS_VPMOVSDB,
    X86_INS_VPMOVSDW,
    X86_INS_VPMOVSQB,
    X86_INS_VPMOVSQD,
    X86_INS_VPMOVSQW,
    X86_INS_VPMOVSXBD,
    X86_INS_VPMOVSXBQ,
    X86_INS_VPMOVSXBW,
    X86_INS_VPMOVSXDQ,
    X86_INS_VPMOVSXWD,
    X86_INS_VPMOVSXWQ,
    X86_INS_VPMOVUSDB,
    X86_INS_VPMOVUSDW,
    X86_INS_VPMOVUSQB,
    X86_INS_VPMOVUSQD,
    X86_INS_VPMOVUSQW,
    X86_INS_VPMOVZXBD,
    X86_INS_VPMOVZXBQ,
    X86_INS_VPMOVZXBW,
    X86_INS_VPMOVZXDQ,
    X86_INS_VPMOVZXWD,
    X86_INS_VPMOVZXWQ,
    X86_INS_VPMULDQ,
    X86_INS_VPMULHRSW,
    X86_INS_VPMULHUW,
    X86_INS_VPMULHW,
    X86_INS_VPMULLD,
    X86_INS_VPMULLQ,
    X86_INS_VPMULLW,
    X86_INS_VPMULUDQ,
    X86_INS_VPORD,
    X86_INS_VPORQ,
    X86_INS_VPOR,
    X86_INS_VPPERM,
    X86_INS_VPROTB,
    X86_INS_VPROTD,
    X86_INS_VPROTQ,
    X86_INS_VPROTW,
    X86_INS_VPSADBW,
    X86_INS_VPSCATTERDD,
    X86_INS_VPSCATTERDQ,
    X86_INS_VPSCATTERQD,
    X86_INS_VPSCATTERQQ,
    X86_INS_VPSHAB,
    X86_INS_VPSHAD,
    X86_INS_VPSHAQ,
    X86_INS_VPSHAW,
    X86_INS_VPSHLB,
    X86_INS_VPSHLD,
    X86_INS_VPSHLQ,
    X86_INS_VPSHLW,
    X86_INS_VPSHUFB,
    X86_INS_VPSHUFD,
    X86_INS_VPSHUFHW,
    X86_INS_VPSHUFLW,
    X86_INS_VPSIGNB,
    X86_INS_VPSIGND,
    X86_INS_VPSIGNW,
    X86_INS_VPSLLDQ,
    X86_INS_VPSLLD,
    X86_INS_VPSLLQ,
    X86_INS_VPSLLVD,
    X86_INS_VPSLLVQ,
    X86_INS_VPSLLW,
    X86_INS_VPSRAD,
    X86_INS_VPSRAQ,
    X86_INS_VPSRAVD,
    X86_INS_VPSRAVQ,
    X86_INS_VPSRAW,
    X86_INS_VPSRLDQ,
    X86_INS_VPSRLD,
    X86_INS_VPSRLQ,
    X86_INS_VPSRLVD,
    X86_INS_VPSRLVQ,
    X86_INS_VPSRLW,
    X86_INS_VPSUBB,
    X86_INS_VPSUBD,
    X86_INS_VPSUBQ,
    X86_INS_VPSUBSB,
    X86_INS_VPSUBSW,
    X86_INS_VPSUBUSB,
    X86_INS_VPSUBUSW,
    X86_INS_VPSUBW,
    X86_INS_VPTESTMD,
    X86_INS_VPTESTMQ,
    X86_INS_VPTESTNMD,
    X86_INS_VPTESTNMQ,
    X86_INS_VPTEST,
    X86_INS_VPUNPCKHBW,
    X86_INS_VPUNPCKHDQ,
    X86_INS_VPUNPCKHQDQ,
    X86_INS_VPUNPCKHWD,
    X86_INS_VPUNPCKLBW,
    X86_INS_VPUNPCKLDQ,
    X86_INS_VPUNPCKLQDQ,
    X86_INS_VPUNPCKLWD,
    X86_INS_VPXORD,
    X86_INS_VPXORQ,
    X86_INS_VPXOR,
    X86_INS_VRCP14PD,
    X86_INS_VRCP14PS,
    X86_INS_VRCP14SD,
    X86_INS_VRCP14SS,
    X86_INS_VRCP28PD,
    X86_INS_VRCP28PS,
    X86_INS_VRCP28SD,
    X86_INS_VRCP28SS,
    X86_INS_VRCPPS,
    X86_INS_VRCPSS,
    X86_INS_VRNDSCALEPD,
    X86_INS_VRNDSCALEPS,
    X86_INS_VRNDSCALESD,
    X86_INS_VRNDSCALESS,
    X86_INS_VROUNDPD,
    X86_INS_VROUNDPS,
    X86_INS_VROUNDSD,
    X86_INS_VROUNDSS,
    X86_INS_VRSQRT14PD,
    X86_INS_VRSQRT14PS,
    X86_INS_VRSQRT14SD,
    X86_INS_VRSQRT14SS,
    X86_INS_VRSQRT28PD,
    X86_INS_VRSQRT28PS,
    X86_INS_VRSQRT28SD,
    X86_INS_VRSQRT28SS,
    X86_INS_VRSQRTPS,
    X86_INS_VRSQRTSS,
    X86_INS_VSCATTERDPD,
    X86_INS_VSCATTERDPS,
    X86_INS_VSCATTERPF0DPD,
    X86_INS_VSCATTERPF0DPS,
    X86_INS_VSCATTERPF0QPD,
    X86_INS_VSCATTERPF0QPS,
    X86_INS_VSCATTERPF1DPD,
    X86_INS_VSCATTERPF1DPS,
    X86_INS_VSCATTERPF1QPD,
    X86_INS_VSCATTERPF1QPS,
    X86_INS_VSCATTERQPD,
    X86_INS_VSCATTERQPS,
    X86_INS_VSHUFPD,
    X86_INS_VSHUFPS,
    X86_INS_VSQRTPD,
    X86_INS_VSQRTPS,
    X86_INS_VSQRTSD,
    X86_INS_VSQRTSS,
    X86_INS_VSTMXCSR,
    X86_INS_VSUBPD,
    X86_INS_VSUBPS,
    X86_INS_VSUBSD,
    X86_INS_VSUBSS,
    X86_INS_VTESTPD,
    X86_INS_VTESTPS,
    X86_INS_VUNPCKHPD,
    X86_INS_VUNPCKHPS,
    X86_INS_VUNPCKLPD,
    X86_INS_VUNPCKLPS,
    X86_INS_VZEROALL,
    X86_INS_VZEROUPPER,
    X86_INS_WAIT,
    X86_INS_WBINVD,
    X86_INS_WRFSBASE,
    X86_INS_WRGSBASE,
    X86_INS_WRMSR,
    X86_INS_XABORT,
    X86_INS_XACQUIRE,
    X86_INS_XBEGIN,
    X86_INS_XCHG,
    X86_INS_XCRYPTCBC,
    X86_INS_XCRYPTCFB,
    X86_INS_XCRYPTCTR,
    X86_INS_XCRYPTECB,
    X86_INS_XCRYPTOFB,
    X86_INS_XEND,
    X86_INS_XGETBV,
    X86_INS_XLATB,
    X86_INS_XRELEASE,
    X86_INS_XRSTOR,
    X86_INS_XRSTOR64,
    X86_INS_XRSTORS,
    X86_INS_XRSTORS64,
    X86_INS_XSAVE,
    X86_INS_XSAVE64,
    X86_INS_XSAVEC,
    X86_INS_XSAVEC64,
    X86_INS_XSAVEOPT,
    X86_INS_XSAVEOPT64,
    X86_INS_XSAVES,
    X86_INS_XSAVES64,
    X86_INS_XSETBV,
    X86_INS_XSHA1,
    X86_INS_XSHA256,
    X86_INS_XSTORE,
    X86_INS_XTEST,
    X86_INS_FDISI8087_NOP,
    X86_INS_FENI8087_NOP,

    // pseudo instructions
    X86_INS_CMPSS,
    X86_INS_CMPEQSS,
    X86_INS_CMPLTSS,
    X86_INS_CMPLESS,
    X86_INS_CMPUNORDSS,
    X86_INS_CMPNEQSS,
    X86_INS_CMPNLTSS,
    X86_INS_CMPNLESS,
    X86_INS_CMPORDSS,

    X86_INS_CMPSD,
    X86_INS_CMPEQSD,
    X86_INS_CMPLTSD,
    X86_INS_CMPLESD,
    X86_INS_CMPUNORDSD,
    X86_INS_CMPNEQSD,
    X86_INS_CMPNLTSD,
    X86_INS_CMPNLESD,
    X86_INS_CMPORDSD,

    X86_INS_CMPPS,
    X86_INS_CMPEQPS,
    X86_INS_CMPLTPS,
    X86_INS_CMPLEPS,
    X86_INS_CMPUNORDPS,
    X86_INS_CMPNEQPS,
    X86_INS_CMPNLTPS,
    X86_INS_CMPNLEPS,
    X86_INS_CMPORDPS,

    X86_INS_CMPPD,
    X86_INS_CMPEQPD,
    X86_INS_CMPLTPD,
    X86_INS_CMPLEPD,
    X86_INS_CMPUNORDPD,
    X86_INS_CMPNEQPD,
    X86_INS_CMPNLTPD,
    X86_INS_CMPNLEPD,
    X86_INS_CMPORDPD,

    X86_INS_VCMPSS,
    X86_INS_VCMPEQSS,
    X86_INS_VCMPLTSS,
    X86_INS_VCMPLESS,
    X86_INS_VCMPUNORDSS,
    X86_INS_VCMPNEQSS,
    X86_INS_VCMPNLTSS,
    X86_INS_VCMPNLESS,
    X86_INS_VCMPORDSS,
    X86_INS_VCMPEQ_UQSS,
    X86_INS_VCMPNGESS,
    X86_INS_VCMPNGTSS,
    X86_INS_VCMPFALSESS,
    X86_INS_VCMPNEQ_OQSS,
    X86_INS_VCMPGESS,
    X86_INS_VCMPGTSS,
    X86_INS_VCMPTRUESS,
    X86_INS_VCMPEQ_OSSS,
    X86_INS_VCMPLT_OQSS,
    X86_INS_VCMPLE_OQSS,
    X86_INS_VCMPUNORD_SSS,
    X86_INS_VCMPNEQ_USSS,
    X86_INS_VCMPNLT_UQSS,
    X86_INS_VCMPNLE_UQSS,
    X86_INS_VCMPORD_SSS,
    X86_INS_VCMPEQ_USSS,
    X86_INS_VCMPNGE_UQSS,
    X86_INS_VCMPNGT_UQSS,
    X86_INS_VCMPFALSE_OSSS,
    X86_INS_VCMPNEQ_OSSS,
    X86_INS_VCMPGE_OQSS,
    X86_INS_VCMPGT_OQSS,
    X86_INS_VCMPTRUE_USSS,

    X86_INS_VCMPSD,
    X86_INS_VCMPEQSD,
    X86_INS_VCMPLTSD,
    X86_INS_VCMPLESD,
    X86_INS_VCMPUNORDSD,
    X86_INS_VCMPNEQSD,
    X86_INS_VCMPNLTSD,
    X86_INS_VCMPNLESD,
    X86_INS_VCMPORDSD,
    X86_INS_VCMPEQ_UQSD,
    X86_INS_VCMPNGESD,
    X86_INS_VCMPNGTSD,
    X86_INS_VCMPFALSESD,
    X86_INS_VCMPNEQ_OQSD,
    X86_INS_VCMPGESD,
    X86_INS_VCMPGTSD,
    X86_INS_VCMPTRUESD,
    X86_INS_VCMPEQ_OSSD,
    X86_INS_VCMPLT_OQSD,
    X86_INS_VCMPLE_OQSD,
    X86_INS_VCMPUNORD_SSD,
    X86_INS_VCMPNEQ_USSD,
    X86_INS_VCMPNLT_UQSD,
    X86_INS_VCMPNLE_UQSD,
    X86_INS_VCMPORD_SSD,
    X86_INS_VCMPEQ_USSD,
    X86_INS_VCMPNGE_UQSD,
    X86_INS_VCMPNGT_UQSD,
    X86_INS_VCMPFALSE_OSSD,
    X86_INS_VCMPNEQ_OSSD,
    X86_INS_VCMPGE_OQSD,
    X86_INS_VCMPGT_OQSD,
    X86_INS_VCMPTRUE_USSD,

    X86_INS_VCMPPS,
    X86_INS_VCMPEQPS,
    X86_INS_VCMPLTPS,
    X86_INS_VCMPLEPS,
    X86_INS_VCMPUNORDPS,
    X86_INS_VCMPNEQPS,
    X86_INS_VCMPNLTPS,
    X86_INS_VCMPNLEPS,
    X86_INS_VCMPORDPS,
    X86_INS_VCMPEQ_UQPS,
    X86_INS_VCMPNGEPS,
    X86_INS_VCMPNGTPS,
    X86_INS_VCMPFALSEPS,
    X86_INS_VCMPNEQ_OQPS,
    X86_INS_VCMPGEPS,
    X86_INS_VCMPGTPS,
    X86_INS_VCMPTRUEPS,
    X86_INS_VCMPEQ_OSPS,
    X86_INS_VCMPLT_OQPS,
    X86_INS_VCMPLE_OQPS,
    X86_INS_VCMPUNORD_SPS,
    X86_INS_VCMPNEQ_USPS,
    X86_INS_VCMPNLT_UQPS,
    X86_INS_VCMPNLE_UQPS,
    X86_INS_VCMPORD_SPS,
    X86_INS_VCMPEQ_USPS,
    X86_INS_VCMPNGE_UQPS,
    X86_INS_VCMPNGT_UQPS,
    X86_INS_VCMPFALSE_OSPS,
    X86_INS_VCMPNEQ_OSPS,
    X86_INS_VCMPGE_OQPS,
    X86_INS_VCMPGT_OQPS,
    X86_INS_VCMPTRUE_USPS,

    X86_INS_VCMPPD,
    X86_INS_VCMPEQPD,
    X86_INS_VCMPLTPD,
    X86_INS_VCMPLEPD,
    X86_INS_VCMPUNORDPD,
    X86_INS_VCMPNEQPD,
    X86_INS_VCMPNLTPD,
    X86_INS_VCMPNLEPD,
    X86_INS_VCMPORDPD,
    X86_INS_VCMPEQ_UQPD,
    X86_INS_VCMPNGEPD,
    X86_INS_VCMPNGTPD,
    X86_INS_VCMPFALSEPD,
    X86_INS_VCMPNEQ_OQPD,
    X86_INS_VCMPGEPD,
    X86_INS_VCMPGTPD,
    X86_INS_VCMPTRUEPD,
    X86_INS_VCMPEQ_OSPD,
    X86_INS_VCMPLT_OQPD,
    X86_INS_VCMPLE_OQPD,
    X86_INS_VCMPUNORD_SPD,
    X86_INS_VCMPNEQ_USPD,
    X86_INS_VCMPNLT_UQPD,
    X86_INS_VCMPNLE_UQPD,
    X86_INS_VCMPORD_SPD,
    X86_INS_VCMPEQ_USPD,
    X86_INS_VCMPNGE_UQPD,
    X86_INS_VCMPNGT_UQPD,
    X86_INS_VCMPFALSE_OSPD,
    X86_INS_VCMPNEQ_OSPD,
    X86_INS_VCMPGE_OQPD,
    X86_INS_VCMPGT_OQPD,
    X86_INS_VCMPTRUE_USPD,

    X86_INS_ENDING, // mark the end of the list of insn
} x86_insn;

//> Group of X86 instructions
typedef enum  x86_insn_group
{
    X86_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    X86_GRP_JUMP,   // = CS_GRP_JUMP
    // all call instructions
    X86_GRP_CALL,   // = CS_GRP_CALL
    // all return instructions
    X86_GRP_RET,    // = CS_GRP_RET
    // all interrupt instructions (int+syscall)
    X86_GRP_INT,    // = CS_GRP_INT
    // all interrupt return instructions
    X86_GRP_IRET,   // = CS_GRP_IRET
    // all privileged instructions
    X86_GRP_PRIVILEGE,  // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    X86_GRP_VM = 128,   // all virtualization instructions (VT-x + AMD-V)
    X86_GRP_3DNOW,
    X86_GRP_AES,
    X86_GRP_ADX,
    X86_GRP_AVX,
    X86_GRP_AVX2,
    X86_GRP_AVX512,
    X86_GRP_BMI,
    X86_GRP_BMI2,
    X86_GRP_CMOV,
    X86_GRP_F16C,
    X86_GRP_FMA,
    X86_GRP_FMA4,
    X86_GRP_FSGSBASE,
    X86_GRP_HLE,
    X86_GRP_MMX,
    X86_GRP_MODE32,
    X86_GRP_MODE64,
    X86_GRP_RTM,
    X86_GRP_SHA,
    X86_GRP_SSE1,
    X86_GRP_SSE2,
    X86_GRP_SSE3,
    X86_GRP_SSE41,
    X86_GRP_SSE42,
    X86_GRP_SSE4A,
    X86_GRP_SSSE3,
    X86_GRP_PCLMUL,
    X86_GRP_XOP,
    X86_GRP_CDI,
    X86_GRP_ERI,
    X86_GRP_TBM,
    X86_GRP_16BITMODE,
    X86_GRP_NOT64BITMODE,
    X86_GRP_SGX,
    X86_GRP_DQI,
    X86_GRP_BWI,
    X86_GRP_PFI,
    X86_GRP_VLX,
    X86_GRP_SMAP,
    X86_GRP_NOVLX,

    X86_GRP_ENDING
} x86_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/capstone/xcore.h`:

```h
#ifndef CAPSTONE_XCORE_H
#define CAPSTONE_XCORE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum xcore_op_type
{
    XCORE_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    XCORE_OP_REG, // = CS_OP_REG (Register operand).
    XCORE_OP_IMM, // = CS_OP_IMM (Immediate operand).
    XCORE_OP_MEM, // = CS_OP_MEM (Memory operand).
} xcore_op_type;

//> XCore registers
typedef enum xcore_reg
{
    XCORE_REG_INVALID = 0,

    XCORE_REG_CP,
    XCORE_REG_DP,
    XCORE_REG_LR,
    XCORE_REG_SP,
    XCORE_REG_R0,
    XCORE_REG_R1,
    XCORE_REG_R2,
    XCORE_REG_R3,
    XCORE_REG_R4,
    XCORE_REG_R5,
    XCORE_REG_R6,
    XCORE_REG_R7,
    XCORE_REG_R8,
    XCORE_REG_R9,
    XCORE_REG_R10,
    XCORE_REG_R11,

    //> pseudo registers
    XCORE_REG_PC,   // pc

    // internal thread registers
    // see The-XMOS-XS1-Architecture(X7879A).pdf
    XCORE_REG_SCP,  // save pc
    XCORE_REG_SSR,  // save status
    XCORE_REG_ET,   // exception type
    XCORE_REG_ED,   // exception data
    XCORE_REG_SED,  // save exception data
    XCORE_REG_KEP,  // kernel entry pointer
    XCORE_REG_KSP,  // kernel stack pointer
    XCORE_REG_ID,   // thread ID

    XCORE_REG_ENDING,   // <-- mark the end of the list of registers
} xcore_reg;

// Instruction's operand referring to memory
// This is associated with XCORE_OP_MEM operand type above
typedef struct xcore_op_mem
{
    uint8_t base;       // base register, can be safely interpreted as
    // a value of type `xcore_reg`, but it is only
    // one byte wide
    uint8_t index;      // index register, same conditions apply here
    int32_t disp;   // displacement/offset value
    int     direct; // +1: forward, -1: backward
} xcore_op_mem;

// Instruction operand
typedef struct cs_xcore_op
{
    xcore_op_type type; // operand type
    union
    {
        xcore_reg reg;  // register value for REG operand
        int32_t imm;        // immediate value for IMM operand
        xcore_op_mem mem;       // base/disp value for MEM operand
    };
} cs_xcore_op;

// Instruction structure
typedef struct cs_xcore
{
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_xcore_op operands[8]; // operands for this instruction.
} cs_xcore;

//> XCore instruction
typedef enum xcore_insn
{
    XCORE_INS_INVALID = 0,

    XCORE_INS_ADD,
    XCORE_INS_ANDNOT,
    XCORE_INS_AND,
    XCORE_INS_ASHR,
    XCORE_INS_BAU,
    XCORE_INS_BITREV,
    XCORE_INS_BLA,
    XCORE_INS_BLAT,
    XCORE_INS_BL,
    XCORE_INS_BF,
    XCORE_INS_BT,
    XCORE_INS_BU,
    XCORE_INS_BRU,
    XCORE_INS_BYTEREV,
    XCORE_INS_CHKCT,
    XCORE_INS_CLRE,
    XCORE_INS_CLRPT,
    XCORE_INS_CLRSR,
    XCORE_INS_CLZ,
    XCORE_INS_CRC8,
    XCORE_INS_CRC32,
    XCORE_INS_DCALL,
    XCORE_INS_DENTSP,
    XCORE_INS_DGETREG,
    XCORE_INS_DIVS,
    XCORE_INS_DIVU,
    XCORE_INS_DRESTSP,
    XCORE_INS_DRET,
    XCORE_INS_ECALLF,
    XCORE_INS_ECALLT,
    XCORE_INS_EDU,
    XCORE_INS_EEF,
    XCORE_INS_EET,
    XCORE_INS_EEU,
    XCORE_INS_ENDIN,
    XCORE_INS_ENTSP,
    XCORE_INS_EQ,
    XCORE_INS_EXTDP,
    XCORE_INS_EXTSP,
    XCORE_INS_FREER,
    XCORE_INS_FREET,
    XCORE_INS_GETD,
    XCORE_INS_GET,
    XCORE_INS_GETN,
    XCORE_INS_GETR,
    XCORE_INS_GETSR,
    XCORE_INS_GETST,
    XCORE_INS_GETTS,
    XCORE_INS_INCT,
    XCORE_INS_INIT,
    XCORE_INS_INPW,
    XCORE_INS_INSHR,
    XCORE_INS_INT,
    XCORE_INS_IN,
    XCORE_INS_KCALL,
    XCORE_INS_KENTSP,
    XCORE_INS_KRESTSP,
    XCORE_INS_KRET,
    XCORE_INS_LADD,
    XCORE_INS_LD16S,
    XCORE_INS_LD8U,
    XCORE_INS_LDA16,
    XCORE_INS_LDAP,
    XCORE_INS_LDAW,
    XCORE_INS_LDC,
    XCORE_INS_LDW,
    XCORE_INS_LDIVU,
    XCORE_INS_LMUL,
    XCORE_INS_LSS,
    XCORE_INS_LSUB,
    XCORE_INS_LSU,
    XCORE_INS_MACCS,
    XCORE_INS_MACCU,
    XCORE_INS_MJOIN,
    XCORE_INS_MKMSK,
    XCORE_INS_MSYNC,
    XCORE_INS_MUL,
    XCORE_INS_NEG,
    XCORE_INS_NOT,
    XCORE_INS_OR,
    XCORE_INS_OUTCT,
    XCORE_INS_OUTPW,
    XCORE_INS_OUTSHR,
    XCORE_INS_OUTT,
    XCORE_INS_OUT,
    XCORE_INS_PEEK,
    XCORE_INS_REMS,
    XCORE_INS_REMU,
    XCORE_INS_RETSP,
    XCORE_INS_SETCLK,
    XCORE_INS_SET,
    XCORE_INS_SETC,
    XCORE_INS_SETD,
    XCORE_INS_SETEV,
    XCORE_INS_SETN,
    XCORE_INS_SETPSC,
    XCORE_INS_SETPT,
    XCORE_INS_SETRDY,
    XCORE_INS_SETSR,
    XCORE_INS_SETTW,
    XCORE_INS_SETV,
    XCORE_INS_SEXT,
    XCORE_INS_SHL,
    XCORE_INS_SHR,
    XCORE_INS_SSYNC,
    XCORE_INS_ST16,
    XCORE_INS_ST8,
    XCORE_INS_STW,
    XCORE_INS_SUB,
    XCORE_INS_SYNCR,
    XCORE_INS_TESTCT,
    XCORE_INS_TESTLCL,
    XCORE_INS_TESTWCT,
    XCORE_INS_TSETMR,
    XCORE_INS_START,
    XCORE_INS_WAITEF,
    XCORE_INS_WAITET,
    XCORE_INS_WAITEU,
    XCORE_INS_XOR,
    XCORE_INS_ZEXT,

    XCORE_INS_ENDING,   // <-- mark the end of the list of instructions
} xcore_insn;

//> Group of XCore instructions
typedef enum xcore_insn_group
{
    XCORE_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    XCORE_GRP_JUMP, // = CS_GRP_JUMP

    XCORE_GRP_ENDING,   // <-- mark the end of the list of groups
} xcore_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/dbghelp/dbghelp.h`:

```h
#ifndef _DBGHELP_
#define _DBGHELP_


// As a general principal always call the 64 bit version
// of every API, if a choice exists.  The 64 bit version
// works great on 32 bit platforms, and is forward
// compatible to 64 bit platforms.

#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif

#pragma pack(push,8)

// For those without specstrings.h
// Since there are different versions of this header, I need to
// individually test each item and define it if it is not around.

#ifndef __in
#define __in
#endif
#ifndef __out
#define __out
#endif
#ifndef __inout
#define __inout
#endif
#ifndef __in_opt
#define __in_opt
#endif
#ifndef __out_opt
#define __out_opt
#endif
#ifndef __inout_opt
#define __inout_opt
#endif
#ifndef __in_ecount
#define __in_ecount(x)
#endif
#ifndef __out_ecount
#define __out_ecount(x)
#endif
#ifndef __inout_ecount
#define __inout_ecount(x)
#endif
#ifndef __in_bcount
#define __in_bcount(x)
#endif
#ifndef __out_bcount
#define __out_bcount(x)
#endif
#ifndef __inout_bcount
#define __inout_bcount(x)
#endif
#ifndef __out_xcount
#define __out_xcount(x)
#endif
#ifndef __deref_opt_out
#define __deref_opt_out
#endif
#ifndef __deref_out
#define __deref_out
#endif
#ifndef __out_ecount_opt
#define __out_ecount_opt(x)
#endif
#ifndef __in_bcount_opt
#define __in_bcount_opt(x)
#endif
#ifndef __out_bcount_opt
#define __out_bcount_opt(x)
#endif
#ifndef __deref_out_opt
#define __deref_out_opt
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#define DBHLP_DEPRECIATED
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DBHLP_DEPRECIATED   __declspec(deprecated)
#else
#define DBHLP_DEPRECIATED
#endif
#endif

#define DBHLPAPI IMAGEAPI

#define IMAGE_SEPARATION (64*1024)

// Observant readers may notice that 2 new fields,
// 'fReadOnly' and 'Version' have been added to
// the LOADED_IMAGE structure after 'fDOSImage'.
// This does not change the size of the structure
// from previous headers.  That is because while
// 'fDOSImage' is a byte, it is padded by the
// compiler to 4 bytes.  So the 2 new fields are
// slipped into the extra space.

typedef struct _LOADED_IMAGE
{
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    BOOLEAN               fReadOnly;
    UCHAR                 Version;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;

#define MAX_SYM_NAME            2000


// Error codes set by dbghelp functions.  Call GetLastError
// to see them.
// Dbghelp also sets error codes found in winerror.h

#define ERROR_IMAGE_NOT_STRIPPED    0x8800  // the image is not stripped.  No dbg file available.
#define ERROR_NO_DBG_POINTER        0x8801  // image is stripped but there is no pointer to a dbg file
#define ERROR_NO_PDB_POINTER        0x8802  // image does not point to a pdb file

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFile(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in PVOID  CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFileW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFile(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath
);

HANDLE
IMAGEAPI
FindDebugInfoFileEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR  DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFileExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACK)(
    __in PCSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPath(
    __in HANDLE hprocess,
    __in_opt PCSTR SearchPath,
    __in PCSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACK callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACKW)(
    __in PCWSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPathW(
    __in HANDLE hprocess,
    __in_opt PCWSTR SearchPath,
    __in PCWSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PWSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACKW callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImage(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACK Callback,
    __in PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImageW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImage(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath
);

HANDLE
IMAGEAPI
FindExecutableImageEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImageExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader(
    __in PVOID Base
);

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size,
    __out_opt PIMAGE_SECTION_HEADER* FoundHeader
);

PVOID
IMAGEAPI
ImageDirectoryEntryToData(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size
);

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva
);

PVOID
IMAGEAPI
ImageRvaToVa(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva,
    __in_opt OUT PIMAGE_SECTION_HEADER* LastRvaSection
);

#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION
{
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    __in_opt HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PCSTR SymbolPath,
    __in ULONG ImageBase
);

BOOL
IMAGEAPI
UnmapDebugInformation(
    __out_xcount(unknown) PIMAGE_DEBUG_INFORMATION DebugInfo
);

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PSTR OutputPathBuffer
);

BOOL
IMAGEAPI
SearchTreeForFileW(
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PWSTR OutputPathBuffer
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACK)(
    __in PCSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTree(
    __in_opt HANDLE hProcess,
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACK cb,
    __in_opt PVOID data
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACKW)(
    __in PCWSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTreeW(
    __in_opt HANDLE hProcess,
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PWSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACKW cb,
    __in_opt PVOID data
);

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    __in PCSTR DirPath
);

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
//  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    __in PCSTR name,
    __out_ecount(maxStringLength) PSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolNameW(
    __in PCWSTR name,
    __out_ecount(maxStringLength) PWSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

//
// these values are used for synthesized file types
// that can be passed in as image headers instead of
// the standard ones from ntimage.h
//

#define DBHHEADER_DEBUGDIRS     0x1
#define DBHHEADER_CVMISC        0x2
#define DBHHEADER_PDBGUID       0x3
typedef struct _MODLOAD_DATA
{
    DWORD   ssize;                  // size of this struct
    DWORD   ssig;                   // signature identifying the passed data
    PVOID   data;                   // pointer to passed data
    DWORD   size;                   // size of passed data
    DWORD   flags;                  // options
} MODLOAD_DATA, *PMODLOAD_DATA;

typedef struct _MODLOAD_CVMISC
{
    DWORD   oCV;                    // ofset to the codeview record
    size_t  cCV;                    // size of the codeview record
    DWORD   oMisc;                  // offset to the misc record
    size_t  cMisc;                  // size of the misc record
    DWORD   dtImage;                // datetime stamp of the image
    DWORD   cImage;                 // size of the image
} MODLOAD_CVMISC, *PMODLOAD_CVMISC;

typedef struct _MODLOAD_PDBGUID_PDBAGE
{
    GUID    PdbGuid;                // Pdb Guid
    DWORD   PdbAge;                 // Pdb Age
} MODLOAD_PDBGUID_PDBAGE, *PMODLOAD_PDBGUID_PDBAGE;

//
// StackWalking API
//

typedef enum
{
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64
{
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS
{
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    __in LPADDRESS a32,
    __out LPADDRESS64 a64
)
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    __in LPADDRESS64 a64,
    __out LPADDRESS a32
)
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD64   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD64   StackBase;
    DWORD64   StackLimit;

    DWORD64   Reserved[5];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD   StackBase;
    DWORD   StackLimit;

    DWORD   Reserved[5];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    __in PKDHELP p32,
    __out PKDHELP64 p64
)
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
    p64->KiUserExceptionDispatcher = p32->KiUserExceptionDispatcher;
    p64->StackBase = p32->StackBase;
    p64->StackLimit = p32->StackLimit;
}
#endif

typedef struct _tagSTACKFRAME64
{
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME
{
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 qwBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out LPDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    __in HANDLE ahProcess,
    __in DWORD64 AddrBase
);

typedef
DWORD64
(__stdcall* PGET_MODULE_BASE_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 Address
);

typedef
DWORD64
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE64)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __in LPADDRESS64 lpaddr
);

BOOL
IMAGEAPI
StackWalk64(
    __in DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME64 StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD lpBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out PDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);

typedef
DWORD
(__stdcall* PGET_MODULE_BASE_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD Address
);

typedef
DWORD
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __out LPADDRESS lpaddr
);

BOOL
IMAGEAPI
StackWalk(
    DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE TranslateAddress
);

#endif


#define API_VERSION_NUMBER 11

typedef struct API_VERSION
{
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
);

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    __in LPAPI_VERSION AppVersion
);

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    __in HMODULE Module
);

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64)(
    __in PCSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64W)(
    __in PCWSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt ULONG64 CallbackData,
    __in_opt ULONG64 UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK)(
    __in HANDLE hProcess,
    __in DWORD AddrBase,
    __in_opt PVOID UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG64 AddrBase,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK)(
    __in PCSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACKW)(
    __in PCWSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt PVOID CallbackData,
    __in_opt PVOID UserContext
);

#endif


// values found in SYMBOL_INFO.Tag
//
// This was taken from cvconst.h and should
// not override any values found there.
//
// #define _NO_CVCONST_H_ if you don't
// have access to that file...

#ifdef _NO_CVCONST_H

// DIA enums

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

#endif

//
// flags found in SYMBOL_INFO.Flags
//

#define SYMFLAG_VALUEPRESENT     0x00000001
#define SYMFLAG_REGISTER         0x00000008
#define SYMFLAG_REGREL           0x00000010
#define SYMFLAG_FRAMEREL         0x00000020
#define SYMFLAG_PARAMETER        0x00000040
#define SYMFLAG_LOCAL            0x00000080
#define SYMFLAG_CONSTANT         0x00000100
#define SYMFLAG_EXPORT           0x00000200
#define SYMFLAG_FORWARDER        0x00000400
#define SYMFLAG_FUNCTION         0x00000800
#define SYMFLAG_VIRTUAL          0x00001000
#define SYMFLAG_THUNK            0x00002000
#define SYMFLAG_TLSREL           0x00004000
#define SYMFLAG_SLOT             0x00008000
#define SYMFLAG_ILREL            0x00010000
#define SYMFLAG_METADATA         0x00020000
#define SYMFLAG_CLR_TOKEN        0x00040000

// this resets SymNext/Prev to the beginning
// of the module passed in the address field

#define SYMFLAG_RESET            0x80000000

//
// symbol type enumeration
//
typedef enum
{
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    SymVirtual,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR    Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

typedef struct _IMAGEHLP_SYMBOL64_PACKAGE
{
    IMAGEHLP_SYMBOL64 sym;
    CHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL64_PACKAGE, *PIMAGEHLP_SYMBOL64_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR   Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW64, *PIMAGEHLP_SYMBOLW64;

typedef struct _IMAGEHLP_SYMBOLW64_PACKAGE
{
    IMAGEHLP_SYMBOLW64 sym;
    WCHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW64_PACKAGE, *PIMAGEHLP_SYMBOLW64_PACKAGE;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#define IMAGEHLP_SYMBOL_PACKAGE IMAGEHLP_SYMBOL64_PACKAGE
#define PIMAGEHLP_SYMBOL_PACKAGE PIMAGEHLP_SYMBOL64_PACKAGE
#define IMAGEHLP_SYMBOLW IMAGEHLP_SYMBOLW64
#define PIMAGEHLP_SYMBOLW PIMAGEHLP_SYMBOLW64
#define IMAGEHLP_SYMBOLW_PACKAGE IMAGEHLP_SYMBOLW64_PACKAGE
#define PIMAGEHLP_SYMBOLW_PACKAGE PIMAGEHLP_SYMBOLW64_PACKAGE

#else

typedef struct _IMAGEHLP_SYMBOL
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;

typedef struct _IMAGEHLP_SYMBOL_PACKAGE
{
    IMAGEHLP_SYMBOL sym;
    CHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL_PACKAGE, *PIMAGEHLP_SYMBOL_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR                       Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW, *PIMAGEHLP_SYMBOLW;

typedef struct _IMAGEHLP_SYMBOLW_PACKAGE
{
    IMAGEHLP_SYMBOLW sym;
    WCHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW_PACKAGE, *PIMAGEHLP_SYMBOLW_PACKAGE;

#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
    // new elements: 07-Jun-2002
    CHAR     LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    CHAR     CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    // new elements: 07-Jun-2002
    WCHAR    LoadedImageName[256];   // symbol file name
    WCHAR    LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    WCHAR        CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    WCHAR    LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

typedef struct _IMAGEHLP_LINEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PWSTR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW64, *PIMAGEHLP_LINEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD    Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;

typedef struct _IMAGEHLP_LINEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW, *PIMAGEHLP_LINEW;
#endif

//
// source file structure
//

typedef struct _SOURCEFILE
{
    DWORD64  ModBase;                // base address of loaded module
    PCHAR    FileName;               // full filename of source
} SOURCEFILE, *PSOURCEFILE;

typedef struct _SOURCEFILEW
{
    DWORD64  ModBase;                // base address of loaded module
    PWSTR    FileName;               // full filename of source
} SOURCEFILEW, *PSOURCEFILEW;

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_EVENT                               0x00000010
#define CBA_DEFERRED_SYMBOL_LOAD_PARTIAL        0x00000020
#define CBA_DEBUG_INFO                          0x10000000
#define CBA_SRCSRV_INFO                         0x20000000
#define CBA_SRCSRV_EVENT                        0x40000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY
{
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD*    bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

enum
{
    sevInfo = 0,
    sevProblem,
    sevAttn,
    sevFatal,
    sevMax  // unused
};

#define EVENT_SRCSPEW_START 100
#define EVENT_SRCSPEW       100
#define EVENT_SRCSPEW_END   199

typedef struct _IMAGEHLP_CBA_EVENT
{
    DWORD severity;                                     // values from sevInfo to sevFatal
    DWORD code;                                         // numerical code IDs the error
    PCHAR desc;                                         // may contain a text description of the error
    PVOID object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENT, *PIMAGEHLP_CBA_EVENT;

typedef struct _IMAGEHLP_CBA_EVENTW
{
    DWORD  severity;                                     // values from sevInfo to sevFatal
    DWORD  code;                                         // numerical code IDs the error
    PCWSTR desc;                                         // may contain a text description of the error
    PVOID  object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENTW, *PIMAGEHLP_CBA_EVENTW;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;                     //
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOADW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOADW64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    WCHAR    FileName[MAX_PATH + 1]; // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;         //
} IMAGEHLP_DEFERRED_SYMBOL_LOADW64, *PIMAGEHLP_DEFERRED_SYMBOL_LOADW64;

#define DSLFLAG_MISMATCHED_PDB  0x1
#define DSLFLAG_MISMATCHED_DBG  0x2

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64
{
    DWORD              SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD              NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64 Symbol;                 // array of duplicate symbols
    DWORD              SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL
{
    DWORD            SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD            NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL Symbol;                 // array of duplicate symbols
    DWORD            SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif

// If dbghelp ever needs to display graphical UI, it will use this as the parent window.

BOOL
IMAGEAPI
SymSetParentWindow(
    __in HWND hwnd
);

PCHAR
IMAGEAPI
SymSetHomeDirectory(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR dir
);

PWSTR
IMAGEAPI
SymSetHomeDirectoryW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR dir
);

PCHAR
IMAGEAPI
SymGetHomeDirectory(
    __in DWORD type,
    __out_ecount(size) PSTR dir,
    __in size_t size
);

PWSTR
IMAGEAPI
SymGetHomeDirectoryW(
    __in DWORD type,
    __out_ecount(size) PWSTR dir,
    __in size_t size
);

enum
{
    hdBase = 0, // root directory for dbghelp
    hdSym,      // where symbols are stored
    hdSrc,      // where source is stored
    hdMax       // end marker
};

typedef struct _OMAP
{
    ULONG  rva;
    ULONG  rvaTo;
} OMAP, *POMAP;

BOOL
IMAGEAPI
SymGetOmaps(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll,
    __out POMAP* OmapTo,
    __out PDWORD64 cOmapTo,
    __out POMAP* OmapFrom,
    __out PDWORD64 cOmapFrom
);

//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE          0x00000001
#define SYMOPT_UNDNAME                   0x00000002
#define SYMOPT_DEFERRED_LOADS            0x00000004
#define SYMOPT_NO_CPP                    0x00000008
#define SYMOPT_LOAD_LINES                0x00000010
#define SYMOPT_OMAP_FIND_NEAREST         0x00000020
#define SYMOPT_LOAD_ANYTHING             0x00000040
#define SYMOPT_IGNORE_CVREC              0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS      0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS      0x00000200
#define SYMOPT_EXACT_SYMBOLS             0x00000400
#define SYMOPT_ALLOW_ABSOLUTE_SYMBOLS    0x00000800
#define SYMOPT_IGNORE_NT_SYMPATH         0x00001000
#define SYMOPT_INCLUDE_32BIT_MODULES     0x00002000
#define SYMOPT_PUBLICS_ONLY              0x00004000
#define SYMOPT_NO_PUBLICS                0x00008000
#define SYMOPT_AUTO_PUBLICS              0x00010000
#define SYMOPT_NO_IMAGE_SEARCH           0x00020000
#define SYMOPT_SECURE                    0x00040000
#define SYMOPT_NO_PROMPTS                0x00080000
#define SYMOPT_OVERWRITE                 0x00100000
#define SYMOPT_IGNORE_IMAGEDIR           0x00200000
#define SYMOPT_FLAT_DIRECTORY            0x00400000
#define SYMOPT_FAVOR_COMPRESSED          0x00800000
#define SYMOPT_ALLOW_ZERO_ADDRESS        0x01000000
#define SYMOPT_DISABLE_SYMSRV_AUTODETECT 0x02000000

#define SYMOPT_DEBUG                     0x80000000

DWORD
IMAGEAPI
SymSetOptions(
    __in DWORD   SymOptions
);

DWORD
IMAGEAPI
SymGetOptions(
    VOID
);

BOOL
IMAGEAPI
SymCleanup(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymMatchString(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringA(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringW(
    __in PCWSTR string,
    __in PCWSTR expression,
    __in BOOL fCase
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACK)(
    __in PSOURCEFILE pSourceFile,
    __in_opt PVOID UserContext
);

// for backwards compatibility - don't use this
#define PSYM_ENUMSOURCFILES_CALLBACK PSYM_ENUMSOURCEFILES_CALLBACK

BOOL
IMAGEAPI
SymEnumSourceFiles(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACK cbSrcFiles,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACKW)(
    __in PSOURCEFILEW pSourceFile,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceFilesW(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACKW cbSrcFiles,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModules64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModulesW64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACKW64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    __in_opt PVOID UserContext
);
#endif

BOOL
IMAGEAPI
EnumerateLoadedModulesEx(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesExW(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesW64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    __in HANDLE hProcess,
    __in DWORD64 AddrBase
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);
#endif

BOOL
IMAGEAPI
SymGetUnwindInfo(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_bcount_opt(*Size) PVOID Buffer,
    __inout PULONG Size
);

BOOL
IMAGEAPI
SymGetModuleInfo64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULE64 ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULEW64 ModuleInfo
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULE ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULEW ModuleInfo
);
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    __in HANDLE hProcess,
    __in DWORD dwAddr
);
#endif

typedef struct _SRCCODEINFO
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    CHAR    Obj[MAX_PATH + 1];      // the object file within the module
    CHAR    FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFO, *PSRCCODEINFO;

typedef struct _SRCCODEINFOW
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    WCHAR   Obj[MAX_PATH + 1];      // the object file within the module
    WCHAR   FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFOW, *PSRCCODEINFOW;

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACK)(
    __in PSRCCODEINFO LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACKW)(
    __in PSRCCODEINFOW LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE64 Line64
);

BOOL
IMAGEAPI
SymGetLineFromAddrW64(
    __in HANDLE hProcess,
    __in DWORD64 dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW64 Line
);

BOOL
IMAGEAPI
SymEnumSourceLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

// flags for SymEnumSourceLines

#define ESLFLAG_FULLPATH        0x1
#define ESLFLAG_NEAREST         0x2
#define ESLFLAG_PREV            0x4
#define ESLFLAG_NEXT            0x8

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#define SymGetLineFromAddrW SymGetLineFromAddrW64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineFromAddrW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineFromNameW64(
    __in HANDLE hProcess,
    __in_opt PCWSTR ModuleName,
    __in_opt PCWSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE Line
);
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLinePrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLinePrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in PCSTR FileName,
    __out_ecount(BufferLines) PDWORD64 Buffer,
    __in ULONG BufferLines
);

BOOL
IMAGEAPI
SymMatchFileName(
    __in PCSTR FileName,
    __in PCSTR Match,
    __deref_opt_out PSTR* FileNameStop,
    __deref_opt_out PSTR* MatchStop
);

BOOL
IMAGEAPI
SymMatchFileNameW(
    __in PCWSTR FileName,
    __in PCWSTR Match,
    __deref_opt_out PWSTR* FileNameStop,
    __deref_opt_out PWSTR* MatchStop
);

BOOL
IMAGEAPI
SymGetSourceFile(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Params,
    __in PCSTR FileSpec,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Params,
    __in PCWSTR FileSpec,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileToken(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileTokenW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCWSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __in PCSTR VarName,
    __out_ecount(Size) PSTR Value,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __in PCWSTR VarName,
    __out_ecount(Size) PWSTR Value,
    __in DWORD Size
);

typedef BOOL (CALLBACK* PENUMSOURCEFILETOKENSCALLBACK)(__in PVOID token,  __in size_t size);

BOOL
IMAGEAPI
SymEnumSourceFileTokens(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PENUMSOURCEFILETOKENSCALLBACK Callback
);

BOOL
IMAGEAPI
SymInitialize(
    __in HANDLE hProcess,
    __in_opt PCSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymInitializeW(
    __in HANDLE hProcess,
    __in_opt PCWSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymGetSearchPath(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymGetSearchPathW(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PWSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymSetSearchPath(
    __in HANDLE hProcess,
    __in_opt PCSTR SearchPath
);

BOOL
IMAGEAPI
SymSetSearchPathW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SearchPath
);

#define SLMFLAG_VIRTUAL     0x1
#define SLMFLAG_ALT_INDEX   0x2
#define SLMFLAG_NO_SYMBOLS  0x4

DWORD64
IMAGEAPI
SymLoadModuleEx(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

DWORD64
IMAGEAPI
SymLoadModuleExW(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCWSTR ImageName,
    __in_opt PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

BOOL
IMAGEAPI
SymUnloadModule64(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    __in HANDLE hProcess,
    __in DWORD BaseOfDll
);
#endif

BOOL
IMAGEAPI
SymUnDName64(
    __in PIMAGEHLP_SYMBOL64 sym,            // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    __in PIMAGEHLP_SYMBOL sym,              // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterCallbackW64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);
#endif


typedef struct _IMAGEHLP_SYMBOL_SRC
{
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO   // AKA TYPTYP
{
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

typedef struct _SYMBOL_INFO
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef struct _SYMBOL_INFO_PACKAGE
{
    SYMBOL_INFO si;
    CHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGE, *PSYMBOL_INFO_PACKAGE;

typedef struct _SYMBOL_INFOW
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    WCHAR       Name[1];          // Name of symbol
} SYMBOL_INFOW, *PSYMBOL_INFOW;

typedef struct _SYMBOL_INFO_PACKAGEW
{
    SYMBOL_INFOW si;
    WCHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGEW, *PSYMBOL_INFO_PACKAGEW;

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


BOOL
IMAGEAPI
SymSetContext(
    __in HANDLE hProcess,
    __in PIMAGEHLP_STACK_FRAME StackFrame,
    __in_opt PIMAGEHLP_CONTEXT Context
);

BOOL
IMAGEAPI
SymSetScopeFromAddr(
    __in HANDLE hProcess,
    __in ULONG64 Address
);

BOOL
IMAGEAPI
SymSetScopeFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index
);

typedef BOOL
(CALLBACK* PSYM_ENUMPROCESSES_CALLBACK)(
    __in HANDLE hProcess,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumProcesses(
    __in PSYM_ENUMPROCESSES_CALLBACK EnumProcessesCallback,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymFromAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromToken(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromTokenW(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymNext(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymNextW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

BOOL
IMAGEAPI
SymPrev(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymPrevW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

// While SymFromName will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromNameW(
    __in HANDLE hProcess,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACK)(
    __in PSYMBOL_INFO pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbols(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACKW)(
    __in PSYMBOL_INFOW pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

#define SYMSEARCH_MASKOBJS      0x01    // used internally to implement other APIs
#define SYMSEARCH_RECURSE       0X02    // recurse scopes
#define SYMSEARCH_GLOBALSONLY   0X04    // search only for global symbols
#define SYMSEARCH_ALLITEMS      0X08    // search for everything in the pdb, not just normal scoped symbols

BOOL
IMAGEAPI
SymSearch(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymSearchW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCWSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymGetScope(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetScopeW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromIndexW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO
{
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
    TI_GET_THISADJUST,
    TI_GET_UDTKIND,
    TI_IS_EQUIV_TO,
    TI_GET_CALLING_CONVENTION,
    TI_IS_CLOSE_EQUIV_TO,
    TI_GTIEX_REQS_VALID,
    TI_GET_VIRTUALBASEOFFSET,
    TI_GET_VIRTUALBASEDISPINDEX,
    TI_GET_IS_REFERENCE,
    TI_GET_INDIRECTVIRTUALBASECLASS,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS
{
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __in ULONG TypeId,
    __in IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    __out PVOID pInfo
);

#define IMAGEHLP_GET_TYPE_INFO_UNCACHED 0x00000001
#define IMAGEHLP_GET_TYPE_INFO_CHILDREN 0x00000002

typedef struct _IMAGEHLP_GET_TYPE_INFO_PARAMS
{
    IN  ULONG    SizeOfStruct;
    IN  ULONG    Flags;
    IN  ULONG    NumIds;
    IN  PULONG   TypeIds;
    IN  ULONG64  TagFilter;
    IN  ULONG    NumReqs;
    IN  IMAGEHLP_SYMBOL_TYPE_INFO* ReqKinds;
    IN  PULONG_PTR ReqOffsets;
    IN  PULONG   ReqSizes;
    IN  ULONG_PTR ReqStride;
    IN  ULONG_PTR BufferSize;
    OUT PVOID    Buffer;
    OUT ULONG    EntriesMatched;
    OUT ULONG    EntriesFilled;
    OUT ULONG64  TagsFound;
    OUT ULONG64  AllReqsValid;
    IN  ULONG    NumReqsValid;
    OUT PULONG64 ReqsValid OPTIONAL;
} IMAGEHLP_GET_TYPE_INFO_PARAMS, *PIMAGEHLP_GET_TYPE_INFO_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfoEx(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __inout PIMAGEHLP_GET_TYPE_INFO_PARAMS Params
);

BOOL
IMAGEAPI
SymEnumTypes(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetTypeFromName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetTypeFromNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymAddSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymAddSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymRefreshModuleList(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymAddSourceStream(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAM)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamA(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAMA)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR FileSpec,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

BOOL
IMAGEAPI
SymSrvIsStoreW(
    __in_opt HANDLE hProcess,
    __in PCWSTR path
);

BOOL
IMAGEAPI
SymSrvIsStore(
    __in_opt HANDLE hProcess,
    __in PCSTR path
);

PCSTR
IMAGEAPI
SymSrvDeltaName(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Type,
    __in PCSTR File1,
    __in PCSTR File2
);

PCWSTR
IMAGEAPI
SymSrvDeltaNameW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Type,
    __in PCWSTR File1,
    __in PCWSTR File2
);

PCSTR
IMAGEAPI
SymSrvGetSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Node,
    __in PCSTR File
);

PCWSTR
IMAGEAPI
SymSrvGetSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File
);

BOOL
IMAGEAPI
SymSrvGetFileIndexes(
    __in PCSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexesW(
    __in PCWSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexStringW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __out_ecount(Size) PWSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexString(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __out_ecount(Size) PSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

typedef struct
{
    DWORD sizeofstruct;
    char file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    char dbgfile[MAX_PATH + 1];
    char pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFO, *PSYMSRV_INDEX_INFO;

typedef struct
{
    DWORD sizeofstruct;
    WCHAR file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    WCHAR dbgfile[MAX_PATH + 1];
    WCHAR pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFOW, *PSYMSRV_INDEX_INFOW;

BOOL
IMAGEAPI
SymSrvGetFileIndexInfo(
    __in PCSTR File,
    __out PSYMSRV_INDEX_INFO Info,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexInfoW(
    __in PCWSTR File,
    __out PSYMSRV_INDEX_INFOW Info,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR Node,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreFile(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreFileW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __in DWORD Flags
);

// used by SymGetSymbolFile's "Type" parameter

enum
{
    sfImage = 0,
    sfDbg,
    sfPdb,
    sfMpd,
    sfMax
};

BOOL
IMAGEAPI
SymGetSymbolFile(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PSTR DbgFile,
    __in size_t cDbgFile
);

BOOL
IMAGEAPI
SymGetSymbolFileW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PWSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PWSTR DbgFile,
    __in size_t cDbgFile
);

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI* PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    __in DWORD DataType,
    __in PVOID* Data,
    __out LPDWORD DataLength,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDump(
    __in_opt LPCSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    __in_opt LPCWSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

// -----------------------------------------------------------------
// The following 4 legacy APIs are fully supported, but newer
// ones are recommended.  SymFromName and SymFromAddr provide
// much more detailed info on the returned symbol.

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out_opt PDWORD64 pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL64  Symbol
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out_opt PDWORD pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif

// While following two APIs will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymGetSymFromName64(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif


// Symbol server exports

typedef BOOL (WINAPI* PSYMBOLSERVERPROC)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCA)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROC)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCA)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCW)(PCWSTR, PCWSTR, PCWSTR, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSWPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR(WINAPI* PSYMBOLSERVERGETOPTIONSPROC)();
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROC)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCA)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCW)(PCWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERGETVERSION)(LPAPI_VERSION);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAME)(PCSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAMEW)(PCWSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRING)(PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRINGW)(PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILE)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILEW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTORE)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTOREW)(PCWSTR);
typedef DWORD (WINAPI* PSYMBOLSERVERVERSION)();
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERMESSAGEPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);

#define SYMSRV_VERSION              2

#define SSRVOPT_CALLBACK            0x00000001
#define SSRVOPT_DWORD               0x00000002
#define SSRVOPT_DWORDPTR            0x00000004
#define SSRVOPT_GUIDPTR             0x00000008
#define SSRVOPT_OLDGUIDPTR          0x00000010
#define SSRVOPT_UNATTENDED          0x00000020
#define SSRVOPT_NOCOPY              0x00000040
#define SSRVOPT_GETPATH             0x00000040
#define SSRVOPT_PARENTWIN           0x00000080
#define SSRVOPT_PARAMTYPE           0x00000100
#define SSRVOPT_SECURE              0x00000200
#define SSRVOPT_TRACE               0x00000400
#define SSRVOPT_SETCONTEXT          0x00000800
#define SSRVOPT_PROXY               0x00001000
#define SSRVOPT_DOWNSTREAM_STORE    0x00002000
#define SSRVOPT_OVERWRITE           0x00004000
#define SSRVOPT_RESETTOU            0x00008000
#define SSRVOPT_CALLBACKW           0x00010000
#define SSRVOPT_FLAT_DEFAULT_STORE  0x00020000
#define SSRVOPT_PROXYW              0x00040000
#define SSRVOPT_MESSAGE             0x00080000
#define SSRVOPT_SERVICE             0x00100000   // deprecated
#define SSRVOPT_FAVOR_COMPRESSED    0x00200000
#define SSRVOPT_STRING              0x00400000
#define SSRVOPT_WINHTTP             0x00800000
#define SSRVOPT_WININET             0x01000000

#define SSRVOPT_MAX                 0x0100000

#define SSRVOPT_RESET               ((ULONG_PTR)-1)


#define NUM_SSRVOPTS                30

#define SSRVACTION_TRACE        1
#define SSRVACTION_QUERYCANCEL  2
#define SSRVACTION_EVENT        3
#define SSRVACTION_EVENTW       4
#define SSRVACTION_SIZE         5

#define SYMSTOREOPT_COMPRESS        0x01
#define SYMSTOREOPT_OVERWRITE       0x02
#define SYMSTOREOPT_RETURNINDEX     0x04
#define SYMSTOREOPT_POINTER         0x08
#define SYMSTOREOPT_ALT_INDEX       0x10
#define SYMSTOREOPT_UNICODE         0x20
#define SYMSTOREOPT_PASS_IF_EXISTS  0x40

#ifdef DBGHELP_TRANSLATE_TCHAR
#define SymInitialize                     SymInitializeW
#define SymAddSymbol                      SymAddSymbolW
#define SymDeleteSymbol                   SymDeleteSymbolW
#define SearchTreeForFile                 SearchTreeForFileW
#define UnDecorateSymbolName              UnDecorateSymbolNameW
#define SymGetLineFromName64              SymGetLineFromNameW64
#define SymGetLineFromAddr64              SymGetLineFromAddrW64
#define SymGetLineNext64                  SymGetLineNextW64
#define SymGetLinePrev64                  SymGetLinePrevW64
#define SymFromName                       SymFromNameW
#define SymFindExecutableImage            SymFindExecutableImageW
#define FindExecutableImageEx             FindExecutableImageExW
#define SymSearch                         SymSearchW
#define SymEnumLines                      SymEnumLinesW
#define SymEnumSourceLines                SymEnumSourceLinesW
#define SymGetTypeFromName                SymGetTypeFromNameW
#define SymEnumSymbolsForAddr             SymEnumSymbolsForAddrW
#define SymFromAddr                       SymFromAddrW
#define SymMatchString                    SymMatchStringW
#define SymEnumSourceFiles                SymEnumSourceFilesW
#define SymEnumSymbols                    SymEnumSymbolsW
#define SymLoadModuleEx                   SymLoadModuleExW
#define SymSetSearchPath                  SymSetSearchPathW
#define SymGetSearchPath                  SymGetSearchPathW
#define EnumDirTree                       EnumDirTreeW
#define SymFromToken                      SymFromTokenW
#define SymFromIndex                      SymFromIndexW
#define SymGetScope                       SymGetScopeW
#define SymNext                           SymNextW
#define SymPrev                           SymPrevW
#define SymEnumTypes                      SymEnumTypesW
#define SymEnumTypesByName                SymEnumTypesByNameW
#define SymRegisterCallback64             SymRegisterCallbackW64
#define SymFindDebugInfoFile              SymFindDebugInfoFileW
#define FindDebugInfoFileEx               FindDebugInfoFileExW
#define SymFindFileInPath                 SymFindFileInPathW
#define SymEnumerateModules64             SymEnumerateModulesW64
#define SymSetHomeDirectory               SymSetHomeDirectoryW
#define SymGetHomeDirectory               SymGetHomeDirectoryW
#define SymGetSourceFile                  SymGetSourceFileW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetFileLineOffsets64           SymGetFileLineOffsetsW64
#define SymFindFileInPath                 SymFindFileInPathW
#define SymMatchFileName                  SymMatchFileNameW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetModuleInfo64                SymGetModuleInfoW64
#define SymSrvIsStore                     SymSrvIsStoreW
#define SymSrvDeltaName                   SymSrvDeltaNameW
#define SymSrvGetSupplement               SymSrvGetSupplementW
#define SymSrvStoreSupplement             SymSrvStoreSupplementW
#define SymSrvGetFileIndexes              SymSrvGetFileIndexes
#define SymSrvGetFileIndexString          SymSrvGetFileIndexStringW
#define SymSrvStoreFile                   SymSrvStoreFileW
#define SymGetSymbolFile                  SymGetSymbolFileW
#define EnumerateLoadedModules64          EnumerateLoadedModulesW64
#define EnumerateLoadedModulesEx          EnumerateLoadedModulesExW
#define SymSrvGetFileIndexInfo            SymSrvGetFileIndexInfoW

#define IMAGEHLP_LINE64                   IMAGEHLP_LINEW64
#define PIMAGEHLP_LINE64                  PIMAGEHLP_LINEW64
#define SYMBOL_INFO                       SYMBOL_INFOW
#define PSYMBOL_INFO                      PSYMBOL_INFOW
#define SYMBOL_INFO_PACKAGE               SYMBOL_INFO_PACKAGEW
#define PSYMBOL_INFO_PACKAGE              PSYMBOL_INFO_PACKAGEW
#define FIND_EXE_FILE_CALLBACK            FIND_EXE_FILE_CALLBACKW
#define PFIND_EXE_FILE_CALLBACK           PFIND_EXE_FILE_CALLBACKW
#define SYM_ENUMERATESYMBOLS_CALLBACK     SYM_ENUMERATESYMBOLS_CALLBACKW
#define PSYM_ENUMERATESYMBOLS_CALLBACK    PSYM_ENUMERATESYMBOLS_CALLBACKW
#define SRCCODEINFO                       SRCCODEINFOW
#define PSRCCODEINFO                      PSRCCODEINFOW
#define SOURCEFILE                        SOURCEFILEW
#define PSOURCEFILE                       PSOURCEFILEW
#define SYM_ENUMSOURECFILES_CALLBACK      SYM_ENUMSOURCEFILES_CALLBACKW
#define PSYM_ENUMSOURCEFILES_CALLBACK     PSYM_ENUMSOURECFILES_CALLBACKW
#define IMAGEHLP_CBA_EVENT                IMAGEHLP_CBA_EVENTW
#define PIMAGEHLP_CBA_EVENT               PIMAGEHLP_CBA_EVENTW
#define PENUMDIRTREE_CALLBACK             PENUMDIRTREE_CALLBACKW
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD64   IMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD64  PIMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PFIND_DEBUG_FILE_CALLBACK         PFIND_DEBUG_FILE_CALLBACKW
#define PFINDFILEINPATHCALLBACK           PFINDFILEINPATHCALLBACKW
#define IMAGEHLP_MODULE64                 IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULE64                PIMAGEHLP_MODULEW64
#define SYMSRV_INDEX_INFO                 SYMSRV_INDEX_INFOW
#define PSYMSRV_INDEX_INFO                PSYMSRV_INDEX_INFOW

#define PSYMBOLSERVERPROC                 PSYMBOLSERVERPROCW
#define PSYMBOLSERVERPINGPROC             PSYMBOLSERVERPINGPROCW
#endif

// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in DWORD one,
    __in DWORD two,
    __in DWORD three,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    __in_opt PVOID UserContext
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);
#endif

// use SymLoadModuleEx

DWORD64
IMAGEAPI
SymLoadModule64(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD SizeOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD BaseOfDll,
    __in DWORD SizeOfDll
);
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#define SymGetSymNextW SymGetSymNextW64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#define SymGetSymPrevW SymGetSymPrevW64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif


// These values should not be used.
// They have been replaced by SYMFLAG_ values.

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
#define SYMF_THUNK            0x00002000
#define SYMF_TLSREL           0x00004000

// These values should also not be used.
// They have been replaced by SYMFLAG_ values.

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000
#define IMAGEHLP_SYMBOL_THUNK                      SYMF_THUNK           // 0x2000
#define IMAGEHLP_SYMBOL_INFO_TLSRELATIVE           SYMF_TLSREL          // 0x4000

#pragma pack(pop)


#pragma pack(push,4)

#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR
{
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64
{
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR
{
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64
{
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER
{
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union
    {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY
{
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING
{
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE
{

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,
    MemoryInfoListStream        = 16,
    ThreadInfoListStream        = 17,
    HandleOperationListStream   = 18,
    TokenStream                 = 19,

    ceStreamNull                = 0x8000,
    ceStreamSystemInfo          = 0x8001,
    ceStreamException           = 0x8002,
    ceStreamModuleList          = 0x8003,
    ceStreamProcessList         = 0x8004,
    ceStreamThreadList          = 0x8005,
    ceStreamThreadContextList   = 0x8006,
    ceStreamThreadCallStackList = 0x8007,
    ceStreamMemoryVirtualList   = 0x8008,
    ceStreamMemoryPhysicalList  = 0x8009,
    ceStreamBucketParameters    = 0x800A,
    ceStreamProcessModuleMap    = 0x800B,
    ceStreamDiagnosisList       = 0x800C,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
//

//
// CPU information is obtained from one of two places.
//
//  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
//     instruction. You must use the X86 portion of the union for X86
//     computers.
//
//  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
//     IsProcessorFeatureSupported().
//

typedef union _CPU_INFORMATION
{

    //
    // X86 platforms use CPUID function to obtain processor information.
    //

    struct
    {

        //
        // CPUID Subfunction 0, register EAX (VendorId [0]),
        // EBX (VendorId [1]) and ECX (VendorId [2]).
        //

        ULONG32 VendorId [ 3 ];

        //
        // CPUID Subfunction 1, register EAX
        //

        ULONG32 VersionInformation;

        //
        // CPUID Subfunction 1, register EDX
        //

        ULONG32 FeatureInformation;


        //
        // CPUID, Subfunction 80000001, register EBX. This will only
        // be obtained if the vendor id is "AuthenticAMD".
        //

        ULONG32 AMDExtendedCpuFeatures;

    } X86CpuInfo;

    //
    // Non-x86 platforms use processor feature flags.
    //

    struct
    {

        ULONG64 ProcessorFeatures [ 2 ];

    } OtherCpuInfo;

} CPU_INFORMATION, *PCPU_INFORMATION;

typedef struct _MINIDUMP_SYSTEM_INFO
{

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //

    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    union
    {
        USHORT Reserved0;
        struct
        {
            UCHAR NumberOfProcessors;
            UCHAR ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //

    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //

    RVA CSDVersionRva;

    union
    {
        ULONG32 Reserved1;
        struct
        {
            USHORT SuiteMask;
            USHORT Reserved2;
        };
    };

    CPU_INFORMATION Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT(sizeof(((PPROCESS_INFORMATION)0)->dwThreadId) == 4);

typedef struct _MINIDUMP_THREAD
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION
{
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM
{
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST
{
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST
{
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST
{
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION
{
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;

typedef struct _MINIDUMP_EXCEPTION_INFORMATION64
{
    DWORD ThreadId;
    ULONG64 ExceptionRecord;
    ULONG64 ContextRecord;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION64, *PMINIDUMP_EXCEPTION_INFORMATION64;


//
// Support for capturing system handle state at the time of the dump.
//

// Per-handle object information varies according to
// the OS, the OS version, the processor type and
// so on.  The minidump gives a minidump identifier
// to each possible data format for identification
// purposes but does not control nor describe the actual data.
typedef enum _MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE
{
    MiniHandleObjectInformationNone,
    MiniThreadInformation1,
    MiniMutantInformation1,
    MiniMutantInformation2,
    MiniProcessInformation1,
    MiniProcessInformation2,
    MiniHandleObjectInformationTypeMax
} MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE;

typedef struct _MINIDUMP_HANDLE_OBJECT_INFORMATION
{
    RVA NextInfoRva;
    ULONG32 InfoType;
    ULONG32 SizeOfInfo;
    // Raw information follows.
} MINIDUMP_HANDLE_OBJECT_INFORMATION;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR_2
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
    RVA ObjectInfoRva;
    ULONG32 Reserved0;
} MINIDUMP_HANDLE_DESCRIPTOR_2, *PMINIDUMP_HANDLE_DESCRIPTOR_2;

// The latest MINIDUMP_HANDLE_DESCRIPTOR definition.
typedef MINIDUMP_HANDLE_DESCRIPTOR_2 MINIDUMP_HANDLE_DESCRIPTOR_N;
typedef MINIDUMP_HANDLE_DESCRIPTOR_N* PMINIDUMP_HANDLE_DESCRIPTOR_N;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;

// Some operating systems can track the last operations
// performed on a handle.  For example, Application Verifier
// can enable this for some versions of Windows.  The
// handle operation list collects handle operations
// known for the dump target.
// Each entry is an AVRF_HANDLE_OPERATION.
typedef struct _MINIDUMP_HANDLE_OPERATION_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_OPERATION_LIST, *PMINIDUMP_HANDLE_OPERATION_LIST;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR
{
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID            0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES         0x00000002
#define MINIDUMP_MISC1_PROCESSOR_POWER_INFO  0x00000004
#define MINIDUMP_MISC3_PROCESS_INTEGRITY     0x00000010
#define MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS 0x00000020
#define MINIDUMP_MISC3_TIMEZONE              0x00000040
#define MINIDUMP_MISC3_PROTECTED_PROCESS     0x00000080

typedef struct _MINIDUMP_MISC_INFO
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;

typedef struct _MINIDUMP_MISC_INFO_2
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
} MINIDUMP_MISC_INFO_2, *PMINIDUMP_MISC_INFO_2;

typedef struct _MINIDUMP_MISC_INFO_3
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
    ULONG32 ProcessIntegrityLevel;
    ULONG32 ProcessExecuteFlags;
    ULONG32 ProtectedProcess;
    ULONG32 TimeZoneId;
    TIME_ZONE_INFORMATION TimeZone;
} MINIDUMP_MISC_INFO_3, *PMINIDUMP_MISC_INFO_3;

// The latest MINIDUMP_MISC_INFO definition.
typedef MINIDUMP_MISC_INFO_3 MINIDUMP_MISC_INFO_N;
typedef MINIDUMP_MISC_INFO_N* PMINIDUMP_MISC_INFO_N;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

typedef struct _MINIDUMP_MEMORY_INFO
{
    ULONG64 BaseAddress;
    ULONG64 AllocationBase;
    ULONG32 AllocationProtect;
    ULONG32 __alignment1;
    ULONG64 RegionSize;
    ULONG32 State;
    ULONG32 Protect;
    ULONG32 Type;
    ULONG32 __alignment2;
} MINIDUMP_MEMORY_INFO, *PMINIDUMP_MEMORY_INFO;

typedef struct _MINIDUMP_MEMORY_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG64 NumberOfEntries;
} MINIDUMP_MEMORY_INFO_LIST, *PMINIDUMP_MEMORY_INFO_LIST;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

// Thread dump writer status flags.
#define MINIDUMP_THREAD_INFO_ERROR_THREAD    0x00000001
#define MINIDUMP_THREAD_INFO_WRITING_THREAD  0x00000002
#define MINIDUMP_THREAD_INFO_EXITED_THREAD   0x00000004
#define MINIDUMP_THREAD_INFO_INVALID_INFO    0x00000008
#define MINIDUMP_THREAD_INFO_INVALID_CONTEXT 0x00000010
#define MINIDUMP_THREAD_INFO_INVALID_TEB     0x00000020

typedef struct _MINIDUMP_THREAD_INFO
{
    ULONG32 ThreadId;
    ULONG32 DumpFlags;
    ULONG32 DumpError;
    ULONG32 ExitStatus;
    ULONG64 CreateTime;
    ULONG64 ExitTime;
    ULONG64 KernelTime;
    ULONG64 UserTime;
    ULONG64 StartAddress;
    ULONG64 Affinity;
} MINIDUMP_THREAD_INFO, *PMINIDUMP_THREAD_INFO;

typedef struct _MINIDUMP_THREAD_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG NumberOfEntries;
} MINIDUMP_THREAD_INFO_LIST, *PMINIDUMP_THREAD_INFO_LIST;

//
// Support for token information.
//
typedef struct _MINIDUMP_TOKEN_INFO_HEADER
{
    ULONG   TokenSize;   // The size of the token structure.
    ULONG   TokenId;     // The PID in NtOpenProcessToken() call or TID in NtOpenThreadToken() call.
    ULONG64 TokenHandle; // The handle value returned.
} MINIDUMP_TOKEN_INFO_HEADER, *PMINIDUMP_TOKEN_INFO_HEADER;

typedef struct _MINIDUMP_TOKEN_INFO_LIST
{
    ULONG TokenListSize;
    ULONG TokenListEntries;
    ULONG ListHeaderSize;
    ULONG ElementHeaderSize;
} MINIDUMP_TOKEN_INFO_LIST, *PMINIDUMP_TOKEN_INFO_LIST;

//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD
{
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM
{
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION
{
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE
{
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
    MemoryCallback,
    CancelCallback,
    WriteKernelMinidumpCallback,
    KernelMinidumpStatusCallback,
    RemoveMemoryCallback,
    IncludeVmRegionCallback,
    IoStartCallback,
    IoWriteAllCallback,
    IoFinishCallback,
    ReadMemoryFailureCallback,
    SecondaryFlagsCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK
{
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS
{
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
    ThreadWriteThreadInfo        = 0x0040,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK
{
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord;
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK
{
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS
{
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010,
    ModuleWriteTlsData       = 0x0020,
    ModuleWriteCodeSegs      = 0x0040,
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_IO_CALLBACK
{
    HANDLE Handle;
    ULONG64 Offset;
    PVOID Buffer;
    ULONG BufferBytes;
} MINIDUMP_IO_CALLBACK, *PMINIDUMP_IO_CALLBACK;


typedef struct _MINIDUMP_READ_MEMORY_FAILURE_CALLBACK
{
    ULONG64 Offset;
    ULONG Bytes;
    HRESULT FailureStatus;
} MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
*PMINIDUMP_READ_MEMORY_FAILURE_CALLBACK;


typedef struct _MINIDUMP_CALLBACK_INPUT
{
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union
    {
        HRESULT Status;
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
        MINIDUMP_IO_CALLBACK Io;
        MINIDUMP_READ_MEMORY_FAILURE_CALLBACK ReadMemoryFailure;
        ULONG SecondaryFlags;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT
{
    union
    {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
        ULONG SecondaryFlags;
        struct
        {
            ULONG64 MemoryBase;
            ULONG MemorySize;
        };
        struct
        {
            BOOL CheckCancel;
            BOOL Cancel;
        };
        HANDLE Handle;
        struct
        {
            MINIDUMP_MEMORY_INFO VmRegion;
            BOOL Continue;
        };
        HRESULT Status;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;


//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//
// Code which is concerned with potentially private information
// getting into the minidump can set a flag that automatically
// modifies all existing and future flags to avoid placing
// unnecessary data in the dump.  Basic data, such as stack
// information, will still be included but optional data, such
// as indirect memory, will not.
//
// When doing a full memory dump it's possible to store all
// of the enumerated memory region descriptive information
// in a memory information stream.
//
// Additional thread information beyond the basic thread
// structure can be collected if desired.
//
// A minidump with code segments includes all of the code
// and code-related sections from loaded modules in order
// to capture executable content.
//
// MiniDumpWithoutAuxiliaryState turns off any secondary,
// auxiliary-supported memory gathering.
//
// MiniDumpWithFullAuxiliaryState asks any present auxiliary
// data providers to include all of their state in the dump.
// The exact set of what is provided depends on the auxiliary.
// This can be quite large.
//

typedef enum _MINIDUMP_TYPE
{
    MiniDumpNormal                         = 0x00000000,
    MiniDumpWithDataSegs                   = 0x00000001,
    MiniDumpWithFullMemory                 = 0x00000002,
    MiniDumpWithHandleData                 = 0x00000004,
    MiniDumpFilterMemory                   = 0x00000008,
    MiniDumpScanMemory                     = 0x00000010,
    MiniDumpWithUnloadedModules            = 0x00000020,
    MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
    MiniDumpFilterModulePaths              = 0x00000080,
    MiniDumpWithProcessThreadData          = 0x00000100,
    MiniDumpWithPrivateReadWriteMemory     = 0x00000200,
    MiniDumpWithoutOptionalData            = 0x00000400,
    MiniDumpWithFullMemoryInfo             = 0x00000800,
    MiniDumpWithThreadInfo                 = 0x00001000,
    MiniDumpWithCodeSegs                   = 0x00002000,
    MiniDumpWithoutAuxiliaryState          = 0x00004000,
    MiniDumpWithFullAuxiliaryState         = 0x00008000,
    MiniDumpWithPrivateWriteCopyMemory     = 0x00010000,
    MiniDumpIgnoreInaccessibleMemory       = 0x00020000,
    MiniDumpWithTokenInformation           = 0x00040000,
    MiniDumpValidTypeFlags                 = 0x0007ffff,
} MINIDUMP_TYPE;

//
// In addition to the primary flags provided to
// MiniDumpWriteDump there are additional, less
// frequently used options queried via the secondary
// flags callback.
//
// MiniSecondaryWithoutPowerInfo suppresses the minidump
// query that retrieves processor power information for
// MINIDUMP_MISC_INFO.
//

typedef enum _MINIDUMP_SECONDARY_FLAGS
{
    MiniSecondaryWithoutPowerInfo = 0x00000001,

    MiniSecondaryValidFlags       = 0x00000001,
} MINIDUMP_SECONDARY_FLAGS;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI* MINIDUMP_CALLBACK_ROUTINE)(
    __inout PVOID CallbackParam,
    __in    PMINIDUMP_CALLBACK_INPUT CallbackInput,
    __inout PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
);

typedef struct _MINIDUMP_CALLBACK_INFORMATION
{
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    __in HANDLE hProcess,
    __in DWORD ProcessId,
    __in HANDLE hFile,
    __in MINIDUMP_TYPE DumpType,
    __in_opt PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    __in_opt PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
    __in_opt PMINIDUMP_CALLBACK_INFORMATION CallbackParam
);

BOOL
WINAPI
MiniDumpReadDumpStream(
    __in PVOID BaseOfDump,
    __in ULONG StreamNumber,
    __deref_out_opt PMINIDUMP_DIRECTORY* Dir,
    __deref_out_opt PVOID* StreamPointer,
    __out_opt ULONG* StreamSize
);

#pragma pack(pop)

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_


```

`src/x64dbgPlaytime/pluginsdk/jansson/jansson.h`:

```h
/*
 * Copyright (c) 2009-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 */

#ifndef JANSSON_H
#define JANSSON_H

#include <stdio.h>
#include <stdlib.h>  /* for size_t */
#include <stdarg.h>

#include "jansson_config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* version */

#define JANSSON_MAJOR_VERSION  2
#define JANSSON_MINOR_VERSION  9
#define JANSSON_MICRO_VERSION  0

/* Micro version is omitted if it's 0 */
#define JANSSON_VERSION  "2.9"

/* Version as a 3-byte hex number, e.g. 0x010201 == 1.2.1. Use this
   for numeric comparisons, e.g. #if JANSSON_VERSION_HEX >= ... */
#define JANSSON_VERSION_HEX  ((JANSSON_MAJOR_VERSION << 16) |   \
                              (JANSSON_MINOR_VERSION << 8)  |   \
                              (JANSSON_MICRO_VERSION << 0))


/* types */

typedef enum
{
    JSON_OBJECT,
    JSON_ARRAY,
    JSON_STRING,
    JSON_INTEGER,
    JSON_REAL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NULL
} json_type;

typedef struct json_t
{
    json_type type;
    size_t refcount;
} json_t;

#ifndef JANSSON_USING_CMAKE /* disabled if using cmake */
#if JSON_INTEGER_IS_LONG_LONG
#ifdef _WIN32
#define JSON_INTEGER_FORMAT "I64d"
#else
#define JSON_INTEGER_FORMAT "lld"
#endif
typedef long long json_int_t;
#else
#define JSON_INTEGER_FORMAT "ld"
typedef long json_int_t;
#endif /* JSON_INTEGER_IS_LONG_LONG */
#endif

#define json_typeof(json)      ((json)->type)
#define json_is_object(json)   ((json) && json_typeof(json) == JSON_OBJECT)
#define json_is_array(json)    ((json) && json_typeof(json) == JSON_ARRAY)
#define json_is_string(json)   ((json) && json_typeof(json) == JSON_STRING)
#define json_is_integer(json)  ((json) && json_typeof(json) == JSON_INTEGER)
#define json_is_real(json)     ((json) && json_typeof(json) == JSON_REAL)
#define json_is_number(json)   (json_is_integer(json) || json_is_real(json))
#define json_is_true(json)     ((json) && json_typeof(json) == JSON_TRUE)
#define json_is_false(json)    ((json) && json_typeof(json) == JSON_FALSE)
#define json_boolean_value     json_is_true
#define json_is_boolean(json)  (json_is_true(json) || json_is_false(json))
#define json_is_null(json)     ((json) && json_typeof(json) == JSON_NULL)

/* construction, destruction, reference counting */

__declspec(dllimport) json_t* json_object(void);
__declspec(dllimport) json_t* json_array(void);
__declspec(dllimport) json_t* json_string(const char* value);
__declspec(dllimport) json_t* json_stringn(const char* value, size_t len);
__declspec(dllimport) json_t* json_string_nocheck(const char* value);
__declspec(dllimport) json_t* json_stringn_nocheck(const char* value, size_t len);
__declspec(dllimport) json_t* json_integer(json_int_t value);
__declspec(dllimport) json_t* json_real(double value);
__declspec(dllimport) json_t* json_true(void);
__declspec(dllimport) json_t* json_false(void);
#define json_boolean(val)      ((val) ? json_true() : json_false())
__declspec(dllimport) json_t* json_null(void);

static JSON_INLINE
json_t* json_incref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1)
        ++json->refcount;
    return json;
}

/* do not call json_delete directly */
__declspec(dllimport) void json_delete(json_t* json);

static JSON_INLINE
void json_decref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1 && --json->refcount == 0)
        json_delete(json);
}

#if defined(__GNUC__) || defined(__clang__)
static JSON_INLINE
void json_decrefp(json_t** json)
{
    if(json)
    {
        json_decref(*json);
        *json = NULL;
    }
}

#define json_auto_t json_t __attribute__((cleanup(json_decrefp)))
#endif


/* error reporting */

#define JSON_ERROR_TEXT_LENGTH    160
#define JSON_ERROR_SOURCE_LENGTH   80

typedef struct
{
    int line;
    int column;
    int position;
    char source[JSON_ERROR_SOURCE_LENGTH];
    char text[JSON_ERROR_TEXT_LENGTH];
} json_error_t;


/* getters, setters, manipulation */

__declspec(dllimport) void json_object_seed(size_t seed);
__declspec(dllimport) size_t json_object_size(const json_t* object);
__declspec(dllimport) json_t* json_object_get(const json_t* object, const char* key);
__declspec(dllimport) int json_object_set_new(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_set_new_nocheck(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_del(json_t* object, const char* key);
__declspec(dllimport) int json_object_clear(json_t* object);
__declspec(dllimport) int json_object_update(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_existing(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_missing(json_t* object, json_t* other);
__declspec(dllimport) void* json_object_iter(json_t* object);
__declspec(dllimport) void* json_object_iter_at(json_t* object, const char* key);
__declspec(dllimport) void* json_object_key_to_iter(const char* key);
__declspec(dllimport) void* json_object_iter_next(json_t* object, void* iter);
__declspec(dllimport) const char* json_object_iter_key(void* iter);
__declspec(dllimport) json_t* json_object_iter_value(void* iter);
__declspec(dllimport) int json_object_iter_set_new(json_t* object, void* iter, json_t* value);

#define json_object_foreach(object, key, value) \
    for(key = json_object_iter_key(json_object_iter(object)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(json_object_iter_next(object, json_object_key_to_iter(key))))

#define json_object_foreach_safe(object, n, key, value)     \
    for(key = json_object_iter_key(json_object_iter(object)), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(n), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)))

#define json_array_foreach(array, index, value) \
    for(index = 0; \
        index < json_array_size(array) && (value = json_array_get(array, index)); \
        index++)

static JSON_INLINE
int json_object_set(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_set_nocheck(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new_nocheck(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_iter_set(json_t* object, void* iter, json_t* value)
{
    return json_object_iter_set_new(object, iter, json_incref(value));
}

__declspec(dllimport) size_t json_array_size(const json_t* array);
__declspec(dllimport) json_t* json_array_get(const json_t* array, size_t index);
__declspec(dllimport) int json_array_set_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_append_new(json_t* array, json_t* value);
__declspec(dllimport) int json_array_insert_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_remove(json_t* array, size_t index);
__declspec(dllimport) int json_array_clear(json_t* array);
__declspec(dllimport) int json_array_extend(json_t* array, json_t* other);

static JSON_INLINE
int json_array_set(json_t* array, size_t ind, json_t* value)
{
    return json_array_set_new(array, ind, json_incref(value));
}

static JSON_INLINE
int json_array_append(json_t* array, json_t* value)
{
    return json_array_append_new(array, json_incref(value));
}

static JSON_INLINE
int json_array_insert(json_t* array, size_t ind, json_t* value)
{
    return json_array_insert_new(array, ind, json_incref(value));
}

__declspec(dllimport) const char* json_string_value(const json_t* string);
__declspec(dllimport) size_t json_string_length(const json_t* string);
__declspec(dllimport) json_int_t json_integer_value(const json_t* integer);
__declspec(dllimport) double json_real_value(const json_t* real);
__declspec(dllimport) double json_number_value(const json_t* json);

__declspec(dllimport) int json_string_set(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_string_set_nocheck(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn_nocheck(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_integer_set(json_t* integer, json_int_t value);
__declspec(dllimport) int json_real_set(json_t* real, double value);

/* pack, unpack */

__declspec(dllimport) json_t* json_pack(const char* fmt, ...);
__declspec(dllimport) json_t* json_pack_ex(json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) json_t* json_vpack_ex(json_error_t* error, size_t flags, const char* fmt, va_list ap);

#define JSON_VALIDATE_ONLY  0x1
#define JSON_STRICT         0x2

__declspec(dllimport) int json_unpack(json_t* root, const char* fmt, ...);
__declspec(dllimport) int json_unpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) int json_vunpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, va_list ap);


/* equality */

__declspec(dllimport) int json_equal(json_t* value1, json_t* value2);


/* copying */

__declspec(dllimport) json_t* json_copy(json_t* value);
__declspec(dllimport) json_t* json_deep_copy(const json_t* value);


/* decoding */

#define JSON_REJECT_DUPLICATES  0x1
#define JSON_DISABLE_EOF_CHECK  0x2
#define JSON_DECODE_ANY         0x4
#define JSON_DECODE_INT_AS_REAL 0x8
#define JSON_ALLOW_NUL          0x10

typedef size_t (*json_load_callback_t)(void* buffer, size_t buflen, void* data);

__declspec(dllimport) json_t* json_loads(const char* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadb(const char* buffer, size_t buflen, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadf(FILE* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_file(const char* path, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_callback(json_load_callback_t callback, void* data, size_t flags, json_error_t* error);


/* encoding */

#define JSON_MAX_INDENT         0x1F
#define JSON_INDENT(n)          ((n) & JSON_MAX_INDENT)
#define JSON_COMPACT            0x20
#define JSON_ENSURE_ASCII       0x40
#define JSON_SORT_KEYS          0x80
#define JSON_PRESERVE_ORDER     0x100
#define JSON_ENCODE_ANY         0x200
#define JSON_ESCAPE_SLASH       0x400
#define JSON_REAL_PRECISION(n)  (((n) & 0x1F) << 11)

typedef int (*json_dump_callback_t)(const char* buffer, size_t size, void* data);

__declspec(dllimport) char* json_dumps(const json_t* json, size_t flags);
__declspec(dllimport) int json_dumpf(const json_t* json, FILE* output, size_t flags);
__declspec(dllimport) int json_dump_file(const json_t* json, const char* path, size_t flags);
__declspec(dllimport) int json_dump_callback(const json_t* json, json_dump_callback_t callback, void* data, size_t flags);

/* custom memory allocation */

typedef void* (*json_malloc_t)(size_t);
typedef void (*json_free_t)(void*);

__declspec(dllimport) void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
__declspec(dllimport) void json_get_alloc_funcs(json_malloc_t* malloc_fn, json_free_t* free_fn);

#ifdef __cplusplus
}
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/jansson/jansson_config.h`:

```h
/*
 * Copyright (c) 2010-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 *
 *
 * This file specifies a part of the site-specific configuration for
 * Jansson, namely those things that affect the public API in
 * jansson.h.
 *
 * The CMake system will generate the jansson_config.h file and
 * copy it to the build and install directories.
 */

#ifndef JANSSON_CONFIG_H
#define JANSSON_CONFIG_H

/* Define this so that we can disable scattered automake configuration in source files */
#ifndef JANSSON_USING_CMAKE
#define JANSSON_USING_CMAKE
#endif

/* Note: when using cmake, JSON_INTEGER_IS_LONG_LONG is not defined nor used,
 * as we will also check for __int64 etc types.
 * (the definition was used in the automake system) */

/* Bring in the cmake-detected defines */
#define HAVE_STDINT_H 1
/* #undef HAVE_INTTYPES_H */
/* #undef HAVE_SYS_TYPES_H */

/* Include our standard type header for the integer typedef */

#if defined(HAVE_STDINT_H)
#  include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#  include <inttypes.h>
#elif defined(HAVE_SYS_TYPES_H)
#  include <sys/types.h>
#endif


/* If your compiler supports the inline keyword in C, JSON_INLINE is
   defined to `inline', otherwise empty. In C++, the inline is always
   supported. */
#ifdef __cplusplus
#define JSON_INLINE inline
#else
#define JSON_INLINE __inline
#endif


#define json_int_t long long
#define json_strtoint strtoll
#define JSON_INTEGER_FORMAT "I64d"


/* If locale.h and localeconv() are available, define to 1, otherwise to 0. */
#define JSON_HAVE_LOCALECONV 1


/* Maximum recursion depth for parsing JSON input.
   This limits the depth of e.g. array-within-array constructions. */
#define JSON_PARSER_MAX_DEPTH 2048


#endif

```

`src/x64dbgPlaytime/pluginsdk/jansson/jansson_x64dbg.h`:

```h
#pragma once

#include "jansson.h"

typedef json_t* JSON;

static JSON_INLINE
json_t* json_hex(unsigned json_int_t value)
{
    char hexvalue[20];
    sprintf(hexvalue, "0x%llX", value);
    return json_string(hexvalue);
}

static JSON_INLINE
unsigned json_int_t json_hex_value(const json_t* hex)
{
    unsigned json_int_t ret = 0;
    const char* hexvalue;
    hexvalue = json_string_value(hex);
    if(!hexvalue)
        return 0;
    sscanf(hexvalue, "0x%llX", &ret);
    return ret;
}
```

`src/x64dbgPlaytime/pluginsdk/lz4/lz4.h`:

```h
/*
   LZ4 - Fast LZ compression algorithm
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4_H
#define _LZ4_H

#if defined (__cplusplus)
extern "C"
{
#endif


/**************************************
   Version
**************************************/
#define LZ4_VERSION_MAJOR    1    /* for major interface/format changes  */
#define LZ4_VERSION_MINOR    1    /* for minor interface/format changes  */
#define LZ4_VERSION_RELEASE  3    /* for tweaks, bug-fixes, or development */


/**************************************
   Compiler Options
**************************************/
#if (defined(__GNUC__) && defined(__STRICT_ANSI__)) || (defined(_MSC_VER) && !defined(__cplusplus))   /* Visual Studio */
#  define inline __inline           /* Visual C is not C99, but supports some kind of inline */
#endif


/**************************************
   Simple Functions
**************************************/

__declspec(dllimport) int LZ4_compress(const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_decompress_safe(const char* source, char* dest, int inputSize, int maxOutputSize);

/*
LZ4_compress() :
    Compresses 'inputSize' bytes from 'source' into 'dest'.
    Destination buffer must be already allocated,
    and must be sized to handle worst cases situations (input data not compressible)
    Worst case size evaluation is provided by function LZ4_compressBound()
    inputSize : Max supported value is LZ4_MAX_INPUT_VALUE
    return : the number of bytes written in buffer dest
             or 0 if the compression fails

LZ4_decompress_safe() :
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function is protected against buffer overflow exploits (never writes outside of output buffer, and never reads outside of input buffer). Therefore, it is protected against malicious data packets
*/


/**************************************
   Advanced Functions
**************************************/
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)

/*
LZ4_compressBound() :
    Provides the maximum size that LZ4 may output in a "worst case" scenario (input data not compressible)
    primarily useful for memory allocation of output buffer.
    inline function is recommended for the general case,
    macro is also provided when result needs to be evaluated at compilation (such as stack memory allocation).

    isize  : is the input size. Max supported value is LZ4_MAX_INPUT_SIZE
    return : maximum output size in a "worst case" scenario
             or 0, if input size is too large ( > LZ4_MAX_INPUT_SIZE)
*/
__declspec(dllimport) int LZ4_compressBound(int isize);


/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is LZ4_MAX_INPUT_VALUE
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes written in buffer 'dest'
             or 0 if the compression fails
*/
__declspec(dllimport) int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);


/*
LZ4_decompress_fast() :
    originalSize : is the original and therefore uncompressed size
    return : the number of bytes read from the source buffer (in other words, the compressed size)
             If the source stream is malformed, the function will stop decoding and return a negative result.
    note : This function is a bit faster than LZ4_decompress_safe()
           This function never writes outside of output buffers, but may read beyond input buffer in case of malicious data packet.
           Use this function preferably into a trusted environment (data to decode comes from a trusted source).
           Destination buffer must be already allocated. Its size must be a minimum of 'outputSize' bytes.
*/
__declspec(dllimport) int LZ4_decompress_fast(const char* source, char* dest, int originalSize);


/*
LZ4_decompress_safe_partial() :
    This function decompress a compressed block of size 'inputSize' at position 'source'
    into output buffer 'dest' of size 'maxOutputSize'.
    The function tries to stop decompressing operation as soon as 'targetOutputSize' has been reached,
    reducing decompression time.
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
       Note : this number can be < 'targetOutputSize' should the compressed block to decode be smaller.
             Always control how many bytes were decoded.
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets
*/
__declspec(dllimport) int LZ4_decompress_safe_partial(const char* source, char* dest, int inputSize, int targetOutputSize, int maxOutputSize);


/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofState();

Note that tables must be aligned on 4-bytes boundaries, otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withState() and LZ4_compress_limitedOutput_withState() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/
__declspec(dllimport) int LZ4_sizeofState(void);
__declspec(dllimport) int LZ4_compress_withState(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compress_limitedOutput_withState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_create(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compress_continue(void* LZ4_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compress_limitedOutput_continue(void* LZ4_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBuffer(void* LZ4_Data);
__declspec(dllimport) int   LZ4_free(void* LZ4_Data);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4 Data Structure, thanks to the function :

void* LZ4_create (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4 Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compress_continue() or LZ4_compress_limitedOutput_continue().
Their behavior are identical to LZ4_compress() or LZ4_compress_limitedOutput(),
but require the LZ4 Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBuffer(void* LZ4_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compress_continue() or LZ4_compress_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_free() will release the memory used by the LZ4 Data Structure.
*/


__declspec(dllimport) int LZ4_sizeofStreamState(void);
__declspec(dllimport) int LZ4_resetStreamState(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_create (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamState();
Note also that space must be 4-bytes aligned.

Once space is allocated, you must initialize it using : LZ4_resetStreamState(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned on 4-bytes boundaries, and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamState() must be 0 is OK.
Any other value means there was an error (typically, pointer is not aligned on 4-bytes boundaries).
*/


__declspec(dllimport) int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int outputSize);

/*
*_withPrefix64k() :
    These decoding functions work the same as their "normal name" versions,
    but can use up to 64KB of data in front of 'char* dest'.
    These functions are necessary to decode inter-dependant blocks.
*/


/**************************************
   Obsolete Functions
**************************************/
/*
These functions are deprecated and should no longer be used.
They are provided here for compatibility with existing user programs.
*/
__declspec(dllimport) int LZ4_uncompress(const char* source, char* dest, int outputSize);
__declspec(dllimport) int LZ4_uncompress_unknownOutputSize(const char* source, char* dest, int isize, int maxOutputSize);


#if defined (__cplusplus)
}
#endif

#endif //_LZ4_H
```

`src/x64dbgPlaytime/pluginsdk/lz4/lz4file.h`:

```h
#ifndef _LZ4FILE_H
#define _LZ4FILE_H

typedef enum _LZ4_STATUS
{
    LZ4_SUCCESS,
    LZ4_FAILED_OPEN_INPUT,
    LZ4_FAILED_OPEN_OUTPUT,
    LZ4_NOT_ENOUGH_MEMORY,
    LZ4_INVALID_ARCHIVE,
    LZ4_CORRUPTED_ARCHIVE
} LZ4_STATUS;

#if defined (__cplusplus)
extern "C"
{
#endif

__declspec(dllimport) LZ4_STATUS LZ4_compress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_compress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);

#if defined (__cplusplus)
}
#endif

#endif //_LZ4FILE_H
```

`src/x64dbgPlaytime/pluginsdk/lz4/lz4hc.h`:

```h
/*
   LZ4 HC - High Compression Mode of LZ4
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4HC_H
#define _LZ4HC_H

#if defined (__cplusplus)
extern "C"
{
#endif


__declspec(dllimport) int LZ4_compressHC(const char* source, char* dest, int inputSize);
/*
LZ4_compressHC :
    return : the number of bytes in compressed buffer dest
             or 0 if compression fails.
    note : destination buffer must be already allocated.
        To avoid any problem, size it to handle worst cases situations (input data not compressible)
        Worst case size evaluation is provided by function LZ4_compressBound() (see "lz4.h")
*/

__declspec(dllimport) int LZ4_compressHC_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);
/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is 1 GB
    maxOutputSize : is maximum allowed size into the destination buffer (which must be already allocated)
    return : the number of output bytes written in buffer 'dest'
             or 0 if compression fails.
*/


__declspec(dllimport) int LZ4_compressHC2(const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);
/*
    Same functions as above, but with programmable 'compressionLevel'.
    Recommended values are between 4 and 9, although any value between 0 and 16 will work.
    'compressionLevel'==0 means use default 'compressionLevel' value.
    Values above 16 behave the same as 16.
    Equivalent variants exist for all other compression functions below.
*/

/* Note :
Decompression functions are provided within LZ4 source code (see "lz4.h") (BSD license)
*/


/**************************************
   Using an external allocation
**************************************/
__declspec(dllimport) int LZ4_sizeofStateHC(void);
__declspec(dllimport) int LZ4_compressHC_withStateHC(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compressHC_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);

__declspec(dllimport) int LZ4_compressHC2_withStateHC(void* state, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofStateHC();

Note that tables must be aligned for pointer (32 or 64 bits), otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withStateHC() and LZ4_compress_limitedOutput_withStateHC() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_createHC(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compressHC_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compressHC_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
__declspec(dllimport) int   LZ4_freeHC(void* LZ4HC_Data);

__declspec(dllimport) int   LZ4_compressHC2_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int   LZ4_compressHC2_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4HC Data Structure, thanks to the function :

void* LZ4_createHC (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4HC Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue().
Their behavior are identical to LZ4_compressHC() or LZ4_compressHC_limitedOutput(),
but require the LZ4HC Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_freeHC() will release the memory used by the LZ4HC Data Structure.
*/

__declspec(dllimport) int LZ4_sizeofStreamStateHC(void);
__declspec(dllimport) int LZ4_resetStreamStateHC(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_createHC (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamStateHC();
Note also that space must be aligned for pointers (32 or 64 bits).

Once space is allocated, you must initialize it using : LZ4_resetStreamStateHC(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned for pointers (32 or 64 bits), and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamStateHC() must be 0 is OK.
Any other value means there was an error (typically, state is not aligned for pointers (32 or 64 bits)).
*/


#if defined (__cplusplus)
}
#endif

#endif //_LZ4HC_H

```

`src/x64dbgPlaytime/pluginsdk/yara/yara.h`:

```h
/*
Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_YARA_H
#define YR_YARA_H

#include "yara/utils.h"
#include "yara/filemap.h"
#include "yara/compiler.h"
#include "yara/modules.h"
#include "yara/object.h"
#include "yara/libyara.h"
#include "yara/error.h"
#include "yara/stream.h"
#include "yara/hash.h"

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/ahocorasick.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _AHOCORASICK_H
#define _AHOCORASICK_H

#include "limits.h"
#include "atoms.h"
#include "types.h"


#define YR_AC_ROOT_STATE                0
#define YR_AC_NEXT_STATE(t)             (t >> 32)
#define YR_AC_INVALID_TRANSITION(t, c)  (((t) & 0xFFFF) != c)

#define YR_AC_MAKE_TRANSITION(state, code, flags) \
  ((uint64_t)((((uint64_t) state) << 32) | ((flags) << 16) | (code)))

#define YR_AC_USED_FLAG    0x1

#define YR_AC_USED_TRANSITION_SLOT(x)   ((x) & (YR_AC_USED_FLAG << 16))
#define YR_AC_UNUSED_TRANSITION_SLOT(x) (!YR_AC_USED_TRANSITION_SLOT(x))


typedef struct _YR_AC_TABLES
{
    YR_AC_TRANSITION* transitions;
    YR_AC_MATCH_TABLE_ENTRY* matches;

} YR_AC_TABLES;


int yr_ac_automaton_create(
    YR_AC_AUTOMATON** automaton);


int yr_ac_automaton_destroy(
    YR_AC_AUTOMATON* automaton);


int yr_ac_add_string(
    YR_AC_AUTOMATON* automaton,
    YR_STRING* string,
    YR_ATOM_LIST_ITEM* atom,
    YR_ARENA* matches_arena);


int yr_ac_compile(
    YR_AC_AUTOMATON* automaton,
    YR_ARENA* arena,
    YR_AC_TABLES* tables);


void yr_ac_print_automaton(
    YR_AC_AUTOMATON* automaton);


#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/arena.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ARENA_H
#define YR_ARENA_H

#include <stddef.h>

#include "integers.h"
#include "stream.h"

#define ARENA_FLAGS_FIXED_SIZE   1
#define ARENA_FLAGS_COALESCED    2
#define ARENA_FILE_VERSION       ((13 << 16) | MAX_THREADS)

#define EOL ((size_t) -1)


typedef struct _YR_RELOC
{
    uint32_t offset;
    struct _YR_RELOC* next;

} YR_RELOC;


typedef struct _YR_ARENA_PAGE
{

    uint8_t* new_address;
    uint8_t* address;

    size_t size;
    size_t used;

    YR_RELOC* reloc_list_head;
    YR_RELOC* reloc_list_tail;

    struct _YR_ARENA_PAGE* next;
    struct _YR_ARENA_PAGE* prev;

} YR_ARENA_PAGE;


typedef struct _YR_ARENA
{
    int flags;

    YR_ARENA_PAGE* page_list_head;
    YR_ARENA_PAGE* current_page;

} YR_ARENA;


int yr_arena_create(
    size_t initial_size,
    int flags,
    YR_ARENA** arena);


void yr_arena_destroy(
    YR_ARENA* arena);


void* yr_arena_base_address(
    YR_ARENA* arena);


void* yr_arena_next_address(
    YR_ARENA* arena,
    void* address,
    size_t offset);


int yr_arena_coalesce(
    YR_ARENA* arena);


int yr_arena_reserve_memory(
    YR_ARENA* arena,
    size_t size);


int yr_arena_allocate_memory(
    YR_ARENA* arena,
    size_t size,
    void** allocated_memory);


int yr_arena_allocate_struct(
    YR_ARENA* arena,
    size_t size,
    void** allocated_memory,
    ...);


int yr_arena_make_relocatable(
    YR_ARENA* arena,
    void* base,
    ...);


int yr_arena_write_data(
    YR_ARENA* arena,
    void* data,
    size_t size,
    void** written_data);


int yr_arena_write_string(
    YR_ARENA* arena,
    const char* string,
    char** written_string);


int yr_arena_append(
    YR_ARENA* target_arena,
    YR_ARENA* source_arena);


int yr_arena_load_stream(
    YR_STREAM* stream,
    YR_ARENA** arena);


int yr_arena_save_stream(
    YR_ARENA* arena,
    YR_STREAM* stream);


int yr_arena_duplicate(
    YR_ARENA* arena,
    YR_ARENA** duplicated);


void yr_arena_print(
    YR_ARENA* arena);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/atoms.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ATOMS_H
#define YR_ATOMS_H

#include "limits.h"
#include "re.h"

#define ATOM_TREE_LEAF  1
#define ATOM_TREE_AND   2
#define ATOM_TREE_OR    3


typedef struct _ATOM_TREE_NODE
{
    uint8_t type;
    uint8_t atom_length;
    uint8_t atom[MAX_ATOM_LENGTH];

    uint8_t* forward_code;
    uint8_t* backward_code;

    RE_NODE* recent_nodes[MAX_ATOM_LENGTH];

    struct _ATOM_TREE_NODE* children_head;
    struct _ATOM_TREE_NODE* children_tail;
    struct _ATOM_TREE_NODE* next_sibling;

} ATOM_TREE_NODE;


typedef struct _ATOM_TREE
{
    ATOM_TREE_NODE* current_leaf;
    ATOM_TREE_NODE* root_node;

} ATOM_TREE;


typedef struct _YR_ATOM_LIST_ITEM
{
    uint8_t atom_length;
    uint8_t atom[MAX_ATOM_LENGTH];

    uint16_t backtrack;

    uint8_t* forward_code;
    uint8_t* backward_code;

    struct _YR_ATOM_LIST_ITEM* next;

} YR_ATOM_LIST_ITEM;


int yr_atoms_extract_from_re(
    RE_AST* re_ast,
    int flags,
    YR_ATOM_LIST_ITEM** atoms);


int yr_atoms_extract_from_string(
    uint8_t* string,
    int string_length,
    int flags,
    YR_ATOM_LIST_ITEM** atoms);


int yr_atoms_min_quality(
    YR_ATOM_LIST_ITEM* atom_list);


void yr_atoms_list_destroy(
    YR_ATOM_LIST_ITEM* list_head);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/compiler.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_COMPILER_H
#define YR_COMPILER_H

#include <stdio.h>
#include <setjmp.h>

#include "ahocorasick.h"
#include "arena.h"
#include "hash.h"
#include "utils.h"
#include "filemap.h"


#define YARA_ERROR_LEVEL_ERROR   0
#define YARA_ERROR_LEVEL_WARNING 1


typedef void (*YR_COMPILER_CALLBACK_FUNC)(
    int error_level,
    const char* file_name,
    int line_number,
    const char* message,
    void* user_data);


typedef struct _YR_FIXUP
{
    void* address;
    struct _YR_FIXUP* next;

} YR_FIXUP;


typedef struct _YR_COMPILER
{
    int               errors;
    int               current_line;
    int               last_error;
    int               last_error_line;
    int               last_result;

    jmp_buf           error_recovery;

    YR_ARENA*         sz_arena;
    YR_ARENA*         rules_arena;
    YR_ARENA*         strings_arena;
    YR_ARENA*         code_arena;
    YR_ARENA*         re_code_arena;
    YR_ARENA*         compiled_rules_arena;
    YR_ARENA*         externals_arena;
    YR_ARENA*         namespaces_arena;
    YR_ARENA*         metas_arena;
    YR_ARENA*         matches_arena;
    YR_ARENA*         automaton_arena;

    YR_AC_AUTOMATON*  automaton;
    YR_HASH_TABLE*    rules_table;
    YR_HASH_TABLE*    objects_table;
    YR_HASH_TABLE*    strings_table;
    YR_NAMESPACE*     current_namespace;
    YR_RULE*          current_rule;

    YR_FIXUP*         fixup_stack_head;

    int               namespaces_count;

    uint8_t*          loop_address[MAX_LOOP_NESTING];
    char*             loop_identifier[MAX_LOOP_NESTING];
    int               loop_depth;
    int               loop_for_of_mem_offset;

    int               allow_includes;

    char*             file_name_stack[MAX_INCLUDE_DEPTH];
    int               file_name_stack_ptr;

    FILE*             file_stack[MAX_INCLUDE_DEPTH];
    int               file_stack_ptr;

    char              last_error_extra_info[MAX_COMPILER_ERROR_EXTRA_INFO];

    char              lex_buf[LEX_BUF_SIZE];
    char*             lex_buf_ptr;
    unsigned short    lex_buf_len;

    char              include_base_dir[MAX_PATH];
    void*             user_data;

    YR_COMPILER_CALLBACK_FUNC  callback;

} YR_COMPILER;


#define yr_compiler_set_error_extra_info(compiler, info) \
    strlcpy( \
        compiler->last_error_extra_info, \
        info, \
        sizeof(compiler->last_error_extra_info)); \


#define yr_compiler_set_error_extra_info_fmt(compiler, fmt, ...) \
    snprintf( \
        compiler->last_error_extra_info, \
        sizeof(compiler->last_error_extra_info), \
        fmt, __VA_ARGS__);


int _yr_compiler_push_file(
    YR_COMPILER* compiler,
    FILE* fh);


FILE* _yr_compiler_pop_file(
    YR_COMPILER* compiler);


int _yr_compiler_push_file_name(
    YR_COMPILER* compiler,
    const char* file_name);


void _yr_compiler_pop_file_name(
    YR_COMPILER* compiler);


YR_API int yr_compiler_create(
    YR_COMPILER** compiler);


YR_API void yr_compiler_destroy(
    YR_COMPILER* compiler);


YR_API void yr_compiler_set_callback(
    YR_COMPILER* compiler,
    YR_COMPILER_CALLBACK_FUNC callback,
    void* user_data);


YR_API int yr_compiler_add_file(
    YR_COMPILER* compiler,
    FILE* rules_file,
    const char* namespace_,
    const char* file_name);


YR_API int yr_compiler_add_fd(
    YR_COMPILER* compiler,
    YR_FILE_DESCRIPTOR rules_fd,
    const char* namespace_,
    const char* file_name);


YR_API int yr_compiler_add_string(
    YR_COMPILER* compiler,
    const char* rules_string,
    const char* namespace_);


YR_API char* yr_compiler_get_error_message(
    YR_COMPILER* compiler,
    char* buffer,
    int buffer_size);


YR_API char* yr_compiler_get_current_file_name(
    YR_COMPILER* context);


YR_API int yr_compiler_define_integer_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    int64_t value);


YR_API int yr_compiler_define_boolean_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    int value);


YR_API int yr_compiler_define_float_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    double value);


YR_API int yr_compiler_define_string_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    const char* value);


YR_API int yr_compiler_get_rules(
    YR_COMPILER* compiler,
    YR_RULES** rules);


#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/elf.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _ELF_H
#define _ELF_H

#include "integers.h"


// 32-bit ELF base types

typedef uint32_t elf32_addr_t;
typedef uint16_t elf32_half_t;
typedef uint32_t elf32_off_t;
typedef uint32_t elf32_word_t;

// 64-bit ELF base types

typedef uint64_t elf64_addr_t;
typedef uint16_t elf64_half_t;
typedef uint64_t elf64_off_t;
typedef uint32_t elf64_word_t;
typedef uint64_t elf64_xword_t;

#define ELF_MAGIC       0x464C457F

#define ELF_ET_NONE     0x0000  // no type
#define ELF_ET_REL      0x0001  // relocatable
#define ELF_ET_EXEC     0x0002  // executable
#define ELF_ET_DYN      0x0003  // Shared-Object-File
#define ELF_ET_CORE     0x0004  // Corefile
#define ELF_ET_LOPROC   0xFF00  // Processor-specific
#define ELF_ET_HIPROC   0x00FF  // Processor-specific

#define ELF_EM_NONE         0x0000  // no type
#define ELF_EM_M32          0x0001  // AT&T WE 32100
#define ELF_EM_SPARC        0x0002  // SPARC
#define ELF_EM_386          0x0003  // Intel 80386
#define ELF_EM_68K          0x0004  // Motorola 68000
#define ELF_EM_88K          0x0005  // Motorola 88000
#define ELF_EM_860          0x0007  // Intel 80860
#define ELF_EM_MIPS         0x0008  // MIPS I Architecture
#define ELF_EM_MIPS_RS3_LE  0x000A  // MIPS RS3000 Little-endian
#define ELF_EM_PPC          0x0014  // PowerPC
#define ELF_EM_PPC64        0x0015  // 64-bit PowerPC
#define ELF_EM_ARM          0x0028  // ARM
#define ELF_EM_X86_64       0x003E  // AMD/Intel x86_64
#define ELF_EM_AARCH64      0x00B7  // 64-bit ARM

#define ELF_CLASS_NONE  0x0000
#define ELF_CLASS_32    0x0001  // 32bit file
#define ELF_CLASS_64    0x0002  // 64bit file

#define ELF_DATA_NONE   0x0000
#define ELF_DATA_2LSB   0x0001
#define ELF_DATA_2MSB   0x002


#define ELF_SHT_NULL         0     // Section header table entry unused
#define ELF_SHT_PROGBITS     1     // Program data
#define ELF_SHT_SYMTAB       2     // Symbol table
#define ELF_SHT_STRTAB       3     // String table
#define ELF_SHT_RELA         4     // Relocation entries with addends
#define ELF_SHT_HASH         5     // Symbol hash table
#define ELF_SHT_DYNAMIC      6     // Dynamic linking information
#define ELF_SHT_NOTE         7     // Notes
#define ELF_SHT_NOBITS       8     // Program space with no data (bss)
#define ELF_SHT_REL          9     // Relocation entries, no addends
#define ELF_SHT_SHLIB        10    // Reserved
#define ELF_SHT_DYNSYM       11    // Dynamic linker symbol table
#define ELF_SHT_NUM          12    // Number of defined types

#define ELF_SHF_WRITE        0x1   // Section is writable
#define ELF_SHF_ALLOC        0x2   // Section is present during execution
#define ELF_SHF_EXECINSTR    0x4   // Section contains executable instructions

#define ELF_SHN_LORESERVE    0xFF00

#define ELF_PT_NULL          0     // The array element is unused
#define ELF_PT_LOAD          1     // Loadable segment
#define ELF_PT_DYNAMIC       2     // Segment contains dynamic linking info
#define ELF_PT_INTERP        3     // Contains interpreter pathname
#define ELF_PT_NOTE          4     // Location & size of auxiliary info
#define ELF_PT_SHLIB         5     // Reserved, unspecified semantics
#define ELF_PT_PHDR          6     // Location and size of program header table
#define ELF_PT_TLS           7     // Thread-Local Storage
#define ELF_PT_GNU_EH_FRAME  0x6474e550
#define ELF_PT_GNU_STACK     0x6474e551

#define ELF_DT_NULL          0     // End of the dynamic entries
#define ELF_DT_NEEDED        1     // Name of needed library
#define ELF_DT_PLTRELSZ      2     // Size in bytes of PLT relocs
#define ELF_DT_PLTGOT        3     // Processor defined value */
#define ELF_DT_HASH          4     // Address of symbol hash table
#define ELF_DT_STRTAB        5     // Address of string table
#define ELF_DT_SYMTAB        6     // Address of symbol table
#define ELF_DT_RELA          7     // Address of Rela relocs
#define ELF_DT_RELASZ        8     // Total size of Rela relocs
#define ELF_DT_RELAENT       9     // Size of one Rela reloc
#define ELF_DT_STRSZ         10    // Size of string table
#define ELF_DT_SYMENT        11    // Size of one symbol table entry
#define ELF_DT_INIT          12    // Address of init function
#define ELF_DT_FINI          13    // Address of termination function
#define ELF_DT_SONAME        14    // Name of shared object
#define ELF_DT_RPATH         15    // Library search path (deprecated)
#define ELF_DT_SYMBOLIC      16    // Start symbol search here
#define ELF_DT_REL           17    // Address of Rel relocs
#define ELF_DT_RELSZ         18    // Total size of Rel relocs
#define ELF_DT_RELENT        19    // Size of one Rel reloc
#define ELF_DT_PLTREL        20    // Type of reloc in PLT
#define ELF_DT_DEBUG         21    // For debugging; unspecified
#define ELF_DT_TEXTREL       22    // Reloc might modify .text
#define ELF_DT_JMPREL        23    // Address of PLT relocs
#define ELF_DT_BIND_NOW      24    // Process relocations of object
#define ELF_DT_INIT_ARRAY    25    // Array with addresses of init fct
#define ELF_DT_FINI_ARRAY    26    // Array with addresses of fini fct
#define ELF_DT_INIT_ARRAYSZ  27    // Size in bytes of DT_INIT_ARRAY
#define ELF_DT_FINI_ARRAYSZ  28    // Size in bytes of DT_FINI_ARRAY
#define ELF_DT_RUNPATH       29    // Library search path
#define ELF_DT_FLAGS         30    // Flags for the object being loaded
#define ELF_DT_ENCODING      32    // Start of encoded range

#define ELF_STT_NOTYPE       0     // Symbol type is unspecified
#define ELF_STT_OBJECT       1     // Symbol is a data object
#define ELF_STT_FUNC         2     // Symbol is a code object
#define ELF_STT_SECTION      3     // Symbol associated with a section
#define ELF_STT_FILE         4     // Symbol's name is file name
#define ELF_STT_COMMON       5     // Symbol is a common data object
#define ELF_STT_TLS          6     // Symbol is thread-local data object

#define ELF_STB_LOCAL        0     // Local symbol
#define ELF_STB_GLOBAL       1     // Global symbol
#define ELF_STB_WEAK         2     // Weak symbol

#define ELF_PF_X             0x1   // Segment is executable
#define ELF_PF_W             0x2   // Segment is writable
#define ELF_PF_R             0x4   // Segment is readable

#define ELF_PN_XNUM          0xffff

#pragma pack(push,1)

typedef struct
{
    uint32_t magic;
    uint8_t _class;
    uint8_t data;
    uint8_t version;
    uint8_t pad[8];
    uint8_t nident;

} elf_ident_t;


typedef struct
{
    elf_ident_t     ident;
    elf32_half_t    type;
    elf32_half_t    machine;
    elf32_word_t    version;
    elf32_addr_t    entry;
    elf32_off_t     ph_offset;
    elf32_off_t     sh_offset;
    elf32_word_t    flags;
    elf32_half_t    header_size;
    elf32_half_t    ph_entry_size;
    elf32_half_t    ph_entry_count;
    elf32_half_t    sh_entry_size;
    elf32_half_t    sh_entry_count;
    elf32_half_t    sh_str_table_index;

} elf32_header_t;


typedef struct
{
    elf_ident_t     ident;
    elf64_half_t    type;
    elf64_half_t    machine;
    elf64_word_t    version;
    elf64_addr_t    entry;
    elf64_off_t     ph_offset;
    elf64_off_t     sh_offset;
    elf64_word_t    flags;
    elf64_half_t    header_size;
    elf64_half_t    ph_entry_size;
    elf64_half_t    ph_entry_count;
    elf64_half_t    sh_entry_size;
    elf64_half_t    sh_entry_count;
    elf64_half_t    sh_str_table_index;

} elf64_header_t;


typedef struct
{
    elf32_word_t    type;
    elf32_off_t     offset;
    elf32_addr_t    virt_addr;
    elf32_addr_t    phys_addr;
    elf32_word_t    file_size;
    elf32_word_t    mem_size;
    elf32_word_t    flags;
    elf32_word_t    alignment;

} elf32_program_header_t;


typedef struct
{
    elf64_word_t    type;
    elf64_word_t    flags;
    elf64_off_t     offset;
    elf64_addr_t    virt_addr;
    elf64_addr_t    phys_addr;
    elf64_xword_t   file_size;
    elf64_xword_t   mem_size;
    elf64_xword_t   alignment;

} elf64_program_header_t;


typedef struct
{
    elf32_word_t    name;
    elf32_word_t    type;
    elf32_word_t    flags;
    elf32_addr_t    addr;
    elf32_off_t     offset;
    elf32_word_t    size;
    elf32_word_t    link;
    elf32_word_t    info;
    elf32_word_t    align;
    elf32_word_t    entry_size;

} elf32_section_header_t;


typedef struct
{
    elf64_word_t    name;
    elf64_word_t    type;
    elf64_xword_t   flags;
    elf64_addr_t    addr;
    elf64_off_t     offset;
    elf64_xword_t   size;
    elf64_word_t    link;
    elf64_word_t    info;
    elf64_xword_t   align;
    elf64_xword_t   entry_size;

} elf64_section_header_t;


typedef struct
{
    elf32_word_t    tag;
    elf32_word_t    val;

} elf32_dyn_t;


typedef struct
{
    elf64_xword_t   tag;
    elf64_xword_t   val;

} elf64_dyn_t;


typedef struct
{
    elf32_word_t    name;
    elf32_addr_t    value;
    elf32_word_t    size;
    unsigned char   info;
    unsigned char   other;
    elf32_half_t    shndx;

} elf32_sym_t;


typedef struct
{
    elf32_word_t    name;
    unsigned char   info;
    unsigned char   other;
    elf32_half_t    shndx;
    elf64_addr_t    value;
    elf64_xword_t   size;

} elf64_sym_t;


#pragma pack(pop)

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/error.h`:

```h
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ERROR_H
#define YR_ERROR_H

#include <string.h>

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#endif

#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS                           0
#endif

// ERROR_INSUFICIENT_MEMORY is misspelled but it's kept for backward
// compatibility, as some other programs can be using it in this form.
#define ERROR_INSUFICIENT_MEMORY                1

#define ERROR_INSUFFICIENT_MEMORY               1
#define ERROR_COULD_NOT_ATTACH_TO_PROCESS       2
#define ERROR_COULD_NOT_OPEN_FILE               3
#define ERROR_COULD_NOT_MAP_FILE                4
#define ERROR_INVALID_FILE                      6
#define ERROR_CORRUPT_FILE                      7
#define ERROR_UNSUPPORTED_FILE_VERSION          8
#define ERROR_INVALID_REGULAR_EXPRESSION        9
#define ERROR_INVALID_HEX_STRING                10
#define ERROR_SYNTAX_ERROR                      11
#define ERROR_LOOP_NESTING_LIMIT_EXCEEDED       12
#define ERROR_DUPLICATED_LOOP_IDENTIFIER        13
#define ERROR_DUPLICATED_IDENTIFIER             14
#define ERROR_DUPLICATED_TAG_IDENTIFIER         15
#define ERROR_DUPLICATED_META_IDENTIFIER        16
#define ERROR_DUPLICATED_STRING_IDENTIFIER      17
#define ERROR_UNREFERENCED_STRING               18
#define ERROR_UNDEFINED_STRING                  19
#define ERROR_UNDEFINED_IDENTIFIER              20
#define ERROR_MISPLACED_ANONYMOUS_STRING        21
#define ERROR_INCLUDES_CIRCULAR_REFERENCE       22
#define ERROR_INCLUDE_DEPTH_EXCEEDED            23
#define ERROR_WRONG_TYPE                        24
#define ERROR_EXEC_STACK_OVERFLOW               25
#define ERROR_SCAN_TIMEOUT                      26
#define ERROR_TOO_MANY_SCAN_THREADS             27
#define ERROR_CALLBACK_ERROR                    28
#define ERROR_INVALID_ARGUMENT                  29
#define ERROR_TOO_MANY_MATCHES                  30
#define ERROR_INTERNAL_FATAL_ERROR              31
#define ERROR_NESTED_FOR_OF_LOOP                32
#define ERROR_INVALID_FIELD_NAME                33
#define ERROR_UNKNOWN_MODULE                    34
#define ERROR_NOT_A_STRUCTURE                   35
#define ERROR_NOT_INDEXABLE                     36
#define ERROR_NOT_A_FUNCTION                    37
#define ERROR_INVALID_FORMAT                    38
#define ERROR_TOO_MANY_ARGUMENTS                39
#define ERROR_WRONG_ARGUMENTS                   40
#define ERROR_WRONG_RETURN_TYPE                 41
#define ERROR_DUPLICATED_STRUCTURE_MEMBER       42
#define ERROR_EMPTY_STRING                      43
#define ERROR_DIVISION_BY_ZERO                  44
#define ERROR_REGULAR_EXPRESSION_TOO_LARGE      45
#define ERROR_TOO_MANY_RE_FIBERS                46
#define ERROR_COULD_NOT_READ_PROCESS_MEMORY     47
#define ERROR_INVALID_EXTERNAL_VARIABLE_TYPE    48
#define ERROR_REGULAR_EXPRESSION_TOO_COMPLEX    49
#define ERROR_INVALID_MODULE_NAME               50


#define FAIL_ON_ERROR(x) { \
  int result = (x); \
  if (result != ERROR_SUCCESS) \
    return result; \
}

#define FAIL_ON_ERROR_WITH_CLEANUP(x, cleanup) { \
  int result = (x); \
  if (result != ERROR_SUCCESS) { \
    cleanup; \
    return result; \
  } \
}

#define FAIL_ON_COMPILER_ERROR(x) { \
  compiler->last_result = (x); \
  if (compiler->last_result != ERROR_SUCCESS) \
    return compiler->last_result; \
}


#ifdef NDEBUG
#define assertf(expr, msg, ...)  ((void)0)
#else
#define assertf(expr, msg, ...) \
    if(!(expr)) { \
      fprintf(stderr, "%s:%d: " msg "\n", __FILE__, __LINE__, ##__VA_ARGS__); \
      abort(); \
    }
#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/exec.h`:

```h
/*
Copyright (c) 2013-2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_EXEC_H
#define YR_EXEC_H

#include "hash.h"
#include "scan.h"
#include "types.h"
#include "rules.h"


#define UNDEFINED           0xFFFABADAFABADAFFLL
#define IS_UNDEFINED(x)     ((size_t)(x) == (size_t) UNDEFINED)

#define OP_ERROR          0
#define OP_HALT           255
#define OP_NOP            254

#define OP_AND            1
#define OP_OR             2
#define OP_NOT            3
#define OP_BITWISE_NOT    4
#define OP_BITWISE_AND    5
#define OP_BITWISE_OR     6
#define OP_BITWISE_XOR    7
#define OP_SHL            8
#define OP_SHR            9
#define OP_MOD            10
#define OP_INT_TO_DBL     11
#define OP_STR_TO_BOOL    12
#define OP_PUSH           13
#define OP_POP            14
#define OP_CALL           15
#define OP_OBJ_LOAD       16
#define OP_OBJ_VALUE      17
#define OP_OBJ_FIELD      18
#define OP_INDEX_ARRAY    19
#define OP_COUNT          20
#define OP_LENGTH         21
#define OP_FOUND          22
#define OP_FOUND_AT       23
#define OP_FOUND_IN       24
#define OP_OFFSET         25
#define OP_OF             26
#define OP_PUSH_RULE      27
#define OP_INIT_RULE      28
#define OP_MATCH_RULE     29
#define OP_INCR_M         30
#define OP_CLEAR_M        31
#define OP_ADD_M          32
#define OP_POP_M          33
#define OP_PUSH_M         34
#define OP_SWAPUNDEF      35
#define OP_JNUNDEF        36
#define OP_JLE            37
#define OP_FILESIZE       38
#define OP_ENTRYPOINT     39
#define OP_CONTAINS       40
#define OP_MATCHES        41
#define OP_IMPORT         42
#define OP_LOOKUP_DICT    43
#define OP_JFALSE         44
#define OP_JTRUE          45


#define _OP_EQ            0
#define _OP_NEQ           1
#define _OP_LT            2
#define _OP_GT            3
#define _OP_LE            4
#define _OP_GE            5
#define _OP_ADD           6
#define _OP_SUB           7
#define _OP_MUL           8
#define _OP_DIV           9
#define _OP_MINUS         10


#define OP_INT_BEGIN      100
#define OP_INT_EQ         (OP_INT_BEGIN + _OP_EQ)
#define OP_INT_NEQ        (OP_INT_BEGIN + _OP_NEQ)
#define OP_INT_LT         (OP_INT_BEGIN + _OP_LT)
#define OP_INT_GT         (OP_INT_BEGIN + _OP_GT)
#define OP_INT_LE         (OP_INT_BEGIN + _OP_LE)
#define OP_INT_GE         (OP_INT_BEGIN + _OP_GE)
#define OP_INT_ADD        (OP_INT_BEGIN + _OP_ADD)
#define OP_INT_SUB        (OP_INT_BEGIN + _OP_SUB)
#define OP_INT_MUL        (OP_INT_BEGIN + _OP_MUL)
#define OP_INT_DIV        (OP_INT_BEGIN + _OP_DIV)
#define OP_INT_MINUS      (OP_INT_BEGIN + _OP_MINUS)
#define OP_INT_END        OP_INT_MINUS

#define OP_DBL_BEGIN      120
#define OP_DBL_EQ         (OP_DBL_BEGIN + _OP_EQ)
#define OP_DBL_NEQ        (OP_DBL_BEGIN + _OP_NEQ)
#define OP_DBL_LT         (OP_DBL_BEGIN + _OP_LT)
#define OP_DBL_GT         (OP_DBL_BEGIN + _OP_GT)
#define OP_DBL_LE         (OP_DBL_BEGIN + _OP_LE)
#define OP_DBL_GE         (OP_DBL_BEGIN + _OP_GE)
#define OP_DBL_ADD        (OP_DBL_BEGIN + _OP_ADD)
#define OP_DBL_SUB        (OP_DBL_BEGIN + _OP_SUB)
#define OP_DBL_MUL        (OP_DBL_BEGIN + _OP_MUL)
#define OP_DBL_DIV        (OP_DBL_BEGIN + _OP_DIV)
#define OP_DBL_MINUS      (OP_DBL_BEGIN + _OP_MINUS)
#define OP_DBL_END        OP_DBL_MINUS

#define OP_STR_BEGIN      140
#define OP_STR_EQ         (OP_STR_BEGIN + _OP_EQ)
#define OP_STR_NEQ        (OP_STR_BEGIN + _OP_NEQ)
#define OP_STR_LT         (OP_STR_BEGIN + _OP_LT)
#define OP_STR_GT         (OP_STR_BEGIN + _OP_GT)
#define OP_STR_LE         (OP_STR_BEGIN + _OP_LE)
#define OP_STR_GE         (OP_STR_BEGIN + _OP_GE)
#define OP_STR_END        OP_STR_GE

#define IS_INT_OP(x)      ((x) >= OP_INT_BEGIN && (x) <= OP_INT_END)
#define IS_DBL_OP(x)      ((x) >= OP_DBL_BEGIN && (x) <= OP_DBL_END)
#define IS_STR_OP(x)      ((x) >= OP_STR_BEGIN && (x) <= OP_STR_END)

#define OP_READ_INT       240
#define OP_INT8           (OP_READ_INT + 0)
#define OP_INT16          (OP_READ_INT + 1)
#define OP_INT32          (OP_READ_INT + 2)
#define OP_UINT8          (OP_READ_INT + 3)
#define OP_UINT16         (OP_READ_INT + 4)
#define OP_UINT32         (OP_READ_INT + 5)
#define OP_INT8BE         (OP_READ_INT + 6)
#define OP_INT16BE        (OP_READ_INT + 7)
#define OP_INT32BE        (OP_READ_INT + 8)
#define OP_UINT8BE        (OP_READ_INT + 9)
#define OP_UINT16BE       (OP_READ_INT + 10)
#define OP_UINT32BE       (OP_READ_INT + 11)


#define OPERATION(operator, op1, op2) \
    (IS_UNDEFINED(op1) || IS_UNDEFINED(op2)) ? (UNDEFINED) : (op1 operator op2)


#define COMPARISON(operator, op1, op2) \
    (IS_UNDEFINED(op1) || IS_UNDEFINED(op2)) ? (0) : (op1 operator op2)


int yr_execute_code(
    YR_RULES* rules,
    YR_SCAN_CONTEXT* context,
    int timeout,
    time_t start_time);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/exefiles.h`:

```h
/*
Copyright (c) 2007. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_EXEFILES_H
#define YR_EXEFILES_H

uint64_t yr_get_entry_point_offset(
    uint8_t* buffer,
    size_t buffer_length);


uint64_t yr_get_entry_point_address(
    uint8_t* buffer,
    size_t buffer_length,
    size_t base_address);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/filemap.h`:

```h
/*
Copyright (c) 2007-2015. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_FILEMAP_H
#define YR_FILEMAP_H

#ifdef _MSC_VER
#define off_t              int64_t
#else
#include <sys/types.h>
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#define YR_FILE_DESCRIPTOR    HANDLE
#else
#define YR_FILE_DESCRIPTOR    int
#endif

#include <stdlib.h>

#include "integers.h"
#include "utils.h"


typedef struct _YR_MAPPED_FILE
{
    YR_FILE_DESCRIPTOR  file;
    size_t              size;
    uint8_t*            data;
#if defined(_WIN32) || defined(__CYGWIN__)
    HANDLE              mapping;
#endif

} YR_MAPPED_FILE;


YR_API int yr_filemap_map(
    const char* file_path,
    YR_MAPPED_FILE* pmapped_file);


YR_API int yr_filemap_map_fd(
    YR_FILE_DESCRIPTOR file,
    off_t offset,
    size_t size,
    YR_MAPPED_FILE* pmapped_file);


YR_API int yr_filemap_map_ex(
    const char* file_path,
    off_t offset,
    size_t size,
    YR_MAPPED_FILE* pmapped_file);


YR_API void yr_filemap_unmap(
    YR_MAPPED_FILE* pmapped_file);


YR_API void yr_filemap_unmap_fd(
    YR_MAPPED_FILE* pmapped_file);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/globals.h`:

```h
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_GLOBALS_H
#define YR_GLOBALS_H

#include "threading.h"

extern char yr_lowercase[256];
extern char yr_altercase[256];

extern YR_THREAD_STORAGE_KEY yr_tidx_key;
extern YR_THREAD_STORAGE_KEY yr_recovery_state_key;

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/hash.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_HASH_H
#define YR_HASH_H

#include <stddef.h>

#include "utils.h"

typedef struct _YR_HASH_TABLE_ENTRY
{
    void* key;
    size_t key_length;
    char* ns;
    void* value;

    struct _YR_HASH_TABLE_ENTRY* next;

} YR_HASH_TABLE_ENTRY;


typedef struct _YR_HASH_TABLE
{
    int size;

    YR_HASH_TABLE_ENTRY* buckets[1];

} YR_HASH_TABLE;


typedef int (*YR_HASH_TABLE_FREE_VALUE_FUNC)(void* value);


YR_API int yr_hash_table_create(
    int size,
    YR_HASH_TABLE** table);


YR_API void yr_hash_table_clean(
    YR_HASH_TABLE* table,
    YR_HASH_TABLE_FREE_VALUE_FUNC free_value);


YR_API void yr_hash_table_destroy(
    YR_HASH_TABLE* table,
    YR_HASH_TABLE_FREE_VALUE_FUNC free_value);


YR_API void* yr_hash_table_lookup(
    YR_HASH_TABLE* table,
    const char* key,
    const char* ns);


YR_API int yr_hash_table_add(
    YR_HASH_TABLE* table,
    const char* key,
    const char* ns,
    void* value);


YR_API void* yr_hash_table_lookup_raw_key(
    YR_HASH_TABLE* table,
    const void* key,
    size_t key_length,
    const char* ns);


YR_API int yr_hash_table_add_raw_key(
    YR_HASH_TABLE* table,
    const void* key,
    size_t key_length,
    const char* ns,
    void* value);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/hex_lexer.h`:

```h
/*
Copyright (c) 2007. Victor M. Alvarez [plusvic@gmail.com].

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "re.h"

#undef yyparse
#undef yylex
#undef yyerror
#undef yyfatal
#undef yychar
#undef yydebug
#undef yynerrs
#undef yyget_extra
#undef yyget_lineno

#undef YY_FATAL_ERROR
#undef YY_DECL
#undef LEX_ENV

#define yyparse         hex_yyparse
#define yylex           hex_yylex
#define yyerror         hex_yyerror
#define yyfatal         hex_yyfatal
#define yychar          hex_yychar
#define yydebug         hex_yydebug
#define yynerrs         hex_yynerrs
#define yyget_extra     hex_yyget_extra
#define yyget_lineno    hex_yyget_lineno


#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#define YY_EXTRA_TYPE RE_AST*
#define YY_USE_CONST


typedef struct _HEX_LEX_ENVIRONMENT
{
    int token_count;
    int inside_or;
    int last_error_code;
    char last_error_message[256];

} HEX_LEX_ENVIRONMENT;


#define YY_FATAL_ERROR(msg) hex_yyfatal(yyscanner, msg)

#define LEX_ENV  ((HEX_LEX_ENVIRONMENT*) lex_env)

#include <hex_grammar.h>

#define YY_DECL int hex_yylex \
    (YYSTYPE * yylval_param , yyscan_t yyscanner, HEX_LEX_ENVIRONMENT* lex_env)


YY_EXTRA_TYPE yyget_extra(
    yyscan_t yyscanner);

int yylex(
    YYSTYPE* yylval_param,
    yyscan_t yyscanner,
    HEX_LEX_ENVIRONMENT* lex_env);

int yyparse(
    void* yyscanner,
    HEX_LEX_ENVIRONMENT* lex_env);

void yyerror(
    yyscan_t yyscanner,
    HEX_LEX_ENVIRONMENT* lex_env,
    const char* error_message);

void yyfatal(
    yyscan_t yyscanner,
    const char* error_message);

int yr_parse_hex_string(
    const char* hex_string,
    RE_AST** re_ast,
    RE_ERROR* error);

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/integers.h`:

```h
/*
Copyright (c) 2007-2015. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_INTEGERS_H
#define YR_INTEGERS_H

/* Integer type definitions
 */
#if ( defined( _MSC_VER ) && ( _MSC_VER < 1600 ) ) || ( defined( __BORLANDC__ ) && ( __BORLANDC__ <= 0x0560 ) )

#ifdef __cplusplus
extern "C" {
#endif

/* Microsoft Visual Studio C++ before Visual Studio 2010 or earlier versions of the Borland C++ Builder
 * do not support the (u)int#_t type definitions but have __int# definitions instead
 */
typedef __int8 int8_t;
typedef unsigned __int8 uint8_t;
typedef __int16 int16_t;
typedef unsigned __int16 uint16_t;
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;

#ifdef __cplusplus
}
#endif

#else

/* Other "compilers" and later versions of Microsoft Visual Studio C++ and
 * Borland C/C++ define the types in <stdint.h>
 */
#include <stdint.h>

#endif

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/lexer.h`:

```h
/*
Copyright (c) 2007. Victor M. Alvarez [plusvic@gmail.com].

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "compiler.h"


#undef yyparse
#undef yylex
#undef yyerror
#undef yyfatal
#undef yychar
#undef yydebug
#undef yynerrs
#undef yyget_extra
#undef yyget_lineno

#undef YY_DECL
#undef YY_FATAL_ERROR
#undef YY_EXTRA_TYPE

#define yyparse       yara_yyparse
#define yylex         yara_yylex
#define yyerror       yara_yyerror
#define yyfatal       yara_yyfatal
#define yywarning     yara_yywarning
#define yychar        yara_yychar
#define yydebug       yara_yydebug
#define yynerrs       yara_yynerrs
#define yyget_extra   yara_yyget_extra
#define yyget_lineno  yara_yyget_lineno


#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#ifndef YY_TYPEDEF_EXPRESSION_T
#define YY_TYPEDEF_EXPRESSION_T


// Expression type constants are powers of two because they are used as flags.
// For example:
//   CHECK_TYPE(whatever, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT)
// The expression above is used to ensure that the type of "whatever" is either
// integer or float.

#define EXPRESSION_TYPE_BOOLEAN   1
#define EXPRESSION_TYPE_INTEGER   2
#define EXPRESSION_TYPE_STRING    4
#define EXPRESSION_TYPE_REGEXP    8
#define EXPRESSION_TYPE_OBJECT    16
#define EXPRESSION_TYPE_FLOAT     32

typedef struct _EXPRESSION
{
    int type;

    union
    {
        int64_t integer;
        YR_OBJECT* object;
        SIZED_STRING* sized_string;
    } value;

    const char* identifier;

} EXPRESSION;

union YYSTYPE;

#endif


#define YY_DECL int yylex( \
    union YYSTYPE* yylval_param, yyscan_t yyscanner, YR_COMPILER* compiler)


#define YY_FATAL_ERROR(msg) yara_yyfatal(yyscanner, msg)


#define YY_EXTRA_TYPE YR_COMPILER*
#define YY_USE_CONST


int yyget_lineno(yyscan_t yyscanner);

int yylex(
    union YYSTYPE* yylval_param,
    yyscan_t yyscanner,
    YR_COMPILER* compiler);

int yyparse(
    void* yyscanner,
    YR_COMPILER* compiler);

void yyerror(
    yyscan_t yyscanner,
    YR_COMPILER* compiler,
    const char* error_message);

void yywarning(
    yyscan_t yyscanner,
    const char* message_fmt,
    ...);

void yyfatal(
    yyscan_t yyscanner,
    const char* error_message);

YY_EXTRA_TYPE yyget_extra(
    yyscan_t yyscanner);

int yr_lex_parse_rules_string(
    const char* rules_string,
    YR_COMPILER* compiler);

int yr_lex_parse_rules_file(
    FILE* rules_file,
    YR_COMPILER* compiler);

int yr_lex_parse_rules_fd(
    YR_FILE_DESCRIPTOR rules_fd,
    YR_COMPILER* compiler);

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/libyara.h`:

```h
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_LIBYARA_H
#define YR_LIBYARA_H

#include "utils.h"

#define YR_MAJOR_VERSION   3
#define YR_MINOR_VERSION   6
#define YR_MICRO_VERSION   0

#define version_str(s) _version_str(s)
#define _version_str(s) #s

// Version as a string
#define YR_VERSION version_str(YR_MAJOR_VERSION) \
    "." version_str(YR_MINOR_VERSION) \
    "." version_str(YR_MICRO_VERSION)

// Version as a single 4-byte hex number, e.g. 0x030401 == 3.4.1.
#define YR_VERSION_HEX ((YR_MAJOR_VERSION << 16) | \
    (YR_MINOR_VERSION << 8) | \
    (YR_MICRO_VERSION << 0))


// Enumerated type listing configuration options
typedef enum _YR_CONFIG_NAME
{
    YR_CONFIG_STACK_SIZE,
    YR_CONFIG_MAX

} YR_CONFIG_NAME;


#define DEFAULT_STACK_SIZE 16384


YR_API int yr_initialize(void);


YR_API int yr_finalize(void);


YR_API void yr_finalize_thread(void);


YR_API int yr_get_tidx(void);


YR_API void yr_set_tidx(int);


YR_API int yr_set_configuration(YR_CONFIG_NAME, void*);


YR_API int yr_get_configuration(YR_CONFIG_NAME, void*);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/limits.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_LIMITS_H
#define YR_LIMITS_H

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#endif

#include "utils.h"

// MAX_THREADS is the number of threads that can use a YR_RULES
// object simultaneously.

#ifndef MAX_THREADS
#define MAX_THREADS 32
#endif


#ifndef MAX_PATH
#define MAX_PATH 1024
#endif

#define MAX_COMPILER_ERROR_EXTRA_INFO   256
#define MAX_ATOM_LENGTH                 4
#define MAX_LOOP_NESTING                4
#define MAX_ARENA_PAGES                 32
#define MAX_INCLUDE_DEPTH               16
#define MAX_STRING_MATCHES              1000000
#define MAX_FUNCTION_ARGS               128
#define MAX_FAST_RE_STACK               300
#define MAX_OVERLOADED_FUNCTIONS        10
#define MAX_HEX_STRING_TOKENS           10000
#define MAX_MATCH_DATA                  4096

#define LOOP_LOCAL_VARS                 4
#define STRING_CHAINING_THRESHOLD       200
#define LEX_BUF_SIZE                    8192


#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/mem.h`:

```h
/*
Copyright (c) 2007. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_MEM_H
#define YR_MEM_H

#include <stdio.h>

#ifdef DMALLOC

#define yr_malloc malloc
#define yr_calloc calloc
#define yr_realloc realloc
#define yr_free free
#define yr_strdup strdup
#define yr_strndup strndup

#include <dmalloc.h>

#else

void* yr_calloc(
    size_t count,
    size_t size);

void* yr_malloc(
    size_t size);

void* yr_realloc(
    void* ptr,
    size_t size);

void yr_free(
    void* ptr);

char* yr_strdup(
    const char* str);

char* yr_strndup(
    const char* str, size_t n);

#endif

int yr_heap_alloc(void);

int yr_heap_free(void);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/modules.h`:

```h
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_MODULES_H
#define YR_MODULES_H

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "utils.h"
#include "limits.h"
#include "error.h"
#include "exec.h"
#include "types.h"
#include "object.h"
#include "libyara.h"

// Concatenation that macro-expands its arguments.

#define YR_CONCAT(arg1, arg2) _YR_CONCAT(arg1, arg2) // expands the arguments.
#define _YR_CONCAT(arg1, arg2) arg1 ## arg2  // do the actual concatenation.


#define module_declarations YR_CONCAT(MODULE_NAME, __declarations)
#define module_load YR_CONCAT(MODULE_NAME, __load)
#define module_unload YR_CONCAT(MODULE_NAME, __unload)
#define module_initialize YR_CONCAT(MODULE_NAME, __initialize)
#define module_finalize YR_CONCAT(MODULE_NAME, __finalize)

#define begin_declarations \
    int module_declarations(YR_OBJECT* module) { \
      YR_OBJECT* stack[64]; \
      int stack_top = 0; \
      stack[stack_top] = module;


#define end_declarations \
    return ERROR_SUCCESS; }


#define begin_struct(name) { \
    YR_OBJECT* structure; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRUCTURE, \
        name, \
        stack[stack_top], \
        &structure)); \
    assertf( \
        stack_top < sizeof(stack)/sizeof(stack[0]) - 1, \
        "too many nested structures"); \
    stack[++stack_top] = structure; \
  }


#define begin_struct_array(name) { \
    YR_OBJECT* structure; \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRUCTURE, \
        name, \
        array, \
        &structure)); \
    assertf( \
        stack_top < sizeof(stack)/sizeof(stack[0]) - 1, \
        "too many nested structures"); \
    stack[++stack_top] = structure; \
  }


#define begin_struct_dictionary(name) { \
    YR_OBJECT* structure; \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRUCTURE, \
        name, \
        array, \
        &structure)); \
    assertf( \
        stack_top < sizeof(stack)/sizeof(stack[0]) - 1, \
        "too many nested structures"); \
    stack[++stack_top] = structure; \
  }


#define end_struct(name) { \
    assert(stack[stack_top]->type == OBJECT_TYPE_STRUCTURE); \
    assertf( \
        strcmp(stack[stack_top]->identifier, name) == 0, \
        "unbalanced begin_struct/end_struct"); \
    stack_top--; \
  }


#define end_struct_array(name) end_struct(name)


#define end_struct_dictionary(name) end_struct(name)


#define declare_integer(name) { \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_INTEGER, \
        name, \
        stack[stack_top], \
        NULL)); \
  }


#define declare_integer_array(name) { \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_INTEGER, \
        name, \
        array, \
        NULL)); \
  }


#define declare_integer_dictionary(name) { \
    YR_OBJECT* dict; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &dict)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_INTEGER, \
        name, \
        dict, \
        NULL)); \
  }


#define declare_float(name) { \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_FLOAT, \
        name, \
        stack[stack_top], \
        NULL)); \
  }


#define declare_float_array(name) { \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_FLOAT, \
        name, \
        array, \
        NULL)); \
  }


#define declare_float_dictionary(name) { \
    YR_OBJECT* dict; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &dict)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_FLOAT, \
        name, \
        dict, \
        NULL)); \
  }


#define declare_string(name) { \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRING, \
        name, \
        stack[stack_top], \
        NULL)); \
  }


#define declare_string_array(name) { \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRING, \
        name, \
        array, \
        NULL)); \
  }


#define declare_string_dictionary(name) { \
    YR_OBJECT* dict; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &dict)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRING, \
        name, \
        dict, \
        NULL)); \
  }


#define declare_function(name, args_fmt, ret_fmt, func) { \
    YR_OBJECT* function; \
    FAIL_ON_ERROR(yr_object_function_create( \
        name, \
        args_fmt, \
        ret_fmt, \
        func, \
        stack[stack_top], \
        &function)); \
    }


#define define_function(func) \
    int func ( \
        YR_VALUE* __args, \
        YR_SCAN_CONTEXT* __context, \
        YR_OBJECT_FUNCTION* __function_obj)


#define sized_string_argument(n) \
    (__args[n-1].ss)

#define string_argument(n) \
    (sized_string_argument(n)->c_string)

#define integer_argument(n) \
    (__args[n-1].i)

#define float_argument(n) \
    (__args[n-1].d)

#define regexp_argument(n) \
    ((RE*)(__args[n-1].re))


#define module()        yr_object_get_root((YR_OBJECT*) __function_obj)
#define parent()        (__function_obj->parent)
#define scan_context()  (__context)


#define foreach_memory_block(iterator, block) \
  for (block = iterator->first(iterator); \
       block != NULL; \
       block = iterator->next(iterator)) \


#define first_memory_block(context) \
      (context)->iterator->first((context)->iterator)


#define is_undefined(object, ...) \
    yr_object_has_undefined_value(object, __VA_ARGS__)


#define get_object(object, ...) \
    yr_object_lookup(object, 0, __VA_ARGS__)


#define get_integer(object, ...) \
    yr_object_get_integer(object, __VA_ARGS__)


#define get_float(object, ...) \
    yr_object_get_float(object, __VA_ARGS__)


#define get_string(object, ...) \
    yr_object_get_string(object, __VA_ARGS__)


#define set_integer(value, object, ...) \
    yr_object_set_integer(value, object, __VA_ARGS__)


#define set_float(value, object, ...) \
    yr_object_set_float(value, object, __VA_ARGS__)


#define set_sized_string(value, len, object, ...) \
    yr_object_set_string(value, len, object, __VA_ARGS__)


#define set_string(value, object, ...) \
    set_sized_string(value, strlen(value), object, __VA_ARGS__)


#define return_integer(integer) { \
      assertf( \
          __function_obj->return_obj->type == OBJECT_TYPE_INTEGER, \
          "return type differs from function declaration"); \
      yr_object_set_integer( \
          (integer), \
          __function_obj->return_obj, \
          NULL); \
      return ERROR_SUCCESS; \
    }


#define return_float(double_) { \
      double d = (double) (double_); \
      assertf( \
          __function_obj->return_obj->type == OBJECT_TYPE_FLOAT, \
          "return type differs from function declaration"); \
      yr_object_set_float( \
          (d != (double) UNDEFINED) ? d : NAN, \
          __function_obj->return_obj, \
          NULL); \
      return ERROR_SUCCESS; \
    }


#define return_string(string) { \
      char* s = (char*) (string); \
      assertf( \
          __function_obj->return_obj->type == OBJECT_TYPE_STRING, \
          "return type differs from function declaration"); \
      yr_object_set_string( \
          (s != (char*) UNDEFINED) ? s : NULL, \
          (s != (char*) UNDEFINED) ? strlen(s) : 0, \
          __function_obj->return_obj, \
          NULL); \
      return ERROR_SUCCESS; \
    }


struct _YR_MODULE;


typedef int (*YR_EXT_INITIALIZE_FUNC)(
    struct _YR_MODULE* module);


typedef int (*YR_EXT_FINALIZE_FUNC)(
    struct _YR_MODULE* module);


typedef int (*YR_EXT_DECLARATIONS_FUNC)(
    YR_OBJECT* module_object);


typedef int (*YR_EXT_LOAD_FUNC)(
    YR_SCAN_CONTEXT* context,
    YR_OBJECT* module_object,
    void* module_data,
    size_t module_data_size);


typedef int (*YR_EXT_UNLOAD_FUNC)(
    YR_OBJECT* module_object);


typedef struct _YR_MODULE
{
    char* name;

    YR_EXT_DECLARATIONS_FUNC declarations;
    YR_EXT_LOAD_FUNC load;
    YR_EXT_UNLOAD_FUNC unload;
    YR_EXT_INITIALIZE_FUNC initialize;
    YR_EXT_FINALIZE_FUNC finalize;

} YR_MODULE;


typedef struct _YR_MODULE_IMPORT
{
    const char* module_name;
    void* module_data;
    size_t module_data_size;

} YR_MODULE_IMPORT;


int yr_modules_initialize(void);


int yr_modules_finalize(void);


int yr_modules_do_declarations(
    const char* module_name,
    YR_OBJECT* main_structure);


int yr_modules_load(
    const char* module_name,
    YR_SCAN_CONTEXT* context);


int yr_modules_unload_all(
    YR_SCAN_CONTEXT* context);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/object.h`:

```h
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_OBJECT_H
#define YR_OBJECT_H

#ifdef _MSC_VER

#include <float.h>
#ifndef isnan
#define isnan _isnan
#endif

#ifndef INFINITY
#define INFINITY (DBL_MAX + DBL_MAX)
#endif

#ifndef NAN
#define NAN (INFINITY-INFINITY)
#endif

#endif

#include "types.h"


#define OBJECT_CREATE           1

#define OBJECT_TYPE_INTEGER     1
#define OBJECT_TYPE_STRING      2
#define OBJECT_TYPE_STRUCTURE   3
#define OBJECT_TYPE_ARRAY       4
#define OBJECT_TYPE_FUNCTION    5
#define OBJECT_TYPE_DICTIONARY  6
#define OBJECT_TYPE_FLOAT       7


int yr_object_create(
    int8_t type,
    const char* identifier,
    YR_OBJECT* parent,
    YR_OBJECT** object);


int yr_object_function_create(
    const char* identifier,
    const char* arguments_fmt,
    const char* return_fmt,
    YR_MODULE_FUNC func,
    YR_OBJECT* parent,
    YR_OBJECT** function);


int yr_object_from_external_variable(
    YR_EXTERNAL_VARIABLE* external,
    YR_OBJECT** object);


void yr_object_destroy(
    YR_OBJECT* object);


int yr_object_copy(
    YR_OBJECT* object,
    YR_OBJECT** object_copy);


YR_OBJECT* yr_object_lookup_field(
    YR_OBJECT* object,
    const char* field_name);


YR_OBJECT* yr_object_lookup(
    YR_OBJECT* root,
    int flags,
    const char* pattern,
    ...);


int yr_object_has_undefined_value(
    YR_OBJECT* object,
    const char* field,
    ...);

int64_t yr_object_get_integer(
    YR_OBJECT* object,
    const char* field,
    ...);


SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...);


int yr_object_set_integer(
    int64_t value,
    YR_OBJECT* object,
    const char* field,
    ...);


int yr_object_set_float(
    double value,
    YR_OBJECT* object,
    const char* field,
    ...);


int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...);


YR_OBJECT* yr_object_array_get_item(
    YR_OBJECT* object,
    int flags,
    int index);


int yr_object_array_set_item(
    YR_OBJECT* object,
    YR_OBJECT* item,
    int index);


YR_OBJECT* yr_object_dict_get_item(
    YR_OBJECT* object,
    int flags,
    const char* key);


int yr_object_dict_set_item(
    YR_OBJECT* object,
    YR_OBJECT* item,
    const char* key);


int yr_object_structure_set_member(
    YR_OBJECT* object,
    YR_OBJECT* member);


YR_OBJECT* yr_object_get_root(
    YR_OBJECT* object);


YR_API void yr_object_print_data(
    YR_OBJECT* object,
    int indent,
    int print_identifier);


#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/parser.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_PARSER_H
#define YR_PARSER_H


#include "lexer.h"


int yr_parser_emit(
    yyscan_t yyscanner,
    uint8_t instruction,
    uint8_t** instruction_address);


int yr_parser_emit_with_arg(
    yyscan_t yyscanner,
    uint8_t instruction,
    int64_t argument,
    uint8_t** instruction_address,
    int64_t** argument_address);


int yr_parser_emit_with_arg_double(
    yyscan_t yyscanner,
    uint8_t instruction,
    double argument,
    uint8_t** instruction_address,
    double** argument_address);


int yr_parser_emit_with_arg_reloc(
    yyscan_t yyscanner,
    uint8_t instruction,
    void* argument,
    uint8_t** instruction_address,
    void** argument_address);


int yr_parser_check_types(
    YR_COMPILER* compiler,
    YR_OBJECT_FUNCTION* function,
    const char* actual_args_fmt);


YR_STRING* yr_parser_lookup_string(
    yyscan_t yyscanner,
    const char* identifier);


int yr_parser_lookup_loop_variable(
    yyscan_t yyscanner,
    const char* identifier);


YR_RULE* yr_parser_reduce_rule_declaration_phase_1(
    yyscan_t yyscanner,
    int32_t flags,
    const char* identifier);


int yr_parser_reduce_rule_declaration_phase_2(
    yyscan_t yyscanner,
    YR_RULE* rule);


YR_STRING* yr_parser_reduce_string_declaration(
    yyscan_t yyscanner,
    int32_t flags,
    const char* identifier,
    SIZED_STRING* str);


YR_META* yr_parser_reduce_meta_declaration(
    yyscan_t yyscanner,
    int32_t type,
    const char* identifier,
    const char* string,
    int64_t integer);


int yr_parser_reduce_string_identifier(
    yyscan_t yyscanner,
    const char* identifier,
    uint8_t instruction,
    uint64_t at_offset);


int yr_parser_emit_pushes_for_strings(
    yyscan_t yyscanner,
    const char* identifier);


int yr_parser_reduce_external(
    yyscan_t yyscanner,
    const char* identifier,
    uint8_t instruction);


int yr_parser_reduce_import(
    yyscan_t yyscanner,
    SIZED_STRING* module_name);


int yr_parser_reduce_operation(
    yyscan_t yyscanner,
    const char* operation,
    EXPRESSION left_operand,
    EXPRESSION right_operand);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/pe.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_PE_H
#define YR_PE_H

#include "endian.h"
#include "types.h"

#pragma pack(push, 1)

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>

// These definitions are not present in older Windows headers.

#ifndef IMAGE_FILE_MACHINE_ARMNT
#define IMAGE_FILE_MACHINE_ARMNT             0x01c4
#endif

#ifndef IMAGE_FILE_MACHINE_ARM64
#define IMAGE_FILE_MACHINE_ARM64             0xaa64
#endif

#else

#include <stdlib.h>

#include "integers.h"

typedef uint8_t   BYTE;
typedef uint16_t  WORD;
typedef uint32_t  DWORD;
typedef int32_t   LONG;
typedef uint32_t  ULONG;
typedef uint64_t  ULONGLONG;


#define FIELD_OFFSET(type, field)    ((size_t)&(((type *)0)->field))

#ifndef _MAC

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_VXD_SIGNATURE                 0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00

#else

#define IMAGE_DOS_SIGNATURE                 0x4D5A      // MZ
#define IMAGE_OS2_SIGNATURE                 0x4E45      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x4C45      // LE
#define IMAGE_NT_SIGNATURE                  0x50450000  // PE00

#endif

#pragma pack(push, 2)

typedef struct _IMAGE_DOS_HEADER        // DOS .EXE header
{
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

#pragma pack(pop)

//
// File header format.
//

#pragma pack(push,4)

typedef struct _IMAGE_FILE_HEADER
{
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;



#define IMAGE_SIZEOF_FILE_HEADER             20


#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved external references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line numbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Aggressively trim working set
#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle >2gb addresses
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.
#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.


#define IMAGE_FILE_MACHINE_UNKNOWN           0x0000
#define IMAGE_FILE_MACHINE_AM33              0x01d3
#define IMAGE_FILE_MACHINE_AMD64             0x8664
#define IMAGE_FILE_MACHINE_ARM               0x01c0
#define IMAGE_FILE_MACHINE_ARMNT             0x01c4
#define IMAGE_FILE_MACHINE_ARM64             0xaa64
#define IMAGE_FILE_MACHINE_EBC               0x0ebc
#define IMAGE_FILE_MACHINE_I386              0x014c
#define IMAGE_FILE_MACHINE_IA64              0x0200
#define IMAGE_FILE_MACHINE_M32R              0x9041
#define IMAGE_FILE_MACHINE_MIPS16            0x0266
#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366
#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466
#define IMAGE_FILE_MACHINE_POWERPC           0x01f0
#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1
#define IMAGE_FILE_MACHINE_R4000             0x0166
#define IMAGE_FILE_MACHINE_SH3               0x01a2
#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3
#define IMAGE_FILE_MACHINE_SH4               0x01a6
#define IMAGE_FILE_MACHINE_SH5               0x01a8
#define IMAGE_FILE_MACHINE_THUMB             0x01c2
#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169

// Section characteristics
#define IMAGE_SCN_CNT_CODE                   0x00000020
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080
#define IMAGE_SCN_GPREL                      0x00008000
#define IMAGE_SCN_MEM_16BIT                  0x00020000
#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000
#define IMAGE_SCN_MEM_SHARED                 0x10000000
#define IMAGE_SCN_MEM_EXECUTE                0x20000000
#define IMAGE_SCN_MEM_READ                   0x40000000
#define IMAGE_SCN_MEM_WRITE                  0x80000000

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY
{
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16


#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER32
{
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;


typedef struct _IMAGE_OPTIONAL_HEADER64
{
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    ULONGLONG ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;


#define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b


typedef struct _IMAGE_NT_HEADERS32
{
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;

} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;


typedef struct _IMAGE_NT_HEADERS64
{
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;

} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

// IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file header is
// the same either way.

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER) \
    ((BYTE*)ntheader + \
     FIELD_OFFSET( IMAGE_NT_HEADERS32, OptionalHeader ) + \
     yr_le16toh(((PIMAGE_NT_HEADERS32)(ntheader))->FileHeader.SizeOfOptionalHeader) \
    ))

// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN                          0
#define IMAGE_SUBSYSTEM_NATIVE                           1
#define IMAGE_SUBSYSTEM_WINDOWS_GUI                      2
#define IMAGE_SUBSYSTEM_WINDOWS_CUI                      3
#define IMAGE_SUBSYSTEM_OS2_CUI                          5
#define IMAGE_SUBSYSTEM_POSIX_CUI                        7
#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS                   8
#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI                   9
#define IMAGE_SUBSYSTEM_EFI_APPLICATION                 10
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER         11
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER              12
#define IMAGE_SUBSYSTEM_EFI_ROM_IMAGE                   13
#define IMAGE_SUBSYSTEM_XBOX                            14
#define IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION        16

// DllCharacteristics values

#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE           0x0040
#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY        0x0080
#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT              0x0100
#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION           0x0200
#define IMAGE_DLLCHARACTERISTICS_NO_SEH                 0x0400
#define IMAGE_DLLCHARACTERISTICS_NO_BIND                0x0800
#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER             0x2000
#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE  0x8000

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER
{
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union
    {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;

} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40


typedef struct _IMAGE_EXPORT_DIRECTORY
{
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;


typedef struct _IMAGE_IMPORT_DESCRIPTOR
{
    union
    {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;
    } ;
    DWORD TimeDateStamp;
    DWORD ForwarderChain;
    DWORD Name;
    DWORD FirstThunk;

} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;


typedef struct _IMAGE_IMPORT_BY_NAME
{
    WORD Hint;
    BYTE Name[1];

} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA32
{
    union
    {
        DWORD ForwarderString;
        DWORD Function;
        DWORD Ordinal;
        DWORD AddressOfData;
    } u1;

} IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32;


#define IMAGE_ORDINAL_FLAG32  0x80000000
#define IMAGE_ORDINAL_FLAG64  0x8000000000000000L

typedef struct _IMAGE_THUNK_DATA64
{
    union
    {
        ULONGLONG ForwarderString;
        ULONGLONG Function;
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;
    } u1;

} IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64;


typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY
{
    DWORD Name;
    DWORD OffsetToData;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;


typedef struct _IMAGE_RESOURCE_DATA_ENTRY
{
    DWORD OffsetToData;
    DWORD Size;
    DWORD CodePage;
    DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;


typedef struct _IMAGE_RESOURCE_DIRECTORY
{
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    WORD  NumberOfNamedEntries;
    WORD  NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#pragma pack(pop)

#endif  // _WIN32

typedef struct _VERSION_INFO
{
    WORD   Length;
    WORD   ValueLength;
    WORD   Type;
    char   Key[0];
} VERSION_INFO, *PVERSION_INFO;


#define WIN_CERT_REVISION_1_0 0x0100
#define WIN_CERT_REVISION_2_0 0x0200

#define WIN_CERT_TYPE_X509             0x0001
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA 0x0002
#define WIN_CERT_TYPE_RESERVED_1       0x0003
#define WIN_CERT_TYPE_TS_STACK_SIGNED  0x0004

typedef struct _WIN_CERTIFICATE
{
    DWORD Length;
    WORD  Revision;
    WORD  CertificateType;
    BYTE  Certificate[0];
} WIN_CERTIFICATE, *PWIN_CERTIFICATE;


//
// Rich signature.
// http://www.ntcore.com/files/richsign.htm
//

#define RICH_VERSION_ID(id_version) (id_version >> 16)
#define RICH_VERSION_VERSION(id_version) (id_version & 0xFFFF)

typedef struct _RICH_VERSION_INFO
{
    DWORD id_version; //tool id and version (use RICH_VERSION_ID and RICH_VERSION_VERSION macros)
    DWORD times; //number of times this tool was used
} RICH_VERSION_INFO, *PRICH_VERSION_INFO;

typedef struct _RICH_SIGNATURE
{
    DWORD dans;
    DWORD key1;
    DWORD key2;
    DWORD key3;
    RICH_VERSION_INFO versions[0];
} RICH_SIGNATURE, *PRICH_SIGNATURE;

#define RICH_DANS 0x536e6144 // "DanS"
#define RICH_RICH 0x68636952 // "Rich"


#pragma pack(pop)
#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/proc.h`:

```h
/*
Copyright (c) 2007. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_PROC_H
#define YR_PROC_H

#include "types.h"

int yr_process_open_iterator(
    int pid,
    YR_MEMORY_BLOCK_ITERATOR* iterator);

int yr_process_close_iterator(
    YR_MEMORY_BLOCK_ITERATOR* iterator);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/re.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_RE_H
#define YR_RE_H

#include <ctype.h>

#include "arena.h"
#include "sizedstr.h"

#define RE_NODE_LITERAL             1
#define RE_NODE_MASKED_LITERAL      2
#define RE_NODE_ANY                 3
#define RE_NODE_CONCAT              4
#define RE_NODE_ALT                 5
#define RE_NODE_RANGE               6
#define RE_NODE_STAR                7
#define RE_NODE_PLUS                8
#define RE_NODE_CLASS               9
#define RE_NODE_WORD_CHAR           10
#define RE_NODE_NON_WORD_CHAR       11
#define RE_NODE_SPACE               12
#define RE_NODE_NON_SPACE           13
#define RE_NODE_DIGIT               14
#define RE_NODE_NON_DIGIT           15
#define RE_NODE_EMPTY               16
#define RE_NODE_ANCHOR_START        17
#define RE_NODE_ANCHOR_END          18
#define RE_NODE_WORD_BOUNDARY       19
#define RE_NODE_NON_WORD_BOUNDARY   20
#define RE_NODE_RANGE_ANY           21


#define RE_OPCODE_ANY                   0xA0
#define RE_OPCODE_ANY_EXCEPT_NEW_LINE   0xA1
#define RE_OPCODE_LITERAL               0xA2
#define RE_OPCODE_MASKED_LITERAL        0xA4
#define RE_OPCODE_CLASS                 0xA5
#define RE_OPCODE_WORD_CHAR             0xA7
#define RE_OPCODE_NON_WORD_CHAR         0xA8
#define RE_OPCODE_SPACE                 0xA9
#define RE_OPCODE_NON_SPACE             0xAA
#define RE_OPCODE_DIGIT                 0xAB
#define RE_OPCODE_NON_DIGIT             0xAC
#define RE_OPCODE_MATCH                 0xAD

#define RE_OPCODE_MATCH_AT_END          0xB0
#define RE_OPCODE_MATCH_AT_START        0xB1
#define RE_OPCODE_WORD_BOUNDARY         0xB2
#define RE_OPCODE_NON_WORD_BOUNDARY     0xB3
#define RE_OPCODE_REPEAT_ANY_GREEDY     0xB4
#define RE_OPCODE_REPEAT_ANY_UNGREEDY   0xB5

#define RE_OPCODE_SPLIT_A               0xC0
#define RE_OPCODE_SPLIT_B               0xC1
#define RE_OPCODE_JUMP                  0xC2
#define RE_OPCODE_REPEAT_START_GREEDY   0xC3
#define RE_OPCODE_REPEAT_END_GREEDY     0xC4
#define RE_OPCODE_REPEAT_START_UNGREEDY 0xC5
#define RE_OPCODE_REPEAT_END_UNGREEDY   0xC6


#define RE_FLAGS_FAST_REGEXP            0x02
#define RE_FLAGS_BACKWARDS              0x04
#define RE_FLAGS_EXHAUSTIVE             0x08
#define RE_FLAGS_WIDE                   0x10
#define RE_FLAGS_NO_CASE                0x20
#define RE_FLAGS_SCAN                   0x40
#define RE_FLAGS_DOT_ALL                0x80
#define RE_FLAGS_GREEDY                0x400
#define RE_FLAGS_UNGREEDY              0x800


typedef struct RE RE;
typedef struct RE_AST RE_AST;
typedef struct RE_NODE RE_NODE;
typedef struct RE_ERROR RE_ERROR;

typedef uint8_t RE_SPLIT_ID_TYPE;


struct RE_NODE
{
    int type;

    union
    {
        int value;
        int count;
        int start;
    };

    union
    {
        int mask;
        int end;
    };

    int greedy;

    uint8_t* class_vector;

    RE_NODE* left;
    RE_NODE* right;

    uint8_t* forward_code;
    uint8_t* backward_code;
};


struct RE_AST
{
    uint32_t flags;
    RE_NODE* root_node;
};


// Disable warning due to zero length array in Microsoft's compiler

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4200)
#endif

struct RE
{
    uint32_t flags;
    uint8_t code[0];
};

#ifdef _MSC_VER
#pragma warning(pop)
#endif


struct RE_ERROR
{
    char message[512];
};


typedef int RE_MATCH_CALLBACK_FUNC(
    uint8_t* match,
    int match_length,
    int flags,
    void* args);


int yr_re_ast_create(
    RE_AST** re_ast);

void yr_re_ast_destroy(
    RE_AST* re_ast);

void yr_re_ast_print(
    RE_AST* re_ast);

SIZED_STRING* yr_re_ast_extract_literal(
    RE_AST* re_ast);


int yr_re_ast_contains_dot_star(
    RE_AST* re_ast);


int yr_re_ast_split_at_chaining_point(
    RE_AST* re_ast,
    RE_AST** result_re_ast,
    RE_AST** remainder_re_ast,
    int32_t* min_gap,
    int32_t* max_gap);


int yr_re_ast_emit_code(
    RE_AST* re_ast,
    YR_ARENA* arena,
    int backwards_code);


RE_NODE* yr_re_node_create(
    int type,
    RE_NODE* left,
    RE_NODE* right);


void yr_re_node_destroy(
    RE_NODE* node);


int yr_re_exec(
    uint8_t* re_code,
    uint8_t* input,
    size_t input_forwards_size,
    size_t input_backwards_size,
    int flags,
    RE_MATCH_CALLBACK_FUNC callback,
    void* callback_args,
    int* matches);


int yr_re_fast_exec(
    uint8_t* code,
    uint8_t* input_data,
    size_t input_forwards_size,
    size_t input_backwards_size,
    int flags,
    RE_MATCH_CALLBACK_FUNC callback,
    void* callback_args,
    int* matches);


int yr_re_parse(
    const char* re_string,
    RE_AST** re_ast,
    RE_ERROR* error);


int yr_re_parse_hex(
    const char* hex_string,
    RE_AST** re_ast,
    RE_ERROR* error);


int yr_re_compile(
    const char* re_string,
    int flags,
    YR_ARENA* code_arena,
    RE** re,
    RE_ERROR* error);


int yr_re_match(
    RE* re,
    const char* target);


int yr_re_initialize(void);


int yr_re_finalize(void);


int yr_re_finalize_thread(void);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/re_lexer.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#undef yyparse
#undef yylex
#undef yyerror
#undef yyfatal
#undef yychar
#undef yydebug
#undef yynerrs
#undef yyget_extra
#undef yyget_lineno

#undef YY_FATAL_ERROR
#undef YY_DECL
#undef LEX_ENV


#define yyparse         re_yyparse
#define yylex           re_yylex
#define yyerror         re_yyerror
#define yyfatal         re_yyfatal
#define yychar          re_yychar
#define yydebug         re_yydebug
#define yynerrs         re_yynerrs
#define yyget_extra     re_yyget_extra
#define yyget_lineno    re_yyget_lineno


#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#define YY_EXTRA_TYPE RE_AST*
#define YY_USE_CONST


typedef struct _RE_LEX_ENVIRONMENT
{
    int negated_class;
    uint8_t class_vector[32];
    int last_error_code;
    char last_error_message[256];

} RE_LEX_ENVIRONMENT;


#define LEX_ENV  ((RE_LEX_ENVIRONMENT*) lex_env)

#define YY_FATAL_ERROR(msg) re_yyfatal(yyscanner, msg)

#include <re_grammar.h>

#define YY_DECL int re_yylex \
    (YYSTYPE * yylval_param , yyscan_t yyscanner, RE_LEX_ENVIRONMENT* lex_env)


YY_EXTRA_TYPE yyget_extra(
    yyscan_t yyscanner);

int yylex(
    YYSTYPE* yylval_param,
    yyscan_t yyscanner,
    RE_LEX_ENVIRONMENT* lex_env);

int yyparse(
    void* yyscanner,
    RE_LEX_ENVIRONMENT* lex_env);

void yyerror(
    yyscan_t yyscanner,
    RE_LEX_ENVIRONMENT* lex_env,
    const char* error_message);

void yyfatal(
    yyscan_t yyscanner,
    const char* error_message);

int yr_parse_re_string(
    const char* re_string,
    RE_AST** re_ast,
    RE_ERROR* error);

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/rules.h`:

```h
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_RULES_H
#define YR_RULES_H

#include "types.h"
#include "utils.h"
#include "filemap.h"


#define CALLBACK_MSG_RULE_MATCHING              1
#define CALLBACK_MSG_RULE_NOT_MATCHING          2
#define CALLBACK_MSG_SCAN_FINISHED              3
#define CALLBACK_MSG_IMPORT_MODULE              4
#define CALLBACK_MSG_MODULE_IMPORTED            5

#define CALLBACK_CONTINUE   0
#define CALLBACK_ABORT      1
#define CALLBACK_ERROR      2


#define yr_rule_tags_foreach(rule, tag_name) \
    for (tag_name = rule->tags; \
         tag_name != NULL && *tag_name != '\0'; \
         tag_name += strlen(tag_name) + 1)


#define yr_rule_metas_foreach(rule, meta) \
    for (meta = rule->metas; !META_IS_NULL(meta); meta++)


#define yr_rule_strings_foreach(rule, string) \
    for (string = rule->strings; !STRING_IS_NULL(string); string++)


#define yr_string_matches_foreach(string, match) \
    for (match = STRING_MATCHES(string).head; match != NULL; match = match->next)


#define yr_rules_foreach(rules, rule) \
    for (rule = rules->rules_list_head; !RULE_IS_NULL(rule); rule++)



YR_API int yr_rules_scan_mem(
    YR_RULES* rules,
    uint8_t* buffer,
    size_t buffer_size,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);


YR_API int yr_rules_scan_file(
    YR_RULES* rules,
    const char* filename,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);


YR_API int yr_rules_scan_fd(
    YR_RULES* rules,
    YR_FILE_DESCRIPTOR fd,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);


YR_API int yr_rules_scan_proc(
    YR_RULES* rules,
    int pid,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);

YR_API int yr_rules_save(
    YR_RULES* rules,
    const char* filename);


YR_API int yr_rules_save_stream(
    YR_RULES* rules,
    YR_STREAM* stream);


YR_API int yr_rules_load(
    const char* filename,
    YR_RULES** rules);


YR_API int yr_rules_load_stream(
    YR_STREAM* stream,
    YR_RULES** rules);


YR_API int yr_rules_destroy(
    YR_RULES* rules);


YR_API int yr_rules_define_integer_variable(
    YR_RULES* rules,
    const char* identifier,
    int64_t value);


YR_API int yr_rules_define_boolean_variable(
    YR_RULES* rules,
    const char* identifier,
    int value);


YR_API int yr_rules_define_float_variable(
    YR_RULES* rules,
    const char* identifier,
    double value);


YR_API int yr_rules_define_string_variable(
    YR_RULES* rules,
    const char* identifier,
    const char* value);


YR_API void yr_rules_print_profiling_info(
    YR_RULES* rules);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/scan.h`:

```h
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_SCAN_H
#define YR_SCAN_H

#include "types.h"

// Bitmasks for flags.
#define SCAN_FLAGS_FAST_MODE         1
#define SCAN_FLAGS_PROCESS_MEMORY    2
#define SCAN_FLAGS_NO_TRYCATCH       4


int yr_scan_verify_match(
    YR_SCAN_CONTEXT* context,
    YR_AC_MATCH* ac_match,
    uint8_t* data,
    size_t data_size,
    size_t data_base,
    size_t offset);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/sizedstr.h`:

```h
/*
Copyright (c) 2007-2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _SIZEDSTR_H
#define _SIZEDSTR_H

#include <stddef.h>

#include "integers.h"

//
// This struct is used to support strings containing null chars. The length of
// the string is stored along the string data. However the string data is also
// terminated with a null char.
//

#define SIZED_STRING_FLAGS_NO_CASE  1
#define SIZED_STRING_FLAGS_DOT_ALL  2

#pragma pack(push)
#pragma pack(8)


typedef struct _SIZED_STRING
{
    uint32_t length;
    uint32_t flags;

    char c_string[1];

} SIZED_STRING;

#pragma pack(pop)


int sized_string_cmp(
    SIZED_STRING* s1,
    SIZED_STRING* s2);


SIZED_STRING* sized_string_dup(
    SIZED_STRING* s);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/stream.h`:

```h
/*
Copyright (c) 2015. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_STREAM_H
#define YR_STREAM_H

#include <stddef.h>

typedef size_t (*YR_STREAM_READ_FUNC)(
    void* ptr,
    size_t size,
    size_t count,
    void* user_data);


typedef size_t (*YR_STREAM_WRITE_FUNC)(
    const void* ptr,
    size_t size,
    size_t count,
    void* user_data);


typedef struct _YR_STREAM
{
    void* user_data;

    YR_STREAM_READ_FUNC read;
    YR_STREAM_WRITE_FUNC write;

} YR_STREAM;


size_t yr_stream_read(
    void* ptr,
    size_t size,
    size_t count,
    YR_STREAM* stream);


size_t yr_stream_write(
    const void* ptr,
    size_t size,
    size_t count,
    YR_STREAM* stream);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/strutils.h`:

```h
/*
Copyright (c) 2007-2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_STRUTILS_H
#define YR_STRUTILS_H

#include <assert.h>
#include <stdlib.h>

#include "integers.h"

// Cygwin already has these functions.
#if defined(_WIN32) && !defined(__CYGWIN__)
#if defined(_MSC_VER) && _MSC_VER < 1900
#define snprintf _snprintf
#endif
#define strcasecmp _stricmp
#define strncasecmp _strnicmp
#endif


uint64_t xtoi(
    const char* hexstr);


#if !HAVE_STRLCPY && !defined(strlcpy)
size_t strlcpy(
    char* dst,
    const char* src,
    size_t size);
#endif


#if !HAVE_STRLCAT && !defined(strlcat)
size_t strlcat(
    char* dst,
    const char* src,
    size_t size);
#endif


#if !HAVE_MEMMEM && !defined(memmem)
void* memmem(
    const void* haystack,
    size_t haystack_size,
    const void* needle,
    size_t needle_size);
#endif


int strnlen_w(
    const char* w_str);


int strcmp_w(
    const char* w_str,
    const char* str);


size_t strlcpy_w(
    char* dst,
    const char* w_src,
    size_t n);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/threading.h`:

```h
/*
Copyright (c) 2016. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_MUTEX_H
#define YR_MUTEX_H



#if defined(_WIN32) || defined(__CYGWIN__)

#include <windows.h>

typedef DWORD YR_THREAD_ID;
typedef DWORD YR_THREAD_STORAGE_KEY;
typedef HANDLE YR_MUTEX;

#else

#include <pthread.h>

typedef pthread_t YR_THREAD_ID;
typedef pthread_key_t YR_THREAD_STORAGE_KEY;
typedef pthread_mutex_t YR_MUTEX;

#endif

YR_THREAD_ID yr_current_thread_id(void);

int yr_mutex_create(YR_MUTEX*);
int yr_mutex_destroy(YR_MUTEX*);
int yr_mutex_lock(YR_MUTEX*);
int yr_mutex_unlock(YR_MUTEX*);

int yr_thread_storage_create(YR_THREAD_STORAGE_KEY*);
int yr_thread_storage_destroy(YR_THREAD_STORAGE_KEY*);
int yr_thread_storage_set_value(YR_THREAD_STORAGE_KEY*, void*);
void* yr_thread_storage_get_value(YR_THREAD_STORAGE_KEY*);

#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/types.h`:

```h
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_TYPES_H
#define YR_TYPES_H


#include "arena.h"
#include "re.h"
#include "limits.h"
#include "hash.h"
#include "utils.h"
#include "threading.h"



#ifdef PROFILING_ENABLED
#include <time.h>
#endif


#define DECLARE_REFERENCE(type, name) \
    union { type name; int64_t name##_; } YR_ALIGN(8)



#define NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL      0x01


#define STRING_GFLAGS_REFERENCED        0x01
#define STRING_GFLAGS_HEXADECIMAL       0x02
#define STRING_GFLAGS_NO_CASE           0x04
#define STRING_GFLAGS_ASCII             0x08
#define STRING_GFLAGS_WIDE              0x10
#define STRING_GFLAGS_REGEXP            0x20
#define STRING_GFLAGS_FAST_REGEXP       0x40
#define STRING_GFLAGS_FULL_WORD         0x80
#define STRING_GFLAGS_ANONYMOUS         0x100
#define STRING_GFLAGS_SINGLE_MATCH      0x200
#define STRING_GFLAGS_LITERAL           0x400
#define STRING_GFLAGS_FITS_IN_ATOM      0x800
#define STRING_GFLAGS_NULL              0x1000
#define STRING_GFLAGS_CHAIN_PART        0x2000
#define STRING_GFLAGS_CHAIN_TAIL        0x4000
#define STRING_GFLAGS_FIXED_OFFSET      0x8000
#define STRING_GFLAGS_GREEDY_REGEXP     0x10000
#define STRING_GFLAGS_DOT_ALL           0x20000

#define STRING_IS_HEX(x) \
    (((x)->g_flags) & STRING_GFLAGS_HEXADECIMAL)

#define STRING_IS_NO_CASE(x) \
    (((x)->g_flags) & STRING_GFLAGS_NO_CASE)

#define STRING_IS_DOT_ALL(x) \
    (((x)->g_flags) & STRING_GFLAGS_DOT_ALL)

#define STRING_IS_ASCII(x) \
    (((x)->g_flags) & STRING_GFLAGS_ASCII)

#define STRING_IS_WIDE(x) \
    (((x)->g_flags) & STRING_GFLAGS_WIDE)

#define STRING_IS_REGEXP(x) \
    (((x)->g_flags) & STRING_GFLAGS_REGEXP)

#define STRING_IS_GREEDY_REGEXP(x) \
    (((x)->g_flags) & STRING_GFLAGS_GREEDY_REGEXP)

#define STRING_IS_FULL_WORD(x) \
    (((x)->g_flags) & STRING_GFLAGS_FULL_WORD)

#define STRING_IS_ANONYMOUS(x) \
    (((x)->g_flags) & STRING_GFLAGS_ANONYMOUS)

#define STRING_IS_REFERENCED(x) \
    (((x)->g_flags) & STRING_GFLAGS_REFERENCED)

#define STRING_IS_SINGLE_MATCH(x) \
    (((x)->g_flags) & STRING_GFLAGS_SINGLE_MATCH)

#define STRING_IS_FIXED_OFFSET(x) \
    (((x)->g_flags) & STRING_GFLAGS_FIXED_OFFSET)

#define STRING_IS_LITERAL(x) \
    (((x)->g_flags) & STRING_GFLAGS_LITERAL)

#define STRING_IS_FAST_REGEXP(x) \
    (((x)->g_flags) & STRING_GFLAGS_FAST_REGEXP)

#define STRING_IS_CHAIN_PART(x) \
    (((x)->g_flags) & STRING_GFLAGS_CHAIN_PART)

#define STRING_IS_CHAIN_TAIL(x) \
    (((x)->g_flags) & STRING_GFLAGS_CHAIN_TAIL)

#define STRING_IS_NULL(x) \
    ((x) == NULL || ((x)->g_flags) & STRING_GFLAGS_NULL)

#define STRING_FITS_IN_ATOM(x) \
    (((x)->g_flags) & STRING_GFLAGS_FITS_IN_ATOM)

#define STRING_FOUND(x) \
    ((x)->matches[yr_get_tidx()].tail != NULL)

#define STRING_MATCHES(x) \
    ((x)->matches[yr_get_tidx()])


#define RULE_TFLAGS_MATCH                0x01

#define RULE_GFLAGS_PRIVATE              0x01
#define RULE_GFLAGS_GLOBAL               0x02
#define RULE_GFLAGS_REQUIRE_EXECUTABLE   0x04
#define RULE_GFLAGS_REQUIRE_FILE         0x08
#define RULE_GFLAGS_NULL                 0x1000

#define RULE_IS_PRIVATE(x) \
    (((x)->g_flags) & RULE_GFLAGS_PRIVATE)

#define RULE_IS_GLOBAL(x) \
    (((x)->g_flags) & RULE_GFLAGS_GLOBAL)

#define RULE_IS_NULL(x) \
    (((x)->g_flags) & RULE_GFLAGS_NULL)

#define RULE_MATCHES(x) \
    ((x)->t_flags[yr_get_tidx()] & RULE_TFLAGS_MATCH)


#define META_TYPE_NULL      0
#define META_TYPE_INTEGER   1
#define META_TYPE_STRING    2
#define META_TYPE_BOOLEAN   3

#define META_IS_NULL(x) \
    ((x) != NULL ? (x)->type == META_TYPE_NULL : TRUE)


#define EXTERNAL_VARIABLE_TYPE_NULL           0
#define EXTERNAL_VARIABLE_TYPE_FLOAT          1
#define EXTERNAL_VARIABLE_TYPE_INTEGER        2
#define EXTERNAL_VARIABLE_TYPE_BOOLEAN        3
#define EXTERNAL_VARIABLE_TYPE_STRING         4
#define EXTERNAL_VARIABLE_TYPE_MALLOC_STRING  5

#define EXTERNAL_VARIABLE_IS_NULL(x) \
    ((x) != NULL ? (x)->type == EXTERNAL_VARIABLE_TYPE_NULL : TRUE)


#pragma pack(push)
#pragma pack(8)


typedef struct _YR_NAMESPACE
{
    int32_t t_flags[MAX_THREADS];     // Thread-specific flags
    DECLARE_REFERENCE(char*, name);

} YR_NAMESPACE;


typedef struct _YR_META
{
    int32_t type;
    YR_ALIGN(8) int64_t integer;

    DECLARE_REFERENCE(const char*, identifier);
    DECLARE_REFERENCE(char*, string);

} YR_META;


struct _YR_MATCH;


typedef struct _YR_MATCHES
{
    int32_t count;

    DECLARE_REFERENCE(struct _YR_MATCH*, head);
    DECLARE_REFERENCE(struct _YR_MATCH*, tail);

} YR_MATCHES;


typedef struct _YR_STRING
{
    int32_t g_flags;
    int32_t length;

    DECLARE_REFERENCE(char*, identifier);
    DECLARE_REFERENCE(uint8_t*, string);
    DECLARE_REFERENCE(struct _YR_STRING*, chained_to);

    int32_t chain_gap_min;
    int32_t chain_gap_max;

    int64_t fixed_offset;

    YR_MATCHES matches[MAX_THREADS];
    YR_MATCHES unconfirmed_matches[MAX_THREADS];

#ifdef PROFILING_ENABLED
    clock_t clock_ticks;
#endif

} YR_STRING;


typedef struct _YR_RULE
{
    int32_t g_flags;               // Global flags
    int32_t t_flags[MAX_THREADS];  // Thread-specific flags

    DECLARE_REFERENCE(const char*, identifier);
    DECLARE_REFERENCE(const char*, tags);
    DECLARE_REFERENCE(YR_META*, metas);
    DECLARE_REFERENCE(YR_STRING*, strings);
    DECLARE_REFERENCE(YR_NAMESPACE*, ns);

#ifdef PROFILING_ENABLED
    clock_t clock_ticks;
#endif

} YR_RULE;


typedef struct _YR_EXTERNAL_VARIABLE
{
    int32_t type;

    YR_ALIGN(8) union
    {
        int64_t i;
        double f;
        char* s;
    } value;

    DECLARE_REFERENCE(char*, identifier);

} YR_EXTERNAL_VARIABLE;


typedef struct _YR_AC_MATCH
{
    uint16_t backtrack;

    DECLARE_REFERENCE(YR_STRING*, string);
    DECLARE_REFERENCE(uint8_t*, forward_code);
    DECLARE_REFERENCE(uint8_t*, backward_code);
    DECLARE_REFERENCE(struct _YR_AC_MATCH*, next);

} YR_AC_MATCH;


typedef struct _YR_AC_MATCH_TABLE_ENTRY
{
    DECLARE_REFERENCE(YR_AC_MATCH*, match);

} YR_AC_MATCH_TABLE_ENTRY;


typedef uint64_t                  YR_AC_TRANSITION;
typedef YR_AC_TRANSITION*         YR_AC_TRANSITION_TABLE;
typedef YR_AC_MATCH_TABLE_ENTRY*  YR_AC_MATCH_TABLE;


typedef struct _YARA_RULES_FILE_HEADER
{
    DECLARE_REFERENCE(YR_RULE*, rules_list_head);
    DECLARE_REFERENCE(YR_EXTERNAL_VARIABLE*, externals_list_head);
    DECLARE_REFERENCE(uint8_t*, code_start);
    DECLARE_REFERENCE(YR_AC_MATCH_TABLE, match_table);
    DECLARE_REFERENCE(YR_AC_TRANSITION_TABLE, transition_table);

} YARA_RULES_FILE_HEADER;

#pragma pack(pop)


//
// Structs defined below are never stored in the compiled rules file
//

typedef struct _YR_MATCH
{
    int64_t base;              // Base address for the match
    int64_t offset;            // Offset relative to base for the match
    int32_t match_length;      // Match length
    int32_t data_length;

    // Pointer to a buffer containing a portion of the matched data. The size of
    // the buffer is data_length. data_length is always <= length and is limited
    // to MAX_MATCH_DATA bytes.

    uint8_t* data;

    // If the match belongs to a chained string chain_length contains the
    // length of the chain. This field is used only in unconfirmed matches.

    int32_t chain_length;

    struct _YR_MATCH* prev;
    struct _YR_MATCH* next;

} YR_MATCH;


struct _YR_AC_STATE;


typedef struct _YR_AC_STATE
{
    uint8_t depth;
    uint8_t input;

    uint32_t t_table_slot;

    struct _YR_AC_STATE* failure;
    struct _YR_AC_STATE* first_child;
    struct _YR_AC_STATE* siblings;

    YR_AC_MATCH* matches;

} YR_AC_STATE;


typedef struct _YR_AC_AUTOMATON
{
    // Both m_table and t_table have the same number of elements, which is
    // stored in tables_size.

    uint32_t tables_size;
    uint32_t t_table_unused_candidate;

    YR_AC_TRANSITION_TABLE t_table;
    YR_AC_MATCH_TABLE m_table;

    YR_AC_STATE* root;

} YR_AC_AUTOMATON;


typedef struct _YR_RULES
{

    unsigned char tidx_mask[YR_BITARRAY_NCHARS(MAX_THREADS)];
    uint8_t* code_start;

    YR_MUTEX mutex;
    YR_ARENA* arena;
    YR_RULE* rules_list_head;
    YR_EXTERNAL_VARIABLE* externals_list_head;
    YR_AC_TRANSITION_TABLE transition_table;
    YR_AC_MATCH_TABLE match_table;

} YR_RULES;


struct _YR_MEMORY_BLOCK;
struct _YR_MEMORY_BLOCK_ITERATOR;


typedef uint8_t* (*YR_MEMORY_BLOCK_FETCH_DATA_FUNC)(
    struct _YR_MEMORY_BLOCK* self);


typedef struct _YR_MEMORY_BLOCK* (*YR_MEMORY_BLOCK_ITERATOR_FUNC)(
    struct _YR_MEMORY_BLOCK_ITERATOR* self);


typedef struct _YR_MEMORY_BLOCK
{
    size_t size;
    size_t base;

    void* context;

    YR_MEMORY_BLOCK_FETCH_DATA_FUNC fetch_data;

} YR_MEMORY_BLOCK;


typedef struct _YR_MEMORY_BLOCK_ITERATOR
{
    void* context;

    YR_MEMORY_BLOCK_ITERATOR_FUNC  first;
    YR_MEMORY_BLOCK_ITERATOR_FUNC  next;

} YR_MEMORY_BLOCK_ITERATOR;


typedef int (*YR_CALLBACK_FUNC)(
    int message,
    void* message_data,
    void* user_data);


typedef struct _YR_SCAN_CONTEXT
{
    uint64_t  file_size;
    uint64_t  entry_point;

    int flags;
    int tidx;

    void* user_data;

    YR_MEMORY_BLOCK_ITERATOR*  iterator;
    YR_HASH_TABLE*  objects_table;
    YR_CALLBACK_FUNC  callback;

    YR_ARENA* matches_arena;
    YR_ARENA* matching_strings_arena;

} YR_SCAN_CONTEXT;


struct _YR_OBJECT;


typedef union _YR_VALUE
{
    int64_t i;
    double d;
    void* p;
    struct _YR_OBJECT* o;
    YR_STRING* s;
    SIZED_STRING* ss;
    RE* re;

} YR_VALUE;


#define OBJECT_COMMON_FIELDS \
    int8_t type; \
    const char* identifier; \
    struct _YR_OBJECT* parent; \
    void* data;


typedef struct _YR_OBJECT
{
    OBJECT_COMMON_FIELDS
    YR_VALUE value;

} YR_OBJECT;


typedef struct _YR_OBJECT_STRUCTURE
{
    OBJECT_COMMON_FIELDS
    struct _YR_STRUCTURE_MEMBER* members;

} YR_OBJECT_STRUCTURE;


typedef struct _YR_OBJECT_ARRAY
{
    OBJECT_COMMON_FIELDS
    YR_OBJECT* prototype_item;
    struct _YR_ARRAY_ITEMS* items;

} YR_OBJECT_ARRAY;


typedef struct _YR_OBJECT_DICTIONARY
{
    OBJECT_COMMON_FIELDS
    YR_OBJECT* prototype_item;
    struct _YR_DICTIONARY_ITEMS* items;

} YR_OBJECT_DICTIONARY;


struct _YR_OBJECT_FUNCTION;


typedef int (*YR_MODULE_FUNC)(
    YR_VALUE* args,
    YR_SCAN_CONTEXT* context,
    struct _YR_OBJECT_FUNCTION* function_obj);


typedef struct _YR_OBJECT_FUNCTION
{
    OBJECT_COMMON_FIELDS
    YR_OBJECT* return_obj;

    struct
    {
        const char* arguments_fmt;
        YR_MODULE_FUNC code;

    } prototypes[MAX_OVERLOADED_FUNCTIONS];

} YR_OBJECT_FUNCTION;


#define object_as_structure(obj)  ((YR_OBJECT_STRUCTURE*) (obj))
#define object_as_array(obj)      ((YR_OBJECT_ARRAY*) (obj))
#define object_as_dictionary(obj) ((YR_OBJECT_DICTIONARY*) (obj))
#define object_as_function(obj)   ((YR_OBJECT_FUNCTION*) (obj))


typedef struct _YR_STRUCTURE_MEMBER
{
    YR_OBJECT* object;
    struct _YR_STRUCTURE_MEMBER* next;

} YR_STRUCTURE_MEMBER;


typedef struct _YR_ARRAY_ITEMS
{
    int count;
    YR_OBJECT* objects[1];

} YR_ARRAY_ITEMS;


typedef struct _YR_DICTIONARY_ITEMS
{
    int used;
    int free;

    struct
    {

        char* key;
        YR_OBJECT* obj;

    } objects[1];

} YR_DICTIONARY_ITEMS;


#endif

```

`src/x64dbgPlaytime/pluginsdk/yara/yara/utils.h`:

```h
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef YR_UTILS_H
#define YR_UTILS_H

#include <limits.h>

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define YR_API EXTERNC __attribute__((visibility("default")))
#elif defined(_MSC_VER)
#define YR_API EXTERNC __declspec(dllexport)
#else
#define YR_API EXTERNC
#endif

#if defined(__GNUC__)
#define YR_ALIGN(n) __attribute__((aligned(n)))
#elif defined(_MSC_VER)
#define YR_ALIGN(n) __declspec(align(n))
#else
#define YR_ALIGN(n)
#endif

#define yr_min(x, y) ((x < y) ? (x) : (y))
#define yr_max(x, y) ((x > y) ? (x) : (y))

#define yr_swap(x, y, T) do { T temp = x; x = y; y = temp; } while (0)

#ifdef NDEBUG

#define assertf(expr, msg, ...)  ((void)0)

#else

#include <stdlib.h>

#define assertf(expr, msg, ...) \
    if(!(expr)) { \
      fprintf(stderr, "%s:%d: " msg "\n", __FILE__, __LINE__, ##__VA_ARGS__); \
      abort(); \
    }

#endif

// Set, unset, and test bits in an array of unsigned characters by integer
// index. The underlying array must be of type char or unsigned char to
// ensure compatibility with the CHAR_BIT constant used in these definitions.

#define YR_BITARRAY_SET(uchar_array_base, bitnum) \
          (((uchar_array_base)[(bitnum)/CHAR_BIT]) = \
            ((uchar_array_base)[(bitnum)/CHAR_BIT] | (1 << ((bitnum) % CHAR_BIT))))

#define YR_BITARRAY_UNSET(uchar_array_base, bitnum) \
          (((uchar_array_base)[(bitnum)/CHAR_BIT]) = \
            ((uchar_array_base)[(bitnum)/CHAR_BIT] & (~(1 << ((bitnum) % CHAR_BIT)))))

#define YR_BITARRAY_TEST(uchar_array_base, bitnum) \
          (((uchar_array_base)[(bitnum)/CHAR_BIT] & (1 << ((bitnum) % CHAR_BIT))) != 0)

#define YR_BITARRAY_NCHARS(bitnum) \
          (((bitnum)+(CHAR_BIT-1))/CHAR_BIT)

#endif

```

`src/x64dbgPlaytime/utils.cpp`:

```cpp
#include "utils.h"
#include <windows.h>
#include <Shlwapi.h>
#include <assert.h>

#pragma comment(lib, "Shlwapi.lib")

namespace Utils {

bool readFileContents(const char *file, const char *mode, std::vector<uint8_t>& data)
{
    uint8_t tempBuffer[2048];

    FILE* fp = nullptr;
    fopen_s(&fp, file, mode);
    if(fp == nullptr)
        return false;

    // Clears buffer, we don't extend existing ones.
    data.clear();

    while (!feof(fp))
    {
        int bytesRead = fread(tempBuffer, 1, sizeof(tempBuffer), fp);
        if (bytesRead > 0)
        {
            data.insert(data.end(), &tempBuffer[0], &tempBuffer[bytesRead]);
        }
    }

    fclose(fp);
    return true;
}

std::vector<DirectoryEntry_t> readDirectory(const std::string& path, const std::string& searchPattern)
{
    std::vector<DirectoryEntry_t> res;

    std::string search = pathCombine(path, searchPattern);

    WIN32_FIND_DATAA fd = {};

    HANDLE hFind = FindFirstFileA(search.c_str(), &fd);
    if(hFind == nullptr)
        return res;

    do 
    {
        if(fd.cFileName[0] == '.' && fd.cFileName[1] == '\0')
            continue;
        if (fd.cFileName[0] == '.' && fd.cFileName[1] == '.' && fd.cFileName[2] == '\0')
            continue;

        DirectoryEntry_t entry;
        entry.fileName = fd.cFileName;
        entry.basePath = path;
        entry.fullFilePath = pathCombine(path, fd.cFileName);
        entry.isDirectory = (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

        res.emplace_back(std::move(entry));

    } while (FindNextFileA(hFind, &fd) != FALSE);

    FindClose(hFind);

    return res;
}

std::string pathCombine(const std::string& path, const std::string& add)
{
    std::string res = path;

    bool appendSlash = false;

    if (path.size() >= 1 && path[path.size() - 1] != '\\')
        appendSlash = true;
    
    if (add.size() >= 1 && add[0] == '\\' && appendSlash == true)
        appendSlash = false;

    if(appendSlash)
        res += "\\";

    res += add;
    return res;
}

std::string removeFileNameFromPath(const std::string& path)
{
    size_t n = path.rfind('\\');
    if(n == path.npos)
        return path;

    std::string res = path.substr(0, n);
    return res;
}

std::string getFileNameFromPath(const std::string& path)
{
    size_t n = path.rfind('\\');
    if (n == path.npos)
        return path;

    std::string res = path.substr(n + 1);
    return res;
}

std::string canonicalizePath(const std::string& path)
{
    char tempBuffer[1024] = {};

    PathCanonicalizeA(tempBuffer, path.c_str());

    return tempBuffer;
}


std::string escapeQuotes(const std::string& val)
{
    std::string res = val;
    for (auto it = res.begin(); it != res.end();)
    {
        if (*it == '"')
        {
            it = res.insert(it, '\\');
            it++;
        }
        it++;
    }
    return res;
}

std::string getx64DbgBasePath()
{
    char tempBuffer[1024] = {};

    // Get path of current process.
    GetModuleFileNameA(nullptr, tempBuffer, sizeof(tempBuffer));

    // Strip image name.
    std::string path = removeFileNameFromPath(tempBuffer);

    // Remove architecture directory.
    std::string arch = getFileNameFromPath(path);
    if (arch == "x32" || arch == "x64")
    {
        path = canonicalizePath(path + "\\..");
    }
    else
    {
        // This will cause problems if the user has a different setup.
        assert(false);
    }

    return path;
}

} // Utils

```

`src/x64dbgPlaytime/utils.h`:

```h
#pragma once

#include <string>
#include <vector>

namespace Utils {

bool readFileContents(const char *file, const char *mode, std::vector<uint8_t>& data);

struct DirectoryEntry_t
{
    std::string basePath;
    std::string fullFilePath;
    std::string fileName;
    bool isDirectory;
};

std::vector<DirectoryEntry_t> readDirectory(const std::string& path, const std::string& searchPattern);

std::string pathCombine(const std::string& path, const std::string& add);
std::string removeFileNameFromPath(const std::string& path);
std::string getFileNameFromPath(const std::string& path);
std::string canonicalizePath(const std::string& path);
std::string escapeQuotes(const std::string& val);
std::string getx64DbgBasePath();

} // Utils

```

`src/x64dbgPlaytime/x64dbgPlaytime.def`:

```def
LIBRARY
EXPORTS
    luaopen_socket_core
    luaopen_mime_core
    luaopen_bit
```

`src/x64dbgPlaytime/x64dbgPlaytime.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{176822C9-3CF8-41A9-81AB-8BBD3E3E2A32}</ProjectGuid>
    <RootNamespace>x64dbgPlaytime</RootNamespace>
    <ProjectName>x64dbgPlaytime</ProjectName>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetExt>.dp32</TargetExt>
    <OutDir>$(SolutionDir)..\bin\x32\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetExt>.dp32</TargetExt>
    <OutDir>$(SolutionDir)..\bin\x32d\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetExt>.dp64</TargetExt>
    <OutDir>$(SolutionDir)..\bin\x64\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetExt>.dp64</TargetExt>
    <OutDir>$(SolutionDir)..\bin\x64d\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>../Lua</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>x64dbgPlaytime.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <AdditionalIncludeDirectories>../Lua</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <ModuleDefinitionFile>x64dbgPlaytime.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>../Lua</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>x64dbgPlaytime.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <AdditionalIncludeDirectories>../Lua</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <ModuleDefinitionFile>x64dbgPlaytime.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="lua_assembler.cpp" />
    <ClCompile Include="lua_bootstrap.cpp" />
    <ClCompile Include="lua_bps.cpp" />
    <ClCompile Include="lua_constants.cpp" />
    <ClCompile Include="lua_context.cpp" />
    <ClCompile Include="lua_debugger.cpp" />
    <ClCompile Include="lua_globals.cpp" />
    <ClCompile Include="lua_modules.cpp" />
    <ClCompile Include="lua_utils.cpp" />
    <ClCompile Include="lua_labels.cpp" />
    <ClCompile Include="lua_memory.cpp" />
    <ClCompile Include="lua_print.cpp" />
    <ClCompile Include="lua_registers.cpp" />
    <ClCompile Include="lua_xrefs.cpp" />
    <ClCompile Include="plugin.cpp" />
    <ClCompile Include="pluginmain.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lua_context.hpp" />
    <ClInclude Include="lua_table_utils.h" />
    <ClInclude Include="plugin.h" />
    <ClInclude Include="pluginmain.h" />
    <ClInclude Include="pluginsdk\bridgegraph.h" />
    <ClInclude Include="pluginsdk\bridgelist.h" />
    <ClInclude Include="pluginsdk\bridgemain.h" />
    <ClInclude Include="pluginsdk\capstone\arm.h" />
    <ClInclude Include="pluginsdk\capstone\arm64.h" />
    <ClInclude Include="pluginsdk\capstone\capstone.h" />
    <ClInclude Include="pluginsdk\capstone\m68k.h" />
    <ClInclude Include="pluginsdk\capstone\mips.h" />
    <ClInclude Include="pluginsdk\capstone\platform.h" />
    <ClInclude Include="pluginsdk\capstone\ppc.h" />
    <ClInclude Include="pluginsdk\capstone\sparc.h" />
    <ClInclude Include="pluginsdk\capstone\systemz.h" />
    <ClInclude Include="pluginsdk\capstone\x86.h" />
    <ClInclude Include="pluginsdk\capstone\xcore.h" />
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h" />
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h" />
    <ClInclude Include="pluginsdk\jansson\jansson.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_config.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h" />
    <ClInclude Include="pluginsdk\lz4\lz4.h" />
    <ClInclude Include="pluginsdk\lz4\lz4file.h" />
    <ClInclude Include="pluginsdk\lz4\lz4hc.h" />
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h" />
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h" />
    <ClInclude Include="pluginsdk\yara\yara.h" />
    <ClInclude Include="pluginsdk\yara\yara\ahocorasick.h" />
    <ClInclude Include="pluginsdk\yara\yara\arena.h" />
    <ClInclude Include="pluginsdk\yara\yara\atoms.h" />
    <ClInclude Include="pluginsdk\yara\yara\compiler.h" />
    <ClInclude Include="pluginsdk\yara\yara\elf.h" />
    <ClInclude Include="pluginsdk\yara\yara\error.h" />
    <ClInclude Include="pluginsdk\yara\yara\exec.h" />
    <ClInclude Include="pluginsdk\yara\yara\exefiles.h" />
    <ClInclude Include="pluginsdk\yara\yara\filemap.h" />
    <ClInclude Include="pluginsdk\yara\yara\globals.h" />
    <ClInclude Include="pluginsdk\yara\yara\hash.h" />
    <ClInclude Include="pluginsdk\yara\yara\hex_lexer.h" />
    <ClInclude Include="pluginsdk\yara\yara\integers.h" />
    <ClInclude Include="pluginsdk\yara\yara\lexer.h" />
    <ClInclude Include="pluginsdk\yara\yara\libyara.h" />
    <ClInclude Include="pluginsdk\yara\yara\limits.h" />
    <ClInclude Include="pluginsdk\yara\yara\mem.h" />
    <ClInclude Include="pluginsdk\yara\yara\modules.h" />
    <ClInclude Include="pluginsdk\yara\yara\object.h" />
    <ClInclude Include="pluginsdk\yara\yara\parser.h" />
    <ClInclude Include="pluginsdk\yara\yara\pe.h" />
    <ClInclude Include="pluginsdk\yara\yara\proc.h" />
    <ClInclude Include="pluginsdk\yara\yara\re.h" />
    <ClInclude Include="pluginsdk\yara\yara\re_lexer.h" />
    <ClInclude Include="pluginsdk\yara\yara\rules.h" />
    <ClInclude Include="pluginsdk\yara\yara\scan.h" />
    <ClInclude Include="pluginsdk\yara\yara\sizedstr.h" />
    <ClInclude Include="pluginsdk\yara\yara\stream.h" />
    <ClInclude Include="pluginsdk\yara\yara\strutils.h" />
    <ClInclude Include="pluginsdk\yara\yara\threading.h" />
    <ClInclude Include="pluginsdk\yara\yara\types.h" />
    <ClInclude Include="pluginsdk\yara\yara\utils.h" />
    <ClInclude Include="pluginsdk\_dbgfunctions.h" />
    <ClInclude Include="pluginsdk\_plugins.h" />
    <ClInclude Include="pluginsdk\_plugin_types.h" />
    <ClInclude Include="pluginsdk\_scriptapi.h" />
    <ClInclude Include="pluginsdk\_scriptapi_argument.h" />
    <ClInclude Include="pluginsdk\_scriptapi_assembler.h" />
    <ClInclude Include="pluginsdk\_scriptapi_bookmark.h" />
    <ClInclude Include="pluginsdk\_scriptapi_comment.h" />
    <ClInclude Include="pluginsdk\_scriptapi_debug.h" />
    <ClInclude Include="pluginsdk\_scriptapi_flag.h" />
    <ClInclude Include="pluginsdk\_scriptapi_function.h" />
    <ClInclude Include="pluginsdk\_scriptapi_gui.h" />
    <ClInclude Include="pluginsdk\_scriptapi_label.h" />
    <ClInclude Include="pluginsdk\_scriptapi_memory.h" />
    <ClInclude Include="pluginsdk\_scriptapi_misc.h" />
    <ClInclude Include="pluginsdk\_scriptapi_module.h" />
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h" />
    <ClInclude Include="pluginsdk\_scriptapi_register.h" />
    <ClInclude Include="pluginsdk\_scriptapi_stack.h" />
    <ClInclude Include="pluginsdk\_scriptapi_symbol.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="pluginsdk\capstone\capstone_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\capstone\capstone_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\DeviceNameResolver\DeviceNameResolver_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\DeviceNameResolver\DeviceNameResolver_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\jansson\jansson_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\jansson\jansson_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\lz4\lz4_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\lz4\lz4_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\TitanEngine\TitanEngine_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\TitanEngine\TitanEngine_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\x32bridge.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\x32dbg.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\x64bridge.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\x64dbg.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\XEDParse\XEDParse_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\XEDParse\XEDParse_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\yara\yara_x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="pluginsdk\yara\yara_x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </Library>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Lua\Lua.vcxproj">
      <Project>{6166f81a-7e2e-42d1-b552-9c8763e0a884}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/x64dbgPlaytime/x64dbgPlaytime.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\pluginsdk">
      <UniqueIdentifier>{e26abb2c-05ce-4474-aa6b-0d6f0bc27926}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\capstone">
      <UniqueIdentifier>{836b0bc9-fdfe-4f45-945f-fd3e597aad9d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\dbghelp">
      <UniqueIdentifier>{c87c3d42-364d-4fe6-9ab3-8f7e8352af43}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\DeviceNameResolver">
      <UniqueIdentifier>{17a1513c-2d16-432c-a7ec-8e31e09ebfbf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\jansson">
      <UniqueIdentifier>{b1cd7fb9-d2e4-448a-bf04-4f11115651f2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\lz4">
      <UniqueIdentifier>{c50e39c1-5972-409e-a5f3-904860f1a661}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\TitanEngine">
      <UniqueIdentifier>{831de1fc-1ccd-427d-a848-f62169b3743e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\XEDParse">
      <UniqueIdentifier>{ffcdd30c-5e60-4075-95bf-ea1ca7aad310}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\yara">
      <UniqueIdentifier>{03176bbe-1752-4b7c-8a63-2decbb9b08a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\yara\yara">
      <UniqueIdentifier>{a7e84a7c-b09c-40d8-b685-8ed504db9f41}</UniqueIdentifier>
    </Filter>
    <Filter Include="Library Files">
      <UniqueIdentifier>{83b94fba-0963-43a4-b8bd-12730a208fad}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pluginsdk\capstone\arm.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\arm64.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\capstone.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\m68k.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\mips.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\platform.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\ppc.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\sparc.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\systemz.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\x86.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\xcore.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h">
      <Filter>Header Files\pluginsdk\dbghelp</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h">
      <Filter>Header Files\pluginsdk\DeviceNameResolver</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_config.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4file.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4hc.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara.h">
      <Filter>Header Files\pluginsdk\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\ahocorasick.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\arena.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\atoms.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\compiler.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\elf.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\error.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\exec.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\exefiles.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\filemap.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\globals.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\hash.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\hex_lexer.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\integers.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\lexer.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\libyara.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\limits.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\mem.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\modules.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\object.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\parser.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\pe.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\proc.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\re.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\re_lexer.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\rules.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\scan.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\sizedstr.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\stream.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\strutils.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\threading.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\types.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\utils.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h">
      <Filter>Header Files\pluginsdk\XEDParse</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h">
      <Filter>Header Files\pluginsdk\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_dbgfunctions.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugin_types.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugins.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_argument.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_assembler.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_bookmark.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_comment.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_debug.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_flag.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_function.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_gui.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_label.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_memory.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_misc.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_module.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_register.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_stack.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_symbol.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgegraph.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgelist.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgemain.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="plugin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pluginmain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lua_context.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lua_table_utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Library Include="pluginsdk\x32bridge.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\x32dbg.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\x64bridge.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\x64dbg.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\capstone\capstone_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\capstone\capstone_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\DeviceNameResolver\DeviceNameResolver_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\DeviceNameResolver\DeviceNameResolver_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\jansson\jansson_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\jansson\jansson_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\lz4\lz4_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\lz4\lz4_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\TitanEngine\TitanEngine_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\TitanEngine\TitanEngine_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\XEDParse\XEDParse_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\XEDParse\XEDParse_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\yara\yara_x64.lib">
      <Filter>Library Files</Filter>
    </Library>
    <Library Include="pluginsdk\yara\yara_x86.lib">
      <Filter>Library Files</Filter>
    </Library>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="plugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pluginmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_registers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_context.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_print.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_debugger.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_bootstrap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_labels.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_constants.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_modules.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_xrefs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_bps.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_globals.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lua_assembler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```