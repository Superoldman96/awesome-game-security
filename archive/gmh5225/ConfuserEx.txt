Project Path: arc_gmh5225_ConfuserEx_i8_fegic

Source Tree:

```txt
arc_gmh5225_ConfuserEx_i8_fegic
├── CODE_OF_CONDUCT.md
├── CONTRIBUTING.md
├── Confuser.CLI
│   ├── Confuser.CLI.csproj
│   └── Program.cs
├── Confuser.Core
│   ├── API
│   │   ├── APIStore.cs
│   │   ├── IDataStore.cs
│   │   └── IOpaquePredicate.cs
│   ├── Annotations.cs
│   ├── Confuser.Core.csproj
│   ├── Confuser.Core.packages.config
│   ├── ConfuserAssemblyResolver.cs
│   ├── ConfuserComponent.cs
│   ├── ConfuserContext.cs
│   ├── ConfuserEngine.cs
│   ├── ConfuserException.cs
│   ├── ConfuserParameters.cs
│   ├── CoreComponent.cs
│   ├── DependencyResolver.cs
│   ├── DnlibUtils.cs
│   ├── Helpers
│   │   ├── ControlFlowGraph.cs
│   │   ├── InjectHelper.cs
│   │   ├── KeySequence.cs
│   │   └── MutationHelper.cs
│   ├── ILogger.cs
│   ├── LZMA
│   │   ├── Common
│   │   │   ├── CRC.cs
│   │   │   ├── InBuffer.cs
│   │   │   └── OutBuffer.cs
│   │   ├── Compress
│   │   │   ├── LZ
│   │   │   │   ├── IMatchFinder.cs
│   │   │   │   ├── LzBinTree.cs
│   │   │   │   ├── LzInWindow.cs
│   │   │   │   └── LzOutWindow.cs
│   │   │   ├── LZMA
│   │   │   │   ├── LzmaBase.cs
│   │   │   │   ├── LzmaDecoder.cs
│   │   │   │   └── LzmaEncoder.cs
│   │   │   └── RangeCoder
│   │   │       ├── RangeCoder.cs
│   │   │       ├── RangeCoderBit.cs
│   │   │       └── RangeCoderBitTree.cs
│   │   └── ICoder.cs
│   ├── Marker.cs
│   ├── MarkerResult.cs
│   ├── ModuleSorter.cs
│   ├── NativeEraser.cs
│   ├── NullLogger.cs
│   ├── ObfAttrMarker.cs
│   ├── ObfAttrParser.cs
│   ├── Packer.cs
│   ├── PluginDiscovery.cs
│   ├── Project
│   │   ├── ConfuserPrj.xsd
│   │   ├── ConfuserProject.cs
│   │   ├── InvalidPatternException.cs
│   │   ├── PatternParser.cs
│   │   ├── PatternToken.cs
│   │   ├── PatternTokenizer.cs
│   │   └── Patterns
│   │       ├── AndOperator.cs
│   │       ├── DeclTypeFunction.cs
│   │       ├── FullNameFunction.cs
│   │       ├── HasAttrFunction.cs
│   │       ├── InheritsFunction.cs
│   │       ├── IsPublicFunction.cs
│   │       ├── IsTypeFunction.cs
│   │       ├── LiteralExpression.cs
│   │       ├── MatchFunction.cs
│   │       ├── MemberTypeFunction.cs
│   │       ├── ModuleFunction.cs
│   │       ├── NameFunction.cs
│   │       ├── NamespaceFunction.cs
│   │       ├── NotOperator.cs
│   │       ├── OrOperator.cs
│   │       ├── PatternExpression.cs
│   │       ├── PatternFunction.cs
│   │       └── PatternOperator.cs
│   ├── Protection.cs
│   ├── ProtectionDependencyAttributes.cs
│   ├── ProtectionParameters.cs
│   ├── ProtectionPhase.cs
│   ├── ProtectionPipeline.cs
│   ├── ProtectionPreset.cs
│   ├── ProtectionSettings.cs
│   ├── ProtectionTargets.cs
│   ├── ServiceRegistry.cs
│   ├── Services
│   │   ├── CompressionService.cs
│   │   ├── MarkerService.cs
│   │   ├── RandomService.cs
│   │   ├── RuntimeService.cs
│   │   └── TraceService.cs
│   ├── UnreachableException.cs
│   ├── Utils.cs
│   └── WatermarkingProtection.cs
├── Confuser.DynCipher
│   ├── AST
│   │   ├── ArrayIndexExpression.cs
│   │   ├── AssignmentStatement.cs
│   │   ├── BinOpExpression.cs
│   │   ├── Expression.cs
│   │   ├── LiteralExpression.cs
│   │   ├── LoopStatement.cs
│   │   ├── Statement.cs
│   │   ├── StatementBlock.cs
│   │   ├── UnaryOpExpression.cs
│   │   ├── Variable.cs
│   │   └── VariableExpression.cs
│   ├── Confuser.DynCipher.csproj
│   ├── DynCipherComponent.cs
│   ├── DynCipherService.cs
│   ├── Elements
│   │   ├── AddKey.cs
│   │   ├── BinOp.cs
│   │   ├── CryptoElement.cs
│   │   ├── Matrix.cs
│   │   ├── NumOp.cs
│   │   ├── RotateBit.cs
│   │   └── Swap.cs
│   ├── Generation
│   │   ├── CILCodeGen.cs
│   │   ├── CipherGenContext.cs
│   │   ├── CipherGenerator.cs
│   │   ├── DMCodeGen.cs
│   │   ├── ExpressionGenerator.cs
│   │   └── x86CodeGen.cs
│   ├── Transforms
│   │   ├── ConvertVariables.cs
│   │   ├── ExpansionTransform.cs
│   │   ├── MulToShiftTransform.cs
│   │   ├── NormalizeBinOpTransform.cs
│   │   └── ShuffleTransform.cs
│   └── Utils.cs
├── Confuser.MSBuild.Tasks
│   ├── ConfuseTask.cs
│   ├── Confuser.MSBuild.Tasks.csproj
│   ├── CreateProjectTask.cs
│   ├── MSBuildLogger.cs
│   └── build
│       ├── Confuser.MSBuild.Tasks.targets
│       └── Confuser.MSBuild.targets
├── Confuser.Protections
│   ├── AntiDebugProtection.cs
│   ├── AntiDumpProtection.cs
│   ├── AntiILDasmProtection.cs
│   ├── AntiTamper
│   │   ├── AntiMode.cs
│   │   ├── AntiTamperExtensions.cs
│   │   ├── AntiTamperProtection.cs
│   │   ├── DynamicDeriver.cs
│   │   ├── IKeyDeriver.cs
│   │   ├── IModeHandler.cs
│   │   ├── JITBody.cs
│   │   ├── JITMode.cs
│   │   ├── NormalDeriver.cs
│   │   └── NormalMode.cs
│   ├── Compress
│   │   ├── Compressor.cs
│   │   ├── CompressorContext.cs
│   │   ├── DynamicDeriver.cs
│   │   ├── ExtractPhase.cs
│   │   ├── IKeyDeriver.cs
│   │   ├── NormalDeriver.cs
│   │   └── StubProtection.cs
│   ├── Confuser.Protections.csproj
│   ├── Constants
│   │   ├── CEContext.cs
│   │   ├── ConstantProtection.cs
│   │   ├── DynamicMode.cs
│   │   ├── EncodeElements.cs
│   │   ├── EncodePhase.cs
│   │   ├── IEncodeMode.cs
│   │   ├── InjectPhase.cs
│   │   ├── Mode.cs
│   │   ├── NormalMode.cs
│   │   ├── ReferenceReplacer.cs
│   │   └── x86Mode.cs
│   ├── ControlFlow
│   │   ├── BlockParser.cs
│   │   ├── Blocks.cs
│   │   ├── CFContext.cs
│   │   ├── ControlFlowPhase.cs
│   │   ├── ControlFlowProtection.cs
│   │   ├── ExpressionPredicate.cs
│   │   ├── IPredicate.cs
│   │   ├── JumpMangler.cs
│   │   ├── ManglerBase.cs
│   │   ├── NormalPredicate.cs
│   │   ├── SwitchMangler.cs
│   │   └── x86Predicate.cs
│   ├── HardeningPhase.cs
│   ├── HardeningProtection.cs
│   ├── InvalidMetadataProtection.cs
│   ├── ReferenceProxy
│   │   ├── ExpressionEncoding.cs
│   │   ├── IRPEncoding.cs
│   │   ├── MildMode.cs
│   │   ├── NormalEncoding.cs
│   │   ├── RPContext.cs
│   │   ├── RPMode.cs
│   │   ├── ReferenceProxyPhase.cs
│   │   ├── ReferenceProxyProtection.cs
│   │   ├── StrongMode.cs
│   │   └── x86Encoding.cs
│   ├── Resources
│   │   ├── DynamicMode.cs
│   │   ├── IEncodeMode.cs
│   │   ├── InjectPhase.cs
│   │   ├── MDPhase.cs
│   │   ├── Mode.cs
│   │   ├── NormalMode.cs
│   │   ├── REContext.cs
│   │   └── ResourceProtection.cs
│   └── TypeScrambler
│       ├── AnalyzePhase.cs
│       ├── ScramblePhase.cs
│       ├── Scrambler
│       │   ├── Analyzers
│       │   │   ├── ContextAnalyzer.cs
│       │   │   ├── ContextAnalyzerFactory.cs
│       │   │   ├── ContextAnalyzer`1.cs
│       │   │   ├── MemberRefAnalyzer.cs
│       │   │   ├── MethodDefAnalyzer.cs
│       │   │   ├── MethodSpecAnalyzer.cs
│       │   │   └── TypeRefAnalyzer.cs
│       │   ├── Rewriter
│       │   │   └── Instructions
│       │   │       ├── FieldDefInstructionRewriter.cs
│       │   │       ├── InstructionRewriter.cs
│       │   │       ├── InstructionRewriterFactory.cs
│       │   │       ├── InstructionRewriter`1.cs
│       │   │       ├── MemberRefInstructionRewriter.cs
│       │   │       ├── MethodDefInstructionRewriter.cs
│       │   │       ├── MethodSpecInstructionRewriter.cs
│       │   │       ├── TypeDefInstructionRewriter.cs
│       │   │       └── TypeRefInstructionRewriter.cs
│       │   ├── ScannedItem.cs
│       │   ├── ScannedMethod.cs
│       │   ├── ScannedType.cs
│       │   ├── SignatureUtils.cs
│       │   └── TypeRewriter.cs
│       ├── TypeScrambleProtection.cs
│       └── TypeService.cs
├── Confuser.Renamer
│   ├── AnalyzePhase.cs
│   ├── Analyzers
│   │   ├── CaliburnAnalyzer.cs
│   │   ├── CallSiteAnalyzer.cs
│   │   ├── InterReferenceAnalyzer.cs
│   │   ├── JsonAnalyzer.cs
│   │   ├── LdtokenEnumAnalyzer.cs
│   │   ├── ManifestResourceAnalyzer.cs
│   │   ├── ReflectionAnalyzer.cs
│   │   ├── ResourceAnalyzer.cs
│   │   ├── TypeBlobAnalyzer.cs
│   │   ├── VTableAnalyzer.cs
│   │   ├── VisualBasicRuntimeAnalyzer.cs
│   │   ├── VsCompositionAnalyzer.cs
│   │   ├── WPFAnalyzer.cs
│   │   └── WinFormsAnalyzer.cs
│   ├── BAML
│   │   ├── BAMLAnalyzer.cs
│   │   ├── BAMLPropertyReference.cs
│   │   ├── BAMLStringReference.cs
│   │   ├── BamlDocument.cs
│   │   ├── BamlElement.cs
│   │   ├── BamlRW.cs
│   │   ├── BamlRecords.cs
│   │   ├── IBAMLReference.cs
│   │   ├── IKnownThings.cs
│   │   ├── KnownThingsv3.cs
│   │   ├── KnownThingsv4.cs
│   │   ├── PropertyPath
│   │   │   ├── DrillIn.cs
│   │   │   ├── IndexerParamInfo.cs
│   │   │   ├── PropertyPathParser.cs
│   │   │   ├── README.md
│   │   │   ├── SourceValueInfo.cs
│   │   │   └── SourceValueType.cs
│   │   ├── PropertyPathIndexUpdater.cs
│   │   ├── PropertyPathPartUpdater.cs
│   │   └── PropertyPathUpdater.cs
│   ├── Confuser.Renamer.csproj
│   ├── DisplayNormalizedName.cs
│   ├── GenericArgumentResolver.cs
│   ├── GenericArguments.cs
│   ├── INameReference.cs
│   ├── IRenamer.cs
│   ├── MessageDeobfuscator.cs
│   ├── NameProtection.cs
│   ├── NameService.cs
│   ├── PostRenamePhase.cs
│   ├── Properties
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── RecursionCounter.cs
│   ├── ReferenceUtilities.cs
│   ├── References
│   │   ├── BAMLAttributeReference.cs
│   │   ├── BAMLConverterMemberReference.cs
│   │   ├── BAMLConverterTypeReference.cs
│   │   ├── BAMLEnumReference.cs
│   │   ├── BAMLPathTypeReference.cs
│   │   ├── BAMLTypeReference.cs
│   │   ├── CAMemberReference.cs
│   │   ├── MemberOldestSiblingReference.cs
│   │   ├── MemberOverrideReference.cs
│   │   ├── MemberRefReference.cs
│   │   ├── MemberSiblingReference.cs
│   │   ├── OverrideDirectiveReference.cs
│   │   ├── RequiredPrefixReference.cs
│   │   ├── ResourceReference.cs
│   │   ├── StringMemberNameReference.cs
│   │   ├── StringTypeReference.cs
│   │   └── TypeRefReference.cs
│   ├── RenameMode.cs
│   ├── RenamePhase.cs
│   ├── ReversibleRenamer.cs
│   ├── RickRoller.cs
│   └── VTable.cs
├── Confuser.Runtime
│   ├── AntiDebug.Antinet.cs
│   ├── AntiDebug.Safe.cs
│   ├── AntiDebug.Win32.cs
│   ├── AntiDump.cs
│   ├── AntiTamper.Anti.cs
│   ├── AntiTamper.JIT.cs
│   ├── AntiTamper.Normal.cs
│   ├── Compressor.Compat.cs
│   ├── Compressor.cs
│   ├── Confuser.Runtime.csproj
│   ├── Constant.cs
│   ├── ExcludeFromCodeCoverageAttribute.cs
│   ├── Lzma.cs
│   ├── Mutation.cs
│   ├── RefProxy.Strong.cs
│   ├── Resource.cs
│   └── antinet
│       ├── ABOUT
│       ├── AntiManagedDebugger.cs
│       ├── AntiManagedProfiler.cs
│       ├── HandleProcessCorruptedStateExceptionsAttribute.cs
│       └── PEInfo.cs
├── Confuser2.sln
├── ConfuserEx
│   ├── App.xaml
│   ├── App.xaml.cs
│   ├── BoolToVisibilityConverter.cs
│   ├── BrushToColorConverter.cs
│   ├── CompComboBox.xaml
│   ├── CompComboBox.xaml.cs
│   ├── ComponentConverter.cs
│   ├── ComponentDiscovery.cs
│   ├── ConfuserEx.csproj
│   ├── ConfuserEx.ico
│   ├── EmptyToBoolConverter.cs
│   ├── EnumValuesExtension.cs
│   ├── FileDragDrop.cs
│   ├── InvertBoolConverter.cs
│   ├── MainWindow.xaml
│   ├── MainWindow.xaml.cs
│   ├── Resources
│   │   ├── CREDITS
│   │   ├── Decode.png
│   │   ├── Error.png
│   │   ├── FontAwesome.otf
│   │   ├── New.png
│   │   ├── Open.png
│   │   ├── Save.png
│   │   └── Tools.png
│   ├── Skin.cs
│   ├── Skin.xaml
│   ├── StackTraceDecoder.xaml
│   ├── StackTraceDecoder.xaml.cs
│   ├── ViewModel
│   │   ├── IViewModel.cs
│   │   ├── Project
│   │   │   ├── ProjectModuleVM.cs
│   │   │   ├── ProjectRuleVM.cs
│   │   │   ├── ProjectSettingVM.cs
│   │   │   └── ProjectVM.cs
│   │   ├── StringItem.cs
│   │   ├── UI
│   │   │   ├── AboutTabVM.cs
│   │   │   ├── AppVM.cs
│   │   │   ├── ProjectTabVM.cs
│   │   │   ├── ProtectTabVM.cs
│   │   │   ├── SettingsTabVM.cs
│   │   │   └── TabViewModel.cs
│   │   ├── Utils.cs
│   │   └── ViewModelBase.cs
│   ├── Views
│   │   ├── AboutTabView.xaml
│   │   ├── ProjectModuleView.xaml
│   │   ├── ProjectModuleView.xaml.cs
│   │   ├── ProjectRuleView.xaml
│   │   ├── ProjectRuleView.xaml.cs
│   │   ├── ProjectTabAdvancedView.xaml
│   │   ├── ProjectTabAdvancedView.xaml.cs
│   │   ├── ProjectTabView.xaml
│   │   ├── ProtectTabView.xaml
│   │   └── SettingsTabView.xaml
│   ├── Views.xaml
│   └── app.config
├── ConfuserEx.Common.props
├── ConfuserEx.Common.targets
├── ConfuserEx.snk
├── GlobalAssemblyInfo.cs
├── LICENSE.md
├── README.md
├── Tests
│   ├── 118_EnhancedStrongName
│   │   ├── 118_EnhancedStrongName.csproj
│   │   ├── Attributes.cs
│   │   ├── IClrStrongName.cs
│   │   ├── IdentityKey.snk
│   │   ├── IdentityPubKey.snk
│   │   ├── Program.cs
│   │   ├── SignatureKey.snk
│   │   └── SignaturePubKey.snk
│   ├── 118_EnhancedStrongName.Test
│   │   ├── 118_EnhancedStrongName.Test.csproj
│   │   └── EnhancedStrongNameTest.cs
│   ├── 123_InheritCustomAttr
│   │   ├── 123_InheritCustomAttr.csproj
│   │   ├── C.cs
│   │   ├── D.cs
│   │   ├── E.cs
│   │   ├── ExtReference
│   │   │   ├── C.cs
│   │   │   ├── IExt.cs
│   │   │   ├── IExt`2.cs
│   │   │   └── IRoot.cs
│   │   ├── I.cs
│   │   ├── IDayOfWeek.cs
│   │   ├── MyAttribute.cs
│   │   └── Program.cs
│   ├── 123_InheritCustomAttr.Test
│   │   ├── 123_InheritCustomAttr.Test.csproj
│   │   └── InheritCustomAttributeTest.cs
│   ├── 161_DynamicTypeRename
│   │   ├── 161_DynamicTypeRename.csproj
│   │   └── Program.cs
│   ├── 161_DynamicTypeRename.Test
│   │   ├── 161_DynamicTypeRename.Test.csproj
│   │   └── RenameDynamicMethodTest.cs
│   ├── 193_ConstantsInlining
│   │   ├── 193_ConstantsInlining.csproj
│   │   └── Program.cs
│   ├── 193_ConstantsInlining.Lib
│   │   ├── 193_ConstantsInlining.Lib.csproj
│   │   └── ExternalClass.cs
│   ├── 193_ConstantsInlining.Test
│   │   ├── 193_ConstantsInlining.Test.csproj
│   │   └── ConstantInliningTest.cs
│   ├── 244_ClrProtection
│   │   ├── 244_ClrProtection.vcxproj
│   │   ├── 244_ClrProtection.vcxproj.filters
│   │   └── Program.cpp
│   ├── 244_ClrProtection.Test
│   │   ├── 244_ClrProtection.Test.csproj
│   │   └── ProtectClrAssemblyTest.cs
│   ├── 252_ComplexInterfaceRenaming
│   │   ├── 252_ComplexInterfaceRenaming.csproj
│   │   ├── IC.cs
│   │   ├── IName.cs
│   │   ├── IOperator.cs
│   │   ├── IWorker.cs
│   │   ├── Manager.cs
│   │   ├── Operator.cs
│   │   ├── Program.cs
│   │   └── Worker.cs
│   ├── 252_ComplexInterfaceRenaming.Test
│   │   ├── 252_ComplexInterfaceRenaming.Test.csproj
│   │   └── RenameComplexInterfaceTest.cs
│   ├── 270_EnumArrayConstantProtection
│   │   ├── 270_EnumArrayConstantProtection.csproj
│   │   ├── Level.cs
│   │   └── Program.cs
│   ├── 270_EnumArrayConstantProtection.Test
│   │   ├── 270_EnumArrayConstantProtection.Test.csproj
│   │   └── ConstantProtectionTest.cs
│   ├── 306_ComplexClassStructureRename
│   │   ├── 306_ComplexClassStructureRename.csproj
│   │   └── Program.cs
│   ├── 306_ComplexClassStructureRename.Lib
│   │   ├── 306_ComplexClassStructureRename.Lib.csproj
│   │   ├── ITestEvents.cs
│   │   ├── InternalBaseClass.cs
│   │   ├── InternalClass1.cs
│   │   ├── InternalClass2.cs
│   │   ├── MyTest.cs
│   │   ├── PublicClass1.cs
│   │   └── PublicClass2.cs
│   ├── 306_ComplexClassStructureRename.Test
│   │   ├── 306_ComplexClassStructureRename.Test.csproj
│   │   └── ComplexRenameTest.cs
│   ├── 342_InterfaceRenamingLoop
│   │   ├── 342_InterfaceRenamingLoop.csproj
│   │   ├── CBase.cs
│   │   ├── ClassA.cs
│   │   ├── ClassB.cs
│   │   ├── IAEvents.cs
│   │   └── Program.cs
│   ├── 342_InterfaceRenamingLoop.Test
│   │   ├── 342_InterfaceRenamingLoop.Test.csproj
│   │   └── InterfaceRenamingLoopTest.cs
│   ├── 345_RenameDynamicParameter
│   │   ├── 345_RenameDynamicParameter.csproj
│   │   ├── ConstructorTestClass.cs
│   │   ├── FieldTestClass.cs
│   │   ├── OverloadTestClass.cs
│   │   ├── OverrideBaseTestClass.cs
│   │   ├── OverrideTestClass.cs
│   │   ├── Program.cs
│   │   └── SimpleTestClass.cs
│   ├── 345_RenameDynamicParameter.Test
│   │   ├── 345_RenameDynamicParameter.Test.csproj
│   │   └── RenameDynamicParameterTest.cs
│   ├── 389_MixedCultureCasing
│   │   ├── 389_MixedCultureCasing.csproj
│   │   ├── Program.cs
│   │   ├── Resource1.Designer.cs
│   │   ├── Resource1.de-DE.resx
│   │   ├── Resource1.resx
│   │   ├── Resource2.Designer.cs
│   │   ├── Resource2.de-de.resx
│   │   └── Resource2.resx
│   ├── 389_MixedCultureCasing.Test
│   │   ├── 389_MixedCultureCasing.Test.csproj
│   │   └── MixedCultureCasingTest.cs
│   ├── 421_NewtonsoftJsonSerialization
│   │   ├── 421_NewtonsoftJsonSerialization.csproj
│   │   ├── ObfExcluded.cs
│   │   ├── ObfMarkedWithAttribute.cs
│   │   └── Program.cs
│   ├── 421_NewtonsoftJsonSerialization.Test
│   │   ├── 421_NewtonsoftJsonSerialization.Test.csproj
│   │   └── NewtonsoftJsonTest.cs
│   ├── 470_ImplementationInBaseClass
│   │   ├── 470_ImplementationInBaseClass.csproj
│   │   ├── IMyInterfaceA.cs
│   │   ├── IMyInterfaceB.cs
│   │   ├── IMyInterfaceC.cs
│   │   ├── MyBaseClass.cs
│   │   ├── MyClassA.cs
│   │   ├── MyClassB.cs
│   │   ├── MyClassB2.cs
│   │   ├── MyClassC.cs
│   │   └── Program.cs
│   ├── 470_ImplementationInBaseClass.Test
│   │   ├── 470_ImplementationInBaseClass.Test.csproj
│   │   └── RenameTest.cs
│   ├── 78_SignatureMismatch
│   │   ├── 78_SignatureMismatch.csproj
│   │   ├── EasyDict.cs
│   │   ├── EasyFile.cs
│   │   └── Program.cs
│   ├── 78_SignatureMismatch.Test
│   │   ├── 78_SignatureMismatch.Test.csproj
│   │   └── SignatureMismatchTest.cs
│   ├── AntiTamper
│   │   ├── AntiTamper.csproj
│   │   ├── Program.cs
│   │   └── Properties
│   │       ├── Resources.Designer.cs
│   │       └── Resources.resx
│   ├── AntiTamper.Test
│   │   ├── AntiTamper.Test.csproj
│   │   └── AntiTamperTest.cs
│   ├── BlockingReferences
│   │   ├── BlockingReferences.csproj
│   │   └── Program.cs
│   ├── BlockingReferences.Test
│   │   ├── BlockingReferences.Test.csproj
│   │   └── Program.cs
│   ├── BlockingReferencesHelper
│   │   ├── BaseImplementation.cs
│   │   └── BlockingReferencesHelper.csproj
│   ├── CompressorWithResx
│   │   ├── CompressorWithResx.csproj
│   │   ├── Program.cs
│   │   └── Properties
│   │       ├── Resources.Designer.cs
│   │       ├── Resources.de.resx
│   │       └── Resources.resx
│   ├── CompressorWithResx.Test
│   │   ├── CompressTest.cs
│   │   └── CompressorWithResx.Test.csproj
│   ├── Confuser.Core.Test
│   │   ├── Confuser.Core.Test.csproj
│   │   ├── Helpers.cs
│   │   ├── Services
│   │   │   └── TraceServiceTest.cs
│   │   └── UtilsTest.cs
│   ├── Confuser.Renamer.Test
│   │   ├── AbstractAttribute.cs
│   │   ├── Analyzers
│   │   │   ├── ManifestResourceAnalyzerTest.cs
│   │   │   ├── ReflectionAnalyzerTest.cs
│   │   │   └── TypeBlobAnalyzerTest.cs
│   │   ├── Confuser.Renamer.Test.csproj
│   │   ├── Helpers.cs
│   │   ├── ImplementationAttribute.cs
│   │   └── VTableTest.cs
│   ├── Confuser.UnitTest
│   │   ├── Confuser.UnitTest.csproj
│   │   ├── FileUtilities.cs
│   │   ├── TestBase.cs
│   │   └── XUnitLogger.cs
│   ├── IncorrectRedirectToGac
│   │   ├── IncorrectRedirectToGac.csproj
│   │   └── Program.cs
│   ├── IncorrectRedirectToGac.Test
│   │   ├── IncorrectRedirectToGac.Test.csproj
│   │   └── IncorrectRedirectToGacTest.cs
│   ├── MessageDeobfuscation
│   │   ├── MessageDeobfuscation.csproj
│   │   └── Program.cs
│   ├── MessageDeobfuscation.Test
│   │   ├── MessageDeobfuscation.Test.csproj
│   │   └── MessageDeobfuscationTest.cs
│   ├── MethodOverloading
│   │   ├── MethodOverloading.csproj
│   │   └── Program.cs
│   ├── MethodOverloading.Test
│   │   ├── MethodOverloading.Test.csproj
│   │   └── MethodOverloadingTest.cs
│   ├── ReferenceProxy
│   │   ├── Program.cs
│   │   └── ReferenceProxy.csproj
│   ├── ReferenceProxy.Test
│   │   ├── ReferenceProxy.Test.csproj
│   │   └── ReferenceProxyTest.cs
│   ├── SignatureMismatch2
│   │   ├── Program.cs
│   │   └── SignatureMismatch2.csproj
│   ├── SignatureMismatch2.Test
│   │   ├── SignatureMismatch2.Test.csproj
│   │   └── SignatureMismatch2Test.cs
│   ├── SignatureMismatch2Helper
│   │   ├── External.cs
│   │   └── SignatureMismatch2Helper.csproj
│   ├── TypeScrambler
│   │   ├── ExplicitInterface.cs
│   │   ├── FactoryPattern.cs
│   │   ├── GenericClass.cs
│   │   ├── ITestInterface.cs
│   │   ├── ImplicitInterface.cs
│   │   ├── Program.cs
│   │   ├── Properties
│   │   │   ├── Resources.Designer.cs
│   │   │   └── Resources.resx
│   │   ├── TestClass.cs
│   │   └── TypeScrambler.csproj
│   ├── TypeScrambler.Test
│   │   ├── TypeScrambler.Test.csproj
│   │   └── TypeScramblerTest.cs
│   ├── VisualBasicRenamingResx
│   │   ├── My Project
│   │   │   ├── Resources.Designer.vb
│   │   │   └── Resources.resx
│   │   ├── Program.vb
│   │   └── VisualBasicRenamingResx.vbproj
│   ├── VisualBasicRenamingResx.Test
│   │   ├── RenamingTest.cs
│   │   └── VisualBasicRenamingResx.Test.csproj
│   ├── WinFormsRenaming
│   │   ├── DataBoundElement.cs
│   │   ├── DataGridViewForm.cs
│   │   └── WinFormsRenaming.csproj
│   ├── WinFormsRenaming.Test
│   │   ├── RenameDataPropertyNameTest.cs
│   │   └── WinFormsRenaming.Test.csproj
│   ├── WpfRenaming
│   │   ├── TestData.xml
│   │   ├── UserControl1.xaml
│   │   ├── UserControl1.xaml.cs
│   │   ├── UserControl1Context.cs
│   │   └── WpfRenaming.csproj
│   └── WpfRenaming.Test
│       ├── ProcessWpfTest.cs
│       └── WpfRenaming.Test.csproj
├── additional
│   ├── Icon.pdn
│   ├── Icon16.pdn
│   ├── Icon256.pdn
│   ├── Icon32.pdn
│   ├── Icon48.pdn
│   ├── Icon64.pdn
│   ├── ilspy.crproj
│   └── pdn.crproj
├── appveyor.yml
├── chocolatey-packages
│   ├── New-ChocolateyPackage.ps1
│   ├── confuserex
│   │   ├── confuserex.nuspec.template
│   │   ├── legal
│   │   │   ├── LICENSE.md
│   │   │   └── VERIFICATION.txt.template
│   │   └── tools
│   │       └── chocolateyInstall.ps1
│   └── confuserex.portable
│       ├── confuserex.portable.nuspec.template
│       ├── legal
│       │   ├── LICENSE.md
│       │   └── VERIFICATION.txt.template
│       └── tools
│           └── chocolateyInstall.ps1
├── docs
│   ├── DeclarativeObfuscation.txt
│   ├── ProjectFormat.md
│   └── docs.shfbproj
└── version.json

```

`CODE_OF_CONDUCT.md`:

```md
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
[karing.martin+confusercoc@gmail.com][coc-mail].
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
[https://www.contributor-covenant.org/version/2/0/code_of_conduct.html][v2.0].

Community Impact Guidelines were inspired by 
[Mozilla's code of conduct enforcement ladder][Mozilla CoC].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][FAQ]. Translations are available 
at [https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org
[v2.0]: https://www.contributor-covenant.org/version/2/0/code_of_conduct.html
[Mozilla CoC]: https://github.com/mozilla/diversity
[FAQ]: https://www.contributor-covenant.org/faq
[translations]: https://www.contributor-covenant.org/translations
[coc-mail]: mailto:karing.martin+confusercoc@gmail.com

```

`CONTRIBUTING.md`:

```md
# Contributing

Contributions of any kind are in general always welcome.

When contributing to this repository, please first discuss the changes you wish
to make via issue, email, discussions, or any other method with the owners of
this repository before making a change.

For contributions that contain only bugfixes or added unit tests, this
discussion is not required before hand.

Please note we have a code of conduct, please follow it in all your
interactions with the project.

## Pull Request Process

1. Ensure that only the files that are part of your change are actually part of
   the pull request. Changes in unrelated files, unrelated additional files or
   binaries have to be removed.
2. In case the pull request is created in response to a specific issue, please
   reference the issue in the description of the pull request.
3. Pull-Requests are merged once they are signed-off by one other developer
   with the permission to merge changes into the repository.

```

`Confuser.CLI/Confuser.CLI.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\ConfuserEx.Common.props" Condition="Exists('..\ConfuserEx.Common.props')" />

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  
  <PropertyGroup Label="Assembly Information">
    <Title>ConfuserEx Command-line</Title>
    <Description>Command-line interface of ConfuserEx</Description>
  </PropertyGroup>

  <ItemGroup Label="Nuget Dependencies">
    <PackageReference Include="NDesk.Options.Core" Version="1.2.5" />
  </ItemGroup>

  <ItemGroup Label="Project Dependencies">
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj" />
    <ProjectReference Include="..\Confuser.Protections\Confuser.Protections.csproj" />
    <ProjectReference Include="..\Confuser.Renamer\Confuser.Renamer.csproj" />
  </ItemGroup>
  
  <Import Project="..\ConfuserEx.Common.targets" Condition="Exists('..\ConfuserEx.Common.targets')" />

</Project>
```

`Confuser.CLI/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml;
using Confuser.Core;
using Confuser.Core.Project;
using NDesk.Options;

namespace Confuser.CLI {
	internal class Program {
		static int Main(string[] args) {
			ConsoleColor original = Console.ForegroundColor;
			Console.ForegroundColor = ConsoleColor.White;
			string originalTitle = Console.Title;
			Console.Title = "ConfuserEx";
			try {
				bool noPause = false;
				bool debug = false;
				string outDir = null;
				List<string> probePaths = new List<string>();
				List<string> plugins = new List<string>();
				var p = new OptionSet {
					{
						"n|nopause", "no pause after finishing protection.",
						value => { noPause = (value != null); }
					}, {
						"o|out=", "specifies output directory.",
						value => { outDir = value; }
					}, {
						"probe=", "specifies probe directory.",
						value => { probePaths.Add(value); }
					}, {
						"plugin=", "specifies plugin path.",
						value => { plugins.Add(value); }
					}, {
						"debug", "specifies debug symbol generation.",
						value => { debug = (value != null); }
					}
				};

				List<string> files;
				try {
					files = p.Parse(args);
					if (files.Count == 0)
						throw new ArgumentException("No input files specified.");
				}
				catch (Exception ex) {
					Console.Write("ConfuserEx.CLI: ");
					Console.WriteLine(ex.Message);
					PrintUsage();
					return -1;
				}

				var parameters = new ConfuserParameters();

				if (files.Count == 1 && Path.GetExtension(files[0]) == ".crproj") {
					var proj = new ConfuserProject();
					try {
						var xmlDoc = new XmlDocument();
						xmlDoc.Load(files[0]);
						proj.Load(xmlDoc);
						proj.BaseDirectory = Path.Combine(Path.GetDirectoryName(files[0]), proj.BaseDirectory);
					}
					catch (Exception ex) {
						WriteLineWithColor(ConsoleColor.Red, "Failed to load project:");
						WriteLineWithColor(ConsoleColor.Red, ex.ToString());
						return -1;
					}

					parameters.Project = proj;
				}
				else {
					if (string.IsNullOrEmpty(outDir)) {
						Console.WriteLine("ConfuserEx.CLI: No output directory specified.");
						PrintUsage();
						return -1;
					}

					var proj = new ConfuserProject();
					var templateModules = new List<ProjectModule>();

					if (Path.GetExtension(files[files.Count - 1]) == ".crproj") {
						LoadTemplateProject(files[files.Count - 1], proj, templateModules);
						files.RemoveAt(files.Count - 1);
					}

					// Generate a ConfuserProject for input modules
					// Assuming first file = main module
					proj.BaseDirectory = Path.GetDirectoryName(files[0]);
					if (string.IsNullOrWhiteSpace(proj.BaseDirectory)) {
						WriteLineWithColor(ConsoleColor.Red, "Failed to identify base directory for main assembly.");
						PrintUsage();
						return -1;
					}

					foreach (var input in files) {
						string modulePath = input;
						if (modulePath.StartsWith(proj.BaseDirectory, StringComparison.OrdinalIgnoreCase)) {
							modulePath = modulePath.Substring(proj.BaseDirectory.Length + 1);
						}

						if (TryMatchTemplateProject(templateModules, proj.BaseDirectory, modulePath, out var matchedModule))
							proj.Add(matchedModule);
						else
							proj.Add(new ProjectModule { Path = modulePath });
					}

					proj.OutputDirectory = outDir;
					foreach (var path in probePaths)
						proj.ProbePaths.Add(path);
					foreach (var path in plugins)
						proj.PluginPaths.Add(path);
					proj.Debug = debug;
					parameters.Project = proj;
				}

				int retVal = RunProject(parameters);

				if (NeedPause() && !noPause) {
					Console.WriteLine("Press any key to continue...");
					Console.ReadKey(true);
				}

				return retVal;
			}
			finally {
				Console.ForegroundColor = original;
				Console.Title = originalTitle;
			}
		}

		static bool TryMatchTemplateProject(List<ProjectModule> templateModules, string baseDirectory, string modulePath, out ProjectModule matchedModule) {
			var matchedToTemplate = false;
			matchedModule = null;

			foreach (var templateModule in templateModules) {
				var templatePath = templateModule.Path;
				if (templatePath.StartsWith(@".\", StringComparison.Ordinal))
					templatePath = templatePath.Substring(2);

				if (modulePath.Equals(templatePath, StringComparison.OrdinalIgnoreCase))
					matchedToTemplate = true;

				if (modulePath.Equals(Path.Combine(baseDirectory, templatePath), StringComparison.OrdinalIgnoreCase))
					matchedToTemplate = true;

				if (matchedToTemplate)
					matchedModule = templateModule;
			}

			return matchedToTemplate;
		}

		static void LoadTemplateProject(string templatePath, ConfuserProject proj, List<ProjectModule> templateModules) {
			var templateProj = new ConfuserProject();
			var xmlDoc = new XmlDocument();
			xmlDoc.Load(templatePath);
			templateProj.Load(xmlDoc);

			foreach (var rule in templateProj.Rules)
				proj.Rules.Add(rule);

			proj.Packer = templateProj.Packer;

			foreach (string pluginPath in templateProj.PluginPaths)
				proj.PluginPaths.Add(pluginPath);

			foreach (string probePath in templateProj.ProbePaths)
				proj.ProbePaths.Add(probePath);

			foreach (var templateModule in templateProj)
				if (templateModule.IsExternal)
					proj.Add(templateModule);
				else
					templateModules.Add(templateModule);
		}

		static int RunProject(ConfuserParameters parameters) {
			var logger = new ConsoleLogger();
			parameters.Logger = logger;

			Console.Title = "ConfuserEx - Running...";
			ConfuserEngine.Run(parameters).Wait();

			return logger.ReturnValue;
		}

		static bool NeedPause() {
			return Debugger.IsAttached || string.IsNullOrEmpty(Environment.GetEnvironmentVariable("PROMPT"));
		}

		static void PrintUsage() {
			WriteLine("Usage:");
			WriteLine("Confuser.CLI -n|noPause <project configuration>");
			WriteLine("Confuser.CLI -n|noPause -o|out=<output directory> <modules>");
			WriteLine("    -n|noPause : no pause after finishing protection.");
			WriteLine("    -o|out     : specifies output directory.");
			WriteLine("    -probe     : specifies probe directory.");
			WriteLine("    -plugin    : specifies plugin path.");
			WriteLine("    -debug     : specifies debug symbol generation.");
		}

		static void WriteLineWithColor(ConsoleColor color, string txt) {
			ConsoleColor original = Console.ForegroundColor;
			Console.ForegroundColor = color;
			Console.WriteLine(txt);
			Console.ForegroundColor = original;
		}

		static void WriteLine(string txt) {
			Console.WriteLine(txt);
		}

		static void WriteLine() {
			Console.WriteLine();
		}

		class ConsoleLogger : ILogger {
			readonly DateTime begin;

			public ConsoleLogger() {
				begin = DateTime.Now;
			}

			public int ReturnValue { get; private set; }

			public void Debug(string msg) {
				WriteLineWithColor(ConsoleColor.Gray, "[DEBUG] " + msg);
			}

			public void DebugFormat(string format, params object[] args) {
				WriteLineWithColor(ConsoleColor.Gray, "[DEBUG] " + string.Format(format, args));
			}

			public void Info(string msg) {
				WriteLineWithColor(ConsoleColor.White, " [INFO] " + msg);
			}

			public void InfoFormat(string format, params object[] args) {
				WriteLineWithColor(ConsoleColor.White, " [INFO] " + string.Format(format, args));
			}

			public void Warn(string msg) {
				WriteLineWithColor(ConsoleColor.Yellow, " [WARN] " + msg);
			}

			public void WarnFormat(string format, params object[] args) {
				WriteLineWithColor(ConsoleColor.Yellow, " [WARN] " + string.Format(format, args));
			}

			public void WarnException(string msg, Exception ex) {
				WriteLineWithColor(ConsoleColor.Yellow, " [WARN] " + msg);
				WriteLineWithColor(ConsoleColor.Yellow, "Exception: " + ex);
			}

			public void Error(string msg) {
				WriteLineWithColor(ConsoleColor.Red, "[ERROR] " + msg);
			}

			public void ErrorFormat(string format, params object[] args) {
				WriteLineWithColor(ConsoleColor.Red, "[ERROR] " + string.Format(format, args));
			}

			public void ErrorException(string msg, Exception ex) {
				WriteLineWithColor(ConsoleColor.Red, "[ERROR] " + msg);
				WriteLineWithColor(ConsoleColor.Red, "Exception: " + ex);
			}

			public void Progress(int progress, int overall) { }

			public void EndProgress() { }

			public void Finish(bool successful) {
				DateTime now = DateTime.Now;
				string timeString = string.Format(
					"at {0}, {1}:{2:d2} elapsed.",
					now.ToShortTimeString(),
					(int)now.Subtract(begin).TotalMinutes,
					now.Subtract(begin).Seconds);
				if (successful) {
					Console.Title = "ConfuserEx - Success";
					WriteLineWithColor(ConsoleColor.Green, "Finished " + timeString);
					ReturnValue = 0;
				}
				else {
					Console.Title = "ConfuserEx - Fail";
					WriteLineWithColor(ConsoleColor.Red, "Failed " + timeString);
					ReturnValue = 1;
				}
			}
		}
	}
}

```

`Confuser.Core/API/APIStore.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core.Services;
using dnlib.DotNet;

namespace Confuser.Core.API {
	internal class APIStore : IAPIStore {
		readonly ConfuserContext context;
		readonly RandomGenerator random;
		readonly SortedList<int, List<IDataStore>> dataStores;
		readonly List<IOpaquePredicateDescriptor> predicates;

		/// <summary>
		///     Initializes a new instance of the <see cref="APIStore" /> class.
		/// </summary>
		/// <param name="context">The working context.</param>
		public APIStore(ConfuserContext context) {
			this.context = context;
			random = context.Registry.GetService<IRandomService>().GetRandomGenerator("APIStore");

			dataStores = new SortedList<int, List<IDataStore>>();
			predicates = new List<IOpaquePredicateDescriptor>();
		}

		/// <inheritdoc />
		public void AddStore(IDataStore dataStore) {
			dataStores.AddListEntry(dataStore.Priority, dataStore);
		}

		/// <inheritdoc />
		public void AddPredicate(IOpaquePredicateDescriptor predicate) {
			predicates.Add(predicate);
		}

		/// <inheritdoc />
		public IDataStore GetStore(MethodDef method) {
			for (int i = dataStores.Count - 1; i >= 0; i--) {
				var list = dataStores[i];
				for (int j = list.Count - 1; j >= 0; j--) {
					if (list[j].IsUsable(method))
						return list[j];
				}
			}
			return null;
		}

		/// <inheritdoc />
		public IOpaquePredicateDescriptor GetPredicate(MethodDef method, OpaquePredicateType? type, params int[] argCount) {
			var randomPredicates = predicates.ToArray();
			random.Shuffle(randomPredicates);
			foreach (var predicate in randomPredicates) {
				if (predicate.IsUsable(method) &&
				    (type == null || predicate.Type == type.Value) &&
				    (argCount == null || Array.IndexOf(argCount, predicate.ArgumentCount) != -1))
					return predicate;
			}
			return null;
		}
	}

	/// <summary>
	///     Provides storage for API interfaces
	/// </summary>
	public interface IAPIStore {
		/// <summary>
		///     Adds the specified data store into this store.
		/// </summary>
		/// <param name="dataStore">The data store.</param>
		void AddStore(IDataStore dataStore);

		/// <summary>
		///     Finds a suitable data store for the specified method, with the
		///     specified number of keys.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <returns>The suitable data store if found, or <c>null</c> if not found.</returns>
		/// <remarks>
		///     It should never returns null --- ConfuserEx has internal data store.
		/// </remarks>
		IDataStore GetStore(MethodDef method);

		/// <summary>
		///     Adds the specified opaque predicate into this store.
		/// </summary>
		/// <param name="predicate">The opaque predicate.</param>
		void AddPredicate(IOpaquePredicateDescriptor predicate);

		/// <summary>
		///     Finds a suitable opaque predicate for the specified method, with the
		///     specified properties.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <param name="type">The required type of predicate, or <c>null</c> if it does not matter.</param>
		/// <param name="argCount">The required numbers of arguments, or <c>null</c> if it does not matter.</param>
		/// <returns>The suitable opaque predicate if found, or <c>null</c> if not found.</returns>
		IOpaquePredicateDescriptor GetPredicate(MethodDef method, OpaquePredicateType? type, params int[] argCount);
	}
}
```

`Confuser.Core/API/IDataStore.cs`:

```cs
using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.API {
	/// <summary>
	///     A data store.
	/// </summary>
	public interface IDataStore {
		/// <summary>
		///     Gets the priority of this data store; higher priority means it
		///     would be tried earlier.
		/// </summary>
		/// <value>The priority of this data store.</value>
		int Priority { get; }

		/// <summary>
		///     Gets the number of keys this predicate has.
		/// </summary>
		/// <remarks>
		///     Keys are used by the data store to encrypt data/whatever purpose.
		/// </remarks>
		/// <value>The number of keys this data store has.</value>
		int KeyCount { get; }

		/// <summary>
		///     Determines whether this data store can be used in the specified method.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <value><c>true</c> if this data store can be used in the specified method; otherwise, <c>false</c>.</value>
		bool IsUsable(MethodDef method);

		/// <summary>
		///     Creates an accessor of this data store for the specified method.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <param name="keys">The keys.</param>
		/// <param name="data">The data to store.</param>
		/// <returns>A newly accessor of this data store.</returns>
		IDataStoreAccessor CreateAccessor(MethodDef method, uint[] keys, byte[] data);
	}

	/// <summary>
	///     An accessor of data store.
	/// </summary>
	public interface IDataStoreAccessor {
		/// <summary>
		///     Emits the runtime instruction sequence for this accessor.
		/// </summary>
		/// <returns>An instruction sequence that returns the stored data.</returns>
		Instruction[] Emit();
	}
}
```

`Confuser.Core/API/IOpaquePredicate.cs`:

```cs
using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.API {
	/// <summary>
	///     The descriptor of a type of opaque predicate.
	/// </summary>
	public interface IOpaquePredicateDescriptor {
		/// <summary>
		///     Gets the type of the opaque predicate.
		/// </summary>
		/// <value>The type of the opaque predicate.</value>
		OpaquePredicateType Type { get; }

		/// <summary>
		///     Gets the number of arguments this predicate has.
		/// </summary>
		/// <remarks>
		///     When <see cref="IOpaquePredicateDescriptor.Type" /> is <see cref="OpaquePredicateType.Invariant" />,
		///     there can be 0 or more arguments.
		///     When <see cref="IOpaquePredicateDescriptor.Type" /> is <see cref="OpaquePredicateType.Function" />,
		///     there must be more than 0 arguments.
		/// </remarks>
		/// <value>The number of arguments this predicate has.</value>
		int ArgumentCount { get; }

		/// <summary>
		///     Determines whether this predicate can be used with the specified method.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <value><c>true</c> if this predicate can be used with the specified method; otherwise, <c>false</c>.</value>
		bool IsUsable(MethodDef method);

		/// <summary>
		///     Creates a new opaque predicate for the specified method.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <returns>A newly create opaque predicate.</returns>
		IOpaquePredicate CreatePredicate(MethodDef method);
	}

	/// <summary>
	///     An instance of opaque predicate.
	/// </summary>
	public interface IOpaquePredicate {
		/// <summary>
		///     Emits the runtime instruction sequence for this predicate.
		/// </summary>
		/// <param name="loadArg">
		///     A function that returns an instruction sequence that returns the input value,
		///     or <c>null</c> if <see cref="IOpaquePredicateDescriptor.ArgumentCount" /> is 0.
		/// </param>
		/// <returns>An instruction sequence that returns the value of this predicate.</returns>
		Instruction[] Emit(Func<Instruction[]> loadArg);

		/// <summary>
		///     Computes the value of this predicate with the specified argument.
		/// </summary>
		/// <param name="arg">The argument to this predicate.</param>
		/// <returns>The return value of this predicate.</returns>
		uint GetValue(uint[] arg);
	}

	/// <summary>
	///     The type of opaque predicate.
	/// </summary>
	public enum OpaquePredicateType {
		/// <summary>
		///     A function, in a mathematics sense, with one input and one output.
		/// </summary>
		Function,

		/// <summary>
		///     A constant function, always returning the same value.
		/// </summary>
		Invariant
	}
}
```

`Confuser.Core/Annotations.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;

namespace Confuser.Core {
	/// <summary>
	///     Provides methods to annotate objects.
	/// </summary>
	/// <remarks>
	///     The annotations are stored using <see cref="WeakReference" />
	/// </remarks>
	public class Annotations {
		readonly Dictionary<object, ListDictionary> annotations = new Dictionary<object, ListDictionary>(WeakReferenceComparer.Instance);

		/// <summary>
		///     Retrieves the annotation on the specified object associated with the specified key.
		/// </summary>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="obj">The object.</param>
		/// <param name="key">The key of annotation.</param>
		/// <param name="defValue">The default value if the specified annotation does not exists on the object.</param>
		/// <returns>The value of annotation, or default value if the annotation does not exist.</returns>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="obj" /> or <paramref name="key" /> is <c>null</c>.
		/// </exception>
		public TValue Get<TValue>(object obj, object key, TValue defValue = default(TValue)) {
			if (obj == null)
				throw new ArgumentNullException("obj");
			if (key == null)
				throw new ArgumentNullException("key");

			ListDictionary objAnno;
			if (!annotations.TryGetValue(obj, out objAnno))
				return defValue;
			if (!objAnno.Contains(key))
				return defValue;

			Type valueType = typeof(TValue);
			if (valueType.IsValueType)
				return (TValue)Convert.ChangeType(objAnno[key], typeof(TValue));
			return (TValue)objAnno[key];
		}

		/// <summary>
		///     Retrieves the annotation on the specified object associated with the specified key.
		/// </summary>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="obj">The object.</param>
		/// <param name="key">The key of annotation.</param>
		/// <param name="defValueFactory">The default value factory function.</param>
		/// <returns>The value of annotation, or default value if the annotation does not exist.</returns>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="obj" /> or <paramref name="key" /> is <c>null</c>.
		/// </exception>
		public TValue GetLazy<TValue>(object obj, object key, Func<object, TValue> defValueFactory) {
			if (obj == null)
				throw new ArgumentNullException("obj");
			if (key == null)
				throw new ArgumentNullException("key");

			ListDictionary objAnno;
			if (!annotations.TryGetValue(obj, out objAnno))
				return defValueFactory(key);
			if (!objAnno.Contains(key))
				return defValueFactory(key);

			Type valueType = typeof(TValue);
			if (valueType.IsValueType)
				return (TValue)Convert.ChangeType(objAnno[key], typeof(TValue));
			return (TValue)objAnno[key];
		}

		/// <summary>
		///     Retrieves or create the annotation on the specified object associated with the specified key.
		/// </summary>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="obj">The object.</param>
		/// <param name="key">The key of annotation.</param>
		/// <param name="factory">The factory function to create the annotation value when the annotation does not exist.</param>
		/// <returns>The value of annotation, or the newly created value.</returns>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="obj" /> or <paramref name="key" /> is <c>null</c>.
		/// </exception>
		public TValue GetOrCreate<TValue>(object obj, object key, Func<object, TValue> factory) {
			if (obj == null)
				throw new ArgumentNullException("obj");
			if (key == null)
				throw new ArgumentNullException("key");

			ListDictionary objAnno;
			if (!annotations.TryGetValue(obj, out objAnno))
				objAnno = annotations[new WeakReferenceKey(obj)] = new ListDictionary();
			TValue ret;
			if (objAnno.Contains(key)) {
				Type valueType = typeof(TValue);
				if (valueType.IsValueType)
					return (TValue)Convert.ChangeType(objAnno[key], typeof(TValue));
				return (TValue)objAnno[key];
			}
			objAnno[key] = ret = factory(key);
			return ret;
		}

		/// <summary>
		///     Sets an annotation on the specified object.
		/// </summary>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="obj">The object.</param>
		/// <param name="key">The key of annotation.</param>
		/// <param name="value">The value of annotation.</param>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="obj" /> or <paramref name="key" /> is <c>null</c>.
		/// </exception>
		public void Set<TValue>(object obj, object key, TValue value) {
			if (obj == null)
				throw new ArgumentNullException("obj");
			if (key == null)
				throw new ArgumentNullException("key");

			ListDictionary objAnno;
			if (!annotations.TryGetValue(obj, out objAnno))
				objAnno = annotations[new WeakReferenceKey(obj)] = new ListDictionary();
			objAnno[key] = value;
		}

		/// <summary>
		///     Trims the annotations of unreachable objects from this instance.
		/// </summary>
		public void Trim() {
			foreach (object key in annotations.Where(kvp => !((WeakReferenceKey)kvp.Key).IsAlive).Select(kvp => kvp.Key))
				annotations.Remove(key);
		}

		/// <summary>
		///     Equality comparer of weak references.
		/// </summary>
		class WeakReferenceComparer : IEqualityComparer<object> {
			/// <summary>
			///     The singleton instance of this comparer.
			/// </summary>
			public static readonly WeakReferenceComparer Instance = new WeakReferenceComparer();

			/// <summary>
			///     Prevents a default instance of the <see cref="WeakReferenceComparer" /> class from being created.
			/// </summary>
			WeakReferenceComparer() { }

			/// <inheritdoc />
			public new bool Equals(object x, object y) {
				if (y is WeakReferenceKey && !(x is WeakReference))
					return Equals(y, x);
				var xWeak = x as WeakReferenceKey;
				var yWeak = y as WeakReferenceKey;
				if (xWeak != null && yWeak != null) {
					return xWeak.IsAlive && yWeak.IsAlive && ReferenceEquals(xWeak.Target, yWeak.Target);
				}
				if (xWeak != null && yWeak == null) {
					return xWeak.IsAlive && ReferenceEquals(xWeak.Target, y);
				}
				if (xWeak == null && yWeak == null) {
					return xWeak.IsAlive && ReferenceEquals(xWeak.Target, y);
				}
				throw new UnreachableException();
			}

			/// <inheritdoc />
			public int GetHashCode(object obj) {
				if (obj is WeakReferenceKey)
					return ((WeakReferenceKey)obj).HashCode;
				return obj.GetHashCode();
			}
		}

		/// <summary>
		///     Represent a key using <see cref="WeakReference" />.
		/// </summary>
		class WeakReferenceKey : WeakReference {
			/// <inheritdoc />
			public WeakReferenceKey(object target)
				: base(target) {
				HashCode = target.GetHashCode();
			}

			/// <summary>
			///     Gets the hash code of the target object.
			/// </summary>
			/// <value>The hash code.</value>
			public int HashCode { get; private set; }
		}
	}
}
```

`Confuser.Core/Confuser.Core.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\ConfuserEx.Common.props" Condition="Exists('..\ConfuserEx.Common.props')" />

  <PropertyGroup Label="Assembly Settings">
    <TargetFrameworks>net461;netstandard2.0</TargetFrameworks>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>

  <PropertyGroup Label="Assembly Information">
    <Title>ConfuserEx Core</Title>
    <Description>Core framework of ConfuserEx</Description>
  </PropertyGroup>

  <ItemGroup Label="Nuget Dependencies">
    <PackageReference Include="dnlib" Version="3.5.0" />
    <PackageReference Include="Microsoft.DiaSymReader.Native" Version="1.7.0" />
    <PackageReference Include="Microsoft.Win32.Registry" Version="5.0.0" />
    <PackageReference Include="System.Threading" Version="4.3.0" />
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Include="Project\ConfuserPrj.xsd">
      <SubType>Designer</SubType>
    </EmbeddedResource>
  </ItemGroup>

  <Import Project="..\ConfuserEx.Common.targets" Condition="Exists('..\ConfuserEx.Common.targets')" />

</Project>

```

`Confuser.Core/Confuser.Core.packages.config`:

```config
<!-- 
	This file as to be present, otherwise the Microsoft.DiaSymReader.Native package does not copy it's files to the output.
	The content of this file does not matter.
-->
<appSettings />

```

`Confuser.Core/ConfuserAssemblyResolver.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;

namespace Confuser.Core {
	internal sealed class ConfuserAssemblyResolver : IAssemblyResolver {
		internal AssemblyResolver InternalFuzzyResolver { get; } = new AssemblyResolver { FindExactMatch = false };
		internal AssemblyResolver InternalExactResolver { get; } = new AssemblyResolver { FindExactMatch = true };

		public bool EnableTypeDefCache {
			get => InternalFuzzyResolver.EnableTypeDefCache;
			set {
				InternalFuzzyResolver.EnableTypeDefCache = value;
				InternalExactResolver.EnableTypeDefCache = value;
			}
		}

		public ModuleContext DefaultModuleContext {
			get => InternalFuzzyResolver.DefaultModuleContext;
			set {
				InternalFuzzyResolver.DefaultModuleContext = value;
				InternalExactResolver.DefaultModuleContext = value;
			}
		}

		public IList<string> PostSearchPaths => new TeeList(InternalFuzzyResolver.PostSearchPaths, InternalExactResolver.PostSearchPaths);
		public IList<string> PreSearchPaths => new TeeList(InternalFuzzyResolver.PreSearchPaths, InternalExactResolver.PreSearchPaths);

		/// <inheritdoc />
		public AssemblyDef Resolve(IAssembly assembly, ModuleDef sourceModule) {
			if (assembly is AssemblyDef assemblyDef)
				return assemblyDef;

			var resolvedAssemblyDef = InternalExactResolver.Resolve(assembly, sourceModule);
			return resolvedAssemblyDef ?? InternalFuzzyResolver.Resolve(assembly, sourceModule);
		}

		public void Clear() {
			InternalExactResolver.Clear();
			InternalFuzzyResolver.Clear();
		}

		public IEnumerable<AssemblyDef> GetCachedAssemblies() => 
			InternalExactResolver.GetCachedAssemblies().Concat(InternalFuzzyResolver.GetCachedAssemblies());

		public void AddToCache(ModuleDefMD modDef) {
			InternalExactResolver.AddToCache(modDef);
			InternalFuzzyResolver.AddToCache(modDef);
		}

		private sealed class TeeList : IList<string> {
			private readonly IList<IList<string>> _lists;

			internal TeeList(params IList<string>[] lists) => _lists = lists;

			/// <inheritdoc />
			public IEnumerator<string> GetEnumerator() => _lists[0].GetEnumerator();

			/// <inheritdoc />
			IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

			/// <inheritdoc />
			public void Add(string item) {
				foreach (var list in _lists) 
					list.Add(item);
			}

			/// <inheritdoc />
			public void Clear() {
				foreach (var list in _lists) 
					list.Clear();
			}

			/// <inheritdoc />
			public bool Contains(string item) => _lists[0].Contains(item);

			/// <inheritdoc />
			public void CopyTo(string[] array, int arrayIndex) => _lists[0].CopyTo(array, arrayIndex);

			/// <inheritdoc />
			public bool Remove(string item) =>
				_lists.Aggregate(true, (current, list) => current | list.Remove(item));

			/// <inheritdoc />
			public int Count => _lists[0].Count;

			/// <inheritdoc />
			public bool IsReadOnly => _lists[0].IsReadOnly;

			/// <inheritdoc />
			public int IndexOf(string item) => _lists[0].IndexOf(item);

			/// <inheritdoc />
			public void Insert(int index, string item) {
				foreach (var list in _lists) 
					list.Insert(index, item);
			}

			/// <inheritdoc />
			public void RemoveAt(int index) {
				foreach (var list in _lists) 
					list.RemoveAt(index);
			}

			/// <inheritdoc />
			public string this[int index] {
				get => _lists[0][index];
				set => _lists[0][index] = value;
			}
		}
	}
}

```

`Confuser.Core/ConfuserComponent.cs`:

```cs
using System;

namespace Confuser.Core {
	/// <summary>
	///     Represent a component in Confuser
	/// </summary>
	public abstract class ConfuserComponent {
		/// <summary>
		///     Gets the name of component.
		/// </summary>
		/// <value>The name of component.</value>
		public abstract string Name { get; }

		/// <summary>
		///     Gets the description of component.
		/// </summary>
		/// <value>The description of component.</value>
		public abstract string Description { get; }

		/// <summary>
		///     Gets the identifier of component used by users.
		/// </summary>
		/// <value>The identifier of component.</value>
		public abstract string Id { get; }

		/// <summary>
		///     Gets the full identifier of component used in Confuser.
		/// </summary>
		/// <value>The full identifier of component.</value>
		public abstract string FullId { get; }

		/// <summary>
		///     Initializes the component.
		/// </summary>
		/// <param name="context">The working context.</param>
		protected internal abstract void Initialize(ConfuserContext context);

		/// <summary>
		///     Inserts protection stages into processing pipeline.
		/// </summary>
		/// <param name="pipeline">The processing pipeline.</param>
		protected internal abstract void PopulatePipeline(ProtectionPipeline pipeline);
	}
}
```

`Confuser.Core/ConfuserContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading;
using Confuser.Core.Project;
using dnlib.DotNet;
using dnlib.DotNet.Writer;

namespace Confuser.Core {
	/// <summary>
	///     Context providing information on the current protection process.
	/// </summary>
	public class ConfuserContext {
		readonly Annotations annotations = new Annotations();
		readonly ServiceRegistry registry = new ServiceRegistry();
		internal CancellationToken token;

		/// <summary>
		///     Gets the logger used for logging events.
		/// </summary>
		/// <value>The logger.</value>
		public ILogger Logger { get; internal set; }

		/// <summary>
		///     Gets the project being processed.
		/// </summary>
		/// <value>The project.</value>
		public ConfuserProject Project { get; internal set; }

		internal bool PackerInitiated { get; set; }

		/// <summary>
		///     Gets the annotation storage.
		/// </summary>
		/// <value>The annotation storage.</value>
		public Annotations Annotations {
			get { return annotations; }
		}

		/// <summary>
		///     Gets the service registry.
		/// </summary>
		/// <value>The service registry.</value>
		public ServiceRegistry Registry {
			get { return registry; }
		}

		/// <summary>
		///     Gets the assembly resolver.
		/// </summary>
		/// <value>The assembly resolver.</value>
		public IAssemblyResolver Resolver => InternalResolver;

		/// <summary>
		///     Gets the assembly resolver.
		/// </summary>
		/// <value>The assembly resolver.</value>
		internal ConfuserAssemblyResolver InternalResolver { get; set; }

		/// <summary>
		///     Gets the modules being protected.
		/// </summary>
		/// <value>The modules being protected.</value>
		public IList<ModuleDefMD> Modules { get; internal set; }

		/// <summary>
		///     Gets the external modules.
		/// </summary>
		/// <value>The external modules.</value>
		public IList<byte[]> ExternalModules { get; internal set; }

		/// <summary>
		///     Gets the base directory.
		/// </summary>
		/// <value>The base directory.</value>
		public string BaseDirectory { get; internal set; }

		/// <summary>
		///     Gets the output directory.
		/// </summary>
		/// <value>The output directory.</value>
		public string OutputDirectory { get; internal set; }

		/// <summary>
		///     Gets the packer.
		/// </summary>
		/// <value>The packer.</value>
		public Packer Packer { get; internal set; }

		/// <summary>
		///     Gets the current processing pipeline.
		/// </summary>
		/// <value>The processing pipeline.</value>
		public ProtectionPipeline Pipeline { get; internal set; }

		/// <summary>
		///     Gets the <c>byte[]</c> of modules after protected, or null if module is not protected yet.
		/// </summary>
		/// <value>The list of <c>byte[]</c> of protected modules.</value>
		public IList<byte[]> OutputModules { get; internal set; }

		/// <summary>
		///     Gets the <c>byte[]</c> of module debug symbols after protected, or null if module is not protected yet.
		/// </summary>
		/// <value>The list of <c>byte[]</c> of module debug symbols.</value>
		public IList<byte[]> OutputSymbols { get; internal set; }

		/// <summary>
		///     Gets the relative output paths of module, or null if module is not protected yet.
		/// </summary>
		/// <value>The relative output paths of protected modules.</value>
		public IList<string> OutputPaths { get; internal set; }

		/// <summary>
		///     Gets the current module index.
		/// </summary>
		/// <value>The current module index.</value>
		public int CurrentModuleIndex { get; internal set; }

		/// <summary>
		///     Gets the current module.
		/// </summary>
		/// <value>The current module.</value>
		public ModuleDefMD CurrentModule {
			get { return CurrentModuleIndex == -1 ? null : Modules[CurrentModuleIndex]; }
		}

		/// <summary>
		///     Gets the writer options of the current module.
		/// </summary>
		/// <value>The writer options.</value>
		public ModuleWriterOptionsBase CurrentModuleWriterOptions { get; internal set; }

		/// <summary>
		///     Gets output <c>byte[]</c> of the current module
		/// </summary>
		/// <value>The output <c>byte[]</c>.</value>
		public byte[] CurrentModuleOutput { get; internal set; }

		/// <summary>
		///     Gets output <c>byte[]</c> debug symbol of the current module
		/// </summary>
		/// <value>The output <c>byte[]</c> debug symbol.</value>
		public byte[] CurrentModuleSymbol { get; internal set; }

		/// <summary>
		///		Gets the token used to indicate cancellation
		/// </summary>
		public CancellationToken CancellationToken { get { return token; } }

		/// <summary>
		///     Throws a System.OperationCanceledException if protection process has been canceled.
		/// </summary>
		/// <exception cref="OperationCanceledException">
		///     The protection process is canceled.
		/// </exception>
		public void CheckCancellation() {
			token.ThrowIfCancellationRequested();
		}

		/// <summary>
		///     Requests the current module to be written as mix-mode module, and return the native writer options.
		/// </summary>
		/// <returns>The native writer options.</returns>
		public NativeModuleWriterOptions RequestNative(bool optimizeImageSize) {
			if (CurrentModule == null)
				return null;
			if (CurrentModuleWriterOptions == null)
				CurrentModuleWriterOptions = new NativeModuleWriterOptions(CurrentModule, optimizeImageSize);
			
			// Clone the current options to the new options
			var newOptions = new NativeModuleWriterOptions(CurrentModule, optimizeImageSize) {
				AddCheckSum = CurrentModuleWriterOptions.AddCheckSum,
				AddMvidSection = CurrentModuleWriterOptions.AddMvidSection,
				Cor20HeaderOptions = CurrentModuleWriterOptions.Cor20HeaderOptions,
				GetPdbContentId = CurrentModuleWriterOptions.GetPdbContentId,
				Logger = CurrentModuleWriterOptions.Logger,
				MetadataLogger = CurrentModuleWriterOptions.MetadataLogger,
				MetadataOptions = CurrentModuleWriterOptions.MetadataOptions,
				ModuleKind = CurrentModuleWriterOptions.ModuleKind,
				NoWin32Resources = CurrentModuleWriterOptions.NoWin32Resources,
				PdbChecksumAlgorithm = CurrentModuleWriterOptions.PdbChecksumAlgorithm,
				PdbFileName = CurrentModuleWriterOptions.PdbFileName,
				PdbFileNameInDebugDirectory = CurrentModuleWriterOptions.PdbFileNameInDebugDirectory,
				PdbOptions = CurrentModuleWriterOptions.PdbOptions,
				PdbStream = CurrentModuleWriterOptions.PdbStream,
				PEHeadersOptions = CurrentModuleWriterOptions.PEHeadersOptions,
				ShareMethodBodies = CurrentModuleWriterOptions.ShareMethodBodies,
				DelaySign = CurrentModuleWriterOptions.DelaySign,
				StrongNameKey = CurrentModuleWriterOptions.StrongNameKey,
				StrongNamePublicKey = CurrentModuleWriterOptions.StrongNamePublicKey,
				Win32Resources = CurrentModuleWriterOptions.Win32Resources,
				WritePdb = CurrentModuleWriterOptions.WritePdb,
			};
			CurrentModuleWriterOptions = newOptions;
			return newOptions;
		}
	}
}

```

`Confuser.Core/ConfuserEngine.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Confuser.Core.Project;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using Microsoft.Win32;
using InformationalAttribute = System.Reflection.AssemblyInformationalVersionAttribute;
using ProductAttribute = System.Reflection.AssemblyProductAttribute;
using CopyrightAttribute = System.Reflection.AssemblyCopyrightAttribute;
using MethodAttributes = dnlib.DotNet.MethodAttributes;
using MethodImplAttributes = dnlib.DotNet.MethodImplAttributes;
using TypeAttributes = dnlib.DotNet.TypeAttributes;

namespace Confuser.Core {
	/// <summary>
	///     The processing engine of ConfuserEx.
	/// </summary>
	public static class ConfuserEngine {
		/// <summary>
		///     The version of ConfuserEx.
		/// </summary>
		public static readonly string Version;

		static readonly string Copyright;

		static ConfuserEngine() {
			Assembly assembly = typeof(ConfuserEngine).Assembly;
			var nameAttr = (ProductAttribute)assembly.GetCustomAttributes(typeof(ProductAttribute), false)[0];
			var verAttr = (InformationalAttribute)assembly.GetCustomAttributes(typeof(InformationalAttribute), false)[0];
			var cpAttr = (CopyrightAttribute)assembly.GetCustomAttributes(typeof(CopyrightAttribute), false)[0];
			Version = string.Format("{0} {1}", nameAttr.Product, verAttr.InformationalVersion);
			Copyright = cpAttr.Copyright;

			AppDomain.CurrentDomain.AssemblyResolve += (sender, e) => {
				try {
					var asmName = new AssemblyName(e.Name);
					foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
						if (asm.GetName().Name == asmName.Name)
							return asm;
					return null;
				}
				catch {
					return null;
				}
			};
		}

		/// <summary>
		///     Runs the engine with the specified parameters.
		/// </summary>
		/// <param name="parameters">The parameters.</param>
		/// <param name="token">The token used for cancellation.</param>
		/// <returns>Task to run the engine.</returns>
		/// <exception cref="System.ArgumentNullException">
		///     <paramref name="parameters" />.Project is <c>null</c>.
		/// </exception>
		public static Task Run(ConfuserParameters parameters, CancellationToken? token = null) {
			if (parameters.Project == null)
				throw new ArgumentNullException("parameters");
			if (token == null)
				token = new CancellationTokenSource().Token;
			return Task.Factory.StartNew(() => RunInternal(parameters, token.Value), token.Value);
		}

		/// <summary>
		///     Runs the engine.
		/// </summary>
		/// <param name="parameters">The parameters.</param>
		/// <param name="token">The cancellation token.</param>
		static void RunInternal(ConfuserParameters parameters, CancellationToken token) {
			// 1. Setup context
			var context = new ConfuserContext();
			context.Logger = parameters.GetLogger();
			context.Project = parameters.Project.Clone();
			context.PackerInitiated = parameters.PackerInitiated;
			context.token = token;

			PrintInfo(context);

			bool ok = false;
			try {
				// Enable watermarking by default
				context.Project.Rules.Insert(0, new Rule {
					new SettingItem<Protection>(WatermarkingProtection._Id)
				});

				var asmResolver = new ConfuserAssemblyResolver {EnableTypeDefCache = true};
				asmResolver.DefaultModuleContext = new ModuleContext(asmResolver);
				context.InternalResolver = asmResolver;
				context.BaseDirectory = Path.Combine(Environment.CurrentDirectory, context.Project.BaseDirectory.TrimEnd(Path.DirectorySeparatorChar) + Path.DirectorySeparatorChar);
				context.OutputDirectory = Path.Combine(context.Project.BaseDirectory, context.Project.OutputDirectory.TrimEnd(Path.DirectorySeparatorChar) + Path.DirectorySeparatorChar);
				foreach (string probePath in context.Project.ProbePaths)
					asmResolver.PostSearchPaths.Insert(0, Path.Combine(context.BaseDirectory, probePath));

				context.CheckCancellation();

				Marker marker = parameters.GetMarker();

				// 2. Discover plugins
				context.Logger.Debug("Discovering plugins...");

				IList<Protection> prots;
				IList<Packer> packers;
				IList<ConfuserComponent> components;
				parameters.GetPluginDiscovery().GetPlugins(context, out prots, out packers, out components);

				context.Logger.InfoFormat("Discovered {0} protections, {1} packers.", prots.Count, packers.Count);

				context.CheckCancellation();

				// 3. Resolve dependency
				context.Logger.Debug("Resolving component dependency...");
				try {
					var resolver = new DependencyResolver(prots);
					prots = resolver.SortDependency();
				}
				catch (CircularDependencyException ex) {
					context.Logger.ErrorException("", ex);
					throw new ConfuserException(ex);
				}

				components.Insert(0, new CoreComponent(context, marker));
				foreach (Protection prot in prots)
					components.Add(prot);
				foreach (Packer packer in packers)
					components.Add(packer);

				context.CheckCancellation();

				// 4. Load modules
				context.Logger.Info("Loading input modules...");
				marker.Initalize(prots, packers);
				MarkerResult markings = marker.MarkProject(context.Project, context);
				context.Modules = new ModuleSorter(markings.Modules).Sort().ToList().AsReadOnly();
				foreach (var module in context.Modules)
					module.EnableTypeDefFindCache = false;
				context.OutputModules = Enumerable.Repeat<byte[]>(null, context.Modules.Count).ToArray();
				context.OutputSymbols = Enumerable.Repeat<byte[]>(null, context.Modules.Count).ToArray();
				context.OutputPaths = Enumerable.Repeat<string>(null, context.Modules.Count).ToArray();
				context.Packer = markings.Packer;
				context.ExternalModules = markings.ExternalModules;

				context.CheckCancellation();

				// 5. Initialize components
				context.Logger.Info("Initializing...");
				foreach (ConfuserComponent comp in components) {
					try {
						comp.Initialize(context);
					}
					catch (Exception ex) {
						context.Logger.ErrorException("Error occured during initialization of '" + comp.Name + "'.", ex);
						throw new ConfuserException(ex);
					}
					context.CheckCancellation();
				}

				context.CheckCancellation();

				// 6. Build pipeline
				context.Logger.Debug("Building pipeline...");
				var pipeline = new ProtectionPipeline();
				context.Pipeline = pipeline;
				foreach (ConfuserComponent comp in components) {
					comp.PopulatePipeline(pipeline);
				}

				context.CheckCancellation();

				//7. Run pipeline
				RunPipeline(pipeline, context);

				ok = true;
			}
			catch (AssemblyResolveException ex) {
				context.Logger.ErrorException("Failed to resolve an assembly, check if all dependencies are present in the correct version.", ex);
				PrintEnvironmentInfo(context);
			}
			catch (TypeResolveException ex) {
				context.Logger.ErrorException("Failed to resolve a type, check if all dependencies are present in the correct version.", ex);
				PrintEnvironmentInfo(context);
			}
			catch (MemberRefResolveException ex) {
				context.Logger.ErrorException("Failed to resolve a member, check if all dependencies are present in the correct version.", ex);
				PrintEnvironmentInfo(context);
			}
			catch (IOException ex) {
				context.Logger.ErrorException("An IO error occurred, check if all input/output locations are readable/writable.", ex);
			}
			catch (OperationCanceledException) {
				context.Logger.Error("Operation cancelled.");
			}
			catch (ConfuserException) {
				// Exception is already handled/logged, so just ignore and report failure
			}
			catch (Exception ex) {
				context.Logger.ErrorException("Unknown error occurred.", ex);
			}
			finally {
				if (context.Resolver != null)
					context.InternalResolver.Clear();
				context.Logger.Finish(ok);
			}
		}

		/// <summary>
		///     Runs the protection pipeline.
		/// </summary>
		/// <param name="pipeline">The protection pipeline.</param>
		/// <param name="context">The context.</param>
		static void RunPipeline(ProtectionPipeline pipeline, ConfuserContext context) {
			Func<IList<IDnlibDef>> getAllDefs = () => context.Modules.SelectMany(module => module.FindDefinitions()).ToList();
			Func<ModuleDef, IList<IDnlibDef>> getModuleDefs = module => module.FindDefinitions().ToList();

			context.CurrentModuleIndex = -1;

			pipeline.ExecuteStage(PipelineStage.Inspection, Inspection, () => getAllDefs(), context);

			var options = new ModuleWriterOptionsBase[context.Modules.Count];
			for (int i = 0; i < context.Modules.Count; i++) {
				context.CurrentModuleIndex = i;
				context.CurrentModuleWriterOptions = null;

				pipeline.ExecuteStage(PipelineStage.BeginModule, BeginModule, () => getModuleDefs(context.CurrentModule), context);
				pipeline.ExecuteStage(PipelineStage.ProcessModule, ProcessModule, () => getModuleDefs(context.CurrentModule), context);
				pipeline.ExecuteStage(PipelineStage.OptimizeMethods, OptimizeMethods, () => getModuleDefs(context.CurrentModule), context);
				pipeline.ExecuteStage(PipelineStage.EndModule, EndModule, () => getModuleDefs(context.CurrentModule), context);

				options[i] = context.CurrentModuleWriterOptions;
			}

			for (int i = 0; i < context.Modules.Count; i++) {
				context.CurrentModuleIndex = i;
				context.CurrentModuleWriterOptions = options[i];

				pipeline.ExecuteStage(PipelineStage.WriteModule, WriteModule, () => getModuleDefs(context.CurrentModule), context);

				context.OutputModules[i] = context.CurrentModuleOutput;
				context.OutputSymbols[i] = context.CurrentModuleSymbol;
				context.CurrentModuleWriterOptions = null;
				context.CurrentModuleOutput = null;
				context.CurrentModuleSymbol = null;
			}

			context.CurrentModuleIndex = -1;

			pipeline.ExecuteStage(PipelineStage.Debug, Debug, () => getAllDefs(), context);
			pipeline.ExecuteStage(PipelineStage.Pack, Pack, () => getAllDefs(), context);
			pipeline.ExecuteStage(PipelineStage.SaveModules, SaveModules, () => getAllDefs(), context);

			if (!context.PackerInitiated)
				context.Logger.Info("Done.");
		}

		static void Inspection(ConfuserContext context) {
			context.Logger.Info("Resolving dependencies...");
			foreach (var dependency in context.Modules
											  .SelectMany(module => module.GetAssemblyRefs().Select(asmRef => Tuple.Create(asmRef, module)))) {
				try {
					context.Resolver.ResolveThrow(dependency.Item1, dependency.Item2);
				}
				catch (AssemblyResolveException ex) {
					context.Logger.ErrorException("Failed to resolve dependency of '" + dependency.Item2.Name + "'.", ex);
					throw new ConfuserException(ex);
				}
			}

			context.Logger.Debug("Checking Strong Name...");
			foreach (var module in context.Modules) {
				CheckStrongName(context, module);
			}

			var marker = context.Registry.GetService<IMarkerService>();

			context.Logger.Debug("Creating global .cctors...");
			foreach (ModuleDefMD module in context.Modules) {
				TypeDef modType = module.GlobalType;
				if (modType == null) {
					modType = new TypeDefUser("", "<Module>", null);
					modType.Attributes = TypeAttributes.AnsiClass;
					module.Types.Add(modType);
					marker.Mark(modType, null);
				}
				MethodDef cctor = modType.FindOrCreateStaticConstructor();
				if (!marker.IsMarked(cctor))
					marker.Mark(cctor, null);
			}
		}

		static void CheckStrongName(ConfuserContext context, ModuleDef module) {
			var snKey = context.Annotations.Get<StrongNameKey>(module, Marker.SNKey);
			var snPubKeyBytes = context.Annotations.Get<StrongNamePublicKey>(module, Marker.SNPubKey)?.CreatePublicKey();
			var snDelaySign = context.Annotations.Get<bool>(module, Marker.SNDelaySig);

			if (snPubKeyBytes == null && snKey != null)
				snPubKeyBytes = snKey.PublicKey;

			bool moduleIsSignedOrDelayedSigned = module.IsStrongNameSigned || !module.Assembly.PublicKey.IsNullOrEmpty;

			bool isKeyProvided = snKey != null || (snDelaySign && snPubKeyBytes != null);

			if (!isKeyProvided && moduleIsSignedOrDelayedSigned)
				context.Logger.WarnFormat("[{0}] SN Key or SN public Key is not provided for a signed module, the output may not be working.", module.Name);
			else if (isKeyProvided && !moduleIsSignedOrDelayedSigned)
				context.Logger.WarnFormat("[{0}] SN Key or SN public Key is provided for an unsigned module, the output may not be working.", module.Name);
			else if (snPubKeyBytes != null && moduleIsSignedOrDelayedSigned &&
			         !module.Assembly.PublicKey.Data.SequenceEqual(snPubKeyBytes))
				context.Logger.WarnFormat("[{0}] Provided SN public Key and signed module's public key do not match, the output may not be working.",
					module.Name);
		}

		static void CopyPEHeaders(PEHeadersOptions writerOptions, ModuleDefMD module) {
			var image = module.Metadata.PEImage;
			writerOptions.MajorImageVersion = image.ImageNTHeaders.OptionalHeader.MajorImageVersion;
			writerOptions.MajorLinkerVersion = image.ImageNTHeaders.OptionalHeader.MajorLinkerVersion;
			writerOptions.MajorOperatingSystemVersion = image.ImageNTHeaders.OptionalHeader.MajorOperatingSystemVersion;
			writerOptions.MajorSubsystemVersion = image.ImageNTHeaders.OptionalHeader.MajorSubsystemVersion;
			writerOptions.MinorImageVersion = image.ImageNTHeaders.OptionalHeader.MinorImageVersion;
			writerOptions.MinorLinkerVersion = image.ImageNTHeaders.OptionalHeader.MinorLinkerVersion;
			writerOptions.MinorOperatingSystemVersion = image.ImageNTHeaders.OptionalHeader.MinorOperatingSystemVersion;
			writerOptions.MinorSubsystemVersion = image.ImageNTHeaders.OptionalHeader.MinorSubsystemVersion;
		}

		static void BeginModule(ConfuserContext context) {
			context.Logger.InfoFormat("Processing module '{0}'...", context.CurrentModule.Name);

			context.CurrentModuleWriterOptions = new ModuleWriterOptions(context.CurrentModule);
			CopyPEHeaders(context.CurrentModuleWriterOptions.PEHeadersOptions, context.CurrentModule);

			if (!context.CurrentModule.IsILOnly || context.CurrentModule.VTableFixups != null)
				context.RequestNative(true);

			var snKey = context.Annotations.Get<StrongNameKey>(context.CurrentModule, Marker.SNKey);
			var snPubKey = context.Annotations.Get<StrongNamePublicKey>(context.CurrentModule, Marker.SNPubKey);
			var snSigKey = context.Annotations.Get<StrongNameKey>(context.CurrentModule, Marker.SNSigKey);
			var snSigPubKey = context.Annotations.Get<StrongNamePublicKey>(context.CurrentModule, Marker.SNSigPubKey);

			var snDelaySig = context.Annotations.Get<bool>(context.CurrentModule, Marker.SNDelaySig, false);

			context.CurrentModuleWriterOptions.DelaySign = snDelaySig;

			if (snKey != null && snPubKey != null && snSigKey != null && snSigPubKey != null)
				context.CurrentModuleWriterOptions.InitializeEnhancedStrongNameSigning(context.CurrentModule, snSigKey, snSigPubKey, snKey, snPubKey);
			else if (snSigPubKey != null && snSigKey != null)
				context.CurrentModuleWriterOptions.InitializeEnhancedStrongNameSigning(context.CurrentModule, snSigKey, snSigPubKey);
			else
				context.CurrentModuleWriterOptions.InitializeStrongNameSigning(context.CurrentModule, snKey);

			if (snDelaySig) {
				context.CurrentModuleWriterOptions.StrongNamePublicKey = snPubKey;
				context.CurrentModuleWriterOptions.StrongNameKey = null;
			}

			foreach (TypeDef type in context.CurrentModule.GetTypes())
				foreach (MethodDef method in type.Methods) {
					if (method.Body != null) {
						method.Body.Instructions.SimplifyMacros(method.Body.Variables, method.Parameters);
					}
				}
		}

		static void ProcessModule(ConfuserContext context) => 
			context.CurrentModuleWriterOptions.WriterEvent += (sender, e) => context.CheckCancellation();

		static void OptimizeMethods(ConfuserContext context) {
			foreach (TypeDef type in context.CurrentModule.GetTypes())
				foreach (MethodDef method in type.Methods) {
					if (method.Body != null)
						method.Body.Instructions.OptimizeMacros();
				}
		}

		static void EndModule(ConfuserContext context) {
			string output = context.Modules[context.CurrentModuleIndex].Location;
			if (!(output is null)) {
				if (!Path.IsPathRooted(output))
					output = Path.Combine(context.BaseDirectory, output);
				string relativeOutput = Utils.GetRelativePath(output, context.BaseDirectory);
				if (relativeOutput is null) {
					context.Logger.WarnFormat("Input file is not inside the base directory. Relative path can't be created. Placing file into output root." +
						Environment.NewLine + "Responsible file is: {0}", output);
					output = Path.GetFileName(output);
				} else {
					output = relativeOutput;
				}
			}
			else {
				output = context.CurrentModule.Name;
			}
			context.OutputPaths[context.CurrentModuleIndex] = output;
		}

		static void WriteModule(ConfuserContext context) {
			context.Logger.InfoFormat("Writing module '{0}'...", context.CurrentModule.Name);

			MemoryStream pdb = null, output = new MemoryStream();

			if (context.CurrentModule.PdbState != null) {
				pdb = new MemoryStream();
				context.CurrentModuleWriterOptions.WritePdb = true;
				context.CurrentModuleWriterOptions.PdbFileName = Path.ChangeExtension(Path.GetFileName(context.OutputPaths[context.CurrentModuleIndex]), "pdb");
				context.CurrentModuleWriterOptions.PdbStream = pdb;
			}

			if (context.CurrentModuleWriterOptions is ModuleWriterOptions)
				context.CurrentModule.Write(output, (ModuleWriterOptions)context.CurrentModuleWriterOptions);
			else
				context.CurrentModule.NativeWrite(output, (NativeModuleWriterOptions)context.CurrentModuleWriterOptions);

			context.CurrentModuleOutput = output.ToArray();
			if (context.CurrentModule.PdbState != null)
				context.CurrentModuleSymbol = pdb.ToArray();
		}

		static void Debug(ConfuserContext context) {
			context.Logger.Info("Finalizing...");
			for (int i = 0; i < context.OutputModules.Count; i++) {
				if (context.OutputSymbols[i] == null)
					continue;
				string path = Path.GetFullPath(Path.Combine(context.OutputDirectory, context.OutputPaths[i]));
				string dir = Path.GetDirectoryName(path);
				if (!Directory.Exists(dir))
					Directory.CreateDirectory(dir);
				File.WriteAllBytes(Path.ChangeExtension(path, "pdb"), context.OutputSymbols[i]);
			}
		}

		static void Pack(ConfuserContext context) {
			if (context.Packer != null) {
				context.Logger.Info("Packing...");
				context.Packer.Pack(context, new ProtectionParameters(context.Packer, context.Modules.OfType<IDnlibDef>().ToList()));
			}
		}

		static void SaveModules(ConfuserContext context) {
			context.InternalResolver.Clear();
			for (int i = 0; i < context.OutputModules.Count; i++) {
				string path = Path.GetFullPath(Path.Combine(context.OutputDirectory, context.OutputPaths[i]));
				string dir = Path.GetDirectoryName(path);
				if (!Directory.Exists(dir))
					Directory.CreateDirectory(dir);
				context.Logger.DebugFormat("Saving to '{0}'...", path);
				File.WriteAllBytes(path, context.OutputModules[i]);
			}
		}

		/// <summary>
		///     Prints the copyright stuff and environment information.
		/// </summary>
		/// <param name="context">The working context.</param>
		static void PrintInfo(ConfuserContext context) {
			if (context.PackerInitiated) {
				context.Logger.Info("Protecting packer stub...");
			}
			else {
				context.Logger.InfoFormat("{0} {1}", Version, Copyright);

				Type mono = Type.GetType("Mono.Runtime");
				context.Logger.InfoFormat("Running on {0}, {1}, {2} bits",
										  Environment.OSVersion,
										  mono == null ?
											  ".NET Framework v" + Environment.Version :
											  mono.GetMethod("GetDisplayName", BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, null),
										  IntPtr.Size * 8);
			}
		}

		static IEnumerable<string> GetFrameworkVersions() {
			// http://msdn.microsoft.com/en-us/library/hh925568.aspx

			using (RegistryKey ndpKey =
				RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "").
							OpenSubKey(@"SOFTWARE\Microsoft\NET Framework Setup\NDP\")) {
				foreach (string versionKeyName in ndpKey.GetSubKeyNames()) {
					if (!versionKeyName.StartsWith("v"))
						continue;

					RegistryKey versionKey = ndpKey.OpenSubKey(versionKeyName);
					var name = (string)versionKey.GetValue("Version", "");
					string sp = versionKey.GetValue("SP", "").ToString();
					string install = versionKey.GetValue("Install", "").ToString();
					if (install == "" || sp != "" && install == "1")
						yield return versionKeyName + "  " + name;

					if (name != "")
						continue;

					foreach (string subKeyName in versionKey.GetSubKeyNames()) {
						RegistryKey subKey = versionKey.OpenSubKey(subKeyName);
						name = (string)subKey.GetValue("Version", "");
						if (name != "")
							sp = subKey.GetValue("SP", "").ToString();
						install = subKey.GetValue("Install", "").ToString();

						if (install == "")
							yield return versionKeyName + "  " + name;
						else if (install == "1")
							yield return "  " + subKeyName + "  " + name;
					}
				}
			}

			using (RegistryKey ndpKey =
				RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "").
							OpenSubKey(@"SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\")) {
				if (ndpKey.GetValue("Release") == null)
					yield break;
				var releaseKey = (int)ndpKey.GetValue("Release");
				yield return "v4.5 " + releaseKey;
			}
		}

		/// <summary>
		///     Prints the environment information when error occurred.
		/// </summary>
		/// <param name="context">The working context.</param>
		static void PrintEnvironmentInfo(ConfuserContext context) {
			if (context.PackerInitiated)
				return;

			context.Logger.Error("---BEGIN DEBUG INFO---");

			context.Logger.Error("Installed Framework Versions:");
			foreach (string ver in GetFrameworkVersions()) {
				context.Logger.ErrorFormat("    {0}", ver.Trim());
			}
			context.Logger.Error("");

			if (context.Resolver != null) {
				context.Logger.Error("Cached assemblies:");
				foreach (AssemblyDef asm in context.InternalResolver.GetCachedAssemblies()) {
					if (string.IsNullOrEmpty(asm.ManifestModule.Location))
						context.Logger.ErrorFormat("    {0}", asm.FullName);
					else
						context.Logger.ErrorFormat("    {0} ({1})", asm.FullName, asm.ManifestModule.Location);
					foreach (var reference in asm.Modules.OfType<ModuleDefMD>().SelectMany(m => m.GetAssemblyRefs()))
						context.Logger.ErrorFormat("        {0}", reference.FullName);
				}
			}

			context.Logger.Error("---END DEBUG INFO---");
		}
	}
}

```

`Confuser.Core/ConfuserException.cs`:

```cs
using System;

namespace Confuser.Core {
	/// <summary>
	///     The exception that is thrown when a handled error occurred during the protection process.
	/// </summary>
	public class ConfuserException : Exception {
		public ConfuserException() : this(null) { }

		/// <summary>
		///     Initializes a new instance of the <see cref="ConfuserException" /> class.
		/// </summary>
		/// <param name="innerException">The inner exception, or null if no exception is associated with the error.</param>
		public ConfuserException(Exception innerException)
			: base("Exception occurred during the protection process.", innerException) { }
	}
}

```

`Confuser.Core/ConfuserParameters.cs`:

```cs
using System;
using Confuser.Core.Project;

namespace Confuser.Core {
	/// <summary>
	///     Parameters that passed to <see cref="ConfuserEngine" />.
	/// </summary>
	public class ConfuserParameters {
		/// <summary>
		///     Gets or sets the project that would be processed.
		/// </summary>
		/// <value>The Confuser project.</value>
		public ConfuserProject Project { get; set; }

		/// <summary>
		///     Gets or sets the logger that used to log the protection process.
		/// </summary>
		/// <value>The logger, or <c>null</c> if logging is not needed.</value>
		public ILogger Logger { get; set; }

		internal bool PackerInitiated { get; set; }

		/// <summary>
		///     Gets or sets the plugin discovery service.
		/// </summary>
		/// <value>The plugin discovery service, or <c>null</c> if default discovery is used.</value>
		public PluginDiscovery PluginDiscovery { get; set; }

		/// <summary>
		///     Gets or sets the marker.
		/// </summary>
		/// <value>The marker, or <c>null</c> if default marker is used.</value>
		public Marker Marker { get; set; }

		/// <summary>
		///     Gets the actual non-null logger.
		/// </summary>
		/// <returns>The logger.</returns>
		internal ILogger GetLogger() {
			return Logger ?? NullLogger.Instance;
		}

		/// <summary>
		///     Gets the actual non-null plugin discovery service.
		/// </summary>
		/// <returns>The plugin discovery service.</returns>
		internal PluginDiscovery GetPluginDiscovery() {
			return PluginDiscovery ?? PluginDiscovery.Instance;
		}

		/// <summary>
		///     Gets the actual non-null marker.
		/// </summary>
		/// <returns>The marker.</returns>
		internal Marker GetMarker() {
			return Marker ?? new ObfAttrMarker();
		}
	}
}
```

`Confuser.Core/CoreComponent.cs`:

```cs
using System;
using Confuser.Core.API;
using Confuser.Core.Services;

namespace Confuser.Core {
	/// <summary>
	///     Core component of Confuser.
	/// </summary>
	public class CoreComponent : ConfuserComponent {
		/// <summary>
		///     The service ID of RNG
		/// </summary>
		public const string _RandomServiceId = "Confuser.Random";

		/// <summary>
		///     The service ID of Marker
		/// </summary>
		public const string _MarkerServiceId = "Confuser.Marker";

		/// <summary>
		///     The service ID of Trace
		/// </summary>
		public const string _TraceServiceId = "Confuser.Trace";

		/// <summary>
		///     The service ID of Runtime
		/// </summary>
		public const string _RuntimeServiceId = "Confuser.Runtime";

		/// <summary>
		///     The service ID of Compression
		/// </summary>
		public const string _CompressionServiceId = "Confuser.Compression";

		/// <summary>
		///     The service ID of API Store
		/// </summary>
		public const string _APIStoreId = "Confuser.APIStore";

		public const string SymbolsFileName = "symbols.map";
		public const string PasswordFileName = "password";

		readonly Marker marker;
		readonly ConfuserContext _context;

		/// <summary>
		///     Initializes a new instance of the <see cref="CoreComponent" /> class.
		/// </summary>
		/// <param name="parameters">The parameters.</param>
		/// <param name="marker">The marker.</param>
		internal CoreComponent(ConfuserContext context, Marker marker) {
			_context = context;
			this.marker = marker;
		}

		/// <inheritdoc />
		public override string Name {
			get { return "Confuser Core"; }
		}

		/// <inheritdoc />
		public override string Description {
			get { return "Initialization of Confuser core services."; }
		}

		/// <inheritdoc />
		public override string Id {
			get { return "Confuser.Core"; }
		}

		/// <inheritdoc />
		public override string FullId {
			get { return "Confuser.Core"; }
		}

		/// <inheritdoc />
		protected internal override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_RandomServiceId, typeof(IRandomService), new RandomService(_context.Project.Seed));
			context.Registry.RegisterService(_MarkerServiceId, typeof(IMarkerService), new MarkerService(context, marker));
			context.Registry.RegisterService(_TraceServiceId, typeof(ITraceService), new TraceService());
			context.Registry.RegisterService(_RuntimeServiceId, typeof(IRuntimeService), new RuntimeService());
			context.Registry.RegisterService(_CompressionServiceId, typeof(ICompressionService), new CompressionService(context));
			context.Registry.RegisterService(_APIStoreId, typeof(IAPIStore), new APIStore(context));
		}

		/// <inheritdoc />
		protected internal override void PopulatePipeline(ProtectionPipeline pipeline) {
			//
		}
	}
}

```

`Confuser.Core/DependencyResolver.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Confuser.Core {
	/// <summary>
	///     Resolves dependency between protections.
	/// </summary>
	internal class DependencyResolver {
		readonly List<Protection> protections;

		/// <summary>
		///     Initializes a new instance of the <see cref="DependencyResolver" /> class.
		/// </summary>
		/// <param name="protections">The protections for resolution.</param>
		public DependencyResolver(IEnumerable<Protection> protections) {
			this.protections = protections.OrderBy(prot => prot.FullId).ToList();
		}

		/// <summary>
		///     Sort the protection according to their dependency.
		/// </summary>
		/// <returns>Sorted protections with respect to dependencies.</returns>
		/// <exception cref="T:CircularDependencyException">
		///     The protections contain circular dependencies.
		/// </exception>
		public IList<Protection> SortDependency() {
			/* Here we do a topological sort of the protections.
             * First we construct a dependency graph of the protections.
             * The edges in the graph is recorded in a list.
             * Then the graph is sorted starting from the null root node.
             */

			var edges = new List<DependencyGraphEdge>();
			var roots = new HashSet<Protection>(protections);
			Dictionary<string, Protection> id2prot = protections.ToDictionary(prot => prot.FullId, prot => prot);

			foreach (Protection prot in protections) {
				Type protType = prot.GetType();

				BeforeProtectionAttribute before = protType
					.GetCustomAttributes(typeof(BeforeProtectionAttribute), false)
					.Cast<BeforeProtectionAttribute>()
					.SingleOrDefault();
				if (before != null) {
					// current -> target
					IEnumerable<Protection> targets = before.Ids.Select(id => id2prot[id]);
					foreach (Protection target in targets) {
						edges.Add(new DependencyGraphEdge(prot, target));
						roots.Remove(target);
					}
				}

				AfterProtectionAttribute after = protType
					.GetCustomAttributes(typeof(AfterProtectionAttribute), false)
					.Cast<AfterProtectionAttribute>()
					.SingleOrDefault();
				if (after != null) {
					// target -> current
					IEnumerable<Protection> targets = after.Ids.Select(id => id2prot[id]);
					foreach (Protection target in targets) {
						edges.Add(new DependencyGraphEdge(target, prot));
						roots.Remove(prot);
					}
				}
			}

			IEnumerable<Protection> sorted = SortGraph(roots, edges);
			return sorted.ToList();
		}

		/// <summary>
		///     Topologically sort the dependency graph.
		/// </summary>
		/// <param name="roots">The root protections.</param>
		/// <param name="edges">The dependency graph edges.</param>
		/// <returns>Topological sorted protections.</returns>
		IEnumerable<Protection> SortGraph(IEnumerable<Protection> roots, IList<DependencyGraphEdge> edges) {
			var queue = new Queue<Protection>(roots.OrderBy(prot => prot.FullId));
			while (queue.Count > 0) {
				Protection root = queue.Dequeue(); // Find a node with no incoming edges
				Debug.Assert(!edges.Where(edge => edge.To == root).Any());
				yield return root;

				foreach (DependencyGraphEdge edge in edges.Where(edge => edge.From == root).ToList()) {
					edges.Remove(edge);
					if (!edges.Any(e => e.To == edge.To)) // No more incoming edge to edge.To
						queue.Enqueue(edge.To); // Add new root node
				}
			}
			if (edges.Count != 0)
				throw new CircularDependencyException(edges[0].From, edges[0].To);
		}

		/// <summary>
		///     An edge of dependency graph.
		/// </summary>
		class DependencyGraphEdge {
			/// <summary>
			///     Initializes a new instance of the <see cref="DependencyGraphEdge" /> class.
			/// </summary>
			/// <param name="from">The source protection node.</param>
			/// <param name="to">The destination protection node.</param>
			public DependencyGraphEdge(Protection from, Protection to) {
				From = from;
				To = to;
			}

			/// <summary>
			///     The source protection node.
			/// </summary>
			public Protection From { get; private set; }

			/// <summary>
			///     The destination protection node.
			/// </summary>
			public Protection To { get; private set; }
		}
	}

	/// <summary>
	///     The exception that is thrown when there exists circular dependency between protections.
	/// </summary>
	internal class CircularDependencyException : Exception {
		/// <summary>
		///     Initializes a new instance of the <see cref="CircularDependencyException" /> class.
		/// </summary>
		/// <param name="a">The first protection.</param>
		/// <param name="b">The second protection.</param>
		internal CircularDependencyException(Protection a, Protection b)
			: base(string.Format("The protections '{0}' and '{1}' has a circular dependency between them.", a, b)) {
			Debug.Assert(a != null);
			Debug.Assert(b != null);
			ProtectionA = a;
			ProtectionB = b;
		}

		/// <summary>
		///     First protection that involved in circular dependency.
		/// </summary>
		public Protection ProtectionA { get; private set; }

		/// <summary>
		///     Second protection that involved in circular dependency.
		/// </summary>
		public Protection ProtectionB { get; private set; }
	}
}
```

`Confuser.Core/DnlibUtils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.IO;

namespace Confuser.Core {
	/// <summary>
	///     Provides a set of utility methods about dnlib
	/// </summary>
	public static class DnlibUtils {
		/// <summary>
		///     Finds all definitions of interest in a module.
		/// </summary>
		/// <param name="module">The module.</param>
		/// <returns>A collection of all required definitions</returns>
		public static IEnumerable<IDnlibDef> FindDefinitions(this ModuleDef module) {
			yield return module;
			foreach (TypeDef type in module.GetTypes()) {
				yield return type;

				foreach (MethodDef method in type.Methods)
					yield return method;

				foreach (FieldDef field in type.Fields)
					yield return field;

				foreach (PropertyDef prop in type.Properties)
					yield return prop;

				foreach (EventDef evt in type.Events)
					yield return evt;
			}
		}

		/// <summary>
		///     Finds all definitions of interest in a type.
		/// </summary>
		/// <param name="typeDef">The type.</param>
		/// <returns>A collection of all required definitions</returns>
		public static IEnumerable<IDnlibDef> FindDefinitions(this TypeDef typeDef) {
			yield return typeDef;

			foreach (TypeDef nestedType in typeDef.NestedTypes)
				yield return nestedType;

			foreach (MethodDef method in typeDef.Methods)
				yield return method;

			foreach (FieldDef field in typeDef.Fields)
				yield return field;

			foreach (PropertyDef prop in typeDef.Properties)
				yield return prop;

			foreach (EventDef evt in typeDef.Events)
				yield return evt;
		}

		/// <summary>
		///     Determines whether the specified method is visible outside the containing assembly.
		/// </summary>
		/// <param name="methodDef">The method that is checked.</param>
		/// <returns><see langword="true"/> in case the method is visible outside of the assembly.</returns>
		/// <exception cref="ArgumentNullException"><paramref name="methodDef"/> is <see langword="null"/>.</exception>
		/// <remarks>
		///     The method is considered visible in case it is public or visible to sub-types (protected) and the
		///     declaring type is also visible outside of the assembly.
		/// </remarks>
		public static bool IsVisibleOutside(this MethodDef methodDef) {
			if (methodDef == null) throw new ArgumentNullException(nameof(methodDef));

			switch (methodDef.Access) {
				case MethodAttributes.Family:
				case MethodAttributes.FamORAssem:
				case MethodAttributes.Public:
					return methodDef.DeclaringType.IsVisibleOutside();
			}

			return false;
		}

		/// <summary>
		///     Determines whether the specified field is visible outside the containing assembly.
		/// </summary>
		/// <param name="fieldDef">The field that is checked.</param>
		/// <returns><see langword="true"/> in case the field is visible outside of the assembly.</returns>
		/// <exception cref="ArgumentNullException"><paramref name="fieldDef"/> is <see langword="null"/>.</exception>
		/// <remarks>
		///     The field is considered visible in case it is public or visible to sub-types (protected) and the
		///     declaring type is also visible outside of the assembly.
		/// </remarks>
		public static bool IsVisibleOutside(this FieldDef fieldDef) {
			if (fieldDef == null) throw new ArgumentNullException(nameof(fieldDef));

			switch (fieldDef.Access) {
				case FieldAttributes.Family:
				case FieldAttributes.FamORAssem:
				case FieldAttributes.Public:
					return fieldDef.DeclaringType.IsVisibleOutside();
			}

			return false;
		}

		/// <summary>
		///     Determines whether the specified event is visible outside the containing assembly.
		/// </summary>
		/// <param name="eventDef">The event that is checked.</param>
		/// <returns><see langword="true"/> in case the event is visible outside of the assembly.</returns>
		/// <exception cref="ArgumentNullException"><paramref name="eventDef"/> is <see langword="null"/>.</exception>
		/// <remarks>
		///     The event is considered visible in case any of the methods related to it is visible outside.
		/// </remarks>
		public static bool IsVisibleOutside(this EventDef eventDef) {
			if (eventDef == null) throw new ArgumentNullException(nameof(eventDef));

			return eventDef.AllMethods().Any(IsVisibleOutside);
		}

		/// <summary>
		///     Determines whether the specified property is visible outside the containing assembly.
		/// </summary>
		/// <param name="propertyDef">The event that is checked.</param>
		/// <returns><see langword="true"/> in case the property is visible outside of the assembly.</returns>
		/// <exception cref="ArgumentNullException">
		///     <paramref name="propertyDef"/> is <see langword="null"/>.
		/// </exception>
		/// <remarks>
		///     The property is considered visible in case any of the getter or setter methods is visible outside.
		/// </remarks>
		public static bool IsVisibleOutside(this PropertyDef propertyDef) {
			if (propertyDef == null) throw new ArgumentNullException(nameof(propertyDef));

			return propertyDef.GetMethods.Any(IsVisibleOutside) || propertyDef.SetMethods.Any(IsVisibleOutside);
		}

		/// <summary>
		///     Determines whether the specified type is visible outside the containing assembly.
		/// </summary>
		/// <param name="typeDef">The type.</param>
		/// <param name="exeNonPublic">Visibility of executable modules.</param>
		/// <returns><c>true</c> if the specified type is visible outside the containing assembly; otherwise, <c>false</c>.</returns>
		public static bool IsVisibleOutside(this TypeDef typeDef, bool exeNonPublic = true) {
			// Assume executable modules' type is not visible
			if (exeNonPublic && (typeDef.Module.Kind == ModuleKind.Windows || typeDef.Module.Kind == ModuleKind.Console))
				return false;

			do {
				if (typeDef.DeclaringType == null)
					return typeDef.IsPublic;
				if (!typeDef.IsNestedPublic && !typeDef.IsNestedFamily && !typeDef.IsNestedFamilyOrAssembly)
					return false;
				typeDef = typeDef.DeclaringType;
			} while (typeDef != null);

			throw new UnreachableException();
		}

		/// <summary>
		///     Determines whether the object has the specified custom attribute.
		/// </summary>
		/// <param name="obj">The object.</param>
		/// <param name="fullName">The full name of the type of custom attribute.</param>
		/// <returns><c>true</c> if the specified object has custom attribute; otherwise, <c>false</c>.</returns>
		public static bool HasAttribute(this IHasCustomAttribute obj, string fullName) {
			return obj.CustomAttributes.Any(attr => attr.TypeFullName == fullName);
		}

		/// <summary>
		///     Determines whether the specified type is COM import.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <returns><c>true</c> if specified type is COM import; otherwise, <c>false</c>.</returns>
		public static bool IsComImport(this TypeDef type) {
			return type.IsImport ||
				   type.HasAttribute("System.Runtime.InteropServices.ComImportAttribute") ||
				   type.HasAttribute("System.Runtime.InteropServices.TypeLibTypeAttribute");
		}

		/// <summary>
		///     Determines whether the specified type is compiler generated.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <returns><c>true</c> if specified type is compiler generated; otherwise, <c>false</c>.</returns>
		public static bool IsCompilerGenerated(this TypeDef type) {
			return type.HasAttribute("System.Runtime.CompilerServices.CompilerGeneratedAttribute");
		}

		/// <summary>
		///     Determines whether the specified type is a delegate.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <returns><c>true</c> if the specified type is a delegate; otherwise, <c>false</c>.</returns>
		public static bool IsDelegate(this TypeDef type) {
			if (type.BaseType == null)
				return false;

			string fullName = type.BaseType.FullName;
			return fullName == "System.Delegate" || fullName == "System.MulticastDelegate";
		}

		/// <summary>
		///     Determines whether the specified type is inherited from a base type in corlib.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <param name="baseType">The full name of base type.</param>
		/// <returns><c>true</c> if the specified type is inherited from a base type; otherwise, <c>false</c>.</returns>
		public static bool InheritsFromCorlib(this TypeDef type, string baseType) {
			if (type.BaseType == null)
				return false;

			TypeDef bas = type;
			do {
				bas = bas.BaseType.ResolveTypeDefThrow();
				if (bas.ReflectionFullName == baseType)
					return true;
			} while (bas.BaseType != null && bas.BaseType.DefinitionAssembly.IsCorLib());
			return false;
		}

		/// <summary>
		///     Determines whether the specified type is inherited from a base type.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <param name="baseType">The full name of base type.</param>
		/// <returns><c>true</c> if the specified type is inherited from a base type; otherwise, <c>false</c>.</returns>
		public static bool InheritsFrom(this TypeDef type, string baseType) {
			if (type.BaseType == null)
				return false;

			TypeDef bas = type;
			do {
				bas = bas.BaseType.ResolveTypeDefThrow();
				if (bas.ReflectionFullName == baseType)
					return true;
			} while (bas.BaseType != null);
			return false;
		}

		/// <summary>
		///     Determines whether the specified type implements the specified interface.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <param name="fullName">The full name of the type of interface.</param>
		/// <returns><c>true</c> if the specified type implements the interface; otherwise, <c>false</c>.</returns>
		public static bool Implements(this TypeDef type, string fullName) {
			do {
				foreach (InterfaceImpl iface in type.Interfaces) {
					if (iface.Interface.ReflectionFullName == fullName)
						return true;
				}

				if (type.BaseType == null)
					return false;

				type = type.BaseType.ResolveTypeDefThrow();
			} while (type != null);
			throw new UnreachableException();
		}

		/// <summary>
		///     Resolves the method.
		/// </summary>
		/// <param name="method">The method to resolve.</param>
		/// <returns>A <see cref="MethodDef" /> instance.</returns>
		/// <exception cref="MemberRefResolveException">The method couldn't be resolved.</exception>
		public static MethodDef ResolveThrow(this IMethod method) {
			var def = method as MethodDef;
			if (def != null)
				return def;

			var spec = method as MethodSpec;
			if (spec != null)
				return spec.Method.ResolveThrow();

			return ((MemberRef)method).ResolveMethodThrow();
		}

		/// <summary>
		///     Resolves the field.
		/// </summary>
		/// <param name="field">The field to resolve.</param>
		/// <returns>A <see cref="FieldDef" /> instance.</returns>
		/// <exception cref="MemberRefResolveException">The method couldn't be resolved.</exception>
		public static FieldDef ResolveThrow(this IField field) {
			var def = field as FieldDef;
			if (def != null)
				return def;

			return ((MemberRef)field).ResolveFieldThrow();
		}

		/// <summary>
		///     Find the basic type reference.
		/// </summary>
		/// <param name="typeSig">The type signature to get the basic type.</param>
		/// <returns>A <see cref="ITypeDefOrRef" /> instance, or null if the typeSig cannot be resolved to basic type.</returns>
		public static ITypeDefOrRef ToBasicTypeDefOrRef(this TypeSig typeSig) {
			while (typeSig.Next != null)
				typeSig = typeSig.Next;

			if (typeSig is GenericInstSig)
				return ((GenericInstSig)typeSig).GenericType.TypeDefOrRef;
			if (typeSig is TypeDefOrRefSig)
				return ((TypeDefOrRefSig)typeSig).TypeDefOrRef;
			return null;
		}

		/// <summary>
		///     Find the type references within the specified type signature.
		/// </summary>
		/// <param name="typeSig">The type signature to find the type references.</param>
		/// <returns>A list of <see cref="ITypeDefOrRef" /> instance.</returns>
		public static IList<ITypeDefOrRef> FindTypeRefs(this TypeSig typeSig) {
			var ret = new List<ITypeDefOrRef>();
			FindTypeRefsInternal(typeSig, ret);
			return ret;
		}

		static void FindTypeRefsInternal(TypeSig typeSig, IList<ITypeDefOrRef> ret) {
			while (typeSig.Next != null) {
				if (typeSig is ModifierSig)
					ret.Add(((ModifierSig)typeSig).Modifier);
				typeSig = typeSig.Next;
			}

			if (typeSig is GenericInstSig) {
				var genInst = (GenericInstSig)typeSig;
				ret.Add(genInst.GenericType.TypeDefOrRef);
				foreach (TypeSig genArg in genInst.GenericArguments)
					FindTypeRefsInternal(genArg, ret);
			}
			else if (typeSig is TypeDefOrRefSig) {
				var type = ((TypeDefOrRefSig)typeSig).TypeDefOrRef;
				while (type != null) {
					ret.Add(type);
					type = type.DeclaringType;
				}
			}
		}

		/// <summary>
		///     Determines whether the specified property is abstract.
		/// </summary>
		/// <param name="property">The property.</param>
		/// <returns><see langword="true" /> if the specified property is abstract; otherwise, <see langword="false" /></returns>
		public static bool IsAbstract(this PropertyDef property) =>
			property.AllMethods().Any(method => method.IsAbstract);

		/// <summary>
		///     Determines whether the specified property is public.
		/// </summary>
		/// <param name="property">The property.</param>
		/// <returns><c>true</c> if the specified property is public; otherwise, <c>false</c>.</returns>
		public static bool IsPublic(this PropertyDef property) {
			return property.AllMethods().Any(method => method.IsPublic);
		}

		/// <summary>
		///     Determines whether the specified property is family or assembly.
		/// </summary>
		/// <param name="property">The property.</param>
		/// <returns><c>true</c> if the specified property is family or assembly; otherwise, <c>false</c>.</returns>
		public static bool IsFamilyOrAssembly(this PropertyDef property) {
			return property.AllMethods().Any(method => method.IsFamilyOrAssembly);
		}

		/// <summary>
		///     Determines whether the specified property is family.
		/// </summary>
		/// <param name="property">The property.</param>
		/// <returns><c>true</c> if the specified property is family; otherwise, <c>false</c>.</returns>
		public static bool IsFamily(this PropertyDef property) {
			return property.AllMethods().Any(method => method.IsFamily);
		}

		/// <summary>
		///     Determines whether the specified property is static.
		/// </summary>
		/// <param name="property">The property.</param>
		/// <returns><c>true</c> if the specified property is static; otherwise, <c>false</c>.</returns>
		public static bool IsStatic(this PropertyDef property) {
			return property.AllMethods().Any(method => method.IsStatic);
		}

		/// <summary>
		///     Determines whether the specified event is abstract.
		/// </summary>
		/// <param name="evt">The event.</param>
		/// <returns><see langword="true" /> if the specified event is abstract; otherwise, <see langword="false" /></returns>
		public static bool IsAbstract(this EventDef evt) =>
			evt.AllMethods().Any(method => method.IsAbstract);

		/// <summary>
		///     Determines whether the specified event is public.
		/// </summary>
		/// <param name="evt">The event.</param>
		/// <returns><c>true</c> if the specified event is public; otherwise, <c>false</c>.</returns>
		public static bool IsPublic(this EventDef evt) {
			return evt.AllMethods().Any(method => method.IsPublic);
		}

		/// <summary>
		///     Determines whether the specified event is family or assembly.
		/// </summary>
		/// <param name="evt">The event.</param>
		/// <returns><c>true</c> if the specified property is family or assembly; otherwise, <c>false</c>.</returns>
		public static bool IsFamilyOrAssembly(this EventDef evt) {
			return evt.AllMethods().Any(method => method.IsFamilyOrAssembly);
		}

		/// <summary>
		///     Determines whether the specified event is family.
		/// </summary>
		/// <param name="evt">The event.</param>
		/// <returns><c>true</c> if the specified property is family; otherwise, <c>false</c>.</returns>
		public static bool IsFamily(this EventDef evt) {
			return evt.AllMethods().Any(method => method.IsFamily);
		}

		/// <summary>
		///     Determines whether the specified event is static.
		/// </summary>
		/// <param name="evt">The event.</param>
		/// <returns><c>true</c> if the specified event is static; otherwise, <c>false</c>.</returns>
		public static bool IsStatic(this EventDef evt) {
			return evt.AllMethods().Any(method => method.IsStatic);
		}

		public static bool IsInterfaceImplementation(this MethodDef method) {
			if (method == null) throw new ArgumentNullException(nameof(method));

			return IsImplicitImplementedInterfaceMember(method) || IsExplicitlyImplementedInterfaceMember(method);
		}

		/// <summary>
		///     Determines whether the specified method is an implicitly implemented interface member.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <returns>
		///     <see langword="true" /> if the specified method is an implicitly implemented interface member;
		///     otherwise, <see langword="false" />.
		/// </returns>
		/// <exception cref="ArgumentNullException"><paramref name="method"/> is <see langword="null" />.</exception>
		/// <exception cref="TypeResolveException">Failed to resolve required interface types.</exception>
		public static bool IsImplicitImplementedInterfaceMember(this MethodDef method) {
			if (method == null) throw new ArgumentNullException(nameof(method));

			if (method.IsPublic && method.IsNewSlot) {
				foreach (var iFace in method.DeclaringType.Interfaces) {
					var iFaceDef = iFace.Interface.ResolveTypeDefThrow();
					if (iFaceDef.FindMethod(method.Name, (MethodSig)method.Signature) != null)
						return true;
				}
			}
			return false;
		}

		/// <summary>
		///     Determines whether the specified method is an explicitly implemented interface member.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <returns><c>true</c> if the specified method is an explicitly implemented interface member; otherwise, <c>false</c>.</returns>
		public static bool IsExplicitlyImplementedInterfaceMember(this MethodDef method) {
			return method.IsFinal && method.IsPrivate;
		}

		/// <summary>
		///     Determines whether the specified property is an explicitly implemented interface member.
		/// </summary>
		/// <param name="property">The method.</param>
		/// <returns><c>true</c> if the specified property is an explicitly implemented interface member; otherwise, <c>false</c>.</returns>
		public static bool IsExplicitlyImplementedInterfaceMember(this PropertyDef property) {
			return property.AllMethods().Any(IsExplicitlyImplementedInterfaceMember);
		}

		/// <summary>
		///     Determines whether the specified event is an explicitly implemented interface member.
		/// </summary>
		/// <param name="evt">The event.</param>
		/// <returns><c>true</c> if the specified eve is an explicitly implemented interface member; otherwise, <c>false</c>.</returns>
		public static bool IsExplicitlyImplementedInterfaceMember(this EventDef evt) {
			return evt.AllMethods().Any(IsExplicitlyImplementedInterfaceMember);
		}

		private static IEnumerable<MethodDef> AllMethods(this EventDef evt) {
			return new[] { evt.AddMethod, evt.RemoveMethod, evt.InvokeMethod }
				.Concat(evt.OtherMethods)
				.Where(m => m != null);
		}

		private static IEnumerable<MethodDef> AllMethods(this PropertyDef property) {
			return new[] { property.GetMethod, property.SetMethod }
				.Concat(property.OtherMethods)
				.Where(m => m != null);
		}

		/// <summary>
		///     Replaces the specified instruction reference with another instruction.
		/// </summary>
		/// <param name="body">The method body.</param>
		/// <param name="target">The instruction to replace.</param>
		/// <param name="newInstr">The new instruction.</param>
		public static void ReplaceReference(this CilBody body, Instruction target, Instruction newInstr) {
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				if (eh.TryStart == target)
					eh.TryStart = newInstr;
				if (eh.TryEnd == target)
					eh.TryEnd = newInstr;
				if (eh.HandlerStart == target)
					eh.HandlerStart = newInstr;
				if (eh.HandlerEnd == target)
					eh.HandlerEnd = newInstr;
				if (eh.FilterStart == target)
					eh.FilterStart = newInstr;
			}
			foreach (Instruction instr in body.Instructions) {
				if (instr.Operand == target)
					instr.Operand = newInstr;
				else if (instr.Operand is Instruction[]) {
					var targets = (Instruction[])instr.Operand;
					for (int i = 0; i < targets.Length; i++)
						if (targets[i] == target)
							targets[i] = newInstr;
				}
			}
		}

		/// <summary>
		///     Determines whether the specified method is array accessors.
		/// </summary>
		/// <param name="method">The method.</param>
		/// <returns><c>true</c> if the specified method is array accessors; otherwise, <c>false</c>.</returns>
		public static bool IsArrayAccessors(this IMethod method) {
			var declType = method.DeclaringType.ToTypeSig();
			if (declType is GenericInstSig)
				declType = ((GenericInstSig)declType).GenericType;

			if (declType.IsArray) {
				return method.Name == "Get" || method.Name == "Set" || method.Name == "Address";
			}
			return false;
		}

		public static bool IsEntryPoint(this MethodDef methodDef) {
			if (methodDef == null) throw new ArgumentNullException(nameof(methodDef));

			return methodDef == methodDef.Module.EntryPoint;
		}

		public static bool IsEntryPoint(this TypeDef typeDef) {
			if (typeDef == null) throw new ArgumentNullException(nameof(typeDef));

			return typeDef == typeDef.Module.EntryPoint?.DeclaringType;
		}
		
		/// <summary>
		///		Merges a specified call instruction into the body.
		/// </summary>
		/// <param name="targetBody">The target body</param>
		/// <param name="callInstruction">The instruction to merge in</param>
		public static void MergeCall(this CilBody targetBody, Instruction callInstruction) {
			if (!(callInstruction.Operand is MethodDef methodToMerge))
				throw new ArgumentException("Call instruction has invalid operand");
			if (!methodToMerge.HasBody)
				throw new Exception("Method to merge has no body!");

			var localParams = methodToMerge.Parameters.ToDictionary(param => param.Index, param => new Local(param.Type));
			var localMap = methodToMerge.Body.Variables.ToDictionary(local => local, local => new Local(local.Type));
			foreach (var local in localParams)
				targetBody.Variables.Add(local.Value);
			foreach (var local in localMap)
				targetBody.Variables.Add(local.Value);

			// Nop the call
			int index = targetBody.Instructions.IndexOf(callInstruction) + 1;
			callInstruction.OpCode = OpCodes.Nop;
			callInstruction.Operand = null;
			var afterIndex = targetBody.Instructions[index];

			// Find Exception handler index
			int exIndex = 0;
			foreach (var ex in targetBody.ExceptionHandlers) {
				if (targetBody.Instructions.IndexOf(ex.TryStart) < index)
					exIndex = targetBody.ExceptionHandlers.IndexOf(ex);
			}

			// setup parameter locals
			foreach (var paramLocal in localParams.Reverse()) {
				targetBody.Instructions.Insert(index++, new Instruction(OpCodes.Stloc, paramLocal.Value));
			}

			var instrMap = new Dictionary<Instruction, Instruction>();
			var newInstrs = new List<Instruction>();

			// Transfer instructions to list
			foreach (var instr in methodToMerge.Body.Instructions) {
				Instruction newInstr;
				if (instr.OpCode == OpCodes.Ret) {
					newInstr = new Instruction(OpCodes.Br, afterIndex);
				}
				else if (instr.IsLdarg()) {
					localParams.TryGetValue(instr.GetParameterIndex(), out var lc);
					newInstr = new Instruction(OpCodes.Ldloc, lc);
				}
				else if (instr.IsStarg()) {
					localParams.TryGetValue(instr.GetParameterIndex(), out var lc);
					newInstr = new Instruction(OpCodes.Stloc, lc);
				}
				else if (instr.IsLdloc()) {
					localMap.TryGetValue(instr.GetLocal(methodToMerge.Body.Variables), out var lc);
					newInstr = new Instruction(OpCodes.Ldloc, lc);
				}
				else if (instr.IsStloc()) {
					localMap.TryGetValue(instr.GetLocal(methodToMerge.Body.Variables), out var lc);
					newInstr = new Instruction(OpCodes.Stloc, lc);
				}
				else {
					newInstr = new Instruction(instr.OpCode, instr.Operand);
				}

				newInstrs.Add(newInstr);
				instrMap[instr] = newInstr;
			}

			// Fix branch targets & add instructions
			foreach (var instr in newInstrs) {
				if (instr.Operand != null && instr.Operand is Instruction instrOp && instrMap.ContainsKey(instrOp))
					instr.Operand = instrMap[instrOp];
				else if (instr.Operand is Instruction[] instructionArrayOp)
					instr.Operand = instructionArrayOp.Select(target => instrMap[target]).ToArray();

				targetBody.Instructions.Insert(index++, instr);
			}

			// Add Exception Handlers
			foreach (var eh in methodToMerge.Body.ExceptionHandlers) {
				targetBody.ExceptionHandlers.Insert(++exIndex, new ExceptionHandler(eh.HandlerType) {
					CatchType = eh.CatchType,
					TryStart = instrMap[eh.TryStart],
					TryEnd = instrMap[eh.TryEnd],
					HandlerStart = instrMap[eh.HandlerStart],
					HandlerEnd = instrMap[eh.HandlerEnd],
					FilterStart = eh.FilterStart == null ? null : instrMap[eh.FilterStart]
				});
			}
		}
	}
}

```

`Confuser.Core/Helpers/ControlFlowGraph.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Helpers {
	/// <summary>
	///     A Control Flow Graph (CFG) of a method
	/// </summary>
	public class ControlFlowGraph : IEnumerable<ControlFlowBlock> {
		readonly List<ControlFlowBlock> blocks;
		readonly CilBody body;
		readonly int[] instrBlocks;
		readonly Dictionary<Instruction, int> indexMap;

		ControlFlowGraph(CilBody body) {
			this.body = body;
			instrBlocks = new int[body.Instructions.Count];
			blocks = new List<ControlFlowBlock>();

			indexMap = new Dictionary<Instruction, int>();
			for (int i = 0; i < body.Instructions.Count; i++)
				indexMap.Add(body.Instructions[i], i);
		}

		/// <summary>
		///     Gets the number of blocks in this CFG.
		/// </summary>
		/// <value>The number of blocks.</value>
		public int Count {
			get { return blocks.Count; }
		}

		/// <summary>
		///     Gets the <see cref="ControlFlowBlock" /> of the specified id.
		/// </summary>
		/// <param name="id">The id.</param>
		/// <returns>The block with specified id.</returns>
		public ControlFlowBlock this[int id] {
			get { return blocks[id]; }
		}

		/// <summary>
		///     Gets the corresponding method body.
		/// </summary>
		/// <value>The method body.</value>
		public CilBody Body {
			get { return body; }
		}

		IEnumerator<ControlFlowBlock> IEnumerable<ControlFlowBlock>.GetEnumerator() {
			return blocks.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator() {
			return blocks.GetEnumerator();
		}

		/// <summary>
		///     Gets the block containing the specified instruction.
		/// </summary>
		/// <param name="instrIndex">The index of instruction.</param>
		/// <returns>The block containing the instruction.</returns>
		public ControlFlowBlock GetContainingBlock(int instrIndex) {
			return blocks[instrBlocks[instrIndex]];
		}

		/// <summary>
		///     Gets the index of the specified instruction.
		/// </summary>
		/// <param name="instr">The instruction.</param>
		/// <returns>The index of instruction.</returns>
		public int IndexOf(Instruction instr) {
			return indexMap[instr];
		}

		void PopulateBlockHeaders(HashSet<Instruction> blockHeaders, HashSet<Instruction> entryHeaders) {
			for (int i = 0; i < body.Instructions.Count; i++) {
				Instruction instr = body.Instructions[i];

				if (instr.Operand is Instruction) {
					blockHeaders.Add((Instruction)instr.Operand);
					if (i + 1 < body.Instructions.Count)
						blockHeaders.Add(body.Instructions[i + 1]);
				}
				else if (instr.Operand is Instruction[]) {
					foreach (Instruction target in (Instruction[])instr.Operand)
						blockHeaders.Add(target);
					if (i + 1 < body.Instructions.Count)
						blockHeaders.Add(body.Instructions[i + 1]);
				}
				else if ((instr.OpCode.FlowControl == FlowControl.Throw || instr.OpCode.FlowControl == FlowControl.Return) &&
				         i + 1 < body.Instructions.Count) {
					blockHeaders.Add(body.Instructions[i + 1]);
				}
			}
			blockHeaders.Add(body.Instructions[0]);
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				blockHeaders.Add(eh.TryStart);
				blockHeaders.Add(eh.HandlerStart);
				blockHeaders.Add(eh.FilterStart);
				entryHeaders.Add(eh.HandlerStart);
				entryHeaders.Add(eh.FilterStart);
			}
		}

		void SplitBlocks(HashSet<Instruction> blockHeaders, HashSet<Instruction> entryHeaders) {
			int nextBlockId = 0;
			int currentBlockId = -1;
			Instruction currentBlockHdr = null;

			for (int i = 0; i < body.Instructions.Count; i++) {
				Instruction instr = body.Instructions[i];
				if (blockHeaders.Contains(instr)) {
					if (currentBlockHdr != null) {
						Instruction footer = body.Instructions[i - 1];

						var type = ControlFlowBlockType.Normal;
						if (entryHeaders.Contains(currentBlockHdr) || currentBlockHdr == body.Instructions[0])
							type |= ControlFlowBlockType.Entry;
						if (footer.OpCode.FlowControl == FlowControl.Return || footer.OpCode.FlowControl == FlowControl.Throw)
							type |= ControlFlowBlockType.Exit;

						blocks.Add(new ControlFlowBlock(currentBlockId, type, currentBlockHdr, footer));
					}

					currentBlockId = nextBlockId++;
					currentBlockHdr = instr;
				}

				instrBlocks[i] = currentBlockId;
			}
			if (blocks.Count == 0 || blocks[blocks.Count - 1].Id != currentBlockId) {
				Instruction footer = body.Instructions[body.Instructions.Count - 1];

				var type = ControlFlowBlockType.Normal;
				if (entryHeaders.Contains(currentBlockHdr) || currentBlockHdr == body.Instructions[0])
					type |= ControlFlowBlockType.Entry;
				if (footer.OpCode.FlowControl == FlowControl.Return || footer.OpCode.FlowControl == FlowControl.Throw)
					type |= ControlFlowBlockType.Exit;

				blocks.Add(new ControlFlowBlock(currentBlockId, type, currentBlockHdr, footer));
			}
		}

		void LinkBlocks() {
			for (int i = 0; i < body.Instructions.Count; i++) {
				Instruction instr = body.Instructions[i];
				if (instr.Operand is Instruction) {
					ControlFlowBlock srcBlock = blocks[instrBlocks[i]];
					ControlFlowBlock dstBlock = blocks[instrBlocks[indexMap[(Instruction)instr.Operand]]];
					dstBlock.Sources.Add(srcBlock);
					srcBlock.Targets.Add(dstBlock);
				}
				else if (instr.Operand is Instruction[]) {
					foreach (Instruction target in (Instruction[])instr.Operand) {
						ControlFlowBlock srcBlock = blocks[instrBlocks[i]];
						ControlFlowBlock dstBlock = blocks[instrBlocks[indexMap[target]]];
						dstBlock.Sources.Add(srcBlock);
						srcBlock.Targets.Add(dstBlock);
					}
				}
			}
			for (int i = 0; i < blocks.Count; i++) {
				if (blocks[i].Footer.OpCode.FlowControl != FlowControl.Branch &&
				    blocks[i].Footer.OpCode.FlowControl != FlowControl.Return &&
				    blocks[i].Footer.OpCode.FlowControl != FlowControl.Throw) {
					blocks[i].Targets.Add(blocks[i + 1]);
					blocks[i + 1].Sources.Add(blocks[i]);
				}
			}
		}

		/// <summary>
		///     Constructs a CFG from the specified method body.
		/// </summary>
		/// <param name="body">The method body.</param>
		/// <returns>The CFG of the given method body.</returns>
		public static ControlFlowGraph Construct(CilBody body) {
			var graph = new ControlFlowGraph(body);
			if (body.Instructions.Count == 0)
				return graph;

			// Populate block headers
			var blockHeaders = new HashSet<Instruction>();
			var entryHeaders = new HashSet<Instruction>();
			graph.PopulateBlockHeaders(blockHeaders, entryHeaders);

			// Split blocks
			graph.SplitBlocks(blockHeaders, entryHeaders);

			// Link blocks
			graph.LinkBlocks();

			return graph;
		}
	}

	/// <summary>
	///     The type of Control Flow Block
	/// </summary>
	[Flags]
	public enum ControlFlowBlockType {
		/// <summary>
		///     The block is a normal block
		/// </summary>
		Normal = 0,

		/// <summary>
		///     There are unknown edges to this block. Usually used at exception handlers / method entry.
		/// </summary>
		Entry = 1,

		/// <summary>
		///     There are unknown edges from this block. Usually used at filter blocks / throw / method exit.
		/// </summary>
		Exit = 2
	}

	/// <summary>
	///     A block in Control Flow Graph (CFG).
	/// </summary>
	public class ControlFlowBlock {
		/// <summary>
		///     The footer instruction
		/// </summary>
		public readonly Instruction Footer;

		/// <summary>
		///     The header instruction
		/// </summary>
		public readonly Instruction Header;

		/// <summary>
		///     The identifier of this block
		/// </summary>
		public readonly int Id;

		/// <summary>
		///     The type of this block
		/// </summary>
		public readonly ControlFlowBlockType Type;

		internal ControlFlowBlock(int id, ControlFlowBlockType type, Instruction header, Instruction footer) {
			Id = id;
			Type = type;
			Header = header;
			Footer = footer;

			Sources = new List<ControlFlowBlock>();
			Targets = new List<ControlFlowBlock>();
		}

		/// <summary>
		///     Gets the source blocks of this control flow block.
		/// </summary>
		/// <value>The source blocks.</value>
		public IList<ControlFlowBlock> Sources { get; private set; }

		/// <summary>
		///     Gets the target blocks of this control flow block.
		/// </summary>
		/// <value>The target blocks.</value>
		public IList<ControlFlowBlock> Targets { get; private set; }

		/// <summary>
		///     Returns a <see cref="System.String" /> that represents this block.
		/// </summary>
		/// <returns>A <see cref="System.String" /> that represents this block.</returns>
		public override string ToString() {
			return string.Format("Block {0} => {1} {2}", Id, Type, string.Join(", ", Targets.Select(block => block.Id.ToString()).ToArray()));
		}
	}
}
```

`Confuser.Core/Helpers/InjectHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Helpers {
	/// <summary>
	///     Provides methods to inject a <see cref="TypeDef" /> into another module.
	/// </summary>
	public static class InjectHelper {
		/// <summary>
		///     Clones the specified origin TypeDef.
		/// </summary>
		/// <param name="origin">The origin TypeDef.</param>
		/// <returns>The cloned TypeDef.</returns>
		static TypeDefUser Clone(TypeDef origin) {
			var ret = new TypeDefUser(origin.Namespace, origin.Name);
			ret.Attributes = origin.Attributes;

			if (origin.ClassLayout != null)
				ret.ClassLayout = new ClassLayoutUser(origin.ClassLayout.PackingSize, origin.ClassSize);

			foreach (GenericParam genericParam in origin.GenericParameters)
				ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

			return ret;
		}

		/// <summary>
		///     Clones the specified origin MethodDef.
		/// </summary>
		/// <param name="origin">The origin MethodDef.</param>
		/// <returns>The cloned MethodDef.</returns>
		static MethodDefUser Clone(MethodDef origin) {
			var ret = new MethodDefUser(origin.Name, null, origin.ImplAttributes, origin.Attributes);

			foreach (GenericParam genericParam in origin.GenericParameters)
				ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

			return ret;
		}

		/// <summary>
		///     Clones the specified origin FieldDef.
		/// </summary>
		/// <param name="origin">The origin FieldDef.</param>
		/// <returns>The cloned FieldDef.</returns>
		static FieldDefUser Clone(FieldDef origin) {
			var ret = new FieldDefUser(origin.Name, null, origin.Attributes);
			return ret;
		}

		/// <summary>
		///     Populates the context mappings.
		/// </summary>
		/// <param name="typeDef">The origin TypeDef.</param>
		/// <param name="ctx">The injection context.</param>
		/// <returns>The new TypeDef.</returns>
		static TypeDef PopulateContext(TypeDef typeDef, InjectContext ctx) {
			var ret = ctx.Map(typeDef)?.ResolveTypeDef();
			if (ret is null) {
				ret = Clone(typeDef);
				ctx.DefMap[typeDef] = ret;
			}

			foreach (TypeDef nestedType in typeDef.NestedTypes)
				ret.NestedTypes.Add(PopulateContext(nestedType, ctx));

			foreach (MethodDef method in typeDef.Methods)
				ret.Methods.Add((MethodDef)(ctx.DefMap[method] = Clone(method)));

			foreach (FieldDef field in typeDef.Fields)
				ret.Fields.Add((FieldDef)(ctx.DefMap[field] = Clone(field)));

			return ret;
		}

		/// <summary>
		///     Copies the information from the origin type to injected type.
		/// </summary>
		/// <param name="typeDef">The origin TypeDef.</param>
		/// <param name="ctx">The injection context.</param>
		static void CopyTypeDef(TypeDef typeDef, InjectContext ctx) {
			var newTypeDef = ctx.Map(typeDef)?.ResolveTypeDefThrow();
			newTypeDef.BaseType = ctx.Importer.Import(typeDef.BaseType);

			foreach (InterfaceImpl iface in typeDef.Interfaces)
				newTypeDef.Interfaces.Add(new InterfaceImplUser(ctx.Importer.Import(iface.Interface)));
		}

		/// <summary>
		///     Copies the information from the origin method to injected method.
		/// </summary>
		/// <param name="methodDef">The origin MethodDef.</param>
		/// <param name="ctx">The injection context.</param>
		static void CopyMethodDef(MethodDef methodDef, InjectContext ctx) {
			var newMethodDef = ctx.Map(methodDef)?.ResolveMethodDefThrow();

			newMethodDef.Signature = ctx.Importer.Import(methodDef.Signature);
			newMethodDef.Parameters.UpdateParameterTypes();
			
			foreach (var paramDef in methodDef.ParamDefs)
				newMethodDef.ParamDefs.Add(new ParamDefUser(paramDef.Name, paramDef.Sequence, paramDef.Attributes));

			if (methodDef.ImplMap != null)
				newMethodDef.ImplMap = new ImplMapUser(new ModuleRefUser(ctx.TargetModule, methodDef.ImplMap.Module.Name), methodDef.ImplMap.Name, methodDef.ImplMap.Attributes);

			foreach (CustomAttribute ca in methodDef.CustomAttributes)
				newMethodDef.CustomAttributes.Add(new CustomAttribute((ICustomAttributeType)ctx.Importer.Import(ca.Constructor)));

			if (methodDef.HasBody)
				CopyMethodBody(methodDef, ctx, newMethodDef);
		}
		
		static void CopyMethodBody(MethodDef methodDef, InjectContext ctx, MethodDef newMethodDef)
		{
			newMethodDef.Body = new CilBody(methodDef.Body.InitLocals, new List<Instruction>(),
				new List<ExceptionHandler>(), new List<Local>()) {MaxStack = methodDef.Body.MaxStack};

			var bodyMap = new Dictionary<object, object>();

			foreach (Local local in methodDef.Body.Variables)
			{
				var newLocal = new Local(ctx.Importer.Import(local.Type));
				newMethodDef.Body.Variables.Add(newLocal);
				newLocal.Name = local.Name;

				bodyMap[local] = newLocal;
			}

			foreach (Instruction instr in methodDef.Body.Instructions)
			{
				var newInstr = new Instruction(instr.OpCode, instr.Operand)
				{
					SequencePoint = instr.SequencePoint
				};

				switch (newInstr.Operand)
				{
					case IType type:
						newInstr.Operand = ctx.Importer.Import(type);
						break;
					case IMethod method:
						newInstr.Operand = ctx.Importer.Import(method);
						break;
					case IField field:
						newInstr.Operand = ctx.Importer.Import(field);
						break;
				}

				newMethodDef.Body.Instructions.Add(newInstr);
				bodyMap[instr] = newInstr;
			}

			foreach (Instruction instr in newMethodDef.Body.Instructions)
			{
				if (instr.Operand != null && bodyMap.ContainsKey(instr.Operand))
					instr.Operand = bodyMap[instr.Operand];
				else if (instr.Operand is Instruction[] instructions)
					instr.Operand = instructions.Select(target => (Instruction) bodyMap[target]).ToArray();
			}

			foreach (ExceptionHandler eh in methodDef.Body.ExceptionHandlers)
				newMethodDef.Body.ExceptionHandlers.Add(new ExceptionHandler(eh.HandlerType)
				{
					CatchType = eh.CatchType == null ? null : ctx.Importer.Import(eh.CatchType),
					TryStart = (Instruction) bodyMap[eh.TryStart],
					TryEnd = (Instruction) bodyMap[eh.TryEnd],
					HandlerStart = (Instruction) bodyMap[eh.HandlerStart],
					HandlerEnd = (Instruction) bodyMap[eh.HandlerEnd],
					FilterStart = eh.FilterStart == null ? null : (Instruction) bodyMap[eh.FilterStart]
				});

			newMethodDef.Body.SimplifyMacros(newMethodDef.Parameters);
		}

		/// <summary>
		///     Copies the information from the origin field to injected field.
		/// </summary>
		/// <param name="fieldDef">The origin FieldDef.</param>
		/// <param name="ctx">The injection context.</param>
		static void CopyFieldDef(FieldDef fieldDef, InjectContext ctx) {
			var newFieldDef = ctx.Map(fieldDef).ResolveFieldDefThrow();

			newFieldDef.Signature = ctx.Importer.Import(fieldDef.Signature);
		}

		/// <summary>
		///     Copies the information to the injected definitions.
		/// </summary>
		/// <param name="typeDef">The origin TypeDef.</param>
		/// <param name="ctx">The injection context.</param>
		/// <param name="copySelf">if set to <c>true</c>, copy information of <paramref name="typeDef" />.</param>
		static void Copy(TypeDef typeDef, InjectContext ctx, bool copySelf) {
			if (copySelf)
				CopyTypeDef(typeDef, ctx);

			foreach (TypeDef nestedType in typeDef.NestedTypes)
				Copy(nestedType, ctx, true);

			foreach (MethodDef method in typeDef.Methods)
				CopyMethodDef(method, ctx);

			foreach (FieldDef field in typeDef.Fields)
				CopyFieldDef(field, ctx);
		}

		/// <summary>
		///     Injects the specified TypeDef to another module.
		/// </summary>
		/// <param name="typeDef">The source TypeDef.</param>
		/// <param name="target">The target module.</param>
		/// <returns>The injected TypeDef.</returns>
		public static TypeDef Inject(TypeDef typeDef, ModuleDef target) {
			var ctx = new InjectContext(typeDef.Module, target);
			var result = PopulateContext(typeDef, ctx);
			Copy(typeDef, ctx, true);
			return result;
		}

		/// <summary>
		///     Injects the specified MethodDef to another module.
		/// </summary>
		/// <param name="methodDef">The source MethodDef.</param>
		/// <param name="target">The target module.</param>
		/// <returns>The injected MethodDef.</returns>
		public static MethodDef Inject(MethodDef methodDef, ModuleDef target) {
			var ctx = new InjectContext(methodDef.Module, target);
			MethodDef result;
			ctx.DefMap[methodDef] = result = Clone(methodDef);
			CopyMethodDef(methodDef, ctx);
			return result;
		}

		/// <summary>
		///     Injects the members of specified TypeDef to another module.
		/// </summary>
		/// <param name="typeDef">The source TypeDef.</param>
		/// <param name="newType">The new type.</param>
		/// <param name="target">The target module.</param>
		/// <returns>Injected members.</returns>
		public static IEnumerable<IDnlibDef> Inject(TypeDef typeDef, TypeDef newType, ModuleDef target) {
			var ctx = new InjectContext(typeDef.Module, target);
			ctx.DefMap[typeDef] = newType;
			PopulateContext(typeDef, ctx);
			Copy(typeDef, ctx, false);
			return ctx.DefMap.Values.Except(new[] { newType }).OfType<IDnlibDef>();
		}

		/// <summary>
		///     Context of the injection process.
		/// </summary>
		class InjectContext : ImportMapper {
			/// <summary>
			///     The mapping of origin definitions to injected definitions.
			/// </summary>
			public readonly Dictionary<IMemberRef, IMemberRef> DefMap = new Dictionary<IMemberRef, IMemberRef>();

			/// <summary>
			///     The module which source type originated from.
			/// </summary>
			public readonly ModuleDef OriginModule;

			/// <summary>
			///     The module which source type is being injected to.
			/// </summary>
			public readonly ModuleDef TargetModule;

			/// <summary>
			///     Initializes a new instance of the <see cref="InjectContext" /> class.
			/// </summary>
			/// <param name="module">The origin module.</param>
			/// <param name="target">The target module.</param>
			public InjectContext(ModuleDef module, ModuleDef target) {
				OriginModule = module;
				TargetModule = target;
				Importer = new Importer(target, ImporterOptions.TryToUseTypeDefs, new GenericParamContext(), this);
			}

			/// <summary>
			///     Gets the importer.
			/// </summary>
			/// <value>The importer.</value>
			public Importer Importer { get; }

			/// <inheritdoc />
			public override ITypeDefOrRef Map(ITypeDefOrRef source) {
				if (DefMap.TryGetValue(source, out var mappedRef))
					return mappedRef as ITypeDefOrRef;
				
				// check if the assembly reference needs to be fixed.
				if (source is TypeRef sourceRef) {
					var targetAssemblyRef = TargetModule.GetAssemblyRef(sourceRef.DefinitionAssembly.Name);
					if (!(targetAssemblyRef is null) && !string.Equals(targetAssemblyRef.FullName, source.DefinitionAssembly.FullName, StringComparison.Ordinal)) {
						// We got a matching assembly by the simple name, but not by the full name.
						// This means the injected code uses a different assembly version than the target assembly.
						// We'll fix the assembly reference, to avoid breaking anything.
						var fixedTypeRef = new TypeRefUser(sourceRef.Module, sourceRef.Namespace, sourceRef.Name, targetAssemblyRef);
						return Importer.Import(fixedTypeRef);
					}
				}
				return null;
			}

			/// <inheritdoc />
			public override IMethod Map(MethodDef source) {
				if (DefMap.TryGetValue(source, out var mappedRef))
					return mappedRef as IMethod;
				return null;
			}

			/// <inheritdoc />
			public override IField Map(FieldDef source) {
				if (DefMap.TryGetValue(source, out var mappedRef))
					return mappedRef as IField;
				return null;
			}

			public override MemberRef Map(MemberRef source) {
				if (DefMap.TryGetValue(source, out var mappedRef))
					return mappedRef as MemberRef;
				return null;
			}
		}
	}
}

```

`Confuser.Core/Helpers/KeySequence.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core.Services;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Helpers {
	/// <summary>
	///     The type of block in the key sequence
	/// </summary>
	public enum BlockKeyType {
		/// <summary>
		///     The state key should be explicitly set in the block
		/// </summary>
		Explicit,

		/// <summary>
		///     The state key could be assumed to be same as <see cref="BlockKey.EntryState" /> at the beginning of block.
		/// </summary>
		Incremental
	}

	/// <summary>
	///     The information of the block in the key sequence
	/// </summary>
	public struct BlockKey {
		/// <summary>
		///     The state key at the beginning of the block
		/// </summary>
		public uint EntryState;

		/// <summary>
		///     The state key at the end of the block
		/// </summary>
		public uint ExitState;

		/// <summary>
		///     The type of block
		/// </summary>
		public BlockKeyType Type;
	}

	/// <summary>
	///     Computes a key sequence that is valid according to the execution of the CFG.
	/// </summary>
	/// <remarks>
	///     The caller can utilize the information provided by this classes to instruments state machines.
	///     For example:
	///     <code>
	/// int state = 4;
	/// for (int i = 0 ; i &lt; 10; i++) {
	///     state = 6;
	///     if (i % 2 == 0) {
	///         state = 3;
	///     else {
	///         // The state varaible is guaranteed to be 6 in here.
	///     }
	/// }
	///     </code>
	/// </remarks>
	public static class KeySequence {
		/// <summary>
		///     Computes a key sequence of the given CFG.
		/// </summary>
		/// <param name="graph">The CFG.</param>
		/// <param name="random">The random source, or <c>null</c> if key id is needed.</param>
		/// <returns>The generated key sequence of the CFG.</returns>
		public static BlockKey[] ComputeKeys(ControlFlowGraph graph, RandomGenerator random) {
			var keys = new BlockKey[graph.Count];

			foreach (ControlFlowBlock block in graph) {
				var key = new BlockKey();
				if ((block.Type & ControlFlowBlockType.Entry) != 0)
					key.Type = BlockKeyType.Explicit;
				else
					key.Type = BlockKeyType.Incremental;
				keys[block.Id] = key;
			}
			ProcessBlocks(keys, graph, random);
			return keys;
		}

		static void ProcessBlocks(BlockKey[] keys, ControlFlowGraph graph, RandomGenerator random) {
			uint id = 0;
			for (int i = 0; i < keys.Length; i++) {
				keys[i].EntryState = id++;
				keys[i].ExitState = id++;
			}

			var finallyIds = new Dictionary<ExceptionHandler, uint>();
			var ehMap = new Dictionary<ControlFlowBlock, List<ExceptionHandler>>();

			bool updated;
			do {
				updated = false;

				// Update the state ids with the maximum id
				foreach (ControlFlowBlock block in graph) {
					BlockKey key = keys[block.Id];
					if (block.Sources.Count > 0) {
						uint newEntry = block.Sources.Select(b => keys[b.Id].ExitState).Max();
						if (key.EntryState != newEntry) {
							key.EntryState = newEntry;
							updated = true;
						}
					}
					if (block.Targets.Count > 0) {
						uint newExit = block.Targets.Select(b => keys[b.Id].EntryState).Max();
						if (key.ExitState != newExit) {
							key.ExitState = newExit;
							updated = true;
						}
					}
					if (block.Footer.OpCode.Code == Code.Endfilter || block.Footer.OpCode.Code == Code.Endfinally) {
						// Match the exit state within finally/fault/filter
						List<ExceptionHandler> ehs;
						if (!ehMap.TryGetValue(block, out ehs)) {
							ehs = new List<ExceptionHandler>();
							int footerIndex = graph.IndexOf(block.Footer);
							foreach (var eh in graph.Body.ExceptionHandlers) {
								if (eh.FilterStart != null && block.Footer.OpCode.Code == Code.Endfilter) {
									if (footerIndex >= graph.IndexOf(eh.FilterStart) &&
									    footerIndex < graph.IndexOf(eh.HandlerStart))
										ehs.Add(eh);
								}
								else if (eh.HandlerType == ExceptionHandlerType.Finally ||
								         eh.HandlerType == ExceptionHandlerType.Fault) {
									if (footerIndex >= graph.IndexOf(eh.HandlerStart) &&
									    (eh.HandlerEnd == null || footerIndex < graph.IndexOf(eh.HandlerEnd)))
										ehs.Add(eh);
								}
							}
							ehMap[block] = ehs;
						}
						foreach (var eh in ehs) {
							uint ehVal;
							if (finallyIds.TryGetValue(eh, out ehVal)) {
								if (key.ExitState > ehVal) {
									finallyIds[eh] = key.ExitState;
									updated = true;
								}
								else if (key.ExitState < ehVal) {
									key.ExitState = ehVal;
									updated = true;
								}
							}
							else {
								finallyIds[eh] = key.ExitState;
								updated = true;
							}
						}
					}
					else if (block.Footer.OpCode.Code == Code.Leave || block.Footer.OpCode.Code == Code.Leave_S) {
						// Match the exit state with finally/fault/filter
						List<ExceptionHandler> ehs;
						if (!ehMap.TryGetValue(block, out ehs)) {
							ehs = new List<ExceptionHandler>();
							int footerIndex = graph.IndexOf(block.Footer);
							foreach (var eh in graph.Body.ExceptionHandlers) {
								if (footerIndex >= graph.IndexOf(eh.TryStart) &&
								    (eh.TryEnd == null || footerIndex < graph.IndexOf(eh.TryEnd)))
									ehs.Add(eh);
							}
							ehMap[block] = ehs;
						}

						uint? maxVal = null;
						foreach (var eh in ehs) {
							uint ehVal;
							if (finallyIds.TryGetValue(eh, out ehVal) && (maxVal == null || ehVal > maxVal)) {
								if (maxVal != null)
									updated = true;
								maxVal = ehVal;
							}
						}
						if (maxVal != null) {
							if (key.ExitState > maxVal.Value) {
								maxVal = key.ExitState;
								updated = true;
							}
							else if (key.ExitState < maxVal.Value) {
								key.ExitState = maxVal.Value;
								updated = true;
							}
							foreach (var eh in ehs)
								finallyIds[eh] = maxVal.Value;
						}
					}
					keys[block.Id] = key;
				}
			} while (updated);

			if (random != null) {
				// Replace id with actual values
				var idMap = new Dictionary<uint, uint>();
				for (int i = 0; i < keys.Length; i++) {
					BlockKey key = keys[i];

					uint entryId = key.EntryState;
					if (!idMap.TryGetValue(entryId, out key.EntryState))
						key.EntryState = idMap[entryId] = random.NextUInt32();

					uint exitId = key.ExitState;
					if (!idMap.TryGetValue(exitId, out key.ExitState))
						key.ExitState = idMap[exitId] = random.NextUInt32();

					keys[i] = key;
				}
			}
		}
	}
}
```

`Confuser.Core/Helpers/MutationHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Helpers {
	/// <summary>
	///     Provides methods to mutated injected methods.
	/// </summary>
	public static class MutationHelper {
		const string mutationType = "Mutation";

		static readonly Dictionary<string, int> field2index = new Dictionary<string, int> {
			{ "KeyI0", 0 },
			{ "KeyI1", 1 },
			{ "KeyI2", 2 },
			{ "KeyI3", 3 },
			{ "KeyI4", 4 },
			{ "KeyI5", 5 },
			{ "KeyI6", 6 },
			{ "KeyI7", 7 },
			{ "KeyI8", 8 },
			{ "KeyI9", 9 },
			{ "KeyI10", 10 },
			{ "KeyI11", 11 },
			{ "KeyI12", 12 },
			{ "KeyI13", 13 },
			{ "KeyI14", 14 },
			{ "KeyI15", 15 }
		};

		/// <summary>
		///     Replaces the mutation key placeholder in method with actual key.
		/// </summary>
		/// <param name="method">The method to process.</param>
		/// <param name="keyId">The mutation key ID.</param>
		/// <param name="key">The actual key.</param>
		public static void InjectKey(MethodDef method, int keyId, int key) {
			foreach (Instruction instr in method.Body.Instructions) {
				if (instr.OpCode == OpCodes.Ldsfld) {
					var field = (IField)instr.Operand;
					int _keyId;
					if (field.DeclaringType.FullName == mutationType &&
					    field2index.TryGetValue(field.Name, out _keyId) &&
					    _keyId == keyId) {
						instr.OpCode = OpCodes.Ldc_I4;
						instr.Operand = key;
					}
				}
			}
		}

		/// <summary>
		///     Replaces the mutation key placeholders in method with actual keys.
		/// </summary>
		/// <param name="method">The method to process.</param>
		/// <param name="keyIds">The mutation key IDs.</param>
		/// <param name="keys">The actual keys.</param>
		public static void InjectKeys(MethodDef method, int[] keyIds, int[] keys) {
			foreach (Instruction instr in method.Body.Instructions) {
				if (instr.OpCode == OpCodes.Ldsfld) {
					var field = (IField)instr.Operand;
					int _keyIndex;
					if (field.DeclaringType.FullName == mutationType &&
					    field2index.TryGetValue(field.Name, out _keyIndex) &&
					    (_keyIndex = Array.IndexOf(keyIds, _keyIndex)) != -1) {
						instr.OpCode = OpCodes.Ldc_I4;
						instr.Operand = keys[_keyIndex];
					}
				}
			}
		}

		/// <summary>
		///     Replaces the placeholder call in method with actual instruction sequence.
		/// </summary>
		/// <param name="method">The methodto process.</param>
		/// <param name="repl">The function replacing the argument of placeholder call with actual instruction sequence.</param>
		public static void ReplacePlaceholder(MethodDef method, Func<Instruction[], Instruction[]> repl) {
			MethodTrace trace = new MethodTrace(method).Trace();
			for (int i = 0; i < method.Body.Instructions.Count; i++) {
				Instruction instr = method.Body.Instructions[i];
				if (instr.OpCode == OpCodes.Call) {
					var operand = (IMethod)instr.Operand;
					if (operand.DeclaringType.FullName == mutationType &&
					    operand.Name == "Placeholder") {
						var initialLoadInstructions = new List<Instruction>();
						var pendingInstructions = new Queue<Instruction>();
						pendingInstructions.Enqueue(instr);
						while (pendingInstructions.Count > 0) {
							var currentInstr = pendingInstructions.Dequeue();
							int[] argIndexes = trace.TraceArguments(currentInstr);
							if (argIndexes == null)
								throw new ArgumentException("Failed to trace placeholder argument.");

							if (argIndexes.Length == 0)
								initialLoadInstructions.Add(currentInstr);

							foreach (int argIndex in argIndexes)
								pendingInstructions.Enqueue(method.Body.Instructions[argIndex]);
						}

						var firstArgIndex = initialLoadInstructions.Select(method.Body.Instructions.IndexOf).Min();
						Instruction[] arg = method.Body.Instructions.Skip(firstArgIndex).Take(i - firstArgIndex).ToArray();
						for (int j = 0; j < arg.Length; j++)
							method.Body.Instructions.RemoveAt(firstArgIndex);
						method.Body.Instructions.RemoveAt(firstArgIndex);
						arg = repl(arg);
						for (int j = arg.Length - 1; j >= 0; j--)
							method.Body.Instructions.Insert(firstArgIndex, arg[j]);
						return;
					}
				}
			}
		}
	}
}

```

`Confuser.Core/ILogger.cs`:

```cs
using System;

namespace Confuser.Core {
	/// <summary>
	///     Defines a logger used to log Confuser events
	/// </summary>
	public interface ILogger {
		/// <summary>
		///     Logs a message at DEBUG level.
		/// </summary>
		/// <param name="msg">The message.</param>
		void Debug(string msg);

		/// <summary>
		///     Logs a message at DEBUG level with specified parameters.
		/// </summary>
		/// <param name="format">The format.</param>
		/// <param name="args">The arguments.</param>
		void DebugFormat(string format, params object[] args);

		/// <summary>
		///     Logs a message at INFO level.
		/// </summary>
		/// <param name="msg">The message.</param>
		void Info(string msg);

		/// <summary>
		///     Logs a message at INFO level with specified parameters.
		/// </summary>
		/// <param name="format">The format.</param>
		/// <param name="args">The arguments.</param>
		void InfoFormat(string format, params object[] args);

		/// <summary>
		///     Logs a message at WARN level.
		/// </summary>
		/// <param name="msg">The message.</param>
		void Warn(string msg);

		/// <summary>
		///     Logs a message at WARN level with specified parameters.
		/// </summary>
		/// <param name="format">The format.</param>
		/// <param name="args">The arguments.</param>
		void WarnFormat(string format, params object[] args);

		/// <summary>
		///     Logs a message at WARN level with specified exception.
		/// </summary>
		/// <param name="msg">The message.</param>
		/// <param name="ex">The exception.</param>
		void WarnException(string msg, Exception ex);

		/// <summary>
		///     Logs a message at ERROR level.
		/// </summary>
		/// <param name="msg">The message.</param>
		void Error(string msg);

		/// <summary>
		///     Logs a message at ERROR level with specified parameters.
		/// </summary>
		/// <param name="format">The format.</param>
		/// <param name="args">The arguments.</param>
		void ErrorFormat(string format, params object[] args);

		/// <summary>
		///     Logs a message at ERROR level with specified exception.
		/// </summary>
		/// <param name="msg">The message.</param>
		/// <param name="ex">The exception.</param>
		void ErrorException(string msg, Exception ex);

		/// <summary>
		///     Logs the progress of protection.
		/// </summary>
		/// <remarks>
		///     This method is intended to be used with <see cref="EndProgress" />.
		/// </remarks>
		/// <example>
		///     <code> 
		///         for (int i = 0; i &lt; defs.Length; i++) {
		///             logger.Progress(i + 1, defs.Length);
		///         }
		///         logger.EndProgress();
		///     </code>
		/// </example>
		/// <param name="overall">The total work amount .</param>
		/// <param name="progress">The amount of work done.</param>
		void Progress(int progress, int overall);

		/// <summary>
		///     End the progress of protection.
		/// </summary>
		/// <seealso cref="Progress" />
		void EndProgress();

		/// <summary>
		///     Logs the finish of protection.
		/// </summary>
		/// <param name="successful">Indicated whether the protection process is successful.</param>
		void Finish(bool successful);
	}
}
```

`Confuser.Core/LZMA/Common/CRC.cs`:

```cs
// Common/CRC.cs

using System;

namespace SevenZip {
	internal class CRC {

		public static readonly uint[] Table;

		private uint _value = 0xFFFFFFFF;

		static CRC() {
			Table = new uint[256];
			const uint kPoly = 0xEDB88320;
			for (uint i = 0; i < 256; i++) {
				uint r = i;
				for (int j = 0; j < 8; j++)
					if ((r & 1) != 0)
						r = (r >> 1) ^ kPoly;
					else
						r >>= 1;
				Table[i] = r;
			}
		}

		public void Init() {
			_value = 0xFFFFFFFF;
		}

		public void UpdateByte(byte b) {
			_value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
		}

		public void Update(byte[] data, uint offset, uint size) {
			for (uint i = 0; i < size; i++)
				_value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
		}

		public uint GetDigest() {
			return _value ^ 0xFFFFFFFF;
		}

		private static uint CalculateDigest(byte[] data, uint offset, uint size) {
			var crc = new CRC();
			// crc.Init();
			crc.Update(data, offset, size);
			return crc.GetDigest();
		}

		private static bool VerifyDigest(uint digest, byte[] data, uint offset, uint size) {
			return (CalculateDigest(data, offset, size) == digest);
		}

	}
}
```

`Confuser.Core/LZMA/Common/InBuffer.cs`:

```cs
// InBuffer.cs

using System;
using System.IO;

namespace SevenZip.Buffer {
	internal class InBuffer {

		private readonly byte[] m_Buffer;
		private readonly uint m_BufferSize;
		private uint m_Limit;
		private uint m_Pos;
		private ulong m_ProcessedSize;
		private Stream m_Stream;
		private bool m_StreamWasExhausted;

		public InBuffer(uint bufferSize) {
			m_Buffer = new byte[bufferSize];
			m_BufferSize = bufferSize;
		}

		public void Init(Stream stream) {
			m_Stream = stream;
			m_ProcessedSize = 0;
			m_Limit = 0;
			m_Pos = 0;
			m_StreamWasExhausted = false;
		}

		public bool ReadBlock() {
			if (m_StreamWasExhausted)
				return false;
			m_ProcessedSize += m_Pos;
			int aNumProcessedBytes = m_Stream.Read(m_Buffer, 0, (int)m_BufferSize);
			m_Pos = 0;
			m_Limit = (uint)aNumProcessedBytes;
			m_StreamWasExhausted = (aNumProcessedBytes == 0);
			return (!m_StreamWasExhausted);
		}


		public void ReleaseStream() {
			// m_Stream.Close(); 
			m_Stream = null;
		}

		public bool ReadByte(byte b) // check it
		{
			if (m_Pos >= m_Limit)
				if (!ReadBlock())
					return false;
			b = m_Buffer[m_Pos++];
			return true;
		}

		public byte ReadByte() {
			// return (byte)m_Stream.ReadByte();
			if (m_Pos >= m_Limit)
				if (!ReadBlock())
					return 0xFF;
			return m_Buffer[m_Pos++];
		}

		public ulong GetProcessedSize() {
			return m_ProcessedSize + m_Pos;
		}

	}
}
```

`Confuser.Core/LZMA/Common/OutBuffer.cs`:

```cs
// OutBuffer.cs

using System;
using System.IO;

namespace SevenZip.Buffer {
	internal class OutBuffer {

		private readonly byte[] m_Buffer;
		private readonly uint m_BufferSize;
		private uint m_Pos;
		private ulong m_ProcessedSize;
		private Stream m_Stream;

		public OutBuffer(uint bufferSize) {
			m_Buffer = new byte[bufferSize];
			m_BufferSize = bufferSize;
		}

		public void SetStream(Stream stream) {
			m_Stream = stream;
		}

		public void FlushStream() {
			m_Stream.Flush();
		}

		public void CloseStream() {
			m_Stream.Close();
		}

		public void ReleaseStream() {
			m_Stream = null;
		}

		public void Init() {
			m_ProcessedSize = 0;
			m_Pos = 0;
		}

		public void WriteByte(byte b) {
			m_Buffer[m_Pos++] = b;
			if (m_Pos >= m_BufferSize)
				FlushData();
		}

		public void FlushData() {
			if (m_Pos == 0)
				return;
			m_Stream.Write(m_Buffer, 0, (int)m_Pos);
			m_Pos = 0;
		}

		public ulong GetProcessedSize() {
			return m_ProcessedSize + m_Pos;
		}

	}
}
```

`Confuser.Core/LZMA/Compress/LZ/IMatchFinder.cs`:

```cs
// IMatchFinder.cs

using System;
using System.IO;

namespace SevenZip.Compression.LZ {
	internal interface IInWindowStream {

		void SetStream(Stream inStream);
		void Init();
		void ReleaseStream();
		Byte GetIndexByte(Int32 index);
		UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit);
		UInt32 GetNumAvailableBytes();

	}

	internal interface IMatchFinder : IInWindowStream {

		void Create(UInt32 historySize, UInt32 keepAddBufferBefore,
		            UInt32 matchMaxLen, UInt32 keepAddBufferAfter);

		UInt32 GetMatches(UInt32[] distances);
		void Skip(UInt32 num);

	}
}
```

`Confuser.Core/LZMA/Compress/LZ/LzBinTree.cs`:

```cs
// LzBinTree.cs

using System;
using System.IO;

namespace SevenZip.Compression.LZ {
	internal class BinTree : InWindow, IMatchFinder {

		private const UInt32 kHash2Size = 1 << 10;
		private const UInt32 kHash3Size = 1 << 16;
		private const UInt32 kBT2HashSize = 1 << 16;
		private const UInt32 kStartMaxLen = 1;
		private const UInt32 kHash3Offset = kHash2Size;
		private const UInt32 kEmptyHashValue = 0;
		private const UInt32 kMaxValForNormalize = ((UInt32)1 << 31) - 1;
		private bool HASH_ARRAY = true;
		private UInt32 _cutValue = 0xFF;
		private UInt32 _cyclicBufferPos;
		private UInt32 _cyclicBufferSize;
		private UInt32[] _hash;
		private UInt32 _hashMask;
		private UInt32 _hashSizeSum;
		private UInt32 _matchMaxLen;

		private UInt32[] _son;

		private UInt32 kFixHashSize = kHash2Size + kHash3Size;
		private UInt32 kMinMatchCheck = 4;
		private UInt32 kNumHashDirectBytes;

		public new void SetStream(Stream stream) {
			base.SetStream(stream);
		}

		public new void ReleaseStream() {
			base.ReleaseStream();
		}

		public new void Init() {
			base.Init();
			for (UInt32 i = 0; i < _hashSizeSum; i++)
				_hash[i] = kEmptyHashValue;
			_cyclicBufferPos = 0;
			ReduceOffsets(-1);
		}

		public new Byte GetIndexByte(Int32 index) {
			return base.GetIndexByte(index);
		}

		public new UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit) {
			return base.GetMatchLen(index, distance, limit);
		}

		public new UInt32 GetNumAvailableBytes() {
			return base.GetNumAvailableBytes();
		}

		public void Create(UInt32 historySize, UInt32 keepAddBufferBefore,
		                   UInt32 matchMaxLen, UInt32 keepAddBufferAfter) {
			if (historySize > kMaxValForNormalize - 256)
				throw new Exception();
			_cutValue = 16 + (matchMaxLen >> 1);

			UInt32 windowReservSize = (historySize + keepAddBufferBefore +
			                           matchMaxLen + keepAddBufferAfter) / 2 + 256;

			base.Create(historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, windowReservSize);

			_matchMaxLen = matchMaxLen;

			UInt32 cyclicBufferSize = historySize + 1;
			if (_cyclicBufferSize != cyclicBufferSize)
				_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];

			UInt32 hs = kBT2HashSize;

			if (HASH_ARRAY) {
				hs = historySize - 1;
				hs |= (hs >> 1);
				hs |= (hs >> 2);
				hs |= (hs >> 4);
				hs |= (hs >> 8);
				hs >>= 1;
				hs |= 0xFFFF;
				if (hs > (1 << 24))
					hs >>= 1;
				_hashMask = hs;
				hs++;
				hs += kFixHashSize;
			}
			if (hs != _hashSizeSum)
				_hash = new UInt32[_hashSizeSum = hs];
		}

		public UInt32 GetMatches(UInt32[] distances) {
			UInt32 lenLimit;
			if (_pos + _matchMaxLen <= _streamPos)
				lenLimit = _matchMaxLen;
			else {
				lenLimit = _streamPos - _pos;
				if (lenLimit < kMinMatchCheck) {
					MovePos();
					return 0;
				}
			}

			UInt32 offset = 0;
			UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
			UInt32 cur = _bufferOffset + _pos;
			UInt32 maxLen = kStartMaxLen; // to avoid items for len < hashSize;
			UInt32 hashValue, hash2Value = 0, hash3Value = 0;

			if (HASH_ARRAY) {
				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];
				hash2Value = temp & (kHash2Size - 1);
				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
				hash3Value = temp & (kHash3Size - 1);
				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
			}
			else
				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);

			UInt32 curMatch = _hash[kFixHashSize + hashValue];
			if (HASH_ARRAY) {
				UInt32 curMatch2 = _hash[hash2Value];
				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];
				_hash[hash2Value] = _pos;
				_hash[kHash3Offset + hash3Value] = _pos;
				if (curMatch2 > matchMinPos)
					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur]) {
						distances[offset++] = maxLen = 2;
						distances[offset++] = _pos - curMatch2 - 1;
					}
				if (curMatch3 > matchMinPos)
					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur]) {
						if (curMatch3 == curMatch2)
							offset -= 2;
						distances[offset++] = maxLen = 3;
						distances[offset++] = _pos - curMatch3 - 1;
						curMatch2 = curMatch3;
					}
				if (offset != 0 && curMatch2 == curMatch) {
					offset -= 2;
					maxLen = kStartMaxLen;
				}
			}

			_hash[kFixHashSize + hashValue] = _pos;

			UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;
			UInt32 ptr1 = (_cyclicBufferPos << 1);

			UInt32 len0, len1;
			len0 = len1 = kNumHashDirectBytes;

			if (kNumHashDirectBytes != 0) {
				if (curMatch > matchMinPos) {
					if (_bufferBase[_bufferOffset + curMatch + kNumHashDirectBytes] !=
					    _bufferBase[cur + kNumHashDirectBytes]) {
						distances[offset++] = maxLen = kNumHashDirectBytes;
						distances[offset++] = _pos - curMatch - 1;
					}
				}
			}

			UInt32 count = _cutValue;

			while (true) {
				if (curMatch <= matchMinPos || count-- == 0) {
					_son[ptr0] = _son[ptr1] = kEmptyHashValue;
					break;
				}
				UInt32 delta = _pos - curMatch;
				UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?
					                    (_cyclicBufferPos - delta) :
					                    (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;

				UInt32 pby1 = _bufferOffset + curMatch;
				UInt32 len = Math.Min(len0, len1);
				if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {
					while (++len != lenLimit)
						if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
							break;
					if (maxLen < len) {
						distances[offset++] = maxLen = len;
						distances[offset++] = delta - 1;
						if (len == lenLimit) {
							_son[ptr1] = _son[cyclicPos];
							_son[ptr0] = _son[cyclicPos + 1];
							break;
						}
					}
				}
				if (_bufferBase[pby1 + len] < _bufferBase[cur + len]) {
					_son[ptr1] = curMatch;
					ptr1 = cyclicPos + 1;
					curMatch = _son[ptr1];
					len1 = len;
				}
				else {
					_son[ptr0] = curMatch;
					ptr0 = cyclicPos;
					curMatch = _son[ptr0];
					len0 = len;
				}
			}
			MovePos();
			return offset;
		}

		public void Skip(UInt32 num) {
			do {
				UInt32 lenLimit;
				if (_pos + _matchMaxLen <= _streamPos)
					lenLimit = _matchMaxLen;
				else {
					lenLimit = _streamPos - _pos;
					if (lenLimit < kMinMatchCheck) {
						MovePos();
						continue;
					}
				}

				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
				UInt32 cur = _bufferOffset + _pos;

				UInt32 hashValue;

				if (HASH_ARRAY) {
					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];
					UInt32 hash2Value = temp & (kHash2Size - 1);
					_hash[hash2Value] = _pos;
					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
					UInt32 hash3Value = temp & (kHash3Size - 1);
					_hash[kHash3Offset + hash3Value] = _pos;
					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
				}
				else
					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);

				UInt32 curMatch = _hash[kFixHashSize + hashValue];
				_hash[kFixHashSize + hashValue] = _pos;

				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;
				UInt32 ptr1 = (_cyclicBufferPos << 1);

				UInt32 len0, len1;
				len0 = len1 = kNumHashDirectBytes;

				UInt32 count = _cutValue;
				while (true) {
					if (curMatch <= matchMinPos || count-- == 0) {
						_son[ptr0] = _son[ptr1] = kEmptyHashValue;
						break;
					}

					UInt32 delta = _pos - curMatch;
					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?
						                    (_cyclicBufferPos - delta) :
						                    (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;

					UInt32 pby1 = _bufferOffset + curMatch;
					UInt32 len = Math.Min(len0, len1);
					if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {
						while (++len != lenLimit)
							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
								break;
						if (len == lenLimit) {
							_son[ptr1] = _son[cyclicPos];
							_son[ptr0] = _son[cyclicPos + 1];
							break;
						}
					}
					if (_bufferBase[pby1 + len] < _bufferBase[cur + len]) {
						_son[ptr1] = curMatch;
						ptr1 = cyclicPos + 1;
						curMatch = _son[ptr1];
						len1 = len;
					}
					else {
						_son[ptr0] = curMatch;
						ptr0 = cyclicPos;
						curMatch = _son[ptr0];
						len0 = len;
					}
				}
				MovePos();
			} while (--num != 0);
		}

		public void SetType(int numHashBytes) {
			HASH_ARRAY = (numHashBytes > 2);
			if (HASH_ARRAY) {
				kNumHashDirectBytes = 0;
				kMinMatchCheck = 4;
				kFixHashSize = kHash2Size + kHash3Size;
			}
			else {
				kNumHashDirectBytes = 2;
				kMinMatchCheck = 2 + 1;
				kFixHashSize = 0;
			}
		}

		public new void MovePos() {
			if (++_cyclicBufferPos >= _cyclicBufferSize)
				_cyclicBufferPos = 0;
			base.MovePos();
			if (_pos == kMaxValForNormalize)
				Normalize();
		}

		private void NormalizeLinks(UInt32[] items, UInt32 numItems, UInt32 subValue) {
			for (UInt32 i = 0; i < numItems; i++) {
				UInt32 value = items[i];
				if (value <= subValue)
					value = kEmptyHashValue;
				else
					value -= subValue;
				items[i] = value;
			}
		}

		private void Normalize() {
			UInt32 subValue = _pos - _cyclicBufferSize;
			NormalizeLinks(_son, _cyclicBufferSize * 2, subValue);
			NormalizeLinks(_hash, _hashSizeSum, subValue);
			ReduceOffsets((Int32)subValue);
		}

		public void SetCutValue(UInt32 cutValue) {
			_cutValue = cutValue;
		}

	}
}
```

`Confuser.Core/LZMA/Compress/LZ/LzInWindow.cs`:

```cs
// LzInWindow.cs

using System;
using System.IO;

namespace SevenZip.Compression.LZ {
	internal class InWindow {

		public UInt32 _blockSize; // Size of Allocated memory block
		public Byte[] _bufferBase = null; // pointer to buffer with data

		public UInt32 _bufferOffset;

		private UInt32 _keepSizeAfter; // how many BYTEs must be kept buffer after _pos
		private UInt32 _keepSizeBefore; // how many BYTEs must be kept in buffer before _pos
		private UInt32 _pointerToLastSafePosition;
		public UInt32 _pos; // offset (from _buffer) of curent byte
		private UInt32 _posLimit; // offset (from _buffer) of first byte when new block reading must be done
		private Stream _stream;
		private bool _streamEndWasReached; // if (true) then _streamPos shows real end of stream
		public UInt32 _streamPos; // offset (from _buffer) of first not read byte from Stream

		public void MoveBlock() {
			UInt32 offset = _bufferOffset + _pos - _keepSizeBefore;
			// we need one additional byte, since MovePos moves on 1 byte.
			if (offset > 0)
				offset--;

			UInt32 numBytes = _bufferOffset + _streamPos - offset;

			// check negative offset ????
			for (UInt32 i = 0; i < numBytes; i++)
				_bufferBase[i] = _bufferBase[offset + i];
			_bufferOffset -= offset;
		}

		public virtual void ReadBlock() {
			if (_streamEndWasReached)
				return;
			while (true) {
				var size = (int)((0 - _bufferOffset) + _blockSize - _streamPos);
				if (size == 0)
					return;
				int numReadBytes = _stream.Read(_bufferBase, (int)(_bufferOffset + _streamPos), size);
				if (numReadBytes == 0) {
					_posLimit = _streamPos;
					UInt32 pointerToPostion = _bufferOffset + _posLimit;
					if (pointerToPostion > _pointerToLastSafePosition)
						_posLimit = _pointerToLastSafePosition - _bufferOffset;

					_streamEndWasReached = true;
					return;
				}
				_streamPos += (UInt32)numReadBytes;
				if (_streamPos >= _pos + _keepSizeAfter)
					_posLimit = _streamPos - _keepSizeAfter;
			}
		}

		private void Free() {
			_bufferBase = null;
		}

		public void Create(UInt32 keepSizeBefore, UInt32 keepSizeAfter, UInt32 keepSizeReserv) {
			_keepSizeBefore = keepSizeBefore;
			_keepSizeAfter = keepSizeAfter;
			UInt32 blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
			if (_bufferBase == null || _blockSize != blockSize) {
				Free();
				_blockSize = blockSize;
				_bufferBase = new Byte[_blockSize];
			}
			_pointerToLastSafePosition = _blockSize - keepSizeAfter;
		}

		public void SetStream(Stream stream) {
			_stream = stream;
		}

		public void ReleaseStream() {
			_stream = null;
		}

		public void Init() {
			_bufferOffset = 0;
			_pos = 0;
			_streamPos = 0;
			_streamEndWasReached = false;
			ReadBlock();
		}

		public void MovePos() {
			_pos++;
			if (_pos > _posLimit) {
				UInt32 pointerToPostion = _bufferOffset + _pos;
				if (pointerToPostion > _pointerToLastSafePosition)
					MoveBlock();
				ReadBlock();
			}
		}

		public Byte GetIndexByte(Int32 index) {
			return _bufferBase[_bufferOffset + _pos + index];
		}

		// index + limit have not to exceed _keepSizeAfter;
		public UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit) {
			if (_streamEndWasReached)
				if ((_pos + index) + limit > _streamPos)
					limit = _streamPos - (UInt32)(_pos + index);
			distance++;
			// Byte *pby = _buffer + (size_t)_pos + index;
			UInt32 pby = _bufferOffset + _pos + (UInt32)index;

			UInt32 i;
			for (i = 0; i < limit && _bufferBase[pby + i] == _bufferBase[pby + i - distance]; i++) ;
			return i;
		}

		public UInt32 GetNumAvailableBytes() {
			return _streamPos - _pos;
		}

		public void ReduceOffsets(Int32 subValue) {
			_bufferOffset += (UInt32)subValue;
			_posLimit -= (UInt32)subValue;
			_pos -= (UInt32)subValue;
			_streamPos -= (UInt32)subValue;
		}

	}
}
```

`Confuser.Core/LZMA/Compress/LZ/LzOutWindow.cs`:

```cs
// LzOutWindow.cs

using System;
using System.IO;

namespace SevenZip.Compression.LZ {
	internal class OutWindow {

		public uint TrainSize = 0;
		private byte[] _buffer;
		private uint _pos;
		private Stream _stream;
		private uint _streamPos;
		private uint _windowSize;

		public void Create(uint windowSize) {
			if (_windowSize != windowSize) {
				// System.GC.Collect();
				_buffer = new byte[windowSize];
			}
			_windowSize = windowSize;
			_pos = 0;
			_streamPos = 0;
		}

		public void Init(Stream stream, bool solid) {
			ReleaseStream();
			_stream = stream;
			if (!solid) {
				_streamPos = 0;
				_pos = 0;
				TrainSize = 0;
			}
		}

		public bool Train(Stream stream) {
			long len = stream.Length;
			uint size = (len < _windowSize) ? (uint)len : _windowSize;
			TrainSize = size;
			stream.Position = len - size;
			_streamPos = _pos = 0;
			while (size > 0) {
				uint curSize = _windowSize - _pos;
				if (size < curSize)
					curSize = size;
				int numReadBytes = stream.Read(_buffer, (int)_pos, (int)curSize);
				if (numReadBytes == 0)
					return false;
				size -= (uint)numReadBytes;
				_pos += (uint)numReadBytes;
				_streamPos += (uint)numReadBytes;
				if (_pos == _windowSize)
					_streamPos = _pos = 0;
			}
			return true;
		}

		public void ReleaseStream() {
			Flush();
			_stream = null;
		}

		public void Flush() {
			uint size = _pos - _streamPos;
			if (size == 0)
				return;
			_stream.Write(_buffer, (int)_streamPos, (int)size);
			if (_pos >= _windowSize)
				_pos = 0;
			_streamPos = _pos;
		}

		public void CopyBlock(uint distance, uint len) {
			uint pos = _pos - distance - 1;
			if (pos >= _windowSize)
				pos += _windowSize;
			for (; len > 0; len--) {
				if (pos >= _windowSize)
					pos = 0;
				_buffer[_pos++] = _buffer[pos++];
				if (_pos >= _windowSize)
					Flush();
			}
		}

		public void PutByte(byte b) {
			_buffer[_pos++] = b;
			if (_pos >= _windowSize)
				Flush();
		}

		public byte GetByte(uint distance) {
			uint pos = _pos - distance - 1;
			if (pos >= _windowSize)
				pos += _windowSize;
			return _buffer[pos];
		}

	}
}
```

`Confuser.Core/LZMA/Compress/LZMA/LzmaBase.cs`:

```cs
// LzmaBase.cs

using System;

namespace SevenZip.Compression.LZMA {
	internal abstract class Base {

		public const uint kNumRepDistances = 4;
		public const uint kNumStates = 12;

		// static byte []kLiteralNextStates  = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
		// static byte []kMatchNextStates    = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
		// static byte []kRepNextStates      = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
		// static byte []kShortRepNextStates = {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};

		public const int kNumPosSlotBits = 6;
		public const int kDicLogSizeMin = 0;
		// public const int kDicLogSizeMax = 30;
		// public const uint kDistTableSizeMax = kDicLogSizeMax * 2;

		public const int kNumLenToPosStatesBits = 2; // it's for speed optimization
		public const uint kNumLenToPosStates = 1 << kNumLenToPosStatesBits;

		public const uint kMatchMinLen = 2;

		public const int kNumAlignBits = 4;
		public const uint kAlignTableSize = 1 << kNumAlignBits;
		public const uint kAlignMask = (kAlignTableSize - 1);

		public const uint kStartPosModelIndex = 4;
		public const uint kEndPosModelIndex = 14;
		public const uint kNumPosModels = kEndPosModelIndex - kStartPosModelIndex;

		public const uint kNumFullDistances = 1 << ((int)kEndPosModelIndex / 2);

		public const uint kNumLitPosStatesBitsEncodingMax = 4;
		public const uint kNumLitContextBitsMax = 8;

		public const int kNumPosStatesBitsMax = 4;
		public const uint kNumPosStatesMax = (1 << kNumPosStatesBitsMax);
		public const int kNumPosStatesBitsEncodingMax = 4;
		public const uint kNumPosStatesEncodingMax = (1 << kNumPosStatesBitsEncodingMax);

		public const int kNumLowLenBits = 3;
		public const int kNumMidLenBits = 3;
		public const int kNumHighLenBits = 8;
		public const uint kNumLowLenSymbols = 1 << kNumLowLenBits;
		public const uint kNumMidLenSymbols = 1 << kNumMidLenBits;

		public const uint kNumLenSymbols = kNumLowLenSymbols + kNumMidLenSymbols +
		                                   (1 << kNumHighLenBits);

		public const uint kMatchMaxLen = kMatchMinLen + kNumLenSymbols - 1;

		public static uint GetLenToPosState(uint len) {
			len -= kMatchMinLen;
			if (len < kNumLenToPosStates)
				return len;
			return kNumLenToPosStates - 1;
		}

		public struct State {

			public uint Index;

			public void Init() {
				Index = 0;
			}

			public void UpdateChar() {
				if (Index < 4) Index = 0;
				else if (Index < 10) Index -= 3;
				else Index -= 6;
			}

			public void UpdateMatch() {
				Index = (uint)(Index < 7 ? 7 : 10);
			}

			public void UpdateRep() {
				Index = (uint)(Index < 7 ? 8 : 11);
			}

			public void UpdateShortRep() {
				Index = (uint)(Index < 7 ? 9 : 11);
			}

			public bool IsCharState() {
				return Index < 7;
			}

		}

	}
}
```

`Confuser.Core/LZMA/Compress/LZMA/LzmaDecoder.cs`:

```cs
// LzmaDecoder.cs

using System;
using System.IO;
using SevenZip.Compression.LZ;
using SevenZip.Compression.RangeCoder;

namespace SevenZip.Compression.LZMA {
	internal class Decoder : ICoder, ISetDecoderProperties // ,System.IO.Stream
	{

		private readonly BitDecoder[] m_IsMatchDecoders = new BitDecoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		private readonly BitDecoder[] m_IsRep0LongDecoders = new BitDecoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		private readonly BitDecoder[] m_IsRepDecoders = new BitDecoder[Base.kNumStates];
		private readonly BitDecoder[] m_IsRepG0Decoders = new BitDecoder[Base.kNumStates];
		private readonly BitDecoder[] m_IsRepG1Decoders = new BitDecoder[Base.kNumStates];
		private readonly BitDecoder[] m_IsRepG2Decoders = new BitDecoder[Base.kNumStates];

		private readonly LenDecoder m_LenDecoder = new LenDecoder();

		private readonly LiteralDecoder m_LiteralDecoder = new LiteralDecoder();
		private readonly OutWindow m_OutWindow = new OutWindow();
		private readonly BitDecoder[] m_PosDecoders = new BitDecoder[Base.kNumFullDistances - Base.kEndPosModelIndex];
		private readonly BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[Base.kNumLenToPosStates];
		private readonly RangeCoder.Decoder m_RangeDecoder = new RangeCoder.Decoder();
		private readonly LenDecoder m_RepLenDecoder = new LenDecoder();
		private bool _solid;

		private uint m_DictionarySize;
		private uint m_DictionarySizeCheck;
		private BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(Base.kNumAlignBits);

		private uint m_PosStateMask;

		public Decoder() {
			m_DictionarySize = 0xFFFFFFFF;
			for (int i = 0; i < Base.kNumLenToPosStates; i++)
				m_PosSlotDecoder[i] = new BitTreeDecoder(Base.kNumPosSlotBits);
		}

		public void Code(Stream inStream, Stream outStream,
		                 Int64 inSize, Int64 outSize, ICodeProgress progress) {
			Init(inStream, outStream);

			var state = new Base.State();
			state.Init();
			uint rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0;

			UInt64 nowPos64 = 0;
			var outSize64 = (UInt64)outSize;
			if (nowPos64 < outSize64) {
				if (m_IsMatchDecoders[state.Index << Base.kNumPosStatesBitsMax].Decode(m_RangeDecoder) != 0)
					throw new DataErrorException();
				state.UpdateChar();
				byte b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, 0, 0);
				m_OutWindow.PutByte(b);
				nowPos64++;
			}
			while (nowPos64 < outSize64) {
				// UInt64 next = Math.Min(nowPos64 + (1 << 18), outSize64);
				// while(nowPos64 < next)
				{
					uint posState = (uint)nowPos64 & m_PosStateMask;
					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {
						byte b;
						byte prevByte = m_OutWindow.GetByte(0);
						if (!state.IsCharState())
							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder,
							                                         (uint)nowPos64, prevByte, m_OutWindow.GetByte(rep0));
						else
							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, (uint)nowPos64, prevByte);
						m_OutWindow.PutByte(b);
						state.UpdateChar();
						nowPos64++;
					}
					else {
						uint len;
						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1) {
							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0) {
								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {
									state.UpdateShortRep();
									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));
									nowPos64++;
									continue;
								}
							}
							else {
								UInt32 distance;
								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0) {
									distance = rep1;
								}
								else {
									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)
										distance = rep2;
									else {
										distance = rep3;
										rep3 = rep2;
									}
									rep2 = rep1;
								}
								rep1 = rep0;
								rep0 = distance;
							}
							len = m_RepLenDecoder.Decode(m_RangeDecoder, posState) + Base.kMatchMinLen;
							state.UpdateRep();
						}
						else {
							rep3 = rep2;
							rep2 = rep1;
							rep1 = rep0;
							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder, posState);
							state.UpdateMatch();
							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);
							if (posSlot >= Base.kStartPosModelIndex) {
								var numDirectBits = (int)((posSlot >> 1) - 1);
								rep0 = ((2 | (posSlot & 1)) << numDirectBits);
								if (posSlot < Base.kEndPosModelIndex)
									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders,
									                                     rep0 - posSlot - 1, m_RangeDecoder, numDirectBits);
								else {
									rep0 += (m_RangeDecoder.DecodeDirectBits(
										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);
									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);
								}
							}
							else
								rep0 = posSlot;
						}
						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {
							if (rep0 == 0xFFFFFFFF)
								break;
							throw new DataErrorException();
						}
						m_OutWindow.CopyBlock(rep0, len);
						nowPos64 += len;
					}
				}
			}
			m_OutWindow.Flush();
			m_OutWindow.ReleaseStream();
			m_RangeDecoder.ReleaseStream();
		}

		public void SetDecoderProperties(byte[] properties) {
			if (properties.Length < 5)
				throw new InvalidParamException();
			int lc = properties[0] % 9;
			int remainder = properties[0] / 9;
			int lp = remainder % 5;
			int pb = remainder / 5;
			if (pb > Base.kNumPosStatesBitsMax)
				throw new InvalidParamException();
			UInt32 dictionarySize = 0;
			for (int i = 0; i < 4; i++)
				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
			SetDictionarySize(dictionarySize);
			SetLiteralProperties(lp, lc);
			SetPosBitsProperties(pb);
		}

		private void SetDictionarySize(uint dictionarySize) {
			if (m_DictionarySize != dictionarySize) {
				m_DictionarySize = dictionarySize;
				m_DictionarySizeCheck = Math.Max(m_DictionarySize, 1);
				uint blockSize = Math.Max(m_DictionarySizeCheck, (1 << 12));
				m_OutWindow.Create(blockSize);
			}
		}

		private void SetLiteralProperties(int lp, int lc) {
			if (lp > 8)
				throw new InvalidParamException();
			if (lc > 8)
				throw new InvalidParamException();
			m_LiteralDecoder.Create(lp, lc);
		}

		private void SetPosBitsProperties(int pb) {
			if (pb > Base.kNumPosStatesBitsMax)
				throw new InvalidParamException();
			uint numPosStates = (uint)1 << pb;
			m_LenDecoder.Create(numPosStates);
			m_RepLenDecoder.Create(numPosStates);
			m_PosStateMask = numPosStates - 1;
		}

		private void Init(Stream inStream, Stream outStream) {
			m_RangeDecoder.Init(inStream);
			m_OutWindow.Init(outStream, _solid);

			uint i;
			for (i = 0; i < Base.kNumStates; i++) {
				for (uint j = 0; j <= m_PosStateMask; j++) {
					uint index = (i << Base.kNumPosStatesBitsMax) + j;
					m_IsMatchDecoders[index].Init();
					m_IsRep0LongDecoders[index].Init();
				}
				m_IsRepDecoders[i].Init();
				m_IsRepG0Decoders[i].Init();
				m_IsRepG1Decoders[i].Init();
				m_IsRepG2Decoders[i].Init();
			}

			m_LiteralDecoder.Init();
			for (i = 0; i < Base.kNumLenToPosStates; i++)
				m_PosSlotDecoder[i].Init();
			// m_PosSpecDecoder.Init();
			for (i = 0; i < Base.kNumFullDistances - Base.kEndPosModelIndex; i++)
				m_PosDecoders[i].Init();

			m_LenDecoder.Init();
			m_RepLenDecoder.Init();
			m_PosAlignDecoder.Init();
		}

		public bool Train(Stream stream) {
			_solid = true;
			return m_OutWindow.Train(stream);
		}

		private class LenDecoder {

			private readonly BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
			private readonly BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
			private BitDecoder m_Choice = new BitDecoder();
			private BitDecoder m_Choice2 = new BitDecoder();
			private BitTreeDecoder m_HighCoder = new BitTreeDecoder(Base.kNumHighLenBits);
			private uint m_NumPosStates;

			public void Create(uint numPosStates) {
				for (uint posState = m_NumPosStates; posState < numPosStates; posState++) {
					m_LowCoder[posState] = new BitTreeDecoder(Base.kNumLowLenBits);
					m_MidCoder[posState] = new BitTreeDecoder(Base.kNumMidLenBits);
				}
				m_NumPosStates = numPosStates;
			}

			public void Init() {
				m_Choice.Init();
				for (uint posState = 0; posState < m_NumPosStates; posState++) {
					m_LowCoder[posState].Init();
					m_MidCoder[posState].Init();
				}
				m_Choice2.Init();
				m_HighCoder.Init();
			}

			public uint Decode(RangeCoder.Decoder rangeDecoder, uint posState) {
				if (m_Choice.Decode(rangeDecoder) == 0)
					return m_LowCoder[posState].Decode(rangeDecoder);
				uint symbol = Base.kNumLowLenSymbols;
				if (m_Choice2.Decode(rangeDecoder) == 0)
					symbol += m_MidCoder[posState].Decode(rangeDecoder);
				else {
					symbol += Base.kNumMidLenSymbols;
					symbol += m_HighCoder.Decode(rangeDecoder);
				}
				return symbol;
			}

		}

		private class LiteralDecoder {

			private Decoder2[] m_Coders;
			private int m_NumPosBits;
			private int m_NumPrevBits;
			private uint m_PosMask;

			public void Create(int numPosBits, int numPrevBits) {
				if (m_Coders != null && m_NumPrevBits == numPrevBits &&
				    m_NumPosBits == numPosBits)
					return;
				m_NumPosBits = numPosBits;
				m_PosMask = ((uint)1 << numPosBits) - 1;
				m_NumPrevBits = numPrevBits;
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				m_Coders = new Decoder2[numStates];
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Create();
			}

			public void Init() {
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Init();
			}

			private uint GetState(uint pos, byte prevByte) {
				return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
			}

			public byte DecodeNormal(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte) {
				return m_Coders[GetState(pos, prevByte)].DecodeNormal(rangeDecoder);
			}

			public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte, byte matchByte) {
				return m_Coders[GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte);
			}

			private struct Decoder2 {

				private BitDecoder[] m_Decoders;

				public void Create() {
					m_Decoders = new BitDecoder[0x300];
				}

				public void Init() {
					for (int i = 0; i < 0x300; i++) m_Decoders[i].Init();
				}

				public byte DecodeNormal(RangeCoder.Decoder rangeDecoder) {
					uint symbol = 1;
					do
						symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder); while (symbol < 0x100);
					return (byte)symbol;
				}

				public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, byte matchByte) {
					uint symbol = 1;
					do {
						uint matchBit = (uint)(matchByte >> 7) & 1;
						matchByte <<= 1;
						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
						symbol = (symbol << 1) | bit;
						if (matchBit != bit) {
							while (symbol < 0x100)
								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);
							break;
						}
					} while (symbol < 0x100);
					return (byte)symbol;
				}

			}

		};

		/*
        public override bool CanRead { get { return true; }}
        public override bool CanWrite { get { return true; }}
        public override bool CanSeek { get { return true; }}
        public override long Length { get { return 0; }}
        public override long Position
        {
            get { return 0;	}
            set { }
        }
        public override void Flush() { }
        public override int Read(byte[] buffer, int offset, int count) 
        {
            return 0;
        }
        public override void Write(byte[] buffer, int offset, int count)
        {
        }
        public override long Seek(long offset, System.IO.SeekOrigin origin)
        {
            return 0;
        }
        public override void SetLength(long value) {}
        */

	}
}
```

`Confuser.Core/LZMA/Compress/LZMA/LzmaEncoder.cs`:

```cs
// LzmaEncoder.cs

using System;
using System.IO;
using SevenZip.Compression.LZ;
using SevenZip.Compression.RangeCoder;

namespace SevenZip.Compression.LZMA {
	internal class Encoder : ICoder, ISetCoderProperties, IWriteCoderProperties {

		private const UInt32 kIfinityPrice = 0xFFFFFFF;

		private const int kDefaultDictionaryLogSize = 22;
		private const UInt32 kNumFastBytesDefault = 0x20;

		private const UInt32 kNumLenSpecSymbols = Base.kNumLowLenSymbols + Base.kNumMidLenSymbols;

		private const UInt32 kNumOpts = 1 << 12;
		private const int kPropSize = 5;
		private static readonly Byte[] g_FastPos = new Byte[1 << 11];

		private static readonly string[] kMatchFinderIDs = {
			"BT2",
			"BT4"
		};

		private readonly UInt32[] _alignPrices = new UInt32[Base.kAlignTableSize];
		private readonly UInt32[] _distancesPrices = new UInt32[Base.kNumFullDistances << Base.kNumLenToPosStatesBits];

		private readonly BitEncoder[] _isMatch = new BitEncoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		private readonly BitEncoder[] _isRep = new BitEncoder[Base.kNumStates];
		private readonly BitEncoder[] _isRep0Long = new BitEncoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		private readonly BitEncoder[] _isRepG0 = new BitEncoder[Base.kNumStates];
		private readonly BitEncoder[] _isRepG1 = new BitEncoder[Base.kNumStates];
		private readonly BitEncoder[] _isRepG2 = new BitEncoder[Base.kNumStates];

		private readonly LenPriceTableEncoder _lenEncoder = new LenPriceTableEncoder();

		private readonly LiteralEncoder _literalEncoder = new LiteralEncoder();

		private readonly UInt32[] _matchDistances = new UInt32[Base.kMatchMaxLen * 2 + 2];
		private readonly Optimal[] _optimum = new Optimal[kNumOpts];
		private readonly BitEncoder[] _posEncoders = new BitEncoder[Base.kNumFullDistances - Base.kEndPosModelIndex];
		private readonly BitTreeEncoder[] _posSlotEncoder = new BitTreeEncoder[Base.kNumLenToPosStates];

		private readonly UInt32[] _posSlotPrices = new UInt32[1 << (Base.kNumPosSlotBits + Base.kNumLenToPosStatesBits)];
		private readonly RangeCoder.Encoder _rangeEncoder = new RangeCoder.Encoder();
		private readonly UInt32[] _repDistances = new UInt32[Base.kNumRepDistances];
		private readonly LenPriceTableEncoder _repMatchLenEncoder = new LenPriceTableEncoder();
		private readonly Byte[] properties = new Byte[kPropSize];
		private readonly UInt32[] repLens = new UInt32[Base.kNumRepDistances];
		private readonly UInt32[] reps = new UInt32[Base.kNumRepDistances];
		private readonly UInt32[] tempPrices = new UInt32[Base.kNumFullDistances];
		private UInt32 _additionalOffset;
		private UInt32 _alignPriceCount;

		private UInt32 _dictionarySize = (1 << kDefaultDictionaryLogSize);
		private UInt32 _dictionarySizePrev = 0xFFFFFFFF;
		private UInt32 _distTableSize = (kDefaultDictionaryLogSize * 2);
		private bool _finished;
		private Stream _inStream;
		private UInt32 _longestMatchLength;
		private bool _longestMatchWasFound;
		private IMatchFinder _matchFinder;

		private EMatchFinderType _matchFinderType = EMatchFinderType.BT4;
		private UInt32 _matchPriceCount;

		private bool _needReleaseMFStream;
		private UInt32 _numDistancePairs;
		private UInt32 _numFastBytes = kNumFastBytesDefault;
		private UInt32 _numFastBytesPrev = 0xFFFFFFFF;
		private int _numLiteralContextBits = 3;
		private int _numLiteralPosStateBits;
		private UInt32 _optimumCurrentIndex;
		private UInt32 _optimumEndIndex;
		private BitTreeEncoder _posAlignEncoder = new BitTreeEncoder(Base.kNumAlignBits);
		private int _posStateBits = 2;
		private UInt32 _posStateMask = (4 - 1);
		private Byte _previousByte;
		private Base.State _state = new Base.State();
		private uint _trainSize;
		private bool _writeEndMark;
		private Int64 nowPos64;

		static Encoder() {
			const Byte kFastSlots = 22;
			int c = 2;
			g_FastPos[0] = 0;
			g_FastPos[1] = 1;
			for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++) {
				UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));
				for (UInt32 j = 0; j < k; j++, c++)
					g_FastPos[c] = slotFast;
			}
		}

		public Encoder() {
			for (int i = 0; i < kNumOpts; i++)
				_optimum[i] = new Optimal();
			for (int i = 0; i < Base.kNumLenToPosStates; i++)
				_posSlotEncoder[i] = new BitTreeEncoder(Base.kNumPosSlotBits);
		}

		public void Code(Stream inStream, Stream outStream,
		                 Int64 inSize, Int64 outSize, ICodeProgress progress) {
			_needReleaseMFStream = false;
			try {
				SetStreams(inStream, outStream, inSize, outSize);
				while (true) {
					Int64 processedInSize;
					Int64 processedOutSize;
					bool finished;
					CodeOneBlock(out processedInSize, out processedOutSize, out finished);
					if (finished)
						return;
					if (progress != null) {
						progress.SetProgress(processedInSize, processedOutSize);
					}
				}
			}
			finally {
				ReleaseStreams();
			}
		}

		public void SetCoderProperties(CoderPropID[] propIDs, object[] properties) {
			for (UInt32 i = 0; i < properties.Length; i++) {
				object prop = properties[i];
				switch (propIDs[i]) {
					case CoderPropID.NumFastBytes: {
						if (!(prop is Int32))
							throw new InvalidParamException();
						var numFastBytes = (Int32)prop;
						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)
							throw new InvalidParamException();
						_numFastBytes = (UInt32)numFastBytes;
						break;
					}
					case CoderPropID.Algorithm: {
						/*
                            if (!(prop is Int32))
                                throw new InvalidParamException();
                            Int32 maximize = (Int32)prop;
                            _fastMode = (maximize == 0);
                            _maxMode = (maximize >= 2);
                            */
						break;
					}
					case CoderPropID.MatchFinder: {
						if (!(prop is String))
							throw new InvalidParamException();
						EMatchFinderType matchFinderIndexPrev = _matchFinderType;
						int m = FindMatchFinder(((string)prop).ToUpper());
						if (m < 0)
							throw new InvalidParamException();
						_matchFinderType = (EMatchFinderType)m;
						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {
							_dictionarySizePrev = 0xFFFFFFFF;
							_matchFinder = null;
						}
						break;
					}
					case CoderPropID.DictionarySize: {
						const int kDicLogSizeMaxCompress = 30;
						if (!(prop is Int32))
							throw new InvalidParamException();
						;
						var dictionarySize = (Int32)prop;
						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||
						    dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))
							throw new InvalidParamException();
						_dictionarySize = (UInt32)dictionarySize;
						int dicLogSize;
						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)
							if (dictionarySize <= ((UInt32)(1) << dicLogSize))
								break;
						_distTableSize = (UInt32)dicLogSize * 2;
						break;
					}
					case CoderPropID.PosStateBits: {
						if (!(prop is Int32))
							throw new InvalidParamException();
						var v = (Int32)prop;
						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)
							throw new InvalidParamException();
						_posStateBits = v;
						_posStateMask = (((UInt32)1) << _posStateBits) - 1;
						break;
					}
					case CoderPropID.LitPosBits: {
						if (!(prop is Int32))
							throw new InvalidParamException();
						var v = (Int32)prop;
						if (v < 0 || v > Base.kNumLitPosStatesBitsEncodingMax)
							throw new InvalidParamException();
						_numLiteralPosStateBits = v;
						break;
					}
					case CoderPropID.LitContextBits: {
						if (!(prop is Int32))
							throw new InvalidParamException();
						var v = (Int32)prop;
						if (v < 0 || v > Base.kNumLitContextBitsMax)
							throw new InvalidParamException();
						;
						_numLiteralContextBits = v;
						break;
					}
					case CoderPropID.EndMarker: {
						if (!(prop is Boolean))
							throw new InvalidParamException();
						SetWriteEndMarkerMode((Boolean)prop);
						break;
					}
					default:
						throw new InvalidParamException();
				}
			}
		}

		public void WriteCoderProperties(Stream outStream) {
			properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
			for (int i = 0; i < 4; i++)
				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
			outStream.Write(properties, 0, kPropSize);
		}

		private static UInt32 GetPosSlot(UInt32 pos) {
			if (pos < (1 << 11))
				return g_FastPos[pos];
			if (pos < (1 << 21))
				return (UInt32)(g_FastPos[pos >> 10] + 20);
			return (UInt32)(g_FastPos[pos >> 20] + 40);
		}

		private static UInt32 GetPosSlot2(UInt32 pos) {
			if (pos < (1 << 17))
				return (UInt32)(g_FastPos[pos >> 6] + 12);
			if (pos < (1 << 27))
				return (UInt32)(g_FastPos[pos >> 16] + 32);
			return (UInt32)(g_FastPos[pos >> 26] + 52);
		}

		private void BaseInit() {
			_state.Init();
			_previousByte = 0;
			for (UInt32 i = 0; i < Base.kNumRepDistances; i++)
				_repDistances[i] = 0;
		}

		private void Create() {
			if (_matchFinder == null) {
				var bt = new BinTree();
				int numHashBytes = 4;
				if (_matchFinderType == EMatchFinderType.BT2)
					numHashBytes = 2;
				bt.SetType(numHashBytes);
				_matchFinder = bt;
			}
			_literalEncoder.Create(_numLiteralPosStateBits, _numLiteralContextBits);

			if (_dictionarySize == _dictionarySizePrev && _numFastBytesPrev == _numFastBytes)
				return;
			_matchFinder.Create(_dictionarySize, kNumOpts, _numFastBytes, Base.kMatchMaxLen + 1);
			_dictionarySizePrev = _dictionarySize;
			_numFastBytesPrev = _numFastBytes;
		}

		private void SetWriteEndMarkerMode(bool writeEndMarker) {
			_writeEndMark = writeEndMarker;
		}

		private void Init() {
			BaseInit();
			_rangeEncoder.Init();

			uint i;
			for (i = 0; i < Base.kNumStates; i++) {
				for (uint j = 0; j <= _posStateMask; j++) {
					uint complexState = (i << Base.kNumPosStatesBitsMax) + j;
					_isMatch[complexState].Init();
					_isRep0Long[complexState].Init();
				}
				_isRep[i].Init();
				_isRepG0[i].Init();
				_isRepG1[i].Init();
				_isRepG2[i].Init();
			}
			_literalEncoder.Init();
			for (i = 0; i < Base.kNumLenToPosStates; i++)
				_posSlotEncoder[i].Init();
			for (i = 0; i < Base.kNumFullDistances - Base.kEndPosModelIndex; i++)
				_posEncoders[i].Init();

			_lenEncoder.Init((UInt32)1 << _posStateBits);
			_repMatchLenEncoder.Init((UInt32)1 << _posStateBits);

			_posAlignEncoder.Init();

			_longestMatchWasFound = false;
			_optimumEndIndex = 0;
			_optimumCurrentIndex = 0;
			_additionalOffset = 0;
		}

		private void ReadMatchDistances(out UInt32 lenRes, out UInt32 numDistancePairs) {
			lenRes = 0;
			numDistancePairs = _matchFinder.GetMatches(_matchDistances);
			if (numDistancePairs > 0) {
				lenRes = _matchDistances[numDistancePairs - 2];
				if (lenRes == _numFastBytes)
					lenRes += _matchFinder.GetMatchLen((int)lenRes - 1, _matchDistances[numDistancePairs - 1],
					                                   Base.kMatchMaxLen - lenRes);
			}
			_additionalOffset++;
		}


		private void MovePos(UInt32 num) {
			if (num > 0) {
				_matchFinder.Skip(num);
				_additionalOffset += num;
			}
		}

		private UInt32 GetRepLen1Price(Base.State state, UInt32 posState) {
			return _isRepG0[state.Index].GetPrice0() +
			       _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0();
		}

		private UInt32 GetPureRepPrice(UInt32 repIndex, Base.State state, UInt32 posState) {
			UInt32 price;
			if (repIndex == 0) {
				price = _isRepG0[state.Index].GetPrice0();
				price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();
			}
			else {
				price = _isRepG0[state.Index].GetPrice1();
				if (repIndex == 1)
					price += _isRepG1[state.Index].GetPrice0();
				else {
					price += _isRepG1[state.Index].GetPrice1();
					price += _isRepG2[state.Index].GetPrice(repIndex - 2);
				}
			}
			return price;
		}

		private UInt32 GetRepPrice(UInt32 repIndex, UInt32 len, Base.State state, UInt32 posState) {
			UInt32 price = _repMatchLenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
			return price + GetPureRepPrice(repIndex, state, posState);
		}

		private UInt32 GetPosLenPrice(UInt32 pos, UInt32 len, UInt32 posState) {
			UInt32 price;
			UInt32 lenToPosState = Base.GetLenToPosState(len);
			if (pos < Base.kNumFullDistances)
				price = _distancesPrices[(lenToPosState * Base.kNumFullDistances) + pos];
			else
				price = _posSlotPrices[(lenToPosState << Base.kNumPosSlotBits) + GetPosSlot2(pos)] +
				        _alignPrices[pos & Base.kAlignMask];
			return price + _lenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
		}

		private UInt32 Backward(out UInt32 backRes, UInt32 cur) {
			_optimumEndIndex = cur;
			UInt32 posMem = _optimum[cur].PosPrev;
			UInt32 backMem = _optimum[cur].BackPrev;
			do {
				if (_optimum[cur].Prev1IsChar) {
					_optimum[posMem].MakeAsChar();
					_optimum[posMem].PosPrev = posMem - 1;
					if (_optimum[cur].Prev2) {
						_optimum[posMem - 1].Prev1IsChar = false;
						_optimum[posMem - 1].PosPrev = _optimum[cur].PosPrev2;
						_optimum[posMem - 1].BackPrev = _optimum[cur].BackPrev2;
					}
				}
				UInt32 posPrev = posMem;
				UInt32 backCur = backMem;

				backMem = _optimum[posPrev].BackPrev;
				posMem = _optimum[posPrev].PosPrev;

				_optimum[posPrev].BackPrev = backCur;
				_optimum[posPrev].PosPrev = cur;
				cur = posPrev;
			} while (cur > 0);
			backRes = _optimum[0].BackPrev;
			_optimumCurrentIndex = _optimum[0].PosPrev;
			return _optimumCurrentIndex;
		}


		private UInt32 GetOptimum(UInt32 position, out UInt32 backRes) {
			if (_optimumEndIndex != _optimumCurrentIndex) {
				UInt32 lenRes = _optimum[_optimumCurrentIndex].PosPrev - _optimumCurrentIndex;
				backRes = _optimum[_optimumCurrentIndex].BackPrev;
				_optimumCurrentIndex = _optimum[_optimumCurrentIndex].PosPrev;
				return lenRes;
			}
			_optimumCurrentIndex = _optimumEndIndex = 0;

			UInt32 lenMain, numDistancePairs;
			if (!_longestMatchWasFound) {
				ReadMatchDistances(out lenMain, out numDistancePairs);
			}
			else {
				lenMain = _longestMatchLength;
				numDistancePairs = _numDistancePairs;
				_longestMatchWasFound = false;
			}

			UInt32 numAvailableBytes = _matchFinder.GetNumAvailableBytes() + 1;
			if (numAvailableBytes < 2) {
				backRes = 0xFFFFFFFF;
				return 1;
			}
			if (numAvailableBytes > Base.kMatchMaxLen)
				numAvailableBytes = Base.kMatchMaxLen;

			UInt32 repMaxIndex = 0;
			UInt32 i;
			for (i = 0; i < Base.kNumRepDistances; i++) {
				reps[i] = _repDistances[i];
				repLens[i] = _matchFinder.GetMatchLen(0 - 1, reps[i], Base.kMatchMaxLen);
				if (repLens[i] > repLens[repMaxIndex])
					repMaxIndex = i;
			}
			if (repLens[repMaxIndex] >= _numFastBytes) {
				backRes = repMaxIndex;
				UInt32 lenRes = repLens[repMaxIndex];
				MovePos(lenRes - 1);
				return lenRes;
			}

			if (lenMain >= _numFastBytes) {
				backRes = _matchDistances[numDistancePairs - 1] + Base.kNumRepDistances;
				MovePos(lenMain - 1);
				return lenMain;
			}

			Byte currentByte = _matchFinder.GetIndexByte(0 - 1);
			Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - 1));

			if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2) {
				backRes = 0xFFFFFFFF;
				return 1;
			}

			_optimum[0].State = _state;

			UInt32 posState = (position & _posStateMask);

			_optimum[1].Price = _isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +
			                    _literalEncoder.GetSubCoder(position, _previousByte).GetPrice(!_state.IsCharState(), matchByte, currentByte);
			_optimum[1].MakeAsChar();

			UInt32 matchPrice = _isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();
			UInt32 repMatchPrice = matchPrice + _isRep[_state.Index].GetPrice1();

			if (matchByte == currentByte) {
				UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(_state, posState);
				if (shortRepPrice < _optimum[1].Price) {
					_optimum[1].Price = shortRepPrice;
					_optimum[1].MakeAsShortRep();
				}
			}

			UInt32 lenEnd = ((lenMain >= repLens[repMaxIndex]) ? lenMain : repLens[repMaxIndex]);

			if (lenEnd < 2) {
				backRes = _optimum[1].BackPrev;
				return 1;
			}

			_optimum[1].PosPrev = 0;

			_optimum[0].Backs0 = reps[0];
			_optimum[0].Backs1 = reps[1];
			_optimum[0].Backs2 = reps[2];
			_optimum[0].Backs3 = reps[3];

			UInt32 len = lenEnd;
			do
				_optimum[len--].Price = kIfinityPrice; while (len >= 2);

			for (i = 0; i < Base.kNumRepDistances; i++) {
				UInt32 repLen = repLens[i];
				if (repLen < 2)
					continue;
				UInt32 price = repMatchPrice + GetPureRepPrice(i, _state, posState);
				do {
					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2, posState);
					Optimal optimum = _optimum[repLen];
					if (curAndLenPrice < optimum.Price) {
						optimum.Price = curAndLenPrice;
						optimum.PosPrev = 0;
						optimum.BackPrev = i;
						optimum.Prev1IsChar = false;
					}
				} while (--repLen >= 2);
			}

			UInt32 normalMatchPrice = matchPrice + _isRep[_state.Index].GetPrice0();

			len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
			if (len <= lenMain) {
				UInt32 offs = 0;
				while (len > _matchDistances[offs])
					offs += 2;
				for (;; len++) {
					UInt32 distance = _matchDistances[offs + 1];
					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance, len, posState);
					Optimal optimum = _optimum[len];
					if (curAndLenPrice < optimum.Price) {
						optimum.Price = curAndLenPrice;
						optimum.PosPrev = 0;
						optimum.BackPrev = distance + Base.kNumRepDistances;
						optimum.Prev1IsChar = false;
					}
					if (len == _matchDistances[offs]) {
						offs += 2;
						if (offs == numDistancePairs)
							break;
					}
				}
			}

			UInt32 cur = 0;

			while (true) {
				cur++;
				if (cur == lenEnd)
					return Backward(out backRes, cur);
				UInt32 newLen;
				ReadMatchDistances(out newLen, out numDistancePairs);
				if (newLen >= _numFastBytes) {
					_numDistancePairs = numDistancePairs;
					_longestMatchLength = newLen;
					_longestMatchWasFound = true;
					return Backward(out backRes, cur);
				}
				position++;
				UInt32 posPrev = _optimum[cur].PosPrev;
				Base.State state;
				if (_optimum[cur].Prev1IsChar) {
					posPrev--;
					if (_optimum[cur].Prev2) {
						state = _optimum[_optimum[cur].PosPrev2].State;
						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)
							state.UpdateRep();
						else
							state.UpdateMatch();
					}
					else
						state = _optimum[posPrev].State;
					state.UpdateChar();
				}
				else
					state = _optimum[posPrev].State;
				if (posPrev == cur - 1) {
					if (_optimum[cur].IsShortRep())
						state.UpdateShortRep();
					else
						state.UpdateChar();
				}
				else {
					UInt32 pos;
					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {
						posPrev = _optimum[cur].PosPrev2;
						pos = _optimum[cur].BackPrev2;
						state.UpdateRep();
					}
					else {
						pos = _optimum[cur].BackPrev;
						if (pos < Base.kNumRepDistances)
							state.UpdateRep();
						else
							state.UpdateMatch();
					}
					Optimal opt = _optimum[posPrev];
					if (pos < Base.kNumRepDistances) {
						if (pos == 0) {
							reps[0] = opt.Backs0;
							reps[1] = opt.Backs1;
							reps[2] = opt.Backs2;
							reps[3] = opt.Backs3;
						}
						else if (pos == 1) {
							reps[0] = opt.Backs1;
							reps[1] = opt.Backs0;
							reps[2] = opt.Backs2;
							reps[3] = opt.Backs3;
						}
						else if (pos == 2) {
							reps[0] = opt.Backs2;
							reps[1] = opt.Backs0;
							reps[2] = opt.Backs1;
							reps[3] = opt.Backs3;
						}
						else {
							reps[0] = opt.Backs3;
							reps[1] = opt.Backs0;
							reps[2] = opt.Backs1;
							reps[3] = opt.Backs2;
						}
					}
					else {
						reps[0] = (pos - Base.kNumRepDistances);
						reps[1] = opt.Backs0;
						reps[2] = opt.Backs1;
						reps[3] = opt.Backs2;
					}
				}
				_optimum[cur].State = state;
				_optimum[cur].Backs0 = reps[0];
				_optimum[cur].Backs1 = reps[1];
				_optimum[cur].Backs2 = reps[2];
				_optimum[cur].Backs3 = reps[3];
				UInt32 curPrice = _optimum[cur].Price;

				currentByte = _matchFinder.GetIndexByte(0 - 1);
				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));

				posState = (position & _posStateMask);

				UInt32 curAnd1Price = curPrice +
				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +
				                      _literalEncoder.GetSubCoder(position, _matchFinder.GetIndexByte(0 - 2)).
				                                      GetPrice(!state.IsCharState(), matchByte, currentByte);

				Optimal nextOptimum = _optimum[cur + 1];

				bool nextIsChar = false;
				if (curAnd1Price < nextOptimum.Price) {
					nextOptimum.Price = curAnd1Price;
					nextOptimum.PosPrev = cur;
					nextOptimum.MakeAsChar();
					nextIsChar = true;
				}

				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();
				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();

				if (matchByte == currentByte &&
				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {
					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);
					if (shortRepPrice <= nextOptimum.Price) {
						nextOptimum.Price = shortRepPrice;
						nextOptimum.PosPrev = cur;
						nextOptimum.MakeAsShortRep();
						nextIsChar = true;
					}
				}

				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;
				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur, numAvailableBytesFull);
				numAvailableBytes = numAvailableBytesFull;

				if (numAvailableBytes < 2)
					continue;
				if (numAvailableBytes > _numFastBytes)
					numAvailableBytes = _numFastBytes;
				if (!nextIsChar && matchByte != currentByte) {
					// try Literal + rep0
					UInt32 t = Math.Min(numAvailableBytesFull - 1, _numFastBytes);
					UInt32 lenTest2 = _matchFinder.GetMatchLen(0, reps[0], t);
					if (lenTest2 >= 2) {
						Base.State state2 = state;
						state2.UpdateChar();
						UInt32 posStateNext = (position + 1) & _posStateMask;
						UInt32 nextRepMatchPrice = curAnd1Price +
						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +
						                           _isRep[state2.Index].GetPrice1();
						{
							UInt32 offset = cur + 1 + lenTest2;
							while (lenEnd < offset)
								_optimum[++lenEnd].Price = kIfinityPrice;
							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(
								0, lenTest2, state2, posStateNext);
							Optimal optimum = _optimum[offset];
							if (curAndLenPrice < optimum.Price) {
								optimum.Price = curAndLenPrice;
								optimum.PosPrev = cur + 1;
								optimum.BackPrev = 0;
								optimum.Prev1IsChar = true;
								optimum.Prev2 = false;
							}
						}
					}
				}

				UInt32 startLen = 2; // speed optimization 

				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {
					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1, reps[repIndex], numAvailableBytes);
					if (lenTest < 2)
						continue;
					UInt32 lenTestTemp = lenTest;
					do {
						while (lenEnd < cur + lenTest)
							_optimum[++lenEnd].Price = kIfinityPrice;
						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState);
						Optimal optimum = _optimum[cur + lenTest];
						if (curAndLenPrice < optimum.Price) {
							optimum.Price = curAndLenPrice;
							optimum.PosPrev = cur;
							optimum.BackPrev = repIndex;
							optimum.Prev1IsChar = false;
						}
					} while (--lenTest >= 2);
					lenTest = lenTestTemp;

					if (repIndex == 0)
						startLen = lenTest + 1;

					// if (_maxMode)
					if (lenTest < numAvailableBytesFull) {
						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest, reps[repIndex], t);
						if (lenTest2 >= 2) {
							Base.State state2 = state;
							state2.UpdateRep();
							UInt32 posStateNext = (position + lenTest) & _posStateMask;
							UInt32 curAndLenCharPrice =
								repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState) +
								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +
								_literalEncoder.GetSubCoder(position + lenTest,
								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true,
								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)),
								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));
							state2.UpdateChar();
							posStateNext = (position + lenTest + 1) & _posStateMask;
							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();
							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();

							// for(; lenTest2 >= 2; lenTest2--)
							{
								UInt32 offset = lenTest + 1 + lenTest2;
								while (lenEnd < cur + offset)
									_optimum[++lenEnd].Price = kIfinityPrice;
								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
								Optimal optimum = _optimum[cur + offset];
								if (curAndLenPrice < optimum.Price) {
									optimum.Price = curAndLenPrice;
									optimum.PosPrev = cur + lenTest + 1;
									optimum.BackPrev = 0;
									optimum.Prev1IsChar = true;
									optimum.Prev2 = true;
									optimum.PosPrev2 = cur;
									optimum.BackPrev2 = repIndex;
								}
							}
						}
					}
				}

				if (newLen > numAvailableBytes) {
					newLen = numAvailableBytes;
					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;
					_matchDistances[numDistancePairs] = newLen;
					numDistancePairs += 2;
				}
				if (newLen >= startLen) {
					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();
					while (lenEnd < cur + newLen)
						_optimum[++lenEnd].Price = kIfinityPrice;

					UInt32 offs = 0;
					while (startLen > _matchDistances[offs])
						offs += 2;

					for (UInt32 lenTest = startLen;; lenTest++) {
						UInt32 curBack = _matchDistances[offs + 1];
						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack, lenTest, posState);
						Optimal optimum = _optimum[cur + lenTest];
						if (curAndLenPrice < optimum.Price) {
							optimum.Price = curAndLenPrice;
							optimum.PosPrev = cur;
							optimum.BackPrev = curBack + Base.kNumRepDistances;
							optimum.Prev1IsChar = false;
						}

						if (lenTest == _matchDistances[offs]) {
							if (lenTest < numAvailableBytesFull) {
								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest, curBack, t);
								if (lenTest2 >= 2) {
									Base.State state2 = state;
									state2.UpdateMatch();
									UInt32 posStateNext = (position + lenTest) & _posStateMask;
									UInt32 curAndLenCharPrice = curAndLenPrice +
									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +
									                            _literalEncoder.GetSubCoder(position + lenTest,
									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).
									                                            GetPrice(true,
									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1),
									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));
									state2.UpdateChar();
									posStateNext = (position + lenTest + 1) & _posStateMask;
									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();
									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();

									UInt32 offset = lenTest + 1 + lenTest2;
									while (lenEnd < cur + offset)
										_optimum[++lenEnd].Price = kIfinityPrice;
									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
									optimum = _optimum[cur + offset];
									if (curAndLenPrice < optimum.Price) {
										optimum.Price = curAndLenPrice;
										optimum.PosPrev = cur + lenTest + 1;
										optimum.BackPrev = 0;
										optimum.Prev1IsChar = true;
										optimum.Prev2 = true;
										optimum.PosPrev2 = cur;
										optimum.BackPrev2 = curBack + Base.kNumRepDistances;
									}
								}
							}
							offs += 2;
							if (offs == numDistancePairs)
								break;
						}
					}
				}
			}
		}

		private bool ChangePair(UInt32 smallDist, UInt32 bigDist) {
			const int kDif = 7;
			return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
		}

		private void WriteEndMarker(UInt32 posState) {
			if (!_writeEndMark)
				return;

			_isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].Encode(_rangeEncoder, 1);
			_isRep[_state.Index].Encode(_rangeEncoder, 0);
			_state.UpdateMatch();
			UInt32 len = Base.kMatchMinLen;
			_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
			UInt32 posSlot = (1 << Base.kNumPosSlotBits) - 1;
			UInt32 lenToPosState = Base.GetLenToPosState(len);
			_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);
			int footerBits = 30;
			UInt32 posReduced = (((UInt32)1) << footerBits) - 1;
			_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
			_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced & Base.kAlignMask);
		}

		private void Flush(UInt32 nowPos) {
			ReleaseMFStream();
			WriteEndMarker(nowPos & _posStateMask);
			_rangeEncoder.FlushData();
			_rangeEncoder.FlushStream();
		}

		public void CodeOneBlock(out Int64 inSize, out Int64 outSize, out bool finished) {
			inSize = 0;
			outSize = 0;
			finished = true;

			if (_inStream != null) {
				_matchFinder.SetStream(_inStream);
				_matchFinder.Init();
				_needReleaseMFStream = true;
				_inStream = null;
				if (_trainSize > 0)
					_matchFinder.Skip(_trainSize);
			}

			if (_finished)
				return;
			_finished = true;


			Int64 progressPosValuePrev = nowPos64;
			if (nowPos64 == 0) {
				if (_matchFinder.GetNumAvailableBytes() == 0) {
					Flush((UInt32)nowPos64);
					return;
				}
				UInt32 len, numDistancePairs; // it's not used
				ReadMatchDistances(out len, out numDistancePairs);
				UInt32 posState = (UInt32)(nowPos64) & _posStateMask;
				_isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].Encode(_rangeEncoder, 0);
				_state.UpdateChar();
				Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));
				_literalEncoder.GetSubCoder((UInt32)(nowPos64), _previousByte).Encode(_rangeEncoder, curByte);
				_previousByte = curByte;
				_additionalOffset--;
				nowPos64++;
			}
			if (_matchFinder.GetNumAvailableBytes() == 0) {
				Flush((UInt32)nowPos64);
				return;
			}
			while (true) {
				UInt32 pos;
				UInt32 len = GetOptimum((UInt32)nowPos64, out pos);

				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;
				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;
				if (len == 1 && pos == 0xFFFFFFFF) {
					_isMatch[complexState].Encode(_rangeEncoder, 0);
					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));
					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64, _previousByte);
					if (!_state.IsCharState()) {
						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));
						subCoder.EncodeMatched(_rangeEncoder, matchByte, curByte);
					}
					else
						subCoder.Encode(_rangeEncoder, curByte);
					_previousByte = curByte;
					_state.UpdateChar();
				}
				else {
					_isMatch[complexState].Encode(_rangeEncoder, 1);
					if (pos < Base.kNumRepDistances) {
						_isRep[_state.Index].Encode(_rangeEncoder, 1);
						if (pos == 0) {
							_isRepG0[_state.Index].Encode(_rangeEncoder, 0);
							if (len == 1)
								_isRep0Long[complexState].Encode(_rangeEncoder, 0);
							else
								_isRep0Long[complexState].Encode(_rangeEncoder, 1);
						}
						else {
							_isRepG0[_state.Index].Encode(_rangeEncoder, 1);
							if (pos == 1)
								_isRepG1[_state.Index].Encode(_rangeEncoder, 0);
							else {
								_isRepG1[_state.Index].Encode(_rangeEncoder, 1);
								_isRepG2[_state.Index].Encode(_rangeEncoder, pos - 2);
							}
						}
						if (len == 1)
							_state.UpdateShortRep();
						else {
							_repMatchLenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
							_state.UpdateRep();
						}
						UInt32 distance = _repDistances[pos];
						if (pos != 0) {
							for (UInt32 i = pos; i >= 1; i--)
								_repDistances[i] = _repDistances[i - 1];
							_repDistances[0] = distance;
						}
					}
					else {
						_isRep[_state.Index].Encode(_rangeEncoder, 0);
						_state.UpdateMatch();
						_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
						pos -= Base.kNumRepDistances;
						UInt32 posSlot = GetPosSlot(pos);
						UInt32 lenToPosState = Base.GetLenToPosState(len);
						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);

						if (posSlot >= Base.kStartPosModelIndex) {
							var footerBits = (int)((posSlot >> 1) - 1);
							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
							UInt32 posReduced = pos - baseVal;

							if (posSlot < Base.kEndPosModelIndex)
								BitTreeEncoder.ReverseEncode(_posEncoders,
								                             baseVal - posSlot - 1, _rangeEncoder, footerBits, posReduced);
							else {
								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
								_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced & Base.kAlignMask);
								_alignPriceCount++;
							}
						}
						UInt32 distance = pos;
						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)
							_repDistances[i] = _repDistances[i - 1];
						_repDistances[0] = distance;
						_matchPriceCount++;
					}
					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));
				}
				_additionalOffset -= len;
				nowPos64 += len;
				if (_additionalOffset == 0) {
					// if (!_fastMode)
					if (_matchPriceCount >= (1 << 7))
						FillDistancesPrices();
					if (_alignPriceCount >= Base.kAlignTableSize)
						FillAlignPrices();
					inSize = nowPos64;
					outSize = _rangeEncoder.GetProcessedSizeAdd();
					if (_matchFinder.GetNumAvailableBytes() == 0) {
						Flush((UInt32)nowPos64);
						return;
					}

					if (nowPos64 - progressPosValuePrev >= (1 << 12)) {
						_finished = false;
						finished = false;
						return;
					}
				}
			}
		}

		private void ReleaseMFStream() {
			if (_matchFinder != null && _needReleaseMFStream) {
				_matchFinder.ReleaseStream();
				_needReleaseMFStream = false;
			}
		}

		private void SetOutStream(Stream outStream) {
			_rangeEncoder.SetStream(outStream);
		}

		private void ReleaseOutStream() {
			_rangeEncoder.ReleaseStream();
		}

		private void ReleaseStreams() {
			ReleaseMFStream();
			ReleaseOutStream();
		}

		private void SetStreams(Stream inStream, Stream outStream,
		                        Int64 inSize, Int64 outSize) {
			_inStream = inStream;
			_finished = false;
			Create();
			SetOutStream(outStream);
			Init();

			// if (!_fastMode)
			                        {
				                        FillDistancesPrices();
				                        FillAlignPrices();
			                        }

			_lenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
			_lenEncoder.UpdateTables((UInt32)1 << _posStateBits);
			_repMatchLenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
			_repMatchLenEncoder.UpdateTables((UInt32)1 << _posStateBits);

			nowPos64 = 0;
		}


		private void FillDistancesPrices() {
			for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++) {
				UInt32 posSlot = GetPosSlot(i);
				var footerBits = (int)((posSlot >> 1) - 1);
				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
				tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders,
				                                               baseVal - posSlot - 1, footerBits, i - baseVal);
			}

			for (UInt32 lenToPosState = 0; lenToPosState < Base.kNumLenToPosStates; lenToPosState++) {
				UInt32 posSlot;
				BitTreeEncoder encoder = _posSlotEncoder[lenToPosState];

				UInt32 st = (lenToPosState << Base.kNumPosSlotBits);
				for (posSlot = 0; posSlot < _distTableSize; posSlot++)
					_posSlotPrices[st + posSlot] = encoder.GetPrice(posSlot);
				for (posSlot = Base.kEndPosModelIndex; posSlot < _distTableSize; posSlot++)
					_posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << BitEncoder.kNumBitPriceShiftBits);

				UInt32 st2 = lenToPosState * Base.kNumFullDistances;
				UInt32 i;
				for (i = 0; i < Base.kStartPosModelIndex; i++)
					_distancesPrices[st2 + i] = _posSlotPrices[st + i];
				for (; i < Base.kNumFullDistances; i++)
					_distancesPrices[st2 + i] = _posSlotPrices[st + GetPosSlot(i)] + tempPrices[i];
			}
			_matchPriceCount = 0;
		}

		private void FillAlignPrices() {
			for (UInt32 i = 0; i < Base.kAlignTableSize; i++)
				_alignPrices[i] = _posAlignEncoder.ReverseGetPrice(i);
			_alignPriceCount = 0;
		}


		private static int FindMatchFinder(string s) {
			for (int m = 0; m < kMatchFinderIDs.Length; m++)
				if (s == kMatchFinderIDs[m])
					return m;
			return -1;
		}

		public void SetTrainSize(uint trainSize) {
			_trainSize = trainSize;
		}

		private enum EMatchFinderType {

			BT2,
			BT4,

		};

		private class LenEncoder {

			private readonly BitTreeEncoder[] _lowCoder = new BitTreeEncoder[Base.kNumPosStatesEncodingMax];
			private readonly BitTreeEncoder[] _midCoder = new BitTreeEncoder[Base.kNumPosStatesEncodingMax];
			private BitEncoder _choice = new BitEncoder();
			private BitEncoder _choice2 = new BitEncoder();
			private BitTreeEncoder _highCoder = new BitTreeEncoder(Base.kNumHighLenBits);

			public LenEncoder() {
				for (UInt32 posState = 0; posState < Base.kNumPosStatesEncodingMax; posState++) {
					_lowCoder[posState] = new BitTreeEncoder(Base.kNumLowLenBits);
					_midCoder[posState] = new BitTreeEncoder(Base.kNumMidLenBits);
				}
			}

			public void Init(UInt32 numPosStates) {
				_choice.Init();
				_choice2.Init();
				for (UInt32 posState = 0; posState < numPosStates; posState++) {
					_lowCoder[posState].Init();
					_midCoder[posState].Init();
				}
				_highCoder.Init();
			}

			public void Encode(RangeCoder.Encoder rangeEncoder, UInt32 symbol, UInt32 posState) {
				if (symbol < Base.kNumLowLenSymbols) {
					_choice.Encode(rangeEncoder, 0);
					_lowCoder[posState].Encode(rangeEncoder, symbol);
				}
				else {
					symbol -= Base.kNumLowLenSymbols;
					_choice.Encode(rangeEncoder, 1);
					if (symbol < Base.kNumMidLenSymbols) {
						_choice2.Encode(rangeEncoder, 0);
						_midCoder[posState].Encode(rangeEncoder, symbol);
					}
					else {
						_choice2.Encode(rangeEncoder, 1);
						_highCoder.Encode(rangeEncoder, symbol - Base.kNumMidLenSymbols);
					}
				}
			}

			public void SetPrices(UInt32 posState, UInt32 numSymbols, UInt32[] prices, UInt32 st) {
				UInt32 a0 = _choice.GetPrice0();
				UInt32 a1 = _choice.GetPrice1();
				UInt32 b0 = a1 + _choice2.GetPrice0();
				UInt32 b1 = a1 + _choice2.GetPrice1();
				UInt32 i = 0;
				for (i = 0; i < Base.kNumLowLenSymbols; i++) {
					if (i >= numSymbols)
						return;
					prices[st + i] = a0 + _lowCoder[posState].GetPrice(i);
				}
				for (; i < Base.kNumLowLenSymbols + Base.kNumMidLenSymbols; i++) {
					if (i >= numSymbols)
						return;
					prices[st + i] = b0 + _midCoder[posState].GetPrice(i - Base.kNumLowLenSymbols);
				}
				for (; i < numSymbols; i++)
					prices[st + i] = b1 + _highCoder.GetPrice(i - Base.kNumLowLenSymbols - Base.kNumMidLenSymbols);
			}

		};

		private class LenPriceTableEncoder : LenEncoder {

			private readonly UInt32[] _counters = new UInt32[Base.kNumPosStatesEncodingMax];
			private readonly UInt32[] _prices = new UInt32[Base.kNumLenSymbols << Base.kNumPosStatesBitsEncodingMax];
			private UInt32 _tableSize;

			public void SetTableSize(UInt32 tableSize) {
				_tableSize = tableSize;
			}

			public UInt32 GetPrice(UInt32 symbol, UInt32 posState) {
				return _prices[posState * Base.kNumLenSymbols + symbol];
			}

			private void UpdateTable(UInt32 posState) {
				SetPrices(posState, _tableSize, _prices, posState * Base.kNumLenSymbols);
				_counters[posState] = _tableSize;
			}

			public void UpdateTables(UInt32 numPosStates) {
				for (UInt32 posState = 0; posState < numPosStates; posState++)
					UpdateTable(posState);
			}

			public new void Encode(RangeCoder.Encoder rangeEncoder, UInt32 symbol, UInt32 posState) {
				base.Encode(rangeEncoder, symbol, posState);
				if (--_counters[posState] == 0)
					UpdateTable(posState);
			}

		}

		private class LiteralEncoder {

			private Encoder2[] m_Coders;
			private int m_NumPosBits;
			private int m_NumPrevBits;
			private uint m_PosMask;

			public void Create(int numPosBits, int numPrevBits) {
				if (m_Coders != null && m_NumPrevBits == numPrevBits && m_NumPosBits == numPosBits)
					return;
				m_NumPosBits = numPosBits;
				m_PosMask = ((uint)1 << numPosBits) - 1;
				m_NumPrevBits = numPrevBits;
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				m_Coders = new Encoder2[numStates];
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Create();
			}

			public void Init() {
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Init();
			}

			public Encoder2 GetSubCoder(UInt32 pos, Byte prevByte) {
				return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
			}

			public struct Encoder2 {

				private BitEncoder[] m_Encoders;

				public void Create() {
					m_Encoders = new BitEncoder[0x300];
				}

				public void Init() {
					for (int i = 0; i < 0x300; i++) m_Encoders[i].Init();
				}

				public void Encode(RangeCoder.Encoder rangeEncoder, byte symbol) {
					uint context = 1;
					for (int i = 7; i >= 0; i--) {
						var bit = (uint)((symbol >> i) & 1);
						m_Encoders[context].Encode(rangeEncoder, bit);
						context = (context << 1) | bit;
					}
				}

				public void EncodeMatched(RangeCoder.Encoder rangeEncoder, byte matchByte, byte symbol) {
					uint context = 1;
					bool same = true;
					for (int i = 7; i >= 0; i--) {
						var bit = (uint)((symbol >> i) & 1);
						uint state = context;
						if (same) {
							var matchBit = (uint)((matchByte >> i) & 1);
							state += ((1 + matchBit) << 8);
							same = (matchBit == bit);
						}
						m_Encoders[state].Encode(rangeEncoder, bit);
						context = (context << 1) | bit;
					}
				}

				public uint GetPrice(bool matchMode, byte matchByte, byte symbol) {
					uint price = 0;
					uint context = 1;
					int i = 7;
					if (matchMode) {
						for (; i >= 0; i--) {
							uint matchBit = (uint)(matchByte >> i) & 1;
							uint bit = (uint)(symbol >> i) & 1;
							price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);
							context = (context << 1) | bit;
							if (matchBit != bit) {
								i--;
								break;
							}
						}
					}
					for (; i >= 0; i--) {
						uint bit = (uint)(symbol >> i) & 1;
						price += m_Encoders[context].GetPrice(bit);
						context = (context << 1) | bit;
					}
					return price;
				}

			}

		}

		private class Optimal {

			public UInt32 BackPrev;
			public UInt32 BackPrev2;

			public UInt32 Backs0;
			public UInt32 Backs1;
			public UInt32 Backs2;
			public UInt32 Backs3;
			public UInt32 PosPrev;
			public UInt32 PosPrev2;
			public bool Prev1IsChar;
			public bool Prev2;
			public UInt32 Price;
			public Base.State State;

			public void MakeAsChar() {
				BackPrev = 0xFFFFFFFF;
				Prev1IsChar = false;
			}

			public void MakeAsShortRep() {
				BackPrev = 0;
				;
				Prev1IsChar = false;
			}

			public bool IsShortRep() {
				return (BackPrev == 0);
			}

		};

	}
}
```

`Confuser.Core/LZMA/Compress/RangeCoder/RangeCoder.cs`:

```cs
using System;
using System.IO;

namespace SevenZip.Compression.RangeCoder {
	internal class Encoder {

		public const uint kTopValue = (1 << 24);

		public UInt64 Low;
		public uint Range;

		private long StartPosition;
		private Stream Stream;
		private byte _cache;
		private uint _cacheSize;

		public void SetStream(Stream stream) {
			Stream = stream;
		}

		public void ReleaseStream() {
			Stream = null;
		}

		public void Init() {
			StartPosition = Stream.Position;

			Low = 0;
			Range = 0xFFFFFFFF;
			_cacheSize = 1;
			_cache = 0;
		}

		public void FlushData() {
			for (int i = 0; i < 5; i++)
				ShiftLow();
		}

		public void FlushStream() {
			Stream.Flush();
		}

		public void CloseStream() {
			Stream.Close();
		}

		public void Encode(uint start, uint size, uint total) {
			Low += start * (Range /= total);
			Range *= size;
			while (Range < kTopValue) {
				Range <<= 8;
				ShiftLow();
			}
		}

		public void ShiftLow() {
			if ((uint)Low < 0xFF000000 || (uint)(Low >> 32) == 1) {
				byte temp = _cache;
				do {
					Stream.WriteByte((byte)(temp + (Low >> 32)));
					temp = 0xFF;
				} while (--_cacheSize != 0);
				_cache = (byte)(((uint)Low) >> 24);
			}
			_cacheSize++;
			Low = ((uint)Low) << 8;
		}

		public void EncodeDirectBits(uint v, int numTotalBits) {
			for (int i = numTotalBits - 1; i >= 0; i--) {
				Range >>= 1;
				if (((v >> i) & 1) == 1)
					Low += Range;
				if (Range < kTopValue) {
					Range <<= 8;
					ShiftLow();
				}
			}
		}

		public void EncodeBit(uint size0, int numTotalBits, uint symbol) {
			uint newBound = (Range >> numTotalBits) * size0;
			if (symbol == 0)
				Range = newBound;
			else {
				Low += newBound;
				Range -= newBound;
			}
			while (Range < kTopValue) {
				Range <<= 8;
				ShiftLow();
			}
		}

		public long GetProcessedSizeAdd() {
			return _cacheSize +
			       Stream.Position - StartPosition + 4;
			// (long)Stream.GetProcessedSize();
		}

	}

	internal class Decoder {

		public const uint kTopValue = (1 << 24);
		public uint Code;
		public uint Range;
		// public Buffer.InBuffer Stream = new Buffer.InBuffer(1 << 16);
		public Stream Stream;

		public void Init(Stream stream) {
			// Stream.Init(stream);
			Stream = stream;

			Code = 0;
			Range = 0xFFFFFFFF;
			for (int i = 0; i < 5; i++)
				Code = (Code << 8) | (byte)Stream.ReadByte();
		}

		public void ReleaseStream() {
			// Stream.ReleaseStream();
			Stream = null;
		}

		public void CloseStream() {
			Stream.Close();
		}

		public void Normalize() {
			while (Range < kTopValue) {
				Code = (Code << 8) | (byte)Stream.ReadByte();
				Range <<= 8;
			}
		}

		public void Normalize2() {
			if (Range < kTopValue) {
				Code = (Code << 8) | (byte)Stream.ReadByte();
				Range <<= 8;
			}
		}

		public uint GetThreshold(uint total) {
			return Code / (Range /= total);
		}

		public void Decode(uint start, uint size, uint total) {
			Code -= start * Range;
			Range *= size;
			Normalize();
		}

		public uint DecodeDirectBits(int numTotalBits) {
			uint range = Range;
			uint code = Code;
			uint result = 0;
			for (int i = numTotalBits; i > 0; i--) {
				range >>= 1;
				/*
                result <<= 1;
                if (code >= range)
                {
                    code -= range;
                    result |= 1;
                }
                */
				uint t = (code - range) >> 31;
				code -= range & (t - 1);
				result = (result << 1) | (1 - t);

				if (range < kTopValue) {
					code = (code << 8) | (byte)Stream.ReadByte();
					range <<= 8;
				}
			}
			Range = range;
			Code = code;
			return result;
		}

		public uint DecodeBit(uint size0, int numTotalBits) {
			uint newBound = (Range >> numTotalBits) * size0;
			uint symbol;
			if (Code < newBound) {
				symbol = 0;
				Range = newBound;
			}
			else {
				symbol = 1;
				Code -= newBound;
				Range -= newBound;
			}
			Normalize();
			return symbol;
		}

		// ulong GetProcessedSize() {return Stream.GetProcessedSize(); }
	}
}
```

`Confuser.Core/LZMA/Compress/RangeCoder/RangeCoderBit.cs`:

```cs
using System;

namespace SevenZip.Compression.RangeCoder {
	internal struct BitEncoder {

		public const int kNumBitModelTotalBits = 11;
		public const uint kBitModelTotal = (1 << kNumBitModelTotalBits);
		private const int kNumMoveBits = 5;
		private const int kNumMoveReducingBits = 2;
		public const int kNumBitPriceShiftBits = 6;
		private static readonly UInt32[] ProbPrices = new UInt32[kBitModelTotal >> kNumMoveReducingBits];

		private uint Prob;

		static BitEncoder() {
			const int kNumBits = (kNumBitModelTotalBits - kNumMoveReducingBits);
			for (int i = kNumBits - 1; i >= 0; i--) {
				UInt32 start = (UInt32)1 << (kNumBits - i - 1);
				UInt32 end = (UInt32)1 << (kNumBits - i);
				for (UInt32 j = start; j < end; j++)
					ProbPrices[j] = ((UInt32)i << kNumBitPriceShiftBits) +
					                (((end - j) << kNumBitPriceShiftBits) >> (kNumBits - i - 1));
			}
		}

		public void Init() {
			Prob = kBitModelTotal >> 1;
		}

		public void UpdateModel(uint symbol) {
			if (symbol == 0)
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
			else
				Prob -= (Prob) >> kNumMoveBits;
		}

		public void Encode(Encoder encoder, uint symbol) {
			// encoder.EncodeBit(Prob, kNumBitModelTotalBits, symbol);
			// UpdateModel(symbol);
			uint newBound = (encoder.Range >> kNumBitModelTotalBits) * Prob;
			if (symbol == 0) {
				encoder.Range = newBound;
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
			}
			else {
				encoder.Low += newBound;
				encoder.Range -= newBound;
				Prob -= (Prob) >> kNumMoveBits;
			}
			if (encoder.Range < Encoder.kTopValue) {
				encoder.Range <<= 8;
				encoder.ShiftLow();
			}
		}

		public uint GetPrice(uint symbol) {
			return ProbPrices[(((Prob - symbol) ^ ((-(int)symbol))) & (kBitModelTotal - 1)) >> kNumMoveReducingBits];
		}

		public uint GetPrice0() {
			return ProbPrices[Prob >> kNumMoveReducingBits];
		}

		public uint GetPrice1() {
			return ProbPrices[(kBitModelTotal - Prob) >> kNumMoveReducingBits];
		}

	}

	internal struct BitDecoder {

		public const int kNumBitModelTotalBits = 11;
		public const uint kBitModelTotal = (1 << kNumBitModelTotalBits);
		private const int kNumMoveBits = 5;

		private uint Prob;

		public void UpdateModel(int numMoveBits, uint symbol) {
			if (symbol == 0)
				Prob += (kBitModelTotal - Prob) >> numMoveBits;
			else
				Prob -= (Prob) >> numMoveBits;
		}

		public void Init() {
			Prob = kBitModelTotal >> 1;
		}

		public uint Decode(Decoder rangeDecoder) {
			uint newBound = (rangeDecoder.Range >> kNumBitModelTotalBits) * Prob;
			if (rangeDecoder.Code < newBound) {
				rangeDecoder.Range = newBound;
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
				if (rangeDecoder.Range < Decoder.kTopValue) {
					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
					rangeDecoder.Range <<= 8;
				}
				return 0;
			}
			rangeDecoder.Range -= newBound;
			rangeDecoder.Code -= newBound;
			Prob -= (Prob) >> kNumMoveBits;
			if (rangeDecoder.Range < Decoder.kTopValue) {
				rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
				rangeDecoder.Range <<= 8;
			}
			return 1;
		}

	}
}
```

`Confuser.Core/LZMA/Compress/RangeCoder/RangeCoderBitTree.cs`:

```cs
using System;

namespace SevenZip.Compression.RangeCoder {
	internal struct BitTreeEncoder {

		private readonly BitEncoder[] Models;
		private readonly int NumBitLevels;

		public BitTreeEncoder(int numBitLevels) {
			NumBitLevels = numBitLevels;
			Models = new BitEncoder[1 << numBitLevels];
		}

		public void Init() {
			for (uint i = 1; i < (1 << NumBitLevels); i++)
				Models[i].Init();
		}

		public void Encode(Encoder rangeEncoder, UInt32 symbol) {
			UInt32 m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0;) {
				bitIndex--;
				UInt32 bit = (symbol >> bitIndex) & 1;
				Models[m].Encode(rangeEncoder, bit);
				m = (m << 1) | bit;
			}
		}

		public void ReverseEncode(Encoder rangeEncoder, UInt32 symbol) {
			UInt32 m = 1;
			for (UInt32 i = 0; i < NumBitLevels; i++) {
				UInt32 bit = symbol & 1;
				Models[m].Encode(rangeEncoder, bit);
				m = (m << 1) | bit;
				symbol >>= 1;
			}
		}

		public UInt32 GetPrice(UInt32 symbol) {
			UInt32 price = 0;
			UInt32 m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0;) {
				bitIndex--;
				UInt32 bit = (symbol >> bitIndex) & 1;
				price += Models[m].GetPrice(bit);
				m = (m << 1) + bit;
			}
			return price;
		}

		public UInt32 ReverseGetPrice(UInt32 symbol) {
			UInt32 price = 0;
			UInt32 m = 1;
			for (int i = NumBitLevels; i > 0; i--) {
				UInt32 bit = symbol & 1;
				symbol >>= 1;
				price += Models[m].GetPrice(bit);
				m = (m << 1) | bit;
			}
			return price;
		}

		public static UInt32 ReverseGetPrice(BitEncoder[] Models, UInt32 startIndex,
		                                     int NumBitLevels, UInt32 symbol) {
			UInt32 price = 0;
			UInt32 m = 1;
			for (int i = NumBitLevels; i > 0; i--) {
				UInt32 bit = symbol & 1;
				symbol >>= 1;
				price += Models[startIndex + m].GetPrice(bit);
				m = (m << 1) | bit;
			}
			return price;
		}

		public static void ReverseEncode(BitEncoder[] Models, UInt32 startIndex,
		                                 Encoder rangeEncoder, int NumBitLevels, UInt32 symbol) {
			UInt32 m = 1;
			for (int i = 0; i < NumBitLevels; i++) {
				UInt32 bit = symbol & 1;
				Models[startIndex + m].Encode(rangeEncoder, bit);
				m = (m << 1) | bit;
				symbol >>= 1;
			}
		}

	}

	internal struct BitTreeDecoder {

		private readonly BitDecoder[] Models;
		private readonly int NumBitLevels;

		public BitTreeDecoder(int numBitLevels) {
			NumBitLevels = numBitLevels;
			Models = new BitDecoder[1 << numBitLevels];
		}

		public void Init() {
			for (uint i = 1; i < (1 << NumBitLevels); i++)
				Models[i].Init();
		}

		public uint Decode(Decoder rangeDecoder) {
			uint m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0; bitIndex--)
				m = (m << 1) + Models[m].Decode(rangeDecoder);
			return m - ((uint)1 << NumBitLevels);
		}

		public uint ReverseDecode(Decoder rangeDecoder) {
			uint m = 1;
			uint symbol = 0;
			for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++) {
				uint bit = Models[m].Decode(rangeDecoder);
				m <<= 1;
				m += bit;
				symbol |= (bit << bitIndex);
			}
			return symbol;
		}

		public static uint ReverseDecode(BitDecoder[] Models, UInt32 startIndex,
		                                 Decoder rangeDecoder, int NumBitLevels) {
			uint m = 1;
			uint symbol = 0;
			for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++) {
				uint bit = Models[startIndex + m].Decode(rangeDecoder);
				m <<= 1;
				m += bit;
				symbol |= (bit << bitIndex);
			}
			return symbol;
		}

	}
}
```

`Confuser.Core/LZMA/ICoder.cs`:

```cs
// ICoder.h

using System;
using System.IO;

namespace SevenZip {
	/// <summary>
	///     The exception that is thrown when an error in input stream occurs during decoding.
	/// </summary>
	internal class DataErrorException : ApplicationException {

		public DataErrorException() : base("Data Error") { }

	}

	/// <summary>
	///     The exception that is thrown when the value of an argument is outside the allowable range.
	/// </summary>
	internal class InvalidParamException : ApplicationException {

		public InvalidParamException() : base("Invalid Parameter") { }

	}

	internal interface ICodeProgress {

		/// <summary>
		///     Callback progress.
		/// </summary>
		/// <param name="inSize">
		///     input size. -1 if unknown.
		/// </param>
		/// <param name="outSize">
		///     output size. -1 if unknown.
		/// </param>
		void SetProgress(Int64 inSize, Int64 outSize);

	};

	internal interface ICoder {

		/// <summary>
		///     Codes streams.
		/// </summary>
		/// <param name="inStream">
		///     input Stream.
		/// </param>
		/// <param name="outStream">
		///     output Stream.
		/// </param>
		/// <param name="inSize">
		///     input Size. -1 if unknown.
		/// </param>
		/// <param name="outSize">
		///     output Size. -1 if unknown.
		/// </param>
		/// <param name="progress">
		///     callback progress reference.
		/// </param>
		/// <exception cref="SevenZip.DataErrorException">
		///     if input stream is not valid
		/// </exception>
		void Code(Stream inStream, Stream outStream,
		          Int64 inSize, Int64 outSize, ICodeProgress progress);

	};

	/*
    public interface ICoder2
    {
         void Code(ISequentialInStream []inStreams,
                const UInt64 []inSizes, 
                ISequentialOutStream []outStreams, 
                UInt64 []outSizes,
                ICodeProgress progress);
    };
  */

	/// <summary>
	///     Provides the fields that represent properties idenitifiers for compressing.
	/// </summary>
	internal enum CoderPropID {

		/// <summary>
		///     Specifies default property.
		/// </summary>
		DefaultProp = 0,

		/// <summary>
		///     Specifies size of dictionary.
		/// </summary>
		DictionarySize,

		/// <summary>
		///     Specifies size of memory for PPM*.
		/// </summary>
		UsedMemorySize,

		/// <summary>
		///     Specifies order for PPM methods.
		/// </summary>
		Order,

		/// <summary>
		///     Specifies Block Size.
		/// </summary>
		BlockSize,

		/// <summary>
		///     Specifies number of postion state bits for LZMA (0 &lt;= x &lt;= 4).
		/// </summary>
		PosStateBits,

		/// <summary>
		///     Specifies number of literal context bits for LZMA (0 &lt;= x &lt;= 8).
		/// </summary>
		LitContextBits,

		/// <summary>
		///     Specifies number of literal position bits for LZMA (0 &lt;= x &lt;= 4).
		/// </summary>
		LitPosBits,

		/// <summary>
		///     Specifies number of fast bytes for LZ*.
		/// </summary>
		NumFastBytes,

		/// <summary>
		///     Specifies match finder. LZMA: "BT2", "BT4" or "BT4B".
		/// </summary>
		MatchFinder,

		/// <summary>
		///     Specifies the number of match finder cyckes.
		/// </summary>
		MatchFinderCycles,

		/// <summary>
		///     Specifies number of passes.
		/// </summary>
		NumPasses,

		/// <summary>
		///     Specifies number of algorithm.
		/// </summary>
		Algorithm,

		/// <summary>
		///     Specifies the number of threads.
		/// </summary>
		NumThreads,

		/// <summary>
		///     Specifies mode with end marker.
		/// </summary>
		EndMarker

	};


	internal interface ISetCoderProperties {

		void SetCoderProperties(CoderPropID[] propIDs, object[] properties);

	};

	internal interface IWriteCoderProperties {

		void WriteCoderProperties(Stream outStream);

	}

	internal interface ISetDecoderProperties {

		void SetDecoderProperties(byte[] properties);

	}
}
```

`Confuser.Core/Marker.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Confuser.Core.Project;
using Confuser.Core.Project.Patterns;
using dnlib.DotNet;

namespace Confuser.Core {
	using Rules = Dictionary<Rule, PatternExpression>;

	/// <summary>
	///     Resolves and marks the modules with protection settings according to the rules.
	/// </summary>
	public class Marker {
		/// <summary>
		///     Annotation key of Strong Name Key.
		/// </summary>
		public static readonly object SNKey = new object();

		/// <summary>
		///     Annotation key of Strong Name Public Key.
		/// </summary>
		public static readonly object SNPubKey = new object();

		/// <summary>
		///     Annotation key of Strong Name delay signing.
		/// </summary>
		public static readonly object SNDelaySig = new object();

		/// <summary>
		///     Annotation key of Strong Name Signature Key.
		/// </summary>
		public static readonly object SNSigKey = new object();

		/// <summary>
		///     Annotation key of Strong Name Public Signature Key.
		/// </summary>
		public static readonly object SNSigPubKey = new object();

		/// <summary>
		///     Annotation key of rules.
		/// </summary>
		public static readonly object RulesKey = new object();

		/// <summary>
		///     The packers available to use.
		/// </summary>
		protected Dictionary<string, Packer> packers;

		/// <summary>
		///     The protections available to use.
		/// </summary>
		protected Dictionary<string, Protection> protections;

		/// <summary>
		///     Initalizes the Marker with specified protections and packers.
		/// </summary>
		/// <param name="protections">The protections.</param>
		/// <param name="packers">The packers.</param>
		public virtual void Initalize(IList<Protection> protections, IList<Packer> packers) {
			this.protections = protections.ToDictionary(prot => prot.Id, prot => prot, StringComparer.OrdinalIgnoreCase);
			this.packers = packers.ToDictionary(packer => packer.Id, packer => packer, StringComparer.OrdinalIgnoreCase);
		}

		/// <summary>
		///     Fills the protection settings with the specified preset.
		/// </summary>
		/// <param name="preset">The preset.</param>
		/// <param name="settings">The settings.</param>
		void FillPreset(ProtectionPreset preset, ProtectionSettings settings) {
			foreach (Protection prot in protections.Values)
				if (prot.Preset != ProtectionPreset.None && prot.Preset <= preset && !settings.ContainsKey(prot))
					settings.Add(prot, new Dictionary<string, string>());
		}

		public static StrongNamePublicKey LoadSNPubKey(ConfuserContext context, string path) {
			if (path == null) return null;

			try {
				return new StrongNamePublicKey(path);
			}
			catch (Exception ex) {
				context.Logger.ErrorException("Cannot load the Strong Name Public Key located at: " + path, ex);
				throw new ConfuserException(ex);
			}
		}

		/// <summary>
		///     Loads the Strong Name Key at the specified path with a optional password.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="path">The path to the key.</param>
		/// <param name="pass">
		///     The password of the certificate at <paramref name="path" /> if
		///     it is a pfx file; otherwise, <c>null</c>.
		/// </param>
		/// <returns>The loaded Strong Name Key.</returns>
		public static StrongNameKey LoadSNKey(ConfuserContext context, string path, string pass) {
			if (path == null) return null;

			try {
				if (pass != null) //pfx
				{
					// http://stackoverflow.com/a/12196742/462805
					var cert = new X509Certificate2();
					cert.Import(path, pass, X509KeyStorageFlags.Exportable);

					var rsa = cert.PrivateKey as RSACryptoServiceProvider;
					if (rsa == null)
						throw new ArgumentException("RSA key does not present in the certificate.", "path");

					return new StrongNameKey(rsa.ExportCspBlob(true));
				}
				return new StrongNameKey(path);
			}
			catch (Exception ex) {
				context.Logger.ErrorException("Cannot load the Strong Name Key located at: " + path, ex);
				throw new ConfuserException(ex);
			}
		}

		/// <summary>
		///     Loads the assembly and marks the project.
		/// </summary>
		/// <param name="proj">The project.</param>
		/// <param name="context">The working context.</param>
		/// <returns><see cref="MarkerResult" /> storing the marked modules and packer information.</returns>
		protected internal virtual MarkerResult MarkProject(ConfuserProject proj, ConfuserContext context) {
			Packer packer = null;
			Dictionary<string, string> packerParams = null;

			if (proj.Packer != null) {
				if (!packers.ContainsKey(proj.Packer.Id)) {
					context.Logger.ErrorFormat("Cannot find packer with ID '{0}'.", proj.Packer.Id);
					throw new ConfuserException(null);
				}
				if (proj.Debug)
					context.Logger.Warn("Generated Debug symbols might not be usable with packers!");

				packer = packers[proj.Packer.Id];
				packerParams = new Dictionary<string, string>(proj.Packer, StringComparer.OrdinalIgnoreCase);
			}

			var modules = new List<Tuple<ProjectModule, ModuleDefMD>>();
			var extModules = new List<byte[]>();
			foreach (ProjectModule module in proj) {
				if (module.IsExternal) {
					var rawModule = module.LoadRaw(proj.BaseDirectory);
					extModules.Add(rawModule);
					var extModule = ModuleDefMD.Load(rawModule, context.InternalResolver.DefaultModuleContext);
					extModule.EnableTypeDefFindCache = true;
					context.InternalResolver.AddToCache(extModule);
					continue;
				}

				ModuleDefMD modDef = module.Resolve(proj.BaseDirectory, context.InternalResolver.DefaultModuleContext);
				context.CheckCancellation();

				if (proj.Debug)
					modDef.LoadPdb();

				context.InternalResolver.AddToCache(modDef);
				modules.Add(Tuple.Create(module, modDef));
			}

			foreach (var module in modules) {
				context.Logger.InfoFormat("Loading '{0}'...", module.Item1.Path);
				Rules rules = ParseRules(proj, module.Item1, context);

				context.Annotations.Set(module.Item2, SNKey, LoadSNKey(context, module.Item1.SNKeyPath == null ? null : Path.Combine(proj.BaseDirectory, module.Item1.SNKeyPath), module.Item1.SNKeyPassword));
				context.Annotations.Set(module.Item2, SNSigKey, LoadSNKey(context, module.Item1.SNSigKeyPath == null ? null : Path.Combine(proj.BaseDirectory, module.Item1.SNSigKeyPath), module.Item1.SNSigKeyPassword));
				context.Annotations.Set(module.Item2, SNPubKey, LoadSNPubKey(context, module.Item1.SNPubKeyPath == null ? null : Path.Combine(proj.BaseDirectory, module.Item1.SNPubKeyPath)));
				context.Annotations.Set(module.Item2, SNSigPubKey, LoadSNPubKey(context, module.Item1.SNPubSigKeyPath == null ? null : Path.Combine(proj.BaseDirectory, module.Item1.SNPubSigKeyPath)));
				context.Annotations.Set(module.Item2, SNDelaySig, module.Item1.SNDelaySig);

				context.Annotations.Set(module.Item2, RulesKey, rules);

				foreach (IDnlibDef def in module.Item2.FindDefinitions()) {
					ApplyRules(context, def, rules);
					context.CheckCancellation();
				}

				// Packer parameters are stored in modules
				if (packerParams != null)
					ProtectionParameters.GetParameters(context, module.Item2)[packer] = packerParams;
			}
			return new MarkerResult(modules.Select(module => module.Item2).ToList(), packer, extModules);
		}

		/// <summary>
		///     Marks the member definition.
		/// </summary>
		/// <param name="member">The member definition.</param>
		/// <param name="context">The working context.</param>
		protected internal virtual void MarkMember(IDnlibDef member, ConfuserContext context) {
			ModuleDef module = ((IMemberRef)member).Module;
			var rules = context.Annotations.Get<Rules>(module, RulesKey);
			ApplyRules(context, member, rules);
		}

		/// <summary>
		///     Parses the rules' patterns.
		/// </summary>
		/// <param name="proj">The project.</param>
		/// <param name="module">The module description.</param>
		/// <param name="context">The working context.</param>
		/// <returns>Parsed rule patterns.</returns>
		/// <exception cref="System.ArgumentException">
		///     One of the rules has invalid pattern.
		/// </exception>
		protected Rules ParseRules(ConfuserProject proj, ProjectModule module, ConfuserContext context) {
			var ret = new Rules();
			var parser = new PatternParser();
			foreach (Rule rule in proj.Rules.Concat(module.Rules)) {
				try {
					ret.Add(rule, parser.Parse(rule.Pattern));
				}
				catch (InvalidPatternException ex) {
					context.Logger.ErrorFormat("Invalid rule pattern: " + rule.Pattern + ": {0}", ex.Message);
					throw new ConfuserException(ex);
				}
				foreach (var setting in rule) {
					if (!protections.ContainsKey(setting.Id)) {
						context.Logger.ErrorFormat("Cannot find protection with ID '{0}'.", setting.Id);
						throw new ConfuserException(null);
					}
				}
			}
			return ret;
		}

		/// <summary>
		///     Applies the rules to the target definition.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="target">The target definition.</param>
		/// <param name="rules">The rules.</param>
		/// <param name="baseSettings">The base settings.</param>
		protected void ApplyRules(ConfuserContext context, IDnlibDef target, Rules rules, ProtectionSettings baseSettings = null) {
			var ret = baseSettings == null ? new ProtectionSettings() : new ProtectionSettings(baseSettings);
			foreach (var i in rules) {
				if (!(bool)i.Value.Evaluate(target)) continue;

				if (!i.Key.Inherit)
					ret.Clear();

				FillPreset(i.Key.Preset, ret);
				foreach (var prot in i.Key) {
					if (prot.Action == SettingItemAction.Add)
						ret[protections[prot.Id]] = new Dictionary<string, string>(prot, StringComparer.OrdinalIgnoreCase);
					else
						ret.Remove(protections[prot.Id]);
				}
			}

			ProtectionParameters.SetParameters(context, target, ret);
		}
	}
}

```

`Confuser.Core/MarkerResult.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     Result of the marker.
	/// </summary>
	public class MarkerResult {
		/// <summary>
		///     Initializes a new instance of the <see cref="MarkerResult" /> class.
		/// </summary>
		/// <param name="modules">The modules.</param>
		/// <param name="packer">The packer.</param>
		/// <param name="extModules">The external modules.</param>
		public MarkerResult(IList<ModuleDefMD> modules, Packer packer, IList<byte[]> extModules) {
			Modules = modules;
			Packer = packer;
			ExternalModules = extModules;
		}

		/// <summary>
		///     Gets a list of modules that is marked.
		/// </summary>
		/// <value>The list of modules.</value>
		public IList<ModuleDefMD> Modules { get; private set; }

		/// <summary>
		///     Gets a list of external modules.
		/// </summary>
		/// <value>The list of external modules.</value>
		public IList<byte[]> ExternalModules { get; private set; }

		/// <summary>
		///     Gets the packer if exists.
		/// </summary>
		/// <value>The packer, or null if no packer exists.</value>
		public Packer Packer { get; private set; }
	}
}
```

`Confuser.Core/ModuleSorter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     Sort modules according dependencies.
	/// </summary>
	internal class ModuleSorter {
		readonly List<ModuleDefMD> modules;

		public ModuleSorter(IEnumerable<ModuleDefMD> modules) {
			this.modules = modules.ToList();
		}

		public IList<ModuleDefMD> Sort() {
			var edges = new List<DependencyGraphEdge>();
			var roots = new HashSet<ModuleDefMD>(modules);
			var asmMap = modules.GroupBy(module => module.Assembly.ToAssemblyRef(), AssemblyNameComparer.CompareAll)
			                    .ToDictionary(gp => gp.Key, gp => gp.ToList(), AssemblyNameComparer.CompareAll);

			foreach (ModuleDefMD m in modules)
				foreach (AssemblyRef nameRef in m.GetAssemblyRefs()) {
					if (!asmMap.ContainsKey(nameRef))
						continue;

					foreach (var asmModule in asmMap[nameRef])
						edges.Add(new DependencyGraphEdge(asmModule, m));
					roots.Remove(m);
				}

			var sorted = SortGraph(roots, edges).ToList();
			Debug.Assert(sorted.Count == modules.Count);
			return sorted;
		}

		IEnumerable<ModuleDefMD> SortGraph(IEnumerable<ModuleDefMD> roots, IList<DependencyGraphEdge> edges) {
			var visited = new HashSet<ModuleDefMD>();
			var queue = new Queue<ModuleDefMD>(roots);
			do {
				while (queue.Count > 0) {
					var node = queue.Dequeue();
					visited.Add(node);

					Debug.Assert(!edges.Where(edge => edge.To == node).Any());
					yield return node;

					foreach (DependencyGraphEdge edge in edges.Where(edge => edge.From == node).ToList()) {
						edges.Remove(edge);
						if (!edges.Any(e => e.To == edge.To))
							queue.Enqueue(edge.To);
					}
				}
				if (edges.Count > 0) {
					foreach (var edge in edges) {
						if (!visited.Contains(edge.From)) {
							queue.Enqueue(edge.From);
							break;
						}
					}
				}
			} while (edges.Count > 0);
		}

		class DependencyGraphEdge {
			public DependencyGraphEdge(ModuleDefMD from, ModuleDefMD to) {
				From = from;
				To = to;
			}

			public ModuleDefMD From { get; private set; }
			public ModuleDefMD To { get; private set; }
		}
	}
}
```

`Confuser.Core/NativeEraser.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using dnlib.IO;
using dnlib.PE;
using SR = System.Reflection;

namespace Confuser.Core {
	internal class NativeEraser {
		static void Erase(Tuple<uint, uint, byte[]> section, uint offset, uint len) {
			Array.Clear(section.Item3, (int)(offset - section.Item1), (int)len);
		}

		static void Erase(List<Tuple<uint, uint, byte[]>> sections, uint beginOffset, uint size) {
			foreach (var sect in sections)
				if (beginOffset >= sect.Item1 && beginOffset + size < sect.Item2) {
					Erase(sect, beginOffset, size);
					break;
				}
		}

		static void Erase(List<Tuple<uint, uint, byte[]>> sections, IFileSection s) {
			foreach (var sect in sections)
				if ((uint)s.StartOffset >= sect.Item1 && (uint)s.EndOffset < sect.Item2) {
					Erase(sect, (uint)s.StartOffset, (uint)(s.EndOffset - s.StartOffset));
					break;
				}
		}

		static void Erase(List<Tuple<uint, uint, byte[]>> sections, uint methodOffset) {
			foreach (var sect in sections)
				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {
					uint f = sect.Item3[methodOffset - sect.Item1];
					uint size;
					switch ((f & 7)) {
					case 2:
					case 6:
						size = (f >> 2) + 1;
						break;

					case 3:
						f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);
						size = (f >> 12) * 4;
						uint codeSize = BitConverter.ToUInt32(sect.Item3, (int)(methodOffset - sect.Item1 + 4));
						size += codeSize;
						break;
					default:
						return;
					}
					Erase(sect, methodOffset, size);
				}
		}

		public static void Erase(NativeModuleWriter writer, ModuleDefMD module) {
			if (writer == null || module == null)
				return;

			var sections = new List<Tuple<uint, uint, byte[]>>();
			var s = new MemoryStream();
			foreach (var origSect in writer.OrigSections) {
				var oldChunk = origSect.Chunk;
				var sectHdr = origSect.PESection;

				s.SetLength(0);
				oldChunk.WriteTo(new DataWriter(s));
				var buf = s.ToArray();
				var newChunk = new DataReaderChunk(oldChunk.CreateReader());
				newChunk.SetOffset(oldChunk.FileOffset, oldChunk.RVA);

				origSect.Chunk = newChunk;

				sections.Add(Tuple.Create(
					sectHdr.PointerToRawData,
					sectHdr.PointerToRawData + sectHdr.SizeOfRawData,
					buf));
			}

			var md = module.Metadata;

			var row = md.TablesStream.MethodTable.Rows;
			for (uint i = 1; i <= row; i++) {
				if (md.TablesStream.TryReadMethodRow(i, out var method)) {
					var codeType = ((MethodImplAttributes)method.ImplFlags & MethodImplAttributes.CodeTypeMask);
					if (codeType == MethodImplAttributes.IL)
						Erase(sections, (uint)md.PEImage.ToFileOffset((RVA)method.RVA));
				}
			}

			var res = md.ImageCor20Header.Resources;
			if (res.Size > 0)
				Erase(sections, (uint)res.StartOffset, res.Size);

			Erase(sections, md.ImageCor20Header);
			Erase(sections, md.MetadataHeader);
			foreach (var stream in md.AllStreams)
				Erase(sections, stream);
		}
	}
}

```

`Confuser.Core/NullLogger.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     An <see cref="ILogger" /> implementation that doesn't actually do any logging.
	/// </summary>
	internal class NullLogger : ILogger {
		/// <summary>
		///     The singleton instance of <see cref="NullLogger" />.
		/// </summary>
		public static readonly NullLogger Instance = new NullLogger();

		/// <summary>
		///     Prevents a default instance of the <see cref="NullLogger" /> class from being created.
		/// </summary>
		NullLogger() { }

		/// <inheritdoc />
		public void Debug(string msg) { }

		/// <inheritdoc />
		public void DebugFormat(string format, params object[] args) { }

		/// <inheritdoc />
		public void Info(string msg) { }

		/// <inheritdoc />
		public void InfoFormat(string format, params object[] args) { }

		/// <inheritdoc />
		public void Warn(string msg) { }

		/// <inheritdoc />
		public void WarnFormat(string format, params object[] args) { }

		/// <inheritdoc />
		public void WarnException(string msg, Exception ex) { }

		/// <inheritdoc />
		public void Error(string msg) { }

		/// <inheritdoc />
		public void ErrorFormat(string format, params object[] args) { }

		/// <inheritdoc />
		public void ErrorException(string msg, Exception ex) { }

		/// <inheritdoc />
		public void Progress(int overall, int progress) { }

		/// <inheritdoc />
		public void EndProgress() { }

		/// <inheritdoc />
		public void Finish(bool successful) { }

		/// <inheritdoc />
		public void BeginModule(ModuleDef module) { }

		/// <inheritdoc />
		public void EndModule(ModuleDef module) { }
	}
}
```

`Confuser.Core/ObfAttrMarker.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Confuser.Core.Project;
using Confuser.Core.Project.Patterns;
using dnlib.DotNet;

namespace Confuser.Core {
	using Rules = Dictionary<Rule, PatternExpression>;

	/// <summary>
	/// Obfuscation Attribute Marker
	/// </summary>
	public class ObfAttrMarker : Marker {
		struct ObfuscationAttributeInfo {
			public IHasCustomAttribute Owner;
			public bool? ApplyToMembers;
			public bool? Exclude;
			public string FeatureName;
			public string FeatureValue;
		}

		struct ProtectionSettingsInfo {
			public bool ApplyToMember;
			public bool Exclude;

			public PatternExpression Condition;
			public string Settings;
		}

		class ProtectionSettingsStack {
			readonly ConfuserContext context;
			readonly Stack<Tuple<ProtectionSettings, ProtectionSettingsInfo[]>> stack;
			readonly ObfAttrParser parser;
			ProtectionSettings settings;

			enum ApplyInfoType {
				CurrentInfoOnly,
				CurrentInfoInherits,
				ParentInfo
			}

			class PopHolder : IDisposable {
				ProtectionSettingsStack parent;

				public PopHolder(ProtectionSettingsStack parent) {
					this.parent = parent;
				}

				public void Dispose() {
					parent.Pop();
				}
			}

			public ProtectionSettingsStack(ConfuserContext context, Dictionary<string, Protection> protections) {
				this.context = context;
				stack = new Stack<Tuple<ProtectionSettings, ProtectionSettingsInfo[]>>();
				parser = new ObfAttrParser(protections);
			}

			public ProtectionSettingsStack(ProtectionSettingsStack copy) {
				context = copy.context;
				stack = new Stack<Tuple<ProtectionSettings, ProtectionSettingsInfo[]>>(copy.stack);
				parser = copy.parser;
			}

			void Pop() {
				settings = stack.Pop().Item1;
			}

			public IDisposable Apply(IDnlibDef target, IEnumerable<ProtectionSettingsInfo> infos) {
				ProtectionSettings settings;
				if (this.settings == null)
					settings = new ProtectionSettings();
				else
					settings = new ProtectionSettings(this.settings);

				var infoArray = infos.ToArray();

				if (stack.Count > 0) {
					foreach (var i in stack.Reverse())
						ApplyInfo(target, settings, i.Item2, ApplyInfoType.ParentInfo);
				}

				IDisposable result;
				if (infoArray.Length != 0) {
					var originalSettings = this.settings;

					// the settings that would apply to members
					ApplyInfo(target, settings, infoArray, ApplyInfoType.CurrentInfoInherits);
					this.settings = new ProtectionSettings(settings);

					// the settings that would apply to itself
					ApplyInfo(target, settings, infoArray, ApplyInfoType.CurrentInfoOnly);
					stack.Push(Tuple.Create(originalSettings, infoArray));

					result = new PopHolder(this);
				}
				else
					result = null;

				ProtectionParameters.SetParameters(context, target, settings);
				return result;
			}

			void ApplyInfo(IDnlibDef context, ProtectionSettings settings, IEnumerable<ProtectionSettingsInfo> infos, ApplyInfoType type) {
				foreach (var info in infos) {
					if (info.Condition != null && !(bool)info.Condition.Evaluate(context))
						continue;

					if (info.Condition == null && info.Exclude) {
						if ((type == ApplyInfoType.ParentInfo && info.ApplyToMember) ||
							type == ApplyInfoType.CurrentInfoOnly ||
							(type == ApplyInfoType.CurrentInfoInherits && info.ApplyToMember)) {
							settings.Clear();
						}
					}
					if (!string.IsNullOrEmpty(info.Settings)) {
						if ((type == ApplyInfoType.ParentInfo && info.ApplyToMember) ||
							type == ApplyInfoType.CurrentInfoOnly ||
							(type == ApplyInfoType.CurrentInfoInherits && info.Condition == null && info.ApplyToMember)) {
							parser.ParseProtectionString(settings, info.Settings);
						}
					}
				}
			}
		}

		static readonly Regex OrderPattern = new Regex("^(\\d+)\\. (.+)$");

		static IEnumerable<ObfuscationAttributeInfo> ReadObfuscationAttributes(IHasCustomAttribute item) {
			var ret = new List<Tuple<int?, ObfuscationAttributeInfo>>();
			for (int i = item.CustomAttributes.Count - 1; i >= 0; i--) {
				var ca = item.CustomAttributes[i];
				if (ca.TypeFullName != "System.Reflection.ObfuscationAttribute")
					continue;

				var info = new ObfuscationAttributeInfo();
				int? order = null;

				info.Owner = item;
				bool strip = true;
				foreach (var prop in ca.Properties) {
					switch (prop.Name) {
					case "ApplyToMembers":
						Debug.Assert(prop.Type.ElementType == ElementType.Boolean);
						info.ApplyToMembers = (bool)prop.Value;
						break;

					case "Exclude":
						Debug.Assert(prop.Type.ElementType == ElementType.Boolean);
						info.Exclude = (bool)prop.Value;
						break;

					case "StripAfterObfuscation":
						Debug.Assert(prop.Type.ElementType == ElementType.Boolean);
						strip = (bool)prop.Value;
						break;

					case "Feature":
						Debug.Assert(prop.Type.ElementType == ElementType.String);
						string feature = (UTF8String)prop.Value;

						var match = OrderPattern.Match(feature);
						if (match.Success) {
							var orderStr = match.Groups[1].Value;
							var f = match.Groups[2].Value;
							int o;
							if (!int.TryParse(orderStr, out o))
								throw new NotSupportedException(string.Format("Failed to parse feature '{0}' in {1} ", feature, item));
							order = o;
							feature = f;
						}

						int sepIndex = feature.IndexOf(':');
						if (sepIndex == -1) {
							info.FeatureName = "";
							info.FeatureValue = feature;
						}
						else {
							info.FeatureName = feature.Substring(0, sepIndex);
							info.FeatureValue = feature.Substring(sepIndex + 1);
						}
						break;

					default:
						throw new NotSupportedException("Unsupported property: " + prop.Name);
					}
				}
				if (strip)
					item.CustomAttributes.RemoveAt(i);

				if (item is IMemberRef && !(item is ITypeDefOrRef))
					info.ApplyToMembers = false;

				ret.Add(Tuple.Create(order, info));
			}
			ret.Reverse();
			return ret.OrderBy(pair => pair.Item1).Select(pair => pair.Item2);
		}

		bool ToInfo(ObfuscationAttributeInfo attr, out ProtectionSettingsInfo info) {
			info = new ProtectionSettingsInfo();

			info.Condition = null;

			info.Exclude = (attr.Exclude ?? true);
			info.ApplyToMember = (attr.ApplyToMembers ?? true);
			info.Settings = attr.FeatureValue;

			bool ok = true;
			try {
				new ObfAttrParser(protections).ParseProtectionString(null, info.Settings);
			}
			catch {
				ok = false;
			}

			if (!ok) {
				context.Logger.WarnFormat("Ignoring rule '{0}' in {1}.", info.Settings, attr.Owner);
				return false;
			}

			if (!string.IsNullOrEmpty(attr.FeatureName))
				throw new ArgumentException("Feature name must not be set. Owner=" + attr.Owner);
			if (info.Exclude && (!string.IsNullOrEmpty(attr.FeatureName) || !string.IsNullOrEmpty(attr.FeatureValue))) {
				throw new ArgumentException("Feature property cannot be set when Exclude is true. Owner=" + attr.Owner);
			}
			return true;
		}

		ProtectionSettingsInfo ToInfo(Rule rule, PatternExpression expr) {
			var info = new ProtectionSettingsInfo();

			info.Condition = expr;

			info.Exclude = false;
			info.ApplyToMember = true;

			var settings = new StringBuilder();
			if (rule.Preset != ProtectionPreset.None)
				settings.AppendFormat("preset({0});", rule.Preset.ToString().ToLowerInvariant());
			foreach (var item in rule) {
				settings.Append(item.Action == SettingItemAction.Add ? '+' : '-');
				settings.Append(item.Id);
				if (item.Count > 0) {
					settings.Append('(');
					int i = 0;
					foreach (var arg in item) {
						if (i != 0)
							settings.Append(',');
						settings.AppendFormat("{0}='{1}'", arg.Key, arg.Value.Replace("'", "\\'"));
						i++;
					}
					settings.Append(')');
				}
				settings.Append(';');
			}
			info.Settings = settings.ToString();

			return info;
		}

		IEnumerable<ProtectionSettingsInfo> ReadInfos(IHasCustomAttribute item) {
			foreach (var attr in ReadObfuscationAttributes(item)) {
				ProtectionSettingsInfo info;
				if (!string.IsNullOrEmpty(attr.FeatureName))
					yield return AddRule(attr, null);
				else if (ToInfo(attr, out info))
					yield return info;
			}
		}

		ConfuserContext context;
		ConfuserProject project;
		Packer packer;
		Dictionary<string, string> packerParams;
		List<byte[]> extModules;

		static readonly object ModuleSettingsKey = new object();

		/// <inheritdoc />
		protected internal override void MarkMember(IDnlibDef member, ConfuserContext context) {
			ModuleDef module = ((IMemberRef)member).Module;
			var stack = context.Annotations.Get<ProtectionSettingsStack>(module, ModuleSettingsKey);
			using (stack.Apply(member, Enumerable.Empty<ProtectionSettingsInfo>()))
				return;
		}

		/// <inheritdoc />
		protected internal override MarkerResult MarkProject(ConfuserProject proj, ConfuserContext context) {
			this.context = context;
			project = proj;
			extModules = new List<byte[]>();

			if (proj.Packer != null) {
				if (!packers.ContainsKey(proj.Packer.Id)) {
					context.Logger.ErrorFormat("Cannot find packer with ID '{0}'.", proj.Packer.Id);
					throw new ConfuserException(null);
				}

				packer = packers[proj.Packer.Id];
				packerParams = new Dictionary<string, string>(proj.Packer, StringComparer.OrdinalIgnoreCase);
			}

			var modules = new List<Tuple<ProjectModule, ModuleDefMD>>();
			foreach (ProjectModule module in proj) {
				if (module.IsExternal) {
					var rawModule = module.LoadRaw(proj.BaseDirectory);
					extModules.Add(rawModule);
					context.InternalResolver.AddToCache(ModuleDefMD.Load(rawModule, context.InternalResolver.DefaultModuleContext));
					continue;
				}

				try {
					ModuleDefMD modDef =
						module.Resolve(proj.BaseDirectory, context.InternalResolver.DefaultModuleContext);
					context.CheckCancellation();

					context.InternalResolver.AddToCache(modDef);
					modules.Add(Tuple.Create(module, modDef));
				}
				catch (BadImageFormatException ex) {
					context.Logger.ErrorFormat("Failed to load \"{0}\" - Assembly does not appear to be a .NET assembly: \"{1}\".", module.Path, ex.Message);
					throw new ConfuserException(ex);
				}
			}
			foreach (var module in modules) {
				context.Logger.InfoFormat("Loading '{0}'...", module.Item1.Path);

				Rules rules = ParseRules(proj, module.Item1, context);
				MarkModule(module.Item1, module.Item2, rules, module == modules[0]);

				context.Annotations.Set(module.Item2, RulesKey, rules);

				// Packer parameters are stored in modules
				if (packer != null)
					ProtectionParameters.GetParameters(context, module.Item2)[packer] = packerParams;
			}

			if (proj.Debug && proj.Packer != null)
				context.Logger.Warn("Generated Debug symbols might not be usable with packers!");

			return new MarkerResult(modules.Select(module => module.Item2).ToList(), packer, extModules);
		}

		ProtectionSettingsInfo AddRule(ObfuscationAttributeInfo attr, List<ProtectionSettingsInfo> infos) {
			Debug.Assert(attr.FeatureName != null);

			var pattern = attr.FeatureName;
			PatternExpression expr;
			try {
				expr = new PatternParser().Parse(pattern);
			}
			catch (Exception ex) {
				throw new Exception("Error when parsing pattern " + pattern + " in ObfuscationAttribute. Owner=" + attr.Owner, ex);
			}

			var info = new ProtectionSettingsInfo();
			info.Condition = expr;

			info.Exclude = (attr.Exclude ?? true);
			info.ApplyToMember = (attr.ApplyToMembers ?? true);
			info.Settings = attr.FeatureValue;

			bool ok = true;
			try {
				new ObfAttrParser(protections).ParseProtectionString(null, info.Settings);
			}
			catch {
				ok = false;
			}

			if (!ok)
				context.Logger.WarnFormat("Ignoring rule '{0}' in {1}.", info.Settings, attr.Owner);
			else if (infos != null)
				infos.Add(info);
			return info;
		}

		void MarkModule(ProjectModule projModule, ModuleDefMD module, Rules rules, bool isMain) {
			string snKeyPath = projModule.SNKeyPath;
			string snKeyPass = projModule.SNKeyPassword;
			string snPubKeyPath = projModule.SNPubKeyPath;
			bool snDelaySig = projModule.SNDelaySig;
			string snSigKeyPath = projModule.SNSigKeyPath;
			string snSigKeyPass = projModule.SNSigKeyPassword;
			string snPubSigKeyPath = projModule.SNPubSigKeyPath;

			var stack = new ProtectionSettingsStack(context, protections);

			var layer = new List<ProtectionSettingsInfo>();
			// Add rules
			foreach (var rule in rules)
				layer.Add(ToInfo(rule.Key, rule.Value));

			// Add obfuscation attributes
			foreach (var attr in ReadObfuscationAttributes(module.Assembly)) {
				if (string.IsNullOrEmpty(attr.FeatureName)) {
					ProtectionSettingsInfo info;
					if (ToInfo(attr, out info))
						layer.Add(info);
				}
				else if (attr.FeatureName.Equals("generate debug symbol", StringComparison.OrdinalIgnoreCase)) {
					if (!isMain)
						throw new ArgumentException("Only main module can set 'generate debug symbol'.");
					project.Debug = bool.Parse(attr.FeatureValue);
				}
				else if (attr.FeatureName.Equals("random seed", StringComparison.OrdinalIgnoreCase)) {
					if (!isMain)
						throw new ArgumentException("Only main module can set 'random seed'.");
					project.Seed = attr.FeatureValue;
				}
				else if (attr.FeatureName.Equals("strong name key", StringComparison.OrdinalIgnoreCase)) {
					snKeyPath = Path.Combine(project.BaseDirectory, attr.FeatureValue);
				}
				else if (attr.FeatureName.Equals("strong name key password", StringComparison.OrdinalIgnoreCase)) {
					snKeyPass = attr.FeatureValue;
				}
				else if (attr.FeatureName.Equals("packer", StringComparison.OrdinalIgnoreCase)) {
					if (!isMain)
						throw new ArgumentException("Only main module can set 'packer'.");
					new ObfAttrParser(packers).ParsePackerString(attr.FeatureValue, out packer, out packerParams);
				}
				else if (attr.FeatureName.Equals("external module", StringComparison.OrdinalIgnoreCase)) {
					if (!isMain)
						throw new ArgumentException("Only main module can add external modules.");
					var rawModule = new ProjectModule { Path = attr.FeatureValue }.LoadRaw(project.BaseDirectory);
					extModules.Add(rawModule);
				}
				else {
					AddRule(attr, layer);
				}
			}

			if (project.Debug && module.PdbState == null) {
				module.LoadPdb();
			}

			snKeyPath = snKeyPath == null ? null : Path.Combine(project.BaseDirectory, snKeyPath);
			snPubKeyPath = snPubKeyPath == null ? null : Path.Combine(project.BaseDirectory, snPubKeyPath);
			snSigKeyPath = snSigKeyPath == null ? null : Path.Combine(project.BaseDirectory, snSigKeyPath);
			snPubSigKeyPath = snPubSigKeyPath == null ? null : Path.Combine(project.BaseDirectory, snPubSigKeyPath);

			var snKey = LoadSNKey(context, snKeyPath, snKeyPass);
			context.Annotations.Set(module, SNKey, snKey);

			var snPubKey = LoadSNPubKey(context, snPubKeyPath);
			context.Annotations.Set(module, SNPubKey, snPubKey);

			context.Annotations.Set(module, SNDelaySig, snDelaySig);

			var snSigKey = LoadSNKey(context, snSigKeyPath, snSigKeyPass);
			context.Annotations.Set(module, SNSigKey, snSigKey);

			var snSigPubKey = LoadSNPubKey(context, snPubSigKeyPath);
			context.Annotations.Set(module, SNSigPubKey, snSigPubKey);

			using (stack.Apply(module, layer))
				ProcessModule(module, stack);
		}

		void ProcessModule(ModuleDefMD module, ProtectionSettingsStack stack) {
			context.Annotations.Set(module, ModuleSettingsKey, new ProtectionSettingsStack(stack));
			foreach (var type in module.Types) {
				using (stack.Apply(type, ReadInfos(type)))
					ProcessTypeMembers(type, stack);
			}
		}

		void ProcessTypeMembers(TypeDef type, ProtectionSettingsStack stack) {
			foreach (var nestedType in type.NestedTypes) {
				using (stack.Apply(nestedType, ReadInfos(nestedType)))
					ProcessTypeMembers(nestedType, stack);
			}

			foreach (var property in type.Properties) {
				using (stack.Apply(property, ReadInfos(property))) {
					if (property.GetMethod != null)
						ProcessMember(property.GetMethod, stack);

					if (property.SetMethod != null)
						ProcessMember(property.SetMethod, stack);

					foreach (var m in property.OtherMethods)
						ProcessMember(m, stack);
				}
			}

			foreach (var evt in type.Events) {
				using (stack.Apply(evt, ReadInfos(evt))) {
					if (evt.AddMethod != null)
						ProcessMember(evt.AddMethod, stack);

					if (evt.RemoveMethod != null)
						ProcessMember(evt.RemoveMethod, stack);

					if (evt.InvokeMethod != null)
						ProcessMember(evt.InvokeMethod, stack);

					foreach (var m in evt.OtherMethods)
						ProcessMember(m, stack);
				}
			}

			foreach (var method in type.Methods) {
				if (method.SemanticsAttributes == 0)
					ProcessMember(method, stack);
			}

			foreach (var field in type.Fields) {
				ProcessMember(field, stack);
			}
		}

		void ProcessMember(IDnlibDef member, ProtectionSettingsStack stack) {
			using (stack.Apply(member, ReadInfos(member)))
				ProcessBody(member as MethodDef, stack);
		}

		void ProcessBody(MethodDef method, ProtectionSettingsStack stack) {
			if (method == null || method.Body == null)
				return;

			var declType = method.DeclaringType;
			foreach (var instr in method.Body.Instructions)
				if (instr.Operand is MethodDef) {
					var cgType = ((MethodDef)instr.Operand).DeclaringType;
					if (cgType.DeclaringType == declType && cgType.IsCompilerGenerated()) {
						using (stack.Apply(cgType, ReadInfos(cgType)))
							ProcessTypeMembers(cgType, stack);
					}
				}
		}
	}
}

```

`Confuser.Core/ObfAttrParser.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Confuser.Core {
	internal struct ObfAttrParser {
		readonly IDictionary items;

		string str;
		int index;

		public ObfAttrParser(IDictionary items) {
			this.items = items;
			str = null;
			index = -1;
		}

		enum ParseState {
			Init,
			ReadPreset,
			ReadItemName,
			ProcessItemName,
			ReadParam,
			EndItem,
			End
		}

		bool ReadId(StringBuilder sb) {
			while (index < str.Length) {
				switch (str[index]) {
					case '(':
					case ')':
					case '+':
					case '-':
					case '=':
					case ';':
					case ',':
						return true;
					default:
						sb.Append(str[index++]);
						break;
				}
			}
			return false;
		}

		bool ReadString(StringBuilder sb) {
			Expect('\'');
			while (index < str.Length) {
				switch (str[index]) {
					case '\\':
						sb.Append(str[++index]);
						break;
					case '\'':
						index++;
						return true;
					default:
						sb.Append(str[index]);
						break;
				}
				index++;
			}
			return false;
		}

		void Expect(char chr) {
			if (str[index] != chr)
				throw new ArgumentException("Expect '" + chr + "' at position " + (index + 1) + ".");
			index++;
		}

		char Peek() {
			return str[index];
		}

		void Next() {
			index++;
		}

		bool IsEnd() {
			return index == str.Length;
		}

		public void ParseProtectionString(IDictionary<ConfuserComponent, Dictionary<string, string>> settings, string str) {
			if (str == null)
				return;

			this.str = str;
			index = 0;

			var state = ParseState.Init;
			var buffer = new StringBuilder();

			bool protAct = true;
			string protId = null;
			var protParams = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

			while (state != ParseState.End) {
				switch (state) {
					case ParseState.Init:
						ReadId(buffer);
						if (buffer.ToString().Equals("preset", StringComparison.OrdinalIgnoreCase)) {
							if (IsEnd())
								throw new ArgumentException("Unexpected end of string in Init state.");
							Expect('(');
							buffer.Length = 0;
							state = ParseState.ReadPreset;
						}
						else if (buffer.Length == 0) {
							if (IsEnd())
								throw new ArgumentException("Unexpected end of string in Init state.");
							state = ParseState.ReadItemName;
						}
						else {
							protAct = true;
							state = ParseState.ProcessItemName;
						}
						break;

					case ParseState.ReadPreset:
						if (!ReadId(buffer))
							throw new ArgumentException("Unexpected end of string in ReadPreset state.");
						Expect(')');

						var preset = (ProtectionPreset)Enum.Parse(typeof(ProtectionPreset), buffer.ToString(), true);
						foreach (var item in items.Values.OfType<Protection>().Where(prot => prot.Preset <= preset)) {
							if (item.Preset != ProtectionPreset.None && settings != null && !settings.ContainsKey(item))
								settings.Add(item, new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase));
						}
						buffer.Length = 0;

						if (IsEnd())
							state = ParseState.End;
						else {
							Expect(';');
							if (IsEnd())
								state = ParseState.End;
							else
								state = ParseState.ReadItemName;
						}
						break;

					case ParseState.ReadItemName:
						protAct = true;
						if (Peek() == '+') {
							protAct = true;
							Next();
						}
						else if (Peek() == '-') {
							protAct = false;
							Next();
						}
						ReadId(buffer);
						state = ParseState.ProcessItemName;
						break;

					case ParseState.ProcessItemName:
						protId = buffer.ToString();
						buffer.Length = 0;
						if (IsEnd() || Peek() == ';')
							state = ParseState.EndItem;
						else if (Peek() == '(') {
							if (!protAct)
								throw new ArgumentException("No parameters is allowed when removing protection.");
							Next();
							state = ParseState.ReadParam;
						}
						else
							throw new ArgumentException("Unexpected character in ProcessItemName state at " + index + ".");
						break;

					case ParseState.ReadParam:
						string paramName, paramValue;

						if (!ReadId(buffer))
							throw new ArgumentException("Unexpected end of string in ReadParam state.");
						paramName = buffer.ToString();
						buffer.Length = 0;

						Expect('=');
						if (!(Peek() == '\'' ? ReadString(buffer) : ReadId(buffer)))
							throw new ArgumentException("Unexpected end of string in ReadParam state.");

						paramValue = buffer.ToString();
						buffer.Length = 0;

						protParams.Add(paramName, paramValue);

						if (Peek() == ',') {
							Next();
							state = ParseState.ReadParam;
						}
						else if (Peek() == ')') {
							Next();
							state = ParseState.EndItem;
						}
						else
							throw new ArgumentException("Unexpected character in ReadParam state at " + index + ".");
						break;

					case ParseState.EndItem:
						if (settings != null) {
							if (!items.Contains(protId))
								throw new KeyNotFoundException("Cannot find protection with id '" + protId + "'.");

							if (protAct) {
								if (settings.ContainsKey((Protection)items[protId])) {
									var p = settings[(Protection)items[protId]];
									foreach (var kvp in protParams)
										p[kvp.Key] = kvp.Value;
								}
								else
									settings[(Protection)items[protId]] = protParams;
							}
							else
								settings.Remove((Protection)items[protId]);
						}
						protParams = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

						if (IsEnd())
							state = ParseState.End;
						else {
							Expect(';');
							if (IsEnd())
								state = ParseState.End;
							else
								state = ParseState.ReadItemName;
						}
						break;
				}
			}
		}

		public void ParsePackerString(string str, out Packer packer, out Dictionary<string, string> packerParams) {
			packer = null;
			packerParams = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

			if (str == null)
				return;

			this.str = str;
			index = 0;

			var state = ParseState.ReadItemName;
			var buffer = new StringBuilder();
			var ret = new ProtectionSettings();

			while (state != ParseState.End) {
				switch (state) {
					case ParseState.ReadItemName:
						ReadId(buffer);

						var packerId = buffer.ToString();
						if (!items.Contains(packerId))
							throw new KeyNotFoundException("Cannot find packer with id '" + packerId + "'.");

						packer = (Packer)items[packerId];
						buffer.Length = 0;

						if (IsEnd() || Peek() == ';')
							state = ParseState.EndItem;
						else if (Peek() == '(') {
							Next();
							state = ParseState.ReadParam;
						}
						else
							throw new ArgumentException("Unexpected character in ReadItemName state at " + index + ".");
						break;

					case ParseState.ReadParam:
						string paramName, paramValue;

						if (!ReadId(buffer))
							throw new ArgumentException("Unexpected end of string in ReadParam state.");
						paramName = buffer.ToString();
						buffer.Length = 0;

						Expect('=');
						if (!ReadId(buffer))
							throw new ArgumentException("Unexpected end of string in ReadParam state.");
						paramValue = buffer.ToString();
						buffer.Length = 0;

						packerParams.Add(paramName, paramValue);

						if (Peek() == ',') {
							Next();
							state = ParseState.ReadParam;
						}
						else if (Peek() == ')') {
							Next();
							state = ParseState.EndItem;
						}
						else
							throw new ArgumentException("Unexpected character in ReadParam state at " + index + ".");
						break;

					case ParseState.EndItem:
						if (IsEnd())
							state = ParseState.End;
						else {
							Expect(';');
							if (!IsEnd())
								throw new ArgumentException("Unexpected character in EndItem state at " + index + ".");
							state = ParseState.End;
						}
						break;
				}
			}
		}
	}
}
```

`Confuser.Core/Packer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using Confuser.Core.Project;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     Base class of Confuser packers.
	/// </summary>
	/// <remarks>
	///     A parameterless constructor must exists in derived classes to enable plugin discovery.
	/// </remarks>
	public abstract class Packer : ConfuserComponent {
		/// <summary>
		///     Executes the packer.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="parameters">The parameters of packer.</param>
		protected internal abstract void Pack(ConfuserContext context, ProtectionParameters parameters);

		/// <summary>
		///     Protects the stub using original project settings replace the current output with the protected stub.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="fileName">The result file name.</param>
		/// <param name="module">The stub module.</param>
		/// <param name="snKey">The strong name key.</param>
		/// <param name="prot">The packer protection that applies to the stub.</param>
		protected void ProtectStub(ConfuserContext context, string fileName, byte[] module, StrongNameKey snKey, StrongNamePublicKey snPubKey, StrongNameKey snSigKey, StrongNamePublicKey snPubSigKey, bool snDelaySig, Protection prot = null) {
			string tmpDir = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
			try {
				string outDir = Path.Combine(tmpDir, Path.GetRandomFileName());
				Directory.CreateDirectory(tmpDir);

				for (int i = 0; i < context.OutputModules.Count; i++) {
					string path = Path.GetFullPath(Path.Combine(tmpDir, context.OutputPaths[i]));
					var dir = Path.GetDirectoryName(path);
					if (!Directory.Exists(dir))
						Directory.CreateDirectory(dir);
					File.WriteAllBytes(path, context.OutputModules[i]);
				}

				File.WriteAllBytes(Path.Combine(tmpDir, fileName), module);

				var proj = new ConfuserProject();
				proj.Seed = context.Project.Seed;
				foreach (Rule rule in context.Project.Rules)
					proj.Rules.Add(rule);
				proj.Add(new ProjectModule {Path = fileName});
				proj.BaseDirectory = tmpDir;
				proj.OutputDirectory = outDir;
				foreach (var path in context.Project.ProbePaths)
					proj.ProbePaths.Add(path);
				proj.ProbePaths.Add(context.Project.BaseDirectory);

				PluginDiscovery discovery = null;
				if (prot != null) {
					var rule = new Rule {
						Preset = ProtectionPreset.None,
						Inherit = true,
						Pattern = "true"
					};
					rule.Add(new SettingItem<Protection> {
						Id = prot.Id,
						Action = SettingItemAction.Add
					});
					proj.Rules.Add(rule);
					discovery = new PackerDiscovery(prot);
				}

				try {
					ConfuserEngine
						.Run(
							new ConfuserParameters {
								Logger = new PackerLogger(context.Logger),
								PluginDiscovery = discovery,
								Marker = new PackerMarker(snKey, snPubKey, snDelaySig, snSigKey, snPubSigKey),
								Project = proj,
								PackerInitiated = true
							}, context.token).Wait();
				}
				catch (AggregateException ex) {
					context.Logger.Error("Failed to protect packer stub.");
					throw new ConfuserException(ex);
				}

				context.OutputModules = new[] {File.ReadAllBytes(Path.Combine(outDir, fileName))};
				context.OutputPaths = new[] {fileName};
			}
			finally {
				try {
					if (Directory.Exists(tmpDir)) {
						Directory.Delete(tmpDir, true);
					}
				}
				catch (IOException ex) {
					context.Logger.WarnException("Failed to remove temporary files of packer.", ex);
				}
			}
		}
	}

	internal class PackerLogger : ILogger {
		readonly ILogger baseLogger;

		public PackerLogger(ILogger baseLogger) {
			this.baseLogger = baseLogger;
		}

		public void Debug(string msg) {
			baseLogger.Debug(msg);
		}

		public void DebugFormat(string format, params object[] args) {
			baseLogger.DebugFormat(format, args);
		}

		public void Info(string msg) {
			baseLogger.Info(msg);
		}

		public void InfoFormat(string format, params object[] args) {
			baseLogger.InfoFormat(format, args);
		}

		public void Warn(string msg) {
			baseLogger.Warn(msg);
		}

		public void WarnFormat(string format, params object[] args) {
			baseLogger.WarnFormat(format, args);
		}

		public void WarnException(string msg, Exception ex) {
			baseLogger.WarnException(msg, ex);
		}

		public void Error(string msg) {
			baseLogger.Error(msg);
		}

		public void ErrorFormat(string format, params object[] args) {
			baseLogger.ErrorFormat(format, args);
		}

		public void ErrorException(string msg, Exception ex) {
			baseLogger.ErrorException(msg, ex);
		}

		public void Progress(int progress, int overall) {
			baseLogger.Progress(progress, overall);
		}

		public void EndProgress() {
			baseLogger.EndProgress();
		}

		public void Finish(bool successful) {
			if (!successful)
				throw new ConfuserException(null);
			baseLogger.Info("Finish protecting packer stub.");
		}
	}

	internal class PackerMarker : Marker {
		readonly StrongNameKey snKey;
		readonly StrongNamePublicKey snPubKey;
		readonly bool snDelaySig;
		readonly StrongNameKey snSigKey;
		readonly StrongNamePublicKey snPubSigKey;

		public PackerMarker(StrongNameKey snKey, StrongNamePublicKey snPubKey, bool snDelaySig, StrongNameKey snSigKey, StrongNamePublicKey snPubSigKey) {
			this.snKey = snKey;
			this.snPubKey = snPubKey;
			this.snDelaySig = snDelaySig;
			this.snSigKey = snSigKey;
			this.snPubSigKey = snPubSigKey;
		}

		protected internal override MarkerResult MarkProject(ConfuserProject proj, ConfuserContext context) {
			MarkerResult result = base.MarkProject(proj, context);
			foreach (ModuleDefMD module in result.Modules) {
				context.Annotations.Set(module, SNKey, snKey);
				context.Annotations.Set(module, SNPubKey, snPubKey);
				context.Annotations.Set(module, SNDelaySig, snDelaySig);
				context.Annotations.Set(module, SNSigKey, snSigKey);
				context.Annotations.Set(module, SNSigPubKey, snPubSigKey);
			}
			return result;
		}
	}

	internal class PackerDiscovery : PluginDiscovery {
		readonly Protection prot;

		public PackerDiscovery(Protection prot) {
			this.prot = prot;
		}

		protected override void GetPluginsInternal(ConfuserContext context, IList<Protection> protections, IList<Packer> packers, IList<ConfuserComponent> components) {
			base.GetPluginsInternal(context, protections, packers, components);
			protections.Add(prot);
		}
	}
}

```

`Confuser.Core/PluginDiscovery.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;

namespace Confuser.Core {
	/// <summary>
	///     Discovers available protection plugins.
	/// </summary>
	public class PluginDiscovery {
		/// <summary>
		///     The default plugin discovery service.
		/// </summary>
		internal static readonly PluginDiscovery Instance = new PluginDiscovery();

		/// <summary>
		///     Initializes a new instance of the <see cref="PluginDiscovery" /> class.
		/// </summary>
		protected PluginDiscovery() { }

		/// <summary>
		///     Retrieves the available protection plugins.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="protections">A list of resolved protections.</param>
		/// <param name="packers">A list of resolved packers.</param>
		/// <param name="components">A list of resolved components.</param>
		public void GetPlugins(ConfuserContext context, out IList<Protection> protections, out IList<Packer> packers, out IList<ConfuserComponent> components) {
			protections = new List<Protection>();
			packers = new List<Packer>();
			components = new List<ConfuserComponent>();
			GetPluginsInternal(context, protections, packers, components);
		}

		/// <summary>
		///     Determines whether the specified type has an accessible default constructor.
		/// </summary>
		/// <param name="type">The type.</param>
		/// <returns><c>true</c> if the specified type has an accessible default constructor; otherwise, <c>false</c>.</returns>
		public static bool HasAccessibleDefConstructor(Type type) {
			ConstructorInfo ctor = type.GetConstructor(Type.EmptyTypes);
			if (ctor == null) return false;
			return ctor.IsPublic;
		}

		/// <summary>
		///     Adds plugins in the assembly to the protection list.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="protections">The working list of protections.</param>
		/// <param name="packers">The working list of packers.</param>
		/// <param name="components">The working list of components.</param>
		/// <param name="asm">The assembly.</param>
		protected static void AddPlugins(
			ConfuserContext context, IList<Protection> protections, IList<Packer> packers,
			IList<ConfuserComponent> components, Assembly asm) {
			foreach(var module in asm.GetLoadedModules())
				foreach (var i in module.GetTypes()) {
					if (i.IsAbstract || !HasAccessibleDefConstructor(i))
						continue;

					if (typeof(Protection).IsAssignableFrom(i)) {
						try {
							protections.Add((Protection)Activator.CreateInstance(i));
						}
						catch (Exception ex) {
							context.Logger.ErrorException("Failed to instantiate protection '" + i.Name + "'.", ex);
						}
					}
					else if (typeof(Packer).IsAssignableFrom(i)) {
						try {
							packers.Add((Packer)Activator.CreateInstance(i));
						}
						catch (Exception ex) {
							context.Logger.ErrorException("Failed to instantiate packer '" + i.Name + "'.", ex);
						}
					}
					else if (typeof(ConfuserComponent).IsAssignableFrom(i)) {
						try {
							components.Add((ConfuserComponent)Activator.CreateInstance(i));
						}
						catch (Exception ex) {
							context.Logger.ErrorException("Failed to instantiate component '" + i.Name + "'.", ex);
						}
					}
				}
			context.CheckCancellation();
		}

		/// <summary>
		///     Retrieves the available protection plugins.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="protections">The working list of protections.</param>
		/// <param name="packers">The working list of packers.</param>
		/// <param name="components">The working list of components.</param>
		protected virtual void GetPluginsInternal(
			ConfuserContext context, IList<Protection> protections,
			IList<Packer> packers, IList<ConfuserComponent> components) {
			protections.Add(new WatermarkingProtection());
			try {
				Assembly protAsm = Assembly.Load("Confuser.Protections");
				AddPlugins(context, protections, packers, components, protAsm);
			}
			catch (Exception ex) {
				context.Logger.WarnException("Failed to load built-in protections.", ex);
			}

			try {
				Assembly renameAsm = Assembly.Load("Confuser.Renamer");
				AddPlugins(context, protections, packers, components, renameAsm);
			}
			catch (Exception ex) {
				context.Logger.WarnException("Failed to load renamer.", ex);
			}

			try {
				Assembly renameAsm = Assembly.Load("Confuser.DynCipher");
				AddPlugins(context, protections, packers, components, renameAsm);
			}
			catch (Exception ex) {
				context.Logger.WarnException("Failed to load dynamic cipher library.", ex);
			}

			foreach (string pluginPath in context.Project.PluginPaths) {
				string realPath = Path.Combine(context.BaseDirectory, pluginPath);
				try {
					Assembly plugin = Assembly.LoadFile(realPath);
					AddPlugins(context, protections, packers, components, plugin);
				}
				catch (Exception ex) {
					context.Logger.WarnException("Failed to load plugin '" + pluginPath + "'.", ex);
				}
			}
		}
	}
}

```

`Confuser.Core/Project/ConfuserPrj.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="http://confuser.codeplex.com"
           xmlns="http://confuser.codeplex.com"
           attributeFormDefault="unqualified"
           elementFormDefault="qualified">

  <xs:simpleType name="action">
    <xs:restriction base="xs:string">
      <xs:enumeration value="add" />
      <xs:enumeration value="remove" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="preset">
    <xs:restriction base="xs:string">
      <xs:enumeration value="none" />
      <xs:enumeration value="minimum" />
      <xs:enumeration value="normal" />
      <xs:enumeration value="aggressive" />
      <xs:enumeration value="maximum" />
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="argument">
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="value" type="xs:string" use="required" />
  </xs:complexType>

  <xs:complexType name="objSettings">
    <xs:sequence>
      <xs:element name="argument" type="argument" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="id" type="xs:string" use="required" />
    <xs:attribute name="action" type="action" default="add" />
  </xs:complexType>

  <xs:complexType name="rule">
    <xs:sequence>
      <xs:element name="protection" type="objSettings" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="preset" type="preset" default="none" />

    <xs:attribute name="inherit" type="xs:boolean" default="true" />
    <xs:attribute name="pattern" type="xs:string" use="required" />
  </xs:complexType>

  <xs:complexType name="module">
    <xs:sequence>
      <xs:element name="rule" type="rule" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="path" type="xs:string" use="required" />
    <xs:attribute name="external" type="xs:boolean" default="false" />
    <xs:attribute name="snKey" type="xs:string" use="optional" />
	<xs:attribute name="snPubKey" type="xs:string" use="optional" />
	<xs:attribute name="snSigKey" type="xs:string" use="optional" />
	<xs:attribute name="snPubSigKey" type="xs:string" use="optional" />
    <xs:attribute name="snKeyPass" type="xs:string" use="optional" />
    <xs:attribute name="snSigKeyPass" type="xs:string" use="optional" />
	<xs:attribute name="snDelaySig" type="xs:boolean" default="false" />
  </xs:complexType>


  <xs:element name="project">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="rule" type="rule" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="packer" type="objSettings" minOccurs="0" maxOccurs="1" />
        <xs:element name="module" type="module" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="probePath" type="xs:string" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="plugin" type="xs:string" minOccurs="0" maxOccurs="unbounded" />
      </xs:sequence>
      <xs:attribute name="outputDir" type="xs:string" use="required" />
      <xs:attribute name="baseDir" type="xs:string" use="required" />
      <xs:attribute name="seed" type="xs:string" use="optional" />
      <xs:attribute name="debug" type="xs:boolean" default="false" />
    </xs:complexType>
  </xs:element>
</xs:schema>

```

`Confuser.Core/Project/ConfuserProject.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Schema;
using dnlib.DotNet;

namespace Confuser.Core.Project {
	/// <summary>
	///     A module description in a Confuser project.
	/// </summary>
	public class ProjectModule {
		/// <summary>
		///     Initializes a new instance of the <see cref="ProjectModule" /> class.
		/// </summary>
		public ProjectModule() {
			Rules = new List<Rule>();
		}

		/// <summary>
		///     Gets the path to the module.
		/// </summary>
		public string Path { get; set; }

		/// <summary>
		///     Indicates whether this module is external and should not be obfuscated.
		/// </summary>
		public bool IsExternal { get; set; }

		/// <summary>
		///     Gets or sets the path to the strong name private key for signing.
		/// </summary>
		/// <value>The path to the strong name private key, or null if not necessary.</value>
		/// <remarks>This is also used as the identity key when doing strong name signing.</remarks>
		public string SNKeyPath { get; set; }

		/// <summary>
		///     Gets or sets the password of the strong name private key.
		/// </summary>
		/// <value>The password of the strong name private key, or null if not necessary.</value>
		/// <remarks>This is the password for the key in <see cref="SNKeyPath"/></remarks>
		public string SNKeyPassword { get; set; }

		/// <summary>
		///     Gets or sets if the generated assembly should be delayed signed.
		/// </summary>
		public bool SNDelaySig { get; set; }

		/// <summary>
		///     Gets or sets the path to the strong name public key for signing.
		/// </summary>
		/// <value>The path to the strong name public key, or null if not necessary.</value>
		/// <remarks>
		/// This is only used in enhanced strong name signing and is the public part of the identity key.
		/// The private part of the key 
		/// </remarks>
		public string SNPubKeyPath { get; set; }

		/// <summary>
		///     Gets or sets the path to the strong name private key used for enhanced signing.
		/// </summary>
		/// <value>The path to the strong name private key used for enhanced signing, or null if not necessary.</value>
		public string SNSigKeyPath { get; set; }

		/// <summary>
		///     Gets or sets the password of the strong name private key.
		/// </summary>
		/// <value>The password of the strong name private key, or null if not necessary.</value>
		public string SNSigKeyPassword { get; set; }

		/// <summary>
		///     Gets or sets the path to the strong name public key used for enhanced signing.
		/// </summary>
		/// <value>The path to the strong name public key used for enhanced signing, or null if not necessary.</value>
		public string SNPubSigKeyPath { get; set; }

		/// <summary>
		///     Gets a list of protection rules applies to the module.
		/// </summary>
		/// <value>A list of protection rules.</value>
		public IList<Rule> Rules { get; private set; }

		/// <summary>
		///     Resolves the module from the path.
		/// </summary>
		/// <param name="basePath">
		///     The base path for the relative module path,
		///     or null if the module path is absolute or relative to current directory.
		/// </param>
		/// <param name="context">The resolved module's context.</param>
		/// <returns>The resolved module.</returns>
		public ModuleDefMD Resolve(string basePath, ModuleContext context = null) {
			if (basePath == null)
				return ModuleDefMD.Load(Path, context);
			return ModuleDefMD.Load(System.IO.Path.Combine(basePath, Path), context);
		}

		/// <summary>
		///     Read the raw bytes of the module from the path.
		/// </summary>
		/// <param name="basePath">
		///     The base path for the relative module path,
		///     or null if the module path is absolute or relative to current directory.
		/// </param>
		/// <returns>The loaded module.</returns>
		public byte[] LoadRaw(string basePath) {
			if (basePath == null)
				return File.ReadAllBytes(Path);
			return File.ReadAllBytes(System.IO.Path.Combine(basePath, Path));
		}

		/// <summary>
		///     Saves the module description as XML element.
		/// </summary>
		/// <param name="xmlDoc">The root XML document.</param>
		/// <returns>The serialized module description.</returns>
		internal XmlElement Save(XmlDocument xmlDoc) {
			XmlElement elem = xmlDoc.CreateElement("module", ConfuserProject.Namespace);

			XmlAttribute nameAttr = xmlDoc.CreateAttribute("path");
			nameAttr.Value = Path;
			elem.Attributes.Append(nameAttr);

			if (IsExternal) {
				XmlAttribute extAttr = xmlDoc.CreateAttribute("external");
				extAttr.Value = IsExternal ? "true" : "false";
				elem.Attributes.Append(extAttr);
			}
			if (SNKeyPath != null) {
				XmlAttribute snKeyAttr = xmlDoc.CreateAttribute("snKey");
				snKeyAttr.Value = SNKeyPath;
				elem.Attributes.Append(snKeyAttr);
			}
			if (SNKeyPassword != null) {
				XmlAttribute snKeyPassAttr = xmlDoc.CreateAttribute("snKeyPass");
				snKeyPassAttr.Value = SNKeyPassword;
				elem.Attributes.Append(snKeyPassAttr);
			}
			if (SNDelaySig) {
				XmlAttribute snKeyAttr = xmlDoc.CreateAttribute("snDelaySig");
				snKeyAttr.Value = SNDelaySig ? "true" : "false";
				elem.Attributes.Append(snKeyAttr);
			}
			if (SNPubKeyPath != null) {
				XmlAttribute snKeyAttr = xmlDoc.CreateAttribute("snPubKey");
				snKeyAttr.Value = SNPubKeyPath;
				elem.Attributes.Append(snKeyAttr);
			}
			if (SNSigKeyPath != null) {
				XmlAttribute snKeyAttr = xmlDoc.CreateAttribute("snSigKey");
				snKeyAttr.Value = SNSigKeyPath;
				elem.Attributes.Append(snKeyAttr);
			}
			if (SNSigKeyPassword != null) {
				XmlAttribute snKeyPassAttr = xmlDoc.CreateAttribute("snSigKeyPass");
				snKeyPassAttr.Value = SNSigKeyPassword;
				elem.Attributes.Append(snKeyPassAttr);
			}
			if (SNPubSigKeyPath != null) {
				XmlAttribute snKeyAttr = xmlDoc.CreateAttribute("snPubSigKey");
				snKeyAttr.Value = SNPubSigKeyPath;
				elem.Attributes.Append(snKeyAttr);
			}

			foreach (Rule i in Rules)
				elem.AppendChild(i.Save(xmlDoc));

			return elem;
		}

		/// <summary>
		///     Loads the module description from XML element.
		/// </summary>
		/// <param name="elem">The serialized module description.</param>
		internal void Load(XmlElement elem) {
			Path = elem.Attributes["path"].Value;

			if (elem.Attributes["external"] != null)
				IsExternal = bool.Parse(elem.Attributes["external"].Value);
			else
				IsExternal = false;

			if (elem.Attributes["snKey"] != null)
				SNKeyPath = elem.Attributes["snKey"].Value.NullIfEmpty();
			else
				SNKeyPath = null;

			if (elem.Attributes["snKeyPass"] != null)
				SNKeyPassword = elem.Attributes["snKeyPass"].Value.NullIfEmpty();
			else
				SNKeyPassword = null;

			bool delaySig = false;

			if (elem.Attributes["snDelaySig"] != null)
				bool.TryParse(elem.Attributes["snDelaySig"].Value, out delaySig);

			SNDelaySig = delaySig;

			if (elem.Attributes["snPubKey"] != null)
				SNPubKeyPath = elem.Attributes["snPubKey"].Value.NullIfEmpty();
			else
				SNPubKeyPath = null;

			if (elem.Attributes["snSigKey"] != null)
				SNSigKeyPath = elem.Attributes["snSigKey"].Value.NullIfEmpty();
			else
				SNSigKeyPath = null;

			if (elem.Attributes["snSigKeyPass"] != null)
				SNSigKeyPassword = elem.Attributes["snSigKeyPass"].Value.NullIfEmpty();
			else
				SNSigKeyPassword = null;

			if (elem.Attributes["snPubSigKey"] != null)
				SNPubSigKeyPath = elem.Attributes["snPubSigKey"].Value.NullIfEmpty();
			else
				SNPubSigKeyPath = null;
			
			Rules.Clear();
			foreach (XmlElement i in elem.ChildNodes.OfType<XmlElement>()) {
				var rule = new Rule();
				rule.Load(i);
				Rules.Add(rule);
			}
		}

		/// <summary>
		///     Returns a <see cref="string" /> that represents this instance.
		/// </summary>
		/// <returns>A <see cref="string" /> that represents this instance.</returns>
		public override string ToString() {
			return Path;
		}

		/// <summary>
		///     Clones this instance.
		/// </summary>
		/// <returns>A duplicated module.</returns>
		public ProjectModule Clone() {
			var ret = new ProjectModule();
			ret.Path = Path;
			ret.IsExternal = IsExternal;
			ret.SNKeyPath = SNKeyPath;
			ret.SNPubKeyPath = SNPubKeyPath;
			ret.SNDelaySig = SNDelaySig;
			ret.SNPubSigKeyPath = SNPubSigKeyPath;
			ret.SNSigKeyPath = SNSigKeyPath;
			ret.SNKeyPassword = SNKeyPassword;
			ret.SNSigKeyPassword = SNSigKeyPassword;
			foreach (var r in Rules)
				ret.Rules.Add(r.Clone());
			return ret;
		}
	}

	/// <summary>
	///     Indicates add or remove the protection from the active protections
	/// </summary>
	public enum SettingItemAction {
		/// <summary>
		///     Add the protection to the active protections
		/// </summary>
		Add,

		/// <summary>
		///     Remove the protection from the active protections
		/// </summary>
		Remove
	}

	/// <summary>
	///     A <see cref="ConfuserComponent" /> setting within a rule.
	/// </summary>
	/// <typeparam name="T"><see cref="Protection" /> or <see cref="Packer" /></typeparam>
	public class SettingItem<T> : Dictionary<string, string> {
		/// <summary>
		/// Initialize this setting item instance
		/// </summary>
		/// <param name="id">The protection id</param>
		/// <param name="action">The action to take</param>
		public SettingItem(string id = null, SettingItemAction action = SettingItemAction.Add) {
			Id = id;
			Action = action;
		}

		/// <summary>
		///     The identifier of component
		/// </summary>
		/// <value>The identifier of component.</value>
		/// <seealso cref="ConfuserComponent.Id" />
		public string Id { get; set; }

		/// <summary>
		///     Gets or sets the action of component.
		/// </summary>
		/// <value>The action of component.</value>
		public SettingItemAction Action { get; set; }

		/// <summary>
		///     Saves the setting description as XML element.
		/// </summary>
		/// <param name="xmlDoc">The root XML document.</param>
		/// <returns>The setting module description.</returns>
		internal XmlElement Save(XmlDocument xmlDoc) {
			XmlElement elem = xmlDoc.CreateElement(typeof(T) == typeof(Packer) ? "packer" : "protection", ConfuserProject.Namespace);

			XmlAttribute idAttr = xmlDoc.CreateAttribute("id");
			idAttr.Value = Id;
			elem.Attributes.Append(idAttr);

			if (Action != SettingItemAction.Add) {
				XmlAttribute pAttr = xmlDoc.CreateAttribute("action");
				pAttr.Value = Action.ToString().ToLower();
				elem.Attributes.Append(pAttr);
			}

			foreach (var i in this) {
				XmlElement arg = xmlDoc.CreateElement("argument", ConfuserProject.Namespace);

				XmlAttribute nameAttr = xmlDoc.CreateAttribute("name");
				nameAttr.Value = i.Key;
				arg.Attributes.Append(nameAttr);
				XmlAttribute valAttr = xmlDoc.CreateAttribute("value");
				valAttr.Value = i.Value;
				arg.Attributes.Append(valAttr);

				elem.AppendChild(arg);
			}

			return elem;
		}

		/// <summary>
		///     Loads the setting description from XML element.
		/// </summary>
		/// <param name="elem">The serialized setting description.</param>
		internal void Load(XmlElement elem) {
			Id = elem.Attributes["id"].Value;

			if (elem.Attributes["action"] != null)
				Action = (SettingItemAction)Enum.Parse(typeof(SettingItemAction), elem.Attributes["action"].Value, true);
			else
				Action = SettingItemAction.Add;

			Clear();
			foreach (XmlElement i in elem.ChildNodes.OfType<XmlElement>())
				Add(i.Attributes["name"].Value, i.Attributes["value"].Value);
		}

		/// <summary>
		///     Clones this instance.
		/// </summary>
		/// <returns>A duplicated setting item.</returns>
		public SettingItem<T> Clone() {
			var item = new SettingItem<T>(Id, Action);
			foreach (var entry in this)
				item.Add(entry.Key, entry.Value);
			return item;
		}
	}


	/// <summary>
	///     A rule that control how <see cref="Protection" />s are applied to module
	/// </summary>
	public class Rule : List<SettingItem<Protection>> {
		/// <summary>
		/// Initialize this rule instance
		/// </summary>
		/// <param name="pattern">The pattern</param>
		/// <param name="preset">The preset</param>
		/// <param name="inherit">Inherits protection</param>
		public Rule(string pattern = "true", ProtectionPreset preset = ProtectionPreset.None, bool inherit = false) {
			Pattern = pattern;
			Preset = preset;
			Inherit = inherit;
		}

		/// <summary>
		///     Gets or sets the pattern that determine the target components of the rule.
		/// </summary>
		/// <value>The pattern expression.</value>
		public string Pattern { get; set; }

		/// <summary>
		///     Gets or sets the protection preset this rule uses.
		/// </summary>
		/// <value>The protection preset.</value>
		public ProtectionPreset Preset { get; set; }

		/// <summary>
		///     Gets or sets a value indicating whether this <see cref="Rule" /> inherits settings from earlier rules.
		/// </summary>
		/// <value><c>true</c> if it inherits settings; otherwise, <c>false</c>.</value>
		public bool Inherit { get; set; }

		/// <summary>
		///     Saves the rule description as XML element.
		/// </summary>
		/// <param name="xmlDoc">The root XML document.</param>
		/// <returns>The serialized rule description.</returns>
		internal XmlElement Save(XmlDocument xmlDoc) {
			XmlElement elem = xmlDoc.CreateElement("rule", ConfuserProject.Namespace);

			XmlAttribute ruleAttr = xmlDoc.CreateAttribute("pattern");
			ruleAttr.Value = Pattern;
			elem.Attributes.Append(ruleAttr);

			if (Preset != ProtectionPreset.None) {
				XmlAttribute pAttr = xmlDoc.CreateAttribute("preset");
				pAttr.Value = Preset.ToString().ToLower();
				elem.Attributes.Append(pAttr);
			}

			if (Inherit != true) {
				XmlAttribute attr = xmlDoc.CreateAttribute("inherit");
				attr.Value = Inherit.ToString().ToLower();
				elem.Attributes.Append(attr);
			}

			foreach (var i in this)
				elem.AppendChild(i.Save(xmlDoc));

			return elem;
		}

		/// <summary>
		///     Loads the rule description from XML element.
		/// </summary>
		/// <param name="elem">The serialized module description.</param>
		internal void Load(XmlElement elem) {
			Pattern = elem.Attributes["pattern"].Value;

			if (elem.Attributes["preset"] != null)
				Preset = (ProtectionPreset)Enum.Parse(typeof(ProtectionPreset), elem.Attributes["preset"].Value, true);
			else
				Preset = ProtectionPreset.None;

			if (elem.Attributes["inherit"] != null)
				Inherit = bool.Parse(elem.Attributes["inherit"].Value);
			else
				Inherit = true;

			Clear();
			foreach (XmlElement i in elem.ChildNodes.OfType<XmlElement>()) {
				var x = new SettingItem<Protection>();
				x.Load(i);
				Add(x);
			}
		}


		/// <summary>
		///     Clones this instance.
		/// </summary>
		/// <returns>A duplicated rule.</returns>
		public Rule Clone() {
			var ret = new Rule();
			ret.Preset = Preset;
			ret.Pattern = Pattern;
			ret.Inherit = Inherit;
			foreach (var i in this) {
				var item = new SettingItem<Protection>();
				item.Id = i.Id;
				item.Action = i.Action;
				foreach (string j in i.Keys)
					item.Add(j, i[j]);
				ret.Add(item);
			}
			return ret;
		}
	}

	/// <summary>
	///     The exception that is thrown when there exists schema errors in the project XML.
	/// </summary>
	public class ProjectValidationException : Exception {
		/// <summary>
		///     Initializes a new instance of the <see cref="ProjectValidationException" /> class.
		/// </summary>
		/// <param name="exceptions">The list of schema exceptions.</param>
		internal ProjectValidationException(List<XmlSchemaException> exceptions)
			: base(exceptions[0].Message) {
			Errors = exceptions;
		}

		/// <summary>
		///     Gets the schema exceptions.
		/// </summary>
		/// <value>A list of schema exceptions.</value>
		public IList<XmlSchemaException> Errors { get; private set; }
	}

	/// <summary>
	///     Represent a project of Confuser.
	/// </summary>
	public class ConfuserProject : List<ProjectModule> {
		/// <summary>
		///     The namespace of Confuser project schema
		/// </summary>
		public const string Namespace = "http://confuser.codeplex.com";

		/// <summary>
		///     The schema of project XML.
		/// </summary>
		public static readonly XmlSchema Schema = XmlSchema.Read(typeof(ConfuserProject).Assembly.GetManifestResourceStream("Confuser.Core.Project.ConfuserPrj.xsd"), null);

		/// <summary>
		///     Initializes a new instance of the <see cref="ConfuserProject" /> class.
		/// </summary>
		public ConfuserProject() {
			ProbePaths = new List<string>();
			PluginPaths = new List<string>();
			Rules = new List<Rule>();
		}

		/// <summary>
		///     Gets or sets the seed of pseudo-random generator used in process of protection.
		/// </summary>
		/// <value>The random seed.</value>
		public string Seed { get; set; }

		/// <summary>
		///     Gets or sets a value indicating whether debug symbols are generated.
		/// </summary>
		/// <value><c>true</c> if debug symbols are generated; otherwise, <c>false</c>.</value>
		public bool Debug { get; set; }

		/// <summary>
		///     Gets or sets the output directory.
		/// </summary>
		/// <value>The output directory.</value>
		public string OutputDirectory { get; set; }

		/// <summary>
		///     Gets or sets the base directory of the project.
		/// </summary>
		/// <value>The base directory.</value>
		public string BaseDirectory { get; set; }

		/// <summary>
		///     Gets a list of protection rules that applies globally.
		/// </summary>
		/// <value>A list of protection rules.</value>
		public IList<Rule> Rules { get; private set; }

		/// <summary>
		///     Gets or sets the packer used to pack up the output.
		/// </summary>
		/// <value>The packer.</value>
		public SettingItem<Packer> Packer { get; set; }

		/// <summary>
		///     Gets a list of paths that used to resolve assemblies.
		/// </summary>
		/// <value>The list of paths.</value>
		public IList<string> ProbePaths { get; private set; }

		/// <summary>
		///     Gets a list of paths to plugin.
		/// </summary>
		/// <value>The list of plugins.</value>
		public IList<string> PluginPaths { get; private set; }

		/// <summary>
		///     Saves the project as XML document.
		/// </summary>
		/// <returns>The serialized project XML.</returns>
		public XmlDocument Save() {
			var xmlDoc = new XmlDocument();
			xmlDoc.Schemas.Add(Schema);

			XmlElement elem = xmlDoc.CreateElement("project", Namespace);

			XmlAttribute outputAttr = xmlDoc.CreateAttribute("outputDir");
			outputAttr.Value = OutputDirectory;
			elem.Attributes.Append(outputAttr);

			XmlAttribute baseAttr = xmlDoc.CreateAttribute("baseDir");
			baseAttr.Value = BaseDirectory;
			elem.Attributes.Append(baseAttr);

			if (Seed != null) {
				XmlAttribute seedAttr = xmlDoc.CreateAttribute("seed");
				seedAttr.Value = Seed;
				elem.Attributes.Append(seedAttr);
			}

			if (Debug) {
				XmlAttribute debugAttr = xmlDoc.CreateAttribute("debug");
				debugAttr.Value = Debug.ToString().ToLower();
				elem.Attributes.Append(debugAttr);
			}

			foreach (Rule i in Rules)
				elem.AppendChild(i.Save(xmlDoc));

			if (Packer != null)
				elem.AppendChild(Packer.Save(xmlDoc));

			foreach (ProjectModule i in this)
				elem.AppendChild(i.Save(xmlDoc));

			foreach (string i in ProbePaths) {
				XmlElement path = xmlDoc.CreateElement("probePath", Namespace);
				path.InnerText = i;
				elem.AppendChild(path);
			}

			foreach (string i in PluginPaths) {
				XmlElement path = xmlDoc.CreateElement("plugin", Namespace);
				path.InnerText = i;
				elem.AppendChild(path);
			}

			xmlDoc.AppendChild(elem);
			return xmlDoc;
		}

		/// <summary>
		///     Loads the project from specified XML document.
		/// </summary>
		/// <param name="doc">The XML document storing the project.</param>
		/// <exception cref="Confuser.Core.Project.ProjectValidationException">
		///     The project XML contains schema errors.
		/// </exception>
		public void Load(XmlDocument doc) {
			doc.Schemas.Add(Schema);
			var exceptions = new List<XmlSchemaException>();
			doc.Validate((sender, e) => {
				if (e.Severity != XmlSeverityType.Error) return;
				exceptions.Add(e.Exception);
			});
			if (exceptions.Count > 0) {
				throw new ProjectValidationException(exceptions);
			}

			XmlElement docElem = doc.DocumentElement;

			OutputDirectory = docElem.Attributes["outputDir"].Value;
			BaseDirectory = docElem.Attributes["baseDir"].Value;

			if (docElem.Attributes["seed"] != null)
				Seed = docElem.Attributes["seed"].Value.NullIfEmpty();
			else
				Seed = null;

			if (docElem.Attributes["debug"] != null)
				Debug = bool.Parse(docElem.Attributes["debug"].Value);
			else
				Debug = false;

			Packer = null;
			Clear();
			ProbePaths.Clear();
			PluginPaths.Clear();
			Rules.Clear();
			foreach (XmlElement i in docElem.ChildNodes.OfType<XmlElement>()) {
				if (i.Name == "rule") {
					var rule = new Rule();
					rule.Load(i);
					Rules.Add(rule);
				}
				else if (i.Name == "packer") {
					Packer = new SettingItem<Packer>();
					Packer.Load(i);
				}
				else if (i.Name == "probePath") {
					ProbePaths.Add(i.InnerText);
				}
				else if (i.Name == "plugin") {
					PluginPaths.Add(i.InnerText);
				}
				else {
					var asm = new ProjectModule();
					asm.Load(i);
					Add(asm);
				}
			}
		}

		/// <summary>
		///     Clones this instance.
		/// </summary>
		/// <returns>A duplicated project.</returns>
		public ConfuserProject Clone() {
			var ret = new ConfuserProject();
			ret.Seed = Seed;
			ret.Debug = Debug;
			ret.OutputDirectory = OutputDirectory;
			ret.BaseDirectory = BaseDirectory;
			ret.Packer = Packer == null ? null : Packer.Clone();
			ret.ProbePaths = new List<string>(ProbePaths);
			ret.PluginPaths = new List<string>(PluginPaths);
			foreach (var module in this)
				ret.Add(module.Clone());
			foreach (var r in Rules)
				ret.Rules.Add(r);
			return ret;
		}
	}
}

```

`Confuser.Core/Project/InvalidPatternException.cs`:

```cs
using System;

namespace Confuser.Core.Project {
	/// <summary>
	///     The exception that is thrown when attempted to parse an invalid pattern.
	/// </summary>
	public class InvalidPatternException : Exception {
		/// <summary>
		///     Initializes a new instance of the <see cref="ConfuserException" /> class.
		/// </summary>
		/// <param name="message">The message that describes the error.</param>
		public InvalidPatternException(string message)
			: base(message) { }

		/// <summary>
		///     Initializes a new instance of the <see cref="ConfuserException" /> class.
		/// </summary>
		/// <param name="message">The error message that explains the reason for the exception.</param>
		/// <param name="innerException">
		///     The exception that is the cause of the current exception, or a null reference (Nothing in
		///     Visual Basic) if no inner exception is specified.
		/// </param>
		public InvalidPatternException(string message, Exception innerException)
			: base(message, innerException) { }
	}
}
```

`Confuser.Core/Project/PatternParser.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core.Project.Patterns;

namespace Confuser.Core.Project {
	/// <summary>
	///     Parser of pattern expressions.
	/// </summary>
	public class PatternParser {
		static readonly Dictionary<string, Func<PatternFunction>> fns;
		static readonly Dictionary<string, Func<PatternOperator>> ops;
		readonly PatternTokenizer tokenizer = new PatternTokenizer();
		PatternToken? lookAhead;

		static PatternParser() {
			fns = new Dictionary<string, Func<PatternFunction>>(StringComparer.OrdinalIgnoreCase);
			fns.Add(ModuleFunction.FnName, () => new ModuleFunction());
			fns.Add(DeclTypeFunction.FnName, () => new DeclTypeFunction());
			fns.Add(NamespaceFunction.FnName, () => new NamespaceFunction());
			fns.Add(NameFunction.FnName, () => new NameFunction());
			fns.Add(FullNameFunction.FnName, () => new FullNameFunction());
			fns.Add(MatchFunction.FnName, () => new MatchFunction());
			fns.Add(MatchNameFunction.FnName, () => new MatchNameFunction());
			fns.Add(MatchTypeNameFunction.FnName, () => new MatchTypeNameFunction());
			fns.Add(MemberTypeFunction.FnName, () => new MemberTypeFunction());
			fns.Add(IsPublicFunction.FnName, () => new IsPublicFunction());
			fns.Add(InheritsFunction.FnName, () => new InheritsFunction());
			fns.Add(IsTypeFunction.FnName, () => new IsTypeFunction());
			fns.Add(HasAttrFunction.FnName, () => new HasAttrFunction());

			ops = new Dictionary<string, Func<PatternOperator>>(StringComparer.OrdinalIgnoreCase);
			ops.Add(AndOperator.OpName, () => new AndOperator());
			ops.Add(OrOperator.OpName, () => new OrOperator());
			ops.Add(NotOperator.OpName, () => new NotOperator());
		}

		/// <summary>
		///     Parses the specified pattern into expression.
		/// </summary>
		/// <param name="pattern">The pattern to parse.</param>
		/// <returns>The parsed expression.</returns>
		/// <exception cref="InvalidPatternException">
		///     The pattern is invalid.
		/// </exception>
		public PatternExpression Parse(string pattern) {
			if (pattern == null)
				throw new ArgumentNullException("pattern");

			try {
				tokenizer.Initialize(pattern);
				lookAhead = tokenizer.NextToken();
				PatternExpression ret = ParseExpression(true);
				if (PeekToken() != null)
					throw new InvalidPatternException("Extra tokens beyond the end of pattern.");
				return ret;
			}
			catch (Exception ex) {
				if (ex is InvalidPatternException)
					throw;
				throw new InvalidPatternException("Invalid pattern.", ex);
			}
		}

		static bool IsFunction(PatternToken token) {
			if (token.Type != TokenType.Identifier)
				return false;
			return fns.ContainsKey(token.Value);
		}

		static bool IsOperator(PatternToken token) {
			if (token.Type != TokenType.Identifier)
				return false;
			return ops.ContainsKey(token.Value);
		}

		Exception UnexpectedEnd() {
			throw new InvalidPatternException("Unexpected end of pattern.");
		}

		Exception MismatchParens(int position) {
			throw new InvalidPatternException(string.Format("Mismatched parentheses at position {0}.", position));
		}

		Exception UnknownToken(PatternToken token) {
			throw new InvalidPatternException(string.Format("Unknown token '{0}' at position {1}.", token.Value, token.Position));
		}

		Exception UnexpectedToken(PatternToken token) {
			throw new InvalidPatternException(string.Format("Unexpected token '{0}' at position {1}.", token.Value, token.Position));
		}

		Exception UnexpectedToken(PatternToken token, char expect) {
			throw new InvalidPatternException(string.Format("Unexpected token '{0}' at position {1}. Expected '{2}'.", token.Value, token.Position, expect));
		}

		Exception BadArgCount(PatternToken token, int expected) {
			throw new InvalidPatternException(string.Format("Invalid argument count for '{0}' at position {1}. Expected {2}", token.Value, token.Position, expected));
		}

		PatternToken ReadToken() {
			if (lookAhead == null)
				throw UnexpectedEnd();
			PatternToken ret = lookAhead.Value;
			lookAhead = tokenizer.NextToken();
			return ret;
		}

		PatternToken? PeekToken() {
			return lookAhead;
		}

		PatternExpression ParseExpression(bool readBinOp = false) {
			PatternExpression ret;
			PatternToken token = ReadToken();
			switch (token.Type) {
				case TokenType.Literal:
					ret = new LiteralExpression(token.Value);
					break;
				case TokenType.LParens: {
					ret = ParseExpression(true);
					PatternToken parens = ReadToken();
					if (parens.Type != TokenType.RParens)
						throw MismatchParens(token.Position.Value);
				}
					break;
				case TokenType.Identifier:
					if (IsOperator(token)) {
						// unary operator
						PatternOperator op = ops[token.Value]();
						if (!op.IsUnary)
							throw UnexpectedToken(token);
						op.OperandA = ParseExpression();
						ret = op;
					}
					else if (IsFunction(token)) {
						// function
						PatternFunction fn = fns[token.Value]();

						PatternToken parens = ReadToken();
						if (parens.Type != TokenType.LParens)
							throw UnexpectedToken(parens, '(');

						fn.Arguments = new List<PatternExpression>(fn.ArgumentCount);
						for (int i = 0; i < fn.ArgumentCount; i++) {
							if (PeekToken() == null)
								throw UnexpectedEnd();
							if (PeekToken().Value.Type == TokenType.RParens)
								throw BadArgCount(token, fn.ArgumentCount);
							if (i != 0) {
								PatternToken comma = ReadToken();
								if (comma.Type != TokenType.Comma)
									throw UnexpectedToken(comma, ',');
							}
							fn.Arguments.Add(ParseExpression());
						}

						parens = ReadToken();
						if (parens.Type == TokenType.Comma)
							throw BadArgCount(token, fn.ArgumentCount);
						if (parens.Type != TokenType.RParens)
							throw MismatchParens(parens.Position.Value);

						ret = fn;
					}
					else {
						bool boolValue;
						if (bool.TryParse(token.Value, out boolValue))
							ret = new LiteralExpression(boolValue);
						else
							throw UnknownToken(token);
					}

					break;
				default:
					throw UnexpectedToken(token);
			}

			if (!readBinOp)
				return ret;

			// binary operator
			PatternToken? peek = PeekToken();
			while (peek != null) {
				if (peek.Value.Type != TokenType.Identifier)
					break;
				if (!IsOperator(peek.Value))
					break;

				PatternToken binOpToken = ReadToken();
				PatternOperator binOp = ops[binOpToken.Value]();
				if (binOp.IsUnary)
					throw UnexpectedToken(binOpToken);
				binOp.OperandA = ret;
				binOp.OperandB = ParseExpression();
				ret = binOp;

				peek = PeekToken();
			}

			return ret;
		}
	}
}
```

`Confuser.Core/Project/PatternToken.cs`:

```cs
using System;

namespace Confuser.Core.Project {
	/// <summary>
	///     The type of pattern tokens
	/// </summary>
	public enum TokenType {
		/// <summary>
		///     An identifier, could be functions/operators.
		/// </summary>
		Identifier,

		/// <summary>
		///     A string literal.
		/// </summary>
		Literal,

		/// <summary>
		///     A left parenthesis.
		/// </summary>
		LParens,

		/// <summary>
		///     A right parenthesis.
		/// </summary>
		RParens,

		/// <summary>
		///     A comma.
		/// </summary>
		Comma
	}


	/// <summary>
	///     Represent a token in pattern
	/// </summary>
	public struct PatternToken {
		/// <summary>
		///     The position of this token in the pattern, or null if position not available.
		/// </summary>
		public readonly int? Position;

		/// <summary>
		///     The type of this token.
		/// </summary>
		public readonly TokenType Type;

		/// <summary>
		///     The value of this token, applicable to identifiers and literals.
		/// </summary>
		public readonly string Value;

		/// <summary>
		///     Initializes a new instance of the <see cref="PatternToken" /> struct.
		/// </summary>
		/// <param name="pos">The position of token.</param>
		/// <param name="type">The type of token.</param>
		public PatternToken(int pos, TokenType type) {
			Position = pos;
			Type = type;
			Value = null;
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="PatternToken" /> struct.
		/// </summary>
		/// <param name="pos">The position of token.</param>
		/// <param name="type">The type of token.</param>
		/// <param name="value">The value of token.</param>
		public PatternToken(int pos, TokenType type, string value) {
			Position = pos;
			Type = type;
			Value = value;
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="PatternToken" /> struct.
		/// </summary>
		/// <param name="type">The type of token.</param>
		public PatternToken(TokenType type) {
			Position = null;
			Type = type;
			Value = null;
		}

		/// <summary>
		///     Initializes a new instance of the <see cref="PatternToken" /> struct.
		/// </summary>
		/// <param name="type">The type of token.</param>
		/// <param name="value">The value of token.</param>
		public PatternToken(TokenType type, string value) {
			Position = null;
			Type = type;
			Value = value;
		}

		/// <inheritdoc />
		public override string ToString() {
			if (Position != null) {
				if (Value != null)
					return string.Format("[{0}] {1} @ {2}", Type, Value, Position);
				return string.Format("[{0}] @ {1}", Type, Position);
			}
			if (Value != null)
				return string.Format("[{0}] {1}", Type, Value);
			return string.Format("[{0}]", Type);
		}
	}
}
```

`Confuser.Core/Project/PatternTokenizer.cs`:

```cs
using System;
using System.Diagnostics;
using System.Text;

namespace Confuser.Core.Project {
	internal class PatternTokenizer {
		int index;
		string rulePattern;

		public void Initialize(string pattern) {
			rulePattern = pattern;
			index = 0;
		}

		void SkipWhitespace() {
			while (index < rulePattern.Length && char.IsWhiteSpace(rulePattern[index]))
				index++;
		}

		char? PeekChar() {
			if (index >= rulePattern.Length)
				return null;
			return rulePattern[index];
		}

		char NextChar() {
			if (index >= rulePattern.Length)
				throw new InvalidPatternException("Unexpected end of pattern.");
			return rulePattern[index++];
		}

		string ReadLiteral() {
			var ret = new StringBuilder();
			char delim = NextChar();
			Debug.Assert(delim == '"' || delim == '\'');

			char chr = NextChar();
			while (chr != delim) {
				// Escape sequence
				if (chr == '\\')
					ret.Append(NextChar());
				else
					ret.Append(chr);
				chr = NextChar();
			}
			return ret.ToString();
		}

		string ReadIdentifier() {
			var ret = new StringBuilder();

			char? chr = PeekChar();
			while (chr != null && (char.IsLetterOrDigit(chr.Value) || chr == '_' || chr == '-')) {
				ret.Append(NextChar());
				chr = PeekChar();
			}

			return ret.ToString();
		}

		public PatternToken? NextToken() {
			if (rulePattern == null)
				throw new InvalidOperationException("Tokenizer not initialized.");

			SkipWhitespace();
			char? tokenBegin = PeekChar();
			if (tokenBegin == null)
				return null;

			int pos = index;
			switch (tokenBegin.Value) {
				case ',':
					index++;
					return new PatternToken(pos, TokenType.Comma);
				case '(':
					index++;
					return new PatternToken(pos, TokenType.LParens);
				case ')':
					index++;
					return new PatternToken(pos, TokenType.RParens);

				case '"':
				case '\'':
					return new PatternToken(pos, TokenType.Literal, ReadLiteral());

				default:
					if (!char.IsLetter(tokenBegin.Value))
						throw new InvalidPatternException(string.Format("Unknown token '{0}' at position {1}.", tokenBegin, pos));

					return new PatternToken(pos, TokenType.Identifier, ReadIdentifier());
			}
		}
	}
}
```

`Confuser.Core/Project/Patterns/AndOperator.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     The AND operator.
	/// </summary>
	public class AndOperator : PatternOperator {
		internal const string OpName = "and";

		/// <inheritdoc />
		public override string Name {
			get { return OpName; }
		}

		/// <inheritdoc />
		public override bool IsUnary {
			get { return false; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			var a = (bool)OperandA.Evaluate(definition);
			if (!a) return false;
			return (bool)OperandB.Evaluate(definition);
		}
	}
}
```

`Confuser.Core/Project/Patterns/DeclTypeFunction.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the full name of declaring type.
	/// </summary>
	public class DeclTypeFunction : PatternFunction {
		internal const string FnName = "decl-type";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			if (!(definition is IMemberDef) || ((IMemberDef)definition).DeclaringType == null)
				return false;
			object fullName = Arguments[0].Evaluate(definition);
			return ((IMemberDef)definition).DeclaringType.FullName == fullName.ToString();
		}
	}
}
```

`Confuser.Core/Project/Patterns/FullNameFunction.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the full name of definition.
	/// </summary>
	public class FullNameFunction : PatternFunction {
		internal const string FnName = "full-name";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			object name = Arguments[0].Evaluate(definition);
			return definition.FullName == name.ToString();
		}
	}
}
```

`Confuser.Core/Project/Patterns/HasAttrFunction.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that indicate whether the item has the given custom attribute.
	/// </summary>
	public class HasAttrFunction : PatternFunction {
		internal const string FnName = "has-attr";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string attrName = Arguments[0].Evaluate(definition).ToString();
			return definition.CustomAttributes.IsDefined(attrName);
		}
	}
}
```

`Confuser.Core/Project/Patterns/InheritsFunction.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that indicate whether the type inherits from the specified type.
	/// </summary>
	public class InheritsFunction : PatternFunction {
		internal const string FnName = "inherits";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string name = Arguments[0].Evaluate(definition).ToString();

			var type = definition as TypeDef;
			if (type == null && definition is IMemberDef)
				type = ((IMemberDef)definition).DeclaringType;
			if (type == null)
				return false;

			if (type.InheritsFrom(name) || type.Implements(name))
				return true;

			return false;
		}
	}
}
```

`Confuser.Core/Project/Patterns/IsPublicFunction.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that indicate the visibility of members.
	/// </summary>
	public class IsPublicFunction : PatternFunction {
		internal const string FnName = "is-public";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 0; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			var member = definition as IMemberDef;
			if (member == null)
				return false;

			var declType = ((IMemberDef)definition).DeclaringType;
			while (declType != null) {
				if (!declType.IsPublic)
					return false;
				declType = declType.DeclaringType;
			}

			if (member is MethodDef)
				return ((MethodDef)member).IsVisibleOutside();
			if (member is FieldDef)
				return ((FieldDef)member).IsVisibleOutside();
			if (member is PropertyDef)
				return ((PropertyDef)member).IsVisibleOutside();
			if (member is EventDef)
				return ((EventDef)member).IsVisibleOutside();
			if (member is TypeDef)
				return ((TypeDef)member).IsVisibleOutside();

			throw new NotSupportedException();
		}
	}
}

```

`Confuser.Core/Project/Patterns/IsTypeFunction.cs`:

```cs
using System;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that indicate the type of type(?).
	/// </summary>
	public class IsTypeFunction : PatternFunction {
		internal const string FnName = "is-type";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			TypeDef type = definition as TypeDef;
			if (type == null && definition is IMemberDef)
				type = ((IMemberDef)definition).DeclaringType;
			if (type == null)
				return false;

			string typeRegex = Arguments[0].Evaluate(definition).ToString();

			var typeType = new StringBuilder();

			if (type.IsEnum)
				typeType.Append("enum ");

			if (type.IsInterface)
				typeType.Append("interface ");

			if (type.IsValueType)
				typeType.Append("valuetype ");

			if (type.IsDelegate())
				typeType.Append("delegate ");

			if (type.IsAbstract)
				typeType.Append("abstract ");

			if (type.IsNested)
				typeType.Append("nested ");

			if (type.IsSerializable)
				typeType.Append("serializable ");

			return Regex.IsMatch(typeType.ToString(), typeRegex);
		}
	}
}
```

`Confuser.Core/Project/Patterns/LiteralExpression.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A literal expression.
	/// </summary>
	public class LiteralExpression : PatternExpression {
		/// <summary>
		///     Initializes a new instance of the <see cref="LiteralExpression" /> class.
		/// </summary>
		/// <param name="literal">The literal.</param>
		public LiteralExpression(object literal) {
			Literal = literal;
		}

		/// <summary>
		///     Gets the value of literal.
		/// </summary>
		/// <value>The value of literal.</value>
		public object Literal { get; private set; }

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			return Literal;
		}

		/// <inheritdoc />
		public override void Serialize(IList<PatternToken> tokens) {
			if (Literal is bool) {
				var value = (bool)Literal;
				tokens.Add(new PatternToken(TokenType.Identifier, value.ToString().ToLowerInvariant()));
			}
			else
				tokens.Add(new PatternToken(TokenType.Literal, Literal.ToString()));
		}
	}
}
```

`Confuser.Core/Project/Patterns/MatchFunction.cs`:

```cs
using System;
using System.Text.RegularExpressions;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that match the full name of the definition with specified RegEx.
	/// </summary>
	public class MatchFunction : PatternFunction {
		internal const string FnName = "match";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string regex = Arguments[0].Evaluate(definition).ToString();
			return Regex.IsMatch(definition.FullName, regex);
		}
	}

	/// <summary>
	///     A function that match the name of the definition with specified RegEx.
	/// </summary>
	public class MatchNameFunction : PatternFunction {
		internal const string FnName = "match-name";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string regex = Arguments[0].Evaluate(definition).ToString();
			return Regex.IsMatch(definition.Name, regex);
		}
	}

	/// <summary>
	///     A function that match the name of declaring type with specified RegEx.
	/// </summary>
	public class MatchTypeNameFunction : PatternFunction {
		internal const string FnName = "match-type-name";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			if (definition is TypeDef) {
				string regex = Arguments[0].Evaluate(definition).ToString();
				return Regex.IsMatch(definition.Name, regex);
			}
			if (definition is IMemberDef && ((IMemberDef)definition).DeclaringType != null) {
				string regex = Arguments[0].Evaluate(definition).ToString();
				return Regex.IsMatch(((IMemberDef)definition).DeclaringType.Name, regex);
			}
			return false;
		}
	}
}
```

`Confuser.Core/Project/Patterns/MemberTypeFunction.cs`:

```cs
using System;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the type of definition.
	/// </summary>
	public class MemberTypeFunction : PatternFunction {
		internal const string FnName = "member-type";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			string typeRegex = Arguments[0].Evaluate(definition).ToString();

			var memberType = new StringBuilder();

			if (definition is TypeDef)
				memberType.Append("type ");

			if (definition is MethodDef) {
				memberType.Append("method ");

				var method = (MethodDef)definition;
				if (method.IsGetter)
					memberType.Append("propertym getter ");
				else if (method.IsSetter)
					memberType.Append("propertym setter ");
				else if (method.IsAddOn)
					memberType.Append("eventm add ");
				else if (method.IsRemoveOn)
					memberType.Append("eventm remove ");
				else if (method.IsFire)
					memberType.Append("eventm fire ");
				else if (method.IsOther)
					memberType.Append("other ");
			}

			if (definition is FieldDef)
				memberType.Append("field ");

			if (definition is PropertyDef)
				memberType.Append("property ");

			if (definition is EventDef)
				memberType.Append("event ");

			if (definition is ModuleDef)
				memberType.Append("module ");

			return Regex.IsMatch(memberType.ToString(), typeRegex);
		}
	}
}
```

`Confuser.Core/Project/Patterns/ModuleFunction.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the module of definition.
	/// </summary>
	public class ModuleFunction : PatternFunction {
		internal const string FnName = "module";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			if (!(definition is IOwnerModule) && !(definition is IModule))
				return false;
			object name = Arguments[0].Evaluate(definition);
			if (definition is IModule)
				return ((IModule)definition).Name == name.ToString();
			return ((IOwnerModule)definition).Module.Name == name.ToString();
		}
	}
}
```

`Confuser.Core/Project/Patterns/NameFunction.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the name of definition.
	/// </summary>
	public class NameFunction : PatternFunction {
		internal const string FnName = "name";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			object name = Arguments[0].Evaluate(definition);
			return definition.Name == name.ToString();
		}
	}
}
```

`Confuser.Core/Project/Patterns/NamespaceFunction.cs`:

```cs
using System;
using System.Text.RegularExpressions;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A function that compare the namespace of definition.
	/// </summary>
	public class NamespaceFunction : PatternFunction {
		internal const string FnName = "namespace";

		/// <inheritdoc />
		public override string Name {
			get { return FnName; }
		}

		/// <inheritdoc />
		public override int ArgumentCount {
			get { return 1; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			if (!(definition is TypeDef) && !(definition is IMemberDef))
				return false;
			var ns = "^" + Arguments[0].Evaluate(definition).ToString() + "$";

			var type = definition as TypeDef;
			if (type == null)
				type = ((IMemberDef)definition).DeclaringType;

			if (type == null)
				return false;

			while (type.IsNested)
				type = type.DeclaringType;

			return type != null && Regex.IsMatch(type.Namespace ?? "", ns);
		}
	}
}
```

`Confuser.Core/Project/Patterns/NotOperator.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     The NOT operator.
	/// </summary>
	public class NotOperator : PatternOperator {
		internal const string OpName = "not";

		/// <inheritdoc />
		public override string Name {
			get { return OpName; }
		}

		/// <inheritdoc />
		public override bool IsUnary {
			get { return true; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			return !(bool)OperandA.Evaluate(definition);
		}
	}
}
```

`Confuser.Core/Project/Patterns/OrOperator.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     The OR operator.
	/// </summary>
	public class OrOperator : PatternOperator {
		internal const string OpName = "or";

		/// <inheritdoc />
		public override string Name {
			get { return OpName; }
		}

		/// <inheritdoc />
		public override bool IsUnary {
			get { return false; }
		}

		/// <inheritdoc />
		public override object Evaluate(IDnlibDef definition) {
			var a = (bool)OperandA.Evaluate(definition);
			if (a) return true;
			return (bool)OperandB.Evaluate(definition);
		}
	}
}
```

`Confuser.Core/Project/Patterns/PatternExpression.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A pattern expression.
	/// </summary>
	public abstract class PatternExpression {
		/// <summary>
		///     Evaluates the expression on the specified definition.
		/// </summary>
		/// <param name="definition">The definition.</param>
		/// <returns>The result value.</returns>
		public abstract object Evaluate(IDnlibDef definition);

		/// <summary>
		///     Serializes the expression into tokens.
		/// </summary>
		/// <param name="tokens">The output list of tokens.</param>
		public abstract void Serialize(IList<PatternToken> tokens);
	}
}
```

`Confuser.Core/Project/Patterns/PatternFunction.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A pattern function.
	/// </summary>
	public abstract class PatternFunction : PatternExpression {
		/// <summary>
		///     Gets the name of function.
		/// </summary>
		/// <value>The name.</value>
		public abstract string Name { get; }

		/// <summary>
		///     Gets the number of arguments of the function.
		/// </summary>
		/// <value>The number of arguments.</value>
		public abstract int ArgumentCount { get; }

		/// <summary>
		///     Gets or sets the arguments of function.
		/// </summary>
		/// <value>The arguments.</value>
		public IList<PatternExpression> Arguments { get; set; }

		/// <inheritdoc />
		public override void Serialize(IList<PatternToken> tokens) {
			tokens.Add(new PatternToken(TokenType.Identifier, Name));
			tokens.Add(new PatternToken(TokenType.LParens));
			for (int i = 0; i < Arguments.Count; i++) {
				if (i != 0)
					tokens.Add(new PatternToken(TokenType.Comma));
				Arguments[i].Serialize(tokens);
			}
			tokens.Add(new PatternToken(TokenType.RParens));
		}
	}
}
```

`Confuser.Core/Project/Patterns/PatternOperator.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Confuser.Core.Project.Patterns {
	/// <summary>
	///     A pattern operator.
	/// </summary>
	public abstract class PatternOperator : PatternExpression {
		/// <summary>
		///     Gets the name of operator.
		/// </summary>
		/// <value>The name.</value>
		public abstract string Name { get; }

		/// <summary>
		///     Gets a value indicating whether this is an unary operator.
		/// </summary>
		/// <value><c>true</c> if this is an unary operator; otherwise, <c>false</c>.</value>
		public abstract bool IsUnary { get; }

		/// <summary>
		///     Gets or sets the first operand.
		/// </summary>
		/// <value>The first operand.</value>
		public PatternExpression OperandA { get; set; }

		/// <summary>
		///     Gets or sets the second operand.
		/// </summary>
		/// <value>The second operand.</value>
		public PatternExpression OperandB { get; set; }

		/// <inheritdoc />
		public override void Serialize(IList<PatternToken> tokens) {
			if (IsUnary) {
				tokens.Add(new PatternToken(TokenType.Identifier, Name));
				OperandA.Serialize(tokens);
			}
			else {
				OperandA.Serialize(tokens);
				tokens.Add(new PatternToken(TokenType.Identifier, Name));
				OperandB.Serialize(tokens);
			}
		}
	}
}
```

`Confuser.Core/Protection.cs`:

```cs
using System;

namespace Confuser.Core {
	/// <summary>
	///     Base class of Confuser protections.
	/// </summary>
	/// <remarks>
	///     A parameterless constructor must exists in derived classes to enable plugin discovery.
	/// </remarks>
	public abstract class Protection : ConfuserComponent {
		/// <summary>
		///     Gets the preset this protection is in.
		/// </summary>
		/// <value>The protection's preset.</value>
		public abstract ProtectionPreset Preset { get; }
	}
}
```

`Confuser.Core/ProtectionDependencyAttributes.cs`:

```cs
using System;

namespace Confuser.Core {
	/// <summary>
	///     Indicates the <see cref="Protection" /> must initialize before the specified protections.
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class BeforeProtectionAttribute : Attribute {
		/// <summary>
		///     Initializes a new instance of the <see cref="BeforeProtectionAttribute" /> class.
		/// </summary>
		/// <param name="ids">The full IDs of the specified protections.</param>
		public BeforeProtectionAttribute(params string[] ids) {
			Ids = ids;
		}

		/// <summary>
		///     Gets the full IDs of the specified protections.
		/// </summary>
		/// <value>The IDs of protections.</value>
		public string[] Ids { get; private set; }
	}

	/// <summary>
	///     Indicates the <see cref="Protection" /> must initialize after the specified protections.
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class AfterProtectionAttribute : Attribute {
		/// <summary>
		///     Initializes a new instance of the <see cref="BeforeProtectionAttribute" /> class.
		/// </summary>
		/// <param name="ids">The full IDs of the specified protections.</param>
		public AfterProtectionAttribute(params string[] ids) {
			Ids = ids;
		}

		/// <summary>
		///     Gets the full IDs of the specified protections.
		/// </summary>
		/// <value>The IDs of protections.</value>
		public string[] Ids { get; private set; }
	}
}
```

`Confuser.Core/ProtectionParameters.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core {
	using ProtectionParams = Dictionary<string, object>;

	/// <summary>
	///     Parameters of <see cref="ConfuserComponent" />.
	/// </summary>
	public class ProtectionParameters {
		static readonly object ParametersKey = new object();

		/// <summary>
		///     A empty instance of <see cref="ProtectionParameters" />.
		/// </summary>
		public static readonly ProtectionParameters Empty = new ProtectionParameters(null, new IDnlibDef[0]);

		readonly ConfuserComponent comp;

		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionParameters" /> class.
		/// </summary>
		/// <param name="component">The component that this parameters applied to.</param>
		/// <param name="targets">The protection targets.</param>
		internal ProtectionParameters(ConfuserComponent component, IList<IDnlibDef> targets) {
			comp = component;
			Targets = targets;
		}

		/// <summary>
		///     Gets the targets of protection.
		///     Possible targets are module, types, methods, fields, events, properties.
		/// </summary>
		/// <value>A list of protection targets.</value>
		public IList<IDnlibDef> Targets { get; private set; }


		/// <summary>
		///     Obtains the value of a parameter of the specified target.
		/// </summary>
		/// <typeparam name="T">The type of the parameter value.</typeparam>
		/// <param name="context">The working context.</param>
		/// <param name="target">The protection target.</param>
		/// <param name="name">The name of the parameter.</param>
		/// <param name="defValue">Default value if the parameter does not exist.</param>
		/// <returns>The value of the parameter.</returns>
		public T GetParameter<T>(ConfuserContext context, IDnlibDef target, string name, T defValue = default(T)) {
			Dictionary<string, string> parameters;

			if (comp == null)
				return defValue;

			if (comp is Packer && target == null) {
				// Packer parameters are stored in modules
				target = context.Modules[0];
			}

			var objParams = context.Annotations.Get<ProtectionSettings>(target, ParametersKey);
			if (objParams == null)
				return defValue;
			if (!objParams.TryGetValue(comp, out parameters))
				return defValue;

			string ret;
			if (parameters.TryGetValue(name, out ret)) {
				Type paramType = typeof(T);
				Type nullable = Nullable.GetUnderlyingType(paramType);
				if (nullable != null)
					paramType = nullable;

				if (paramType.IsEnum)
					return (T)Enum.Parse(paramType, ret, true);
				return (T)Convert.ChangeType(ret, paramType);
			}
			return defValue;
		}

		/// <summary>
		///     Sets the protection parameters of the specified target.
		/// </summary>
		/// <param name="context">The context.</param>
		/// <param name="target">The protection target.</param>
		/// <param name="parameters">The parameters.</param>
		public static void SetParameters(
			ConfuserContext context, IDnlibDef target, ProtectionSettings parameters) {
			context.Annotations.Set(target, ParametersKey, parameters);
		}

		/// <summary>
		///     Gets the protection parameters of the specified target.
		/// </summary>
		/// <param name="context">The context.</param>
		/// <param name="target">The protection target.</param>
		/// <returns>The parameters.</returns>
		public static ProtectionSettings GetParameters(
			ConfuserContext context, IDnlibDef target) {
			return context.Annotations.Get<ProtectionSettings>(target, ParametersKey);
		}
	}
}
```

`Confuser.Core/ProtectionPhase.cs`:

```cs
using System;

namespace Confuser.Core {
	/// <summary>
	///     Base class of protection phases.
	/// </summary>
	public abstract class ProtectionPhase {
		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionPhase" /> class.
		/// </summary>
		/// <param name="parent">The parent component of this phase.</param>
		public ProtectionPhase(ConfuserComponent parent) {
			Parent = parent;
		}

		/// <summary>
		///     Gets the parent component.
		/// </summary>
		/// <value>The parent component.</value>
		public ConfuserComponent Parent { get; private set; }

		/// <summary>
		///     Gets the targets of protection.
		/// </summary>
		/// <value>The protection targets.</value>
		public abstract ProtectionTargets Targets { get; }

		/// <summary>
		///     Gets the name of the phase.
		/// </summary>
		/// <value>The name of phase.</value>
		public abstract string Name { get; }

		/// <summary>
		///     Gets a value indicating whether this phase process all targets, not just the targets that requires the component.
		/// </summary>
		/// <value><c>true</c> if this phase process all targets; otherwise, <c>false</c>.</value>
		public virtual bool ProcessAll {
			get { return false; }
		}

		/// <summary>
		///     Executes the protection phase.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="parameters">The parameters of protection.</param>
		protected internal abstract void Execute(ConfuserContext context, ProtectionParameters parameters);
	}
}
```

`Confuser.Core/ProtectionPipeline.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet;

namespace Confuser.Core {
	/// <summary>
	///     Various stages in <see cref="ProtectionPipeline" />.
	/// </summary>
	public enum PipelineStage {
		/// <summary>
		///     Confuser engine inspects the loaded modules and makes necessary changes.
		///     This stage occurs only once per pipeline run.
		/// </summary>
		Inspection,

		/// <summary>
		///     Confuser engine begins to process a module.
		///     This stage occurs once per module.
		/// </summary>
		BeginModule,

		/// <summary>
		///     Confuser engine processes a module.
		///     This stage occurs once per module.
		/// </summary>
		ProcessModule,

		/// <summary>
		///     Confuser engine optimizes opcodes of the method bodys.
		///     This stage occurs once per module.
		/// </summary>
		OptimizeMethods,

		/// <summary>
		///     Confuser engine finishes processing a module.
		///     This stage occurs once per module.
		/// </summary>
		EndModule,

		/// <summary>
		///     Confuser engine writes the module to byte array.
		///     This stage occurs once per module, after all processing of modules are completed.
		/// </summary>
		WriteModule,

		/// <summary>
		///     Confuser engine generates debug symbols.
		///     This stage occurs only once per pipeline run.
		/// </summary>
		Debug,

		/// <summary>
		///     Confuser engine packs up the output if packer is present.
		///     This stage occurs only once per pipeline run.
		/// </summary>
		Pack,

		/// <summary>
		///     Confuser engine saves the output.
		///     This stage occurs only once per pipeline run.
		/// </summary>
		SaveModules
	}

	/// <summary>
	///     Protection processing pipeline.
	/// </summary>
	public class ProtectionPipeline {
		readonly Dictionary<PipelineStage, List<ProtectionPhase>> postStage;
		readonly Dictionary<PipelineStage, List<ProtectionPhase>> preStage;

		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionPipeline" /> class.
		/// </summary>
		public ProtectionPipeline() {
			var stages = (PipelineStage[])Enum.GetValues(typeof(PipelineStage));
			preStage = stages.ToDictionary(stage => stage, stage => new List<ProtectionPhase>());
			postStage = stages.ToDictionary(stage => stage, stage => new List<ProtectionPhase>());
		}

		/// <summary>
		///     Inserts the phase into pre-processing pipeline of the specified stage.
		/// </summary>
		/// <param name="stage">The pipeline stage.</param>
		/// <param name="phase">The protection phase.</param>
		public void InsertPreStage(PipelineStage stage, ProtectionPhase phase) {
			preStage[stage].Add(phase);
		}

		/// <summary>
		///     Inserts the phase into post-processing pipeline of the specified stage.
		/// </summary>
		/// <param name="stage">The pipeline stage.</param>
		/// <param name="phase">The protection phase.</param>
		public void InsertPostStage(PipelineStage stage, ProtectionPhase phase) {
			postStage[stage].Add(phase);
		}

		/// <summary>
		///     Finds the phase with the specified type in the pipeline.
		/// </summary>
		/// <typeparam name="T">The type of the phase.</typeparam>
		/// <returns>The phase with specified type in the pipeline.</returns>
		public T FindPhase<T>() where T : ProtectionPhase {
			foreach (var phases in preStage.Values)
				foreach (ProtectionPhase phase in phases) {
					if (phase is T)
						return (T)phase;
				}
			foreach (var phases in postStage.Values)
				foreach (ProtectionPhase phase in phases) {
					if (phase is T)
						return (T)phase;
				}
			return null;
		}

		/// <summary>
		///     Execute the specified pipeline stage with pre-processing and post-processing.
		/// </summary>
		/// <param name="stage">The pipeline stage.</param>
		/// <param name="func">The stage function.</param>
		/// <param name="targets">The target list of the stage.</param>
		/// <param name="context">The working context.</param>
		internal void ExecuteStage(PipelineStage stage, Action<ConfuserContext> func, Func<IList<IDnlibDef>> targets, ConfuserContext context) {
			foreach (ProtectionPhase pre in preStage[stage]) {
				context.CheckCancellation();
				context.Logger.DebugFormat("Executing '{0}' phase...", pre.Name);
				pre.Execute(context, new ProtectionParameters(pre.Parent, Filter(context, targets(), pre)));
			}
			context.CheckCancellation();
			func(context);
			context.CheckCancellation();
			foreach (ProtectionPhase post in postStage[stage]) {
				context.Logger.DebugFormat("Executing '{0}' phase...", post.Name);
				post.Execute(context, new ProtectionParameters(post.Parent, Filter(context, targets(), post)));
				context.CheckCancellation();
			}
		}

		/// <summary>
		///     Returns only the targets with the specified type and used by specified component.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="targets">List of targets.</param>
		/// <param name="phase">The component phase.</param>
		/// <returns>Filtered targets.</returns>
		static IList<IDnlibDef> Filter(ConfuserContext context, IList<IDnlibDef> targets, ProtectionPhase phase) {
			ProtectionTargets targetType = phase.Targets;

			IEnumerable<IDnlibDef> filter = targets;
			if ((targetType & ProtectionTargets.Modules) == 0)
				filter = filter.Where(def => !(def is ModuleDef));
			if ((targetType & ProtectionTargets.Types) == 0)
				filter = filter.Where(def => !(def is TypeDef));
			if ((targetType & ProtectionTargets.Methods) == 0)
				filter = filter.Where(def => !(def is MethodDef));
			if ((targetType & ProtectionTargets.Fields) == 0)
				filter = filter.Where(def => !(def is FieldDef));
			if ((targetType & ProtectionTargets.Properties) == 0)
				filter = filter.Where(def => !(def is PropertyDef));
			if ((targetType & ProtectionTargets.Events) == 0)
				filter = filter.Where(def => !(def is EventDef));

			if (phase.ProcessAll)
				return filter.ToList();
			return filter.Where(def => {
				ProtectionSettings parameters = ProtectionParameters.GetParameters(context, def);
				Debug.Assert(parameters != null);
				if (parameters == null) {
					context.Logger.ErrorFormat("'{0}' not marked for obfuscation, possibly a bug.", def);
					throw new ConfuserException(null);
				}
				return parameters.ContainsKey(phase.Parent);
			}).ToList();
		}
	}
}
```

`Confuser.Core/ProtectionPreset.cs`:

```cs
using System;

namespace Confuser.Core {
	/// <summary>
	///     Various presets of protections.
	/// </summary>
	public enum ProtectionPreset {
		/// <summary> The protection does not belong to any preset. </summary>
		None = 0,

		/// <summary> The protection provides basic security. </summary>
		Minimum = 1,

		/// <summary> The protection provides normal security for public release. </summary>
		Normal = 2,

		/// <summary> The protection provides better security with observable performance impact. </summary>
		Aggressive = 3,

		/// <summary> The protection provides strongest security with possible incompatibility. </summary>
		Maximum = 4
	}
}
```

`Confuser.Core/ProtectionSettings.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Confuser.Core {
	/// <summary>
	///     Protection settings for a certain component
	/// </summary>
	public class ProtectionSettings : Dictionary<ConfuserComponent, Dictionary<string, string>> {
		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionSettings" /> class.
		/// </summary>
		public ProtectionSettings() { }

		/// <summary>
		///     Initializes a new instance of the <see cref="ProtectionSettings" /> class
		///     from an existing <see cref="ProtectionSettings" />.
		/// </summary>
		/// <param name="settings">The settings to copy from.</param>
		public ProtectionSettings(ProtectionSettings settings) {
			if (settings == null)
				return;

			foreach (var i in settings)
				Add(i.Key, new Dictionary<string, string>(i.Value));
		}

		/// <summary>
		///     Determines whether the settings is empty.
		/// </summary>
		/// <returns><c>true</c> if the settings is empty; otherwise, <c>false</c>.</returns>
		public bool IsEmpty() {
			return Count == 0;
		}
	}
}
```

`Confuser.Core/ProtectionTargets.cs`:

```cs
using System;

namespace Confuser.Core {
	/// <summary>
	///     Targets of protection.
	/// </summary>
	[Flags]
	public enum ProtectionTargets {
		/// <summary> Type definitions. </summary>
		Types = 1,

		/// <summary> Method definitions. </summary>
		Methods = 2,

		/// <summary> Field definitions. </summary>
		Fields = 4,

		/// <summary> Event definitions. </summary>
		Events = 8,

		/// <summary> Property definitions. </summary>
		Properties = 16,

		/// <summary> All member definitions (i.e. type, methods, fields, events and properties). </summary>
		AllMembers = Types | Methods | Fields | Events | Properties,

		/// <summary> Module definitions. </summary>
		Modules = 32,

		/// <summary> All definitions (i.e. All member definitions and modules). </summary>
		AllDefinitions = AllMembers | Modules
	}
}
```

`Confuser.Core/ServiceRegistry.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Confuser.Core {
	/// <summary>
	///     A registry of different services provided by protections
	/// </summary>
	public class ServiceRegistry : IServiceProvider {
		readonly HashSet<string> serviceIds = new HashSet<string>();
		readonly Dictionary<Type, object> services = new Dictionary<Type, object>();

		/// <inheritdoc />
		object IServiceProvider.GetService(Type serviceType) {
			return services.GetValueOrDefault(serviceType, null);
		}

		/// <summary>
		///     Retrieves the service of type <typeparamref name="T" />.
		/// </summary>
		/// <typeparam name="T">The type of service.</typeparam>
		/// <returns>The service instance.</returns>
		public T GetService<T>() {
			return (T)services.GetValueOrDefault(typeof(T), null);
		}

		/// <summary>
		///     Registers the service with specified ID .
		/// </summary>
		/// <param name="serviceId">The service identifier.</param>
		/// <param name="serviceType">The service type.</param>
		/// <param name="service">The service.</param>
		/// <exception cref="System.ArgumentException">Service with same ID or type has already registered.</exception>
		public void RegisterService(string serviceId, Type serviceType, object service) {
			if (!serviceIds.Add(serviceId))
				throw new ArgumentException("Service with ID '" + serviceIds + "' has already registered.", "serviceId");
			if (services.ContainsKey(serviceType))
				throw new ArgumentException("Service with type '" + service.GetType().Name + "' has already registered.", "service");
			services.Add(serviceType, service);
		}

		/// <summary>
		///     Determines whether the service with specified identifier has already registered.
		/// </summary>
		/// <param name="serviceId">The service identifier.</param>
		/// <returns><c>true</c> if the service with specified identifier has already registered; otherwise, <c>false</c>.</returns>
		public bool Contains(string serviceId) {
			return serviceIds.Contains(serviceId);
		}
	}
}
```

`Confuser.Core/Services/CompressionService.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Confuser.Core.Helpers;
using dnlib.DotNet;
using SevenZip;
using SevenZip.Compression.LZMA;

namespace Confuser.Core.Services {
	internal class CompressionService : ICompressionService {
		static readonly object Decompressor = new object();
		readonly ConfuserContext context;

		/// <summary>
		///     Initializes a new instance of the <see cref="CompressionService" /> class.
		/// </summary>
		/// <param name="context">The working context.</param>
		public CompressionService(ConfuserContext context) {
			this.context = context;
		}

		/// <inheritdoc />
		public MethodDef TryGetRuntimeDecompressor(ModuleDef module, Action<IDnlibDef> init) {
			var decompressor = context.Annotations.Get<Tuple<MethodDef, List<IDnlibDef>>>(module, Decompressor);
			if (decompressor == null)
				return null;

			foreach (IDnlibDef member in decompressor.Item2)
				init(member);
			return decompressor.Item1;
		}

		/// <inheritdoc />
		public MethodDef GetRuntimeDecompressor(ModuleDef module, Action<IDnlibDef> init) {
			Tuple<MethodDef, List<IDnlibDef>> decompressor = context.Annotations.GetOrCreate(module, Decompressor, m => {
				var rt = context.Registry.GetService<IRuntimeService>();

				List<IDnlibDef> members = InjectHelper.Inject(rt.GetRuntimeType("Confuser.Runtime.Lzma"), module.GlobalType, module).ToList();
				MethodDef decomp = null;
				foreach (IDnlibDef member in members) {
					if (member is MethodDef) {
						var method = (MethodDef)member;
						if (method.Access == MethodAttributes.Public)
							method.Access = MethodAttributes.Assembly;
						if (!method.IsConstructor)
							method.IsSpecialName = false;

						if (method.Name == "Decompress")
							decomp = method;
					}
					else if (member is FieldDef) {
						var field = (FieldDef)member;
						if (field.Access == FieldAttributes.Public)
							field.Access = FieldAttributes.Assembly;
						if (field.IsLiteral) {
							field.DeclaringType.Fields.Remove(field);
						}
					}
				}
				members.RemoveWhere(def => def is FieldDef && ((FieldDef)def).IsLiteral);

				Debug.Assert(decomp != null);
				return Tuple.Create(decomp, members);
			});
			foreach (IDnlibDef member in decompressor.Item2)
				init(member);
			return decompressor.Item1;
		}

		/// <inheritdoc />
		public byte[] Compress(byte[] data, Action<double> progressFunc = null) {
			CoderPropID[] propIDs = {
				CoderPropID.DictionarySize,
				CoderPropID.PosStateBits,
				CoderPropID.LitContextBits,
				CoderPropID.LitPosBits,
				CoderPropID.Algorithm,
				CoderPropID.NumFastBytes,
				CoderPropID.MatchFinder,
				CoderPropID.EndMarker
			};
			object[] properties = {
				1 << 23,
				2,
				3,
				0,
				2,
				128,
				"bt4",
				false
			};

			var x = new MemoryStream();
			var encoder = new Encoder();
			encoder.SetCoderProperties(propIDs, properties);
			encoder.WriteCoderProperties(x);

			var length = BitConverter.GetBytes(data.Length);
			if (!BitConverter.IsLittleEndian)
				Array.Reverse(length);
			
			// Store 4 byte length value (little-endian)
			x.Write(length, 0, sizeof(int));

			ICodeProgress progress = null;
			if (progressFunc != null)
				progress = new CompressionLogger(progressFunc, data.Length);
			encoder.Code(new MemoryStream(data), x, -1, -1, progress);

			return x.ToArray();
		}

		class CompressionLogger : ICodeProgress {
			readonly Action<double> progressFunc;
			readonly int size;

			public CompressionLogger(Action<double> progressFunc, int size) {
				this.progressFunc = progressFunc;
				this.size = size;
			}

			public void SetProgress(long inSize, long outSize) {
				double precentage = (double)inSize / size;
				progressFunc(precentage);
			}
		}
	}

	/// <summary>
	///     Provides methods to do compression and inject decompression algorithm.
	/// </summary>
	public interface ICompressionService {
		/// <summary>
		///     Gets the runtime decompression method in the module, or null if it's not yet injected.
		/// </summary>
		/// <param name="module">The module which the decompression method resides in.</param>
		/// <param name="init">The initializing method for compression helper definitions.</param>
		/// <returns>
		///     The requested decompression method with signature 'static Byte[] (Byte[])',
		///     or null if it hasn't been injected yet.
		/// </returns>
		MethodDef TryGetRuntimeDecompressor(ModuleDef module, Action<IDnlibDef> init);

		/// <summary>
		///     Gets the runtime decompression method in the module and inject if it does not exists.
		/// </summary>
		/// <param name="module">The module which the decompression method resides in.</param>
		/// <param name="init">The initializing method for injected helper definitions.</param>
		/// <returns>The requested decompression method with signature 'static Byte[] (Byte[])'.</returns>
		MethodDef GetRuntimeDecompressor(ModuleDef module, Action<IDnlibDef> init);

		/// <summary>
		///     Compresses the specified data.
		/// </summary>
		/// <param name="data">The buffer storing the data.</param>
		/// <param name="progressFunc">The function that receive the progress of compression.</param>
		/// <returns>The compressed data.</returns>
		byte[] Compress(byte[] data, Action<double> progressFunc = null);
	}
}

```

`Confuser.Core/Services/MarkerService.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Core.Services {
	internal class MarkerService : IMarkerService {
		readonly ConfuserContext context;
		readonly Marker marker;
		readonly Dictionary<IDnlibDef, ConfuserComponent> helperParents;

		/// <summary>
		///     Initializes a new instance of the <see cref="MarkerService" /> class.
		/// </summary>
		/// <param name="context">The working context.</param>
		/// <param name="marker">The marker.</param>
		public MarkerService(ConfuserContext context, Marker marker) {
			this.context = context;
			this.marker = marker;
			helperParents = new Dictionary<IDnlibDef, ConfuserComponent>();
		}

		/// <inheritdoc />
		public void Mark(IDnlibDef member, ConfuserComponent parentComp) {
			if (member == null)
				throw new ArgumentNullException("member");
			if (member is ModuleDef)
				throw new ArgumentException("New ModuleDef cannot be marked.");
			if (IsMarked(member)) // avoid double marking
				return;

			marker.MarkMember(member, context);
			if (parentComp != null)
				helperParents[member] = parentComp;
		}

		/// <inheritdoc />
		public bool IsMarked(IDnlibDef def) {
			return ProtectionParameters.GetParameters(context, def) != null;
		}

		/// <inheritdoc />
		public ConfuserComponent GetHelperParent(IDnlibDef def) {
			ConfuserComponent parent;
			if (!helperParents.TryGetValue(def, out parent))
				return null;
			return parent;
		}
	}

	/// <summary>
	///     Provides methods to access the obfuscation marker.
	/// </summary>
	public interface IMarkerService {
		/// <summary>
		///     Marks the helper member.
		/// </summary>
		/// <param name="member">The helper member.</param>
		/// <param name="parentComp">The parent component.</param>
		/// <exception cref="System.ArgumentException"><paramref name="member" /> is a <see cref="ModuleDef" />.</exception>
		/// <exception cref="System.ArgumentNullException"><paramref name="member" /> is <c>null</c>.</exception>
		void Mark(IDnlibDef member, ConfuserComponent parentComp);

		/// <summary>
		///     Determines whether the specified definition is marked.
		/// </summary>
		/// <param name="def">The definition.</param>
		/// <returns><c>true</c> if the specified definition is marked; otherwise, <c>false</c>.</returns>
		bool IsMarked(IDnlibDef def);

		/// <summary>
		///     Gets the parent component of the specified helper.
		/// </summary>
		/// <param name="def">The helper definition.</param>
		/// <returns>The parent component of the helper, or <c>null</c> if the specified definition is not a helper.</returns>
		ConfuserComponent GetHelperParent(IDnlibDef def);
	}
}
```

`Confuser.Core/Services/RandomService.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;
using dnlib.DotNet.Writer;

namespace Confuser.Core.Services {
	/// <summary>
	///     A seeded SHA256 PRNG.
	/// </summary>
	public class RandomGenerator {
		/// <summary>
		///     The prime numbers used for generation
		/// </summary>
		static readonly byte[] primes = { 7, 11, 23, 37, 43, 59, 71 };

		readonly SHA256Managed sha256 = new SHA256Managed();
		int mixIndex;
		byte[] state; //32 bytes
		int stateFilled;

		/// <summary>
		///     Initializes a new instance of the <see cref="RandomGenerator" /> class.
		/// </summary>
		/// <param name="seed">The seed.</param>
		internal RandomGenerator(byte[] seed) {
			state = (byte[])seed.Clone();
			stateFilled = 32;
			mixIndex = 0;
		}

		/// <summary>
		///     Creates a seed buffer.
		/// </summary>
		/// <param name="seed">The seed data.</param>
		/// <returns>The seed buffer.</returns>
		internal static byte[] Seed(string seed) {
			byte[] ret = Utils.SHA256(!string.IsNullOrEmpty(seed) ? Encoding.UTF8.GetBytes(seed) : Guid.NewGuid().ToByteArray());

			for (int i = 0; i < 32; i++) {
				ret[i] *= primes[i % primes.Length];
				ret = Utils.SHA256(ret);
			}
			return ret;
		}

		/// <summary>
		///     Refills the state buffer.
		/// </summary>
		void NextState() {
			for (int i = 0; i < 32; i++)
				state[i] ^= primes[mixIndex = (mixIndex + 1) % primes.Length];
			state = sha256.ComputeHash(state);
			stateFilled = 32;
		}

		/// <summary>
		///     Fills the specified buffer with random bytes.
		/// </summary>
		/// <param name="buffer">The buffer.</param>
		/// <param name="offset">The offset of buffer to fill in.</param>
		/// <param name="length">The number of random bytes.</param>
		/// <exception cref="System.ArgumentNullException"><paramref name="buffer" /> is <c>null</c>.</exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		///     <paramref name="offset" /> or <paramref name="length" /> is less than 0.
		/// </exception>
		/// <exception cref="System.ArgumentException">Invalid <paramref name="offset" /> or <paramref name="length" />.</exception>
		public void NextBytes(byte[] buffer, int offset, int length) {
			if (buffer == null)
				throw new ArgumentNullException("buffer");
			if (offset < 0)
				throw new ArgumentOutOfRangeException("offset");
			if (length < 0)
				throw new ArgumentOutOfRangeException("length");
			if (buffer.Length - offset < length)
				throw new ArgumentException("Invalid offset or length.");

			while (length > 0) {
				if (length >= stateFilled) {
					Buffer.BlockCopy(state, 32 - stateFilled, buffer, offset, stateFilled);
					offset += stateFilled;
					length -= stateFilled;
					stateFilled = 0;
				}
				else {
					Buffer.BlockCopy(state, 32 - stateFilled, buffer, offset, length);
					stateFilled -= length;
					length = 0;
				}
				if (stateFilled == 0)
					NextState();
			}
		}

		/// <summary>
		///     Returns a random byte.
		/// </summary>
		/// <returns>Requested random byte.</returns>
		public byte NextByte() {
			byte ret = state[32 - stateFilled];
			stateFilled--;
			if (stateFilled == 0)
				NextState();
			return ret;
		}

		/// <summary>
		///     Gets a buffer of random bytes with the specified length.
		/// </summary>
		/// <param name="length">The number of random bytes.</param>
		/// <returns>A buffer of random bytes.</returns>
		public byte[] NextBytes(int length) {
			var ret = new byte[length];
			NextBytes(ret, 0, length);
			return ret;
		}

		/// <summary>
		///     Returns a random signed integer.
		/// </summary>
		/// <returns>Requested random number.</returns>
		public int NextInt32() {
			return BitConverter.ToInt32(NextBytes(4), 0);
		}

		/// <summary>
		///     Returns a nonnegative random integer that is less than the specified maximum.
		/// </summary>
		/// <param name="max">The exclusive upper bound.</param>
		/// <returns>Requested random number.</returns>
		public int NextInt32(int max) {
			return (int)(NextUInt32() % max);
		}

		/// <summary>
		///     Returns a random integer that is within a specified range.
		/// </summary>
		/// <param name="min">The inclusive lower bound.</param>
		/// <param name="max">The exclusive upper bound.</param>
		/// <returns>Requested random number.</returns>
		public int NextInt32(int min, int max) {
			if (max <= min) return min;
			return min + (int)(NextUInt32() % (max - min));
		}

		/// <summary>
		///     Returns a random unsigned integer.
		/// </summary>
		/// <returns>Requested random number.</returns>
		public uint NextUInt32() {
			return BitConverter.ToUInt32(NextBytes(4), 0);
		}

		/// <summary>
		///     Returns a nonnegative random integer that is less than the specified maximum.
		/// </summary>
		/// <param name="max">The exclusive upper bound.</param>
		/// <returns>Requested random number.</returns>
		public uint NextUInt32(uint max) => NextUInt32() % max;

		/// <summary>
		///     Returns a random double floating pointer number from 0 (inclusive) to 1 (exclusive).
		/// </summary>
		/// <returns>Requested random number.</returns>
		public double NextDouble() {
			return NextUInt32() / ((double)uint.MaxValue + 1);
		}

		/// <summary>
		///     Returns a random boolean value.
		/// </summary>
		/// <returns>Requested random boolean value.</returns>
		public bool NextBoolean() {
			byte s = state[32 - stateFilled];
			stateFilled--;
			if (stateFilled == 0)
				NextState();
			return s % 2 == 0;
		}

		/// <summary>
		///     Shuffles the element in the specified list.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="list">The list to shuffle.</param>
		public void Shuffle<T>(IList<T> list) {
			for (int i = list.Count - 1; i > 1; i--) {
				int k = NextInt32(i + 1);
				T tmp = list[k];
				list[k] = list[i];
				list[i] = tmp;
			}
		}

		/// <summary>
		///     Shuffles the element in the specified metadata table.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="table">The metadata table to shuffle.</param>
		public void Shuffle<T>(MDTable<T> table) where T : struct {
			if (table.IsEmpty) return;

			for (uint i = (uint)(table.Rows); i > 2; i--) {
				uint k = NextUInt32(i - 1) + 1;
				Debug.Assert(k >= 1, $"{nameof(k)} >= 1");
				Debug.Assert(k < i, $"{nameof(k)} < {nameof(i)}");
				Debug.Assert(k <= table.Rows, $"{nameof(k)} <= {nameof(table)}.Rows");

				var tmp = table[k];
				table[k] = table[i];
				table[i] = tmp;
			}
		}
	}

	/// <summary>
	///     Implementation of <see cref="IRandomService" />.
	/// </summary>
	internal class RandomService : IRandomService {
		readonly byte[] seed; //32 bytes

		public string SeedString { get; }

		/// <summary>
		///     Initializes a new instance of the <see cref="RandomService" /> class.
		/// </summary>
		/// <param name="seed">The project seed.</param>
		public RandomService(string seed) {
			SeedString = string.IsNullOrEmpty(seed) ? Guid.NewGuid().ToString() : seed;
			this.seed = RandomGenerator.Seed(SeedString);
		}

		/// <inheritdoc />
		public RandomGenerator GetRandomGenerator(string id) {
			if (string.IsNullOrEmpty(id))
				throw new ArgumentNullException("id");
			byte[] newSeed = seed;
			byte[] idHash = Utils.SHA256(Encoding.UTF8.GetBytes(id));
			for (int i = 0; i < 32; i++)
				newSeed[i] ^= idHash[i];
			return new RandomGenerator(Utils.SHA256(newSeed));
		}
	}

	/// <summary>
	///     Provides methods to obtain a unique stable PRNG for any given ID.
	/// </summary>
	public interface IRandomService {
		/// <summary>
		///     Gets a RNG with the specified identifier.
		/// </summary>
		/// <param name="id">The identifier.</param>
		/// <returns>The requested RNG.</returns>
		/// <exception cref="System.ArgumentNullException"><paramref name="id" /> is <c>null</c>.</exception>
		RandomGenerator GetRandomGenerator(string id);

		string SeedString { get; }
	}
}

```

`Confuser.Core/Services/RuntimeService.cs`:

```cs
using System;
using System.IO;
using System.Reflection;
using dnlib.DotNet;

namespace Confuser.Core.Services {
	internal class RuntimeService : IRuntimeService {
		ModuleDef rtModule;

		/// <inheritdoc />
		public TypeDef GetRuntimeType(string fullName) {
			if (rtModule == null) {
				LoadConfuserRuntimeModule();
			}
			return rtModule.Find(fullName, true);
		}

		private void LoadConfuserRuntimeModule() {
			const string runtimeDllName = "Confuser.Runtime.dll";

			var module = typeof(RuntimeService).Assembly.ManifestModule;
			string rtPath = runtimeDllName;
			var creationOptions = new ModuleCreationOptions() { TryToLoadPdbFromDisk = true };
			if (module.FullyQualifiedName[0] != '<') {
				rtPath = Path.Combine(Path.GetDirectoryName(module.FullyQualifiedName), rtPath);
				if (File.Exists(rtPath)) {
					try {
						rtModule = ModuleDefMD.Load(rtPath, creationOptions);
					}
					catch (IOException) { }
				}
				if (rtModule == null) {
					rtPath = runtimeDllName;
				}
			}
			if (rtModule == null) {
				rtModule = ModuleDefMD.Load(rtPath, creationOptions);
			}
			rtModule.EnableTypeDefFindCache = true;
		}
	}

	/// <summary>
	///     Provides methods to obtain runtime library injection type.
	/// </summary>
	public interface IRuntimeService {
		/// <summary>
		///     Gets the specified runtime type for injection.
		/// </summary>
		/// <param name="fullName">The full name of the runtime type.</param>
		/// <returns>The requested runtime type.</returns>
		TypeDef GetRuntimeType(string fullName);
	}
}

```

`Confuser.Core/Services/TraceService.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core.Services {
	public sealed class TraceService : ITraceService {
		readonly Dictionary<MethodDef, MethodTrace> cache = new Dictionary<MethodDef, MethodTrace>();

		/// <summary>
		///     Initializes a new instance of the <see cref="TraceService" /> class.
		/// </summary>
		/// <param name="context">The working context.</param>
		public TraceService() {
		}


		/// <inheritdoc />
		public MethodTrace Trace(MethodDef method) {
			if (method == null)
				throw new ArgumentNullException("method");
			return cache.GetValueOrDefaultLazy(method, m => cache[m] = new MethodTrace(m)).Trace();
		}
	}

	/// <summary>
	///     Provides methods to trace stack of method body.
	/// </summary>
	public interface ITraceService {
		/// <summary>
		///     Trace the stack of the specified method.
		/// </summary>
		/// <param name="method">The method to trace.</param>
		/// <exception cref="InvalidMethodException"><paramref name="method" /> has invalid body.</exception>
		/// <exception cref="System.ArgumentNullException"><paramref name="method" /> is <c>null</c>.</exception>
		MethodTrace Trace(MethodDef method);
	}


	/// <summary>
	///     The trace result of a method.
	/// </summary>
	public class MethodTrace {
		readonly MethodDef method;
		Dictionary<int, List<Instruction>> fromInstrs;
		Dictionary<uint, int> offset2index;

		/// <summary>
		///     Initializes a new instance of the <see cref="MethodTrace" /> class.
		/// </summary>
		/// <param name="method">The method to trace.</param>
		internal MethodTrace(MethodDef method) {
			this.method = method;
		}

		/// <summary>
		///     Gets the method this trace belongs to.
		/// </summary>
		/// <value>The method.</value>
		public MethodDef Method {
			get { return method; }
		}

		/// <summary>
		///     Gets the instructions this trace is performed on.
		/// </summary>
		/// <value>The instructions.</value>
		public Instruction[] Instructions { get; private set; }

		/// <summary>
		///     Gets the map of offset to index.
		/// </summary>
		/// <value>The map.</value>
		public Func<uint, int> OffsetToIndexMap {
			get { return offset => offset2index[offset]; }
		}

		/// <summary>
		///     Gets the stack depths of method body.
		/// </summary>
		/// <value>The stack depths.</value>
		public int[] BeforeStackDepths { get; private set; }

		/// <summary>
		///     Gets the stack depths of method body.
		/// </summary>
		/// <value>The stack depths.</value>
		public int[] AfterStackDepths { get; private set; }

		/// <summary>
		///     Determines whether the specified instruction is the target of a branch instruction.
		/// </summary>
		/// <param name="instrIndex">The index of instruction.</param>
		/// <returns><c>true</c> if the specified instruction is a branch target; otherwise, <c>false</c>.</returns>
		public bool IsBranchTarget(int instrIndex) {
			return fromInstrs.ContainsKey(instrIndex);
		}

		/// <summary>
		///     Perform the actual tracing.
		/// </summary>
		/// <returns>This instance.</returns>
		/// <exception cref="InvalidMethodException">Bad method body.</exception>
		internal MethodTrace Trace() {
			CilBody body = method.Body;
			method.Body.UpdateInstructionOffsets();
			Instructions = method.Body.Instructions.ToArray();

			offset2index = new Dictionary<uint, int>();
			var beforeDepths = new int[body.Instructions.Count];
			var afterDepths = new int[body.Instructions.Count];
			fromInstrs = new Dictionary<int, List<Instruction>>();

			IList<Instruction> instrs = body.Instructions;
			for (int i = 0; i < instrs.Count; i++) {
				offset2index.Add(instrs[i].Offset, i);
				beforeDepths[i] = int.MinValue;
			}

			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				beforeDepths[offset2index[eh.TryStart.Offset]] = 0;
				beforeDepths[offset2index[eh.HandlerStart.Offset]] = (eh.HandlerType != ExceptionHandlerType.Finally ? 1 : 0);
				if (eh.FilterStart != null)
					beforeDepths[offset2index[eh.FilterStart.Offset]] = 1;
			}

			// Just do a simple forward scan to build the stack depth map
			int currentStack = 0;
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];

				if (beforeDepths[i] != int.MinValue) // Already set due to being target of a branch / beginning of EHs.
					currentStack = beforeDepths[i];

				beforeDepths[i] = currentStack;
				instr.UpdateStack(ref currentStack, Method.HasReturnType);
				afterDepths[i] = currentStack;

				switch (instr.OpCode.FlowControl) {
					case FlowControl.Branch:
						int index = offset2index[((Instruction)instr.Operand).Offset];
						if (beforeDepths[index] == int.MinValue)
							beforeDepths[index] = currentStack;
						fromInstrs.AddListEntry(offset2index[((Instruction)instr.Operand).Offset], instr);
						currentStack = 0;
						break;
					case FlowControl.Break:
						break;
					case FlowControl.Call:
						if (instr.OpCode.Code == Code.Jmp)
							currentStack = 0;
						break;
					case FlowControl.Cond_Branch:
						if (instr.OpCode.Code == Code.Switch) {
							foreach (Instruction target in (Instruction[])instr.Operand) {
								int targetIndex = offset2index[target.Offset];
								if (beforeDepths[targetIndex] == int.MinValue)
									beforeDepths[targetIndex] = currentStack;
								fromInstrs.AddListEntry(offset2index[target.Offset], instr);
							}
						}
						else {
							int targetIndex = offset2index[((Instruction)instr.Operand).Offset];
							if (beforeDepths[targetIndex] == int.MinValue)
								beforeDepths[targetIndex] = currentStack;
							fromInstrs.AddListEntry(offset2index[((Instruction)instr.Operand).Offset], instr);
						}
						break;
					case FlowControl.Meta:
						break;
					case FlowControl.Next:
						break;
					case FlowControl.Return:
						break;
					case FlowControl.Throw:
						break;
					default:
						throw new UnreachableException();
				}
			}

			foreach (int stackDepth in beforeDepths)
				if (stackDepth == int.MinValue)
					throw new InvalidMethodException("Bad method body.");

			foreach (int stackDepth in afterDepths)
				if (stackDepth == int.MinValue)
					throw new InvalidMethodException("Bad method body.");

			BeforeStackDepths = beforeDepths;
			AfterStackDepths = afterDepths;

			return this;
		}

		/// <summary>
		///     Traces the arguments of the specified call instruction.
		/// </summary>
		/// <param name="instr">The call instruction.</param>
		/// <returns>The indexes of the begin instruction of arguments.</returns>
		/// <exception cref="InvalidMethodException">The method body is invalid.</exception>
		public int[] TraceArguments(Instruction instr) {
			instr.CalculateStackUsage(Method.HasReturnType, out _, out int pop); // pop is number of arguments
			if (pop == 0)
				return new int[0];

			int instrIndex = offset2index[instr.Offset];
			int argCount = pop;
			int targetStack = BeforeStackDepths[instrIndex] - argCount;

			// Find the begin instruction of method call
			int beginInstrIndex = -1;
			var seen = new HashSet<uint>();
			var working = new Queue<int>();
			working.Enqueue(offset2index[instr.Offset] - 1);
			while (working.Count > 0) {
				int index = working.Dequeue();
				while (index >= 0) {
					if (BeforeStackDepths[index] == targetStack) {
						var currentInstr = Instructions[index];
						currentInstr.CalculateStackUsage(Method.HasReturnType, out int push, out pop);
						if (push == 0 && pop == 0) {
							// This instruction isn't doing anything to the stack. Could be a nop or some prefix.
							// Ignore it and move on to the next.
						} else if (Instructions[index].OpCode.Code != Code.Dup) {
							// It's not a duplicate instruction, this is an acceptable start point.
							break;
						} else {
							var prevInstr = Instructions[index - 1];
							prevInstr.CalculateStackUsage(Method.HasReturnType, out push, out _);
							if (push > 0) {
								// A duplicate instruction is an acceptable start point in case the preceeding instruction
								// pushes a value.
								break;
							}
						}
					}

					if (fromInstrs.ContainsKey(index))
						foreach (Instruction fromInstr in fromInstrs[index]) {
							if (!seen.Contains(fromInstr.Offset)) {
								seen.Add(fromInstr.Offset);
								working.Enqueue(offset2index[fromInstr.Offset]);
							}
						}
					index--;
				}
				if (index < 0)
					return null;

				if (beginInstrIndex == -1)
					beginInstrIndex = index;
				else if (beginInstrIndex != index)
					return null;
			}

			while (Instructions[beginInstrIndex].OpCode.Code == Code.Dup)
				beginInstrIndex--;

			// Trace the index of arguments
			seen.Clear();
			var working2 = new Queue<Tuple<int, Stack<int>>>();
			working2.Clear();
			working2.Enqueue(Tuple.Create(beginInstrIndex, new Stack<int>()));
			int[] ret = null;
			while (working2.Count > 0) {
				Tuple<int, Stack<int>> tuple = working2.Dequeue();
				int index = tuple.Item1;
				Stack<int> evalStack = tuple.Item2;

				while (index != instrIndex && index < Instructions.Length) {
					Instruction currentInstr = Instructions[index];
					currentInstr.CalculateStackUsage(Method.HasReturnType, out int push, out pop);
					if (currentInstr.OpCode.Code == Code.Dup) {
						// Special case duplicate. This causes the current value on the stack to be duplicated.
						// To show this behaviour, we'll fetch the last object on the eval stack and add it back twice.
						Debug.Assert(pop == 1 && push == 2 && evalStack.Count > 0);
						var lastIdx = evalStack.Pop();
						evalStack.Push(lastIdx);
						evalStack.Push(lastIdx);
					}
					else {
						// Removing values from the stack. If the stack is already empty, the poped values are of no relevance.
						Debug.Assert(evalStack.Count >= pop);
						for (var i = 0; i < pop; i++) {
							if (evalStack.Count > 0)
								evalStack.Pop();
						}
						Debug.Assert(push <= 1); // Instructions shouldn't put more than one value on the stack.
						for (var i = 0; i < push; i++) {
							evalStack.Push(index);
						}
					}

					object instrOperand = currentInstr.Operand;
					if (currentInstr.Operand is Instruction) {
						int targetIndex = offset2index[((Instruction)currentInstr.Operand).Offset];
						if (currentInstr.OpCode.FlowControl == FlowControl.Branch)
							index = targetIndex;
						else {
							working2.Enqueue(Tuple.Create(targetIndex, CopyStack(evalStack)));
							index++;
						}
					}
					else if (currentInstr.Operand is Instruction[]) {
						foreach (Instruction targetInstr in (Instruction[])currentInstr.Operand)
							working2.Enqueue(Tuple.Create(offset2index[targetInstr.Offset], CopyStack(evalStack)));
						index++;
					}
					else
						index++;
				}

				if (evalStack.Count > argCount) {
					// There are too many instructions on the eval stack.
					// That means that there are instructions for following commands.
					// To handle things properly we're only using the required amount on the top of the stack.
					var tmp = evalStack.ToArray();
					evalStack.Clear();
					foreach(var idx in tmp.Take(argCount).Reverse())
						evalStack.Push(idx);
				}

				if (evalStack.Count != argCount)
					return null;
				if (ret != null && !evalStack.SequenceEqual(ret))
					return null;
				ret = evalStack.ToArray();
			}

			if (ret == null)
				return ret;

			Array.Reverse(ret);
			return ret;
		}

		public static Stack<T> CopyStack<T>(Stack<T> original)
		{
			var arr = new T[original.Count];
			original.CopyTo(arr, 0);
			Array.Reverse(arr);
			return new Stack<T>(arr);
		}
	}
}

```

`Confuser.Core/UnreachableException.cs`:

```cs
using System;

namespace Confuser.Core {
	/// <summary>
	///     The exception that is thrown when supposedly unreachable code is executed.
	/// </summary>
	public class UnreachableException : SystemException {
		/// <summary>
		///     Initializes a new instance of the <see cref="UnreachableException" /> class.
		/// </summary>
		public UnreachableException() :
			base("Unreachable code reached.") { }
	}
}
```

`Confuser.Core/Utils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Confuser.Core {
	/// <summary>
	///     Provides a set of utility methods
	/// </summary>
	public static class Utils {
		static readonly char[] hexCharset = "0123456789abcdef".ToCharArray();

		/// <summary>
		///     Gets the value associated with the specified key, or default value if the key does not exists.
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key of the value to get.</param>
		/// <param name="defValue">The default value.</param>
		/// <returns>The value associated with the specified key, or the default value if the key does not exists</returns>
		public static TValue GetValueOrDefault<TKey, TValue>(
			this Dictionary<TKey, TValue> dictionary,
			TKey key,
			TValue defValue = default(TValue)) {
			TValue ret;
			if (dictionary.TryGetValue(key, out ret))
				return ret;
			return defValue;
		}

		/// <summary>
		///     Gets the value associated with the specified key, or default value if the key does not exists.
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key of the value to get.</param>
		/// <param name="defValueFactory">The default value factory function.</param>
		/// <returns>The value associated with the specified key, or the default value if the key does not exists</returns>
		public static TValue GetValueOrDefaultLazy<TKey, TValue>(
			this Dictionary<TKey, TValue> dictionary,
			TKey key,
			Func<TKey, TValue> defValueFactory) {
			TValue ret;
			if (dictionary.TryGetValue(key, out ret))
				return ret;
			return defValueFactory(key);
		}

		/// <summary>
		///     Adds the specified key and value to the multi dictionary.
		/// </summary>
		/// <typeparam name="TKey">The type of key.</typeparam>
		/// <typeparam name="TValue">The type of value.</typeparam>
		/// <param name="self">The dictionary to add to.</param>
		/// <param name="key">The key of the element to add.</param>
		/// <param name="value">The value of the element to add.</param>
		/// <exception cref="System.ArgumentNullException">key is <c>null</c>.</exception>
		public static void AddListEntry<TKey, TValue>(this IDictionary<TKey, List<TValue>> self, TKey key, TValue value) {
			if (key == null)
				throw new ArgumentNullException("key");
			List<TValue> list;
			if (!self.TryGetValue(key, out list))
				list = self[key] = new List<TValue>();
			list.Add(value);
		}

		/// <summary>
		///     Obtains the relative path from the specified base path.
		/// </summary>
		/// <param name="fileSpec">The file path.</param>
		/// <param name="baseDirectory">The base path.</param>
		/// <returns>The path of <paramref name="filespec" /> relative to <paramref name="folder" />.</returns>
		public static string GetRelativePath(string fileSpec, string baseDirectory) {
			if (fileSpec is null) throw new ArgumentNullException(nameof(fileSpec));
			if (baseDirectory is null) throw new ArgumentNullException(nameof(fileSpec));

			return GetRelativePath(new FileInfo(fileSpec), new DirectoryInfo(baseDirectory));
		}

		public static string GetRelativePath(FileInfo fileSpec, DirectoryInfo baseDirectory) {
			if (fileSpec is null) throw new ArgumentNullException(nameof(fileSpec));
			if (baseDirectory is null) throw new ArgumentNullException(nameof(fileSpec));

			if (baseDirectory.FullName.EndsWith(Path.DirectorySeparatorChar.ToString())) {
				baseDirectory = new DirectoryInfo(baseDirectory.FullName.TrimEnd(Path.DirectorySeparatorChar));
			}

			var relativePath = fileSpec.Name;
			var currentDirectory = fileSpec.Directory;
			while (!(currentDirectory is null) && !string.Equals(currentDirectory.FullName, baseDirectory.FullName, StringComparison.OrdinalIgnoreCase)) {
				relativePath = currentDirectory.Name + Path.DirectorySeparatorChar + relativePath;
				currentDirectory = currentDirectory.Parent;
			}

			if (currentDirectory is null) return null; //file is not inside the base directory
			return relativePath;
		}

		/// <summary>
		///     If the input string is empty, return null; otherwise, return the original input string.
		/// </summary>
		/// <param name="val">The input string.</param>
		/// <returns><c>null</c> if the input string is empty; otherwise, the original input string.</returns>
		public static string NullIfEmpty(this string val) {
			if (string.IsNullOrEmpty(val))
				return null;
			return val;
		}

		/// <summary>
		///     Compute the SHA1 hash of the input buffer.
		/// </summary>
		/// <param name="buffer">The input buffer.</param>
		/// <returns>The SHA1 hash of the input buffer.</returns>
		public static byte[] SHA1(byte[] buffer) {
			var sha = new SHA1Managed();
			return sha.ComputeHash(buffer);
		}

		/// <summary>
		///     Xor the values in the two buffer together.
		/// </summary>
		/// <param name="buffer1">The input buffer 1.</param>
		/// <param name="buffer2">The input buffer 2.</param>
		/// <returns>The result buffer.</returns>
		/// <exception cref="System.ArgumentException">Length of the two buffers are not equal.</exception>
		public static byte[] Xor(byte[] buffer1, byte[] buffer2) {
			if (buffer1.Length != buffer2.Length)
				throw new ArgumentException("Length mismatched.");
			var ret = new byte[buffer1.Length];
			for (int i = 0; i < ret.Length; i++)
				ret[i] = (byte)(buffer1[i] ^ buffer2[i]);
			return ret;
		}

		/// <summary>
		///     Compute the SHA256 hash of the input buffer.
		/// </summary>
		/// <param name="buffer">The input buffer.</param>
		/// <returns>The SHA256 hash of the input buffer.</returns>
		public static byte[] SHA256(byte[] buffer) {
			var sha = new SHA256Managed();
			return sha.ComputeHash(buffer);
		}

		/// <summary>
		///     Encoding the buffer to a string using specified charset.
		/// </summary>
		/// <param name="buff">The input buffer.</param>
		/// <param name="charset">The charset.</param>
		/// <returns>The encoded string.</returns>
		public static string EncodeString(byte[] buff, char[] charset) {
			int current = buff[0];
			var ret = new StringBuilder();
			for (int i = 1; i < buff.Length; i++) {
				current = (current << 8) + buff[i];
				while (current >= charset.Length) {
					current = Math.DivRem(current, charset.Length, out int remainder);
					ret.Append(charset[remainder]);
				}
			}
			if (current != 0)
				ret.Append(charset[current % charset.Length]);
			return ret.ToString();
		}

		/// <summary>
		///     Encode the buffer to a hexadecimal string.
		/// </summary>
		/// <param name="buff">The input buffer.</param>
		/// <returns>A hexadecimal representation of input buffer.</returns>
		public static string ToHexString(byte[] buff) {
			var ret = new char[buff.Length * 2];
			int i = 0;
			foreach (byte val in buff) {
				ret[i++] = hexCharset[val >> 4];
				ret[i++] = hexCharset[val & 0xf];
			}
			return new string(ret);
		}

		/// <summary>
		///     Removes all elements that match the conditions defined by the specified predicate from a the list.
		/// </summary>
		/// <typeparam name="T">The type of the elements of <paramref name="self" />.</typeparam>
		/// <param name="self">The list to remove from.</param>
		/// <param name="match">The predicate that defines the conditions of the elements to remove.</param>
		/// <returns><paramref name="self" /> for method chaining.</returns>
		public static void RemoveWhere<T>(this IList<T> self, Predicate<T> match) {
			if (self is List<T> list) {
				list.RemoveAll(match);
				return;
			}

			// Switch to slow algorithm
			for (int i = self.Count - 1; i >= 0; i--) {
				if (match(self[i]))
					self.RemoveAt(i);
			}
		}

		/// <summary>
		///     Returns a <see cref="IEnumerable{T}" /> that log the progress of iterating the specified list.
		/// </summary>
		/// <typeparam name="T">The type of list element</typeparam>
		/// <param name="enumerable">The list.</param>
		/// <param name="logger">The logger.</param>
		/// <returns>A wrapper of the list.</returns>
		public static IEnumerable<T> WithProgress<T>(this IEnumerable<T> enumerable, ILogger logger) {
			switch (enumerable) {
				case IReadOnlyCollection<T> readOnlyCollection:
					return WithProgress(enumerable, readOnlyCollection.Count, logger);
				case ICollection<T> collection:
					return WithProgress(enumerable, collection.Count, logger);
				default:
					var buffered = enumerable.ToList();
					return WithProgress(buffered, buffered.Count, logger);
			}
		}

		public static IEnumerable<T> WithProgress<T>(this IEnumerable<T> enumerable, int totalCount, ILogger logger) {
			var counter = 0;
			foreach (var obj in enumerable) {
				logger.Progress(counter, totalCount);
				yield return obj;
				counter++;
			}
			logger.Progress(totalCount, totalCount);
			logger.EndProgress();
		}
	}
}

```

`Confuser.Core/WatermarkingProtection.cs`:

```cs
using System.Linq;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Core {
	public sealed class WatermarkingProtection : Protection {
		public const string _Id = "watermark";
		public const string _FullId = "Cx.Watermark";

		/// <inheritdoc />
		public override string Name => "Watermarking";

		/// <inheritdoc />
		public override string Description =>
			"This applies a watermark to the assembly, showing that ConfuserEx protected the assembly. So people try to reverse the obfuscation know to just give up.";

		/// <inheritdoc />
		public override string Id => _Id;

		/// <inheritdoc />
		public override string FullId => _FullId;

		/// <inheritdoc />
		protected internal override void Initialize(ConfuserContext context) { }

		/// <inheritdoc />
		protected internal override void PopulatePipeline(ProtectionPipeline pipeline) =>
			pipeline.InsertPostStage(PipelineStage.EndModule, new WatermarkingPhase(this));

		/// <inheritdoc />
		public override ProtectionPreset Preset => ProtectionPreset.None;

		private sealed class WatermarkingPhase : ProtectionPhase {
			/// <inheritdoc />
			public WatermarkingPhase(ConfuserComponent parent) : base(parent) { }

			/// <inheritdoc />
			public override ProtectionTargets Targets => ProtectionTargets.Modules;

			/// <inheritdoc />
			public override string Name => "Apply watermark";

			/// <inheritdoc />
			protected internal override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				var marker = context.Registry.GetService<IMarkerService>();

				context.Logger.Debug("Watermarking...");
				foreach (var module in parameters.Targets.OfType<ModuleDef>()) {
					var attrRef = module.CorLibTypes.GetTypeRef("System", "Attribute");
					var attrType = module.FindNormal("ConfusedByAttribute");
					if (attrType == null) {
						attrType = new TypeDefUser("", "ConfusedByAttribute", attrRef);
						module.Types.Add(attrType);
						marker.Mark(attrType, Parent);
					}

					var ctor = attrType.FindInstanceConstructors()
						.FirstOrDefault(m => m.Parameters.Count == 1 && m.Parameters[0].Type == module.CorLibTypes.String);
					if (ctor == null) {
						ctor = new MethodDefUser(
							".ctor",
							MethodSig.CreateInstance(module.CorLibTypes.Void, module.CorLibTypes.String),
							MethodImplAttributes.Managed,
							MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName) {
							Body = new CilBody {MaxStack = 1}
						};
						ctor.Body.Instructions.Add(OpCodes.Ldarg_0.ToInstruction());
						ctor.Body.Instructions.Add(OpCodes.Call.ToInstruction(new MemberRefUser(module, ".ctor",
							MethodSig.CreateInstance(module.CorLibTypes.Void), attrRef)));
						ctor.Body.Instructions.Add(OpCodes.Ret.ToInstruction());
						attrType.Methods.Add(ctor);
						marker.Mark(ctor, Parent);
					}

					var attr = new CustomAttribute(ctor);
					attr.ConstructorArguments.Add(new CAArgument(module.CorLibTypes.String, ConfuserEngine.Version));

					module.CustomAttributes.Add(attr);
				}
			}
		}
	}
}

```

`Confuser.DynCipher/AST/ArrayIndexExpression.cs`:

```cs
using System;

namespace Confuser.DynCipher.AST {
	public class ArrayIndexExpression : Expression {
		public Expression Array { get; set; }
		public int Index { get; set; }

		public override string ToString() {
			return string.Format("{0}[{1}]", Array, Index);
		}
	}
}
```

`Confuser.DynCipher/AST/AssignmentStatement.cs`:

```cs
using System;

namespace Confuser.DynCipher.AST {
	public class AssignmentStatement : Statement {
		public Expression Target { get; set; }
		public Expression Value { get; set; }

		public override string ToString() {
			return string.Format("{0} = {1};", Target, Value);
		}
	}
}
```

`Confuser.DynCipher/AST/BinOpExpression.cs`:

```cs
using System;

namespace Confuser.DynCipher.AST {
	public enum BinOps {
		Add,
		Sub,
		Div,
		Mul,
		Or,
		And,
		Xor,
		Lsh,
		Rsh
	}

	public class BinOpExpression : Expression {
		public Expression Left { get; set; }
		public Expression Right { get; set; }
		public BinOps Operation { get; set; }

		public override string ToString() {
			string op;
			switch (Operation) {
				case BinOps.Add:
					op = "+";
					break;
				case BinOps.Sub:
					op = "-";
					break;
				case BinOps.Div:
					op = "/";
					break;
				case BinOps.Mul:
					op = "*";
					break;
				case BinOps.Or:
					op = "|";
					break;
				case BinOps.And:
					op = "&";
					break;
				case BinOps.Xor:
					op = "^";
					break;
				case BinOps.Lsh:
					op = "<<";
					break;
				case BinOps.Rsh:
					op = ">>";
					break;
				default:
					throw new Exception();
			}
			return string.Format("({0} {1} {2})", Left, op, Right);
		}
	}
}
```

`Confuser.DynCipher/AST/Expression.cs`:

```cs
using System;

namespace Confuser.DynCipher.AST {
	public abstract class Expression {
		public object Tag { get; set; }
		public abstract override string ToString();

		public static BinOpExpression operator +(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Add
			};
		}

		public static BinOpExpression operator -(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Sub
			};
		}

		public static BinOpExpression operator *(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Mul
			};
		}

		public static BinOpExpression operator >>(Expression a, int b) {
			return new BinOpExpression {
				Left = a,
				Right = (LiteralExpression)(uint)b,
				Operation = BinOps.Rsh
			};
		}

		public static BinOpExpression operator <<(Expression a, int b) {
			return new BinOpExpression {
				Left = a,
				Right = (LiteralExpression)(uint)b,
				Operation = BinOps.Lsh
			};
		}

		public static BinOpExpression operator |(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Or
			};
		}

		public static BinOpExpression operator &(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.And
			};
		}

		public static BinOpExpression operator ^(Expression a, Expression b) {
			return new BinOpExpression {
				Left = a,
				Right = b,
				Operation = BinOps.Xor
			};
		}

		public static UnaryOpExpression operator ~(Expression val) {
			return new UnaryOpExpression {
				Value = val,
				Operation = UnaryOps.Not
			};
		}

		public static UnaryOpExpression operator -(Expression val) {
			return new UnaryOpExpression {
				Value = val,
				Operation = UnaryOps.Negate
			};
		}
	}
}
```

`Confuser.DynCipher/AST/LiteralExpression.cs`:

```cs
using System;

namespace Confuser.DynCipher.AST {
	public class LiteralExpression : Expression {
		public uint Value { get; set; }

		public static implicit operator LiteralExpression(uint val) {
			return new LiteralExpression { Value = val };
		}

		public override string ToString() {
			return Value.ToString("x8") + "h";
		}
	}
}
```

`Confuser.DynCipher/AST/LoopStatement.cs`:

```cs
using System;
using System.Text;

namespace Confuser.DynCipher.AST {
	// i.e. for loop
	public class LoopStatement : StatementBlock {
		public int Begin { get; set; }
		public int Limit { get; set; }

		public override string ToString() {
			var ret = new StringBuilder();
			ret.AppendFormat("for (int i = {0}; i < {1}; i++)", Begin, Limit);
			ret.AppendLine();
			ret.Append(base.ToString());
			return ret.ToString();
		}
	}
}
```

`Confuser.DynCipher/AST/Statement.cs`:

```cs
using System;

namespace Confuser.DynCipher.AST {
	public abstract class Statement {
		public object Tag { get; set; }
		public abstract override string ToString();
	}
}
```

`Confuser.DynCipher/AST/StatementBlock.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Confuser.DynCipher.AST {
	public class StatementBlock : Statement {
		public StatementBlock() {
			Statements = new List<Statement>();
		}

		public IList<Statement> Statements { get; private set; }

		public override string ToString() {
			var sb = new StringBuilder();
			sb.AppendLine("{");
			foreach (Statement i in Statements)
				sb.AppendLine(i.ToString());
			sb.AppendLine("}");
			return sb.ToString();
		}
	}
}
```

`Confuser.DynCipher/AST/UnaryOpExpression.cs`:

```cs
using System;

namespace Confuser.DynCipher.AST {
	public enum UnaryOps {
		Not,
		Negate
	}

	public class UnaryOpExpression : Expression {
		public Expression Value { get; set; }
		public UnaryOps Operation { get; set; }

		public override string ToString() {
			string op;
			switch (Operation) {
				case UnaryOps.Not:
					op = "~";
					break;
				case UnaryOps.Negate:
					op = "-";
					break;
				default:
					throw new Exception();
			}
			return op + Value;
		}
	}
}
```

`Confuser.DynCipher/AST/Variable.cs`:

```cs
using System;

namespace Confuser.DynCipher.AST {
	public class Variable {
		public Variable(string name) {
			Name = name;
		}

		public string Name { get; set; }
		public object Tag { get; set; }

		public override string ToString() {
			return Name;
		}
	}
}
```

`Confuser.DynCipher/AST/VariableExpression.cs`:

```cs
using System;

namespace Confuser.DynCipher.AST {
	public class VariableExpression : Expression {
		public Variable Variable { get; set; }

		public override string ToString() {
			return Variable.Name;
		}
	}
}
```

`Confuser.DynCipher/Confuser.DynCipher.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\ConfuserEx.Common.props" Condition="Exists('..\ConfuserEx.Common.props')" />

  <PropertyGroup Label="Assembly Settings">
    <TargetFrameworks>net461;netstandard2.0</TargetFrameworks>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>

  <PropertyGroup Label="Assembly Information">
    <Title>ConfuserEx Dynamic Cipher Library</Title>
    <Description>Cipher generator of ConfuserEx</Description>
  </PropertyGroup>

  <ItemGroup Label="Project Dependencies">
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj" />
  </ItemGroup>

  <Import Project="..\ConfuserEx.Common.targets" Condition="Exists('..\ConfuserEx.Common.targets')" />

</Project>
```

`Confuser.DynCipher/DynCipherComponent.cs`:

```cs
using System;
using Confuser.Core;

namespace Confuser.DynCipher {
	internal class DynCipherComponent : ConfuserComponent {
		public const string _ServiceId = "Confuser.DynCipher";

		public override string Name {
			get { return "Dynamic Cipher"; }
		}

		public override string Description {
			get { return "Provides dynamic cipher generation services."; }
		}

		public override string Id {
			get { return _ServiceId; }
		}

		public override string FullId {
			get { return _ServiceId; }
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IDynCipherService), new DynCipherService());
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			//
		}
	}
}
```

`Confuser.DynCipher/DynCipherService.cs`:

```cs
using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher {
	public interface IDynCipherService {
		void GenerateCipherPair(RandomGenerator random, out StatementBlock encrypt, out StatementBlock decrypt);
		void GenerateExpressionPair(RandomGenerator random, Expression var, Expression result, int depth, out Expression expression, out Expression inverse);
	}

	internal class DynCipherService : IDynCipherService {
		public void GenerateCipherPair(RandomGenerator random, out StatementBlock encrypt, out StatementBlock decrypt) {
			CipherGenerator.GeneratePair(random, out encrypt, out decrypt);
		}

		public void GenerateExpressionPair(RandomGenerator random, Expression var, Expression result, int depth, out Expression expression, out Expression inverse) {
			ExpressionGenerator.GeneratePair(random, var, result, depth, out expression, out inverse);
		}
	}
}
```

`Confuser.DynCipher/Elements/AddKey.cs`:

```cs
using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal class AddKey : CryptoElement {
		public AddKey(int index)
			: base(0) {
			Index = index;
		}

		public int Index { get; private set; }

		public override void Initialize(RandomGenerator random) { }

		void EmitCore(CipherGenContext context) {
			Expression val = context.GetDataExpression(Index);

			context.Emit(new AssignmentStatement {
				Value = val ^ context.GetKeyExpression(Index),
				Target = val
			});
		}

		public override void Emit(CipherGenContext context) {
			EmitCore(context);
		}

		public override void EmitInverse(CipherGenContext context) {
			EmitCore(context);
		}
	}
}
```

`Confuser.DynCipher/Elements/BinOp.cs`:

```cs
using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal enum CryptoBinOps {
		Add,
		Xor,
		Xnor
	}

	internal class BinOp : CryptoElement {
		public BinOp()
			: base(2) { }

		public CryptoBinOps Operation { get; private set; }

		public override void Initialize(RandomGenerator random) {
			Operation = (CryptoBinOps)random.NextInt32(3);
		}

		public override void Emit(CipherGenContext context) {
			Expression a = context.GetDataExpression(DataIndexes[0]);
			Expression b = context.GetDataExpression(DataIndexes[1]);
			switch (Operation) {
				case CryptoBinOps.Add:
					context.Emit(new AssignmentStatement {
						Value = a + b,
						Target = a
					});
					break;
				case CryptoBinOps.Xor:
					context.Emit(new AssignmentStatement {
						Value = a ^ b,
						Target = a
					});
					break;
				case CryptoBinOps.Xnor:
					context.Emit(new AssignmentStatement {
						Value = ~(a ^ b),
						Target = a
					});
					break;
			}
		}

		public override void EmitInverse(CipherGenContext context) {
			Expression a = context.GetDataExpression(DataIndexes[0]);
			Expression b = context.GetDataExpression(DataIndexes[1]);
			switch (Operation) {
				case CryptoBinOps.Add:
					context.Emit(new AssignmentStatement {
						Value = a - b,
						Target = a
					});
					break;
				case CryptoBinOps.Xor:
					context.Emit(new AssignmentStatement {
						Value = a ^ b,
						Target = a
					});
					break;
				case CryptoBinOps.Xnor:
					context.Emit(new AssignmentStatement {
						Value = a ^ (~b),
						Target = a
					});
					break;
			}
		}
	}
}
```

`Confuser.DynCipher/Elements/CryptoElement.cs`:

```cs
using System;
using Confuser.Core.Services;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal abstract class CryptoElement {
		public CryptoElement(int count) {
			DataCount = count;
			DataIndexes = new int[count];
		}

		public int DataCount { get; private set; }
		public int[] DataIndexes { get; private set; }

		public abstract void Initialize(RandomGenerator random);
		public abstract void Emit(CipherGenContext context);
		public abstract void EmitInverse(CipherGenContext context);
	}
}
```

`Confuser.DynCipher/Elements/Matrix.cs`:

```cs
using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal class Matrix : CryptoElement {
		public Matrix()
			: base(4) { }

		public uint[,] Key { get; private set; }
		public uint[,] InverseKey { get; private set; }

		static uint[,] GenerateUnimodularMatrix(RandomGenerator random) {
			Func<uint> next = () => (uint)random.NextInt32(4);

			uint[,] l = {
				{ 1, 0, 0, 0 },
				{ next(), 1, 0, 0 },
				{ next(), next(), 1, 0 },
				{ next(), next(), next(), 1 }
			};
			uint[,] u = {
				{ 1, next(), next(), next() },
				{ 0, 1, next(), next() },
				{ 0, 0, 1, next() },
				{ 0, 0, 0, 1 }
			};

			return mul(l, u);
		}

		static uint[,] mul(uint[,] a, uint[,] b) {
			int n = a.GetLength(0), p = b.GetLength(1);
			int m = a.GetLength(1);
			if (b.GetLength(0) != m) return null;

			var ret = new uint[n, p];
			for (int i = 0; i < n; i++)
				for (int j = 0; j < p; j++) {
					ret[i, j] = 0;
					for (int k = 0; k < m; k++)
						ret[i, j] += a[i, k] * b[k, j];
				}
			return ret;
		}

		static uint cofactor4(uint[,] mat, int i, int j) {
			var sub = new uint[3, 3];
			for (int ci = 0, si = 0; ci < 4; ci++, si++) {
				if (ci == i) {
					si--;
					continue;
				}
				for (int cj = 0, sj = 0; cj < 4; cj++, sj++) {
					if (cj == j) {
						sj--;
						continue;
					}
					sub[si, sj] = mat[ci, cj];
				}
			}
			uint ret = det3(sub);
			if ((i + j) % 2 == 0) return ret;
			return (uint)(-ret);
		}

		static uint det3(uint[,] mat) {
			return mat[0, 0] * mat[1, 1] * mat[2, 2] +
			       mat[0, 1] * mat[1, 2] * mat[2, 0] +
			       mat[0, 2] * mat[1, 0] * mat[2, 1] -
			       mat[0, 2] * mat[1, 1] * mat[2, 0] -
			       mat[0, 1] * mat[1, 0] * mat[2, 2] -
			       mat[0, 0] * mat[1, 2] * mat[2, 1];
		}

		static uint[,] transpose4(uint[,] mat) {
			var ret = new uint[4, 4];
			for (int i = 0; i < 4; i++)
				for (int j = 0; j < 4; j++)
					ret[j, i] = mat[i, j];
			return ret;
		}

		public override void Initialize(RandomGenerator random) {
			InverseKey = mul(transpose4(GenerateUnimodularMatrix(random)), GenerateUnimodularMatrix(random));

			var cof = new uint[4, 4];
			for (int i = 0; i < 4; i++)
				for (int j = 0; j < 4; j++)
					cof[i, j] = cofactor4(InverseKey, i, j);
			Key = transpose4(cof);
		}

		void EmitCore(CipherGenContext context, uint[,] k) {
			Expression a = context.GetDataExpression(DataIndexes[0]);
			Expression b = context.GetDataExpression(DataIndexes[1]);
			Expression c = context.GetDataExpression(DataIndexes[2]);
			Expression d = context.GetDataExpression(DataIndexes[3]);

			VariableExpression ta, tb, tc, td;

			Func<uint, LiteralExpression> l = v => (LiteralExpression)v;
			using (context.AcquireTempVar(out ta))
			using (context.AcquireTempVar(out tb))
			using (context.AcquireTempVar(out tc))
			using (context.AcquireTempVar(out td)) {
				context.Emit(new AssignmentStatement {
					Value = a * l(k[0, 0]) + b * l(k[0, 1]) + c * l(k[0, 2]) + d * l(k[0, 3]),
					Target = ta
				}).Emit(new AssignmentStatement {
					Value = a * l(k[1, 0]) + b * l(k[1, 1]) + c * l(k[1, 2]) + d * l(k[1, 3]),
					Target = tb
				}).Emit(new AssignmentStatement {
					Value = a * l(k[2, 0]) + b * l(k[2, 1]) + c * l(k[2, 2]) + d * l(k[2, 3]),
					Target = tc
				}).Emit(new AssignmentStatement {
					Value = a * l(k[3, 0]) + b * l(k[3, 1]) + c * l(k[3, 2]) + d * l(k[3, 3]),
					Target = td
				})
				       .Emit(new AssignmentStatement { Value = ta, Target = a })
				       .Emit(new AssignmentStatement { Value = tb, Target = b })
				       .Emit(new AssignmentStatement { Value = tc, Target = c })
				       .Emit(new AssignmentStatement { Value = td, Target = d });
			}
		}

		public override void Emit(CipherGenContext context) {
			EmitCore(context, Key);
		}

		public override void EmitInverse(CipherGenContext context) {
			EmitCore(context, InverseKey);
		}
	}
}
```

`Confuser.DynCipher/Elements/NumOp.cs`:

```cs
using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal enum CryptoNumOps {
		Add,
		Mul,
		Xor,
		Xnor
	}

	internal class NumOp : CryptoElement {
		public NumOp()
			: base(1) { }

		public uint Key { get; private set; }
		public uint InverseKey { get; private set; }
		public CryptoNumOps Operation { get; private set; }

		public override void Initialize(RandomGenerator random) {
			Operation = (CryptoNumOps)(random.NextInt32(4));
			switch (Operation) {
				case CryptoNumOps.Add:
				case CryptoNumOps.Xor:
					Key = InverseKey = random.NextUInt32();
					break;
				case CryptoNumOps.Mul:
					Key = random.NextUInt32() | 1;
					InverseKey = MathsUtils.modInv(Key);
					break;
				case CryptoNumOps.Xnor:
					Key = random.NextUInt32();
					InverseKey = ~Key;
					break;
			}
		}

		public override void Emit(CipherGenContext context) {
			Expression val = context.GetDataExpression(DataIndexes[0]);
			switch (Operation) {
				case CryptoNumOps.Add:
					context.Emit(new AssignmentStatement {
						Value = val + (LiteralExpression)Key,
						Target = val
					});
					break;
				case CryptoNumOps.Xor:
					context.Emit(new AssignmentStatement {
						Value = val ^ (LiteralExpression)Key,
						Target = val
					});
					break;
				case CryptoNumOps.Mul:
					context.Emit(new AssignmentStatement {
						Value = val * (LiteralExpression)Key,
						Target = val
					});
					break;
				case CryptoNumOps.Xnor:
					context.Emit(new AssignmentStatement {
						Value = ~(val ^ (LiteralExpression)Key),
						Target = val
					});
					break;
			}
		}

		public override void EmitInverse(CipherGenContext context) {
			Expression val = context.GetDataExpression(DataIndexes[0]);
			switch (Operation) {
				case CryptoNumOps.Add:
					context.Emit(new AssignmentStatement {
						Value = val - (LiteralExpression)InverseKey,
						Target = val
					});
					break;
				case CryptoNumOps.Xor:
					context.Emit(new AssignmentStatement {
						Value = val ^ (LiteralExpression)InverseKey,
						Target = val
					});
					break;
				case CryptoNumOps.Mul:
					context.Emit(new AssignmentStatement {
						Value = val * (LiteralExpression)InverseKey,
						Target = val
					});
					break;
				case CryptoNumOps.Xnor:
					context.Emit(new AssignmentStatement {
						Value = val ^ (LiteralExpression)InverseKey,
						Target = val
					});
					break;
			}
		}
	}
}
```

`Confuser.DynCipher/Elements/RotateBit.cs`:

```cs
using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal class RotateBit : CryptoElement {
		public RotateBit()
			: base(1) { }

		public int Bits { get; private set; }
		public bool IsAlternate { get; private set; }

		public override void Initialize(RandomGenerator random) {
			Bits = random.NextInt32(1, 32);
			IsAlternate = (random.NextInt32() % 2 == 0);
		}

		public override void Emit(CipherGenContext context) {
			Expression val = context.GetDataExpression(DataIndexes[0]);
			VariableExpression tmp;
			using (context.AcquireTempVar(out tmp)) {
				if (IsAlternate)
					context.Emit(new AssignmentStatement {
						Value = (val >> (32 - Bits)),
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (val << Bits) | tmp,
						Target = val
					});
				else
					context.Emit(new AssignmentStatement {
						Value = (val << (32 - Bits)),
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (val >> Bits) | tmp,
						Target = val
					});
			}
		}

		public override void EmitInverse(CipherGenContext context) {
			Expression val = context.GetDataExpression(DataIndexes[0]);
			VariableExpression tmp;
			using (context.AcquireTempVar(out tmp)) {
				if (IsAlternate)
					context.Emit(new AssignmentStatement {
						Value = (val << (32 - Bits)),
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (val >> Bits) | tmp,
						Target = val
					});
				else
					context.Emit(new AssignmentStatement {
						Value = (val >> (32 - Bits)),
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (val << Bits) | tmp,
						Target = val
					});
			}
		}
	}
}
```

`Confuser.DynCipher/Elements/Swap.cs`:

```cs
using System;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher.Elements {
	internal class Swap : CryptoElement {
		public Swap()
			: base(2) { }

		public uint Mask { get; private set; }
		public uint Key { get; private set; }

		public override void Initialize(RandomGenerator random) {
			if (random.NextInt32(3) == 0)
				Mask = 0xffffffff;
			else
				Mask = random.NextUInt32();
			Key = random.NextUInt32() | 1;
		}

		void EmitCore(CipherGenContext context) {
			Expression a = context.GetDataExpression(DataIndexes[0]);
			Expression b = context.GetDataExpression(DataIndexes[1]);
			VariableExpression tmp;

			if (Mask == 0xffffffff) {
				/*  t = a * k;
                    a = b;
                    b = t * k^-1;
                 */
				using (context.AcquireTempVar(out tmp)) {
					context.Emit(new AssignmentStatement {
						Value = a * (LiteralExpression)Key,
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = b,
						Target = a
					}).Emit(new AssignmentStatement {
						Value = tmp * (LiteralExpression)MathsUtils.modInv(Key),
						Target = b
					});
				}
			}
			else {
				var mask = (LiteralExpression)Mask;
				var notMask = (LiteralExpression)~Mask;
				/*  t = (a & mask) * k;
                    a = a & (~mask) | (b & mask);
                    b = b & (~mask) | (t * k^-1);
                 */
				using (context.AcquireTempVar(out tmp)) {
					context.Emit(new AssignmentStatement {
						Value = (a & mask) * (LiteralExpression)Key,
						Target = tmp
					}).Emit(new AssignmentStatement {
						Value = (a & notMask) | (b & mask),
						Target = a
					}).Emit(new AssignmentStatement {
						Value = (b & notMask) | (tmp * (LiteralExpression)MathsUtils.modInv(Key)),
						Target = b
					});
				}
			}
		}

		public override void Emit(CipherGenContext context) {
			EmitCore(context);
		}

		public override void EmitInverse(CipherGenContext context) {
			EmitCore(context);
		}
	}
}
```

`Confuser.DynCipher/Generation/CILCodeGen.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.DynCipher.AST;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.DynCipher.Generation {
	public class CILCodeGen {
		readonly Dictionary<string, Local> localMap = new Dictionary<string, Local>();

		public CILCodeGen(MethodDef method, IList<Instruction> instrs) {
			Method = method;
			Instructions = instrs;
		}

		public MethodDef Method { get; private set; }
		public IList<Instruction> Instructions { get; private set; }

		protected void Emit(Instruction instr) {
			Instructions.Add(instr);
		}

		protected virtual Local Var(Variable var) {
			Local ret;
			if (!localMap.TryGetValue(var.Name, out ret)) {
				ret = new Local(Method.Module.CorLibTypes.UInt32);
				ret.Name = var.Name;
				localMap[var.Name] = ret;
			}
			return ret;
		}

		protected virtual void LoadVar(Variable var) {
			Emit(Instruction.Create(OpCodes.Ldloc, Var(var)));
		}

		protected virtual void StoreVar(Variable var) {
			Emit(Instruction.Create(OpCodes.Stloc, Var(var)));
		}

		public void Commit(CilBody body) {
			foreach (Local i in localMap.Values) {
				body.InitLocals = true;
				body.Variables.Add(i);
			}
		}


		public void GenerateCIL(Expression expression) {
			EmitLoad(expression);
		}

		public void GenerateCIL(Statement statement) {
			EmitStatement(statement);
		}

		void EmitLoad(Expression exp) {
			if (exp is ArrayIndexExpression) {
				var arrIndex = (ArrayIndexExpression)exp;
				EmitLoad(arrIndex.Array);
				Emit(Instruction.CreateLdcI4(arrIndex.Index));
				Emit(Instruction.Create(OpCodes.Ldelem_U4));
			}
			else if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				EmitLoad(binOp.Left);
				EmitLoad(binOp.Right);
				OpCode op;
				switch (binOp.Operation) {
					case BinOps.Add:
						op = OpCodes.Add;
						break;
					case BinOps.Sub:
						op = OpCodes.Sub;
						break;
					case BinOps.Div:
						op = OpCodes.Div;
						break;
					case BinOps.Mul:
						op = OpCodes.Mul;
						break;
					case BinOps.Or:
						op = OpCodes.Or;
						break;
					case BinOps.And:
						op = OpCodes.And;
						break;
					case BinOps.Xor:
						op = OpCodes.Xor;
						break;
					case BinOps.Lsh:
						op = OpCodes.Shl;
						break;
					case BinOps.Rsh:
						op = OpCodes.Shr_Un;
						break;
					default:
						throw new NotSupportedException();
				}
				Emit(Instruction.Create(op));
			}
			else if (exp is UnaryOpExpression) {
				var unaryOp = (UnaryOpExpression)exp;
				EmitLoad(unaryOp.Value);
				OpCode op;
				switch (unaryOp.Operation) {
					case UnaryOps.Not:
						op = OpCodes.Not;
						break;
					case UnaryOps.Negate:
						op = OpCodes.Neg;
						break;
					default:
						throw new NotSupportedException();
				}
				Emit(Instruction.Create(op));
			}
			else if (exp is LiteralExpression) {
				var literal = (LiteralExpression)exp;
				Emit(Instruction.CreateLdcI4((int)literal.Value));
			}
			else if (exp is VariableExpression) {
				var var = (VariableExpression)exp;
				LoadVar(var.Variable);
			}
			else
				throw new NotSupportedException();
		}

		void EmitStore(Expression exp, Expression value) {
			if (exp is ArrayIndexExpression) {
				var arrIndex = (ArrayIndexExpression)exp;
				EmitLoad(arrIndex.Array);
				Emit(Instruction.CreateLdcI4(arrIndex.Index));
				EmitLoad(value);
				Emit(Instruction.Create(OpCodes.Stelem_I4));
			}
			else if (exp is VariableExpression) {
				var var = (VariableExpression)exp;
				EmitLoad(value);
				StoreVar(var.Variable);
			}
			else
				throw new NotSupportedException();
		}

		void EmitStatement(Statement statement) {
			if (statement is AssignmentStatement) {
				var assignment = (AssignmentStatement)statement;
				EmitStore(assignment.Target, assignment.Value);
			}
			else if (statement is LoopStatement) {
				var loop = (LoopStatement)statement;
				/*
                 *      ldc.i4  begin
                 *      br      cmp
                 *      ldc.i4  dummy   //hint for dnlib
                 * lop: nop
                 *      ...
                 *      ...
                 *      ldc.i4.1
                 *      add
                 * cmp: dup
                 *      ldc.i4  limit
                 *      blt     lop
                 *      pop
                 */
				Instruction lbl = Instruction.Create(OpCodes.Nop);
				Instruction dup = Instruction.Create(OpCodes.Dup);
				Emit(Instruction.CreateLdcI4(loop.Begin));
				Emit(Instruction.Create(OpCodes.Br, dup));
				Emit(Instruction.CreateLdcI4(loop.Begin));
				Emit(lbl);

				foreach (Statement child in loop.Statements)
					EmitStatement(child);

				Emit(Instruction.CreateLdcI4(1));
				Emit(Instruction.Create(OpCodes.Add));
				Emit(dup);
				Emit(Instruction.CreateLdcI4(loop.Limit));
				Emit(Instruction.Create(OpCodes.Blt, lbl));
				Emit(Instruction.Create(OpCodes.Pop));
			}
			else if (statement is StatementBlock) {
				foreach (Statement child in ((StatementBlock)statement).Statements)
					EmitStatement(child);
			}
			else
				throw new NotSupportedException();
		}
	}
}
```

`Confuser.DynCipher/Generation/CipherGenContext.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Generation {
	internal class CipherGenContext {
		readonly Variable[] dataVars;
		readonly Variable keyVar = new Variable("{KEY}");
		readonly RandomGenerator random;
		readonly List<Variable> tempVars = new List<Variable>();
		int tempVarCounter;

		public CipherGenContext(RandomGenerator random, int dataVarCount) {
			this.random = random;
			Block = new StatementBlock(); // new LoopStatement() { Begin = 0, Limit = 4 };
			dataVars = new Variable[dataVarCount];
			for (int i = 0; i < dataVarCount; i++)
				dataVars[i] = new Variable("v" + i) { Tag = i };
		}

		public StatementBlock Block { get; private set; }

		public Expression GetDataExpression(int index) {
			return new VariableExpression { Variable = dataVars[index] };
		}

		public Expression GetKeyExpression(int index) {
			return new ArrayIndexExpression {
				Array = new VariableExpression { Variable = keyVar },
				Index = index
			};
		}

		public CipherGenContext Emit(Statement statement) {
			Block.Statements.Add(statement);
			return this;
		}

		public IDisposable AcquireTempVar(out VariableExpression exp) {
			Variable var;
			if (tempVars.Count == 0)
				var = new Variable("t" + tempVarCounter++);
			else {
				var = tempVars[random.NextInt32(tempVars.Count)];
				tempVars.Remove(var);
			}
			exp = new VariableExpression { Variable = var };
			return new TempVarHolder(this, var);
		}

		struct TempVarHolder : IDisposable {
			readonly CipherGenContext parent;
			readonly Variable tempVar;

			public TempVarHolder(CipherGenContext p, Variable v) {
				parent = p;
				tempVar = v;
			}

			public void Dispose() {
				parent.tempVars.Add(tempVar);
			}
		}
	}
}
```

`Confuser.DynCipher/Generation/CipherGenerator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Elements;
using Confuser.DynCipher.Transforms;

namespace Confuser.DynCipher.Generation {
	internal class CipherGenerator {
		const int MAT_RATIO = 4;
		const int NUMOP_RATIO = 10;
		const int SWAP_RATIO = 6;
		const int BINOP_RATIO = 9;
		const int ROTATE_RATIO = 6;
		const int RATIO_SUM = MAT_RATIO + NUMOP_RATIO + SWAP_RATIO + BINOP_RATIO + ROTATE_RATIO;
		const double VARIANCE = 0.2;


		static void Shuffle<T>(RandomGenerator random, IList<T> arr) {
			for (int i = 1; i < arr.Count; i++) {
				int j = random.NextInt32(i + 1);
				T tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
			}
		}

		static void PostProcessStatements(StatementBlock block, RandomGenerator random) {
			MulToShiftTransform.Run(block);
			NormalizeBinOpTransform.Run(block);
			ExpansionTransform.Run(block);
			ShuffleTransform.Run(block, random);
			ConvertVariables.Run(block);
		}

		public static void GeneratePair(RandomGenerator random, out StatementBlock encrypt, out StatementBlock decrypt) {
			double varPrecentage = 1 + ((random.NextDouble() * 2) - 1) * VARIANCE;
			var totalElements = (int)(((random.NextDouble() + 1) * RATIO_SUM) * varPrecentage);

			var elems = new List<CryptoElement>();
			for (int i = 0; i < totalElements * MAT_RATIO / RATIO_SUM; i++)
				elems.Add(new Matrix());
			for (int i = 0; i < totalElements * NUMOP_RATIO / RATIO_SUM; i++)
				elems.Add(new NumOp());
			for (int i = 0; i < totalElements * SWAP_RATIO / RATIO_SUM; i++)
				elems.Add(new Swap());
			for (int i = 0; i < totalElements * BINOP_RATIO / RATIO_SUM; i++)
				elems.Add(new BinOp());
			for (int i = 0; i < totalElements * ROTATE_RATIO / RATIO_SUM; i++)
				elems.Add(new RotateBit());
			for (int i = 0; i < 16; i++)
				elems.Add(new AddKey(i));
			Shuffle(random, elems);


			int[] x = Enumerable.Range(0, 16).ToArray();
			int index = 16;
			bool overdue = false;
			foreach (CryptoElement elem in elems) {
				elem.Initialize(random);
				for (int i = 0; i < elem.DataCount; i++) {
					if (index == 16) {
						overdue = true; // Can't shuffle now to prevent duplication
						index = 0;
					}
					elem.DataIndexes[i] = x[index++];
				}
				if (overdue) {
					Shuffle(random, x);
					index = 0;
					overdue = false;
				}
			}

			var encryptContext = new CipherGenContext(random, 16);
			foreach (CryptoElement elem in elems)
				elem.Emit(encryptContext);
			encrypt = encryptContext.Block;
			PostProcessStatements(encrypt, random);


			var decryptContext = new CipherGenContext(random, 16);
			foreach (CryptoElement elem in Enumerable.Reverse(elems))
				elem.EmitInverse(decryptContext);
			decrypt = decryptContext.Block;
			PostProcessStatements(decrypt, random);
		}
	}
}
```

`Confuser.DynCipher/Generation/DMCodeGen.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Emit;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Generation {
	public class DMCodeGen {
		readonly DynamicMethod dm;
		readonly ILGenerator ilGen;

		readonly Dictionary<string, LocalBuilder> localMap = new Dictionary<string, LocalBuilder>();
		readonly Dictionary<string, int> paramMap;

		public DMCodeGen(Type returnType, Tuple<string, Type>[] parameters) {
			dm = new DynamicMethod("", returnType, parameters.Select(param => param.Item2).ToArray(), true);
			paramMap = new Dictionary<string, int>();
			for (int i = 0; i < parameters.Length; i++)
				paramMap.Add(parameters[i].Item1, i);
			ilGen = dm.GetILGenerator();
		}

		protected virtual LocalBuilder Var(Variable var) {
			LocalBuilder ret;
			if (!localMap.TryGetValue(var.Name, out ret)) {
				ret = ilGen.DeclareLocal(typeof(int));
				localMap[var.Name] = ret;
			}
			return ret;
		}

		protected virtual void LoadVar(Variable var) {
			if (paramMap.ContainsKey(var.Name))
				ilGen.Emit(OpCodes.Ldarg, paramMap[var.Name]);
			else
				ilGen.Emit(OpCodes.Ldloc, Var(var));
		}

		protected virtual void StoreVar(Variable var) {
			if (paramMap.ContainsKey(var.Name))
				ilGen.Emit(OpCodes.Starg, paramMap[var.Name]);
			else
				ilGen.Emit(OpCodes.Stloc, Var(var));
		}

		public T Compile<T>() {
			ilGen.Emit(OpCodes.Ret);
			return (T)(object)dm.CreateDelegate(typeof(T));
		}


		public DMCodeGen GenerateCIL(Expression expression) {
			EmitLoad(expression);
			return this;
		}

		public DMCodeGen GenerateCIL(Statement statement) {
			EmitStatement(statement);
			return this;
		}

		void EmitLoad(Expression exp) {
			if (exp is ArrayIndexExpression) {
				var arrIndex = (ArrayIndexExpression)exp;
				EmitLoad(arrIndex.Array);
				ilGen.Emit(OpCodes.Ldc_I4, arrIndex.Index);
				ilGen.Emit(OpCodes.Ldelem_U4);
			}
			else if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				EmitLoad(binOp.Left);
				EmitLoad(binOp.Right);
				OpCode op;
				switch (binOp.Operation) {
					case BinOps.Add:
						op = OpCodes.Add;
						break;
					case BinOps.Sub:
						op = OpCodes.Sub;
						break;
					case BinOps.Div:
						op = OpCodes.Div;
						break;
					case BinOps.Mul:
						op = OpCodes.Mul;
						break;
					case BinOps.Or:
						op = OpCodes.Or;
						break;
					case BinOps.And:
						op = OpCodes.And;
						break;
					case BinOps.Xor:
						op = OpCodes.Xor;
						break;
					case BinOps.Lsh:
						op = OpCodes.Shl;
						break;
					case BinOps.Rsh:
						op = OpCodes.Shr_Un;
						break;
					default:
						throw new NotSupportedException();
				}
				ilGen.Emit(op);
			}
			else if (exp is UnaryOpExpression) {
				var unaryOp = (UnaryOpExpression)exp;
				EmitLoad(unaryOp.Value);
				OpCode op;
				switch (unaryOp.Operation) {
					case UnaryOps.Not:
						op = OpCodes.Not;
						break;
					case UnaryOps.Negate:
						op = OpCodes.Neg;
						break;
					default:
						throw new NotSupportedException();
				}
				ilGen.Emit(op);
			}
			else if (exp is LiteralExpression) {
				var literal = (LiteralExpression)exp;
				ilGen.Emit(OpCodes.Ldc_I4, (int)literal.Value);
			}
			else if (exp is VariableExpression) {
				var var = (VariableExpression)exp;
				LoadVar(var.Variable);
			}
			else
				throw new NotSupportedException();
		}

		void EmitStore(Expression exp, Expression value) {
			if (exp is ArrayIndexExpression) {
				var arrIndex = (ArrayIndexExpression)exp;
				EmitLoad(arrIndex.Array);
				ilGen.Emit(OpCodes.Ldc_I4, arrIndex.Index);
				EmitLoad(value);
				ilGen.Emit(OpCodes.Stelem_I4);
			}
			else if (exp is VariableExpression) {
				var var = (VariableExpression)exp;
				EmitLoad(value);
				StoreVar(var.Variable);
			}
			else
				throw new NotSupportedException();
		}

		void EmitStatement(Statement statement) {
			if (statement is AssignmentStatement) {
				var assignment = (AssignmentStatement)statement;
				EmitStore(assignment.Target, assignment.Value);
			}
			else if (statement is LoopStatement) {
				var loop = (LoopStatement)statement;
				/*
                 *      ldc.i4  begin
                 *      br      cmp
                 *      ldc.i4  dummy   //hint for dnlib
                 * lop: nop
                 *      ...
                 *      ...
                 *      ldc.i4.1
                 *      add
                 * cmp: dup
                 *      ldc.i4  limit
                 *      blt     lop
                 *      pop
                 */
				Label lbl = ilGen.DefineLabel();
				Label dup = ilGen.DefineLabel();
				ilGen.Emit(OpCodes.Ldc_I4, loop.Begin);
				ilGen.Emit(OpCodes.Br, dup);
				ilGen.Emit(OpCodes.Ldc_I4, loop.Begin);
				ilGen.MarkLabel(lbl);

				foreach (Statement child in loop.Statements)
					EmitStatement(child);

				ilGen.Emit(OpCodes.Ldc_I4_1);
				ilGen.Emit(OpCodes.Add);
				ilGen.MarkLabel(dup);
				ilGen.Emit(OpCodes.Dup);
				ilGen.Emit(OpCodes.Ldc_I4, loop.Limit);
				ilGen.Emit(OpCodes.Blt, lbl);
				ilGen.Emit(OpCodes.Pop);
			}
			else if (statement is StatementBlock) {
				foreach (Statement child in ((StatementBlock)statement).Statements)
					EmitStatement(child);
			}
			else
				throw new NotSupportedException();
		}
	}
}
```

`Confuser.DynCipher/Generation/ExpressionGenerator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Generation {
	internal class ExpressionGenerator {
		static Expression GenerateExpression(RandomGenerator random, Expression current, int currentDepth, int targetDepth) {
			if (currentDepth == targetDepth || (currentDepth > targetDepth / 3 && random.NextInt32(100) > 85))
				return current;

			switch ((ExpressionOps)random.NextInt32(6)) {
				case ExpressionOps.Add:
					return GenerateExpression(random, current, currentDepth + 1, targetDepth) +
					       GenerateExpression(random, (LiteralExpression)random.NextUInt32(), currentDepth + 1, targetDepth);

				case ExpressionOps.Sub:
					return GenerateExpression(random, current, currentDepth + 1, targetDepth) -
					       GenerateExpression(random, (LiteralExpression)random.NextUInt32(), currentDepth + 1, targetDepth);

				case ExpressionOps.Mul:
					return GenerateExpression(random, current, currentDepth + 1, targetDepth) * (LiteralExpression)(random.NextUInt32() | 1);

				case ExpressionOps.Xor:
					return GenerateExpression(random, current, currentDepth + 1, targetDepth) ^
					       GenerateExpression(random, (LiteralExpression)random.NextUInt32(), currentDepth + 1, targetDepth);

				case ExpressionOps.Not:
					return ~GenerateExpression(random, current, currentDepth + 1, targetDepth);

				case ExpressionOps.Neg:
					return -GenerateExpression(random, current, currentDepth + 1, targetDepth);
			}
			throw new UnreachableException();
		}

		static void SwapOperands(RandomGenerator random, Expression exp) {
			if (exp is BinOpExpression) {
				var binExp = (BinOpExpression)exp;
				if (random.NextBoolean()) {
					Expression tmp = binExp.Left;
					binExp.Left = binExp.Right;
					binExp.Right = tmp;
				}
				SwapOperands(random, binExp.Left);
				SwapOperands(random, binExp.Right);
			}
			else if (exp is UnaryOpExpression)
				SwapOperands(random, ((UnaryOpExpression)exp).Value);
			else if (exp is LiteralExpression || exp is VariableExpression)
				return;
			else
				throw new UnreachableException();
		}

		static bool HasVariable(Expression exp, Dictionary<Expression, bool> hasVar) {
			bool ret;
			if (!hasVar.TryGetValue(exp, out ret)) {
				if (exp is VariableExpression)
					ret = true;
				else if (exp is LiteralExpression)
					ret = false;
				else if (exp is BinOpExpression) {
					var binExp = (BinOpExpression)exp;
					ret = HasVariable(binExp.Left, hasVar) || HasVariable(binExp.Right, hasVar);
				}
				else if (exp is UnaryOpExpression) {
					ret = HasVariable(((UnaryOpExpression)exp).Value, hasVar);
				}
				else
					throw new UnreachableException();
				hasVar[exp] = ret;
			}
			return ret;
		}

		static Expression GenerateInverse(Expression exp, Expression var, Dictionary<Expression, bool> hasVar) {
			Expression result = var;
			while (!(exp is VariableExpression)) {
				Debug.Assert(hasVar[exp]);
				if (exp is UnaryOpExpression) {
					var unaryOp = (UnaryOpExpression)exp;
					result = new UnaryOpExpression {
						Operation = unaryOp.Operation,
						Value = result
					};
					exp = unaryOp.Value;
				}
				else if (exp is BinOpExpression) {
					var binOp = (BinOpExpression)exp;
					bool leftHasVar = hasVar[binOp.Left];
					Expression varExp = leftHasVar ? binOp.Left : binOp.Right;
					Expression constExp = leftHasVar ? binOp.Right : binOp.Left;

					if (binOp.Operation == BinOps.Add)
						result = new BinOpExpression {
							Operation = BinOps.Sub,
							Left = result,
							Right = constExp
						};

					else if (binOp.Operation == BinOps.Sub) {
						if (leftHasVar) {
							// v - k = r => v = r + k
							result = new BinOpExpression {
								Operation = BinOps.Add,
								Left = result,
								Right = constExp
							};
						}
						else {
							// k - v = r => v = k - r
							result = new BinOpExpression {
								Operation = BinOps.Sub,
								Left = constExp,
								Right = result
							};
						}
					}
					else if (binOp.Operation == BinOps.Mul) {
						Debug.Assert(constExp is LiteralExpression);
						uint val = ((LiteralExpression)constExp).Value;
						val = MathsUtils.modInv(val);
						result = new BinOpExpression {
							Operation = BinOps.Mul,
							Left = result,
							Right = (LiteralExpression)val
						};
					}
					else if (binOp.Operation == BinOps.Xor)
						result = new BinOpExpression {
							Operation = BinOps.Xor,
							Left = result,
							Right = constExp
						};

					exp = varExp;
				}
			}
			return result;
		}

		public static void GeneratePair(RandomGenerator random, Expression var, Expression result, int depth, out Expression expression, out Expression inverse) {
			expression = GenerateExpression(random, var, 0, depth);
			SwapOperands(random, expression);

			var hasVar = new Dictionary<Expression, bool>();
			HasVariable(expression, hasVar);

			inverse = GenerateInverse(expression, result, hasVar);
		}

		enum ExpressionOps {
			Add,
			Sub,
			Mul,
			Xor,
			Not,
			Neg
		}
	}
}
```

`Confuser.DynCipher/Generation/x86CodeGen.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Generation {
	public class x86CodeGen {
		List<x86Instruction> instrs;
		bool[] usedRegs;

		public IList<x86Instruction> Instructions {
			get { return instrs; }
		}

		public int MaxUsedRegister { get; private set; }

		public x86Register? GenerateX86(Expression expression, Func<Variable, x86Register, IEnumerable<x86Instruction>> loadArg) {
			instrs = new List<x86Instruction>();
			usedRegs = new bool[8];
			MaxUsedRegister = -1;

			// CRITICAL registers!
			usedRegs[(int)x86Register.EBP] = true;
			usedRegs[(int)x86Register.ESP] = true;

			try {
				return ((x86RegisterOperand)Emit(expression, loadArg)).Register;
			}
			catch (Exception ex) {
				if (ex.Message == "Register overflowed.")
					return null;
				throw;
			}
		}

		x86Register GetFreeRegister() {
			for (int i = 0; i < 8; i++)
				if (!usedRegs[i])
					return (x86Register)i;

			throw new Exception("Register overflowed.");
		}

		void TakeRegister(x86Register reg) {
			usedRegs[(int)reg] = true;
			if ((int)reg > MaxUsedRegister)
				MaxUsedRegister = (int)reg;
		}

		void ReleaseRegister(x86Register reg) {
			usedRegs[(int)reg] = false;
		}

		x86Register Normalize(x86Instruction instr) {
			if (instr.Operands.Length == 2 &&
			    instr.Operands[0] is x86ImmediateOperand &&
			    instr.Operands[1] is x86ImmediateOperand) {
				/*
                 * op imm1, imm2
                 * ==>
                 * mov reg, imm1
                 * op reg, imm2
                 */
				x86Register reg = GetFreeRegister();
				instrs.Add(x86Instruction.Create(x86OpCode.MOV, new x86RegisterOperand(reg), instr.Operands[0]));
				instr.Operands[0] = new x86RegisterOperand(reg);
				instrs.Add(instr);

				return reg;
			}

			if (instr.Operands.Length == 1 &&
			    instr.Operands[0] is x86ImmediateOperand) {
				/*
                 * op imm
                 * ==>
                 * mov reg, imm
                 * op reg
                 */
				x86Register reg = GetFreeRegister();
				instrs.Add(x86Instruction.Create(x86OpCode.MOV, new x86RegisterOperand(reg), instr.Operands[0]));
				instr.Operands[0] = new x86RegisterOperand(reg);
				instrs.Add(instr);

				return reg;
			}

			if (instr.OpCode == x86OpCode.SUB &&
			    instr.Operands[0] is x86ImmediateOperand &&
			    instr.Operands[1] is x86RegisterOperand) {
				/*
                 * sub imm, reg
                 * ==>
                 * neg reg
                 * add reg, imm
                 */

				x86Register reg = ((x86RegisterOperand)instr.Operands[1]).Register;
				instrs.Add(x86Instruction.Create(x86OpCode.NEG, new x86RegisterOperand(reg)));
				instr.OpCode = x86OpCode.ADD;
				instr.Operands[1] = instr.Operands[0];
				instr.Operands[0] = new x86RegisterOperand(reg);
				instrs.Add(instr);

				return reg;
			}

			if (instr.Operands.Length == 2 &&
			    instr.Operands[0] is x86ImmediateOperand &&
			    instr.Operands[1] is x86RegisterOperand) {
				/*
                 * op imm, reg
                 * ==>
                 * op reg, imm
                 */

				x86Register reg = ((x86RegisterOperand)instr.Operands[1]).Register;
				instr.Operands[1] = instr.Operands[0];
				instr.Operands[0] = new x86RegisterOperand(reg);
				instrs.Add(instr);

				return reg;
			}
			Debug.Assert(instr.Operands.Length > 0);
			Debug.Assert(instr.Operands[0] is x86RegisterOperand);

			if (instr.Operands.Length == 2 && instr.Operands[1] is x86RegisterOperand)
				ReleaseRegister(((x86RegisterOperand)instr.Operands[1]).Register);

			instrs.Add(instr);

			return ((x86RegisterOperand)instr.Operands[0]).Register;
		}

		Ix86Operand Emit(Expression exp, Func<Variable, x86Register, IEnumerable<x86Instruction>> loadArg) {
			if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				x86Register reg;
				switch (binOp.Operation) {
					case BinOps.Add:
						reg = Normalize(x86Instruction.Create(x86OpCode.ADD, Emit(binOp.Left, loadArg), Emit(binOp.Right, loadArg)));
						break;

					case BinOps.Sub:
						reg = Normalize(x86Instruction.Create(x86OpCode.SUB, Emit(binOp.Left, loadArg), Emit(binOp.Right, loadArg)));
						break;

					case BinOps.Mul:
						reg = Normalize(x86Instruction.Create(x86OpCode.IMUL, Emit(binOp.Left, loadArg), Emit(binOp.Right, loadArg)));
						break;

					case BinOps.Xor:
						reg = Normalize(x86Instruction.Create(x86OpCode.XOR, Emit(binOp.Left, loadArg), Emit(binOp.Right, loadArg)));
						break;

					default:
						throw new NotSupportedException();
				}
				TakeRegister(reg);
				return new x86RegisterOperand(reg);
			}

			if (exp is UnaryOpExpression) {
				var unaryOp = (UnaryOpExpression)exp;
				x86Register reg;
				switch (unaryOp.Operation) {
					case UnaryOps.Negate:
						reg = Normalize(x86Instruction.Create(x86OpCode.NEG, Emit(unaryOp.Value, loadArg)));
						break;

					case UnaryOps.Not:
						reg = Normalize(x86Instruction.Create(x86OpCode.NOT, Emit(unaryOp.Value, loadArg)));
						break;

					default:
						throw new NotSupportedException();
				}
				TakeRegister(reg);
				return new x86RegisterOperand(reg);
			}

			if (exp is LiteralExpression)
				return new x86ImmediateOperand((int)((LiteralExpression)exp).Value);

			if (exp is VariableExpression) {
				x86Register reg = GetFreeRegister();
				TakeRegister(reg);
				instrs.AddRange(loadArg(((VariableExpression)exp).Variable, reg));
				return new x86RegisterOperand(reg);
			}

			throw new NotSupportedException();
		}

		public override string ToString() {
			return string.Join("\r\n", instrs.Select(instr => instr.ToString()).ToArray());
		}
	}

	public enum x86OpCode {
		MOV,
		ADD,
		SUB,
		IMUL,
		DIV,
		NEG,
		NOT,
		XOR,
		POP
	}

	public enum x86Register {
		EAX,
		ECX,
		EDX,
		EBX,
		ESP,
		EBP,
		ESI,
		EDI
	}

	public interface Ix86Operand { }

	public class x86RegisterOperand : Ix86Operand {
		public x86RegisterOperand(x86Register reg) {
			Register = reg;
		}

		public x86Register Register { get; set; }

		public override string ToString() {
			return Register.ToString();
		}
	}

	public class x86ImmediateOperand : Ix86Operand {
		public x86ImmediateOperand(int imm) {
			Immediate = imm;
		}

		public int Immediate { get; set; }

		public override string ToString() {
			return Immediate.ToString("X") + "h";
		}
	}

	public class x86Instruction {
		public x86OpCode OpCode { get; set; }
		public Ix86Operand[] Operands { get; set; }

		public static x86Instruction Create(x86OpCode opCode, params Ix86Operand[] operands) {
			var ret = new x86Instruction();
			ret.OpCode = opCode;
			ret.Operands = operands;
			return ret;
		}

		public byte[] Assemble() {
			switch (OpCode) {
				case x86OpCode.MOV: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0x89;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[5];
						ret[0] = 0xb8;
						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 1, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.ADD: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0x01;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[6];
						ret[0] = 0x81;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 2, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.SUB: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0x29;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[6];
						ret[0] = 0x81;
						ret[1] = 0xe8;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 2, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.NEG: {
					if (Operands.Length != 1) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0xf7;
						ret[1] = 0xd8;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.NOT: {
					if (Operands.Length != 1) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0xf7;
						ret[1] = 0xd0;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.XOR: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[2];
						ret[0] = 0x31;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[6];
						ret[0] = 0x81;
						ret[1] = 0xf0;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 2, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.POP: {
					if (Operands.Length != 1) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand) {
						var ret = new byte[1];
						ret[0] = 0x58;
						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					throw new NotSupportedException();
				}

				case x86OpCode.IMUL: {
					if (Operands.Length != 2) throw new InvalidOperationException();
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86RegisterOperand) {
						var ret = new byte[3];
						ret[0] = 0x0f;
						ret[1] = 0xaf;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						return ret;
					}
					if (Operands[0] is x86RegisterOperand &&
					    Operands[1] is x86ImmediateOperand) {
						var ret = new byte[6];
						ret[0] = 0x69;
						ret[1] = 0xc0;
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);
						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);
						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate), 0, ret, 2, 4);
						return ret;
					}
					throw new NotSupportedException();
				}

				default:
					throw new NotSupportedException();
			}
		}

		public override string ToString() {
			var ret = new StringBuilder();
			ret.Append(OpCode);
			for (int i = 0; i < Operands.Length; i++) {
				ret.AppendFormat("{0}{1}", i == 0 ? " " : ", ", Operands[i]);
			}
			return ret.ToString();
		}
	}
}
```

`Confuser.DynCipher/Transforms/ConvertVariables.cs`:

```cs
using System;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class ConvertVariables {
		static Expression ReplaceVar(Expression exp, Variable buff) {
			if (exp is VariableExpression) {
				if (((VariableExpression)exp).Variable.Name[0] != 'v') return exp;
				return new ArrayIndexExpression {
					Array = new VariableExpression { Variable = buff },
					Index = (int)(exp as VariableExpression).Variable.Tag
				};
			}
			if (exp is ArrayIndexExpression) {
				((ArrayIndexExpression)exp).Array = ReplaceVar(((ArrayIndexExpression)exp).Array, buff);
			}
			else if (exp is BinOpExpression) {
				((BinOpExpression)exp).Left = ReplaceVar(((BinOpExpression)exp).Left, buff);
				((BinOpExpression)exp).Right = ReplaceVar(((BinOpExpression)exp).Right, buff);
			}
			else if (exp is UnaryOpExpression) {
				((UnaryOpExpression)exp).Value = ReplaceVar(((UnaryOpExpression)exp).Value, buff);
			}
			return exp;
		}

		static Statement ReplaceVar(Statement st, Variable buff) {
			if (st is AssignmentStatement) {
				((AssignmentStatement)st).Value = ReplaceVar(((AssignmentStatement)st).Value, buff);
				((AssignmentStatement)st).Target = ReplaceVar(((AssignmentStatement)st).Target, buff);
			}
			return st;
		}

		public static void Run(StatementBlock block) {
			var mainBuff = new Variable("{BUFFER}");
			for (int i = 0; i < block.Statements.Count; i++)
				block.Statements[i] = ReplaceVar(block.Statements[i], mainBuff);
		}
	}
}
```

`Confuser.DynCipher/Transforms/ExpansionTransform.cs`:

```cs
using System;
using System.Linq;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class ExpansionTransform {
		static bool ProcessStatement(Statement st, StatementBlock block) {
			if (st is AssignmentStatement) {
				var assign = (AssignmentStatement)st;
				if (assign.Value is BinOpExpression) {
					var exp = (BinOpExpression)assign.Value;
					if ((exp.Left is BinOpExpression || exp.Right is BinOpExpression) &&
					    exp.Left != assign.Target) {
						block.Statements.Add(new AssignmentStatement {
							Target = assign.Target,
							Value = exp.Left
						});
						block.Statements.Add(new AssignmentStatement {
							Target = assign.Target,
							Value = new BinOpExpression {
								Left = assign.Target,
								Operation = exp.Operation,
								Right = exp.Right
							}
						});
						return true;
					}
				}
			}
			block.Statements.Add(st);
			return false;
		}

		public static void Run(StatementBlock block) {
			bool workDone;
			do {
				workDone = false;
				Statement[] copy = block.Statements.ToArray();
				block.Statements.Clear();
				foreach (Statement st in copy)
					workDone |= ProcessStatement(st, block);
			} while (workDone);
		}
	}
}
```

`Confuser.DynCipher/Transforms/MulToShiftTransform.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class MulToShiftTransform {
		static uint NumberOfSetBits(uint i) {
			i = i - ((i >> 1) & 0x55555555);
			i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
			return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
		}

		static Expression ProcessExpression(Expression exp) {
			if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				if (binOp.Operation == BinOps.Mul && binOp.Right is LiteralExpression) {
					// Decompose multiplication into shifts, e.g. x * 3 => x << 1 + x
					uint literal = ((LiteralExpression)binOp.Right).Value;
					if (literal == 0) return (LiteralExpression)0;
					if (literal == 1) return binOp.Left;

					uint bits = NumberOfSetBits(literal);
					if (bits <= 2) {
						var sum = new List<Expression>();
						int n = 0;
						while (literal != 0) {
							if ((literal & 1) != 0) {
								if (n == 0)
									sum.Add(binOp.Left);
								else
									sum.Add(binOp.Left << n);
							}
							literal >>= 1;
							n++;
						}
						BinOpExpression x = sum.OfType<BinOpExpression>().First();
						foreach (Expression i in sum.Except(new[] { x }))
							x += i;
						return x;
					}
				}
				else {
					binOp.Left = ProcessExpression(binOp.Left);
					binOp.Right = ProcessExpression(binOp.Right);
				}
			}
			else if (exp is ArrayIndexExpression) {
				((ArrayIndexExpression)exp).Array = ProcessExpression(((ArrayIndexExpression)exp).Array);
			}
			else if (exp is UnaryOpExpression) {
				((UnaryOpExpression)exp).Value = ProcessExpression(((UnaryOpExpression)exp).Value);
			}
			return exp;
		}

		static void ProcessStatement(Statement st) {
			if (st is AssignmentStatement) {
				var assign = (AssignmentStatement)st;
				assign.Target = ProcessExpression(assign.Target);
				assign.Value = ProcessExpression(assign.Value);
			}
		}

		public static void Run(StatementBlock block) {
			foreach (Statement st in block.Statements)
				ProcessStatement(st);
		}
	}
}
```

`Confuser.DynCipher/Transforms/NormalizeBinOpTransform.cs`:

```cs
using System;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class NormalizeBinOpTransform {
		static Expression ProcessExpression(Expression exp) {
			if (exp is BinOpExpression) {
				var binOp = (BinOpExpression)exp;
				var binOpRight = binOp.Right as BinOpExpression;
				//  a + (b + c) => (a + b) + c
				if (binOpRight != null && binOpRight.Operation == binOp.Operation &&
				    (binOp.Operation == BinOps.Add || binOp.Operation == BinOps.Mul ||
				     binOp.Operation == BinOps.Or || binOp.Operation == BinOps.And ||
				     binOp.Operation == BinOps.Xor)) {
					binOp.Left = new BinOpExpression {
						Left = binOp.Left,
						Operation = binOp.Operation,
						Right = binOpRight.Left
					};
					binOp.Right = binOpRight.Right;
				}

				binOp.Left = ProcessExpression(binOp.Left);
				binOp.Right = ProcessExpression(binOp.Right);

				if (binOp.Right is LiteralExpression && ((LiteralExpression)binOp.Right).Value == 0 &&
				    binOp.Operation == BinOps.Add) // x + 0 => x
					return binOp.Left;
			}
			else if (exp is ArrayIndexExpression) {
				((ArrayIndexExpression)exp).Array = ProcessExpression(((ArrayIndexExpression)exp).Array);
			}
			else if (exp is UnaryOpExpression) {
				((UnaryOpExpression)exp).Value = ProcessExpression(((UnaryOpExpression)exp).Value);
			}
			return exp;
		}

		static void ProcessStatement(Statement st) {
			if (st is AssignmentStatement) {
				var assign = (AssignmentStatement)st;
				assign.Target = ProcessExpression(assign.Target);
				assign.Value = ProcessExpression(assign.Value);
			}
		}

		public static void Run(StatementBlock block) {
			foreach (Statement st in block.Statements)
				ProcessStatement(st);
		}
	}
}
```

`Confuser.DynCipher/Transforms/ShuffleTransform.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core.Services;
using Confuser.DynCipher.AST;

namespace Confuser.DynCipher.Transforms {
	internal class ShuffleTransform {
		const int ITERATION = 20;

		static IEnumerable<Variable> GetVariableUsage(Expression exp) {
			if (exp is VariableExpression)
				yield return ((VariableExpression)exp).Variable;
			else if (exp is ArrayIndexExpression) {
				foreach (Variable i in GetVariableUsage(((ArrayIndexExpression)exp).Array))
					yield return i;
			}
			else if (exp is BinOpExpression) {
				foreach (Variable i in GetVariableUsage(((BinOpExpression)exp).Left)
					.Concat(GetVariableUsage(((BinOpExpression)exp).Right)))
					yield return i;
			}
			else if (exp is UnaryOpExpression) {
				foreach (Variable i in GetVariableUsage(((UnaryOpExpression)exp).Value))
					yield return i;
			}
		}

		static IEnumerable<Variable> GetVariableUsage(Statement st) {
			if (st is AssignmentStatement) {
				foreach (Variable i in GetVariableUsage(((AssignmentStatement)st).Value))
					yield return i;
			}
		}

		static IEnumerable<Variable> GetVariableDefinition(Expression exp) {
			if (exp is VariableExpression)
				yield return ((VariableExpression)exp).Variable;
		}

		static IEnumerable<Variable> GetVariableDefinition(Statement st) {
			if (st is AssignmentStatement) {
				foreach (Variable i in GetVariableDefinition(((AssignmentStatement)st).Target))
					yield return i;
			}
		}


		// Cannot go before the statements that use the variable defined at the statement
		// Cannot go further than the statements that override the variable used at the statement
		static int SearchUpwardKill(TransformContext context, Statement st, StatementBlock block, int startIndex) {
			Variable[] usage = context.Usages[st];
			Variable[] definition = context.Definitions[st];
			for (int i = startIndex - 1; i >= 0; i--) {
				if (context.Usages[block.Statements[i]].Intersect(definition).Count() > 0 ||
				    context.Definitions[block.Statements[i]].Intersect(usage).Count() > 0)
					return i;
			}
			return 0;
		}

		static int SearchDownwardKill(TransformContext context, Statement st, StatementBlock block, int startIndex) {
			Variable[] usage = context.Usages[st];
			Variable[] definition = context.Definitions[st];
			for (int i = startIndex + 1; i < block.Statements.Count; i++) {
				if (context.Usages[block.Statements[i]].Intersect(definition).Count() > 0 ||
				    context.Definitions[block.Statements[i]].Intersect(usage).Count() > 0)
					return i;
			}
			return block.Statements.Count - 1;
		}

		public static void Run(StatementBlock block, RandomGenerator random) {
			var context = new TransformContext {
				Statements = block.Statements.ToArray(),
				Usages = block.Statements.ToDictionary(s => s, s => GetVariableUsage(s).ToArray()),
				Definitions = block.Statements.ToDictionary(s => s, s => GetVariableDefinition(s).ToArray())
			};
			for (int i = 0; i < ITERATION; i++) {
				foreach (Statement st in context.Statements) {
					int index = block.Statements.IndexOf(st);
					Variable[] vars = GetVariableUsage(st).Concat(GetVariableDefinition(st)).ToArray();

					// Statement can move between defIndex & useIndex without side effects
					int defIndex = SearchUpwardKill(context, st, block, index);
					int useIndex = SearchDownwardKill(context, st, block, index);


					// Move to a random spot in the interval
					int newIndex = defIndex + random.NextInt32(1, useIndex - defIndex);
					if (newIndex > index) newIndex--;
					block.Statements.RemoveAt(index);
					block.Statements.Insert(newIndex, st);
				}
			}
		}

		class TransformContext {
			public Dictionary<Statement, Variable[]> Definitions;
			public Statement[] Statements;
			public Dictionary<Statement, Variable[]> Usages;
		}
	}
}
```

`Confuser.DynCipher/Utils.cs`:

```cs
using System;
using System.IO;
using Confuser.DynCipher.Generation;

namespace Confuser.DynCipher {
	public static class MathsUtils {
		const ulong MODULO32 = 0x100000000;

		public static ulong modInv(ulong num, ulong mod) {
			ulong a = mod, b = num % mod;
			ulong p0 = 0, p1 = 1;
			while (b != 0) {
				if (b == 1) return p1;
				p0 += (a / b) * p1;
				a = a % b;

				if (a == 0) break;
				if (a == 1) return mod - p0;

				p1 += (b / a) * p0;
				b = b % a;
			}
			return 0;
		}

		public static uint modInv(uint num) {
			return (uint)modInv(num, MODULO32);
		}

		public static byte modInv(byte num) {
			return (byte)modInv(num, 0x100);
		}
	}

	public static class CodeGenUtils {
		public static byte[] AssembleCode(x86CodeGen codeGen, x86Register reg) {
			var stream = new MemoryStream();
			using (var writer = new BinaryWriter(stream)) {
				/* 
                 *      mov eax, esp
                 *      push ebx
                 *      push edi
                 *      push esi
                 *      sub eax, esp
                 *      cmp eax, 24             ; determine the bitness of platform
                 *      je n
                 *      mov eax, [esp + 4]      ; 32 bits => argument in stack
                 *      push eax
                 *      jmp z
                 *  n:  push ecx                ; 64 bits => argument in register
                 *  z:  XXX
                 *      pop esi
                 *      pop edi
                 *      pop ebx
                 *      pop ret
                 *      
                 */
				writer.Write(new byte[] { 0x89, 0xe0 });
				writer.Write(new byte[] { 0x53 });
				writer.Write(new byte[] { 0x57 });
				writer.Write(new byte[] { 0x56 });
				writer.Write(new byte[] { 0x29, 0xe0 });
				writer.Write(new byte[] { 0x83, 0xf8, 0x18 });
				writer.Write(new byte[] { 0x74, 0x07 });
				writer.Write(new byte[] { 0x8b, 0x44, 0x24, 0x10 });
				writer.Write(new byte[] { 0x50 });
				writer.Write(new byte[] { 0xeb, 0x01 });
				writer.Write(new byte[] { 0x51 });

				foreach (x86Instruction i in codeGen.Instructions)
					writer.Write(i.Assemble());

				if (reg != x86Register.EAX)
					writer.Write(x86Instruction.Create(x86OpCode.MOV, new x86RegisterOperand(x86Register.EAX), new x86RegisterOperand(reg)).Assemble());

				writer.Write(new byte[] { 0x5e });
				writer.Write(new byte[] { 0x5f });
				writer.Write(new byte[] { 0x5b });
				writer.Write(new byte[] { 0xc3 });
			}
			return stream.ToArray();
		}
	}
}
```

`Confuser.MSBuild.Tasks/ConfuseTask.cs`:

```cs
using System.IO;
using System.Linq;
using System.Xml;
using Confuser.Core;
using Confuser.Core.Project;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

namespace Confuser.MSBuild.Tasks {
	public sealed class ConfuseTask : Task {
		[Required]
		public ITaskItem Project { get; set; }

		[Required]
		public ITaskItem OutputAssembly { get; set; }

		[Output]
		public ITaskItem[] ConfusedFiles { get; set; }

		public override bool Execute() {
			var project = new ConfuserProject();
			var xmlDoc = new XmlDocument();
			xmlDoc.Load(Project.ItemSpec);
			project.Load(xmlDoc);
			project.OutputDirectory = Path.GetDirectoryName(Path.GetFullPath(OutputAssembly.ItemSpec));

			var logger = new MSBuildLogger(Log);
			var parameters = new ConfuserParameters {
				Project = project,
				Logger = logger
			};

			ConfuserEngine.Run(parameters).Wait();

			ConfusedFiles = project.Select(m => new TaskItem(Path.Combine(project.OutputDirectory, m.Path))).Cast<ITaskItem>().ToArray();

			return !logger.HasError;
		}
	}
}

```

`Confuser.MSBuild.Tasks/Confuser.MSBuild.Tasks.csproj`:

```csproj
<!--EXTERNAL_PROPERTIES: TargetFramework;BaseOutputPath-->
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\ConfuserEx.Common.props" Condition="Exists('..\ConfuserEx.Common.props')" />

  <PropertyGroup Label="Assembly Settings">
    <TargetFrameworks>net461;netstandard2.0</TargetFrameworks>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>

  <PropertyGroup Label="Nuget Package Settings">
    <PackageId>Confuser.MSBuild</PackageId>
    <Product>ConfuserEx - MSBuild Integration</Product>
    <Description>This package contains the integration of ConfuserEx into the MSBuild build procedure. It allows automatically obfuscating the assemblies during the build.</Description>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageProjectUrl>https://github.com/mkaring/ConfuserEx</PackageProjectUrl>
    <PackageTags>Obfuscation Confuser ConfuserEx</PackageTags>
    <DevelopmentDependency>true</DevelopmentDependency>
    <IncludeBuildOutput>false</IncludeBuildOutput>
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    <NoPackageAnalysis>true</NoPackageAnalysis>
    <TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);IncludeConfuserDependencyFiles</TargetsForTfmSpecificContentInPackage>
    <IncludeBuildOutput>false</IncludeBuildOutput>
  </PropertyGroup>

  <ItemGroup Label="Nuget Dependencies">
    <PackageReference Include="Microsoft.Build.Tasks.Core" Version="15.9.*" PrivateAssets="all" />
  </ItemGroup>

  <ItemGroup Label="Project Dependencies">
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj" PrivateAssets="all" />
    <ProjectReference Include="..\Confuser.Protections\Confuser.Protections.csproj" PrivateAssets="all" />
    <ProjectReference Include="..\Confuser.Renamer\Confuser.Renamer.csproj" PrivateAssets="all" />
    <ProjectReference Include="..\Confuser.Runtime\Confuser.Runtime.csproj" Condition="'$(TargetFramework)' == 'net461'" PrivateAssets="all" />
  </ItemGroup>

  <ItemGroup>
    <Content Include="build\*" PackagePath="build" />
  </ItemGroup>

  <PropertyGroup>
    <IncludeConfuserDependencyFilesDependsOn>
      IncludeConfuserDependencyFilesFramework;
      IncludeConfuserDependencyFilesStandard
    </IncludeConfuserDependencyFilesDependsOn>
  </PropertyGroup>

  <Target Name="IncludeConfuserDependencyFiles" DependsOnTargets="$(IncludeConfuserDependencyFilesDependsOn)" />

  <Target Name="IncludeConfuserDependencyFilesFramework" Condition="'$(TargetFramework)' == 'net461'">
    <ItemGroup>
      <ConfuserNetFrameworkDependencies Include="$(BaseOutputPath)\$(Configuration)\net461\*.dll" />
      <ConfuserNetFrameworkDependencies Include="$(BaseOutputPath)\$(Configuration)\net461\*.pdb" />
    </ItemGroup>
    <CreateItem Include="@(ConfuserNetFrameworkDependencies)" AdditionalMetadata="PackagePath=netframework">
      <Output TaskParameter="Include" ItemName="TfmSpecificPackageFile" />
    </CreateItem>
  </Target>

  <Target Name="IncludeConfuserDependencyFilesStandard" Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <ItemGroup>
      <ConfuserNetStandardDependencies Include="$(BaseOutputPath)\$(Configuration)\netstandard2.0\*.dll" />
      <ConfuserNetStandardDependencies Include="$(BaseOutputPath)\$(Configuration)\netstandard2.0\*.pdb" />
    </ItemGroup>
    <CreateItem Include="@(ConfuserNetStandardDependencies)" AdditionalMetadata="PackagePath=netstandard">
      <Output TaskParameter="Include" ItemName="TfmSpecificPackageFile" />
    </CreateItem>
  </Target>

  <Import Project="..\ConfuserEx.Common.targets" Condition="Exists('..\ConfuserEx.Common.targets')" />

</Project>

```

`Confuser.MSBuild.Tasks/CreateProjectTask.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Xml;
using Confuser.Core.Project;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

namespace Confuser.MSBuild.Tasks {
	public sealed class CreateProjectTask : Task {
		public ITaskItem SourceProject { get; set; }

		[Required]
		public ITaskItem[] References { get; set; }

		[Required]
		public ITaskItem AssemblyPath { get; set; }

		public ITaskItem[] SatelliteAssemblyPaths { get; set; }

		public ITaskItem KeyFilePath { get; set; }

		public ITaskItem DelaySig { get; set; }

		public ITaskItem PubKeyFilePath { get; set; }

		public ITaskItem SigKeyFilePath { get; set; }

		public ITaskItem PubSigKeyFilePath { get; set; }

		[Required, Output]
		public ITaskItem ResultProject { get; set; }

		public override bool Execute() {
			var project = new ConfuserProject();
			if (!string.IsNullOrWhiteSpace(SourceProject?.ItemSpec)) {
				var xmlDoc = new XmlDocument();
				xmlDoc.Load(SourceProject.ItemSpec);
				project.Load(xmlDoc);

				// Probe Paths are not required, because all dependent assemblies are added as external modules.
				project.ProbePaths.Clear();
			}

			project.BaseDirectory = Path.GetDirectoryName(AssemblyPath.ItemSpec);
			var mainModule = GetOrCreateProjectModule(project, AssemblyPath.ItemSpec);

			if (!string.IsNullOrWhiteSpace(KeyFilePath?.ItemSpec)) {
				mainModule.SNKeyPath = KeyFilePath.ItemSpec;
			}
			if (!string.IsNullOrWhiteSpace(PubKeyFilePath?.ItemSpec)) {
				mainModule.SNPubKeyPath = PubKeyFilePath.ItemSpec;
			}
			if (!string.IsNullOrWhiteSpace(SigKeyFilePath?.ItemSpec)) {
				mainModule.SNSigKeyPath = SigKeyFilePath.ItemSpec;
			}
			if (!string.IsNullOrWhiteSpace(PubSigKeyFilePath?.ItemSpec)) {
				mainModule.SNPubSigKeyPath = PubSigKeyFilePath.ItemSpec;
			}
			if (!string.IsNullOrWhiteSpace(DelaySig?.ItemSpec)) {
				bool.TryParse(DelaySig.ItemSpec, out bool delaySig);
				mainModule.SNDelaySig = delaySig;
			}

			if (SatelliteAssemblyPaths != null) {
				foreach (var satelliteAssembly in SatelliteAssemblyPaths) {
					if (string.IsNullOrWhiteSpace(satelliteAssembly?.ItemSpec)) continue;

					var satelliteModule = GetOrCreateProjectModule(project, satelliteAssembly.ItemSpec);

					satelliteModule.SNKeyPath = mainModule.SNKeyPath;
					satelliteModule.SNPubKeyPath = mainModule.SNPubKeyPath;
					satelliteModule.SNSigKeyPath = mainModule.SNSigKeyPath;
					satelliteModule.SNPubSigKeyPath = mainModule.SNPubSigKeyPath;
					satelliteModule.SNDelaySig = mainModule.SNDelaySig;
				}
			}

			foreach (var probePath in References.Select(r => Path.GetDirectoryName(r.ItemSpec)).Distinct()) {
				project.ProbePaths.Add(probePath);
			}

			project.Save().Save(ResultProject.ItemSpec);

			return true;
		}

		private static ProjectModule GetOrCreateProjectModule(ConfuserProject project, string assemblyPath, bool isExternal = false) {
			var assemblyFileName = Path.GetFileName(assemblyPath);
			var assemblyName = Path.GetFileNameWithoutExtension(assemblyPath);
			foreach (var module in project) {
				if (string.Equals(module.Path, assemblyFileName) || string.Equals(module.Path, assemblyName)) {
					return module;
				}
			}

			if (assemblyPath.StartsWith(project.BaseDirectory)) {
				assemblyPath = assemblyPath.Substring(project.BaseDirectory.Length).TrimStart(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
			}

			var result = new ProjectModule {
				Path = assemblyPath,
				IsExternal = isExternal
			};
			project.Add(result);
			return result;
		}
	}
}

```

`Confuser.MSBuild.Tasks/MSBuildLogger.cs`:

```cs
using System;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;
using ILogger = Confuser.Core.ILogger;

namespace Confuser.MSBuild.Tasks {
	internal sealed class MSBuildLogger : ILogger {
		private readonly TaskLoggingHelper loggingHelper;
		
		internal bool HasError { get; private set; }

		internal MSBuildLogger(TaskLoggingHelper loggingHelper) =>
			this.loggingHelper = loggingHelper ?? throw new ArgumentNullException(nameof(loggingHelper));

		void ILogger.Debug(string msg) => loggingHelper.LogMessage(MessageImportance.Low, "[DEBUG] " + msg);

		void ILogger.DebugFormat(string format, params object[] args) {
			loggingHelper.LogMessage(MessageImportance.Low, "[DEBUG] " + format, args);
		}

		void ILogger.EndProgress() {}

		void ILogger.Error(string msg) {
			loggingHelper.LogError(msg);
			HasError = true;
		}

		void ILogger.ErrorException(string msg, Exception ex) {
			loggingHelper.LogError(msg);
			loggingHelper.LogErrorFromException(ex);
			HasError = true;
		}

		void ILogger.ErrorFormat(string format, params object[] args) {
			loggingHelper.LogError(format, args);
			HasError = true;
		}

		void ILogger.Finish(bool successful) {
			if (!successful) {
				HasError = false;
			}
		}

		void ILogger.Info(string msg) => loggingHelper.LogMessage(MessageImportance.Normal, msg);

		void ILogger.InfoFormat(string format, params object[] args) =>
			loggingHelper.LogMessage(MessageImportance.Normal, format, args);

		void ILogger.Progress(int progress, int overall) { }

		void ILogger.Warn(string msg) => loggingHelper.LogWarning(msg);

		void ILogger.WarnException(string msg, Exception ex) {
			loggingHelper.LogWarning(msg);
			loggingHelper.LogWarningFromException(ex);
		}

		void ILogger.WarnFormat(string format, params object[] args) => loggingHelper.LogWarning(format, args);
	}
}

```

`Confuser.MSBuild.Tasks/build/Confuser.MSBuild.Tasks.targets`:

```targets
<?xml version="1.0" encoding="utf-8" ?>
<Project>
  <PropertyGroup>
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <PropertyGroup>
    <ConfuserAssemblyPath Condition="'$(MSBuildRuntimeType)' == 'Full'">$(MSBuildThisFileDirectory)\..\netframework\</ConfuserAssemblyPath>
    <ConfuserAssemblyPath Condition="'$(ConfuserAssemblyPath)' == ''">$(MSBuildThisFileDirectory)\..\netstandard\</ConfuserAssemblyPath>
  </PropertyGroup>

  <UsingTask TaskName="Confuser.MSBuild.Tasks.CreateProjectTask"
             AssemblyFile="$(ConfuserAssemblyPath)Confuser.MSBuild.Tasks.dll" />
  <UsingTask TaskName="Confuser.MSBuild.Tasks.ConfuseTask"
             AssemblyFile="$(ConfuserAssemblyPath)Confuser.MSBuild.Tasks.dll" />  
</Project>

```

`Confuser.MSBuild.Tasks/build/Confuser.MSBuild.targets`:

```targets
<?xml version="1.0" encoding="utf-8" ?>
<Project>
  <PropertyGroup>
    <MSBuildAllProjects Condition="'$(MSBuildVersion)' == '' Or '$(MSBuildVersion)' &lt; '16.0'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)\Confuser.MSBuild.Tasks.targets" />
  
  <PropertyGroup>
    <ConfuserKeyFile Condition="'$(ConfuserKeyFile)' == ''">$(AssemblyOriginatorKeyFile)</ConfuserKeyFile>
    <ConfuserIntermediateOutputPath Condition="'$(ConfuserIntermediateOutputPath)' == ''">$(IntermediateOutputPath)confused\</ConfuserIntermediateOutputPath>
    <ConfuserReplaceOutput Condition="'$(ConfuserReplaceOutput)' == ''">false</ConfuserReplaceOutput>
    <ConfuserOutDir Condition="'$(ConfuserOutDir)' == ''">$(OutDir)confused\</ConfuserOutDir>
    <ConfuserSymbolFileName Condition="'$(ConfuserSymbolFileName)' == '' And '$(ConfuserReplaceOutput)' == 'true'">$(AssemblyName).symbols.map</ConfuserSymbolFileName>
    <ConfuserSymbolFileName Condition="'$(ConfuserSymbolFileName)' == ''">symbols.map</ConfuserSymbolFileName>
  </PropertyGroup>

  <PropertyGroup Condition="'$(ConfuserProject)' == ''">
    <ConfuserProject Condition="Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName).crproj')">$(MSBuildProjectDirectory)\$(MSBuildProjectName).crproj</ConfuserProject>
  </PropertyGroup>

  <PropertyGroup Condition="'$(ConfuserKeyFile)' != ''">
    <ConfuserKeyFile Condition="!Exists('$(ConfuserKeyFile)')">$(MSBuildProjectDirectory)$(ConfuserKeyFile)</ConfuserKeyFile>
    <ConfuserKeyFile Condition="!Exists('$(ConfuserKeyFile)')"></ConfuserKeyFile>
  </PropertyGroup>

  <PropertyGroup>
    <ConfuserExDependsOn>
      CreateConfuserProject;
      ConfuseAssembly;
      _ReplaceOutputWithConfusedAssemblies;
      _ReplaceDebugOutputWithConfusedAssemblies;
      CopyConfusedFilesToOutputDirectory;      
      _CopySymbolMapToOutputDirectory;
    </ConfuserExDependsOn>
  </PropertyGroup>

  <Target Name="ConfuserEx"
          DependsOnTargets="$(ConfuserExDependsOn)"
          BeforeTargets="CopyFilesToOutputDirectory" />

  <PropertyGroup>
    <CreateConfuserProjectDependsOn>
      ResolveReferences;
      ComputeIntermediateSatelliteAssemblies
    </CreateConfuserProjectDependsOn>
  </PropertyGroup>

  <Target Name="CreateConfuserProject"
          Condition="$(DesignTimeBuild) != true And $(Obfuscate) == true"          
          DependsOnTargets="$(CreateConfuserProjectDependsOn)"
          Inputs="@(IntermediateAssembly->'%(FullPath)');$(ConfuserProject);@(IntermediateSatelliteAssembliesWithTargetPath)"
          Outputs="@(IntermediateAssembly->'$(IntermediateOutputPath)%(Filename).crproj')">
    <Confuser.MSBuild.Tasks.CreateProjectTask
      SourceProject="$(ConfuserProject)"
      References="@(ReferencePath)"
      AssemblyPath="@(IntermediateAssembly)"
      SatelliteAssemblyPaths="@(IntermediateSatelliteAssembliesWithTargetPath)"
      KeyFilePath="$(ConfuserKeyFile)"
      ResultProject="@(IntermediateAssembly->'$(IntermediateOutputPath)%(Filename).crproj')"/>
  </Target>

  <PropertyGroup>
    <ConfuseAssemblyDependsOn>
      CreateConfuserProject
    </ConfuseAssemblyDependsOn>
  </PropertyGroup>

  <Target Name="ConfuseAssembly"
          Condition="Exists('@(IntermediateAssembly)') And $(DesignTimeBuild) != true And $(Obfuscate) == true"
          DependsOnTargets="$(ConfuseAssemblyDependsOn)"
          Inputs="@(IntermediateAssembly->'%(FullPath)');@(IntermediateAssembly->'$(IntermediateOutputPath)%(Filename).crproj')"
          Outputs="@(IntermediateAssembly->'$(ConfuserIntermediateOutputPath)%(Filename)%(Extension)');@(IntermediateSatelliteAssembliesWithTargetPath->'$(ConfuserIntermediateOutputPath)%(TargetPath)')">
    <Confuser.MSBuild.Tasks.ConfuseTask
      Project="@(IntermediateAssembly->'$(IntermediateOutputPath)%(Filename).crproj')"
      OutputAssembly="@(IntermediateAssembly->'$(ConfuserIntermediateOutputPath)%(Filename)%(Extension)')">
      <Output TaskParameter="ConfusedFiles" ItemName="FileWrites"/>
    </Confuser.MSBuild.Tasks.ConfuseTask>
  </Target>

  <Target Name="_ReplaceOutputWithConfusedAssemblies"
          Condition="$(DesignTimeBuild) != true And $(Obfuscate) == true and '$(ConfuserReplaceOutput)' == 'true'"
          DependsOnTargets="ConfuseAssembly">
    <CreateItem Include="@(IntermediateAssembly->'$(ConfuserIntermediateOutputPath)%(Filename)%(Extension)')">
      <Output TaskParameter="Include" ItemName="IntermediateConfusedAssembly" />
    </CreateItem>
    <ItemGroup>
      <IntermediateAssembly Remove="@(IntermediateAssembly)" />
    </ItemGroup>
    <CreateItem Include="@(IntermediateConfusedAssembly)">
      <Output TaskParameter="Include" ItemName="IntermediateAssembly" />
    </CreateItem>
  </Target>
  
  <Target Name="_ReplaceDebugOutputWithConfusedAssemblies"
          Condition="$(DesignTimeBuild) != true And $(Obfuscate) == true and '$(ConfuserReplaceOutput)' == 'true' and '@(_DebugSymbolsIntermediatePath)' != ''"
          DependsOnTargets="ConfuseAssembly">
    <CreateItem Include="@(IntermediateAssembly->'$(ConfuserIntermediateOutputPath)%(Filename).pdb')">
      <Output TaskParameter="Include" ItemName="_ConfusedDebugSymbolsIntermediatePath" />
    </CreateItem>
    <ItemGroup>
      <_DebugSymbolsIntermediatePath Remove="@(_DebugSymbolsIntermediatePath)" />
    </ItemGroup>
    <CreateItem Include="@(_ConfusedDebugSymbolsIntermediatePath)">
      <Output TaskParameter="Include" ItemName="_DebugSymbolsIntermediatePath" />
    </CreateItem>
  </Target>
  
  <Target Name="_CopySymbolMapToOutputDirectory"
          Condition="$(DesignTimeBuild) != true And $(Obfuscate) == true"
          DependsOnTargets="ConfuseAssembly">
    <PropertyGroup>
      <_SymbolsMapOutputDirectory Condition="'$(ConfuserReplaceOutput)' == 'true'">$(OutDir)</_SymbolsMapOutputDirectory>
      <_SymbolsMapOutputDirectory Condition="'$(ConfuserReplaceOutput)' != 'true'">$(ConfuserOutDir)</_SymbolsMapOutputDirectory>
    </PropertyGroup>

    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateHardLinksForCopyFilesToOutputDirectoryIfPossible>
      <CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible>
    </PropertyGroup>

    <PropertyGroup>
      <CopyConfuserSymbolsMapToOutputDirectory Condition="'$(CopyConfuserSymbolsMapToOutputDirectory)'==''">true</CopyConfuserSymbolsMapToOutputDirectory>
    </PropertyGroup>

    <ItemGroup Condition="Exists('$(ConfuserIntermediateOutputPath)symbols.map')">
      <_SymbolsMapSourceFiles Include="$(ConfuserIntermediateOutputPath)symbols.map" />
      <_SymbolsMapDestinationFiles Include="$(_SymbolsMapOutputDirectory)$(ConfuserSymbolFileName)" />
    </ItemGroup>

    <!-- Copy the symbols.map file in case it exists. -->
    <Copy
      SourceFiles="@(_SymbolsMapSourceFiles)"
      DestinationFiles="@(_SymbolsMapDestinationFiles)"
      SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
      OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
      Retries="$(CopyRetryCount)"
      RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
      UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
      UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)"
      Condition="'$(CopyConfuserSymbolsMapToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
      
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
      
    </Copy>
  </Target>

  <Target Name="CopyConfusedFilesToOutputDirectory"
          Condition="$(DesignTimeBuild) != true And $(Obfuscate) == true and '$(ConfuserReplaceOutput)' != 'true'">
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateHardLinksForCopyFilesToOutputDirectoryIfPossible>
      <CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible>
    </PropertyGroup>

    <PropertyGroup>
      <CopyBuildOutputToOutputDirectory Condition="'$(CopyBuildOutputToOutputDirectory)'==''">true</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory Condition="'$(CopyOutputSymbolsToOutputDirectory)'==''">true</CopyOutputSymbolsToOutputDirectory>
    </PropertyGroup>

    <!-- Copy the confused build product (.dll or .exe). -->
    <Copy
      SourceFiles="@(IntermediateAssembly->'$(ConfuserIntermediateOutputPath)%(Filename)%(Extension)')"
      DestinationFolder="$(ConfuserOutDir)"
      SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
      OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
      Retries="$(CopyRetryCount)"
      RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
      UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
      UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)"
      Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
      
      <Output TaskParameter="DestinationFiles" ItemName="ConfusedMainAssembly"/>
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
      
    </Copy>
    
    <!-- Copy the debug information file (.pdb), if any -->
    <Copy
        SourceFiles="@(IntermediateAssembly->'$(ConfuserIntermediateOutputPath)%(Filename).pdb')"
        DestinationFolder="$(ConfuserOutDir)"
        SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
        Retries="$(CopyRetryCount)"
        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
        UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
        UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)"
        Condition="'$(_DebugSymbolsProduced)'=='true' and '$(SkipCopyingSymbolsToOutputDirectory)' != 'true' and '$(CopyOutputSymbolsToOutputDirectory)'=='true'">
        
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
      
    </Copy>

    <!-- Copy the satellite assemblies (.resources.dll), if any -->
    <Copy
        SourceFiles="@(IntermediateSatelliteAssembliesWithTargetPath->'$(ConfuserIntermediateOutputPath)%(TargetPath)')"
        DestinationFiles="@(IntermediateSatelliteAssembliesWithTargetPath->'$(ConfuserOutDir)%(TargetPath)')"
        SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
        Retries="$(CopyRetryCount)"
        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
        UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
        UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)"
        Condition="'$(_DebugSymbolsProduced)'=='true' and '$(SkipCopyingSymbolsToOutputDirectory)' != 'true' and '$(CopyOutputSymbolsToOutputDirectory)'=='true'">

      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>

    </Copy>
  </Target>
</Project>

```

`Confuser.Protections/AntiDebugProtection.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections {
	[BeforeProtection("Ki.ControlFlow")]
	internal class AntiDebugProtection : Protection {
		public const string _Id = "anti debug";
		public const string _FullId = "Ki.AntiDebug";

		public override string Name {
			get { return "Anti Debug Protection"; }
		}

		public override string Description {
			get { return "This protection prevents the assembly from being debugged or profiled."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Minimum; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new AntiDebugPhase(this));
		}

		class AntiDebugPhase : ProtectionPhase {
			public AntiDebugPhase(AntiDebugProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Anti-debug injection"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				var rt = context.Registry.GetService<IRuntimeService>();
				var marker = context.Registry.GetService<IMarkerService>();
				var name = context.Registry.GetService<INameService>();

				foreach (ModuleDef module in parameters.Targets.OfType<ModuleDef>()) {
					AntiMode mode = parameters.GetParameter(context, module, "mode", AntiMode.Safe);

					TypeDef rtType;
					TypeDef attr = null;
					const string attrName = "System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute";
					switch (mode) {
						case AntiMode.Safe:
							rtType = rt.GetRuntimeType("Confuser.Runtime.AntiDebugSafe");
							break;
						case AntiMode.Win32:
							rtType = rt.GetRuntimeType("Confuser.Runtime.AntiDebugWin32");
							break;
						case AntiMode.Antinet:
							rtType = rt.GetRuntimeType("Confuser.Runtime.AntiDebugAntinet");

							attr = rt.GetRuntimeType(attrName);
							module.Types.Add(attr = InjectHelper.Inject(attr, module));
							foreach (IDnlibDef member in attr.FindDefinitions()) {
								marker.Mark(member, (Protection)Parent);
								name.Analyze(member);
							}
							name.SetCanRename(attr, false);
							break;
						default:
							throw new UnreachableException();
					}

					IEnumerable<IDnlibDef> members = InjectHelper.Inject(rtType, module.GlobalType, module);

					MethodDef cctor = module.GlobalType.FindStaticConstructor();
					var init = (MethodDef)members.Single(method => method.Name == "Initialize");
					cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init));

					foreach (IDnlibDef member in members) {
						marker.Mark(member, (Protection)Parent);
						name.Analyze(member);

						bool ren = true;
						if (member is MethodDef) {
							var method = (MethodDef)member;
							if (method.Access == MethodAttributes.Public)
								method.Access = MethodAttributes.Assembly;
							if (!method.IsConstructor)
								method.IsSpecialName = false;
							else
								ren = false;

							CustomAttribute ca = method.CustomAttributes.Find(attrName);
							if (ca != null)
								ca.Constructor = attr.FindMethod(".ctor");
						}
						else if (member is FieldDef) {
							var field = (FieldDef)member;
							if (field.Access == FieldAttributes.Public)
								field.Access = FieldAttributes.Assembly;
							if (field.IsLiteral) {
								field.DeclaringType.Fields.Remove(field);
								continue;
							}
						}
						if (ren) {
							member.Name = name.ObfuscateName(member, RenameMode.Unicode);
							name.SetCanRename(member, false);
						}
					}
				}
			}

			enum AntiMode {
				Safe,
				Win32,
				Antinet
			}
		}
	}
}

```

`Confuser.Protections/AntiDumpProtection.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections {
	[BeforeProtection("Ki.ControlFlow")]
	internal class AntiDumpProtection : Protection {
		public const string _Id = "anti dump";
		public const string _FullId = "Ki.AntiDump";

		public override string Name {
			get { return "Anti Dump Protection"; }
		}

		public override string Description {
			get { return "This protection prevents the assembly from being dumped from memory."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Maximum; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new AntiDumpPhase(this));
		}

		class AntiDumpPhase : ProtectionPhase {
			public AntiDumpPhase(AntiDumpProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Anti-dump injection"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				TypeDef rtType = context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.AntiDump");

				var marker = context.Registry.GetService<IMarkerService>();
				var name = context.Registry.GetService<INameService>();

				foreach (ModuleDef module in parameters.Targets.OfType<ModuleDef>()) {
					IEnumerable<IDnlibDef> members = InjectHelper.Inject(rtType, module.GlobalType, module);

					MethodDef cctor = module.GlobalType.FindStaticConstructor();
					var init = (MethodDef)members.Single(method => method.Name == "Initialize");
					cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init));

					foreach (IDnlibDef member in members)
						name.MarkHelper(member, marker, (Protection)Parent);
				}
			}
		}
	}
}
```

`Confuser.Protections/AntiILDasmProtection.cs`:

```cs
using System;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Protections {
	internal class AntiILDasmProtection : Protection {
		public const string _Id = "anti ildasm";
		public const string _FullId = "Ki.AntiILDasm";

		public override string Name {
			get { return "Anti IL Dasm Protection"; }
		}

		public override string Description {
			get { return "This protection marks the module with a attribute that discourage ILDasm from disassembling it."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Minimum; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new AntiILDasmPhase(this));
		}

		class AntiILDasmPhase : ProtectionPhase {
			public AntiILDasmPhase(AntiILDasmProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Anti-ILDasm marking"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				foreach (ModuleDef module in parameters.Targets.OfType<ModuleDef>()) {
					TypeRef attrRef = module.CorLibTypes.GetTypeRef("System.Runtime.CompilerServices", "SuppressIldasmAttribute");
					var ctorRef = new MemberRefUser(module, ".ctor", MethodSig.CreateInstance(module.CorLibTypes.Void), attrRef);

					var attr = new CustomAttribute(ctorRef);
					module.CustomAttributes.Add(attr);
				}
			}
		}
	}
}
```

`Confuser.Protections/AntiTamper/AntiMode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using MethodBody = dnlib.DotNet.Writer.MethodBody;

namespace Confuser.Protections.AntiTamper {
	internal class AntiMode : IModeHandler {
		uint c;
		IKeyDeriver deriver;

		List<MethodDef> methods;
		uint name1, name2;
		RandomGenerator random;
		uint v;
		uint x;
		uint z;

		public void HandleInject(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			random = context.Registry.GetService<IRandomService>().GetRandomGenerator(parent.FullId);
			z = random.NextUInt32();
			x = random.NextUInt32();
			c = random.NextUInt32();
			v = random.NextUInt32();
			name1 = random.NextUInt32() & 0x7f7f7f7f;
			name2 = random.NextUInt32() & 0x7f7f7f7f;

			switch (parameters.GetParameter(context, context.CurrentModule, "key", Mode.Normal)) {
				case Mode.Normal:
					deriver = new NormalDeriver();
					break;
				case Mode.Dynamic:
					deriver = new DynamicDeriver();
					break;
				default:
					throw new UnreachableException();
			}
			deriver.Init(context, random);

			var rt = context.Registry.GetService<IRuntimeService>();
			TypeDef initType = rt.GetRuntimeType("Confuser.Runtime.AntiTamperAnti");
			IEnumerable<IDnlibDef> members = InjectHelper.Inject(initType, context.CurrentModule.GlobalType, context.CurrentModule);
			var initMethod = (MethodDef)members.Single(m => m.Name == "Initialize");

			initMethod.Body.SimplifyMacros(initMethod.Parameters);
			List<Instruction> instrs = initMethod.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				if (instr.OpCode == OpCodes.Ldtoken) {
					instr.Operand = context.CurrentModule.GlobalType;
				}
				else if (instr.OpCode == OpCodes.Call) {
					var method = (IMethod)instr.Operand;
					if (method.DeclaringType.Name == "Mutation" &&
						method.Name == "Crypt") {
						Instruction ldDst = instrs[i - 2];
						Instruction ldSrc = instrs[i - 1];
						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, deriver.EmitDerivation(initMethod, context, (Local)ldDst.Operand, (Local)ldSrc.Operand));
					}
				}
			}
			initMethod.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				initMethod.Body.Instructions.Add(instr);

			MutationHelper.InjectKeys(initMethod,
									  new[] { 0, 1, 2, 3, 4 },
									  new[] { (int)(name1 * name2), (int)z, (int)x, (int)c, (int)v });

			var name = context.Registry.GetService<INameService>();
			var marker = context.Registry.GetService<IMarkerService>();
			foreach (IDnlibDef def in members) {
				name.MarkHelper(def, marker, parent);
				if (def is MethodDef)
					parent.ExcludeMethod(context, (MethodDef)def);
			}

			MethodDef cctor = context.CurrentModule.GlobalType.FindStaticConstructor();
			cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, initMethod));

			parent.ExcludeMethod(context, cctor);
		}

		public void HandleMD(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			methods = parameters.Targets.OfType<MethodDef>().ToList();
			context.CurrentModuleWriterOptions.WriterEvent += OnWriterEvent;
		}

		void OnWriterEvent(object sender, ModuleWriterEventArgs e) {
			var writer = e.Writer;
			if (e.Event == ModuleWriterEvent.MDEndCreateTables) {
				CreateSections(writer);
			}
			else if (e.Event == ModuleWriterEvent.BeginStrongNameSign) {
				EncryptSection(writer);
			}
		}

		void CreateSections(ModuleWriterBase writer) {
			var nameBuffer = new byte[8];
			nameBuffer[0] = (byte)(name1 >> 0);
			nameBuffer[1] = (byte)(name1 >> 8);
			nameBuffer[2] = (byte)(name1 >> 16);
			nameBuffer[3] = (byte)(name1 >> 24);
			nameBuffer[4] = (byte)(name2 >> 0);
			nameBuffer[5] = (byte)(name2 >> 8);
			nameBuffer[6] = (byte)(name2 >> 16);
			nameBuffer[7] = (byte)(name2 >> 24);
			var newSection = new PESection(Encoding.ASCII.GetString(nameBuffer), 0xE0000040);
			writer.Sections.Insert(0, newSection); // insert first to ensure proper RVA

			uint alignment;

			alignment = writer.TextSection.Remove(writer.Metadata).Value;
			writer.TextSection.Add(writer.Metadata, alignment);

			alignment = writer.TextSection.Remove(writer.NetResources).Value;
			writer.TextSection.Add(writer.NetResources, alignment);

			alignment = writer.TextSection.Remove(writer.Constants).Value;
			newSection.Add(writer.Constants, alignment);

			// move some PE parts to separate section to prevent it from being hashed
			var peSection = new PESection("", 0x60000020);
			bool moved = false;
			if (writer.StrongNameSignature != null) {
				alignment = writer.TextSection.Remove(writer.StrongNameSignature).Value;
				peSection.Add(writer.StrongNameSignature, alignment);
				moved = true;
			}
			var managedWriter = writer as ModuleWriter;
			if (managedWriter != null) {
				if (managedWriter.ImportAddressTable != null) {
					alignment = writer.TextSection.Remove(managedWriter.ImportAddressTable).Value;
					peSection.Add(managedWriter.ImportAddressTable, alignment);
					moved = true;
				}
				if (managedWriter.StartupStub != null) {
					alignment = writer.TextSection.Remove(managedWriter.StartupStub).Value;
					peSection.Add(managedWriter.StartupStub, alignment);
					moved = true;
				}
			}
			if (moved)
				writer.Sections.AddBeforeReloc(peSection);

			// move encrypted methods
			var encryptedChunk = new MethodBodyChunks(writer.TheOptions.ShareMethodBodies);
			newSection.Add(encryptedChunk, 4);
			foreach (MethodDef method in methods) {
				if (!method.HasBody)
					continue;
				MethodBody body = writer.Metadata.GetMethodBody(method);
				bool ok = writer.MethodBodies.Remove(body);
				encryptedChunk.Add(body);
			}

			// padding to prevent bad size due to shift division
			newSection.Add(new ByteArrayChunk(new byte[4]), 4);
		}

		void EncryptSection(ModuleWriterBase writer) {
			Stream stream = writer.DestinationStream;
			var reader = new BinaryReader(writer.DestinationStream);
			stream.Position = 0x3C;
			stream.Position = reader.ReadUInt32();

			stream.Position += 6;
			ushort sections = reader.ReadUInt16();
			stream.Position += 0xc;
			ushort optSize = reader.ReadUInt16();
			stream.Position += 2 + optSize;

			uint encLoc = 0, encSize = 0;
			int origSects = -1;
			if (writer is NativeModuleWriter && writer.Module is ModuleDefMD)
				origSects = ((ModuleDefMD)writer.Module).Metadata.PEImage.ImageSectionHeaders.Count;
			for (int i = 0; i < sections; i++) {
				uint nameHash;
				if (origSects > 0) {
					origSects--;
					stream.Write(new byte[8], 0, 8);
					nameHash = 0;
				}
				else
					nameHash = reader.ReadUInt32() * reader.ReadUInt32();
				stream.Position += 8;
				if (nameHash == name1 * name2) {
					encSize = reader.ReadUInt32();
					encLoc = reader.ReadUInt32();
				}
				else if (nameHash != 0) {
					uint sectSize = reader.ReadUInt32();
					uint sectLoc = reader.ReadUInt32();
					Hash(stream, reader, sectLoc, sectSize);
				}
				else
					stream.Position += 8;
				stream.Position += 16;
			}

			uint[] key = DeriveKey();
			encSize >>= 2;
			stream.Position = encLoc;
			var result = new uint[encSize];
			for (uint i = 0; i < encSize; i++) {
				uint data = reader.ReadUInt32();
				result[i] = data ^ key[i & 0xf];
				key[i & 0xf] = (key[i & 0xf] ^ data) + 0x3dbb2819;
			}
			var byteResult = new byte[encSize << 2];
			Buffer.BlockCopy(result, 0, byteResult, 0, byteResult.Length);
			stream.Position = encLoc;
			stream.Write(byteResult, 0, byteResult.Length);
		}

		void Hash(Stream stream, BinaryReader reader, uint offset, uint size) {
			long original = stream.Position;
			stream.Position = offset;
			size >>= 2;
			for (uint i = 0; i < size; i++) {
				uint data = reader.ReadUInt32();
				uint tmp = (z ^ data) + x + c * v;
				z = x;
				x = c;
				x = v;
				v = tmp;
			}
			stream.Position = original;
		}

		uint[] DeriveKey() {
			uint[] dst = new uint[0x10], src = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				dst[i] = v;
				src[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);
				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			return deriver.DeriveKey(dst, src);
		}
	}
}

```

`Confuser.Protections/AntiTamper/AntiTamperExtensions.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.AntiTamper {
	internal static class AntiTamperExtensions {
		internal static void AddBeforeReloc(this List<PESection> sections, PESection newSection) {
			if (sections == null) throw new ArgumentNullException(nameof(sections));
			InsertBeforeReloc(sections, sections.Count, newSection);
		}

		internal static void InsertBeforeReloc(this List<PESection> sections, int preferredIndex, PESection newSection) {
			if (sections == null) throw new ArgumentNullException(nameof(sections));
			if (preferredIndex < 0 || preferredIndex > sections.Count) throw new ArgumentOutOfRangeException(nameof(preferredIndex), preferredIndex, "Preferred index is out of range.");
			if (newSection == null) throw new ArgumentNullException(nameof(newSection));

			var relocIndex = sections.FindIndex(0, Math.Min(preferredIndex + 1, sections.Count), IsRelocSection);
			if (relocIndex == -1)
				sections.Insert(preferredIndex, newSection);
			else
				sections.Insert(relocIndex, newSection);
		}

		private static bool IsRelocSection(PESection section) => 
			section.Name.Equals(".reloc", StringComparison.Ordinal);
	}
}

```

`Confuser.Protections/AntiTamper/AntiTamperProtection.cs`:

```cs
using System;
using System.Linq;
using Confuser.Core;
using Confuser.Protections.AntiTamper;
using dnlib.DotNet;
using dnlib.DotNet.Writer;

namespace Confuser.Protections {
	public interface IAntiTamperService {
		void ExcludeMethod(ConfuserContext context, MethodDef method);
	}

	[BeforeProtection("Ki.ControlFlow"), AfterProtection("Ki.Constants")]
	internal class AntiTamperProtection : Protection, IAntiTamperService {
		public const string _Id = "anti tamper";
		public const string _FullId = "Ki.AntiTamper";
		public const string _ServiceId = "Ki.AntiTamper";
		static readonly object HandlerKey = new object();

		public override string Name {
			get { return "Anti Tamper Protection"; }
		}

		public override string Description {
			get { return "This protection ensures the integrity of application."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Maximum; }
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IAntiTamperService), this);
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPostStage(PipelineStage.BeginModule, new ModuleWriterSetupPhase(this));
			pipeline.InsertPreStage(PipelineStage.OptimizeMethods, new InjectPhase(this));
			pipeline.InsertPreStage(PipelineStage.EndModule, new MDPhase(this));
		}

		public void ExcludeMethod(ConfuserContext context, MethodDef method) {
			ProtectionParameters.GetParameters(context, method).Remove(this);
		}

		class ModuleWriterSetupPhase : ProtectionPhase {
			public ModuleWriterSetupPhase(AntiTamperProtection parent) : base(parent) { }

			/// <inheritdoc />
			public override ProtectionTargets Targets => ProtectionTargets.Methods;

			/// <inheritdoc />
			public override string Name => "Anti-tamper module writer preparation";

			/// <inheritdoc />
			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				if (!parameters.Targets.Any()) return;

				if (context.CurrentModuleWriterOptions is NativeModuleWriterOptions nativeOptions) {
					context.RequestNative(false);
				}
			}
		}

		class InjectPhase : ProtectionPhase {
			public InjectPhase(AntiTamperProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Methods; }
			}

			public override string Name {
				get { return "Anti-tamper helpers injection"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				if (!parameters.Targets.Any())
					return;

				Mode mode = parameters.GetParameter(context, context.CurrentModule, "mode", Mode.Normal);
				IModeHandler modeHandler;
				switch (mode) {
					case Mode.Normal:
						modeHandler = new NormalMode();
						break;
					case Mode.Anti:
						modeHandler = new AntiMode();
						break;
					case Mode.JIT:
						modeHandler = new JITMode();
						break;
					default:
						throw new UnreachableException();
				}
				modeHandler.HandleInject((AntiTamperProtection)Parent, context, parameters);
				context.Annotations.Set(context.CurrentModule, HandlerKey, modeHandler);
			}
		}

		class MDPhase : ProtectionPhase {
			public MDPhase(AntiTamperProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Methods; }
			}

			public override string Name {
				get { return "Anti-tamper metadata preparation"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				if (!parameters.Targets.Any())
					return;

				var modeHandler = context.Annotations.Get<IModeHandler>(context.CurrentModule, HandlerKey);
				modeHandler.HandleMD((AntiTamperProtection)Parent, context, parameters);
			}
		}

		enum Mode {
			Normal,
			Anti,
			JIT
		}
	}
}

```

`Confuser.Protections/AntiTamper/DynamicDeriver.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.AntiTamper {
	internal class DynamicDeriver : IKeyDeriver {
		StatementBlock derivation;
		Action<uint[], uint[]> encryptFunc;

		public void Init(ConfuserContext ctx, RandomGenerator random) {
			StatementBlock dummy;
			ctx.Registry.GetService<IDynCipherService>().GenerateCipherPair(random, out derivation, out dummy);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(derivation);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();
		}

		public uint[] DeriveKey(uint[] a, uint[] b) {
			var ret = new uint[0x10];
			Buffer.BlockCopy(a, 0, ret, 0, a.Length * sizeof(uint));
			encryptFunc(ret, b);
			return ret;
		}

		public IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src) {
			var ret = new List<Instruction>();
			var codeGen = new CodeGen(dst, src, method, ret);
			codeGen.GenerateCIL(derivation);
			codeGen.Commit(method.Body);
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CodeGen(Local block, Local key, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}
	}
}
```

`Confuser.Protections/AntiTamper/IKeyDeriver.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.AntiTamper {
	internal enum Mode {
		Normal,
		Dynamic
	}

	internal interface IKeyDeriver {
		void Init(ConfuserContext ctx, RandomGenerator random);
		uint[] DeriveKey(uint[] a, uint[] b);
		IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src);
	}
}
```

`Confuser.Protections/AntiTamper/IModeHandler.cs`:

```cs
using System;
using Confuser.Core;

namespace Confuser.Protections.AntiTamper {
	internal interface IModeHandler {
		void HandleInject(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters);
		void HandleMD(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters);
	}
}
```

`Confuser.Protections/AntiTamper/JITBody.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using dnlib.IO;
using dnlib.PE;

namespace Confuser.Protections.AntiTamper {
	internal struct JITEHClause {
		public uint ClassTokenOrFilterOffset;
		public uint Flags;
		public uint HandlerLength;
		public uint HandlerOffset;
		public uint TryLength;
		public uint TryOffset;
	}

	internal class JITMethodBody : IChunk {
		public byte[] Body;
		public JITEHClause[] EHs;
		public byte[] ILCode;
		public byte[] LocalVars;
		public uint MaxStack;
		public uint MulSeed;

		public uint Offset;
		public uint Options;

		public FileOffset FileOffset { get; set; }

		public RVA RVA { get; set; }

		public void SetOffset(FileOffset offset, RVA rva) {
			this.FileOffset = offset;
			this.RVA = rva;
		}

		public uint GetFileLength() {
			return (uint)Body.Length + 4;
		}

		public uint GetVirtualSize() {
			return GetFileLength();
		}

		public void WriteTo(DataWriter writer) {
			writer.WriteUInt32((uint)(Body.Length >> 2));
			writer.WriteBytes(Body);
		}

		public void Serialize(uint token, uint key, byte[] fieldLayout) {
			using (var ms = new MemoryStream()) {
				var writer = new DataWriter(ms);
				foreach (byte i in fieldLayout)
					switch (i) {
						case 0:
							writer.WriteUInt32((uint)ILCode.Length);
							break;
						case 1:
							writer.WriteUInt32(MaxStack);
							break;
						case 2:
							writer.WriteUInt32((uint)EHs.Length);
							break;
						case 3:
							writer.WriteUInt32((uint)LocalVars.Length);
							break;
						case 4:
							writer.WriteUInt32(Options);
							break;
						case 5:
							writer.WriteUInt32(MulSeed);
							break;
					}

				writer.WriteBytes(ILCode);
				writer.WriteBytes(LocalVars);
				foreach (JITEHClause clause in EHs) {
					writer.WriteUInt32(clause.Flags);
					writer.WriteUInt32(clause.TryOffset);
					writer.WriteUInt32(clause.TryLength);
					writer.WriteUInt32(clause.HandlerOffset);
					writer.WriteUInt32(clause.HandlerLength);
					writer.WriteUInt32(clause.ClassTokenOrFilterOffset);
				}
				writer.WriteZeroes(4 - ((int)ms.Length & 3)); // pad to 4 bytes
				Body = ms.ToArray();
			}
			Debug.Assert(Body.Length % 4 == 0);
			// encrypt body
			uint state = token * key;
			uint counter = state;
			for (uint i = 0; i < Body.Length; i += 4) {
				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);
				Body[i + 0] ^= (byte)(state >> 0);
				Body[i + 1] ^= (byte)(state >> 8);
				Body[i + 2] ^= (byte)(state >> 16);
				Body[i + 3] ^= (byte)(state >> 24);
				state += data ^ counter;
				counter ^= (state >> 5) | (state << 27);
			}
		}
  }

	internal class JITMethodBodyWriter : MethodBodyWriterBase {
		readonly CilBody body;
		readonly JITMethodBody jitBody;
		readonly bool keepMaxStack;
		readonly Metadata metadata;

		public JITMethodBodyWriter(Metadata md, CilBody body, JITMethodBody jitBody, uint mulSeed, bool keepMaxStack) :
			base(body.Instructions, body.ExceptionHandlers) {
			metadata = md;
			this.body = body;
			this.jitBody = jitBody;
			this.keepMaxStack = keepMaxStack;
			this.jitBody.MulSeed = mulSeed;
		}

		public void Write() {
			uint codeSize = InitializeInstructionOffsets();
			jitBody.MaxStack = keepMaxStack ? body.MaxStack : GetMaxStack();

			jitBody.Options = 0;
			if (body.InitLocals)
				jitBody.Options |= 0x10;

			if (body.Variables.Count > 0) {
				var local = new LocalSig(body.Variables.Select(var => var.Type).ToList());
				jitBody.LocalVars = SignatureWriter.Write(metadata, local);
			}
			else
				jitBody.LocalVars = new byte[0];

      {
        var newCode = new byte[codeSize];
        var writer = new ArrayWriter(newCode);
        uint _codeSize = WriteInstructions(ref writer);
        Debug.Assert(codeSize == _codeSize);
        jitBody.ILCode = newCode;
      }

			jitBody.EHs = new JITEHClause[exceptionHandlers.Count];
			if (exceptionHandlers.Count > 0) {
				jitBody.Options |= 8;
				for (int i = 0; i < exceptionHandlers.Count; i++) {
					ExceptionHandler eh = exceptionHandlers[i];
					jitBody.EHs[i].Flags = (uint)eh.HandlerType;

					uint tryStart = GetOffset(eh.TryStart);
					uint tryEnd = GetOffset(eh.TryEnd);
					jitBody.EHs[i].TryOffset = tryStart;
					jitBody.EHs[i].TryLength = tryEnd - tryStart;

					uint handlerStart = GetOffset(eh.HandlerStart);
					uint handlerEnd = GetOffset(eh.HandlerEnd);
					jitBody.EHs[i].HandlerOffset = handlerStart;
					jitBody.EHs[i].HandlerLength = handlerEnd - handlerStart;

					if (eh.HandlerType == ExceptionHandlerType.Catch) {
						uint token = metadata.GetToken(eh.CatchType).Raw;
						if ((token & 0xff000000) == 0x1b000000)
							jitBody.Options |= 0x80;

						jitBody.EHs[i].ClassTokenOrFilterOffset = token;
					}
					else if (eh.HandlerType == ExceptionHandlerType.Filter) {
						jitBody.EHs[i].ClassTokenOrFilterOffset = GetOffset(eh.FilterStart);
					}
				}
			}
		}

		protected override void WriteInlineField(ref ArrayWriter writer, Instruction instr) {
      writer.WriteUInt32(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineMethod(ref ArrayWriter writer, Instruction instr) {
			writer.WriteUInt32(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineSig(ref ArrayWriter writer, Instruction instr) {
			writer.WriteUInt32(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineString(ref ArrayWriter writer, Instruction instr) {
			writer.WriteUInt32(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineTok(ref ArrayWriter writer, Instruction instr) {
			writer.WriteUInt32(metadata.GetToken(instr.Operand).Raw);
		}

		protected override void WriteInlineType(ref ArrayWriter writer, Instruction instr) {
			writer.WriteUInt32(metadata.GetToken(instr.Operand).Raw);
		}
	}

	internal class JITBodyIndex : IChunk {
		readonly Dictionary<uint, JITMethodBody> bodies;

		public JITBodyIndex(IEnumerable<uint> tokens) {
			bodies = tokens.ToDictionary(token => token, token => (JITMethodBody)null);
		}

		public FileOffset FileOffset { get; set; }

		public RVA RVA { get; set; }

		public void SetOffset(FileOffset offset, RVA rva) {
			this.FileOffset = offset;
			this.RVA = rva;
		}

		public uint GetFileLength() {
			return (uint)bodies.Count * 8 + 4;
		}

		public uint GetVirtualSize() {
			return GetFileLength();
		}

		public void WriteTo(DataWriter writer) {
			uint length = GetFileLength() - 4; // minus length field
			writer.WriteUInt32((uint)bodies.Count);
			foreach (var entry in bodies.OrderBy(entry => entry.Key)) {
				writer.WriteUInt32(entry.Key);
				Debug.Assert(entry.Value != null);
				Debug.Assert((length + entry.Value.Offset) % 4 == 0);
				writer.WriteUInt32((length + entry.Value.Offset) >> 2);
			}
		}

		public void Add(uint token, JITMethodBody body) {
			Debug.Assert(bodies.ContainsKey(token));
			bodies[token] = body;
		}

		public void PopulateSection(PESection section) {
			uint offset = 0;
			foreach (var entry in bodies.OrderBy(entry => entry.Key)) {
				Debug.Assert(entry.Value != null);
				section.Add(entry.Value, 4);
				entry.Value.Offset = offset;

				Debug.Assert(entry.Value.GetFileLength() % 4 == 0);
				offset += entry.Value.GetFileLength();
			}
		}
	}
}
```

`Confuser.Protections/AntiTamper/JITMode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.AntiTamper {
	internal class JITMode : IModeHandler {
		static readonly CilBody NopBody = new CilBody {
			Instructions = {
				Instruction.Create(OpCodes.Ldnull),
				Instruction.Create(OpCodes.Throw)
			}
		};

		uint c;
		MethodDef cctor;
		MethodDef cctorRepl;
		ConfuserContext context;
		IKeyDeriver deriver;
		byte[] fieldLayout;

		MethodDef initMethod;
		uint key;
		List<MethodDef> methods;
		uint name1, name2;
		RandomGenerator random;
		uint v;
		uint x;
		uint z;

		public void HandleInject(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			this.context = context;
			random = context.Registry.GetService<IRandomService>().GetRandomGenerator(parent.FullId);
			z = random.NextUInt32();
			x = random.NextUInt32();
			c = random.NextUInt32();
			v = random.NextUInt32();
			name1 = random.NextUInt32() & 0x7f7f7f7f;
			name2 = random.NextUInt32() & 0x7f7f7f7f;
			key = random.NextUInt32();

			fieldLayout = new byte[6];
			for (int i = 0; i < 6; i++) {
				int index = random.NextInt32(0, 6);
				while (fieldLayout[index] != 0)
					index = random.NextInt32(0, 6);
				fieldLayout[index] = (byte)i;
			}

			switch (parameters.GetParameter(context, context.CurrentModule, "key", Mode.Normal)) {
				case Mode.Normal:
					deriver = new NormalDeriver();
					break;
				case Mode.Dynamic:
					deriver = new DynamicDeriver();
					break;
				default:
					throw new UnreachableException();
			}
			deriver.Init(context, random);

			var rt = context.Registry.GetService<IRuntimeService>();
			TypeDef initType = rt.GetRuntimeType("Confuser.Runtime.AntiTamperJIT");
			IEnumerable<IDnlibDef> defs = InjectHelper.Inject(initType, context.CurrentModule.GlobalType, context.CurrentModule);
			initMethod = defs.OfType<MethodDef>().Single(method => method.Name == "Initialize");

			initMethod.Body.SimplifyMacros(initMethod.Parameters);
			List<Instruction> instrs = initMethod.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				if (instr.OpCode == OpCodes.Ldtoken) {
					instr.Operand = context.CurrentModule.GlobalType;
				}
				else if (instr.OpCode == OpCodes.Call) {
					var method = (IMethod)instr.Operand;
					if (method.DeclaringType.Name == "Mutation" &&
						method.Name == "Crypt") {
						Instruction ldDst = instrs[i - 2];
						Instruction ldSrc = instrs[i - 1];
						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, deriver.EmitDerivation(initMethod, context, (Local)ldDst.Operand, (Local)ldSrc.Operand));
					}
				}
			}
			initMethod.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				initMethod.Body.Instructions.Add(instr);

			MutationHelper.InjectKeys(initMethod,
									  new[] { 0, 1, 2, 3, 4 },
									  new[] { (int)(name1 * name2), (int)z, (int)x, (int)c, (int)v });

			var name = context.Registry.GetService<INameService>();
			var marker = context.Registry.GetService<IMarkerService>();

			cctor = context.CurrentModule.GlobalType.FindStaticConstructor();

			cctorRepl = new MethodDefUser(name.RandomName(), MethodSig.CreateStatic(context.CurrentModule.CorLibTypes.Void));
			cctorRepl.IsStatic = true;
			cctorRepl.Access = MethodAttributes.CompilerControlled;
			cctorRepl.Body = new CilBody();
			cctorRepl.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
			context.CurrentModule.GlobalType.Methods.Add(cctorRepl);
			name.MarkHelper(cctorRepl, marker, parent);

			MutationHelper.InjectKeys(defs.OfType<MethodDef>().Single(method => method.Name == "HookHandler"),
									  new[] { 0 }, new[] { (int)key });
			foreach (IDnlibDef def in defs) {
				if (def.Name == "MethodData") {
					var dataType = (TypeDef)def;
					FieldDef[] fields = dataType.Fields.ToArray();
					var layout = fieldLayout.Clone() as byte[];
					Array.Sort(layout, fields);
					for (byte j = 0; j < 6; j++)
						layout[j] = j;
					Array.Sort(fieldLayout, layout);
					fieldLayout = layout;
					dataType.Fields.Clear();
					foreach (FieldDef f in fields)
						dataType.Fields.Add(f);
				}
				name.MarkHelper(def, marker, parent);
				if (def is MethodDef)
					parent.ExcludeMethod(context, (MethodDef)def);
			}
			parent.ExcludeMethod(context, cctor);
		}

		public void HandleMD(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			// move initialization away from module initializer
			cctorRepl.Body = cctor.Body;
			cctor.Body = new CilBody();
			cctor.Body.Instructions.Add(Instruction.Create(OpCodes.Call, initMethod));
			cctor.Body.Instructions.Add(Instruction.Create(OpCodes.Call, cctorRepl));
			cctor.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));

			methods = parameters.Targets.OfType<MethodDef>().Where(method => method.HasBody).ToList();
			context.CurrentModuleWriterOptions.WriterEvent += OnWriterEvent;
		}

		void OnWriterEvent(object sender, ModuleWriterEventArgs e) {
			var writer = (ModuleWriterBase)sender;
			if (e.Event == ModuleWriterEvent.MDBeginWriteMethodBodies) {
				context.Logger.Debug("Extracting method bodies...");
				CreateSection(writer);
			}
			else if (e.Event == ModuleWriterEvent.BeginStrongNameSign) {
				context.Logger.Debug("Encrypting method section...");
				EncryptSection(writer);
			}
		}

		void CreateSection(ModuleWriterBase writer) {
			// move some PE parts to separate section to prevent it from being hashed
			var peSection = new PESection("", 0x60000020);
			bool moved = false;
			uint alignment;
			if (writer.StrongNameSignature != null) {
				alignment = writer.TextSection.Remove(writer.StrongNameSignature).Value;
				peSection.Add(writer.StrongNameSignature, alignment);
				moved = true;
			}
			var managedWriter = writer as ModuleWriter;
			if (managedWriter != null) {
				if (managedWriter.ImportAddressTable != null) {
					alignment = writer.TextSection.Remove(managedWriter.ImportAddressTable).Value;
					peSection.Add(managedWriter.ImportAddressTable, alignment);
					moved = true;
				}
				if (managedWriter.StartupStub != null) {
					alignment = writer.TextSection.Remove(managedWriter.StartupStub).Value;
					peSection.Add(managedWriter.StartupStub, alignment);
					moved = true;
				}
			}
			if (moved)
				writer.Sections.AddBeforeReloc(peSection);

			// create section
			var nameBuffer = new byte[8];
			nameBuffer[0] = (byte)(name1 >> 0);
			nameBuffer[1] = (byte)(name1 >> 8);
			nameBuffer[2] = (byte)(name1 >> 16);
			nameBuffer[3] = (byte)(name1 >> 24);
			nameBuffer[4] = (byte)(name2 >> 0);
			nameBuffer[5] = (byte)(name2 >> 8);
			nameBuffer[6] = (byte)(name2 >> 16);
			nameBuffer[7] = (byte)(name2 >> 24);
			var newSection = new PESection(Encoding.ASCII.GetString(nameBuffer), 0xE0000040);
			writer.Sections.InsertBeforeReloc(random.NextInt32(writer.Sections.Count), newSection);

			// random padding at beginning to prevent revealing hash key
			newSection.Add(new ByteArrayChunk(random.NextBytes(0x10)), 0x10);

			// create index
			var bodyIndex = new JITBodyIndex(methods.Select(method => writer.Metadata.GetToken(method).Raw));
			newSection.Add(bodyIndex, 0x10);

			// save methods
			foreach (MethodDef method in methods.WithProgress(context.Logger)) {
				if (!method.HasBody)
					continue;

				MDToken token = writer.Metadata.GetToken(method);

				var jitBody = new JITMethodBody();
				var bodyWriter = new JITMethodBodyWriter(writer.Metadata, method.Body, jitBody, random.NextUInt32(), writer.Metadata.KeepOldMaxStack || method.Body.KeepOldMaxStack);
				bodyWriter.Write();
				jitBody.Serialize(token.Raw, key, fieldLayout);
				bodyIndex.Add(token.Raw, jitBody);

				method.Body = NopBody;
				RawMethodRow methodRow = writer.Metadata.TablesHeap.MethodTable[token.Rid];
				writer.Metadata.TablesHeap.MethodTable[token.Rid] = new RawMethodRow(
					methodRow.RVA,
					(ushort)(methodRow.ImplFlags | (ushort)MethodImplAttributes.NoInlining),
					methodRow.Flags,
					methodRow.Name,
					methodRow.Signature,
					methodRow.ParamList);

				context.CheckCancellation();
			}
			bodyIndex.PopulateSection(newSection);

			// padding to prevent bad size due to shift division
			newSection.Add(new ByteArrayChunk(new byte[4]), 4);
		}

		void EncryptSection(ModuleWriterBase writer) {
			Stream stream = writer.DestinationStream;
			var reader = new BinaryReader(writer.DestinationStream);
			stream.Position = 0x3C;
			stream.Position = reader.ReadUInt32();

			stream.Position += 6;
			ushort sections = reader.ReadUInt16();
			stream.Position += 0xc;
			ushort optSize = reader.ReadUInt16();
			stream.Position += 2 + optSize;

			uint encLoc = 0, encSize = 0;
			int origSects = -1;
			if (writer is NativeModuleWriter && writer.Module is ModuleDefMD)
				origSects = ((ModuleDefMD)writer.Module).Metadata.PEImage.ImageSectionHeaders.Count;
			for (int i = 0; i < sections; i++) {
				uint nameHash;
				if (origSects > 0) {
					origSects--;
					stream.Write(new byte[8], 0, 8);
					nameHash = 0;
				}
				else
					nameHash = reader.ReadUInt32() * reader.ReadUInt32();
				stream.Position += 8;
				if (nameHash == name1 * name2) {
					encSize = reader.ReadUInt32();
					encLoc = reader.ReadUInt32();
				}
				else if (nameHash != 0) {
					uint sectSize = reader.ReadUInt32();
					uint sectLoc = reader.ReadUInt32();
					Hash(stream, reader, sectLoc, sectSize);
				}
				else
					stream.Position += 8;
				stream.Position += 16;
			}

			uint[] key = DeriveKey();
			encSize >>= 2;
			stream.Position = encLoc;
			var result = new uint[encSize];
			for (uint i = 0; i < encSize; i++) {
				uint data = reader.ReadUInt32();
				result[i] = data ^ key[i & 0xf];
				key[i & 0xf] = (key[i & 0xf] ^ data) + 0x3dbb2819;
			}
			var byteResult = new byte[encSize << 2];
			Buffer.BlockCopy(result, 0, byteResult, 0, byteResult.Length);
			stream.Position = encLoc;
			stream.Write(byteResult, 0, byteResult.Length);
		}

		void Hash(Stream stream, BinaryReader reader, uint offset, uint size) {
			long original = stream.Position;
			stream.Position = offset;
			size >>= 2;
			for (uint i = 0; i < size; i++) {
				uint data = reader.ReadUInt32();
				uint tmp = (z ^ data) + x + c * v;
				z = x;
				x = c;
				x = v;
				v = tmp;
			}
			stream.Position = original;
		}

		uint[] DeriveKey() {
			uint[] dst = new uint[0x10], src = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				dst[i] = v;
				src[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);
				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			return deriver.DeriveKey(dst, src);
		}
	}
}

```

`Confuser.Protections/AntiTamper/NormalDeriver.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.AntiTamper {
	internal class NormalDeriver : IKeyDeriver {
		public void Init(ConfuserContext ctx, RandomGenerator random) {
			//
		}

		public uint[] DeriveKey(uint[] a, uint[] b) {
			var ret = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				switch (i % 3) {
					case 0:
						ret[i] = a[i] ^ b[i];
						break;
					case 1:
						ret[i] = a[i] * b[i];
						break;
					case 2:
						ret[i] = a[i] + b[i];
						break;
				}
			}
			return ret;
		}

		public IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src) {
			for (int i = 0; i < 0x10; i++) {
				yield return Instruction.Create(OpCodes.Ldloc, dst);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldloc, dst);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Ldloc, src);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				switch (i % 3) {
					case 0:
						yield return Instruction.Create(OpCodes.Xor);
						break;
					case 1:
						yield return Instruction.Create(OpCodes.Mul);
						break;
					case 2:
						yield return Instruction.Create(OpCodes.Add);
						break;
				}
				yield return Instruction.Create(OpCodes.Stelem_I4);
			}
		}
	}
}
```

`Confuser.Protections/AntiTamper/NormalMode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using MethodBody = dnlib.DotNet.Writer.MethodBody;

namespace Confuser.Protections.AntiTamper {
	internal class NormalMode : IModeHandler {
		uint c;
		IKeyDeriver deriver;

		List<MethodDef> methods;
		uint name1, name2;
		RandomGenerator random;
		uint v;
		uint x;
		uint z;

		public void HandleInject(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			random = context.Registry.GetService<IRandomService>().GetRandomGenerator(parent.FullId);
			z = random.NextUInt32();
			x = random.NextUInt32();
			c = random.NextUInt32();
			v = random.NextUInt32();
			name1 = random.NextUInt32() & 0x7f7f7f7f;
			name2 = random.NextUInt32() & 0x7f7f7f7f;

			switch (parameters.GetParameter(context, context.CurrentModule, "key", Mode.Normal)) {
				case Mode.Normal:
					deriver = new NormalDeriver();
					break;
				case Mode.Dynamic:
					deriver = new DynamicDeriver();
					break;
				default:
					throw new UnreachableException();
			}
			deriver.Init(context, random);

			var rt = context.Registry.GetService<IRuntimeService>();
			TypeDef initType = rt.GetRuntimeType("Confuser.Runtime.AntiTamperNormal");
			IEnumerable<IDnlibDef> members = InjectHelper.Inject(initType, context.CurrentModule.GlobalType, context.CurrentModule);
			var initMethod = (MethodDef)members.Single(m => m.Name == "Initialize");

			initMethod.Body.SimplifyMacros(initMethod.Parameters);
			List<Instruction> instrs = initMethod.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				if (instr.OpCode == OpCodes.Ldtoken) {
					instr.Operand = context.CurrentModule.GlobalType;
				}
				else if (instr.OpCode == OpCodes.Call) {
					var method = (IMethod)instr.Operand;
					if (method.DeclaringType.Name == "Mutation" &&
						method.Name == "Crypt") {
						Instruction ldDst = instrs[i - 2];
						Instruction ldSrc = instrs[i - 1];
						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, deriver.EmitDerivation(initMethod, context, (Local)ldDst.Operand, (Local)ldSrc.Operand));
					}
				}
			}
			initMethod.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				initMethod.Body.Instructions.Add(instr);

			MutationHelper.InjectKeys(initMethod,
									  new[] { 0, 1, 2, 3, 4 },
									  new[] { (int)(name1 * name2), (int)z, (int)x, (int)c, (int)v });

			var name = context.Registry.GetService<INameService>();
			var marker = context.Registry.GetService<IMarkerService>();
			foreach (IDnlibDef def in members) {
				name.MarkHelper(def, marker, parent);
				if (def is MethodDef)
					parent.ExcludeMethod(context, (MethodDef)def);
			}

			MethodDef cctor = context.CurrentModule.GlobalType.FindStaticConstructor();
			cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, initMethod));

			parent.ExcludeMethod(context, cctor);
		}

		public void HandleMD(AntiTamperProtection parent, ConfuserContext context, ProtectionParameters parameters) {
			methods = parameters.Targets.OfType<MethodDef>().ToList();
			context.CurrentModuleWriterOptions.WriterEvent += WriterEvent;
		}

		void WriterEvent(object sender, ModuleWriterEventArgs e) {
			switch (e.Event)
			{
				case ModuleWriterEvent.MDEndCreateTables:
					CreateSections(e.Writer);
					break;
				case ModuleWriterEvent.BeginStrongNameSign:
					EncryptSection(e.Writer);
					break;
			}
		}

		void CreateSections(ModuleWriterBase writer) {
			var nameBuffer = new byte[8];
			nameBuffer[0] = (byte)(name1 >> 0);
			nameBuffer[1] = (byte)(name1 >> 8);
			nameBuffer[2] = (byte)(name1 >> 16);
			nameBuffer[3] = (byte)(name1 >> 24);
			nameBuffer[4] = (byte)(name2 >> 0);
			nameBuffer[5] = (byte)(name2 >> 8);
			nameBuffer[6] = (byte)(name2 >> 16);
			nameBuffer[7] = (byte)(name2 >> 24);
			var newSection = new PESection(Encoding.ASCII.GetString(nameBuffer), 0xE0000040);
			writer.Sections.Insert(0, newSection); // insert first to ensure proper RVA

			uint alignment;

			alignment = writer.TextSection.Remove(writer.Metadata).Value;
			writer.TextSection.Add(writer.Metadata, alignment);

			alignment = writer.TextSection.Remove(writer.NetResources).Value;
			writer.TextSection.Add(writer.NetResources, alignment);

			alignment = writer.TextSection.Remove(writer.Constants).Value;
			newSection.Add(writer.Constants, alignment);

			// move some PE parts to separate section to prevent it from being hashed
			var peSection = new PESection("", 0x60000020);
			bool moved = false;
			if (writer.StrongNameSignature != null) {
				alignment = writer.TextSection.Remove(writer.StrongNameSignature).Value;
				peSection.Add(writer.StrongNameSignature, alignment);
				moved = true;
			}
			var managedWriter = writer as ModuleWriter;
			if (managedWriter != null) {
				if (managedWriter.ImportAddressTable != null) {
					alignment = writer.TextSection.Remove(managedWriter.ImportAddressTable).Value;
					peSection.Add(managedWriter.ImportAddressTable, alignment);
					moved = true;
				}
				if (managedWriter.StartupStub != null) {
					alignment = writer.TextSection.Remove(managedWriter.StartupStub).Value;
					peSection.Add(managedWriter.StartupStub, alignment);
					moved = true;
				}
			}
			if (moved)
				writer.Sections.AddBeforeReloc(peSection);

			// move encrypted methods
			var encryptedChunk = new MethodBodyChunks(writer.TheOptions.ShareMethodBodies);
			newSection.Add(encryptedChunk, 4);
			foreach (MethodDef method in methods) {
				if (!method.HasBody)
					continue;
				MethodBody body = writer.Metadata.GetMethodBody(method);
				bool ok = writer.MethodBodies.Remove(body);
				encryptedChunk.Add(body);
			}

			// padding to prevent bad size due to shift division
			newSection.Add(new ByteArrayChunk(new byte[4]), 4);
		}

		void EncryptSection(ModuleWriterBase writer) {
			Stream stream = writer.DestinationStream;
			var reader = new BinaryReader(writer.DestinationStream);
			stream.Position = 0x3C;
			stream.Position = reader.ReadUInt32();

			stream.Position += 6;
			ushort sections = reader.ReadUInt16();
			stream.Position += 0xc;
			ushort optSize = reader.ReadUInt16();
			stream.Position += 2 + optSize;

			uint encLoc = 0, encSize = 0;
			int origSects = -1;
			if (writer is NativeModuleWriter && writer.Module is ModuleDefMD)
				origSects = ((ModuleDefMD)writer.Module).Metadata.PEImage.ImageSectionHeaders.Count;
			for (int i = 0; i < sections; i++) {
				uint nameHash;
				if (origSects > 0) {
					origSects--;
					stream.Write(new byte[8], 0, 8);
					nameHash = 0;
				}
				else
					nameHash = reader.ReadUInt32() * reader.ReadUInt32();
				stream.Position += 8;
				if (nameHash == name1 * name2) {
					encSize = reader.ReadUInt32();
					encLoc = reader.ReadUInt32();
				}
				else if (nameHash != 0) {
					uint sectSize = reader.ReadUInt32();
					uint sectLoc = reader.ReadUInt32();
					Hash(stream, reader, sectLoc, sectSize);
				}
				else
					stream.Position += 8;
				stream.Position += 16;
			}

			uint[] key = DeriveKey();
			encSize >>= 2;
			stream.Position = encLoc;
			var result = new uint[encSize];
			for (uint i = 0; i < encSize; i++) {
				uint data = reader.ReadUInt32();
				result[i] = data ^ key[i & 0xf];
				key[i & 0xf] = (key[i & 0xf] ^ data) + 0x3dbb2819;
			}
			var byteResult = new byte[encSize << 2];
			Buffer.BlockCopy(result, 0, byteResult, 0, byteResult.Length);
			stream.Position = encLoc;
			stream.Write(byteResult, 0, byteResult.Length);
		}

		void Hash(Stream stream, BinaryReader reader, uint offset, uint size) {
			long original = stream.Position;
			stream.Position = offset;
			size >>= 2;
			for (uint i = 0; i < size; i++) {
				uint data = reader.ReadUInt32();
				uint tmp = (z ^ data) + x + c * v;
				z = x;
				x = c;
				x = v;
				v = tmp;
			}
			stream.Position = original;
		}

		uint[] DeriveKey() {
			uint[] dst = new uint[0x10], src = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				dst[i] = v;
				src[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);
				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			return deriver.DeriveKey(dst, src);
		}
	}
}

```

`Confuser.Protections/Compress/Compressor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Protections.Compress;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;
using dnlib.PE;
using FileAttributes = dnlib.DotNet.FileAttributes;
using SR = System.Reflection;

namespace Confuser.Protections {
	internal class Compressor : Packer {
		public const string _Id = "compressor";
		public const string _FullId = "Ki.Compressor";
		public const string _ServiceId = "Ki.Compressor";
		public static readonly object ContextKey = new object();

		public override string Name {
			get { return "Compressing Packer"; }
		}

		public override string Description {
			get { return "This packer reduces the size of output."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		protected override void Initialize(ConfuserContext context) { }

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.WriteModule, new ExtractPhase(this));
		}

		protected override void Pack(ConfuserContext context, ProtectionParameters parameters) {
			var ctx = context.Annotations.Get<CompressorContext>(context, ContextKey);
			if (ctx == null) {
				context.Logger.Error("No executable module!");
				throw new ConfuserException(null);
			}

			ModuleDefMD originModule = context.Modules[ctx.ModuleIndex];
			ctx.OriginModuleDef = originModule;

			var stubModule = new ModuleDefUser(ctx.ModuleName, originModule.Mvid, originModule.CorLibTypes.AssemblyRef);
			if (ctx.CompatMode) {
				var assembly = new AssemblyDefUser(originModule.Assembly);
				assembly.Name += ".cr";
				assembly.Modules.Add(stubModule);
			}
			else {
				ctx.Assembly.Modules.Insert(0, stubModule);
				ImportAssemblyTypeReferences(originModule, stubModule);
			}
			stubModule.Characteristics = originModule.Characteristics;
			stubModule.Cor20HeaderFlags = originModule.Cor20HeaderFlags;
			stubModule.Cor20HeaderRuntimeVersion = originModule.Cor20HeaderRuntimeVersion;
			stubModule.DllCharacteristics = originModule.DllCharacteristics;
			stubModule.EncBaseId = originModule.EncBaseId;
			stubModule.EncId = originModule.EncId;
			stubModule.Generation = originModule.Generation;
			stubModule.Kind = ctx.Kind;
			stubModule.Machine = originModule.Machine;
			stubModule.RuntimeVersion = originModule.RuntimeVersion;
			stubModule.TablesHeaderVersion = originModule.TablesHeaderVersion;
			stubModule.Win32Resources = originModule.Win32Resources;

			InjectStub(context, ctx, parameters, stubModule);

			var snKey = context.Annotations.Get<StrongNameKey>(originModule, Marker.SNKey);
			var snPubKey = context.Annotations.Get<StrongNamePublicKey>(originModule, Marker.SNPubKey);
			var snDelaySig = context.Annotations.Get<bool>(originModule, Marker.SNDelaySig, false);
			var snSigKey = context.Annotations.Get<StrongNameKey>(originModule, Marker.SNSigKey);
			var snPubSigKey = context.Annotations.Get<StrongNamePublicKey>(originModule, Marker.SNSigPubKey);

			using (var ms = new MemoryStream()) {
				var options = new ModuleWriterOptions(stubModule) {
					StrongNameKey = snKey,
					StrongNamePublicKey = snPubKey,
					DelaySign = snDelaySig
				};
				var injector = new KeyInjector(ctx);
				options.WriterEvent += injector.WriterEvent;

				stubModule.Write(ms, options);
				context.CheckCancellation();
				ProtectStub(context, context.OutputPaths[ctx.ModuleIndex], ms.ToArray(), snKey, snPubKey, snSigKey, snPubKey, snDelaySig, new StubProtection(ctx, originModule));
			}
		}

		static string GetId(byte[] module) {
			var md = MetadataFactory.CreateMetadata(new PEImage(module));
			var assembly = new AssemblyNameInfo();
			if (md.TablesStream.TryReadAssemblyRow(1, out var assemblyRow)) {
				assembly.Name = md.StringsStream.ReadNoNull(assemblyRow.Name);
				assembly.Culture = md.StringsStream.ReadNoNull(assemblyRow.Locale);
				assembly.PublicKeyOrToken = new PublicKey(md.BlobStream.Read(assemblyRow.PublicKey));
				assembly.HashAlgId = (AssemblyHashAlgorithm)assemblyRow.HashAlgId;
				assembly.Version = new Version(assemblyRow.MajorVersion, assemblyRow.MinorVersion, assemblyRow.BuildNumber, assemblyRow.RevisionNumber);
				assembly.Attributes = (AssemblyAttributes)assemblyRow.Flags;
			}
			return GetId(assembly);
		}

		static string GetId(IAssembly assembly) {
			return new SR.AssemblyName(assembly.FullName).FullName.ToUpperInvariant();
		}

		void PackModules(ConfuserContext context, CompressorContext compCtx, ModuleDef stubModule, ICompressionService comp, RandomGenerator random) {
			int maxLen = 0;
			var modules = new Dictionary<string, byte[]>();
			for (int i = 0; i < context.OutputModules.Count; i++) {
				if (i == compCtx.ModuleIndex)
					continue;

				string id = GetId(context.Modules[i].Assembly);
				modules.Add(id, context.OutputModules[i]);

				int strLen = Encoding.UTF8.GetByteCount(id);
				if (strLen > maxLen)
					maxLen = strLen;
			}
			foreach (var extModule in context.ExternalModules) {
				var name = GetId(extModule).ToUpperInvariant();
				modules.Add(name, extModule);

				int strLen = Encoding.UTF8.GetByteCount(name);
				if (strLen > maxLen)
					maxLen = strLen;
			}

			byte[] key = random.NextBytes(4 + maxLen);
			key[0] = (byte)(compCtx.EntryPointToken >> 0);
			key[1] = (byte)(compCtx.EntryPointToken >> 8);
			key[2] = (byte)(compCtx.EntryPointToken >> 16);
			key[3] = (byte)(compCtx.EntryPointToken >> 24);
			for (int i = 4; i < key.Length; i++) // no zero bytes
				key[i] |= 1;
			compCtx.KeySig = key;

			int moduleIndex = 0;
			foreach (var entry in modules) {
				byte[] name = Encoding.UTF8.GetBytes(entry.Key);
				for (int i = 0; i < name.Length; i++)
					name[i] *= key[i + 4];

				uint state = 0x6fff61;
				foreach (byte chr in name)
					state = state * 0x5e3f1f + chr;
				byte[] encrypted = compCtx.Encrypt(comp, entry.Value, state, progress => {
					progress = (progress + moduleIndex) / modules.Count;
					context.Logger.Progress((int)(progress * 10000), 10000);
				});
				context.CheckCancellation();

				var resource = new EmbeddedResource(Convert.ToBase64String(name), encrypted, ManifestResourceAttributes.Private);
				stubModule.Resources.Add(resource);
				moduleIndex++;
			}
			context.Logger.EndProgress();
		}

		void InjectData(ModuleDef stubModule, MethodDef method, byte[] data) {
			var dataType = new TypeDefUser("", "DataType", stubModule.CorLibTypes.GetTypeRef("System", "ValueType"));
			dataType.Layout = TypeAttributes.ExplicitLayout;
			dataType.Visibility = TypeAttributes.NestedPrivate;
			dataType.IsSealed = true;
			dataType.ClassLayout = new ClassLayoutUser(1, (uint)data.Length);
			stubModule.GlobalType.NestedTypes.Add(dataType);

			var dataField = new FieldDefUser("DataField", new FieldSig(dataType.ToTypeSig())) {
				IsStatic = true,
				HasFieldRVA = true,
				InitialValue = data,
				Access = FieldAttributes.CompilerControlled
			};
			stubModule.GlobalType.Fields.Add(dataField);

			MutationHelper.ReplacePlaceholder(method, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Dup));
				repl.Add(Instruction.Create(OpCodes.Ldtoken, dataField));
				repl.Add(Instruction.Create(OpCodes.Call, stubModule.Import(
					typeof(RuntimeHelpers).GetMethod("InitializeArray"))));
				return repl.ToArray();
			});
		}

		void InjectStub(ConfuserContext context, CompressorContext compCtx, ProtectionParameters parameters, ModuleDef stubModule) {
			var rt = context.Registry.GetService<IRuntimeService>();
			RandomGenerator random = context.Registry.GetService<IRandomService>().GetRandomGenerator(Id);
			var comp = context.Registry.GetService<ICompressionService>();

			var rtType = rt.GetRuntimeType(compCtx.CompatMode ? "Confuser.Runtime.CompressorCompat" : "Confuser.Runtime.Compressor");
			IEnumerable<IDnlibDef> defs = InjectHelper.Inject(rtType, stubModule.GlobalType, stubModule);

			switch (parameters.GetParameter(context, context.CurrentModule, "key", Mode.Normal)) {
			case Mode.Normal:
				compCtx.Deriver = new NormalDeriver();
				break;
			case Mode.Dynamic:
				compCtx.Deriver = new DynamicDeriver();
				break;
			default:
				throw new UnreachableException();
			}
			compCtx.Deriver.Init(context, random);

			context.Logger.Debug("Encrypting modules...");

			// Main
			MethodDef entryPoint = defs.OfType<MethodDef>().Single(method => method.Name == "Main");
			stubModule.EntryPoint = entryPoint;

			if (compCtx.EntryPoint.HasAttribute("System.STAThreadAttribute")) {
				var attrType = stubModule.CorLibTypes.GetTypeRef("System", "STAThreadAttribute");
				var ctorSig = MethodSig.CreateInstance(stubModule.CorLibTypes.Void);
				entryPoint.CustomAttributes.Add(new CustomAttribute(
					new MemberRefUser(stubModule, ".ctor", ctorSig, attrType)));
			}
			else if (compCtx.EntryPoint.HasAttribute("System.MTAThreadAttribute")) {
				var attrType = stubModule.CorLibTypes.GetTypeRef("System", "MTAThreadAttribute");
				var ctorSig = MethodSig.CreateInstance(stubModule.CorLibTypes.Void);
				entryPoint.CustomAttributes.Add(new CustomAttribute(
					new MemberRefUser(stubModule, ".ctor", ctorSig, attrType)));
			}

			uint seed = random.NextUInt32();
			compCtx.OriginModule = context.OutputModules[compCtx.ModuleIndex];

			byte[] encryptedModule = compCtx.Encrypt(comp, compCtx.OriginModule, seed,
													 progress => context.Logger.Progress((int)(progress * 10000), 10000));
			context.Logger.EndProgress();
			context.CheckCancellation();

			compCtx.EncryptedModule = encryptedModule;

			MutationHelper.InjectKeys(entryPoint,
									  new[] { 0, 1 },
									  new[] { encryptedModule.Length >> 2, (int)seed });
			InjectData(stubModule, entryPoint, encryptedModule);

			// Decrypt
			MethodDef decrypter = defs.OfType<MethodDef>().Single(method => method.Name == "Decrypt");
			decrypter.Body.SimplifyMacros(decrypter.Parameters);
			List<Instruction> instrs = decrypter.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				if (instr.OpCode == OpCodes.Call) {
					var method = (IMethod)instr.Operand;
					if (method.DeclaringType.Name == "Mutation" &&
						method.Name == "Crypt") {
						Instruction ldDst = instrs[i - 2];
						Instruction ldSrc = instrs[i - 1];
						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, compCtx.Deriver.EmitDerivation(decrypter, context, (Local)ldDst.Operand, (Local)ldSrc.Operand));
					}
					else if (method.DeclaringType.Name == "Lzma" &&
							 method.Name == "Decompress") {
						MethodDef decomp = comp.GetRuntimeDecompressor(stubModule, member => { });
						instr.Operand = decomp;
					}
				}
			}
			decrypter.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				decrypter.Body.Instructions.Add(instr);

			// Pack modules
			PackModules(context, compCtx, stubModule, comp, random);
		}

		void ImportAssemblyTypeReferences(ModuleDef originModule, ModuleDef stubModule) {
			var assembly = stubModule.Assembly;
			foreach (var ca in assembly.CustomAttributes) {
				if (ca.AttributeType.Scope == originModule)
					ca.Constructor = (ICustomAttributeType)stubModule.Import(ca.Constructor);
			}
			foreach (var ca in assembly.DeclSecurities.SelectMany(declSec => declSec.CustomAttributes)) {
				if (ca.AttributeType.Scope == originModule)
					ca.Constructor = (ICustomAttributeType)stubModule.Import(ca.Constructor);
			}
		}

		class KeyInjector {
			readonly CompressorContext ctx;

			public KeyInjector(CompressorContext ctx) {
				this.ctx = ctx;
			}

			public void WriterEvent(object sender, ModuleWriterEventArgs args) {
				OnWriterEvent(args.Writer, args.Event);
			}

			private void OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt) {
				if (evt == ModuleWriterEvent.MDBeginCreateTables) {
					// Add key signature
					uint sigBlob = writer.Metadata.BlobHeap.Add(ctx.KeySig);
					uint sigRid = writer.Metadata.TablesHeap.StandAloneSigTable.Add(new RawStandAloneSigRow(sigBlob));
					Debug.Assert(sigRid == 1);
					uint sigToken = 0x11000000 | sigRid;
					ctx.KeyToken = sigToken;
					MutationHelper.InjectKey(writer.Module.EntryPoint, 2, (int)sigToken);
				}
				else if (evt == ModuleWriterEvent.MDBeginAddResources && !ctx.CompatMode) {
					// Compute hash
					byte[] hash = SHA1.Create().ComputeHash(ctx.OriginModule);
					uint hashBlob = writer.Metadata.BlobHeap.Add(hash);

					MDTable<RawFileRow> fileTbl = writer.Metadata.TablesHeap.FileTable;
					uint fileRid = fileTbl.Add(new RawFileRow(
												   (uint)FileAttributes.ContainsMetadata,
												   writer.Metadata.StringsHeap.Add("koi"),
												   hashBlob));
					uint impl = CodedToken.Implementation.Encode(new MDToken(Table.File, fileRid));

					// Add resources
					MDTable<RawManifestResourceRow> resTbl = writer.Metadata.TablesHeap.ManifestResourceTable;
					foreach (var resource in ctx.ManifestResources)
						resTbl.Add(new RawManifestResourceRow(resource.Offset, resource.Flags, writer.Metadata.StringsHeap.Add(resource.Value), impl));

					// Add exported types
					var exTbl = writer.Metadata.TablesHeap.ExportedTypeTable;
					foreach (var type in ctx.OriginModuleDef.GetTypes()) {
						if (!type.IsVisibleOutside())
							continue;
						exTbl.Add(new RawExportedTypeRow((uint)type.Attributes, 0,
														 writer.Metadata.StringsHeap.Add(type.Name),
														 writer.Metadata.StringsHeap.Add(type.Namespace), impl));
					}
				}
			}
		}
	}
}

```

`Confuser.Protections/Compress/CompressorContext.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core.Services;
using dnlib.DotNet;

namespace Confuser.Protections.Compress {
	internal class CompressorContext {
		public AssemblyDef Assembly;
		public IKeyDeriver Deriver;
		public byte[] EncryptedModule;
		public MethodDef EntryPoint;
		public uint EntryPointToken;
		public byte[] KeySig;
		public uint KeyToken;
		public ModuleKind Kind;
		public List<(uint Offset, uint Flags, UTF8String Value)> ManifestResources;
		public int ModuleIndex;
		public string ModuleName;
		public byte[] OriginModule;
		public ModuleDef OriginModuleDef;
		public bool CompatMode;

		public byte[] Encrypt(ICompressionService compress, byte[] data, uint seed, Action<double> progressFunc) {
			data = (byte[])data.Clone();
			var dst = new uint[0x10];
			var src = new uint[0x10];
			ulong state = seed;
			for (int i = 0; i < 0x10; i++) {
				state = (state * state) % 0x143fc089;
				src[i] = (uint)state;
				dst[i] = (uint)((state * state) % 0x444d56fb);
			}
			uint[] key = Deriver.DeriveKey(dst, src);

			var z = (uint)(state % 0x8a5cb7);
			for (int i = 0; i < data.Length; i++) {
				data[i] ^= (byte)state;
				if ((i & 0xff) == 0)
					state = (state * state) % 0x8a5cb7;
			}
			data = compress.Compress(data, progressFunc);
			Array.Resize(ref data, (data.Length + 3) & ~3);

			var encryptedData = new byte[data.Length];
			int keyIndex = 0;
			for (int i = 0; i < data.Length; i += 4) {
				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));
				uint encrypted = datum ^ key[keyIndex & 0xf];
				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;
				encryptedData[i + 0] = (byte)(encrypted >> 0);
				encryptedData[i + 1] = (byte)(encrypted >> 8);
				encryptedData[i + 2] = (byte)(encrypted >> 16);
				encryptedData[i + 3] = (byte)(encrypted >> 24);
				keyIndex++;
			}

			return encryptedData;
		}
	}
}

```

`Confuser.Protections/Compress/DynamicDeriver.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Compress {
	internal class DynamicDeriver : IKeyDeriver {
		StatementBlock derivation;
		Action<uint[], uint[]> encryptFunc;

		public void Init(ConfuserContext ctx, RandomGenerator random) {
			StatementBlock dummy;
			ctx.Registry.GetService<IDynCipherService>().GenerateCipherPair(random, out derivation, out dummy);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(derivation);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();
		}

		public uint[] DeriveKey(uint[] a, uint[] b) {
			var ret = new uint[0x10];
			Buffer.BlockCopy(a, 0, ret, 0, a.Length * sizeof(uint));
			encryptFunc(ret, b);
			return ret;
		}

		public IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src) {
			var ret = new List<Instruction>();
			var codeGen = new CodeGen(dst, src, method, ret);
			codeGen.GenerateCIL(derivation);
			codeGen.Commit(method.Body);
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CodeGen(Local block, Local key, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}
	}
}
```

`Confuser.Protections/Compress/ExtractPhase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.Compress {
	internal class ExtractPhase : ProtectionPhase {
		public ExtractPhase(Compressor parent) : base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Modules; }
		}

		public override string Name {
			get { return "Packer info extraction"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			if (context.Packer == null)
				return;

			bool isExe = context.CurrentModule.Kind == ModuleKind.Windows ||
						 context.CurrentModule.Kind == ModuleKind.Console;

			if (context.Annotations.Get<CompressorContext>(context, Compressor.ContextKey) != null) {
				if (isExe) {
					context.Logger.Error("Too many executable modules!");
					throw new ConfuserException(null);
				}
				return;
			}

			if (isExe) {
				var ctx = new CompressorContext {
					ModuleIndex = context.CurrentModuleIndex,
					Assembly = context.CurrentModule.Assembly,
					CompatMode = parameters.GetParameter(context, null, "compat", false)
				};
				context.Annotations.Set(context, Compressor.ContextKey, ctx);

				ctx.ModuleName = context.CurrentModule.Name;
				ctx.EntryPoint = context.CurrentModule.EntryPoint;
				ctx.Kind = context.CurrentModule.Kind;

				if (!ctx.CompatMode) {
					context.CurrentModule.Name = "koi";
					context.CurrentModule.EntryPoint = null;
					context.CurrentModule.Kind = ModuleKind.NetModule;
				}

				context.CurrentModuleWriterOptions.WriterEvent += new ResourceRecorder(ctx).WriterEvent;
			}
		}

		private sealed class ResourceRecorder {
			private readonly CompressorContext ctx;

			public ResourceRecorder(CompressorContext ctx) => this.ctx = ctx;

			public void WriterEvent(object sender, ModuleWriterEventArgs e) {
				if (e.Event == ModuleWriterEvent.MDEndAddResources) {
					var writer = e.Writer;
					ctx.ManifestResources = new List<(uint, uint, UTF8String)>();

					foreach (var resource in writer.Module.Resources) {
						var rid = writer.Metadata.GetManifestResourceRid(resource);
						if (rid != 0) {
							// The resource has a RID assigned. So it is part of the written module.
							var resourceRow = writer.Metadata.TablesHeap.ManifestResourceTable[rid];
							Debug.Assert(resourceRow.Name == writer.Metadata.StringsHeap.Add(resource.Name),
								"Resource with RID has different name in StringHeap?!");
							ctx.ManifestResources.Add((resourceRow.Offset, resourceRow.Flags, resource.Name));
						}
					}

					ctx.EntryPointToken = writer.Metadata.GetToken(ctx.EntryPoint).Raw;
				}
			}
		}
	}
}

```

`Confuser.Protections/Compress/IKeyDeriver.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Compress {
	internal enum Mode {
		Normal,
		Dynamic
	}

	internal interface IKeyDeriver {
		void Init(ConfuserContext ctx, RandomGenerator random);
		uint[] DeriveKey(uint[] a, uint[] b);
		IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src);
	}
}
```

`Confuser.Protections/Compress/NormalDeriver.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Compress {
	internal class NormalDeriver : IKeyDeriver {
		uint k1;
		uint k2;
		uint k3;
		uint seed;

		public void Init(ConfuserContext ctx, RandomGenerator random) {
			k1 = random.NextUInt32() | 1;
			k2 = random.NextUInt32() | 1;
			k3 = random.NextUInt32() | 1;
			seed = random.NextUInt32();
		}

		public uint[] DeriveKey(uint[] a, uint[] b) {
			var ret = new uint[0x10];
			var state = seed;
			for (int i = 0; i < 0x10; i++) {
				switch (state % 3) {
					case 0:
						ret[i] = a[i] ^ b[i];
						break;
					case 1:
						ret[i] = a[i] * b[i];
						break;
					case 2:
						ret[i] = a[i] + b[i];
						break;
				}
				state = (state * state) % 0x2E082D35;
				switch (state % 3) {
					case 0:
						ret[i] += k1;
						break;
					case 1:
						ret[i] ^= k2;
						break;
					case 2:
						ret[i] *= k3;
						break;
				}
				state = (state * state) % 0x2E082D35;
			}
			return ret;
		}

		public IEnumerable<Instruction> EmitDerivation(MethodDef method, ConfuserContext ctx, Local dst, Local src) {
			var state = seed;
			for (int i = 0; i < 0x10; i++) {
				yield return Instruction.Create(OpCodes.Ldloc, dst);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldloc, dst);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Ldloc, src);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				switch (state % 3) {
					case 0:
						yield return Instruction.Create(OpCodes.Xor);
						break;
					case 1:
						yield return Instruction.Create(OpCodes.Mul);
						break;
					case 2:
						yield return Instruction.Create(OpCodes.Add);
						break;
				}
				state = (state * state) % 0x2E082D35;
				switch (state % 3) {
					case 0:
						yield return Instruction.Create(OpCodes.Ldc_I4, (int)k1);
						yield return Instruction.Create(OpCodes.Add);
						break;
					case 1:
						yield return Instruction.Create(OpCodes.Ldc_I4, (int)k2);
						yield return Instruction.Create(OpCodes.Xor);
						break;
					case 2:
						yield return Instruction.Create(OpCodes.Ldc_I4, (int)k3);
						yield return Instruction.Create(OpCodes.Mul);
						break;
				}
				state = (state * state) % 0x2E082D35;
				yield return Instruction.Create(OpCodes.Stelem_I4);
			}
		}
	}
}
```

`Confuser.Protections/Compress/StubProtection.cs`:

```cs
using System;
using System.Diagnostics;
using System.Security.Cryptography;
using Confuser.Core;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.Compress {
	internal class StubProtection : Protection {
		readonly CompressorContext ctx;
		readonly ModuleDef originModule;

		internal StubProtection(CompressorContext ctx, ModuleDef originModule) {
			this.ctx = ctx;
			this.originModule = originModule;
		}

		public override string Name {
			get { return "Compressor Stub Protection"; }
		}

		public override string Description {
			get { return "Do some extra works on the protected stub."; }
		}

		public override string Id {
			get { return "Ki.Compressor.Protection"; }
		}

		public override string FullId {
			get { return "Ki.Compressor.Protection"; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.None; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			if (!ctx.CompatMode)
				pipeline.InsertPreStage(PipelineStage.Inspection, new InjPhase(this));
			pipeline.InsertPostStage(PipelineStage.BeginModule, new SigPhase(this));
		}

		class InjPhase : ProtectionPhase {
			public InjPhase(StubProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override bool ProcessAll {
				get { return true; }
			}

			public override string Name {
				get { return "Module injection"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				// Hack the origin module into the assembly to make sure correct type resolution
				var originModule = ((StubProtection)Parent).originModule;
				originModule.Assembly.Modules.Remove(originModule);
				context.Modules[0].Assembly.Modules.Add(((StubProtection)Parent).originModule);
			}
		}

		class SigPhase : ProtectionPhase {
			public SigPhase(StubProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Packer info encoding"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				var field = context.CurrentModule.Types[0].FindField("DataField");
				Debug.Assert(field != null);
				context.Registry.GetService<INameService>().SetCanRename(field, true);

				context.CurrentModuleWriterOptions.WriterEvent += (sender, e) => {
					if (e.Event == ModuleWriterEvent.MDBeginCreateTables) {
						// Add key signature
						var writer = (ModuleWriterBase)sender;
						var prot = (StubProtection)Parent;
						uint blob = writer.Metadata.BlobHeap.Add(prot.ctx.KeySig);
						uint rid = writer.Metadata.TablesHeap.StandAloneSigTable.Add(new RawStandAloneSigRow(blob));
						Debug.Assert((0x11000000 | rid) == prot.ctx.KeyToken);

						if (prot.ctx.CompatMode)
							return;

						// Add File reference
						byte[] hash = SHA1.Create().ComputeHash(prot.ctx.OriginModule);
						uint hashBlob = writer.Metadata.BlobHeap.Add(hash);

						MDTable<RawFileRow> fileTbl = writer.Metadata.TablesHeap.FileTable;
						uint fileRid = fileTbl.Add(new RawFileRow(
							                           (uint)FileAttributes.ContainsMetadata,
							                           writer.Metadata.StringsHeap.Add("koi"),
							                           hashBlob));
					}
				};
			}
		}
	}
}
```

`Confuser.Protections/Confuser.Protections.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\ConfuserEx.Common.props" Condition="Exists('..\ConfuserEx.Common.props')" />

  <PropertyGroup Label="Assembly Settings">
    <TargetFrameworks>net461;netstandard2.0</TargetFrameworks>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>

  <PropertyGroup Label="Assembly Information">
    <Title>ConfuserEx Protections</Title>
    <Description>Protections and packers of ConfuserEx</Description>
  </PropertyGroup>

  <ItemGroup Label="Nuget Dependencies">
    <PackageReference Include="System.ValueTuple" Version="4.5.0" />
  </ItemGroup>

  <ItemGroup Label="Project Dependencies">
    <ProjectReference Include="..\Confuser.DynCipher\Confuser.DynCipher.csproj" />
    <ProjectReference Include="..\Confuser.Renamer\Confuser.Renamer.csproj" />
    <ProjectReference Include="..\Confuser.Runtime\Confuser.Runtime.csproj" Condition="'$(TargetFramework)' == 'net461'" />
  </ItemGroup>

  <Import Project="..\ConfuserEx.Common.targets" Condition="Exists('..\ConfuserEx.Common.targets')" />

</Project>
```

`Confuser.Protections/Constants/CEContext.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class CEContext {
		public ConfuserContext Context;
		public ConstantProtection Protection;
		public ModuleDef Module;

		public FieldDef BufferField;
		public FieldDef DataField;
		public TypeDef DataType;
		public MethodDef InitMethod;

		public int DecoderCount;
		public List<Tuple<MethodDef, DecoderDesc>> Decoders;

		public EncodeElements Elements;
		public List<uint> EncodedBuffer;

		public Mode Mode;
		public IEncodeMode ModeHandler;

		public IDynCipherService DynCipher;
		public IMarkerService Marker;
		public INameService Name;
		public RandomGenerator Random;

		public TypeDef CfgCtxType;
		public MethodDef CfgCtxCtor;
		public MethodDef CfgCtxNext;
		public Dictionary<MethodDef, List<Tuple<Instruction, uint, IMethod>>> ReferenceRepl;
	}

	internal class DecoderDesc {
		public object Data;
		public byte InitializerID;
		public byte NumberID;
		public byte StringID;
	}
}
```

`Confuser.Protections/Constants/ConstantProtection.cs`:

```cs
using System;
using Confuser.Core;
using Confuser.Protections.Constants;
using dnlib.DotNet;

namespace Confuser.Protections {
	public interface IConstantService {
		void ExcludeMethod(ConfuserContext context, MethodDef method);
	}

	[BeforeProtection("Ki.ControlFlow"), AfterProtection("Ki.RefProxy")]
	internal class ConstantProtection : Protection, IConstantService {
		public const string _Id = "constants";
		public const string _FullId = "Ki.Constants";
		public const string _ServiceId = "Ki.Constants";
		internal static readonly object ContextKey = new object();

		public override string Name {
			get { return "Constants Protection"; }
		}

		public override string Description {
			get { return "This protection encodes and compresses constants in the code."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Normal; }
		}

		public void ExcludeMethod(ConfuserContext context, MethodDef method) {
			ProtectionParameters.GetParameters(context, method).Remove(this);
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IConstantService), this);
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new InjectPhase(this));
			pipeline.InsertPostStage(PipelineStage.ProcessModule, new EncodePhase(this));
		}
	}
}
```

`Confuser.Protections/Constants/DynamicMode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using Confuser.Core.Helpers;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class DynamicMode : IEncodeMode {
		Action<uint[], uint[]> encryptFunc;

		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, CEContext ctx, Local block, Local key) {
			StatementBlock encrypt, decrypt;
			ctx.DynCipher.GenerateCipherPair(ctx.Random, out encrypt, out decrypt);
			var ret = new List<Instruction>();

			var codeGen = new CodeGen(block, key, init, ret);
			codeGen.GenerateCIL(decrypt);
			codeGen.Commit(init.Body);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(encrypt);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();

			return ret;
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			Buffer.BlockCopy(data, offset * sizeof(uint), ret, 0, key.Length * sizeof(uint));
			encryptFunc(ret, key);
			return ret;
		}

		public object CreateDecoder(MethodDef decoder, CEContext ctx) {
			uint k1 = ctx.Random.NextUInt32() | 1;
			uint k2 = ctx.Random.NextUInt32();
			MutationHelper.ReplacePlaceholder(decoder, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Ldc_I4, (int)MathsUtils.modInv(k1)));
				repl.Add(Instruction.Create(OpCodes.Mul));
				repl.Add(Instruction.Create(OpCodes.Ldc_I4, (int)k2));
				repl.Add(Instruction.Create(OpCodes.Xor));
				return repl.ToArray();
			});
			return Tuple.Create(k1, k2);
		}

		public uint Encode(object data, CEContext ctx, uint id) {
			var key = (Tuple<uint, uint>)data;
			uint ret = (id ^ key.Item2) * key.Item1;
			Debug.Assert(((ret * MathsUtils.modInv(key.Item1)) ^ key.Item2) == id);
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CodeGen(Local block, Local key, MethodDef init, IList<Instruction> instrs)
				: base(init, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}
	}
}
```

`Confuser.Protections/Constants/EncodeElements.cs`:

```cs
using System;

namespace Confuser.Protections.Constants {
	[Flags]
	internal enum EncodeElements {
		Strings = 1,
		Numbers = 2,
		Primitive = 4,
		Initializers = 8
	}
}
```

`Confuser.Protections/Constants/EncodePhase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class EncodePhase : ProtectionPhase {
		public EncodePhase(ConstantProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Constants encoding"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			var moduleCtx = context.Annotations.Get<CEContext>(context.CurrentModule, ConstantProtection.ContextKey);
			if (!parameters.Targets.Any() || moduleCtx == null)
				return;

			var ldc = new Dictionary<object, List<Tuple<MethodDef, Instruction>>>();
			var ldInit = new Dictionary<byte[], List<Tuple<MethodDef, Instruction>>>(new ByteArrayComparer());

			// Extract constants
			ExtractConstants(context, parameters, moduleCtx, ldc, ldInit);

			// Encode constants
			moduleCtx.ReferenceRepl = new Dictionary<MethodDef, List<Tuple<Instruction, uint, IMethod>>>();
			moduleCtx.EncodedBuffer = new List<uint>();
			foreach (var entry in ldInit.WithProgress(context.Logger)) // Ensure the array length haven't been encoded yet
			{
				EncodeInitializer(moduleCtx, entry.Key, entry.Value);
				context.CheckCancellation();
			}
			foreach (var entry in ldc.WithProgress(context.Logger)) {
				if (entry.Key is string) {
					EncodeString(moduleCtx, (string)entry.Key, entry.Value);
				}
				else if (entry.Key is int) {
					EncodeConstant32(moduleCtx, (uint)(int)entry.Key, context.CurrentModule.CorLibTypes.Int32, entry.Value);
				}
				else if (entry.Key is long) {
					EncodeConstant64(moduleCtx, (uint)((long)entry.Key >> 32), (uint)(long)entry.Key, context.CurrentModule.CorLibTypes.Int64, entry.Value);
				}
				else if (entry.Key is float) {
					var t = new RTransform();
					t.R4 = (float)entry.Key;
					EncodeConstant32(moduleCtx, t.Lo, context.CurrentModule.CorLibTypes.Single, entry.Value);
				}
				else if (entry.Key is double) {
					var t = new RTransform();
					t.R8 = (double)entry.Key;
					EncodeConstant64(moduleCtx, t.Hi, t.Lo, context.CurrentModule.CorLibTypes.Double, entry.Value);
				}
				else
					throw new UnreachableException();
				context.CheckCancellation();
			}
			ReferenceReplacer.ReplaceReference(moduleCtx, parameters);

			// compress
			var encodedBuff = new byte[moduleCtx.EncodedBuffer.Count * 4];
			int buffIndex = 0;
			foreach (uint dat in moduleCtx.EncodedBuffer) {
				encodedBuff[buffIndex++] = (byte)((dat >> 0) & 0xff);
				encodedBuff[buffIndex++] = (byte)((dat >> 8) & 0xff);
				encodedBuff[buffIndex++] = (byte)((dat >> 16) & 0xff);
				encodedBuff[buffIndex++] = (byte)((dat >> 24) & 0xff);
			}
			Debug.Assert(buffIndex == encodedBuff.Length);
			encodedBuff = context.Registry.GetService<ICompressionService>().Compress(encodedBuff);
			context.CheckCancellation();

			uint compressedLen = (uint)(encodedBuff.Length + 3) / 4;
			compressedLen = (compressedLen + 0xfu) & ~0xfu;
			var compressedBuff = new uint[compressedLen];
			Buffer.BlockCopy(encodedBuff, 0, compressedBuff, 0, encodedBuff.Length);
			Debug.Assert(compressedLen % 0x10 == 0);

			// encrypt
			uint keySeed = moduleCtx.Random.NextUInt32();
			var key = new uint[0x10];
			uint state = keySeed;
			for (int i = 0; i < 0x10; i++) {
				state ^= state >> 12;
				state ^= state << 25;
				state ^= state >> 27;
				key[i] = state;
			}

			var encryptedBuffer = new byte[compressedBuff.Length * 4];
			buffIndex = 0;
			while (buffIndex < compressedBuff.Length) {
				uint[] enc = moduleCtx.ModeHandler.Encrypt(compressedBuff, buffIndex, key);
				for (int j = 0; j < 0x10; j++)
					key[j] ^= compressedBuff[buffIndex + j];
				Buffer.BlockCopy(enc, 0, encryptedBuffer, buffIndex * 4, 0x40);
				buffIndex += 0x10;
			}
			Debug.Assert(buffIndex == compressedBuff.Length);

			moduleCtx.DataField.InitialValue = encryptedBuffer;
			moduleCtx.DataField.HasFieldRVA = true;
			moduleCtx.DataType.ClassLayout = new ClassLayoutUser(0, (uint)encryptedBuffer.Length);
			MutationHelper.InjectKeys(moduleCtx.InitMethod,
			                          new[] { 0, 1 },
			                          new[] { encryptedBuffer.Length / 4, (int)keySeed });
			MutationHelper.ReplacePlaceholder(moduleCtx.InitMethod, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Dup));
				repl.Add(Instruction.Create(OpCodes.Ldtoken, moduleCtx.DataField));
				repl.Add(Instruction.Create(OpCodes.Call, moduleCtx.Module.Import(
					typeof(RuntimeHelpers).GetMethod("InitializeArray"))));
				return repl.ToArray();
			});
		}

		void EncodeString(CEContext moduleCtx, string value, List<Tuple<MethodDef, Instruction>> references) {
			int buffIndex = EncodeByteArray(moduleCtx, Encoding.UTF8.GetBytes(value));

			UpdateReference(moduleCtx, moduleCtx.Module.CorLibTypes.String, references, buffIndex, desc => desc.StringID);
		}

		void EncodeConstant32(CEContext moduleCtx, uint value, TypeSig valueType, List<Tuple<MethodDef, Instruction>> references) {
			int buffIndex = moduleCtx.EncodedBuffer.IndexOf(value);
			if (buffIndex == -1) {
				buffIndex = moduleCtx.EncodedBuffer.Count;
				moduleCtx.EncodedBuffer.Add(value);
			}

			UpdateReference(moduleCtx, valueType, references, buffIndex, desc => desc.NumberID);
		}

		void EncodeConstant64(CEContext moduleCtx, uint hi, uint lo, TypeSig valueType, List<Tuple<MethodDef, Instruction>> references) {
			int buffIndex = -1;
			do {
				buffIndex = moduleCtx.EncodedBuffer.IndexOf(lo, buffIndex + 1);
				if (buffIndex + 1 < moduleCtx.EncodedBuffer.Count && moduleCtx.EncodedBuffer[buffIndex + 1] == hi)
					break;
			} while (buffIndex >= 0);
			
			if (buffIndex == -1) {
				buffIndex = moduleCtx.EncodedBuffer.Count;
				moduleCtx.EncodedBuffer.Add(lo);
				moduleCtx.EncodedBuffer.Add(hi);
			}

			UpdateReference(moduleCtx, valueType, references, buffIndex, desc => desc.NumberID);
		}

		void EncodeInitializer(CEContext moduleCtx, byte[] init, List<Tuple<MethodDef, Instruction>> references) {
			int buffIndex = -1;

			foreach (var instr in references) {
				IList<Instruction> instrs = instr.Item1.Body.Instructions;
				int i = instrs.IndexOf(instr.Item2);

				if (buffIndex == -1)
					buffIndex = EncodeByteArray(moduleCtx, init);

				Tuple<MethodDef, DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];
				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);
				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data, moduleCtx, id);

				instrs[i - 4].Operand = (int)id;
				instrs[i - 3].OpCode = OpCodes.Call;
				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());
				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1, new GenericInstMethodSig(arrType));
				instrs.RemoveAt(i - 2);
				instrs.RemoveAt(i - 2);
				instrs.RemoveAt(i - 2);
			}
		}

		int EncodeByteArray(CEContext moduleCtx, byte[] buff) {
			int buffIndex = moduleCtx.EncodedBuffer.Count;
			moduleCtx.EncodedBuffer.Add((uint)buff.Length);

			// byte[] -> uint[]
			int integral = buff.Length / 4, remainder = buff.Length % 4;
			for (int i = 0; i < integral; i++) {
				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));
				moduleCtx.EncodedBuffer.Add(data);
			}
			if (remainder > 0) {
				int baseIndex = integral * 4;
				uint r = 0;
				for (int i = 0; i < remainder; i++)
					r |= (uint)(buff[baseIndex + i] << (i * 8));
				moduleCtx.EncodedBuffer.Add(r);
			}
			return buffIndex;
		}

		void UpdateReference(CEContext moduleCtx, TypeSig valueType, List<Tuple<MethodDef, Instruction>> references, int buffIndex, Func<DecoderDesc, byte> typeID) {
			foreach (var instr in references) {
				Tuple<MethodDef, DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];
				uint id = (uint)buffIndex | (uint)(typeID(decoder.Item2) << 30);
				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data, moduleCtx, id);

				var targetDecoder = new MethodSpecUser(decoder.Item1, new GenericInstMethodSig(valueType));
				moduleCtx.ReferenceRepl.AddListEntry(instr.Item1, Tuple.Create(instr.Item2, id, (IMethod)targetDecoder));
			}
		}

		void RemoveDataFieldRefs(ConfuserContext context, HashSet<FieldDef> dataFields, HashSet<Instruction> fieldRefs) {
			foreach (var type in context.CurrentModule.GetTypes())
				foreach (var method in type.Methods.Where(m => m.HasBody)) {
					foreach (var instr in method.Body.Instructions)
						if (instr.Operand is FieldDef && !fieldRefs.Contains(instr))
							dataFields.Remove((FieldDef)instr.Operand);
				}

			foreach (var fieldToRemove in dataFields) {
				fieldToRemove.DeclaringType.Fields.Remove(fieldToRemove);
			}
		}

		void ExtractConstants(
			ConfuserContext context, ProtectionParameters parameters, CEContext moduleCtx,
			Dictionary<object, List<Tuple<MethodDef, Instruction>>> ldc,
			Dictionary<byte[], List<Tuple<MethodDef, Instruction>>> ldInit) {
			var dataFields = new HashSet<FieldDef>();
			var fieldRefs = new HashSet<Instruction>();
			foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {
				if (!method.HasBody)
					continue;

				moduleCtx.Elements = 0;
				string elements = parameters.GetParameter(context, method, "elements", "SI");
				foreach (char elem in elements)
					switch (elem) {
						case 'S':
						case 's':
							moduleCtx.Elements |= EncodeElements.Strings;
							break;
						case 'N':
						case 'n':
							moduleCtx.Elements |= EncodeElements.Numbers;
							break;
						case 'P':
						case 'p':
							moduleCtx.Elements |= EncodeElements.Primitive;
							break;
						case 'I':
						case 'i':
							moduleCtx.Elements |= EncodeElements.Initializers;
							break;
					}

				if (moduleCtx.Elements == 0)
					continue;

				foreach (Instruction instr in method.Body.Instructions) {
					bool eligible = false;
					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {
						var operand = (string)instr.Operand;
						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
							continue;
						eligible = true;
					}
					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {
						var operand = (IMethod)instr.Operand;
						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&
						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&
						    operand.DeclaringType.Name == "RuntimeHelpers" &&
						    operand.Name == "InitializeArray") {
							IList<Instruction> instrs = method.Body.Instructions;
							int i = instrs.IndexOf(instr);
							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;
							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;
							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;
							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;
							if (!(instrs[i - 3].Operand is ITypeDefOrRef arrayType)) continue;
							if (!arrayType.IsPrimitive) continue;

							var dataField = instrs[i - 1].Operand as FieldDef;
							if (dataField == null)
								continue;
							if (!dataField.HasFieldRVA || dataField.InitialValue == null)
								continue;

							// Prevent array length from being encoded
							var arrLen = (int)instrs[i - 4].Operand;
							if (ldc.ContainsKey(arrLen)) {
								List<Tuple<MethodDef, Instruction>> list = ldc[arrLen];
								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);
								if (list.Count == 0)
									ldc.Remove(arrLen);
							}

							dataFields.Add(dataField);
							fieldRefs.Add(instrs[i - 1]);

							var value = new byte[dataField.InitialValue.Length + 4];
							value[0] = (byte)(arrLen >> 0);
							value[1] = (byte)(arrLen >> 8);
							value[2] = (byte)(arrLen >> 16);
							value[3] = (byte)(arrLen >> 24);
							Buffer.BlockCopy(dataField.InitialValue, 0, value, 4, dataField.InitialValue.Length);
							ldInit.AddListEntry(value, Tuple.Create(method, instr));
						}
					}
					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {
						if (instr.OpCode == OpCodes.Ldc_I4) {
							var operand = (int)instr.Operand;
							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
								continue;
							eligible = true;
						}
						else if (instr.OpCode == OpCodes.Ldc_I8) {
							var operand = (long)instr.Operand;
							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
								continue;
							eligible = true;
						}
						else if (instr.OpCode == OpCodes.Ldc_R4) {
							var operand = (float)instr.Operand;
							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
								continue;
							eligible = true;
						}
						else if (instr.OpCode == OpCodes.Ldc_R8) {
							var operand = (double)instr.Operand;
							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)
								continue;
							eligible = true;
						}
					}

					if (eligible)
						ldc.AddListEntry(instr.Operand, Tuple.Create(method, instr));
				}

				context.CheckCancellation();
			}
			RemoveDataFieldRefs(context, dataFields, fieldRefs);
		}

		class ByteArrayComparer : IEqualityComparer<byte[]> {
			public bool Equals(byte[] x, byte[] y) {
				return x.SequenceEqual(y);
			}

			public int GetHashCode(byte[] obj) {
				int ret = 31;
				foreach (byte v in obj)
					ret = ret * 17 + v;
				return ret;
			}
		}

		[StructLayout(LayoutKind.Explicit)]
		struct RTransform {
			[FieldOffset(0)] public float R4;
			[FieldOffset(0)] public double R8;

			[FieldOffset(4)] public readonly uint Hi;
			[FieldOffset(0)] public readonly uint Lo;
		}
	}
}

```

`Confuser.Protections/Constants/IEncodeMode.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal interface IEncodeMode {
		IEnumerable<Instruction> EmitDecrypt(MethodDef init, CEContext ctx, Local block, Local key);
		uint[] Encrypt(uint[] data, int offset, uint[] key);

		object CreateDecoder(MethodDef decoder, CEContext ctx);
		uint Encode(object data, CEContext ctx, uint id);
	}
}
```

`Confuser.Protections/Constants/InjectPhase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;

namespace Confuser.Protections.Constants {
	internal class InjectPhase : ProtectionPhase {
		public InjectPhase(ConstantProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Constant encryption helpers injection"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			if (parameters.Targets.Any()) {
				var compression = context.Registry.GetService<ICompressionService>();
				var name = context.Registry.GetService<INameService>();
				var marker = context.Registry.GetService<IMarkerService>();
				var rt = context.Registry.GetService<IRuntimeService>();
				var moduleCtx = new CEContext {
					Protection = (ConstantProtection)Parent,
					Random = context.Registry.GetService<IRandomService>().GetRandomGenerator(Parent.Id),
					Context = context,
					Module = context.CurrentModule,
					Marker = marker,
					DynCipher = context.Registry.GetService<IDynCipherService>(),
					Name = name
				};

				// Extract parameters
				moduleCtx.Mode = parameters.GetParameter(context, context.CurrentModule, "mode", Mode.Normal);
				moduleCtx.DecoderCount = parameters.GetParameter(context, context.CurrentModule, "decoderCount", 5);

				switch (moduleCtx.Mode) {
					case Mode.Normal:
						moduleCtx.ModeHandler = new NormalMode();
						break;
					case Mode.Dynamic:
						moduleCtx.ModeHandler = new DynamicMode();
						break;
					case Mode.x86:
						moduleCtx.ModeHandler = new x86Mode();
						if ((context.CurrentModule.Cor20HeaderFlags & ComImageFlags.ILOnly) != 0)
							context.CurrentModuleWriterOptions.Cor20HeaderOptions.Flags &= ~ComImageFlags.ILOnly;
						break;
					default:
						throw new UnreachableException();
				}

				// Inject helpers
				MethodDef decomp = compression.GetRuntimeDecompressor(context.CurrentModule, member => {
					name.MarkHelper(member, marker, (Protection)Parent);
					if (member is MethodDef)
						ProtectionParameters.GetParameters(context, member).Remove(Parent);
				});
				InjectHelpers(context, compression, rt, moduleCtx);

				// Mutate codes
				MutateInitializer(moduleCtx, decomp);

				MethodDef cctor = context.CurrentModule.GlobalType.FindStaticConstructor();
				cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, moduleCtx.InitMethod));

				context.Annotations.Set(context.CurrentModule, ConstantProtection.ContextKey, moduleCtx);
			}
		}

		void InjectHelpers(ConfuserContext context, ICompressionService compression, IRuntimeService rt, CEContext moduleCtx) {
			IEnumerable<IDnlibDef> members = InjectHelper.Inject(rt.GetRuntimeType("Confuser.Runtime.Constant"), context.CurrentModule.GlobalType, context.CurrentModule);
			foreach (IDnlibDef member in members) {
				if (member.Name == "Get") {
					context.CurrentModule.GlobalType.Remove((MethodDef)member);
					continue;
				}
				if (member.Name == "b")
					moduleCtx.BufferField = (FieldDef)member;
				else if (member.Name == "Initialize")
					moduleCtx.InitMethod = (MethodDef)member;
				moduleCtx.Name.MarkHelper(member, moduleCtx.Marker, (Protection)Parent);
			}
			ProtectionParameters.GetParameters(context, moduleCtx.InitMethod).Remove(Parent);

			var dataType = new TypeDefUser("", moduleCtx.Name.RandomName(), context.CurrentModule.CorLibTypes.GetTypeRef("System", "ValueType"));
			dataType.Layout = TypeAttributes.ExplicitLayout;
			dataType.Visibility = TypeAttributes.NestedPrivate;
			dataType.IsSealed = true;
			moduleCtx.DataType = dataType;
			context.CurrentModule.GlobalType.NestedTypes.Add(dataType);
			moduleCtx.Name.MarkHelper(dataType, moduleCtx.Marker, (Protection)Parent);

			moduleCtx.DataField = new FieldDefUser(moduleCtx.Name.RandomName(), new FieldSig(dataType.ToTypeSig())) {
				IsStatic = true,
				Access = FieldAttributes.CompilerControlled
			};
			context.CurrentModule.GlobalType.Fields.Add(moduleCtx.DataField);
			moduleCtx.Name.MarkHelper(moduleCtx.DataField, moduleCtx.Marker, (Protection)Parent);

			MethodDef decoder = rt.GetRuntimeType("Confuser.Runtime.Constant").FindMethod("Get");
			moduleCtx.Decoders = new List<Tuple<MethodDef, DecoderDesc>>();
			for (int i = 0; i < moduleCtx.DecoderCount; i++) {
				MethodDef decoderInst = InjectHelper.Inject(decoder, context.CurrentModule);
				for (int j = 0; j < decoderInst.Body.Instructions.Count; j++) {
					Instruction instr = decoderInst.Body.Instructions[j];
					var method = instr.Operand as IMethod;
					var field = instr.Operand as IField;
					if (instr.OpCode == OpCodes.Call &&
					    method.DeclaringType.Name == "Mutation" &&
					    method.Name == "Value") {
						decoderInst.Body.Instructions[j] = Instruction.Create(OpCodes.Sizeof, new GenericMVar(0).ToTypeDefOrRef());
					}
					else if (instr.OpCode == OpCodes.Ldsfld &&
					         method.DeclaringType.Name == "Constant") {
						if (field.Name == "b") instr.Operand = moduleCtx.BufferField;
						else throw new UnreachableException();
					}
				}
				context.CurrentModule.GlobalType.Methods.Add(decoderInst);
				moduleCtx.Name.MarkHelper(decoderInst, moduleCtx.Marker, (Protection)Parent);
				ProtectionParameters.GetParameters(context, decoderInst).Remove(Parent);

				var decoderDesc = new DecoderDesc();

				decoderDesc.StringID = (byte)(moduleCtx.Random.NextByte() & 3);

				do decoderDesc.NumberID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.NumberID == decoderDesc.StringID);

				do decoderDesc.InitializerID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.InitializerID == decoderDesc.StringID || decoderDesc.InitializerID == decoderDesc.NumberID);

				MutationHelper.InjectKeys(decoderInst,
				                          new[] { 0, 1, 2 },
				                          new int[] { decoderDesc.StringID, decoderDesc.NumberID, decoderDesc.InitializerID });
				decoderDesc.Data = moduleCtx.ModeHandler.CreateDecoder(decoderInst, moduleCtx);
				moduleCtx.Decoders.Add(Tuple.Create(decoderInst, decoderDesc));
			}
		}

		void MutateInitializer(CEContext moduleCtx, MethodDef decomp) {
			moduleCtx.InitMethod.Body.SimplifyMacros(moduleCtx.InitMethod.Parameters);
			List<Instruction> instrs = moduleCtx.InitMethod.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				var method = instr.Operand as IMethod;
				if (instr.OpCode == OpCodes.Call) {
					if (method.DeclaringType.Name == "Mutation" &&
					    method.Name == "Crypt") {
						Instruction ldBlock = instrs[i - 2];
						Instruction ldKey = instrs[i - 1];
						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod, moduleCtx, (Local)ldBlock.Operand, (Local)ldKey.Operand));
					}
					else if (method.DeclaringType.Name == "Lzma" &&
					         method.Name == "Decompress") {
						instr.Operand = decomp;
					}
				}
			}
			moduleCtx.InitMethod.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				moduleCtx.InitMethod.Body.Instructions.Add(instr);
		}
	}
}
```

`Confuser.Protections/Constants/Mode.cs`:

```cs
using System;

namespace Confuser.Protections.Constants {
	internal enum Mode {
		Normal,
		Dynamic,
		x86
	}
}
```

`Confuser.Protections/Constants/NormalMode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using Confuser.Core.Helpers;
using Confuser.DynCipher;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class NormalMode : IEncodeMode {
		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, CEContext ctx, Local block, Local key) {
			for (int i = 0; i < 0x10; i++) {
				yield return Instruction.Create(OpCodes.Ldloc, block);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldloc, block);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Ldloc, key);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Xor);
				yield return Instruction.Create(OpCodes.Stelem_I4);
			}
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			for (int i = 0; i < key.Length; i++)
				ret[i] = data[i + offset] ^ key[i];
			return ret;
		}

		public object CreateDecoder(MethodDef decoder, CEContext ctx) {
			uint k1 = ctx.Random.NextUInt32() | 1;
			uint k2 = ctx.Random.NextUInt32();
			MutationHelper.ReplacePlaceholder(decoder, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Ldc_I4, (int)MathsUtils.modInv(k1)));
				repl.Add(Instruction.Create(OpCodes.Mul));
				repl.Add(Instruction.Create(OpCodes.Ldc_I4, (int)k2));
				repl.Add(Instruction.Create(OpCodes.Xor));
				return repl.ToArray();
			});
			return Tuple.Create(k1, k2);
		}

		public uint Encode(object data, CEContext ctx, uint id) {
			var key = (Tuple<uint, uint>)data;
			uint ret = (id ^ key.Item2) * key.Item1;
			Debug.Assert(((ret * MathsUtils.modInv(key.Item1)) ^ key.Item2) == id);
			return ret;
		}
	}
}
```

`Confuser.Protections/Constants/ReferenceReplacer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Constants {
	internal class ReferenceReplacer {
		public static void ReplaceReference(CEContext ctx, ProtectionParameters parameters) {
			foreach (var entry in ctx.ReferenceRepl) {
				EnsureNoInlining(entry.Key);
				if (parameters.GetParameter<bool>(ctx.Context, entry.Key, "cfg"))
					ReplaceCFG(entry.Key, entry.Value, ctx);
				else
					ReplaceNormal(entry.Key, entry.Value);
			}
		}

		static void ReplaceNormal(MethodDef method, List<Tuple<Instruction, uint, IMethod>> instrs) {
			foreach (var instr in instrs) {
				int i = method.Body.Instructions.IndexOf(instr.Item1);
				instr.Item1.OpCode = OpCodes.Ldc_I4;
				instr.Item1.Operand = (int)instr.Item2;
				method.Body.Instructions.Insert(i + 1, Instruction.Create(OpCodes.Call, instr.Item3));
				Instruction instr1 = method.Body.Instructions[i + 1];
				method.Body.Instructions.Insert(i + 1, Instruction.Create(OpCodes.Br_S, instr1));
			}
		}

		static void EnsureNoInlining(MethodDef method) {
			method.ImplAttributes &= ~MethodImplAttributes.AggressiveInlining;
			method.ImplAttributes |= MethodImplAttributes.NoInlining;
		}

		struct CFGContext {
			public CEContext Ctx;
			public ControlFlowGraph Graph;
			public BlockKey[] Keys;
			public RandomGenerator Random;
			public Dictionary<uint, CFGState> StatesMap;
			public Local StateVariable;
		}

		struct CFGState {
			public uint A;
			public uint B;
			public uint C;
			public uint D;

			public CFGState(uint seed) {
				A = seed *= 0x21412321;
				B = seed *= 0x21412321;
				C = seed *= 0x21412321;
				D = seed *= 0x21412321;
			}

			public void UpdateExplicit(int id, uint value) {
				switch (id) {
					case 0:
						A = value;
						break;
					case 1:
						B = value;
						break;
					case 2:
						C = value;
						break;
					case 3:
						D = value;
						break;
				}
			}

			public void UpdateIncremental(int id, uint value) {
				switch (id) {
					case 0:
						A *= value;
						break;
					case 1:
						B += value;
						break;
					case 2:
						C ^= value;
						break;
					case 3:
						D -= value;
						break;
				}
			}

			public uint GetIncrementalUpdate(int id, uint target) {
				switch (id) {
					case 0:
						return A ^ target;
					case 1:
						return target - B;
					case 2:
						return C ^ target;
					case 3:
						return D - target;
				}
				throw new UnreachableException();
			}

			public uint Get(int id) {
				switch (id) {
					case 0:
						return A;
					case 1:
						return B;
					case 2:
						return C;
					case 3:
						return D;
				}
				throw new UnreachableException();
			}

			public static byte EncodeFlag(bool exp, int updateId, int getId) {
				byte fl = (byte)(exp ? 0x80 : 0);
				fl |= (byte)updateId;
				fl |= (byte)(getId << 2);
				return fl;
			}
		}

		static void InjectStateType(CEContext ctx) {
			if (ctx.CfgCtxType == null) {
				var type = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.CFGCtx");
				ctx.CfgCtxType = InjectHelper.Inject(type, ctx.Module);
				ctx.Module.Types.Add(ctx.CfgCtxType);
				ctx.CfgCtxCtor = ctx.CfgCtxType.FindMethod(".ctor");
				ctx.CfgCtxNext = ctx.CfgCtxType.FindMethod("Next");

				ctx.Name.MarkHelper(ctx.CfgCtxType, ctx.Marker, ctx.Protection);
				foreach (var def in ctx.CfgCtxType.Fields)
					ctx.Name.MarkHelper(def, ctx.Marker, ctx.Protection);
				foreach (var def in ctx.CfgCtxType.Methods)
					ctx.Name.MarkHelper(def, ctx.Marker, ctx.Protection);
			}
		}

		static void InsertEmptyStateUpdate(CFGContext ctx, ControlFlowBlock block) {
			var body = ctx.Graph.Body;
			var key = ctx.Keys[block.Id];
			if (key.EntryState == key.ExitState)
				return;

			Instruction first = null;
			// Cannot use graph.IndexOf because instructions has been modified.
			int targetIndex = body.Instructions.IndexOf(block.Header);

			CFGState entry;
			if (!ctx.StatesMap.TryGetValue(key.EntryState, out entry)) {
				key.Type = BlockKeyType.Explicit;
			}


			if (key.Type == BlockKeyType.Incremental) {
				// Incremental

				CFGState exit;
				if (!ctx.StatesMap.TryGetValue(key.ExitState, out exit)) {
					// Create new exit state
					// Update one of the entry states to be exit state
					exit = entry;
					int updateId = ctx.Random.NextInt32(3);
					uint targetValue = ctx.Random.NextUInt32();
					exit.UpdateExplicit(updateId, targetValue);

					int getId = ctx.Random.NextInt32(3);
					var fl = CFGState.EncodeFlag(false, updateId, getId);
					var incr = entry.GetIncrementalUpdate(updateId, targetValue);

					body.Instructions.Insert(targetIndex++, first = Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Pop));

					ctx.StatesMap[key.ExitState] = exit;
				}
				else {
					// Scan for updated state
					var headerIndex = targetIndex;
					for (int stateId = 0; stateId < 4; stateId++) {
						if (entry.Get(stateId) == exit.Get(stateId))
							continue;

						uint targetValue = exit.Get(stateId);
						int getId = ctx.Random.NextInt32(3);
						var fl = CFGState.EncodeFlag(false, stateId, getId);
						var incr = entry.GetIncrementalUpdate(stateId, targetValue);

						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Pop));
					}
					first = body.Instructions[headerIndex];
				}
			}
			else {
				// Explicit

				CFGState exit;
				if (!ctx.StatesMap.TryGetValue(key.ExitState, out exit)) {
					// Create new exit state from random seed
					var seed = ctx.Random.NextUInt32();
					exit = new CFGState(seed);
					body.Instructions.Insert(targetIndex++, first = Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4, (int)seed));
					body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxCtor));

					ctx.StatesMap[key.ExitState] = exit;
				}
				else {
					// Scan for updated state
					var headerIndex = targetIndex;
					for (int stateId = 0; stateId < 4; stateId++) {
						uint targetValue = exit.Get(stateId);
						int getId = ctx.Random.NextInt32(3);
						var fl = CFGState.EncodeFlag(true, stateId, getId);

						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Ldc_I4, (int)targetValue));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));
						body.Instructions.Insert(targetIndex++, Instruction.Create(OpCodes.Pop));
					}
					first = body.Instructions[headerIndex];
				}
			}

			ctx.Graph.Body.ReplaceReference(block.Header, first);
		}

		static uint InsertStateGetAndUpdate(CFGContext ctx, ref int index, BlockKeyType type, ref CFGState currentState, CFGState? targetState) {
			var body = ctx.Graph.Body;

			if (type == BlockKeyType.Incremental) {
				// Incremental

				if (targetState == null) {
					// Randomly update and get state
					int updateId = ctx.Random.NextInt32(3);
					uint targetValue = ctx.Random.NextUInt32();

					int getId = ctx.Random.NextInt32(3);
					var fl = CFGState.EncodeFlag(false, updateId, getId);
					var incr = currentState.GetIncrementalUpdate(updateId, targetValue);
					currentState.UpdateExplicit(updateId, targetValue);

					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));

					return currentState.Get(getId);
				}
				// Scan for updated state
				int[] stateIds = { 0, 1, 2, 3 };
				ctx.Random.Shuffle(stateIds);
				int i = 0;
				uint getValue = 0;
				foreach (var stateId in stateIds) {
					// There must be at least one update&get
					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&
						i != stateIds.Length - 1) {
						i++;
						continue;
					}

					uint targetValue = targetState.Value.Get(stateId);
					int getId = ctx.Random.NextInt32(3);
					var fl = CFGState.EncodeFlag(false, stateId, getId);
					var incr = currentState.GetIncrementalUpdate(stateId, targetValue);
					currentState.UpdateExplicit(stateId, targetValue);

					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));

					i++;
					if (i == stateIds.Length)
						getValue = currentState.Get(getId);
					else
						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Pop));
				}
				return getValue;
			}
			else {
				// Explicit

				if (targetState == null) {
					// Create new exit state from random seed
					var seed = ctx.Random.NextUInt32();
					currentState = new CFGState(seed);
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Dup));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)seed));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxCtor));

					// Randomly get state
					int updateId = ctx.Random.NextInt32(3);
					uint targetValue = ctx.Random.NextUInt32();

					int getId = ctx.Random.NextInt32(3);
					var fl = CFGState.EncodeFlag(false, updateId, getId);
					var incr = currentState.GetIncrementalUpdate(updateId, targetValue);
					currentState.UpdateExplicit(updateId, targetValue);

					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)incr));
					body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));

					return currentState.Get(getId);
				}
				else {
					// Scan for updated state
					int[] stateIds = { 0, 1, 2, 3 };
					ctx.Random.Shuffle(stateIds);
					int i = 0;
					uint getValue = 0;
					foreach (var stateId in stateIds) {
						uint targetValue = targetState.Value.Get(stateId);
						int getId = ctx.Random.NextInt32(3);
						var fl = CFGState.EncodeFlag(true, stateId, getId);
						currentState.UpdateExplicit(stateId, targetValue);

						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldloca, ctx.StateVariable));
						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4_S, (sbyte)fl));
						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)targetValue));
						body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.Ctx.CfgCtxNext));

						i++;
						if (i == stateIds.Length)
							getValue = targetState.Value.Get(getId);
						else
							body.Instructions.Insert(index++, Instruction.Create(OpCodes.Pop));
					}
					return getValue;
				}
			}
		}

		static void ReplaceCFG(MethodDef method, List<Tuple<Instruction, uint, IMethod>> instrs, CEContext ctx) {
			InjectStateType(ctx);

			var graph = ControlFlowGraph.Construct(method.Body);
			var sequence = KeySequence.ComputeKeys(graph, null);

			var cfgCtx = new CFGContext {
				Ctx = ctx,
				Graph = graph,
				Keys = sequence,
				StatesMap = new Dictionary<uint, CFGState>(),
				Random = ctx.Random
			};

			cfgCtx.StateVariable = new Local(ctx.CfgCtxType.ToTypeSig());
			method.Body.Variables.Add(cfgCtx.StateVariable);
			method.Body.InitLocals = true;

			var blockReferences = new Dictionary<int, SortedList<int, Tuple<Instruction, uint, IMethod>>>();
			foreach (var instr in instrs) {
				var index = graph.IndexOf(instr.Item1);
				var block = graph.GetContainingBlock(index);

				SortedList<int, Tuple<Instruction, uint, IMethod>> list;
				if (!blockReferences.TryGetValue(block.Id, out list))
					list = blockReferences[block.Id] = new SortedList<int, Tuple<Instruction, uint, IMethod>>();

				list.Add(index, instr);
			}

			// Update state for blocks not in use
			for (int i = 0; i < graph.Count; i++) {
				var block = graph[i];
				if (blockReferences.ContainsKey(block.Id))
					continue;
				InsertEmptyStateUpdate(cfgCtx, block);
			}

			// Update references
			foreach (var blockRef in blockReferences) {
				var key = sequence[blockRef.Key];
				CFGState currentState;
				if (!cfgCtx.StatesMap.TryGetValue(key.EntryState, out currentState)) {
					Debug.Assert((graph[blockRef.Key].Type & ControlFlowBlockType.Entry) != 0);
					Debug.Assert(key.Type == BlockKeyType.Explicit);

					// Create new entry state
					uint blockSeed = ctx.Random.NextUInt32();
					currentState = new CFGState(blockSeed);
					cfgCtx.StatesMap[key.EntryState] = currentState;

					var index = graph.Body.Instructions.IndexOf(graph[blockRef.Key].Header);
					Instruction newHeader;
					method.Body.Instructions.Insert(index++, newHeader = Instruction.Create(OpCodes.Ldloca, cfgCtx.StateVariable));
					method.Body.Instructions.Insert(index++, Instruction.Create(OpCodes.Ldc_I4, (int)blockSeed));
					method.Body.Instructions.Insert(index++, Instruction.Create(OpCodes.Call, ctx.CfgCtxCtor));
					method.Body.ReplaceReference(graph[blockRef.Key].Header, newHeader);
					key.Type = BlockKeyType.Incremental;
				}
				var type = key.Type;

				for (int i = 0; i < blockRef.Value.Count; i++) {
					var refEntry = blockRef.Value.Values[i];

					CFGState? targetState = null;
					if (i == blockRef.Value.Count - 1) {
						CFGState exitState;
						if (cfgCtx.StatesMap.TryGetValue(key.ExitState, out exitState))
							targetState = exitState;
					}

					var index = graph.Body.Instructions.IndexOf(refEntry.Item1) + 1;
					var value = InsertStateGetAndUpdate(cfgCtx, ref index, type, ref currentState, targetState);

					refEntry.Item1.OpCode = OpCodes.Ldc_I4;
					refEntry.Item1.Operand = (int)(refEntry.Item2 ^ value);
					method.Body.Instructions.Insert(index++, Instruction.Create(OpCodes.Xor));
					method.Body.Instructions.Insert(index, Instruction.Create(OpCodes.Call, refEntry.Item3));

					if (i == blockRef.Value.Count - 1 && targetState == null) {
						cfgCtx.StatesMap[key.ExitState] = currentState;
					}

					type = BlockKeyType.Incremental;
				}
			}
		}
	}
}

```

`Confuser.Protections/Constants/x86Mode.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;
using MethodBody = dnlib.DotNet.Writer.MethodBody;

namespace Confuser.Protections.Constants {
	internal class x86Mode : IEncodeMode {
		Action<uint[], uint[]> encryptFunc;

		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, CEContext ctx, Local block, Local key) {
			StatementBlock encrypt, decrypt;
			ctx.DynCipher.GenerateCipherPair(ctx.Random, out encrypt, out decrypt);
			var ret = new List<Instruction>();

			var codeGen = new CipherCodeGen(block, key, init, ret);
			codeGen.GenerateCIL(decrypt);
			codeGen.Commit(init.Body);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(encrypt);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();

			return ret;
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			Buffer.BlockCopy(data, offset * sizeof(uint), ret, 0, key.Length * sizeof(uint));
			encryptFunc(ret, key);
			return ret;
		}

		public object CreateDecoder(MethodDef decoder, CEContext ctx) {
			var encoding = new x86Encoding();
			encoding.Compile(ctx);
			MutationHelper.ReplacePlaceholder(decoder, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Call, encoding.native));
				return repl.ToArray();
			});
			return encoding;
		}

		public uint Encode(object data, CEContext ctx, uint id) {
			var encoding = (x86Encoding)data;
			return (uint)encoding.expCompiled((int)id);
		}

		class CipherCodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CipherCodeGen(Local block, Local key, MethodDef init, IList<Instruction> instrs)
				: base(init, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}

		class x86Encoding {
			byte[] code;
			MethodBody codeChunk;

			public Func<int, int> expCompiled;
			Expression expression;
			Expression inverse;
			public MethodDef native;

			public void Compile(CEContext ctx) {
				var var = new Variable("{VAR}");
				var result = new Variable("{RESULT}");

				CorLibTypeSig int32 = ctx.Module.CorLibTypes.Int32;
				native = new MethodDefUser("", MethodSig.CreateStatic(int32, int32), MethodAttributes.PinvokeImpl | MethodAttributes.PrivateScope | MethodAttributes.Static);
				native.ImplAttributes = MethodImplAttributes.Native | MethodImplAttributes.Unmanaged | MethodImplAttributes.PreserveSig;
				// Attempt to improve performance --- failed with StackOverflowException... :/
				//var suppressAttr = ctx.Method.Module.CorLibTypes.GetTypeRef("System.Security", "SuppressUnmanagedCodeSecurityAttribute").ResolveThrow();
				//native.CustomAttributes.Add(new CustomAttribute((MemberRef)ctx.Method.Module.Import(suppressAttr.FindDefaultConstructor())));
				//native.HasSecurity = true;
				ctx.Module.GlobalType.Methods.Add(native);

				ctx.Name.MarkHelper(native, ctx.Marker, ctx.Protection);

				x86Register? reg;
				var codeGen = new x86CodeGen();
				do {
					ctx.DynCipher.GenerateExpressionPair(
						ctx.Random,
						new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
						4, out expression, out inverse);

					reg = codeGen.GenerateX86(inverse, (v, r) => { return new[] { x86Instruction.Create(x86OpCode.POP, new x86RegisterOperand(r)) }; });
				} while (reg == null);

				code = CodeGenUtils.AssembleCode(codeGen, reg.Value);

				expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
					.GenerateCIL(expression)
					.Compile<Func<int, int>>();


				ctx.Context.CurrentModuleWriterOptions.WriterEvent += InjectNativeCode;
			}

			void InjectNativeCode(object sender, ModuleWriterEventArgs e) {
				var writer = e.Writer;
				switch (e.Event) {
				case ModuleWriterEvent.MDEndWriteMethodBodies:
					codeChunk = writer.MethodBodies.Add(new MethodBody(code));
					break;
				case ModuleWriterEvent.EndCalculateRvasAndFileOffsets:
					uint rid = writer.Metadata.GetRid(native);
					var methodRow = writer.Metadata.TablesHeap.MethodTable[rid];
					writer.Metadata.TablesHeap.MethodTable[rid] = new RawMethodRow(
					  (uint)codeChunk.RVA,
					  methodRow.ImplFlags,
					  methodRow.Flags,
					  methodRow.Name,
					  methodRow.Signature,
					  methodRow.ParamList);
					break;
				}
			}
		}
	}
}

```

`Confuser.Protections/ControlFlow/BlockParser.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal static class BlockParser {
		public static ScopeBlock ParseBody(CilBody body) {
			var ehScopes = new Dictionary<ExceptionHandler, Tuple<ScopeBlock, ScopeBlock, ScopeBlock>>();
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				var tryBlock = new ScopeBlock(BlockType.Try, eh);

				var handlerType = BlockType.Handler;

				if (eh.HandlerType == ExceptionHandlerType.Finally)
					handlerType = BlockType.Finally;
				else if (eh.HandlerType == ExceptionHandlerType.Fault)
					handlerType = BlockType.Fault;

				var handlerBlock = new ScopeBlock(handlerType, eh);

				if (eh.FilterStart != null) {
					var filterBlock = new ScopeBlock(BlockType.Filter, eh);
					ehScopes[eh] = Tuple.Create(tryBlock, handlerBlock, filterBlock);
				}
				else
					ehScopes[eh] = Tuple.Create(tryBlock, handlerBlock, (ScopeBlock)null);
			}

			var root = new ScopeBlock(BlockType.Normal, null);
			var scopeStack = new Stack<ScopeBlock>();

			scopeStack.Push(root);
			foreach (Instruction instr in body.Instructions) {
				foreach (ExceptionHandler eh in body.ExceptionHandlers) {
					Tuple<ScopeBlock, ScopeBlock, ScopeBlock> ehScope = ehScopes[eh];

					if (instr == eh.TryEnd)
						scopeStack.Pop();

					if (instr == eh.HandlerEnd)
						scopeStack.Pop();

					if (eh.FilterStart != null && instr == eh.HandlerStart) {
						// Filter must precede handler immediately
						Debug.Assert(scopeStack.Peek().Type == BlockType.Filter);
						scopeStack.Pop();
					}
				}
				foreach (ExceptionHandler eh in body.ExceptionHandlers.Reverse()) {
					Tuple<ScopeBlock, ScopeBlock, ScopeBlock> ehScope = ehScopes[eh];
					ScopeBlock parent = scopeStack.Count > 0 ? scopeStack.Peek() : null;

					if (instr == eh.TryStart) {
						if (parent != null)
							parent.Children.Add(ehScope.Item1);
						scopeStack.Push(ehScope.Item1);
					}

					if (instr == eh.HandlerStart) {
						if (parent != null)
							parent.Children.Add(ehScope.Item2);
						scopeStack.Push(ehScope.Item2);
					}

					if (instr == eh.FilterStart) {
						if (parent != null)
							parent.Children.Add(ehScope.Item3);
						scopeStack.Push(ehScope.Item3);
					}
				}

				ScopeBlock scope = scopeStack.Peek();
				var block = scope.Children.LastOrDefault() as InstrBlock;
				if (block == null)
					scope.Children.Add(block = new InstrBlock());
				block.Instructions.Add(instr);
			}
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				if (eh.TryEnd == null)
					scopeStack.Pop();
				if (eh.HandlerEnd == null)
					scopeStack.Pop();
			}
			Debug.Assert(scopeStack.Count == 1);
			return root;
		}
	}
}
```

`Confuser.Protections/ControlFlow/Blocks.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal abstract class BlockBase {
		public BlockBase(BlockType type) {
			Type = type;
		}

		public ScopeBlock Parent { get; private set; }

		public BlockType Type { get; private set; }
		public abstract void ToBody(CilBody body);
	}

	internal enum BlockType {
		Normal,
		Try,
		Handler,
		Finally,
		Filter,
		Fault
	}

	internal class ScopeBlock : BlockBase {
		public ScopeBlock(BlockType type, ExceptionHandler handler)
			: base(type) {
			Handler = handler;
			Children = new List<BlockBase>();
		}

		public ExceptionHandler Handler { get; private set; }

		public List<BlockBase> Children { get; set; }

		public override string ToString() {
			var ret = new StringBuilder();
			if (Type == BlockType.Try)
				ret.Append("try ");
			else if (Type == BlockType.Handler)
				ret.Append("handler ");
			else if (Type == BlockType.Finally)
				ret.Append("finally ");
			else if (Type == BlockType.Fault)
				ret.Append("fault ");
			ret.AppendLine("{");
			foreach (BlockBase child in Children)
				ret.Append(child);
			ret.AppendLine("}");
			return ret.ToString();
		}

		public Instruction GetFirstInstr() {
			BlockBase firstBlock = Children.First();
			if (firstBlock is ScopeBlock)
				return ((ScopeBlock)firstBlock).GetFirstInstr();
			return ((InstrBlock)firstBlock).Instructions.First();
		}

		public Instruction GetLastInstr() {
			BlockBase firstBlock = Children.Last();
			if (firstBlock is ScopeBlock)
				return ((ScopeBlock)firstBlock).GetLastInstr();
			return ((InstrBlock)firstBlock).Instructions.Last();
		}

		public override void ToBody(CilBody body) {
			if (Type != BlockType.Normal) {
				if (Type == BlockType.Try) {
					Handler.TryStart = GetFirstInstr();
					Handler.TryEnd = GetLastInstr();
				}
				else if (Type == BlockType.Filter) {
					Handler.FilterStart = GetFirstInstr();
				}
				else {
					Handler.HandlerStart = GetFirstInstr();
					Handler.HandlerEnd = GetLastInstr();
				}
			}

			foreach (BlockBase block in Children)
				block.ToBody(body);
		}
	}

	internal class InstrBlock : BlockBase {
		public InstrBlock()
			: base(BlockType.Normal) {
			Instructions = new List<Instruction>();
		}

		public List<Instruction> Instructions { get; set; }

		public override string ToString() {
			var ret = new StringBuilder();
			foreach (Instruction instr in Instructions)
				ret.AppendLine(instr.ToString());
			return ret.ToString();
		}

		public override void ToBody(CilBody body) {
			foreach (Instruction instr in Instructions)
				body.Instructions.Add(instr);
		}
	}
}
```

`Confuser.Protections/ControlFlow/CFContext.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal enum CFType {
		Switch,
		Jump
	}

	internal enum PredicateType {
		Normal,
		Expression,
		x86
	}

	internal class CFContext {
		public ConfuserContext Context;
		public ControlFlowProtection Protection;
		public int Depth;
		public IDynCipherService DynCipher;

		public double Intensity;
		public bool JunkCode;
		public MethodDef Method;
		public PredicateType Predicate;
		public RandomGenerator Random;
		public CFType Type;

		public void AddJump(IList<Instruction> instrs, Instruction target) {
			if (!Method.Module.IsClr40 && JunkCode &&
			    !Method.DeclaringType.HasGenericParameters && !Method.HasGenericParameters &&
			    (instrs[0].OpCode.FlowControl == FlowControl.Call || instrs[0].OpCode.FlowControl == FlowControl.Next)) {
				switch (Random.NextInt32(3)) {
					case 0:
						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_0));
						instrs.Add(Instruction.Create(OpCodes.Brtrue, instrs[0]));
						break;

					case 1:
						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_1));
						instrs.Add(Instruction.Create(OpCodes.Brfalse, instrs[0]));
						break;

					case 2: // Take that, de4dot + ILSpy :)
						bool addDefOk = false;
						if (Random.NextBoolean()) {
							TypeDef randomType;
							randomType = Method.Module.Types[Random.NextInt32(Method.Module.Types.Count)];

							if (randomType.HasMethods) {
								instrs.Add(Instruction.Create(OpCodes.Ldtoken, randomType.Methods[Random.NextInt32(randomType.Methods.Count)]));
								instrs.Add(Instruction.Create(OpCodes.Box, Method.Module.CorLibTypes.GetTypeRef("System", "RuntimeMethodHandle")));
								addDefOk = true;
							}
						}

						if (!addDefOk) {
							instrs.Add(Instruction.Create(OpCodes.Ldc_I4, Random.NextBoolean() ? 0 : 1));
							instrs.Add(Instruction.Create(OpCodes.Box, Method.Module.CorLibTypes.Int32.TypeDefOrRef));
						}
						Instruction pop = Instruction.Create(OpCodes.Pop);
						instrs.Add(Instruction.Create(OpCodes.Brfalse, instrs[0]));
						instrs.Add(Instruction.Create(OpCodes.Ldc_I4, Random.NextBoolean() ? 0 : 1));
						instrs.Add(pop);
						break;
				}
			}

			instrs.Add(Instruction.Create(OpCodes.Br, target));
		}

		public void AddJunk(IList<Instruction> instrs) {
			if (Method.Module.IsClr40 || !JunkCode)
				return;

			switch (Random.NextInt32(6)) {
				case 0:
					instrs.Add(Instruction.Create(OpCodes.Pop));
					break;
				case 1:
					instrs.Add(Instruction.Create(OpCodes.Dup));
					break;
				case 2:
					instrs.Add(Instruction.Create(OpCodes.Throw));
					break;
				case 3:
					instrs.Add(Instruction.Create(OpCodes.Ldarg, new Parameter(0xff)));
					break;
				case 4:
					instrs.Add(Instruction.Create(OpCodes.Ldloc, new Local(null, null, 0xff)));
					break;
				case 5:
					instrs.Add(Instruction.Create(OpCodes.Ldtoken, Method));
					break;
			}
		}
	}
}

```

`Confuser.Protections/ControlFlow/ControlFlowPhase.cs`:

```cs
using System;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.ControlFlow {
	internal class ControlFlowPhase : ProtectionPhase {
		static readonly JumpMangler Jump = new JumpMangler();
		static readonly SwitchMangler Switch = new SwitchMangler();

		public ControlFlowPhase(ControlFlowProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Control flow mangling"; }
		}

		CFContext ParseParameters(MethodDef method, ConfuserContext context, ProtectionParameters parameters, RandomGenerator random, bool disableOpti) {
			var ret = new CFContext();
			ret.Type = parameters.GetParameter(context, method, "type", CFType.Switch);
			ret.Predicate = parameters.GetParameter(context, method, "predicate", PredicateType.Normal);

			int rawIntensity = parameters.GetParameter(context, method, "intensity", 60);
			ret.Intensity = rawIntensity / 100.0;
			ret.Depth = parameters.GetParameter(context, method, "depth", 4);

			ret.JunkCode = parameters.GetParameter(context, method, "junk", false) && !disableOpti;

			ret.Protection = (ControlFlowProtection)Parent;
			ret.Random = random;
			ret.Method = method;
			ret.Context = context;
			ret.DynCipher = context.Registry.GetService<IDynCipherService>();

			if (ret.Predicate == PredicateType.x86) {
				if ((context.CurrentModule.Cor20HeaderFlags & ComImageFlags.ILOnly) != 0)
					context.CurrentModuleWriterOptions.Cor20HeaderOptions.Flags &= ~ComImageFlags.ILOnly;
			}

			return ret;
		}

		static bool DisabledOptimization(ModuleDef module) {
			bool disableOpti = false;
			CustomAttribute debugAttr = module.Assembly.CustomAttributes.Find("System.Diagnostics.DebuggableAttribute");
			if (debugAttr != null) {
				if (debugAttr.ConstructorArguments.Count == 1)
					disableOpti |= ((DebuggableAttribute.DebuggingModes)(int)debugAttr.ConstructorArguments[0].Value & DebuggableAttribute.DebuggingModes.DisableOptimizations) != 0;
				else
					disableOpti |= (bool)debugAttr.ConstructorArguments[1].Value;
			}
			debugAttr = module.CustomAttributes.Find("System.Diagnostics.DebuggableAttribute");
			if (debugAttr != null) {
				if (debugAttr.ConstructorArguments.Count == 1)
					disableOpti |= ((DebuggableAttribute.DebuggingModes)(int)debugAttr.ConstructorArguments[0].Value & DebuggableAttribute.DebuggingModes.DisableOptimizations) != 0;
				else
					disableOpti |= (bool)debugAttr.ConstructorArguments[1].Value;
			}
			return disableOpti;
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			bool disabledOpti = DisabledOptimization(context.CurrentModule);
			RandomGenerator random = context.Registry.GetService<IRandomService>().GetRandomGenerator(ControlFlowProtection._FullId);

			foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger))
				if (method.HasBody && method.Body.Instructions.Count > 0) {
					ProcessMethod(method.Body, ParseParameters(method, context, parameters, random, disabledOpti));
					context.CheckCancellation();
				}
		}

		static ManglerBase GetMangler(CFType type) {
			if (type == CFType.Switch)
				return Switch;
			return Jump;
		}

		void ProcessMethod(CilBody body, CFContext ctx) {
			uint maxStack;
			if (!MaxStackCalculator.GetMaxStack(body.Instructions, body.ExceptionHandlers, out maxStack)) {
				ctx.Context.Logger.Error("Failed to calcuate maxstack.");
				throw new ConfuserException(null);
			}
			body.MaxStack = (ushort)maxStack;
			ScopeBlock root = BlockParser.ParseBody(body);

			GetMangler(ctx.Type).Mangle(body, root, ctx);

			body.Instructions.Clear();
			root.ToBody(body);
			if (body.PdbMethod != null) {
				body.PdbMethod = new PdbMethod() {
					Scope = new PdbScope() {
						Start = body.Instructions.First(),
						End = body.Instructions.Last()
					}
				};
			}
			foreach (ExceptionHandler eh in body.ExceptionHandlers) {
				var index = body.Instructions.IndexOf(eh.TryEnd) + 1;
				eh.TryEnd = index < body.Instructions.Count ? body.Instructions[index] : null;
				index = body.Instructions.IndexOf(eh.HandlerEnd) + 1;
				eh.HandlerEnd = index < body.Instructions.Count ? body.Instructions[index] : null;
			}
			body.KeepOldMaxStack = true;
		}
	}
}

```

`Confuser.Protections/ControlFlow/ControlFlowProtection.cs`:

```cs
using System;
using Confuser.Core;
using Confuser.Protections.ControlFlow;
using dnlib.DotNet;

namespace Confuser.Protections {
	public interface IControlFlowService {
		void ExcludeMethod(ConfuserContext context, MethodDef method);
	}

	internal class ControlFlowProtection : Protection, IControlFlowService {
		public const string _Id = "ctrl flow";
		public const string _FullId = "Ki.ControlFlow";
		public const string _ServiceId = "Ki.ControlFlow";

		public override string Name {
			get { return "Control Flow Protection"; }
		}

		public override string Description {
			get { return "This protection mangles the code in the methods so that decompilers cannot decompile the methods."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Normal; }
		}

		public void ExcludeMethod(ConfuserContext context, MethodDef method) {
			ProtectionParameters.GetParameters(context, method).Remove(this);
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IControlFlowService), this);
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.OptimizeMethods, new ControlFlowPhase(this));
		}
	}
}
```

`Confuser.Protections/ControlFlow/ExpressionPredicate.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal class ExpressionPredicate : IPredicate {
		readonly CFContext ctx;
		Func<int, int> expCompiled;
		Expression expression;

		bool inited;
		List<Instruction> invCompiled;
		Expression inverse;
		Local stateVar;

		public ExpressionPredicate(CFContext ctx) {
			this.ctx = ctx;
		}

		public void Init(CilBody body) {
			if (inited)
				return;
			stateVar = new Local(ctx.Method.Module.CorLibTypes.Int32);
			body.Variables.Add(stateVar);
			body.InitLocals = true;
			Compile(body);
			inited = true;
		}

		public void EmitSwitchLoad(IList<Instruction> instrs) {
			instrs.Add(Instruction.Create(OpCodes.Stloc, stateVar));
			foreach (Instruction instr in invCompiled)
				instrs.Add(instr.Clone());
		}

		public int GetSwitchKey(int key) {
			return expCompiled(key);
		}

		void Compile(CilBody body) {
			var var = new Variable("{VAR}");
			var result = new Variable("{RESULT}");

			ctx.DynCipher.GenerateExpressionPair(
				ctx.Random,
				new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
				ctx.Depth, out expression, out inverse);

			expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
				.GenerateCIL(expression)
				.Compile<Func<int, int>>();

			invCompiled = new List<Instruction>();
			new CodeGen(stateVar, ctx, invCompiled).GenerateCIL(inverse);
			body.MaxStack += (ushort)ctx.Depth;
		}

		class CodeGen : CILCodeGen {
			readonly Local state;

			public CodeGen(Local state, CFContext ctx, IList<Instruction> instrs)
				: base(ctx.Method, instrs) {
				this.state = state;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{RESULT}")
					return state;
				return base.Var(var);
			}
		}
	}
}
```

`Confuser.Protections/ControlFlow/IPredicate.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal interface IPredicate {
		void Init(CilBody body);
		void EmitSwitchLoad(IList<Instruction> instrs);
		int GetSwitchKey(int key);
	}
}
```

`Confuser.Protections/ControlFlow/JumpMangler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal class JumpMangler : ManglerBase {
		LinkedList<Instruction[]> SpiltFragments(InstrBlock block, CFContext ctx) {
			var fragments = new LinkedList<Instruction[]>();
			var currentFragment = new List<Instruction>();

			int skipCount = -1;
			for (int i = 0; i < block.Instructions.Count; i++) {
				if (skipCount != -1) {
					if (skipCount > 0) {
						currentFragment.Add(block.Instructions[i]);
						skipCount--;
						continue;
					}
					fragments.AddLast(currentFragment.ToArray());
					currentFragment.Clear();

					skipCount = -1;
				}

				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {
					skipCount = 1;
				}
				else if (HasInstructionSeq(block.Instructions, i,Code.Dup, Code.Ldvirtftn, Code.Newobj)) {
					skipCount = 2;
				}
				else if (HasInstructionSeq(block.Instructions, i,Code.Ldc_I4, Code.Newarr, Code.Dup, Code.Ldtoken, Code.Call)) { // Array initializer
					skipCount = 4;
				}
				else if (HasInstructionSeq(block.Instructions, i,Code.Ldftn, Code.Newobj)) { // Create delegate to function
					skipCount = 1;
				}
				currentFragment.Add(block.Instructions[i]);

				if (skipCount == -1 && ctx.Intensity > ctx.Random.NextDouble()) {
					fragments.AddLast(currentFragment.ToArray());
					currentFragment.Clear();
				}
			}

			if (currentFragment.Count > 0)
				fragments.AddLast(currentFragment.ToArray());

			return fragments;
		}

		private static bool HasInstructionSeq(List<Instruction> instructions, int offset, params Code[] codes) {
			if (offset + codes.Length > instructions.Count) return false;
			return !codes.Where((code, i) => instructions[i + offset].OpCode.Code != code).Any();
		}

		public override void Mangle(CilBody body, ScopeBlock root, CFContext ctx) {
			body.MaxStack++;
			foreach (InstrBlock block in GetAllBlocks(root)) {
				LinkedList<Instruction[]> fragments = SpiltFragments(block, ctx);
				if (fragments.Count < 4) continue;

				LinkedListNode<Instruction[]> current = fragments.First;
				while (current.Next != null) {
					var newFragment = new List<Instruction>(current.Value);
					ctx.AddJump(newFragment, current.Next.Value[0]);
					ctx.AddJunk(newFragment);
					current.Value = newFragment.ToArray();
					current = current.Next;
				}
				Instruction[] first = fragments.First.Value;
				fragments.RemoveFirst();
				Instruction[] last = fragments.Last.Value;
				fragments.RemoveLast();

				List<Instruction[]> newFragments = fragments.ToList();
				ctx.Random.Shuffle(newFragments);

				block.Instructions = first
					.Concat(newFragments.SelectMany(fragment => fragment))
					.Concat(last).ToList();
			}
		}
	}
}

```

`Confuser.Protections/ControlFlow/ManglerBase.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal abstract class ManglerBase {
		protected static IEnumerable<InstrBlock> GetAllBlocks(ScopeBlock scope) {
			foreach (BlockBase child in scope.Children) {
				if (child is InstrBlock)
					yield return (InstrBlock)child;
				else {
					foreach (InstrBlock block in GetAllBlocks((ScopeBlock)child))
						yield return block;
				}
			}
		}

		public abstract void Mangle(CilBody body, ScopeBlock root, CFContext ctx);
	}
}
```

`Confuser.Protections/ControlFlow/NormalPredicate.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal class NormalPredicate : IPredicate {
		readonly CFContext ctx;
		bool inited;
		int xorKey;

		public NormalPredicate(CFContext ctx) {
			this.ctx = ctx;
		}

		public void Init(CilBody body) {
			if (inited)
				return;

			xorKey = ctx.Random.NextInt32();
			inited = true;
		}

		public void EmitSwitchLoad(IList<Instruction> instrs) {
			instrs.Add(Instruction.Create(OpCodes.Ldc_I4, xorKey));
			instrs.Add(Instruction.Create(OpCodes.Xor));
		}

		public int GetSwitchKey(int key) {
			return key ^ xorKey;
		}
	}
}
```

`Confuser.Protections/ControlFlow/SwitchMangler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ControlFlow {
	internal class SwitchMangler : ManglerBase {
		struct Trace {
			public Dictionary<uint, int> RefCount;
			public Dictionary<uint, List<Instruction>> BrRefs;
			public Dictionary<uint, int> BeforeStack;
			public Dictionary<uint, int> AfterStack;

			static void Increment(Dictionary<uint, int> counts, uint key) {
				int value;
				if (!counts.TryGetValue(key, out value))
					value = 0;
				counts[key] = value + 1;
			}

			public Trace(CilBody body, bool hasReturnValue) {
				RefCount = new Dictionary<uint, int>();
				BrRefs = new Dictionary<uint, List<Instruction>>();
				BeforeStack = new Dictionary<uint, int>();
				AfterStack = new Dictionary<uint, int>();

				body.UpdateInstructionOffsets();

				foreach (ExceptionHandler eh in body.ExceptionHandlers) {
					BeforeStack[eh.TryStart.Offset] = 0;
					BeforeStack[eh.HandlerStart.Offset] = (eh.HandlerType != ExceptionHandlerType.Finally ? 1 : 0);
					if (eh.FilterStart != null)
						BeforeStack[eh.FilterStart.Offset] = 1;
				}

				int currentStack = 0;
				for (int i = 0; i < body.Instructions.Count; i++) {
					var instr = body.Instructions[i];

					if (BeforeStack.ContainsKey(instr.Offset))
						currentStack = BeforeStack[instr.Offset];

					BeforeStack[instr.Offset] = currentStack;
					instr.UpdateStack(ref currentStack, hasReturnValue);
					AfterStack[instr.Offset] = currentStack;

					uint offset;
					switch (instr.OpCode.FlowControl) {
						case FlowControl.Branch:
							offset = ((Instruction)instr.Operand).Offset;
							if (!BeforeStack.ContainsKey(offset))
								BeforeStack[offset] = currentStack;

							Increment(RefCount, offset);
							BrRefs.AddListEntry(offset, instr);

							currentStack = 0;
							continue;
						case FlowControl.Call:
							if (instr.OpCode.Code == Code.Jmp)
								currentStack = 0;
							break;
						case FlowControl.Cond_Branch:
							if (instr.OpCode.Code == Code.Switch) {
								foreach (Instruction target in (Instruction[])instr.Operand) {
									if (!BeforeStack.ContainsKey(target.Offset))
										BeforeStack[target.Offset] = currentStack;

									Increment(RefCount, target.Offset);
									BrRefs.AddListEntry(target.Offset, instr);
								}
							}
							else {
								offset = ((Instruction)instr.Operand).Offset;
								if (!BeforeStack.ContainsKey(offset))
									BeforeStack[offset] = currentStack;

								Increment(RefCount, offset);
								BrRefs.AddListEntry(offset, instr);
							}
							break;
						case FlowControl.Meta:
						case FlowControl.Next:
						case FlowControl.Break:
							break;
						case FlowControl.Return:
						case FlowControl.Throw:
							continue;
						default:
							throw new UnreachableException();
					}

					if (i + 1 < body.Instructions.Count) {
						offset = body.Instructions[i + 1].Offset;
						Increment(RefCount, offset);
					}
				}
			}

			public bool IsBranchTarget(uint offset) {
				List<Instruction> src;
				if (BrRefs.TryGetValue(offset, out src))
					return src.Count > 0;
				return false;
			}

			public bool HasMultipleSources(uint offset) {
				int src;
				if (RefCount.TryGetValue(offset, out src))
					return src > 1;
				return false;
			}
		}

		LinkedList<Instruction[]> SpiltStatements(InstrBlock block, Trace trace, CFContext ctx) {
			var statements = new LinkedList<Instruction[]>();
			var currentStatement = new List<Instruction>();

			// Instructions that must be included in the ccurrent statement to ensure all outgoing
			// branches have stack = 0
			var requiredInstr = new HashSet<Instruction>();

			for (int i = 0; i < block.Instructions.Count; i++) {
				Instruction instr = block.Instructions[i];
				currentStatement.Add(instr);

				bool shouldSpilt = i + 1 < block.Instructions.Count && trace.HasMultipleSources(block.Instructions[i + 1].Offset);
				switch (instr.OpCode.FlowControl) {
					case FlowControl.Branch:
					case FlowControl.Cond_Branch:
					case FlowControl.Return:
					case FlowControl.Throw:
						shouldSpilt = true;
						if (trace.AfterStack[instr.Offset] != 0) {
							if (instr.Operand is Instruction)
								requiredInstr.Add((Instruction)instr.Operand);
							else if (instr.Operand is Instruction[]) {
								foreach (var target in (Instruction[])instr.Operand)
									requiredInstr.Add(target);
							}
						}
						break;
				}
				requiredInstr.Remove(instr);
				if ((instr.OpCode.OpCodeType != OpCodeType.Prefix && trace.AfterStack[instr.Offset] == 0 &&
				     requiredInstr.Count == 0) &&
				    (shouldSpilt || ctx.Intensity > ctx.Random.NextDouble())) {
					statements.AddLast(currentStatement.ToArray());
					currentStatement.Clear();
				}
			}

			if (currentStatement.Count > 0)
				statements.AddLast(currentStatement.ToArray());

			return statements;
		}

		static OpCode InverseBranch(OpCode opCode) {
			switch (opCode.Code) {
				case Code.Bge:
					return OpCodes.Blt;
				case Code.Bge_Un:
					return OpCodes.Blt_Un;
				case Code.Blt:
					return OpCodes.Bge;
				case Code.Blt_Un:
					return OpCodes.Bge_Un;
				case Code.Bgt:
					return OpCodes.Ble;
				case Code.Bgt_Un:
					return OpCodes.Ble_Un;
				case Code.Ble:
					return OpCodes.Bgt;
				case Code.Ble_Un:
					return OpCodes.Bgt_Un;
				case Code.Brfalse:
					return OpCodes.Brtrue;
				case Code.Brtrue:
					return OpCodes.Brfalse;
				case Code.Beq:
					return OpCodes.Bne_Un;
				case Code.Bne_Un:
					return OpCodes.Beq;
			}
			throw new NotSupportedException();
		}

		public override void Mangle(CilBody body, ScopeBlock root, CFContext ctx) {
			Trace trace = new Trace(body, ctx.Method.ReturnType.RemoveModifiers().ElementType != ElementType.Void);
			var local = new Local(ctx.Method.Module.CorLibTypes.UInt32);
			body.Variables.Add(local);
			body.InitLocals = true;

			body.MaxStack += 2;
			IPredicate predicate = null;
			if (ctx.Predicate == PredicateType.Normal) {
				predicate = new NormalPredicate(ctx);
			}
			else if (ctx.Predicate == PredicateType.Expression) {
				predicate = new ExpressionPredicate(ctx);
			}
			else if (ctx.Predicate == PredicateType.x86) {
				predicate = new x86Predicate(ctx);
			}

			foreach (InstrBlock block in GetAllBlocks(root)) {
				LinkedList<Instruction[]> statements = SpiltStatements(block, trace, ctx);

				// Make sure .ctor is executed before switch
				if (ctx.Method.IsInstanceConstructor) {
					var newStatement = new List<Instruction>();
					while (statements.First != null) {
						newStatement.AddRange(statements.First.Value);
						Instruction lastInstr = statements.First.Value.Last();
						statements.RemoveFirst();
						if (lastInstr.OpCode == OpCodes.Call && ((IMethod)lastInstr.Operand).Name == ".ctor")
							break;
					}
					statements.AddFirst(newStatement.ToArray());
				}

				if (statements.Count < 3) continue;

				int i;

				var keyId = Enumerable.Range(0, statements.Count).ToArray();
				ctx.Random.Shuffle(keyId);
				var key = new int[keyId.Length];
				for (i = 0; i < key.Length; i++) {
					var q = ctx.Random.NextInt32() & 0x7fffffff;
					key[i] = q - q % statements.Count + keyId[i];
				}

				var statementKeys = new Dictionary<Instruction, int>();
				LinkedListNode<Instruction[]> current = statements.First;
				i = 0;
				while (current != null) {
					if (i != 0)
						statementKeys[current.Value[0]] = key[i];
					i++;
					current = current.Next;
				}

				var statementLast = new HashSet<Instruction>(statements.Select(st => st.Last()));

				Func<IList<Instruction>, bool> hasUnknownSource;
				hasUnknownSource = instrs => instrs.Any(instr => {
					if (trace.HasMultipleSources(instr.Offset))
						return true;
					if (trace.BrRefs.TryGetValue(instr.Offset, out var srcs)) {
						// Target of switch => assume unknown
						if (srcs.Any(src => src.Operand is Instruction[]))
							return true;

						// Not within current instruction block / targeted in first statement
						if (srcs.Any(src => src.Offset <= statements.First.Value.Last().Offset ||
						                    src.Offset >= block.Instructions.Last().Offset))
							return true;

						// Disable flow obfuscation for blocks reached by jump instructions.
						// Bug in #153 caused exactly this behaviour, expect for allowing wrong jump instructions
						// There is another issue present here tracked here:
						// https://github.com/mkaring/ConfuserEx/issues/162
						// Until this issue is resolved, the ctrl flow obfuscation will be severely reduced.
						if (srcs.Any())
							return true;

						// Not targeted by the last of statements
						if (srcs.Any(src => !statementLast.Contains(src)))
							return true;
					}
					return false;
				});

				var switchInstr = new Instruction(OpCodes.Switch);
				var switchHdr = new List<Instruction>();

				if (predicate != null) {
					predicate.Init(body);
					switchHdr.Add(Instruction.CreateLdcI4(predicate.GetSwitchKey(key[1])));
					predicate.EmitSwitchLoad(switchHdr);
				}
				else {
					switchHdr.Add(Instruction.CreateLdcI4(key[1]));
				}

				switchHdr.Add(Instruction.Create(OpCodes.Dup));
				switchHdr.Add(Instruction.Create(OpCodes.Stloc, local));
				switchHdr.Add(Instruction.Create(OpCodes.Ldc_I4, statements.Count));
				switchHdr.Add(Instruction.Create(OpCodes.Rem_Un));
				switchHdr.Add(switchInstr);

				ctx.AddJump(switchHdr, statements.Last.Value[0]);
				ctx.AddJunk(switchHdr);

				var operands = new Instruction[statements.Count];
				current = statements.First;
				i = 0;
				while (current.Next != null) {
					var newStatement = new List<Instruction>(current.Value);

					if (i != 0) {
						// Convert to switch
						bool converted = false;

						if (newStatement.Last().IsBr()) {
							// Unconditional

							var target = (Instruction)newStatement.Last().Operand;
							int brKey;
							if (!trace.IsBranchTarget(newStatement.Last().Offset) &&
							    statementKeys.TryGetValue(target, out brKey)) {
								var targetKey = predicate != null ? predicate.GetSwitchKey(brKey) : brKey;
								var unkSrc = hasUnknownSource(newStatement);

								newStatement.RemoveAt(newStatement.Count - 1);

								if (unkSrc) {
									newStatement.Add(Instruction.Create(OpCodes.Ldc_I4, targetKey));
								}
								else {
									var thisKey = key[i];
									var r = ctx.Random.NextInt32();
									newStatement.Add(Instruction.Create(OpCodes.Ldloc, local));
									newStatement.Add(Instruction.CreateLdcI4(r));
									newStatement.Add(Instruction.Create(OpCodes.Mul));
									newStatement.Add(Instruction.Create(OpCodes.Ldc_I4, (thisKey * r) ^ targetKey));
									newStatement.Add(Instruction.Create(OpCodes.Xor));
								}

								ctx.AddJump(newStatement, switchHdr[1]);
								ctx.AddJunk(newStatement);
								operands[keyId[i]] = newStatement[0];
								converted = true;
							}
						}
						else if (newStatement.Last().IsConditionalBranch()) {
							// Conditional

							var target = (Instruction)newStatement.Last().Operand;
							int brKey;
							if (!trace.IsBranchTarget(newStatement.Last().Offset) &&
							    statementKeys.TryGetValue(target, out brKey)) {
								bool unkSrc = hasUnknownSource(newStatement);
								int nextKey = key[i + 1];
								OpCode condBr = newStatement.Last().OpCode;
								newStatement.RemoveAt(newStatement.Count - 1);

								if (ctx.Random.NextBoolean()) {
									condBr = InverseBranch(condBr);
									int tmp = brKey;
									brKey = nextKey;
									nextKey = tmp;
								}

								var thisKey = key[i];
								int r = 0, xorKey = 0;
								if (!unkSrc) {
									r = ctx.Random.NextInt32();
									xorKey = thisKey * r;
								}

								Instruction brKeyInstr = Instruction.CreateLdcI4(xorKey ^ (predicate != null ? predicate.GetSwitchKey(brKey) : brKey));
								Instruction nextKeyInstr = Instruction.CreateLdcI4(xorKey ^ (predicate != null ? predicate.GetSwitchKey(nextKey) : nextKey));
								Instruction pop = Instruction.Create(OpCodes.Pop);

								newStatement.Add(Instruction.Create(condBr, brKeyInstr));
								newStatement.Add(nextKeyInstr);
								newStatement.Add(Instruction.Create(OpCodes.Dup));
								newStatement.Add(Instruction.Create(OpCodes.Br, pop));
								newStatement.Add(brKeyInstr);
								newStatement.Add(Instruction.Create(OpCodes.Dup));
								newStatement.Add(pop);

								if (!unkSrc) {
									newStatement.Add(Instruction.Create(OpCodes.Ldloc, local));
									newStatement.Add(Instruction.CreateLdcI4(r));
									newStatement.Add(Instruction.Create(OpCodes.Mul));
									newStatement.Add(Instruction.Create(OpCodes.Xor));
								}

								ctx.AddJump(newStatement, switchHdr[1]);
								ctx.AddJunk(newStatement);
								operands[keyId[i]] = newStatement[0];
								converted = true;
							}
						}

						if (!converted) {
							// Normal

							var targetKey = predicate != null ? predicate.GetSwitchKey(key[i + 1]) : key[i + 1];
							if (!hasUnknownSource(newStatement)) {
								var thisKey = key[i];
								var r = ctx.Random.NextInt32();
								newStatement.Add(Instruction.Create(OpCodes.Ldloc, local));
								newStatement.Add(Instruction.CreateLdcI4(r));
								newStatement.Add(Instruction.Create(OpCodes.Mul));
								newStatement.Add(Instruction.Create(OpCodes.Ldc_I4, (thisKey * r) ^ targetKey));
								newStatement.Add(Instruction.Create(OpCodes.Xor));
							}
							else {
								newStatement.Add(Instruction.Create(OpCodes.Ldc_I4, targetKey));
							}

							ctx.AddJump(newStatement, switchHdr[1]);
							ctx.AddJunk(newStatement);
							operands[keyId[i]] = newStatement[0];
						}
					}
					else
						operands[keyId[i]] = switchHdr[0];

					current.Value = newStatement.ToArray();
					current = current.Next;
					i++;
				}
				operands[keyId[i]] = current.Value[0];
				switchInstr.Operand = operands;

				Instruction[] first = statements.First.Value;
				statements.RemoveFirst();
				Instruction[] last = statements.Last.Value;
				statements.RemoveLast();

				List<Instruction[]> newStatements = statements.ToList();
				ctx.Random.Shuffle(newStatements);

				block.Instructions.Clear();
				block.Instructions.AddRange(first);
				block.Instructions.AddRange(switchHdr);
				foreach (var statement in newStatements)
					block.Instructions.AddRange(statement);
				block.Instructions.AddRange(last);
			}
		}
	}
}

```

`Confuser.Protections/ControlFlow/x86Predicate.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;
using MethodBody = dnlib.DotNet.Writer.MethodBody;

namespace Confuser.Protections.ControlFlow {
	internal class x86Predicate : IPredicate {
		static readonly object Encoding = new object();
		readonly CFContext ctx;
		x86Encoding encoding;

		bool inited;

		public x86Predicate(CFContext ctx) {
			this.ctx = ctx;
		}

		public void Init(CilBody body) {
			if (inited)
				return;

			encoding = ctx.Context.Annotations.Get<x86Encoding>(ctx.Method.DeclaringType, Encoding, null);
			if (encoding == null) {
				encoding = new x86Encoding();
				encoding.Compile(ctx);
				ctx.Context.Annotations.Set(ctx.Method.DeclaringType, Encoding, encoding);
			}

			inited = true;
		}

		public void EmitSwitchLoad(IList<Instruction> instrs) {
			instrs.Add(Instruction.Create(OpCodes.Call, encoding.native));
		}

		public int GetSwitchKey(int key) {
			return encoding.expCompiled(key);
		}

		class x86Encoding {
			byte[] code;
			MethodBody codeChunk;

			public Func<int, int> expCompiled;
			Expression expression;
			Expression inverse;
			public MethodDef native;

			public void Compile(CFContext ctx) {
				var var = new Variable("{VAR}");
				var result = new Variable("{RESULT}");

				CorLibTypeSig int32 = ctx.Method.Module.CorLibTypes.Int32;
				native = new MethodDefUser(ctx.Context.Registry.GetService<INameService>().RandomName(), MethodSig.CreateStatic(int32, int32), MethodAttributes.PinvokeImpl | MethodAttributes.PrivateScope | MethodAttributes.Static);
				native.ImplAttributes = MethodImplAttributes.Native | MethodImplAttributes.Unmanaged | MethodImplAttributes.PreserveSig;
				// Attempt to improve performance --- failed with StackOverflowException... :/
				//var suppressAttr = ctx.Method.Module.CorLibTypes.GetTypeRef("System.Security", "SuppressUnmanagedCodeSecurityAttribute").ResolveThrow();
				//native.CustomAttributes.Add(new CustomAttribute((MemberRef)ctx.Method.Module.Import(suppressAttr.FindDefaultConstructor())));
				//native.HasSecurity = true;
				ctx.Method.Module.GlobalType.Methods.Add(native);

				ctx.Context.Registry.GetService<IMarkerService>().Mark(native, ctx.Protection);
				ctx.Context.Registry.GetService<INameService>().SetCanRename(native, false);

				x86Register? reg;
				var codeGen = new x86CodeGen();
				do {
					ctx.DynCipher.GenerateExpressionPair(
						ctx.Random,
						new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
						ctx.Depth, out expression, out inverse);

					reg = codeGen.GenerateX86(inverse, (v, r) => { return new[] { x86Instruction.Create(x86OpCode.POP, new x86RegisterOperand(r)) }; });
				} while (reg == null);

				code = CodeGenUtils.AssembleCode(codeGen, reg.Value);

				expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
					.GenerateCIL(expression)
					.Compile<Func<int, int>>();


				ctx.Context.CurrentModuleWriterOptions.WriterEvent += InjectNativeCode;
			}

			void InjectNativeCode(object sender, ModuleWriterEventArgs e) {
				var writer = e.Writer;
				switch (e.Event) {
				case ModuleWriterEvent.MDEndWriteMethodBodies:
					codeChunk = writer.MethodBodies.Add(new MethodBody(code));
					break;
				case ModuleWriterEvent.EndCalculateRvasAndFileOffsets:
					uint rid = writer.Metadata.GetRid(native);

					var methodRow = writer.Metadata.TablesHeap.MethodTable[rid];
					writer.Metadata.TablesHeap.MethodTable[rid] = new RawMethodRow(
					  (uint)codeChunk.RVA,
					  methodRow.ImplFlags,
					  methodRow.Flags,
					  methodRow.Name,
					  methodRow.Signature,
					  methodRow.ParamList);
					break;
				}
			}
		}
	}
}

```

`Confuser.Protections/HardeningPhase.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections {
	internal sealed class HardeningPhase : ProtectionPhase {
		//private new HardeningComponent Parent => (HardeningComponent)base.Parent;

		/// <inheritdoc />
		[SuppressMessage("ReSharper", "SuggestBaseTypeForParameter")]
		public HardeningPhase(HardeningProtection parent) : base(parent) { }

		/// <inheritdoc />
		public override ProtectionTargets Targets => ProtectionTargets.Modules;

		/// <inheritdoc />
		public override string Name => "Hardening Phase";

		/// <inheritdoc />
		public override bool ProcessAll => false;

		/// <inheritdoc />
		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			foreach (var module in parameters.Targets.OfType<ModuleDef>())
				HardenMethod(context, module);
		}

		private static void HardenMethod(ConfuserContext context, ModuleDef module) {
			var cctor = module.GlobalType.FindStaticConstructor();
			if (cctor == null) {
				context.Logger.Debug("No .cctor containing protection code found. Nothing to do.");
				return;
			}

			if (!cctor.HasBody || !cctor.Body.HasInstructions) return;

			var marker = context.Registry.GetService<IMarkerService>();
			var instructions = cctor.Body.Instructions;
			for (var i = instructions.Count - 1; i >= 0; i--) {
				if (instructions[i].OpCode.Code != Code.Call) continue;
				if (!(instructions[i].Operand is MethodDef targetMethod)) continue;
				if (!targetMethod.IsStatic || targetMethod.DeclaringType != module.GlobalType) continue;
				if (!marker.IsMarked(targetMethod) || !(marker.GetHelperParent(targetMethod) is Protection protection)) continue;

				// Resource protection needs to rewrite the method during the write phase. Not compatible!
				if (protection.FullId.Equals(ResourceProtection._FullId)) continue; 

				cctor.Body.MergeCall(instructions[i]);
				targetMethod.DeclaringType.Methods.Remove(targetMethod);
			}
		}
	}
}

```

`Confuser.Protections/HardeningProtection.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using Confuser.Core;

namespace Confuser.Protections {
	[SuppressMessage("ReSharper", "ClassNeverInstantiated.Global", Justification = "Instantiated by reflection.")]
	internal sealed class HardeningProtection : Protection {
		/// <inheritdoc />
		public override string Name => "Protection Hardening";

		/// <inheritdoc />
		public override string Description => "This component improves the protection code, making it harder to circumvent it.";

		/// <inheritdoc />
		public override string Id => "harden";

		/// <inheritdoc />
		public override string FullId => "Cx.Harden";

		/// <inheritdoc />
		protected override void Initialize(ConfuserContext context) { }

		/// <inheritdoc />
		protected override void PopulatePipeline(ProtectionPipeline pipeline) => 
			pipeline.InsertPreStage(PipelineStage.OptimizeMethods, new HardeningPhase(this));

		/// <inheritdoc />
		public override ProtectionPreset Preset => ProtectionPreset.Minimum;
	}
}

```

`Confuser.Protections/InvalidMetadataProtection.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace Confuser.Protections {
	internal class InvalidMetadataProtection : Protection {
		public const string _Id = "invalid metadata";
		public const string _FullId = "Ki.InvalidMD";

		public override string Name {
			get { return "Invalid Metadata Protection"; }
		}

		public override string Description {
			get { return "This protection adds invalid metadata to modules to prevent disassembler/decompiler from opening them."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.None; }
		}

		protected override void Initialize(ConfuserContext context) {
			//
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPostStage(PipelineStage.BeginModule, new InvalidMDPhase(this));
		}

		class InvalidMDPhase : ProtectionPhase {
			RandomGenerator random;

			public InvalidMDPhase(InvalidMetadataProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Invalid metadata addition"; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				if (parameters.Targets.Contains(context.CurrentModule)) {
					random = context.Registry.GetService<IRandomService>().GetRandomGenerator(_FullId);
					context.CurrentModuleWriterOptions.WriterEvent += OnWriterEvent;
				}
			}

			void Randomize<T>(MDTable<T> table) where T : struct => random.Shuffle(table);

			void OnWriterEvent(object sender, ModuleWriterEventArgs e) {
				var writer = (ModuleWriterBase)sender;
				if (e.Event == ModuleWriterEvent.MDEndCreateTables) {
					// These hurts reflection

					/*
					uint methodLen = (uint)writer.MetaData.TablesHeap.MethodTable.Rows + 1;
					uint fieldLen = (uint)writer.MetaData.TablesHeap.FieldTable.Rows + 1;

					var root = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(
							0, 0x7fff7fff, 0, 0x3FFFD, fieldLen, methodLen));
					writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root, root));

					var namespaces = writer.MetaData.TablesHeap.TypeDefTable
						.Select(row => row.Namespace)
						.Distinct()
						.ToList();
					foreach (var ns in namespaces)
					{
						if (ns == 0) continue;
						var type = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(
							0, 0, ns, 0x3FFFD, fieldLen, methodLen));
						writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root, type));
					}

					foreach (var row in writer.MetaData.TablesHeap.ParamTable)
						row.Name = 0x7fff7fff;
					*/

					writer.Metadata.TablesHeap.ModuleTable.Add(new RawModuleRow(0, 0x7fff7fff, 0, 0, 0));
					writer.Metadata.TablesHeap.AssemblyTable.Add(new RawAssemblyRow(0, 0, 0, 0, 0, 0, 0, 0x7fff7fff, 0));

					int r = random.NextInt32(8, 16);
					for (int i = 0; i < r; i++)
						writer.Metadata.TablesHeap.ENCLogTable.Add(new RawENCLogRow(random.NextUInt32(), random.NextUInt32()));
					r = random.NextInt32(8, 16);
					for (int i = 0; i < r; i++)
						writer.Metadata.TablesHeap.ENCMapTable.Add(new RawENCMapRow(random.NextUInt32()));

					//Randomize(writer.MetaData.TablesHeap.NestedClassTable);
					Randomize(writer.Metadata.TablesHeap.ManifestResourceTable);
					//Randomize(writer.MetaData.TablesHeap.GenericParamConstraintTable);

					writer.TheOptions.MetadataOptions.TablesHeapOptions.ExtraData = random.NextUInt32();
					writer.TheOptions.MetadataOptions.TablesHeapOptions.UseENC = false;
					writer.TheOptions.MetadataOptions.MetadataHeaderOptions.VersionString += "\0\0\0\0";

					/*
					We are going to create a new specific '#GUID' Heap to avoid UnConfuserEX to work.
					<sarcasm>UnConfuserEX is so well coded, it relies on static cmp between values</sarcasm>
					If you deobfuscate this tool, you can see that it check for #GUID size and compare it to
					'16', so we have to create a new array of byte wich size is exactly 16 and put it into
					our brand new Heap
					*/
					//
					writer.TheOptions.MetadataOptions.CustomHeaps.Add(new RawHeap("#GUID", Guid.NewGuid().ToByteArray()));
					//
					writer.TheOptions.MetadataOptions.CustomHeaps.Add(new RawHeap("#Strings", new byte[1]));
					writer.TheOptions.MetadataOptions.CustomHeaps.Add(new RawHeap("#Blob", new byte[1]));
					writer.TheOptions.MetadataOptions.CustomHeaps.Add(new RawHeap("#Schema", new byte[1]));
				}
				else if (e.Event == ModuleWriterEvent.MDOnAllTablesSorted) {
					writer.Metadata.TablesHeap.DeclSecurityTable.Add(new RawDeclSecurityRow(
																		 unchecked(0x7fff), 0xffff7fff, 0xffff7fff));
					/*
					writer.MetaData.TablesHeap.ManifestResourceTable.Add(new RawManifestResourceRow(
						0x7fff7fff, (uint)ManifestResourceAttributes.Private, 0x7fff7fff, 2));
					*/
				}
			}
		}

		class RawHeap : HeapBase {
			readonly byte[] content;
			readonly string name;

			public RawHeap(string name, byte[] content) {
				this.name = name;
				this.content = content;
			}

			public override string Name {
				get { return name; }
			}

			public override uint GetRawLength() {
				return (uint)content.Length;
			}

			protected override void WriteToImpl(DataWriter writer) {
				writer.WriteBytes(content);
			}
		}
	}
}

```

`Confuser.Protections/ReferenceProxy/ExpressionEncoding.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal class ExpressionEncoding : IRPEncoding {
		readonly Dictionary<MethodDef, Tuple<Expression, Func<int, int>>> keys = new Dictionary<MethodDef, Tuple<Expression, Func<int, int>>>();

		public Instruction[] EmitDecode(MethodDef init, RPContext ctx, Instruction[] arg) {
			Tuple<Expression, Func<int, int>> key = GetKey(ctx, init);

			var invCompiled = new List<Instruction>();
			new CodeGen(arg, ctx.Method, invCompiled).GenerateCIL(key.Item1);
			init.Body.MaxStack += (ushort)ctx.Depth;
			return invCompiled.ToArray();
		}

		public int Encode(MethodDef init, RPContext ctx, int value) {
			Tuple<Expression, Func<int, int>> key = GetKey(ctx, init);
			return key.Item2(value);
		}

		void Compile(RPContext ctx, CilBody body, out Func<int, int> expCompiled, out Expression inverse) {
			var var = new Variable("{VAR}");
			var result = new Variable("{RESULT}");

			Expression expression;
			ctx.DynCipher.GenerateExpressionPair(
				ctx.Random,
				new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
				ctx.Depth, out expression, out inverse);

			expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
				.GenerateCIL(expression)
				.Compile<Func<int, int>>();
		}

		Tuple<Expression, Func<int, int>> GetKey(RPContext ctx, MethodDef init) {
			Tuple<Expression, Func<int, int>> ret;
			if (!keys.TryGetValue(init, out ret)) {
				Func<int, int> keyFunc;
				Expression inverse;
				Compile(ctx, init.Body, out keyFunc, out inverse);
				keys[init] = ret = Tuple.Create(inverse, keyFunc);
			}
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Instruction[] arg;

			public CodeGen(Instruction[] arg, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.arg = arg;
			}

			protected override void LoadVar(Variable var) {
				if (var.Name == "{RESULT}") {
					foreach (Instruction instr in arg)
						Emit(instr);
				}
				else
					base.LoadVar(var);
			}
		}
	}
}
```

`Confuser.Protections/ReferenceProxy/IRPEncoding.cs`:

```cs
using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal interface IRPEncoding {
		Instruction[] EmitDecode(MethodDef init, RPContext ctx, Instruction[] arg);
		int Encode(MethodDef init, RPContext ctx, int value);
	}
}
```

`Confuser.Protections/ReferenceProxy/MildMode.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal class MildMode : RPMode {
		// proxy method, { opCode, calling type, target method}
		readonly Dictionary<Tuple<Code, TypeDef, IMethod>, MethodDef> proxies = new Dictionary<Tuple<Code, TypeDef, IMethod>, MethodDef>();

		public override void ProcessCall(RPContext ctx, int instrIndex) {
			Instruction invoke = ctx.Body.Instructions[instrIndex];
			var target = (IMethod)invoke.Operand;

			// Value type proxy is not supported in mild mode.
			if (target.DeclaringType.ResolveTypeDefThrow().IsValueType)
				return;
			// Skipping visibility is not supported in mild mode.
			if (!target.ResolveThrow().IsPublic && !target.ResolveThrow().IsAssembly)
				return;

			Tuple<Code, TypeDef, IMethod> key = Tuple.Create(invoke.OpCode.Code, ctx.Method.DeclaringType, target);
			MethodDef proxy;
			if (!proxies.TryGetValue(key, out proxy)) {
				MethodSig sig = CreateProxySignature(ctx, target, invoke.OpCode.Code == Code.Newobj);

				proxy = new MethodDefUser(ctx.Name.RandomName(), sig);
				proxy.Attributes = MethodAttributes.PrivateScope | MethodAttributes.Static;
				proxy.ImplAttributes = MethodImplAttributes.Managed | MethodImplAttributes.IL;
				ctx.Method.DeclaringType.Methods.Add(proxy);

				// Fix peverify --- Non-virtual call to virtual methods must be done on this pointer
				if (invoke.OpCode.Code == Code.Call && target.ResolveThrow().IsVirtual) {
					proxy.IsStatic = false;
					sig.HasThis = true;
					sig.Params.RemoveAt(0);
				}

				ctx.Marker.Mark(proxy, ctx.Protection);
				ctx.Name.Analyze(proxy);
				ctx.Name.SetCanRename(proxy, false);

				proxy.Body = new CilBody();
				for (int i = 0; i < proxy.Parameters.Count; i++)
					proxy.Body.Instructions.Add(Instruction.Create(OpCodes.Ldarg, proxy.Parameters[i]));
				proxy.Body.Instructions.Add(Instruction.Create(invoke.OpCode, target));
				proxy.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));

				proxies[key] = proxy;
			}

			invoke.OpCode = OpCodes.Call;
			if (ctx.Method.DeclaringType.HasGenericParameters) {
				var genArgs = new GenericVar[ctx.Method.DeclaringType.GenericParameters.Count];
				for (int i = 0; i < genArgs.Length; i++)
					genArgs[i] = new GenericVar(i);

				invoke.Operand = new MemberRefUser(
					ctx.Module,
					proxy.Name,
					proxy.MethodSig,
					new GenericInstSig((ClassOrValueTypeSig)ctx.Method.DeclaringType.ToTypeSig(), genArgs).ToTypeDefOrRef());
			}
			else
				invoke.Operand = proxy;

			var targetDef = target.ResolveMethodDef();
			if (targetDef != null)
				ctx.Context.Annotations.Set(targetDef, ReferenceProxyProtection.Targeted, ReferenceProxyProtection.Targeted);
		}

		public override void Finalize(RPContext ctx) { }
	}
}
```

`Confuser.Protections/ReferenceProxy/NormalEncoding.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core.Services;
using Confuser.DynCipher;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal class NormalEncoding : IRPEncoding {
		readonly Dictionary<MethodDef, Tuple<int, int>> keys = new Dictionary<MethodDef, Tuple<int, int>>();

		public Instruction[] EmitDecode(MethodDef init, RPContext ctx, Instruction[] arg) {
			Tuple<int, int> key = GetKey(ctx.Random, init);
			var ret = new List<Instruction>();
			if (ctx.Random.NextBoolean()) {
				ret.Add(Instruction.Create(OpCodes.Ldc_I4, key.Item1));
				ret.AddRange(arg);
			}
			else {
				ret.AddRange(arg);
				ret.Add(Instruction.Create(OpCodes.Ldc_I4, key.Item1));
			}
			ret.Add(Instruction.Create(OpCodes.Mul));
			return ret.ToArray();
		}

		public int Encode(MethodDef init, RPContext ctx, int value) {
			Tuple<int, int> key = GetKey(ctx.Random, init);
			return value * key.Item2;
		}

		Tuple<int, int> GetKey(RandomGenerator random, MethodDef init) {
			Tuple<int, int> ret;
			if (!keys.TryGetValue(init, out ret)) {
				int key = random.NextInt32() | 1;
				keys[init] = ret = Tuple.Create(key, (int)MathsUtils.modInv((uint)key));
			}
			return ret;
		}
	}
}
```

`Confuser.Protections/ReferenceProxy/RPContext.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.ReferenceProxy {
	internal enum Mode {
		Mild,
		Strong,
		Ftn
	}

	internal enum EncodingType {
		Normal,
		Expression,
		x86
	}

	internal class RPContext {
		public ReferenceProxyProtection Protection;
		public CilBody Body;
		public HashSet<Instruction> BranchTargets;
		public ConfuserContext Context;
		public Dictionary<MethodSig, TypeDef> Delegates;
		public int Depth;
		public IDynCipherService DynCipher;
		public EncodingType Encoding;
		public IRPEncoding EncodingHandler;
		public int InitCount;
		public bool InternalAlso;
		public IMarkerService Marker;
		public MethodDef Method;
		public Mode Mode;

		public RPMode ModeHandler;
		public ModuleDef Module;
		public INameService Name;
		public RandomGenerator Random;
		public bool TypeErasure;
	}
}
```

`Confuser.Protections/ReferenceProxy/RPMode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Renamer;
using Confuser.Renamer.References;
using dnlib.DotNet;

namespace Confuser.Protections.ReferenceProxy {
	internal abstract class RPMode {
		public abstract void ProcessCall(RPContext ctx, int instrIndex);
		public abstract void Finalize(RPContext ctx);

		static ITypeDefOrRef Import(RPContext ctx, TypeDef typeDef) {
			ITypeDefOrRef retTypeRef = new Importer(ctx.Module, ImporterOptions.TryToUseTypeDefs).Import(typeDef);
			if (typeDef.Module != ctx.Module && ctx.Context.Modules.Contains((ModuleDefMD)typeDef.Module))
				ctx.Name.AddReference(typeDef, new TypeRefReference((TypeRef)retTypeRef, typeDef));
			return retTypeRef;
		}

		protected static MethodSig CreateProxySignature(RPContext ctx, IMethod method, bool newObj) {
			ModuleDef module = ctx.Module;
			if (newObj) {
				Debug.Assert(method.MethodSig.HasThis);
				Debug.Assert(method.Name == ".ctor");
				TypeSig[] paramTypes = method.MethodSig.Params.Select(type => {
					if (ctx.TypeErasure && type.IsClassSig && method.MethodSig.HasThis)
						return module.CorLibTypes.Object;
					return type;
				}).ToArray();

				TypeSig retType;
				if (ctx.TypeErasure) // newobj will not be used with value types
					retType = module.CorLibTypes.Object;
				else {
					TypeDef declType = method.DeclaringType.ResolveTypeDefThrow();
					retType = Import(ctx, declType).ToTypeSig();
				}
				return MethodSig.CreateStatic(retType, paramTypes);
			}
			else {
				IEnumerable<TypeSig> paramTypes = method.MethodSig.Params.Select(type => {
					if (ctx.TypeErasure && type.IsClassSig && method.MethodSig.HasThis)
						return module.CorLibTypes.Object;
					return type;
				});
				if (method.MethodSig.HasThis && !method.MethodSig.ExplicitThis) {
					TypeDef declType = method.DeclaringType.ResolveTypeDefThrow();
					if (ctx.TypeErasure && !declType.IsValueType)
						paramTypes = new[] { module.CorLibTypes.Object }.Concat(paramTypes);
					else
						paramTypes = new[] { Import(ctx, declType).ToTypeSig() }.Concat(paramTypes);
				}
				TypeSig retType = method.MethodSig.RetType;
				if (ctx.TypeErasure && retType.IsClassSig)
					retType = module.CorLibTypes.Object;
				return MethodSig.CreateStatic(retType, paramTypes.ToArray());
			}
		}

		protected static TypeDef GetDelegateType(RPContext ctx, MethodSig sig) {
			TypeDef ret;
			if (ctx.Delegates.TryGetValue(sig, out ret))
				return ret;

			ret = new TypeDefUser(ctx.Name.ObfuscateName(ctx.Method.DeclaringType.Namespace, RenameMode.Unicode), ctx.Name.RandomName(), ctx.Module.CorLibTypes.GetTypeRef("System", "MulticastDelegate"));
			ret.Attributes = TypeAttributes.NotPublic | TypeAttributes.Sealed;

			var ctor = new MethodDefUser(".ctor", MethodSig.CreateInstance(ctx.Module.CorLibTypes.Void, ctx.Module.CorLibTypes.Object, ctx.Module.CorLibTypes.IntPtr));
			ctor.Attributes = MethodAttributes.Assembly | MethodAttributes.HideBySig | MethodAttributes.RTSpecialName | MethodAttributes.SpecialName;
			ctor.ImplAttributes = MethodImplAttributes.Runtime;
			ret.Methods.Add(ctor);

			var invoke = new MethodDefUser("Invoke", sig.Clone());
			invoke.MethodSig.HasThis = true;
			invoke.Attributes = MethodAttributes.Assembly | MethodAttributes.HideBySig | MethodAttributes.Virtual | MethodAttributes.NewSlot;
			invoke.ImplAttributes = MethodImplAttributes.Runtime;
			ret.Methods.Add(invoke);

			ctx.Module.Types.Add(ret);

			foreach (IDnlibDef def in ret.FindDefinitions()) {
				ctx.Marker.Mark(def, ctx.Protection);
				ctx.Name.SetCanRename(def, false);
			}

			ctx.Delegates[sig] = ret;
			return ret;
		}
	}
}
```

`Confuser.Protections/ReferenceProxy/ReferenceProxyPhase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;

namespace Confuser.Protections.ReferenceProxy {
	internal class ReferenceProxyPhase : ProtectionPhase {
		public ReferenceProxyPhase(ReferenceProxyProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Encoding reference proxies"; }
		}

		RPContext ParseParameters(MethodDef method, ConfuserContext context, ProtectionParameters parameters, RPStore store) {
			var ret = new RPContext();
			ret.Mode = parameters.GetParameter(context, method, "mode", Mode.Mild);
			ret.Encoding = parameters.GetParameter(context, method, "encoding", EncodingType.Normal);
			ret.InternalAlso = parameters.GetParameter(context, method, "internal", false);
			ret.TypeErasure = parameters.GetParameter(context, method, "typeErasure", false);
			ret.Depth = parameters.GetParameter(context, method, "depth", 3);

			ret.Module = method.Module;
			ret.Method = method;
			ret.Body = method.Body;
			ret.BranchTargets = new HashSet<Instruction>(
				method.Body.Instructions
				      .Select(instr => instr.Operand as Instruction)
				      .Concat(method.Body.Instructions
				                    .Where(instr => instr.Operand is Instruction[])
				                    .SelectMany(instr => (Instruction[])instr.Operand))
				      .Where(target => target != null));

			ret.Protection = (ReferenceProxyProtection)Parent;
			ret.Random = store.random;
			ret.Context = context;
			ret.Marker = context.Registry.GetService<IMarkerService>();
			ret.DynCipher = context.Registry.GetService<IDynCipherService>();
			ret.Name = context.Registry.GetService<INameService>();

			ret.Delegates = store.delegates;

			switch (ret.Mode) {
				case Mode.Mild:
					ret.ModeHandler = store.mild ?? (store.mild = new MildMode());
					break;
				case Mode.Strong:
					ret.ModeHandler = store.strong ?? (store.strong = new StrongMode());
					break;
				default:
					throw new UnreachableException();
			}

			switch (ret.Encoding) {
				case EncodingType.Normal:
					ret.EncodingHandler = store.normal ?? (store.normal = new NormalEncoding());
					break;
				case EncodingType.Expression:
					ret.EncodingHandler = store.expression ?? (store.expression = new ExpressionEncoding());
					break;
				case EncodingType.x86:
					ret.EncodingHandler = store.x86 ?? (store.x86 = new x86Encoding());

					if ((context.CurrentModule.Cor20HeaderFlags & ComImageFlags.ILOnly) != 0)
						context.CurrentModuleWriterOptions.Cor20HeaderOptions.Flags &= ~ComImageFlags.ILOnly;
					break;
				default:
					throw new UnreachableException();
			}

			return ret;
		}

		static RPContext ParseParameters(ModuleDef module, ConfuserContext context, ProtectionParameters parameters, RPStore store) {
			var ret = new RPContext();
			ret.Depth = parameters.GetParameter(context, module, "depth", 3);
			ret.InitCount = parameters.GetParameter(context, module, "initCount", 0x10);

			ret.Random = store.random;
			ret.Module = module;
			ret.Context = context;
			ret.Marker = context.Registry.GetService<IMarkerService>();
			ret.DynCipher = context.Registry.GetService<IDynCipherService>();
			ret.Name = context.Registry.GetService<INameService>();

			ret.Delegates = store.delegates;

			return ret;
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			RandomGenerator random = context.Registry.GetService<IRandomService>().GetRandomGenerator(ReferenceProxyProtection._FullId);

			var store = new RPStore { random = random };

			foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger))
				if (method.HasBody && method.Body.Instructions.Count > 0) {
					ProcessMethod(ParseParameters(method, context, parameters, store));
					context.CheckCancellation();
				}

			RPContext ctx = ParseParameters(context.CurrentModule, context, parameters, store);

			if (store.mild != null)
				store.mild.Finalize(ctx);

			if (store.strong != null)
				store.strong.Finalize(ctx);
		}

		void ProcessMethod(RPContext ctx) {
			if (ctx.Marker.GetHelperParent(ctx.Method) != null)
				return;

			for (int i = 0; i < ctx.Body.Instructions.Count; i++) {
				Instruction instr = ctx.Body.Instructions[i];
				if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt || instr.OpCode.Code == Code.Newobj) {
					var operand = (IMethod)instr.Operand;
					var def = operand.ResolveMethodDef();

					if (def != null && ctx.Context.Annotations.Get<object>(def, ReferenceProxyProtection.TargetExcluded) != null)
						return;

					// Call constructor
					if (instr.OpCode.Code != Code.Newobj && operand.Name == ".ctor")
						continue;
					// Internal reference option
					if (operand is MethodDef && !ctx.InternalAlso)
						continue;
					// No generic methods
					if (operand is MethodSpec)
						continue;
					// No generic types / array types
					if (operand.DeclaringType is TypeSpec)
						continue;
					// No varargs
					if (operand.MethodSig.ParamsAfterSentinel != null &&
						operand.MethodSig.ParamsAfterSentinel.Count > 0)
						continue;
					TypeDef declType = operand.DeclaringType.ResolveTypeDefThrow();
					// No delegates
					if (declType.IsDelegate())
						continue;
					// No instance value type methods
					if (declType.IsValueType && operand.MethodSig.HasThis)
						continue;
					// No prefixed call
					if (i - 1 >= 0 && ctx.Body.Instructions[i - 1].OpCode.OpCodeType == OpCodeType.Prefix)
						continue;

					ctx.ModeHandler.ProcessCall(ctx, i);
				}
			}
		}

		class RPStore {
			public readonly Dictionary<MethodSig, TypeDef> delegates = new Dictionary<MethodSig, TypeDef>(new MethodSigComparer());
			public ExpressionEncoding expression;
			public MildMode mild;

			public NormalEncoding normal;
			public RandomGenerator random;
			public StrongMode strong;
			public x86Encoding x86;

			class MethodSigComparer : IEqualityComparer<MethodSig> {
				public bool Equals(MethodSig x, MethodSig y) {
					return new SigComparer().Equals(x, y);
				}

				public int GetHashCode(MethodSig obj) {
					return new SigComparer().GetHashCode(obj);
				}
			}
		}
	}
}

```

`Confuser.Protections/ReferenceProxy/ReferenceProxyProtection.cs`:

```cs
using System;
using Confuser.Core;
using Confuser.Protections.ReferenceProxy;
using dnlib.DotNet;

namespace Confuser.Protections {
	public interface IReferenceProxyService {
		void ExcludeMethod(ConfuserContext context, MethodDef method);
		void ExcludeTarget(ConfuserContext context, MethodDef method);
		bool IsTargeted(ConfuserContext context, MethodDef method);
	}

	[AfterProtection("Ki.AntiDebug", "Ki.AntiDump")]
	[BeforeProtection("Ki.ControlFlow")]
	internal class ReferenceProxyProtection : Protection, IReferenceProxyService {
		public const string _Id = "ref proxy";
		public const string _FullId = "Ki.RefProxy";
		public const string _ServiceId = "Ki.RefProxy";

		internal static object TargetExcluded = new object();
		internal static object Targeted = new object();

		public override string Name {
			get { return "Reference Proxy Protection"; }
		}

		public override string Description {
			get { return "This protection encodes and hides references to type/method/fields."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Normal; }
		}

		public void ExcludeMethod(ConfuserContext context, MethodDef method) {
			ProtectionParameters.GetParameters(context, method).Remove(this);
		}

		public void ExcludeTarget(ConfuserContext context, MethodDef method) {
			context.Annotations.Set(method, TargetExcluded, TargetExcluded);
		}

		public bool IsTargeted(ConfuserContext context, MethodDef method) {
			return context.Annotations.Get<object>(method, Targeted) != null;
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(IReferenceProxyService), this);
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new ReferenceProxyPhase(this));
		}
	}
}
```

`Confuser.Protections/ReferenceProxy/StrongMode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.ReferenceProxy {
	internal class StrongMode : RPMode {
		// { invoke opCode, invoke target, encoding}, { proxy field, bridge method }
		readonly List<FieldDesc> fieldDescs = new List<FieldDesc>();
		readonly Dictionary<Tuple<Code, IMethod, IRPEncoding>, Tuple<FieldDef, MethodDef>> fields = new Dictionary<Tuple<Code, IMethod, IRPEncoding>, Tuple<FieldDef, MethodDef>>();

		readonly Dictionary<IRPEncoding, InitMethodDesc[]> inits = new Dictionary<IRPEncoding, InitMethodDesc[]>();
		RPContext encodeCtx;
		Tuple<TypeDef, Func<int, int>>[] keyAttrs;

		static int? TraceBeginning(RPContext ctx, int index, int argCount) {
			if (ctx.BranchTargets.Contains(ctx.Body.Instructions[index]))
				return null;

			int currentStack = argCount;
			int currentIndex = index;
			while (currentStack > 0) {
				currentIndex--;
				Instruction currentInstr = ctx.Body.Instructions[currentIndex];

				// Disrupt stack analysis :/ Used by array initializer
				if (currentInstr.OpCode == OpCodes.Pop || currentInstr.OpCode == OpCodes.Dup)
					return null;

				// No branch instr.
				switch (currentInstr.OpCode.FlowControl) {
					case FlowControl.Call:
					case FlowControl.Break:
					case FlowControl.Meta:
					case FlowControl.Next:
						break;
					default:
						return null;
				}

				int push, pop;
				currentInstr.CalculateStackUsage(ctx.Method.HasReturnType, out push, out pop);
				currentStack += pop;
				currentStack -= push;

				// No branch target
				if (ctx.BranchTargets.Contains(currentInstr) && currentStack != 0)
					return null;
			}
			if (currentStack < 0)
				return null;
			return currentIndex;
		}

		public override void ProcessCall(RPContext ctx, int instrIndex) {
			Instruction invoke = ctx.Body.Instructions[instrIndex];

			TypeDef declType = ((IMethod)invoke.Operand).DeclaringType.ResolveTypeDefThrow();
			if (!declType.Module.IsILOnly) // Reflection doesn't like mixed mode modules.
				return;
			if (declType.IsGlobalModuleType) // Reflection doesn't like global methods too.
				return;

			int push, pop;
			invoke.CalculateStackUsage(ctx.Method.HasReturnType, out push, out pop);
			int? begin = TraceBeginning(ctx, instrIndex, pop);
			// Fail to trace the arguments => fall back to bridge method
			bool fallBack = begin == null;

			if (fallBack) {
				ProcessBridge(ctx, instrIndex);
			}
			else {
				ProcessInvoke(ctx, instrIndex, begin.Value);
			}
		}

		void ProcessBridge(RPContext ctx, int instrIndex) {
			Instruction instr = ctx.Body.Instructions[instrIndex];
			var target = (IMethod)instr.Operand;

			TypeDef declType = target.DeclaringType.ResolveTypeDefThrow();
			if (!declType.Module.IsILOnly) // Reflection doesn't like mixed mode modules.
				return;
			if (declType.IsGlobalModuleType) // Reflection doesn't like global methods too.
				return;

			Tuple<Code, IMethod, IRPEncoding> key = Tuple.Create(instr.OpCode.Code, target, ctx.EncodingHandler);
			Tuple<FieldDef, MethodDef> proxy;
			if (fields.TryGetValue(key, out proxy)) {
				if (proxy.Item2 != null) {
					instr.OpCode = OpCodes.Call;
					instr.Operand = proxy.Item2;
					return;
				}
			}
			else
				proxy = new Tuple<FieldDef, MethodDef>(null, null);

			MethodSig sig = CreateProxySignature(ctx, target, instr.OpCode.Code == Code.Newobj);
			TypeDef delegateType = GetDelegateType(ctx, sig);

			// Create proxy field
			if (proxy.Item1 == null)
				proxy = new Tuple<FieldDef, MethodDef>(
					CreateField(ctx, delegateType),
					proxy.Item2);

			// Create proxy bridge
			Debug.Assert(proxy.Item2 == null);

			proxy = new Tuple<FieldDef, MethodDef>(
				proxy.Item1,
				CreateBridge(ctx, delegateType, proxy.Item1, sig));

			fields[key] = proxy;

			// Replace instruction
			instr.OpCode = OpCodes.Call;
			instr.Operand = proxy.Item2;

			var targetDef = target.ResolveMethodDef();
			if (targetDef != null)
				ctx.Context.Annotations.Set(targetDef, ReferenceProxyProtection.Targeted, ReferenceProxyProtection.Targeted);
		}

		void ProcessInvoke(RPContext ctx, int instrIndex, int argBeginIndex) {
			Instruction instr = ctx.Body.Instructions[instrIndex];
			var target = (IMethod)instr.Operand;

			MethodSig sig = CreateProxySignature(ctx, target, instr.OpCode.Code == Code.Newobj);
			TypeDef delegateType = GetDelegateType(ctx, sig);

			Tuple<Code, IMethod, IRPEncoding> key = Tuple.Create(instr.OpCode.Code, target, ctx.EncodingHandler);
			Tuple<FieldDef, MethodDef> proxy;
			if (!fields.TryGetValue(key, out proxy)) {
				// Create proxy field
				proxy = new Tuple<FieldDef, MethodDef>(CreateField(ctx, delegateType), null);
				fields[key] = proxy;
			}

			// Insert field load & replace instruction
			if (argBeginIndex == instrIndex) {
				ctx.Body.Instructions.Insert(instrIndex + 1,
				                             new Instruction(OpCodes.Call, delegateType.FindMethod("Invoke")));
				instr.OpCode = OpCodes.Ldsfld;
				instr.Operand = proxy.Item1;
			}
			else {
				Instruction argBegin = ctx.Body.Instructions[argBeginIndex];
				ctx.Body.Instructions.Insert(argBeginIndex + 1,
				                             new Instruction(argBegin.OpCode, argBegin.Operand));
				argBegin.OpCode = OpCodes.Ldsfld;
				argBegin.Operand = proxy.Item1;

				instr.OpCode = OpCodes.Call;
				instr.Operand = delegateType.FindMethod("Invoke");
			}

			var targetDef = target.ResolveMethodDef();
			if (targetDef != null)
				ctx.Context.Annotations.Set(targetDef, ReferenceProxyProtection.Targeted, ReferenceProxyProtection.Targeted);
		}

		MethodDef CreateBridge(RPContext ctx, TypeDef delegateType, FieldDef field, MethodSig sig) {
			var method = new MethodDefUser(ctx.Name.RandomName(), sig);
			method.Attributes = MethodAttributes.PrivateScope | MethodAttributes.Static;
			method.ImplAttributes = MethodImplAttributes.Managed | MethodImplAttributes.IL;

			method.Body = new CilBody();
			method.Body.Instructions.Add(Instruction.Create(OpCodes.Ldsfld, field));
			for (int i = 0; i < method.Parameters.Count; i++)
				method.Body.Instructions.Add(Instruction.Create(OpCodes.Ldarg, method.Parameters[i]));
			method.Body.Instructions.Add(Instruction.Create(OpCodes.Call, delegateType.FindMethod("Invoke")));
			method.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));

			delegateType.Methods.Add(method);

			ctx.Context.Registry.GetService<IMarkerService>().Mark(method, ctx.Protection);
			ctx.Name.SetCanRename(method, false);

			return method;
		}

		FieldDef CreateField(RPContext ctx, TypeDef delegateType) {
			// Details will be filled in during metadata writing
			TypeDef randomType;
			do {
				randomType = ctx.Module.Types[ctx.Random.NextInt32(ctx.Module.Types.Count)];
			} while (randomType.HasGenericParameters || randomType.IsGlobalModuleType || randomType.IsDelegate());

			TypeSig fieldType = new CModOptSig(randomType, delegateType.ToTypeSig());

			var field = new FieldDefUser("", new FieldSig(fieldType), FieldAttributes.Static | FieldAttributes.Assembly);
			field.CustomAttributes.Add(new CustomAttribute(GetKeyAttr(ctx).FindInstanceConstructors().First()));
			delegateType.Fields.Add(field);

			ctx.Marker.Mark(field, ctx.Protection);
			ctx.Name.SetCanRename(field, false);

			return field;
		}

		TypeDef GetKeyAttr(RPContext ctx) {
			if (keyAttrs == null)
				keyAttrs = new Tuple<TypeDef, Func<int, int>>[0x10];

			int index = ctx.Random.NextInt32(keyAttrs.Length);
			if (keyAttrs[index] == null) {
				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyKey");
				TypeDef injectedAttr = InjectHelper.Inject(rtType, ctx.Module);
				injectedAttr.Name = ctx.Name.RandomName();
				injectedAttr.Namespace = string.Empty;

				Expression expression, inverse;
				var var = new Variable("{VAR}");
				var result = new Variable("{RESULT}");

				ctx.DynCipher.GenerateExpressionPair(
					ctx.Random,
					new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
					ctx.Depth, out expression, out inverse);

				var expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
					.GenerateCIL(expression)
					.Compile<Func<int, int>>();

				MethodDef ctor = injectedAttr.FindMethod(".ctor");
				MutationHelper.ReplacePlaceholder(ctor, arg => {
					var invCompiled = new List<Instruction>();
					new CodeGen(arg, ctor, invCompiled).GenerateCIL(inverse);
					return invCompiled.ToArray();
				});
				keyAttrs[index] = Tuple.Create(injectedAttr, expCompiled);

				ctx.Module.AddAsNonNestedType(injectedAttr);

				foreach (IDnlibDef def in injectedAttr.FindDefinitions()) {
					if (def.Name == "GetHashCode") {
						ctx.Name.MarkHelper(def, ctx.Marker, ctx.Protection);
						((MethodDef)def).Access = MethodAttributes.Public;
					}
					else
						ctx.Name.MarkHelper(def, ctx.Marker, ctx.Protection);
				}
			}
			return keyAttrs[index].Item1;
		}

		InitMethodDesc GetInitMethod(RPContext ctx, IRPEncoding encoding) {
			InitMethodDesc[] initDescs;
			if (!inits.TryGetValue(encoding, out initDescs))
				inits[encoding] = initDescs = new InitMethodDesc[ctx.InitCount];

			int index = ctx.Random.NextInt32(initDescs.Length);
			if (initDescs[index] == null) {
				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");
				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize"), ctx.Module);
				ctx.Module.GlobalType.Methods.Add(injectedMethod);

				injectedMethod.Access = MethodAttributes.PrivateScope;
				injectedMethod.Name = ctx.Name.RandomName();
				ctx.Name.SetCanRename(injectedMethod, false);
				ctx.Marker.Mark(injectedMethod, ctx.Protection);

				var desc = new InitMethodDesc { Method = injectedMethod };

				// Field name has five bytes, each bytes has different order & meaning
				int[] order = Enumerable.Range(0, 5).ToArray();
				ctx.Random.Shuffle(order);
				desc.OpCodeIndex = order[4];

				desc.TokenNameOrder = new int[4];
				Array.Copy(order, 0, desc.TokenNameOrder, 0, 4);
				desc.TokenByteOrder = Enumerable.Range(0, 4).Select(x => x * 8).ToArray();
				ctx.Random.Shuffle(desc.TokenByteOrder);

				var keyInjection = new int[9];
				Array.Copy(desc.TokenNameOrder, 0, keyInjection, 0, 4);
				Array.Copy(desc.TokenByteOrder, 0, keyInjection, 4, 4);
				keyInjection[8] = desc.OpCodeIndex;
				MutationHelper.InjectKeys(injectedMethod, Enumerable.Range(0, 9).ToArray(), keyInjection);

				// Encoding
				MutationHelper.ReplacePlaceholder(injectedMethod, arg => { return encoding.EmitDecode(injectedMethod, ctx, arg); });
				desc.Encoding = encoding;

				initDescs[index] = desc;
			}
			return initDescs[index];
		}

		public override void Finalize(RPContext ctx) {
			foreach (var field in fields) {
				InitMethodDesc init = GetInitMethod(ctx, field.Key.Item3);
				byte opKey;
				do {
					// No zero bytes
					opKey = ctx.Random.NextByte();
				} while (opKey == (byte)field.Key.Item1);

				TypeDef delegateType = field.Value.Item1.DeclaringType;

				MethodDef cctor = delegateType.FindOrCreateStaticConstructor();
				cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init.Method));
				cctor.Body.Instructions.Insert(0, Instruction.CreateLdcI4(opKey));
				cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Ldtoken, field.Value.Item1));

				fieldDescs.Add(new FieldDesc {
					Field = field.Value.Item1,
					OpCode = field.Key.Item1,
					Method = field.Key.Item2,
					OpKey = opKey,
					InitDesc = init
				});
			}

			foreach (TypeDef delegateType in ctx.Delegates.Values) {
				MethodDef cctor = delegateType.FindOrCreateStaticConstructor();
				ctx.Marker.Mark(cctor, ctx.Protection);
				ctx.Name.SetCanRename(cctor, false);
			}

			ctx.Context.CurrentModuleWriterOptions.MetadataOptions.Flags |= MetadataFlags.PreserveExtraSignatureData;
			ctx.Context.CurrentModuleWriterOptions.WriterEvent += EncodeField;
			encodeCtx = ctx;
		}

		void EncodeField(object sender, ModuleWriterEventArgs e) {
			var writer = (ModuleWriterBase)sender;
			if (e.Event == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {
				Dictionary<TypeDef, Func<int, int>> keyFuncs = keyAttrs
					.Where(entry => entry != null)
					.ToDictionary(entry => entry.Item1, entry => entry.Item2);
				foreach (FieldDesc desc in fieldDescs) {
					uint token = writer.Metadata.GetToken(desc.Method).Raw;
					uint key = encodeCtx.Random.NextUInt32() | 1;

					// CA
					CustomAttribute ca = desc.Field.CustomAttributes[0];
					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));
					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32, encodedKey));
					token *= key;

					// Encoding
					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method, encodeCtx, (int)token);

					// Field name
					var name = new char[5];
					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);

					byte[] nameKey = encodeCtx.Random.NextBytes(4);
					uint encodedNameKey = 0;
					for (int i = 0; i < 4; i++) {
						// No zero bytes
						while (nameKey[i] == 0)
							nameKey[i] = encodeCtx.Random.NextByte();
						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];
						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];
					}
					desc.Field.Name = new string(name);

					// Field sig
					FieldSig sig = desc.Field.FieldSig;
					uint encodedToken = (token - writer.Metadata.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;


					var extra = new byte[8];
					extra[0] = 0xc0;
					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);
					extra[4] = 0xc0;
					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);
					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);
					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);
					sig.ExtraData = extra;
				}
			}
		}

		class CodeGen : CILCodeGen {
			readonly Instruction[] arg;

			public CodeGen(Instruction[] arg, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.arg = arg;
			}

			protected override void LoadVar(Variable var) {
				if (var.Name == "{RESULT}") {
					foreach (Instruction instr in arg)
						Emit(instr);
				}
				else
					base.LoadVar(var);
			}
		}

		class FieldDesc {
			public FieldDef Field;
			public InitMethodDesc InitDesc;
			public IMethod Method;
			public Code OpCode;
			public byte OpKey;
		}

		class InitMethodDesc {
			public IRPEncoding Encoding;
			public MethodDef Method;
			public int OpCodeIndex;
			public int[] TokenByteOrder;
			public int[] TokenNameOrder;
		}
	}
}

```

`Confuser.Protections/ReferenceProxy/x86Encoding.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;
using MethodBody = dnlib.DotNet.Writer.MethodBody;

namespace Confuser.Protections.ReferenceProxy {
	internal class x86Encoding : IRPEncoding {
		readonly Dictionary<MethodDef, Tuple<MethodDef, Func<int, int>>> keys = new Dictionary<MethodDef, Tuple<MethodDef, Func<int, int>>>();
		readonly List<Tuple<MethodDef, byte[], MethodBody>> nativeCodes = new List<Tuple<MethodDef, byte[], MethodBody>>();
		bool addedHandler;

		public Instruction[] EmitDecode(MethodDef init, RPContext ctx, Instruction[] arg) {
			Tuple<MethodDef, Func<int, int>> key = GetKey(ctx, init);

			var repl = new List<Instruction>();
			repl.AddRange(arg);
			repl.Add(Instruction.Create(OpCodes.Call, key.Item1));
			return repl.ToArray();
		}

		public int Encode(MethodDef init, RPContext ctx, int value) {
			Tuple<MethodDef, Func<int, int>> key = GetKey(ctx, init);
			return key.Item2(value);
		}

		void Compile(RPContext ctx, out Func<int, int> expCompiled, out MethodDef native) {
			var var = new Variable("{VAR}");
			var result = new Variable("{RESULT}");

			CorLibTypeSig int32 = ctx.Module.CorLibTypes.Int32;
			native = new MethodDefUser(ctx.Context.Registry.GetService<INameService>().RandomName(), MethodSig.CreateStatic(int32, int32), MethodAttributes.PinvokeImpl | MethodAttributes.PrivateScope | MethodAttributes.Static);
			native.ImplAttributes = MethodImplAttributes.Native | MethodImplAttributes.Unmanaged | MethodImplAttributes.PreserveSig;
			ctx.Module.GlobalType.Methods.Add(native);

			ctx.Context.Registry.GetService<IMarkerService>().Mark(native, ctx.Protection);
			ctx.Context.Registry.GetService<INameService>().SetCanRename(native, false);

			x86Register? reg;
			var codeGen = new x86CodeGen();
			Expression expression, inverse;
			do {
				ctx.DynCipher.GenerateExpressionPair(
					ctx.Random,
					new VariableExpression { Variable = var }, new VariableExpression { Variable = result },
					ctx.Depth, out expression, out inverse);

				reg = codeGen.GenerateX86(inverse, (v, r) => { return new[] { x86Instruction.Create(x86OpCode.POP, new x86RegisterOperand(r)) }; });
			} while (reg == null);

			byte[] code = CodeGenUtils.AssembleCode(codeGen, reg.Value);

			expCompiled = new DMCodeGen(typeof(int), new[] { Tuple.Create("{VAR}", typeof(int)) })
				.GenerateCIL(expression)
				.Compile<Func<int, int>>();

			nativeCodes.Add(Tuple.Create(native, code, (MethodBody)null));
			if (!addedHandler) {
				ctx.Context.CurrentModuleWriterOptions.WriterEvent += InjectNativeCode;
				addedHandler = true;
			}
		}

		void InjectNativeCode(object sender, ModuleWriterEventArgs e) {
			var writer = (ModuleWriterBase)sender;
			if (e.Event == ModuleWriterEvent.MDEndWriteMethodBodies) {
				for (int n = 0; n < nativeCodes.Count; n++)
					nativeCodes[n] = new Tuple<MethodDef, byte[], MethodBody>(
						nativeCodes[n].Item1,
						nativeCodes[n].Item2,
						writer.MethodBodies.Add(new MethodBody(nativeCodes[n].Item2)));
			}
			else if (e.Event == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {
				foreach (var native in nativeCodes) {
					uint rid = writer.Metadata.GetRid(native.Item1);
          RawMethodRow methodRow = writer.Metadata.TablesHeap.MethodTable[rid];
          writer.Metadata.TablesHeap.MethodTable[rid] = new RawMethodRow(
            (uint)native.Item3.RVA,
            methodRow.ImplFlags,
            methodRow.Flags,
            methodRow.Name,
            methodRow.Signature,
            methodRow.ParamList);
				}
			}
		}

		Tuple<MethodDef, Func<int, int>> GetKey(RPContext ctx, MethodDef init) {
			Tuple<MethodDef, Func<int, int>> ret;
			if (!keys.TryGetValue(init, out ret)) {
				Func<int, int> keyFunc;
				MethodDef native;
				Compile(ctx, out keyFunc, out native);
				keys[init] = ret = Tuple.Create(native, keyFunc);
			}
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Instruction[] arg;

			public CodeGen(Instruction[] arg, MethodDef method, IList<Instruction> instrs)
				: base(method, instrs) {
				this.arg = arg;
			}

			protected override void LoadVar(Variable var) {
				if (var.Name == "{RESULT}") {
					foreach (Instruction instr in arg)
						Emit(instr);
				}
				else
					base.LoadVar(var);
			}
		}
	}
}
```

`Confuser.Protections/Resources/DynamicMode.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.DynCipher.AST;
using Confuser.DynCipher.Generation;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Resources {
	internal class DynamicMode : IEncodeMode {
		Action<uint[], uint[]> encryptFunc;

		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, REContext ctx, Local block, Local key) {
			StatementBlock encrypt, decrypt;
			ctx.DynCipher.GenerateCipherPair(ctx.Random, out encrypt, out decrypt);
			var ret = new List<Instruction>();

			var codeGen = new CodeGen(block, key, init, ret);
			codeGen.GenerateCIL(decrypt);
			codeGen.Commit(init.Body);

			var dmCodeGen = new DMCodeGen(typeof(void), new[] {
				Tuple.Create("{BUFFER}", typeof(uint[])),
				Tuple.Create("{KEY}", typeof(uint[]))
			});
			dmCodeGen.GenerateCIL(encrypt);
			encryptFunc = dmCodeGen.Compile<Action<uint[], uint[]>>();

			return ret;
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			Buffer.BlockCopy(data, offset * sizeof(uint), ret, 0, key.Length * sizeof(uint));
			encryptFunc(ret, key);
			return ret;
		}

		class CodeGen : CILCodeGen {
			readonly Local block;
			readonly Local key;

			public CodeGen(Local block, Local key, MethodDef init, IList<Instruction> instrs)
				: base(init, instrs) {
				this.block = block;
				this.key = key;
			}

			protected override Local Var(Variable var) {
				if (var.Name == "{BUFFER}")
					return block;
				if (var.Name == "{KEY}")
					return key;
				return base.Var(var);
			}
		}
	}
}
```

`Confuser.Protections/Resources/IEncodeMode.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Resources {
	internal interface IEncodeMode {
		IEnumerable<Instruction> EmitDecrypt(MethodDef init, REContext ctx, Local block, Local key);
		uint[] Encrypt(uint[] data, int offset, uint[] key);
	}
}
```

`Confuser.Protections/Resources/InjectPhase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Resources {
	internal class InjectPhase : ProtectionPhase {
		public InjectPhase(ResourceProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.Methods; }
		}

		public override string Name {
			get { return "Resource encryption helpers injection"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			if (parameters.Targets.Any()) {
				if (!UTF8String.IsNullOrEmpty(context.CurrentModule.Assembly.Culture)) {
					context.Logger.DebugFormat("Skipping resource encryption for satellite assembly '{0}'.",
					                           context.CurrentModule.Assembly.FullName);
					return;
				}
				var compression = context.Registry.GetService<ICompressionService>();
				var name = context.Registry.GetService<INameService>();
				var marker = context.Registry.GetService<IMarkerService>();
				var rt = context.Registry.GetService<IRuntimeService>();
				var moduleCtx = new REContext {
					Random = context.Registry.GetService<IRandomService>().GetRandomGenerator(Parent.Id),
					Context = context,
					Module = context.CurrentModule,
					Marker = marker,
					DynCipher = context.Registry.GetService<IDynCipherService>(),
					Name = name
				};

				// Extract parameters
				moduleCtx.Mode = parameters.GetParameter(context, context.CurrentModule, "mode", Mode.Normal);

				switch (moduleCtx.Mode) {
					case Mode.Normal:
						moduleCtx.ModeHandler = new NormalMode();
						break;
					case Mode.Dynamic:
						moduleCtx.ModeHandler = new DynamicMode();
						break;
					default:
						throw new UnreachableException();
				}

				// Inject helpers
				MethodDef decomp = compression.GetRuntimeDecompressor(context.CurrentModule, member => {
					name.MarkHelper(member, marker, (Protection)Parent);
					if (member is MethodDef)
						ProtectionParameters.GetParameters(context, member).Remove(Parent);
				});
				InjectHelpers(context, compression, rt, moduleCtx);

				// Mutate codes
				MutateInitializer(moduleCtx, decomp);

				MethodDef cctor = context.CurrentModule.GlobalType.FindStaticConstructor();
				cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, moduleCtx.InitMethod));

				new MDPhase(moduleCtx).Hook();
			}
		}

		void InjectHelpers(ConfuserContext context, ICompressionService compression, IRuntimeService rt, REContext moduleCtx) {
			var rtName = context.Packer != null ? "Confuser.Runtime.Resource_Packer" : "Confuser.Runtime.Resource";
			IEnumerable<IDnlibDef> members = InjectHelper.Inject(rt.GetRuntimeType(rtName), context.CurrentModule.GlobalType, context.CurrentModule);
			foreach (IDnlibDef member in members) {
				if (member.Name == "Initialize")
					moduleCtx.InitMethod = (MethodDef)member;
				moduleCtx.Name.MarkHelper(member, moduleCtx.Marker, (Protection)Parent);
			}

			var dataType = new TypeDefUser("", moduleCtx.Name.RandomName(), context.CurrentModule.CorLibTypes.GetTypeRef("System", "ValueType"));
			dataType.Layout = TypeAttributes.ExplicitLayout;
			dataType.Visibility = TypeAttributes.NestedPrivate;
			dataType.IsSealed = true;
			dataType.ClassLayout = new ClassLayoutUser(1, 0);
			moduleCtx.DataType = dataType;
			context.CurrentModule.GlobalType.NestedTypes.Add(dataType);
			moduleCtx.Name.MarkHelper(dataType, moduleCtx.Marker, (Protection)Parent);

			moduleCtx.DataField = new FieldDefUser(moduleCtx.Name.RandomName(), new FieldSig(dataType.ToTypeSig())) {
				IsStatic = true,
				HasFieldRVA = true,
				InitialValue = new byte[0],
				Access = FieldAttributes.CompilerControlled
			};
			context.CurrentModule.GlobalType.Fields.Add(moduleCtx.DataField);
			moduleCtx.Name.MarkHelper(moduleCtx.DataField, moduleCtx.Marker, (Protection)Parent);
		}

		void MutateInitializer(REContext moduleCtx, MethodDef decomp) {
			moduleCtx.InitMethod.Body.SimplifyMacros(moduleCtx.InitMethod.Parameters);
			List<Instruction> instrs = moduleCtx.InitMethod.Body.Instructions.ToList();
			for (int i = 0; i < instrs.Count; i++) {
				Instruction instr = instrs[i];
				var method = instr.Operand as IMethod;
				if (instr.OpCode == OpCodes.Call) {
					if (method.DeclaringType.Name == "Mutation" &&
					    method.Name == "Crypt") {
						Instruction ldBlock = instrs[i - 2];
						Instruction ldKey = instrs[i - 1];
						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);
						instrs.RemoveAt(i);
						instrs.RemoveAt(i - 1);
						instrs.RemoveAt(i - 2);
						instrs.InsertRange(i - 2, moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod, moduleCtx, (Local)ldBlock.Operand, (Local)ldKey.Operand));
					}
					else if (method.DeclaringType.Name == "Lzma" &&
					         method.Name == "Decompress") {
						instr.Operand = decomp;
					}
				}
			}
			moduleCtx.InitMethod.Body.Instructions.Clear();
			foreach (Instruction instr in instrs)
				moduleCtx.InitMethod.Body.Instructions.Add(instr);

			MutationHelper.ReplacePlaceholder(moduleCtx.InitMethod, arg => {
				var repl = new List<Instruction>();
				repl.AddRange(arg);
				repl.Add(Instruction.Create(OpCodes.Dup));
				repl.Add(Instruction.Create(OpCodes.Ldtoken, moduleCtx.DataField));
				repl.Add(Instruction.Create(OpCodes.Call, moduleCtx.Module.Import(
					typeof(RuntimeHelpers).GetMethod("InitializeArray"))));
				return repl.ToArray();
			});
			moduleCtx.Context.Registry.GetService<IConstantService>().ExcludeMethod(moduleCtx.Context, moduleCtx.InitMethod);
		}
	}
}
```

`Confuser.Protections/Resources/MDPhase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Helpers;
using Confuser.Core.Services;
using Confuser.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;

namespace Confuser.Protections.Resources {
	internal class MDPhase {
		readonly REContext ctx;
		ByteArrayChunk encryptedResource;

		public MDPhase(REContext ctx) {
			this.ctx = ctx;
		}

		public void Hook() {
			ctx.Context.CurrentModuleWriterOptions.WriterEvent += OnWriterEvent;
		}

		void OnWriterEvent(object sender, ModuleWriterEventArgs e) {
			var writer = (ModuleWriterBase)sender;
			if (e.Event == ModuleWriterEvent.MDBeginAddResources) {
				ctx.Context.CheckCancellation();
				ctx.Context.Logger.Debug("Encrypting resources...");
				bool hasPacker = ctx.Context.Packer != null;

				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();
				if (!hasPacker)
					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);

				// move resources
				string asmName = ctx.Name.RandomName(RenameMode.Letters);
				PublicKey pubKey = null;
				if (writer.TheOptions.StrongNamePublicKey != null)
					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNamePublicKey.CreatePublicKey());
				else if (writer.TheOptions.StrongNameKey != null)
					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey); 
				var assembly = new AssemblyDefUser(asmName, new Version(0, 0), pubKey);
				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));
				ModuleDef module = assembly.ManifestModule;
				assembly.ManifestModule.Kind = ModuleKind.Dll;
				var asmRef = new AssemblyRefUser(module.Assembly);
				if (!hasPacker) {
					foreach (EmbeddedResource res in resources) {
						res.Attributes = ManifestResourceAttributes.Public;
						module.Resources.Add(res);
						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name, asmRef, res.Attributes));
					}
				}
				byte[] moduleBuff;
				using (var ms = new MemoryStream()) {
					var options = new ModuleWriterOptions(module) {
						StrongNameKey = writer.TheOptions.StrongNameKey,
						StrongNamePublicKey = writer.TheOptions.StrongNamePublicKey,
						DelaySign = writer.TheOptions.DelaySign
					};
					module.Write(ms, options);
					moduleBuff = ms.ToArray();
				}

				// compress
				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(
					moduleBuff,
					progress => ctx.Context.Logger.Progress((int)(progress * 10000), 10000));
				ctx.Context.Logger.EndProgress();
				ctx.Context.CheckCancellation();

				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;
				compressedLen = (compressedLen + 0xfu) & ~0xfu;
				var compressedBuff = new uint[compressedLen];
				Buffer.BlockCopy(moduleBuff, 0, compressedBuff, 0, moduleBuff.Length);
				Debug.Assert(compressedLen % 0x10 == 0);

				// encrypt
				uint keySeed = ctx.Random.NextUInt32() | 0x10;
				var key = new uint[0x10];
				uint state = keySeed;
				for (int i = 0; i < 0x10; i++) {
					state ^= state >> 13;
					state ^= state << 25;
					state ^= state >> 27;
					key[i] = state;
				}

				var encryptedBuffer = new byte[compressedBuff.Length * 4];
				int buffIndex = 0;
				while (buffIndex < compressedBuff.Length) {
					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff, buffIndex, key);
					for (int j = 0; j < 0x10; j++)
						key[j] ^= compressedBuff[buffIndex + j];
					Buffer.BlockCopy(enc, 0, encryptedBuffer, buffIndex * 4, 0x40);
					buffIndex += 0x10;
				}
				Debug.Assert(buffIndex == compressedBuff.Length);
				var size = (uint)encryptedBuffer.Length;

				TablesHeap tblHeap = writer.Metadata.TablesHeap;

				uint classLayoutRid = writer.Metadata.GetClassLayoutRid(ctx.DataType);
				RawClassLayoutRow classLayout = tblHeap.ClassLayoutTable[classLayoutRid];
				tblHeap.ClassLayoutTable[classLayoutRid] = new RawClassLayoutRow(classLayout.PackingSize, size, classLayout.Parent);

				uint dataFieldRid = writer.Metadata.GetRid(ctx.DataField);
				RawFieldRow dataField = tblHeap.FieldTable[dataFieldRid];
				tblHeap.FieldTable[dataFieldRid] = new RawFieldRow((ushort)(dataField.Flags | (ushort)FieldAttributes.HasFieldRVA), dataField.Name, dataField.Signature);
				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer), 8);

				// inject key values
				MutationHelper.InjectKeys(ctx.InitMethod,
										  new[] { 0, 1 },
										  new[] { (int)(size / 4), (int)(keySeed) });
			}
			else if (e.Event == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {
				TablesHeap tblHeap = writer.Metadata.TablesHeap;
				uint fieldRvaRid = writer.Metadata.GetFieldRVARid(ctx.DataField);
				RawFieldRVARow fieldRva = tblHeap.FieldRVATable[fieldRvaRid];
				tblHeap.FieldRVATable[fieldRvaRid] = new RawFieldRVARow((uint)encryptedResource.RVA, fieldRva.Field);
			}
		}
	}
}

```

`Confuser.Protections/Resources/Mode.cs`:

```cs
using System;

namespace Confuser.Protections.Resources {
	internal enum Mode {
		Normal,
		Dynamic
	}
}
```

`Confuser.Protections/Resources/NormalMode.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.Resources {
	internal class NormalMode : IEncodeMode {
		public IEnumerable<Instruction> EmitDecrypt(MethodDef init, REContext ctx, Local block, Local key) {
			for (int i = 0; i < 0x10; i++) {
				yield return Instruction.Create(OpCodes.Ldloc, block);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldloc, block);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Ldloc, key);
				yield return Instruction.Create(OpCodes.Ldc_I4, i);
				yield return Instruction.Create(OpCodes.Ldelem_U4);
				yield return Instruction.Create(OpCodes.Xor);
				yield return Instruction.Create(OpCodes.Stelem_I4);
			}
		}

		public uint[] Encrypt(uint[] data, int offset, uint[] key) {
			var ret = new uint[key.Length];
			for (int i = 0; i < key.Length; i++)
				ret[i] = data[i + offset] ^ key[i];
			return ret;
		}
	}
}
```

`Confuser.Protections/Resources/REContext.cs`:

```cs
using System;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.DynCipher;
using Confuser.Renamer;
using dnlib.DotNet;

namespace Confuser.Protections.Resources {
	internal class REContext {
		public ConfuserContext Context;

		public FieldDef DataField;
		public TypeDef DataType;
		public IDynCipherService DynCipher;
		public MethodDef InitMethod;
		public IMarkerService Marker;

		public Mode Mode;

		public IEncodeMode ModeHandler;
		public ModuleDef Module;
		public INameService Name;
		public RandomGenerator Random;
	}
}
```

`Confuser.Protections/Resources/ResourceProtection.cs`:

```cs
using System;
using Confuser.Core;
using Confuser.Protections.Resources;

namespace Confuser.Protections {
	[BeforeProtection("Ki.ControlFlow"), AfterProtection("Ki.Constants")]
	internal class ResourceProtection : Protection {
		public const string _Id = "resources";
		public const string _FullId = "Ki.Resources";
		public const string _ServiceId = "Ki.Resources";

		public override string Name {
			get { return "Resources Protection"; }
		}

		public override string Description {
			get { return "This protection encodes and compresses the embedded resources."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Normal; }
		}

		protected override void Initialize(ConfuserContext context) { }

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPreStage(PipelineStage.ProcessModule, new InjectPhase(this));
		}
	}
}
```

`Confuser.Protections/TypeScrambler/AnalyzePhase.cs`:

```cs
using System;
using System.Diagnostics;
using Confuser.Core;
using Confuser.Protections.TypeScrambler.Scrambler;
using dnlib.DotNet;

namespace Confuser.Protections.TypeScrambler {
	internal sealed class AnalyzePhase : ProtectionPhase {
		public AnalyzePhase(TypeScrambleProtection parent) : base(parent) {}

		public override ProtectionTargets Targets => ProtectionTargets.Types | ProtectionTargets.Methods;

		public override string Name => "Type scanner";

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			if (context == null) throw new ArgumentNullException(nameof(context));
			if (parameters == null) throw new ArgumentNullException(nameof(parameters));

			var typeService = context.Registry.GetService<TypeService>();
			Debug.Assert(typeService != null, $"{nameof(typeService)} != null");

			foreach (var target in parameters.Targets.WithProgress(context.Logger)) {
				switch (target) {
					case TypeDef typeDef:
						typeService.AddScannedItem(new ScannedType(typeDef));
						break;
					case MethodDef methodDef:
						var scramblePublic = parameters.GetParameter(context, methodDef, "scramblePublic", false);
						typeService.AddScannedItem(new ScannedMethod(typeService, methodDef, scramblePublic));
						break;
				}
				context.CheckCancellation();
			}
		}
	}
}

```

`Confuser.Protections/TypeScrambler/ScramblePhase.cs`:

```cs
using System;
using System.Diagnostics;
using Confuser.Core;
using Confuser.Protections.TypeScrambler.Scrambler;
using dnlib.DotNet;

namespace Confuser.Protections.TypeScrambler {
	sealed class ScramblePhase : ProtectionPhase {
		public ScramblePhase(TypeScrambleProtection parent) : base(parent) { }

		public override ProtectionTargets Targets => ProtectionTargets.Types | ProtectionTargets.Methods;

		public override string Name => "Type scrambler";

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			if (context == null) throw new ArgumentNullException(nameof(context));
			if (parameters == null) throw new ArgumentNullException(nameof(parameters));

			// First check if the type scrambler did anything that needs rewriting.
			// If that is not the case, we can skip this whole thing.
			var service = context.Registry.GetService<TypeService>();
			Debug.Assert(service != null, $"{nameof(service)} != null");
			if (!service.ScrambledAnything) return;

			var rewriter = new TypeRewriter(context);
			rewriter.ApplyGenerics();

			// In this stage the references to the scrambled types need to be fixed. This needs to be done for all
			// methods in the assembly, because all methods may contain references to the scrambled types and methods.
			foreach (var def in context.CurrentModule.FindDefinitions().WithProgress(context.Logger)) {
				switch (def) {
					case MethodDef md:
						if (md.HasReturnType)
							md.ReturnType = rewriter.UpdateSignature(md.ReturnType);
						if (md.HasBody) {
							rewriter.ProcessBody(md);
						}
						break;
					case TypeDef td:
						foreach (var field in td.Fields) {
							field.FieldType = rewriter.UpdateSignature(field.FieldType);
						}
						break;
				}

				context.CheckCancellation();
			}
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Analyzers/ContextAnalyzer.cs`:

```cs
using System;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Analyzers {
	internal abstract class ContextAnalyzer {
		internal abstract Type TargetType();

		internal abstract void ProcessOperand(ScannedMethod method, Instruction instruction, object operand);
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Analyzers/ContextAnalyzerFactory.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Analyzers {
	internal sealed class ContextAnalyzerFactory : IEnumerable<ContextAnalyzer> {
		private IDictionary<Type, ContextAnalyzer> Analyzers { get; } = new Dictionary<Type, ContextAnalyzer>();
		private ScannedMethod TargetMethod { get; }
		internal ContextAnalyzerFactory(ScannedMethod method) {
			Debug.Assert(method != null, $"{nameof(method)} != null");

			TargetMethod = method;
		}

		internal void Add(ContextAnalyzer a) {
			Analyzers.Add(a.TargetType(), a);
		}

		internal void Analyze(Instruction inst) {
			Debug.Assert(inst != null, $"{nameof(inst)} != null");
			Debug.Assert(inst.Operand != null, $"{nameof(inst)}.Operand != null");

			var operand = inst.Operand;

			var currentRefType = operand.GetType();
			while (currentRefType != typeof(object)) {
				if (Analyzers.TryGetValue(currentRefType, out var analyzer)) {
					analyzer.ProcessOperand(TargetMethod, inst, operand);
					break;
				}
				currentRefType = currentRefType.BaseType;
			}
		}

		public IEnumerator<ContextAnalyzer> GetEnumerator() => Analyzers.Values.GetEnumerator();

		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Analyzers/ContextAnalyzer`1.cs`:

```cs
using System;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Analyzers {
	internal abstract class ContextAnalyzer<T> : ContextAnalyzer {
		internal override Type TargetType() => typeof(T);
		internal abstract void Process(ScannedMethod method, Instruction instruction, T operand);
		internal override void ProcessOperand(ScannedMethod method, Instruction instruction, object operand) => 
			Process(method, instruction, (T)operand);
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Analyzers/MemberRefAnalyzer.cs`:

```cs
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Analyzers {
	internal sealed class MemberRefAnalyzer : ContextAnalyzer<MemberRef> {
		internal override void Process(ScannedMethod method, Instruction instruction, MemberRef operand) {
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(instruction != null, $"{nameof(instruction)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");

			// Scrambling member references only works for constructors without parameters currently.
			if (instruction.OpCode != OpCodes.Newobj) return;
			if (operand.MethodSig.Params.Count > 0) return;

			TypeSig sig = null;
			if (operand.Class is TypeRef typeRef)
				sig = typeRef.ToTypeSig();

			if (operand.Class is TypeSpec typeSpec)
				sig = typeSpec.ToTypeSig();

			if (sig != null)
				method.RegisterGeneric(sig);
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Analyzers/MethodDefAnalyzer.cs`:

```cs
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Analyzers {
	internal sealed class MethodDefAnalyzer : ContextAnalyzer<MethodDef> {
		private TypeService Service { get; }

		internal MethodDefAnalyzer(TypeService service) {
			Debug.Assert(service != null, $"{nameof(service)} != null");

			Service = service;
		}
		internal override void Process(ScannedMethod method, Instruction instruction, MethodDef operand) {
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(instruction != null, $"{nameof(instruction)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");

			var sc = Service.GetItem(operand);
			if (sc?.IsScambled == true)
				foreach (var regTypes in sc.TrueTypes)
					method.RegisterGeneric(regTypes);
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Analyzers/MethodSpecAnalyzer.cs`:

```cs
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Analyzers {
	internal sealed class MethodSpecAnalyzer : ContextAnalyzer<MethodSpec> {
		internal override void Process(ScannedMethod method, Instruction instruction, MethodSpec operand) {
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(instruction != null, $"{nameof(instruction)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");

			foreach (var t in operand.GenericInstMethodSig.GenericArguments)
				method.RegisterGeneric(t);
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Analyzers/TypeRefAnalyzer.cs`:

```cs
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Analyzers {
	internal sealed class TypeRefAnalyzer : ContextAnalyzer<TypeRef> {
		internal override void Process(ScannedMethod method, Instruction instruction, TypeRef operand) {
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(instruction != null, $"{nameof(instruction)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");

			method.RegisterGeneric(operand.ToTypeSig());
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Rewriter/Instructions/FieldDefInstructionRewriter.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions {
	internal sealed class FieldDefInstructionRewriter : InstructionRewriter<FieldDef> {
		internal override void ProcessOperand(TypeService service, MethodDef method, IList<Instruction> body, ref int index, FieldDef operand) {
			Debug.Assert(service != null, $"{nameof(service)} != null");
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(body != null, $"{nameof(body)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");
			Debug.Assert(index >= 0, $"{nameof(index)} >= 0");
			Debug.Assert(index < body.Count, $"{nameof(index)} < {nameof(body)}.Count");

			if (method.Module.IsClr40 && body[index].OpCode != OpCodes.Ldsfld && body[index].OpCode != OpCodes.Ldsflda && body[index].OpCode != OpCodes.Stsfld) {
				return;
			}

			var declType = service.GetItem(operand.DeclaringType);
			if (declType?.IsScambled == true) {
				body[index].Operand = new MemberRefUser(operand.Module, operand.Name, operand.FieldSig,
					declType.CreateGenericTypeSig(service.GetItem(method.DeclaringType)).ToTypeDefOrRef());
			}
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Rewriter/Instructions/InstructionRewriter.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions {
	internal abstract class InstructionRewriter {
		internal abstract void ProcessInstruction(TypeService service, MethodDef method, IList<Instruction> body, ref int index, Instruction i);
		internal abstract Type TargetType();
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Rewriter/Instructions/InstructionRewriterFactory.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions {
	internal sealed class InstructionRewriterFactory : IEnumerable<InstructionRewriter> {
		private IDictionary<Type, InstructionRewriter> RewriterDefinitions { get; } 
			= new Dictionary<Type, InstructionRewriter>();

		internal void Add(InstructionRewriter i) {
			Debug.Assert(i != null, $"{nameof(i)} != null");

			RewriterDefinitions.Add(i.TargetType(), i);
		}

		internal void Process(TypeService service, MethodDef method, IList<Instruction> instructions, ref int index) {
			Debug.Assert(service != null, $"{nameof(service)} != null");
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(instructions != null, $"{nameof(instructions)} != null");
			Debug.Assert(index >= 0, $"{nameof(index)} >= 0");
			Debug.Assert(index < instructions.Count, $"{nameof(index)} < {nameof(instructions)}.Count");

			Instruction current = instructions[index];
			if (current.Operand == null) return;

			var currentRefType = current.Operand.GetType();
			while (currentRefType != typeof(object)) {
				if (RewriterDefinitions.TryGetValue(currentRefType, out var rw)) {
					rw.ProcessInstruction(service, method, instructions, ref index, current);
					break;
				}
				currentRefType = currentRefType.BaseType;
			}
		}

		public IEnumerator<InstructionRewriter> GetEnumerator() => RewriterDefinitions.Values.GetEnumerator();

		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Rewriter/Instructions/InstructionRewriter`1.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions {
	internal abstract class InstructionRewriter<T> : InstructionRewriter {
		internal override void ProcessInstruction(TypeService service, MethodDef method, IList<Instruction> body, ref int index, Instruction i) {
			ProcessOperand(service, method, body, ref index, (T)i.Operand);
		}
		internal override Type TargetType() => typeof(T);

		internal abstract void ProcessOperand(TypeService service, MethodDef method, IList<Instruction> body, ref int index, T operand);
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Rewriter/Instructions/MemberRefInstructionRewriter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions {
	internal sealed class MemberRefInstructionRewriter : InstructionRewriter<MemberRef> {
		internal override void ProcessOperand(TypeService service, MethodDef method, IList<Instruction> body, ref int index, MemberRef operand) {
			Debug.Assert(service != null, $"{nameof(service)} != null");
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(body != null, $"{nameof(body)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");
			Debug.Assert(index >= 0, $"{nameof(index)} >= 0");
			Debug.Assert(index < body.Count, $"{nameof(index)} < {nameof(body)}.Count");

			var current = service.GetItem(method);

			if (operand.MethodSig == null)
				return;

			if (operand.MethodSig.Params.Count > 0 || body[index].OpCode != OpCodes.Newobj)
				return;

			ModuleDef mod = method.Module;

			var corlibType = mod.CorLibTypes.GetTypeRef("System", "Type").ResolveThrow();
			var gettype = corlibType.FindMethod("GetTypeFromHandle");
			var createInstance = mod.CorLibTypes.GetTypeRef("System", "Activator").ResolveThrow()
				.FindMethod("CreateInstance", MethodSig.CreateStatic(mod.CorLibTypes.Object, corlibType.ToTypeSig()));

			TypeSig sig = null;

			if (operand.Class is TypeRef typeRef)
				sig = typeRef.ToTypeSig();

			if (operand.Class is TypeSpec typeSpec)
				sig = typeSpec.ToTypeSig();

			if (sig != null) {
				body[index].OpCode = OpCodes.Ldtoken;

				var gen = current?.GetGeneric(sig);
				TypeSpecUser newTypeSpec = null;
				if (gen != null) {
					newTypeSpec = new TypeSpecUser(new GenericMVar(gen.Number));
				}
				else {
					newTypeSpec = new TypeSpecUser(sig);
				}
				body[index].Operand = newTypeSpec;

				body.Insert(++index, Instruction.Create(OpCodes.Call, mod.Import(gettype)));
				body.Insert(++index, Instruction.Create(OpCodes.Call, mod.Import(createInstance)));
			}
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Rewriter/Instructions/MethodDefInstructionRewriter.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions {
	internal sealed class MethodDefInstructionRewriter : InstructionRewriter<MethodDef> {
		internal override void ProcessOperand(TypeService service, MethodDef method, IList<Instruction> body, ref int index, MethodDef operand) {
			Debug.Assert(service != null, $"{nameof(service)} != null");
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(body != null, $"{nameof(body)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");
			Debug.Assert(index >= 0, $"{nameof(index)} >= 0");
			Debug.Assert(index < body.Count, $"{nameof(index)} < {nameof(body)}.Count");

			var declType = service.GetItem(operand.DeclaringType);
			var targetMethod = service.GetItem(operand);

			if (declType?.IsScambled == true) {
				var methodD = new MemberRefUser(operand.Module, operand.Name, operand.MethodSig,
					declType.CreateGenericTypeSig(service.GetItem(method.DeclaringType)).ToTypeDefOrRef());

				if (targetMethod?.IsScambled == true) {
					var newSpec = new MethodSpecUser(methodD, targetMethod.CreateGenericMethodSig(service.GetItem(method), service));

					Debug.Assert(newSpec.GenericInstMethodSig.GenericArguments.Count == targetMethod.TargetMethod.GenericParameters.Count,
						$"{nameof(newSpec)}.GenericInstMethodSig.GenericArguments.Count == {nameof(targetMethod)}.TargetMethod.GenericParameters.Count");

					body[index].Operand = newSpec;
				}
				else
					body[index].Operand = methodD;
			}
			else if (targetMethod?.IsScambled == true) {
				var newSpec = new MethodSpecUser(targetMethod.TargetMethod, targetMethod.CreateGenericMethodSig(service.GetItem(method), service));

				Debug.Assert(newSpec.GenericInstMethodSig.GenericArguments.Count == targetMethod.TargetMethod.GenericParameters.Count,
					$"{nameof(newSpec)}.GenericInstMethodSig.GenericArguments.Count == {nameof(targetMethod)}.TargetMethod.GenericParameters.Count");

				body[index].Operand = newSpec;
			}
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Rewriter/Instructions/MethodSpecInstructionRewriter.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions {
	internal sealed class MethodSpecInstructionRewriter : InstructionRewriter<MethodSpec> {
		internal override void ProcessOperand(TypeService service, MethodDef method, IList<Instruction> body, ref int index, MethodSpec operand) {
			Debug.Assert(service != null, $"{nameof(service)} != null");
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(body != null, $"{nameof(body)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");
			Debug.Assert(index >= 0, $"{nameof(index)} >= 0");
			Debug.Assert(index < body.Count, $"{nameof(index)} < {nameof(body)}.Count");

			var current = service.GetItem(method);
			if (operand.Method is MethodDef operandDef) {
				var operandScanned = service.GetItem(operandDef);
				if (operandScanned?.IsScambled == true) {
					operand.GenericInstMethodSig = operandScanned.CreateGenericMethodSig(current, service, operand.GenericInstMethodSig);
				}
			} else if (current?.IsScambled == true) {
				var generics = operand.GenericInstMethodSig.GenericArguments.Select(x => current.ConvertToGenericIfAvalible(x));
				operand.GenericInstMethodSig = new GenericInstMethodSig(generics.ToArray());
			}
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Rewriter/Instructions/TypeDefInstructionRewriter.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions {
	internal sealed class TypeDefInstructionRewriter : InstructionRewriter<TypeDef> {
		internal override void ProcessOperand(TypeService service, MethodDef method, IList<Instruction> body, ref int index, TypeDef operand) {
			Debug.Assert(service != null, $"{nameof(service)} != null");
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(body != null, $"{nameof(body)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");
			Debug.Assert(index >= 0, $"{nameof(index)} >= 0");
			Debug.Assert(index < body.Count, $"{nameof(index)} < {nameof(body)}.Count");

			var current = service.GetItem(operand);
			if (current?.IsScambled == true)
				body[index].Operand = new TypeSpecUser(current.CreateGenericTypeSig(service.GetItem(method.DeclaringType)));
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/Rewriter/Instructions/TypeRefInstructionRewriter.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions {
	internal sealed class TypeRefInstructionRewriter : InstructionRewriter<TypeRef> {
		internal override void ProcessOperand(TypeService service, MethodDef method, IList<Instruction> body, ref int index, TypeRef operand) {
			Debug.Assert(service != null, $"{nameof(service)} != null");
			Debug.Assert(method != null, $"{nameof(method)} != null");
			Debug.Assert(body != null, $"{nameof(body)} != null");
			Debug.Assert(operand != null, $"{nameof(operand)} != null");
			Debug.Assert(index >= 0, $"{nameof(index)} >= 0");
			Debug.Assert(index < body.Count, $"{nameof(index)} < {nameof(body)}.Count");

			var current = service.GetItem(method);
			if (current?.IsScambled == true)
				body[index].Operand = new TypeSpecUser(current.ConvertToGenericIfAvalible(operand.ToTypeSig()));
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/ScannedItem.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Protections.TypeScrambler.Scrambler {
	internal abstract class ScannedItem {
		private readonly List<TypeSig> _trueTypes;

		private IDictionary<TypeSig, GenericParam> Generics { get; }
		internal IReadOnlyList<TypeSig> TrueTypes => _trueTypes;

		private ushort GenericCount { get; set; }

		internal bool IsScambled => GenericCount > 0;

		protected ScannedItem(IGenericParameterProvider genericsProvider) {
			Debug.Assert(genericsProvider != null, $"{nameof(genericsProvider)} != null");

			GenericCount = 0;
			Generics = new Dictionary<TypeSig, GenericParam>(TypeEqualityComparer.Instance);
			_trueTypes = new List<TypeSig>();
		}

		internal bool RegisterGeneric(TypeSig t) {
			Debug.Assert(t != null, $"{nameof(t)} != null");

			// This is a temporary fix.
			// Type visibility should be handled in a much better way which would involved some analysis.
			var typeDef = t.ToTypeDefOrRef().ResolveTypeDef();
			if (typeDef != null && !typeDef.IsVisibleOutside())
				return false;

			// Get proper type.
			t = SignatureUtils.GetLeaf(t);

			// scrambling voids leads to peverify errors, better leave them out.
			if (t.ElementType == ElementType.Void)
				return false;

			if (!Generics.ContainsKey(t)) {
				GenericParam newGenericParam;
				if (t.IsGenericMethodParameter) {
					var mVar = t.ToGenericMVar();
					Debug.Assert(mVar != null, $"{nameof(mVar)} != null");
					newGenericParam = new GenericParamUser(GenericCount, mVar.GenericParam.Flags, $"T{GenericCount}") {
						Rid = mVar.Rid
					};
				}
				else if (t.IsGenericTypeParameter) {
					var tVar = t.ToGenericVar();
					Debug.Assert(tVar != null, $"{nameof(tVar)} != null");
					newGenericParam = new GenericParamUser(GenericCount, tVar.GenericParam.Flags, $"T{GenericCount}") {
						Rid = tVar.Rid
					};
				}
				else {
					newGenericParam = new GenericParamUser(GenericCount, GenericParamAttributes.NoSpecialConstraint, $"T{GenericCount}");
				}
				Generics.Add(t, newGenericParam);
				GenericCount++;
				_trueTypes.Add(t);
				return true;
			}
			else {
				return false;
			}
		}

		internal GenericSig GetGeneric(TypeSig t) {
			Debug.Assert(t != null, $"{nameof(t)} != null");

			t = SignatureUtils.GetLeaf(t);

			GenericSig result = null;
			if (Generics.TryGetValue(t, out var gp))
				result = this is ScannedType ? (GenericSig)new GenericVar(gp.Number) : new GenericMVar(gp.Number);

			return result;
		}

		internal TypeSig ConvertToGenericIfAvalible(TypeSig t) {
			Debug.Assert(t != null, $"{nameof(t)} != null");

			TypeSig newSig = GetGeneric(t);
			if (newSig != null) {
				// Now it may be that the signature contains lots of modifiers and signatures.
				// We need to process those... inside out.
				newSig = SignatureUtils.CopyModifiers(t, newSig);
			}

			return newSig ?? t;
		}

		internal void PrepareGenerics() => PrepareGenerics(Generics.Values.OrderBy(gp => gp.Number));

		protected abstract void PrepareGenerics(IEnumerable<GenericParam> scrambleParams);
		internal abstract IMemberDef GetMemberDef();

		internal abstract void Scan();
		internal abstract ClassOrValueTypeSig GetTarget();
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/ScannedMethod.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Confuser.Core;
using Confuser.Protections.TypeScrambler.Scrambler.Analyzers;
using dnlib.DotNet;

namespace Confuser.Protections.TypeScrambler.Scrambler {
	internal sealed class ScannedMethod : ScannedItem {
		internal MethodDef TargetMethod { get; }

		private ContextAnalyzerFactory Analyzers { get; }

		private bool ScramblePublicMethods { get; }

		internal ScannedMethod(TypeService service, MethodDef target, bool scramblePublic) : base(target) {
			Debug.Assert(service != null, $"{nameof(service)} != null");
			Debug.Assert(target != null, $"{nameof(target)} != null");

			TargetMethod = target;
			ScramblePublicMethods = scramblePublic;

			Analyzers = new ContextAnalyzerFactory(this) {
				new MemberRefAnalyzer(),
				new TypeRefAnalyzer(),
				new MethodSpecAnalyzer(),
				new MethodDefAnalyzer(service)
			};
		}

		internal override void Scan() {
			// First we need to verify if it is actually acceptable to modify the method in any way.
			if (!CanScrambleMethod(TargetMethod, ScramblePublicMethods)) return;

			if (TargetMethod.HasBody) {
				foreach (var v in TargetMethod.Body.Variables) {
					RegisterGeneric(v.Type);
				}
			}

			if (TargetMethod.HasReturnType) {
				RegisterGeneric(TargetMethod.ReturnType);
			}
			
			foreach (var param in TargetMethod.Parameters.Where(ProcessParameter))
				RegisterGeneric(param.Type);

			if (TargetMethod.HasBody)
				foreach (var i in TargetMethod.Body.Instructions)
					if (i.Operand != null)
						Analyzers.Analyze(i);
		}

		private static bool CanScrambleMethod(MethodDef method, bool scramblePublic) {
			Debug.Assert(method != null, $"{nameof(method)} != null");

			// Unmanaged methods are very much not supported by this.
			if (!method.IsManaged) return false;

			// The entry point of the assembly must not be scrambled.
			if (method.IsEntryPoint()) return false;

			// Methods that are part of inheritance shouldn't be scrambled.
			if (method.HasOverrides || method.IsAbstract || method.IsVirtual) return false;

			// Constructors and properties will not be scrambled.
			// It may be possible for properties with some more investigation.
			if (method.IsConstructor || method.IsGetter || method.IsSetter) return false;

			// Resolving the references does not work in case the declaring type has generic paramters.
			// May be possible with some additional investigation.
			if (method.DeclaringType.HasGenericParameters) return false;

			// Skip methods with multiple overloaded signatures.
			if (method.DeclaringType.FindMethods(method.Name).Take(2).Count() > 1) return false;

			// Skip methods that are implementations of a interface.
			if (method.IsInterfaceImplementation()) return false;

			// Delegates are something we better don't scramble.
			if (method.DeclaringType.IsDelegate) return false;

			// COM imports do not like generics.
			if (method.DeclaringType.IsComImport()) return false;

			// Skip public visible methods is scrambling of public members is disabled.
			if (!scramblePublic && method.IsVisibleOutside()) return false;

			// PInvoke implementations won't work with this.
			if (method.IsPinvokeImpl) return false;

			if (method.DeclaringType.IsGlobalModuleType) return false;

			return true;
		}

		private static bool ProcessParameter(Parameter parameter) {
			Debug.Assert(parameter != null, $"{nameof(parameter)} != null");

			// Only handle normal parameters.
			// The hidden this parameter is skipped, the return parameter is handled later.
			if (!parameter.IsNormalMethodParameter) return false;

			// Skip ref and out parameters.
			if (parameter.ParamDef?.IsOut == true) return false;

			return true;
		}

		protected override void PrepareGenerics(IEnumerable<GenericParam> scrambleParams) {
			Debug.Assert(scrambleParams != null, $"{nameof(scrambleParams)} != null");
			if (!IsScambled) return;

			TargetMethod.GenericParameters.Clear();
			foreach (var generic in scrambleParams)
				TargetMethod.GenericParameters.Add(generic);

			// The generic parameter count is not updated when adding stuff to the GenericParameters.
			// So we do that by hand.
			TargetMethod.MethodSig.GenParamCount = (ushort)TargetMethod.GenericParameters.Count;

			if (TargetMethod.HasBody) {
				foreach (var v in TargetMethod.Body.Variables) {
					v.Type = ConvertToGenericIfAvalible(v.Type);
				}
			}

			foreach (var parameter in TargetMethod.Parameters.Where(ProcessParameter)) {
				parameter.Type = ConvertToGenericIfAvalible(parameter.Type);
				Debug.Assert(parameter.Type == TargetMethod.MethodSig.Params[parameter.MethodSigIndex],
					$"{nameof(parameter)}.Type == {nameof(TargetMethod)}.MethodSig.Params[{nameof(parameter)}.MethodSigIndex]");
			}

			if (TargetMethod.HasReturnType)
				TargetMethod.ReturnType = ConvertToGenericIfAvalible(TargetMethod.ReturnType);

			Debug.Assert(TargetMethod.ReturnType == TargetMethod.MethodSig.RetType,
				$"{nameof(TargetMethod)}.ReturnType == {nameof(TargetMethod)}.MethodSig.RetType");

			// The generic flag is not automatically set. So we fix it by hand.
			TargetMethod.Signature.Generic = true;

			Debug.Assert(TargetMethod.Signature.Generic, $"({nameof(TargetMethod)}.Signature.Generic");
		}

		internal GenericInstMethodSig CreateGenericMethodSig(ScannedMethod from, TypeService srv, GenericInstMethodSig original = null) {
			var types = new List<TypeSig>(TrueTypes.Count);
			foreach (var trueType in TrueTypes) {
				if (trueType.IsGenericMethodParameter) {
					Debug.Assert(original != null, $"{nameof(original)} != null");

					var number = ((GenericSig)trueType).Number;
					Debug.Assert(number < original.GenericArguments.Count,
						$"{nameof(number)} < {nameof(original)}.GenericArguments.Count");
					var originalArgument = original.GenericArguments[(int)number];
					types.Add(originalArgument);
				} else if (from?.IsScambled == true) {
					types.Add(from.ConvertToGenericIfAvalible(trueType));
				} else if (trueType.ToTypeDefOrRef() is TypeDef def) {
					// I am sure there are cleaner and better ways to do this.
					var item = srv.GetItem(def);
					types.Add(item?.IsScambled == true ? item.CreateGenericTypeSig(null) : trueType);
				} else {
					types.Add(trueType);
				}
			}
			return new GenericInstMethodSig(types);
		}

		internal override IMemberDef GetMemberDef() => TargetMethod;

		internal override ClassOrValueTypeSig GetTarget() => TargetMethod.DeclaringType.TryGetClassOrValueTypeSig();
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/ScannedType.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Protections.TypeScrambler.Scrambler {
	internal sealed class ScannedType : ScannedItem {
		internal TypeDef TargetType { get; private set; }

		public ScannedType(TypeDef target) : base(target) {
			Debug.Assert(target != null, $"{nameof(target)} != null");

			TargetType = target;
		}

		internal override void Scan() {
			if (!CanScrambleType(TargetType)) return;

			foreach (var field in TargetType.Fields)
				RegisterGeneric(field.FieldType);
		}

		private static bool CanScrambleType(TypeDef type) {
			// Enums don't work with generics.
			if (type.IsEnum) return false;

			// ComImports and PInvokes don't like generics.
			if (type.Methods.Any(x => x.IsPinvokeImpl)) return false;
			if (type.IsComImport()) return false;

			// Delegates are something that shouldn't be touched.
			if (type.IsDelegate) return false;

			// No entrypoints or global types
			if (type.Methods.Any(x => x.Module.EntryPoint == x) || type.IsGlobalModuleType) return false;

			if (type.IsValueType) return false;

			return true;
		}

		protected override void PrepareGenerics(IEnumerable<GenericParam> scrambleParams) {
			Debug.Assert(scrambleParams != null, $"{nameof(scrambleParams)} != null");
			if (!IsScambled) return;

			TargetType.GenericParameters.Clear();
			foreach (var generic in scrambleParams)
				TargetType.GenericParameters.Add(generic);

			foreach (var field in TargetType.Fields)
				field.FieldType = ConvertToGenericIfAvalible(field.FieldType);
		}

		internal GenericInstSig CreateGenericTypeSig(ScannedType from) => new GenericInstSig(GetTarget(), TrueTypes.ToList());

		internal override IMemberDef GetMemberDef() => TargetType;

		internal override ClassOrValueTypeSig GetTarget() => TargetType.ToTypeSig().ToClassOrValueTypeSig();
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/SignatureUtils.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using dnlib.DotNet;

namespace Confuser.Protections.TypeScrambler.Scrambler {
	internal static class SignatureUtils {
		internal static TypeSig GetLeaf(TypeSig t) {
			Debug.Assert(t != null, $"{nameof(t)} != null");

			while (t is NonLeafSig nonLeafSig)
				t = nonLeafSig.Next;

			return t;
		}

		internal static TypeSig CopyModifiers(TypeSig from, TypeSig to) {
			if (from is NonLeafSig current) {
				// There are additional signatures. Store all of the in a stack and process them one by one.
				var sigStack = new Stack<NonLeafSig>();
				while (current != null) {
					sigStack.Push(current);
					current = current.Next as NonLeafSig;
				}

				// Now process the entries on the stack one by one.
				while (sigStack.Any()) {
					current = sigStack.Pop();
					if (current is SZArraySig arraySig)
						to = new ArraySig(to, arraySig.Rank, arraySig.GetSizes(), arraySig.GetLowerBounds());
					else if (current is ByRefSig)
						to = new ByRefSig(to);
					else if (current is CModReqdSig cModReqdSig)
						to = new CModReqdSig(cModReqdSig.Modifier, to);
					else if (current is CModOptSig cModOptSig)
						to = new CModOptSig(cModOptSig.Modifier, to);
					else if (current is PtrSig)
						to = new PtrSig(to);
					else if (current is PinnedSig)
						to = new PinnedSig(to);
					else
						Debug.Fail("Unexpected leaf signature: " + current.GetType().FullName);
				}
			}

			return to;
		}
	}
}

```

`Confuser.Protections/TypeScrambler/Scrambler/TypeRewriter.cs`:

```cs
using System.Diagnostics;
using Confuser.Core;
using Confuser.Protections.TypeScrambler.Scrambler.Rewriter.Instructions;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Protections.TypeScrambler.Scrambler {
	internal sealed class TypeRewriter {
		private TypeService Service { get; }
		private InstructionRewriterFactory RewriteFactory { get; }

		internal TypeRewriter(ConfuserContext context) {
			Debug.Assert(context != null, $"{nameof(context)} != null");

			Service = context.Registry.GetService<TypeService>();
			Debug.Assert(Service != null, $"{nameof(Service)} != null");

			RewriteFactory = new InstructionRewriterFactory() {
				new FieldDefInstructionRewriter(),
				new MethodSpecInstructionRewriter(),
				new MethodDefInstructionRewriter(),
				new MemberRefInstructionRewriter(),
				new TypeRefInstructionRewriter(),
				new TypeDefInstructionRewriter()
			};
		}

		internal void ApplyGenerics() => Service.PrepareItems();

		internal void ProcessBody(MethodDef method) {
			Debug.Assert(method != null, $"{nameof(method)} != null");

			foreach (var local in method.Body.Variables) {
				local.Type = UpdateSignature(local.Type);
			}

			var il = method.Body.Instructions;
			for (int i = 0; i < il.Count; i++)
				RewriteFactory.Process(Service, method, il, ref i);
		}

		internal TypeSig UpdateSignature(TypeSig original) {
			var leaf = SignatureUtils.GetLeaf(original);
			if (leaf is TypeDefOrRefSig typeDefSig && typeDefSig.TypeDef != null) {
				var scannedDef = Service.GetItem(typeDefSig.TypeDef);
				if (scannedDef?.IsScambled == true) {
					TypeSig newSig = scannedDef.CreateGenericTypeSig(null);
					return SignatureUtils.CopyModifiers(original, newSig);
				}
			}

			return original;
		}
	}
}

```

`Confuser.Protections/TypeScrambler/TypeScrambleProtection.cs`:

```cs
using System;
using Confuser.Core;

namespace Confuser.Protections.TypeScrambler {
	class TypeScrambleProtection : Protection {
		public override ProtectionPreset Preset => ProtectionPreset.None;

		public override string Name => "Type Scrambler";

		public override string Description => "Replaces types with generics";

		public override string Id => "typescramble";

		public override string FullId => "BahNahNah.typescramble";

		protected override void Initialize(ConfuserContext context) {
			if (context == null) throw new ArgumentNullException(nameof(context));

			context.Registry.RegisterService(FullId, typeof(TypeService), new TypeService());
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			if (pipeline == null) throw new ArgumentNullException(nameof(pipeline));

			pipeline.InsertPreStage(PipelineStage.Inspection, new AnalyzePhase(this));
			pipeline.InsertPostStage(PipelineStage.ProcessModule, new ScramblePhase(this));
		}
	}
}

```

`Confuser.Protections/TypeScrambler/TypeService.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Protections.TypeScrambler.Scrambler;
using dnlib.DotNet;

namespace Confuser.Protections.TypeScrambler {
	internal sealed class TypeService {
		private Dictionary<IMemberDef, ScannedItem> GenericsMapper = new Dictionary<IMemberDef, ScannedItem>();

		internal bool ScrambledAnything => GenericsMapper.Any();

		internal void AddScannedItem(ScannedMethod m) => AddScannedItemGeneral(m);

		internal void AddScannedItem(ScannedType m) {
			//AddScannedItemGeneral(m);
		}

		private void AddScannedItemGeneral(ScannedItem m) {
			m.Scan();
			if (!GenericsMapper.ContainsKey(m.GetMemberDef())) {
				GenericsMapper.Add(m.GetMemberDef(), m);
			}
		}

		internal void PrepareItems() {
			foreach (var item in GenericsMapper.Values) {
				item.PrepareGenerics();
			}
		}

		private ScannedItem GetItemInternal(IMemberDef memberDef) {
			Debug.Assert(memberDef != null, $"{nameof(memberDef)} != null");

			if (GenericsMapper.TryGetValue(memberDef, out var item)) return item;
			return null;
		}

		internal ScannedMethod GetItem(MethodDef methodDef) => GetItemInternal(methodDef) as ScannedMethod;

		internal ScannedType GetItem(TypeDef typeDef) => GetItemInternal(typeDef) as ScannedType;
	}
}

```

`Confuser.Renamer/AnalyzePhase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.Renamer.Analyzers;
using dnlib.DotNet;

namespace Confuser.Renamer {
	internal class AnalyzePhase : ProtectionPhase {

		public AnalyzePhase(NameProtection parent)
			: base(parent) { }

		public override bool ProcessAll {
			get { return true; }
		}

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.AllDefinitions; }
		}

		public override string Name {
			get { return "Name analysis"; }
		}

		void ParseParameters(IDnlibDef def, ConfuserContext context, NameService service, ProtectionParameters parameters) {
			var mode = parameters.GetParameter<RenameMode?>(context, def, "mode", null);
			if (mode != null)
				service.SetRenameMode(def, mode.Value);
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			var service = (NameService)context.Registry.GetService<INameService>();

			context.Logger.Debug("Building VTables & identifier list...");

			foreach (ModuleDef moduleDef in parameters.Targets.OfType<ModuleDef>())
				moduleDef.EnableTypeDefFindCache = true;

			foreach (IDnlibDef def in parameters.Targets.WithProgress(context.Logger)) {
				ParseParameters(def, context, service, parameters);

				if (def is ModuleDef module) {
					foreach (var res in module.Resources)
						service.AddReservedIdentifier(res.Name);
				}
				else {
					service.StoreNames(def);
				}

				if (def is TypeDef typeDef) {
					service.GetVTables().GetVTable(typeDef);
				}
				context.CheckCancellation();
			}

			context.Logger.Debug("Analyzing...");
			RegisterRenamers(context, service);
			IList<IRenamer> renamers = service.Renamers;
			foreach (IDnlibDef def in parameters.Targets.WithProgress(context.Logger)) {
				Analyze(service, context, parameters, def, true);
				context.CheckCancellation();
			}

			foreach (ModuleDef moduleDef in parameters.Targets.OfType<ModuleDef>()) {
				moduleDef.EnableTypeDefFindCache = false;
				moduleDef.ResetTypeDefFindCache();
			}
		}

		void RegisterRenamers(ConfuserContext context, NameService service) {
			bool wpf = false;
			bool caliburn = false;
			bool winforms = false;
			bool json = false;
			bool visualBasic = false;
			bool vsComposition = false;

			foreach (var module in context.Modules) {
				foreach (var asmRef in module.GetAssemblyRefs()) {
					if (asmRef.Name == "WindowsBase" || asmRef.Name == "PresentationCore" ||
						asmRef.Name == "PresentationFramework" || asmRef.Name == "System.Xaml") {
						wpf = true;
					}
					else if (asmRef.Name == "Caliburn.Micro") {
						caliburn = true;
					}
					else if (asmRef.Name == "System.Windows.Forms") {
						winforms = true;
					}
					else if (asmRef.Name == "Newtonsoft.Json") {
						json = true;
					}
					else if (asmRef.Name == "Microsoft.VisualStudio.Composition") {
						vsComposition = true;
					}
				}

				var vbEmbeddedAttribute = module.FindNormal("Microsoft.VisualBasic.Embedded");
				if (vbEmbeddedAttribute != null && vbEmbeddedAttribute.BaseType.FullName.Equals("System.Attribute")) {
					visualBasic = true;
				}
			}

			if (wpf) {
				var wpfAnalyzer = new WPFAnalyzer();
				context.Logger.Debug("WPF found, enabling compatibility.");
				service.Renamers.Add(wpfAnalyzer);
				if (caliburn) {
					context.Logger.Debug("Caliburn.Micro found, enabling compatibility.");
					service.Renamers.Add(new CaliburnAnalyzer(wpfAnalyzer));
				}
			}

			if (winforms) {
				var winformsAnalyzer = new WinFormsAnalyzer();
				context.Logger.Debug("WinForms found, enabling compatibility.");
				service.Renamers.Add(winformsAnalyzer);
			}

			if (json) {
				var jsonAnalyzer = new JsonAnalyzer();
				context.Logger.Debug("Newtonsoft.Json found, enabling compatibility.");
				service.Renamers.Add(jsonAnalyzer);
			}

			if (visualBasic) {
				var vbAnalyzer = new VisualBasicRuntimeAnalyzer();
				context.Logger.Debug("Visual Basic Embedded Runtime found, enabling compatibility.");
				service.Renamers.Add(vbAnalyzer);
			}

			if (vsComposition) {
				var analyzer = new VsCompositionAnalyzer();
				context.Logger.Debug("Visual Studio Composition found, enabling compatibility.");
				service.Renamers.Add(analyzer);
			}
		}

		internal void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, IDnlibDef def, bool runAnalyzer) {
			if (def is TypeDef)
				Analyze(service, context, parameters, (TypeDef)def);
			else if (def is MethodDef)
				Analyze(service, context, parameters, (MethodDef)def);
			else if (def is FieldDef)
				Analyze(service, context, parameters, (FieldDef)def);
			else if (def is PropertyDef)
				Analyze(service, context, parameters, (PropertyDef)def);
			else if (def is EventDef)
				Analyze(service, context, parameters, (EventDef)def);
			else if (def is ModuleDef) {
				var renamingMode = parameters.GetParameter<RenameMode>(context, def, "mode");
				if (renamingMode == RenameMode.Reversible && service.reversibleRenamer == null) {
					var generatePassword = parameters.GetParameter<bool>(context, def, "generatePassword");
					var password = parameters.GetParameter<string>(context, def, "password");
					if (generatePassword || password == null) {
						password = context.Registry.GetService<IRandomService>().SeedString;
					}
					string dir = context.OutputDirectory;
					string path = Path.GetFullPath(Path.Combine(dir, CoreComponent.PasswordFileName));
					if (!Directory.Exists(dir))
						Directory.CreateDirectory(dir);
					File.WriteAllText(path, password);
					service.reversibleRenamer = new ReversibleRenamer(password);
				}

				service.SetCanRename(def, false);
			}

			if (!runAnalyzer || parameters.GetParameter(context, def, "forceRen", false))
				return;

			foreach (IRenamer renamer in service.Renamers)
				renamer.Analyze(context, service, parameters, def);
		}

		static bool IsVisibleOutside(ConfuserContext context, ProtectionParameters parameters, IMemberDef def) {
			var type = def as TypeDef;
			if (type == null)
				type = def.DeclaringType;

			var renPublic = parameters.GetParameter<bool?>(context, def, "renPublic", null);
			if (renPublic == null)
				return type.IsVisibleOutside();
			else
				return type.IsVisibleOutside(false) && !renPublic.Value;
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, TypeDef type) {
			if (IsVisibleOutside(context, parameters, type)) {
				service.SetCanRename(type, false);
			}
			else if (type.IsRuntimeSpecialName || type.IsGlobalModuleType) {
				service.SetCanRename(type, false);
			}

			if (parameters.GetParameter(context, type, "forceRen", false))
				return;

			if (type.InheritsFromCorlib("System.Attribute")) {
				service.ReduceRenameMode(type, RenameMode.Reflection);
			}

			if (type.InheritsFrom("System.Configuration.SettingsBase")) {
				service.SetCanRename(type, false);
			}
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, MethodDef method) {
			if (IsVisibleOutside(context, parameters, method.DeclaringType) &&
				(method.IsFamily || method.IsFamilyOrAssembly || method.IsPublic) &&
				IsVisibleOutside(context, parameters, method))
				service.SetCanRename(method, false);

			else if (method.IsRuntimeSpecialName)
				service.SetCanRename(method, false);

			else if (method.IsExplicitlyImplementedInterfaceMember())
				service.SetCanRename(method, false);

			else if (parameters.GetParameter(context, method, "forceRen", false))
				return;

			else if (method.DeclaringType.IsComImport() && !method.HasAttribute("System.Runtime.InteropServices.DispIdAttribute"))
				service.SetCanRename(method, false);

			else if (method.DeclaringType.IsDelegate())
				service.SetCanRename(method, false);
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, FieldDef field) {
			if (IsVisibleOutside(context, parameters, field.DeclaringType) &&
				(field.IsFamily || field.IsFamilyOrAssembly || field.IsPublic) &&
				IsVisibleOutside(context, parameters, field))
				service.SetCanRename(field, false);

			else if (field.IsRuntimeSpecialName)
				service.SetCanRename(field, false);

			else if (parameters.GetParameter(context, field, "forceRen", false))
				return;

			else if (field.DeclaringType.IsSerializable && !field.IsNotSerialized)
				service.SetCanRename(field, false);

			else if (field.IsLiteral && field.DeclaringType.IsEnum &&
				!parameters.GetParameter(context, field, "renEnum", false))
				service.SetCanRename(field, false);
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, PropertyDef property) {
			if (IsVisibleOutside(context, parameters, property.DeclaringType) &&
			    (property.IsFamily() || property.IsFamilyOrAssembly() || property.IsPublic()) &&
				IsVisibleOutside(context, parameters, property))
				service.SetCanRename(property, false);

			else if (property.IsRuntimeSpecialName)
				service.SetCanRename(property, false);

			else if (parameters.GetParameter(context, property, "forceRen", false))
				return;

			else if (property.DeclaringType.Implements("System.ComponentModel.INotifyPropertyChanged"))
				service.SetCanRename(property, false);

			else if (property.DeclaringType.Name.String.Contains("AnonymousType"))
				service.SetCanRename(property, false);
		}

		void Analyze(NameService service, ConfuserContext context, ProtectionParameters parameters, EventDef evt) {
			if (IsVisibleOutside(context, parameters, evt.DeclaringType) &&
			    (evt.IsFamily() || evt.IsFamilyOrAssembly() || evt.IsPublic()) &&
				IsVisibleOutside(context, parameters, evt))
				service.SetCanRename(evt, false);

			else if (evt.IsRuntimeSpecialName)
				service.SetCanRename(evt, false);
		}
	}
}

```

`Confuser.Renamer/Analyzers/CaliburnAnalyzer.cs`:

```cs
using System;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.Analyzers {
	internal class CaliburnAnalyzer : IRenamer {
		public CaliburnAnalyzer(WPFAnalyzer wpfAnalyzer) {
			wpfAnalyzer.AnalyzeBAMLElement += AnalyzeBAMLElement;
		}

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var type = def as TypeDef;
			if (type == null || type.DeclaringType != null)
				return;
			if (type.Name.Contains("ViewModel")) {
				string viewNs = type.Namespace.Replace("ViewModels", "Views");
				string viewName = type.Name.Replace("PageViewModel", "Page").Replace("ViewModel", "View");
				TypeDef view = type.Module.Find(viewNs + "." + viewName, true);
				if (view != null) {
					service.SetCanRename(type, false);
					service.SetCanRename(view, false);
				}

				// Test for Multi-view
				string multiViewNs = type.Namespace + "." + type.Name.Replace("ViewModel", "");
				foreach (var t in type.Module.Types)
					if (t.Namespace == multiViewNs) {
						service.SetCanRename(type, false);
						service.SetCanRename(t, false);
					}
			}
		}

		void AnalyzeBAMLElement(BAMLAnalyzer analyzer, BamlElement elem) {
			foreach (var rec in elem.Body) {
				var prop = rec as PropertyWithConverterRecord;
				if (prop == null)
					continue;

				var attr = analyzer.ResolveAttribute(prop.AttributeId);
				string attrName = null;
				if (attr.Item2 != null)
					attrName = attr.Item2.Name;
				else if (attr.Item1 != null)
					attrName = attr.Item1.Name;

				if (attrName == "Attach")
					AnalyzeMessageAttach(analyzer, attr, prop.Value);

				if (attrName == "Name")
					AnalyzeAutoBind(analyzer, attr, prop.Value);

				if (attrName == "MethodName")
					AnalyzeActionMessage(analyzer, attr, prop.Value);
			}
		}

		void AnalyzeMessageAttach(BAMLAnalyzer analyzer, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> attr, string value) {
			if (attr.Item2 == null)
				return;
			var attrDeclType = analyzer.ResolveType(attr.Item2.OwnerTypeId);
			if (attrDeclType.FullName != "Caliburn.Micro.Message")
				return;

			foreach (var msg in value.Split(';')) {
				string msgStr;
				if (msg.Contains("=")) {
					msgStr = msg.Split('=')[1].Trim('[', ']', ' ');
				}
				else {
					msgStr = msg.Trim('[', ']', ' ');
				}
				if (msgStr.StartsWith("Action"))
					msgStr = msgStr.Substring(6);
				int parenIndex = msgStr.IndexOf('(');
				if (parenIndex != -1)
					msgStr = msgStr.Substring(0, parenIndex);

				string actName = msgStr.Trim();
				foreach (var method in analyzer.LookupMethod(actName))
					analyzer.NameService.SetCanRename(method, false);
			}
		}

		void AnalyzeAutoBind(BAMLAnalyzer analyzer, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> attr, string value) {
			if (!(attr.Item1 is PropertyDef) || ((PropertyDef)attr.Item1).DeclaringType.FullName != "System.Windows.FrameworkElement")
				return;

			foreach (var method in analyzer.LookupMethod(value))
				analyzer.NameService.SetCanRename(method, false);
			foreach (var method in analyzer.LookupProperty(value))
				analyzer.NameService.SetCanRename(method, false);
		}

		void AnalyzeActionMessage(BAMLAnalyzer analyzer, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> attr, string value) {
			if (attr.Item2 == null)
				return;
			var attrDeclType = analyzer.ResolveType(attr.Item2.OwnerTypeId);
			if (attrDeclType.FullName != "Caliburn.Micro.ActionMessage")
				return;

			foreach (var method in analyzer.LookupMethod(value))
				analyzer.NameService.SetCanRename(method, false);
		}


		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}
```

`Confuser.Renamer/Analyzers/CallSiteAnalyzer.cs`:

```cs
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.Renamer.References;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.Analyzers {
	internal sealed class CallSiteAnalyzer : IRenamer {
		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (!(def is MethodDef method) || !method.HasBody)
				return;

			var logger = context.Logger;

			var traceService = context.Registry.GetService<ITraceService>();
			MethodTrace methodTrace = null;

			var instructions = method.Body.Instructions;
			foreach (var instruction in instructions) {
				if (!IsCreateCallSiteInstruction(instruction)) continue;

				if (methodTrace is null)
					methodTrace = traceService.Trace(method);

				// CallSite`1.Create(CallSiteBinder)
				int[] createArguments = methodTrace.TraceArguments(instruction);
				if (createArguments.Length != 1) continue;

				// Binder.InvokeMember(CSharpBinderFlags, string, IEnumerable<Type>, Type, IEnumerable<CSharpArgumentInfo>)
				var binderInstruction = instructions[createArguments[0]];
				if (IsBinderInvokeMember(binderInstruction)) {
					HandleBinderInvokeMember(context, method, methodTrace, binderInstruction);
				}
			}
		}

		private static void HandleBinderInvokeMember(ConfuserContext context, MethodDef method, MethodTrace methodTrace, Instruction instruction) {
			var instructions = method.Body.Instructions;

			int[] binderArguments = methodTrace.TraceArguments(instruction);
			if (binderArguments.Length != 5) return;

			var nameInstruction = instructions[binderArguments[1]];
			var contextInstruction = instructions[binderArguments[3]];

			// Name instruction is expected to contain a string constant - This is the name of the invoked member
			if (nameInstruction.OpCode.Code != Code.Ldstr) return;
			string boundMemberName = nameInstruction.Operand as string;

			var ldContextTokenInstruction = contextInstruction;
			if (IsGetTypeFromHandle(contextInstruction)) {
				int[] getTypeFromHandleArguments = methodTrace.TraceArguments(contextInstruction);
				if (getTypeFromHandleArguments.Length == 1)
					ldContextTokenInstruction = instructions[getTypeFromHandleArguments[0]];
			}

			if (ldContextTokenInstruction.OpCode.Code == Code.Ldtoken &&
				ldContextTokenInstruction.Operand is ITypeDefOrRef typeDefOrRef) {
				// We found the load token of the context parameter. This means we know the type the member is called for.
				BuildMemberReferences(context, typeDefOrRef, boundMemberName, nameInstruction);
			}
			else {
				context.Logger.WarnFormat(
					"Failed to resolve type for dynamic invoke member in {0} - blocking all members with name {1} from renaming.",
					method, boundMemberName);

				// The type referenced is unknown. To be safe, all methods matching the name need to be blocked from renaming.
				DisableRenamingForMethods(context, boundMemberName);
			}
		}

		static void DisableRenamingForMethods(ConfuserContext context, string methodName) {
			var service = context.Registry.GetService<INameService>();

			var candidateMethods = context.Modules
				.SelectMany(m => m.FindDefinitions())
				.OfType<MethodDef>()
				.Where(m => m.Name.Equals(methodName));
			foreach (var candidateMethod in candidateMethods)
				service.SetCanRename(candidateMethod, false);
		}

		static void BuildMemberReferences(ConfuserContext context, ITypeDefOrRef typeDefOrRef, string boundMemberName,
			Instruction nameInstruction) {
			var service = context.Registry.GetService<INameService>();

			var boundMemberTypeDef = typeDefOrRef.ResolveTypeDef();
			if (boundMemberTypeDef is null) return;

			var currentType = boundMemberTypeDef;
			while (currentType != null) {
				foreach (var refMethod in currentType.FindMethods(boundMemberName)) {
					service.AddReference(refMethod,
						new StringMemberNameReference(nameInstruction, refMethod));
					service.ReduceRenameMode(refMethod, RenameMode.Reflection);
				}

				currentType = currentType.BaseType.ResolveTypeDef();
			}
		}

		private static bool IsCreateCallSiteInstruction(Instruction instruction) {
			if (instruction.OpCode.Code != Code.Call) return false;
			if (!(instruction.Operand is IMethodDefOrRef method)) return false;

			return method.DeclaringType.Namespace.Equals("System.Runtime.CompilerServices") &&
				   method.DeclaringType.Name.Equals("CallSite`1") &&
				   method.Name.Equals("Create");
		}

		private static bool IsBinderInvokeMember(Instruction instruction) {
			if (instruction.OpCode.Code != Code.Call) return false;
			if (!(instruction.Operand is IMethodDefOrRef method)) return false;

			return method.DeclaringType.Namespace.Equals("Microsoft.CSharp.RuntimeBinder") &&
				   method.DeclaringType.Name.Equals("Binder") &&
				   method.Name.Equals("InvokeMember");
		}

		private static bool IsGetTypeFromHandle(Instruction instruction) {
			if (instruction.OpCode.Code != Code.Call) return false;
			if (!(instruction.Operand is IMethodDefOrRef method)) return false;

			return method.DeclaringType.Namespace.Equals("System") &&
				   method.DeclaringType.Name.Equals("Type") &&
				   method.Name.Equals("GetTypeFromHandle");
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) { }

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) { }
	}
}

```

`Confuser.Renamer/Analyzers/InterReferenceAnalyzer.cs`:

```cs
using System;
using System.Linq;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;
using dnlib.DotNet.MD;

namespace Confuser.Renamer.Analyzers {
	internal class InterReferenceAnalyzer : IRenamer {
		// i.e. Inter-Assembly References, e.g. InternalVisibleToAttributes

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var module = def as ModuleDefMD;
			if (module == null) return;

			// MemberRef/MethodSpec
			var methods = module.GetTypes().SelectMany(type => type.Methods);
			foreach(var methodDef in methods) {
				foreach (var ov in methodDef.Overrides) {
					ProcessMemberRef(context, service, module, ov.MethodBody);
					ProcessMemberRef(context, service, module, ov.MethodDeclaration);
				}

				if (!methodDef.HasBody)
					continue;
				foreach (var instr in methodDef.Body.Instructions) {
					if (instr.Operand is MemberRef || instr.Operand is MethodSpec)
						ProcessMemberRef(context, service, module, (IMemberRef)instr.Operand);
				}
			}

			// TypeRef
			var table = module.TablesStream.Get(Table.TypeRef);
			uint len = table.Rows;
			for (uint i = 1; i <= len; i++) {
				TypeRef typeRef = module.ResolveTypeRef(i);

				TypeDef typeDef = typeRef.ResolveTypeDefThrow();
				if (typeDef.Module != module && context.Modules.Contains((ModuleDefMD)typeDef.Module)) {
					service.AddReference(typeDef, new TypeRefReference(typeRef, typeDef));
				}
			}
		}

		void ProcessMemberRef(ConfuserContext context, INameService service, ModuleDefMD module, IMemberRef r) {
			var memberRef = r as MemberRef;
			if (r is MethodSpec)
				memberRef = ((MethodSpec)r).Method as MemberRef;

			if (memberRef != null) {
				if (memberRef.DeclaringType.TryGetArraySig() != null)
					return;

				TypeDef declType = memberRef.DeclaringType.ResolveTypeDefThrow();
				if (declType.Module != module && context.Modules.Contains((ModuleDefMD)declType.Module)) {
					var memberDef = (IMemberDef)declType.ResolveThrow(memberRef);
					service.AddReference(memberDef, new MemberRefReference(memberRef, memberDef));
				}
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}

```

`Confuser.Renamer/Analyzers/JsonAnalyzer.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.Analyzers {
	internal class JsonAnalyzer : IRenamer {
		public JsonAnalyzer() {
		}

		const string JsonProperty = "Newtonsoft.Json.JsonPropertyAttribute";
		const string JsonIgnore = "Newtonsoft.Json.JsonIgnoreAttribute";
		const string JsonObject = "Newtonsoft.Json.JsonObjectAttribute";
		static readonly HashSet<string> JsonContainers = new HashSet<string> {
			"Newtonsoft.Json.JsonArrayAttribute",
			"Newtonsoft.Json.JsonContainerAttribute",
			"Newtonsoft.Json.JsonDictionaryAttribute",
			"Newtonsoft.Json.JsonObjectAttribute"
		};

		static CustomAttribute GetJsonContainerAttribute(IHasCustomAttribute attrs) {
			foreach (var attr in attrs.CustomAttributes) {
				if (JsonContainers.Contains(attr.TypeFullName))
					return attr;
			}
			return null;
		}

		static bool ShouldExclude(TypeDef type, IDnlibDef def) {
			CustomAttribute attr;

			if (def.CustomAttributes.IsDefined(JsonProperty)) {
				attr = def.CustomAttributes.Find(JsonProperty);
				if (attr.HasConstructorArguments || attr.GetProperty("PropertyName") != null)
					return false;
			}

			attr = GetJsonContainerAttribute(type);
			if (attr == null || attr.TypeFullName != JsonObject)
				return false;

			if (def.CustomAttributes.IsDefined(JsonIgnore))
				return false;

			int serialization = 0;
			if (attr.HasConstructorArguments && attr.ConstructorArguments[0].Type.FullName == "Newtonsoft.Json.MemberSerialization")
				serialization = (int)attr.ConstructorArguments[0].Value;
			else {
				foreach (var property in attr.Properties) {
					if (property.Name == "MemberSerialization")
						serialization = (int)property.Value;
				}
			}

			if (serialization == 0) { // OptOut
				return (def is PropertyDef && ((PropertyDef)def).IsPublic()) ||
					(def is FieldDef && ((FieldDef)def).IsPublic);
			}
			else if (serialization == 1) // OptIn
				return false;
			else if (serialization == 2) // Fields
				return def is FieldDef;
			else  // Unknown
				return false;
		}

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (def is TypeDef)
				Analyze(context, service, (TypeDef)def, parameters);
			else if (def is MethodDef)
				Analyze(context, service, (MethodDef)def, parameters);
			else if (def is PropertyDef)
				Analyze(context, service, (PropertyDef)def, parameters);
			else if (def is FieldDef)
				Analyze(context, service, (FieldDef)def, parameters);
		}

		void Analyze(ConfuserContext context, INameService service, TypeDef type, ProtectionParameters parameters) {
			var attr = GetJsonContainerAttribute(type);
			if (attr == null)
				return;

			bool hasId = false;
			if (attr.HasConstructorArguments && attr.ConstructorArguments[0].Type.FullName == "System.String")
				hasId = true;
			else {
				foreach (var property in attr.Properties) {
					if (property.Name == "Id")
						hasId = true;
				}
			}
			if (!hasId)
				service.SetCanRename(type, false);
		}

		void Analyze(ConfuserContext context, INameService service, MethodDef method, ProtectionParameters parameters) {
			if (GetJsonContainerAttribute(method.DeclaringType) != null && method.IsConstructor) {
				service.SetParam(method, "renameArgs", "false");
			}
		}

		void Analyze(ConfuserContext context, INameService service, PropertyDef property, ProtectionParameters parameters) {
			if (ShouldExclude(property.DeclaringType, property)) {
				service.SetCanRename(property, false);
			}
		}

		void Analyze(ConfuserContext context, INameService service, FieldDef field, ProtectionParameters parameters) {
			if (ShouldExclude(field.DeclaringType, field)) {
				service.SetCanRename(field, false);
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}
```

`Confuser.Renamer/Analyzers/LdtokenEnumAnalyzer.cs`:

```cs
using System;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.Analyzers {
	internal class LdtokenEnumAnalyzer : IRenamer {
		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var method = def as MethodDef;
			if (method == null || !method.HasBody)
				return;

			// When a ldtoken instruction reference a definition,
			// most likely it would be used in reflection and thus probably should not be renamed.
			// Also, when ToString is invoked on enum,
			// the enum should not be renamed.
			for (int i = 0; i < method.Body.Instructions.Count; i++) {
				Instruction instr = method.Body.Instructions[i];
				if (instr.OpCode.Code == Code.Ldtoken) {
					if (instr.Operand is MemberRef) {
						IMemberForwarded member = ((MemberRef)instr.Operand).ResolveThrow();
						if (context.Modules.Contains((ModuleDefMD)member.Module))
							service.SetCanRename(member, false);
					}
					else if (instr.Operand is IField) {
						FieldDef field = ((IField)instr.Operand).ResolveThrow();
						if (context.Modules.Contains((ModuleDefMD)field.Module))
							service.SetCanRename(field, false);
					}
					else if (instr.Operand is IMethod) {
						var im = (IMethod)instr.Operand;
						if (!im.IsArrayAccessors()) {
							MethodDef m = im.ResolveThrow();
							if (context.Modules.Contains((ModuleDefMD)m.Module))
								service.SetCanRename(method, false);
						}
					}
					else if (instr.Operand is ITypeDefOrRef) {
						if (!(instr.Operand is TypeSpec)) {
							TypeDef type = ((ITypeDefOrRef)instr.Operand).ResolveTypeDefThrow();
							if (context.Modules.Contains((ModuleDefMD)type.Module) &&
							    HandleTypeOf(context, service, method, i)) {
								var t = type;
								do {
									DisableRename(service, t, false);
									t = t.DeclaringType;
								} while (t != null);
							}
						}
					}
					else
						throw new UnreachableException();
				}
				else if ((instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) &&
				         ((IMethod)instr.Operand).Name == "ToString") {
					HandleEnum(context, service, method, i);
				}
				else if (instr.OpCode.Code == Code.Ldstr) {
					TypeDef typeDef = method.Module.FindReflection((string)instr.Operand);
					if (typeDef != null)
						service.AddReference(typeDef, new StringTypeReference(instr, typeDef));
				}
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		void HandleEnum(ConfuserContext context, INameService service, MethodDef method, int index) {
			var target = (IMethod)method.Body.Instructions[index].Operand;
			if (target.FullName == "System.String System.Object::ToString()" ||
			    target.FullName == "System.String System.Enum::ToString(System.String)") {
				int prevIndex = index - 1;
				while (prevIndex >= 0 && method.Body.Instructions[prevIndex].OpCode.Code == Code.Nop)
					prevIndex--;

				if (prevIndex < 0)
					return;

				Instruction prevInstr = method.Body.Instructions[prevIndex];
				TypeSig targetType;

				if (prevInstr.Operand is MemberRef) {
					var memberRef = (MemberRef)prevInstr.Operand;
					targetType = memberRef.IsFieldRef ? memberRef.FieldSig.Type : memberRef.MethodSig.RetType;
				}
				else if (prevInstr.Operand is IField)
					targetType = ((IField)prevInstr.Operand).FieldSig.Type;

				else if (prevInstr.Operand is IMethod)
					targetType = ((IMethod)prevInstr.Operand).MethodSig.RetType;

				else if (prevInstr.Operand is ITypeDefOrRef)
					targetType = ((ITypeDefOrRef)prevInstr.Operand).ToTypeSig();

				else if (prevInstr.GetParameter(method.Parameters) != null)
					targetType = prevInstr.GetParameter(method.Parameters).Type;

				else if (prevInstr.GetLocal(method.Body.Variables) != null)
					targetType = prevInstr.GetLocal(method.Body.Variables).Type;

				else
					return;

				ITypeDefOrRef targetTypeRef = targetType.ToBasicTypeDefOrRef();
				if (targetTypeRef == null)
					return;

				TypeDef targetTypeDef = targetTypeRef.ResolveTypeDefThrow();
				if (targetTypeDef != null && targetTypeDef.IsEnum && context.Modules.Contains((ModuleDefMD)targetTypeDef.Module))
					DisableRename(service, targetTypeDef);
			}
		}

		bool HandleTypeOf(ConfuserContext context, INameService service, MethodDef method, int index) {
			if (index + 1 >= method.Body.Instructions.Count)
				return true;

			var gtfh = method.Body.Instructions[index + 1].Operand as IMethod;
			if (gtfh == null || gtfh.FullName != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")
				return true;

			if (index + 2 < method.Body.Instructions.Count) {
				Instruction instr = method.Body.Instructions[index + 2];
				var operand = instr.Operand as IMethod;
				if (instr.OpCode == OpCodes.Newobj && operand.FullName == "System.Void System.ComponentModel.ComponentResourceManager::.ctor(System.Type)")
					return false;
				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {
					switch (operand.DeclaringType.FullName) {
						case "System.Runtime.InteropServices.Marshal":
							return false;
						case "System.Type":
							if (operand.Name.StartsWith("Get") || operand.Name == "InvokeMember")
								return true;
							if (operand.Name == "get_AssemblyQualifiedName" ||
							    operand.Name == "get_FullName" ||
							    operand.Name == "get_Namespace")
								return true;
							return false;
						case "System.Reflection.MemberInfo":
							return operand.Name == "get_Name";
						case "System.Object":
							return operand.Name == "ToString";
					}
				}
			}
			if (index + 3 < method.Body.Instructions.Count) {
				Instruction instr = method.Body.Instructions[index + 3];
				var operand = instr.Operand as IMethod;
				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {
					switch (operand.DeclaringType.FullName) {
						case "System.Runtime.InteropServices.Marshal":
							return false;
					}
				}
			}

			return false;
		}

		void DisableRename(INameService service, TypeDef typeDef, bool memberOnly = true) {
			service.SetCanRename(typeDef, false);

			foreach (MethodDef m in typeDef.Methods)
				service.SetCanRename(m, false);

			foreach (FieldDef field in typeDef.Fields)
				service.SetCanRename(field, false);

			foreach (PropertyDef prop in typeDef.Properties)
				service.SetCanRename(prop, false);

			foreach (EventDef evt in typeDef.Events)
				service.SetCanRename(evt, false);

			foreach (TypeDef nested in typeDef.NestedTypes)
				DisableRename(service, nested, false);
		}
	}
}
```

`Confuser.Renamer/Analyzers/ManifestResourceAnalyzer.cs`:

```cs
using System;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.Analyzers {
	public sealed class ManifestResourceAnalyzer : IRenamer {
		/// <inheritdoc />
		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) { }

		/// <inheritdoc />
		void IRenamer.PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (!(def is MethodDef methodDef) || !methodDef.HasBody || !methodDef.Body.HasInstructions) return;

			var trace = context.Registry.GetService<ITraceService>();
			PreRename(context.CurrentModule, trace, methodDef);
		}

		public static void PreRename(ModuleDef currentModule, ITraceService trace, MethodDef methodDef) {
			var instructions = methodDef.Body.Instructions;
			var methodTrace = new Lazy<MethodTrace>(() => trace.Trace(methodDef));
			for (var i = 0; i < instructions.Count; i++) {
				var instruction = instructions[i];
				if (instruction.OpCode != OpCodes.Callvirt ||
				    !(instruction.Operand is IMethodDefOrRef targetMethodDefOrRef) ||
				    !UTF8String.Equals(targetMethodDefOrRef.Name, "GetManifestResourceStream") ||
				    !UTF8String.Equals(targetMethodDefOrRef.DeclaringType.FullName, "System.Reflection.Assembly")) continue;

				var targetMethodDef = targetMethodDefOrRef.ResolveMethodDefThrow();
				if (targetMethodDef.Parameters.Count != 3) continue;

				var argumentIdx = methodTrace.Value.TraceArguments(instruction);
				if (argumentIdx.Length != 3) continue;

				var typeLoadInstruction = instructions[argumentIdx[1]];
				var resNameInstruction = instructions[argumentIdx[2]];

				if (typeLoadInstruction.OpCode != OpCodes.Call ||
				    !(typeLoadInstruction.Operand is IMethodDefOrRef loadTypeMethodRef) ||
				    !UTF8String.Equals(loadTypeMethodRef.Name, "GetTypeFromHandle") ||
				    !UTF8String.Equals(loadTypeMethodRef.DeclaringType.FullName, "System.Type")) continue;
				if (resNameInstruction.OpCode != OpCodes.Ldstr ||
				    !(resNameInstruction.Operand is string resName)) continue;

				var typeLoadArguments = methodTrace.Value.TraceArguments(typeLoadInstruction);
				if (typeLoadArguments.Length != 1) continue;

				var typeTokenLoadInstruction = instructions[typeLoadArguments[0]];
				if (typeTokenLoadInstruction.OpCode != OpCodes.Ldtoken ||
				    !(typeTokenLoadInstruction.Operand is ITypeDefOrRef refTypeDefOrRef)) continue;

				var resourceName = refTypeDefOrRef.Namespace + '.' + resName;

				var getManifestMethodDef = targetMethodDefOrRef.ResolveMethodDefThrow();
				var assemblyTypeDef = getManifestMethodDef.DeclaringType;
				var expectedSig = MethodSig.CreateInstance(getManifestMethodDef.MethodSig.RetType, getManifestMethodDef.MethodSig.Params.Last());
				var newMethodDef = assemblyTypeDef.FindMethod("GetManifestResourceStream", expectedSig);
				var newMethodRef = currentModule.Import(newMethodDef);
				
				resNameInstruction.Operand = resourceName;
				instruction.Operand = newMethodRef;

				instructions.RemoveAt(argumentIdx[1]);
				instructions.RemoveAt(typeLoadArguments[0]);
			}
		}

		/// <inheritdoc />
		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) { }
	}
}

```

`Confuser.Renamer/Analyzers/ReflectionAnalyzer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.Renamer.Properties;
using Confuser.Renamer.References;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using ILogger = Confuser.Core.ILogger;

namespace Confuser.Renamer.Analyzers {
	/// <summary>
	/// This analyzer is looking for calls to the reflection API and blocks methods from being renamed if required.
	/// </summary>
	public sealed class ReflectionAnalyzer : IRenamer {
		void IRenamer.Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (!(def is MethodDef method) || !method.HasBody) return;

			Analyze(service, context.Registry.GetService<ITraceService>(), context.Modules.Cast<ModuleDef>().ToArray(), context.Logger, method);
		}

		public void Analyze(INameService nameService, ITraceService traceService, IReadOnlyList<ModuleDef> moduleDefs, ILogger logger, MethodDef method) {
			if (!method.HasBody) return;

			MethodTrace methodTrace = null;
			MethodTrace GetMethodTrace() {
				if (methodTrace == null)
					methodTrace = traceService.Trace(method);
				return methodTrace;
			}

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Call && instr.Operand is IMethodDefOrRef calledMethod) {
					if (calledMethod.DeclaringType.FullName == "System.Type") {
						Func<TypeDef, IEnumerable<IMemberDef>> getMember = null;
						if (calledMethod.Name == nameof(Type.GetMethod))
							getMember = t => t.Methods;
						else if (calledMethod.Name == nameof(Type.GetField))
							getMember = t => t.Fields;
						else if (calledMethod.Name == nameof(Type.GetProperty))
							getMember = t => t.Properties;
						else if (calledMethod.Name == nameof(Type.GetEvent))
							getMember = t => t.Events;
						else if (calledMethod.Name == nameof(Type.GetMember))
							getMember = t => Enumerable.Empty<IMemberDef>().Concat(t.Methods).Concat(t.Fields).Concat(t.Properties).Concat(t.Events);

						if (getMember != null) {
							var trace = GetMethodTrace();
							var arguments = trace.TraceArguments(instr);
							if (arguments == null) {
								logger.WarnFormat(Resources.ReflectionAnalyzer_Analyze_TracingArgumentsFailed, calledMethod.FullName, method.FullName);
							} 
							else if (arguments.Length >= 2) {
								var types = GetReferencedTypes(method.Body.Instructions[arguments[0]], method, trace);
								var names = GetReferencedNames(method.Body.Instructions[arguments[1]]);

								if (!types.Any())
									types = moduleDefs.SelectMany(m => m.GetTypes()).ToArray();

								foreach (var possibleMember in types.SelectMany(GetTypeAndBaseTypes).SelectMany(getMember).Where(m => names.Contains(m.Name))) {
									nameService.SetCanRename(possibleMember, false);
									if (!(possibleMember is IMethod) && !(possibleMember is PropertyDef) && !(possibleMember is EventDef)) continue;
									
									foreach (var reference in nameService.GetReferences(possibleMember).OfType<MemberOverrideReference>()) {
										nameService.SetCanRename(reference.BaseMemberDef, false);
									}
								}
							}
						}
					}
				}
			}
		}

		private static IEnumerable<TypeDef> GetTypeAndBaseTypes(TypeDef typeDef) {
			var currentType = typeDef;
			while (currentType != null) {
				yield return currentType;
				currentType = currentType.BaseType.ResolveTypeDef();
			}
		}

		/// <summary>
		/// This method is used to determine the types that are load onto the stack at the referenced instruction.
		/// In case the method is unable to determine all the types reliable, it will return a empty list.
		/// </summary>
		private static IReadOnlyList<TypeDef> GetReferencedTypes(Instruction instruction, MethodDef method, MethodTrace trace) {
			if (instruction.OpCode.Code == Code.Call && instruction.Operand is IMethodDefOrRef calledMethod) {
				if (calledMethod.DeclaringType.FullName == "System.Type" && calledMethod.Name == "GetTypeFromHandle") {
					var arguments = trace.TraceArguments(instruction);
					if (arguments.Length == 1) {
						var ldTokenInstr = method.Body.Instructions[arguments[0]];
						if (ldTokenInstr.OpCode.Code == Code.Ldtoken && ldTokenInstr.Operand is TypeDef refTypeDef) {
							return new List<TypeDef>() { refTypeDef };
						}
					}
				}
			}

			return new List<TypeDef>();
		}

		private static IReadOnlyList<UTF8String> GetReferencedNames(Instruction instruction) {
			if (instruction.OpCode.Code == Code.Ldstr && instruction.Operand is string str) {
				return new List<UTF8String>() { str };
			}

			return new List<UTF8String>();
		}

		void IRenamer.PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) { }

		void IRenamer.PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) { }
	}
}

```

`Confuser.Renamer/Analyzers/ResourceAnalyzer.cs`:

```cs
using System;
using System.Linq;
using System.Text.RegularExpressions;
using Confuser.Core;
using Confuser.Renamer.Properties;
using Confuser.Renamer.References;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.Analyzers {
	internal class ResourceAnalyzer : IRenamer {
		static readonly Regex ResourceNamePattern = new Regex("^(.*)\\.resources$");

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var module = def as ModuleDef;
			if (module == null) return;

			string asmName = module.Assembly.Name.String;
			if (!string.IsNullOrEmpty(module.Assembly.Culture) &&
				asmName.EndsWith(".resources")) {
				// Satellite assembly
				string satellitePattern = $"^(.*)\\.(?i:({module.Assembly.Culture}))\\.resources$";
				string nameAsmName = asmName.Substring(0, asmName.Length - ".resources".Length);
				ModuleDef mainModule = context.Modules.SingleOrDefault(mod => mod.Assembly.Name == nameAsmName);
				if (mainModule == null) {
					context.Logger.ErrorFormat("Could not find main assembly of satellite assembly '{0}'.", module.Assembly.FullName);
					throw new ConfuserException(null);
				}

				foreach (Resource res in module.Resources) {
					Match match = Regex.Match(res.Name, satellitePattern);
					if (!match.Success) continue;
					string typeName = match.Groups[1].Value;
					string culture = match.Groups[2].Value;

					TypeDef type = mainModule.FindReflection(typeName);
					if (type == null) {
						context.Logger.WarnFormat(Resources.ResourceAnalyzer_Analyze_CouldNotFindResourceType, typeName);
						continue;
					}
					string format = $"{{0}}.{culture}.resources";

					service.ReduceRenameMode(type, RenameMode.Reflection);
					service.AddReference(type, new ResourceReference(res, type, format));
				}
			}
			else {
				string format = "{0}.resources";
				foreach (Resource res in module.Resources) {
					Match match = ResourceNamePattern.Match(res.Name);
					if (!match.Success || res.ResourceType != ResourceType.Embedded)
						continue;
					string typeName = match.Groups[1].Value;

					if (typeName.EndsWith(".g")) // WPF resources, ignore
						continue;

					// This variable is set true in case the name of the resource doesn't match the name of the class.
					// That happens for the resources in Visual Basic.
					var mismatchingName = false;
					TypeDef type = module.FindReflection(typeName);
					if (type == null) {
						if (typeName.EndsWith(".Resources")) {
							typeName = typeName.Substring(0, typeName.Length - 10) + ".My.Resources.Resources";
							type = module.FindReflection(typeName);
							mismatchingName = type != null;
						}
					}

					if (type == null) {
						context.Logger.WarnFormat(Resources.ResourceAnalyzer_Analyze_CouldNotFindResourceType, typeName);
						continue;
					}
					service.ReduceRenameMode(type, RenameMode.Reflection);
					service.AddReference(type, new ResourceReference(res, type, format));

					if (mismatchingName)
						// Add string type references in case the name didn't match. This will cause the resource to get
						// the same name as the class, despite that not being the case before. But that doesn't really matter.
						FindLdTokenResourceReferences(type, match.Groups[1].Value, service);
				}
			}
		}

		private static void FindLdTokenResourceReferences(TypeDef type, string name, INameService service) {
			foreach (var method in type.Methods)
				FindLdTokenResourceReferences(type, method, name, service);
		}

		private static void FindLdTokenResourceReferences(TypeDef type, MethodDef method, string name, INameService service) {
			if (!method.HasBody) return;

			foreach (var instr in method.Body.Instructions) {
				if (instr.OpCode.Code == Code.Ldstr && ((string)instr.Operand).Equals(name)) {
					service.AddReference(type, new StringTypeReference(instr, type));
				}
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}

```

`Confuser.Renamer/Analyzers/TypeBlobAnalyzer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;

namespace Confuser.Renamer.Analyzers {
	public sealed class TypeBlobAnalyzer : IRenamer {
		void IRenamer.Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (!(def is ModuleDefMD moduleDef)) return;

			Analyze(service, context.Modules, context.Logger, moduleDef);
		}

		public static void Analyze(INameService service, ICollection<ModuleDefMD> modules, Core.ILogger logger, ModuleDefMD module) {
			// MemberRef
			var table = module.TablesStream.Get(Table.Method);
			var len = table.Rows;
			IEnumerable<MethodDef> methods = module.GetTypes().SelectMany(type => type.Methods);
			foreach (MethodDef method in methods) {
				foreach (MethodOverride methodImpl in method.Overrides) {
					if (methodImpl.MethodBody is MemberRef)
						AnalyzeMemberRef(modules, service, (MemberRef)methodImpl.MethodBody);
					if (methodImpl.MethodDeclaration is MemberRef)
						AnalyzeMemberRef(modules, service, (MemberRef)methodImpl.MethodDeclaration);
				}
				if (!method.HasBody)
					continue;
				foreach (Instruction instr in method.Body.Instructions) {
					if (instr.Operand is MemberRef)
						AnalyzeMemberRef(modules, service, (MemberRef)instr.Operand);
					else if (instr.Operand is MethodSpec) {
						var spec = (MethodSpec)instr.Operand;
						if (spec.Method is MemberRef)
							AnalyzeMemberRef(modules, service, (MemberRef)spec.Method);
					}
				}
			}


			// CustomAttribute
			table = module.TablesStream.Get(Table.CustomAttribute);
			len = table.Rows;
			var attrs = Enumerable.Range(1, (int)len)
				.Select(rid => {
					if (module.TablesStream.TryReadCustomAttributeRow((uint)rid, out var row)) {
						return module.ResolveHasCustomAttribute(row.Parent);
					}
					return null;
				})
				.Where(a => a != null)
				.Distinct()
				.SelectMany(owner => owner.CustomAttributes);
			foreach (CustomAttribute attr in attrs) {
				if (attr.Constructor is MemberRef)
					AnalyzeMemberRef(modules, service, (MemberRef)attr.Constructor);

				foreach (CAArgument arg in attr.ConstructorArguments)
					AnalyzeCAArgument(modules, service, arg);

				foreach (CANamedArgument arg in attr.Fields)
					AnalyzeCAArgument(modules, service, arg.Argument);

				foreach (CANamedArgument arg in attr.Properties)
					AnalyzeCAArgument(modules, service, arg.Argument);

				TypeDef attrType = attr.AttributeType.ResolveTypeDefThrow();
				if (!modules.Contains((ModuleDefMD)attrType.Module))
					continue;

				foreach (var arg in attr.NamedArguments) {
					var memberDef = FindArgumentMemberDef(arg, attrType);
					if (memberDef == null)
						logger.WarnFormat(
							arg.IsField ? "Failed to resolve CA field '{0}::{1} : {2}'." : "Failed to resolve CA property '{0}::{1} : {2}'.",
							attrType, arg.Name, arg.Type);
					else
						service.AddReference(memberDef, new CAMemberReference(arg, memberDef));
				}
			}
		}

		private static IMemberDef FindArgumentMemberDef(CANamedArgument arg, TypeDef attrType) {
			if (arg.IsField)
				return FindArgumentMemberDef(arg.Name, new FieldSig(arg.Type), attrType);

			if (arg.IsProperty)
				return FindArgumentMemberDef(arg.Name, new PropertySig(true, arg.Type), attrType);

			throw new UnreachableException();
		}

		private static IMemberDef FindArgumentMemberDef(UTF8String name, FieldSig fieldSig, TypeDef attrType) {
			while (attrType != null) {
				var field = attrType.FindField(name, fieldSig);

				if (field != null) return field;
				attrType = attrType.DeclaringType;
			}

			return null;
		}

		private static IMemberDef FindArgumentMemberDef(UTF8String name, CallingConventionSig propertySig, TypeDef attrType) {
			while (attrType != null) {
				var property = attrType.FindProperty(name, propertySig);

				if (property != null) return property;
				attrType = attrType.BaseType.ResolveTypeDef();
			}

			return null;
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		private static void AnalyzeCAArgument(ICollection<ModuleDefMD> modules, INameService service, CAArgument arg) {
			if (arg.Value == null) return; // null was passed to the custom attribute. We'll ignore that.

			if (arg.Type.DefinitionAssembly.IsCorLib() && arg.Type.FullName == "System.Type") {
				var typeSig = (TypeSig)arg.Value;
				foreach (ITypeDefOrRef typeRef in typeSig.FindTypeRefs()) {
					TypeDef typeDef = typeRef.ResolveTypeDefThrow();
					if (modules.Contains((ModuleDefMD)typeDef.Module)) {
						if (typeRef is TypeRef)
							service.AddReference(typeDef, new TypeRefReference((TypeRef)typeRef, typeDef));
						service.ReduceRenameMode(typeDef, RenameMode.Reflection);
					}
				}
			}
			else if (arg.Value is CAArgument[]) {
				foreach (CAArgument elem in (CAArgument[])arg.Value)
					AnalyzeCAArgument(modules, service, elem);
			}
		}

		private static void AnalyzeMemberRef(ICollection<ModuleDefMD> modules, INameService service, MemberRef memberRef) {
			ITypeDefOrRef declType = memberRef.DeclaringType;
			var typeSpec = declType as TypeSpec;
			if (typeSpec == null || typeSpec.TypeSig.IsArray || typeSpec.TypeSig.IsSZArray)
				return;

			TypeSig sig = typeSpec.TypeSig;
			while (sig.Next != null)
				sig = sig.Next;


			Debug.Assert(sig is TypeDefOrRefSig || sig is GenericInstSig || sig is GenericSig);
			if (sig is GenericInstSig) {
				var inst = (GenericInstSig)sig;
				Debug.Assert(!(inst.GenericType.TypeDefOrRef is TypeSpec));
				TypeDef openType = inst.GenericType.TypeDefOrRef.ResolveTypeDefThrow();
				if (!modules.Contains((ModuleDefMD)openType.Module) ||
					memberRef.IsArrayAccessors())
					return;

				IMemberDef member;
				if (memberRef.IsFieldRef) member = memberRef.ResolveFieldThrow();
				else if (memberRef.IsMethodRef) member = memberRef.ResolveMethodThrow();
				else throw new UnreachableException();

				service.AddReference(member, new MemberRefReference(memberRef, member));
			}
		}
	}
}

```

`Confuser.Renamer/Analyzers/VTableAnalyzer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;

namespace Confuser.Renamer.Analyzers {
	public class VTableAnalyzer : IRenamer {
		void IRenamer.Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			switch (def) {
				case TypeDef typeDef:
					Analyze(service, context.Modules, typeDef);
					break;
				case MethodDef methodDef:
					Analyze(service, context.Modules, methodDef);
					break;
			}
		}

		public static void Analyze(INameService service, ICollection<ModuleDefMD> modules, TypeDef type) {
			if (type.IsInterface)
				return;

			var vTbl = service.GetVTables()[type];
			foreach (var ifaceVTbl in vTbl.InterfaceSlots.Values) {
				foreach (var slot in ifaceVTbl) {
					if (slot.Overrides == null)
						continue;
					Debug.Assert(slot.Overrides.MethodDef.DeclaringType.IsInterface);
					// A method in base type can implements an interface method for a
					// derived type. If the base type/interface is not in our control, we should
					// not rename the methods.
					bool baseUnderCtrl = modules.Contains(slot.MethodDef.DeclaringType.Module as ModuleDefMD);
					bool interfaceUnderCtrl = modules.Contains(slot.Overrides.MethodDef.DeclaringType.Module as ModuleDefMD);
					if (!baseUnderCtrl && interfaceUnderCtrl || !service.CanRename(slot.MethodDef)) {
						service.SetCanRename(slot.Overrides.MethodDef, false);
					}
					else if ((baseUnderCtrl && !interfaceUnderCtrl) || (!service.CanRename(slot.Overrides.MethodDef))) {
						service.SetCanRename(slot.MethodDef, false);
					}

					// Now it is possible that the method implementing the interface, belongs to the base class.
					// If that happens the methods analyzing the methods will not pick up on this. We'll mark that
					// case here.
					if (!TypeEqualityComparer.Instance.Equals(slot.MethodDef.DeclaringType, type)) {
						SetupOverwriteReferences(service, modules, slot, type);

						// If required, create the sibling references, so the names of the interfaces line up correctly.
						var existingReferences = service.GetReferences(slot.MethodDef);
						var overrideDef = existingReferences
							.OfType<MemberOverrideReference>()
							.FirstOrDefault(r => !MethodEqualityComparer.CompareDeclaringTypes.Equals(r.BaseMemberDef as MethodDef, slot.Overrides.MethodDef));

						if (!(overrideDef is null)) {
							var baseMemberDef = overrideDef.BaseMemberDef;
							CreateSiblingReference(slot.Overrides.MethodDef, ref baseMemberDef, service);
						}
					}

					// For the case when method in base type implements an interface method for a derived type
					// do not consider method parameters to make method name the same in base type, derived type and interface
					var methodDef = slot.MethodDef;
					var typeDef = type.BaseType?.ResolveTypeDef();
					var baseMethod = typeDef?.FindMethod(methodDef.Name, methodDef.Signature as MethodSig);
					if (baseMethod != null) {
						string unifiedName = service.GetNormalizedName(slot.Overrides.MethodDef);
						service.SetNormalizedName(slot.MethodDef, unifiedName);
						service.SetNormalizedName(baseMethod, unifiedName);
					}
				}
			}
		}

		public static void Analyze(INameService service, ICollection<ModuleDefMD> modules, MethodDef method) {
			if (!method.IsVirtual)
				return;

			IMemberDef discoveredBaseMemberDef = null;
			MethodDef discoveredBaseMethodDef = null;

			bool doesOverridePropertyOrEvent = false;
			var methodProp = method.DeclaringType.Properties.Where(p => BelongsToProperty(p, method));
			foreach (var prop in methodProp) {
				foreach (var baseMethodDef in FindBaseDeclarations(service, method)) {
					var basePropDef = baseMethodDef.DeclaringType.Properties.
						FirstOrDefault(p => BelongsToProperty(p, baseMethodDef) && String.Equals(p.Name, prop.Name, StringComparison.Ordinal));

					if (basePropDef is null) continue;

					// Name of property has to line up.
					CreateOverrideReference(service, prop, basePropDef);
					CreateSiblingReference(basePropDef, ref discoveredBaseMemberDef, service);

					// Method names have to line up as well (otherwise inheriting attributes does not work).
					CreateOverrideReference(service, method, baseMethodDef);
					CreateSiblingReference(baseMethodDef, ref discoveredBaseMethodDef, service);

					doesOverridePropertyOrEvent = true;
				}
			}

			discoveredBaseMemberDef = null;
			discoveredBaseMethodDef = null;

			var methodEvent = method.DeclaringType.Events.Where(e => BelongsToEvent(e, method));
			foreach (var evt in methodEvent) {
				foreach (var baseMethodDef in FindBaseDeclarations(service, method)) {
					var baseEventDef = baseMethodDef.DeclaringType.Events.
						FirstOrDefault(e => BelongsToEvent(e, baseMethodDef) && String.Equals(e.Name, evt.Name, StringComparison.Ordinal));

					if (baseEventDef is null) continue;

					// Name of event has to line up.
					CreateOverrideReference(service, evt, baseEventDef);
					CreateSiblingReference(baseEventDef, ref discoveredBaseMemberDef, service);

					// Method names have to line up as well (otherwise inheriting attributes does not work).
					CreateOverrideReference(service, method, baseMethodDef);
					CreateSiblingReference(baseMethodDef, ref discoveredBaseMethodDef, service);

					doesOverridePropertyOrEvent = true;
				}
			}

			if (!method.IsAbstract) {
				var vTbl = service.GetVTables()[method.DeclaringType];
				var slots = vTbl.FindSlots(method).ToArray();

				foreach (var slot in slots) {
					if (slot.Overrides == null)
						continue;

					SetupOverwriteReferences(service, modules, slot, method.DeclaringType);
				}
			}
			else if (!doesOverridePropertyOrEvent) {
				foreach (var baseMethodDef in FindBaseDeclarations(service, method)) {
					CreateOverrideReference(service, method, baseMethodDef);
				}
			}
		}

		static void CreateSiblingReference<T>(T baseMemberDef, ref T discoveredBaseMemberDef, INameService service) where T : class, IMemberDef {
			if (discoveredBaseMemberDef is null)
				discoveredBaseMemberDef = baseMemberDef;
			else {
				var references = service.GetReferences(discoveredBaseMemberDef)
					.OfType<MemberSiblingReference>()
					.ToArray();
				if (references.Length > 0) {
					discoveredBaseMemberDef = (T)references[0].OldestSiblingDef;
					foreach (var siblingRef in references.Skip(1)) {
						// Redirect all the siblings to the new oldest reference
						RedirectSiblingReferences(siblingRef.OldestSiblingDef, discoveredBaseMemberDef, service);
					}
				}

				// Check if the discovered base type is the current type. If so, nothing needs to be done.
				if (ReferenceEquals(baseMemberDef, discoveredBaseMemberDef)) return;

				var reference = new MemberSiblingReference(baseMemberDef, discoveredBaseMemberDef);
				service.AddReference(baseMemberDef, reference);
				service.AddReference(discoveredBaseMemberDef, reference);
				UpdateOldestSiblingReference(discoveredBaseMemberDef, baseMemberDef, service);
			}
		}

		static void UpdateOldestSiblingReference(IMemberDef oldestSiblingMemberDef, IMemberDef basePropDef, INameService service) {
			var reverseReference = service.GetReferences(oldestSiblingMemberDef).OfType<MemberOldestSiblingReference>()
				.SingleOrDefault();
			if (reverseReference is null) {
				service.AddReference(oldestSiblingMemberDef, new MemberOldestSiblingReference(oldestSiblingMemberDef, basePropDef));
				PropagateRenamingRestrictions(service, oldestSiblingMemberDef, basePropDef);
			}
			else if (!reverseReference.OtherSiblings.Contains(basePropDef)) {
				reverseReference.OtherSiblings.Add(basePropDef);
				PropagateRenamingRestrictions(service, reverseReference.OtherSiblings);
			}
		}

		static void RedirectSiblingReferences(IMemberDef oldMemberDef, IMemberDef newMemberDef, INameService service) {
			if (ReferenceEquals(oldMemberDef, newMemberDef)) return;

			var referencesToUpdate = service.GetReferences(oldMemberDef)
				.OfType<MemberOldestSiblingReference>()
				.SelectMany(r => r.OtherSiblings)
				.SelectMany(service.GetReferences)
				.OfType<MemberSiblingReference>()
				.Where(r => ReferenceEquals(r.OldestSiblingDef, oldMemberDef));

			foreach (var reference in referencesToUpdate) {
				reference.OldestSiblingDef = newMemberDef;
				UpdateOldestSiblingReference(newMemberDef, reference.ThisMemberDef, service);
			}
			UpdateOldestSiblingReference(newMemberDef, oldMemberDef, service);
		}

		static void CreateOverrideReference(INameService service, IMemberDef thisMemberDef, IMemberDef baseMemberDef) {
			var overrideRef = new MemberOverrideReference(thisMemberDef, baseMemberDef);
			service.AddReference(thisMemberDef, overrideRef);
			service.AddReference(baseMemberDef, overrideRef);

			PropagateRenamingRestrictions(service, thisMemberDef, baseMemberDef);
		}

		static void PropagateRenamingRestrictions(INameService service, params object[] objects) =>
			PropagateRenamingRestrictions(service, (IList<object>)objects);

		static void PropagateRenamingRestrictions(INameService service, IList<object> objects) {
			if (!objects.All(service.CanRename)) {
				foreach (var o in objects) {
					service.SetCanRename(o, false);
				}
			}
			else {
				var minimalRenamingLevel = objects.Max(service.GetRenameMode);
				foreach (var o in objects) {
					service.ReduceRenameMode(o, minimalRenamingLevel);
				}
			}
		}

		private static IEnumerable<MethodDef> FindBaseDeclarations(INameService service, MethodDef method) {
			var unprocessed = new Queue<MethodDef>();
			unprocessed.Enqueue(method);

			var vTables = service.GetVTables();

			while (unprocessed.Any()) {
				var currentMethod = unprocessed.Dequeue();

				var vTbl = vTables[currentMethod.DeclaringType];
				var slots = vTbl.FindSlots(currentMethod).Where(s => s.Overrides != null);

				bool slotsExists = false;
				foreach (var slot in slots) {
					unprocessed.Enqueue(slot.Overrides.MethodDef);
					slotsExists = true;
				}

				if (!slotsExists && method != currentMethod)
					yield return currentMethod;
			}
		}

		private static bool BelongsToProperty(PropertyDef propertyDef, MethodDef methodDef) =>
			propertyDef.GetMethods.Contains(methodDef) || propertyDef.SetMethods.Contains(methodDef) ||
			(propertyDef.HasOtherMethods && propertyDef.OtherMethods.Contains(methodDef));

		private static bool BelongsToEvent(EventDef eventDef, MethodDef methodDef) =>
			Equals(eventDef.AddMethod, methodDef) || Equals(eventDef.RemoveMethod, methodDef) || Equals(eventDef.InvokeMethod, methodDef) ||
			(eventDef.HasOtherMethods && eventDef.OtherMethods.Contains(methodDef));

		private static void AddImportReference(INameService service, ICollection<ModuleDefMD> modules, ModuleDef module, MethodDef method, MemberRef methodRef) {
			if (method.Module != module && modules.Contains((ModuleDefMD)module)) {
				var declType = (TypeRef)methodRef.DeclaringType.ScopeType;
				service.AddReference(method.DeclaringType, new TypeRefReference(declType, method.DeclaringType));
				service.AddReference(method, new MemberRefReference(methodRef, method));

				var typeRefs = methodRef.MethodSig.Params.SelectMany(param => param.FindTypeRefs()).ToList();
				typeRefs.AddRange(methodRef.MethodSig.RetType.FindTypeRefs());
				typeRefs.AddRange(methodRef.DeclaringType.ToTypeSig().FindTypeRefs());
				foreach (var typeRef in typeRefs) {
					SetupTypeReference(service, modules, module, typeRef);
				}
			}
		}

		private static void SetupTypeReference(INameService service, ICollection<ModuleDefMD> modules, ModuleDef module, ITypeDefOrRef typeDefOrRef) {
			if (!(typeDefOrRef is TypeRef typeRef)) return;

			var def = typeRef.ResolveTypeDef();
			if (!(def is null) && def.Module != module && modules.Contains((ModuleDefMD)def.Module))
				service.AddReference(def, new TypeRefReference(typeRef, def));
		}

		private static void SetupSignatureReferences(INameService service, ICollection<ModuleDefMD> modules,
			ModuleDef module, GenericInstSig typeSig) {
			SetupSignatureReferences(service, modules, module, typeSig.GenericType);
			foreach (var genericArgument in typeSig.GenericArguments)
				SetupSignatureReferences(service, modules, module, genericArgument);
		}

		private static void SetupSignatureReferences(INameService service, ICollection<ModuleDefMD> modules, ModuleDef module, TypeSig typeSig) {
			var asTypeRef = typeSig.TryGetTypeRef();
			if (asTypeRef != null) {
				SetupTypeReference(service, modules, module, asTypeRef);
			}
		}

		private static void SetupOverwriteReferences(INameService service, ICollection<ModuleDefMD> modules, VTableSlot slot, TypeDef thisType) {
			var module = thisType.Module;
			var methodDef = slot.MethodDef;
			var baseSlot = slot.Overrides;
			var baseMethodDef = baseSlot.MethodDef;

			var overrideRef = new OverrideDirectiveReference(slot, baseSlot);
			service.AddReference(methodDef, overrideRef);
			service.AddReference(slot.Overrides.MethodDef, overrideRef);

			var importer = new Importer(module, ImporterOptions.TryToUseTypeDefs);

			IMethodDefOrRef target;
			if (baseSlot.MethodDefDeclType is GenericInstSig declType) {
				MemberRef targetRef = new MemberRefUser(module, baseMethodDef.Name, baseMethodDef.MethodSig, declType.ToTypeDefOrRef());
				targetRef = importer.Import(targetRef);
				service.AddReference(baseMethodDef, new MemberRefReference(targetRef, baseMethodDef));
				SetupSignatureReferences(service, modules, module, targetRef.DeclaringType.ToTypeSig() as GenericInstSig);

				target = targetRef;
			}
			else {
				target = baseMethodDef;
				if (target.Module != module) {
					target = (IMethodDefOrRef)importer.Import(baseMethodDef);
					if (target is MemberRef memberRef)
						service.AddReference(baseMethodDef, new MemberRefReference(memberRef, baseMethodDef));
				}
			}

			if (target is MemberRef methodRef)
				AddImportReference(service, modules, module, baseMethodDef, methodRef);

			if (TypeEqualityComparer.Instance.Equals(methodDef.DeclaringType, thisType)) {
				if (methodDef.Overrides.Any(impl => IsMatchingOverride(impl, target)))
					return;

				methodDef.Overrides.Add(new MethodOverride(methodDef, target));
			}
			else if (target is IMemberDef targetDef) {
				// Reaching this place means that a slot of the base type is overwritten by a specific interface.
				// In case the this type is implementing the interface responsible for this, we need to declare
				// this as an override reference. If the base type is implementing the interface (as well), this
				// declaration is redundant.
				var overrideRefRequired = true;
				if (targetDef.DeclaringType.IsInterface) {
					var baseTypeDef = thisType.BaseType?.ResolveTypeDef();
					if (!(baseTypeDef is null)) {
						var baseTypeVTable = service.GetVTables()[baseTypeDef];
						if (baseTypeVTable.InterfaceSlots.TryGetValue(targetDef.DeclaringType.ToTypeSig(), out var ifcSlots)) {
							overrideRefRequired = !ifcSlots.Contains(slot);
						}
					}
				}
				if (overrideRefRequired)
					CreateOverrideReference(service, methodDef, targetDef);
			}
		}

		private static bool IsMatchingOverride(MethodOverride methodOverride, IMethodDefOrRef targetMethod) {
			SigComparer comparer = default;

			var targetDeclTypeDef = targetMethod.DeclaringType.ResolveTypeDef();
			var overrideDeclTypeDef = methodOverride.MethodDeclaration.DeclaringType.ResolveTypeDef();
			if (!comparer.Equals(targetDeclTypeDef, overrideDeclTypeDef))
				return false;

			var targetMethodSig = targetMethod.MethodSig;
			var overrideMethodSig = methodOverride.MethodDeclaration.MethodSig;

			targetMethodSig = ResolveGenericSignature(targetMethod, targetMethodSig);
			overrideMethodSig = ResolveGenericSignature(methodOverride.MethodDeclaration, overrideMethodSig);

			return comparer.Equals(targetMethodSig, overrideMethodSig);
		}

		static MethodSig ResolveGenericSignature(IMemberRef method, MethodSig overrideMethodSig) {
			if (method.DeclaringType is TypeSpec spec && spec.TypeSig is GenericInstSig genericInstSig) {
				overrideMethodSig = GenericArgumentResolver.Resolve(overrideMethodSig, genericInstSig.GenericArguments);
			}

			return overrideMethodSig;
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var method = def as MethodDef;
			if (method == null || !method.IsVirtual || method.Overrides.Count == 0)
				return;

			method.Overrides
				  .RemoveWhere(impl => MethodEqualityComparer.CompareDeclaringTypes.Equals(impl.MethodDeclaration, method));
		}
	}
}

```

`Confuser.Renamer/Analyzers/VisualBasicRuntimeAnalyzer.cs`:

```cs
using System;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.Analyzers {
	internal sealed class VisualBasicRuntimeAnalyzer : IRenamer {
		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var typeDef = (def as TypeDef);
			if (typeDef != null) {
				AnalyzeType(context, service, parameters, typeDef);
			}
		}

		private static void AnalyzeType(ConfuserContext context, INameService service, ProtectionParameters parameters, TypeDef def) {
			if (IsEmbeddedAttribute(def) &&
				def.BaseType != null &&
				def.BaseType.FullName.Equals("System.Attribute", StringComparison.Ordinal)) {
				service.SetCanRename(def, false);
			} else if (def.HasCustomAttributes && def.CustomAttributes.Any(a => IsEmbeddedAttribute(a.AttributeType))) {
				service.SetCanRename(def, false);
			}
		}

		private static bool IsEmbeddedAttribute(ITypeDefOrRef defOrRef) {
			if (defOrRef.FullName.Equals("Microsoft.VisualBasic.Embedded", StringComparison.Ordinal)) {
				var typeDef = (defOrRef as TypeDef);
				if (typeDef != null) {
					return typeDef.IsNotPublic && 
						typeDef.BaseType != null && 
						typeDef.BaseType.FullName.Equals("System.Attribute", StringComparison.Ordinal);
				}
			}
			return false;
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
		}
	}
}

```

`Confuser.Renamer/Analyzers/VsCompositionAnalyzer.cs`:

```cs
using System;
using System.Linq;
using Confuser.Core;
using Confuser.Renamer.References;
using dnlib.DotNet;

namespace Confuser.Renamer.Analyzers {
	internal sealed class VsCompositionAnalyzer : IRenamer {
		/// <inheritdoc />
		void IRenamer.Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (!(def is TypeDef typeDef)) return;

			Analyze(context, service, typeDef);
		}

		public static void Analyze(ConfuserContext context, INameService service, TypeDef typeDef) {
			if (typeDef.InheritsFrom("System.ComponentModel.Composition.ExportAttribute")) {
				// This type is an export attribute. In case it implements interfaces, these interfaces may be used as Metadata.
				// If that is the case, the implementation of the meta data handling requires that the getter methods
				// of the properties are starting their name with "get_".
				// Reference:
				// https://github.com/microsoft/vs-mef/blob/dc35edfa2c49ae2e20dc8fde2dec59c373062f32/src/Microsoft.VisualStudio.Composition/Configuration/ExportMetadataViewInterfaceEmitProxy.cs#L49-L50
				foreach (var ifcProps in typeDef.Interfaces.SelectMany(i => i.Interface.ResolveTypeDefThrow().Properties)) {
					var getter = ifcProps.GetMethod;
					if (getter != null) {
						service.AddReference(getter, new RequiredPrefixReference<MethodDef>(getter, "get_"));
					}
				}
			}
		}

		/// <inheritdoc />
		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) { }

		/// <inheritdoc />
		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) { }
	}
}

```

`Confuser.Renamer/Analyzers/WPFAnalyzer.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Resources;
using System.Text.RegularExpressions;
using System.Web;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.Renamer.BAML;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.IO;

namespace Confuser.Renamer.Analyzers {
	internal class WPFAnalyzer : IRenamer {
		static readonly object BAMLKey = new object();

		static readonly Regex ResourceNamePattern = new Regex("^.*\\.g\\.resources$");
		internal static readonly Regex UriPattern = new Regex("^(?:PACK\\://(?:COMPONENT|APPLICATION)\\:,,,)?(?:/(.+?)(?:;V\\d+\\.\\d+\\.\\d+\\.\\d+)?;COMPONENT)?(/?[^/].*\\.[BX]AML)$");
		BAMLAnalyzer analyzer;

		internal Dictionary<string, List<IBAMLReference>> bamlRefs = new Dictionary<string, List<IBAMLReference>>(StringComparer.OrdinalIgnoreCase);
		public event Action<BAMLAnalyzer, BamlElement> AnalyzeBAMLElement;

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var method = def as MethodDef;
			if (method != null) {
				if (!method.HasBody)
					return;
				AnalyzeMethod(context, service, method);
			}

			var module = def as ModuleDefMD;
			if (module != null) {
				AnalyzeResources(context, service, module);
			}
		}

		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (!(def is ModuleDefMD module) || !parameters.GetParameter(context, def, "renXaml", true))
				return;

			var renameMode = parameters.GetParameter(context, def, "renXamlMode", RenameMode.Letters);
			if (renameMode < RenameMode.Letters) {
				var illegalValues = Enum.GetValues(typeof(RenameMode)).Cast<RenameMode>().Where(m => m < RenameMode.Letters);
				context.Logger.Warn("The renaming modes " + String.Join(", ", illegalValues) + " are not allowed for XAML resources. Letters mode will be used.");
				renameMode = RenameMode.Letters;
			}

			var wpfResInfo = context.Annotations.Get<Dictionary<string, Dictionary<string, BamlDocument>>>(module, BAMLKey);
			if (wpfResInfo == null)
				return;

			foreach (var res in wpfResInfo.Values)
				foreach (var doc in res.Values) {
					var decodedName = HttpUtility.UrlDecode(doc.DocumentName);
					var encodedName = doc.DocumentName;
					if (bamlRefs.TryGetValue(decodedName, out var references)) {
						var decodedDirectory = decodedName.Substring(0, decodedName.LastIndexOf('/') + 1);
						var encodedDirectory = encodedName.Substring(0, encodedName.LastIndexOf('/') + 1);

						var fileName = service.RandomName(renameMode).ToLowerInvariant();
						if (decodedName.EndsWith(".BAML", StringComparison.OrdinalIgnoreCase))
							fileName += ".baml";
						else if (decodedName.EndsWith(".XAML", StringComparison.OrdinalIgnoreCase))
							fileName += ".xaml";

						string decodedNewName = decodedDirectory + fileName;
						string encodedNewName = encodedDirectory + fileName;

						context.Logger.Debug(String.Format("Preserving virtual paths. Replaced {0} with {1}", decodedName, decodedNewName));

						bool renameOk = references.All(r => r.CanRename(module, decodedName, decodedNewName) || r.CanRename(module, encodedName, encodedNewName));

						if (renameOk) {
							foreach (var bamlRef in references) {
								bamlRef.Rename(module, decodedName, decodedNewName);
								bamlRef.Rename(module, encodedName, encodedNewName);
							}
							doc.DocumentName = encodedNewName;
						}
					}
				}
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			var module = def as ModuleDefMD;
			if (module == null)
				return;

			var wpfResInfo = context.Annotations.Get<Dictionary<string, Dictionary<string, BamlDocument>>>(module, BAMLKey);
			if (wpfResInfo == null)
				return;

			var newResources = new List<EmbeddedResource>();

			foreach (EmbeddedResource res in module.Resources.OfType<EmbeddedResource>()) {
				Dictionary<string, BamlDocument> resInfo;

				if (!wpfResInfo.TryGetValue(res.Name, out resInfo))
					continue;

				var stream = new MemoryStream();
				var writer = new ResourceWriter(stream);

				var reader = new ResourceReader(res.CreateReader().AsStream());
				IDictionaryEnumerator enumerator = reader.GetEnumerator();
				while (enumerator.MoveNext()) {
					var name = (string)enumerator.Key;
					string typeName;
					byte[] data;
					reader.GetResourceData(name, out typeName, out data);

					BamlDocument document;
					if (resInfo.TryGetValue(name, out document)) {
						var docStream = new MemoryStream();
						docStream.Position = 4;
						BamlWriter.WriteDocument(document, docStream);
						docStream.Position = 0;
						docStream.Write(BitConverter.GetBytes((int)docStream.Length - 4), 0, 4);
						data = docStream.ToArray();
						name = document.DocumentName;
					}

					writer.AddResourceData(name, typeName, data);
				}
				writer.Generate();
				newResources.Add(new EmbeddedResource(res.Name, stream.ToArray(), res.Attributes));
			}

			foreach (EmbeddedResource res in newResources) {
				int index = module.Resources.IndexOfEmbeddedResource(res.Name);
				module.Resources[index] = res;
			}
		}

		void AnalyzeMethod(ConfuserContext context, INameService service, MethodDef method) {
			var dpRegInstrs = new List<Tuple<bool, Instruction>>();
			var routedEvtRegInstrs = new List<Instruction>();
			for (int i = 0; i < method.Body.Instructions.Count; i++) {
				Instruction instr = method.Body.Instructions[i];
				if ((instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt)) {
					var regMethod = (IMethod)instr.Operand;

					if (regMethod.DeclaringType.FullName == "System.Windows.DependencyProperty" &&
						regMethod.Name.String.StartsWith("Register")) {
						dpRegInstrs.Add(Tuple.Create(regMethod.Name.String.StartsWith("RegisterAttached"), instr));
					}
					else if (regMethod.DeclaringType.FullName == "System.Windows.EventManager" &&
							 regMethod.Name.String == "RegisterRoutedEvent") {
						routedEvtRegInstrs.Add(instr);
					}
				}
				else if (instr.OpCode.Code == Code.Newobj) {
					var methodRef = (IMethod)instr.Operand;

					if (methodRef.DeclaringType.FullName == "System.Windows.Data.PropertyGroupDescription" &&
						methodRef.Name == ".ctor" && i - 1 >= 0 && method.Body.Instructions[i - 1].OpCode.Code == Code.Ldstr) {
						foreach (var property in analyzer.LookupProperty((string)method.Body.Instructions[i - 1].Operand))
							service.SetCanRename(property, false);
					}
				}
				else if (instr.OpCode == OpCodes.Ldstr) {
					var operand = ((string)instr.Operand).ToUpperInvariant();
					if (operand.EndsWith(".BAML") || operand.EndsWith(".XAML")) {
						var match = UriPattern.Match(operand);
						var refModule = method.Module;
						if (match.Success) {
							var resourceAssemblyName = match.Groups[1].Success ? match.Groups[1].Value : string.Empty;
							// Check if the expression contains a resource name (group 1)
							// If it does, check if it is this assembly.
							if (!string.IsNullOrWhiteSpace(resourceAssemblyName) &&
								!resourceAssemblyName.Equals(method.Module.Assembly.Name.String, StringComparison.OrdinalIgnoreCase)) {
								// Let's see if we can find this assembly.
								refModule = context.Modules.FirstOrDefault(m =>
									resourceAssemblyName.Equals(m.Assembly.Name.String,
										StringComparison.OrdinalIgnoreCase));

								if (refModule == null) {
									// This resource points to an assembly that is not part of the obfuscation.
									// Leave it alone!
									return;
								}
							}
							operand = match.Groups[2].Value;
						}
						else if (operand.Contains("/"))
							context.Logger.WarnFormat("Fail to extract XAML name from '{0}'.", instr.Operand);

						var reference = new BAMLStringReference(refModule, instr);
						operand = WebUtility.UrlDecode(operand.TrimStart('/'));
						var baml = operand.Substring(0, operand.Length - 5) + ".BAML";
						var xaml = operand.Substring(0, operand.Length - 5) + ".XAML";
						bamlRefs.AddListEntry(baml, reference);
						bamlRefs.AddListEntry(xaml, reference);
					}
				}
			}

			if (dpRegInstrs.Count == 0)
				return;

			var traceSrv = context.Registry.GetService<ITraceService>();
			MethodTrace trace = traceSrv.Trace(method);

			bool erred = false;
			foreach (var instrInfo in dpRegInstrs) {
				int[] args = trace.TraceArguments(instrInfo.Item2);
				if (args == null) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract dependency property name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}
				Instruction ldstr = method.Body.Instructions[args[0]];
				if (ldstr.OpCode.Code != Code.Ldstr) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract dependency property name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}

				var name = (string)ldstr.Operand;
				TypeDef declType = method.DeclaringType;
				bool found = false;
				if (instrInfo.Item1) // Attached DP
				{
					MethodDef accessor;
					if ((accessor = declType.FindMethod("Get" + name)) != null && accessor.IsStatic) {
						service.SetCanRename(accessor, false);
						found = true;
					}
					if ((accessor = declType.FindMethod("Set" + name)) != null && accessor.IsStatic) {
						service.SetCanRename(accessor, false);
						found = true;
					}
				}

				// Normal DP
				// Find CLR property for attached DP as well, because it seems attached DP can be use as normal DP as well.
				PropertyDef property = null;
				if ((property = declType.FindProperty(name)) != null) {
					service.SetCanRename(property, false);

					found = true;
					if (property.GetMethod != null)
						service.SetCanRename(property.GetMethod, false);

					if (property.SetMethod != null)
						service.SetCanRename(property.SetMethod, false);

					if (property.HasOtherMethods) {
						foreach (MethodDef accessor in property.OtherMethods)
							service.SetCanRename(accessor, false);
					}
				}
				if (!found) {
					if (instrInfo.Item1)
						context.Logger.WarnFormat("Failed to find the accessors of attached dependency property '{0}' in type '{1}'.",
												  name, declType.FullName);
					else
						context.Logger.WarnFormat("Failed to find the CLR property of normal dependency property '{0}' in type '{1}'.",
												  name, declType.FullName);
				}
			}

			erred = false;
			foreach (Instruction instr in routedEvtRegInstrs) {
				int[] args = trace.TraceArguments(instr);
				if (args == null) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract routed event name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}
				Instruction ldstr = method.Body.Instructions[args[0]];
				if (ldstr.OpCode.Code != Code.Ldstr) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract routed event name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}

				var name = (string)ldstr.Operand;
				TypeDef declType = method.DeclaringType;

				EventDef eventDef = null;
				if ((eventDef = declType.FindEvent(name)) == null) {
					context.Logger.WarnFormat("Failed to find the CLR event of routed event '{0}' in type '{1}'.",
											  name, declType.FullName);
					continue;
				}
				service.SetCanRename(eventDef, false);

				if (eventDef.AddMethod != null)
					service.SetCanRename(eventDef.AddMethod, false);

				if (eventDef.RemoveMethod != null)
					service.SetCanRename(eventDef.RemoveMethod, false);

				if (eventDef.InvokeMethod != null)
					service.SetCanRename(eventDef.InvokeMethod, false);

				if (eventDef.HasOtherMethods) {
					foreach (MethodDef accessor in eventDef.OtherMethods)
						service.SetCanRename(accessor, false);
				}
			}
		}

		void AnalyzeResources(ConfuserContext context, INameService service, ModuleDefMD module) {
			if (analyzer == null) {
				analyzer = new BAMLAnalyzer(context, service);
				analyzer.AnalyzeElement += AnalyzeBAMLElement;
			}

			var wpfResInfo = new Dictionary<string, Dictionary<string, BamlDocument>>();

			foreach (EmbeddedResource res in module.Resources.OfType<EmbeddedResource>()) {
				Match match = ResourceNamePattern.Match(res.Name);
				if (!match.Success)
					continue;

				var resInfo = new Dictionary<string, BamlDocument>();

				var reader = new ResourceReader(res.CreateReader().AsStream());
				IDictionaryEnumerator enumerator = reader.GetEnumerator();
				while (enumerator.MoveNext()) {
					var name = (string)enumerator.Key;
					if (!name.EndsWith(".baml"))
						continue;

					string typeName;
					byte[] data;
					reader.GetResourceData(name, out typeName, out data);
					BamlDocument document = analyzer.Analyze(module, name, data);
					document.DocumentName = name;
					resInfo.Add(name, document);
				}

				if (resInfo.Count > 0)
					wpfResInfo.Add(res.Name, resInfo);
			}
			if (wpfResInfo.Count > 0)
				context.Annotations.Set(module, BAMLKey, wpfResInfo);
		}
	}
}

```

`Confuser.Renamer/Analyzers/WinFormsAnalyzer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.Analyzers {
	public class WinFormsAnalyzer : IRenamer {
		Dictionary<string, List<PropertyDef>> properties = new Dictionary<string, List<PropertyDef>>();

		public void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			if (def is ModuleDef moduleDef) {
				foreach (var prop in moduleDef.GetTypes().SelectMany(t => t.Properties))
					properties.AddListEntry(prop.Name, prop);
				return;
			}

			if (!(def is MethodDef method) || !method.HasBody)
				return;

			AnalyzeMethod(context, service, method);
		}

		void AnalyzeMethod(ConfuserContext context, INameService service, MethodDef method) {
			var binding = new List<Tuple<bool, Instruction>>();
			var dataPropertyName = new List<Instruction>();
			foreach (var instr in method.Body.Instructions) {
				var target = instr.Operand as IMethod;
				switch (instr.OpCode.Code) {
					case Code.Call:
					case Code.Callvirt:
						Debug.Assert(target != null);

						if ((target.DeclaringType.FullName == "System.Windows.Forms.ControlBindingsCollection" ||
							 target.DeclaringType.FullName == "System.Windows.Forms.BindingsCollection") &&
							target.Name == "Add" && target.MethodSig.Params.Count != 1) {
							binding.Add(Tuple.Create(true, instr));
						}
						else if (target.DeclaringType.FullName == "System.Windows.Forms.DataGridViewColumn" &&
							target.Name == "set_DataPropertyName" &&
							target.MethodSig.Params.Count == 1) {
							dataPropertyName.Add(instr);
						}
						break;
					case Code.Newobj:
						Debug.Assert(target != null);
						if (target.DeclaringType.FullName == "System.Windows.Forms.Binding" &&
								target.Name.String == ".ctor") {
							binding.Add(Tuple.Create(false, instr));
						}
						break;
				}
			}

			if (binding.Count == 0 && dataPropertyName.Count == 0)
				return;

			var traceSrv = context.Registry.GetService<ITraceService>();
			MethodTrace trace = traceSrv.Trace(method);

			bool erred = false;
			foreach (var instrInfo in binding) {
				int[] args = trace.TraceArguments(instrInfo.Item2);
				if (args == null) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract binding property name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}

				var argumentIndex = (instrInfo.Item1 ? 1 : 0);
				var propertyName = ResolveNameInstruction(method, args, ref argumentIndex);
				if (propertyName.OpCode.Code != Code.Ldstr) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract binding property name in '{0}'.", method.FullName);
					erred = true;
				}
				else {
					List<PropertyDef> props;
					if (!properties.TryGetValue((string)propertyName.Operand, out props)) {
						if (!erred)
							context.Logger.WarnFormat("Failed to extract target property in '{0}'.", method.FullName);
						erred = true;
					}
					else {
						foreach (var property in props)
							service.SetCanRename(property, false);
					}
				}

				argumentIndex += 2;
				var dataMember = ResolveNameInstruction(method, args, ref argumentIndex);
				if (dataMember.OpCode.Code != Code.Ldstr) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract binding property name in '{0}'.", method.FullName);
					erred = true;
				}
				else {
					List<PropertyDef> props;
					if (!properties.TryGetValue((string)dataMember.Operand, out props)) {
						if (!erred)
							context.Logger.WarnFormat("Failed to extract target property in '{0}'.", method.FullName);
						erred = true;
					}
					else {
						foreach (var property in props)
							service.SetCanRename(property, false);
					}
				}
			}

			foreach (var instrInfo in dataPropertyName) {
				int[] args = trace.TraceArguments(instrInfo);
				if (args == null) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract binding property name in '{0}'.", method.FullName);
					erred = true;
					continue;
				}

				var argumentIndex = 1;
				var propertyName = ResolveNameInstruction(method, args, ref argumentIndex);
				if (propertyName.OpCode.Code != Code.Ldstr) {
					if (!erred)
						context.Logger.WarnFormat("Failed to extract binding property name in '{0}'.", method.FullName);
					erred = true;
				}
				else {
					if (!properties.TryGetValue((string)propertyName.Operand, out var props)) {
						if (!erred)
							context.Logger.WarnFormat("Failed to extract target property in '{0}'.", method.FullName);
						erred = true;
					}
					else {
						foreach (var property in props)
							service.SetCanRename(property, false);
					}
				}
			}
		}

		private static Instruction ResolveNameInstruction(MethodDef method, int[] tracedArguments, ref int argumentIndex) {
			Instruction propertyName = null;
			for (; ; ) {
				propertyName = method.Body.Instructions[tracedArguments[argumentIndex]];
				if (propertyName.OpCode.Code == Code.Dup)
					argumentIndex++;
				else break;
			}
			return propertyName;
		}


		public void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}

		public void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def) {
			//
		}
	}
}

```

`Confuser.Renamer/BAML/BAMLAnalyzer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Packaging;
using System.Linq;
using System.Net;
using Confuser.Core;
using Confuser.Renamer.Analyzers;
using Confuser.Renamer.References;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal class BAMLAnalyzer {
		readonly ConfuserContext context;
		readonly INameService service;

		readonly Dictionary<string, List<MethodDef>> methods = new Dictionary<string, List<MethodDef>>();
		readonly Dictionary<string, List<EventDef>> events = new Dictionary<string, List<EventDef>>();
		readonly Dictionary<string, List<PropertyDef>> properties = new Dictionary<string, List<PropertyDef>>();

		readonly Dictionary<ushort, AssemblyDef> assemblyRefs = new Dictionary<ushort, AssemblyDef>();
		readonly Dictionary<ushort, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef>> attrRefs = new Dictionary<ushort, Tuple<IDnlibDef, AttributeInfoRecord, TypeDef>>();

		readonly Dictionary<ushort, StringInfoRecord> strings = new Dictionary<ushort, StringInfoRecord>();
		readonly Dictionary<ushort, TypeSig> typeRefs = new Dictionary<ushort, TypeSig>();
		readonly Dictionary<string, List<Tuple<AssemblyDef, string>>> xmlns = new Dictionary<string, List<Tuple<AssemblyDef, string>>>();

		private PropertyPathParser PathParser { get; } = new PropertyPathParser();

		readonly string packScheme = PackUriHelper.UriSchemePack + "://";

		IKnownThings things;

		KnownThingsv3 thingsv3;
		KnownThingsv4 thingsv4;
		XmlNsContext xmlnsCtx;

		public event Action<BAMLAnalyzer, BamlElement> AnalyzeElement;

		public ConfuserContext Context {
			get { return context; }
		}

		public INameService NameService {
			get { return service; }
		}

		public string CurrentBAMLName { get; set; }
		public ModuleDefMD Module { get; set; }

		public BAMLAnalyzer(ConfuserContext context, INameService service) {
			this.context = context;
			this.service = service;
			PreInit();
		}

		void PreInit() {
			// WPF will only look for public instance members
			foreach (TypeDef type in context.Modules.SelectMany(m => m.GetTypes())) {
				foreach (PropertyDef property in type.Properties) {
					if (property.IsPublic() && !property.IsStatic())
						properties.AddListEntry(property.Name, property);
				}

				foreach (EventDef evt in type.Events) {
					if (evt.IsPublic() && !evt.IsStatic())
						events.AddListEntry(evt.Name, evt);
				}

				foreach (MethodDef method in type.Methods) {
					if (method.IsPublic && !method.IsStatic)
						methods.AddListEntry(method.Name, method);
				}
			}
		}

		public IEnumerable<PropertyDef> LookupProperty(string name) {
			List<PropertyDef> ret;
			if (!properties.TryGetValue(name, out ret))
				return Enumerable.Empty<PropertyDef>();
			return ret;
		}

		public IEnumerable<EventDef> LookupEvent(string name) {
			List<EventDef> ret;
			if (!events.TryGetValue(name, out ret))
				return Enumerable.Empty<EventDef>();
			return ret;
		}

		public IEnumerable<MethodDef> LookupMethod(string name) {
			List<MethodDef> ret;
			if (!methods.TryGetValue(name, out ret))
				return Enumerable.Empty<MethodDef>();
			return ret;
		}

		public BamlDocument Analyze(ModuleDefMD module, string bamlName, byte[] data) {
			Module = module;
			CurrentBAMLName = bamlName;
			if (module.IsClr40) {
				things = thingsv4 ?? (thingsv4 = new KnownThingsv4(context, module));
			}
			else {
				things = thingsv3 ?? (thingsv3 = new KnownThingsv3(context, module));
			}

			Debug.Assert(BitConverter.ToInt32(data, 0) == data.Length - 4);

			BamlDocument document = BamlReader.ReadDocument(new MemoryStream(data, 4, data.Length - 4));

			// Remove debug infos
			document.RemoveWhere(rec => rec is LineNumberAndPositionRecord || rec is LinePositionRecord);

			// Populate references
			PopulateReferences(document);

			// Process elements
			BamlElement rootElem = BamlElement.Read(document);
			BamlElement trueRoot = rootElem.Children.Single();
			var stack = new Stack<BamlElement>();
			stack.Push(rootElem);
			while (stack.Count > 0) {
				BamlElement elem = stack.Pop();
				ProcessBAMLElement(trueRoot, elem);
				foreach (BamlElement child in elem.Children)
					stack.Push(child);
			}

			return document;
		}

		void PopulateReferences(BamlDocument document) {
			var clrNs = new Dictionary<string, List<Tuple<AssemblyDef, string>>>();

			assemblyRefs.Clear();
			foreach (AssemblyInfoRecord rec in document.OfType<AssemblyInfoRecord>()) {
				AssemblyDef assembly = context.Resolver.ResolveThrow(rec.AssemblyFullName, Module);
				assemblyRefs.Add(rec.AssemblyId, assembly);

				if (!context.Modules.Any(m => m.Assembly == assembly))
					continue;

				foreach (CustomAttribute attr in assembly.CustomAttributes.FindAll("System.Windows.Markup.XmlnsDefinitionAttribute")) {
					clrNs.AddListEntry(
						(UTF8String)attr.ConstructorArguments[0].Value,
						Tuple.Create(assembly, (string)(UTF8String)attr.ConstructorArguments[1].Value));
				}
			}

			xmlnsCtx = new XmlNsContext(document, assemblyRefs);

			typeRefs.Clear();
			foreach (TypeInfoRecord rec in document.OfType<TypeInfoRecord>()) {
				AssemblyDef assembly;
				var asmId = (short)(rec.AssemblyId & 0xfff);
				if (asmId == -1)
					assembly = things.FrameworkAssembly;
				else
					assembly = assemblyRefs[(ushort)asmId];

				AssemblyDef assemblyRef = Module.Assembly == assembly ? null : assembly;

				TypeSig typeSig = TypeNameParser.ParseAsTypeSigReflectionThrow(Module, rec.TypeFullName, new DummyAssemblyRefFinder(assemblyRef));
				typeRefs[rec.TypeId] = typeSig;

				AddTypeSigReference(typeSig, new BAMLTypeReference(typeSig, rec));
			}

			attrRefs.Clear();
			foreach (AttributeInfoRecord rec in document.OfType<AttributeInfoRecord>()) {
				TypeSig declType;
				if (typeRefs.TryGetValue(rec.OwnerTypeId, out declType)) {
					TypeDef type = declType.ToBasicTypeDefOrRef().ResolveTypeDefThrow();
					attrRefs[rec.AttributeId] = AnalyzeAttributeReference(type, rec);
				}
				else {
					Debug.Assert((short)rec.OwnerTypeId < 0);
					TypeDef declTypeDef = things.Types((KnownTypes)(-(short)rec.OwnerTypeId));
					attrRefs[rec.AttributeId] = AnalyzeAttributeReference(declTypeDef, rec);
				}
			}

			strings.Clear();
			foreach (StringInfoRecord rec in document.OfType<StringInfoRecord>()) {
				strings[rec.StringId] = rec;
			}

			foreach (PIMappingRecord rec in document.OfType<PIMappingRecord>()) {
				var asmId = (short)(rec.AssemblyId & 0xfff);
				AssemblyDef assembly;
				if (asmId == -1)
					assembly = things.FrameworkAssembly;
				else
					assembly = assemblyRefs[(ushort)asmId];

				Tuple<AssemblyDef, string> scope = Tuple.Create(assembly, rec.ClrNamespace);
				clrNs.AddListEntry(rec.XmlNamespace, scope);
			}

			xmlns.Clear();
			foreach (XmlnsPropertyRecord rec in document.OfType<XmlnsPropertyRecord>()) {
				List<Tuple<AssemblyDef, string>> clrMap;
				if (clrNs.TryGetValue(rec.XmlNamespace, out clrMap)) {
					xmlns[rec.Prefix] = clrMap;
					foreach (var scope in clrMap)
						xmlnsCtx.AddNsMap(scope, rec.Prefix);
				}
			}
		}

		public TypeDef ResolveType(ushort typeId) {
			if ((short)typeId < 0)
				return things.Types((KnownTypes)(-(short)typeId));
			return typeRefs[typeId].ToBasicTypeDefOrRef().ResolveTypeDefThrow();
		}

		TypeSig ResolveType(string typeName, out string prefix) {
			List<Tuple<AssemblyDef, string>> clrNs;

			int index = typeName.IndexOf(':');
			if (index == -1) {
				prefix = "";
				if (!xmlns.TryGetValue(prefix, out clrNs))
					return null;
			}
			else {
				prefix = typeName.Substring(0, index);
				if (!xmlns.TryGetValue(prefix, out clrNs))
					return null;

				typeName = typeName.Substring(index + 1);
			}

			foreach (var ns in clrNs) {
				TypeSig sig = TypeNameParser.ParseAsTypeSigReflectionThrow(Module, ns.Item2 + "." + typeName, new DummyAssemblyRefFinder(ns.Item1));
				if (sig.ToBasicTypeDefOrRef().ResolveTypeDef() != null)
					return sig;
			}
			return null;
		}

		public Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> ResolveAttribute(ushort attrId) {
			if ((short)attrId < 0) {
				Tuple<KnownTypes, PropertyDef, TypeDef> info = things.Properties((KnownProperties)(-(short)attrId));
				return Tuple.Create<IDnlibDef, AttributeInfoRecord, TypeDef>(info.Item2, null, info.Item3);
			}
			return attrRefs[attrId];
		}

		void AddTypeSigReference(TypeSig typeSig, INameReference<IDnlibDef> reference) {
			foreach (ITypeDefOrRef type in typeSig.FindTypeRefs()) {
				TypeDef typeDef = type.ResolveTypeDefThrow();
				if (context.Modules.Contains((ModuleDefMD)typeDef.Module)) {
					AddDefReference(typeDef, reference);
					if (type is TypeRef typeRef)
						service.AddReference(typeDef, new TypeRefReference(typeRef, typeDef));
				}
			}
		}

		void AddDefReference<T>(T def, INameReference<T> reference) where T : IDnlibDef {
			service.ReduceRenameMode(def, RenameMode.Letters);
			service.AddReference(def, reference);
		}

		void ProcessBAMLElement(BamlElement root, BamlElement elem) {
			ProcessElementHeader(elem);
			ProcessElementBody(root, elem);

			if (AnalyzeElement != null)
				AnalyzeElement(this, elem);
		}

		void ProcessElementHeader(BamlElement elem) {
			// Resolve type & properties of the element.
			switch (elem.Header.Type) {
				case BamlRecordType.ConstructorParametersStart:
					elem.Type = elem.Parent.Type;
					elem.Attribute = elem.Parent.Attribute;
					break;

				case BamlRecordType.DocumentStart:
					break;

				case BamlRecordType.ElementStart:
				case BamlRecordType.NamedElementStart:
					elem.Type = ResolveType(((ElementStartRecord)elem.Header).TypeId);
					elem.Attribute = elem.Parent.Attribute;
					if (elem.Attribute != null)
						elem.Type = GetAttributeType(elem.Attribute);
					break;

				case BamlRecordType.PropertyArrayStart:
				case BamlRecordType.PropertyComplexStart:
				case BamlRecordType.PropertyDictionaryStart:
				case BamlRecordType.PropertyListStart:
					var attrInfo = ResolveAttribute(((PropertyComplexStartRecord)elem.Header).AttributeId);
					elem.Type = attrInfo.Item3;
					elem.Attribute = attrInfo.Item1;
					if (elem.Attribute != null)
						elem.Type = GetAttributeType(elem.Attribute);
					break;

				case BamlRecordType.KeyElementStart:
				case BamlRecordType.StaticResourceStart:
					// i.e. <x:Key></x:Key>
					elem.Type = Module.CorLibTypes.Object.TypeDefOrRef.ResolveTypeDef();
					elem.Attribute = null;
					break;
			}
		}

		TypeDef GetAttributeType(IDnlibDef attr) {
			ITypeDefOrRef retType = null;
			if (attr is PropertyDef)
				retType = ((PropertyDef)attr).PropertySig.RetType.ToBasicTypeDefOrRef();
			else if (attr is EventDef)
				retType = ((EventDef)attr).EventType;
			return (retType == null) ? null : retType.ResolveTypeDefThrow();
			throw new UnreachableException();
		}

		void ProcessElementBody(BamlElement root, BamlElement elem) {
			foreach (BamlRecord rec in elem.Body) {
				// Resolve the type & property for simple property record too.
				TypeDef type = null;
				IDnlibDef attr = null;
				if (rec is PropertyRecord) {
					var propRec = (PropertyRecord)rec;
					var attrInfo = ResolveAttribute(propRec.AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (attr != null)
						type = GetAttributeType(attr);

					if (attrInfo.Item1 is EventDef) {
						MethodDef method = root.Type.FindMethod(propRec.Value);
						if (method == null)
							context.Logger.WarnFormat("Cannot resolve method '{0}' in '{1}'.", root.Type.FullName, propRec.Value);
						else {
							var reference = new BAMLAttributeReference(method, propRec);
							service.AddReference(method, reference);
						}
					}

					if (rec is PropertyWithConverterRecord) {
						ProcessConverter((PropertyWithConverterRecord)rec, type);
					}
				}
				else if (rec is PropertyComplexStartRecord) {
					var attrInfo = ResolveAttribute(((PropertyComplexStartRecord)rec).AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (attr != null)
						type = GetAttributeType(attr);
				}
				else if (rec is ContentPropertyRecord) {
					var attrInfo = ResolveAttribute(((ContentPropertyRecord)rec).AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (elem.Attribute != null && attr != null)
						type = GetAttributeType(attr);
					foreach (BamlElement child in elem.Children) {
						child.Type = type;
						child.Attribute = attr;
					}
				}
				else if (rec is PropertyCustomRecord) {
					var customRec = (PropertyCustomRecord)rec;
					var attrInfo = ResolveAttribute(customRec.AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (elem.Attribute != null && attr != null)
						type = GetAttributeType(attr);

					if ((customRec.SerializerTypeId & ~0x4000) != 0 && (customRec.SerializerTypeId & ~0x4000) == 0x89) {
						// See BamlRecordReader.GetCustomDependencyPropertyValue.
						// Umm... Well, actually nothing to do, since this record only describe DP, which already won't be renamed.
					}
				}
				else if (rec is PropertyWithExtensionRecord) {
					var extRec = (PropertyWithExtensionRecord)rec;
					var attrInfo = ResolveAttribute(extRec.AttributeId);
					type = attrInfo.Item3;
					attr = attrInfo.Item1;
					if (elem.Attribute != null && attr != null)
						type = GetAttributeType(attr);

					if (extRec.Flags == 602) {
						// Static Extension
						// We only care about the references in user-defined assemblies, so skip built-in attributes
						// Also, ValueId is a resource ID, which is not implemented, so just skip it.
						if ((short)extRec.ValueId >= 0) {
							attrInfo = ResolveAttribute(extRec.ValueId);

							var attrTarget = attrInfo.Item1;
							if (attrTarget == null) {
								TypeSig declType;
								TypeDef declTypeDef;
								if (typeRefs.TryGetValue(attrInfo.Item2.OwnerTypeId, out declType))
									declTypeDef = declType.ToBasicTypeDefOrRef().ResolveTypeDefThrow();
								else {
									Debug.Assert((short)attrInfo.Item2.OwnerTypeId < 0);
									declTypeDef = things.Types((KnownTypes)(-(short)attrInfo.Item2.OwnerTypeId));
								}
								attrTarget = declTypeDef.FindField(attrInfo.Item2.Name);
							}

							if (attrTarget != null)
								service.AddReference(attrTarget, new BAMLAttributeReference(attrTarget, attrInfo.Item2));
						}
					}
				}
				else if (rec is TextRecord) {
					var txt = (TextRecord)rec;
					string value = txt.Value;
					if (txt is TextWithIdRecord)
						value = strings[((TextWithIdRecord)txt).ValueId].Value;

					// At this point the text entry to analyzed for matching a type or a property reference.
					// Not sure why this is done and in what instances a reference to a property would be stored in a
					// TextRecord.
					// The only instance I know of that creates a text record, is the content of a Tag. For example
					// <TextBlock>abc</TextBlock> where "abc" is the text block.

					string prefix;
					TypeSig sig = ResolveType(value.Trim(), out prefix);
					if (sig != null && context.Modules.Contains((ModuleDefMD)sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module)) {
						var reference = new BAMLConverterTypeReference(xmlnsCtx, sig, txt);
						AddTypeSigReference(sig, reference);
					}
					else
						AnalyzePropertyPath(value, s => txt.Value = s);
				}
			}
		}

		void ProcessConverter(PropertyWithConverterRecord rec, TypeDef type) {
			TypeDef converter = ResolveType(rec.ConverterTypeId);

			if (converter.FullName == "System.ComponentModel.EnumConverter") {
				if (type != null && context.Modules.Contains((ModuleDefMD)type.Module)) {
					FieldDef enumField = type.FindField(rec.Value);
					if (enumField != null)
						service.AddReference(enumField, new BAMLEnumReference(enumField, rec));
				}
			}
			else if (converter.FullName == "System.Windows.Input.CommandConverter") {
				string cmd = rec.Value.Trim();
				int index = cmd.IndexOf('.');
				if (index != -1) {
					string typeName = cmd.Substring(0, index);
					string prefix;
					TypeSig sig = ResolveType(typeName, out prefix);
					if (sig != null) {
						string cmdName = cmd.Substring(index + 1);

						TypeDef typeDef = sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow();
						if (context.Modules.Contains((ModuleDefMD)typeDef.Module)) {
							PropertyDef property = typeDef.FindProperty(cmdName);
							if (property != null) {
								var reference = new BAMLConverterMemberReference(xmlnsCtx, sig, property, rec);
								AddTypeSigReference(sig, reference);
								AddDefReference(property, reference);
							}
							FieldDef field = typeDef.FindField(cmdName);
							if (field != null) {
								var reference = new BAMLConverterMemberReference(xmlnsCtx, sig, field, rec);
								AddTypeSigReference(sig, reference);
								AddDefReference(field, reference);
							}
							if (property == null && field == null)
								context.Logger.WarnFormat("Could not resolve command '{0}' in '{1}'.", cmd, CurrentBAMLName);
						}
					}
				}
			}
			else if (converter.FullName == "System.Windows.Markup.DependencyPropertyConverter") {
				// Umm... Again nothing to do, DP already won't be renamed.
			}
			else if (converter.FullName == "System.Windows.PropertyPathConverter") {
				AnalyzePropertyPath(rec.Value, s => rec.Value = s);
			}
			else if (converter.FullName == "System.Windows.Markup.RoutedEventConverter") {
				;
			}
			else if (converter.FullName == "System.Windows.Markup.TypeTypeConverter") {
				TypeSig sig = ResolveType(rec.Value.Trim(), out _);
				if (sig != null && context.Modules.Contains((ModuleDefMD)sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module)) {
					var reference = new BAMLConverterTypeReference(xmlnsCtx, sig, rec);
					AddTypeSigReference(sig, reference);
				}
			}

			var attrInfo = ResolveAttribute(rec.AttributeId);
			string attrName = null;
			if (attrInfo.Item1 != null)
				attrName = attrInfo.Item1.Name;
			else if (attrInfo.Item2 != null)
				attrName = attrInfo.Item2.Name;

			if (attrName == "DisplayMemberPath") {
				AnalyzePropertyPath(rec.Value, s => rec.Value = s);
			}
			else if (attrName == "TypeName") {
				var sig = ResolveType(rec.Value.Trim(), out _);
				if (!(sig is null))
					AddTypeSigReference(sig, new BAMLConverterTypeReference(xmlnsCtx, sig, rec));
			}
			else if (attrName == "Source") {
				string declType = null;
				if (attrInfo.Item1 is IMemberDef)
					declType = ((IMemberDef)attrInfo.Item1).DeclaringType.FullName;
				else if (attrInfo.Item2 != null)
					declType = ResolveType(attrInfo.Item2.OwnerTypeId).FullName;
				if (declType == "System.Windows.ResourceDictionary") {
					var src = rec.Value.ToUpperInvariant();
					if (src.EndsWith(".BAML") || src.EndsWith(".XAML")) {
						var refModule = Module;
						var match = WPFAnalyzer.UriPattern.Match(src);
						if (match.Success) {
							var resourceAssemblyName = match.Groups[1].Success ? match.Groups[1].Value : string.Empty;
							// Check if the expression contains a resource name (group 1)
							// If it does, check if it is this assembly.
							if (!string.IsNullOrWhiteSpace(resourceAssemblyName) &&
								!resourceAssemblyName.Equals(Module.Assembly.Name.String, StringComparison.OrdinalIgnoreCase)) {
								// Let's see if we can find this assembly.
								refModule = context.Modules.FirstOrDefault(m =>
									resourceAssemblyName.Equals(m.Assembly.Name.String,
										StringComparison.OrdinalIgnoreCase));

								if (refModule == null) {
									// This resource points to an assembly that is not part of the obfuscation.
									// Leave it alone!
									return;
								}
							}
							src = match.Groups[2].Value;
						}
						else if (rec.Value.Contains("/"))
							context.Logger.WarnFormat("Fail to extract XAML name from '{0}'.", rec.Value);

						if (!src.StartsWith(packScheme, StringComparison.OrdinalIgnoreCase)) {
							var rel = new Uri(new Uri(packScheme + "application:,,,/" + CurrentBAMLName), src);
							src = rel.LocalPath;
						}
						var reference = new BAMLPropertyReference(refModule, rec);
						src = WebUtility.UrlDecode(src.TrimStart('/'));
						var baml = src.Substring(0, src.Length - 5) + ".BAML";
						var xaml = src.Substring(0, src.Length - 5) + ".XAML";
						var bamlRefs = service.FindRenamer<WPFAnalyzer>().bamlRefs;
						bamlRefs.AddListEntry(baml, reference);
						bamlRefs.AddListEntry(xaml, reference);
					}
				}
			}
		}

		Tuple<IDnlibDef, AttributeInfoRecord, TypeDef> AnalyzeAttributeReference(TypeDef declType, AttributeInfoRecord rec) {
			IDnlibDef retDef = null;
			ITypeDefOrRef retType = null;
			while (declType != null) {
				PropertyDef property = declType.FindProperty(rec.Name);
				if (property != null) {
					retDef = property;
					retType = property.PropertySig.RetType.ToBasicTypeDefOrRef();
					if (context.Modules.Contains((ModuleDefMD)declType.Module))
						service.AddReference(property, new BAMLAttributeReference(property, rec));
					break;
				}

				EventDef evt = declType.FindEvent(rec.Name);
				if (evt != null) {
					retDef = evt;
					retType = evt.EventType;
					if (context.Modules.Contains((ModuleDefMD)declType.Module))
						service.AddReference(evt, new BAMLAttributeReference(evt, rec));
					break;
				}

				if (declType.BaseType == null)
					break;
				declType = declType.BaseType.ResolveTypeDefThrow();
			}
			return Tuple.Create(retDef, rec, retType == null ? null : retType.ResolveTypeDefThrow());
		}

		void AnalyzePropertyPath(string path, Action<string> updateAction) {
			var pathUpdater = new PropertyPathUpdater(path, updateAction);
			foreach (var part in pathUpdater) {
				switch (part.Type) {
					case SourceValueType.Property:
						AnalyzePropertyPathProperty(part);
						break;
					case SourceValueType.Indexer:
						// This is the indexer part of a property reference.
						AnalyzePropertyPathIndexer(part);
						break;
				}
			}
		}

		void AnalyzePropertyPathProperty(PropertyPathPartUpdater part) {
			// This is a property reference. This may be directly the name of a property or a reference by
			// with the type to the property
			// Simple Property:    "TestProperty"
			// Property with Type: "(local:DataClass.TestProperty)"

			var typeName = part.GetTypeName();
			var propertyName = part.GetPropertyName();
			if (!string.IsNullOrWhiteSpace(typeName)) {
				var sig = ResolveType(typeName, out _);
				var basicTypeDef = sig?.ToBasicTypeDefOrRef().ResolveTypeDef();
				if (!(basicTypeDef is null) && context.Modules.Contains(basicTypeDef.Module as ModuleDefMD)) {
					var propDef = basicTypeDef.FindPropertyCheckBaseType(propertyName);
					var reference = new BAMLPathTypeReference(xmlnsCtx, sig, propDef, part);
					AddTypeSigReference(sig, reference);

					if (!(propDef is null)) {
						AddDefReference(propDef, reference);
						return; // Return to avoid blocking renaming of the property.
					}
				}
			}

			// Reaching this point means that the type reference was either not present or failed to
			// resolve. In this case every property with the matching name will be flagged so it does not
			// get renamed.
			if (properties.TryGetValue(propertyName, out var candidates))
				foreach (var property in candidates)
					service.SetCanRename(property, false);
		}

		void AnalyzePropertyPathIndexer(PropertyPathPartUpdater part) {
			foreach (var indexerArg in part.ParamList) {
				if (!string.IsNullOrWhiteSpace(indexerArg.ParenString)) {
					var sig = ResolveType(indexerArg.ParenString, out var prefix);
					if (sig != null && context.Modules.Contains((ModuleDefMD) sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module)) {
						var reference = new BAMLPathTypeReference(xmlnsCtx, sig, indexerArg);
						AddTypeSigReference(sig, reference);
						break;
					}
				}
			}
		}

		class DummyAssemblyRefFinder : IAssemblyRefFinder {
			readonly AssemblyDef assemblyDef;

			public DummyAssemblyRefFinder(AssemblyDef assemblyDef) {
				this.assemblyDef = assemblyDef;
			}

			public AssemblyRef FindAssemblyRef(TypeRef nonNestedTypeRef) {
				return assemblyDef.ToAssemblyRef();
			}
		}

		internal class XmlNsContext {
			readonly Dictionary<AssemblyDef, ushort> assemblyRefs;
			readonly BamlDocument doc;
			readonly Dictionary<Tuple<AssemblyDef, string>, string> xmlNsMap = new Dictionary<Tuple<AssemblyDef, string>, string>();
			int rootIndex = -1;
			int x;

			public XmlNsContext(BamlDocument doc, Dictionary<ushort, AssemblyDef> assemblyRefs) {
				this.doc = doc;

				this.assemblyRefs = new Dictionary<AssemblyDef, ushort>();
				foreach (var entry in assemblyRefs)
					this.assemblyRefs[entry.Value] = entry.Key;

				for (int i = 0; i < doc.Count; i++)
					if (doc[i] is ElementStartRecord) {
						rootIndex = i + 1;
						break;
					}
				Debug.Assert(rootIndex != -1);
			}

			public void AddNsMap(string clrNs, AssemblyDef assembly, string prefix) => 
				AddNsMap(Tuple.Create(assembly, clrNs), prefix);

			public void AddNsMap(Tuple<AssemblyDef, string> scope, string prefix) {
				xmlNsMap[scope] = prefix;
			}

			public string GetPrefix(string clrNs, AssemblyDef assembly) {
				string prefix;
				if (!xmlNsMap.TryGetValue(Tuple.Create(assembly, clrNs), out prefix)) {
					prefix = "_" + x++;
					ushort assemblyId = assemblyRefs[assembly];
					doc.Insert(rootIndex, new XmlnsPropertyRecord {
						AssemblyIds = new[] { assemblyId },
						Prefix = prefix,
						XmlNamespace = "clr-namespace:" + clrNs
					});
					doc.Insert(rootIndex - 1, new PIMappingRecord {
						AssemblyId = assemblyId,
						ClrNamespace = clrNs,
						XmlNamespace = "clr-namespace:" + clrNs
					});
					rootIndex++;

					AddNsMap(clrNs, assembly, prefix);
				}
				return prefix;
			}
		}
	}
}

```

`Confuser.Renamer/BAML/BAMLPropertyReference.cs`:

```cs
using System;
using System.Diagnostics;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	sealed class BAMLPropertyReference : IBAMLReference {
		readonly ModuleDef _refModule;
		readonly PropertyRecord _rec;

		public BAMLPropertyReference(ModuleDef refModule, PropertyRecord rec) {
			_refModule = refModule;
			_rec = rec;
		}

		public bool CanRename(ModuleDef moduleDef, string oldName, string newName) => true;

		public void Rename(ModuleDef moduleDef, string oldName, string newName) {
			if (moduleDef != _refModule) return;

			var value = _rec.Value;
			while (true) {
				if (value.EndsWith(oldName, StringComparison.OrdinalIgnoreCase)) {
					value = value.Substring(0, value.Length - oldName.Length) + newName;
					_rec.Value = value;
				}
				else if (oldName.EndsWith(".baml", StringComparison.OrdinalIgnoreCase)) {
					oldName = ToXaml(oldName);
					newName = ToXaml(newName);
					continue;
				}

				break;
			}
		}

		private static string ToXaml(string refName) {
			Debug.Assert(refName.EndsWith(".baml"));
			return refName.Substring(0, refName.Length - 5) + ".xaml";
		}
	}
}

```

`Confuser.Renamer/BAML/BAMLStringReference.cs`:

```cs
using System;
using System.Diagnostics;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.BAML {
	sealed class BAMLStringReference : IBAMLReference {
		readonly ModuleDef _refModule;
		readonly Instruction _instr;

		public BAMLStringReference(ModuleDef refModule, Instruction instr) {
			_refModule = refModule;
			_instr = instr;
		}

		public bool CanRename(ModuleDef moduleDef, string oldName, string newName) {
			if (moduleDef != _refModule) return true; // Not relevant for renaming.

			return _instr.OpCode.Code == Code.Ldstr;
		}

		public void Rename(ModuleDef moduleDef, string oldName, string newName) {
			if (moduleDef != _refModule) return;

			var value = (string)_instr.Operand;
			while (true) {
				if (value.EndsWith(oldName, StringComparison.OrdinalIgnoreCase)) {
					value = value.Substring(0, value.Length - oldName.Length) + newName;
					_instr.Operand = value;
				}
				else if (oldName.EndsWith(".baml", StringComparison.OrdinalIgnoreCase)) {
					oldName = ToXaml(oldName);
					newName = ToXaml(newName);
					continue;
				}

				break;
			}
		}

		private static string ToXaml(string refName) {
			Debug.Assert(refName.EndsWith(".baml", StringComparison.OrdinalIgnoreCase));
			return refName.Substring(0, refName.Length - 5) + ".xaml";
		}
	}
}

```

`Confuser.Renamer/BAML/BamlDocument.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Confuser.Renamer.BAML {
	internal class BamlDocument : List<BamlRecord> {
		public string DocumentName { get; set; }

		public string Signature { get; set; }
		public BamlVersion ReaderVersion { get; set; }
		public BamlVersion UpdaterVersion { get; set; }
		public BamlVersion WriterVersion { get; set; }

		public struct BamlVersion {
			public ushort Major;
			public ushort Minor;
		}
	}
}
```

`Confuser.Renamer/BAML/BamlElement.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal class BamlElement {
		public BamlElement Parent { get; private set; }
		public BamlRecord Header { get; private set; }
		public IList<BamlRecord> Body { get; private set; }
		public IList<BamlElement> Children { get; private set; }
		public BamlRecord Footer { get; private set; }

		// Type of this element
		public TypeDef Type { get; set; }
		// Attribute this element will be assigned to.
		public IDnlibDef Attribute { get; set; }

		static bool IsHeader(BamlRecord rec) {
			switch (rec.Type) {
				case BamlRecordType.ConstructorParametersStart:
				case BamlRecordType.DocumentStart:
				case BamlRecordType.ElementStart:
				case BamlRecordType.KeyElementStart:
				case BamlRecordType.NamedElementStart:
				case BamlRecordType.PropertyArrayStart:
				case BamlRecordType.PropertyComplexStart:
				case BamlRecordType.PropertyDictionaryStart:
				case BamlRecordType.PropertyListStart:
				case BamlRecordType.StaticResourceStart:
					return true;
			}
			return false;
		}

		static bool IsFooter(BamlRecord rec) {
			switch (rec.Type) {
				case BamlRecordType.ConstructorParametersEnd:
				case BamlRecordType.DocumentEnd:
				case BamlRecordType.ElementEnd:
				case BamlRecordType.KeyElementEnd:
				case BamlRecordType.PropertyArrayEnd:
				case BamlRecordType.PropertyComplexEnd:
				case BamlRecordType.PropertyDictionaryEnd:
				case BamlRecordType.PropertyListEnd:
				case BamlRecordType.StaticResourceEnd:
					return true;
			}
			return false;
		}

		static bool IsMatch(BamlRecord header, BamlRecord footer) {
			switch (header.Type) {
				case BamlRecordType.ConstructorParametersStart:
					return footer.Type == BamlRecordType.ConstructorParametersEnd;

				case BamlRecordType.DocumentStart:
					return footer.Type == BamlRecordType.DocumentEnd;

				case BamlRecordType.KeyElementStart:
					return footer.Type == BamlRecordType.KeyElementEnd;

				case BamlRecordType.PropertyArrayStart:
					return footer.Type == BamlRecordType.PropertyArrayEnd;

				case BamlRecordType.PropertyComplexStart:
					return footer.Type == BamlRecordType.PropertyComplexEnd;

				case BamlRecordType.PropertyDictionaryStart:
					return footer.Type == BamlRecordType.PropertyDictionaryEnd;

				case BamlRecordType.PropertyListStart:
					return footer.Type == BamlRecordType.PropertyListEnd;

				case BamlRecordType.StaticResourceStart:
					return footer.Type == BamlRecordType.StaticResourceEnd;

				case BamlRecordType.ElementStart:
				case BamlRecordType.NamedElementStart:
					return footer.Type == BamlRecordType.ElementEnd;
			}
			return false;
		}

		public static BamlElement Read(BamlDocument document) {
			Debug.Assert(document.Count > 0 && document[0].Type == BamlRecordType.DocumentStart);

			BamlElement current = null;
			var stack = new Stack<BamlElement>();

			for (int i = 0; i < document.Count; i++) {
				if (IsHeader(document[i])) {
					BamlElement prev = current;

					current = new BamlElement();
					current.Header = document[i];
					current.Body = new List<BamlRecord>();
					current.Children = new List<BamlElement>();

					if (prev != null) {
						prev.Children.Add(current);
						current.Parent = prev;
						stack.Push(prev);
					}
				}
				else if (IsFooter(document[i])) {
					if (current == null)
						throw new Exception("Unexpected footer.");

					while (!IsMatch(current.Header, document[i])) {
						// End record can be omited (sometimes).
						if (stack.Count > 0)
							current = stack.Pop();
					}
					current.Footer = document[i];
					if (stack.Count > 0)
						current = stack.Pop();
				}
				else
					current.Body.Add(document[i]);
			}
			Debug.Assert(stack.Count == 0);
			return current;
		}
	}
}
```

`Confuser.Renamer/BAML/BamlRW.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Confuser.Renamer.BAML {
	internal class BamlBinaryReader : BinaryReader {
		public BamlBinaryReader(Stream stream)
			: base(stream) { }

		public int ReadEncodedInt() {
			return Read7BitEncodedInt();
		}
	}

	internal class BamlBinaryWriter : BinaryWriter {
		public BamlBinaryWriter(Stream stream)
			: base(stream) { }

		public void WriteEncodedInt(int val) {
			Write7BitEncodedInt(val);
		}
	}

	internal class BamlReader {
		public static BamlDocument ReadDocument(Stream str) {
			var ret = new BamlDocument();
			var reader = new BamlBinaryReader(str);
			{
				var rdr = new BinaryReader(str, Encoding.Unicode);
				uint len = rdr.ReadUInt32();
				ret.Signature = new string(rdr.ReadChars((int)(len >> 1)));
				rdr.ReadBytes((int)(((len + 3) & ~3) - len));
			}
			if (ret.Signature != "MSBAML") throw new NotSupportedException();
			ret.ReaderVersion = new BamlDocument.BamlVersion { Major = reader.ReadUInt16(), Minor = reader.ReadUInt16() };
			ret.UpdaterVersion = new BamlDocument.BamlVersion { Major = reader.ReadUInt16(), Minor = reader.ReadUInt16() };
			ret.WriterVersion = new BamlDocument.BamlVersion { Major = reader.ReadUInt16(), Minor = reader.ReadUInt16() };
			if (ret.ReaderVersion.Major != 0 || ret.ReaderVersion.Minor != 0x60 ||
			    ret.UpdaterVersion.Major != 0 || ret.UpdaterVersion.Minor != 0x60 ||
			    ret.WriterVersion.Major != 0 || ret.WriterVersion.Minor != 0x60)
				throw new NotSupportedException();

			var recs = new Dictionary<long, BamlRecord>();
			while (str.Position < str.Length) {
				long pos = str.Position;
				var type = (BamlRecordType)reader.ReadByte();
				BamlRecord rec = null;
				switch (type) {
					case BamlRecordType.AssemblyInfo:
						rec = new AssemblyInfoRecord();
						break;
					case BamlRecordType.AttributeInfo:
						rec = new AttributeInfoRecord();
						break;
					case BamlRecordType.ConstructorParametersStart:
						rec = new ConstructorParametersStartRecord();
						break;
					case BamlRecordType.ConstructorParametersEnd:
						rec = new ConstructorParametersEndRecord();
						break;
					case BamlRecordType.ConstructorParameterType:
						rec = new ConstructorParameterTypeRecord();
						break;
					case BamlRecordType.ConnectionId:
						rec = new ConnectionIdRecord();
						break;
					case BamlRecordType.ContentProperty:
						rec = new ContentPropertyRecord();
						break;
					case BamlRecordType.DefAttribute:
						rec = new DefAttributeRecord();
						break;
					case BamlRecordType.DefAttributeKeyString:
						rec = new DefAttributeKeyStringRecord();
						break;
					case BamlRecordType.DefAttributeKeyType:
						rec = new DefAttributeKeyTypeRecord();
						break;
					case BamlRecordType.DeferableContentStart:
						rec = new DeferableContentStartRecord();
						break;
					case BamlRecordType.DocumentEnd:
						rec = new DocumentEndRecord();
						break;
					case BamlRecordType.DocumentStart:
						rec = new DocumentStartRecord();
						break;
					case BamlRecordType.ElementEnd:
						rec = new ElementEndRecord();
						break;
					case BamlRecordType.ElementStart:
						rec = new ElementStartRecord();
						break;
					case BamlRecordType.KeyElementEnd:
						rec = new KeyElementEndRecord();
						break;
					case BamlRecordType.KeyElementStart:
						rec = new KeyElementStartRecord();
						break;
					case BamlRecordType.LineNumberAndPosition:
						rec = new LineNumberAndPositionRecord();
						break;
					case BamlRecordType.LinePosition:
						rec = new LinePositionRecord();
						break;
					case BamlRecordType.LiteralContent:
						rec = new LiteralContentRecord();
						break;
					case BamlRecordType.NamedElementStart:
						rec = new NamedElementStartRecord();
						break;
					case BamlRecordType.OptimizedStaticResource:
						rec = new OptimizedStaticResourceRecord();
						break;
					case BamlRecordType.PIMapping:
						rec = new PIMappingRecord();
						break;
					case BamlRecordType.PresentationOptionsAttribute:
						rec = new PresentationOptionsAttributeRecord();
						break;
					case BamlRecordType.Property:
						rec = new PropertyRecord();
						break;
					case BamlRecordType.PropertyArrayEnd:
						rec = new PropertyArrayEndRecord();
						break;
					case BamlRecordType.PropertyArrayStart:
						rec = new PropertyArrayStartRecord();
						break;
					case BamlRecordType.PropertyComplexEnd:
						rec = new PropertyComplexEndRecord();
						break;
					case BamlRecordType.PropertyComplexStart:
						rec = new PropertyComplexStartRecord();
						break;
					case BamlRecordType.PropertyCustom:
						rec = new PropertyCustomRecord();
						break;
					case BamlRecordType.PropertyDictionaryEnd:
						rec = new PropertyDictionaryEndRecord();
						break;
					case BamlRecordType.PropertyDictionaryStart:
						rec = new PropertyDictionaryStartRecord();
						break;
					case BamlRecordType.PropertyListEnd:
						rec = new PropertyListEndRecord();
						break;
					case BamlRecordType.PropertyListStart:
						rec = new PropertyListStartRecord();
						break;
					case BamlRecordType.PropertyStringReference:
						rec = new PropertyStringReferenceRecord();
						break;
					case BamlRecordType.PropertyTypeReference:
						rec = new PropertyTypeReferenceRecord();
						break;
					case BamlRecordType.PropertyWithConverter:
						rec = new PropertyWithConverterRecord();
						break;
					case BamlRecordType.PropertyWithExtension:
						rec = new PropertyWithExtensionRecord();
						break;
					case BamlRecordType.PropertyWithStaticResourceId:
						rec = new PropertyWithStaticResourceIdRecord();
						break;
					case BamlRecordType.RoutedEvent:
						rec = new RoutedEventRecord();
						break;
					case BamlRecordType.StaticResourceEnd:
						rec = new StaticResourceEndRecord();
						break;
					case BamlRecordType.StaticResourceId:
						rec = new StaticResourceIdRecord();
						break;
					case BamlRecordType.StaticResourceStart:
						rec = new StaticResourceStartRecord();
						break;
					case BamlRecordType.StringInfo:
						rec = new StringInfoRecord();
						break;
					case BamlRecordType.Text:
						rec = new TextRecord();
						break;
					case BamlRecordType.TextWithConverter:
						rec = new TextWithConverterRecord();
						break;
					case BamlRecordType.TextWithId:
						rec = new TextWithIdRecord();
						break;
					case BamlRecordType.TypeInfo:
						rec = new TypeInfoRecord();
						break;
					case BamlRecordType.TypeSerializerInfo:
						rec = new TypeSerializerInfoRecord();
						break;
					case BamlRecordType.XmlnsProperty:
						rec = new XmlnsPropertyRecord();
						break;
					case BamlRecordType.XmlAttribute:
					case BamlRecordType.ProcessingInstruction:
					case BamlRecordType.LastRecordType:
					case BamlRecordType.EndAttributes:
					case BamlRecordType.DefTag:
					case BamlRecordType.ClrEvent:
					case BamlRecordType.Comment:
					default:
						throw new NotSupportedException();
				}
				rec.Position = pos;

				rec.Read(reader);
				ret.Add(rec);
				recs.Add(pos, rec);
			}
			for (int i = 0; i < ret.Count; i++) {
				var defer = ret[i] as IBamlDeferRecord;
				if (defer != null)
					defer.ReadDefer(ret, i, _ => recs[_]);
			}

			return ret;
		}
	}

	internal class BamlWriter {
		public static void WriteDocument(BamlDocument doc, Stream str) {
			var writer = new BamlBinaryWriter(str);
			{
				var wtr = new BinaryWriter(str, Encoding.Unicode);
				int len = doc.Signature.Length * 2;
				wtr.Write(len);
				wtr.Write(doc.Signature.ToCharArray());
				wtr.Write(new byte[((len + 3) & ~3) - len]);
			}
			writer.Write(doc.ReaderVersion.Major);
			writer.Write(doc.ReaderVersion.Minor);
			writer.Write(doc.UpdaterVersion.Major);
			writer.Write(doc.UpdaterVersion.Minor);
			writer.Write(doc.WriterVersion.Major);
			writer.Write(doc.WriterVersion.Minor);

			var defers = new List<int>();
			for (int i = 0; i < doc.Count; i++) {
				BamlRecord rec = doc[i];
				rec.Position = str.Position;
				writer.Write((byte)rec.Type);
				rec.Write(writer);
				if (rec is IBamlDeferRecord) defers.Add(i);
			}
			foreach (int i in defers)
				(doc[i] as IBamlDeferRecord).WriteDefer(doc, i, writer);
		}
	}
}
```

`Confuser.Renamer/BAML/BamlRecords.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;

namespace Confuser.Renamer.BAML {
	internal enum BamlRecordType : byte {
		ClrEvent = 0x13,
		Comment = 0x17,
		AssemblyInfo = 0x1c,
		AttributeInfo = 0x1f,
		ConstructorParametersStart = 0x2a,
		ConstructorParametersEnd = 0x2b,
		ConstructorParameterType = 0x2c,
		ConnectionId = 0x2d,
		ContentProperty = 0x2e,
		DefAttribute = 0x19,
		DefAttributeKeyString = 0x26,
		DefAttributeKeyType = 0x27,
		DeferableContentStart = 0x25,
		DefTag = 0x18,
		DocumentEnd = 0x2,
		DocumentStart = 0x1,
		ElementEnd = 0x4,
		ElementStart = 0x3,
		EndAttributes = 0x1a,
		KeyElementEnd = 0x29,
		KeyElementStart = 0x28,
		LastRecordType = 0x39,
		LineNumberAndPosition = 0x35,
		LinePosition = 0x36,
		LiteralContent = 0xf,
		NamedElementStart = 0x2f,
		OptimizedStaticResource = 0x37,
		PIMapping = 0x1b,
		PresentationOptionsAttribute = 0x34,
		ProcessingInstruction = 0x16,
		Property = 0x5,
		PropertyArrayEnd = 0xa,
		PropertyArrayStart = 0x9,
		PropertyComplexEnd = 0x8,
		PropertyComplexStart = 0x7,
		PropertyCustom = 0x6,
		PropertyDictionaryEnd = 0xe,
		PropertyDictionaryStart = 0xd,
		PropertyListEnd = 0xc,
		PropertyListStart = 0xb,
		PropertyStringReference = 0x21,
		PropertyTypeReference = 0x22,
		PropertyWithConverter = 0x24,
		PropertyWithExtension = 0x23,
		PropertyWithStaticResourceId = 0x38,
		RoutedEvent = 0x12,
		StaticResourceEnd = 0x31,
		StaticResourceId = 0x32,
		StaticResourceStart = 0x30,
		StringInfo = 0x20,
		Text = 0x10,
		TextWithConverter = 0x11,
		TextWithId = 0x33,
		TypeInfo = 0x1d,
		TypeSerializerInfo = 0x1e,
		XmlAttribute = 0x15,
		XmlnsProperty = 0x14
	}

	internal abstract class BamlRecord {
		public abstract BamlRecordType Type { get; }
		public long Position { get; internal set; }
		public abstract void Read(BamlBinaryReader reader);
		public abstract void Write(BamlBinaryWriter writer);
	}

	internal abstract class SizedBamlRecord : BamlRecord {
		public override void Read(BamlBinaryReader reader) {
			long pos = reader.BaseStream.Position;
			int size = reader.ReadEncodedInt();

			ReadData(reader, size - (int)(reader.BaseStream.Position - pos));
			Debug.Assert(reader.BaseStream.Position - pos == size);
		}

		int SizeofEncodedInt(int val) {
			if ((val & ~0x7F) == 0) {
				return 1;
			}
			if ((val & ~0x3FFF) == 0) {
				return 2;
			}
			if ((val & ~0x1FFFFF) == 0) {
				return 3;
			}
			if ((val & ~0xFFFFFFF) == 0) {
				return 4;
			}
			return 5;
		}

		public override void Write(BamlBinaryWriter writer) {
			long pos = writer.BaseStream.Position;
			WriteData(writer);
			var size = (int)(writer.BaseStream.Position - pos);
			size = SizeofEncodedInt(SizeofEncodedInt(size) + size) + size;
			writer.BaseStream.Position = pos;
			writer.WriteEncodedInt(size);
			WriteData(writer);
		}

		protected abstract void ReadData(BamlBinaryReader reader, int size);
		protected abstract void WriteData(BamlBinaryWriter writer);
	}

	internal interface IBamlDeferRecord {
		BamlRecord Record { get; set; }
		void ReadDefer(BamlDocument doc, int index, Func<long, BamlRecord> resolve);
		void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr);
	}

	internal class XmlnsPropertyRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.XmlnsProperty; }
		}

		public string Prefix { get; set; }
		public string XmlNamespace { get; set; }
		public ushort[] AssemblyIds { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Prefix = reader.ReadString();
			XmlNamespace = reader.ReadString();
			AssemblyIds = new ushort[reader.ReadUInt16()];
			for (int i = 0; i < AssemblyIds.Length; i++)
				AssemblyIds[i] = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Prefix);
			writer.Write(XmlNamespace);
			writer.Write((ushort)AssemblyIds.Length);
			foreach (ushort i in AssemblyIds)
				writer.Write(i);
		}
	}

	internal class PresentationOptionsAttributeRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PresentationOptionsAttribute; }
		}

		public string Value { get; set; }
		public ushort NameId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Value = reader.ReadString();
			NameId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Value);
			writer.Write(NameId);
		}
	}

	internal class PIMappingRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PIMapping; }
		}

		public string XmlNamespace { get; set; }
		public string ClrNamespace { get; set; }
		public ushort AssemblyId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			XmlNamespace = reader.ReadString();
			ClrNamespace = reader.ReadString();
			AssemblyId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(XmlNamespace);
			writer.Write(ClrNamespace);
			writer.Write(AssemblyId);
		}
	}

	internal class AssemblyInfoRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.AssemblyInfo; }
		}

		public ushort AssemblyId { get; set; }
		public string AssemblyFullName { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			AssemblyId = reader.ReadUInt16();
			AssemblyFullName = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(AssemblyId);
			writer.Write(AssemblyFullName);
		}
	}

	internal class PropertyRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.Property; }
		}

		public ushort AttributeId { get; set; }
		public string Value { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			AttributeId = reader.ReadUInt16();
			Value = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			writer.Write(Value);
		}
	}

	internal class PropertyWithConverterRecord : PropertyRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyWithConverter; }
		}

		public ushort ConverterTypeId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			base.ReadData(reader, size);
			ConverterTypeId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			base.WriteData(writer);
			writer.Write(ConverterTypeId);
		}
	}

	internal class PropertyCustomRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyCustom; }
		}

		public ushort AttributeId { get; set; }
		public ushort SerializerTypeId { get; set; }
		public byte[] Data { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			long pos = reader.BaseStream.Position;
			AttributeId = reader.ReadUInt16();
			SerializerTypeId = reader.ReadUInt16();
			Data = reader.ReadBytes(size - (int)(reader.BaseStream.Position - pos));
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			writer.Write(SerializerTypeId);
			writer.Write(Data);
		}
	}

	internal class DefAttributeRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.DefAttribute; }
		}

		public string Value { get; set; }
		public ushort NameId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Value = reader.ReadString();
			NameId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Value);
			writer.Write(NameId);
		}
	}

	internal class DefAttributeKeyStringRecord : SizedBamlRecord, IBamlDeferRecord {
		internal uint pos = 0xffffffff;

		public override BamlRecordType Type {
			get { return BamlRecordType.DefAttributeKeyString; }
		}

		public ushort ValueId { get; set; }
		public bool Shared { get; set; }
		public bool SharedSet { get; set; }

		public BamlRecord Record { get; set; }

		public void ReadDefer(BamlDocument doc, int index, Func<long, BamlRecord> resolve) {
			bool keys = true;
			do {
				switch (doc[index].Type) {
					case BamlRecordType.DefAttributeKeyString:
					case BamlRecordType.DefAttributeKeyType:
					case BamlRecordType.OptimizedStaticResource:
						keys = true;
						break;
					case BamlRecordType.StaticResourceStart:
						NavigateTree(doc, BamlRecordType.StaticResourceStart, BamlRecordType.StaticResourceEnd, ref index);
						keys = true;
						break;
					case BamlRecordType.KeyElementStart:
						NavigateTree(doc, BamlRecordType.KeyElementStart, BamlRecordType.KeyElementEnd, ref index);
						keys = true;
						break;
					default:
						keys = false;
						index--;
						break;
				}
				index++;
			} while (keys);
			Record = resolve(doc[index].Position + pos);
		}

		public void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr) {
			bool keys = true;
			do {
				switch (doc[index].Type) {
					case BamlRecordType.DefAttributeKeyString:
					case BamlRecordType.DefAttributeKeyType:
					case BamlRecordType.OptimizedStaticResource:
						keys = true;
						break;
					case BamlRecordType.StaticResourceStart:
						NavigateTree(doc, BamlRecordType.StaticResourceStart, BamlRecordType.StaticResourceEnd, ref index);
						keys = true;
						break;
					case BamlRecordType.KeyElementStart:
						NavigateTree(doc, BamlRecordType.KeyElementStart, BamlRecordType.KeyElementEnd, ref index);
						keys = true;
						break;
					default:
						keys = false;
						index--;
						break;
				}
				index++;
			} while (keys);
			wtr.BaseStream.Seek(pos, SeekOrigin.Begin);
			wtr.Write((uint)(Record.Position - doc[index].Position));
		}

		protected override void ReadData(BamlBinaryReader reader, int size) {
			ValueId = reader.ReadUInt16();
			pos = reader.ReadUInt32();
			Shared = reader.ReadBoolean();
			SharedSet = reader.ReadBoolean();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(ValueId);
			pos = (uint)writer.BaseStream.Position;
			writer.Write((uint)0);
			writer.Write(Shared);
			writer.Write(SharedSet);
		}

		static void NavigateTree(BamlDocument doc, BamlRecordType start, BamlRecordType end, ref int index) {
			index++;
			while (true) //Assume there alway is a end
			{
				if (doc[index].Type == start)
					NavigateTree(doc, start, end, ref index);
				else if (doc[index].Type == end)
					return;
				index++;
			}
		}
	}

	internal class TypeInfoRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.TypeInfo; }
		}

		public ushort TypeId { get; set; }
		public ushort AssemblyId { get; set; }
		public string TypeFullName { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			TypeId = reader.ReadUInt16();
			AssemblyId = reader.ReadUInt16();
			TypeFullName = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(TypeId);
			writer.Write(AssemblyId);
			writer.Write(TypeFullName);
		}
	}

	internal class TypeSerializerInfoRecord : TypeInfoRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.TypeSerializerInfo; }
		}

		public ushort SerializerTypeId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			base.ReadData(reader, size);
			SerializerTypeId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			base.WriteData(writer);
			writer.Write(SerializerTypeId);
		}
	}

	internal class AttributeInfoRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.AttributeInfo; }
		}

		public ushort AttributeId { get; set; }
		public ushort OwnerTypeId { get; set; }
		public byte AttributeUsage { get; set; }
		public string Name { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			AttributeId = reader.ReadUInt16();
			OwnerTypeId = reader.ReadUInt16();
			AttributeUsage = reader.ReadByte();
			Name = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			writer.Write(OwnerTypeId);
			writer.Write(AttributeUsage);
			writer.Write(Name);
		}
	}

	internal class StringInfoRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.StringInfo; }
		}

		public ushort StringId { get; set; }
		public string Value { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			StringId = reader.ReadUInt16();
			Value = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(StringId);
			writer.Write(Value);
		}
	}

	internal class TextRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.Text; }
		}

		public string Value { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Value = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Value);
		}
	}

	internal class TextWithConverterRecord : TextRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.TextWithConverter; }
		}

		public ushort ConverterTypeId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			base.ReadData(reader, size);
			ConverterTypeId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			base.WriteData(writer);
			writer.Write(ConverterTypeId);
		}
	}

	internal class TextWithIdRecord : TextRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.TextWithId; }
		}

		public ushort ValueId { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			ValueId = reader.ReadUInt16();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(ValueId);
		}
	}

	internal class LiteralContentRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.LiteralContent; }
		}

		public string Value { get; set; }
		public uint Reserved0 { get; set; }
		public uint Reserved1 { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			Value = reader.ReadString();
			Reserved0 = reader.ReadUInt32();
			Reserved1 = reader.ReadUInt32();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(Value);
			writer.Write(Reserved0);
			writer.Write(Reserved1);
		}
	}

	internal class RoutedEventRecord : SizedBamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.RoutedEvent; }
		}

		public string Value { get; set; }
		public ushort AttributeId { get; set; }
		public uint Reserved1 { get; set; }

		protected override void ReadData(BamlBinaryReader reader, int size) {
			AttributeId = reader.ReadUInt16();
			Value = reader.ReadString();
		}

		protected override void WriteData(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			writer.Write(Value);
		}
	}

	internal class DocumentStartRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.DocumentStart; }
		}

		public bool LoadAsync { get; set; }
		public uint MaxAsyncRecords { get; set; }
		public bool DebugBaml { get; set; }

		public override void Read(BamlBinaryReader reader) {
			LoadAsync = reader.ReadBoolean();
			MaxAsyncRecords = reader.ReadUInt32();
			DebugBaml = reader.ReadBoolean();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(LoadAsync);
			writer.Write(MaxAsyncRecords);
			writer.Write(DebugBaml);
		}
	}

	internal class DocumentEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.DocumentEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ElementStartRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ElementStart; }
		}

		public ushort TypeId { get; set; }
		public byte Flags { get; set; }

		public override void Read(BamlBinaryReader reader) {
			TypeId = reader.ReadUInt16();
			Flags = reader.ReadByte();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(TypeId);
			writer.Write(Flags);
		}
	}

	internal class ElementEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ElementEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class KeyElementStartRecord : DefAttributeKeyTypeRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.KeyElementStart; }
		}
	}

	internal class KeyElementEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.KeyElementEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ConnectionIdRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ConnectionId; }
		}

		public uint ConnectionId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			ConnectionId = reader.ReadUInt32();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(ConnectionId);
		}
	}

	internal class PropertyWithExtensionRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyWithExtension; }
		}

		public ushort AttributeId { get; set; }
		public ushort Flags { get; set; }
		public ushort ValueId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			AttributeId = reader.ReadUInt16();
			Flags = reader.ReadUInt16();
			ValueId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			writer.Write(Flags);
			writer.Write(ValueId);
		}
	}

	internal class PropertyTypeReferenceRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyTypeReference; }
		}

		public ushort TypeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			base.Read(reader);
			TypeId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			base.Write(writer);
			writer.Write(TypeId);
		}
	}

	internal class PropertyStringReferenceRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyStringReference; }
		}

		public ushort StringId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			base.Read(reader);
			StringId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			base.Write(writer);
			writer.Write(StringId);
		}
	}

	internal class PropertyWithStaticResourceIdRecord : StaticResourceIdRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyWithStaticResourceId; }
		}

		public ushort AttributeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			AttributeId = reader.ReadUInt16();
			base.Read(reader);
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
			base.Write(writer);
		}
	}

	internal class ContentPropertyRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ContentProperty; }
		}

		public ushort AttributeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			AttributeId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
		}
	}

	internal class DefAttributeKeyTypeRecord : ElementStartRecord, IBamlDeferRecord {
		internal uint pos = 0xffffffff;

		public override BamlRecordType Type {
			get { return BamlRecordType.DefAttributeKeyType; }
		}

		public bool Shared { get; set; }
		public bool SharedSet { get; set; }

		public BamlRecord Record { get; set; }

		public void ReadDefer(BamlDocument doc, int index, Func<long, BamlRecord> resolve) {
			bool keys = true;
			do {
				switch (doc[index].Type) {
					case BamlRecordType.DefAttributeKeyString:
					case BamlRecordType.DefAttributeKeyType:
					case BamlRecordType.OptimizedStaticResource:
						keys = true;
						break;
					case BamlRecordType.StaticResourceStart:
						NavigateTree(doc, BamlRecordType.StaticResourceStart, BamlRecordType.StaticResourceEnd, ref index);
						keys = true;
						break;
					case BamlRecordType.KeyElementStart:
						NavigateTree(doc, BamlRecordType.KeyElementStart, BamlRecordType.KeyElementEnd, ref index);
						keys = true;
						break;
					default:
						keys = false;
						index--;
						break;
				}
				index++;
			} while (keys);
			Record = resolve(doc[index].Position + pos);
		}

		public void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr) {
			bool keys = true;
			do {
				switch (doc[index].Type) {
					case BamlRecordType.DefAttributeKeyString:
					case BamlRecordType.DefAttributeKeyType:
					case BamlRecordType.OptimizedStaticResource:
						keys = true;
						break;
					case BamlRecordType.StaticResourceStart:
						NavigateTree(doc, BamlRecordType.StaticResourceStart, BamlRecordType.StaticResourceEnd, ref index);
						keys = true;
						break;
					case BamlRecordType.KeyElementStart:
						NavigateTree(doc, BamlRecordType.KeyElementStart, BamlRecordType.KeyElementEnd, ref index);
						keys = true;
						break;
					default:
						keys = false;
						index--;
						break;
				}
				index++;
			} while (keys);
			wtr.BaseStream.Seek(pos, SeekOrigin.Begin);
			wtr.Write((uint)(Record.Position - doc[index].Position));
		}

		public override void Read(BamlBinaryReader reader) {
			base.Read(reader);
			pos = reader.ReadUInt32();
			Shared = reader.ReadBoolean();
			SharedSet = reader.ReadBoolean();
		}

		public override void Write(BamlBinaryWriter writer) {
			base.Write(writer);
			pos = (uint)writer.BaseStream.Position;
			writer.Write((uint)0);
			writer.Write(Shared);
			writer.Write(SharedSet);
		}

		static void NavigateTree(BamlDocument doc, BamlRecordType start, BamlRecordType end, ref int index) {
			index++;
			while (true) {
				if (doc[index].Type == start)
					NavigateTree(doc, start, end, ref index);
				else if (doc[index].Type == end)
					return;
				index++;
			}
		}
	}

	internal class PropertyListStartRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyListStart; }
		}
	}

	internal class PropertyListEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyListEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class PropertyDictionaryStartRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyDictionaryStart; }
		}
	}

	internal class PropertyDictionaryEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyDictionaryEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class PropertyArrayStartRecord : PropertyComplexStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyArrayStart; }
		}
	}

	internal class PropertyArrayEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyArrayEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class PropertyComplexStartRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyComplexStart; }
		}

		public ushort AttributeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			AttributeId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(AttributeId);
		}
	}

	internal class PropertyComplexEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.PropertyComplexEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ConstructorParametersStartRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ConstructorParametersStart; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ConstructorParametersEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ConstructorParametersEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class ConstructorParameterTypeRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.ConstructorParameterType; }
		}

		public ushort TypeId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			TypeId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(TypeId);
		}
	}

	internal class DeferableContentStartRecord : BamlRecord, IBamlDeferRecord {
		long pos;
		internal uint size = 0xffffffff;

		public override BamlRecordType Type {
			get { return BamlRecordType.DeferableContentStart; }
		}

		public BamlRecord Record { get; set; }

		public void ReadDefer(BamlDocument doc, int index, Func<long, BamlRecord> resolve) {
			Record = resolve(pos + size);
		}

		public void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr) {
			wtr.BaseStream.Seek(pos, SeekOrigin.Begin);
			wtr.Write((uint)(Record.Position - (pos + 4)));
		}

		public override void Read(BamlBinaryReader reader) {
			size = reader.ReadUInt32();
			pos = reader.BaseStream.Position;
		}

		public override void Write(BamlBinaryWriter writer) {
			pos = writer.BaseStream.Position;
			writer.Write((uint)0);
		}
	}

	internal class StaticResourceStartRecord : ElementStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.StaticResourceStart; }
		}
	}

	internal class StaticResourceEndRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.StaticResourceEnd; }
		}

		public override void Read(BamlBinaryReader reader) { }
		public override void Write(BamlBinaryWriter writer) { }
	}

	internal class StaticResourceIdRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.StaticResourceId; }
		}

		public ushort StaticResourceId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			StaticResourceId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(StaticResourceId);
		}
	}

	internal class OptimizedStaticResourceRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.OptimizedStaticResource; }
		}

		public byte Flags { get; set; }
		public ushort ValueId { get; set; }

		public override void Read(BamlBinaryReader reader) {
			Flags = reader.ReadByte();
			ValueId = reader.ReadUInt16();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(Flags);
			writer.Write(ValueId);
		}
	}

	internal class LineNumberAndPositionRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.LineNumberAndPosition; }
		}

		public uint LineNumber { get; set; }
		public uint LinePosition { get; set; }

		public override void Read(BamlBinaryReader reader) {
			LineNumber = reader.ReadUInt32();
			LinePosition = reader.ReadUInt32();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(LineNumber);
			writer.Write(LinePosition);
		}
	}

	internal class LinePositionRecord : BamlRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.LinePosition; }
		}

		public uint LinePosition { get; set; }

		public override void Read(BamlBinaryReader reader) {
			LinePosition = reader.ReadUInt32();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(LinePosition);
		}
	}

	internal class NamedElementStartRecord : ElementStartRecord {
		public override BamlRecordType Type {
			get { return BamlRecordType.NamedElementStart; }
		}

		public string RuntimeName { get; set; }

		public override void Read(BamlBinaryReader reader) {
			TypeId = reader.ReadUInt16();
			RuntimeName = reader.ReadString();
		}

		public override void Write(BamlBinaryWriter writer) {
			writer.Write(TypeId);
			if (RuntimeName != null) {
				writer.Write(RuntimeName);
			}
		}
	}
}

```

`Confuser.Renamer/BAML/IBAMLReference.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal interface IBAMLReference {
		bool CanRename(ModuleDef moduleDef, string oldName, string newName);
		void Rename(ModuleDef moduleDef, string oldName, string newName);
	}
}

```

`Confuser.Renamer/BAML/IKnownThings.cs`:

```cs
using System;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal enum KnownTypes : short {
		Unknown = 0,
		AccessText,
		AdornedElementPlaceholder,
		Adorner,
		AdornerDecorator,
		AdornerLayer,
		AffineTransform3D,
		AmbientLight,
		AnchoredBlock,
		Animatable,
		AnimationClock,
		AnimationTimeline,
		Application,
		ArcSegment,
		ArrayExtension,
		AxisAngleRotation3D,
		BaseIListConverter,
		BeginStoryboard,
		BevelBitmapEffect,
		BezierSegment,
		Binding,
		BindingBase,
		BindingExpression,
		BindingExpressionBase,
		BindingListCollectionView,
		BitmapDecoder,
		BitmapEffect,
		BitmapEffectCollection,
		BitmapEffectGroup,
		BitmapEffectInput,
		BitmapEncoder,
		BitmapFrame,
		BitmapImage,
		BitmapMetadata,
		BitmapPalette,
		BitmapSource,
		Block,
		BlockUIContainer,
		BlurBitmapEffect,
		BmpBitmapDecoder,
		BmpBitmapEncoder,
		Bold,
		BoolIListConverter,
		Boolean,
		BooleanAnimationBase,
		BooleanAnimationUsingKeyFrames,
		BooleanConverter,
		BooleanKeyFrame,
		BooleanKeyFrameCollection,
		BooleanToVisibilityConverter,
		Border,
		BorderGapMaskConverter,
		Brush,
		BrushConverter,
		BulletDecorator,
		Button,
		ButtonBase,
		Byte,
		ByteAnimation,
		ByteAnimationBase,
		ByteAnimationUsingKeyFrames,
		ByteConverter,
		ByteKeyFrame,
		ByteKeyFrameCollection,
		CachedBitmap,
		Camera,
		Canvas,
		Char,
		CharAnimationBase,
		CharAnimationUsingKeyFrames,
		CharConverter,
		CharIListConverter,
		CharKeyFrame,
		CharKeyFrameCollection,
		CheckBox,
		Clock,
		ClockController,
		ClockGroup,
		CollectionContainer,
		CollectionView,
		CollectionViewSource,
		Color,
		ColorAnimation,
		ColorAnimationBase,
		ColorAnimationUsingKeyFrames,
		ColorConvertedBitmap,
		ColorConvertedBitmapExtension,
		ColorConverter,
		ColorKeyFrame,
		ColorKeyFrameCollection,
		ColumnDefinition,
		CombinedGeometry,
		ComboBox,
		ComboBoxItem,
		CommandConverter,
		ComponentResourceKey,
		ComponentResourceKeyConverter,
		CompositionTarget,
		Condition,
		ContainerVisual,
		ContentControl,
		ContentElement,
		ContentPresenter,
		ContentPropertyAttribute,
		ContentWrapperAttribute,
		ContextMenu,
		ContextMenuService,
		Control,
		ControlTemplate,
		ControllableStoryboardAction,
		CornerRadius,
		CornerRadiusConverter,
		CroppedBitmap,
		CultureInfo,
		CultureInfoConverter,
		CultureInfoIetfLanguageTagConverter,
		Cursor,
		CursorConverter,
		DashStyle,
		DataChangedEventManager,
		DataTemplate,
		DataTemplateKey,
		DataTrigger,
		DateTime,
		DateTimeConverter,
		DateTimeConverter2,
		Decimal,
		DecimalAnimation,
		DecimalAnimationBase,
		DecimalAnimationUsingKeyFrames,
		DecimalConverter,
		DecimalKeyFrame,
		DecimalKeyFrameCollection,
		Decorator,
		DefinitionBase,
		DependencyObject,
		DependencyProperty,
		DependencyPropertyConverter,
		DialogResultConverter,
		DiffuseMaterial,
		DirectionalLight,
		DiscreteBooleanKeyFrame,
		DiscreteByteKeyFrame,
		DiscreteCharKeyFrame,
		DiscreteColorKeyFrame,
		DiscreteDecimalKeyFrame,
		DiscreteDoubleKeyFrame,
		DiscreteInt16KeyFrame,
		DiscreteInt32KeyFrame,
		DiscreteInt64KeyFrame,
		DiscreteMatrixKeyFrame,
		DiscreteObjectKeyFrame,
		DiscretePoint3DKeyFrame,
		DiscretePointKeyFrame,
		DiscreteQuaternionKeyFrame,
		DiscreteRectKeyFrame,
		DiscreteRotation3DKeyFrame,
		DiscreteSingleKeyFrame,
		DiscreteSizeKeyFrame,
		DiscreteStringKeyFrame,
		DiscreteThicknessKeyFrame,
		DiscreteVector3DKeyFrame,
		DiscreteVectorKeyFrame,
		DockPanel,
		DocumentPageView,
		DocumentReference,
		DocumentViewer,
		DocumentViewerBase,
		Double,
		DoubleAnimation,
		DoubleAnimationBase,
		DoubleAnimationUsingKeyFrames,
		DoubleAnimationUsingPath,
		DoubleCollection,
		DoubleCollectionConverter,
		DoubleConverter,
		DoubleIListConverter,
		DoubleKeyFrame,
		DoubleKeyFrameCollection,
		Drawing,
		DrawingBrush,
		DrawingCollection,
		DrawingContext,
		DrawingGroup,
		DrawingImage,
		DrawingVisual,
		DropShadowBitmapEffect,
		Duration,
		DurationConverter,
		DynamicResourceExtension,
		DynamicResourceExtensionConverter,
		Ellipse,
		EllipseGeometry,
		EmbossBitmapEffect,
		EmissiveMaterial,
		EnumConverter,
		EventManager,
		EventSetter,
		EventTrigger,
		Expander,
		Expression,
		ExpressionConverter,
		Figure,
		FigureLength,
		FigureLengthConverter,
		FixedDocument,
		FixedDocumentSequence,
		FixedPage,
		Floater,
		FlowDocument,
		FlowDocumentPageViewer,
		FlowDocumentReader,
		FlowDocumentScrollViewer,
		FocusManager,
		FontFamily,
		FontFamilyConverter,
		FontSizeConverter,
		FontStretch,
		FontStretchConverter,
		FontStyle,
		FontStyleConverter,
		FontWeight,
		FontWeightConverter,
		FormatConvertedBitmap,
		Frame,
		FrameworkContentElement,
		FrameworkElement,
		FrameworkElementFactory,
		FrameworkPropertyMetadata,
		FrameworkPropertyMetadataOptions,
		FrameworkRichTextComposition,
		FrameworkTemplate,
		FrameworkTextComposition,
		Freezable,
		GeneralTransform,
		GeneralTransformCollection,
		GeneralTransformGroup,
		Geometry,
		Geometry3D,
		GeometryCollection,
		GeometryConverter,
		GeometryDrawing,
		GeometryGroup,
		GeometryModel3D,
		GestureRecognizer,
		GifBitmapDecoder,
		GifBitmapEncoder,
		GlyphRun,
		GlyphRunDrawing,
		GlyphTypeface,
		Glyphs,
		GradientBrush,
		GradientStop,
		GradientStopCollection,
		Grid,
		GridLength,
		GridLengthConverter,
		GridSplitter,
		GridView,
		GridViewColumn,
		GridViewColumnHeader,
		GridViewHeaderRowPresenter,
		GridViewRowPresenter,
		GridViewRowPresenterBase,
		GroupBox,
		GroupItem,
		Guid,
		GuidConverter,
		GuidelineSet,
		HeaderedContentControl,
		HeaderedItemsControl,
		HierarchicalDataTemplate,
		HostVisual,
		Hyperlink,
		IAddChild,
		IAddChildInternal,
		ICommand,
		IComponentConnector,
		INameScope,
		IStyleConnector,
		IconBitmapDecoder,
		Image,
		ImageBrush,
		ImageDrawing,
		ImageMetadata,
		ImageSource,
		ImageSourceConverter,
		InPlaceBitmapMetadataWriter,
		InkCanvas,
		InkPresenter,
		Inline,
		InlineCollection,
		InlineUIContainer,
		InputBinding,
		InputDevice,
		InputLanguageManager,
		InputManager,
		InputMethod,
		InputScope,
		InputScopeConverter,
		InputScopeName,
		InputScopeNameConverter,
		Int16,
		Int16Animation,
		Int16AnimationBase,
		Int16AnimationUsingKeyFrames,
		Int16Converter,
		Int16KeyFrame,
		Int16KeyFrameCollection,
		Int32,
		Int32Animation,
		Int32AnimationBase,
		Int32AnimationUsingKeyFrames,
		Int32Collection,
		Int32CollectionConverter,
		Int32Converter,
		Int32KeyFrame,
		Int32KeyFrameCollection,
		Int32Rect,
		Int32RectConverter,
		Int64,
		Int64Animation,
		Int64AnimationBase,
		Int64AnimationUsingKeyFrames,
		Int64Converter,
		Int64KeyFrame,
		Int64KeyFrameCollection,
		Italic,
		ItemCollection,
		ItemsControl,
		ItemsPanelTemplate,
		ItemsPresenter,
		JournalEntry,
		JournalEntryListConverter,
		JournalEntryUnifiedViewConverter,
		JpegBitmapDecoder,
		JpegBitmapEncoder,
		KeyBinding,
		KeyConverter,
		KeyGesture,
		KeyGestureConverter,
		KeySpline,
		KeySplineConverter,
		KeyTime,
		KeyTimeConverter,
		KeyboardDevice,
		Label,
		LateBoundBitmapDecoder,
		LengthConverter,
		Light,
		Line,
		LineBreak,
		LineGeometry,
		LineSegment,
		LinearByteKeyFrame,
		LinearColorKeyFrame,
		LinearDecimalKeyFrame,
		LinearDoubleKeyFrame,
		LinearGradientBrush,
		LinearInt16KeyFrame,
		LinearInt32KeyFrame,
		LinearInt64KeyFrame,
		LinearPoint3DKeyFrame,
		LinearPointKeyFrame,
		LinearQuaternionKeyFrame,
		LinearRectKeyFrame,
		LinearRotation3DKeyFrame,
		LinearSingleKeyFrame,
		LinearSizeKeyFrame,
		LinearThicknessKeyFrame,
		LinearVector3DKeyFrame,
		LinearVectorKeyFrame,
		List,
		ListBox,
		ListBoxItem,
		ListCollectionView,
		ListItem,
		ListView,
		ListViewItem,
		Localization,
		LostFocusEventManager,
		MarkupExtension,
		Material,
		MaterialCollection,
		MaterialGroup,
		Matrix,
		Matrix3D,
		Matrix3DConverter,
		MatrixAnimationBase,
		MatrixAnimationUsingKeyFrames,
		MatrixAnimationUsingPath,
		MatrixCamera,
		MatrixConverter,
		MatrixKeyFrame,
		MatrixKeyFrameCollection,
		MatrixTransform,
		MatrixTransform3D,
		MediaClock,
		MediaElement,
		MediaPlayer,
		MediaTimeline,
		Menu,
		MenuBase,
		MenuItem,
		MenuScrollingVisibilityConverter,
		MeshGeometry3D,
		Model3D,
		Model3DCollection,
		Model3DGroup,
		ModelVisual3D,
		ModifierKeysConverter,
		MouseActionConverter,
		MouseBinding,
		MouseDevice,
		MouseGesture,
		MouseGestureConverter,
		MultiBinding,
		MultiBindingExpression,
		MultiDataTrigger,
		MultiTrigger,
		NameScope,
		NavigationWindow,
		NullExtension,
		NullableBoolConverter,
		NullableConverter,
		NumberSubstitution,
		Object,
		ObjectAnimationBase,
		ObjectAnimationUsingKeyFrames,
		ObjectDataProvider,
		ObjectKeyFrame,
		ObjectKeyFrameCollection,
		OrthographicCamera,
		OuterGlowBitmapEffect,
		Page,
		PageContent,
		PageFunctionBase,
		Panel,
		Paragraph,
		ParallelTimeline,
		ParserContext,
		PasswordBox,
		Path,
		PathFigure,
		PathFigureCollection,
		PathFigureCollectionConverter,
		PathGeometry,
		PathSegment,
		PathSegmentCollection,
		PauseStoryboard,
		Pen,
		PerspectiveCamera,
		PixelFormat,
		PixelFormatConverter,
		PngBitmapDecoder,
		PngBitmapEncoder,
		Point,
		Point3D,
		Point3DAnimation,
		Point3DAnimationBase,
		Point3DAnimationUsingKeyFrames,
		Point3DCollection,
		Point3DCollectionConverter,
		Point3DConverter,
		Point3DKeyFrame,
		Point3DKeyFrameCollection,
		Point4D,
		Point4DConverter,
		PointAnimation,
		PointAnimationBase,
		PointAnimationUsingKeyFrames,
		PointAnimationUsingPath,
		PointCollection,
		PointCollectionConverter,
		PointConverter,
		PointIListConverter,
		PointKeyFrame,
		PointKeyFrameCollection,
		PointLight,
		PointLightBase,
		PolyBezierSegment,
		PolyLineSegment,
		PolyQuadraticBezierSegment,
		Polygon,
		Polyline,
		Popup,
		PresentationSource,
		PriorityBinding,
		PriorityBindingExpression,
		ProgressBar,
		ProjectionCamera,
		PropertyPath,
		PropertyPathConverter,
		QuadraticBezierSegment,
		Quaternion,
		QuaternionAnimation,
		QuaternionAnimationBase,
		QuaternionAnimationUsingKeyFrames,
		QuaternionConverter,
		QuaternionKeyFrame,
		QuaternionKeyFrameCollection,
		QuaternionRotation3D,
		RadialGradientBrush,
		RadioButton,
		RangeBase,
		Rect,
		Rect3D,
		Rect3DConverter,
		RectAnimation,
		RectAnimationBase,
		RectAnimationUsingKeyFrames,
		RectConverter,
		RectKeyFrame,
		RectKeyFrameCollection,
		Rectangle,
		RectangleGeometry,
		RelativeSource,
		RemoveStoryboard,
		RenderOptions,
		RenderTargetBitmap,
		RepeatBehavior,
		RepeatBehaviorConverter,
		RepeatButton,
		ResizeGrip,
		ResourceDictionary,
		ResourceKey,
		ResumeStoryboard,
		RichTextBox,
		RotateTransform,
		RotateTransform3D,
		Rotation3D,
		Rotation3DAnimation,
		Rotation3DAnimationBase,
		Rotation3DAnimationUsingKeyFrames,
		Rotation3DKeyFrame,
		Rotation3DKeyFrameCollection,
		RoutedCommand,
		RoutedEvent,
		RoutedEventConverter,
		RoutedUICommand,
		RoutingStrategy,
		RowDefinition,
		Run,
		RuntimeNamePropertyAttribute,
		SByte,
		SByteConverter,
		ScaleTransform,
		ScaleTransform3D,
		ScrollBar,
		ScrollContentPresenter,
		ScrollViewer,
		Section,
		SeekStoryboard,
		Selector,
		Separator,
		SetStoryboardSpeedRatio,
		Setter,
		SetterBase,
		Shape,
		Single,
		SingleAnimation,
		SingleAnimationBase,
		SingleAnimationUsingKeyFrames,
		SingleConverter,
		SingleKeyFrame,
		SingleKeyFrameCollection,
		Size,
		Size3D,
		Size3DConverter,
		SizeAnimation,
		SizeAnimationBase,
		SizeAnimationUsingKeyFrames,
		SizeConverter,
		SizeKeyFrame,
		SizeKeyFrameCollection,
		SkewTransform,
		SkipStoryboardToFill,
		Slider,
		SolidColorBrush,
		SoundPlayerAction,
		Span,
		SpecularMaterial,
		SpellCheck,
		SplineByteKeyFrame,
		SplineColorKeyFrame,
		SplineDecimalKeyFrame,
		SplineDoubleKeyFrame,
		SplineInt16KeyFrame,
		SplineInt32KeyFrame,
		SplineInt64KeyFrame,
		SplinePoint3DKeyFrame,
		SplinePointKeyFrame,
		SplineQuaternionKeyFrame,
		SplineRectKeyFrame,
		SplineRotation3DKeyFrame,
		SplineSingleKeyFrame,
		SplineSizeKeyFrame,
		SplineThicknessKeyFrame,
		SplineVector3DKeyFrame,
		SplineVectorKeyFrame,
		SpotLight,
		StackPanel,
		StaticExtension,
		StaticResourceExtension,
		StatusBar,
		StatusBarItem,
		StickyNoteControl,
		StopStoryboard,
		Storyboard,
		StreamGeometry,
		StreamGeometryContext,
		StreamResourceInfo,
		String,
		StringAnimationBase,
		StringAnimationUsingKeyFrames,
		StringConverter,
		StringKeyFrame,
		StringKeyFrameCollection,
		StrokeCollection,
		StrokeCollectionConverter,
		Style,
		Stylus,
		StylusDevice,
		TabControl,
		TabItem,
		TabPanel,
		Table,
		TableCell,
		TableColumn,
		TableRow,
		TableRowGroup,
		TabletDevice,
		TemplateBindingExpression,
		TemplateBindingExpressionConverter,
		TemplateBindingExtension,
		TemplateBindingExtensionConverter,
		TemplateKey,
		TemplateKeyConverter,
		TextBlock,
		TextBox,
		TextBoxBase,
		TextComposition,
		TextCompositionManager,
		TextDecoration,
		TextDecorationCollection,
		TextDecorationCollectionConverter,
		TextEffect,
		TextEffectCollection,
		TextElement,
		TextSearch,
		ThemeDictionaryExtension,
		Thickness,
		ThicknessAnimation,
		ThicknessAnimationBase,
		ThicknessAnimationUsingKeyFrames,
		ThicknessConverter,
		ThicknessKeyFrame,
		ThicknessKeyFrameCollection,
		Thumb,
		TickBar,
		TiffBitmapDecoder,
		TiffBitmapEncoder,
		TileBrush,
		TimeSpan,
		TimeSpanConverter,
		Timeline,
		TimelineCollection,
		TimelineGroup,
		ToggleButton,
		ToolBar,
		ToolBarOverflowPanel,
		ToolBarPanel,
		ToolBarTray,
		ToolTip,
		ToolTipService,
		Track,
		Transform,
		Transform3D,
		Transform3DCollection,
		Transform3DGroup,
		TransformCollection,
		TransformConverter,
		TransformGroup,
		TransformedBitmap,
		TranslateTransform,
		TranslateTransform3D,
		TreeView,
		TreeViewItem,
		Trigger,
		TriggerAction,
		TriggerBase,
		TypeExtension,
		TypeTypeConverter,
		Typography,
		UIElement,
		UInt16,
		UInt16Converter,
		UInt32,
		UInt32Converter,
		UInt64,
		UInt64Converter,
		UShortIListConverter,
		Underline,
		UniformGrid,
		Uri,
		UriTypeConverter,
		UserControl,
		Validation,
		Vector,
		Vector3D,
		Vector3DAnimation,
		Vector3DAnimationBase,
		Vector3DAnimationUsingKeyFrames,
		Vector3DCollection,
		Vector3DCollectionConverter,
		Vector3DConverter,
		Vector3DKeyFrame,
		Vector3DKeyFrameCollection,
		VectorAnimation,
		VectorAnimationBase,
		VectorAnimationUsingKeyFrames,
		VectorCollection,
		VectorCollectionConverter,
		VectorConverter,
		VectorKeyFrame,
		VectorKeyFrameCollection,
		VideoDrawing,
		ViewBase,
		Viewbox,
		Viewport3D,
		Viewport3DVisual,
		VirtualizingPanel,
		VirtualizingStackPanel,
		Visual,
		Visual3D,
		VisualBrush,
		VisualTarget,
		WeakEventManager,
		WhitespaceSignificantCollectionAttribute,
		Window,
		WmpBitmapDecoder,
		WmpBitmapEncoder,
		WrapPanel,
		WriteableBitmap,
		XamlBrushSerializer,
		XamlInt32CollectionSerializer,
		XamlPathDataSerializer,
		XamlPoint3DCollectionSerializer,
		XamlPointCollectionSerializer,
		XamlReader,
		XamlStyleSerializer,
		XamlTemplateSerializer,
		XamlVector3DCollectionSerializer,
		XamlWriter,
		XmlDataProvider,
		XmlLangPropertyAttribute,
		XmlLanguage,
		XmlLanguageConverter,
		XmlNamespaceMapping,
		ZoomPercentageConverter
	}

	internal enum KnownProperties : short {
		Unknown = 0,
		AccessText_Text,
		BeginStoryboard_Storyboard,
		BitmapEffectGroup_Children,
		Border_Background,
		Border_BorderBrush,
		Border_BorderThickness,
		ButtonBase_Command,
		ButtonBase_CommandParameter,
		ButtonBase_CommandTarget,
		ButtonBase_IsPressed,
		ColumnDefinition_MaxWidth,
		ColumnDefinition_MinWidth,
		ColumnDefinition_Width,
		ContentControl_Content,
		ContentControl_ContentTemplate,
		ContentControl_ContentTemplateSelector,
		ContentControl_HasContent,
		ContentElement_Focusable,
		ContentPresenter_Content,
		ContentPresenter_ContentSource,
		ContentPresenter_ContentTemplate,
		ContentPresenter_ContentTemplateSelector,
		ContentPresenter_RecognizesAccessKey,
		Control_Background,
		Control_BorderBrush,
		Control_BorderThickness,
		Control_FontFamily,
		Control_FontSize,
		Control_FontStretch,
		Control_FontStyle,
		Control_FontWeight,
		Control_Foreground,
		Control_HorizontalContentAlignment,
		Control_IsTabStop,
		Control_Padding,
		Control_TabIndex,
		Control_Template,
		Control_VerticalContentAlignment,
		DockPanel_Dock,
		DockPanel_LastChildFill,
		DocumentViewerBase_Document,
		DrawingGroup_Children,
		FlowDocumentReader_Document,
		FlowDocumentScrollViewer_Document,
		FrameworkContentElement_Style,
		FrameworkElement_FlowDirection,
		FrameworkElement_Height,
		FrameworkElement_HorizontalAlignment,
		FrameworkElement_Margin,
		FrameworkElement_MaxHeight,
		FrameworkElement_MaxWidth,
		FrameworkElement_MinHeight,
		FrameworkElement_MinWidth,
		FrameworkElement_Name,
		FrameworkElement_Style,
		FrameworkElement_VerticalAlignment,
		FrameworkElement_Width,
		GeneralTransformGroup_Children,
		GeometryGroup_Children,
		GradientBrush_GradientStops,
		Grid_Column,
		Grid_ColumnSpan,
		Grid_Row,
		Grid_RowSpan,
		GridViewColumn_Header,
		HeaderedContentControl_HasHeader,
		HeaderedContentControl_Header,
		HeaderedContentControl_HeaderTemplate,
		HeaderedContentControl_HeaderTemplateSelector,
		HeaderedItemsControl_HasHeader,
		HeaderedItemsControl_Header,
		HeaderedItemsControl_HeaderTemplate,
		HeaderedItemsControl_HeaderTemplateSelector,
		Hyperlink_NavigateUri,
		Image_Source,
		Image_Stretch,
		ItemsControl_ItemContainerStyle,
		ItemsControl_ItemContainerStyleSelector,
		ItemsControl_ItemTemplate,
		ItemsControl_ItemTemplateSelector,
		ItemsControl_ItemsPanel,
		ItemsControl_ItemsSource,
		MaterialGroup_Children,
		Model3DGroup_Children,
		Page_Content,
		Panel_Background,
		Path_Data,
		PathFigure_Segments,
		PathGeometry_Figures,
		Popup_Child,
		Popup_IsOpen,
		Popup_Placement,
		Popup_PopupAnimation,
		RowDefinition_Height,
		RowDefinition_MaxHeight,
		RowDefinition_MinHeight,
		ScrollViewer_CanContentScroll,
		ScrollViewer_HorizontalScrollBarVisibility,
		ScrollViewer_VerticalScrollBarVisibility,
		Shape_Fill,
		Shape_Stroke,
		Shape_StrokeThickness,
		TextBlock_Background,
		TextBlock_FontFamily,
		TextBlock_FontSize,
		TextBlock_FontStretch,
		TextBlock_FontStyle,
		TextBlock_FontWeight,
		TextBlock_Foreground,
		TextBlock_Text,
		TextBlock_TextDecorations,
		TextBlock_TextTrimming,
		TextBlock_TextWrapping,
		TextBox_Text,
		TextElement_Background,
		TextElement_FontFamily,
		TextElement_FontSize,
		TextElement_FontStretch,
		TextElement_FontStyle,
		TextElement_FontWeight,
		TextElement_Foreground,
		TimelineGroup_Children,
		Track_IsDirectionReversed,
		Track_Maximum,
		Track_Minimum,
		Track_Orientation,
		Track_Value,
		Track_ViewportSize,
		Transform3DGroup_Children,
		TransformGroup_Children,
		UIElement_ClipToBounds,
		UIElement_Focusable,
		UIElement_IsEnabled,
		UIElement_RenderTransform,
		UIElement_Visibility,
		Viewport3D_Children,
		MaxDependencyProperty,
		AdornedElementPlaceholder_Child,
		AdornerDecorator_Child,
		AnchoredBlock_Blocks,
		ArrayExtension_Items,
		BlockUIContainer_Child,
		Bold_Inlines,
		BooleanAnimationUsingKeyFrames_KeyFrames,
		Border_Child,
		BulletDecorator_Child,
		Button_Content,
		ButtonBase_Content,
		ByteAnimationUsingKeyFrames_KeyFrames,
		Canvas_Children,
		CharAnimationUsingKeyFrames_KeyFrames,
		CheckBox_Content,
		ColorAnimationUsingKeyFrames_KeyFrames,
		ComboBox_Items,
		ComboBoxItem_Content,
		ContextMenu_Items,
		ControlTemplate_VisualTree,
		DataTemplate_VisualTree,
		DataTrigger_Setters,
		DecimalAnimationUsingKeyFrames_KeyFrames,
		Decorator_Child,
		DockPanel_Children,
		DocumentViewer_Document,
		DoubleAnimationUsingKeyFrames_KeyFrames,
		EventTrigger_Actions,
		Expander_Content,
		Figure_Blocks,
		FixedDocument_Pages,
		FixedDocumentSequence_References,
		FixedPage_Children,
		Floater_Blocks,
		FlowDocument_Blocks,
		FlowDocumentPageViewer_Document,
		FrameworkTemplate_VisualTree,
		Grid_Children,
		GridView_Columns,
		GridViewColumnHeader_Content,
		GroupBox_Content,
		GroupItem_Content,
		HeaderedContentControl_Content,
		HeaderedItemsControl_Items,
		HierarchicalDataTemplate_VisualTree,
		Hyperlink_Inlines,
		InkCanvas_Children,
		InkPresenter_Child,
		InlineUIContainer_Child,
		InputScopeName_NameValue,
		Int16AnimationUsingKeyFrames_KeyFrames,
		Int32AnimationUsingKeyFrames_KeyFrames,
		Int64AnimationUsingKeyFrames_KeyFrames,
		Italic_Inlines,
		ItemsControl_Items,
		ItemsPanelTemplate_VisualTree,
		Label_Content,
		LinearGradientBrush_GradientStops,
		List_ListItems,
		ListBox_Items,
		ListBoxItem_Content,
		ListItem_Blocks,
		ListView_Items,
		ListViewItem_Content,
		MatrixAnimationUsingKeyFrames_KeyFrames,
		Menu_Items,
		MenuBase_Items,
		MenuItem_Items,
		ModelVisual3D_Children,
		MultiBinding_Bindings,
		MultiDataTrigger_Setters,
		MultiTrigger_Setters,
		ObjectAnimationUsingKeyFrames_KeyFrames,
		PageContent_Child,
		PageFunctionBase_Content,
		Panel_Children,
		Paragraph_Inlines,
		ParallelTimeline_Children,
		Point3DAnimationUsingKeyFrames_KeyFrames,
		PointAnimationUsingKeyFrames_KeyFrames,
		PriorityBinding_Bindings,
		QuaternionAnimationUsingKeyFrames_KeyFrames,
		RadialGradientBrush_GradientStops,
		RadioButton_Content,
		RectAnimationUsingKeyFrames_KeyFrames,
		RepeatButton_Content,
		RichTextBox_Document,
		Rotation3DAnimationUsingKeyFrames_KeyFrames,
		Run_Text,
		ScrollViewer_Content,
		Section_Blocks,
		Selector_Items,
		SingleAnimationUsingKeyFrames_KeyFrames,
		SizeAnimationUsingKeyFrames_KeyFrames,
		Span_Inlines,
		StackPanel_Children,
		StatusBar_Items,
		StatusBarItem_Content,
		Storyboard_Children,
		StringAnimationUsingKeyFrames_KeyFrames,
		Style_Setters,
		TabControl_Items,
		TabItem_Content,
		TabPanel_Children,
		Table_RowGroups,
		TableCell_Blocks,
		TableRow_Cells,
		TableRowGroup_Rows,
		TextBlock_Inlines,
		ThicknessAnimationUsingKeyFrames_KeyFrames,
		ToggleButton_Content,
		ToolBar_Items,
		ToolBarOverflowPanel_Children,
		ToolBarPanel_Children,
		ToolBarTray_ToolBars,
		ToolTip_Content,
		TreeView_Items,
		TreeViewItem_Items,
		Trigger_Setters,
		Underline_Inlines,
		UniformGrid_Children,
		UserControl_Content,
		Vector3DAnimationUsingKeyFrames_KeyFrames,
		VectorAnimationUsingKeyFrames_KeyFrames,
		Viewbox_Child,
		Viewport3DVisual_Children,
		VirtualizingPanel_Children,
		VirtualizingStackPanel_Children,
		Window_Content,
		WrapPanel_Children,
		XmlDataProvider_XmlSerializer
	}

	internal interface IKnownThings {
		Func<KnownTypes, TypeDef> Types { get; }
		Func<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> Properties { get; }
		AssemblyDef FrameworkAssembly { get; }
	}
}
```

`Confuser.Renamer/BAML/KnownThingsv3.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal class KnownThingsv3 : IKnownThings {
		readonly Dictionary<int, AssemblyDef> assemblies;
		readonly ConfuserContext context;
		readonly Dictionary<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> properties;
		readonly Dictionary<KnownTypes, TypeDef> types;

		public KnownThingsv3(ConfuserContext context, ModuleDefMD initMod) {
			this.context = context;

			assemblies = new Dictionary<int, AssemblyDef>();
			types = new Dictionary<KnownTypes, TypeDef>();
			properties = new Dictionary<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>>();

			InitAssemblies(initMod);
			InitTypes();
			InitProperties();
		}

		public Func<KnownTypes, TypeDef> Types {
			get { return type => types[type]; }
		}

		public Func<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> Properties {
			get { return property => properties[property]; }
		}

		public AssemblyDef FrameworkAssembly {
			get { return assemblies[0]; }
		}

		Tuple<KnownTypes, PropertyDef, TypeDef> InitProperty(KnownTypes parent, string propertyName, TypeDef propertyType) {
			if (propertyName != null)
				return Tuple.Create(parent, types[parent].FindProperty(propertyName), propertyType);
			return Tuple.Create(parent, (PropertyDef)null, propertyType);
		}

		// Following codes are auto-generated, do not modify.

		void InitAssemblies(ModuleDefMD initMod) {
			assemblies[0] = context.Resolver.ResolveThrow("PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[1] = context.Resolver.ResolveThrow("PresentationCore, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[2] = context.Resolver.ResolveThrow("mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[3] = context.Resolver.ResolveThrow("System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[4] = context.Resolver.ResolveThrow("WindowsBase, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[5] = context.Resolver.ResolveThrow("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
		}

		void InitTypes() {
			types[KnownTypes.AccessText] = assemblies[0].Find("System.Windows.Controls.AccessText", true);
			types[KnownTypes.AdornedElementPlaceholder] = assemblies[0].Find("System.Windows.Controls.AdornedElementPlaceholder", true);
			types[KnownTypes.Adorner] = assemblies[0].Find("System.Windows.Documents.Adorner", true);
			types[KnownTypes.AdornerDecorator] = assemblies[0].Find("System.Windows.Documents.AdornerDecorator", true);
			types[KnownTypes.AdornerLayer] = assemblies[0].Find("System.Windows.Documents.AdornerLayer", true);
			types[KnownTypes.AffineTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.AffineTransform3D", true);
			types[KnownTypes.AmbientLight] = assemblies[1].Find("System.Windows.Media.Media3D.AmbientLight", true);
			types[KnownTypes.AnchoredBlock] = assemblies[0].Find("System.Windows.Documents.AnchoredBlock", true);
			types[KnownTypes.Animatable] = assemblies[1].Find("System.Windows.Media.Animation.Animatable", true);
			types[KnownTypes.AnimationClock] = assemblies[1].Find("System.Windows.Media.Animation.AnimationClock", true);
			types[KnownTypes.AnimationTimeline] = assemblies[1].Find("System.Windows.Media.Animation.AnimationTimeline", true);
			types[KnownTypes.Application] = assemblies[0].Find("System.Windows.Application", true);
			types[KnownTypes.ArcSegment] = assemblies[1].Find("System.Windows.Media.ArcSegment", true);
			types[KnownTypes.ArrayExtension] = assemblies[0].Find("System.Windows.Markup.ArrayExtension", true);
			types[KnownTypes.AxisAngleRotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.AxisAngleRotation3D", true);
			types[KnownTypes.BaseIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.BaseIListConverter", true);
			types[KnownTypes.BeginStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.BeginStoryboard", true);
			types[KnownTypes.BevelBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BevelBitmapEffect", true);
			types[KnownTypes.BezierSegment] = assemblies[1].Find("System.Windows.Media.BezierSegment", true);
			types[KnownTypes.Binding] = assemblies[0].Find("System.Windows.Data.Binding", true);
			types[KnownTypes.BindingBase] = assemblies[0].Find("System.Windows.Data.BindingBase", true);
			types[KnownTypes.BindingExpression] = assemblies[0].Find("System.Windows.Data.BindingExpression", true);
			types[KnownTypes.BindingExpressionBase] = assemblies[0].Find("System.Windows.Data.BindingExpressionBase", true);
			types[KnownTypes.BindingListCollectionView] = assemblies[0].Find("System.Windows.Data.BindingListCollectionView", true);
			types[KnownTypes.BitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapDecoder", true);
			types[KnownTypes.BitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffect", true);
			types[KnownTypes.BitmapEffectCollection] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectCollection", true);
			types[KnownTypes.BitmapEffectGroup] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectGroup", true);
			types[KnownTypes.BitmapEffectInput] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectInput", true);
			types[KnownTypes.BitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapEncoder", true);
			types[KnownTypes.BitmapFrame] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapFrame", true);
			types[KnownTypes.BitmapImage] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapImage", true);
			types[KnownTypes.BitmapMetadata] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapMetadata", true);
			types[KnownTypes.BitmapPalette] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapPalette", true);
			types[KnownTypes.BitmapSource] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapSource", true);
			types[KnownTypes.Block] = assemblies[0].Find("System.Windows.Documents.Block", true);
			types[KnownTypes.BlockUIContainer] = assemblies[0].Find("System.Windows.Documents.BlockUIContainer", true);
			types[KnownTypes.BlurBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BlurBitmapEffect", true);
			types[KnownTypes.BmpBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.BmpBitmapDecoder", true);
			types[KnownTypes.BmpBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.BmpBitmapEncoder", true);
			types[KnownTypes.Bold] = assemblies[0].Find("System.Windows.Documents.Bold", true);
			types[KnownTypes.BoolIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.BoolIListConverter", true);
			types[KnownTypes.Boolean] = assemblies[2].Find("System.Boolean", true);
			types[KnownTypes.BooleanAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.BooleanAnimationBase", true);
			types[KnownTypes.BooleanAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.BooleanAnimationUsingKeyFrames", true);
			types[KnownTypes.BooleanConverter] = assemblies[3].Find("System.ComponentModel.BooleanConverter", true);
			types[KnownTypes.BooleanKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrame", true);
			types[KnownTypes.BooleanKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrameCollection", true);
			types[KnownTypes.BooleanToVisibilityConverter] = assemblies[0].Find("System.Windows.Controls.BooleanToVisibilityConverter", true);
			types[KnownTypes.Border] = assemblies[0].Find("System.Windows.Controls.Border", true);
			types[KnownTypes.BorderGapMaskConverter] = assemblies[0].Find("System.Windows.Controls.BorderGapMaskConverter", true);
			types[KnownTypes.Brush] = assemblies[1].Find("System.Windows.Media.Brush", true);
			types[KnownTypes.BrushConverter] = assemblies[1].Find("System.Windows.Media.BrushConverter", true);
			types[KnownTypes.BulletDecorator] = assemblies[0].Find("System.Windows.Controls.Primitives.BulletDecorator", true);
			types[KnownTypes.Button] = assemblies[0].Find("System.Windows.Controls.Button", true);
			types[KnownTypes.ButtonBase] = assemblies[0].Find("System.Windows.Controls.Primitives.ButtonBase", true);
			types[KnownTypes.Byte] = assemblies[2].Find("System.Byte", true);
			types[KnownTypes.ByteAnimation] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimation", true);
			types[KnownTypes.ByteAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimationBase", true);
			types[KnownTypes.ByteAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimationUsingKeyFrames", true);
			types[KnownTypes.ByteConverter] = assemblies[3].Find("System.ComponentModel.ByteConverter", true);
			types[KnownTypes.ByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrame", true);
			types[KnownTypes.ByteKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrameCollection", true);
			types[KnownTypes.CachedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.CachedBitmap", true);
			types[KnownTypes.Camera] = assemblies[1].Find("System.Windows.Media.Media3D.Camera", true);
			types[KnownTypes.Canvas] = assemblies[0].Find("System.Windows.Controls.Canvas", true);
			types[KnownTypes.Char] = assemblies[2].Find("System.Char", true);
			types[KnownTypes.CharAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.CharAnimationBase", true);
			types[KnownTypes.CharAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.CharAnimationUsingKeyFrames", true);
			types[KnownTypes.CharConverter] = assemblies[3].Find("System.ComponentModel.CharConverter", true);
			types[KnownTypes.CharIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.CharIListConverter", true);
			types[KnownTypes.CharKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrame", true);
			types[KnownTypes.CharKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrameCollection", true);
			types[KnownTypes.CheckBox] = assemblies[0].Find("System.Windows.Controls.CheckBox", true);
			types[KnownTypes.Clock] = assemblies[1].Find("System.Windows.Media.Animation.Clock", true);
			types[KnownTypes.ClockController] = assemblies[1].Find("System.Windows.Media.Animation.ClockController", true);
			types[KnownTypes.ClockGroup] = assemblies[1].Find("System.Windows.Media.Animation.ClockGroup", true);
			types[KnownTypes.CollectionContainer] = assemblies[0].Find("System.Windows.Data.CollectionContainer", true);
			types[KnownTypes.CollectionView] = assemblies[0].Find("System.Windows.Data.CollectionView", true);
			types[KnownTypes.CollectionViewSource] = assemblies[0].Find("System.Windows.Data.CollectionViewSource", true);
			types[KnownTypes.Color] = assemblies[1].Find("System.Windows.Media.Color", true);
			types[KnownTypes.ColorAnimation] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimation", true);
			types[KnownTypes.ColorAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimationBase", true);
			types[KnownTypes.ColorAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimationUsingKeyFrames", true);
			types[KnownTypes.ColorConvertedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.ColorConvertedBitmap", true);
			types[KnownTypes.ColorConvertedBitmapExtension] = assemblies[0].Find("System.Windows.ColorConvertedBitmapExtension", true);
			types[KnownTypes.ColorConverter] = assemblies[1].Find("System.Windows.Media.ColorConverter", true);
			types[KnownTypes.ColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrame", true);
			types[KnownTypes.ColorKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrameCollection", true);
			types[KnownTypes.ColumnDefinition] = assemblies[0].Find("System.Windows.Controls.ColumnDefinition", true);
			types[KnownTypes.CombinedGeometry] = assemblies[1].Find("System.Windows.Media.CombinedGeometry", true);
			types[KnownTypes.ComboBox] = assemblies[0].Find("System.Windows.Controls.ComboBox", true);
			types[KnownTypes.ComboBoxItem] = assemblies[0].Find("System.Windows.Controls.ComboBoxItem", true);
			types[KnownTypes.CommandConverter] = assemblies[0].Find("System.Windows.Input.CommandConverter", true);
			types[KnownTypes.ComponentResourceKey] = assemblies[0].Find("System.Windows.ComponentResourceKey", true);
			types[KnownTypes.ComponentResourceKeyConverter] = assemblies[0].Find("System.Windows.Markup.ComponentResourceKeyConverter", true);
			types[KnownTypes.CompositionTarget] = assemblies[1].Find("System.Windows.Media.CompositionTarget", true);
			types[KnownTypes.Condition] = assemblies[0].Find("System.Windows.Condition", true);
			types[KnownTypes.ContainerVisual] = assemblies[1].Find("System.Windows.Media.ContainerVisual", true);
			types[KnownTypes.ContentControl] = assemblies[0].Find("System.Windows.Controls.ContentControl", true);
			types[KnownTypes.ContentElement] = assemblies[1].Find("System.Windows.ContentElement", true);
			types[KnownTypes.ContentPresenter] = assemblies[0].Find("System.Windows.Controls.ContentPresenter", true);
			types[KnownTypes.ContentPropertyAttribute] = assemblies[4].Find("System.Windows.Markup.ContentPropertyAttribute", true);
			types[KnownTypes.ContentWrapperAttribute] = assemblies[4].Find("System.Windows.Markup.ContentWrapperAttribute", true);
			types[KnownTypes.ContextMenu] = assemblies[0].Find("System.Windows.Controls.ContextMenu", true);
			types[KnownTypes.ContextMenuService] = assemblies[0].Find("System.Windows.Controls.ContextMenuService", true);
			types[KnownTypes.Control] = assemblies[0].Find("System.Windows.Controls.Control", true);
			types[KnownTypes.ControlTemplate] = assemblies[0].Find("System.Windows.Controls.ControlTemplate", true);
			types[KnownTypes.ControllableStoryboardAction] = assemblies[0].Find("System.Windows.Media.Animation.ControllableStoryboardAction", true);
			types[KnownTypes.CornerRadius] = assemblies[0].Find("System.Windows.CornerRadius", true);
			types[KnownTypes.CornerRadiusConverter] = assemblies[0].Find("System.Windows.CornerRadiusConverter", true);
			types[KnownTypes.CroppedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.CroppedBitmap", true);
			types[KnownTypes.CultureInfo] = assemblies[2].Find("System.Globalization.CultureInfo", true);
			types[KnownTypes.CultureInfoConverter] = assemblies[3].Find("System.ComponentModel.CultureInfoConverter", true);
			types[KnownTypes.CultureInfoIetfLanguageTagConverter] = assemblies[1].Find("System.Windows.CultureInfoIetfLanguageTagConverter", true);
			types[KnownTypes.Cursor] = assemblies[1].Find("System.Windows.Input.Cursor", true);
			types[KnownTypes.CursorConverter] = assemblies[1].Find("System.Windows.Input.CursorConverter", true);
			types[KnownTypes.DashStyle] = assemblies[1].Find("System.Windows.Media.DashStyle", true);
			types[KnownTypes.DataChangedEventManager] = assemblies[0].Find("System.Windows.Data.DataChangedEventManager", true);
			types[KnownTypes.DataTemplate] = assemblies[0].Find("System.Windows.DataTemplate", true);
			types[KnownTypes.DataTemplateKey] = assemblies[0].Find("System.Windows.DataTemplateKey", true);
			types[KnownTypes.DataTrigger] = assemblies[0].Find("System.Windows.DataTrigger", true);
			types[KnownTypes.DateTime] = assemblies[2].Find("System.DateTime", true);
			types[KnownTypes.DateTimeConverter] = assemblies[3].Find("System.ComponentModel.DateTimeConverter", true);
			types[KnownTypes.DateTimeConverter2] = assemblies[4].Find("System.Windows.Markup.DateTimeConverter2", true);
			types[KnownTypes.Decimal] = assemblies[2].Find("System.Decimal", true);
			types[KnownTypes.DecimalAnimation] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimation", true);
			types[KnownTypes.DecimalAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimationBase", true);
			types[KnownTypes.DecimalAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimationUsingKeyFrames", true);
			types[KnownTypes.DecimalConverter] = assemblies[3].Find("System.ComponentModel.DecimalConverter", true);
			types[KnownTypes.DecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrame", true);
			types[KnownTypes.DecimalKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrameCollection", true);
			types[KnownTypes.Decorator] = assemblies[0].Find("System.Windows.Controls.Decorator", true);
			types[KnownTypes.DefinitionBase] = assemblies[0].Find("System.Windows.Controls.DefinitionBase", true);
			types[KnownTypes.DependencyObject] = assemblies[4].Find("System.Windows.DependencyObject", true);
			types[KnownTypes.DependencyProperty] = assemblies[4].Find("System.Windows.DependencyProperty", true);
			types[KnownTypes.DependencyPropertyConverter] = assemblies[0].Find("System.Windows.Markup.DependencyPropertyConverter", true);
			types[KnownTypes.DialogResultConverter] = assemblies[0].Find("System.Windows.DialogResultConverter", true);
			types[KnownTypes.DiffuseMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.DiffuseMaterial", true);
			types[KnownTypes.DirectionalLight] = assemblies[1].Find("System.Windows.Media.Media3D.DirectionalLight", true);
			types[KnownTypes.DiscreteBooleanKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteBooleanKeyFrame", true);
			types[KnownTypes.DiscreteByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteByteKeyFrame", true);
			types[KnownTypes.DiscreteCharKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteCharKeyFrame", true);
			types[KnownTypes.DiscreteColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteColorKeyFrame", true);
			types[KnownTypes.DiscreteDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteDecimalKeyFrame", true);
			types[KnownTypes.DiscreteDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteDoubleKeyFrame", true);
			types[KnownTypes.DiscreteInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt16KeyFrame", true);
			types[KnownTypes.DiscreteInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt32KeyFrame", true);
			types[KnownTypes.DiscreteInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt64KeyFrame", true);
			types[KnownTypes.DiscreteMatrixKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteMatrixKeyFrame", true);
			types[KnownTypes.DiscreteObjectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteObjectKeyFrame", true);
			types[KnownTypes.DiscretePoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscretePoint3DKeyFrame", true);
			types[KnownTypes.DiscretePointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscretePointKeyFrame", true);
			types[KnownTypes.DiscreteQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteQuaternionKeyFrame", true);
			types[KnownTypes.DiscreteRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteRectKeyFrame", true);
			types[KnownTypes.DiscreteRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteRotation3DKeyFrame", true);
			types[KnownTypes.DiscreteSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteSingleKeyFrame", true);
			types[KnownTypes.DiscreteSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteSizeKeyFrame", true);
			types[KnownTypes.DiscreteStringKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteStringKeyFrame", true);
			types[KnownTypes.DiscreteThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.DiscreteThicknessKeyFrame", true);
			types[KnownTypes.DiscreteVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteVector3DKeyFrame", true);
			types[KnownTypes.DiscreteVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteVectorKeyFrame", true);
			types[KnownTypes.DockPanel] = assemblies[0].Find("System.Windows.Controls.DockPanel", true);
			types[KnownTypes.DocumentPageView] = assemblies[0].Find("System.Windows.Controls.Primitives.DocumentPageView", true);
			types[KnownTypes.DocumentReference] = assemblies[0].Find("System.Windows.Documents.DocumentReference", true);
			types[KnownTypes.DocumentViewer] = assemblies[0].Find("System.Windows.Controls.DocumentViewer", true);
			types[KnownTypes.DocumentViewerBase] = assemblies[0].Find("System.Windows.Controls.Primitives.DocumentViewerBase", true);
			types[KnownTypes.Double] = assemblies[2].Find("System.Double", true);
			types[KnownTypes.DoubleAnimation] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimation", true);
			types[KnownTypes.DoubleAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationBase", true);
			types[KnownTypes.DoubleAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames", true);
			types[KnownTypes.DoubleAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationUsingPath", true);
			types[KnownTypes.DoubleCollection] = assemblies[1].Find("System.Windows.Media.DoubleCollection", true);
			types[KnownTypes.DoubleCollectionConverter] = assemblies[1].Find("System.Windows.Media.DoubleCollectionConverter", true);
			types[KnownTypes.DoubleConverter] = assemblies[3].Find("System.ComponentModel.DoubleConverter", true);
			types[KnownTypes.DoubleIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.DoubleIListConverter", true);
			types[KnownTypes.DoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrame", true);
			types[KnownTypes.DoubleKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrameCollection", true);
			types[KnownTypes.Drawing] = assemblies[1].Find("System.Windows.Media.Drawing", true);
			types[KnownTypes.DrawingBrush] = assemblies[1].Find("System.Windows.Media.DrawingBrush", true);
			types[KnownTypes.DrawingCollection] = assemblies[1].Find("System.Windows.Media.DrawingCollection", true);
			types[KnownTypes.DrawingContext] = assemblies[1].Find("System.Windows.Media.DrawingContext", true);
			types[KnownTypes.DrawingGroup] = assemblies[1].Find("System.Windows.Media.DrawingGroup", true);
			types[KnownTypes.DrawingImage] = assemblies[1].Find("System.Windows.Media.DrawingImage", true);
			types[KnownTypes.DrawingVisual] = assemblies[1].Find("System.Windows.Media.DrawingVisual", true);
			types[KnownTypes.DropShadowBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.DropShadowBitmapEffect", true);
			types[KnownTypes.Duration] = assemblies[1].Find("System.Windows.Duration", true);
			types[KnownTypes.DurationConverter] = assemblies[1].Find("System.Windows.DurationConverter", true);
			types[KnownTypes.DynamicResourceExtension] = assemblies[0].Find("System.Windows.DynamicResourceExtension", true);
			types[KnownTypes.DynamicResourceExtensionConverter] = assemblies[0].Find("System.Windows.DynamicResourceExtensionConverter", true);
			types[KnownTypes.Ellipse] = assemblies[0].Find("System.Windows.Shapes.Ellipse", true);
			types[KnownTypes.EllipseGeometry] = assemblies[1].Find("System.Windows.Media.EllipseGeometry", true);
			types[KnownTypes.EmbossBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.EmbossBitmapEffect", true);
			types[KnownTypes.EmissiveMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.EmissiveMaterial", true);
			types[KnownTypes.EnumConverter] = assemblies[3].Find("System.ComponentModel.EnumConverter", true);
			types[KnownTypes.EventManager] = assemblies[1].Find("System.Windows.EventManager", true);
			types[KnownTypes.EventSetter] = assemblies[0].Find("System.Windows.EventSetter", true);
			types[KnownTypes.EventTrigger] = assemblies[0].Find("System.Windows.EventTrigger", true);
			types[KnownTypes.Expander] = assemblies[0].Find("System.Windows.Controls.Expander", true);
			types[KnownTypes.Expression] = assemblies[4].Find("System.Windows.Expression", true);
			types[KnownTypes.ExpressionConverter] = assemblies[4].Find("System.Windows.ExpressionConverter", true);
			types[KnownTypes.Figure] = assemblies[0].Find("System.Windows.Documents.Figure", true);
			types[KnownTypes.FigureLength] = assemblies[0].Find("System.Windows.FigureLength", true);
			types[KnownTypes.FigureLengthConverter] = assemblies[0].Find("System.Windows.FigureLengthConverter", true);
			types[KnownTypes.FixedDocument] = assemblies[0].Find("System.Windows.Documents.FixedDocument", true);
			types[KnownTypes.FixedDocumentSequence] = assemblies[0].Find("System.Windows.Documents.FixedDocumentSequence", true);
			types[KnownTypes.FixedPage] = assemblies[0].Find("System.Windows.Documents.FixedPage", true);
			types[KnownTypes.Floater] = assemblies[0].Find("System.Windows.Documents.Floater", true);
			types[KnownTypes.FlowDocument] = assemblies[0].Find("System.Windows.Documents.FlowDocument", true);
			types[KnownTypes.FlowDocumentPageViewer] = assemblies[0].Find("System.Windows.Controls.FlowDocumentPageViewer", true);
			types[KnownTypes.FlowDocumentReader] = assemblies[0].Find("System.Windows.Controls.FlowDocumentReader", true);
			types[KnownTypes.FlowDocumentScrollViewer] = assemblies[0].Find("System.Windows.Controls.FlowDocumentScrollViewer", true);
			types[KnownTypes.FocusManager] = assemblies[1].Find("System.Windows.Input.FocusManager", true);
			types[KnownTypes.FontFamily] = assemblies[1].Find("System.Windows.Media.FontFamily", true);
			types[KnownTypes.FontFamilyConverter] = assemblies[1].Find("System.Windows.Media.FontFamilyConverter", true);
			types[KnownTypes.FontSizeConverter] = assemblies[0].Find("System.Windows.FontSizeConverter", true);
			types[KnownTypes.FontStretch] = assemblies[1].Find("System.Windows.FontStretch", true);
			types[KnownTypes.FontStretchConverter] = assemblies[1].Find("System.Windows.FontStretchConverter", true);
			types[KnownTypes.FontStyle] = assemblies[1].Find("System.Windows.FontStyle", true);
			types[KnownTypes.FontStyleConverter] = assemblies[1].Find("System.Windows.FontStyleConverter", true);
			types[KnownTypes.FontWeight] = assemblies[1].Find("System.Windows.FontWeight", true);
			types[KnownTypes.FontWeightConverter] = assemblies[1].Find("System.Windows.FontWeightConverter", true);
			types[KnownTypes.FormatConvertedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.FormatConvertedBitmap", true);
			types[KnownTypes.Frame] = assemblies[0].Find("System.Windows.Controls.Frame", true);
			types[KnownTypes.FrameworkContentElement] = assemblies[0].Find("System.Windows.FrameworkContentElement", true);
			types[KnownTypes.FrameworkElement] = assemblies[0].Find("System.Windows.FrameworkElement", true);
			types[KnownTypes.FrameworkElementFactory] = assemblies[0].Find("System.Windows.FrameworkElementFactory", true);
			types[KnownTypes.FrameworkPropertyMetadata] = assemblies[0].Find("System.Windows.FrameworkPropertyMetadata", true);
			types[KnownTypes.FrameworkPropertyMetadataOptions] = assemblies[0].Find("System.Windows.FrameworkPropertyMetadataOptions", true);
			types[KnownTypes.FrameworkRichTextComposition] = assemblies[0].Find("System.Windows.Documents.FrameworkRichTextComposition", true);
			types[KnownTypes.FrameworkTemplate] = assemblies[0].Find("System.Windows.FrameworkTemplate", true);
			types[KnownTypes.FrameworkTextComposition] = assemblies[0].Find("System.Windows.Documents.FrameworkTextComposition", true);
			types[KnownTypes.Freezable] = assemblies[4].Find("System.Windows.Freezable", true);
			types[KnownTypes.GeneralTransform] = assemblies[1].Find("System.Windows.Media.GeneralTransform", true);
			types[KnownTypes.GeneralTransformCollection] = assemblies[1].Find("System.Windows.Media.GeneralTransformCollection", true);
			types[KnownTypes.GeneralTransformGroup] = assemblies[1].Find("System.Windows.Media.GeneralTransformGroup", true);
			types[KnownTypes.Geometry] = assemblies[1].Find("System.Windows.Media.Geometry", true);
			types[KnownTypes.Geometry3D] = assemblies[1].Find("System.Windows.Media.Media3D.Geometry3D", true);
			types[KnownTypes.GeometryCollection] = assemblies[1].Find("System.Windows.Media.GeometryCollection", true);
			types[KnownTypes.GeometryConverter] = assemblies[1].Find("System.Windows.Media.GeometryConverter", true);
			types[KnownTypes.GeometryDrawing] = assemblies[1].Find("System.Windows.Media.GeometryDrawing", true);
			types[KnownTypes.GeometryGroup] = assemblies[1].Find("System.Windows.Media.GeometryGroup", true);
			types[KnownTypes.GeometryModel3D] = assemblies[1].Find("System.Windows.Media.Media3D.GeometryModel3D", true);
			types[KnownTypes.GestureRecognizer] = assemblies[1].Find("System.Windows.Ink.GestureRecognizer", true);
			types[KnownTypes.GifBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.GifBitmapDecoder", true);
			types[KnownTypes.GifBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.GifBitmapEncoder", true);
			types[KnownTypes.GlyphRun] = assemblies[1].Find("System.Windows.Media.GlyphRun", true);
			types[KnownTypes.GlyphRunDrawing] = assemblies[1].Find("System.Windows.Media.GlyphRunDrawing", true);
			types[KnownTypes.GlyphTypeface] = assemblies[1].Find("System.Windows.Media.GlyphTypeface", true);
			types[KnownTypes.Glyphs] = assemblies[0].Find("System.Windows.Documents.Glyphs", true);
			types[KnownTypes.GradientBrush] = assemblies[1].Find("System.Windows.Media.GradientBrush", true);
			types[KnownTypes.GradientStop] = assemblies[1].Find("System.Windows.Media.GradientStop", true);
			types[KnownTypes.GradientStopCollection] = assemblies[1].Find("System.Windows.Media.GradientStopCollection", true);
			types[KnownTypes.Grid] = assemblies[0].Find("System.Windows.Controls.Grid", true);
			types[KnownTypes.GridLength] = assemblies[0].Find("System.Windows.GridLength", true);
			types[KnownTypes.GridLengthConverter] = assemblies[0].Find("System.Windows.GridLengthConverter", true);
			types[KnownTypes.GridSplitter] = assemblies[0].Find("System.Windows.Controls.GridSplitter", true);
			types[KnownTypes.GridView] = assemblies[0].Find("System.Windows.Controls.GridView", true);
			types[KnownTypes.GridViewColumn] = assemblies[0].Find("System.Windows.Controls.GridViewColumn", true);
			types[KnownTypes.GridViewColumnHeader] = assemblies[0].Find("System.Windows.Controls.GridViewColumnHeader", true);
			types[KnownTypes.GridViewHeaderRowPresenter] = assemblies[0].Find("System.Windows.Controls.GridViewHeaderRowPresenter", true);
			types[KnownTypes.GridViewRowPresenter] = assemblies[0].Find("System.Windows.Controls.GridViewRowPresenter", true);
			types[KnownTypes.GridViewRowPresenterBase] = assemblies[0].Find("System.Windows.Controls.Primitives.GridViewRowPresenterBase", true);
			types[KnownTypes.GroupBox] = assemblies[0].Find("System.Windows.Controls.GroupBox", true);
			types[KnownTypes.GroupItem] = assemblies[0].Find("System.Windows.Controls.GroupItem", true);
			types[KnownTypes.Guid] = assemblies[2].Find("System.Guid", true);
			types[KnownTypes.GuidConverter] = assemblies[3].Find("System.ComponentModel.GuidConverter", true);
			types[KnownTypes.GuidelineSet] = assemblies[1].Find("System.Windows.Media.GuidelineSet", true);
			types[KnownTypes.HeaderedContentControl] = assemblies[0].Find("System.Windows.Controls.HeaderedContentControl", true);
			types[KnownTypes.HeaderedItemsControl] = assemblies[0].Find("System.Windows.Controls.HeaderedItemsControl", true);
			types[KnownTypes.HierarchicalDataTemplate] = assemblies[0].Find("System.Windows.HierarchicalDataTemplate", true);
			types[KnownTypes.HostVisual] = assemblies[1].Find("System.Windows.Media.HostVisual", true);
			types[KnownTypes.Hyperlink] = assemblies[0].Find("System.Windows.Documents.Hyperlink", true);
			types[KnownTypes.IAddChild] = assemblies[1].Find("System.Windows.Markup.IAddChild", true);
			types[KnownTypes.IAddChildInternal] = assemblies[1].Find("System.Windows.Markup.IAddChildInternal", true);
			types[KnownTypes.ICommand] = assemblies[1].Find("System.Windows.Input.ICommand", true);
			types[KnownTypes.IComponentConnector] = assemblies[4].Find("System.Windows.Markup.IComponentConnector", true);
			types[KnownTypes.INameScope] = assemblies[4].Find("System.Windows.Markup.INameScope", true);
			types[KnownTypes.IStyleConnector] = assemblies[0].Find("System.Windows.Markup.IStyleConnector", true);
			types[KnownTypes.IconBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.IconBitmapDecoder", true);
			types[KnownTypes.Image] = assemblies[0].Find("System.Windows.Controls.Image", true);
			types[KnownTypes.ImageBrush] = assemblies[1].Find("System.Windows.Media.ImageBrush", true);
			types[KnownTypes.ImageDrawing] = assemblies[1].Find("System.Windows.Media.ImageDrawing", true);
			types[KnownTypes.ImageMetadata] = assemblies[1].Find("System.Windows.Media.ImageMetadata", true);
			types[KnownTypes.ImageSource] = assemblies[1].Find("System.Windows.Media.ImageSource", true);
			types[KnownTypes.ImageSourceConverter] = assemblies[1].Find("System.Windows.Media.ImageSourceConverter", true);
			types[KnownTypes.InPlaceBitmapMetadataWriter] = assemblies[1].Find("System.Windows.Media.Imaging.InPlaceBitmapMetadataWriter", true);
			types[KnownTypes.InkCanvas] = assemblies[0].Find("System.Windows.Controls.InkCanvas", true);
			types[KnownTypes.InkPresenter] = assemblies[0].Find("System.Windows.Controls.InkPresenter", true);
			types[KnownTypes.Inline] = assemblies[0].Find("System.Windows.Documents.Inline", true);
			types[KnownTypes.InlineCollection] = assemblies[0].Find("System.Windows.Documents.InlineCollection", true);
			types[KnownTypes.InlineUIContainer] = assemblies[0].Find("System.Windows.Documents.InlineUIContainer", true);
			types[KnownTypes.InputBinding] = assemblies[1].Find("System.Windows.Input.InputBinding", true);
			types[KnownTypes.InputDevice] = assemblies[1].Find("System.Windows.Input.InputDevice", true);
			types[KnownTypes.InputLanguageManager] = assemblies[1].Find("System.Windows.Input.InputLanguageManager", true);
			types[KnownTypes.InputManager] = assemblies[1].Find("System.Windows.Input.InputManager", true);
			types[KnownTypes.InputMethod] = assemblies[1].Find("System.Windows.Input.InputMethod", true);
			types[KnownTypes.InputScope] = assemblies[1].Find("System.Windows.Input.InputScope", true);
			types[KnownTypes.InputScopeConverter] = assemblies[1].Find("System.Windows.Input.InputScopeConverter", true);
			types[KnownTypes.InputScopeName] = assemblies[1].Find("System.Windows.Input.InputScopeName", true);
			types[KnownTypes.InputScopeNameConverter] = assemblies[1].Find("System.Windows.Input.InputScopeNameConverter", true);
			types[KnownTypes.Int16] = assemblies[2].Find("System.Int16", true);
			types[KnownTypes.Int16Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int16Animation", true);
			types[KnownTypes.Int16AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int16AnimationBase", true);
			types[KnownTypes.Int16AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int16AnimationUsingKeyFrames", true);
			types[KnownTypes.Int16Converter] = assemblies[3].Find("System.ComponentModel.Int16Converter", true);
			types[KnownTypes.Int16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrame", true);
			types[KnownTypes.Int16KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrameCollection", true);
			types[KnownTypes.Int32] = assemblies[2].Find("System.Int32", true);
			types[KnownTypes.Int32Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int32Animation", true);
			types[KnownTypes.Int32AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int32AnimationBase", true);
			types[KnownTypes.Int32AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int32AnimationUsingKeyFrames", true);
			types[KnownTypes.Int32Collection] = assemblies[1].Find("System.Windows.Media.Int32Collection", true);
			types[KnownTypes.Int32CollectionConverter] = assemblies[1].Find("System.Windows.Media.Int32CollectionConverter", true);
			types[KnownTypes.Int32Converter] = assemblies[3].Find("System.ComponentModel.Int32Converter", true);
			types[KnownTypes.Int32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrame", true);
			types[KnownTypes.Int32KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrameCollection", true);
			types[KnownTypes.Int32Rect] = assemblies[4].Find("System.Windows.Int32Rect", true);
			types[KnownTypes.Int32RectConverter] = assemblies[4].Find("System.Windows.Int32RectConverter", true);
			types[KnownTypes.Int64] = assemblies[2].Find("System.Int64", true);
			types[KnownTypes.Int64Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int64Animation", true);
			types[KnownTypes.Int64AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int64AnimationBase", true);
			types[KnownTypes.Int64AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int64AnimationUsingKeyFrames", true);
			types[KnownTypes.Int64Converter] = assemblies[3].Find("System.ComponentModel.Int64Converter", true);
			types[KnownTypes.Int64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrame", true);
			types[KnownTypes.Int64KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrameCollection", true);
			types[KnownTypes.Italic] = assemblies[0].Find("System.Windows.Documents.Italic", true);
			types[KnownTypes.ItemCollection] = assemblies[0].Find("System.Windows.Controls.ItemCollection", true);
			types[KnownTypes.ItemsControl] = assemblies[0].Find("System.Windows.Controls.ItemsControl", true);
			types[KnownTypes.ItemsPanelTemplate] = assemblies[0].Find("System.Windows.Controls.ItemsPanelTemplate", true);
			types[KnownTypes.ItemsPresenter] = assemblies[0].Find("System.Windows.Controls.ItemsPresenter", true);
			types[KnownTypes.JournalEntry] = assemblies[0].Find("System.Windows.Navigation.JournalEntry", true);
			types[KnownTypes.JournalEntryListConverter] = assemblies[0].Find("System.Windows.Navigation.JournalEntryListConverter", true);
			types[KnownTypes.JournalEntryUnifiedViewConverter] = assemblies[0].Find("System.Windows.Navigation.JournalEntryUnifiedViewConverter", true);
			types[KnownTypes.JpegBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.JpegBitmapDecoder", true);
			types[KnownTypes.JpegBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.JpegBitmapEncoder", true);
			types[KnownTypes.KeyBinding] = assemblies[1].Find("System.Windows.Input.KeyBinding", true);
			types[KnownTypes.KeyConverter] = assemblies[4].Find("System.Windows.Input.KeyConverter", true);
			types[KnownTypes.KeyGesture] = assemblies[1].Find("System.Windows.Input.KeyGesture", true);
			types[KnownTypes.KeyGestureConverter] = assemblies[1].Find("System.Windows.Input.KeyGestureConverter", true);
			types[KnownTypes.KeySpline] = assemblies[1].Find("System.Windows.Media.Animation.KeySpline", true);
			types[KnownTypes.KeySplineConverter] = assemblies[1].Find("System.Windows.KeySplineConverter", true);
			types[KnownTypes.KeyTime] = assemblies[1].Find("System.Windows.Media.Animation.KeyTime", true);
			types[KnownTypes.KeyTimeConverter] = assemblies[1].Find("System.Windows.KeyTimeConverter", true);
			types[KnownTypes.KeyboardDevice] = assemblies[1].Find("System.Windows.Input.KeyboardDevice", true);
			types[KnownTypes.Label] = assemblies[0].Find("System.Windows.Controls.Label", true);
			types[KnownTypes.LateBoundBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.LateBoundBitmapDecoder", true);
			types[KnownTypes.LengthConverter] = assemblies[0].Find("System.Windows.LengthConverter", true);
			types[KnownTypes.Light] = assemblies[1].Find("System.Windows.Media.Media3D.Light", true);
			types[KnownTypes.Line] = assemblies[0].Find("System.Windows.Shapes.Line", true);
			types[KnownTypes.LineBreak] = assemblies[0].Find("System.Windows.Documents.LineBreak", true);
			types[KnownTypes.LineGeometry] = assemblies[1].Find("System.Windows.Media.LineGeometry", true);
			types[KnownTypes.LineSegment] = assemblies[1].Find("System.Windows.Media.LineSegment", true);
			types[KnownTypes.LinearByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearByteKeyFrame", true);
			types[KnownTypes.LinearColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearColorKeyFrame", true);
			types[KnownTypes.LinearDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearDecimalKeyFrame", true);
			types[KnownTypes.LinearDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearDoubleKeyFrame", true);
			types[KnownTypes.LinearGradientBrush] = assemblies[1].Find("System.Windows.Media.LinearGradientBrush", true);
			types[KnownTypes.LinearInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt16KeyFrame", true);
			types[KnownTypes.LinearInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt32KeyFrame", true);
			types[KnownTypes.LinearInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt64KeyFrame", true);
			types[KnownTypes.LinearPoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearPoint3DKeyFrame", true);
			types[KnownTypes.LinearPointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearPointKeyFrame", true);
			types[KnownTypes.LinearQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearQuaternionKeyFrame", true);
			types[KnownTypes.LinearRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearRectKeyFrame", true);
			types[KnownTypes.LinearRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearRotation3DKeyFrame", true);
			types[KnownTypes.LinearSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearSingleKeyFrame", true);
			types[KnownTypes.LinearSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearSizeKeyFrame", true);
			types[KnownTypes.LinearThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.LinearThicknessKeyFrame", true);
			types[KnownTypes.LinearVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearVector3DKeyFrame", true);
			types[KnownTypes.LinearVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearVectorKeyFrame", true);
			types[KnownTypes.List] = assemblies[0].Find("System.Windows.Documents.List", true);
			types[KnownTypes.ListBox] = assemblies[0].Find("System.Windows.Controls.ListBox", true);
			types[KnownTypes.ListBoxItem] = assemblies[0].Find("System.Windows.Controls.ListBoxItem", true);
			types[KnownTypes.ListCollectionView] = assemblies[0].Find("System.Windows.Data.ListCollectionView", true);
			types[KnownTypes.ListItem] = assemblies[0].Find("System.Windows.Documents.ListItem", true);
			types[KnownTypes.ListView] = assemblies[0].Find("System.Windows.Controls.ListView", true);
			types[KnownTypes.ListViewItem] = assemblies[0].Find("System.Windows.Controls.ListViewItem", true);
			types[KnownTypes.Localization] = assemblies[0].Find("System.Windows.Localization", true);
			types[KnownTypes.LostFocusEventManager] = assemblies[0].Find("System.Windows.LostFocusEventManager", true);
			types[KnownTypes.MarkupExtension] = assemblies[4].Find("System.Windows.Markup.MarkupExtension", true);
			types[KnownTypes.Material] = assemblies[1].Find("System.Windows.Media.Media3D.Material", true);
			types[KnownTypes.MaterialCollection] = assemblies[1].Find("System.Windows.Media.Media3D.MaterialCollection", true);
			types[KnownTypes.MaterialGroup] = assemblies[1].Find("System.Windows.Media.Media3D.MaterialGroup", true);
			types[KnownTypes.Matrix] = assemblies[4].Find("System.Windows.Media.Matrix", true);
			types[KnownTypes.Matrix3D] = assemblies[1].Find("System.Windows.Media.Media3D.Matrix3D", true);
			types[KnownTypes.Matrix3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Matrix3DConverter", true);
			types[KnownTypes.MatrixAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationBase", true);
			types[KnownTypes.MatrixAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationUsingKeyFrames", true);
			types[KnownTypes.MatrixAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationUsingPath", true);
			types[KnownTypes.MatrixCamera] = assemblies[1].Find("System.Windows.Media.Media3D.MatrixCamera", true);
			types[KnownTypes.MatrixConverter] = assemblies[4].Find("System.Windows.Media.MatrixConverter", true);
			types[KnownTypes.MatrixKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrame", true);
			types[KnownTypes.MatrixKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrameCollection", true);
			types[KnownTypes.MatrixTransform] = assemblies[1].Find("System.Windows.Media.MatrixTransform", true);
			types[KnownTypes.MatrixTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.MatrixTransform3D", true);
			types[KnownTypes.MediaClock] = assemblies[1].Find("System.Windows.Media.MediaClock", true);
			types[KnownTypes.MediaElement] = assemblies[0].Find("System.Windows.Controls.MediaElement", true);
			types[KnownTypes.MediaPlayer] = assemblies[1].Find("System.Windows.Media.MediaPlayer", true);
			types[KnownTypes.MediaTimeline] = assemblies[1].Find("System.Windows.Media.MediaTimeline", true);
			types[KnownTypes.Menu] = assemblies[0].Find("System.Windows.Controls.Menu", true);
			types[KnownTypes.MenuBase] = assemblies[0].Find("System.Windows.Controls.Primitives.MenuBase", true);
			types[KnownTypes.MenuItem] = assemblies[0].Find("System.Windows.Controls.MenuItem", true);
			types[KnownTypes.MenuScrollingVisibilityConverter] = assemblies[0].Find("System.Windows.Controls.MenuScrollingVisibilityConverter", true);
			types[KnownTypes.MeshGeometry3D] = assemblies[1].Find("System.Windows.Media.Media3D.MeshGeometry3D", true);
			types[KnownTypes.Model3D] = assemblies[1].Find("System.Windows.Media.Media3D.Model3D", true);
			types[KnownTypes.Model3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Model3DCollection", true);
			types[KnownTypes.Model3DGroup] = assemblies[1].Find("System.Windows.Media.Media3D.Model3DGroup", true);
			types[KnownTypes.ModelVisual3D] = assemblies[1].Find("System.Windows.Media.Media3D.ModelVisual3D", true);
			types[KnownTypes.ModifierKeysConverter] = assemblies[4].Find("System.Windows.Input.ModifierKeysConverter", true);
			types[KnownTypes.MouseActionConverter] = assemblies[1].Find("System.Windows.Input.MouseActionConverter", true);
			types[KnownTypes.MouseBinding] = assemblies[1].Find("System.Windows.Input.MouseBinding", true);
			types[KnownTypes.MouseDevice] = assemblies[1].Find("System.Windows.Input.MouseDevice", true);
			types[KnownTypes.MouseGesture] = assemblies[1].Find("System.Windows.Input.MouseGesture", true);
			types[KnownTypes.MouseGestureConverter] = assemblies[1].Find("System.Windows.Input.MouseGestureConverter", true);
			types[KnownTypes.MultiBinding] = assemblies[0].Find("System.Windows.Data.MultiBinding", true);
			types[KnownTypes.MultiBindingExpression] = assemblies[0].Find("System.Windows.Data.MultiBindingExpression", true);
			types[KnownTypes.MultiDataTrigger] = assemblies[0].Find("System.Windows.MultiDataTrigger", true);
			types[KnownTypes.MultiTrigger] = assemblies[0].Find("System.Windows.MultiTrigger", true);
			types[KnownTypes.NameScope] = assemblies[0].Find("System.Windows.NameScope", true);
			types[KnownTypes.NavigationWindow] = assemblies[0].Find("System.Windows.Navigation.NavigationWindow", true);
			types[KnownTypes.NullExtension] = assemblies[0].Find("System.Windows.Markup.NullExtension", true);
			types[KnownTypes.NullableBoolConverter] = assemblies[0].Find("System.Windows.NullableBoolConverter", true);
			types[KnownTypes.NullableConverter] = assemblies[3].Find("System.ComponentModel.NullableConverter", true);
			types[KnownTypes.NumberSubstitution] = assemblies[1].Find("System.Windows.Media.NumberSubstitution", true);
			types[KnownTypes.Object] = assemblies[2].Find("System.Object", true);
			types[KnownTypes.ObjectAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ObjectAnimationBase", true);
			types[KnownTypes.ObjectAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ObjectAnimationUsingKeyFrames", true);
			types[KnownTypes.ObjectDataProvider] = assemblies[0].Find("System.Windows.Data.ObjectDataProvider", true);
			types[KnownTypes.ObjectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrame", true);
			types[KnownTypes.ObjectKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrameCollection", true);
			types[KnownTypes.OrthographicCamera] = assemblies[1].Find("System.Windows.Media.Media3D.OrthographicCamera", true);
			types[KnownTypes.OuterGlowBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.OuterGlowBitmapEffect", true);
			types[KnownTypes.Page] = assemblies[0].Find("System.Windows.Controls.Page", true);
			types[KnownTypes.PageContent] = assemblies[0].Find("System.Windows.Documents.PageContent", true);
			types[KnownTypes.PageFunctionBase] = assemblies[0].Find("System.Windows.Navigation.PageFunctionBase", true);
			types[KnownTypes.Panel] = assemblies[0].Find("System.Windows.Controls.Panel", true);
			types[KnownTypes.Paragraph] = assemblies[0].Find("System.Windows.Documents.Paragraph", true);
			types[KnownTypes.ParallelTimeline] = assemblies[1].Find("System.Windows.Media.Animation.ParallelTimeline", true);
			types[KnownTypes.ParserContext] = assemblies[0].Find("System.Windows.Markup.ParserContext", true);
			types[KnownTypes.PasswordBox] = assemblies[0].Find("System.Windows.Controls.PasswordBox", true);
			types[KnownTypes.Path] = assemblies[0].Find("System.Windows.Shapes.Path", true);
			types[KnownTypes.PathFigure] = assemblies[1].Find("System.Windows.Media.PathFigure", true);
			types[KnownTypes.PathFigureCollection] = assemblies[1].Find("System.Windows.Media.PathFigureCollection", true);
			types[KnownTypes.PathFigureCollectionConverter] = assemblies[1].Find("System.Windows.Media.PathFigureCollectionConverter", true);
			types[KnownTypes.PathGeometry] = assemblies[1].Find("System.Windows.Media.PathGeometry", true);
			types[KnownTypes.PathSegment] = assemblies[1].Find("System.Windows.Media.PathSegment", true);
			types[KnownTypes.PathSegmentCollection] = assemblies[1].Find("System.Windows.Media.PathSegmentCollection", true);
			types[KnownTypes.PauseStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.PauseStoryboard", true);
			types[KnownTypes.Pen] = assemblies[1].Find("System.Windows.Media.Pen", true);
			types[KnownTypes.PerspectiveCamera] = assemblies[1].Find("System.Windows.Media.Media3D.PerspectiveCamera", true);
			types[KnownTypes.PixelFormat] = assemblies[1].Find("System.Windows.Media.PixelFormat", true);
			types[KnownTypes.PixelFormatConverter] = assemblies[1].Find("System.Windows.Media.PixelFormatConverter", true);
			types[KnownTypes.PngBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.PngBitmapDecoder", true);
			types[KnownTypes.PngBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.PngBitmapEncoder", true);
			types[KnownTypes.Point] = assemblies[4].Find("System.Windows.Point", true);
			types[KnownTypes.Point3D] = assemblies[1].Find("System.Windows.Media.Media3D.Point3D", true);
			types[KnownTypes.Point3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimation", true);
			types[KnownTypes.Point3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimationBase", true);
			types[KnownTypes.Point3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Point3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DCollection", true);
			types[KnownTypes.Point3DCollectionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DCollectionConverter", true);
			types[KnownTypes.Point3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DConverter", true);
			types[KnownTypes.Point3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrame", true);
			types[KnownTypes.Point3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrameCollection", true);
			types[KnownTypes.Point4D] = assemblies[1].Find("System.Windows.Media.Media3D.Point4D", true);
			types[KnownTypes.Point4DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point4DConverter", true);
			types[KnownTypes.PointAnimation] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimation", true);
			types[KnownTypes.PointAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationBase", true);
			types[KnownTypes.PointAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationUsingKeyFrames", true);
			types[KnownTypes.PointAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationUsingPath", true);
			types[KnownTypes.PointCollection] = assemblies[1].Find("System.Windows.Media.PointCollection", true);
			types[KnownTypes.PointCollectionConverter] = assemblies[1].Find("System.Windows.Media.PointCollectionConverter", true);
			types[KnownTypes.PointConverter] = assemblies[4].Find("System.Windows.PointConverter", true);
			types[KnownTypes.PointIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.PointIListConverter", true);
			types[KnownTypes.PointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrame", true);
			types[KnownTypes.PointKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrameCollection", true);
			types[KnownTypes.PointLight] = assemblies[1].Find("System.Windows.Media.Media3D.PointLight", true);
			types[KnownTypes.PointLightBase] = assemblies[1].Find("System.Windows.Media.Media3D.PointLightBase", true);
			types[KnownTypes.PolyBezierSegment] = assemblies[1].Find("System.Windows.Media.PolyBezierSegment", true);
			types[KnownTypes.PolyLineSegment] = assemblies[1].Find("System.Windows.Media.PolyLineSegment", true);
			types[KnownTypes.PolyQuadraticBezierSegment] = assemblies[1].Find("System.Windows.Media.PolyQuadraticBezierSegment", true);
			types[KnownTypes.Polygon] = assemblies[0].Find("System.Windows.Shapes.Polygon", true);
			types[KnownTypes.Polyline] = assemblies[0].Find("System.Windows.Shapes.Polyline", true);
			types[KnownTypes.Popup] = assemblies[0].Find("System.Windows.Controls.Primitives.Popup", true);
			types[KnownTypes.PresentationSource] = assemblies[1].Find("System.Windows.PresentationSource", true);
			types[KnownTypes.PriorityBinding] = assemblies[0].Find("System.Windows.Data.PriorityBinding", true);
			types[KnownTypes.PriorityBindingExpression] = assemblies[0].Find("System.Windows.Data.PriorityBindingExpression", true);
			types[KnownTypes.ProgressBar] = assemblies[0].Find("System.Windows.Controls.ProgressBar", true);
			types[KnownTypes.ProjectionCamera] = assemblies[1].Find("System.Windows.Media.Media3D.ProjectionCamera", true);
			types[KnownTypes.PropertyPath] = assemblies[0].Find("System.Windows.PropertyPath", true);
			types[KnownTypes.PropertyPathConverter] = assemblies[0].Find("System.Windows.PropertyPathConverter", true);
			types[KnownTypes.QuadraticBezierSegment] = assemblies[1].Find("System.Windows.Media.QuadraticBezierSegment", true);
			types[KnownTypes.Quaternion] = assemblies[1].Find("System.Windows.Media.Media3D.Quaternion", true);
			types[KnownTypes.QuaternionAnimation] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimation", true);
			types[KnownTypes.QuaternionAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimationBase", true);
			types[KnownTypes.QuaternionAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimationUsingKeyFrames", true);
			types[KnownTypes.QuaternionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.QuaternionConverter", true);
			types[KnownTypes.QuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrame", true);
			types[KnownTypes.QuaternionKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrameCollection", true);
			types[KnownTypes.QuaternionRotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.QuaternionRotation3D", true);
			types[KnownTypes.RadialGradientBrush] = assemblies[1].Find("System.Windows.Media.RadialGradientBrush", true);
			types[KnownTypes.RadioButton] = assemblies[0].Find("System.Windows.Controls.RadioButton", true);
			types[KnownTypes.RangeBase] = assemblies[0].Find("System.Windows.Controls.Primitives.RangeBase", true);
			types[KnownTypes.Rect] = assemblies[4].Find("System.Windows.Rect", true);
			types[KnownTypes.Rect3D] = assemblies[1].Find("System.Windows.Media.Media3D.Rect3D", true);
			types[KnownTypes.Rect3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Rect3DConverter", true);
			types[KnownTypes.RectAnimation] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimation", true);
			types[KnownTypes.RectAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimationBase", true);
			types[KnownTypes.RectAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimationUsingKeyFrames", true);
			types[KnownTypes.RectConverter] = assemblies[4].Find("System.Windows.RectConverter", true);
			types[KnownTypes.RectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrame", true);
			types[KnownTypes.RectKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrameCollection", true);
			types[KnownTypes.Rectangle] = assemblies[0].Find("System.Windows.Shapes.Rectangle", true);
			types[KnownTypes.RectangleGeometry] = assemblies[1].Find("System.Windows.Media.RectangleGeometry", true);
			types[KnownTypes.RelativeSource] = assemblies[0].Find("System.Windows.Data.RelativeSource", true);
			types[KnownTypes.RemoveStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.RemoveStoryboard", true);
			types[KnownTypes.RenderOptions] = assemblies[1].Find("System.Windows.Media.RenderOptions", true);
			types[KnownTypes.RenderTargetBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.RenderTargetBitmap", true);
			types[KnownTypes.RepeatBehavior] = assemblies[1].Find("System.Windows.Media.Animation.RepeatBehavior", true);
			types[KnownTypes.RepeatBehaviorConverter] = assemblies[1].Find("System.Windows.Media.Animation.RepeatBehaviorConverter", true);
			types[KnownTypes.RepeatButton] = assemblies[0].Find("System.Windows.Controls.Primitives.RepeatButton", true);
			types[KnownTypes.ResizeGrip] = assemblies[0].Find("System.Windows.Controls.Primitives.ResizeGrip", true);
			types[KnownTypes.ResourceDictionary] = assemblies[0].Find("System.Windows.ResourceDictionary", true);
			types[KnownTypes.ResourceKey] = assemblies[0].Find("System.Windows.ResourceKey", true);
			types[KnownTypes.ResumeStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.ResumeStoryboard", true);
			types[KnownTypes.RichTextBox] = assemblies[0].Find("System.Windows.Controls.RichTextBox", true);
			types[KnownTypes.RotateTransform] = assemblies[1].Find("System.Windows.Media.RotateTransform", true);
			types[KnownTypes.RotateTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.RotateTransform3D", true);
			types[KnownTypes.Rotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.Rotation3D", true);
			types[KnownTypes.Rotation3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimation", true);
			types[KnownTypes.Rotation3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimationBase", true);
			types[KnownTypes.Rotation3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Rotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrame", true);
			types[KnownTypes.Rotation3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrameCollection", true);
			types[KnownTypes.RoutedCommand] = assemblies[1].Find("System.Windows.Input.RoutedCommand", true);
			types[KnownTypes.RoutedEvent] = assemblies[1].Find("System.Windows.RoutedEvent", true);
			types[KnownTypes.RoutedEventConverter] = assemblies[0].Find("System.Windows.Markup.RoutedEventConverter", true);
			types[KnownTypes.RoutedUICommand] = assemblies[1].Find("System.Windows.Input.RoutedUICommand", true);
			types[KnownTypes.RoutingStrategy] = assemblies[1].Find("System.Windows.RoutingStrategy", true);
			types[KnownTypes.RowDefinition] = assemblies[0].Find("System.Windows.Controls.RowDefinition", true);
			types[KnownTypes.Run] = assemblies[0].Find("System.Windows.Documents.Run", true);
			types[KnownTypes.RuntimeNamePropertyAttribute] = assemblies[4].Find("System.Windows.Markup.RuntimeNamePropertyAttribute", true);
			types[KnownTypes.SByte] = assemblies[2].Find("System.SByte", true);
			types[KnownTypes.SByteConverter] = assemblies[3].Find("System.ComponentModel.SByteConverter", true);
			types[KnownTypes.ScaleTransform] = assemblies[1].Find("System.Windows.Media.ScaleTransform", true);
			types[KnownTypes.ScaleTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.ScaleTransform3D", true);
			types[KnownTypes.ScrollBar] = assemblies[0].Find("System.Windows.Controls.Primitives.ScrollBar", true);
			types[KnownTypes.ScrollContentPresenter] = assemblies[0].Find("System.Windows.Controls.ScrollContentPresenter", true);
			types[KnownTypes.ScrollViewer] = assemblies[0].Find("System.Windows.Controls.ScrollViewer", true);
			types[KnownTypes.Section] = assemblies[0].Find("System.Windows.Documents.Section", true);
			types[KnownTypes.SeekStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.SeekStoryboard", true);
			types[KnownTypes.Selector] = assemblies[0].Find("System.Windows.Controls.Primitives.Selector", true);
			types[KnownTypes.Separator] = assemblies[0].Find("System.Windows.Controls.Separator", true);
			types[KnownTypes.SetStoryboardSpeedRatio] = assemblies[0].Find("System.Windows.Media.Animation.SetStoryboardSpeedRatio", true);
			types[KnownTypes.Setter] = assemblies[0].Find("System.Windows.Setter", true);
			types[KnownTypes.SetterBase] = assemblies[0].Find("System.Windows.SetterBase", true);
			types[KnownTypes.Shape] = assemblies[0].Find("System.Windows.Shapes.Shape", true);
			types[KnownTypes.Single] = assemblies[2].Find("System.Single", true);
			types[KnownTypes.SingleAnimation] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimation", true);
			types[KnownTypes.SingleAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimationBase", true);
			types[KnownTypes.SingleAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimationUsingKeyFrames", true);
			types[KnownTypes.SingleConverter] = assemblies[3].Find("System.ComponentModel.SingleConverter", true);
			types[KnownTypes.SingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrame", true);
			types[KnownTypes.SingleKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrameCollection", true);
			types[KnownTypes.Size] = assemblies[4].Find("System.Windows.Size", true);
			types[KnownTypes.Size3D] = assemblies[1].Find("System.Windows.Media.Media3D.Size3D", true);
			types[KnownTypes.Size3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Size3DConverter", true);
			types[KnownTypes.SizeAnimation] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimation", true);
			types[KnownTypes.SizeAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimationBase", true);
			types[KnownTypes.SizeAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimationUsingKeyFrames", true);
			types[KnownTypes.SizeConverter] = assemblies[4].Find("System.Windows.SizeConverter", true);
			types[KnownTypes.SizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrame", true);
			types[KnownTypes.SizeKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrameCollection", true);
			types[KnownTypes.SkewTransform] = assemblies[1].Find("System.Windows.Media.SkewTransform", true);
			types[KnownTypes.SkipStoryboardToFill] = assemblies[0].Find("System.Windows.Media.Animation.SkipStoryboardToFill", true);
			types[KnownTypes.Slider] = assemblies[0].Find("System.Windows.Controls.Slider", true);
			types[KnownTypes.SolidColorBrush] = assemblies[1].Find("System.Windows.Media.SolidColorBrush", true);
			types[KnownTypes.SoundPlayerAction] = assemblies[0].Find("System.Windows.Controls.SoundPlayerAction", true);
			types[KnownTypes.Span] = assemblies[0].Find("System.Windows.Documents.Span", true);
			types[KnownTypes.SpecularMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.SpecularMaterial", true);
			types[KnownTypes.SpellCheck] = assemblies[0].Find("System.Windows.Controls.SpellCheck", true);
			types[KnownTypes.SplineByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineByteKeyFrame", true);
			types[KnownTypes.SplineColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineColorKeyFrame", true);
			types[KnownTypes.SplineDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineDecimalKeyFrame", true);
			types[KnownTypes.SplineDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineDoubleKeyFrame", true);
			types[KnownTypes.SplineInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt16KeyFrame", true);
			types[KnownTypes.SplineInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt32KeyFrame", true);
			types[KnownTypes.SplineInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt64KeyFrame", true);
			types[KnownTypes.SplinePoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplinePoint3DKeyFrame", true);
			types[KnownTypes.SplinePointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplinePointKeyFrame", true);
			types[KnownTypes.SplineQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineQuaternionKeyFrame", true);
			types[KnownTypes.SplineRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineRectKeyFrame", true);
			types[KnownTypes.SplineRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineRotation3DKeyFrame", true);
			types[KnownTypes.SplineSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineSingleKeyFrame", true);
			types[KnownTypes.SplineSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineSizeKeyFrame", true);
			types[KnownTypes.SplineThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.SplineThicknessKeyFrame", true);
			types[KnownTypes.SplineVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineVector3DKeyFrame", true);
			types[KnownTypes.SplineVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineVectorKeyFrame", true);
			types[KnownTypes.SpotLight] = assemblies[1].Find("System.Windows.Media.Media3D.SpotLight", true);
			types[KnownTypes.StackPanel] = assemblies[0].Find("System.Windows.Controls.StackPanel", true);
			types[KnownTypes.StaticExtension] = assemblies[0].Find("System.Windows.Markup.StaticExtension", true);
			types[KnownTypes.StaticResourceExtension] = assemblies[0].Find("System.Windows.StaticResourceExtension", true);
			types[KnownTypes.StatusBar] = assemblies[0].Find("System.Windows.Controls.Primitives.StatusBar", true);
			types[KnownTypes.StatusBarItem] = assemblies[0].Find("System.Windows.Controls.Primitives.StatusBarItem", true);
			types[KnownTypes.StickyNoteControl] = assemblies[0].Find("System.Windows.Controls.StickyNoteControl", true);
			types[KnownTypes.StopStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.StopStoryboard", true);
			types[KnownTypes.Storyboard] = assemblies[0].Find("System.Windows.Media.Animation.Storyboard", true);
			types[KnownTypes.StreamGeometry] = assemblies[1].Find("System.Windows.Media.StreamGeometry", true);
			types[KnownTypes.StreamGeometryContext] = assemblies[1].Find("System.Windows.Media.StreamGeometryContext", true);
			types[KnownTypes.StreamResourceInfo] = assemblies[0].Find("System.Windows.Resources.StreamResourceInfo", true);
			types[KnownTypes.String] = assemblies[2].Find("System.String", true);
			types[KnownTypes.StringAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.StringAnimationBase", true);
			types[KnownTypes.StringAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.StringAnimationUsingKeyFrames", true);
			types[KnownTypes.StringConverter] = assemblies[3].Find("System.ComponentModel.StringConverter", true);
			types[KnownTypes.StringKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrame", true);
			types[KnownTypes.StringKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrameCollection", true);
			types[KnownTypes.StrokeCollection] = assemblies[1].Find("System.Windows.Ink.StrokeCollection", true);
			types[KnownTypes.StrokeCollectionConverter] = assemblies[1].Find("System.Windows.StrokeCollectionConverter", true);
			types[KnownTypes.Style] = assemblies[0].Find("System.Windows.Style", true);
			types[KnownTypes.Stylus] = assemblies[1].Find("System.Windows.Input.Stylus", true);
			types[KnownTypes.StylusDevice] = assemblies[1].Find("System.Windows.Input.StylusDevice", true);
			types[KnownTypes.TabControl] = assemblies[0].Find("System.Windows.Controls.TabControl", true);
			types[KnownTypes.TabItem] = assemblies[0].Find("System.Windows.Controls.TabItem", true);
			types[KnownTypes.TabPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.TabPanel", true);
			types[KnownTypes.Table] = assemblies[0].Find("System.Windows.Documents.Table", true);
			types[KnownTypes.TableCell] = assemblies[0].Find("System.Windows.Documents.TableCell", true);
			types[KnownTypes.TableColumn] = assemblies[0].Find("System.Windows.Documents.TableColumn", true);
			types[KnownTypes.TableRow] = assemblies[0].Find("System.Windows.Documents.TableRow", true);
			types[KnownTypes.TableRowGroup] = assemblies[0].Find("System.Windows.Documents.TableRowGroup", true);
			types[KnownTypes.TabletDevice] = assemblies[1].Find("System.Windows.Input.TabletDevice", true);
			types[KnownTypes.TemplateBindingExpression] = assemblies[0].Find("System.Windows.TemplateBindingExpression", true);
			types[KnownTypes.TemplateBindingExpressionConverter] = assemblies[0].Find("System.Windows.TemplateBindingExpressionConverter", true);
			types[KnownTypes.TemplateBindingExtension] = assemblies[0].Find("System.Windows.TemplateBindingExtension", true);
			types[KnownTypes.TemplateBindingExtensionConverter] = assemblies[0].Find("System.Windows.TemplateBindingExtensionConverter", true);
			types[KnownTypes.TemplateKey] = assemblies[0].Find("System.Windows.TemplateKey", true);
			types[KnownTypes.TemplateKeyConverter] = assemblies[0].Find("System.Windows.Markup.TemplateKeyConverter", true);
			types[KnownTypes.TextBlock] = assemblies[0].Find("System.Windows.Controls.TextBlock", true);
			types[KnownTypes.TextBox] = assemblies[0].Find("System.Windows.Controls.TextBox", true);
			types[KnownTypes.TextBoxBase] = assemblies[0].Find("System.Windows.Controls.Primitives.TextBoxBase", true);
			types[KnownTypes.TextComposition] = assemblies[1].Find("System.Windows.Input.TextComposition", true);
			types[KnownTypes.TextCompositionManager] = assemblies[1].Find("System.Windows.Input.TextCompositionManager", true);
			types[KnownTypes.TextDecoration] = assemblies[1].Find("System.Windows.TextDecoration", true);
			types[KnownTypes.TextDecorationCollection] = assemblies[1].Find("System.Windows.TextDecorationCollection", true);
			types[KnownTypes.TextDecorationCollectionConverter] = assemblies[1].Find("System.Windows.TextDecorationCollectionConverter", true);
			types[KnownTypes.TextEffect] = assemblies[1].Find("System.Windows.Media.TextEffect", true);
			types[KnownTypes.TextEffectCollection] = assemblies[1].Find("System.Windows.Media.TextEffectCollection", true);
			types[KnownTypes.TextElement] = assemblies[0].Find("System.Windows.Documents.TextElement", true);
			types[KnownTypes.TextSearch] = assemblies[0].Find("System.Windows.Controls.TextSearch", true);
			types[KnownTypes.ThemeDictionaryExtension] = assemblies[0].Find("System.Windows.ThemeDictionaryExtension", true);
			types[KnownTypes.Thickness] = assemblies[0].Find("System.Windows.Thickness", true);
			types[KnownTypes.ThicknessAnimation] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimation", true);
			types[KnownTypes.ThicknessAnimationBase] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimationBase", true);
			types[KnownTypes.ThicknessAnimationUsingKeyFrames] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimationUsingKeyFrames", true);
			types[KnownTypes.ThicknessConverter] = assemblies[0].Find("System.Windows.ThicknessConverter", true);
			types[KnownTypes.ThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrame", true);
			types[KnownTypes.ThicknessKeyFrameCollection] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrameCollection", true);
			types[KnownTypes.Thumb] = assemblies[0].Find("System.Windows.Controls.Primitives.Thumb", true);
			types[KnownTypes.TickBar] = assemblies[0].Find("System.Windows.Controls.Primitives.TickBar", true);
			types[KnownTypes.TiffBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.TiffBitmapDecoder", true);
			types[KnownTypes.TiffBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.TiffBitmapEncoder", true);
			types[KnownTypes.TileBrush] = assemblies[1].Find("System.Windows.Media.TileBrush", true);
			types[KnownTypes.TimeSpan] = assemblies[2].Find("System.TimeSpan", true);
			types[KnownTypes.TimeSpanConverter] = assemblies[3].Find("System.ComponentModel.TimeSpanConverter", true);
			types[KnownTypes.Timeline] = assemblies[1].Find("System.Windows.Media.Animation.Timeline", true);
			types[KnownTypes.TimelineCollection] = assemblies[1].Find("System.Windows.Media.Animation.TimelineCollection", true);
			types[KnownTypes.TimelineGroup] = assemblies[1].Find("System.Windows.Media.Animation.TimelineGroup", true);
			types[KnownTypes.ToggleButton] = assemblies[0].Find("System.Windows.Controls.Primitives.ToggleButton", true);
			types[KnownTypes.ToolBar] = assemblies[0].Find("System.Windows.Controls.ToolBar", true);
			types[KnownTypes.ToolBarOverflowPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.ToolBarOverflowPanel", true);
			types[KnownTypes.ToolBarPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.ToolBarPanel", true);
			types[KnownTypes.ToolBarTray] = assemblies[0].Find("System.Windows.Controls.ToolBarTray", true);
			types[KnownTypes.ToolTip] = assemblies[0].Find("System.Windows.Controls.ToolTip", true);
			types[KnownTypes.ToolTipService] = assemblies[0].Find("System.Windows.Controls.ToolTipService", true);
			types[KnownTypes.Track] = assemblies[0].Find("System.Windows.Controls.Primitives.Track", true);
			types[KnownTypes.Transform] = assemblies[1].Find("System.Windows.Media.Transform", true);
			types[KnownTypes.Transform3D] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3D", true);
			types[KnownTypes.Transform3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3DCollection", true);
			types[KnownTypes.Transform3DGroup] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3DGroup", true);
			types[KnownTypes.TransformCollection] = assemblies[1].Find("System.Windows.Media.TransformCollection", true);
			types[KnownTypes.TransformConverter] = assemblies[1].Find("System.Windows.Media.TransformConverter", true);
			types[KnownTypes.TransformGroup] = assemblies[1].Find("System.Windows.Media.TransformGroup", true);
			types[KnownTypes.TransformedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.TransformedBitmap", true);
			types[KnownTypes.TranslateTransform] = assemblies[1].Find("System.Windows.Media.TranslateTransform", true);
			types[KnownTypes.TranslateTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.TranslateTransform3D", true);
			types[KnownTypes.TreeView] = assemblies[0].Find("System.Windows.Controls.TreeView", true);
			types[KnownTypes.TreeViewItem] = assemblies[0].Find("System.Windows.Controls.TreeViewItem", true);
			types[KnownTypes.Trigger] = assemblies[0].Find("System.Windows.Trigger", true);
			types[KnownTypes.TriggerAction] = assemblies[0].Find("System.Windows.TriggerAction", true);
			types[KnownTypes.TriggerBase] = assemblies[0].Find("System.Windows.TriggerBase", true);
			types[KnownTypes.TypeExtension] = assemblies[0].Find("System.Windows.Markup.TypeExtension", true);
			types[KnownTypes.TypeTypeConverter] = assemblies[4].Find("System.Windows.Markup.TypeTypeConverter", true);
			types[KnownTypes.Typography] = assemblies[0].Find("System.Windows.Documents.Typography", true);
			types[KnownTypes.UIElement] = assemblies[1].Find("System.Windows.UIElement", true);
			types[KnownTypes.UInt16] = assemblies[2].Find("System.UInt16", true);
			types[KnownTypes.UInt16Converter] = assemblies[3].Find("System.ComponentModel.UInt16Converter", true);
			types[KnownTypes.UInt32] = assemblies[2].Find("System.UInt32", true);
			types[KnownTypes.UInt32Converter] = assemblies[3].Find("System.ComponentModel.UInt32Converter", true);
			types[KnownTypes.UInt64] = assemblies[2].Find("System.UInt64", true);
			types[KnownTypes.UInt64Converter] = assemblies[3].Find("System.ComponentModel.UInt64Converter", true);
			types[KnownTypes.UShortIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.UShortIListConverter", true);
			types[KnownTypes.Underline] = assemblies[0].Find("System.Windows.Documents.Underline", true);
			types[KnownTypes.UniformGrid] = assemblies[0].Find("System.Windows.Controls.Primitives.UniformGrid", true);
			types[KnownTypes.Uri] = assemblies[3].Find("System.Uri", true);
			types[KnownTypes.UriTypeConverter] = assemblies[3].Find("System.UriTypeConverter", true);
			types[KnownTypes.UserControl] = assemblies[0].Find("System.Windows.Controls.UserControl", true);
			types[KnownTypes.Validation] = assemblies[0].Find("System.Windows.Controls.Validation", true);
			types[KnownTypes.Vector] = assemblies[4].Find("System.Windows.Vector", true);
			types[KnownTypes.Vector3D] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3D", true);
			types[KnownTypes.Vector3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimation", true);
			types[KnownTypes.Vector3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimationBase", true);
			types[KnownTypes.Vector3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Vector3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DCollection", true);
			types[KnownTypes.Vector3DCollectionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DCollectionConverter", true);
			types[KnownTypes.Vector3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DConverter", true);
			types[KnownTypes.Vector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrame", true);
			types[KnownTypes.Vector3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrameCollection", true);
			types[KnownTypes.VectorAnimation] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimation", true);
			types[KnownTypes.VectorAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimationBase", true);
			types[KnownTypes.VectorAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimationUsingKeyFrames", true);
			types[KnownTypes.VectorCollection] = assemblies[1].Find("System.Windows.Media.VectorCollection", true);
			types[KnownTypes.VectorCollectionConverter] = assemblies[1].Find("System.Windows.Media.VectorCollectionConverter", true);
			types[KnownTypes.VectorConverter] = assemblies[4].Find("System.Windows.VectorConverter", true);
			types[KnownTypes.VectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrame", true);
			types[KnownTypes.VectorKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrameCollection", true);
			types[KnownTypes.VideoDrawing] = assemblies[1].Find("System.Windows.Media.VideoDrawing", true);
			types[KnownTypes.ViewBase] = assemblies[0].Find("System.Windows.Controls.ViewBase", true);
			types[KnownTypes.Viewbox] = assemblies[0].Find("System.Windows.Controls.Viewbox", true);
			types[KnownTypes.Viewport3D] = assemblies[0].Find("System.Windows.Controls.Viewport3D", true);
			types[KnownTypes.Viewport3DVisual] = assemblies[1].Find("System.Windows.Media.Media3D.Viewport3DVisual", true);
			types[KnownTypes.VirtualizingPanel] = assemblies[0].Find("System.Windows.Controls.VirtualizingPanel", true);
			types[KnownTypes.VirtualizingStackPanel] = assemblies[0].Find("System.Windows.Controls.VirtualizingStackPanel", true);
			types[KnownTypes.Visual] = assemblies[1].Find("System.Windows.Media.Visual", true);
			types[KnownTypes.Visual3D] = assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true);
			types[KnownTypes.VisualBrush] = assemblies[1].Find("System.Windows.Media.VisualBrush", true);
			types[KnownTypes.VisualTarget] = assemblies[1].Find("System.Windows.Media.VisualTarget", true);
			types[KnownTypes.WeakEventManager] = assemblies[4].Find("System.Windows.WeakEventManager", true);
			types[KnownTypes.WhitespaceSignificantCollectionAttribute] = assemblies[4].Find("System.Windows.Markup.WhitespaceSignificantCollectionAttribute", true);
			types[KnownTypes.Window] = assemblies[0].Find("System.Windows.Window", true);
			types[KnownTypes.WmpBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.WmpBitmapDecoder", true);
			types[KnownTypes.WmpBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.WmpBitmapEncoder", true);
			types[KnownTypes.WrapPanel] = assemblies[0].Find("System.Windows.Controls.WrapPanel", true);
			types[KnownTypes.WriteableBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.WriteableBitmap", true);
			types[KnownTypes.XamlBrushSerializer] = assemblies[0].Find("System.Windows.Markup.XamlBrushSerializer", true);
			types[KnownTypes.XamlInt32CollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlInt32CollectionSerializer", true);
			types[KnownTypes.XamlPathDataSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPathDataSerializer", true);
			types[KnownTypes.XamlPoint3DCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPoint3DCollectionSerializer", true);
			types[KnownTypes.XamlPointCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPointCollectionSerializer", true);
			types[KnownTypes.XamlReader] = assemblies[0].Find("System.Windows.Markup.XamlReader", true);
			types[KnownTypes.XamlStyleSerializer] = assemblies[0].Find("System.Windows.Markup.XamlStyleSerializer", true);
			types[KnownTypes.XamlTemplateSerializer] = assemblies[0].Find("System.Windows.Markup.XamlTemplateSerializer", true);
			types[KnownTypes.XamlVector3DCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlVector3DCollectionSerializer", true);
			types[KnownTypes.XamlWriter] = assemblies[0].Find("System.Windows.Markup.XamlWriter", true);
			types[KnownTypes.XmlDataProvider] = assemblies[0].Find("System.Windows.Data.XmlDataProvider", true);
			types[KnownTypes.XmlLangPropertyAttribute] = assemblies[4].Find("System.Windows.Markup.XmlLangPropertyAttribute", true);
			types[KnownTypes.XmlLanguage] = assemblies[1].Find("System.Windows.Markup.XmlLanguage", true);
			types[KnownTypes.XmlLanguageConverter] = assemblies[1].Find("System.Windows.Markup.XmlLanguageConverter", true);
			types[KnownTypes.XmlNamespaceMapping] = assemblies[0].Find("System.Windows.Data.XmlNamespaceMapping", true);
			types[KnownTypes.ZoomPercentageConverter] = assemblies[0].Find("System.Windows.Documents.ZoomPercentageConverter", true);
		}

		void InitProperties() {
			properties[KnownProperties.AccessText_Text] = InitProperty(KnownTypes.AccessText, "Text", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.BeginStoryboard_Storyboard] = InitProperty(KnownTypes.BeginStoryboard, "Storyboard", assemblies[0].Find("System.Windows.Media.Animation.Storyboard", true));
			properties[KnownProperties.BitmapEffectGroup_Children] = InitProperty(KnownTypes.BitmapEffectGroup, "Children", assemblies[1].Find("System.Windows.Media.Effects.BitmapEffect", true));
			properties[KnownProperties.Border_Background] = InitProperty(KnownTypes.Border, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Border_BorderBrush] = InitProperty(KnownTypes.Border, "BorderBrush", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Border_BorderThickness] = InitProperty(KnownTypes.Border, "BorderThickness", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.ButtonBase_Command] = InitProperty(KnownTypes.ButtonBase, "Command", assemblies[1].Find("System.Windows.Input.ICommand", true));
			properties[KnownProperties.ButtonBase_CommandParameter] = InitProperty(KnownTypes.ButtonBase, "CommandParameter", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ButtonBase_CommandTarget] = InitProperty(KnownTypes.ButtonBase, "CommandTarget", assemblies[1].Find("System.Windows.IInputElement", true));
			properties[KnownProperties.ButtonBase_IsPressed] = InitProperty(KnownTypes.ButtonBase, "IsPressed", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.ColumnDefinition_MaxWidth] = InitProperty(KnownTypes.ColumnDefinition, "MaxWidth", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.ColumnDefinition_MinWidth] = InitProperty(KnownTypes.ColumnDefinition, "MinWidth", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.ColumnDefinition_Width] = InitProperty(KnownTypes.ColumnDefinition, "Width", assemblies[0].Find("System.Windows.GridLength", true));
			properties[KnownProperties.ContentControl_Content] = InitProperty(KnownTypes.ContentControl, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ContentControl_ContentTemplate] = InitProperty(KnownTypes.ContentControl, "ContentTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ContentControl_ContentTemplateSelector] = InitProperty(KnownTypes.ContentControl, "ContentTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ContentControl_HasContent] = InitProperty(KnownTypes.ContentControl, "HasContent", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.ContentElement_Focusable] = InitProperty(KnownTypes.ContentElement, "Focusable", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.ContentPresenter_Content] = InitProperty(KnownTypes.ContentPresenter, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ContentPresenter_ContentSource] = InitProperty(KnownTypes.ContentPresenter, "ContentSource", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.ContentPresenter_ContentTemplate] = InitProperty(KnownTypes.ContentPresenter, "ContentTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ContentPresenter_ContentTemplateSelector] = InitProperty(KnownTypes.ContentPresenter, "ContentTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ContentPresenter_RecognizesAccessKey] = InitProperty(KnownTypes.ContentPresenter, "RecognizesAccessKey", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.Control_Background] = InitProperty(KnownTypes.Control, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_BorderBrush] = InitProperty(KnownTypes.Control, "BorderBrush", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_BorderThickness] = InitProperty(KnownTypes.Control, "BorderThickness", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.Control_FontFamily] = InitProperty(KnownTypes.Control, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.Control_FontSize] = InitProperty(KnownTypes.Control, "FontSize", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Control_FontStretch] = InitProperty(KnownTypes.Control, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.Control_FontStyle] = InitProperty(KnownTypes.Control, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.Control_FontWeight] = InitProperty(KnownTypes.Control, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.Control_Foreground] = InitProperty(KnownTypes.Control, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_HorizontalContentAlignment] = InitProperty(KnownTypes.Control, "HorizontalContentAlignment", assemblies[0].Find("System.Windows.HorizontalAlignment", true));
			properties[KnownProperties.Control_IsTabStop] = InitProperty(KnownTypes.Control, null, assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.Control_Padding] = InitProperty(KnownTypes.Control, "Padding", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.Control_TabIndex] = InitProperty(KnownTypes.Control, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.Control_Template] = InitProperty(KnownTypes.Control, "Template", assemblies[0].Find("System.Windows.Controls.ControlTemplate", true));
			properties[KnownProperties.Control_VerticalContentAlignment] = InitProperty(KnownTypes.Control, "VerticalContentAlignment", assemblies[0].Find("System.Windows.VerticalAlignment", true));
			properties[KnownProperties.DockPanel_Dock] = InitProperty(KnownTypes.DockPanel, null, assemblies[0].Find("System.Windows.Controls.Dock", true));
			properties[KnownProperties.DockPanel_LastChildFill] = InitProperty(KnownTypes.DockPanel, "LastChildFill", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.DocumentViewerBase_Document] = InitProperty(KnownTypes.DocumentViewerBase, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.DrawingGroup_Children] = InitProperty(KnownTypes.DrawingGroup, "Children", assemblies[1].Find("System.Windows.Media.Drawing", true));
			properties[KnownProperties.FlowDocumentReader_Document] = InitProperty(KnownTypes.FlowDocumentReader, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.FlowDocumentScrollViewer_Document] = InitProperty(KnownTypes.FlowDocumentScrollViewer, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.FrameworkContentElement_Style] = InitProperty(KnownTypes.FrameworkContentElement, "Style", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.FrameworkElement_FlowDirection] = InitProperty(KnownTypes.FrameworkElement, "FlowDirection", assemblies[1].Find("System.Windows.FlowDirection", true));
			properties[KnownProperties.FrameworkElement_Height] = InitProperty(KnownTypes.FrameworkElement, "Height", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_HorizontalAlignment] = InitProperty(KnownTypes.FrameworkElement, "HorizontalAlignment", assemblies[0].Find("System.Windows.HorizontalAlignment", true));
			properties[KnownProperties.FrameworkElement_Margin] = InitProperty(KnownTypes.FrameworkElement, "Margin", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.FrameworkElement_MaxHeight] = InitProperty(KnownTypes.FrameworkElement, "MaxHeight", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MaxWidth] = InitProperty(KnownTypes.FrameworkElement, "MaxWidth", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MinHeight] = InitProperty(KnownTypes.FrameworkElement, "MinHeight", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MinWidth] = InitProperty(KnownTypes.FrameworkElement, "MinWidth", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_Name] = InitProperty(KnownTypes.FrameworkElement, "Name", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.FrameworkElement_Style] = InitProperty(KnownTypes.FrameworkElement, "Style", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.FrameworkElement_VerticalAlignment] = InitProperty(KnownTypes.FrameworkElement, "VerticalAlignment", assemblies[0].Find("System.Windows.VerticalAlignment", true));
			properties[KnownProperties.FrameworkElement_Width] = InitProperty(KnownTypes.FrameworkElement, "Width", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.GeneralTransformGroup_Children] = InitProperty(KnownTypes.GeneralTransformGroup, "Children", assemblies[1].Find("System.Windows.Media.GeneralTransform", true));
			properties[KnownProperties.GeometryGroup_Children] = InitProperty(KnownTypes.GeometryGroup, "Children", assemblies[1].Find("System.Windows.Media.Geometry", true));
			properties[KnownProperties.GradientBrush_GradientStops] = InitProperty(KnownTypes.GradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.Grid_Column] = InitProperty(KnownTypes.Grid, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.Grid_ColumnSpan] = InitProperty(KnownTypes.Grid, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.Grid_Row] = InitProperty(KnownTypes.Grid, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.Grid_RowSpan] = InitProperty(KnownTypes.Grid, null, assemblies[2].Find("System.Int32", true));
			properties[KnownProperties.GridViewColumn_Header] = InitProperty(KnownTypes.GridViewColumn, "Header", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_HasHeader] = InitProperty(KnownTypes.HeaderedContentControl, "HasHeader", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.HeaderedContentControl_Header] = InitProperty(KnownTypes.HeaderedContentControl, "Header", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_HeaderTemplate] = InitProperty(KnownTypes.HeaderedContentControl, "HeaderTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.HeaderedContentControl_HeaderTemplateSelector] = InitProperty(KnownTypes.HeaderedContentControl, "HeaderTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.HeaderedItemsControl_HasHeader] = InitProperty(KnownTypes.HeaderedItemsControl, "HasHeader", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.HeaderedItemsControl_Header] = InitProperty(KnownTypes.HeaderedItemsControl, "Header", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedItemsControl_HeaderTemplate] = InitProperty(KnownTypes.HeaderedItemsControl, "HeaderTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.HeaderedItemsControl_HeaderTemplateSelector] = InitProperty(KnownTypes.HeaderedItemsControl, "HeaderTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.Hyperlink_NavigateUri] = InitProperty(KnownTypes.Hyperlink, "NavigateUri", assemblies[3].Find("System.Uri", true));
			properties[KnownProperties.Image_Source] = InitProperty(KnownTypes.Image, "Source", assemblies[1].Find("System.Windows.Media.ImageSource", true));
			properties[KnownProperties.Image_Stretch] = InitProperty(KnownTypes.Image, "Stretch", assemblies[1].Find("System.Windows.Media.Stretch", true));
			properties[KnownProperties.ItemsControl_ItemContainerStyle] = InitProperty(KnownTypes.ItemsControl, "ItemContainerStyle", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.ItemsControl_ItemContainerStyleSelector] = InitProperty(KnownTypes.ItemsControl, "ItemContainerStyleSelector", assemblies[0].Find("System.Windows.Controls.StyleSelector", true));
			properties[KnownProperties.ItemsControl_ItemTemplate] = InitProperty(KnownTypes.ItemsControl, "ItemTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ItemsControl_ItemTemplateSelector] = InitProperty(KnownTypes.ItemsControl, "ItemTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ItemsControl_ItemsPanel] = InitProperty(KnownTypes.ItemsControl, "ItemsPanel", assemblies[0].Find("System.Windows.Controls.ItemsPanelTemplate", true));
			properties[KnownProperties.ItemsControl_ItemsSource] = InitProperty(KnownTypes.ItemsControl, "ItemsSource", assemblies[2].Find("System.Collections.IEnumerable", true));
			properties[KnownProperties.MaterialGroup_Children] = InitProperty(KnownTypes.MaterialGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Material", true));
			properties[KnownProperties.Model3DGroup_Children] = InitProperty(KnownTypes.Model3DGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Model3D", true));
			properties[KnownProperties.Page_Content] = InitProperty(KnownTypes.Page, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Panel_Background] = InitProperty(KnownTypes.Panel, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Path_Data] = InitProperty(KnownTypes.Path, "Data", assemblies[1].Find("System.Windows.Media.Geometry", true));
			properties[KnownProperties.PathFigure_Segments] = InitProperty(KnownTypes.PathFigure, "Segments", assemblies[1].Find("System.Windows.Media.PathSegment", true));
			properties[KnownProperties.PathGeometry_Figures] = InitProperty(KnownTypes.PathGeometry, "Figures", assemblies[1].Find("System.Windows.Media.PathFigure", true));
			properties[KnownProperties.Popup_Child] = InitProperty(KnownTypes.Popup, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Popup_IsOpen] = InitProperty(KnownTypes.Popup, "IsOpen", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.Popup_Placement] = InitProperty(KnownTypes.Popup, "Placement", assemblies[0].Find("System.Windows.Controls.Primitives.PlacementMode", true));
			properties[KnownProperties.Popup_PopupAnimation] = InitProperty(KnownTypes.Popup, "PopupAnimation", assemblies[0].Find("System.Windows.Controls.Primitives.PopupAnimation", true));
			properties[KnownProperties.RowDefinition_Height] = InitProperty(KnownTypes.RowDefinition, "Height", assemblies[0].Find("System.Windows.GridLength", true));
			properties[KnownProperties.RowDefinition_MaxHeight] = InitProperty(KnownTypes.RowDefinition, "MaxHeight", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.RowDefinition_MinHeight] = InitProperty(KnownTypes.RowDefinition, "MinHeight", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.ScrollViewer_CanContentScroll] = InitProperty(KnownTypes.ScrollViewer, "CanContentScroll", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.ScrollViewer_HorizontalScrollBarVisibility] = InitProperty(KnownTypes.ScrollViewer, "HorizontalScrollBarVisibility", assemblies[0].Find("System.Windows.Controls.ScrollBarVisibility", true));
			properties[KnownProperties.ScrollViewer_VerticalScrollBarVisibility] = InitProperty(KnownTypes.ScrollViewer, "VerticalScrollBarVisibility", assemblies[0].Find("System.Windows.Controls.ScrollBarVisibility", true));
			properties[KnownProperties.Shape_Fill] = InitProperty(KnownTypes.Shape, "Fill", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Shape_Stroke] = InitProperty(KnownTypes.Shape, "Stroke", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Shape_StrokeThickness] = InitProperty(KnownTypes.Shape, "StrokeThickness", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.TextBlock_Background] = InitProperty(KnownTypes.TextBlock, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextBlock_FontFamily] = InitProperty(KnownTypes.TextBlock, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.TextBlock_FontSize] = InitProperty(KnownTypes.TextBlock, "FontSize", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.TextBlock_FontStretch] = InitProperty(KnownTypes.TextBlock, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.TextBlock_FontStyle] = InitProperty(KnownTypes.TextBlock, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.TextBlock_FontWeight] = InitProperty(KnownTypes.TextBlock, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.TextBlock_Foreground] = InitProperty(KnownTypes.TextBlock, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextBlock_Text] = InitProperty(KnownTypes.TextBlock, "Text", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.TextBlock_TextDecorations] = InitProperty(KnownTypes.TextBlock, "TextDecorations", assemblies[1].Find("System.Windows.TextDecoration", true));
			properties[KnownProperties.TextBlock_TextTrimming] = InitProperty(KnownTypes.TextBlock, "TextTrimming", assemblies[1].Find("System.Windows.TextTrimming", true));
			properties[KnownProperties.TextBlock_TextWrapping] = InitProperty(KnownTypes.TextBlock, "TextWrapping", assemblies[1].Find("System.Windows.TextWrapping", true));
			properties[KnownProperties.TextBox_Text] = InitProperty(KnownTypes.TextBox, "Text", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.TextElement_Background] = InitProperty(KnownTypes.TextElement, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextElement_FontFamily] = InitProperty(KnownTypes.TextElement, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.TextElement_FontSize] = InitProperty(KnownTypes.TextElement, "FontSize", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.TextElement_FontStretch] = InitProperty(KnownTypes.TextElement, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.TextElement_FontStyle] = InitProperty(KnownTypes.TextElement, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.TextElement_FontWeight] = InitProperty(KnownTypes.TextElement, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.TextElement_Foreground] = InitProperty(KnownTypes.TextElement, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TimelineGroup_Children] = InitProperty(KnownTypes.TimelineGroup, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.Track_IsDirectionReversed] = InitProperty(KnownTypes.Track, "IsDirectionReversed", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.Track_Maximum] = InitProperty(KnownTypes.Track, "Maximum", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Track_Minimum] = InitProperty(KnownTypes.Track, "Minimum", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Track_Orientation] = InitProperty(KnownTypes.Track, "Orientation", assemblies[0].Find("System.Windows.Controls.Orientation", true));
			properties[KnownProperties.Track_Value] = InitProperty(KnownTypes.Track, "Value", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Track_ViewportSize] = InitProperty(KnownTypes.Track, "ViewportSize", assemblies[2].Find("System.Double", true));
			properties[KnownProperties.Transform3DGroup_Children] = InitProperty(KnownTypes.Transform3DGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Transform3D", true));
			properties[KnownProperties.TransformGroup_Children] = InitProperty(KnownTypes.TransformGroup, "Children", assemblies[1].Find("System.Windows.Media.Transform", true));
			properties[KnownProperties.UIElement_ClipToBounds] = InitProperty(KnownTypes.UIElement, "ClipToBounds", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_Focusable] = InitProperty(KnownTypes.UIElement, "Focusable", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_IsEnabled] = InitProperty(KnownTypes.UIElement, "IsEnabled", assemblies[2].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_RenderTransform] = InitProperty(KnownTypes.UIElement, "RenderTransform", assemblies[1].Find("System.Windows.Media.Transform", true));
			properties[KnownProperties.UIElement_Visibility] = InitProperty(KnownTypes.UIElement, "Visibility", assemblies[1].Find("System.Windows.Visibility", true));
			properties[KnownProperties.Viewport3D_Children] = InitProperty(KnownTypes.Viewport3D, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.AdornedElementPlaceholder_Child] = InitProperty(KnownTypes.AdornedElementPlaceholder, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.AdornerDecorator_Child] = InitProperty(KnownTypes.AdornerDecorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.AnchoredBlock_Blocks] = InitProperty(KnownTypes.AnchoredBlock, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.ArrayExtension_Items] = InitProperty(KnownTypes.ArrayExtension, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.BlockUIContainer_Child] = InitProperty(KnownTypes.BlockUIContainer, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Bold_Inlines] = InitProperty(KnownTypes.Bold, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.BooleanAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.BooleanAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrame", true));
			properties[KnownProperties.Border_Child] = InitProperty(KnownTypes.Border, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.BulletDecorator_Child] = InitProperty(KnownTypes.BulletDecorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Button_Content] = InitProperty(KnownTypes.Button, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ButtonBase_Content] = InitProperty(KnownTypes.ButtonBase, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ByteAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ByteAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrame", true));
			properties[KnownProperties.Canvas_Children] = InitProperty(KnownTypes.Canvas, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.CharAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.CharAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrame", true));
			properties[KnownProperties.CheckBox_Content] = InitProperty(KnownTypes.CheckBox, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ColorAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ColorAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrame", true));
			properties[KnownProperties.ComboBox_Items] = InitProperty(KnownTypes.ComboBox, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ComboBoxItem_Content] = InitProperty(KnownTypes.ComboBoxItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ContextMenu_Items] = InitProperty(KnownTypes.ContextMenu, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ControlTemplate_VisualTree] = InitProperty(KnownTypes.ControlTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.DataTemplate_VisualTree] = InitProperty(KnownTypes.DataTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.DataTrigger_Setters] = InitProperty(KnownTypes.DataTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.DecimalAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.DecimalAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrame", true));
			properties[KnownProperties.Decorator_Child] = InitProperty(KnownTypes.Decorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.DockPanel_Children] = InitProperty(KnownTypes.DockPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.DocumentViewer_Document] = InitProperty(KnownTypes.DocumentViewer, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.DoubleAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.DoubleAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrame", true));
			properties[KnownProperties.EventTrigger_Actions] = InitProperty(KnownTypes.EventTrigger, "Actions", assemblies[0].Find("System.Windows.TriggerAction", true));
			properties[KnownProperties.Expander_Content] = InitProperty(KnownTypes.Expander, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Figure_Blocks] = InitProperty(KnownTypes.Figure, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FixedDocument_Pages] = InitProperty(KnownTypes.FixedDocument, "Pages", assemblies[0].Find("System.Windows.Documents.PageContent", true));
			properties[KnownProperties.FixedDocumentSequence_References] = InitProperty(KnownTypes.FixedDocumentSequence, "References", assemblies[0].Find("System.Windows.Documents.DocumentReference", true));
			properties[KnownProperties.FixedPage_Children] = InitProperty(KnownTypes.FixedPage, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Floater_Blocks] = InitProperty(KnownTypes.Floater, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FlowDocument_Blocks] = InitProperty(KnownTypes.FlowDocument, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FlowDocumentPageViewer_Document] = InitProperty(KnownTypes.FlowDocumentPageViewer, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.FrameworkTemplate_VisualTree] = InitProperty(KnownTypes.FrameworkTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Grid_Children] = InitProperty(KnownTypes.Grid, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.GridView_Columns] = InitProperty(KnownTypes.GridView, "Columns", assemblies[0].Find("System.Windows.Controls.GridViewColumn", true));
			properties[KnownProperties.GridViewColumnHeader_Content] = InitProperty(KnownTypes.GridViewColumnHeader, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.GroupBox_Content] = InitProperty(KnownTypes.GroupBox, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.GroupItem_Content] = InitProperty(KnownTypes.GroupItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_Content] = InitProperty(KnownTypes.HeaderedContentControl, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HeaderedItemsControl_Items] = InitProperty(KnownTypes.HeaderedItemsControl, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.HierarchicalDataTemplate_VisualTree] = InitProperty(KnownTypes.HierarchicalDataTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Hyperlink_Inlines] = InitProperty(KnownTypes.Hyperlink, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.InkCanvas_Children] = InitProperty(KnownTypes.InkCanvas, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InkPresenter_Child] = InitProperty(KnownTypes.InkPresenter, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InlineUIContainer_Child] = InitProperty(KnownTypes.InlineUIContainer, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InputScopeName_NameValue] = InitProperty(KnownTypes.InputScopeName, "NameValue", assemblies[1].Find("System.Windows.Input.InputScopeNameValue", true));
			properties[KnownProperties.Int16AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int16AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrame", true));
			properties[KnownProperties.Int32AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int32AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrame", true));
			properties[KnownProperties.Int64AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int64AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrame", true));
			properties[KnownProperties.Italic_Inlines] = InitProperty(KnownTypes.Italic, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ItemsControl_Items] = InitProperty(KnownTypes.ItemsControl, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ItemsPanelTemplate_VisualTree] = InitProperty(KnownTypes.ItemsPanelTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Label_Content] = InitProperty(KnownTypes.Label, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.LinearGradientBrush_GradientStops] = InitProperty(KnownTypes.LinearGradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.List_ListItems] = InitProperty(KnownTypes.List, "ListItems", assemblies[0].Find("System.Windows.Documents.ListItem", true));
			properties[KnownProperties.ListBox_Items] = InitProperty(KnownTypes.ListBox, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ListBoxItem_Content] = InitProperty(KnownTypes.ListBoxItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ListItem_Blocks] = InitProperty(KnownTypes.ListItem, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.ListView_Items] = InitProperty(KnownTypes.ListView, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ListViewItem_Content] = InitProperty(KnownTypes.ListViewItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.MatrixAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.MatrixAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrame", true));
			properties[KnownProperties.Menu_Items] = InitProperty(KnownTypes.Menu, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.MenuBase_Items] = InitProperty(KnownTypes.MenuBase, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.MenuItem_Items] = InitProperty(KnownTypes.MenuItem, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ModelVisual3D_Children] = InitProperty(KnownTypes.ModelVisual3D, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.MultiBinding_Bindings] = InitProperty(KnownTypes.MultiBinding, "Bindings", assemblies[0].Find("System.Windows.Data.BindingBase", true));
			properties[KnownProperties.MultiDataTrigger_Setters] = InitProperty(KnownTypes.MultiDataTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.MultiTrigger_Setters] = InitProperty(KnownTypes.MultiTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.ObjectAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ObjectAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrame", true));
			properties[KnownProperties.PageContent_Child] = InitProperty(KnownTypes.PageContent, "Child", assemblies[0].Find("System.Windows.Documents.FixedPage", true));
			properties[KnownProperties.PageFunctionBase_Content] = InitProperty(KnownTypes.PageFunctionBase, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Panel_Children] = InitProperty(KnownTypes.Panel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Paragraph_Inlines] = InitProperty(KnownTypes.Paragraph, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ParallelTimeline_Children] = InitProperty(KnownTypes.ParallelTimeline, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.Point3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Point3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrame", true));
			properties[KnownProperties.PointAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.PointAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrame", true));
			properties[KnownProperties.PriorityBinding_Bindings] = InitProperty(KnownTypes.PriorityBinding, "Bindings", assemblies[0].Find("System.Windows.Data.BindingBase", true));
			properties[KnownProperties.QuaternionAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.QuaternionAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrame", true));
			properties[KnownProperties.RadialGradientBrush_GradientStops] = InitProperty(KnownTypes.RadialGradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.RadioButton_Content] = InitProperty(KnownTypes.RadioButton, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.RectAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.RectAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrame", true));
			properties[KnownProperties.RepeatButton_Content] = InitProperty(KnownTypes.RepeatButton, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.RichTextBox_Document] = InitProperty(KnownTypes.RichTextBox, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.Rotation3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Rotation3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrame", true));
			properties[KnownProperties.Run_Text] = InitProperty(KnownTypes.Run, "Text", assemblies[2].Find("System.Char", true));
			properties[KnownProperties.ScrollViewer_Content] = InitProperty(KnownTypes.ScrollViewer, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Section_Blocks] = InitProperty(KnownTypes.Section, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.Selector_Items] = InitProperty(KnownTypes.Selector, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.SingleAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.SingleAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrame", true));
			properties[KnownProperties.SizeAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.SizeAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrame", true));
			properties[KnownProperties.Span_Inlines] = InitProperty(KnownTypes.Span, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.StackPanel_Children] = InitProperty(KnownTypes.StackPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.StatusBar_Items] = InitProperty(KnownTypes.StatusBar, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.StatusBarItem_Content] = InitProperty(KnownTypes.StatusBarItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Storyboard_Children] = InitProperty(KnownTypes.Storyboard, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.StringAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.StringAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrame", true));
			properties[KnownProperties.Style_Setters] = InitProperty(KnownTypes.Style, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.TabControl_Items] = InitProperty(KnownTypes.TabControl, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.TabItem_Content] = InitProperty(KnownTypes.TabItem, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.TabPanel_Children] = InitProperty(KnownTypes.TabPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Table_RowGroups] = InitProperty(KnownTypes.Table, "RowGroups", assemblies[0].Find("System.Windows.Documents.TableRowGroup", true));
			properties[KnownProperties.TableCell_Blocks] = InitProperty(KnownTypes.TableCell, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.TableRow_Cells] = InitProperty(KnownTypes.TableRow, "Cells", assemblies[0].Find("System.Windows.Documents.TableCell", true));
			properties[KnownProperties.TableRowGroup_Rows] = InitProperty(KnownTypes.TableRowGroup, "Rows", assemblies[0].Find("System.Windows.Documents.TableRow", true));
			properties[KnownProperties.TextBlock_Inlines] = InitProperty(KnownTypes.TextBlock, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ThicknessAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ThicknessAnimationUsingKeyFrames, "KeyFrames", assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrame", true));
			properties[KnownProperties.ToggleButton_Content] = InitProperty(KnownTypes.ToggleButton, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ToolBar_Items] = InitProperty(KnownTypes.ToolBar, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.ToolBarOverflowPanel_Children] = InitProperty(KnownTypes.ToolBarOverflowPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.ToolBarPanel_Children] = InitProperty(KnownTypes.ToolBarPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.ToolBarTray_ToolBars] = InitProperty(KnownTypes.ToolBarTray, "ToolBars", assemblies[0].Find("System.Windows.Controls.ToolBar", true));
			properties[KnownProperties.ToolTip_Content] = InitProperty(KnownTypes.ToolTip, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.TreeView_Items] = InitProperty(KnownTypes.TreeView, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.TreeViewItem_Items] = InitProperty(KnownTypes.TreeViewItem, "Items", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Trigger_Setters] = InitProperty(KnownTypes.Trigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.Underline_Inlines] = InitProperty(KnownTypes.Underline, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.UniformGrid_Children] = InitProperty(KnownTypes.UniformGrid, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.UserControl_Content] = InitProperty(KnownTypes.UserControl, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.Vector3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Vector3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrame", true));
			properties[KnownProperties.VectorAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.VectorAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrame", true));
			properties[KnownProperties.Viewbox_Child] = InitProperty(KnownTypes.Viewbox, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Viewport3DVisual_Children] = InitProperty(KnownTypes.Viewport3DVisual, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.VirtualizingPanel_Children] = InitProperty(KnownTypes.VirtualizingPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.VirtualizingStackPanel_Children] = InitProperty(KnownTypes.VirtualizingStackPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Window_Content] = InitProperty(KnownTypes.Window, "Content", assemblies[2].Find("System.Object", true));
			properties[KnownProperties.WrapPanel_Children] = InitProperty(KnownTypes.WrapPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.XmlDataProvider_XmlSerializer] = InitProperty(KnownTypes.XmlDataProvider, "XmlSerializer", assemblies[5].Find("System.Xml.Serialization.IXmlSerializable", true));
		}
	}
}
```

`Confuser.Renamer/BAML/KnownThingsv4.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.BAML {
	internal class KnownThingsv4 : IKnownThings {
		readonly Dictionary<int, AssemblyDef> assemblies;
		readonly ConfuserContext context;
		readonly Dictionary<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> properties;
		readonly Dictionary<KnownTypes, TypeDef> types;

		public KnownThingsv4(ConfuserContext context, ModuleDefMD initMod) {
			this.context = context;

			assemblies = new Dictionary<int, AssemblyDef>();
			types = new Dictionary<KnownTypes, TypeDef>();
			properties = new Dictionary<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>>();

			InitAssemblies(initMod);
			InitTypes();
			InitProperties();
		}

		public Func<KnownTypes, TypeDef> Types {
			get { return type => types[type]; }
		}

		public Func<KnownProperties, Tuple<KnownTypes, PropertyDef, TypeDef>> Properties {
			get { return property => properties[property]; }
		}

		public AssemblyDef FrameworkAssembly {
			get { return assemblies[0]; }
		}

		Tuple<KnownTypes, PropertyDef, TypeDef> InitProperty(KnownTypes parent, string propertyName, TypeDef propertyType) {
			if (propertyName != null)
				return Tuple.Create(parent, types[parent].FindProperty(propertyName), propertyType);
			return Tuple.Create(parent, (PropertyDef)null, propertyType);
		}

		// Following codes are auto-generated, do not modify.

		void InitAssemblies(ModuleDefMD initMod) {
			assemblies[0] = context.Resolver.ResolveThrow("PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[1] = context.Resolver.ResolveThrow("PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[2] = context.Resolver.ResolveThrow("System.Xaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[3] = context.Resolver.ResolveThrow("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[4] = context.Resolver.ResolveThrow("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
			assemblies[5] = context.Resolver.ResolveThrow("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", initMod);
			assemblies[6] = context.Resolver.ResolveThrow("System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", initMod);
		}

		void InitTypes() {
			types[KnownTypes.AccessText] = assemblies[0].Find("System.Windows.Controls.AccessText", true);
			types[KnownTypes.AdornedElementPlaceholder] = assemblies[0].Find("System.Windows.Controls.AdornedElementPlaceholder", true);
			types[KnownTypes.Adorner] = assemblies[0].Find("System.Windows.Documents.Adorner", true);
			types[KnownTypes.AdornerDecorator] = assemblies[0].Find("System.Windows.Documents.AdornerDecorator", true);
			types[KnownTypes.AdornerLayer] = assemblies[0].Find("System.Windows.Documents.AdornerLayer", true);
			types[KnownTypes.AffineTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.AffineTransform3D", true);
			types[KnownTypes.AmbientLight] = assemblies[1].Find("System.Windows.Media.Media3D.AmbientLight", true);
			types[KnownTypes.AnchoredBlock] = assemblies[0].Find("System.Windows.Documents.AnchoredBlock", true);
			types[KnownTypes.Animatable] = assemblies[1].Find("System.Windows.Media.Animation.Animatable", true);
			types[KnownTypes.AnimationClock] = assemblies[1].Find("System.Windows.Media.Animation.AnimationClock", true);
			types[KnownTypes.AnimationTimeline] = assemblies[1].Find("System.Windows.Media.Animation.AnimationTimeline", true);
			types[KnownTypes.Application] = assemblies[0].Find("System.Windows.Application", true);
			types[KnownTypes.ArcSegment] = assemblies[1].Find("System.Windows.Media.ArcSegment", true);
			types[KnownTypes.ArrayExtension] = assemblies[2].Find("System.Windows.Markup.ArrayExtension", true);
			types[KnownTypes.AxisAngleRotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.AxisAngleRotation3D", true);
			types[KnownTypes.BaseIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.BaseIListConverter", true);
			types[KnownTypes.BeginStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.BeginStoryboard", true);
			types[KnownTypes.BevelBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BevelBitmapEffect", true);
			types[KnownTypes.BezierSegment] = assemblies[1].Find("System.Windows.Media.BezierSegment", true);
			types[KnownTypes.Binding] = assemblies[0].Find("System.Windows.Data.Binding", true);
			types[KnownTypes.BindingBase] = assemblies[0].Find("System.Windows.Data.BindingBase", true);
			types[KnownTypes.BindingExpression] = assemblies[0].Find("System.Windows.Data.BindingExpression", true);
			types[KnownTypes.BindingExpressionBase] = assemblies[0].Find("System.Windows.Data.BindingExpressionBase", true);
			types[KnownTypes.BindingListCollectionView] = assemblies[0].Find("System.Windows.Data.BindingListCollectionView", true);
			types[KnownTypes.BitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapDecoder", true);
			types[KnownTypes.BitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffect", true);
			types[KnownTypes.BitmapEffectCollection] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectCollection", true);
			types[KnownTypes.BitmapEffectGroup] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectGroup", true);
			types[KnownTypes.BitmapEffectInput] = assemblies[1].Find("System.Windows.Media.Effects.BitmapEffectInput", true);
			types[KnownTypes.BitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapEncoder", true);
			types[KnownTypes.BitmapFrame] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapFrame", true);
			types[KnownTypes.BitmapImage] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapImage", true);
			types[KnownTypes.BitmapMetadata] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapMetadata", true);
			types[KnownTypes.BitmapPalette] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapPalette", true);
			types[KnownTypes.BitmapSource] = assemblies[1].Find("System.Windows.Media.Imaging.BitmapSource", true);
			types[KnownTypes.Block] = assemblies[0].Find("System.Windows.Documents.Block", true);
			types[KnownTypes.BlockUIContainer] = assemblies[0].Find("System.Windows.Documents.BlockUIContainer", true);
			types[KnownTypes.BlurBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.BlurBitmapEffect", true);
			types[KnownTypes.BmpBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.BmpBitmapDecoder", true);
			types[KnownTypes.BmpBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.BmpBitmapEncoder", true);
			types[KnownTypes.Bold] = assemblies[0].Find("System.Windows.Documents.Bold", true);
			types[KnownTypes.BoolIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.BoolIListConverter", true);
			types[KnownTypes.Boolean] = assemblies[3].Find("System.Boolean", true);
			types[KnownTypes.BooleanAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.BooleanAnimationBase", true);
			types[KnownTypes.BooleanAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.BooleanAnimationUsingKeyFrames", true);
			types[KnownTypes.BooleanConverter] = assemblies[4].Find("System.ComponentModel.BooleanConverter", true);
			types[KnownTypes.BooleanKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrame", true);
			types[KnownTypes.BooleanKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrameCollection", true);
			types[KnownTypes.BooleanToVisibilityConverter] = assemblies[0].Find("System.Windows.Controls.BooleanToVisibilityConverter", true);
			types[KnownTypes.Border] = assemblies[0].Find("System.Windows.Controls.Border", true);
			types[KnownTypes.BorderGapMaskConverter] = assemblies[0].Find("System.Windows.Controls.BorderGapMaskConverter", true);
			types[KnownTypes.Brush] = assemblies[1].Find("System.Windows.Media.Brush", true);
			types[KnownTypes.BrushConverter] = assemblies[1].Find("System.Windows.Media.BrushConverter", true);
			types[KnownTypes.BulletDecorator] = assemblies[0].Find("System.Windows.Controls.Primitives.BulletDecorator", true);
			types[KnownTypes.Button] = assemblies[0].Find("System.Windows.Controls.Button", true);
			types[KnownTypes.ButtonBase] = assemblies[0].Find("System.Windows.Controls.Primitives.ButtonBase", true);
			types[KnownTypes.Byte] = assemblies[3].Find("System.Byte", true);
			types[KnownTypes.ByteAnimation] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimation", true);
			types[KnownTypes.ByteAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimationBase", true);
			types[KnownTypes.ByteAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ByteAnimationUsingKeyFrames", true);
			types[KnownTypes.ByteConverter] = assemblies[4].Find("System.ComponentModel.ByteConverter", true);
			types[KnownTypes.ByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrame", true);
			types[KnownTypes.ByteKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrameCollection", true);
			types[KnownTypes.CachedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.CachedBitmap", true);
			types[KnownTypes.Camera] = assemblies[1].Find("System.Windows.Media.Media3D.Camera", true);
			types[KnownTypes.Canvas] = assemblies[0].Find("System.Windows.Controls.Canvas", true);
			types[KnownTypes.Char] = assemblies[3].Find("System.Char", true);
			types[KnownTypes.CharAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.CharAnimationBase", true);
			types[KnownTypes.CharAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.CharAnimationUsingKeyFrames", true);
			types[KnownTypes.CharConverter] = assemblies[4].Find("System.ComponentModel.CharConverter", true);
			types[KnownTypes.CharIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.CharIListConverter", true);
			types[KnownTypes.CharKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrame", true);
			types[KnownTypes.CharKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrameCollection", true);
			types[KnownTypes.CheckBox] = assemblies[0].Find("System.Windows.Controls.CheckBox", true);
			types[KnownTypes.Clock] = assemblies[1].Find("System.Windows.Media.Animation.Clock", true);
			types[KnownTypes.ClockController] = assemblies[1].Find("System.Windows.Media.Animation.ClockController", true);
			types[KnownTypes.ClockGroup] = assemblies[1].Find("System.Windows.Media.Animation.ClockGroup", true);
			types[KnownTypes.CollectionContainer] = assemblies[0].Find("System.Windows.Data.CollectionContainer", true);
			types[KnownTypes.CollectionView] = assemblies[0].Find("System.Windows.Data.CollectionView", true);
			types[KnownTypes.CollectionViewSource] = assemblies[0].Find("System.Windows.Data.CollectionViewSource", true);
			types[KnownTypes.Color] = assemblies[1].Find("System.Windows.Media.Color", true);
			types[KnownTypes.ColorAnimation] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimation", true);
			types[KnownTypes.ColorAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimationBase", true);
			types[KnownTypes.ColorAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ColorAnimationUsingKeyFrames", true);
			types[KnownTypes.ColorConvertedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.ColorConvertedBitmap", true);
			types[KnownTypes.ColorConvertedBitmapExtension] = assemblies[0].Find("System.Windows.ColorConvertedBitmapExtension", true);
			types[KnownTypes.ColorConverter] = assemblies[1].Find("System.Windows.Media.ColorConverter", true);
			types[KnownTypes.ColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrame", true);
			types[KnownTypes.ColorKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrameCollection", true);
			types[KnownTypes.ColumnDefinition] = assemblies[0].Find("System.Windows.Controls.ColumnDefinition", true);
			types[KnownTypes.CombinedGeometry] = assemblies[1].Find("System.Windows.Media.CombinedGeometry", true);
			types[KnownTypes.ComboBox] = assemblies[0].Find("System.Windows.Controls.ComboBox", true);
			types[KnownTypes.ComboBoxItem] = assemblies[0].Find("System.Windows.Controls.ComboBoxItem", true);
			types[KnownTypes.CommandConverter] = assemblies[0].Find("System.Windows.Input.CommandConverter", true);
			types[KnownTypes.ComponentResourceKey] = assemblies[0].Find("System.Windows.ComponentResourceKey", true);
			types[KnownTypes.ComponentResourceKeyConverter] = assemblies[0].Find("System.Windows.Markup.ComponentResourceKeyConverter", true);
			types[KnownTypes.CompositionTarget] = assemblies[1].Find("System.Windows.Media.CompositionTarget", true);
			types[KnownTypes.Condition] = assemblies[0].Find("System.Windows.Condition", true);
			types[KnownTypes.ContainerVisual] = assemblies[1].Find("System.Windows.Media.ContainerVisual", true);
			types[KnownTypes.ContentControl] = assemblies[0].Find("System.Windows.Controls.ContentControl", true);
			types[KnownTypes.ContentElement] = assemblies[1].Find("System.Windows.ContentElement", true);
			types[KnownTypes.ContentPresenter] = assemblies[0].Find("System.Windows.Controls.ContentPresenter", true);
			types[KnownTypes.ContentPropertyAttribute] = assemblies[2].Find("System.Windows.Markup.ContentPropertyAttribute", true);
			types[KnownTypes.ContentWrapperAttribute] = assemblies[2].Find("System.Windows.Markup.ContentWrapperAttribute", true);
			types[KnownTypes.ContextMenu] = assemblies[0].Find("System.Windows.Controls.ContextMenu", true);
			types[KnownTypes.ContextMenuService] = assemblies[0].Find("System.Windows.Controls.ContextMenuService", true);
			types[KnownTypes.Control] = assemblies[0].Find("System.Windows.Controls.Control", true);
			types[KnownTypes.ControlTemplate] = assemblies[0].Find("System.Windows.Controls.ControlTemplate", true);
			types[KnownTypes.ControllableStoryboardAction] = assemblies[0].Find("System.Windows.Media.Animation.ControllableStoryboardAction", true);
			types[KnownTypes.CornerRadius] = assemblies[0].Find("System.Windows.CornerRadius", true);
			types[KnownTypes.CornerRadiusConverter] = assemblies[0].Find("System.Windows.CornerRadiusConverter", true);
			types[KnownTypes.CroppedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.CroppedBitmap", true);
			types[KnownTypes.CultureInfo] = assemblies[3].Find("System.Globalization.CultureInfo", true);
			types[KnownTypes.CultureInfoConverter] = assemblies[4].Find("System.ComponentModel.CultureInfoConverter", true);
			types[KnownTypes.CultureInfoIetfLanguageTagConverter] = assemblies[1].Find("System.Windows.CultureInfoIetfLanguageTagConverter", true);
			types[KnownTypes.Cursor] = assemblies[1].Find("System.Windows.Input.Cursor", true);
			types[KnownTypes.CursorConverter] = assemblies[1].Find("System.Windows.Input.CursorConverter", true);
			types[KnownTypes.DashStyle] = assemblies[1].Find("System.Windows.Media.DashStyle", true);
			types[KnownTypes.DataChangedEventManager] = assemblies[0].Find("System.Windows.Data.DataChangedEventManager", true);
			types[KnownTypes.DataTemplate] = assemblies[0].Find("System.Windows.DataTemplate", true);
			types[KnownTypes.DataTemplateKey] = assemblies[0].Find("System.Windows.DataTemplateKey", true);
			types[KnownTypes.DataTrigger] = assemblies[0].Find("System.Windows.DataTrigger", true);
			types[KnownTypes.DateTime] = assemblies[3].Find("System.DateTime", true);
			types[KnownTypes.DateTimeConverter] = assemblies[4].Find("System.ComponentModel.DateTimeConverter", true);
			types[KnownTypes.DateTimeConverter2] = assemblies[5].Find("System.Windows.Markup.DateTimeConverter2", true);
			types[KnownTypes.Decimal] = assemblies[3].Find("System.Decimal", true);
			types[KnownTypes.DecimalAnimation] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimation", true);
			types[KnownTypes.DecimalAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimationBase", true);
			types[KnownTypes.DecimalAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.DecimalAnimationUsingKeyFrames", true);
			types[KnownTypes.DecimalConverter] = assemblies[4].Find("System.ComponentModel.DecimalConverter", true);
			types[KnownTypes.DecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrame", true);
			types[KnownTypes.DecimalKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrameCollection", true);
			types[KnownTypes.Decorator] = assemblies[0].Find("System.Windows.Controls.Decorator", true);
			types[KnownTypes.DefinitionBase] = assemblies[0].Find("System.Windows.Controls.DefinitionBase", true);
			types[KnownTypes.DependencyObject] = assemblies[5].Find("System.Windows.DependencyObject", true);
			types[KnownTypes.DependencyProperty] = assemblies[5].Find("System.Windows.DependencyProperty", true);
			types[KnownTypes.DependencyPropertyConverter] = assemblies[0].Find("System.Windows.Markup.DependencyPropertyConverter", true);
			types[KnownTypes.DialogResultConverter] = assemblies[0].Find("System.Windows.DialogResultConverter", true);
			types[KnownTypes.DiffuseMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.DiffuseMaterial", true);
			types[KnownTypes.DirectionalLight] = assemblies[1].Find("System.Windows.Media.Media3D.DirectionalLight", true);
			types[KnownTypes.DiscreteBooleanKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteBooleanKeyFrame", true);
			types[KnownTypes.DiscreteByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteByteKeyFrame", true);
			types[KnownTypes.DiscreteCharKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteCharKeyFrame", true);
			types[KnownTypes.DiscreteColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteColorKeyFrame", true);
			types[KnownTypes.DiscreteDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteDecimalKeyFrame", true);
			types[KnownTypes.DiscreteDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteDoubleKeyFrame", true);
			types[KnownTypes.DiscreteInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt16KeyFrame", true);
			types[KnownTypes.DiscreteInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt32KeyFrame", true);
			types[KnownTypes.DiscreteInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteInt64KeyFrame", true);
			types[KnownTypes.DiscreteMatrixKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteMatrixKeyFrame", true);
			types[KnownTypes.DiscreteObjectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteObjectKeyFrame", true);
			types[KnownTypes.DiscretePoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscretePoint3DKeyFrame", true);
			types[KnownTypes.DiscretePointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscretePointKeyFrame", true);
			types[KnownTypes.DiscreteQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteQuaternionKeyFrame", true);
			types[KnownTypes.DiscreteRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteRectKeyFrame", true);
			types[KnownTypes.DiscreteRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteRotation3DKeyFrame", true);
			types[KnownTypes.DiscreteSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteSingleKeyFrame", true);
			types[KnownTypes.DiscreteSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteSizeKeyFrame", true);
			types[KnownTypes.DiscreteStringKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteStringKeyFrame", true);
			types[KnownTypes.DiscreteThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.DiscreteThicknessKeyFrame", true);
			types[KnownTypes.DiscreteVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteVector3DKeyFrame", true);
			types[KnownTypes.DiscreteVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DiscreteVectorKeyFrame", true);
			types[KnownTypes.DockPanel] = assemblies[0].Find("System.Windows.Controls.DockPanel", true);
			types[KnownTypes.DocumentPageView] = assemblies[0].Find("System.Windows.Controls.Primitives.DocumentPageView", true);
			types[KnownTypes.DocumentReference] = assemblies[0].Find("System.Windows.Documents.DocumentReference", true);
			types[KnownTypes.DocumentViewer] = assemblies[0].Find("System.Windows.Controls.DocumentViewer", true);
			types[KnownTypes.DocumentViewerBase] = assemblies[0].Find("System.Windows.Controls.Primitives.DocumentViewerBase", true);
			types[KnownTypes.Double] = assemblies[3].Find("System.Double", true);
			types[KnownTypes.DoubleAnimation] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimation", true);
			types[KnownTypes.DoubleAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationBase", true);
			types[KnownTypes.DoubleAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames", true);
			types[KnownTypes.DoubleAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.DoubleAnimationUsingPath", true);
			types[KnownTypes.DoubleCollection] = assemblies[1].Find("System.Windows.Media.DoubleCollection", true);
			types[KnownTypes.DoubleCollectionConverter] = assemblies[1].Find("System.Windows.Media.DoubleCollectionConverter", true);
			types[KnownTypes.DoubleConverter] = assemblies[4].Find("System.ComponentModel.DoubleConverter", true);
			types[KnownTypes.DoubleIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.DoubleIListConverter", true);
			types[KnownTypes.DoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrame", true);
			types[KnownTypes.DoubleKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrameCollection", true);
			types[KnownTypes.Drawing] = assemblies[1].Find("System.Windows.Media.Drawing", true);
			types[KnownTypes.DrawingBrush] = assemblies[1].Find("System.Windows.Media.DrawingBrush", true);
			types[KnownTypes.DrawingCollection] = assemblies[1].Find("System.Windows.Media.DrawingCollection", true);
			types[KnownTypes.DrawingContext] = assemblies[1].Find("System.Windows.Media.DrawingContext", true);
			types[KnownTypes.DrawingGroup] = assemblies[1].Find("System.Windows.Media.DrawingGroup", true);
			types[KnownTypes.DrawingImage] = assemblies[1].Find("System.Windows.Media.DrawingImage", true);
			types[KnownTypes.DrawingVisual] = assemblies[1].Find("System.Windows.Media.DrawingVisual", true);
			types[KnownTypes.DropShadowBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.DropShadowBitmapEffect", true);
			types[KnownTypes.Duration] = assemblies[1].Find("System.Windows.Duration", true);
			types[KnownTypes.DurationConverter] = assemblies[1].Find("System.Windows.DurationConverter", true);
			types[KnownTypes.DynamicResourceExtension] = assemblies[0].Find("System.Windows.DynamicResourceExtension", true);
			types[KnownTypes.DynamicResourceExtensionConverter] = assemblies[0].Find("System.Windows.DynamicResourceExtensionConverter", true);
			types[KnownTypes.Ellipse] = assemblies[0].Find("System.Windows.Shapes.Ellipse", true);
			types[KnownTypes.EllipseGeometry] = assemblies[1].Find("System.Windows.Media.EllipseGeometry", true);
			types[KnownTypes.EmbossBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.EmbossBitmapEffect", true);
			types[KnownTypes.EmissiveMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.EmissiveMaterial", true);
			types[KnownTypes.EnumConverter] = assemblies[4].Find("System.ComponentModel.EnumConverter", true);
			types[KnownTypes.EventManager] = assemblies[1].Find("System.Windows.EventManager", true);
			types[KnownTypes.EventSetter] = assemblies[0].Find("System.Windows.EventSetter", true);
			types[KnownTypes.EventTrigger] = assemblies[0].Find("System.Windows.EventTrigger", true);
			types[KnownTypes.Expander] = assemblies[0].Find("System.Windows.Controls.Expander", true);
			types[KnownTypes.Expression] = assemblies[5].Find("System.Windows.Expression", true);
			types[KnownTypes.ExpressionConverter] = assemblies[5].Find("System.Windows.ExpressionConverter", true);
			types[KnownTypes.Figure] = assemblies[0].Find("System.Windows.Documents.Figure", true);
			types[KnownTypes.FigureLength] = assemblies[0].Find("System.Windows.FigureLength", true);
			types[KnownTypes.FigureLengthConverter] = assemblies[0].Find("System.Windows.FigureLengthConverter", true);
			types[KnownTypes.FixedDocument] = assemblies[0].Find("System.Windows.Documents.FixedDocument", true);
			types[KnownTypes.FixedDocumentSequence] = assemblies[0].Find("System.Windows.Documents.FixedDocumentSequence", true);
			types[KnownTypes.FixedPage] = assemblies[0].Find("System.Windows.Documents.FixedPage", true);
			types[KnownTypes.Floater] = assemblies[0].Find("System.Windows.Documents.Floater", true);
			types[KnownTypes.FlowDocument] = assemblies[0].Find("System.Windows.Documents.FlowDocument", true);
			types[KnownTypes.FlowDocumentPageViewer] = assemblies[0].Find("System.Windows.Controls.FlowDocumentPageViewer", true);
			types[KnownTypes.FlowDocumentReader] = assemblies[0].Find("System.Windows.Controls.FlowDocumentReader", true);
			types[KnownTypes.FlowDocumentScrollViewer] = assemblies[0].Find("System.Windows.Controls.FlowDocumentScrollViewer", true);
			types[KnownTypes.FocusManager] = assemblies[1].Find("System.Windows.Input.FocusManager", true);
			types[KnownTypes.FontFamily] = assemblies[1].Find("System.Windows.Media.FontFamily", true);
			types[KnownTypes.FontFamilyConverter] = assemblies[1].Find("System.Windows.Media.FontFamilyConverter", true);
			types[KnownTypes.FontSizeConverter] = assemblies[0].Find("System.Windows.FontSizeConverter", true);
			types[KnownTypes.FontStretch] = assemblies[1].Find("System.Windows.FontStretch", true);
			types[KnownTypes.FontStretchConverter] = assemblies[1].Find("System.Windows.FontStretchConverter", true);
			types[KnownTypes.FontStyle] = assemblies[1].Find("System.Windows.FontStyle", true);
			types[KnownTypes.FontStyleConverter] = assemblies[1].Find("System.Windows.FontStyleConverter", true);
			types[KnownTypes.FontWeight] = assemblies[1].Find("System.Windows.FontWeight", true);
			types[KnownTypes.FontWeightConverter] = assemblies[1].Find("System.Windows.FontWeightConverter", true);
			types[KnownTypes.FormatConvertedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.FormatConvertedBitmap", true);
			types[KnownTypes.Frame] = assemblies[0].Find("System.Windows.Controls.Frame", true);
			types[KnownTypes.FrameworkContentElement] = assemblies[0].Find("System.Windows.FrameworkContentElement", true);
			types[KnownTypes.FrameworkElement] = assemblies[0].Find("System.Windows.FrameworkElement", true);
			types[KnownTypes.FrameworkElementFactory] = assemblies[0].Find("System.Windows.FrameworkElementFactory", true);
			types[KnownTypes.FrameworkPropertyMetadata] = assemblies[0].Find("System.Windows.FrameworkPropertyMetadata", true);
			types[KnownTypes.FrameworkPropertyMetadataOptions] = assemblies[0].Find("System.Windows.FrameworkPropertyMetadataOptions", true);
			types[KnownTypes.FrameworkRichTextComposition] = assemblies[0].Find("System.Windows.Documents.FrameworkRichTextComposition", true);
			types[KnownTypes.FrameworkTemplate] = assemblies[0].Find("System.Windows.FrameworkTemplate", true);
			types[KnownTypes.FrameworkTextComposition] = assemblies[0].Find("System.Windows.Documents.FrameworkTextComposition", true);
			types[KnownTypes.Freezable] = assemblies[5].Find("System.Windows.Freezable", true);
			types[KnownTypes.GeneralTransform] = assemblies[1].Find("System.Windows.Media.GeneralTransform", true);
			types[KnownTypes.GeneralTransformCollection] = assemblies[1].Find("System.Windows.Media.GeneralTransformCollection", true);
			types[KnownTypes.GeneralTransformGroup] = assemblies[1].Find("System.Windows.Media.GeneralTransformGroup", true);
			types[KnownTypes.Geometry] = assemblies[1].Find("System.Windows.Media.Geometry", true);
			types[KnownTypes.Geometry3D] = assemblies[1].Find("System.Windows.Media.Media3D.Geometry3D", true);
			types[KnownTypes.GeometryCollection] = assemblies[1].Find("System.Windows.Media.GeometryCollection", true);
			types[KnownTypes.GeometryConverter] = assemblies[1].Find("System.Windows.Media.GeometryConverter", true);
			types[KnownTypes.GeometryDrawing] = assemblies[1].Find("System.Windows.Media.GeometryDrawing", true);
			types[KnownTypes.GeometryGroup] = assemblies[1].Find("System.Windows.Media.GeometryGroup", true);
			types[KnownTypes.GeometryModel3D] = assemblies[1].Find("System.Windows.Media.Media3D.GeometryModel3D", true);
			types[KnownTypes.GestureRecognizer] = assemblies[1].Find("System.Windows.Ink.GestureRecognizer", true);
			types[KnownTypes.GifBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.GifBitmapDecoder", true);
			types[KnownTypes.GifBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.GifBitmapEncoder", true);
			types[KnownTypes.GlyphRun] = assemblies[1].Find("System.Windows.Media.GlyphRun", true);
			types[KnownTypes.GlyphRunDrawing] = assemblies[1].Find("System.Windows.Media.GlyphRunDrawing", true);
			types[KnownTypes.GlyphTypeface] = assemblies[1].Find("System.Windows.Media.GlyphTypeface", true);
			types[KnownTypes.Glyphs] = assemblies[0].Find("System.Windows.Documents.Glyphs", true);
			types[KnownTypes.GradientBrush] = assemblies[1].Find("System.Windows.Media.GradientBrush", true);
			types[KnownTypes.GradientStop] = assemblies[1].Find("System.Windows.Media.GradientStop", true);
			types[KnownTypes.GradientStopCollection] = assemblies[1].Find("System.Windows.Media.GradientStopCollection", true);
			types[KnownTypes.Grid] = assemblies[0].Find("System.Windows.Controls.Grid", true);
			types[KnownTypes.GridLength] = assemblies[0].Find("System.Windows.GridLength", true);
			types[KnownTypes.GridLengthConverter] = assemblies[0].Find("System.Windows.GridLengthConverter", true);
			types[KnownTypes.GridSplitter] = assemblies[0].Find("System.Windows.Controls.GridSplitter", true);
			types[KnownTypes.GridView] = assemblies[0].Find("System.Windows.Controls.GridView", true);
			types[KnownTypes.GridViewColumn] = assemblies[0].Find("System.Windows.Controls.GridViewColumn", true);
			types[KnownTypes.GridViewColumnHeader] = assemblies[0].Find("System.Windows.Controls.GridViewColumnHeader", true);
			types[KnownTypes.GridViewHeaderRowPresenter] = assemblies[0].Find("System.Windows.Controls.GridViewHeaderRowPresenter", true);
			types[KnownTypes.GridViewRowPresenter] = assemblies[0].Find("System.Windows.Controls.GridViewRowPresenter", true);
			types[KnownTypes.GridViewRowPresenterBase] = assemblies[0].Find("System.Windows.Controls.Primitives.GridViewRowPresenterBase", true);
			types[KnownTypes.GroupBox] = assemblies[0].Find("System.Windows.Controls.GroupBox", true);
			types[KnownTypes.GroupItem] = assemblies[0].Find("System.Windows.Controls.GroupItem", true);
			types[KnownTypes.Guid] = assemblies[3].Find("System.Guid", true);
			types[KnownTypes.GuidConverter] = assemblies[4].Find("System.ComponentModel.GuidConverter", true);
			types[KnownTypes.GuidelineSet] = assemblies[1].Find("System.Windows.Media.GuidelineSet", true);
			types[KnownTypes.HeaderedContentControl] = assemblies[0].Find("System.Windows.Controls.HeaderedContentControl", true);
			types[KnownTypes.HeaderedItemsControl] = assemblies[0].Find("System.Windows.Controls.HeaderedItemsControl", true);
			types[KnownTypes.HierarchicalDataTemplate] = assemblies[0].Find("System.Windows.HierarchicalDataTemplate", true);
			types[KnownTypes.HostVisual] = assemblies[1].Find("System.Windows.Media.HostVisual", true);
			types[KnownTypes.Hyperlink] = assemblies[0].Find("System.Windows.Documents.Hyperlink", true);
			types[KnownTypes.IAddChild] = assemblies[1].Find("System.Windows.Markup.IAddChild", true);
			types[KnownTypes.IAddChildInternal] = assemblies[1].Find("System.Windows.Markup.IAddChildInternal", true);
			types[KnownTypes.ICommand] = assemblies[1].Find("System.Windows.Input.ICommand", true);
			types[KnownTypes.IComponentConnector] = assemblies[2].Find("System.Windows.Markup.IComponentConnector", true);
			types[KnownTypes.INameScope] = assemblies[2].Find("System.Windows.Markup.INameScope", true);
			types[KnownTypes.IStyleConnector] = assemblies[0].Find("System.Windows.Markup.IStyleConnector", true);
			types[KnownTypes.IconBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.IconBitmapDecoder", true);
			types[KnownTypes.Image] = assemblies[0].Find("System.Windows.Controls.Image", true);
			types[KnownTypes.ImageBrush] = assemblies[1].Find("System.Windows.Media.ImageBrush", true);
			types[KnownTypes.ImageDrawing] = assemblies[1].Find("System.Windows.Media.ImageDrawing", true);
			types[KnownTypes.ImageMetadata] = assemblies[1].Find("System.Windows.Media.ImageMetadata", true);
			types[KnownTypes.ImageSource] = assemblies[1].Find("System.Windows.Media.ImageSource", true);
			types[KnownTypes.ImageSourceConverter] = assemblies[1].Find("System.Windows.Media.ImageSourceConverter", true);
			types[KnownTypes.InPlaceBitmapMetadataWriter] = assemblies[1].Find("System.Windows.Media.Imaging.InPlaceBitmapMetadataWriter", true);
			types[KnownTypes.InkCanvas] = assemblies[0].Find("System.Windows.Controls.InkCanvas", true);
			types[KnownTypes.InkPresenter] = assemblies[0].Find("System.Windows.Controls.InkPresenter", true);
			types[KnownTypes.Inline] = assemblies[0].Find("System.Windows.Documents.Inline", true);
			types[KnownTypes.InlineCollection] = assemblies[0].Find("System.Windows.Documents.InlineCollection", true);
			types[KnownTypes.InlineUIContainer] = assemblies[0].Find("System.Windows.Documents.InlineUIContainer", true);
			types[KnownTypes.InputBinding] = assemblies[1].Find("System.Windows.Input.InputBinding", true);
			types[KnownTypes.InputDevice] = assemblies[1].Find("System.Windows.Input.InputDevice", true);
			types[KnownTypes.InputLanguageManager] = assemblies[1].Find("System.Windows.Input.InputLanguageManager", true);
			types[KnownTypes.InputManager] = assemblies[1].Find("System.Windows.Input.InputManager", true);
			types[KnownTypes.InputMethod] = assemblies[1].Find("System.Windows.Input.InputMethod", true);
			types[KnownTypes.InputScope] = assemblies[1].Find("System.Windows.Input.InputScope", true);
			types[KnownTypes.InputScopeConverter] = assemblies[1].Find("System.Windows.Input.InputScopeConverter", true);
			types[KnownTypes.InputScopeName] = assemblies[1].Find("System.Windows.Input.InputScopeName", true);
			types[KnownTypes.InputScopeNameConverter] = assemblies[1].Find("System.Windows.Input.InputScopeNameConverter", true);
			types[KnownTypes.Int16] = assemblies[3].Find("System.Int16", true);
			types[KnownTypes.Int16Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int16Animation", true);
			types[KnownTypes.Int16AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int16AnimationBase", true);
			types[KnownTypes.Int16AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int16AnimationUsingKeyFrames", true);
			types[KnownTypes.Int16Converter] = assemblies[4].Find("System.ComponentModel.Int16Converter", true);
			types[KnownTypes.Int16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrame", true);
			types[KnownTypes.Int16KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrameCollection", true);
			types[KnownTypes.Int32] = assemblies[3].Find("System.Int32", true);
			types[KnownTypes.Int32Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int32Animation", true);
			types[KnownTypes.Int32AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int32AnimationBase", true);
			types[KnownTypes.Int32AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int32AnimationUsingKeyFrames", true);
			types[KnownTypes.Int32Collection] = assemblies[1].Find("System.Windows.Media.Int32Collection", true);
			types[KnownTypes.Int32CollectionConverter] = assemblies[1].Find("System.Windows.Media.Int32CollectionConverter", true);
			types[KnownTypes.Int32Converter] = assemblies[4].Find("System.ComponentModel.Int32Converter", true);
			types[KnownTypes.Int32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrame", true);
			types[KnownTypes.Int32KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrameCollection", true);
			types[KnownTypes.Int32Rect] = assemblies[5].Find("System.Windows.Int32Rect", true);
			types[KnownTypes.Int32RectConverter] = assemblies[5].Find("System.Windows.Int32RectConverter", true);
			types[KnownTypes.Int64] = assemblies[3].Find("System.Int64", true);
			types[KnownTypes.Int64Animation] = assemblies[1].Find("System.Windows.Media.Animation.Int64Animation", true);
			types[KnownTypes.Int64AnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Int64AnimationBase", true);
			types[KnownTypes.Int64AnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Int64AnimationUsingKeyFrames", true);
			types[KnownTypes.Int64Converter] = assemblies[4].Find("System.ComponentModel.Int64Converter", true);
			types[KnownTypes.Int64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrame", true);
			types[KnownTypes.Int64KeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrameCollection", true);
			types[KnownTypes.Italic] = assemblies[0].Find("System.Windows.Documents.Italic", true);
			types[KnownTypes.ItemCollection] = assemblies[0].Find("System.Windows.Controls.ItemCollection", true);
			types[KnownTypes.ItemsControl] = assemblies[0].Find("System.Windows.Controls.ItemsControl", true);
			types[KnownTypes.ItemsPanelTemplate] = assemblies[0].Find("System.Windows.Controls.ItemsPanelTemplate", true);
			types[KnownTypes.ItemsPresenter] = assemblies[0].Find("System.Windows.Controls.ItemsPresenter", true);
			types[KnownTypes.JournalEntry] = assemblies[0].Find("System.Windows.Navigation.JournalEntry", true);
			types[KnownTypes.JournalEntryListConverter] = assemblies[0].Find("System.Windows.Navigation.JournalEntryListConverter", true);
			types[KnownTypes.JournalEntryUnifiedViewConverter] = assemblies[0].Find("System.Windows.Navigation.JournalEntryUnifiedViewConverter", true);
			types[KnownTypes.JpegBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.JpegBitmapDecoder", true);
			types[KnownTypes.JpegBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.JpegBitmapEncoder", true);
			types[KnownTypes.KeyBinding] = assemblies[1].Find("System.Windows.Input.KeyBinding", true);
			types[KnownTypes.KeyConverter] = assemblies[5].Find("System.Windows.Input.KeyConverter", true);
			types[KnownTypes.KeyGesture] = assemblies[1].Find("System.Windows.Input.KeyGesture", true);
			types[KnownTypes.KeyGestureConverter] = assemblies[1].Find("System.Windows.Input.KeyGestureConverter", true);
			types[KnownTypes.KeySpline] = assemblies[1].Find("System.Windows.Media.Animation.KeySpline", true);
			types[KnownTypes.KeySplineConverter] = assemblies[1].Find("System.Windows.KeySplineConverter", true);
			types[KnownTypes.KeyTime] = assemblies[1].Find("System.Windows.Media.Animation.KeyTime", true);
			types[KnownTypes.KeyTimeConverter] = assemblies[1].Find("System.Windows.KeyTimeConverter", true);
			types[KnownTypes.KeyboardDevice] = assemblies[1].Find("System.Windows.Input.KeyboardDevice", true);
			types[KnownTypes.Label] = assemblies[0].Find("System.Windows.Controls.Label", true);
			types[KnownTypes.LateBoundBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.LateBoundBitmapDecoder", true);
			types[KnownTypes.LengthConverter] = assemblies[0].Find("System.Windows.LengthConverter", true);
			types[KnownTypes.Light] = assemblies[1].Find("System.Windows.Media.Media3D.Light", true);
			types[KnownTypes.Line] = assemblies[0].Find("System.Windows.Shapes.Line", true);
			types[KnownTypes.LineBreak] = assemblies[0].Find("System.Windows.Documents.LineBreak", true);
			types[KnownTypes.LineGeometry] = assemblies[1].Find("System.Windows.Media.LineGeometry", true);
			types[KnownTypes.LineSegment] = assemblies[1].Find("System.Windows.Media.LineSegment", true);
			types[KnownTypes.LinearByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearByteKeyFrame", true);
			types[KnownTypes.LinearColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearColorKeyFrame", true);
			types[KnownTypes.LinearDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearDecimalKeyFrame", true);
			types[KnownTypes.LinearDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearDoubleKeyFrame", true);
			types[KnownTypes.LinearGradientBrush] = assemblies[1].Find("System.Windows.Media.LinearGradientBrush", true);
			types[KnownTypes.LinearInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt16KeyFrame", true);
			types[KnownTypes.LinearInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt32KeyFrame", true);
			types[KnownTypes.LinearInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearInt64KeyFrame", true);
			types[KnownTypes.LinearPoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearPoint3DKeyFrame", true);
			types[KnownTypes.LinearPointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearPointKeyFrame", true);
			types[KnownTypes.LinearQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearQuaternionKeyFrame", true);
			types[KnownTypes.LinearRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearRectKeyFrame", true);
			types[KnownTypes.LinearRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearRotation3DKeyFrame", true);
			types[KnownTypes.LinearSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearSingleKeyFrame", true);
			types[KnownTypes.LinearSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearSizeKeyFrame", true);
			types[KnownTypes.LinearThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.LinearThicknessKeyFrame", true);
			types[KnownTypes.LinearVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearVector3DKeyFrame", true);
			types[KnownTypes.LinearVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.LinearVectorKeyFrame", true);
			types[KnownTypes.List] = assemblies[0].Find("System.Windows.Documents.List", true);
			types[KnownTypes.ListBox] = assemblies[0].Find("System.Windows.Controls.ListBox", true);
			types[KnownTypes.ListBoxItem] = assemblies[0].Find("System.Windows.Controls.ListBoxItem", true);
			types[KnownTypes.ListCollectionView] = assemblies[0].Find("System.Windows.Data.ListCollectionView", true);
			types[KnownTypes.ListItem] = assemblies[0].Find("System.Windows.Documents.ListItem", true);
			types[KnownTypes.ListView] = assemblies[0].Find("System.Windows.Controls.ListView", true);
			types[KnownTypes.ListViewItem] = assemblies[0].Find("System.Windows.Controls.ListViewItem", true);
			types[KnownTypes.Localization] = assemblies[0].Find("System.Windows.Localization", true);
			types[KnownTypes.LostFocusEventManager] = assemblies[0].Find("System.Windows.LostFocusEventManager", true);
			types[KnownTypes.MarkupExtension] = assemblies[2].Find("System.Windows.Markup.MarkupExtension", true);
			types[KnownTypes.Material] = assemblies[1].Find("System.Windows.Media.Media3D.Material", true);
			types[KnownTypes.MaterialCollection] = assemblies[1].Find("System.Windows.Media.Media3D.MaterialCollection", true);
			types[KnownTypes.MaterialGroup] = assemblies[1].Find("System.Windows.Media.Media3D.MaterialGroup", true);
			types[KnownTypes.Matrix] = assemblies[5].Find("System.Windows.Media.Matrix", true);
			types[KnownTypes.Matrix3D] = assemblies[1].Find("System.Windows.Media.Media3D.Matrix3D", true);
			types[KnownTypes.Matrix3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Matrix3DConverter", true);
			types[KnownTypes.MatrixAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationBase", true);
			types[KnownTypes.MatrixAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationUsingKeyFrames", true);
			types[KnownTypes.MatrixAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.MatrixAnimationUsingPath", true);
			types[KnownTypes.MatrixCamera] = assemblies[1].Find("System.Windows.Media.Media3D.MatrixCamera", true);
			types[KnownTypes.MatrixConverter] = assemblies[5].Find("System.Windows.Media.MatrixConverter", true);
			types[KnownTypes.MatrixKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrame", true);
			types[KnownTypes.MatrixKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrameCollection", true);
			types[KnownTypes.MatrixTransform] = assemblies[1].Find("System.Windows.Media.MatrixTransform", true);
			types[KnownTypes.MatrixTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.MatrixTransform3D", true);
			types[KnownTypes.MediaClock] = assemblies[1].Find("System.Windows.Media.MediaClock", true);
			types[KnownTypes.MediaElement] = assemblies[0].Find("System.Windows.Controls.MediaElement", true);
			types[KnownTypes.MediaPlayer] = assemblies[1].Find("System.Windows.Media.MediaPlayer", true);
			types[KnownTypes.MediaTimeline] = assemblies[1].Find("System.Windows.Media.MediaTimeline", true);
			types[KnownTypes.Menu] = assemblies[0].Find("System.Windows.Controls.Menu", true);
			types[KnownTypes.MenuBase] = assemblies[0].Find("System.Windows.Controls.Primitives.MenuBase", true);
			types[KnownTypes.MenuItem] = assemblies[0].Find("System.Windows.Controls.MenuItem", true);
			types[KnownTypes.MenuScrollingVisibilityConverter] = assemblies[0].Find("System.Windows.Controls.MenuScrollingVisibilityConverter", true);
			types[KnownTypes.MeshGeometry3D] = assemblies[1].Find("System.Windows.Media.Media3D.MeshGeometry3D", true);
			types[KnownTypes.Model3D] = assemblies[1].Find("System.Windows.Media.Media3D.Model3D", true);
			types[KnownTypes.Model3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Model3DCollection", true);
			types[KnownTypes.Model3DGroup] = assemblies[1].Find("System.Windows.Media.Media3D.Model3DGroup", true);
			types[KnownTypes.ModelVisual3D] = assemblies[1].Find("System.Windows.Media.Media3D.ModelVisual3D", true);
			types[KnownTypes.ModifierKeysConverter] = assemblies[5].Find("System.Windows.Input.ModifierKeysConverter", true);
			types[KnownTypes.MouseActionConverter] = assemblies[1].Find("System.Windows.Input.MouseActionConverter", true);
			types[KnownTypes.MouseBinding] = assemblies[1].Find("System.Windows.Input.MouseBinding", true);
			types[KnownTypes.MouseDevice] = assemblies[1].Find("System.Windows.Input.MouseDevice", true);
			types[KnownTypes.MouseGesture] = assemblies[1].Find("System.Windows.Input.MouseGesture", true);
			types[KnownTypes.MouseGestureConverter] = assemblies[1].Find("System.Windows.Input.MouseGestureConverter", true);
			types[KnownTypes.MultiBinding] = assemblies[0].Find("System.Windows.Data.MultiBinding", true);
			types[KnownTypes.MultiBindingExpression] = assemblies[0].Find("System.Windows.Data.MultiBindingExpression", true);
			types[KnownTypes.MultiDataTrigger] = assemblies[0].Find("System.Windows.MultiDataTrigger", true);
			types[KnownTypes.MultiTrigger] = assemblies[0].Find("System.Windows.MultiTrigger", true);
			types[KnownTypes.NameScope] = assemblies[5].Find("System.Windows.NameScope", true);
			types[KnownTypes.NavigationWindow] = assemblies[0].Find("System.Windows.Navigation.NavigationWindow", true);
			types[KnownTypes.NullExtension] = assemblies[2].Find("System.Windows.Markup.NullExtension", true);
			types[KnownTypes.NullableBoolConverter] = assemblies[0].Find("System.Windows.NullableBoolConverter", true);
			types[KnownTypes.NullableConverter] = assemblies[4].Find("System.ComponentModel.NullableConverter", true);
			types[KnownTypes.NumberSubstitution] = assemblies[1].Find("System.Windows.Media.NumberSubstitution", true);
			types[KnownTypes.Object] = assemblies[3].Find("System.Object", true);
			types[KnownTypes.ObjectAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.ObjectAnimationBase", true);
			types[KnownTypes.ObjectAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.ObjectAnimationUsingKeyFrames", true);
			types[KnownTypes.ObjectDataProvider] = assemblies[0].Find("System.Windows.Data.ObjectDataProvider", true);
			types[KnownTypes.ObjectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrame", true);
			types[KnownTypes.ObjectKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrameCollection", true);
			types[KnownTypes.OrthographicCamera] = assemblies[1].Find("System.Windows.Media.Media3D.OrthographicCamera", true);
			types[KnownTypes.OuterGlowBitmapEffect] = assemblies[1].Find("System.Windows.Media.Effects.OuterGlowBitmapEffect", true);
			types[KnownTypes.Page] = assemblies[0].Find("System.Windows.Controls.Page", true);
			types[KnownTypes.PageContent] = assemblies[0].Find("System.Windows.Documents.PageContent", true);
			types[KnownTypes.PageFunctionBase] = assemblies[0].Find("System.Windows.Navigation.PageFunctionBase", true);
			types[KnownTypes.Panel] = assemblies[0].Find("System.Windows.Controls.Panel", true);
			types[KnownTypes.Paragraph] = assemblies[0].Find("System.Windows.Documents.Paragraph", true);
			types[KnownTypes.ParallelTimeline] = assemblies[1].Find("System.Windows.Media.Animation.ParallelTimeline", true);
			types[KnownTypes.ParserContext] = assemblies[0].Find("System.Windows.Markup.ParserContext", true);
			types[KnownTypes.PasswordBox] = assemblies[0].Find("System.Windows.Controls.PasswordBox", true);
			types[KnownTypes.Path] = assemblies[0].Find("System.Windows.Shapes.Path", true);
			types[KnownTypes.PathFigure] = assemblies[1].Find("System.Windows.Media.PathFigure", true);
			types[KnownTypes.PathFigureCollection] = assemblies[1].Find("System.Windows.Media.PathFigureCollection", true);
			types[KnownTypes.PathFigureCollectionConverter] = assemblies[1].Find("System.Windows.Media.PathFigureCollectionConverter", true);
			types[KnownTypes.PathGeometry] = assemblies[1].Find("System.Windows.Media.PathGeometry", true);
			types[KnownTypes.PathSegment] = assemblies[1].Find("System.Windows.Media.PathSegment", true);
			types[KnownTypes.PathSegmentCollection] = assemblies[1].Find("System.Windows.Media.PathSegmentCollection", true);
			types[KnownTypes.PauseStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.PauseStoryboard", true);
			types[KnownTypes.Pen] = assemblies[1].Find("System.Windows.Media.Pen", true);
			types[KnownTypes.PerspectiveCamera] = assemblies[1].Find("System.Windows.Media.Media3D.PerspectiveCamera", true);
			types[KnownTypes.PixelFormat] = assemblies[1].Find("System.Windows.Media.PixelFormat", true);
			types[KnownTypes.PixelFormatConverter] = assemblies[1].Find("System.Windows.Media.PixelFormatConverter", true);
			types[KnownTypes.PngBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.PngBitmapDecoder", true);
			types[KnownTypes.PngBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.PngBitmapEncoder", true);
			types[KnownTypes.Point] = assemblies[5].Find("System.Windows.Point", true);
			types[KnownTypes.Point3D] = assemblies[1].Find("System.Windows.Media.Media3D.Point3D", true);
			types[KnownTypes.Point3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimation", true);
			types[KnownTypes.Point3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimationBase", true);
			types[KnownTypes.Point3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Point3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Point3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DCollection", true);
			types[KnownTypes.Point3DCollectionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DCollectionConverter", true);
			types[KnownTypes.Point3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point3DConverter", true);
			types[KnownTypes.Point3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrame", true);
			types[KnownTypes.Point3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrameCollection", true);
			types[KnownTypes.Point4D] = assemblies[1].Find("System.Windows.Media.Media3D.Point4D", true);
			types[KnownTypes.Point4DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Point4DConverter", true);
			types[KnownTypes.PointAnimation] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimation", true);
			types[KnownTypes.PointAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationBase", true);
			types[KnownTypes.PointAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationUsingKeyFrames", true);
			types[KnownTypes.PointAnimationUsingPath] = assemblies[1].Find("System.Windows.Media.Animation.PointAnimationUsingPath", true);
			types[KnownTypes.PointCollection] = assemblies[1].Find("System.Windows.Media.PointCollection", true);
			types[KnownTypes.PointCollectionConverter] = assemblies[1].Find("System.Windows.Media.PointCollectionConverter", true);
			types[KnownTypes.PointConverter] = assemblies[5].Find("System.Windows.PointConverter", true);
			types[KnownTypes.PointIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.PointIListConverter", true);
			types[KnownTypes.PointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrame", true);
			types[KnownTypes.PointKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrameCollection", true);
			types[KnownTypes.PointLight] = assemblies[1].Find("System.Windows.Media.Media3D.PointLight", true);
			types[KnownTypes.PointLightBase] = assemblies[1].Find("System.Windows.Media.Media3D.PointLightBase", true);
			types[KnownTypes.PolyBezierSegment] = assemblies[1].Find("System.Windows.Media.PolyBezierSegment", true);
			types[KnownTypes.PolyLineSegment] = assemblies[1].Find("System.Windows.Media.PolyLineSegment", true);
			types[KnownTypes.PolyQuadraticBezierSegment] = assemblies[1].Find("System.Windows.Media.PolyQuadraticBezierSegment", true);
			types[KnownTypes.Polygon] = assemblies[0].Find("System.Windows.Shapes.Polygon", true);
			types[KnownTypes.Polyline] = assemblies[0].Find("System.Windows.Shapes.Polyline", true);
			types[KnownTypes.Popup] = assemblies[0].Find("System.Windows.Controls.Primitives.Popup", true);
			types[KnownTypes.PresentationSource] = assemblies[1].Find("System.Windows.PresentationSource", true);
			types[KnownTypes.PriorityBinding] = assemblies[0].Find("System.Windows.Data.PriorityBinding", true);
			types[KnownTypes.PriorityBindingExpression] = assemblies[0].Find("System.Windows.Data.PriorityBindingExpression", true);
			types[KnownTypes.ProgressBar] = assemblies[0].Find("System.Windows.Controls.ProgressBar", true);
			types[KnownTypes.ProjectionCamera] = assemblies[1].Find("System.Windows.Media.Media3D.ProjectionCamera", true);
			types[KnownTypes.PropertyPath] = assemblies[0].Find("System.Windows.PropertyPath", true);
			types[KnownTypes.PropertyPathConverter] = assemblies[0].Find("System.Windows.PropertyPathConverter", true);
			types[KnownTypes.QuadraticBezierSegment] = assemblies[1].Find("System.Windows.Media.QuadraticBezierSegment", true);
			types[KnownTypes.Quaternion] = assemblies[1].Find("System.Windows.Media.Media3D.Quaternion", true);
			types[KnownTypes.QuaternionAnimation] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimation", true);
			types[KnownTypes.QuaternionAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimationBase", true);
			types[KnownTypes.QuaternionAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionAnimationUsingKeyFrames", true);
			types[KnownTypes.QuaternionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.QuaternionConverter", true);
			types[KnownTypes.QuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrame", true);
			types[KnownTypes.QuaternionKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrameCollection", true);
			types[KnownTypes.QuaternionRotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.QuaternionRotation3D", true);
			types[KnownTypes.RadialGradientBrush] = assemblies[1].Find("System.Windows.Media.RadialGradientBrush", true);
			types[KnownTypes.RadioButton] = assemblies[0].Find("System.Windows.Controls.RadioButton", true);
			types[KnownTypes.RangeBase] = assemblies[0].Find("System.Windows.Controls.Primitives.RangeBase", true);
			types[KnownTypes.Rect] = assemblies[5].Find("System.Windows.Rect", true);
			types[KnownTypes.Rect3D] = assemblies[1].Find("System.Windows.Media.Media3D.Rect3D", true);
			types[KnownTypes.Rect3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Rect3DConverter", true);
			types[KnownTypes.RectAnimation] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimation", true);
			types[KnownTypes.RectAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimationBase", true);
			types[KnownTypes.RectAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.RectAnimationUsingKeyFrames", true);
			types[KnownTypes.RectConverter] = assemblies[5].Find("System.Windows.RectConverter", true);
			types[KnownTypes.RectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrame", true);
			types[KnownTypes.RectKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrameCollection", true);
			types[KnownTypes.Rectangle] = assemblies[0].Find("System.Windows.Shapes.Rectangle", true);
			types[KnownTypes.RectangleGeometry] = assemblies[1].Find("System.Windows.Media.RectangleGeometry", true);
			types[KnownTypes.RelativeSource] = assemblies[0].Find("System.Windows.Data.RelativeSource", true);
			types[KnownTypes.RemoveStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.RemoveStoryboard", true);
			types[KnownTypes.RenderOptions] = assemblies[1].Find("System.Windows.Media.RenderOptions", true);
			types[KnownTypes.RenderTargetBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.RenderTargetBitmap", true);
			types[KnownTypes.RepeatBehavior] = assemblies[1].Find("System.Windows.Media.Animation.RepeatBehavior", true);
			types[KnownTypes.RepeatBehaviorConverter] = assemblies[1].Find("System.Windows.Media.Animation.RepeatBehaviorConverter", true);
			types[KnownTypes.RepeatButton] = assemblies[0].Find("System.Windows.Controls.Primitives.RepeatButton", true);
			types[KnownTypes.ResizeGrip] = assemblies[0].Find("System.Windows.Controls.Primitives.ResizeGrip", true);
			types[KnownTypes.ResourceDictionary] = assemblies[0].Find("System.Windows.ResourceDictionary", true);
			types[KnownTypes.ResourceKey] = assemblies[0].Find("System.Windows.ResourceKey", true);
			types[KnownTypes.ResumeStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.ResumeStoryboard", true);
			types[KnownTypes.RichTextBox] = assemblies[0].Find("System.Windows.Controls.RichTextBox", true);
			types[KnownTypes.RotateTransform] = assemblies[1].Find("System.Windows.Media.RotateTransform", true);
			types[KnownTypes.RotateTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.RotateTransform3D", true);
			types[KnownTypes.Rotation3D] = assemblies[1].Find("System.Windows.Media.Media3D.Rotation3D", true);
			types[KnownTypes.Rotation3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimation", true);
			types[KnownTypes.Rotation3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimationBase", true);
			types[KnownTypes.Rotation3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Rotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrame", true);
			types[KnownTypes.Rotation3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrameCollection", true);
			types[KnownTypes.RoutedCommand] = assemblies[1].Find("System.Windows.Input.RoutedCommand", true);
			types[KnownTypes.RoutedEvent] = assemblies[1].Find("System.Windows.RoutedEvent", true);
			types[KnownTypes.RoutedEventConverter] = assemblies[0].Find("System.Windows.Markup.RoutedEventConverter", true);
			types[KnownTypes.RoutedUICommand] = assemblies[1].Find("System.Windows.Input.RoutedUICommand", true);
			types[KnownTypes.RoutingStrategy] = assemblies[1].Find("System.Windows.RoutingStrategy", true);
			types[KnownTypes.RowDefinition] = assemblies[0].Find("System.Windows.Controls.RowDefinition", true);
			types[KnownTypes.Run] = assemblies[0].Find("System.Windows.Documents.Run", true);
			types[KnownTypes.RuntimeNamePropertyAttribute] = assemblies[2].Find("System.Windows.Markup.RuntimeNamePropertyAttribute", true);
			types[KnownTypes.SByte] = assemblies[3].Find("System.SByte", true);
			types[KnownTypes.SByteConverter] = assemblies[4].Find("System.ComponentModel.SByteConverter", true);
			types[KnownTypes.ScaleTransform] = assemblies[1].Find("System.Windows.Media.ScaleTransform", true);
			types[KnownTypes.ScaleTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.ScaleTransform3D", true);
			types[KnownTypes.ScrollBar] = assemblies[0].Find("System.Windows.Controls.Primitives.ScrollBar", true);
			types[KnownTypes.ScrollContentPresenter] = assemblies[0].Find("System.Windows.Controls.ScrollContentPresenter", true);
			types[KnownTypes.ScrollViewer] = assemblies[0].Find("System.Windows.Controls.ScrollViewer", true);
			types[KnownTypes.Section] = assemblies[0].Find("System.Windows.Documents.Section", true);
			types[KnownTypes.SeekStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.SeekStoryboard", true);
			types[KnownTypes.Selector] = assemblies[0].Find("System.Windows.Controls.Primitives.Selector", true);
			types[KnownTypes.Separator] = assemblies[0].Find("System.Windows.Controls.Separator", true);
			types[KnownTypes.SetStoryboardSpeedRatio] = assemblies[0].Find("System.Windows.Media.Animation.SetStoryboardSpeedRatio", true);
			types[KnownTypes.Setter] = assemblies[0].Find("System.Windows.Setter", true);
			types[KnownTypes.SetterBase] = assemblies[0].Find("System.Windows.SetterBase", true);
			types[KnownTypes.Shape] = assemblies[0].Find("System.Windows.Shapes.Shape", true);
			types[KnownTypes.Single] = assemblies[3].Find("System.Single", true);
			types[KnownTypes.SingleAnimation] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimation", true);
			types[KnownTypes.SingleAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimationBase", true);
			types[KnownTypes.SingleAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.SingleAnimationUsingKeyFrames", true);
			types[KnownTypes.SingleConverter] = assemblies[4].Find("System.ComponentModel.SingleConverter", true);
			types[KnownTypes.SingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrame", true);
			types[KnownTypes.SingleKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrameCollection", true);
			types[KnownTypes.Size] = assemblies[5].Find("System.Windows.Size", true);
			types[KnownTypes.Size3D] = assemblies[1].Find("System.Windows.Media.Media3D.Size3D", true);
			types[KnownTypes.Size3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Size3DConverter", true);
			types[KnownTypes.SizeAnimation] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimation", true);
			types[KnownTypes.SizeAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimationBase", true);
			types[KnownTypes.SizeAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.SizeAnimationUsingKeyFrames", true);
			types[KnownTypes.SizeConverter] = assemblies[5].Find("System.Windows.SizeConverter", true);
			types[KnownTypes.SizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrame", true);
			types[KnownTypes.SizeKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrameCollection", true);
			types[KnownTypes.SkewTransform] = assemblies[1].Find("System.Windows.Media.SkewTransform", true);
			types[KnownTypes.SkipStoryboardToFill] = assemblies[0].Find("System.Windows.Media.Animation.SkipStoryboardToFill", true);
			types[KnownTypes.Slider] = assemblies[0].Find("System.Windows.Controls.Slider", true);
			types[KnownTypes.SolidColorBrush] = assemblies[1].Find("System.Windows.Media.SolidColorBrush", true);
			types[KnownTypes.SoundPlayerAction] = assemblies[0].Find("System.Windows.Controls.SoundPlayerAction", true);
			types[KnownTypes.Span] = assemblies[0].Find("System.Windows.Documents.Span", true);
			types[KnownTypes.SpecularMaterial] = assemblies[1].Find("System.Windows.Media.Media3D.SpecularMaterial", true);
			types[KnownTypes.SpellCheck] = assemblies[0].Find("System.Windows.Controls.SpellCheck", true);
			types[KnownTypes.SplineByteKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineByteKeyFrame", true);
			types[KnownTypes.SplineColorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineColorKeyFrame", true);
			types[KnownTypes.SplineDecimalKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineDecimalKeyFrame", true);
			types[KnownTypes.SplineDoubleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineDoubleKeyFrame", true);
			types[KnownTypes.SplineInt16KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt16KeyFrame", true);
			types[KnownTypes.SplineInt32KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt32KeyFrame", true);
			types[KnownTypes.SplineInt64KeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineInt64KeyFrame", true);
			types[KnownTypes.SplinePoint3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplinePoint3DKeyFrame", true);
			types[KnownTypes.SplinePointKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplinePointKeyFrame", true);
			types[KnownTypes.SplineQuaternionKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineQuaternionKeyFrame", true);
			types[KnownTypes.SplineRectKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineRectKeyFrame", true);
			types[KnownTypes.SplineRotation3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineRotation3DKeyFrame", true);
			types[KnownTypes.SplineSingleKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineSingleKeyFrame", true);
			types[KnownTypes.SplineSizeKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineSizeKeyFrame", true);
			types[KnownTypes.SplineThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.SplineThicknessKeyFrame", true);
			types[KnownTypes.SplineVector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineVector3DKeyFrame", true);
			types[KnownTypes.SplineVectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.SplineVectorKeyFrame", true);
			types[KnownTypes.SpotLight] = assemblies[1].Find("System.Windows.Media.Media3D.SpotLight", true);
			types[KnownTypes.StackPanel] = assemblies[0].Find("System.Windows.Controls.StackPanel", true);
			types[KnownTypes.StaticExtension] = assemblies[2].Find("System.Windows.Markup.StaticExtension", true);
			types[KnownTypes.StaticResourceExtension] = assemblies[0].Find("System.Windows.StaticResourceExtension", true);
			types[KnownTypes.StatusBar] = assemblies[0].Find("System.Windows.Controls.Primitives.StatusBar", true);
			types[KnownTypes.StatusBarItem] = assemblies[0].Find("System.Windows.Controls.Primitives.StatusBarItem", true);
			types[KnownTypes.StickyNoteControl] = assemblies[0].Find("System.Windows.Controls.StickyNoteControl", true);
			types[KnownTypes.StopStoryboard] = assemblies[0].Find("System.Windows.Media.Animation.StopStoryboard", true);
			types[KnownTypes.Storyboard] = assemblies[0].Find("System.Windows.Media.Animation.Storyboard", true);
			types[KnownTypes.StreamGeometry] = assemblies[1].Find("System.Windows.Media.StreamGeometry", true);
			types[KnownTypes.StreamGeometryContext] = assemblies[1].Find("System.Windows.Media.StreamGeometryContext", true);
			types[KnownTypes.StreamResourceInfo] = assemblies[0].Find("System.Windows.Resources.StreamResourceInfo", true);
			types[KnownTypes.String] = assemblies[3].Find("System.String", true);
			types[KnownTypes.StringAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.StringAnimationBase", true);
			types[KnownTypes.StringAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.StringAnimationUsingKeyFrames", true);
			types[KnownTypes.StringConverter] = assemblies[4].Find("System.ComponentModel.StringConverter", true);
			types[KnownTypes.StringKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrame", true);
			types[KnownTypes.StringKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrameCollection", true);
			types[KnownTypes.StrokeCollection] = assemblies[1].Find("System.Windows.Ink.StrokeCollection", true);
			types[KnownTypes.StrokeCollectionConverter] = assemblies[1].Find("System.Windows.StrokeCollectionConverter", true);
			types[KnownTypes.Style] = assemblies[0].Find("System.Windows.Style", true);
			types[KnownTypes.Stylus] = assemblies[1].Find("System.Windows.Input.Stylus", true);
			types[KnownTypes.StylusDevice] = assemblies[1].Find("System.Windows.Input.StylusDevice", true);
			types[KnownTypes.TabControl] = assemblies[0].Find("System.Windows.Controls.TabControl", true);
			types[KnownTypes.TabItem] = assemblies[0].Find("System.Windows.Controls.TabItem", true);
			types[KnownTypes.TabPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.TabPanel", true);
			types[KnownTypes.Table] = assemblies[0].Find("System.Windows.Documents.Table", true);
			types[KnownTypes.TableCell] = assemblies[0].Find("System.Windows.Documents.TableCell", true);
			types[KnownTypes.TableColumn] = assemblies[0].Find("System.Windows.Documents.TableColumn", true);
			types[KnownTypes.TableRow] = assemblies[0].Find("System.Windows.Documents.TableRow", true);
			types[KnownTypes.TableRowGroup] = assemblies[0].Find("System.Windows.Documents.TableRowGroup", true);
			types[KnownTypes.TabletDevice] = assemblies[1].Find("System.Windows.Input.TabletDevice", true);
			types[KnownTypes.TemplateBindingExpression] = assemblies[0].Find("System.Windows.TemplateBindingExpression", true);
			types[KnownTypes.TemplateBindingExpressionConverter] = assemblies[0].Find("System.Windows.TemplateBindingExpressionConverter", true);
			types[KnownTypes.TemplateBindingExtension] = assemblies[0].Find("System.Windows.TemplateBindingExtension", true);
			types[KnownTypes.TemplateBindingExtensionConverter] = assemblies[0].Find("System.Windows.TemplateBindingExtensionConverter", true);
			types[KnownTypes.TemplateKey] = assemblies[0].Find("System.Windows.TemplateKey", true);
			types[KnownTypes.TemplateKeyConverter] = assemblies[0].Find("System.Windows.Markup.TemplateKeyConverter", true);
			types[KnownTypes.TextBlock] = assemblies[0].Find("System.Windows.Controls.TextBlock", true);
			types[KnownTypes.TextBox] = assemblies[0].Find("System.Windows.Controls.TextBox", true);
			types[KnownTypes.TextBoxBase] = assemblies[0].Find("System.Windows.Controls.Primitives.TextBoxBase", true);
			types[KnownTypes.TextComposition] = assemblies[1].Find("System.Windows.Input.TextComposition", true);
			types[KnownTypes.TextCompositionManager] = assemblies[1].Find("System.Windows.Input.TextCompositionManager", true);
			types[KnownTypes.TextDecoration] = assemblies[1].Find("System.Windows.TextDecoration", true);
			types[KnownTypes.TextDecorationCollection] = assemblies[1].Find("System.Windows.TextDecorationCollection", true);
			types[KnownTypes.TextDecorationCollectionConverter] = assemblies[1].Find("System.Windows.TextDecorationCollectionConverter", true);
			types[KnownTypes.TextEffect] = assemblies[1].Find("System.Windows.Media.TextEffect", true);
			types[KnownTypes.TextEffectCollection] = assemblies[1].Find("System.Windows.Media.TextEffectCollection", true);
			types[KnownTypes.TextElement] = assemblies[0].Find("System.Windows.Documents.TextElement", true);
			types[KnownTypes.TextSearch] = assemblies[0].Find("System.Windows.Controls.TextSearch", true);
			types[KnownTypes.ThemeDictionaryExtension] = assemblies[0].Find("System.Windows.ThemeDictionaryExtension", true);
			types[KnownTypes.Thickness] = assemblies[0].Find("System.Windows.Thickness", true);
			types[KnownTypes.ThicknessAnimation] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimation", true);
			types[KnownTypes.ThicknessAnimationBase] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimationBase", true);
			types[KnownTypes.ThicknessAnimationUsingKeyFrames] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessAnimationUsingKeyFrames", true);
			types[KnownTypes.ThicknessConverter] = assemblies[0].Find("System.Windows.ThicknessConverter", true);
			types[KnownTypes.ThicknessKeyFrame] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrame", true);
			types[KnownTypes.ThicknessKeyFrameCollection] = assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrameCollection", true);
			types[KnownTypes.Thumb] = assemblies[0].Find("System.Windows.Controls.Primitives.Thumb", true);
			types[KnownTypes.TickBar] = assemblies[0].Find("System.Windows.Controls.Primitives.TickBar", true);
			types[KnownTypes.TiffBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.TiffBitmapDecoder", true);
			types[KnownTypes.TiffBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.TiffBitmapEncoder", true);
			types[KnownTypes.TileBrush] = assemblies[1].Find("System.Windows.Media.TileBrush", true);
			types[KnownTypes.TimeSpan] = assemblies[3].Find("System.TimeSpan", true);
			types[KnownTypes.TimeSpanConverter] = assemblies[4].Find("System.ComponentModel.TimeSpanConverter", true);
			types[KnownTypes.Timeline] = assemblies[1].Find("System.Windows.Media.Animation.Timeline", true);
			types[KnownTypes.TimelineCollection] = assemblies[1].Find("System.Windows.Media.Animation.TimelineCollection", true);
			types[KnownTypes.TimelineGroup] = assemblies[1].Find("System.Windows.Media.Animation.TimelineGroup", true);
			types[KnownTypes.ToggleButton] = assemblies[0].Find("System.Windows.Controls.Primitives.ToggleButton", true);
			types[KnownTypes.ToolBar] = assemblies[0].Find("System.Windows.Controls.ToolBar", true);
			types[KnownTypes.ToolBarOverflowPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.ToolBarOverflowPanel", true);
			types[KnownTypes.ToolBarPanel] = assemblies[0].Find("System.Windows.Controls.Primitives.ToolBarPanel", true);
			types[KnownTypes.ToolBarTray] = assemblies[0].Find("System.Windows.Controls.ToolBarTray", true);
			types[KnownTypes.ToolTip] = assemblies[0].Find("System.Windows.Controls.ToolTip", true);
			types[KnownTypes.ToolTipService] = assemblies[0].Find("System.Windows.Controls.ToolTipService", true);
			types[KnownTypes.Track] = assemblies[0].Find("System.Windows.Controls.Primitives.Track", true);
			types[KnownTypes.Transform] = assemblies[1].Find("System.Windows.Media.Transform", true);
			types[KnownTypes.Transform3D] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3D", true);
			types[KnownTypes.Transform3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3DCollection", true);
			types[KnownTypes.Transform3DGroup] = assemblies[1].Find("System.Windows.Media.Media3D.Transform3DGroup", true);
			types[KnownTypes.TransformCollection] = assemblies[1].Find("System.Windows.Media.TransformCollection", true);
			types[KnownTypes.TransformConverter] = assemblies[1].Find("System.Windows.Media.TransformConverter", true);
			types[KnownTypes.TransformGroup] = assemblies[1].Find("System.Windows.Media.TransformGroup", true);
			types[KnownTypes.TransformedBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.TransformedBitmap", true);
			types[KnownTypes.TranslateTransform] = assemblies[1].Find("System.Windows.Media.TranslateTransform", true);
			types[KnownTypes.TranslateTransform3D] = assemblies[1].Find("System.Windows.Media.Media3D.TranslateTransform3D", true);
			types[KnownTypes.TreeView] = assemblies[0].Find("System.Windows.Controls.TreeView", true);
			types[KnownTypes.TreeViewItem] = assemblies[0].Find("System.Windows.Controls.TreeViewItem", true);
			types[KnownTypes.Trigger] = assemblies[0].Find("System.Windows.Trigger", true);
			types[KnownTypes.TriggerAction] = assemblies[0].Find("System.Windows.TriggerAction", true);
			types[KnownTypes.TriggerBase] = assemblies[0].Find("System.Windows.TriggerBase", true);
			types[KnownTypes.TypeExtension] = assemblies[2].Find("System.Windows.Markup.TypeExtension", true);
			types[KnownTypes.TypeTypeConverter] = assemblies[5].Find("System.Windows.Markup.TypeTypeConverter", true);
			types[KnownTypes.Typography] = assemblies[0].Find("System.Windows.Documents.Typography", true);
			types[KnownTypes.UIElement] = assemblies[1].Find("System.Windows.UIElement", true);
			types[KnownTypes.UInt16] = assemblies[3].Find("System.UInt16", true);
			types[KnownTypes.UInt16Converter] = assemblies[4].Find("System.ComponentModel.UInt16Converter", true);
			types[KnownTypes.UInt32] = assemblies[3].Find("System.UInt32", true);
			types[KnownTypes.UInt32Converter] = assemblies[4].Find("System.ComponentModel.UInt32Converter", true);
			types[KnownTypes.UInt64] = assemblies[3].Find("System.UInt64", true);
			types[KnownTypes.UInt64Converter] = assemblies[4].Find("System.ComponentModel.UInt64Converter", true);
			types[KnownTypes.UShortIListConverter] = assemblies[1].Find("System.Windows.Media.Converters.UShortIListConverter", true);
			types[KnownTypes.Underline] = assemblies[0].Find("System.Windows.Documents.Underline", true);
			types[KnownTypes.UniformGrid] = assemblies[0].Find("System.Windows.Controls.Primitives.UniformGrid", true);
			types[KnownTypes.Uri] = assemblies[4].Find("System.Uri", true);
			types[KnownTypes.UriTypeConverter] = assemblies[4].Find("System.UriTypeConverter", true);
			types[KnownTypes.UserControl] = assemblies[0].Find("System.Windows.Controls.UserControl", true);
			types[KnownTypes.Validation] = assemblies[0].Find("System.Windows.Controls.Validation", true);
			types[KnownTypes.Vector] = assemblies[5].Find("System.Windows.Vector", true);
			types[KnownTypes.Vector3D] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3D", true);
			types[KnownTypes.Vector3DAnimation] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimation", true);
			types[KnownTypes.Vector3DAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimationBase", true);
			types[KnownTypes.Vector3DAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DAnimationUsingKeyFrames", true);
			types[KnownTypes.Vector3DCollection] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DCollection", true);
			types[KnownTypes.Vector3DCollectionConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DCollectionConverter", true);
			types[KnownTypes.Vector3DConverter] = assemblies[1].Find("System.Windows.Media.Media3D.Vector3DConverter", true);
			types[KnownTypes.Vector3DKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrame", true);
			types[KnownTypes.Vector3DKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrameCollection", true);
			types[KnownTypes.VectorAnimation] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimation", true);
			types[KnownTypes.VectorAnimationBase] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimationBase", true);
			types[KnownTypes.VectorAnimationUsingKeyFrames] = assemblies[1].Find("System.Windows.Media.Animation.VectorAnimationUsingKeyFrames", true);
			types[KnownTypes.VectorCollection] = assemblies[1].Find("System.Windows.Media.VectorCollection", true);
			types[KnownTypes.VectorCollectionConverter] = assemblies[1].Find("System.Windows.Media.VectorCollectionConverter", true);
			types[KnownTypes.VectorConverter] = assemblies[5].Find("System.Windows.VectorConverter", true);
			types[KnownTypes.VectorKeyFrame] = assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrame", true);
			types[KnownTypes.VectorKeyFrameCollection] = assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrameCollection", true);
			types[KnownTypes.VideoDrawing] = assemblies[1].Find("System.Windows.Media.VideoDrawing", true);
			types[KnownTypes.ViewBase] = assemblies[0].Find("System.Windows.Controls.ViewBase", true);
			types[KnownTypes.Viewbox] = assemblies[0].Find("System.Windows.Controls.Viewbox", true);
			types[KnownTypes.Viewport3D] = assemblies[0].Find("System.Windows.Controls.Viewport3D", true);
			types[KnownTypes.Viewport3DVisual] = assemblies[1].Find("System.Windows.Media.Media3D.Viewport3DVisual", true);
			types[KnownTypes.VirtualizingPanel] = assemblies[0].Find("System.Windows.Controls.VirtualizingPanel", true);
			types[KnownTypes.VirtualizingStackPanel] = assemblies[0].Find("System.Windows.Controls.VirtualizingStackPanel", true);
			types[KnownTypes.Visual] = assemblies[1].Find("System.Windows.Media.Visual", true);
			types[KnownTypes.Visual3D] = assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true);
			types[KnownTypes.VisualBrush] = assemblies[1].Find("System.Windows.Media.VisualBrush", true);
			types[KnownTypes.VisualTarget] = assemblies[1].Find("System.Windows.Media.VisualTarget", true);
			types[KnownTypes.WeakEventManager] = assemblies[5].Find("System.Windows.WeakEventManager", true);
			types[KnownTypes.WhitespaceSignificantCollectionAttribute] = assemblies[2].Find("System.Windows.Markup.WhitespaceSignificantCollectionAttribute", true);
			types[KnownTypes.Window] = assemblies[0].Find("System.Windows.Window", true);
			types[KnownTypes.WmpBitmapDecoder] = assemblies[1].Find("System.Windows.Media.Imaging.WmpBitmapDecoder", true);
			types[KnownTypes.WmpBitmapEncoder] = assemblies[1].Find("System.Windows.Media.Imaging.WmpBitmapEncoder", true);
			types[KnownTypes.WrapPanel] = assemblies[0].Find("System.Windows.Controls.WrapPanel", true);
			types[KnownTypes.WriteableBitmap] = assemblies[1].Find("System.Windows.Media.Imaging.WriteableBitmap", true);
			types[KnownTypes.XamlBrushSerializer] = assemblies[0].Find("System.Windows.Markup.XamlBrushSerializer", true);
			types[KnownTypes.XamlInt32CollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlInt32CollectionSerializer", true);
			types[KnownTypes.XamlPathDataSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPathDataSerializer", true);
			types[KnownTypes.XamlPoint3DCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPoint3DCollectionSerializer", true);
			types[KnownTypes.XamlPointCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlPointCollectionSerializer", true);
			types[KnownTypes.XamlReader] = assemblies[0].Find("System.Windows.Markup.XamlReader", true);
			types[KnownTypes.XamlStyleSerializer] = assemblies[0].Find("System.Windows.Markup.XamlStyleSerializer", true);
			types[KnownTypes.XamlTemplateSerializer] = assemblies[0].Find("System.Windows.Markup.XamlTemplateSerializer", true);
			types[KnownTypes.XamlVector3DCollectionSerializer] = assemblies[0].Find("System.Windows.Markup.XamlVector3DCollectionSerializer", true);
			types[KnownTypes.XamlWriter] = assemblies[0].Find("System.Windows.Markup.XamlWriter", true);
			types[KnownTypes.XmlDataProvider] = assemblies[0].Find("System.Windows.Data.XmlDataProvider", true);
			types[KnownTypes.XmlLangPropertyAttribute] = assemblies[2].Find("System.Windows.Markup.XmlLangPropertyAttribute", true);
			types[KnownTypes.XmlLanguage] = assemblies[1].Find("System.Windows.Markup.XmlLanguage", true);
			types[KnownTypes.XmlLanguageConverter] = assemblies[1].Find("System.Windows.Markup.XmlLanguageConverter", true);
			types[KnownTypes.XmlNamespaceMapping] = assemblies[0].Find("System.Windows.Data.XmlNamespaceMapping", true);
			types[KnownTypes.ZoomPercentageConverter] = assemblies[0].Find("System.Windows.Documents.ZoomPercentageConverter", true);
		}

		void InitProperties() {
			properties[KnownProperties.AccessText_Text] = InitProperty(KnownTypes.AccessText, "Text", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.BeginStoryboard_Storyboard] = InitProperty(KnownTypes.BeginStoryboard, "Storyboard", assemblies[0].Find("System.Windows.Media.Animation.Storyboard", true));
			properties[KnownProperties.BitmapEffectGroup_Children] = InitProperty(KnownTypes.BitmapEffectGroup, "Children", assemblies[1].Find("System.Windows.Media.Effects.BitmapEffect", true));
			properties[KnownProperties.Border_Background] = InitProperty(KnownTypes.Border, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Border_BorderBrush] = InitProperty(KnownTypes.Border, "BorderBrush", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Border_BorderThickness] = InitProperty(KnownTypes.Border, "BorderThickness", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.ButtonBase_Command] = InitProperty(KnownTypes.ButtonBase, "Command", assemblies[1].Find("System.Windows.Input.ICommand", true));
			properties[KnownProperties.ButtonBase_CommandParameter] = InitProperty(KnownTypes.ButtonBase, "CommandParameter", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ButtonBase_CommandTarget] = InitProperty(KnownTypes.ButtonBase, "CommandTarget", assemblies[1].Find("System.Windows.IInputElement", true));
			properties[KnownProperties.ButtonBase_IsPressed] = InitProperty(KnownTypes.ButtonBase, "IsPressed", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.ColumnDefinition_MaxWidth] = InitProperty(KnownTypes.ColumnDefinition, "MaxWidth", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.ColumnDefinition_MinWidth] = InitProperty(KnownTypes.ColumnDefinition, "MinWidth", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.ColumnDefinition_Width] = InitProperty(KnownTypes.ColumnDefinition, "Width", assemblies[0].Find("System.Windows.GridLength", true));
			properties[KnownProperties.ContentControl_Content] = InitProperty(KnownTypes.ContentControl, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ContentControl_ContentTemplate] = InitProperty(KnownTypes.ContentControl, "ContentTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ContentControl_ContentTemplateSelector] = InitProperty(KnownTypes.ContentControl, "ContentTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ContentControl_HasContent] = InitProperty(KnownTypes.ContentControl, "HasContent", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.ContentElement_Focusable] = InitProperty(KnownTypes.ContentElement, "Focusable", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.ContentPresenter_Content] = InitProperty(KnownTypes.ContentPresenter, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ContentPresenter_ContentSource] = InitProperty(KnownTypes.ContentPresenter, "ContentSource", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.ContentPresenter_ContentTemplate] = InitProperty(KnownTypes.ContentPresenter, "ContentTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ContentPresenter_ContentTemplateSelector] = InitProperty(KnownTypes.ContentPresenter, "ContentTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ContentPresenter_RecognizesAccessKey] = InitProperty(KnownTypes.ContentPresenter, "RecognizesAccessKey", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.Control_Background] = InitProperty(KnownTypes.Control, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_BorderBrush] = InitProperty(KnownTypes.Control, "BorderBrush", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_BorderThickness] = InitProperty(KnownTypes.Control, "BorderThickness", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.Control_FontFamily] = InitProperty(KnownTypes.Control, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.Control_FontSize] = InitProperty(KnownTypes.Control, "FontSize", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Control_FontStretch] = InitProperty(KnownTypes.Control, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.Control_FontStyle] = InitProperty(KnownTypes.Control, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.Control_FontWeight] = InitProperty(KnownTypes.Control, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.Control_Foreground] = InitProperty(KnownTypes.Control, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Control_HorizontalContentAlignment] = InitProperty(KnownTypes.Control, "HorizontalContentAlignment", assemblies[0].Find("System.Windows.HorizontalAlignment", true));
			properties[KnownProperties.Control_IsTabStop] = InitProperty(KnownTypes.Control, null, assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.Control_Padding] = InitProperty(KnownTypes.Control, "Padding", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.Control_TabIndex] = InitProperty(KnownTypes.Control, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.Control_Template] = InitProperty(KnownTypes.Control, "Template", assemblies[0].Find("System.Windows.Controls.ControlTemplate", true));
			properties[KnownProperties.Control_VerticalContentAlignment] = InitProperty(KnownTypes.Control, "VerticalContentAlignment", assemblies[0].Find("System.Windows.VerticalAlignment", true));
			properties[KnownProperties.DockPanel_Dock] = InitProperty(KnownTypes.DockPanel, null, assemblies[0].Find("System.Windows.Controls.Dock", true));
			properties[KnownProperties.DockPanel_LastChildFill] = InitProperty(KnownTypes.DockPanel, "LastChildFill", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.DocumentViewerBase_Document] = InitProperty(KnownTypes.DocumentViewerBase, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.DrawingGroup_Children] = InitProperty(KnownTypes.DrawingGroup, "Children", assemblies[1].Find("System.Windows.Media.Drawing", true));
			properties[KnownProperties.FlowDocumentReader_Document] = InitProperty(KnownTypes.FlowDocumentReader, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.FlowDocumentScrollViewer_Document] = InitProperty(KnownTypes.FlowDocumentScrollViewer, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.FrameworkContentElement_Style] = InitProperty(KnownTypes.FrameworkContentElement, "Style", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.FrameworkElement_FlowDirection] = InitProperty(KnownTypes.FrameworkElement, "FlowDirection", assemblies[1].Find("System.Windows.FlowDirection", true));
			properties[KnownProperties.FrameworkElement_Height] = InitProperty(KnownTypes.FrameworkElement, "Height", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_HorizontalAlignment] = InitProperty(KnownTypes.FrameworkElement, "HorizontalAlignment", assemblies[0].Find("System.Windows.HorizontalAlignment", true));
			properties[KnownProperties.FrameworkElement_Margin] = InitProperty(KnownTypes.FrameworkElement, "Margin", assemblies[0].Find("System.Windows.Thickness", true));
			properties[KnownProperties.FrameworkElement_MaxHeight] = InitProperty(KnownTypes.FrameworkElement, "MaxHeight", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MaxWidth] = InitProperty(KnownTypes.FrameworkElement, "MaxWidth", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MinHeight] = InitProperty(KnownTypes.FrameworkElement, "MinHeight", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_MinWidth] = InitProperty(KnownTypes.FrameworkElement, "MinWidth", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.FrameworkElement_Name] = InitProperty(KnownTypes.FrameworkElement, "Name", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.FrameworkElement_Style] = InitProperty(KnownTypes.FrameworkElement, "Style", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.FrameworkElement_VerticalAlignment] = InitProperty(KnownTypes.FrameworkElement, "VerticalAlignment", assemblies[0].Find("System.Windows.VerticalAlignment", true));
			properties[KnownProperties.FrameworkElement_Width] = InitProperty(KnownTypes.FrameworkElement, "Width", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.GeneralTransformGroup_Children] = InitProperty(KnownTypes.GeneralTransformGroup, "Children", assemblies[1].Find("System.Windows.Media.GeneralTransform", true));
			properties[KnownProperties.GeometryGroup_Children] = InitProperty(KnownTypes.GeometryGroup, "Children", assemblies[1].Find("System.Windows.Media.Geometry", true));
			properties[KnownProperties.GradientBrush_GradientStops] = InitProperty(KnownTypes.GradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.Grid_Column] = InitProperty(KnownTypes.Grid, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.Grid_ColumnSpan] = InitProperty(KnownTypes.Grid, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.Grid_Row] = InitProperty(KnownTypes.Grid, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.Grid_RowSpan] = InitProperty(KnownTypes.Grid, null, assemblies[3].Find("System.Int32", true));
			properties[KnownProperties.GridViewColumn_Header] = InitProperty(KnownTypes.GridViewColumn, "Header", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_HasHeader] = InitProperty(KnownTypes.HeaderedContentControl, "HasHeader", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.HeaderedContentControl_Header] = InitProperty(KnownTypes.HeaderedContentControl, "Header", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_HeaderTemplate] = InitProperty(KnownTypes.HeaderedContentControl, "HeaderTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.HeaderedContentControl_HeaderTemplateSelector] = InitProperty(KnownTypes.HeaderedContentControl, "HeaderTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.HeaderedItemsControl_HasHeader] = InitProperty(KnownTypes.HeaderedItemsControl, "HasHeader", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.HeaderedItemsControl_Header] = InitProperty(KnownTypes.HeaderedItemsControl, "Header", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedItemsControl_HeaderTemplate] = InitProperty(KnownTypes.HeaderedItemsControl, "HeaderTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.HeaderedItemsControl_HeaderTemplateSelector] = InitProperty(KnownTypes.HeaderedItemsControl, "HeaderTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.Hyperlink_NavigateUri] = InitProperty(KnownTypes.Hyperlink, "NavigateUri", assemblies[4].Find("System.Uri", true));
			properties[KnownProperties.Image_Source] = InitProperty(KnownTypes.Image, "Source", assemblies[1].Find("System.Windows.Media.ImageSource", true));
			properties[KnownProperties.Image_Stretch] = InitProperty(KnownTypes.Image, "Stretch", assemblies[1].Find("System.Windows.Media.Stretch", true));
			properties[KnownProperties.ItemsControl_ItemContainerStyle] = InitProperty(KnownTypes.ItemsControl, "ItemContainerStyle", assemblies[0].Find("System.Windows.Style", true));
			properties[KnownProperties.ItemsControl_ItemContainerStyleSelector] = InitProperty(KnownTypes.ItemsControl, "ItemContainerStyleSelector", assemblies[0].Find("System.Windows.Controls.StyleSelector", true));
			properties[KnownProperties.ItemsControl_ItemTemplate] = InitProperty(KnownTypes.ItemsControl, "ItemTemplate", assemblies[0].Find("System.Windows.DataTemplate", true));
			properties[KnownProperties.ItemsControl_ItemTemplateSelector] = InitProperty(KnownTypes.ItemsControl, "ItemTemplateSelector", assemblies[0].Find("System.Windows.Controls.DataTemplateSelector", true));
			properties[KnownProperties.ItemsControl_ItemsPanel] = InitProperty(KnownTypes.ItemsControl, "ItemsPanel", assemblies[0].Find("System.Windows.Controls.ItemsPanelTemplate", true));
			properties[KnownProperties.ItemsControl_ItemsSource] = InitProperty(KnownTypes.ItemsControl, "ItemsSource", assemblies[3].Find("System.Collections.IEnumerable", true));
			properties[KnownProperties.MaterialGroup_Children] = InitProperty(KnownTypes.MaterialGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Material", true));
			properties[KnownProperties.Model3DGroup_Children] = InitProperty(KnownTypes.Model3DGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Model3D", true));
			properties[KnownProperties.Page_Content] = InitProperty(KnownTypes.Page, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Panel_Background] = InitProperty(KnownTypes.Panel, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Path_Data] = InitProperty(KnownTypes.Path, "Data", assemblies[1].Find("System.Windows.Media.Geometry", true));
			properties[KnownProperties.PathFigure_Segments] = InitProperty(KnownTypes.PathFigure, "Segments", assemblies[1].Find("System.Windows.Media.PathSegment", true));
			properties[KnownProperties.PathGeometry_Figures] = InitProperty(KnownTypes.PathGeometry, "Figures", assemblies[1].Find("System.Windows.Media.PathFigure", true));
			properties[KnownProperties.Popup_Child] = InitProperty(KnownTypes.Popup, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Popup_IsOpen] = InitProperty(KnownTypes.Popup, "IsOpen", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.Popup_Placement] = InitProperty(KnownTypes.Popup, "Placement", assemblies[0].Find("System.Windows.Controls.Primitives.PlacementMode", true));
			properties[KnownProperties.Popup_PopupAnimation] = InitProperty(KnownTypes.Popup, "PopupAnimation", assemblies[0].Find("System.Windows.Controls.Primitives.PopupAnimation", true));
			properties[KnownProperties.RowDefinition_Height] = InitProperty(KnownTypes.RowDefinition, "Height", assemblies[0].Find("System.Windows.GridLength", true));
			properties[KnownProperties.RowDefinition_MaxHeight] = InitProperty(KnownTypes.RowDefinition, "MaxHeight", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.RowDefinition_MinHeight] = InitProperty(KnownTypes.RowDefinition, "MinHeight", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.ScrollViewer_CanContentScroll] = InitProperty(KnownTypes.ScrollViewer, "CanContentScroll", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.ScrollViewer_HorizontalScrollBarVisibility] = InitProperty(KnownTypes.ScrollViewer, "HorizontalScrollBarVisibility", assemblies[0].Find("System.Windows.Controls.ScrollBarVisibility", true));
			properties[KnownProperties.ScrollViewer_VerticalScrollBarVisibility] = InitProperty(KnownTypes.ScrollViewer, "VerticalScrollBarVisibility", assemblies[0].Find("System.Windows.Controls.ScrollBarVisibility", true));
			properties[KnownProperties.Shape_Fill] = InitProperty(KnownTypes.Shape, "Fill", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Shape_Stroke] = InitProperty(KnownTypes.Shape, "Stroke", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.Shape_StrokeThickness] = InitProperty(KnownTypes.Shape, "StrokeThickness", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.TextBlock_Background] = InitProperty(KnownTypes.TextBlock, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextBlock_FontFamily] = InitProperty(KnownTypes.TextBlock, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.TextBlock_FontSize] = InitProperty(KnownTypes.TextBlock, "FontSize", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.TextBlock_FontStretch] = InitProperty(KnownTypes.TextBlock, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.TextBlock_FontStyle] = InitProperty(KnownTypes.TextBlock, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.TextBlock_FontWeight] = InitProperty(KnownTypes.TextBlock, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.TextBlock_Foreground] = InitProperty(KnownTypes.TextBlock, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextBlock_Text] = InitProperty(KnownTypes.TextBlock, "Text", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.TextBlock_TextDecorations] = InitProperty(KnownTypes.TextBlock, "TextDecorations", assemblies[1].Find("System.Windows.TextDecoration", true));
			properties[KnownProperties.TextBlock_TextTrimming] = InitProperty(KnownTypes.TextBlock, "TextTrimming", assemblies[1].Find("System.Windows.TextTrimming", true));
			properties[KnownProperties.TextBlock_TextWrapping] = InitProperty(KnownTypes.TextBlock, "TextWrapping", assemblies[1].Find("System.Windows.TextWrapping", true));
			properties[KnownProperties.TextBox_Text] = InitProperty(KnownTypes.TextBox, "Text", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.TextElement_Background] = InitProperty(KnownTypes.TextElement, "Background", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TextElement_FontFamily] = InitProperty(KnownTypes.TextElement, "FontFamily", assemblies[1].Find("System.Windows.Media.FontFamily", true));
			properties[KnownProperties.TextElement_FontSize] = InitProperty(KnownTypes.TextElement, "FontSize", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.TextElement_FontStretch] = InitProperty(KnownTypes.TextElement, "FontStretch", assemblies[1].Find("System.Windows.FontStretch", true));
			properties[KnownProperties.TextElement_FontStyle] = InitProperty(KnownTypes.TextElement, "FontStyle", assemblies[1].Find("System.Windows.FontStyle", true));
			properties[KnownProperties.TextElement_FontWeight] = InitProperty(KnownTypes.TextElement, "FontWeight", assemblies[1].Find("System.Windows.FontWeight", true));
			properties[KnownProperties.TextElement_Foreground] = InitProperty(KnownTypes.TextElement, "Foreground", assemblies[1].Find("System.Windows.Media.Brush", true));
			properties[KnownProperties.TimelineGroup_Children] = InitProperty(KnownTypes.TimelineGroup, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.Track_IsDirectionReversed] = InitProperty(KnownTypes.Track, "IsDirectionReversed", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.Track_Maximum] = InitProperty(KnownTypes.Track, "Maximum", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Track_Minimum] = InitProperty(KnownTypes.Track, "Minimum", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Track_Orientation] = InitProperty(KnownTypes.Track, "Orientation", assemblies[0].Find("System.Windows.Controls.Orientation", true));
			properties[KnownProperties.Track_Value] = InitProperty(KnownTypes.Track, "Value", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Track_ViewportSize] = InitProperty(KnownTypes.Track, "ViewportSize", assemblies[3].Find("System.Double", true));
			properties[KnownProperties.Transform3DGroup_Children] = InitProperty(KnownTypes.Transform3DGroup, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Transform3D", true));
			properties[KnownProperties.TransformGroup_Children] = InitProperty(KnownTypes.TransformGroup, "Children", assemblies[1].Find("System.Windows.Media.Transform", true));
			properties[KnownProperties.UIElement_ClipToBounds] = InitProperty(KnownTypes.UIElement, "ClipToBounds", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_Focusable] = InitProperty(KnownTypes.UIElement, "Focusable", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_IsEnabled] = InitProperty(KnownTypes.UIElement, "IsEnabled", assemblies[3].Find("System.Boolean", true));
			properties[KnownProperties.UIElement_RenderTransform] = InitProperty(KnownTypes.UIElement, "RenderTransform", assemblies[1].Find("System.Windows.Media.Transform", true));
			properties[KnownProperties.UIElement_Visibility] = InitProperty(KnownTypes.UIElement, "Visibility", assemblies[1].Find("System.Windows.Visibility", true));
			properties[KnownProperties.Viewport3D_Children] = InitProperty(KnownTypes.Viewport3D, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.AdornedElementPlaceholder_Child] = InitProperty(KnownTypes.AdornedElementPlaceholder, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.AdornerDecorator_Child] = InitProperty(KnownTypes.AdornerDecorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.AnchoredBlock_Blocks] = InitProperty(KnownTypes.AnchoredBlock, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.ArrayExtension_Items] = InitProperty(KnownTypes.ArrayExtension, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.BlockUIContainer_Child] = InitProperty(KnownTypes.BlockUIContainer, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Bold_Inlines] = InitProperty(KnownTypes.Bold, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.BooleanAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.BooleanAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.BooleanKeyFrame", true));
			properties[KnownProperties.Border_Child] = InitProperty(KnownTypes.Border, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.BulletDecorator_Child] = InitProperty(KnownTypes.BulletDecorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Button_Content] = InitProperty(KnownTypes.Button, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ButtonBase_Content] = InitProperty(KnownTypes.ButtonBase, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ByteAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ByteAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ByteKeyFrame", true));
			properties[KnownProperties.Canvas_Children] = InitProperty(KnownTypes.Canvas, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.CharAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.CharAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.CharKeyFrame", true));
			properties[KnownProperties.CheckBox_Content] = InitProperty(KnownTypes.CheckBox, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ColorAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ColorAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ColorKeyFrame", true));
			properties[KnownProperties.ComboBox_Items] = InitProperty(KnownTypes.ComboBox, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ComboBoxItem_Content] = InitProperty(KnownTypes.ComboBoxItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ContextMenu_Items] = InitProperty(KnownTypes.ContextMenu, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ControlTemplate_VisualTree] = InitProperty(KnownTypes.ControlTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.DataTemplate_VisualTree] = InitProperty(KnownTypes.DataTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.DataTrigger_Setters] = InitProperty(KnownTypes.DataTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.DecimalAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.DecimalAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.DecimalKeyFrame", true));
			properties[KnownProperties.Decorator_Child] = InitProperty(KnownTypes.Decorator, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.DockPanel_Children] = InitProperty(KnownTypes.DockPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.DocumentViewer_Document] = InitProperty(KnownTypes.DocumentViewer, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.DoubleAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.DoubleAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.DoubleKeyFrame", true));
			properties[KnownProperties.EventTrigger_Actions] = InitProperty(KnownTypes.EventTrigger, "Actions", assemblies[0].Find("System.Windows.TriggerAction", true));
			properties[KnownProperties.Expander_Content] = InitProperty(KnownTypes.Expander, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Figure_Blocks] = InitProperty(KnownTypes.Figure, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FixedDocument_Pages] = InitProperty(KnownTypes.FixedDocument, "Pages", assemblies[0].Find("System.Windows.Documents.PageContent", true));
			properties[KnownProperties.FixedDocumentSequence_References] = InitProperty(KnownTypes.FixedDocumentSequence, "References", assemblies[0].Find("System.Windows.Documents.DocumentReference", true));
			properties[KnownProperties.FixedPage_Children] = InitProperty(KnownTypes.FixedPage, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Floater_Blocks] = InitProperty(KnownTypes.Floater, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FlowDocument_Blocks] = InitProperty(KnownTypes.FlowDocument, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.FlowDocumentPageViewer_Document] = InitProperty(KnownTypes.FlowDocumentPageViewer, "Document", assemblies[1].Find("System.Windows.Documents.IDocumentPaginatorSource", true));
			properties[KnownProperties.FrameworkTemplate_VisualTree] = InitProperty(KnownTypes.FrameworkTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Grid_Children] = InitProperty(KnownTypes.Grid, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.GridView_Columns] = InitProperty(KnownTypes.GridView, "Columns", assemblies[0].Find("System.Windows.Controls.GridViewColumn", true));
			properties[KnownProperties.GridViewColumnHeader_Content] = InitProperty(KnownTypes.GridViewColumnHeader, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.GroupBox_Content] = InitProperty(KnownTypes.GroupBox, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.GroupItem_Content] = InitProperty(KnownTypes.GroupItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedContentControl_Content] = InitProperty(KnownTypes.HeaderedContentControl, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HeaderedItemsControl_Items] = InitProperty(KnownTypes.HeaderedItemsControl, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.HierarchicalDataTemplate_VisualTree] = InitProperty(KnownTypes.HierarchicalDataTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Hyperlink_Inlines] = InitProperty(KnownTypes.Hyperlink, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.InkCanvas_Children] = InitProperty(KnownTypes.InkCanvas, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InkPresenter_Child] = InitProperty(KnownTypes.InkPresenter, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InlineUIContainer_Child] = InitProperty(KnownTypes.InlineUIContainer, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.InputScopeName_NameValue] = InitProperty(KnownTypes.InputScopeName, "NameValue", assemblies[1].Find("System.Windows.Input.InputScopeNameValue", true));
			properties[KnownProperties.Int16AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int16AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int16KeyFrame", true));
			properties[KnownProperties.Int32AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int32AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int32KeyFrame", true));
			properties[KnownProperties.Int64AnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Int64AnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Int64KeyFrame", true));
			properties[KnownProperties.Italic_Inlines] = InitProperty(KnownTypes.Italic, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ItemsControl_Items] = InitProperty(KnownTypes.ItemsControl, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ItemsPanelTemplate_VisualTree] = InitProperty(KnownTypes.ItemsPanelTemplate, "VisualTree", assemblies[0].Find("System.Windows.FrameworkElementFactory", true));
			properties[KnownProperties.Label_Content] = InitProperty(KnownTypes.Label, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.LinearGradientBrush_GradientStops] = InitProperty(KnownTypes.LinearGradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.List_ListItems] = InitProperty(KnownTypes.List, "ListItems", assemblies[0].Find("System.Windows.Documents.ListItem", true));
			properties[KnownProperties.ListBox_Items] = InitProperty(KnownTypes.ListBox, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ListBoxItem_Content] = InitProperty(KnownTypes.ListBoxItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ListItem_Blocks] = InitProperty(KnownTypes.ListItem, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.ListView_Items] = InitProperty(KnownTypes.ListView, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ListViewItem_Content] = InitProperty(KnownTypes.ListViewItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.MatrixAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.MatrixAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.MatrixKeyFrame", true));
			properties[KnownProperties.Menu_Items] = InitProperty(KnownTypes.Menu, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.MenuBase_Items] = InitProperty(KnownTypes.MenuBase, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.MenuItem_Items] = InitProperty(KnownTypes.MenuItem, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ModelVisual3D_Children] = InitProperty(KnownTypes.ModelVisual3D, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.MultiBinding_Bindings] = InitProperty(KnownTypes.MultiBinding, "Bindings", assemblies[0].Find("System.Windows.Data.BindingBase", true));
			properties[KnownProperties.MultiDataTrigger_Setters] = InitProperty(KnownTypes.MultiDataTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.MultiTrigger_Setters] = InitProperty(KnownTypes.MultiTrigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.ObjectAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ObjectAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.ObjectKeyFrame", true));
			properties[KnownProperties.PageContent_Child] = InitProperty(KnownTypes.PageContent, "Child", assemblies[0].Find("System.Windows.Documents.FixedPage", true));
			properties[KnownProperties.PageFunctionBase_Content] = InitProperty(KnownTypes.PageFunctionBase, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Panel_Children] = InitProperty(KnownTypes.Panel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Paragraph_Inlines] = InitProperty(KnownTypes.Paragraph, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ParallelTimeline_Children] = InitProperty(KnownTypes.ParallelTimeline, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.Point3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Point3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Point3DKeyFrame", true));
			properties[KnownProperties.PointAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.PointAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.PointKeyFrame", true));
			properties[KnownProperties.PriorityBinding_Bindings] = InitProperty(KnownTypes.PriorityBinding, "Bindings", assemblies[0].Find("System.Windows.Data.BindingBase", true));
			properties[KnownProperties.QuaternionAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.QuaternionAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.QuaternionKeyFrame", true));
			properties[KnownProperties.RadialGradientBrush_GradientStops] = InitProperty(KnownTypes.RadialGradientBrush, "GradientStops", assemblies[1].Find("System.Windows.Media.GradientStop", true));
			properties[KnownProperties.RadioButton_Content] = InitProperty(KnownTypes.RadioButton, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.RectAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.RectAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.RectKeyFrame", true));
			properties[KnownProperties.RepeatButton_Content] = InitProperty(KnownTypes.RepeatButton, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.RichTextBox_Document] = InitProperty(KnownTypes.RichTextBox, "Document", assemblies[0].Find("System.Windows.Documents.FlowDocument", true));
			properties[KnownProperties.Rotation3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Rotation3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Rotation3DKeyFrame", true));
			properties[KnownProperties.Run_Text] = InitProperty(KnownTypes.Run, "Text", assemblies[3].Find("System.Char", true));
			properties[KnownProperties.ScrollViewer_Content] = InitProperty(KnownTypes.ScrollViewer, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Section_Blocks] = InitProperty(KnownTypes.Section, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.Selector_Items] = InitProperty(KnownTypes.Selector, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.SingleAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.SingleAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.SingleKeyFrame", true));
			properties[KnownProperties.SizeAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.SizeAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.SizeKeyFrame", true));
			properties[KnownProperties.Span_Inlines] = InitProperty(KnownTypes.Span, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.StackPanel_Children] = InitProperty(KnownTypes.StackPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.StatusBar_Items] = InitProperty(KnownTypes.StatusBar, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.StatusBarItem_Content] = InitProperty(KnownTypes.StatusBarItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Storyboard_Children] = InitProperty(KnownTypes.Storyboard, "Children", assemblies[1].Find("System.Windows.Media.Animation.Timeline", true));
			properties[KnownProperties.StringAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.StringAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.StringKeyFrame", true));
			properties[KnownProperties.Style_Setters] = InitProperty(KnownTypes.Style, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.TabControl_Items] = InitProperty(KnownTypes.TabControl, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.TabItem_Content] = InitProperty(KnownTypes.TabItem, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.TabPanel_Children] = InitProperty(KnownTypes.TabPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Table_RowGroups] = InitProperty(KnownTypes.Table, "RowGroups", assemblies[0].Find("System.Windows.Documents.TableRowGroup", true));
			properties[KnownProperties.TableCell_Blocks] = InitProperty(KnownTypes.TableCell, "Blocks", assemblies[0].Find("System.Windows.Documents.Block", true));
			properties[KnownProperties.TableRow_Cells] = InitProperty(KnownTypes.TableRow, "Cells", assemblies[0].Find("System.Windows.Documents.TableCell", true));
			properties[KnownProperties.TableRowGroup_Rows] = InitProperty(KnownTypes.TableRowGroup, "Rows", assemblies[0].Find("System.Windows.Documents.TableRow", true));
			properties[KnownProperties.TextBlock_Inlines] = InitProperty(KnownTypes.TextBlock, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.ThicknessAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.ThicknessAnimationUsingKeyFrames, "KeyFrames", assemblies[0].Find("System.Windows.Media.Animation.ThicknessKeyFrame", true));
			properties[KnownProperties.ToggleButton_Content] = InitProperty(KnownTypes.ToggleButton, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ToolBar_Items] = InitProperty(KnownTypes.ToolBar, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.ToolBarOverflowPanel_Children] = InitProperty(KnownTypes.ToolBarOverflowPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.ToolBarPanel_Children] = InitProperty(KnownTypes.ToolBarPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.ToolBarTray_ToolBars] = InitProperty(KnownTypes.ToolBarTray, "ToolBars", assemblies[0].Find("System.Windows.Controls.ToolBar", true));
			properties[KnownProperties.ToolTip_Content] = InitProperty(KnownTypes.ToolTip, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.TreeView_Items] = InitProperty(KnownTypes.TreeView, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.TreeViewItem_Items] = InitProperty(KnownTypes.TreeViewItem, "Items", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Trigger_Setters] = InitProperty(KnownTypes.Trigger, "Setters", assemblies[0].Find("System.Windows.SetterBase", true));
			properties[KnownProperties.Underline_Inlines] = InitProperty(KnownTypes.Underline, "Inlines", assemblies[0].Find("System.Windows.Documents.Inline", true));
			properties[KnownProperties.UniformGrid_Children] = InitProperty(KnownTypes.UniformGrid, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.UserControl_Content] = InitProperty(KnownTypes.UserControl, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.Vector3DAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.Vector3DAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.Vector3DKeyFrame", true));
			properties[KnownProperties.VectorAnimationUsingKeyFrames_KeyFrames] = InitProperty(KnownTypes.VectorAnimationUsingKeyFrames, "KeyFrames", assemblies[1].Find("System.Windows.Media.Animation.VectorKeyFrame", true));
			properties[KnownProperties.Viewbox_Child] = InitProperty(KnownTypes.Viewbox, "Child", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Viewport3DVisual_Children] = InitProperty(KnownTypes.Viewport3DVisual, "Children", assemblies[1].Find("System.Windows.Media.Media3D.Visual3D", true));
			properties[KnownProperties.VirtualizingPanel_Children] = InitProperty(KnownTypes.VirtualizingPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.VirtualizingStackPanel_Children] = InitProperty(KnownTypes.VirtualizingStackPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.Window_Content] = InitProperty(KnownTypes.Window, "Content", assemblies[3].Find("System.Object", true));
			properties[KnownProperties.WrapPanel_Children] = InitProperty(KnownTypes.WrapPanel, "Children", assemblies[1].Find("System.Windows.UIElement", true));
			properties[KnownProperties.XmlDataProvider_XmlSerializer] = InitProperty(KnownTypes.XmlDataProvider, "XmlSerializer", assemblies[6].Find("System.Xml.Serialization.IXmlSerializable", true));
		}
	}
}
```

`Confuser.Renamer/BAML/PropertyPath/DrillIn.cs`:

```cs
namespace Confuser.Renamer.BAML {
	internal enum DrillIn {
		Never,
		IfNeeded,
		Always
	}
}

```

`Confuser.Renamer/BAML/PropertyPath/IndexerParamInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Confuser.Renamer.BAML {
	internal struct IndexerParamInfo {
		// parse each indexer param "(abc)xyz" into two pieces - either can be empty
		public string parenString;
		public string valueString;

		public IndexerParamInfo(string paren, string value) {
			parenString = paren;
			valueString = value;
		}
	}
}

```

`Confuser.Renamer/BAML/PropertyPath/PropertyPathParser.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Confuser.Renamer.Properties;

namespace Confuser.Renamer.BAML {
	/// <summary>
	/// This is the parser for property paths that are used in WPF to reference properties.
	/// </summary>
	/// <remarks>
	/// This parser is based on <see cref="MS.Internal.Data.PathParser"/>. See the reference source for the original
	/// implementation: https://referencesource.microsoft.com/#PresentationFramework/src/Framework/MS/Internal/Data/PathParser.cs,408574f0013d222e
	/// </remarks>
	internal sealed class PropertyPathParser {
		private enum State { Init, DrillIn, Prop, Done }

		internal string Error { get; private set; }

		private void SetError(string message, params string[] args) =>
			Error = string.Format(CultureInfo.CurrentUICulture, message, args);

		// Each level of the path consists of
		//      a property or indexer:
		//                  .propname
		//                  /propname
		//                  [index]
		//                  /[index]
		//          (The . or / is optional in the very first level.)
		// The parser is a finite-state machine with two states corresponding
		// to the two-character lookahead above, plus two more states for the begining
		// and end.  The state transistions are done explicitly in the code below.
		//
		// The parser returns a 0-length array if it finds a syntax error.
		// It sets the Error property, so the caller can find out what happened.

		public SourceValueInfo[] Parse(string path) {
			_path = (path != null) ? path.Trim() : String.Empty;
			_n = _path.Length;

			if (_n == 0) {
				// When no path string is specified, use value directly and do not drill-in. (same as Path=".")
				// ClrBindingWorker needs this information to tell XmlBindingWorker about collectionMode.
				return new SourceValueInfo[] { new SourceValueInfo(SourceValueType.Direct, DrillIn.Never, (string)null) };
			}

			_index = 0;
			_drillIn = DrillIn.IfNeeded;

			_al.Clear();
			Error = null;
			_state = State.Init;

			while (_state != State.Done) {
				char c = (_index < _n) ? _path[_index] : NullChar;
				if (Char.IsWhiteSpace(c)) {
					++_index;
					continue;
				}

				switch (_state) {
					case State.Init:
						switch (c) {
							case '/':
							case '.':
							case NullChar:
								_state = State.DrillIn;
								break;
							default:
								_state = State.Prop;
								break;
						}
						break;

					case State.DrillIn:
						switch (c) {
							case '/':
								_drillIn = DrillIn.Always;
								++_index;
								break;
							case '.':
								_drillIn = DrillIn.Never;
								++_index;
								break;
							case '[':
							case NullChar:
								break;
							default:
								SetError(Resources.InvalidPathSyntax, _path.Substring(0, _index), _path.Substring(_index));
								return EmptyInfo;
						}
						_state = State.Prop;
						break;

					case State.Prop:
						bool isIndexer = false;
						switch (c) {
							case '[':
								isIndexer = true;
								break;
							default:
								break;
						}

						if (isIndexer)
							AddIndexer();
						else
							AddProperty();

						break;
				}
			}


			SourceValueInfo[] result;

			if (Error == null) {
				result = new SourceValueInfo[_al.Count];
				_al.CopyTo(result);
			}
			else {
				result = EmptyInfo;
			}

			return result;
		}

		void AddProperty() {
			int start = _index;
			int level = 0;

			// include leading dots in the path (for XLinq)
			while (_index < _n && _path[_index] == '.')
				++_index;

			while (_index < _n && (level > 0 || SpecialChars.IndexOf(_path[_index]) < 0)) {
				if (_path[_index] == '(')
					++level;
				else if (_path[_index] == ')')
					--level;

				++_index;
			}

			if (level > 0) {
				SetError(Resources.UnmatchedParen, _path.Substring(start));
				return;
			}

			if (level < 0) {
				SetError(Resources.UnmatchedParen, _path.Substring(0, _index));
				return;
			}

			string name = _path.Substring(start, _index - start).Trim();

			SourceValueInfo info = (name.Length > 0)
				? new SourceValueInfo(SourceValueType.Property, _drillIn, name)
				: new SourceValueInfo(SourceValueType.Direct, _drillIn, (string)null);

			_al.Add(info);

			StartNewLevel();
		}


		enum IndexerState { BeginParam, ParenString, ValueString, Done }

		void AddIndexer() {
			// indexer args are parsed by a (sub-) state machine with four
			// states.  The string is a comma-separated list of params, each
			// of which has two parts:  a "paren string" and a "value string"
			// (both parts are optional).  The character ^ can be used to
			// escape any of the special characters:  comma, parens, ], ^,
			// and white space.

			int start = ++_index;       // skip over initial [
			int level = 1;              // level of nested []

			bool escaped = false;       // true if current char is escaped
			bool trimRight = false;     // true if value string has trailing white space

			StringBuilder parenStringBuilder = new StringBuilder();
			StringBuilder valueStringBuilder = new StringBuilder();

			List<IndexerParamInfo> paramList = new List<IndexerParamInfo>(0);

			IndexerState state = IndexerState.BeginParam;
			while (state != IndexerState.Done) {
				if (_index >= _n) {
					SetError(Resources.UnmatchedBracket, _path.Substring(start - 1));
					return;
				}

				Char c = _path[_index++];

				// handle the escape character - set the flag for the next character
				if (c == EscapeChar && !escaped) {
					escaped = true;
					continue;
				}

				switch (state) {
					case IndexerState.BeginParam:   // look for optional (...)
						if (escaped) {
							// no '(', go parse the value
							state = IndexerState.ValueString;
							goto case IndexerState.ValueString;
						}
						else if (c == '(') {
							// '(' introduces optional paren string
							state = IndexerState.ParenString;
						}
						else if (Char.IsWhiteSpace(c)) {
							// ignore leading white space
						}
						else {
							// no '(', go parse the value
							state = IndexerState.ValueString;
							goto case IndexerState.ValueString;
						}
						break;

					case IndexerState.ParenString:  // parse (...)
						if (escaped) {
							// add an escaped character without question
							parenStringBuilder.Append(c);
						}
						else if (c == ')') {
							// end of (...), start to parse value
							state = IndexerState.ValueString;
						}
						else {
							// add normal characters inside (...)
							parenStringBuilder.Append(c);
						}
						break;

					case IndexerState.ValueString:  // parse value
						if (escaped) {
							// add an escaped character without question
							valueStringBuilder.Append(c);
							trimRight = false;
						}
						else if (level > 1) {
							// inside nested [], add characters without question
							valueStringBuilder.Append(c);
							trimRight = false;

							if (c == ']') {
								--level;
							}
						}
						else if (Char.IsWhiteSpace(c)) {
							// add white space, but trim it later if it's trailing
							valueStringBuilder.Append(c);
							trimRight = true;
						}
						else if (c == ',' || c == ']') {
							// end of current paramater - assemble the two parts
							string parenString = parenStringBuilder.ToString();
							string valueString = valueStringBuilder.ToString();
							if (trimRight) {
								valueString = valueString.TrimEnd();
							}

							// add the parts to the final result
							paramList.Add(new IndexerParamInfo(parenString, valueString));

							// reset for the next parameter
							parenStringBuilder.Length = 0;
							valueStringBuilder.Length = 0;
							trimRight = false;

							// after ',' parse next parameter;  after ']' we're done
							state = (c == ']') ? IndexerState.Done : IndexerState.BeginParam;
						}
						else {
							// add normal characters
							valueStringBuilder.Append(c);
							trimRight = false;

							// keep track of nested []
							if (c == '[') {
								++level;
							}
						}
						break;
				}

				// after processing each character, clear the escape flag
				escaped = false;
			}

			// assemble the final result
			SourceValueInfo info = new SourceValueInfo(
										SourceValueType.Indexer,
										_drillIn, paramList);
			_al.Add(info);

			StartNewLevel();
		}

		void StartNewLevel() {
			_state = (_index < _n) ? State.DrillIn : State.Done;
			_drillIn = DrillIn.Never;
		}

		State _state;
		string _path;
		int _index;
		int _n;
		DrillIn _drillIn;
		ArrayList _al = new ArrayList();
		const char NullChar = Char.MinValue;
		const char EscapeChar = '^';
		static SourceValueInfo[] EmptyInfo = new SourceValueInfo[0];
		static string SpecialChars = @"./[]";
	}
}

```

`Confuser.Renamer/BAML/PropertyPath/README.md`:

```md
# WPF Property Path Parser

The code in this directory was extracted from the sources of the Presentation Framework part of the .NET Fraemework.

The original code can be viewed here:  
https://referencesource.microsoft.com/#PresentationFramework/src/Framework/MS/Internal/Data/PathParser.cs

```

`Confuser.Renamer/BAML/PropertyPath/SourceValueInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Confuser.Renamer.BAML {
	internal struct SourceValueInfo {
		public SourceValueType type;
		public DrillIn drillIn;
		public string name;                 // the name the user supplied - could be "(0)"
		public IReadOnlyList<IndexerParamInfo> paramList;    // params for indexer

		public SourceValueInfo(SourceValueType t, DrillIn d, string n) {
			type = t;
			drillIn = d;
			name = n;
			paramList = null;
		}

		public SourceValueInfo(SourceValueType t, DrillIn d, IReadOnlyList<IndexerParamInfo> list) {
			type = t;
			drillIn = d;
			name = null;
			paramList = list;
		}
	}
}

```

`Confuser.Renamer/BAML/PropertyPath/SourceValueType.cs`:

```cs
namespace Confuser.Renamer.BAML {
	internal enum SourceValueType {
		Property,
		Indexer,
		Direct
	}
}

```

`Confuser.Renamer/BAML/PropertyPathIndexUpdater.cs`:

```cs
using System;

namespace Confuser.Renamer.BAML {
	internal struct PropertyPathIndexUpdater {
		PropertyPathUpdater Parent { get; }
		int PathIndex { get; }
		int IndexerIndex { get; }
		IndexerParamInfo IndexInfo => Parent.PropertyPath[PathIndex].paramList[IndexerIndex];

		internal string ParenString {
			get => IndexInfo.parenString;
			set => Parent.UpdateParenString(PathIndex, IndexerIndex, value);
		}

		internal PropertyPathIndexUpdater(PropertyPathUpdater parent, int pathIndex, int indexerIndex) {
			Parent = parent ?? throw new ArgumentNullException(nameof(parent));
			PathIndex = pathIndex;
			IndexerIndex = indexerIndex;
		}
	}
}

```

`Confuser.Renamer/BAML/PropertyPathPartUpdater.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Confuser.Renamer.BAML {
	internal struct PropertyPathPartUpdater {
		PropertyPathUpdater Parent { get; }
		int PathIndex { get; }
		SourceValueInfo PathInfo => Parent.PropertyPath[PathIndex];

		internal IEnumerable<PropertyPathIndexUpdater> ParamList {
			get {
				var parent = Parent;
				var pathIndex = PathIndex;
				return Enumerable.Range(0, PathInfo.paramList.Count).Select(i => new PropertyPathIndexUpdater(parent, pathIndex, i));
			}
		}

		internal SourceValueType Type => PathInfo.type;

		internal string Name {
			get => PathInfo.name;
			set => Parent.Update(PathIndex, value);
		}

		internal PropertyPathPartUpdater(PropertyPathUpdater parent, int pathIndex) {
			Parent = parent ?? throw new ArgumentNullException(nameof(parent));
			PathIndex = pathIndex;
		}

		internal string GetTypeName() {
			var propertyName = PathInfo.name?.Trim();
			if (propertyName != null && propertyName.StartsWith("(") && propertyName.EndsWith(")")) {
				var indexOfDot = propertyName.LastIndexOf('.');
				if (indexOfDot < 0) return null;
				return propertyName.Substring(1, indexOfDot - 1);
			}
			return null;
		}

		internal string GetPropertyName() {
			switch (PathInfo.type) {
				case SourceValueType.Direct:
					return null;
				case SourceValueType.Property:
					var propertyName = PathInfo.name?.Trim();
					if (propertyName != null && propertyName.StartsWith("(") && propertyName.EndsWith(")")) {
						var indexOfDot = propertyName.LastIndexOf('.');
						if (indexOfDot < 0) return propertyName.Substring(1, propertyName.Length - 2);
						return propertyName.Substring(indexOfDot + 1, propertyName.Length - indexOfDot - 2);
					}
					return propertyName;
				case SourceValueType.Indexer:
					return "Item";
				default:
					throw new InvalidOperationException("Unexpected SourceValueType.");
			}
		}
	}
}

```

`Confuser.Renamer/BAML/PropertyPathUpdater.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Confuser.Renamer.BAML {
	/// <summary>
	/// This class is used to update parts of an property path based on the references.
	/// </summary>
	internal sealed class PropertyPathUpdater : IEnumerable<PropertyPathPartUpdater> {
		internal SourceValueInfo[] PropertyPath { get; }
		Action<string> UpdateAction { get; }

		internal PropertyPathUpdater(string path, Action<string> updateAction) {
			UpdateAction = updateAction ?? throw new ArgumentNullException(nameof(updateAction));
			var pathParser = new PropertyPathParser();
			PropertyPath = pathParser.Parse(path);
		}

		internal void Update(int index, string value) {
			PropertyPath[index].name = value;
			RebuildAndUpdatePath();
		}

		public void UpdateParenString(int pathIndex, int indexerIndex, string value) {
			var originalParams = PropertyPath[pathIndex].paramList;
			var newIndexParams = originalParams.ToArray();
			newIndexParams[indexerIndex].parenString = value;
			PropertyPath[pathIndex].paramList = newIndexParams;
			RebuildAndUpdatePath();
		}

		private void RebuildAndUpdatePath() {
			var builder = new StringBuilder();
			foreach (var sourceValueInfo in PropertyPath) {
				if (builder.Length > 0) builder.Append('.');
				builder.Append(sourceValueInfo.name);
				if (sourceValueInfo.paramList?.Count > 0) {
					builder.Append('[');
					builder.Append(sourceValueInfo.paramList[0].parenString);
					builder.Append(sourceValueInfo.paramList[0].valueString);
					for (int i = 1; i < sourceValueInfo.paramList.Count; i++) {
						builder.Append(',');
						builder.Append(sourceValueInfo.paramList[i].parenString);
						builder.Append(sourceValueInfo.paramList[i].valueString);
					}
					builder.Append(']');
				}
			}

			UpdateAction.Invoke(builder.ToString());
		}

		/// <inheritdoc />
		public IEnumerator<PropertyPathPartUpdater> GetEnumerator() =>
			Enumerable.Range(0, PropertyPath.Length).Select(i => new PropertyPathPartUpdater(this, i)).GetEnumerator();

		/// <inheritdoc />
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}
}

```

`Confuser.Renamer/Confuser.Renamer.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\ConfuserEx.Common.props" Condition="Exists('..\ConfuserEx.Common.props')" />

  <PropertyGroup Label="Assembly Settings">
    <TargetFrameworks>net461;netstandard2.0</TargetFrameworks>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>

  <PropertyGroup Label="Assembly Information">
    <Title>ConfuserEx Renamer</Title>
    <Description>Renaming analysis of ConfuserEx</Description>
  </PropertyGroup>

  <ItemGroup>
    <Reference Include="System.Web" Condition="'$(TargetFramework)' == 'net461'" />
  </ItemGroup>

  <ItemGroup Label="Nuget Dependencies">
    <PackageReference Include="System.IO.Packaging" Version="6.*" />
    <PackageReference Include="System.Runtime.Extensions" Version="4.3.*" />
    <PackageReference Include="System.ValueTuple" Version="4.5.0" />
  </ItemGroup>

  <ItemGroup Label="Project Dependencies">
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

  <Import Project="..\ConfuserEx.Common.targets" Condition="Exists('..\ConfuserEx.Common.targets')" />

</Project>
```

`Confuser.Renamer/DisplayNormalizedName.cs`:

```cs
namespace Confuser.Renamer {
	public struct DisplayNormalizedName {
		public string DisplayName { get; }

		public string NormalizedName { get; }

		public DisplayNormalizedName(string displayName, string normalizedName) {
			DisplayName = displayName;
			NormalizedName = normalizedName;
		}
	}
}

```

`Confuser.Renamer/GenericArgumentResolver.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace Confuser.Renamer {
	/// <summary>
	///     Resolves generic arguments
	/// </summary>
	public ref struct GenericArgumentResolver {
		private GenericArguments _genericArguments;
		private RecursionCounter _recursionCounter;

		/// <summary>
		///     Resolves the type signature with the specified generic arguments.
		/// </summary>
		/// <param name="typeSig">The type signature.</param>
		/// <param name="typeGenArgs">The type generic arguments.</param>
		/// <returns>Resolved type signature.</returns>
		/// <exception cref="System.ArgumentException">No generic arguments to resolve.</exception>
		public static TypeSig Resolve(TypeSig typeSig, IList<TypeSig> typeGenArgs) {
			if (typeGenArgs == null) throw new ArgumentException("No generic arguments to resolve.");

			var resolver = new GenericArgumentResolver();
			resolver._genericArguments = new GenericArguments();
			resolver._recursionCounter = new RecursionCounter();
			resolver._genericArguments.PushTypeArgs(typeGenArgs);

			return resolver.ResolveGenericArgs(typeSig);
		}

		/// <summary>
		///     Resolves the method signature with the specified generic arguments.
		/// </summary>
		/// <param name="methodSig">The method signature.</param>
		/// <param name="typeGenArgs">The type generic arguments.</param>
		/// <returns>Resolved method signature.</returns>
		/// <exception cref="System.ArgumentException">No generic arguments to resolve.</exception>
		public static MethodSig Resolve(MethodSig methodSig, IList<TypeSig> typeGenArgs) {
			if (typeGenArgs == null)
				throw new ArgumentException("No generic arguments to resolve.");

			var resolver = new GenericArgumentResolver();
			resolver._genericArguments = new GenericArguments();
			resolver._recursionCounter = new RecursionCounter();
			resolver._genericArguments.PushTypeArgs(typeGenArgs);

			return resolver.ResolveGenericArgs(methodSig);
		}

		private bool ReplaceGenericArg(ref TypeSig typeSig) {
			var newTypeSig = _genericArguments.Resolve(typeSig);
			if (newTypeSig == typeSig) return false;

			typeSig = newTypeSig;
			return true;

		}

		private MethodSig ResolveGenericArgs(MethodSig sig) {
			if (sig == null)
				return null;
			if (!_recursionCounter.Increment())
				return null;

			var result = ResolveGenericArgs(new MethodSig(sig.GetCallingConvention()), sig);

			_recursionCounter.Decrement();
			return result;
		}

		private MethodSig ResolveGenericArgs(MethodSig sig, MethodSig old) {
			sig.RetType = ResolveGenericArgs(old.RetType);
			foreach (var p in old.Params)
				sig.Params.Add(ResolveGenericArgs(p));
			sig.GenParamCount = old.GenParamCount;
			if (sig.ParamsAfterSentinel != null) {
				foreach (var p in old.ParamsAfterSentinel)
					sig.ParamsAfterSentinel.Add(ResolveGenericArgs(p));
			}
			return sig;
		}

		private TypeSig ResolveGenericArgs(TypeSig typeSig) {
			if (!_recursionCounter.Increment())
				return null;

			if (ReplaceGenericArg(ref typeSig)) {
				_recursionCounter.Decrement();
				return typeSig;
			}

			TypeSig result;
			switch (typeSig.ElementType) {
				case ElementType.Ptr:
					result = new PtrSig(ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.ByRef:
					result = new ByRefSig(ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.Var:
					result = new GenericVar(((GenericVar) typeSig).Number);
					break;
				case ElementType.ValueArray:
					result = new ValueArraySig(ResolveGenericArgs(typeSig.Next), ((ValueArraySig) typeSig).Size);
					break;
				case ElementType.SZArray:
					result = new SZArraySig(ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.MVar:
					result = new GenericMVar((typeSig as GenericMVar).Number);
					break;
				case ElementType.CModReqd:
					result = new CModReqdSig((typeSig as ModifierSig).Modifier, ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.CModOpt:
					result = new CModOptSig((typeSig as ModifierSig).Modifier, ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.Module:
					result = new ModuleSig((typeSig as ModuleSig).Index, ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.Pinned:
					result = new PinnedSig(ResolveGenericArgs(typeSig.Next));
					break;
				case ElementType.FnPtr:
					throw new NotSupportedException("FnPtr is not supported.");

				case ElementType.Array:
					var arraySig = (ArraySig)typeSig;
					var sizes = new List<uint>(arraySig.Sizes);
					var lBounds = new List<int>(arraySig.LowerBounds);
					result = new ArraySig(ResolveGenericArgs(typeSig.Next), arraySig.Rank, sizes, lBounds);
					break;
				case ElementType.GenericInst:
					var gis = (GenericInstSig)typeSig;
					var genArgs = new List<TypeSig>(gis.GenericArguments.Count);
					foreach (var ga in gis.GenericArguments)
						genArgs.Add(ResolveGenericArgs(ga));
					
					result = new GenericInstSig(ResolveGenericArgs(gis.GenericType) as ClassOrValueTypeSig, genArgs);
					break;

				default:
					result = typeSig;
					break;
			}

			_recursionCounter.Decrement();

			return result;
		}
	}
}
```

`Confuser.Renamer/GenericArguments.cs`:

```cs
using System;
using System.Collections.Generic;
using dnlib.DotNet;

// This file is originally from dnlib. Find the original source here:
// https://github.com/0xd4d/dnlib/blob/a75105a4600b5641e42e6ac36847661ae9383701/src/DotNet/GenericArguments.cs
// Find the original license of this file here:
// https://github.com/0xd4d/dnlib/blob/a75105a4600b5641e42e6ac36847661ae9383701/LICENSE.txt
namespace Confuser.Renamer {
	/// <summary>
	/// Replaces generic type/method var with its generic argument
	/// </summary>
	internal ref struct GenericArguments {
#pragma warning disable 649 // Default value is okay.
		private GenericArgumentsStack _typeArgsStack;
		private GenericArgumentsStack _methodArgsStack;
#pragma warning restore 649

		/// <summary>
		/// Pushes generic arguments
		/// </summary>
		/// <param name="typeArgs">The generic arguments</param>
		public void PushTypeArgs(IList<TypeSig> typeArgs) => _typeArgsStack.Push(typeArgs);

		/// <summary>
		/// Pops generic arguments
		/// </summary>
		/// <returns>The popped generic arguments</returns>
		public IList<TypeSig> PopTypeArgs() => _typeArgsStack.Pop();

		/// <summary>
		/// Pushes generic arguments
		/// </summary>
		/// <param name="methodArgs">The generic arguments</param>
		public void PushMethodArgs(IList<TypeSig> methodArgs) => _methodArgsStack.Push(methodArgs);

		/// <summary>
		/// Pops generic arguments
		/// </summary>
		/// <returns>The popped generic arguments</returns>
		public IList<TypeSig> PopMethodArgs() => _methodArgsStack.Pop();

		/// <summary>
		/// Replaces a generic type/method var with its generic argument (if any). If
		/// <paramref name="typeSig"/> isn't a generic type/method var or if it can't
		/// be resolved, it itself is returned. Else the resolved type is returned.
		/// </summary>
		/// <param name="typeSig">Type signature</param>
		/// <returns>New <see cref="TypeSig"/> which is never <c>null</c> unless
		/// <paramref name="typeSig"/> is <c>null</c></returns>
		public TypeSig Resolve(TypeSig typeSig) {
			if (typeSig == null)
				return null;

			var sig = typeSig;

			if (sig is GenericMVar genericMVar) {
				var newSig = _methodArgsStack.Resolve(genericMVar.Number, false);
				if (newSig == null || newSig == sig)
					return sig;
				return newSig;
			}

			if (sig is GenericVar genericVar) {
				var newSig = _typeArgsStack.Resolve(genericVar.Number, true);
				if (newSig == null || newSig == sig)
					return sig;
				return newSig;
			}

			return sig;
		}
		
		private ref struct GenericArgumentsStack {
			private List<IList<TypeSig>> _argsStack;

			/// <summary>
			/// Pushes generic arguments
			/// </summary>
			/// <param name="args">The generic arguments</param>
			public void Push(IList<TypeSig> args) => (_argsStack ?? (_argsStack = new List<IList<TypeSig>>())).Add(args);

			/// <summary>
			/// Pops generic arguments
			/// </summary>
			/// <returns>The popped generic arguments</returns>
			public IList<TypeSig> Pop() {
				if (_argsStack == null) throw new IndexOutOfRangeException();

				int index = _argsStack.Count - 1;
				var result = _argsStack[index];
				_argsStack.RemoveAt(index);
				return result;
			}

			/// <summary>
			/// Resolves a generic argument
			/// </summary>
			/// <param name="number">Generic variable number</param>
			/// <param name="isTypeVar"></param>
			/// <returns>A <see cref="TypeSig"/> or <see langword="null" /> if none was found</returns>
			public TypeSig Resolve(uint number, bool isTypeVar) {
				if (_argsStack == null) return null;

				TypeSig result = null;
				for (int i = _argsStack.Count - 1; i >= 0; i--) {
					var args = _argsStack[i];
					if (number >= args.Count)
						return null;
					var typeSig = args[(int)number];
					if (!(typeSig is GenericSig genericVar) || genericVar.IsTypeVar != isTypeVar)
						return typeSig;
					result = genericVar;
					number = genericVar.Number;
				}
				return result;
			}
		}
	}
}

```

`Confuser.Renamer/INameReference.cs`:

```cs
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer {
	public interface INameReference {
		/// <summary>
		///		Check if the element with this reference attached should be
		///		renamed at all.
		/// </summary>
		bool ShouldCancelRename { get; }

		/// <summary>
		/// Check if the renaming has to be delayed, because the referenced objects are not handled yet.
		/// </summary>
		/// <param name="service">The naming service</param>
		/// <returns>
		///		<see langword="true" /> in case the reference can't be resolved yet;
		///		otherwise <see langword="false" />.</returns>
		bool DelayRenaming(INameService service, IDnlibDef currentDef);

		/// <summary>
		///		Update the name reference.
		/// </summary>
		/// <param name="context">The confuser context</param>
		/// <param name="service">The name service</param>
		/// <returns>
		///		<see langword="true" /> in case the name was updated;
		///		otherwise <see langword="false" />.
		///	</returns>
		///	<exception cref="ArgumentNullException">
		///		<paramref name="context" /> is <see langword="null" />
		///		<br />- or -<br />
		///		<paramref name="service" /> is <see langword="null" />
		/// </exception>
		bool UpdateNameReference(ConfuserContext context, INameService service);
		
		/// <summary>
		///		Get a description of this reference, containing the original
		///		names of the referenced objects.
		/// </summary>
		/// <param name="nameService">
		///		The name service used to get the original names;
		///		or <see langword="null"/>
		///	</param>
		/// <returns>Description of this reference.</returns>
		string ToString(INameService nameService);
	}

	public interface INameReference<out T> : INameReference { }
}

```

`Confuser.Renamer/IRenamer.cs`:

```cs
using System;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer {
	public interface IRenamer {
		void Analyze(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def);
		void PreRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def);
		void PostRename(ConfuserContext context, INameService service, ProtectionParameters parameters, IDnlibDef def);
	}
}
```

`Confuser.Renamer/MessageDeobfuscator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

namespace Confuser.Renamer {
	public class MessageDeobfuscator {
		static readonly Regex MapSymbolRegex = new Regex("_[a-zA-Z0-9]+");
		static readonly Regex PasswordSymbolRegex = new Regex("[a-zA-Z0-9_$]{23,}");

		readonly Dictionary<string, string> _symbolMap;
		readonly ReversibleRenamer _renamer;

		public static MessageDeobfuscator Load(string symbolMapFileName) {
			if (symbolMapFileName is null)
				throw new ArgumentNullException(nameof(symbolMapFileName));

			var symbolMap = new Dictionary<string, string>();
			using (var reader = new StreamReader(File.OpenRead(symbolMapFileName))) {
				var line = reader.ReadLine();
				while (line != null) {
					int tabIndex = line.IndexOf('\t');
					if (tabIndex == -1)
						throw new FileFormatException();
					symbolMap.Add(line.Substring(0, tabIndex), line.Substring(tabIndex + 1));
					line = reader.ReadLine();
				}
			}

			return new MessageDeobfuscator(symbolMap);
		}

		public MessageDeobfuscator(Dictionary<string, string> map) => _symbolMap = map ?? throw new ArgumentNullException(nameof(map));

		public MessageDeobfuscator(string password) => _renamer = new ReversibleRenamer(password);

		public string DeobfuscateMessage(string message) {
			if (_symbolMap != null) {
				return MapSymbolRegex.Replace(message, m => DeobfuscateSymbol(m.Value, true));
			}

			return PasswordSymbolRegex.Replace(message, m => DeobfuscateSymbol(m.Value, true));
		}

		public string DeobfuscateSymbol(string obfuscatedIdentifier, bool shortName) {
			string fullName;

			if (_symbolMap != null) {
				if (!_symbolMap.TryGetValue(obfuscatedIdentifier, out fullName))
					fullName = obfuscatedIdentifier;
			}
			else {
				try {
					fullName = _renamer.Decrypt(obfuscatedIdentifier);
				}
				catch {
					fullName = obfuscatedIdentifier;
				}
			}

			return shortName ? ExtractShortName(fullName) : fullName;
		}

		public static string ExtractShortName(string fullName) {
			const string doubleParen = "::";
			int doubleParenIndex = fullName.IndexOf(doubleParen, StringComparison.Ordinal);
			if (doubleParenIndex != -1) {
				int resultStringStartIndex = doubleParenIndex + doubleParen.Length;
				int parenIndex = fullName.IndexOf('(', doubleParenIndex);
				return fullName.Substring(resultStringStartIndex,
					(parenIndex == -1 ? fullName.Length : parenIndex) - resultStringStartIndex);
			}

			int slashIndex = fullName.IndexOf('/');
			if (slashIndex != -1) {
				return fullName.Substring(slashIndex + 1);
			}

			return fullName;
		}
	}
}

```

`Confuser.Renamer/NameProtection.cs`:

```cs
using System;
using System.IO;
using Confuser.Core;

namespace Confuser.Renamer {
	internal class NameProtection : Protection {
		public const string _Id = "rename";
		public const string _FullId = "Ki.Rename";
		public const string _ServiceId = "Ki.Rename";

		public override string Name {
			get { return "Name Protection"; }
		}

		public override string Description {
			get { return "This protection obfuscate the symbols' name so the decompiled source code can neither be compiled nor read."; }
		}

		public override string Id {
			get { return _Id; }
		}

		public override string FullId {
			get { return _FullId; }
		}

		public override ProtectionPreset Preset {
			get { return ProtectionPreset.Minimum; }
		}

		protected override void Initialize(ConfuserContext context) {
			context.Registry.RegisterService(_ServiceId, typeof(INameService), new NameService(context));
		}

		protected override void PopulatePipeline(ProtectionPipeline pipeline) {
			pipeline.InsertPostStage(PipelineStage.Inspection, new AnalyzePhase(this));
			pipeline.InsertPostStage(PipelineStage.BeginModule, new RenamePhase(this));
			pipeline.InsertPreStage(PipelineStage.EndModule, new PostRenamePhase(this));
			pipeline.InsertPostStage(PipelineStage.SaveModules, new ExportMapPhase(this));
		}

		class ExportMapPhase : ProtectionPhase {
			public ExportMapPhase(NameProtection parent)
				: base(parent) { }

			public override ProtectionTargets Targets {
				get { return ProtectionTargets.Modules; }
			}

			public override string Name {
				get { return "Export symbol map"; }
			}

			public override bool ProcessAll {
				get { return true; }
			}

			protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
				var srv = (NameService)context.Registry.GetService<INameService>();
				var map = srv.GetNameMap();
				if (map.Count == 0)
					return;

				string dir = context.OutputDirectory;
				string path = Path.GetFullPath(Path.Combine(dir, CoreComponent.SymbolsFileName));
				if (!Directory.Exists(dir))
					Directory.CreateDirectory(dir);

				using (var writer = new StreamWriter(File.Create(path))) {
					foreach (var entry in map)
						writer.WriteLine("{0}\t{1}", entry.Key, entry.Value);
				}
			}
		}
	}
}

```

`Confuser.Renamer/NameService.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using Confuser.Core;
using Confuser.Core.Services;
using Confuser.Renamer.Analyzers;
using Confuser.Renamer.Properties;
using dnlib.DotNet;

namespace Confuser.Renamer {
	public interface INameService {
		VTableStorage GetVTables();

		void Analyze(IDnlibDef def);

		bool CanRename(object obj);
		void SetCanRename(object obj, bool val);

		void SetParam(IDnlibDef def, string name, string value);
		string GetParam(IDnlibDef def, string name);

		RenameMode GetRenameMode(object obj);
		void SetRenameMode(object obj, RenameMode val);
		void ReduceRenameMode(object obj, RenameMode val);

		string ObfuscateName(string name, RenameMode mode);
		string ObfuscateName(IDnlibDef name, RenameMode mode);
		string RandomName();
		string RandomName(RenameMode mode);

		void RegisterRenamer(IRenamer renamer);
		T FindRenamer<T>();
		void AddReference<T>(T obj, INameReference<T> reference);
		IList<INameReference> GetReferences(object obj);

		void StoreNames(IDnlibDef obj);
		void SetNormalizedName(IDnlibDef obj, string name);
		string GetDisplayName(IDnlibDef obj);
		string GetNormalizedName(IDnlibDef obj);

		bool IsRenamed(IDnlibDef def);
		void SetIsRenamed(IDnlibDef def);

		void MarkHelper(IDnlibDef def, IMarkerService marker, ConfuserComponent parentComp);
	}

	internal class NameService : INameService {
		static readonly object CanRenameKey = new object();
		static readonly object RenameModeKey = new object();
		static readonly object ReferencesKey = new object();
		static readonly object DisplayNameKey = new object();
		static readonly object NormalizedNameKey = new object();
		static readonly object IsRenamedKey = new object();

		readonly ConfuserContext context;
		readonly byte[] nameSeed;
		readonly RandomGenerator random;
		readonly VTableStorage storage;
		AnalyzePhase analyze;

		readonly HashSet<string> identifiers = new HashSet<string>();

		long _nameId;
		readonly StringBuilder _nameBuilder = new StringBuilder();
		readonly Dictionary<string, string> _originalToObfuscatedNameMap = new Dictionary<string, string>();
		readonly Dictionary<string, string> _obfuscatedToOriginalNameMap = new Dictionary<string, string>();
		readonly Dictionary<string, string> _prefixesMap = new Dictionary<string, string>();
		internal ReversibleRenamer reversibleRenamer;

		public NameService(ConfuserContext context) {
			this.context = context;
			storage = new VTableStorage(context.Logger);
			random = context.Registry.GetService<IRandomService>().GetRandomGenerator(NameProtection._FullId);
			nameSeed = random.NextBytes(20);

			Renamers = new List<IRenamer> {
				new InterReferenceAnalyzer(),
				new VTableAnalyzer(),
				new TypeBlobAnalyzer(),
				new ResourceAnalyzer(),
				new LdtokenEnumAnalyzer(),
				new ManifestResourceAnalyzer(),
				new ReflectionAnalyzer(),
				new CallSiteAnalyzer()
			};
		}

		public IList<IRenamer> Renamers { get; private set; }

		public VTableStorage GetVTables() {
			return storage;
		}

		public bool CanRename(object obj) {
			if (obj is IDnlibDef) {
				if (analyze == null)
					analyze = context.Pipeline.FindPhase<AnalyzePhase>();

				var prot = (NameProtection)analyze.Parent;
				ProtectionSettings parameters = ProtectionParameters.GetParameters(context, (IDnlibDef)obj);
				if (parameters == null || !parameters.ContainsKey(prot))
					return false;
				return context.Annotations.Get(obj, CanRenameKey, true);
			}

			return false;
		}

		public void SetCanRename(object obj, bool val) {
			context.Annotations.Set(obj, CanRenameKey, val);
		}

		public void SetParam(IDnlibDef def, string name, string value) {
			var param = ProtectionParameters.GetParameters(context, def);
			if (param == null)
				ProtectionParameters.SetParameters(context, def, param = new ProtectionSettings());
			Dictionary<string, string> nameParam;
			if (!param.TryGetValue(analyze.Parent, out nameParam))
				param[analyze.Parent] = nameParam = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			nameParam[name] = value;
		}

		public string GetParam(IDnlibDef def, string name) {
			var param = ProtectionParameters.GetParameters(context, def);
			if (param == null)
				return null;
			if (analyze == null)
				analyze = context.Pipeline.FindPhase<AnalyzePhase>();
			if (!param.TryGetValue(analyze.Parent, out var nameParam))
				return null;
			return nameParam.GetValueOrDefault(name);
		}

		public RenameMode GetRenameMode(object obj) {
			return context.Annotations.Get(obj, RenameModeKey, RenameMode.Unicode);
		}

		public void SetRenameMode(object obj, RenameMode val) {
			context.Annotations.Set(obj, RenameModeKey, val);
		}

		public void ReduceRenameMode(object obj, RenameMode val) {
			RenameMode original = GetRenameMode(obj);
			if (original < val)
				context.Annotations.Set(obj, RenameModeKey, val);
			if (val <= RenameMode.Reflection && obj is IDnlibDef dnlibDef) {
				var name = ExtractDisplayNormalizedName(dnlibDef, true);
				SetNormalizedName(dnlibDef, name.NormalizedName);
			}
		}

		public void AddReference<T>(T obj, INameReference<T> reference) {
			context.Annotations.GetOrCreate(obj, ReferencesKey, key => new List<INameReference>()).Add(reference);
		}

		public void Analyze(IDnlibDef def) {
			if (analyze == null)
				analyze = context.Pipeline.FindPhase<AnalyzePhase>();

			StoreNames(def);
			if (def is TypeDef typeDef) {
				GetVTables().GetVTable(typeDef);
			}

			analyze.Analyze(this, context, ProtectionParameters.Empty, def, true);
		}

		string ObfuscateNameInternal(byte[] hash, RenameMode mode) {
			switch (mode) {
				case RenameMode.Empty:
					return "";
				case RenameMode.Unicode:
					return Utils.EncodeString(hash, unicodeCharset) + "\u202e";
				case RenameMode.Letters:
					return Utils.EncodeString(hash, letterCharset);
				case RenameMode.ASCII:
					return Utils.EncodeString(hash, asciiCharset);
				case RenameMode.Reflection:
					return Utils.EncodeString(hash, reflectionCharset);
				case RenameMode.Decodable:
					return "_" + Utils.EncodeString(hash, alphaNumCharset);
				case RenameMode.Sequential:
					return "_" + GetNextSequentialName();
				default:
					throw new NotSupportedException("Rename mode '" + mode + "' is not supported.");
			}
		}

		string ParseGenericName(string name, out int count) {
			int graveIndex = name.LastIndexOf('`');
			if (graveIndex != -1) {
				if (int.TryParse(name.Substring(graveIndex + 1), out int c)) {
					count = c;
					return name.Substring(0, graveIndex);
				}
			}

			count = 0;
			return name;
		}

		string MakeGenericName(string name, int count) => count == 0 ? name : $"{name}`{count}";

		public string ObfuscateName(string name, RenameMode mode) => ObfuscateName(null, name, mode, false);

		public string ObfuscateName(IDnlibDef dnlibDef, RenameMode mode) {
			var normalizedName = GetNormalizedName(dnlibDef);
			bool preserveGenericParams = GetParam(dnlibDef, "preserveGenericParams")
				?.Equals("true", StringComparison.OrdinalIgnoreCase) == true;
			return ObfuscateName(null, normalizedName, mode, preserveGenericParams);
		}

		public string ObfuscateName(string format, string name, RenameMode mode, bool preserveGenericParams = false) {
			int genericParamsCount = 0;
			if (preserveGenericParams) {
				name = ParseGenericName(name, out genericParamsCount);
			}

			string newName;

			if (string.IsNullOrEmpty(name) || mode == RenameMode.Empty)
				return string.Empty;

			if (mode == RenameMode.Debug || mode == RenameMode.Retain) {
				// When flattening there are issues, in case there is a . in the name of the assembly.
				newName = name.Replace('.', '_');
				newName = mode == RenameMode.Debug ? "_" + newName : newName;
			}
			else if (mode == RenameMode.Reversible) {
				if (reversibleRenamer == null)
					throw new ArgumentException("Password not provided for reversible renaming.");
				newName = reversibleRenamer.Encrypt(name);
			}
			else if (!_originalToObfuscatedNameMap.TryGetValue(name, out newName)) {
				byte[] hash = Utils.Xor(Utils.SHA1(Encoding.UTF8.GetBytes(name)), nameSeed);
				while (true) {
					newName = ObfuscateNameInternal(hash, mode);

					try {
						if (!(format is null))
							newName = string.Format(CultureInfo.InvariantCulture, format, newName);
					}
					catch (FormatException ex) {
						throw new ArgumentException(
							string.Format(CultureInfo.InvariantCulture,
								Resources.NameService_ObfuscateName_InvalidFormat, format),
							nameof(format), ex);
					}

					if (!identifiers.Contains(MakeGenericName(newName, genericParamsCount))
					    && !_obfuscatedToOriginalNameMap.ContainsKey(newName))
						break;
					hash = Utils.SHA1(hash);
				}

				if (mode == RenameMode.Decodable || mode == RenameMode.Sequential) {
					_obfuscatedToOriginalNameMap.Add(newName, name);
					_originalToObfuscatedNameMap.Add(name, newName);
				}
			}

			return MakeGenericName(newName, genericParamsCount);
		}

		public string RandomName() {
			return RandomName(RenameMode.Unicode);
		}

		public string RandomName(RenameMode mode) {
			return ObfuscateName(Utils.ToHexString(random.NextBytes(16)), mode);
		}

		public void StoreNames(IDnlibDef dnlibDef) {
			AddReservedIdentifier(dnlibDef.Name);
			if (dnlibDef is TypeDef typeDef) {
				AddReservedIdentifier(typeDef.Namespace);
			}

			var name = ExtractDisplayNormalizedName(dnlibDef);
			context.Annotations.Set(dnlibDef, DisplayNameKey, name.DisplayName);
			context.Annotations.Set(dnlibDef, NormalizedNameKey, name.NormalizedName);
		}

		public void SetNormalizedName(IDnlibDef dnlibDef, string name) {
			context.Annotations.Set(dnlibDef, NormalizedNameKey, name);
		}

		public void AddReservedIdentifier(string id) => identifiers.Add(id);

		public void RegisterRenamer(IRenamer renamer) {
			Renamers.Add(renamer);
		}

		public T FindRenamer<T>() {
			return Renamers.OfType<T>().Single();
		}

		public void MarkHelper(IDnlibDef def, IMarkerService marker, ConfuserComponent parentComp) {
			if (marker.IsMarked(def))
				return;
			if (def is MethodDef) {
				var method = (MethodDef)def;
				method.Access = MethodAttributes.Assembly;
				if (!method.IsSpecialName && !method.IsRuntimeSpecialName && !method.DeclaringType.IsDelegate())
					method.Name = RandomName();
			}
			else if (def is FieldDef) {
				var field = (FieldDef)def;
				field.Access = FieldAttributes.Assembly;
				if (!field.IsSpecialName && !field.IsRuntimeSpecialName)
					field.Name = RandomName();
			}
			else if (def is TypeDef) {
				var type = (TypeDef)def;
				type.Visibility = type.DeclaringType == null ? TypeAttributes.NotPublic : TypeAttributes.NestedAssembly;
				type.Namespace = "";
				if (!type.IsSpecialName && !type.IsRuntimeSpecialName)
					type.Name = RandomName();
			}

			SetCanRename(def, false);
			Analyze(def);
			marker.Mark(def, parentComp);
		}

		#region Charsets

		static readonly char[] asciiCharset = Enumerable.Range(32, 95)
			.Select(ord => (char)ord)
			.Except(new[] {'.'})
			.ToArray();

		static readonly char[] reflectionCharset = asciiCharset.Except(new[] {' ', '[', ']'}).ToArray();

		static readonly char[] letterCharset = Enumerable.Range(0, 26)
			.SelectMany(ord => new[] {(char)('a' + ord), (char)('A' + ord)})
			.ToArray();

		static readonly char[] alphaNumCharset = Enumerable.Range(0, 26)
			.SelectMany(ord => new[] {(char)('a' + ord), (char)('A' + ord)})
			.Concat(Enumerable.Range(0, 10).Select(ord => (char)('0' + ord)))
			.ToArray();

		// Especially chosen, just to mess with people.
		// Inspired by: http://xkcd.com/1137/ :D
		static readonly char[] unicodeCharset = new char[] { }
			.Concat(Enumerable.Range(0x200b, 5).Select(ord => (char)ord))
			.Concat(Enumerable.Range(0x2029, 6).Select(ord => (char)ord))
			.Concat(Enumerable.Range(0x206a, 6).Select(ord => (char)ord))
			.Except(new[] {'\u2029'})
			.ToArray();

		#endregion

		public RandomGenerator GetRandom() {
			return random;
		}

		public IList<INameReference> GetReferences(object obj) {
			return context.Annotations.GetLazy(obj, ReferencesKey, key => new List<INameReference>());
		}

		public string GetDisplayName(IDnlibDef obj) =>
			context.Annotations.Get(obj, DisplayNameKey, (string)null);

		public string GetNormalizedName(IDnlibDef obj) =>
			context.Annotations.Get(obj, NormalizedNameKey, (string)null);

		public IReadOnlyDictionary<string, string> GetNameMap() => _obfuscatedToOriginalNameMap;

		public bool IsRenamed(IDnlibDef def) => context.Annotations.Get(def, IsRenamedKey, !CanRename(def));

		public void SetIsRenamed(IDnlibDef def) => context.Annotations.Set(def, IsRenamedKey, true);

		DisplayNormalizedName ExtractDisplayNormalizedName(IDnlibDef dnlibDef, bool forceShortNames = false) {
			var shortNames = forceShortNames ||
			                 GetParam(dnlibDef, "shortNames")?.Equals("true", StringComparison.OrdinalIgnoreCase) ==
			                 true;
			var renameMode = GetRenameMode(dnlibDef);

			if (dnlibDef is TypeDef typeDef) {
				if (typeDef.DeclaringType != null) {
					var outerClassName = CompressTypeName(typeDef.DeclaringType.FullName, renameMode);
					return
						new DisplayNormalizedName(dnlibDef.FullName, $"{outerClassName.NormalizedName}/{dnlibDef.Name}");
				}

				return new DisplayNormalizedName(dnlibDef.FullName, dnlibDef.FullName);
			}

			var displayNameBuilder = new StringBuilder();
			var normalizedNameBuilder = new StringBuilder();
			if (dnlibDef is IMemberDef memberDef) {
				var declaringTypeName = CompressTypeName(memberDef.DeclaringType?.FullName ?? "", renameMode);

				displayNameBuilder.Append(declaringTypeName.DisplayName);
				displayNameBuilder.Append("::");
				displayNameBuilder.Append(dnlibDef.Name);

				normalizedNameBuilder.Append(declaringTypeName.NormalizedName);
				normalizedNameBuilder.Append("::");
				normalizedNameBuilder.Append(dnlibDef.Name);

				if (memberDef is MethodDef methodDef) {
					displayNameBuilder.Append('(');
					normalizedNameBuilder.Append('(');
					if (methodDef.Signature is MethodSig methodSig) {
						var methodParams = methodSig.Params;
						for (var index = 0; index < methodParams.Count; index++) {
							var parameterName = CompressTypeName(methodParams[index].ToString(), renameMode);
							displayNameBuilder.Append(parameterName.DisplayName);
							normalizedNameBuilder.Append(parameterName.NormalizedName);

							if (index < methodParams.Count - 1) {
								displayNameBuilder.Append(',');
								normalizedNameBuilder.Append(',');
							}
						}
					}

					displayNameBuilder.Append(')');
					normalizedNameBuilder.Append(')');
				}
			}

			return new DisplayNormalizedName(displayNameBuilder.ToString(),
				shortNames ? dnlibDef.Name.ToString() : normalizedNameBuilder.ToString());
		}

		DisplayNormalizedName CompressTypeName(string typeName, RenameMode renameMode)
		{
			if (renameMode == RenameMode.Reversible)
			{
				if (!_prefixesMap.TryGetValue(typeName, out string prefix))
				{
					_prefixesMap.Add(typeName, GetNextSequentialName());
				}

				return new DisplayNormalizedName(typeName, prefix);
			}

			return new DisplayNormalizedName(typeName, typeName);
		}

		string GetNextSequentialName() {
			var number = _nameId++;
			var bigLength = (long)alphaNumCharset.Length;
			_nameBuilder.Clear();
			do {
				number = Math.DivRem(number, bigLength, out var remainder);
				_nameBuilder.Append(alphaNumCharset[remainder]);
			} while (number != 0);
			return _nameBuilder.ToString();
		}
	}
}

```

`Confuser.Renamer/PostRenamePhase.cs`:

```cs
using System;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer {
	internal class PostRenamePhase : ProtectionPhase {
		public PostRenamePhase(NameProtection parent)
			: base(parent) { }

		public override bool ProcessAll {
			get { return true; }
		}

		public override ProtectionTargets Targets {
			get { return ProtectionTargets.AllDefinitions; }
		}

		public override string Name {
			get { return "Post-renaming"; }
		}

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			var service = (NameService)context.Registry.GetService<INameService>();

			foreach (IRenamer renamer in service.Renamers) {
				foreach (IDnlibDef def in parameters.Targets)
					renamer.PostRename(context, service, parameters, def);
				context.CheckCancellation();
			}
		}
	}
}
```

`Confuser.Renamer/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Confuser.Renamer.Properties {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Confuser.Renamer.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die The syntax is of the path is invalid.
        ///{0}&lt;ERROR&gt;{1} ähnelt.
        /// </summary>
        internal static string InvalidPathSyntax {
            get {
                return ResourceManager.GetString("InvalidPathSyntax", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Invalid format string provided for the namespace format. Got: {0} ähnelt.
        /// </summary>
        internal static string NameService_ObfuscateName_InvalidFormat {
            get {
                return ResourceManager.GetString("NameService_ObfuscateName_InvalidFormat", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Tracing arguments for {0} call in {1} failed. What ever member is referenced here by reflection won&apos;t be properly handled by the name obfuscation. ähnelt.
        /// </summary>
        internal static string ReflectionAnalyzer_Analyze_TracingArgumentsFailed {
            get {
                return ResourceManager.GetString("ReflectionAnalyzer_Analyze_TracingArgumentsFailed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Could not find backing code for resource type &apos;{0}&apos;, protections may not apply to that type. ähnelt.
        /// </summary>
        internal static string ResourceAnalyzer_Analyze_CouldNotFindResourceType {
            get {
                return ResourceManager.GetString("ResourceAnalyzer_Analyze_CouldNotFindResourceType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Unmatched brackets.
        ///{0} ähnelt.
        /// </summary>
        internal static string UnmatchedBracket {
            get {
                return ResourceManager.GetString("UnmatchedBracket", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Unmatched parenthesis.
        ///{0} ähnelt.
        /// </summary>
        internal static string UnmatchedParen {
            get {
                return ResourceManager.GetString("UnmatchedParen", resourceCulture);
            }
        }
    }
}

```

`Confuser.Renamer/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InvalidPathSyntax" xml:space="preserve">
    <value>The syntax is of the path is invalid.
{0}&lt;ERROR&gt;{1}</value>
  </data>
  <data name="UnmatchedBracket" xml:space="preserve">
    <value>Unmatched brackets.
{0}</value>
  </data>
  <data name="UnmatchedParen" xml:space="preserve">
    <value>Unmatched parenthesis.
{0}</value>
  </data>
  <data name="ResourceAnalyzer_Analyze_CouldNotFindResourceType" xml:space="preserve">
    <value>Could not find backing code for resource type '{0}', protections may not apply to that type.</value>
  </data>
  <data name="ReflectionAnalyzer_Analyze_TracingArgumentsFailed" xml:space="preserve">
    <value>Tracing arguments for {0} call in {1} failed. What ever member is referenced here by reflection won't be properly handled by the name obfuscation.</value>
  </data>
  <data name="NameService_ObfuscateName_InvalidFormat" xml:space="preserve">
    <value>Invalid format string provided for the namespace format. Got: {0}</value>
    <comment>Exception message</comment>
  </data>
</root>
```

`Confuser.Renamer/RecursionCounter.cs`:

```cs
using System;
using System.Globalization;

// This file is originally from dnlib. Find the original source here:
// https://github.com/0xd4d/dnlib/blob/a75105a4600b5641e42e6ac36847661ae9383701/src/DotNet/RecursionCounter.cs
// Find the original license of this file here:
// https://github.com/0xd4d/dnlib/blob/a75105a4600b5641e42e6ac36847661ae9383701/LICENSE.txt
namespace Confuser.Renamer {
	/// <summary>
	/// Recursion counter
	/// </summary>
	internal ref struct RecursionCounter {
		/// <summary>
		/// Max recursion count. If this is reached, we won't continue, and will use a default value.
		/// </summary>
		private const int MAX_RECURSION_COUNT = 100;

		/// <summary>
		/// Gets the recursion counter
		/// </summary>
		private int Counter { get; set; }

		/// <summary>
		/// Increments <see cref="Counter"/> if it's not too high. <c>ALL</c> instance methods
		/// that can be called recursively must call this method and <see cref="Decrement"/>
		/// (if this method returns <see langword="true" />)
		/// </summary>
		/// <returns><see langword="true" /> if it was incremented and caller can continue, <see langword="false" /> if
		/// it was <c>not</c> incremented and the caller must return to its caller.</returns>
		public bool Increment() {
			if (Counter >= MAX_RECURSION_COUNT)
				return false;
			Counter++;
			return true;
		}

		/// <summary>
		/// Must be called before returning to caller if <see cref="Increment"/>
		/// returned <see langword="true" />.
		/// </summary>
		public void Decrement() {
#if DEBUG
			if (Counter <= 0)
				throw new InvalidOperationException("recursionCounter <= 0");
#endif
			Counter--;
		}

		/// <inheritdoc/>
		public override string ToString() => Counter.ToString(CultureInfo.InvariantCulture);
	}
}

```

`Confuser.Renamer/ReferenceUtilities.cs`:

```cs
using System.Text;
using dnlib.DotNet;

namespace Confuser.Renamer {
	internal static class ReferenceUtilities {
		internal static StringBuilder AppendDescription(this StringBuilder builder, IDnlibDef def, INameService nameService) {
			if (nameService is null)
				return builder.AppendHashedIdentifier("Name", def.FullName);

			builder.Append("Original Name").Append(": ");
			builder.Append(nameService.GetDisplayName(def));
			builder.Append("; ");
			return builder.AppendHashedIdentifier("Name", def.FullName);
		}

		internal static StringBuilder AppendReferencedDef(this StringBuilder builder, IDnlibDef def, INameService nameService) {
			switch (def) {
				case EventDef eventDef:
					return builder.AppendReferencedEvent(eventDef, nameService);
				case FieldDef fieldDef:
					return builder.AppendReferencedField(fieldDef, nameService);
				case MethodDef methodDef:
					return builder.AppendReferencedMethod(methodDef, nameService);
				case PropertyDef propDef:
					return builder.AppendReferencedProperty(propDef, nameService);
				case TypeDef typeDef:
					return builder.AppendReferencedType(typeDef, nameService);
				default:
					return builder.Append("Referenced Definition").Append("(").AppendDescription(def, nameService).Append(")");
			}
		}

		internal static StringBuilder AppendReferencedEvent(this StringBuilder builder, EventDef eventDef, INameService nameService) =>
			builder.Append("Referenced Event").Append("(").AppendDescription(eventDef, nameService).Append(")");

		internal static StringBuilder AppendReferencedField(this StringBuilder builder, FieldDef fieldDef, INameService nameService) =>
			builder.Append("Referenced Method").Append("(").AppendDescription(fieldDef, nameService).Append(")");

		internal static StringBuilder AppendReferencedMethod(this StringBuilder builder, MethodDef methodDef, INameService nameService) =>
			builder.Append("Referenced Method").Append("(").AppendDescription(methodDef, nameService).Append(")");

		internal static StringBuilder AppendReferencedProperty(this StringBuilder builder, PropertyDef propertyDef, INameService nameService) =>
			builder.Append("Referenced Property").Append("(").AppendDescription(propertyDef, nameService).Append(")");

		internal static StringBuilder AppendReferencedType(this StringBuilder builder, TypeDef typeDef, INameService nameService) =>
			builder.Append("Referenced Type").Append("(").AppendDescription(typeDef, nameService).Append(")");

		internal static StringBuilder AppendHashedIdentifier(this StringBuilder builder, string descriptor, object value) =>
			builder.Append(descriptor).Append(" Hash: ").AppendFormat("{0:X}", value.GetHashCode());
	}
}

```

`Confuser.Renamer/References/BAMLAttributeReference.cs`:

```cs
using System.Text;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal sealed class BAMLAttributeReference : INameReference<IDnlibDef> {
		readonly AttributeInfoRecord attrRec;
		readonly IDnlibDef member;
		readonly PropertyRecord propRec;

		public bool ShouldCancelRename => false;

		public BAMLAttributeReference(IDnlibDef member, AttributeInfoRecord rec) {
			this.member = member;
			attrRec = rec;
		}

		public BAMLAttributeReference(IDnlibDef member, PropertyRecord rec) {
			this.member = member;
			propRec = rec;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (attrRec != null) {
				if (UTF8String.Equals(attrRec.Name, member.Name)) return false;
				attrRec.Name = member.Name;
			}
			else {
				if (UTF8String.Equals(propRec.Value, member.Name)) return false;
				propRec.Value = member.Name;
			}
			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("BAML Attribute Reference").Append("(");
			if (attrRec != null) {
				builder.Append("Attribute Info Record").Append("(");
				builder.AppendHashedIdentifier("Name", attrRec.Name);
				builder.Append(")");
			}
			if (propRec != null) {
				builder.Append("Property Record").Append("(");
				builder.AppendHashedIdentifier("Value", propRec.Value);
				builder.Append(")");
			}
			builder.Append("; ");
			builder.AppendReferencedDef(member, nameService);
			builder.Append(")");

			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/BAMLConverterMemberReference.cs`:

```cs
using System;
using System.Text;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal sealed class BAMLConverterMemberReference : INameReference<IDnlibDef> {
		readonly IMemberDef member;
		readonly PropertyRecord rec;
		readonly TypeSig sig;
		readonly BAMLAnalyzer.XmlNsContext xmlnsCtx;

		public bool ShouldCancelRename => false;

		public BAMLConverterMemberReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, IMemberDef member, PropertyRecord rec) {
			this.xmlnsCtx = xmlnsCtx;
			this.sig = sig;
			this.member = member;
			this.rec = rec;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			string typeName = sig.ReflectionName;
			string prefix = xmlnsCtx.GetPrefix(sig.ReflectionNamespace, sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module.Assembly);
			if (!string.IsNullOrEmpty(prefix))
				typeName = prefix + ":" + typeName;
			var newValue = typeName + "." + member.Name;
			if (string.Equals(rec.Value, newValue, StringComparison.Ordinal)) return false;
			rec.Value = newValue;
			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("BAML Converter Member Reference").Append("(");
			builder.Append("Property Record").Append("(").AppendHashedIdentifier("Value", rec.Value).Append(")");
			builder.Append("; ");
			builder.Append("Type Signature").Append("(").AppendHashedIdentifier("Name", sig.ReflectionFullName).Append(")");
			builder.Append("; ");
			builder.AppendReferencedDef(member, nameService);
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/BAMLConverterTypeReference.cs`:

```cs
using System;
using System.Text;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal sealed class BAMLConverterTypeReference : INameReference<TypeDef> {
		readonly PropertyRecord propRec;
		readonly TypeSig sig;
		readonly TextRecord textRec;
		readonly BAMLAnalyzer.XmlNsContext xmlnsCtx;

		public bool ShouldCancelRename => false;

		public BAMLConverterTypeReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, PropertyRecord rec) {
			this.xmlnsCtx = xmlnsCtx;
			this.sig = sig;
			propRec = rec;
		}

		public BAMLConverterTypeReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, TextRecord rec) {
			this.xmlnsCtx = xmlnsCtx;
			this.sig = sig;
			textRec = rec;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			string name = sig.ReflectionName;
			string prefix = xmlnsCtx.GetPrefix(sig.ReflectionNamespace, sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module.Assembly);
			if (!string.IsNullOrEmpty(prefix))
				name = prefix + ":" + name;

			if (propRec != null) {
				if (string.Equals(propRec.Value, name, StringComparison.Ordinal)) return false;
				propRec.Value = name;
			}
			else {
				if (string.Equals(textRec.Value, name, StringComparison.Ordinal)) return false;
				textRec.Value = name;
			}

			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("BAML Converter Type Reference").Append("(");
			if (propRec != null) {
				builder.Append("Property Record").Append("(").AppendHashedIdentifier("Value", propRec.Value).Append(")");
			}
			else {
				builder.Append("Text Record").Append("(").AppendHashedIdentifier("Value", propRec.Value).Append(")");
			}
			builder.Append("; ");
			builder.Append("Type Signature").Append("(").AppendHashedIdentifier("Name", sig.ReflectionFullName).Append(")");
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/BAMLEnumReference.cs`:

```cs
using System.Text;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal sealed class BAMLEnumReference : INameReference<FieldDef> {
		readonly FieldDef enumField;
		readonly PropertyRecord rec;

		public bool ShouldCancelRename => false;

		public BAMLEnumReference(FieldDef enumField, PropertyRecord rec) {
			this.enumField = enumField;
			this.rec = rec;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (UTF8String.Equals(rec.Value, enumField.Name)) return false;
			rec.Value = enumField.Name;
			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("BAML Enum Reference").Append("(");
			builder.Append("Property Record").Append("(").AppendHashedIdentifier("Value", rec.Value).Append(")");
			builder.Append("; ");
			builder.AppendReferencedField(enumField, nameService);
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/BAMLPathTypeReference.cs`:

```cs
using System;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal sealed class BAMLPathTypeReference : INameReference<TypeDef>, INameReference<PropertyDef> {
		PropertyPathPartUpdater? PropertyInfo { get; }
		PropertyPathIndexUpdater? IndexerInfo { get; }
		private readonly TypeSig sig;
		readonly PropertyDef prop;
		private readonly BAMLAnalyzer.XmlNsContext xmlnsCtx;

		public bool ShouldCancelRename => false;

		private BAMLPathTypeReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig) {
			this.xmlnsCtx = xmlnsCtx ?? throw new ArgumentNullException(nameof(xmlnsCtx));
			this.sig = sig ?? throw new ArgumentNullException(nameof(sig));
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public BAMLPathTypeReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, PropertyPathIndexUpdater indexerInfo) : this(xmlnsCtx, sig) => 
			IndexerInfo = indexerInfo;

		public BAMLPathTypeReference(BAMLAnalyzer.XmlNsContext xmlnsCtx, TypeSig sig, PropertyDef property, PropertyPathPartUpdater propertyInfo) : this(xmlnsCtx, sig) {
			PropertyInfo = propertyInfo;
			prop = property;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			string name = sig.ReflectionName;
			string prefix = xmlnsCtx.GetPrefix(sig.ReflectionNamespace, sig.ToBasicTypeDefOrRef().ResolveTypeDefThrow().Module.Assembly);
			if (!string.IsNullOrEmpty(prefix))
				name = prefix + ":" + name;

			if (IndexerInfo != null) {
				var info = IndexerInfo.Value;
				if (string.Equals(info.ParenString, name, StringComparison.Ordinal)) return false;
				info.ParenString = name;
			}
			else {
				Debug.Assert(PropertyInfo != null, nameof(PropertyInfo) + " != null");
				var info = PropertyInfo.Value;
				var propertyName = prop?.Name ?? info.GetPropertyName();
				var newName = string.Format(CultureInfo.InvariantCulture, "({0}.{1})", name, propertyName);
				if (string.Equals(info.Name, newName, StringComparison.Ordinal)) return false;
				info.Name = newName;
			}
			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("BAML Path Type Reference").Append("(");
			if (PropertyInfo.HasValue)
				builder.Append("Property Info").Append("(").AppendHashedIdentifier("Name", PropertyInfo.Value.Name).Append(")");
			else
				builder.Append("Indexer Info").Append("(").AppendHashedIdentifier("Indexer", IndexerInfo.Value.ParenString).Append(")");
			builder.Append("; ");
			builder.Append("Type Signature").Append("(").AppendHashedIdentifier("Name", sig.ReflectionFullName).Append(")");
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/BAMLTypeReference.cs`:

```cs
using System;
using System.Text;
using Confuser.Core;
using Confuser.Renamer.BAML;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal sealed class BAMLTypeReference : INameReference<TypeDef> {
		readonly TypeInfoRecord rec;
		readonly TypeSig sig;

		public bool ShouldCancelRename => false;

		public BAMLTypeReference(TypeSig sig, TypeInfoRecord rec) {
			this.sig = sig;
			this.rec = rec;
		}

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (string.Equals(rec.TypeFullName, sig.ReflectionFullName, StringComparison.Ordinal)) return false;
			rec.TypeFullName = sig.ReflectionFullName;
			return true;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("BAML Type Reference").Append("(");
			builder.Append("Type Info Record").Append("(").AppendHashedIdentifier("Name", rec.TypeFullName).Append(")");
			builder.Append("; ");
			builder.Append("Type Signature").Append("(").AppendHashedIdentifier("Name", sig.ReflectionFullName).Append(")");
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/CAMemberReference.cs`:

```cs
using System.Text;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	public sealed class CAMemberReference : INameReference<IDnlibDef> {
		readonly IDnlibDef definition;
		readonly CANamedArgument namedArg;

		public bool ShouldCancelRename => false;

		public CAMemberReference(CANamedArgument namedArg, IDnlibDef definition) {
			this.namedArg = namedArg;
			this.definition = definition;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (UTF8String.Equals(namedArg.Name, definition.Name)) return false;
			namedArg.Name = definition.Name;
			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("Custom Argument Reference").Append("(");
			builder.Append("CA Argument").Append("(").AppendHashedIdentifier("Name", namedArg.Name).Append(")");
			builder.Append("; ");
			builder.AppendReferencedDef(definition, nameService);
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/MemberOldestSiblingReference.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	/// <summary>
	/// This is the reverse reference to <see cref="MemberSiblingReference"/>.
	/// It's required to detect complex inheritance situations,
	/// where multiple sets of overlapping siblings are declared.
	/// </summary>
	/// <remarks>This reference does not perform any renaming itself.</remarks>
	public sealed class MemberOldestSiblingReference : INameReference<IDnlibDef> {
		public IMemberDef OldestSiblingDef { get; set; }
		public IList<IMemberDef> OtherSiblings { get; }

		public MemberOldestSiblingReference(IMemberDef oldestSiblingDef, IMemberDef otherSiblingDef) {
			OldestSiblingDef = oldestSiblingDef ?? throw new ArgumentNullException(nameof(oldestSiblingDef));
			if (otherSiblingDef is null) throw new ArgumentNullException(nameof(otherSiblingDef));
			OtherSiblings = new List<IMemberDef> {otherSiblingDef};
		}

		/// <inheritdoc />
		public bool ShouldCancelRename => false;

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		/// <inheritdoc />
		public bool UpdateNameReference(ConfuserContext context, INameService service) => false;

		public override string ToString() => ToString(null);
		
		/// <inheritdoc />
		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("Oldest Sibling Reference").Append("(");
			builder.Append("Oldest Sibling ").AppendReferencedDef(OldestSiblingDef, nameService);
			builder.Append("; Other Siblings: ");
			foreach (var otherSibling in OtherSiblings) 
				builder.AppendReferencedDef(otherSibling, nameService).Append(", ");

			builder.Length -= 2;
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/MemberOverrideReference.cs`:

```cs
using System;
using System.Diagnostics;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	public sealed class MemberOverrideReference : INameReference<IDnlibDef> {
		internal IMemberDef ThisMemberDef { get; }
		internal IMemberDef BaseMemberDef { get; }

		public bool ShouldCancelRename => ThisMemberDef.Module != BaseMemberDef.Module;

		public MemberOverrideReference(IMemberDef thisMemberDef, IMemberDef baseMemberDef) {
			ThisMemberDef = thisMemberDef ?? throw new ArgumentNullException(nameof(thisMemberDef));
			BaseMemberDef = baseMemberDef ?? throw new ArgumentNullException(nameof(baseMemberDef));
			Debug.Assert(thisMemberDef != baseMemberDef);
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => 
			currentDef != BaseMemberDef 
			&& !ShouldCancelRename 
			&& !service.IsRenamed(BaseMemberDef);

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (UTF8String.Equals(ThisMemberDef.Name, BaseMemberDef.Name)) return false;
			ThisMemberDef.Name = BaseMemberDef.Name;
			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("Member Override Reference").Append("(");
			builder.Append("This ").AppendReferencedDef(ThisMemberDef, nameService);
			builder.Append("; ");
			builder.Append("Base ").AppendReferencedDef(BaseMemberDef, nameService);
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/MemberRefReference.cs`:

```cs
using System.Text;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	public sealed class MemberRefReference : INameReference<IMemberDef> {
		readonly IMemberDef memberDef;
		readonly MemberRef memberRef;

		public bool ShouldCancelRename => false;

		public MemberRefReference(MemberRef memberRef, IMemberDef memberDef) {
			this.memberRef = memberRef;
			this.memberDef = memberDef;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (UTF8String.Equals(memberRef.Name, memberDef.Name)) return false;
			memberRef.Name = memberDef.Name;
			return true;
		}

		public override string ToString() => ToString(null); 

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("MemberRef Reference").Append("(");
			builder.Append("MemberRef").Append("(").AppendHashedIdentifier("Name", memberRef.Name).Append(")");
			builder.Append("; ");
			builder.AppendReferencedDef(memberDef, nameService);
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/MemberSiblingReference.cs`:

```cs
using System;
using System.Diagnostics;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	public sealed class MemberSiblingReference : INameReference<IDnlibDef> {
		IMemberDef _oldestSiblingDef;
		public IMemberDef ThisMemberDef { get; }

		public IMemberDef OldestSiblingDef {
			get => _oldestSiblingDef;
			set {
				Debug.Assert(!ReferenceEquals(ThisMemberDef, value));
				_oldestSiblingDef = value;
			}
		}

		public MemberSiblingReference(IMemberDef thisMemberDef, IMemberDef oldestSiblingDef) {
			ThisMemberDef = thisMemberDef ?? throw new ArgumentNullException(nameof(thisMemberDef));
			OldestSiblingDef = oldestSiblingDef ?? throw new ArgumentNullException(nameof(oldestSiblingDef));
			Debug.Assert(!ReferenceEquals(ThisMemberDef, OldestSiblingDef));
		}

		/// <inheritdoc />
		public bool ShouldCancelRename => ThisMemberDef.Module != OldestSiblingDef.Module;

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => 
			currentDef != OldestSiblingDef 
			&& !ShouldCancelRename 
			&& !service.IsRenamed(OldestSiblingDef);

		/// <inheritdoc />
		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (UTF8String.Equals(ThisMemberDef.Name, OldestSiblingDef.Name)) return false;
			ThisMemberDef.Name = OldestSiblingDef.Name;
			return true;
		}

		public override string ToString() => ToString(null);
		
		/// <inheritdoc />
		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("Member Sibling Reference").Append("(");
			builder.Append("This ").AppendReferencedDef(ThisMemberDef, nameService);
			builder.Append("; ");
			builder.Append("Oldest Sibling ").AppendReferencedDef(OldestSiblingDef, nameService);
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/OverrideDirectiveReference.cs`:

```cs
using System.Text;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	internal sealed class OverrideDirectiveReference : INameReference<MethodDef> {
		readonly VTableSlot baseSlot;
		readonly VTableSlot thisSlot;

		public bool ShouldCancelRename => baseSlot.MethodDefDeclType is GenericInstSig && thisSlot.MethodDef.Module.IsClr20;
		
		public OverrideDirectiveReference(VTableSlot thisSlot, VTableSlot baseSlot) {
			this.thisSlot = thisSlot;
			this.baseSlot = baseSlot;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) => false;

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("Override directive").Append("(");
			builder.AppendReferencedMethod(thisSlot.MethodDef, nameService);
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/RequiredPrefixReference.cs`:

```cs
using System;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	public sealed class RequiredPrefixReference<T> : INameReference<T> where T : class, IDnlibDef {
		T Def { get; }
		string Prefix  { get; }

		/// <inheritdoc />
		public bool ShouldCancelRename => false;

		internal RequiredPrefixReference(T def, string prefix) {
			Def = def ?? throw new ArgumentNullException(nameof(def));
			Prefix = prefix ?? throw new ArgumentNullException(nameof(prefix));
			if (prefix.Length < 0) throw new ArgumentException("Prefix must not be empty.", nameof(prefix));
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		/// <inheritdoc />
		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (Def.Name.StartsWith(Prefix, StringComparison.Ordinal)) return false;

			Def.Name = Prefix + Def.Name;
			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("Required Prefix").Append("(");
			builder.Append("Prefix").Append("(").Append(Prefix).Append(")");
			builder.Append("; ");
			builder.AppendReferencedDef(Def, nameService);
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/ResourceReference.cs`:

```cs
using System.Globalization;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	public sealed class ResourceReference : INameReference<TypeDef> {
		readonly string format;
		readonly Resource resource;
		readonly TypeDef typeDef;

		public bool ShouldCancelRename => false;

		public ResourceReference(Resource resource, TypeDef typeDef, string format) {
			this.resource = resource;
			this.typeDef = typeDef;
			this.format = format;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			var newName = string.Format(CultureInfo.InvariantCulture, format, typeDef.ReflectionFullName);
			if (UTF8String.Equals(resource.Name, newName)) return false;
			resource.Name = newName;
			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("Resource Reference").Append("(");
			builder.Append("Resource").Append("(").AppendHashedIdentifier("Name", resource.Name).Append(")");
			builder.Append("; ");
			builder.AppendReferencedType(typeDef, nameService);
			builder.Append(")");
			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/StringMemberNameReference.cs`:

```cs
using System;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.References {
	public sealed class StringMemberNameReference : INameReference<IMemberDef> {
		private readonly Instruction _reference;
		private readonly IMemberDef _memberDef;
		public bool ShouldCancelRename => false;

		public StringMemberNameReference(Instruction reference, IMemberDef memberDef) {
			_reference = reference;
			_memberDef = memberDef;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			switch (_reference.Operand) {
				case string strOp when string.Equals(strOp, _memberDef.Name, StringComparison.Ordinal):
				case UTF8String utf8StrOp when UTF8String.Equals(utf8StrOp, _memberDef.Name):
					return false;
				default:
					_reference.Operand = (string)_memberDef.Name;
					return true;
			}
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("String Member Name Reference").Append("(");

			builder.Append("Instruction").Append("(").AppendHashedIdentifier("Operand", _reference.Operand).Append(")");
			builder.Append("; ");
			builder.AppendReferencedDef(_memberDef, nameService);

			builder.Append(")");

			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/StringTypeReference.cs`:

```cs
using System;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer.References {
	public sealed class StringTypeReference : INameReference<TypeDef> {
		readonly Instruction reference;
		readonly TypeDef typeDef;
		public bool ShouldCancelRename => false;

		public StringTypeReference(Instruction reference, TypeDef typeDef) {
			this.reference = reference;
			this.typeDef = typeDef;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			switch (reference.Operand) {
				case string strOp when string.Equals(strOp, typeDef.ReflectionFullName, StringComparison.Ordinal):
				case UTF8String utf8StrOp when UTF8String.Equals(utf8StrOp, typeDef.ReflectionFullName):
					return false;
				default:
					reference.Operand = typeDef.ReflectionFullName;
					return true;
			}
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("String Type Reference").Append("(");

			builder.Append("Instruction").Append("(").AppendHashedIdentifier("Operand", reference.Operand).Append(")");
			builder.Append("; ");
			builder.AppendReferencedType(typeDef, nameService);

			builder.Append(")");

			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/References/TypeRefReference.cs`:

```cs
using System.Text;
using Confuser.Core;
using dnlib.DotNet;

namespace Confuser.Renamer.References {
	public sealed class TypeRefReference : INameReference<TypeDef> {
		readonly TypeDef typeDef;
		readonly TypeRef typeRef;

		public bool ShouldCancelRename => false;

		public TypeRefReference(TypeRef typeRef, TypeDef typeDef) {
			this.typeRef = typeRef;
			this.typeDef = typeDef;
		}

		/// <inheritdoc />
		public bool DelayRenaming(INameService service, IDnlibDef currentDef) => false;

		public bool UpdateNameReference(ConfuserContext context, INameService service) {
			if (UTF8String.Equals(typeRef.Namespace, typeDef.Namespace) && 
				UTF8String.Equals(typeRef.Name, typeDef.Name)) return false;

			typeRef.Namespace = typeDef.Namespace;
			typeRef.Name = typeDef.Name;
			return true;
		}

		public override string ToString() => ToString(null);

		public string ToString(INameService nameService) {
			var builder = new StringBuilder();
			builder.Append("TypeRef Reference").Append("(");

			builder.Append("TypeRef").Append("(").AppendHashedIdentifier("Name", typeRef.FullName).Append(")");
			builder.Append("; ");
			builder.AppendReferencedType(typeDef, nameService);

			builder.Append(")");

			return builder.ToString();
		}
	}
}

```

`Confuser.Renamer/RenameMode.cs`:

```cs
using System;

namespace Confuser.Renamer {
	public enum RenameMode {
		Empty = 0x0,
		Unicode = 0x1,
		// ReSharper disable once InconsistentNaming
		ASCII = 0x2,
		/// <summary>
		/// This the the rename mode with the largest set of possible characters,
		/// that is still save for reflection.
		/// </summary>
		Reflection = 0x3,
		Letters = 0x4,

		Decodable = 0x10,
		Sequential = 0x11,
		Reversible = 0x12,

		/// <summary>Add a underscore to the name to mark that it would be renamed.</summary>
		Debug = 0x20,

		/// <summary>Keep the names as they are.</summary>
		Retain = Int32.MaxValue
	}
}

```

`Confuser.Renamer/RenamePhase.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Pdb;

namespace Confuser.Renamer {
	class RenamePhase : ProtectionPhase {
		public RenamePhase(NameProtection parent)
			: base(parent) { }

		public override ProtectionTargets Targets => ProtectionTargets.AllDefinitions;

		public override string Name => "Renaming";

		protected override void Execute(ConfuserContext context, ProtectionParameters parameters) {
			var service = (NameService)context.Registry.GetService<INameService>();

			context.Logger.Debug("Renaming...");
			foreach (var renamer in service.Renamers) {
				foreach (var def in parameters.Targets)
					renamer.PreRename(context, service, parameters, def);
				context.CheckCancellation();
			}

			var targets = parameters.Targets.ToList();
			service.GetRandom().Shuffle(targets);
			var pdbDocs = new HashSet<string>();
			foreach (var def in GetTargetsWithDelay(targets, context, service).WithProgress(targets.Count, context.Logger)) {
				if (def is ModuleDef moduleDef && parameters.GetParameter(context, moduleDef, "rickroll", false))
					RickRoller.CommenceRickroll(context, moduleDef);

				bool canRename = service.CanRename(def);
				var mode = service.GetRenameMode(def);

				if (def is MethodDef method) {
					if ((canRename || method.IsConstructor) && parameters.GetParameter(context, method, "renameArgs", true)) {
						foreach (var param in method.ParamDefs)
							param.Name = null;
					}

					if (parameters.GetParameter(context, method, "renPdb", false) && method.HasBody) {
						foreach (var instr in method.Body.Instructions) {
							if (instr.SequencePoint != null && !pdbDocs.Contains(instr.SequencePoint.Document.Url)) {
								instr.SequencePoint.Document.Url = service.ObfuscateName(instr.SequencePoint.Document.Url, mode);
								pdbDocs.Add(instr.SequencePoint.Document.Url);
							}
						}
						foreach (var local in method.Body.Variables) {
							if (!string.IsNullOrEmpty(local.Name))
								local.Name = service.ObfuscateName(local.Name, mode);
						}

						if (method.Body.HasPdbMethod)
							method.Body.PdbMethod.Scope = new PdbScope();
					}
				}

				if (!canRename)
					continue;

				service.SetIsRenamed(def);

				var references = service.GetReferences(def);
				bool cancel = references.Any(r => r.ShouldCancelRename);
				if (cancel)
					continue;

				if (def is TypeDef typeDef) {
					if (parameters.GetParameter(context, typeDef, "flatten", true)) {
						typeDef.Namespace = "";
					}
					else {
						var nsFormat = parameters.GetParameter(context, typeDef, "nsFormat", "{0}");
						typeDef.Namespace = service.ObfuscateName(nsFormat, typeDef.Namespace, mode);
					}
					typeDef.Name = service.ObfuscateName(typeDef, mode);
					RenameGenericParameters(typeDef.GenericParameters);
				}
				else if (def is MethodDef methodDef) {
					methodDef.Name = service.ObfuscateName(methodDef, mode);
					RenameGenericParameters(methodDef.GenericParameters);
				}
				else
					def.Name = service.ObfuscateName(def, mode);

				int updatedReferences = -1;
				do {
					var oldUpdatedCount = updatedReferences;
					// This resolves the changed name references and counts how many were changed.
					var updatedReferenceList = references.Where(refer => refer.UpdateNameReference(context, service)).ToArray();
					updatedReferences = updatedReferenceList.Length;
					if (updatedReferences == oldUpdatedCount) {
						var errorBuilder = new StringBuilder();
						errorBuilder.AppendLine("Infinite loop detected while resolving name references.");
						errorBuilder.Append("Processed definition: ").AppendDescription(def, service).AppendLine();
						errorBuilder.Append("Assembly: ").AppendLine(context.CurrentModule.FullName);
						errorBuilder.AppendLine("Faulty References:");
						foreach (var reference in updatedReferenceList) {
							errorBuilder.Append(" - ").AppendLine(reference.ToString(service));
						}
						context.Logger.Error(errorBuilder.ToString().Trim());
						throw new ConfuserException();
					}
					context.CheckCancellation();
				} while (updatedReferences > 0);
			}
		}

		static void RenameGenericParameters(IList<GenericParam> genericParams)
		{
			foreach (var param in genericParams)
				param.Name = ((char) (param.Number + 1)).ToString();
		}

		static IEnumerable<IDnlibDef> GetTargetsWithDelay(IList<IDnlibDef> definitions, ConfuserContext context, INameService service) {
			var delayedItems = new List<IDnlibDef>();
			var currentList = definitions;
			var lastCount = -1;
			while (currentList.Any()) {
				foreach (var def in currentList) {
					if (service.GetReferences(def).Any(r => r.DelayRenaming(service, def)))
						delayedItems.Add(def);
					else
						yield return def;
				}

				if (delayedItems.Count == lastCount) {
					var errorBuilder = new StringBuilder();
					errorBuilder.AppendLine("Failed to rename all targeted members, because the references are blocking each other.");
					errorBuilder.AppendLine("Remaining definitions: ");
					foreach (var def in delayedItems) {
						errorBuilder.Append("• ").AppendDescription(def, service).AppendLine();
					}
					context.Logger.Warn(errorBuilder.ToString().Trim());
					yield break;
				}
				lastCount = delayedItems.Count;
				currentList = delayedItems;
				delayedItems = new List<IDnlibDef>();
			}
		}
	}
}

```

`Confuser.Renamer/ReversibleRenamer.cs`:

```cs
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Confuser.Renamer {
	public class ReversibleRenamer {
		readonly Aes cipher;
		readonly byte[] key;

		public ReversibleRenamer(string password) {
			cipher = Aes.Create();
			using (var sha = SHA256.Create())
				cipher.Key = key = sha.ComputeHash(Encoding.UTF8.GetBytes(password));
		}

		public string Encrypt(string name) {
			byte ivId = GetIVId(name);
			cipher.IV = GetIV(ivId);
			var buf = Encoding.UTF8.GetBytes(name);

			using (var ms = new MemoryStream()) {
				ms.WriteByte(ivId);
				using (var stream = new CryptoStream(ms, cipher.CreateEncryptor(), CryptoStreamMode.Write)) {
					stream.Write(buf, 0, buf.Length);
					stream.FlushFinalBlock();
					return Base64Encode(ms.GetBuffer(), (int)ms.Length);
				}
			}
		}

		public string Decrypt(string name) {
			using (var ms = new MemoryStream(Base64Decode(name))) {
				byte ivId = (byte)ms.ReadByte();
				cipher.IV = GetIV(ivId);

				using (var result = new MemoryStream()) {
					using (var stream = new CryptoStream(ms, cipher.CreateDecryptor(), CryptoStreamMode.Read))
						stream.CopyTo(result);
					return Encoding.UTF8.GetString(result.GetBuffer(), 0, (int)result.Length);
				}
			}
		}

		byte[] GetIV(byte ivId) {
			byte[] iv = new byte[cipher.BlockSize / 8];
			for (int i = 0; i < iv.Length; i++)
				iv[i] = (byte)(ivId ^ key[i]);
			return iv;
		}

		byte GetIVId(string str) {
			byte x = (byte)str[0];
			for (int i = 1; i < str.Length; i++)
				x = (byte)(x * 3 + (byte)str[i]);
			return x;
		}

		static string Base64Encode(byte[] buffer, int length) {
			int inputUnpaddedLength = 4 * length / 3;
			var outArray = new char[(inputUnpaddedLength + 3) & ~3];
			Convert.ToBase64CharArray(buffer, 0, length, outArray, 0);

			var result = new StringBuilder(inputUnpaddedLength);
			foreach (var oldChar in outArray) {
				if (oldChar == '=') {
					break;
				}

				result.Append(oldChar == '+'
					? '$'
					: oldChar == '/'
						? '_'
						: oldChar);
			}

			return result.ToString();
		}

		static byte[] Base64Decode(string str) {
			var newLength = (str.Length + 3) & ~3;
			var inArray = new char[newLength];
			for (int index = 0; index < newLength; index++) {
				char newChar;
				if (index < str.Length) {
					char oldChar = str[index];
					newChar = oldChar == '$'
						? '+'
						: oldChar == '_'
							? '/'
							: oldChar;
				}
				else {
					newChar = '=';
				}

				inArray[index] = newChar;
			}

			return Convert.FromBase64CharArray(inArray, 0, inArray.Length);
		}
	}
}

```

`Confuser.Renamer/RickRoller.cs`:

```cs
using System;
using System.Linq;
using Confuser.Core;
using Confuser.Core.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Confuser.Renamer {
	// For my dearest Reflector devs, this is my Christmas present.
	public static class RickRoller {
		const string Injection = "\"onclick=\"return(false);\"style=\"background:#ffffff;cursor:default;position:absolute;display:block;width:10000px;height:10000px;top:0px;left:0px\"><IMG/src=\"#\"onerror=\"REPL\"></A></TABLE><!--";
		const string JS = "window.open(\"https://youtu.be/dQw4w9WgXcQ\",\"\",\"fullscreen=yes\")";

		static string EscapeScript(string script) {
			return script
				.Replace("&", "&amp;")
				.Replace(" ", "&nbsp;")
				.Replace("\"", "&quot;")
				.Replace("<", "&lt;")
				.Replace("\r", "")
				.Replace("\n", "");
		}


		public static void CommenceRickroll(ConfuserContext context, ModuleDef module) {
			var marker = context.Registry.GetService<IMarkerService>();
			var nameService = context.Registry.GetService<INameService>();
			var injection = Injection.Replace("REPL", EscapeScript(JS));

			var globalType = module.GlobalType;
			var newType = new TypeDefUser(" ", module.CorLibTypes.Object.ToTypeDefOrRef());
			newType.Attributes |= TypeAttributes.NestedPublic;
			globalType.NestedTypes.Add(newType);

			var trap = new MethodDefUser(
				injection,
				MethodSig.CreateStatic(module.CorLibTypes.Void),
				MethodAttributes.Public | MethodAttributes.Static);
			trap.Body = new CilBody();
			trap.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
			newType.Methods.Add(trap);

			marker.Mark(newType, null);
			marker.Mark(trap, null);
			nameService.SetCanRename(trap, false);

			foreach (var method in module.GetTypes().SelectMany(type => type.Methods)) {
				if (method != trap && method.HasBody)
					method.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, trap));
			}
		}
	}
}

```

`Confuser.Renamer/VTable.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Confuser.Core;
using dnlib.DotNet;
using ILogger = Confuser.Core.ILogger;

namespace Confuser.Renamer {
	public class VTableSignature {
		internal VTableSignature(MethodSig sig, string name) {
			MethodSig = sig;
			Name = name;
		}

		public MethodSig MethodSig { get; private set; }
		public string Name { get; private set; }

		public static VTableSignature FromMethod(IMethod method) {
			MethodSig sig = method.MethodSig;
			TypeSig declType = method.DeclaringType.ToTypeSig();
			if (declType is GenericInstSig) {
				sig = GenericArgumentResolver.Resolve(sig, ((GenericInstSig)declType).GenericArguments);
			}
			return new VTableSignature(sig, method.Name);
		}

		public override bool Equals(object obj) {
			var other = obj as VTableSignature;
			if (other == null)
				return false;
			return new SigComparer().Equals(MethodSig, other.MethodSig) &&
				   Name.Equals(other.Name, StringComparison.Ordinal);
		}

		public override int GetHashCode() {
			int hash = 17;
			hash = hash * 7 + new SigComparer().GetHashCode(MethodSig);
			return hash * 7 + Name.GetHashCode();
		}

		public static bool operator ==(VTableSignature a, VTableSignature b) {
			if (ReferenceEquals(a, b))
				return true;
			if (!Equals(a, null) && Equals(b, null))
				return false;

			return a.Equals(b);
		}

		public static bool operator !=(VTableSignature a, VTableSignature b) {
			return !(a == b);
		}

		public override string ToString() {
			return FullNameFactory.MethodFullName("", Name, MethodSig);
		}
	}

	public class VTableSlot {
		internal VTableSlot(MethodDef def, TypeSig decl, VTableSignature signature)
			: this(def.DeclaringType.ToTypeSig(), def, decl, signature, null) { }

		internal VTableSlot(TypeSig defDeclType, MethodDef def, TypeSig decl, VTableSignature signature, VTableSlot overrides) {
			MethodDefDeclType = defDeclType;
			MethodDef = def;
			DeclaringType = decl;
			Signature = signature;
			Overrides = overrides;
		}

		// This is the type in which this slot is defined.
		public TypeSig DeclaringType { get; internal set; }
		// This is the signature of this slot.
		public VTableSignature Signature { get; internal set; }

		// This is the method that is currently in the slot.
		public TypeSig MethodDefDeclType { get; private set; }
		public MethodDef MethodDef { get; private set; }

		// This is the 'parent slot' that this slot overrides.
		public VTableSlot Overrides { get; private set; }

		public VTableSlot OverridedBy(MethodDef method) {
			return new VTableSlot(method.DeclaringType.ToTypeSig(), method, DeclaringType, Signature, this);
		}

		internal VTableSlot Clone() {
			return new VTableSlot(MethodDefDeclType, MethodDef, DeclaringType, Signature, Overrides);
		}

		public override string ToString() {
			return MethodDef.ToString();
		}
	}

	public class VTable {
		internal VTable(TypeSig type) {
			Type = type;
			Slots = new List<VTableSlot>();
			InterfaceSlots = new Dictionary<TypeSig, IList<VTableSlot>>(TypeEqualityComparer.Instance);
		}

		public TypeSig Type { get; private set; }

		public IList<VTableSlot> Slots { get; private set; }
		public IDictionary<TypeSig, IList<VTableSlot>> InterfaceSlots { get; private set; }

		class VTableConstruction {
			// All virtual method slots, excluding interfaces
			public List<VTableSlot> AllSlots = new List<VTableSlot>();
			// All visible virtual method slots (i.e. excluded those being shadowed)
			public Dictionary<VTableSignature, VTableSlot> SlotsMap = new Dictionary<VTableSignature, VTableSlot>();
			public Dictionary<TypeSig, ILookup<VTableSignature, VTableSlot>> InterfaceSlots = new Dictionary<TypeSig, ILookup<VTableSignature, VTableSlot>>(TypeEqualityComparer.Instance);
		}

		public IEnumerable<VTableSlot> FindSlots(IMethod method) {
			return Slots
				.Concat(InterfaceSlots.SelectMany(iface => iface.Value))
				.Where(slot => slot.MethodDef == method);
		}

		public static VTable ConstructVTable(TypeDef typeDef, VTableStorage storage) {
			var ret = new VTable(typeDef.ToTypeSig());

			var virtualMethods = typeDef.Methods
										.Where(method => method.IsVirtual)
										.ToDictionary(
											method => VTableSignature.FromMethod(method),
											method => method
				);

			// See Partition II 12.2 for implementation algorithm
			VTableConstruction vTbl = new VTableConstruction();

			// Inherits base type's slots
			VTable baseVTbl = storage.GetVTable(typeDef.GetBaseTypeThrow());
			if (baseVTbl != null) {
				Inherits(vTbl, baseVTbl);
			}

			// Explicit interface implementation
			foreach (InterfaceImpl iface in typeDef.Interfaces) {
				VTable ifaceVTbl = storage.GetVTable(iface.Interface);
				if (ifaceVTbl != null) {
					Implements(vTbl, virtualMethods, ifaceVTbl, iface.Interface.ToTypeSig());
				}
			}

			// Normal interface implementation
			if (!typeDef.IsInterface) {
				// Interface methods cannot implements base interface methods.

				foreach (var interfaceTypeSig in vTbl.InterfaceSlots.Keys.ToList()) {
					var slots = vTbl.InterfaceSlots[interfaceTypeSig];
					if (slots.Select(g => g.Key)
						.Any(sig => virtualMethods.ContainsKey(sig) || vTbl.SlotsMap.ContainsKey(sig))) {
						// Something has a new signature. We need to rewrite the whole thing.
						
						// This is the step 1 of 12.2 algorithm -- find implementation for still empty slots.
						// Note that it seems we should include newslot methods as well, despite what the standard said.
						slots = slots
							.SelectMany(g => g.Select(slot => (g.Key, Slot: slot)))
							.ToLookup(t => t.Key, t => {
								if (!t.Slot.MethodDef.DeclaringType.IsInterface)
									return t.Slot;

								if (virtualMethods.TryGetValue(t.Key, out var impl))
									return t.Slot.OverridedBy(impl);

								if (vTbl.SlotsMap.TryGetValue(t.Key, out var implSlot))
									return t.Slot.OverridedBy(implSlot.MethodDef);

								return t.Slot;
							});

						vTbl.InterfaceSlots[interfaceTypeSig] = slots;
					}
				}
			}

			// Normal overrides
			foreach (var method in virtualMethods) {
				VTableSlot slot;
				if (method.Value.IsNewSlot) {
					slot = new VTableSlot(method.Value, typeDef.ToTypeSig(), method.Key);
				}
				else {
					if (vTbl.SlotsMap.TryGetValue(method.Key, out slot)) {
						Debug.Assert(!slot.MethodDef.IsFinal);
						slot = slot.OverridedBy(method.Value);
					}
					else
						slot = new VTableSlot(method.Value, typeDef.ToTypeSig(), method.Key);
				}
				vTbl.SlotsMap[method.Key] = slot;
				vTbl.AllSlots.Add(slot);
			}

			// MethodImpls
			foreach (var method in virtualMethods) {
				foreach (var impl in method.Value.Overrides) {
					Debug.Assert(impl.MethodBody == method.Value);

					MethodDef targetMethod = impl.MethodDeclaration.ResolveThrow();
					if (targetMethod.DeclaringType.IsInterface) {
						var iface = impl.MethodDeclaration.DeclaringType.ToTypeSig();
						CheckKeyExist(storage, vTbl.InterfaceSlots, iface, "MethodImpl Iface");
						var ifaceVTbl = vTbl.InterfaceSlots[iface];

						var signature = VTableSignature.FromMethod(impl.MethodDeclaration);
						CheckKeyExist(storage, ifaceVTbl, signature, "MethodImpl Iface Sig");

						vTbl.InterfaceSlots[iface] = ifaceVTbl
							.SelectMany(g => g.Select(slot => (g.Key, Slot: slot)))
							.ToLookup(t => t.Key, t => {
								if (!t.Key.Equals(signature)) 
									return t.Slot;

								var targetSlot = t.Slot;
								while (targetSlot.Overrides != null)
									targetSlot = targetSlot.Overrides;
								Debug.Assert(targetSlot.MethodDef.DeclaringType.IsInterface);
								Debug.Assert(targetSlot.Signature.Equals(t.Slot.Signature));

								return targetSlot.OverridedBy(method.Value);
							});
					}
					else {
						var targetSlot = vTbl.AllSlots.SingleOrDefault(slot => slot.MethodDef == targetMethod);
						if (targetSlot == null) {
							throw new Exception($"method [{method}] not found.");
						}
						CheckKeyExist(storage, vTbl.SlotsMap, targetSlot.Signature, "MethodImpl Normal Sig");
						targetSlot = vTbl.SlotsMap[targetSlot.Signature]; // Use the most derived slot
																		  // Maybe implemented by above processes --- this process should take priority
						while (targetSlot.MethodDef.DeclaringType == typeDef)
							targetSlot = targetSlot.Overrides;
						vTbl.SlotsMap[targetSlot.Signature] = targetSlot.OverridedBy(method.Value);
					}
				}
			}

			// Populate result V-table
			ret.InterfaceSlots = vTbl.InterfaceSlots.ToDictionary(
				kvp => kvp.Key, kvp => (IList<VTableSlot>)kvp.Value.SelectMany(g => g).ToList(), TypeEqualityComparer.Instance);

			foreach (var slot in vTbl.AllSlots) {
				ret.Slots.Add(slot);
			}

			return ret;
		}

		static void Implements(VTableConstruction vTbl, Dictionary<VTableSignature, MethodDef> virtualMethods, VTable ifaceVTbl, TypeSig iface) {
			// This is the step 2 of 12.2 algorithm -- use virtual newslot methods for explicit implementation.

			Func<VTableSlot, VTableSlot> implLookup = slot => {
				MethodDef impl;
				if (virtualMethods.TryGetValue(slot.Signature, out impl) &&
					impl.IsNewSlot && !impl.DeclaringType.IsInterface) {
					// Interface methods cannot implements base interface methods.
					// The Overrides of interface slots should directly points to the root interface slot
					var targetSlot = slot;
					while (targetSlot.Overrides != null && !targetSlot.MethodDef.DeclaringType.IsInterface)
						targetSlot = targetSlot.Overrides;
					Debug.Assert(targetSlot.MethodDef.DeclaringType.IsInterface);
					return targetSlot.OverridedBy(impl);
				}
				return slot;
			};

			if (vTbl.InterfaceSlots.ContainsKey(iface)) {
				vTbl.InterfaceSlots[iface] = vTbl.InterfaceSlots[iface].SelectMany(g => g).ToLookup(
					slot => slot.Signature, implLookup);
			}
			else {
				vTbl.InterfaceSlots.Add(iface, ifaceVTbl.Slots.ToLookup(
					slot => slot.Signature, implLookup));
			}

			foreach (var baseIface in ifaceVTbl.InterfaceSlots) {
				if (vTbl.InterfaceSlots.ContainsKey(baseIface.Key)) {
					vTbl.InterfaceSlots[baseIface.Key] = vTbl.InterfaceSlots[baseIface.Key].SelectMany(g => g).ToLookup(
						slot => slot.Signature, implLookup);
				}
				else {
					vTbl.InterfaceSlots.Add(baseIface.Key, baseIface.Value.ToLookup(
						slot => slot.Signature, implLookup));
				}
			}
		}

		static void Inherits(VTableConstruction vTbl, VTable baseVTbl) {
			foreach (VTableSlot slot in baseVTbl.Slots) {
				vTbl.AllSlots.Add(slot);
				// It's possible to have same signature in multiple slots,
				// when a derived type shadow the base type using newslot.
				// In this case, use the derived type's slot in SlotsMap.

				// The derived type's slots are always at a later position
				// than the base type, so it would naturally 'override'
				// their position in SlotsMap.
				vTbl.SlotsMap[slot.Signature] = slot;
			}

			// This is the step 1 of 12.2 algorithm -- copy the base interface implementation.
			foreach (var iface in baseVTbl.InterfaceSlots) {
				Debug.Assert(!vTbl.InterfaceSlots.ContainsKey(iface.Key));
				vTbl.InterfaceSlots.Add(iface.Key, iface.Value.ToLookup(slot => slot.Signature, slot => slot));
			}
		}

		[Conditional("DEBUG")]
		static void CheckKeyExist<TKey, TValue>(VTableStorage storage, IDictionary<TKey, TValue> dictionary, TKey key, string name) {
			if (!dictionary.ContainsKey(key)) {
				storage.GetLogger().ErrorFormat("{0} not found: {1}", name, key);
				foreach (var k in dictionary.Values)
					storage.GetLogger().ErrorFormat("    {0}", k);
			}
		}

		[Conditional("DEBUG")]
		static void CheckKeyExist<TKey, TValue>(VTableStorage storage, ILookup<TKey, TValue> lookup, TKey key, string name) {
			if (!lookup.Contains(key)) {
				storage.GetLogger().ErrorFormat("{0} not found: {1}", name, key);
				foreach (var k in lookup.Select(g => g.Key))
					storage.GetLogger().ErrorFormat("    {0}", k);
			}
		}
	}

	public class VTableStorage {
		Dictionary<TypeDef, VTable> storage = new Dictionary<TypeDef, VTable>();
		ILogger logger;

		public VTableStorage(ILogger logger) {
			this.logger = logger;
		}

		public ILogger GetLogger() {
			return logger;
		}

		public VTable this[TypeDef type] {
			get { return storage.GetValueOrDefault(type, null); }
			internal set { storage[type] = value; }
		}

		VTable GetOrConstruct(TypeDef type) {
			VTable ret;
			if (!storage.TryGetValue(type, out ret))
				ret = storage[type] = VTable.ConstructVTable(type, this);
			return ret;
		}

		public VTable GetVTable(ITypeDefOrRef type) {
			if (type == null)
				return null;
			if (type is TypeDef)
				return GetOrConstruct((TypeDef)type);
			if (type is TypeRef)
				return GetOrConstruct(((TypeRef)type).ResolveThrow());
			if (type is TypeSpec) {
				TypeSig sig = ((TypeSpec)type).TypeSig;
				if (sig is TypeDefOrRefSig) {
					TypeDef typeDef = ((TypeDefOrRefSig)sig).TypeDefOrRef.ResolveTypeDefThrow();
					return GetOrConstruct(typeDef);
				}
				if (sig is GenericInstSig) {
					var genInst = (GenericInstSig)sig;
					TypeDef openType = genInst.GenericType.TypeDefOrRef.ResolveTypeDefThrow();
					VTable vTable = GetOrConstruct(openType);

					return ResolveGenericArgument(openType, genInst, vTable);
				}
				throw new NotSupportedException("Unexpected type: " + type);
			}
			throw new UnreachableException();
		}

		static VTableSlot ResolveSlot(TypeDef openType, VTableSlot slot, IList<TypeSig> genArgs) {
			var newSig = GenericArgumentResolver.Resolve(slot.Signature.MethodSig, genArgs);
			TypeSig newDecl = slot.MethodDefDeclType;
			if (new SigComparer().Equals(newDecl, openType))
				newDecl = new GenericInstSig((ClassOrValueTypeSig)openType.ToTypeSig(), genArgs.ToArray());
			else
				newDecl = GenericArgumentResolver.Resolve(newDecl, genArgs);
			return new VTableSlot(newDecl, slot.MethodDef, slot.DeclaringType, new VTableSignature(newSig, slot.Signature.Name), slot.Overrides);
		}

		static VTable ResolveGenericArgument(TypeDef openType, GenericInstSig genInst, VTable vTable) {
			Debug.Assert(new SigComparer().Equals(openType, vTable.Type));
			var ret = new VTable(genInst);
			foreach (VTableSlot slot in vTable.Slots) {
				ret.Slots.Add(ResolveSlot(openType, slot, genInst.GenericArguments));
			}
			foreach (var iface in vTable.InterfaceSlots) {
				ret.InterfaceSlots.Add(GenericArgumentResolver.Resolve(iface.Key, genInst.GenericArguments),
									   iface.Value.Select(slot => ResolveSlot(openType, slot, genInst.GenericArguments)).ToList());
			}
			return ret;
		}
	}
}

```

`Confuser.Runtime/AntiDebug.Antinet.cs`:

```cs
using System;

namespace Confuser.Runtime {
	static partial class AntiDebugAntinet {
		static void Initialize() {
			if (!InitializeAntiDebugger())
				Environment.FailFast(null);
			InitializeAntiProfiler();
			if (IsProfilerAttached) {
				Environment.FailFast(null);
				PreventActiveProfilerFromReceivingProfilingMessages();
			}
		}
	}
}
```

`Confuser.Runtime/AntiDebug.Safe.cs`:

```cs
using System;
using System.Diagnostics;
using System.Threading;

namespace Confuser.Runtime {
	internal static class AntiDebugSafe {
		static void Initialize() {
			const string x = "COR";
			var env = typeof(Environment);
			var method = env.GetMethod("GetEnvironmentVariable", new[] { typeof(string) });

			// Comparison is done using is-operator to avoid the op_inequality overload of .NET 4.0
			// This is required to ensure that the result is .NET 2.0 compatible.
			if (!(method is null) &&
			    "1".Equals(method.Invoke(null, new object[] { x + "_ENABLE_PROFILING" })))
				Environment.FailFast(null);

			var thread = new Thread(Worker);
			thread.IsBackground = true;
			thread.Start(null);
		}

		static void Worker(object thread) {
			if (!(thread is Thread th)) {
				th = new Thread(Worker);
				th.IsBackground = true;
				th.Start(Thread.CurrentThread);
				Thread.Sleep(500);
			}
			while (true) {
				if (Debugger.IsAttached || Debugger.IsLogging())
					Environment.FailFast(null);

				if (!th.IsAlive)
					Environment.FailFast(null);

				Thread.Sleep(1000);
			}
		}
	}
}

```

`Confuser.Runtime/AntiDebug.Win32.cs`:

```cs
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;

namespace Confuser.Runtime {
	internal static class AntiDebugWin32 {
		static void Initialize() {
			string x = "COR";
			if (Environment.GetEnvironmentVariable(x + "_PROFILER") != null ||
			    Environment.GetEnvironmentVariable(x + "_ENABLE_PROFILING") != null)
				Environment.FailFast(null);
			//Anti dnspy
			Process here = GetParentProcess();
			if (here != null && here.ProcessName.ToLower().Contains("dnspy"))
				Environment.FailFast("");

			var thread = new Thread(Worker);
			thread.IsBackground = true;
			thread.Start(null);
		}

		//https://stackoverflow.com/questions/394816/how-to-get-parent-process-in-net-in-managed-way

		private static ParentProcessUtilities PPU;
		public static Process GetParentProcess() {
			return ParentProcessUtilities.GetParentProcess();
		}

		/// <summary>
		/// A utility class to determine a process parent.
		/// </summary>
		[StructLayout(LayoutKind.Sequential)]
		internal struct ParentProcessUtilities {
			// These members must match PROCESS_BASIC_INFORMATION
			internal IntPtr Reserved1;
			internal IntPtr PebBaseAddress;
			internal IntPtr Reserved2_0;
			internal IntPtr Reserved2_1;
			internal IntPtr UniqueProcessId;
			internal IntPtr InheritedFromUniqueProcessId;

			[DllImport("ntdll.dll")]
			private static extern int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass, ref ParentProcessUtilities processInformation, uint processInformationLength, out int returnLength);
			
			/// <summary>
			/// Gets the parent process of the current process.
			/// </summary>
			/// <returns>An instance of the Process class.</returns>
			internal static Process GetParentProcess() {
				return GetParentProcess(Process.GetCurrentProcess().Handle);
			}

			/// <summary>
			/// Gets the parent process of specified process.
			/// </summary>
			/// <param name="id">The process id.</param>
			/// <returns>An instance of the Process class.</returns>
			public static Process GetParentProcess(int id) {
				Process process = Process.GetProcessById(id);
				return GetParentProcess(process.Handle);
			}

			/// <summary>
			/// Gets the parent process of a specified process.
			/// </summary>
			/// <param name="handle">The process handle.</param>
			/// <returns>An instance of the Process class.</returns>
			public static Process GetParentProcess(IntPtr handle) {
				var pbi = new ParentProcessUtilities();
				int status = NtQueryInformationProcess(handle, 0, ref pbi, (uint)Marshal.SizeOf(pbi), out _);
				if (status != 0)
					return null;

				try {
					return Process.GetProcessById(pbi.InheritedFromUniqueProcessId.ToInt32());
				}
				catch (ArgumentException) {
					// not found
					return null;
				}
			}
		}

		[DllImport("kernel32.dll")]
		static extern bool CloseHandle(IntPtr hObject);

		[DllImport("kernel32.dll")]
		static extern bool IsDebuggerPresent();

		[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
		static extern int OutputDebugString(string str);

		static void Worker(object thread) {
			var th = thread as Thread;
			if (th == null) {
				th = new Thread(Worker);
				th.IsBackground = true;
				th.Start(Thread.CurrentThread);
				Thread.Sleep(500);
			}
			while (true) {
				// Managed
				if (Debugger.IsAttached || Debugger.IsLogging())
					Environment.FailFast("");

				// IsDebuggerPresent
				if (IsDebuggerPresent())
					Environment.FailFast("");

				// OpenProcess
				Process ps = Process.GetCurrentProcess();
				if (ps.Handle == IntPtr.Zero)
					Environment.FailFast("");
				ps.Close();

				// OutputDebugString
				if (OutputDebugString("") > IntPtr.Size)
					Environment.FailFast("");

				// CloseHandle
				try {
					CloseHandle(IntPtr.Zero);
				}
				catch {
					Environment.FailFast("");
				}

				if (!th.IsAlive)
					Environment.FailFast("");

				Thread.Sleep(1000);
			}
		}
	}
}

```

`Confuser.Runtime/AntiDump.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace Confuser.Runtime {
	internal static class AntiDump {
		[DllImport("kernel32.dll")]
		static extern unsafe bool VirtualProtect(byte* lpAddress, int dwSize, uint flNewProtect, out uint lpflOldProtect);

		static unsafe void Initialize() {
			uint old;
			Module module = typeof(AntiDump).Module;
			var bas = (byte*)Marshal.GetHINSTANCE(module);
			byte* ptr = bas + 0x3c;
			byte* ptr2;
			ptr = ptr2 = bas + *(uint*)ptr;
			ptr += 0x6;
			ushort sectNum = *(ushort*)ptr;
			ptr += 14;
			ushort optSize = *(ushort*)ptr;
			ptr = ptr2 = ptr + 0x4 + optSize;

			byte* @new = stackalloc byte[11];
			if (module.FullyQualifiedName[0] != '<') //Mapped
			{
				//VirtualProtect(ptr - 16, 8, 0x40, out old);
				//*(uint*)(ptr - 12) = 0;
				byte* mdDir = bas + *(uint*)(ptr - 16);
				//*(uint*)(ptr - 16) = 0;

				if (*(uint*)(ptr - 0x78) != 0) {
					byte* importDir = bas + *(uint*)(ptr - 0x78);
					byte* oftMod = bas + *(uint*)importDir;
					byte* modName = bas + *(uint*)(importDir + 12);
					byte* funcName = bas + *(uint*)oftMod + 2;
					VirtualProtect(modName, 11, 0x40, out old);

					*(uint*)@new = 0x6c64746e;
					*((uint*)@new + 1) = 0x6c642e6c;
					*((ushort*)@new + 4) = 0x006c;
					*(@new + 10) = 0;

					for (int i = 0; i < 11; i++)
						*(modName + i) = *(@new + i);

					VirtualProtect(funcName, 11, 0x40, out old);

					*(uint*)@new = 0x6f43744e;
					*((uint*)@new + 1) = 0x6e69746e;
					*((ushort*)@new + 4) = 0x6575;
					*(@new + 10) = 0;

					for (int i = 0; i < 11; i++)
						*(funcName + i) = *(@new + i);
				}

				for (int i = 0; i < sectNum; i++) {
					VirtualProtect(ptr, 8, 0x40, out old);
					Marshal.Copy(new byte[8], 0, (IntPtr)ptr, 8);
					ptr += 0x28;
				}
				VirtualProtect(mdDir, 0x48, 0x40, out old);
				byte* mdHdr = bas + *(uint*)(mdDir + 8);
				*(uint*)mdDir = 0;
				*((uint*)mdDir + 1) = 0;
				*((uint*)mdDir + 2) = 0;
				*((uint*)mdDir + 3) = 0;

				VirtualProtect(mdHdr, 4, 0x40, out old);
				*(uint*)mdHdr = 0;
				mdHdr += 12;
				mdHdr += *(uint*)mdHdr;
				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);
				mdHdr += 2;
				ushort numOfStream = *mdHdr;
				mdHdr += 2;
				for (int i = 0; i < numOfStream; i++) {
					VirtualProtect(mdHdr, 8, 0x40, out old);
					//*(uint*)mdHdr = 0;
					mdHdr += 4;
					//*(uint*)mdHdr = 0;
					mdHdr += 4;
					for (int ii = 0; ii < 8; ii++) {
						VirtualProtect(mdHdr, 4, 0x40, out old);
						*mdHdr = 0;
						mdHdr++;
						if (*mdHdr == 0) {
							mdHdr += 3;
							break;
						}
						*mdHdr = 0;
						mdHdr++;
						if (*mdHdr == 0) {
							mdHdr += 2;
							break;
						}
						*mdHdr = 0;
						mdHdr++;
						if (*mdHdr == 0) {
							mdHdr += 1;
							break;
						}
						*mdHdr = 0;
						mdHdr++;
					}
				}
			}
			else //Flat
			{
				//VirtualProtect(ptr - 16, 8, 0x40, out old);
				//*(uint*)(ptr - 12) = 0;
				uint mdDir = *(uint*)(ptr - 16);
				//*(uint*)(ptr - 16) = 0;
				uint importDir = *(uint*)(ptr - 0x78);

				var vAdrs = new uint[sectNum];
				var vSizes = new uint[sectNum];
				var rAdrs = new uint[sectNum];
				for (int i = 0; i < sectNum; i++) {
					VirtualProtect(ptr, 8, 0x40, out old);
					Marshal.Copy(new byte[8], 0, (IntPtr)ptr, 8);
					vAdrs[i] = *(uint*)(ptr + 12);
					vSizes[i] = *(uint*)(ptr + 8);
					rAdrs[i] = *(uint*)(ptr + 20);
					ptr += 0x28;
				}


				if (importDir != 0) {
					for (int i = 0; i < sectNum; i++)
						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {
							importDir = importDir - vAdrs[i] + rAdrs[i];
							break;
						}
					byte* importDirPtr = bas + importDir;
					uint oftMod = *(uint*)importDirPtr;
					for (int i = 0; i < sectNum; i++)
						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {
							oftMod = oftMod - vAdrs[i] + rAdrs[i];
							break;
						}
					byte* oftModPtr = bas + oftMod;
					uint modName = *(uint*)(importDirPtr + 12);
					for (int i = 0; i < sectNum; i++)
						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {
							modName = modName - vAdrs[i] + rAdrs[i];
							break;
						}
					uint funcName = *(uint*)oftModPtr + 2;
					for (int i = 0; i < sectNum; i++)
						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {
							funcName = funcName - vAdrs[i] + rAdrs[i];
							break;
						}
					VirtualProtect(bas + modName, 11, 0x40, out old);

					*(uint*)@new = 0x6c64746e;
					*((uint*)@new + 1) = 0x6c642e6c;
					*((ushort*)@new + 4) = 0x006c;
					*(@new + 10) = 0;

					for (int i = 0; i < 11; i++)
						*(bas + modName + i) = *(@new + i);

					VirtualProtect(bas + funcName, 11, 0x40, out old);

					*(uint*)@new = 0x6f43744e;
					*((uint*)@new + 1) = 0x6e69746e;
					*((ushort*)@new + 4) = 0x6575;
					*(@new + 10) = 0;

					for (int i = 0; i < 11; i++)
						*(bas + funcName + i) = *(@new + i);
				}


				for (int i = 0; i < sectNum; i++)
					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {
						mdDir = mdDir - vAdrs[i] + rAdrs[i];
						break;
					}
				byte* mdDirPtr = bas + mdDir;
				VirtualProtect(mdDirPtr, 0x48, 0x40, out old);
				uint mdHdr = *(uint*)(mdDirPtr + 8);
				for (int i = 0; i < sectNum; i++)
					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {
						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];
						break;
					}
				*(uint*)mdDirPtr = 0;
				*((uint*)mdDirPtr + 1) = 0;
				*((uint*)mdDirPtr + 2) = 0;
				*((uint*)mdDirPtr + 3) = 0;


				byte* mdHdrPtr = bas + mdHdr;
				VirtualProtect(mdHdrPtr, 4, 0x40, out old);
				*(uint*)mdHdrPtr = 0;
				mdHdrPtr += 12;
				mdHdrPtr += *(uint*)mdHdrPtr;
				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);
				mdHdrPtr += 2;
				ushort numOfStream = *mdHdrPtr;
				mdHdrPtr += 2;
				for (int i = 0; i < numOfStream; i++) {
					VirtualProtect(mdHdrPtr, 8, 0x40, out old);
					//*(uint*)mdHdrPtr = 0;
					mdHdrPtr += 4;
					//*(uint*)mdHdrPtr = 0;
					mdHdrPtr += 4;
					for (int ii = 0; ii < 8; ii++) {
						VirtualProtect(mdHdrPtr, 4, 0x40, out old);
						*mdHdrPtr = 0;
						mdHdrPtr++;
						if (*mdHdrPtr == 0) {
							mdHdrPtr += 3;
							break;
						}
						*mdHdrPtr = 0;
						mdHdrPtr++;
						if (*mdHdrPtr == 0) {
							mdHdrPtr += 2;
							break;
						}
						*mdHdrPtr = 0;
						mdHdrPtr++;
						if (*mdHdrPtr == 0) {
							mdHdrPtr += 1;
							break;
						}
						*mdHdrPtr = 0;
						mdHdrPtr++;
					}
				}
			}
		}
	}
}
```

`Confuser.Runtime/AntiTamper.Anti.cs`:

```cs
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;

namespace Confuser.Runtime {
	internal static class AntiTamperAnti {
		[DllImport("kernel32.dll")]
		static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize, uint flNewProtect, out uint lpflOldProtect);


		[DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
		static extern bool CheckRemoteDebuggerPresent(IntPtr hProcess, ref bool isDebuggerPresent);

		static unsafe void Initialize() {
			Module m = typeof(AntiTamperAnti).Module;
			string n = m.FullyQualifiedName;
			bool f = n.Length > 0 && n[0] == '<';
			var b = (byte*)Marshal.GetHINSTANCE(m);
			byte* p = b + *(uint*)(b + 0x3c);
			ushort s = *(ushort*)(p + 0x6);
			ushort o = *(ushort*)(p + 0x14);

			bool isDebuggerPresent = false;

			uint* e = null;
			uint l = 0;
			var r = (uint*)(p + 0x18 + o);
			uint z = (uint)Mutation.KeyI1, x = (uint)Mutation.KeyI2, c = (uint)Mutation.KeyI3, v = (uint)Mutation.KeyI4;

			CheckRemoteDebuggerPresent(Process.GetCurrentProcess().Handle, ref isDebuggerPresent);
			if (isDebuggerPresent) Environment.FailFast(null);

			for (int i = 0; i < s; i++) {
				uint g = (*r++) * (*r++);
				if (g == (uint)Mutation.KeyI0) {
					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));

					CheckRemoteDebuggerPresent(Process.GetCurrentProcess().Handle, ref isDebuggerPresent);
					if (isDebuggerPresent) Environment.FailFast(null);

					l = (f ? *(r + 2) : *(r + 0)) >> 2;
				}
				else if (g != 0) {
					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));
					uint j = *(r + 2) >> 2;
					for (uint k = 0; k < j; k++) {
						uint t = (z ^ (*q++)) + x + c * v;
						z = x;
						x = c;
						x = v;
						v = t;
					}

				}
				r += 8;
			}

			uint[] y = new uint[0x10], d = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				y[i] = v;
				d[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);

				CheckRemoteDebuggerPresent(Process.GetCurrentProcess().Handle, ref isDebuggerPresent);
				if (isDebuggerPresent) Environment.FailFast(null);

				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			Mutation.Crypt(y, d);

			uint w = 0x40;
			VirtualProtect((IntPtr)e, l << 2, w, out w);

			if (w == 0x40)
				return;

			uint h = 0;
			for (uint i = 0; i < l; i++) {
				*e ^= y[h & 0xf];
				y[h & 0xf] = (y[h & 0xf] ^ (*e++)) + 0x3dbb2819;

				CheckRemoteDebuggerPresent(Process.GetCurrentProcess().Handle, ref isDebuggerPresent);
				if (isDebuggerPresent) Environment.FailFast(null);

				h++;
			}
		}
	}
}

```

`Confuser.Runtime/AntiTamper.JIT.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Confuser.Runtime {
	internal static unsafe class AntiTamperJIT {
		static uint* ptr;
		static uint len;
		static IntPtr moduleHnd;
		static compileMethod originalDelegate;

		static bool ver4;
		static bool ver5;

		static compileMethod handler;

		public static void Initialize() {
			Module m = typeof(AntiTamperNormal).Module;
			string n = m.FullyQualifiedName;
			bool f = n.Length > 0 && n[0] == '<';
			var b = (byte*)Marshal.GetHINSTANCE(m);
			byte* p = b + *(uint*)(b + 0x3c);
			ushort s = *(ushort*)(p + 0x6);
			ushort o = *(ushort*)(p + 0x14);

			uint* e = null;
			uint l = 0;
			var r = (uint*)(p + 0x18 + o);
			uint z = (uint)Mutation.KeyI1, x = (uint)Mutation.KeyI2, c = (uint)Mutation.KeyI3, v = (uint)Mutation.KeyI4;
			for (int i = 0; i < s; i++) {
				uint g = (*r++) * (*r++);
				if (g == (uint)Mutation.KeyI0) {
					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));
					l = (f ? *(r + 2) : *(r + 0)) >> 2;
				}
				else if (g != 0) {
					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));
					uint j = *(r + 2) >> 2;
					for (uint k = 0; k < j; k++) {
						uint t = (z ^ (*q++)) + x + c * v;
						z = x;
						x = c;
						x = v;
						v = t;
					}
				}
				r += 8;
			}

			uint[] y = new uint[0x10], d = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				y[i] = v;
				d[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);
				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			Mutation.Crypt(y, d);

			uint h = 0;
			uint* u = e;
			VirtualProtect((IntPtr)e, l << 2, 0x40, out z);
			for (uint i = 0; i < l; i++) {
				*e ^= y[h & 0xf];
				y[h & 0xf] = (y[h & 0xf] ^ (*e++)) + 0x3dbb2819;
				h++;
			}

			ptr = u + 4;
			len = *ptr++;

			ver4 = Environment.Version.Major == 4;
			ver5 = ver4 && Environment.Version.Revision > 17020;
			ModuleHandle hnd = m.ModuleHandle;
			var obj = GetFieldValue(hnd, "m_ptr");
			if (obj is IntPtr) {
				moduleHnd = (IntPtr)obj;
			} else if (obj.GetType().ToString() == "System.Reflection.RuntimeModule") {
				moduleHnd = (IntPtr)GetFieldValue(obj, "m_pData");
			} else {
				throw new ApplicationException($"Failed to get pointer for module handle: {hnd.ToString()}");
			}

			Hook();
		}

		static object GetFieldValue(object obj, string fieldName) {
			var field = obj.GetType().GetField(fieldName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (field == null)
				throw new ApplicationException($"Could not get field {obj.GetType()}::{fieldName}");
			return field.GetValue(obj);
		}

		[DllImport("kernel32.dll")]
		static extern IntPtr LoadLibrary(string lib);

		[DllImport("kernel32.dll")]
		static extern IntPtr GetProcAddress(IntPtr lib, string proc);

		[DllImport("kernel32.dll")]
		static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize, uint flNewProtect, out uint lpflOldProtect);

		static void Hook() {
			ulong* ptr = stackalloc ulong[2];
			if (ver4) {
				ptr[0] = 0x642e74696a726c63; //clrjit.d
				ptr[1] = 0x0000000000006c6c; //ll......
			}
			else {
				ptr[0] = 0x74696a726f63736d; //mscorjit
				ptr[1] = 0x000000006c6c642e; //.dll....
			}
			IntPtr jit = LoadLibrary(new string((sbyte*)ptr));
			ptr[0] = 0x000074694a746567; //getJit
			var get = (getJit)Marshal.GetDelegateForFunctionPointer(GetProcAddress(jit, new string((sbyte*)ptr)), typeof(getJit));
			IntPtr hookPosition = *get();
			IntPtr original = *(IntPtr*)hookPosition;

			IntPtr trampoline;
			uint oldPl;
			if (IntPtr.Size == 8) {
				trampoline = Marshal.AllocHGlobal(16);
				var tptr = (ulong*)trampoline;
				tptr[0] = 0xffffffffffffb848;
				tptr[1] = 0x90909090e0ffffff;

				VirtualProtect(trampoline, 12, 0x40, out oldPl);
				Marshal.WriteIntPtr(trampoline, 2, original);
			}
			else {
				trampoline = Marshal.AllocHGlobal(8);
				var tptr = (ulong*)trampoline;
				tptr[0] = 0x90e0ffffffffffb8;

				VirtualProtect(trampoline, 7, 0x40, out oldPl);
				Marshal.WriteIntPtr(trampoline, 1, original);
			}

			originalDelegate = (compileMethod)Marshal.GetDelegateForFunctionPointer(trampoline, typeof(compileMethod));
			handler = HookHandler;

			RuntimeHelpers.PrepareDelegate(originalDelegate);
			RuntimeHelpers.PrepareDelegate(handler);

			VirtualProtect(hookPosition, (uint)IntPtr.Size, 0x40, out oldPl);
			Marshal.WriteIntPtr(hookPosition, Marshal.GetFunctionPointerForDelegate(handler));
			VirtualProtect(hookPosition, (uint)IntPtr.Size, oldPl, out oldPl);
		}

		static void ExtractLocalVars(CORINFO_METHOD_INFO* info, uint len, byte* localVar) {
			void* sigInfo;
			if (ver4) {
				if (IntPtr.Size == 8)
					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;
				else
					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;
			}
			else {
				if (IntPtr.Size == 8)
					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;
				else
					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;
			}

			if (IntPtr.Size == 8)
				((CORINFO_SIG_INFO_x64*)sigInfo)->sig = (IntPtr)localVar;
			else
				((CORINFO_SIG_INFO_x86*)sigInfo)->sig = (IntPtr)localVar;
			localVar++;
			byte b = *localVar;
			ushort numArgs;
			IntPtr args;
			if ((b & 0x80) == 0) {
				numArgs = b;
				args = (IntPtr)(localVar + 1);
			}
			else {
				numArgs = (ushort)(((uint)(b & ~0x80) << 8) | *(localVar + 1));
				args = (IntPtr)(localVar + 2);
			}

			if (IntPtr.Size == 8) {
				var sigInfox64 = (CORINFO_SIG_INFO_x64*)sigInfo;
				sigInfox64->callConv = 0;
				sigInfox64->retType = 1;
				sigInfox64->flags = 1;
				sigInfox64->numArgs = numArgs;
				sigInfox64->args = args;
			}
			else {
				var sigInfox86 = (CORINFO_SIG_INFO_x86*)sigInfo;
				sigInfox86->callConv = 0;
				sigInfox86->retType = 1;
				sigInfox86->flags = 1;
				sigInfox86->numArgs = numArgs;
				sigInfox86->args = args;
			}
		}

		static uint HookHandler(IntPtr self, ICorJitInfo* comp, CORINFO_METHOD_INFO* info, uint flags, byte** nativeEntry, uint* nativeSizeOfCode) {
			if (info != null && info->scope == moduleHnd && info->ILCode[0] == 0x14) {
				uint token;
				if (ver5) {
					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(comp->vfptr[0x64], typeof(getMethodDefFromMethod));
					token = getMethodDef((IntPtr)comp, info->ftn);
				}
				else {
					ICorClassInfo* clsInfo = ICorStaticInfo.ICorClassInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));
					int gmdSlot = 12 + (ver4 ? 2 : 1);
					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(clsInfo->vfptr[gmdSlot], typeof(getMethodDefFromMethod));
					token = getMethodDef((IntPtr)clsInfo, info->ftn);
				}

				uint lo = 0, hi = len;
				uint? offset = null;
				while (hi >= lo) {
					uint mid = lo + ((hi - lo) >> 1);
					uint midTok = *(ptr + (mid << 1));
					if (midTok == token) {
						offset = *(ptr + (mid << 1) + 1);
						break;
					}
					if (midTok < token)
						lo = mid + 1;
					else
						hi = mid - 1;
				}
				if (offset == null)
					return originalDelegate(self, comp, info, flags, nativeEntry, nativeSizeOfCode);

				uint* dataPtr = ptr + (uint)offset;
				uint dataLen = *dataPtr++;
				var newPtr = (uint*)Marshal.AllocHGlobal((int)dataLen << 2);
				try {
					var data = (MethodData*)newPtr;
					uint* copyData = newPtr;

					uint state = token * (uint)Mutation.KeyI0;
					uint counter = state;
					for (uint i = 0; i < dataLen; i++) {
						*copyData = *dataPtr++ ^ state;
						state += (*copyData++) ^ counter;
						counter ^= (state >> 5) | (state << 27);
					}

					info->ILCodeSize = data->ILCodeSize;
					if (ver4) {
						*((uint*)(info + 1) + 0) = data->MaxStack;
						*((uint*)(info + 1) + 1) = data->EHCount;
						*((uint*)(info + 1) + 2) = data->Options;
					}
					else {
						*((ushort*)(info + 1) + 0) = (ushort)data->MaxStack;
						*((ushort*)(info + 1) + 1) = (ushort)data->EHCount;
						*((uint*)(info + 1) + 1) = data->Options;
					}

					var body = (byte*)(data + 1);

					info->ILCode = body;
					body += info->ILCodeSize;

					if (data->LocalVars != 0) {
						ExtractLocalVars(info, data->LocalVars, body);
						body += data->LocalVars;
					}

					var ehPtr = (CORINFO_EH_CLAUSE*)body;

					uint ret;
					if (ver5) {
						CorJitInfoHook hook = CorJitInfoHook.Hook(comp, info->ftn, ehPtr);
						ret = originalDelegate(self, comp, info, flags, nativeEntry, nativeSizeOfCode);
						hook.Dispose();
					}
					else {
						CorMethodInfoHook hook = CorMethodInfoHook.Hook(comp, info->ftn, ehPtr);
						ret = originalDelegate(self, comp, info, flags, nativeEntry, nativeSizeOfCode);
						hook.Dispose();
					}

					return ret;
				}
				finally {
					Marshal.FreeHGlobal((IntPtr)newPtr);
				}
			}
			return originalDelegate(self, comp, info, flags, nativeEntry, nativeSizeOfCode);
		}

		#region JIT internal

		static bool hasLinkInfo;

		[StructLayout(LayoutKind.Sequential, Size = 0x18)]
		struct CORINFO_EH_CLAUSE { }

		[StructLayout(LayoutKind.Sequential, Pack = 1)]
		struct CORINFO_METHOD_INFO {
			public IntPtr ftn;
			public IntPtr scope;
			public byte* ILCode;
			public uint ILCodeSize;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct CORINFO_SIG_INFO_x64 {
			public uint callConv;
			uint pad1;
			public IntPtr retTypeClass;
			public IntPtr retTypeSigClass;
			public byte retType;
			public byte flags;
			public ushort numArgs;
			uint pad2;
			public CORINFO_SIG_INST_x64 sigInst;
			public IntPtr args;
			public IntPtr sig;
			public IntPtr scope;
			public uint token;
			uint pad3;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct CORINFO_SIG_INFO_x86 {
			public uint callConv;
			public IntPtr retTypeClass;
			public IntPtr retTypeSigClass;
			public byte retType;
			public byte flags;
			public ushort numArgs;
			public CORINFO_SIG_INST_x86 sigInst;
			public IntPtr args;
			public IntPtr sig;
			public IntPtr scope;
			public uint token;
		}

		[StructLayout(LayoutKind.Sequential, Size = 32)]
		struct CORINFO_SIG_INST_x64 { }

		[StructLayout(LayoutKind.Sequential, Size = 16)]
		struct CORINFO_SIG_INST_x86 { }

		[StructLayout(LayoutKind.Sequential)]
		struct ICorClassInfo {
			public readonly IntPtr* vfptr;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorDynamicInfo {
			public IntPtr* vfptr;
			public int* vbptr;

			public static ICorStaticInfo* ICorStaticInfo(ICorDynamicInfo* ptr) {
				return (ICorStaticInfo*)((byte*)&ptr->vbptr + ptr->vbptr[hasLinkInfo ? 9 : 8]);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorJitInfo {
			public IntPtr* vfptr;
			public int* vbptr;

			public static ICorDynamicInfo* ICorDynamicInfo(ICorJitInfo* ptr) {
				hasLinkInfo = ptr->vbptr[10] > 0 && ptr->vbptr[10] >> 16 == 0; // != 0 and hiword byte == 0
				return (ICorDynamicInfo*)((byte*)&ptr->vbptr + ptr->vbptr[hasLinkInfo ? 10 : 9]);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorMethodInfo {
			public IntPtr* vfptr;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorModuleInfo {
			public IntPtr* vfptr;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct ICorStaticInfo {
			public IntPtr* vfptr;
			public int* vbptr;

			public static ICorMethodInfo* ICorMethodInfo(ICorStaticInfo* ptr) {
				return (ICorMethodInfo*)((byte*)&ptr->vbptr + ptr->vbptr[1]);
			}

			public static ICorModuleInfo* ICorModuleInfo(ICorStaticInfo* ptr) {
				return (ICorModuleInfo*)((byte*)&ptr->vbptr + ptr->vbptr[2]);
			}

			public static ICorClassInfo* ICorClassInfo(ICorStaticInfo* ptr) {
				return (ICorClassInfo*)((byte*)&ptr->vbptr + ptr->vbptr[3]);
			}
		}

		#endregion

		class CorMethodInfoHook {
			static int ehNum = -1;
			public CORINFO_EH_CLAUSE* clauses;
			public IntPtr ftn;
			public ICorMethodInfo* info;
			public getEHinfo n_getEHinfo;
			public IntPtr* newVfTbl;

			public getEHinfo o_getEHinfo;
			public IntPtr* oldVfTbl;

			void hookEHInfo(IntPtr self, IntPtr ftn, uint EHnumber, CORINFO_EH_CLAUSE* clause) {
				if (ftn == this.ftn) {
					*clause = clauses[EHnumber];
				}
				else {
					o_getEHinfo(self, ftn, EHnumber, clause);
				}
			}

			public void Dispose() {
				Marshal.FreeHGlobal((IntPtr)newVfTbl);
				info->vfptr = oldVfTbl;
			}

			public static CorMethodInfoHook Hook(ICorJitInfo* comp, IntPtr ftn, CORINFO_EH_CLAUSE* clauses) {
				ICorMethodInfo* mtdInfo = ICorStaticInfo.ICorMethodInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));
				IntPtr* vfTbl = mtdInfo->vfptr;
				const int SLOT_NUM = 0x1B;
				var newVfTbl = (IntPtr*)Marshal.AllocHGlobal(SLOT_NUM * IntPtr.Size);
				for (int i = 0; i < SLOT_NUM; i++)
					newVfTbl[i] = vfTbl[i];
				if (ehNum == -1)
					for (int i = 0; i < SLOT_NUM; i++) {
						bool isEh = true;
						for (var func = (byte*)vfTbl[i]; *func != 0xe9; func++)
							if (IntPtr.Size == 8 ?
								  (*func == 0x48 && *(func + 1) == 0x81 && *(func + 2) == 0xe9) :
								  (*func == 0x83 && *(func + 1) == 0xe9)) {
								isEh = false;
								break;
							}
						if (isEh) {
							ehNum = i;
							break;
						}
					}

				var ret = new CorMethodInfoHook {
					ftn = ftn,
					info = mtdInfo,
					clauses = clauses,
					newVfTbl = newVfTbl,
					oldVfTbl = vfTbl
				};

				ret.n_getEHinfo = ret.hookEHInfo;
				ret.o_getEHinfo = (getEHinfo)Marshal.GetDelegateForFunctionPointer(vfTbl[ehNum], typeof(getEHinfo));
				newVfTbl[ehNum] = Marshal.GetFunctionPointerForDelegate(ret.n_getEHinfo);

				mtdInfo->vfptr = newVfTbl;
				return ret;
			}
		}

		class CorJitInfoHook {
			public CORINFO_EH_CLAUSE* clauses;
			public IntPtr ftn;
			public ICorJitInfo* info;
			public getEHinfo n_getEHinfo;
			public IntPtr* newVfTbl;

			public getEHinfo o_getEHinfo;
			public IntPtr* oldVfTbl;

			void hookEHInfo(IntPtr self, IntPtr ftn, uint EHnumber, CORINFO_EH_CLAUSE* clause) {
				if (ftn == this.ftn) {
					*clause = clauses[EHnumber];
				}
				else {
					o_getEHinfo(self, ftn, EHnumber, clause);
				}
			}

			public void Dispose() {
				Marshal.FreeHGlobal((IntPtr)newVfTbl);
				info->vfptr = oldVfTbl;
			}

			public static CorJitInfoHook Hook(ICorJitInfo* comp, IntPtr ftn, CORINFO_EH_CLAUSE* clauses) {
				const int slotNum = 8;

				IntPtr* vfTbl = comp->vfptr;
				const int SLOT_NUM = 0x9E;
				var newVfTbl = (IntPtr*)Marshal.AllocHGlobal(SLOT_NUM * IntPtr.Size);
				for (int i = 0; i < SLOT_NUM; i++)
					newVfTbl[i] = vfTbl[i];

				var ret = new CorJitInfoHook {
					ftn = ftn,
					info = comp,
					clauses = clauses,
					newVfTbl = newVfTbl,
					oldVfTbl = vfTbl
				};

				ret.n_getEHinfo = ret.hookEHInfo;
				ret.o_getEHinfo = (getEHinfo)Marshal.GetDelegateForFunctionPointer(vfTbl[slotNum], typeof(getEHinfo));
				newVfTbl[slotNum] = Marshal.GetFunctionPointerForDelegate(ret.n_getEHinfo);

				comp->vfptr = newVfTbl;
				return ret;
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		struct MethodData {
			public readonly uint ILCodeSize;
			public readonly uint MaxStack;
			public readonly uint EHCount;
			public readonly uint LocalVars;
			public readonly uint Options;
			public readonly uint MulSeed;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		delegate uint compileMethod(IntPtr self, ICorJitInfo* comp, CORINFO_METHOD_INFO* info, uint flags, byte** nativeEntry, uint* nativeSizeOfCode);

		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		delegate void getEHinfo(IntPtr self, IntPtr ftn, uint EHnumber, CORINFO_EH_CLAUSE* clause);

		delegate IntPtr* getJit();

		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		delegate uint getMethodDefFromMethod(IntPtr self, IntPtr ftn);
	}
}

```

`Confuser.Runtime/AntiTamper.Normal.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace Confuser.Runtime {
	internal static class AntiTamperNormal {
		[DllImport("kernel32.dll")]
		static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize, uint flNewProtect, out uint lpflOldProtect);

		static unsafe void Initialize() {
			Module m = typeof(AntiTamperNormal).Module;
			string n = m.FullyQualifiedName;
			bool f = n.Length > 0 && n[0] == '<';
			var b = (byte*)Marshal.GetHINSTANCE(m);
			byte* p = b + *(uint*)(b + 0x3c);
			ushort s = *(ushort*)(p + 0x6);
			ushort o = *(ushort*)(p + 0x14);

			uint* e = null;
			uint l = 0;
			var r = (uint*)(p + 0x18 + o);
			uint z = (uint)Mutation.KeyI1, x = (uint)Mutation.KeyI2, c = (uint)Mutation.KeyI3, v = (uint)Mutation.KeyI4;
			for (int i = 0; i < s; i++) {
				uint g = (*r++) * (*r++);
				if (g == (uint)Mutation.KeyI0) {
					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));
					l = (f ? *(r + 2) : *(r + 0)) >> 2;
				}
				else if (g != 0) {
					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));
					uint j = *(r + 2) >> 2;
					for (uint k = 0; k < j; k++) {
						uint t = (z ^ (*q++)) + x + c * v;
						z = x;
						x = c;
						x = v;
						v = t;
					}
				}
				r += 8;
			}

			uint[] y = new uint[0x10], d = new uint[0x10];
			for (int i = 0; i < 0x10; i++) {
				y[i] = v;
				d[i] = x;
				z = (x >> 5) | (x << 27);
				x = (c >> 3) | (c << 29);
				c = (v >> 7) | (v << 25);
				v = (z >> 11) | (z << 21);
			}
			Mutation.Crypt(y, d);

			uint w = 0x40;
			VirtualProtect((IntPtr)e, l << 2, w, out w);

			if (w == 0x40)
				return;

			uint h = 0;
			for (uint i = 0; i < l; i++) {
				*e ^= y[h & 0xf];
				y[h & 0xf] = (y[h & 0xf] ^ (*e++)) + 0x3dbb2819;
				h++;
			}
		}
	}
}

```

`Confuser.Runtime/Compressor.Compat.cs`:

```cs
using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace Confuser.Runtime {
	internal static class CompressorCompat {
		static byte[] key;

		static GCHandle Decrypt(uint[] data, uint seed) {
			var w = new uint[0x10];
			var k = new uint[0x10];
			ulong s = seed;
			for (int i = 0; i < 0x10; i++) {
				s = (s * s) % 0x143fc089;
				k[i] = (uint)s;
				w[i] = (uint)((s * s) % 0x444d56fb);
			}
			Mutation.Crypt(w, k);
			Array.Clear(k, 0, 0x10);

			var b = new byte[data.Length << 2];
			uint h = 0;
			for (int i = 0; i < data.Length; i++) {
				uint d = data[i] ^ w[i & 0xf];
				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;
				b[h + 0] = (byte)(d >> 0);
				b[h + 1] = (byte)(d >> 8);
				b[h + 2] = (byte)(d >> 16);
				b[h + 3] = (byte)(d >> 24);
				h += 4;
			}
			Array.Clear(w, 0, 0x10);
			byte[] j = Lzma.Decompress(b);
			Array.Clear(b, 0, b.Length);

			GCHandle g = GCHandle.Alloc(j, GCHandleType.Pinned);
			var z = (uint)(s % 0x8a5cb7);
			for (int i = 0; i < j.Length; i++) {
				j[i] ^= (byte)s;
				if ((i & 0xff) == 0)
					s = (s * s) % 0x8a5cb7;
			}
			return g;
		}

		[STAThread]
		static int Main(string[] args) {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			GCHandle h = Decrypt(q, (uint)Mutation.KeyI1);
			var b = (byte[])h.Target;
			Assembly a = Assembly.Load(b);
			Array.Clear(b, 0, b.Length);
			h.Free();
			Array.Clear(q, 0, q.Length);

			var m = typeof(CompressorCompat).Module;
			key = m.ResolveSignature(Mutation.KeyI2);
			AppDomain.CurrentDomain.AssemblyResolve += Resolve;

			MethodBase e = a.ManifestModule.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
			var g = new object[e.GetParameters().Length];
			if (g.Length != 0)
				g[0] = args;
			object r = e.Invoke(null, g);
			if (r is int)
				return (int)r;
			return 0;
		}

		static Assembly Resolve(object sender, ResolveEventArgs e) {
			byte[] b = Encoding.UTF8.GetBytes(new AssemblyName(e.Name).FullName.ToUpperInvariant());

			Stream m = null;
			if (b.Length + 4 <= key.Length) {
				for (int i = 0; i < b.Length; i++)
					b[i] *= key[i + 4];
				string n = Convert.ToBase64String(b);
				m = Assembly.GetEntryAssembly().GetManifestResourceStream(n);
			}
			if (m != null) {
				var d = new uint[m.Length >> 2];
				var t = new byte[0x100];
				int r;
				int o = 0;
				while ((r = m.Read(t, 0, 0x100)) > 0) {
					Buffer.BlockCopy(t, 0, d, o, r);
					o += r;
				}
				uint s = 0x6fff61;
				foreach (byte c in b)
					s = s * 0x5e3f1f + c;
				GCHandle h = Decrypt(d, s);

				var f = (byte[])h.Target;
				Assembly a = Assembly.Load(f);
				Array.Clear(f, 0, f.Length);
				h.Free();
				Array.Clear(d, 0, d.Length);

				return a;
			}
			return null;
		}
	}
}

```

`Confuser.Runtime/Compressor.cs`:

```cs
using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace Confuser.Runtime {
	internal static class Compressor {
		static byte[] key;

		static GCHandle Decrypt(uint[] data, uint seed) {
			var w = new uint[0x10];
			var k = new uint[0x10];
			ulong s = seed;
			for (int i = 0; i < 0x10; i++) {
				s = (s * s) % 0x143fc089;
				k[i] = (uint)s;
				w[i] = (uint)((s * s) % 0x444d56fb);
			}
			Mutation.Crypt(w, k);
			Array.Clear(k, 0, 0x10);

			var b = new byte[data.Length << 2];
			uint h = 0;
			for (int i = 0; i < data.Length; i++) {
				uint d = data[i] ^ w[i & 0xf];
				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;
				b[h + 0] = (byte)(d >> 0);
				b[h + 1] = (byte)(d >> 8);
				b[h + 2] = (byte)(d >> 16);
				b[h + 3] = (byte)(d >> 24);
				h += 4;
			}
			Array.Clear(w, 0, 0x10);
			byte[] j = Lzma.Decompress(b);
			Array.Clear(b, 0, b.Length);

			GCHandle g = GCHandle.Alloc(j, GCHandleType.Pinned);
			var z = (uint)(s % 0x8a5cb7);
			for (int i = 0; i < j.Length; i++) {
				j[i] ^= (byte)s;
				if ((i & 0xff) == 0)
					s = (s * s) % 0x8a5cb7;
			}
			return g;
		}

		[STAThread]
		static int Main(string[] args) {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			Assembly a = Assembly.GetExecutingAssembly();
			Module n = a.ManifestModule;
			GCHandle h = Decrypt(q, (uint)Mutation.KeyI1);
			var b = (byte[])h.Target;
			Module m = a.LoadModule("koi", b);

			Array.Clear(b, 0, b.Length);
			h.Free();
			Array.Clear(q, 0, q.Length);

			key = n.ResolveSignature(Mutation.KeyI2);
			AppDomain.CurrentDomain.AssemblyResolve += Resolve;

			// For some reasons, reflection on Assembly would not discover the types unless GetTypes is called.
			m.GetTypes();

			MethodBase e = m.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
			var g = new object[e.GetParameters().Length];
			if (g.Length != 0)
				g[0] = args;
			object r = e.Invoke(null, g);
			if (r is int)
				return (int)r;
			return 0;
		}

		static Assembly Resolve(object sender, ResolveEventArgs e) {
			byte[] b = Encoding.UTF8.GetBytes(new AssemblyName(e.Name).FullName.ToUpperInvariant());

			Stream m = null;
			if (b.Length + 4 <= key.Length) {
				for (int i = 0; i < b.Length; i++)
					b[i] *= key[i + 4];
				string n = Convert.ToBase64String(b);
				m = Assembly.GetEntryAssembly().GetManifestResourceStream(n);
			}
			if (m != null) {
				var d = new uint[m.Length >> 2];
				var t = new byte[0x100];
				int r;
				int o = 0;
				while ((r = m.Read(t, 0, 0x100)) > 0) {
					Buffer.BlockCopy(t, 0, d, o, r);
					o += r;
				}
				uint s = 0x6fff61;
				foreach (byte c in b)
					s = s * 0x5e3f1f + c;
				GCHandle h = Decrypt(d, s);

				var f = (byte[])h.Target;
				Assembly a = Assembly.Load(f);
				Array.Clear(f, 0, f.Length);
				h.Free();
				Array.Clear(d, 0, d.Length);

				return a;
			}
			return null;
		}
	}
}

```

`Confuser.Runtime/Confuser.Runtime.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\ConfuserEx.Common.props" Condition="Exists('..\ConfuserEx.Common.props')" />

  <PropertyGroup Label="Assembly Settings">
    <TargetFrameworks>net20</TargetFrameworks>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>

  <PropertyGroup Label="Assembly Information">
    <Title>ConfuserEx Runtime</Title>
    <Description>Runtime library of ConfuserEx</Description>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <Import Project="..\ConfuserEx.Common.targets" Condition="Exists('..\ConfuserEx.Common.targets')" />

</Project>
```

`Confuser.Runtime/Constant.cs`:

```cs
using System;
using System.Reflection;
using System.Text;

namespace Confuser.Runtime {
	internal static class Constant {
		static byte[] b;

		static void Initialize() {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			var k = new uint[0x10];
			var n = (uint)Mutation.KeyI1;
			for (int i = 0; i < 0x10; i++) {
				n ^= n >> 12;
				n ^= n << 25;
				n ^= n >> 27;
				k[i] = n;
			}

			int s = 0, d = 0;
			var w = new uint[0x10];
			var o = new byte[l * 4];
			while (s < l) {
				for (int j = 0; j < 0x10; j++)
					w[j] = q[s + j];
				Mutation.Crypt(w, k);
				for (int j = 0; j < 0x10; j++) {
					uint e = w[j];
					o[d++] = (byte)e;
					o[d++] = (byte)(e >> 8);
					o[d++] = (byte)(e >> 16);
					o[d++] = (byte)(e >> 24);
					k[j] ^= e;
				}
				s += 0x10;
			}

			b = Lzma.Decompress(o);
		}

		static T Get<T>(int id) {
			// op_equality is not available on .NET Framework 2.0 and older. To ensure compatibility,
			// we'll be using equals.
			if (Assembly.GetExecutingAssembly().Equals(Assembly.GetCallingAssembly())) {
				id = Mutation.Placeholder(id);
				int t = (int)((uint)id >> 30);

				T ret;
				id = (id & 0x3fffffff) << 2;

				if (t == Mutation.KeyI0) {
					int l = b[id] | (b[id+1] << 8) | (b[id+2] << 16) | (b[id+3] << 24);
					ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b, id+4, l));
				}
				// NOTE: Assume little-endian
				else if (t == Mutation.KeyI1) {
					var v = new T[1];
					Buffer.BlockCopy(b, id, v, 0, Mutation.Value<int>());
					ret = v[0];
				}
				else if (t == Mutation.KeyI2) {
					int s = b[id] | (b[id+1] << 8) | (b[id+2] << 16) | (b[id+3] << 24);
					int l = b[id+4] | (b[id+5] << 8) | (b[id+6] << 16) | (b[id+7] << 24);
					Array v = Array.CreateInstance(typeof(T).GetElementType(), l);
					Buffer.BlockCopy(b, id+8, v, 0, s - 4);
					ret = (T)(object)v;
				}
				else
					ret = default(T);

				return ret;
			}
			return default(T);
		}
	}

	internal struct CFGCtx {
		uint A;
		uint B;
		uint C;
		uint D;

		public CFGCtx(uint seed) {
			A = seed *= 0x21412321;
			B = seed *= 0x21412321;
			C = seed *= 0x21412321;
			D = seed *= 0x21412321;
		}

		public uint Next(byte f, uint q) {
			if ((f & 0x80) != 0) {
				switch (f & 0x3) {
					case 0:
						A = q;
						break;
					case 1:
						B = q;
						break;
					case 2:
						C = q;
						break;
					case 3:
						D = q;
						break;
				}
			}
			else {
				switch (f & 0x3) {
					case 0:
						A ^= q;
						break;
					case 1:
						B += q;
						break;
					case 2:
						C ^= q;
						break;
					case 3:
						D -= q;
						break;
				}
			}

			switch ((f >> 2) & 0x3) {
				case 0:
					return A;
				case 1:
					return B;
				case 2:
					return C;
			}
			return D;
		}
	}
}

```

`Confuser.Runtime/ExcludeFromCodeCoverageAttribute.cs`:

```cs
#if NETFRAMEWORK && (NET20 || NET35)
// ReSharper disable once CheckNamespace
namespace System.Diagnostics.CodeAnalysis {
	internal sealed class ExcludeFromCodeCoverageAttribute : Attribute {
	}
}
#endif

```

`Confuser.Runtime/Lzma.cs`:

```cs
using System;
using System.IO;

namespace Confuser.Runtime {
	internal static class Lzma {
		const uint kNumStates = 12;

		const int kNumPosSlotBits = 6;

		const uint kNumLenToPosStates = 4;

		const uint kMatchMinLen = 2;

		const int kNumAlignBits = 4;
		const uint kAlignTableSize = 1 << kNumAlignBits;

		const uint kStartPosModelIndex = 4;
		const uint kEndPosModelIndex = 14;

		const uint kNumFullDistances = 1 << ((int)kEndPosModelIndex / 2);

		const int kNumPosStatesBitsMax = 4;
		const uint kNumPosStatesMax = (1 << kNumPosStatesBitsMax);

		const int kNumLowLenBits = 3;
		const int kNumMidLenBits = 3;
		const int kNumHighLenBits = 8;
		const uint kNumLowLenSymbols = 1 << kNumLowLenBits;
		const uint kNumMidLenSymbols = 1 << kNumMidLenBits;

		public static byte[] Decompress(byte[] data) {
			var s = new MemoryStream(data);
			var decoder = new LzmaDecoder();
			var prop = new byte[5];
			var readCnt = 0;
			while (readCnt < 5) {
				readCnt += s.Read(prop, readCnt, 5 - readCnt);
			}
			decoder.SetDecoderProperties(prop);

			readCnt = 0;
			while (readCnt < sizeof(int)) {
				readCnt += s.Read(prop, readCnt, sizeof(int) - readCnt);
			}
			if (!BitConverter.IsLittleEndian)
				Array.Reverse(prop, 0, sizeof(int));
			var outSize = BitConverter.ToInt32(prop, 0);
			var b = new byte[outSize];
			var z = new MemoryStream(b, true);
			long compressedSize = s.Length - 5 - sizeof(int);
			decoder.Code(s, z, compressedSize, outSize);
			return b;
		}

		struct BitDecoder {
			public const int kNumBitModelTotalBits = 11;
			public const uint kBitModelTotal = (1 << kNumBitModelTotalBits);
			const int kNumMoveBits = 5;

			uint Prob;

			public void Init() {
				Prob = kBitModelTotal >> 1;
			}

			public uint Decode(Decoder rangeDecoder) {
				uint newBound = (rangeDecoder.Range >> kNumBitModelTotalBits) * Prob;
				if (rangeDecoder.Code < newBound) {
					rangeDecoder.Range = newBound;
					Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
					if (rangeDecoder.Range < Decoder.kTopValue) {
						rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
						rangeDecoder.Range <<= 8;
					}
					return 0;
				}
				rangeDecoder.Range -= newBound;
				rangeDecoder.Code -= newBound;
				Prob -= (Prob) >> kNumMoveBits;
				if (rangeDecoder.Range < Decoder.kTopValue) {
					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
					rangeDecoder.Range <<= 8;
				}
				return 1;
			}
		}

		struct BitTreeDecoder {
			readonly BitDecoder[] Models;
			readonly int NumBitLevels;

			public BitTreeDecoder(int numBitLevels) {
				NumBitLevels = numBitLevels;
				Models = new BitDecoder[1 << numBitLevels];
			}

			public void Init() {
				for (uint i = 1; i < (1 << NumBitLevels); i++)
					Models[i].Init();
			}

			public uint Decode(Decoder rangeDecoder) {
				uint m = 1;
				for (int bitIndex = NumBitLevels; bitIndex > 0; bitIndex--)
					m = (m << 1) + Models[m].Decode(rangeDecoder);
				return m - ((uint)1 << NumBitLevels);
			}

			public uint ReverseDecode(Decoder rangeDecoder) {
				uint m = 1;
				uint symbol = 0;
				for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++) {
					uint bit = Models[m].Decode(rangeDecoder);
					m <<= 1;
					m += bit;
					symbol |= (bit << bitIndex);
				}
				return symbol;
			}

			public static uint ReverseDecode(BitDecoder[] Models, UInt32 startIndex,
			                                 Decoder rangeDecoder, int NumBitLevels) {
				uint m = 1;
				uint symbol = 0;
				for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++) {
					uint bit = Models[startIndex + m].Decode(rangeDecoder);
					m <<= 1;
					m += bit;
					symbol |= (bit << bitIndex);
				}
				return symbol;
			}
		}

		class Decoder {
			public const uint kTopValue = (1 << 24);
			public uint Code;
			public uint Range;
			public Stream Stream;

			public void Init(Stream stream) {
				// Stream.Init(stream);
				Stream = stream;

				Code = 0;
				Range = 0xFFFFFFFF;
				for (int i = 0; i < 5; i++)
					Code = (Code << 8) | (byte)Stream.ReadByte();
			}

			public void ReleaseStream() {
				Stream = null;
			}

			public void Normalize() {
				while (Range < kTopValue) {
					Code = (Code << 8) | (byte)Stream.ReadByte();
					Range <<= 8;
				}
			}

			public uint DecodeDirectBits(int numTotalBits) {
				uint range = Range;
				uint code = Code;
				uint result = 0;
				for (int i = numTotalBits; i > 0; i--) {
					range >>= 1;
					/*
                    result <<= 1;
                    if (code >= range)
                    {
                        code -= range;
                        result |= 1;
                    }
                    */
					uint t = (code - range) >> 31;
					code -= range & (t - 1);
					result = (result << 1) | (1 - t);

					if (range < kTopValue) {
						code = (code << 8) | (byte)Stream.ReadByte();
						range <<= 8;
					}
				}
				Range = range;
				Code = code;
				return result;
			}
		}

		class LzmaDecoder {
			readonly BitDecoder[] m_IsMatchDecoders = new BitDecoder[kNumStates << kNumPosStatesBitsMax];
			readonly BitDecoder[] m_IsRep0LongDecoders = new BitDecoder[kNumStates << kNumPosStatesBitsMax];
			readonly BitDecoder[] m_IsRepDecoders = new BitDecoder[kNumStates];
			readonly BitDecoder[] m_IsRepG0Decoders = new BitDecoder[kNumStates];
			readonly BitDecoder[] m_IsRepG1Decoders = new BitDecoder[kNumStates];
			readonly BitDecoder[] m_IsRepG2Decoders = new BitDecoder[kNumStates];

			readonly LenDecoder m_LenDecoder = new LenDecoder();

			readonly LiteralDecoder m_LiteralDecoder = new LiteralDecoder();
			readonly OutWindow m_OutWindow = new OutWindow();
			readonly BitDecoder[] m_PosDecoders = new BitDecoder[kNumFullDistances - kEndPosModelIndex];
			readonly BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[kNumLenToPosStates];
			readonly Decoder m_RangeDecoder = new Decoder();
			readonly LenDecoder m_RepLenDecoder = new LenDecoder();
			bool _solid = false;

			uint m_DictionarySize;
			uint m_DictionarySizeCheck;
			BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(kNumAlignBits);

			uint m_PosStateMask;

			public LzmaDecoder() {
				m_DictionarySize = 0xFFFFFFFF;
				for (int i = 0; i < kNumLenToPosStates; i++)
					m_PosSlotDecoder[i] = new BitTreeDecoder(kNumPosSlotBits);
			}

			void SetDictionarySize(uint dictionarySize) {
				if (m_DictionarySize != dictionarySize) {
					m_DictionarySize = dictionarySize;
					m_DictionarySizeCheck = Math.Max(m_DictionarySize, 1);
					uint blockSize = Math.Max(m_DictionarySizeCheck, (1 << 12));
					m_OutWindow.Create(blockSize);
				}
			}

			void SetLiteralProperties(int lp, int lc) {
				m_LiteralDecoder.Create(lp, lc);
			}

			void SetPosBitsProperties(int pb) {
				uint numPosStates = (uint)1 << pb;
				m_LenDecoder.Create(numPosStates);
				m_RepLenDecoder.Create(numPosStates);
				m_PosStateMask = numPosStates - 1;
			}

			void Init(Stream inStream, Stream outStream) {
				m_RangeDecoder.Init(inStream);
				m_OutWindow.Init(outStream, _solid);

				uint i;
				for (i = 0; i < kNumStates; i++) {
					for (uint j = 0; j <= m_PosStateMask; j++) {
						uint index = (i << kNumPosStatesBitsMax) + j;
						m_IsMatchDecoders[index].Init();
						m_IsRep0LongDecoders[index].Init();
					}
					m_IsRepDecoders[i].Init();
					m_IsRepG0Decoders[i].Init();
					m_IsRepG1Decoders[i].Init();
					m_IsRepG2Decoders[i].Init();
				}

				m_LiteralDecoder.Init();
				for (i = 0; i < kNumLenToPosStates; i++)
					m_PosSlotDecoder[i].Init();
				// m_PosSpecDecoder.Init();
				for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
					m_PosDecoders[i].Init();

				m_LenDecoder.Init();
				m_RepLenDecoder.Init();
				m_PosAlignDecoder.Init();
			}

			public void Code(Stream inStream, Stream outStream,
			                 Int64 inSize, Int64 outSize) {
				Init(inStream, outStream);

				var state = new State();
				state.Init();
				uint rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0;

				UInt64 nowPos64 = 0;
				var outSize64 = (UInt64)outSize;
				if (nowPos64 < outSize64) {
					m_IsMatchDecoders[state.Index << kNumPosStatesBitsMax].Decode(m_RangeDecoder);
					state.UpdateChar();
					byte b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, 0, 0);
					m_OutWindow.PutByte(b);
					nowPos64++;
				}
				while (nowPos64 < outSize64) {
					// UInt64 next = Math.Min(nowPos64 + (1 << 18), outSize64);
					// while(nowPos64 < next)
					{
						uint posState = (uint)nowPos64 & m_PosStateMask;
						if (m_IsMatchDecoders[(state.Index << kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {
							byte b;
							byte prevByte = m_OutWindow.GetByte(0);
							if (!state.IsCharState())
								b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder,
								                                         (uint)nowPos64, prevByte, m_OutWindow.GetByte(rep0));
							else
								b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, (uint)nowPos64, prevByte);
							m_OutWindow.PutByte(b);
							state.UpdateChar();
							nowPos64++;
						}
						else {
							uint len;
							if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1) {
								if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0) {
									if (m_IsRep0LongDecoders[(state.Index << kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {
										state.UpdateShortRep();
										m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));
										nowPos64++;
										continue;
									}
								}
								else {
									UInt32 distance;
									if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0) {
										distance = rep1;
									}
									else {
										if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)
											distance = rep2;
										else {
											distance = rep3;
											rep3 = rep2;
										}
										rep2 = rep1;
									}
									rep1 = rep0;
									rep0 = distance;
								}
								len = m_RepLenDecoder.Decode(m_RangeDecoder, posState) + kMatchMinLen;
								state.UpdateRep();
							}
							else {
								rep3 = rep2;
								rep2 = rep1;
								rep1 = rep0;
								len = kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder, posState);
								state.UpdateMatch();
								uint posSlot = m_PosSlotDecoder[GetLenToPosState(len)].Decode(m_RangeDecoder);
								if (posSlot >= kStartPosModelIndex) {
									var numDirectBits = (int)((posSlot >> 1) - 1);
									rep0 = ((2 | (posSlot & 1)) << numDirectBits);
									if (posSlot < kEndPosModelIndex)
										rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders,
										                                     rep0 - posSlot - 1, m_RangeDecoder, numDirectBits);
									else {
										rep0 += (m_RangeDecoder.DecodeDirectBits(
											numDirectBits - kNumAlignBits) << kNumAlignBits);
										rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);
									}
								}
								else
									rep0 = posSlot;
							}
							if (rep0 >= nowPos64 || rep0 >= m_DictionarySizeCheck) {
								if (rep0 == 0xFFFFFFFF)
									break;
							}
							m_OutWindow.CopyBlock(rep0, len);
							nowPos64 += len;
						}
					}
				}
				m_OutWindow.Flush();
				m_OutWindow.ReleaseStream();
				m_RangeDecoder.ReleaseStream();
			}

			public void SetDecoderProperties(byte[] properties) {
				int lc = properties[0] % 9;
				int remainder = properties[0] / 9;
				int lp = remainder % 5;
				int pb = remainder / 5;
				UInt32 dictionarySize = 0;
				for (int i = 0; i < 4; i++)
					dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
				SetDictionarySize(dictionarySize);
				SetLiteralProperties(lp, lc);
				SetPosBitsProperties(pb);
			}

			static uint GetLenToPosState(uint len) {
				len -= kMatchMinLen;
				if (len < kNumLenToPosStates)
					return len;
				return unchecked((kNumLenToPosStates - 1));
			}

			class LenDecoder {
				readonly BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[kNumPosStatesMax];
				readonly BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[kNumPosStatesMax];
				BitDecoder m_Choice = new BitDecoder();
				BitDecoder m_Choice2 = new BitDecoder();
				BitTreeDecoder m_HighCoder = new BitTreeDecoder(kNumHighLenBits);
				uint m_NumPosStates;

				public void Create(uint numPosStates) {
					for (uint posState = m_NumPosStates; posState < numPosStates; posState++) {
						m_LowCoder[posState] = new BitTreeDecoder(kNumLowLenBits);
						m_MidCoder[posState] = new BitTreeDecoder(kNumMidLenBits);
					}
					m_NumPosStates = numPosStates;
				}

				public void Init() {
					m_Choice.Init();
					for (uint posState = 0; posState < m_NumPosStates; posState++) {
						m_LowCoder[posState].Init();
						m_MidCoder[posState].Init();
					}
					m_Choice2.Init();
					m_HighCoder.Init();
				}

				public uint Decode(Decoder rangeDecoder, uint posState) {
					if (m_Choice.Decode(rangeDecoder) == 0)
						return m_LowCoder[posState].Decode(rangeDecoder);
					uint symbol = kNumLowLenSymbols;
					if (m_Choice2.Decode(rangeDecoder) == 0)
						symbol += m_MidCoder[posState].Decode(rangeDecoder);
					else {
						symbol += kNumMidLenSymbols;
						symbol += m_HighCoder.Decode(rangeDecoder);
					}
					return symbol;
				}
			}

			class LiteralDecoder {
				Decoder2[] m_Coders;
				int m_NumPosBits;
				int m_NumPrevBits;
				uint m_PosMask;

				public void Create(int numPosBits, int numPrevBits) {
					if (m_Coders != null && m_NumPrevBits == numPrevBits &&
					    m_NumPosBits == numPosBits)
						return;
					m_NumPosBits = numPosBits;
					m_PosMask = ((uint)1 << numPosBits) - 1;
					m_NumPrevBits = numPrevBits;
					uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
					m_Coders = new Decoder2[numStates];
					for (uint i = 0; i < numStates; i++)
						m_Coders[i].Create();
				}

				public void Init() {
					uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
					for (uint i = 0; i < numStates; i++)
						m_Coders[i].Init();
				}

				uint GetState(uint pos, byte prevByte) {
					return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
				}

				public byte DecodeNormal(Decoder rangeDecoder, uint pos, byte prevByte) {
					return m_Coders[GetState(pos, prevByte)].DecodeNormal(rangeDecoder);
				}

				public byte DecodeWithMatchByte(Decoder rangeDecoder, uint pos, byte prevByte, byte matchByte) {
					return m_Coders[GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte);
				}

				struct Decoder2 {
					BitDecoder[] m_Decoders;

					public void Create() {
						m_Decoders = new BitDecoder[0x300];
					}

					public void Init() {
						for (int i = 0; i < 0x300; i++) m_Decoders[i].Init();
					}

					public byte DecodeNormal(Decoder rangeDecoder) {
						uint symbol = 1;
						do
							symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder); while (symbol < 0x100);
						return (byte)symbol;
					}

					public byte DecodeWithMatchByte(Decoder rangeDecoder, byte matchByte) {
						uint symbol = 1;
						do {
							uint matchBit = (uint)(matchByte >> 7) & 1;
							matchByte <<= 1;
							uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
							symbol = (symbol << 1) | bit;
							if (matchBit != bit) {
								while (symbol < 0x100)
									symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);
								break;
							}
						} while (symbol < 0x100);
						return (byte)symbol;
					}
				}
			};
		}

		class OutWindow {
			byte[] _buffer;
			uint _pos;
			Stream _stream;
			uint _streamPos;
			uint _windowSize;

			public void Create(uint windowSize) {
				if (_windowSize != windowSize) {
					_buffer = new byte[windowSize];
				}
				_windowSize = windowSize;
				_pos = 0;
				_streamPos = 0;
			}

			public void Init(Stream stream, bool solid) {
				ReleaseStream();
				_stream = stream;
				if (!solid) {
					_streamPos = 0;
					_pos = 0;
				}
			}

			public void ReleaseStream() {
				Flush();
				_stream = null;
				Buffer.BlockCopy(new byte[_buffer.Length], 0, _buffer, 0, _buffer.Length);
			}

			public void Flush() {
				uint size = _pos - _streamPos;
				if (size == 0)
					return;
				_stream.Write(_buffer, (int)_streamPos, (int)size);
				if (_pos >= _windowSize)
					_pos = 0;
				_streamPos = _pos;
			}

			public void CopyBlock(uint distance, uint len) {
				uint pos = _pos - distance - 1;
				if (pos >= _windowSize)
					pos += _windowSize;
				for (; len > 0; len--) {
					if (pos >= _windowSize)
						pos = 0;
					_buffer[_pos++] = _buffer[pos++];
					if (_pos >= _windowSize)
						Flush();
				}
			}

			public void PutByte(byte b) {
				_buffer[_pos++] = b;
				if (_pos >= _windowSize)
					Flush();
			}

			public byte GetByte(uint distance) {
				uint pos = _pos - distance - 1;
				if (pos >= _windowSize)
					pos += _windowSize;
				return _buffer[pos];
			}
		}

		struct State {
			public uint Index;

			public void Init() {
				Index = 0;
			}

			public void UpdateChar() {
				if (Index < 4) Index = 0;
				else if (Index < 10) Index -= 3;
				else Index -= 6;
			}

			public void UpdateMatch() {
				Index = (uint)(Index < 7 ? 7 : 10);
			}

			public void UpdateRep() {
				Index = (uint)(Index < 7 ? 8 : 11);
			}

			public void UpdateShortRep() {
				Index = (uint)(Index < 7 ? 9 : 11);
			}

			public bool IsCharState() {
				return Index < 7;
			}
		}
	}
}

```

`Confuser.Runtime/Mutation.cs`:

```cs
using System;

internal class Mutation {
	public static readonly int KeyI0 = 0;
	public static readonly int KeyI1 = 1;
	public static readonly int KeyI2 = 2;
	public static readonly int KeyI3 = 3;
	public static readonly int KeyI4 = 4;
	public static readonly int KeyI5 = 5;
	public static readonly int KeyI6 = 6;
	public static readonly int KeyI7 = 7;
	public static readonly int KeyI8 = 8;
	public static readonly int KeyI9 = 9;
	public static readonly int KeyI10 = 10;
	public static readonly int KeyI11 = 11;
	public static readonly int KeyI12 = 12;
	public static readonly int KeyI13 = 13;
	public static readonly int KeyI14 = 14;
	public static readonly int KeyI15 = 15;

	public static T Placeholder<T>(T val) {
		return val;
	}

	public static T Value<T>() {
		return default(T);
	}

	public static T Value<T, Arg0>(Arg0 arg0) {
		return default(T);
	}

	public static void Crypt(uint[] data, uint[] key) { }
}
```

`Confuser.Runtime/RefProxy.Strong.cs`:

```cs
using System;
using System.Reflection;
using System.Reflection.Emit;

namespace Confuser.Runtime {
	internal class RefProxyKey : Attribute {
		readonly int key;

		public RefProxyKey(int key) {
			this.key = Mutation.Placeholder(key);
		}

		public override int GetHashCode() {
			return key;
		}
	}

	internal static class RefProxyStrong {
		internal static void Initialize(RuntimeFieldHandle field, byte opKey) {
			FieldInfo fieldInfo = FieldInfo.GetFieldFromHandle(field);
			byte[] sig = fieldInfo.Module.ResolveSignature(fieldInfo.MetadataToken);
			int len = sig.Length;
			int key = fieldInfo.GetOptionalCustomModifiers()[0].MetadataToken;

			key += (fieldInfo.Name[Mutation.KeyI0] ^ sig[--len]) << Mutation.KeyI4;
			key += (fieldInfo.Name[Mutation.KeyI1] ^ sig[--len]) << Mutation.KeyI5;
			key += (fieldInfo.Name[Mutation.KeyI2] ^ sig[--len]) << Mutation.KeyI6;
			len--;
			key += (fieldInfo.Name[Mutation.KeyI3] ^ sig[--len]) << Mutation.KeyI7;

			int token = Mutation.Placeholder(key);
			token *= fieldInfo.GetCustomAttributes(false)[0].GetHashCode();

			MethodBase method = fieldInfo.Module.ResolveMethod(token);
			Type delegateType = fieldInfo.FieldType;
			if (method.IsStatic)
				fieldInfo.SetValue(null, Delegate.CreateDelegate(delegateType, (MethodInfo)method));

			else {
				DynamicMethod dm = null;
				Type[] argTypes = null;

				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))
					if (invoke.DeclaringType == delegateType) {
						ParameterInfo[] paramTypes = invoke.GetParameters();
						argTypes = new Type[paramTypes.Length];
						for (int i = 0; i < argTypes.Length; i++)
							argTypes[i] = paramTypes[i].ParameterType;

						Type declType = method.DeclaringType;
						dm = new DynamicMethod("", invoke.ReturnType, argTypes, (declType.IsInterface || declType.IsArray) ? delegateType : declType, true);
						break;
					}

				DynamicILInfo info = dm.GetDynamicILInfo();
				info.SetLocalSignature(new byte[] { 0x7, 0x0 });
				var code = new byte[(2 + 5) * argTypes.Length + 6];
				int index = 0;
				var mParams = method.GetParameters();
				int mIndex = method.IsConstructor ? 0 : -1;
				for (int i = 0; i < argTypes.Length; i++) {
					code[index++] = 0x0e;
					code[index++] = (byte)i;

					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;
					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {
						var cToken = info.GetTokenFor(mType.TypeHandle);
						code[index++] = 0x74;
						code[index++] = (byte)cToken;
						code[index++] = (byte)(cToken >> 8);
						code[index++] = (byte)(cToken >> 16);
						code[index++] = (byte)(cToken >> 24);
					}
					else
						index += 5;
					mIndex++;
				}
				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);
				int dmToken = info.GetTokenFor(method.MethodHandle);
				code[index++] = (byte)dmToken;
				code[index++] = (byte)(dmToken >> 8);
				code[index++] = (byte)(dmToken >> 16);
				code[index++] = (byte)(dmToken >> 24);
				code[index] = 0x2a;
				info.SetCode(code, argTypes.Length + 1);

				fieldInfo.SetValue(null, dm.CreateDelegate(delegateType));
			}
		}
	}
}
```

`Confuser.Runtime/Resource.cs`:

```cs
using System;
using System.Reflection;

namespace Confuser.Runtime {
	internal static class Resource {
		static Assembly c;

		// Hmm... Too lazy.
		static void Initialize() {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			var k = new uint[0x10];
			var n = (uint)Mutation.KeyI1;
			for (int i = 0; i < 0x10; i++) {
				n ^= n >> 13;
				n ^= n << 25;
				n ^= n >> 27;
				k[i] = n;
			}

			int s = 0, d = 0;
			var w = new uint[0x10];
			var o = new byte[l * 4];
			while (s < l) {
				for (int j = 0; j < 0x10; j++)
					w[j] = q[s + j];
				Mutation.Crypt(w, k);
				for (int j = 0; j < 0x10; j++) {
					uint e = w[j];
					o[d++] = (byte)e;
					o[d++] = (byte)(e >> 8);
					o[d++] = (byte)(e >> 16);
					o[d++] = (byte)(e >> 24);
					k[j] ^= e;
				}
				s += 0x10;
			}

			c = Assembly.Load(Lzma.Decompress(o));
			AppDomain.CurrentDomain.AssemblyResolve += Handler;
		}

		static Assembly Handler(object sender, ResolveEventArgs args) {
			if (c.FullName == args.Name)
				return c;
			return null;
		}
	}

	internal static class Resource_Packer {
		static Assembly c;

		// Hmm... Too lazy.
		static void Initialize() {
			var l = (uint)Mutation.KeyI0;
			uint[] q = Mutation.Placeholder(new uint[Mutation.KeyI0]);

			var k = new uint[0x10];
			var n = (uint)Mutation.KeyI1;
			for (int i = 0; i < 0x10; i++) {
				n ^= n >> 13;
				n ^= n << 25;
				n ^= n >> 27;
				k[i] = n;
			}

			int s = 0, d = 0;
			var w = new uint[0x10];
			var o = new byte[l * 4];
			while (s < l) {
				for (int j = 0; j < 0x10; j++)
					w[j] = q[s + j];
				Mutation.Crypt(w, k);
				for (int j = 0; j < 0x10; j++) {
					uint e = w[j];
					o[d++] = (byte)e;
					o[d++] = (byte)(e >> 8);
					o[d++] = (byte)(e >> 16);
					o[d++] = (byte)(e >> 24);
					k[j] ^= e;
				}
				s += 0x10;
			}

			c = Assembly.Load(Lzma.Decompress(o));
			AppDomain.CurrentDomain.ResourceResolve += Handler;
		}

		static Assembly Handler(object sender, ResolveEventArgs args) {
			var n = c.GetManifestResourceNames();
			if (Array.IndexOf(n, args.Name) != -1)
				return c;
			return null;
		}
	}
}
```

`Confuser.Runtime/antinet/ABOUT`:

```
antinet --- Code to prevent a managed .NET debugger/profiler from working
Official site: https://bitbucket.org/0xd4d/antinet

Written by de4dot@gmail.com
Modified by Ki for use in ConfuserEx

The source code in this folder is in the public domain.
```

`Confuser.Runtime/antinet/AntiManagedDebugger.cs`:

```cs
/*
 * Anti managed debugger code. Written by de4dot@gmail.com
 * This code is in the public domain.
 * Official site: https://github.com/0xd4d/antinet
 */

using System;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;

namespace Confuser.Runtime {
	// This class will make sure that no managed .NET debugger can attach and
	// debug this .NET process. This code assumes that it's Microsoft's .NET
	// implementation (for the desktop) that is used. The only currently supported
	// versions are .NET Framework 2.0 - 4.5 (CLR 2.0 and CLR 4.0).
	// It prevents debugging by killing the .NET debugger thread. When it's killed,
	// any attached managed debugger, or any managed debugger that attaches, will
	// fail to send and receive any .NET debug messages. If a debugger is attached,
	// <c>Debugger.IsAttached</c> will still return <c>true</c> but that doesn't mean
	// the debugger is working. It's just that the debugger flag isn't reset by our code.
	// If a debugger is attached before this code is executed, the process could hang at
	// some later time when this process is trying to send a debug message to the debugger.
	// Clearing the debug flag could possibly solve this if you don't want it to hang.
	static partial class AntiDebugAntinet {

		[DllImport("kernel32", CharSet = CharSet.Auto)]
		private static extern uint GetCurrentProcessId();

		[DllImport("kernel32")]
		private static extern bool SetEvent(IntPtr hEvent);

		/// <summary>
		///     Must be called to initialize anti-managed debugger code
		/// </summary>
		/// <returns><c>true</c> if successful, <c>false</c> otherwise</returns>
		private static unsafe bool InitializeAntiDebugger() {
			Info info = GetInfo();
			IntPtr pDebuggerRCThread = FindDebuggerRCThreadAddress(info);
			if (pDebuggerRCThread == IntPtr.Zero)
				return false;

			// This isn't needed but it will at least stop debuggers from attaching.
			// Even if they did attach, they wouldn't get any messages since the debugger
			// thread has exited. A user who tries to attach will be greeted with an
			// "unable to attach due to different versions etc" message. This will not stop
			// already attached debuggers. Killing the debugger thread will.
			var pDebuggerIPCControlBlock = (byte*)*(IntPtr*)((byte*)pDebuggerRCThread + info.DebuggerRCThread_pDebuggerIPCControlBlock);
			if (Environment.Version.Major == 2)
				pDebuggerIPCControlBlock = (byte*)*(IntPtr*)pDebuggerIPCControlBlock;
			// Set size field to 0. mscordbi!CordbProcess::VerifyControlBlock() will fail
			// when it detects an unknown size.
			*(uint*)pDebuggerIPCControlBlock = 0;

			// Signal debugger thread to exit
			*((byte*)pDebuggerRCThread + info.DebuggerRCThread_shouldKeepLooping) = 0;
			IntPtr hEvent = *(IntPtr*)((byte*)pDebuggerRCThread + info.DebuggerRCThread_hEvent1);
			SetEvent(hEvent);

			return true;
		}

		/// <summary>
		///     Returns the correct <see cref="Info" /> instance
		/// </summary>
		private static Info GetInfo() {
			switch (Environment.Version.Major) {
				case 2:
					return IntPtr.Size == 4 ? Infos.info_CLR20_x86 : Infos.info_CLR20_x64;
				case 4:
					if (Environment.Version.Revision <= 17020)
						return IntPtr.Size == 4 ? Infos.info_CLR40_x86_1 : Infos.info_CLR40_x64;
					return IntPtr.Size == 4 ? Infos.info_CLR40_x86_2 : Infos.info_CLR40_x64;
				default:
					goto case 4; // Assume CLR 4.0
			}
		}

		/// <summary>
		///     Tries to find the address of the <c>DebuggerRCThread</c> instance in memory
		/// </summary>
		/// <param name="info">The debugger info we need</param>
		[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
		private static unsafe IntPtr FindDebuggerRCThreadAddress(Info info) {
			uint pid = GetCurrentProcessId();

			try {
				PEInfo peInfo = PEInfo.GetCLR();
				if (peInfo == null)
					return IntPtr.Zero;

				IntPtr sectionAddr;
				uint sectionSize;
				if (!peInfo.FindSection(".data", out sectionAddr, out sectionSize))
					return IntPtr.Zero;

				// Try to find the Debugger instance location in the data section
				var p = (byte*)sectionAddr;
				byte* end = (byte*)sectionAddr + sectionSize;
				for (; p + IntPtr.Size <= end; p += IntPtr.Size) {
					IntPtr pDebugger = *(IntPtr*)p;
					if (pDebugger == IntPtr.Zero)
						continue;

					try {
						// All allocations are pointer-size aligned
						if (!PEInfo.IsAlignedPointer(pDebugger))
							continue;

						// Make sure pid is correct
						uint pid2 = *(uint*)((byte*)pDebugger + info.Debugger_pid);
						if (pid != pid2)
							continue;

						IntPtr pDebuggerRCThread = *(IntPtr*)((byte*)pDebugger + info.Debugger_pDebuggerRCThread);

						// All allocations are pointer-size aligned
						if (!PEInfo.IsAlignedPointer(pDebuggerRCThread))
							continue;

						// Make sure it points back to Debugger
						IntPtr pDebugger2 = *(IntPtr*)((byte*)pDebuggerRCThread + info.DebuggerRCThread_pDebugger);
						if (pDebugger != pDebugger2)
							continue;

						return pDebuggerRCThread;
					}
					catch { }
				}
			}
			catch { }

			return IntPtr.Zero;
		}

		private class Info {

			/// <summary>
			///     Offset in <c>DebuggerRCThread</c> of event to signal to wake it up.
			///     See <c>Debugger::StopDebugger()</c> or one of the first methods it calls.
			/// </summary>
			public int DebuggerRCThread_hEvent1;

			/// <summary>
			///     Offset in <c>DebuggerRCThread</c> of pointer to <c>Debugger</c>.
			///     See <c>DebuggerRCThread::DebuggerRCThread()</c>.
			/// </summary>
			public int DebuggerRCThread_pDebugger;

			/// <summary>
			///     Offset in <c>DebuggerRCThread</c> of pointer to <c>DebuggerIPCControlBlock</c>.
			///     See <c>DebuggerRCThread::Start() after it creates the thread.</c>.
			/// </summary>
			public int DebuggerRCThread_pDebuggerIPCControlBlock;

			/// <summary>
			///     Offset in <c>DebuggerRCThread</c> of keep-looping boolean (1 byte).
			///     See <c>Debugger::StopDebugger()</c> or one of the first methods it calls.
			/// </summary>
			public int DebuggerRCThread_shouldKeepLooping;

			/// <summary>
			///     Offset in <c>Debugger</c> of pointer to <c>DebuggerRCThread</c>.
			///     See <c>Debugger::Startup()</c> (after creating DebuggerRCThread).
			/// </summary>
			public int Debugger_pDebuggerRCThread;

			/// <summary>
			///     Offset in <c>Debugger</c> of the <c>pid</c>.
			///     See <c>Debugger::Debugger()</c>.
			/// </summary>
			public int Debugger_pid;

		}

		private static class Infos {

			/// <summary>
			///     CLR 2.0 x86 offsets
			/// </summary>
			public static readonly Info info_CLR20_x86 = new Info {
				Debugger_pDebuggerRCThread = 4,
				Debugger_pid = 8,
				DebuggerRCThread_pDebugger = 0x30,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x34,
				DebuggerRCThread_shouldKeepLooping = 0x3C,
				DebuggerRCThread_hEvent1 = 0x40,
			};

			/// <summary>
			///     CLR 2.0 x64 offsets
			/// </summary>
			public static readonly Info info_CLR20_x64 = new Info {
				Debugger_pDebuggerRCThread = 8,
				Debugger_pid = 0x10,
				DebuggerRCThread_pDebugger = 0x58,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x60,
				DebuggerRCThread_shouldKeepLooping = 0x70,
				DebuggerRCThread_hEvent1 = 0x78,
			};

			/// <summary>
			///     CLR 4.0 x86 offsets
			/// </summary>
			public static readonly Info info_CLR40_x86_1 = new Info {
				Debugger_pDebuggerRCThread = 8,
				Debugger_pid = 0xC,
				DebuggerRCThread_pDebugger = 0x34,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x38,
				DebuggerRCThread_shouldKeepLooping = 0x40,
				DebuggerRCThread_hEvent1 = 0x44,
			};

			/// <summary>
			///     CLR 4.0 x86 offsets (rev >= 17379 (.NET 4.5 Beta, but not .NET 4.5 Dev Preview))
			/// </summary>
			public static readonly Info info_CLR40_x86_2 = new Info {
				Debugger_pDebuggerRCThread = 8,
				Debugger_pid = 0xC,
				DebuggerRCThread_pDebugger = 0x30,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x34,
				DebuggerRCThread_shouldKeepLooping = 0x3C,
				DebuggerRCThread_hEvent1 = 0x40,
			};

			/// <summary>
			///     CLR 4.0 x64 offsets (this is the same in all CLR 4.0 versions, even in .NET 4.5 RTM)
			/// </summary>
			public static readonly Info info_CLR40_x64 = new Info {
				Debugger_pDebuggerRCThread = 0x10,
				Debugger_pid = 0x18,
				DebuggerRCThread_pDebugger = 0x58,
				DebuggerRCThread_pDebuggerIPCControlBlock = 0x60,
				DebuggerRCThread_shouldKeepLooping = 0x70,
				DebuggerRCThread_hEvent1 = 0x78,
			};

		}

	}
}
```

`Confuser.Runtime/antinet/AntiManagedProfiler.cs`:

```cs
/*
 * Anti managed profiler code. Written by de4dot@gmail.com
 * This code is in the public domain.
 * Official site: https://github.com/0xd4d/antinet
 */

using System;
using System.Collections.Generic;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;
using Microsoft.Win32.SafeHandles;

namespace Confuser.Runtime {
	//  This class will make sure that no managed .NET profiler is working.

	//  To detect profilers that are loaded when the CLR is loaded, this code will find
	//  the CLR profiler status flag in the data section. If CLR 4.0 is used, the code
	//  will find instructions in clr.dll that compares a dword location with the value 4.
	//  4 is the value that is stored when a profiler has successfully attached to the
	//  CLR. If CLR 2.0 is used, then it will look for code that tests bits 1 and 2 of
	//  some dword location.

	//  CLR 4.0 allows a profiler to attach at any time. For this to work, it will create
	//  a named event, called "Global\CPFATE_PID_vCLRVERSION" where PID is the pid
	//  of the process the CLR is in and CLRVERSION is the first 3 version numbers
	//  (eg. 4.0.30319). It's actually the Finalizer thread that waits on this event. :)

	//  When a profiler tries to attach, it will try to connect to a named pipe. This pipe's
	//  name is called "\\.\pipe\CPFATP_PID_vCLRVERSION". It will then signal the above event to
	//  wake up the Finalizer thread. If the event can't be created, then no profiler can ever
	//  attach. Any code that runs before the CLR has a chance to "steal" this event from it
	//  to prevent the CLR from allowing profilers to attach at runtime. We can't do it. But
	//  we can create the named pipe. If we own the named pipe, then no profiler can ever send
	//  the attach message and they'll never be able to attach.

	//  Most of the time, the named pipe isn't created. All we do is create the named pipe
	//  and we've prevented profilers from attaching at runtime. If the pipe has already been
	//  created, we must make sure the CLR closes the pipe and exits the "profiler attacher"
	//  thread. By default, it will wait up to 5 mins (300,000ms) before exiting the wait loop.
	//  You can change this value with the ProfAPIMaxWaitForTriggerMs option (dword in registry)
	//  or COMPlus_ProfAPIMaxWaitForTriggerMs environment value. If the AttachThreadAlwaysOn
	//  option (COMPlus_AttachThreadAlwaysOn env value) is enabled, the attach thread will
	//  never exit and the named pipe is never closed. It's possible to close the thread and
	//  the named pipe, but it requires more memory patching. See the code for details.

	//  A user could close the named pipe handle, so we must also patch the thread proc so
	//  it always returns immediately. Only patching the thread proc and not taking ownership
	//  of the named pipe isn't good enough. If we own the named pipe, we know that the attacher
	//  thread has exited. Once we've patched the thread proc, we don't really need the named
	//  pipe anymore.
	static partial class AntiDebugAntinet {

		private static ProfilerDetector profilerDetector;

		/// <summary>
		///     Returns <c>true</c> if a profiler was attached, is attaching or detaching.
		/// </summary>
		private static bool IsProfilerAttached {
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			get {
				try {
					if (profilerDetector == null)
						return false;
					return profilerDetector.IsProfilerAttached();
				}
				catch { }
				return false;
			}
		}

		/// <summary>
		///     Returns <c>true</c> if a profiler was attached, is attaching or detaching.
		/// </summary>
		private static bool WasProfilerAttached {
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			get {
				try {
					if (profilerDetector == null)
						return false;
					return profilerDetector.WasProfilerAttached();
				}
				catch { }
				return false;
			}
		}

		/// <summary>
		///     Must be called to initialize anti-managed profiler code. This method should only
		///     be called once per process. I.e., don't call it from every loaded .NET DLL.
		/// </summary>
		/// <returns><c>true</c> if successful, <c>false</c> otherwise</returns>
		private static bool InitializeAntiProfiler() {
			profilerDetector = CreateProfilerDetector();
			return profilerDetector.Init();
		}

		private static ProfilerDetector CreateProfilerDetector() {
			if (Environment.Version.Major == 2)
				return new ProfilerDetectorCLR20();
			return new ProfilerDetectorCLR40();
		}

		/// <summary>
		///     Prevents any active profiler from receiving any profiling messages. Since the
		///     profiler is still in memory, it can call into the CLR even if it doesn't receive
		///     any messages. It's better to terminate the application than call this method.
		/// </summary>
		private static void PreventActiveProfilerFromReceivingProfilingMessages() {
			if (profilerDetector == null)
				return;
			profilerDetector.PreventActiveProfilerFromReceivingProfilingMessages();
		}

		private static IntPtr GetMax(Dictionary<IntPtr, int> addresses, int minCount) {
			IntPtr foundAddr = IntPtr.Zero;
			int maxCount = 0;

			foreach (var kv in addresses) {
				if (foundAddr == IntPtr.Zero || maxCount < kv.Value) {
					foundAddr = kv.Key;
					maxCount = kv.Value;
				}
			}

			return maxCount >= minCount ? foundAddr : IntPtr.Zero;
		}

		private abstract class ProfilerDetector {

			public abstract bool IsProfilerAttached();
			public abstract bool WasProfilerAttached();
			public abstract bool Init();
			public abstract void PreventActiveProfilerFromReceivingProfilingMessages();

		}

		private class ProfilerDetectorCLR20 : ProfilerDetector {

			/// <summary>
			///     Address of CLR 2.0's profiler status flag. If one or both of bits 1 or 2 is set,
			///     a profiler is attached.
			/// </summary>
			private IntPtr profilerStatusFlag;

			private bool wasAttached;

			public override bool IsProfilerAttached() {
				unsafe {
					if (profilerStatusFlag == IntPtr.Zero)
						return false;
					return (*(uint*)profilerStatusFlag & 6) != 0;
				}
			}

			public override bool WasProfilerAttached() {
				return wasAttached;
			}

			public override bool Init() {
				bool result = FindProfilerStatus();
				wasAttached = IsProfilerAttached();
				return result;
			}

			/// <summary>
			///     This code tries to find the CLR 2.0 profiler status flag. It searches the whole
			///     .text section for a certain instruction.
			/// </summary>
			/// <returns><c>true</c> if it was found, <c>false</c> otherwise</returns>
			private unsafe bool FindProfilerStatus() {
				// Record each hit here and pick the one with the most hits
				var addrCounts = new Dictionary<IntPtr, int>();
				try {
					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return false;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return false;

					const int MAX_COUNTS = 50;
					var p = (byte*)sectionAddr;
					byte* end = (byte*)sectionAddr + sectionSize;
					for (; p < end; p++) {
						IntPtr addr;

						// F6 05 XX XX XX XX 06	test byte ptr [mem],6
						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 2));
							else
								addr = new IntPtr(p + 7 + *(int*)(p + 2));
						}
						else
							continue;

						if (!PEInfo.IsAligned(addr, 4))
							continue;
						if (!peInfo.IsValidImageAddress(addr, 4))
							continue;

						try {
							*(uint*)addr = *(uint*)addr;
						}
						catch {
							continue;
						}

						int count = 0;
						addrCounts.TryGetValue(addr, out count);
						count++;
						addrCounts[addr] = count;
						if (count >= MAX_COUNTS)
							break;
					}
				}
				catch { }
				IntPtr foundAddr = GetMax(addrCounts, 5);
				if (foundAddr == IntPtr.Zero)
					return false;

				profilerStatusFlag = foundAddr;
				return true;
			}

			public override unsafe void PreventActiveProfilerFromReceivingProfilingMessages() {
				if (profilerStatusFlag == IntPtr.Zero)
					return;
				*(uint*)profilerStatusFlag &= ~6U;
			}

		}

		private class ProfilerDetectorCLR40 : ProfilerDetector {

			private const uint PIPE_ACCESS_DUPLEX = 3;
			private const uint PIPE_TYPE_MESSAGE = 4;
			private const uint PIPE_READMODE_MESSAGE = 2;
			private const uint FILE_FLAG_OVERLAPPED = 0x40000000;
			private const uint GENERIC_READ = 0x80000000;
			private const uint GENERIC_WRITE = 0x40000000;
			private const uint OPEN_EXISTING = 3;
			private const uint PAGE_EXECUTE_READWRITE = 0x40;

			private const uint ConfigDWORDInfo_name = 0;
			private const string ProfAPIMaxWaitForTriggerMs_name = "ProfAPIMaxWaitForTriggerMs";
			private static readonly uint ConfigDWORDInfo_defValue = (uint)IntPtr.Size;

			/// <summary>
			///     Address of the profiler control block. Only some fields are interesting and
			///     here they are in order:
			///     <code>
			/// EEToProfInterfaceImpl*
			/// uint profilerEventMask
			/// uint profilerStatus
			/// </code>
			///     <c>profilerStatus</c> is <c>0</c> when no profiler is attached. Any other value
			///     indicates that a profiler is attached, attaching, or detaching. It's <c>4</c>
			///     when a profiler is attached. When it's attached, it will receive messages from
			///     the CLR.
			/// </summary>
			private IntPtr profilerControlBlock;

			private SafeFileHandle profilerPipe;

			private bool wasAttached;

			[DllImport("kernel32", CharSet = CharSet.Auto)]
			private static extern uint GetCurrentProcessId();

			[DllImport("kernel32", CharSet = CharSet.Auto)]
			private static extern void Sleep(uint dwMilliseconds);

			[DllImport("kernel32", SetLastError = true)]
			private static extern SafeFileHandle CreateNamedPipe(string lpName, uint dwOpenMode,
			                                                     uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize,
			                                                     uint nDefaultTimeOut, IntPtr lpSecurityAttributes);

			[DllImport("kernel32", SetLastError = true, CharSet = CharSet.Auto)]
			private static extern SafeFileHandle CreateFile(string lpFileName, uint dwDesiredAccess,
			                                                uint dwShareMode, IntPtr lpSecurityAttributes, uint dwCreationDisposition,
			                                                uint dwFlagsAndAttributes, IntPtr hTemplateFile);

			[DllImport("kernel32")]
			private static extern bool VirtualProtect(IntPtr lpAddress, int dwSize, uint flNewProtect, out uint lpflOldProtect);

			public override bool IsProfilerAttached() {
				unsafe {
					if (profilerControlBlock == IntPtr.Zero)
						return false;
					return *(uint*)((byte*)profilerControlBlock + IntPtr.Size + 4) != 0;
				}
			}

			public override bool WasProfilerAttached() {
				return wasAttached;
			}

			public override bool Init() {
				bool result = FindProfilerControlBlock();
				result &= TakeOwnershipOfNamedPipe() || CreateNamedPipe();
				result &= PatchAttacherThreadProc();
				wasAttached = IsProfilerAttached();
				return result;
			}

			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private unsafe bool TakeOwnershipOfNamedPipe() {
				try {
					if (CreateNamedPipe())
						return true;

					// The CLR has already created the named pipe. Either the AttachThreadAlwaysOn
					// CLR option is enabled or some profiler has just attached or is attaching.
					// We must force it to exit its loop. There are two options that can prevent
					// it from exiting the thread, AttachThreadAlwaysOn and
					// ProfAPIMaxWaitForTriggerMs. If AttachThreadAlwaysOn is enabled, the thread
					// is started immediately when the CLR is loaded and it never exits.
					// ProfAPIMaxWaitForTriggerMs is the timeout in ms to use when waiting on
					// client attach messages. A user could set this to FFFFFFFF which is equal
					// to the INFINITE constant.
					//
					// To force it to exit, we must do this:
					//	- Find clr!ProfilingAPIAttachDetach::s_attachThreadingMode and make sure
					//	  it's not 2 (AttachThreadAlwaysOn is enabled).
					//	- Find clr!EXTERNAL_ProfAPIMaxWaitForTriggerMs and:
					//		- Set its default value to 0
					//		- Rename the option so the user can't override it
					//	- Open the named pipe to wake it up and then close the file to force a
					//	  timeout error.
					//	- Wait a little while until the thread has exited

					IntPtr threadingModeAddr = FindThreadingModeAddress();
					IntPtr timeOutOptionAddr = FindTimeOutOptionAddress();

					if (timeOutOptionAddr == IntPtr.Zero)
						return false;

					// Make sure the thread can exit. If this value is 2, it will never exit.
					if (threadingModeAddr != IntPtr.Zero && *(uint*)threadingModeAddr == 2)
						*(uint*)threadingModeAddr = 1;

					// Set default timeout to 0 and rename timeout option
					FixTimeOutOption(timeOutOptionAddr);

					// Wake up clr!ProfilingAPIAttachServer::ConnectToClient(). We immediately
					// close the pipe so it will fail to read any data. It will then start over
					// again but this time, its timeout value will be 0, and it will fail. Since
					// the thread can now exit, it will exit and close its named pipe.
					using (SafeFileHandle hPipe = CreatePipeFileHandleWait()) {
						if (hPipe == null)
							return false;
						if (hPipe.IsInvalid)
							return false;
					}

					return CreateNamedPipeWait();
				}
				catch { }
				return false;
			}

			private bool CreateNamedPipeWait() {
				int timeLeft = 100;
				const int waitTime = 5;
				while (timeLeft > 0) {
					if (CreateNamedPipe())
						return true;
					Sleep(waitTime);
					timeLeft -= waitTime;
				}
				return CreateNamedPipe();
			}

			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private static unsafe void FixTimeOutOption(IntPtr timeOutOptionAddr) {
				if (timeOutOptionAddr == IntPtr.Zero)
					return;

				uint oldProtect;
				VirtualProtect(timeOutOptionAddr, (int)ConfigDWORDInfo_defValue + 4, PAGE_EXECUTE_READWRITE, out oldProtect);
				try {
					// Set default timeout to 0 to make sure it fails immediately
					*(uint*)((byte*)timeOutOptionAddr + ConfigDWORDInfo_defValue) = 0;
				}
				finally {
					VirtualProtect(timeOutOptionAddr, (int)ConfigDWORDInfo_defValue + 4, oldProtect, out oldProtect);
				}

				// Rename the option to make sure the user can't override the value
				char* name = *(char**)((byte*)timeOutOptionAddr + ConfigDWORDInfo_name);
				var nameAddr = new IntPtr(name);
				VirtualProtect(nameAddr, ProfAPIMaxWaitForTriggerMs_name.Length * 2, PAGE_EXECUTE_READWRITE, out oldProtect);
				try {
					var rand = new Random();
					for (int i = 0; i < ProfAPIMaxWaitForTriggerMs_name.Length; i++)
						name[i] = (char)rand.Next(1, ushort.MaxValue);
				}
				finally {
					VirtualProtect(nameAddr, IntPtr.Size, oldProtect, out oldProtect);
				}
			}

			private SafeFileHandle CreatePipeFileHandleWait() {
				int timeLeft = 100;
				const int waitTime = 5;
				while (timeLeft > 0) {
					if (CreateNamedPipe())
						return null;
					SafeFileHandle hFile = CreatePipeFileHandle();
					if (!hFile.IsInvalid)
						return hFile;
					Sleep(waitTime);
					timeLeft -= waitTime;
				}
				return CreatePipeFileHandle();
			}

			private static SafeFileHandle CreatePipeFileHandle() {
				return CreateFile(GetPipeName(), GENERIC_READ | GENERIC_WRITE, 0, IntPtr.Zero, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, IntPtr.Zero);
			}

			private static string GetPipeName() {
				return string.Format(@"\\.\pipe\CPFATP_{0}_v{1}.{2}.{3}",
				                     GetCurrentProcessId(), Environment.Version.Major,
				                     Environment.Version.Minor, Environment.Version.Build);
			}

			private bool CreateNamedPipe() {
				if (profilerPipe != null && !profilerPipe.IsInvalid)
					return true;

				profilerPipe = CreateNamedPipe(GetPipeName(),
				                               FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX,
				                               PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
				                               1, // nMaxInstances
				                               0x24, // nOutBufferSize
				                               0x338, // nInBufferSize
				                               1000, // nDefaultTimeOut
				                               IntPtr.Zero); // lpSecurityAttributes

				return !profilerPipe.IsInvalid;
			}

			/// <summary>
			///     Finds the address of clr!ProfilingAPIAttachDetach::s_attachThreadingMode
			/// </summary>
			/// <returns>The address or <c>null</c> if none was found</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private static unsafe IntPtr FindThreadingModeAddress() {
				try {
					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()
					//	83 3D XX XX XX XX 02	cmp dword ptr [mem],2
					//	74 / 0F 84 XX			je there
					//	83 E8+r 00 / 85 C0+rr	sub reg,0 / test reg,reg
					//	74 / 0F 84 XX			je there
					//	48+r / FF C8+r			dec reg
					//	74 / 0F 84 XX			je there
					//	48+r / FF C8+r			dec reg

					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return IntPtr.Zero;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return IntPtr.Zero;

					var ptr = (byte*)sectionAddr;
					byte* end = (byte*)sectionAddr + sectionSize;
					for (; ptr < end; ptr++) {
						IntPtr addr;

						try {
							//	83 3D XX XX XX XX 02	cmp dword ptr [mem],2
							byte* p = ptr;
							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)
								continue;
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 2));
							else
								addr = new IntPtr(p + 7 + *(int*)(p + 2));
							if (!PEInfo.IsAligned(addr, 4))
								continue;
							if (!peInfo.IsValidImageAddress(addr))
								continue;
							p += 7;

							// 1 = normal lazy thread creation. 2 = thread is always present
							if (*(uint*)addr < 1 || *(uint*)addr > 2)
								continue;
							*(uint*)addr = *(uint*)addr;

							//	74 / 0F 84 XX			je there
							if (!NextJz(ref p))
								continue;

							//	83 E8+r 00 / 85 C0+rr	sub reg,0 / test reg,reg
							SkipRex(ref p);
							if (*p == 0x83 && p[2] == 0) {
								if ((uint)(p[1] - 0xE8) > 7)
									continue;
								p += 3;
							}
							else if (*p == 0x85) {
								int reg = (p[1] >> 3) & 7;
								int rm = p[1] & 7;
								if (reg != rm)
									continue;
								p += 2;
							}
							else
								continue;

							//	74 / 0F 84 XX			je there
							if (!NextJz(ref p))
								continue;

							//	48+r / FF C8+r			dec reg
							if (!SkipDecReg(ref p))
								continue;

							//	74 / 0F 84 XX			je there
							if (!NextJz(ref p))
								continue;

							//	48+r / FF C8+r			dec reg
							if (!SkipDecReg(ref p))
								continue;

							return addr;
						}
						catch { }
					}
				}
				catch { }
				return IntPtr.Zero;
			}

			/// <summary>
			///     Finds the address of clr!EXTERNAL_ProfAPIMaxWaitForTriggerMs
			/// </summary>
			/// <returns>The address or <c>null</c> if none was found</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private static unsafe IntPtr FindTimeOutOptionAddress() {
				try {
					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return IntPtr.Zero;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".rdata", out sectionAddr, out sectionSize) &&
					    !peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return IntPtr.Zero;

					var p = (byte*)sectionAddr;
					byte* end = (byte*)sectionAddr + sectionSize;
					for (; p < end; p++) {
						try {
							char* name = *(char**)(p + ConfigDWORDInfo_name);
							if (!PEInfo.IsAligned(new IntPtr(name), 2))
								continue;
							if (!peInfo.IsValidImageAddress(name))
								continue;

							if (!Equals(name, ProfAPIMaxWaitForTriggerMs_name))
								continue;

							return new IntPtr(p);
						}
						catch { }
					}
				}
				catch { }
				return IntPtr.Zero;
			}

			private static unsafe bool Equals(char* s1, string s2) {
				for (int i = 0; i < s2.Length; i++) {
					if (char.ToUpperInvariant(s1[i]) != char.ToUpperInvariant(s2[i]))
						return false;
				}
				return s1[s2.Length] == 0;
			}

			private static unsafe void SkipRex(ref byte* p) {
				if (IntPtr.Size != 8)
					return;
				if (*p >= 0x48 && *p <= 0x4F)
					p++;
			}

			private static unsafe bool SkipDecReg(ref byte* p) {
				SkipRex(ref p);
				if (IntPtr.Size == 4 && *p >= 0x48 && *p <= 0x4F)
					p++;
				else if (*p == 0xFF && p[1] >= 0xC8 && p[1] <= 0xCF)
					p += 2;
				else
					return false;
				return true;
			}

			private static unsafe bool NextJz(ref byte* p) {
				if (*p == 0x74) {
					p += 2;
					return true;
				}

				if (*p == 0x0F && p[1] == 0x84) {
					p += 6;
					return true;
				}

				return false;
			}

			/// <summary>
			///     Finds the attacher thread's thread proc and patches it so it returns immediately.
			/// </summary>
			/// <returns><c>true</c> if it was patched, <c>false</c> otherwise</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private unsafe bool PatchAttacherThreadProc() {
				IntPtr threadProc = FindAttacherThreadProc();
				if (threadProc == IntPtr.Zero)
					return false;

				var p = (byte*)threadProc;
				uint oldProtect;
				VirtualProtect(new IntPtr(p), 5, PAGE_EXECUTE_READWRITE, out oldProtect);
				try {
					if (IntPtr.Size == 4) {
						// xor eax,eax
						p[0] = 0x33;
						p[1] = 0xC0;
						// retn 4
						p[2] = 0xC2;
						p[3] = 0x04;
						p[4] = 0x00;
					}
					else {
						// xor eax,eax
						p[0] = 0x33;
						p[1] = 0xC0;
						// retn
						p[2] = 0xC3;
					}
				}
				finally {
					VirtualProtect(new IntPtr(p), 5, oldProtect, out oldProtect);
				}
				return true;
			}

			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private unsafe IntPtr FindAttacherThreadProc() {
				try {
					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return IntPtr.Zero;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return IntPtr.Zero;

					var p = (byte*)sectionAddr;
					byte* start = p;
					byte* end = (byte*)sectionAddr + sectionSize;

					if (IntPtr.Size == 4) {
						for (; p < end; p++) {
							// Find this code:
							//	50+r				push reg
							//	50+r				push reg
							//	50+r				push reg
							//	68 XX XX XX XX		push offset ThreadProc
							//	50+r				push reg
							//	50+r				push reg
							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()

							byte push = *p;
							if (push < 0x50 || push > 0x57)
								continue;
							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)
								continue;
							if (p[3] != 0x68)
								continue;
							if (p[10] != 0xFF || p[11] != 0x15)
								continue;

							var threadProc = new IntPtr((void*)*(uint*)(p + 4));
							if (!CheckThreadProc(start, end, threadProc))
								continue;

							return threadProc;
						}
					}
					else {
						for (; p < end; p++) {
							// Find this code:
							//	45 33 C9				xor r9d,r9d
							//	4C 8D 05 XX XX XX XX	lea r8,ThreadProc
							//	33 D2					xor edx,edx
							//	33 C9					xor ecx,ecx
							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()

							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)
								continue;
							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)
								continue;
							if (p[10] != 0x33 && p[11] != 0xD2)
								continue;
							if (p[12] != 0x33 && p[13] != 0xC9)
								continue;
							if (p[14] != 0xFF && p[15] != 0x15)
								continue;

							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));
							if (!CheckThreadProc(start, end, threadProc))
								continue;

							return threadProc;
						}
					}
				}
				catch { }

				return IntPtr.Zero;
			}

			/// <summary>
			///     Checks whether it appears to be the profiler attacher thread proc
			/// </summary>
			/// <param name="codeStart">Start of code</param>
			/// <param name="codeEnd">End of code</param>
			/// <param name="threadProc">Possible thread proc</param>
			/// <returns><c>true</c> if it's probably the thread proc, <c>false</c> otherwise</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private static unsafe bool CheckThreadProc(byte* codeStart, byte* codeEnd, IntPtr threadProc) {
				try {
					var p = (byte*)threadProc;

					// Must be in .text section
					if (p < codeStart || p >= codeEnd)
						return false;

					// It has a constant that is present in the first N bytes
					for (int i = 0; i < 0x20; i++) {
						if (*(uint*)(p + i) == 0x4000)
							return true;
					}
				}
				catch { }
				return false;
			}

			/// <summary>
			///     This code tries to find the CLR 4.0 profiler control block address. It does this
			///     by searching for the code that accesses the profiler status field.
			/// </summary>
			/// <returns><c>true</c> if it was found, <c>false</c> otherwise</returns>
			[HandleProcessCorruptedStateExceptions, SecurityCritical] // Req'd on .NET 4.0
			private unsafe bool FindProfilerControlBlock() {
				// Record each hit here and pick the one with the most hits
				var addrCounts = new Dictionary<IntPtr, int>();
				try {
					PEInfo peInfo = PEInfo.GetCLR();
					if (peInfo == null)
						return false;

					IntPtr sectionAddr;
					uint sectionSize;
					if (!peInfo.FindSection(".text", out sectionAddr, out sectionSize))
						return false;

					const int MAX_COUNTS = 50;
					var p = (byte*)sectionAddr;
					byte* end = (byte*)sectionAddr + sectionSize;
					for (; p < end; p++) {
						IntPtr addr;

						// A1 xx xx xx xx		mov eax,[mem]
						// 83 F8 04				cmp eax,4
						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 1));
							else
								addr = new IntPtr(p + 5 + *(int*)(p + 1));
						}
							// 8B 05 xx xx xx xx	mov eax,[mem]
							// 83 F8 04				cmp eax,4
						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 2));
							else
								addr = new IntPtr(p + 6 + *(int*)(p + 2));
						}
							// 83 3D XX XX XX XX 04	cmp dword ptr [mem],4
						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {
							if (IntPtr.Size == 4)
								addr = new IntPtr((void*)*(uint*)(p + 2));
							else
								addr = new IntPtr(p + 7 + *(int*)(p + 2));
						}
						else
							continue;

						if (!PEInfo.IsAligned(addr, 4))
							continue;
						if (!peInfo.IsValidImageAddress(addr, 4))
							continue;

						// Valid values are 0-4. 4 being attached.
						try {
							if (*(uint*)addr > 4)
								continue;
							*(uint*)addr = *(uint*)addr;
						}
						catch {
							continue;
						}

						int count = 0;
						addrCounts.TryGetValue(addr, out count);
						count++;
						addrCounts[addr] = count;
						if (count >= MAX_COUNTS)
							break;
					}
				}
				catch { }
				IntPtr foundAddr = GetMax(addrCounts, 5);
				if (foundAddr == IntPtr.Zero)
					return false;

				profilerControlBlock = new IntPtr((byte*)foundAddr - (IntPtr.Size + 4));
				return true;
			}

			public override unsafe void PreventActiveProfilerFromReceivingProfilingMessages() {
				if (profilerControlBlock == IntPtr.Zero)
					return;
				*(uint*)((byte*)profilerControlBlock + IntPtr.Size + 4) = 0;
			}

		}

	}
}
```

`Confuser.Runtime/antinet/HandleProcessCorruptedStateExceptionsAttribute.cs`:

```cs
using System;

namespace System.Runtime.ExceptionServices {
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	internal class HandleProcessCorruptedStateExceptionsAttribute : Attribute {

	}
}
```

`Confuser.Runtime/antinet/PEInfo.cs`:

```cs
/*
 * PE helper code. Written by de4dot@gmail.com
 * This code is in the public domain.
 * Official site: https://github.com/0xd4d/antinet
 */

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace Confuser.Runtime {
	static partial class AntiDebugAntinet {

		private class PEInfo {

			private readonly IntPtr imageBase;
			private IntPtr imageEnd;
			private int numSects;
			private IntPtr sectionsAddr;

			/// <summary>
			///     Constructor
			/// </summary>
			/// <param name="addr">Address of a PE image</param>
			public PEInfo(IntPtr addr) {
				imageBase = addr;
				Init();
			}

			[DllImport("kernel32", CharSet = CharSet.Auto)]
			private static extern IntPtr GetModuleHandle(string name);

			/// <summary>
			///     Creates a <see cref="PEInfo" /> instance loaded from the CLR (clr.dll / mscorwks.dll)
			/// </summary>
			/// <returns>The new instance or <c>null</c> if we failed</returns>
			public static PEInfo GetCLR() {
				IntPtr clrAddr = GetCLRAddress();
				if (clrAddr == IntPtr.Zero)
					return null;
				return new PEInfo(clrAddr);
			}

			private static IntPtr GetCLRAddress() {
				if (Environment.Version.Major == 2)
					return GetModuleHandle("mscorwks");
				return GetModuleHandle("clr");
			}

			private unsafe void Init() {
				var p = (byte*)imageBase;
				p += *(uint*)(p + 0x3C); // Get NT headers
				p += 4 + 2; // Skip magic + machine
				numSects = *(ushort*)p;
				p += 2 + 0x10; // Skip the rest of file header
				bool is32 = *(ushort*)p == 0x010B;
				uint sizeOfImage = *(uint*)(p + 0x38);
				imageEnd = new IntPtr((byte*)imageBase + sizeOfImage);
				p += is32 ? 0x60 : 0x70; // Skip optional header
				p += 0x10 * 8; // Skip data dirs
				sectionsAddr = new IntPtr(p);
			}

			/// <summary>
			///     Checks whether the address is within the image
			/// </summary>
			/// <param name="addr">Address</param>
			public unsafe bool IsValidImageAddress(IntPtr addr) {
				return IsValidImageAddress((void*)addr, 0);
			}

			/// <summary>
			///     Checks whether the address is within the image
			/// </summary>
			/// <param name="addr">Address</param>
			/// <param name="size">Number of bytes</param>
			public unsafe bool IsValidImageAddress(IntPtr addr, uint size) {
				return IsValidImageAddress((void*)addr, size);
			}

			/// <summary>
			///     Checks whether the address is within the image
			/// </summary>
			/// <param name="addr">Address</param>
			public unsafe bool IsValidImageAddress(void* addr) {
				return IsValidImageAddress(addr, 0);
			}

			/// <summary>
			///     Checks whether the address is within the image
			/// </summary>
			/// <param name="addr">Address</param>
			/// <param name="size">Number of bytes</param>
			public unsafe bool IsValidImageAddress(void* addr, uint size) {
				if (addr < (void*)imageBase)
					return false;
				if (addr >= (void*)imageEnd)
					return false;

				if (size != 0) {
					if ((byte*)addr + size < addr)
						return false;
					if ((byte*)addr + size > (void*)imageEnd)
						return false;
				}

				return true;
			}

			/// <summary>
			///     Finds a section
			/// </summary>
			/// <param name="name">Name of section</param>
			/// <param name="sectionStart">Updated with start address of section</param>
			/// <param name="sectionSize">Updated with size of section</param>
			/// <returns><c>true</c> on success, <c>false</c> on failure</returns>
			public unsafe bool FindSection(string name, out IntPtr sectionStart, out uint sectionSize) {
				byte[] nameBytes = Encoding.UTF8.GetBytes(name + "\0\0\0\0\0\0\0\0");
				for (int i = 0; i < numSects; i++) {
					byte* p = (byte*)sectionsAddr + i * 0x28;
					if (!CompareSectionName(p, nameBytes))
						continue;

					sectionStart = new IntPtr((byte*)imageBase + *(uint*)(p + 12));
					sectionSize = Math.Max(*(uint*)(p + 8), *(uint*)(p + 16));
					return true;
				}

				sectionStart = IntPtr.Zero;
				sectionSize = 0;
				return false;
			}

			private static unsafe bool CompareSectionName(byte* sectionName, byte[] nameBytes) {
				for (int i = 0; i < 8; i++) {
					if (*sectionName != nameBytes[i])
						return false;
					sectionName++;
				}
				return true;
			}

			/// <summary>
			///     Checks whether a pointer is aligned
			/// </summary>
			/// <param name="addr">Address</param>
			public static bool IsAlignedPointer(IntPtr addr) {
				return ((int)addr.ToInt64() & (IntPtr.Size - 1)) == 0;
			}

			/// <summary>
			///     Checks whether a pointer is aligned
			/// </summary>
			/// <param name="addr">Address</param>
			/// <param name="alignment">Alignment</param>
			public static bool IsAligned(IntPtr addr, uint alignment) {
				return ((uint)addr.ToInt64() & (alignment - 1)) == 0;
			}

		}

	}
}
```

`Confuser2.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32014.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.Core", "Confuser.Core\Confuser.Core.csproj", "{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.Protections", "Confuser.Protections\Confuser.Protections.csproj", "{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.CLI", "Confuser.CLI\Confuser.CLI.csproj", "{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.Renamer", "Confuser.Renamer\Confuser.Renamer.csproj", "{862DA0DA-52E1-47CD-B9C2-46B106031B28}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.DynCipher", "Confuser.DynCipher\Confuser.DynCipher.csproj", "{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.Runtime", "Confuser.Runtime\Confuser.Runtime.csproj", "{A45C184F-F98F-4258-A928-BFF437034791}"
	ProjectSection(ProjectDependencies) = postProject
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92} = {BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ConfuserEx", "ConfuserEx\ConfuserEx.csproj", "{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Tests", "Tests", "{356BDB31-853E-43BB-8F9A-D8AC08F69EBB}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CompressorWithResx", "Tests\CompressorWithResx\CompressorWithResx.csproj", "{32223BE8-3E78-489C-92ED-7900B26DFF43}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "CompressorWithResx.Test", "Tests\CompressorWithResx.Test\CompressorWithResx.Test.csproj", "{32CE1CB1-B7D9-416F-8EFE-6A0055867537}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{B26E932E-3EEB-41A4-9EDF-B02CAFA43DF4}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		appveyor.yml = appveyor.yml
		LICENSE.md = LICENSE.md
		README.md = README.md
		version.json = version.json
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.UnitTest", "Tests\Confuser.UnitTest\Confuser.UnitTest.csproj", "{73226E13-1701-424E-A4F2-3E4D575A1DD0}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AntiTamper", "Tests\AntiTamper\AntiTamper.csproj", "{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AntiTamper.Test", "Tests\AntiTamper.Test\AntiTamper.Test.csproj", "{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "TypeScrambler", "Tests\TypeScrambler\TypeScrambler.csproj", "{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "TypeScrambler.Test", "Tests\TypeScrambler.Test\TypeScrambler.Test.csproj", "{DEED6795-9EC9-4B2C-95E0-9E465DA61755}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.MSBuild.Tasks", "Confuser.MSBuild.Tasks\Confuser.MSBuild.Tasks.csproj", "{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "WpfRenaming", "Tests\WpfRenaming\WpfRenaming.csproj", "{BA9D2748-1342-41A3-87F2-343E82D99813}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "WpfRenaming.Test", "Tests\WpfRenaming.Test\WpfRenaming.Test.csproj", "{30B8883F-A0A2-4256-ADCF-A790525D3696}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "WinFormsRenaming", "Tests\WinFormsRenaming\WinFormsRenaming.csproj", "{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "WinFormsRenaming.Test", "Tests\WinFormsRenaming.Test\WinFormsRenaming.Test.csproj", "{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}"
EndProject
Project("{778DAE3C-4631-46EA-AA77-85C1314464D9}") = "VisualBasicRenamingResx", "Tests\VisualBasicRenamingResx\VisualBasicRenamingResx.vbproj", "{4B2CE997-8157-40B4-B42F-51CE33954AAC}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "VisualBasicRenamingResx.Test", "Tests\VisualBasicRenamingResx.Test\VisualBasicRenamingResx.Test.csproj", "{40C6A1BB-69AA-4869-81EE-41917D0B009A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.Renamer.Test", "Tests\Confuser.Renamer.Test\Confuser.Renamer.Test.csproj", "{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "78_SignatureMismatch", "Tests\78_SignatureMismatch\78_SignatureMismatch.csproj", "{CD257C0A-9071-42B4-A2FF-180622DBCA96}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "78_SignatureMismatch.Test", "Tests\78_SignatureMismatch.Test\78_SignatureMismatch.Test.csproj", "{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Confuser.Core.Test", "Tests\Confuser.Core.Test\Confuser.Core.Test.csproj", "{055BC73F-FCAE-4361-B035-2E156A101EA9}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "118_EnhancedStrongName", "Tests\118_EnhancedStrongName\118_EnhancedStrongName.csproj", "{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "118_EnhancedStrongName.Test", "Tests\118_EnhancedStrongName.Test\118_EnhancedStrongName.Test.csproj", "{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "123_InheritCustomAttr", "Tests\123_InheritCustomAttr\123_InheritCustomAttr.csproj", "{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "123_InheritCustomAttr.Test", "Tests\123_InheritCustomAttr.Test\123_InheritCustomAttr.Test.csproj", "{DA7DF89C-447D-4C2D-9C75-933037BF245E}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "161_DynamicTypeRename", "Tests\161_DynamicTypeRename\161_DynamicTypeRename.csproj", "{034B1C28-96B9-486A-B238-9C651EAA32CA}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "161_DynamicTypeRename.Test", "Tests\161_DynamicTypeRename.Test\161_DynamicTypeRename.Test.csproj", "{2B914EE7-F206-4A83-B435-460D054315BB}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "193_ConstantsInlining", "Tests\193_ConstantsInlining\193_ConstantsInlining.csproj", "{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "193_ConstantsInlining.Lib", "Tests\193_ConstantsInlining.Lib\193_ConstantsInlining.Lib.csproj", "{630BF262-768C-4085-89B1-9FEF7375F442}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "193_ConstantsInlining.Test", "Tests\193_ConstantsInlining.Test\193_ConstantsInlining.Test.csproj", "{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "SignatureMismatch2", "Tests\SignatureMismatch2\SignatureMismatch2.csproj", "{3504F678-95FA-4DB2-8437-31A927CABC16}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "SignatureMismatch2Helper", "Tests\SignatureMismatch2Helper\SignatureMismatch2Helper.csproj", "{02948DD6-47BD-4C82-9B4B-78931DB23B8A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "SignatureMismatch2.Test", "Tests\SignatureMismatch2.Test\SignatureMismatch2.Test.csproj", "{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "IncorrectRedirectToGac", "Tests\IncorrectRedirectToGac\IncorrectRedirectToGac.csproj", "{9B823D93-BF1B-407B-A4CD-231347F656AD}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "IncorrectRedirectToGac.Test", "Tests\IncorrectRedirectToGac.Test\IncorrectRedirectToGac.Test.csproj", "{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "252_ComplexInterfaceRenaming", "Tests\252_ComplexInterfaceRenaming\252_ComplexInterfaceRenaming.csproj", "{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "252_ComplexInterfaceRenaming.Test", "Tests\252_ComplexInterfaceRenaming.Test\252_ComplexInterfaceRenaming.Test.csproj", "{C10599E3-5A79-484F-940B-E4B61F256466}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "270_EnumArrayConstantProtection", "Tests\270_EnumArrayConstantProtection\270_EnumArrayConstantProtection.csproj", "{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "270_EnumArrayConstantProtection.Test", "Tests\270_EnumArrayConstantProtection.Test\270_EnumArrayConstantProtection.Test.csproj", "{DB234158-233E-4EC4-A2CE-EF02699563A2}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ReferenceProxy", "Tests\ReferenceProxy\ReferenceProxy.csproj", "{FE068381-F170-4C37-82C4-11A81FE60F1A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ReferenceProxy.Test", "Tests\ReferenceProxy.Test\ReferenceProxy.Test.csproj", "{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "244_ClrProtection", "Tests\244_ClrProtection\244_ClrProtection.vcxproj", "{73F11EE8-F565-479E-8366-BD74EE467CE8}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "244_ClrProtection.Test", "Tests\244_ClrProtection.Test\244_ClrProtection.Test.csproj", "{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "306_ComplexClassStructureRename.Lib", "Tests\306_ComplexClassStructureRename.Lib\306_ComplexClassStructureRename.Lib.csproj", "{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "306_ComplexClassStructureRename", "Tests\306_ComplexClassStructureRename\306_ComplexClassStructureRename.csproj", "{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "306_ComplexClassStructureRename.Test", "Tests\306_ComplexClassStructureRename.Test\306_ComplexClassStructureRename.Test.csproj", "{13431429-2DB6-480F-B73F-CA019FE759E3}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "342_InterfaceRenamingLoop", "Tests\342_InterfaceRenamingLoop\342_InterfaceRenamingLoop.csproj", "{382B6332-4A57-458D-96EB-B312688A7604}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "342_InterfaceRenamingLoop.Test", "Tests\342_InterfaceRenamingLoop.Test\342_InterfaceRenamingLoop.Test.csproj", "{EC62CE1D-ADD7-419A-84A9-D6A04E866197}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "345_RenameDynamicParameter", "Tests\345_RenameDynamicParameter\345_RenameDynamicParameter.csproj", "{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "345_RenameDynamicParameter.Test", "Tests\345_RenameDynamicParameter.Test\345_RenameDynamicParameter.Test.csproj", "{0C8F49D8-BD68-420A-907D-031B83737C50}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MethodOverloading", "Tests\MethodOverloading\MethodOverloading.csproj", "{A5B912EC-D588-401C-A84F-D01F98142B9E}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MethodOverloading.Test", "Tests\MethodOverloading.Test\MethodOverloading.Test.csproj", "{E17B7339-C788-4DBE-B382-3AEDB024073D}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessageDeobfuscation", "Tests\MessageDeobfuscation\MessageDeobfuscation.csproj", "{F2378C48-D441-49E7-B094-1E8642A7E7C0}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MessageDeobfuscation.Test", "Tests\MessageDeobfuscation.Test\MessageDeobfuscation.Test.csproj", "{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "389_MixedCultureCasing", "Tests\389_MixedCultureCasing\389_MixedCultureCasing.csproj", "{75E5F9A0-8D69-4426-9F16-4A65E941974D}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "389_MixedCultureCasing.Test", "Tests\389_MixedCultureCasing.Test\389_MixedCultureCasing.Test.csproj", "{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BlockingReferences", "Tests\BlockingReferences\BlockingReferences.csproj", "{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BlockingReferencesHelper", "Tests\BlockingReferencesHelper\BlockingReferencesHelper.csproj", "{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BlockingReferences.Test", "Tests\BlockingReferences.Test\BlockingReferences.Test.csproj", "{4FB03AD0-96FF-4730-801A-4F997795D920}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "421_NewtonsoftJsonSerialization", "Tests\421_NewtonsoftJsonSerialization\421_NewtonsoftJsonSerialization.csproj", "{4EF73752-78B0-4E0D-A33B-B6637B6C2177}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "421_NewtonsoftJsonSerialization.Test", "Tests\421_NewtonsoftJsonSerialization.Test\421_NewtonsoftJsonSerialization.Test.csproj", "{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "470_ImplementationInBaseClass", "Tests\470_ImplementationInBaseClass\470_ImplementationInBaseClass.csproj", "{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "470_ImplementationInBaseClass.Test", "Tests\470_ImplementationInBaseClass.Test\470_ImplementationInBaseClass.Test.csproj", "{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|x64.ActiveCfg = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|x64.Build.0 = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|x86.ActiveCfg = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Debug|x86.Build.0 = Debug|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|Any CPU.Build.0 = Release|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|x64.ActiveCfg = Release|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|x64.Build.0 = Release|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|x86.ActiveCfg = Release|Any CPU
		{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}.Release|x86.Build.0 = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|x64.ActiveCfg = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|x64.Build.0 = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Debug|x86.Build.0 = Debug|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|Any CPU.Build.0 = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|x64.ActiveCfg = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|x64.Build.0 = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|x86.ActiveCfg = Release|Any CPU
		{3EAB01B5-9B49-48D8-BFA1-5493B26CCB71}.Release|x86.Build.0 = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|x64.ActiveCfg = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|x64.Build.0 = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|x86.ActiveCfg = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Debug|x86.Build.0 = Debug|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|Any CPU.Build.0 = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|x64.ActiveCfg = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|x64.Build.0 = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|x86.ActiveCfg = Release|Any CPU
		{CE61ADEE-C032-43EC-ACD8-E4A742F894A3}.Release|x86.Build.0 = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|x64.ActiveCfg = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|x64.Build.0 = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|x86.ActiveCfg = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Debug|x86.Build.0 = Debug|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|Any CPU.Build.0 = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|x64.ActiveCfg = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|x64.Build.0 = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|x86.ActiveCfg = Release|Any CPU
		{862DA0DA-52E1-47CD-B9C2-46B106031B28}.Release|x86.Build.0 = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|x64.Build.0 = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Debug|x86.Build.0 = Debug|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|Any CPU.Build.0 = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|x64.ActiveCfg = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|x64.Build.0 = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|x86.ActiveCfg = Release|Any CPU
		{E832E9B8-2158-4FC0-89A1-56C6ECC10F6B}.Release|x86.Build.0 = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|Any CPU.ActiveCfg = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|Any CPU.Build.0 = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|x64.Build.0 = Debug|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Debug|x86.Build.0 = Debug|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|Any CPU.Build.0 = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|x64.ActiveCfg = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|x64.Build.0 = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|x86.ActiveCfg = Release|Any CPU
		{A45C184F-F98F-4258-A928-BFF437034791}.Release|x86.Build.0 = Release|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Debug|x64.ActiveCfg = Debug|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Debug|x64.Build.0 = Debug|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Debug|x86.ActiveCfg = Debug|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Debug|x86.Build.0 = Debug|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Release|Any CPU.Build.0 = Release|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Release|x64.ActiveCfg = Release|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Release|x64.Build.0 = Release|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Release|x86.ActiveCfg = Release|Any CPU
		{B5205EBA-EC32-4C53-86A0-FAEEE7393EC0}.Release|x86.Build.0 = Release|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Debug|x64.ActiveCfg = Debug|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Debug|x64.Build.0 = Debug|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Debug|x86.ActiveCfg = Debug|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Debug|x86.Build.0 = Debug|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Release|Any CPU.Build.0 = Release|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Release|x64.ActiveCfg = Release|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Release|x64.Build.0 = Release|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Release|x86.ActiveCfg = Release|Any CPU
		{32223BE8-3E78-489C-92ED-7900B26DFF43}.Release|x86.Build.0 = Release|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Debug|x64.ActiveCfg = Debug|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Debug|x64.Build.0 = Debug|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Debug|x86.ActiveCfg = Debug|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Debug|x86.Build.0 = Debug|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Release|Any CPU.Build.0 = Release|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Release|x64.ActiveCfg = Release|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Release|x64.Build.0 = Release|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Release|x86.ActiveCfg = Release|Any CPU
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537}.Release|x86.Build.0 = Release|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Debug|x64.ActiveCfg = Debug|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Debug|x64.Build.0 = Debug|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Debug|x86.ActiveCfg = Debug|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Debug|x86.Build.0 = Debug|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Release|Any CPU.Build.0 = Release|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Release|x64.ActiveCfg = Release|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Release|x64.Build.0 = Release|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Release|x86.ActiveCfg = Release|Any CPU
		{73226E13-1701-424E-A4F2-3E4D575A1DD0}.Release|x86.Build.0 = Release|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Debug|x64.ActiveCfg = Debug|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Debug|x64.Build.0 = Debug|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Debug|x86.ActiveCfg = Debug|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Debug|x86.Build.0 = Debug|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Release|Any CPU.Build.0 = Release|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Release|x64.ActiveCfg = Release|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Release|x64.Build.0 = Release|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Release|x86.ActiveCfg = Release|Any CPU
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9}.Release|x86.Build.0 = Release|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Debug|x64.ActiveCfg = Debug|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Debug|x64.Build.0 = Debug|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Debug|x86.Build.0 = Debug|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Release|Any CPU.Build.0 = Release|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Release|x64.ActiveCfg = Release|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Release|x64.Build.0 = Release|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Release|x86.ActiveCfg = Release|Any CPU
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17}.Release|x86.Build.0 = Release|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Debug|x64.ActiveCfg = Debug|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Debug|x64.Build.0 = Debug|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Debug|x86.ActiveCfg = Debug|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Debug|x86.Build.0 = Debug|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Release|Any CPU.Build.0 = Release|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Release|x64.ActiveCfg = Release|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Release|x64.Build.0 = Release|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Release|x86.ActiveCfg = Release|Any CPU
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C}.Release|x86.Build.0 = Release|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Debug|x64.ActiveCfg = Debug|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Debug|x64.Build.0 = Debug|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Debug|x86.ActiveCfg = Debug|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Debug|x86.Build.0 = Debug|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Release|Any CPU.Build.0 = Release|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Release|x64.ActiveCfg = Release|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Release|x64.Build.0 = Release|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Release|x86.ActiveCfg = Release|Any CPU
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755}.Release|x86.Build.0 = Release|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Debug|x64.ActiveCfg = Debug|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Debug|x64.Build.0 = Debug|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Debug|x86.ActiveCfg = Debug|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Debug|x86.Build.0 = Debug|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Release|Any CPU.Build.0 = Release|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Release|x64.ActiveCfg = Release|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Release|x64.Build.0 = Release|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Release|x86.ActiveCfg = Release|Any CPU
		{91B12706-DC6A-45DE-97F1-FAF0901FF6AF}.Release|x86.Build.0 = Release|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Debug|x64.ActiveCfg = Debug|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Debug|x64.Build.0 = Debug|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Debug|x86.ActiveCfg = Debug|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Debug|x86.Build.0 = Debug|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Release|Any CPU.Build.0 = Release|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Release|x64.ActiveCfg = Release|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Release|x64.Build.0 = Release|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Release|x86.ActiveCfg = Release|Any CPU
		{BA9D2748-1342-41A3-87F2-343E82D99813}.Release|x86.Build.0 = Release|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Debug|x64.ActiveCfg = Debug|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Debug|x64.Build.0 = Debug|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Debug|x86.ActiveCfg = Debug|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Debug|x86.Build.0 = Debug|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Release|Any CPU.Build.0 = Release|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Release|x64.ActiveCfg = Release|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Release|x64.Build.0 = Release|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Release|x86.ActiveCfg = Release|Any CPU
		{30B8883F-A0A2-4256-ADCF-A790525D3696}.Release|x86.Build.0 = Release|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Debug|x64.ActiveCfg = Debug|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Debug|x64.Build.0 = Debug|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Debug|x86.ActiveCfg = Debug|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Debug|x86.Build.0 = Debug|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Release|Any CPU.Build.0 = Release|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Release|x64.ActiveCfg = Release|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Release|x64.Build.0 = Release|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Release|x86.ActiveCfg = Release|Any CPU
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A}.Release|x86.Build.0 = Release|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Debug|x64.ActiveCfg = Debug|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Debug|x64.Build.0 = Debug|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Debug|x86.Build.0 = Debug|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Release|Any CPU.Build.0 = Release|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Release|x64.ActiveCfg = Release|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Release|x64.Build.0 = Release|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Release|x86.ActiveCfg = Release|Any CPU
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E}.Release|x86.Build.0 = Release|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Debug|x64.ActiveCfg = Debug|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Debug|x64.Build.0 = Debug|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Debug|x86.ActiveCfg = Debug|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Debug|x86.Build.0 = Debug|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Release|Any CPU.Build.0 = Release|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Release|x64.ActiveCfg = Release|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Release|x64.Build.0 = Release|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Release|x86.ActiveCfg = Release|Any CPU
		{4B2CE997-8157-40B4-B42F-51CE33954AAC}.Release|x86.Build.0 = Release|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Debug|x64.ActiveCfg = Debug|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Debug|x64.Build.0 = Debug|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Debug|x86.ActiveCfg = Debug|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Debug|x86.Build.0 = Debug|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Release|Any CPU.Build.0 = Release|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Release|x64.ActiveCfg = Release|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Release|x64.Build.0 = Release|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Release|x86.ActiveCfg = Release|Any CPU
		{40C6A1BB-69AA-4869-81EE-41917D0B009A}.Release|x86.Build.0 = Release|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Debug|x64.Build.0 = Debug|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Debug|x86.Build.0 = Debug|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Release|Any CPU.Build.0 = Release|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Release|x64.ActiveCfg = Release|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Release|x64.Build.0 = Release|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Release|x86.ActiveCfg = Release|Any CPU
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01}.Release|x86.Build.0 = Release|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Debug|x64.ActiveCfg = Debug|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Debug|x64.Build.0 = Debug|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Debug|x86.ActiveCfg = Debug|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Debug|x86.Build.0 = Debug|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Release|Any CPU.Build.0 = Release|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Release|x64.ActiveCfg = Release|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Release|x64.Build.0 = Release|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Release|x86.ActiveCfg = Release|Any CPU
		{CD257C0A-9071-42B4-A2FF-180622DBCA96}.Release|x86.Build.0 = Release|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Debug|x64.ActiveCfg = Debug|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Debug|x64.Build.0 = Debug|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Debug|x86.ActiveCfg = Debug|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Debug|x86.Build.0 = Debug|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Release|Any CPU.Build.0 = Release|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Release|x64.ActiveCfg = Release|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Release|x64.Build.0 = Release|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Release|x86.ActiveCfg = Release|Any CPU
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE}.Release|x86.Build.0 = Release|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Debug|x64.ActiveCfg = Debug|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Debug|x64.Build.0 = Debug|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Debug|x86.ActiveCfg = Debug|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Debug|x86.Build.0 = Debug|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Release|Any CPU.Build.0 = Release|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Release|x64.ActiveCfg = Release|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Release|x64.Build.0 = Release|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Release|x86.ActiveCfg = Release|Any CPU
		{055BC73F-FCAE-4361-B035-2E156A101EA9}.Release|x86.Build.0 = Release|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Debug|x64.ActiveCfg = Debug|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Debug|x64.Build.0 = Debug|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Debug|x86.ActiveCfg = Debug|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Debug|x86.Build.0 = Debug|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Release|Any CPU.Build.0 = Release|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Release|x64.ActiveCfg = Release|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Release|x64.Build.0 = Release|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Release|x86.ActiveCfg = Release|Any CPU
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339}.Release|x86.Build.0 = Release|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Debug|x64.ActiveCfg = Debug|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Debug|x64.Build.0 = Debug|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Debug|x86.Build.0 = Debug|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Release|Any CPU.Build.0 = Release|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Release|x64.ActiveCfg = Release|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Release|x64.Build.0 = Release|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Release|x86.ActiveCfg = Release|Any CPU
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E}.Release|x86.Build.0 = Release|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Debug|x64.ActiveCfg = Debug|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Debug|x64.Build.0 = Debug|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Debug|x86.Build.0 = Debug|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Release|Any CPU.Build.0 = Release|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Release|x64.ActiveCfg = Release|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Release|x64.Build.0 = Release|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Release|x86.ActiveCfg = Release|Any CPU
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32}.Release|x86.Build.0 = Release|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Debug|x64.ActiveCfg = Debug|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Debug|x64.Build.0 = Debug|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Debug|x86.Build.0 = Debug|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Release|Any CPU.Build.0 = Release|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Release|x64.ActiveCfg = Release|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Release|x64.Build.0 = Release|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Release|x86.ActiveCfg = Release|Any CPU
		{DA7DF89C-447D-4C2D-9C75-933037BF245E}.Release|x86.Build.0 = Release|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Debug|x64.ActiveCfg = Debug|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Debug|x64.Build.0 = Debug|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Debug|x86.ActiveCfg = Debug|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Debug|x86.Build.0 = Debug|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Release|Any CPU.Build.0 = Release|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Release|x64.ActiveCfg = Release|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Release|x64.Build.0 = Release|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Release|x86.ActiveCfg = Release|Any CPU
		{034B1C28-96B9-486A-B238-9C651EAA32CA}.Release|x86.Build.0 = Release|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Debug|x64.ActiveCfg = Debug|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Debug|x64.Build.0 = Debug|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Debug|x86.ActiveCfg = Debug|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Debug|x86.Build.0 = Debug|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Release|Any CPU.Build.0 = Release|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Release|x64.ActiveCfg = Release|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Release|x64.Build.0 = Release|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Release|x86.ActiveCfg = Release|Any CPU
		{2B914EE7-F206-4A83-B435-460D054315BB}.Release|x86.Build.0 = Release|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Debug|x64.ActiveCfg = Debug|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Debug|x64.Build.0 = Debug|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Debug|x86.ActiveCfg = Debug|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Debug|x86.Build.0 = Debug|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Release|Any CPU.Build.0 = Release|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Release|x64.ActiveCfg = Release|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Release|x64.Build.0 = Release|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Release|x86.ActiveCfg = Release|Any CPU
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD}.Release|x86.Build.0 = Release|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Debug|x64.ActiveCfg = Debug|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Debug|x64.Build.0 = Debug|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Debug|x86.ActiveCfg = Debug|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Debug|x86.Build.0 = Debug|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Release|Any CPU.Build.0 = Release|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Release|x64.ActiveCfg = Release|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Release|x64.Build.0 = Release|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Release|x86.ActiveCfg = Release|Any CPU
		{630BF262-768C-4085-89B1-9FEF7375F442}.Release|x86.Build.0 = Release|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Debug|x64.ActiveCfg = Debug|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Debug|x64.Build.0 = Debug|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Debug|x86.ActiveCfg = Debug|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Debug|x86.Build.0 = Debug|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Release|Any CPU.Build.0 = Release|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Release|x64.ActiveCfg = Release|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Release|x64.Build.0 = Release|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Release|x86.ActiveCfg = Release|Any CPU
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB}.Release|x86.Build.0 = Release|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Debug|x64.ActiveCfg = Debug|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Debug|x64.Build.0 = Debug|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Debug|x86.Build.0 = Debug|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Release|Any CPU.Build.0 = Release|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Release|x64.ActiveCfg = Release|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Release|x64.Build.0 = Release|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Release|x86.ActiveCfg = Release|Any CPU
		{3504F678-95FA-4DB2-8437-31A927CABC16}.Release|x86.Build.0 = Release|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Debug|x64.ActiveCfg = Debug|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Debug|x64.Build.0 = Debug|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Debug|x86.ActiveCfg = Debug|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Debug|x86.Build.0 = Debug|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Release|Any CPU.Build.0 = Release|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Release|x64.ActiveCfg = Release|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Release|x64.Build.0 = Release|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Release|x86.ActiveCfg = Release|Any CPU
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A}.Release|x86.Build.0 = Release|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Debug|x64.ActiveCfg = Debug|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Debug|x64.Build.0 = Debug|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Debug|x86.ActiveCfg = Debug|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Debug|x86.Build.0 = Debug|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Release|Any CPU.Build.0 = Release|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Release|x64.ActiveCfg = Release|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Release|x64.Build.0 = Release|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Release|x86.ActiveCfg = Release|Any CPU
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34}.Release|x86.Build.0 = Release|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Debug|x64.ActiveCfg = Debug|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Debug|x64.Build.0 = Debug|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Debug|x86.ActiveCfg = Debug|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Debug|x86.Build.0 = Debug|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Release|Any CPU.Build.0 = Release|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Release|x64.ActiveCfg = Release|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Release|x64.Build.0 = Release|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Release|x86.ActiveCfg = Release|Any CPU
		{9B823D93-BF1B-407B-A4CD-231347F656AD}.Release|x86.Build.0 = Release|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Debug|x64.ActiveCfg = Debug|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Debug|x64.Build.0 = Debug|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Debug|x86.ActiveCfg = Debug|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Debug|x86.Build.0 = Debug|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Release|Any CPU.Build.0 = Release|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Release|x64.ActiveCfg = Release|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Release|x64.Build.0 = Release|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Release|x86.ActiveCfg = Release|Any CPU
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2}.Release|x86.Build.0 = Release|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Debug|x64.ActiveCfg = Debug|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Debug|x64.Build.0 = Debug|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Debug|x86.ActiveCfg = Debug|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Debug|x86.Build.0 = Debug|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Release|Any CPU.Build.0 = Release|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Release|x64.ActiveCfg = Release|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Release|x64.Build.0 = Release|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Release|x86.ActiveCfg = Release|Any CPU
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D}.Release|x86.Build.0 = Release|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Debug|x64.ActiveCfg = Debug|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Debug|x64.Build.0 = Debug|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Debug|x86.ActiveCfg = Debug|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Debug|x86.Build.0 = Debug|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Release|Any CPU.Build.0 = Release|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Release|x64.ActiveCfg = Release|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Release|x64.Build.0 = Release|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Release|x86.ActiveCfg = Release|Any CPU
		{C10599E3-5A79-484F-940B-E4B61F256466}.Release|x86.Build.0 = Release|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Debug|x64.ActiveCfg = Debug|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Debug|x64.Build.0 = Debug|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Debug|x86.ActiveCfg = Debug|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Debug|x86.Build.0 = Debug|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Release|Any CPU.Build.0 = Release|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Release|x64.ActiveCfg = Release|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Release|x64.Build.0 = Release|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Release|x86.ActiveCfg = Release|Any CPU
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091}.Release|x86.Build.0 = Release|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Debug|x64.ActiveCfg = Debug|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Debug|x64.Build.0 = Debug|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Debug|x86.ActiveCfg = Debug|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Debug|x86.Build.0 = Debug|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Release|Any CPU.Build.0 = Release|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Release|x64.ActiveCfg = Release|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Release|x64.Build.0 = Release|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Release|x86.ActiveCfg = Release|Any CPU
		{DB234158-233E-4EC4-A2CE-EF02699563A2}.Release|x86.Build.0 = Release|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Debug|x64.ActiveCfg = Debug|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Debug|x64.Build.0 = Debug|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Debug|x86.ActiveCfg = Debug|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Debug|x86.Build.0 = Debug|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Release|Any CPU.Build.0 = Release|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Release|x64.ActiveCfg = Release|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Release|x64.Build.0 = Release|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Release|x86.ActiveCfg = Release|Any CPU
		{FE068381-F170-4C37-82C4-11A81FE60F1A}.Release|x86.Build.0 = Release|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Debug|x64.ActiveCfg = Debug|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Debug|x64.Build.0 = Debug|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Debug|x86.ActiveCfg = Debug|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Debug|x86.Build.0 = Debug|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Release|Any CPU.Build.0 = Release|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Release|x64.ActiveCfg = Release|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Release|x64.Build.0 = Release|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Release|x86.ActiveCfg = Release|Any CPU
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1}.Release|x86.Build.0 = Release|Any CPU
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Debug|Any CPU.Build.0 = Debug|Win32
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Debug|x64.ActiveCfg = Debug|x64
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Debug|x64.Build.0 = Debug|x64
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Debug|x86.ActiveCfg = Debug|Win32
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Debug|x86.Build.0 = Debug|Win32
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Release|Any CPU.ActiveCfg = Release|Win32
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Release|Any CPU.Build.0 = Release|Win32
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Release|x64.ActiveCfg = Release|x64
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Release|x64.Build.0 = Release|x64
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Release|x86.ActiveCfg = Release|Win32
		{73F11EE8-F565-479E-8366-BD74EE467CE8}.Release|x86.Build.0 = Release|Win32
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Debug|x64.ActiveCfg = Debug|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Debug|x64.Build.0 = Debug|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Debug|x86.ActiveCfg = Debug|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Debug|x86.Build.0 = Debug|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Release|Any CPU.Build.0 = Release|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Release|x64.ActiveCfg = Release|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Release|x64.Build.0 = Release|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Release|x86.ActiveCfg = Release|Any CPU
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9}.Release|x86.Build.0 = Release|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Debug|x64.ActiveCfg = Debug|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Debug|x64.Build.0 = Debug|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Debug|x86.ActiveCfg = Debug|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Debug|x86.Build.0 = Debug|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Release|Any CPU.Build.0 = Release|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Release|x64.ActiveCfg = Release|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Release|x64.Build.0 = Release|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Release|x86.ActiveCfg = Release|Any CPU
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35}.Release|x86.Build.0 = Release|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Debug|x64.ActiveCfg = Debug|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Debug|x64.Build.0 = Debug|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Debug|x86.ActiveCfg = Debug|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Debug|x86.Build.0 = Debug|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Release|Any CPU.Build.0 = Release|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Release|x64.ActiveCfg = Release|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Release|x64.Build.0 = Release|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Release|x86.ActiveCfg = Release|Any CPU
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16}.Release|x86.Build.0 = Release|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Debug|x64.ActiveCfg = Debug|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Debug|x64.Build.0 = Debug|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Debug|x86.ActiveCfg = Debug|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Debug|x86.Build.0 = Debug|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Release|Any CPU.Build.0 = Release|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Release|x64.ActiveCfg = Release|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Release|x64.Build.0 = Release|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Release|x86.ActiveCfg = Release|Any CPU
		{13431429-2DB6-480F-B73F-CA019FE759E3}.Release|x86.Build.0 = Release|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Debug|x64.ActiveCfg = Debug|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Debug|x64.Build.0 = Debug|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Debug|x86.ActiveCfg = Debug|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Debug|x86.Build.0 = Debug|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Release|Any CPU.Build.0 = Release|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Release|x64.ActiveCfg = Release|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Release|x64.Build.0 = Release|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Release|x86.ActiveCfg = Release|Any CPU
		{382B6332-4A57-458D-96EB-B312688A7604}.Release|x86.Build.0 = Release|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Debug|x64.ActiveCfg = Debug|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Debug|x64.Build.0 = Debug|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Debug|x86.ActiveCfg = Debug|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Debug|x86.Build.0 = Debug|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Release|Any CPU.Build.0 = Release|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Release|x64.ActiveCfg = Release|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Release|x64.Build.0 = Release|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Release|x86.ActiveCfg = Release|Any CPU
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197}.Release|x86.Build.0 = Release|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Debug|x64.ActiveCfg = Debug|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Debug|x64.Build.0 = Debug|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Debug|x86.ActiveCfg = Debug|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Debug|x86.Build.0 = Debug|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Release|Any CPU.Build.0 = Release|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Release|x64.ActiveCfg = Release|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Release|x64.Build.0 = Release|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Release|x86.ActiveCfg = Release|Any CPU
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C}.Release|x86.Build.0 = Release|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Debug|x64.ActiveCfg = Debug|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Debug|x64.Build.0 = Debug|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Debug|x86.ActiveCfg = Debug|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Debug|x86.Build.0 = Debug|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Release|Any CPU.Build.0 = Release|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Release|x64.ActiveCfg = Release|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Release|x64.Build.0 = Release|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Release|x86.ActiveCfg = Release|Any CPU
		{0C8F49D8-BD68-420A-907D-031B83737C50}.Release|x86.Build.0 = Release|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Debug|x64.ActiveCfg = Debug|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Debug|x64.Build.0 = Debug|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Debug|x86.ActiveCfg = Debug|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Debug|x86.Build.0 = Debug|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Release|Any CPU.Build.0 = Release|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Release|x64.ActiveCfg = Release|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Release|x64.Build.0 = Release|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Release|x86.ActiveCfg = Release|Any CPU
		{A5B912EC-D588-401C-A84F-D01F98142B9E}.Release|x86.Build.0 = Release|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Debug|x64.ActiveCfg = Debug|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Debug|x64.Build.0 = Debug|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Debug|x86.ActiveCfg = Debug|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Debug|x86.Build.0 = Debug|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Release|Any CPU.Build.0 = Release|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Release|x64.ActiveCfg = Release|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Release|x64.Build.0 = Release|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Release|x86.ActiveCfg = Release|Any CPU
		{E17B7339-C788-4DBE-B382-3AEDB024073D}.Release|x86.Build.0 = Release|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Debug|x64.ActiveCfg = Debug|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Debug|x64.Build.0 = Debug|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Debug|x86.ActiveCfg = Debug|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Debug|x86.Build.0 = Debug|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Release|Any CPU.Build.0 = Release|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Release|x64.ActiveCfg = Release|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Release|x64.Build.0 = Release|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Release|x86.ActiveCfg = Release|Any CPU
		{F2378C48-D441-49E7-B094-1E8642A7E7C0}.Release|x86.Build.0 = Release|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Debug|x64.ActiveCfg = Debug|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Debug|x64.Build.0 = Debug|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Debug|x86.ActiveCfg = Debug|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Debug|x86.Build.0 = Debug|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Release|Any CPU.Build.0 = Release|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Release|x64.ActiveCfg = Release|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Release|x64.Build.0 = Release|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Release|x86.ActiveCfg = Release|Any CPU
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93}.Release|x86.Build.0 = Release|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Debug|x64.ActiveCfg = Debug|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Debug|x64.Build.0 = Debug|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Debug|x86.ActiveCfg = Debug|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Debug|x86.Build.0 = Debug|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Release|Any CPU.Build.0 = Release|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Release|x64.ActiveCfg = Release|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Release|x64.Build.0 = Release|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Release|x86.ActiveCfg = Release|Any CPU
		{75E5F9A0-8D69-4426-9F16-4A65E941974D}.Release|x86.Build.0 = Release|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Debug|x64.ActiveCfg = Debug|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Debug|x64.Build.0 = Debug|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Debug|x86.ActiveCfg = Debug|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Debug|x86.Build.0 = Debug|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Release|Any CPU.Build.0 = Release|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Release|x64.ActiveCfg = Release|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Release|x64.Build.0 = Release|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Release|x86.ActiveCfg = Release|Any CPU
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3}.Release|x86.Build.0 = Release|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Debug|x64.ActiveCfg = Debug|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Debug|x64.Build.0 = Debug|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Debug|x86.ActiveCfg = Debug|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Debug|x86.Build.0 = Debug|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Release|Any CPU.Build.0 = Release|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Release|x64.ActiveCfg = Release|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Release|x64.Build.0 = Release|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Release|x86.ActiveCfg = Release|Any CPU
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821}.Release|x86.Build.0 = Release|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Debug|x64.ActiveCfg = Debug|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Debug|x64.Build.0 = Debug|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Debug|x86.ActiveCfg = Debug|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Debug|x86.Build.0 = Debug|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Release|Any CPU.Build.0 = Release|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Release|x64.ActiveCfg = Release|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Release|x64.Build.0 = Release|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Release|x86.ActiveCfg = Release|Any CPU
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD}.Release|x86.Build.0 = Release|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Debug|x64.ActiveCfg = Debug|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Debug|x64.Build.0 = Debug|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Debug|x86.ActiveCfg = Debug|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Debug|x86.Build.0 = Debug|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Release|Any CPU.Build.0 = Release|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Release|x64.ActiveCfg = Release|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Release|x64.Build.0 = Release|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Release|x86.ActiveCfg = Release|Any CPU
		{4FB03AD0-96FF-4730-801A-4F997795D920}.Release|x86.Build.0 = Release|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Debug|x64.ActiveCfg = Debug|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Debug|x64.Build.0 = Debug|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Debug|x86.ActiveCfg = Debug|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Debug|x86.Build.0 = Debug|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Release|Any CPU.Build.0 = Release|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Release|x64.ActiveCfg = Release|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Release|x64.Build.0 = Release|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Release|x86.ActiveCfg = Release|Any CPU
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177}.Release|x86.Build.0 = Release|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Debug|x64.ActiveCfg = Debug|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Debug|x64.Build.0 = Debug|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Debug|x86.ActiveCfg = Debug|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Debug|x86.Build.0 = Debug|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Release|Any CPU.Build.0 = Release|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Release|x64.ActiveCfg = Release|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Release|x64.Build.0 = Release|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Release|x86.ActiveCfg = Release|Any CPU
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78}.Release|x86.Build.0 = Release|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Debug|x64.ActiveCfg = Debug|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Debug|x64.Build.0 = Debug|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Debug|x86.ActiveCfg = Debug|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Debug|x86.Build.0 = Debug|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Release|Any CPU.Build.0 = Release|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Release|x64.ActiveCfg = Release|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Release|x64.Build.0 = Release|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Release|x86.ActiveCfg = Release|Any CPU
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE}.Release|x86.Build.0 = Release|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Debug|x64.ActiveCfg = Debug|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Debug|x64.Build.0 = Debug|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Debug|x86.ActiveCfg = Debug|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Debug|x86.Build.0 = Debug|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Release|Any CPU.Build.0 = Release|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Release|x64.ActiveCfg = Release|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Release|x64.Build.0 = Release|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Release|x86.ActiveCfg = Release|Any CPU
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{32223BE8-3E78-489C-92ED-7900B26DFF43} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{32CE1CB1-B7D9-416F-8EFE-6A0055867537} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{73226E13-1701-424E-A4F2-3E4D575A1DD0} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{6A2BA6F7-3399-4890-9453-2D5BE8EEBBA9} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{3F5558BD-7B94-4CB0-A46C-A7252B5BCA17} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{E7F99164-F00F-4B2A-86A9-8EB5F659F34C} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{DEED6795-9EC9-4B2C-95E0-9E465DA61755} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{BA9D2748-1342-41A3-87F2-343E82D99813} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{30B8883F-A0A2-4256-ADCF-A790525D3696} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{211A4598-B46E-4CD3-BA5A-1EC259D4DB5A} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{6C8ECB51-EECE-49C3-89EC-CB0AAECCFF7E} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{4B2CE997-8157-40B4-B42F-51CE33954AAC} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{40C6A1BB-69AA-4869-81EE-41917D0B009A} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{A1F54816-3FBA-4A71-9D26-D31C6BE9CF01} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{CD257C0A-9071-42B4-A2FF-180622DBCA96} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{8489A9CE-AB1A-4D8D-8824-D9E18B9945FE} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{055BC73F-FCAE-4361-B035-2E156A101EA9} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{D5C4F5A2-5713-4A0A-A833-F9466AE5A339} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{D8BDABF6-6A96-4B48-8C1C-B6E78CBBF50E} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{3B85D7A9-6BD0-4CD8-9009-36554EF24D32} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{DA7DF89C-447D-4C2D-9C75-933037BF245E} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{034B1C28-96B9-486A-B238-9C651EAA32CA} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{2B914EE7-F206-4A83-B435-460D054315BB} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{AB2E1440-7EC2-45A2-8CF3-2975DE8A57AD} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{630BF262-768C-4085-89B1-9FEF7375F442} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{E9D90B2A-F563-4A5E-9EFB-B1D6B1E7F8CB} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{3504F678-95FA-4DB2-8437-31A927CABC16} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{02948DD6-47BD-4C82-9B4B-78931DB23B8A} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{87BEF4D7-813E-48BA-96FE-E3A24BF2DC34} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{9B823D93-BF1B-407B-A4CD-231347F656AD} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{B7FF0EE8-6C68-46C6-AADB-58C0E3309FB2} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{F233D36D-B64A-4F14-A9F9-B8557C2D4F5D} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{C10599E3-5A79-484F-940B-E4B61F256466} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{7C6D1CCD-D4DF-426A-B5D6-A6B5F13D0091} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{DB234158-233E-4EC4-A2CE-EF02699563A2} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{FE068381-F170-4C37-82C4-11A81FE60F1A} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{2C059FE7-C868-4C6D-AFA0-D62BA3C1B2E1} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{73F11EE8-F565-479E-8366-BD74EE467CE8} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{3ADB8BB1-AE14-49DA-A7E1-1C0D9BEB76E9} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{FD93D181-2EC5-4863-8A8F-5F8C84C06B35} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{1B52A3D9-014C-4CBF-BB98-09080D9A8D16} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{13431429-2DB6-480F-B73F-CA019FE759E3} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{382B6332-4A57-458D-96EB-B312688A7604} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{EC62CE1D-ADD7-419A-84A9-D6A04E866197} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{DAE3997B-D51B-4D9F-9F11-2EBC6FDDF57C} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{0C8F49D8-BD68-420A-907D-031B83737C50} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{A5B912EC-D588-401C-A84F-D01F98142B9E} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{E17B7339-C788-4DBE-B382-3AEDB024073D} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{F2378C48-D441-49E7-B094-1E8642A7E7C0} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{5E9715AB-CAF7-4FFF-8E14-A8727891DA93} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{75E5F9A0-8D69-4426-9F16-4A65E941974D} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{D1CCDA5D-E460-4ACC-B51A-730DE8F0ECF3} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{F602DAFE-E8A2-4CB2-AF0E-656CD357D821} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{9EB8DC3B-60DC-451E-8C18-3D7E38D463FD} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{4FB03AD0-96FF-4730-801A-4F997795D920} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{4EF73752-78B0-4E0D-A33B-B6637B6C2177} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{B1CB9A30-FEA6-4467-BEC5-4803CCE9BF78} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{5D10ED0A-6C52-49FE-90F5-CFAAECA8FABE} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
		{F7581FB4-FAF5-4CD0-888A-B588F5BC69CD} = {356BDB31-853E-43BB-8F9A-D8AC08F69EBB}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0D937D9E-E04B-4A68-B639-D4260473A388}
	EndGlobalSection
EndGlobal

```

`ConfuserEx.Common.props`:

```props
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003"> 

  <PropertyGroup Label="C-Sharp Compiler Settings" Condition="'$(MSBuildProjectExtension)' == '.csproj'">
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

  <PropertyGroup Label="Assembly Information">
    <_CurrentYear>$([System.DateTime]::Now.ToString(yyyy))</_CurrentYear>
    <Authors>Ki;Martin Karing</Authors>
    <Copyright>Copyright © 2014 Ki, 2018 - $(_CurrentYear) Martin Karing</Copyright>
    <RepositoryUrl>https://github.com/mkaring/ConfuserEx.git</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
  </PropertyGroup>
  
  <PropertyGroup Label="Language">
    <NeutralLanguage>en</NeutralLanguage>
  </PropertyGroup>
  
  <PropertyGroup Label="SourceLink">
	<SourceLinkServerType>GitHub</SourceLinkServerType>
	<SourceLinkOriginUrl>$(RepositoryUrl)</SourceLinkOriginUrl>
  </PropertyGroup> 
  
  <PropertyGroup Label="Code Analysis">
	<EnableCodeAnalysis>false</EnableCodeAnalysis>
  </PropertyGroup>
  
</Project>
```

`ConfuserEx.Common.targets`:

```targets
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  
  <ItemGroup>
    <PackageReference Include="Microsoft.SourceLink.GitHub" Version="1.1.1" PrivateAssets="all" />
    <PackageReference Include="Nerdbank.GitVersioning" Version="3.4.255" PrivateAssets="all" />
    <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers" Version="*" PrivateAssets="all"
					  Condition="'$(EnableCodeAnalysis)' != 'false'" />
  </ItemGroup>
  
</Project>
```

`ConfuserEx/App.xaml`:

```xaml
<Application x:Class="ConfuserEx.App" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" StartupUri="MainWindow.xaml">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Skin.xaml" />
                <ResourceDictionary Source="Views.xaml" />
            </ResourceDictionary.MergedDictionaries>
            <BitmapImage x:Key="New" UriSource="Resources/New.png" />
            <BitmapImage x:Key="Open" UriSource="Resources/Open.png" />
            <BitmapImage x:Key="Save" UriSource="Resources/Save.png" />
            <BitmapImage x:Key="Tools" UriSource="Resources/Tools.png" />
            <BitmapImage x:Key="Decode" UriSource="Resources/Decode.png" />
            <BitmapImage x:Key="Error" UriSource="Resources/Error.png" />
            <FontFamily x:Key="FontAwesome">Resources/#FontAwesome</FontFamily>
        </ResourceDictionary>
    </Application.Resources>
</Application>

```

`ConfuserEx/App.xaml.cs`:

```cs
using System;
using System.Windows;

namespace ConfuserEx {
	public partial class App : Application { }
}
```

`ConfuserEx/BoolToVisibilityConverter.cs`:

```cs
using System;
using System.Diagnostics;
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace ConfuserEx {
	internal class BoolToVisibilityConverter : IValueConverter {
		public static readonly BoolToVisibilityConverter Instance = new BoolToVisibilityConverter();
		BoolToVisibilityConverter() { }

		public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
			Debug.Assert(value is bool);
			Debug.Assert(targetType == typeof(Visibility));
			return (bool)value ? Visibility.Visible : Visibility.Collapsed;
		}

		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) {
			throw new NotSupportedException();
		}
	}
}
```

`ConfuserEx/BrushToColorConverter.cs`:

```cs
using System;
using System.Globalization;
using System.Windows.Data;
using System.Windows.Media;

namespace ConfuserEx {
	public class BrushToColorConverter : IValueConverter {
		public static readonly BrushToColorConverter Instance = new BrushToColorConverter();
		BrushToColorConverter() { }

		public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
			var brush = value as SolidColorBrush;
			if (brush != null)
				return brush.Color;
			return null;
		}

		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) {
			throw new NotImplementedException();
		}
	}
}
```

`ConfuserEx/CompComboBox.xaml`:

```xaml
<UserControl x:Class="ConfuserEx.CompComboBox"
             x:Name="Root"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:core="clr-namespace:Confuser.Core;assembly=Confuser.Core">
    <ComboBox ItemsSource="{Binding Components, ElementName=Root}"
              SelectedItem="{Binding SelectedComponent, ElementName=Root}"
              DisplayMemberPath="Id" FontFamily="Consolas"
              ScrollViewer.CanContentScroll="False">
        <ComboBox.ItemContainerStyle>
            <Style TargetType="{x:Type ComboBoxItem}">
                <Setter Property="OverridesDefaultStyle" Value="True" />
                <Setter Property="Template">
                    <Setter.Value>
                        <ControlTemplate TargetType="{x:Type ComboBoxItem}">
                            <Border Width="350" BorderBrush="{StaticResource Foreground}"
                                    Background="{TemplateBinding Background}" BorderThickness="1" Margin="5">
                                <Grid Background="Transparent">
                                    <Grid.RowDefinitions>
                                        <RowDefinition />
                                        <RowDefinition />
                                    </Grid.RowDefinitions>
                                    <Label Grid.Row="0" Content="{Binding Name}" HorizontalAlignment="Left" />
                                    <Label Grid.Row="0" Content="{Binding Id}" HorizontalAlignment="Right" />
                                    <Label Grid.Row="1">
                                        <TextBlock Text="{Binding Description}" TextTrimming="WordEllipsis"
                                                   FontSize="10" Foreground="Gray" />
                                    </Label>
                                </Grid>
                            </Border>
                            <ControlTemplate.Triggers>
                                <Trigger Property="IsMouseOver" Value="True">
                                    <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
                                    <Setter Property="Foreground" Value="{StaticResource SelectedForeground}" />
                                </Trigger>
                            </ControlTemplate.Triggers>
                        </ControlTemplate>
                    </Setter.Value>
                </Setter>
            </Style>
        </ComboBox.ItemContainerStyle>
    </ComboBox>
</UserControl>
```

`ConfuserEx/CompComboBox.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Controls;
using Confuser.Core;

namespace ConfuserEx {
	public partial class CompComboBox : UserControl {
		public static readonly DependencyProperty ComponentsProperty = DependencyProperty.Register("Components", typeof(IEnumerable<ConfuserComponent>), typeof(CompComboBox), new UIPropertyMetadata(null));
		public static readonly DependencyProperty SelectedComponentProperty = DependencyProperty.Register("SelectedComponent", typeof(ConfuserComponent), typeof(CompComboBox), new UIPropertyMetadata(null));
		public static readonly DependencyProperty ArgumentsProperty = DependencyProperty.Register("Arguments", typeof(Dictionary<string, string>), typeof(CompComboBox), new UIPropertyMetadata(null));

		public CompComboBox() {
			InitializeComponent();
		}

		public IEnumerable<ConfuserComponent> Components {
			get { return (IEnumerable<ConfuserComponent>)GetValue(ComponentsProperty); }
			set { SetValue(ComponentsProperty, value); }
		}

		public ConfuserComponent SelectedComponent {
			get { return (ConfuserComponent)GetValue(SelectedComponentProperty); }
			set { SetValue(SelectedComponentProperty, value); }
		}

		public Dictionary<string, string> Arguments {
			get { return (Dictionary<string, string>)GetValue(ArgumentsProperty); }
			set { SetValue(ArgumentsProperty, value); }
		}
	}
}
```

`ConfuserEx/ComponentConverter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using Confuser.Core;

namespace ConfuserEx {
	internal class ComponentConverter : Freezable, IValueConverter {
		public static readonly DependencyProperty ComponentsProperty = DependencyProperty.Register("Components", typeof(IList<ConfuserComponent>), typeof(ComponentConverter), new UIPropertyMetadata(null));

		public IList<ConfuserComponent> Components {
			get { return (IList<ConfuserComponent>)GetValue(ComponentsProperty); }
			set { SetValue(ComponentsProperty, value); }
		}

		public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
			Debug.Assert(value is string || value == null);
			Debug.Assert(targetType == typeof(ConfuserComponent));
			Debug.Assert(Components != null);

			if (value == null) return null;
			return Components.Single(comp => comp.Id == (string)value);
		}

		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) {
			Debug.Assert(value is ConfuserComponent || value == null);
			Debug.Assert(targetType == typeof(string));

			if (value == null) return null;
			return ((ConfuserComponent)value).Id;
		}

		protected override Freezable CreateInstanceCore() {
			return new ComponentConverter();
		}
	}
}
```

`ConfuserEx/ComponentDiscovery.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using Confuser.Core;

namespace ConfuserEx {
	internal class ComponentDiscovery {
		static void CrossDomainLoadComponents() {
			var ctx = (CrossDomainContext)AppDomain.CurrentDomain.GetData("ctx");
			// Initialize the version resolver callback
			ConfuserEngine.Version.ToString();

			Assembly assembly = Assembly.LoadFile(ctx.PluginPath);
			foreach (var module in assembly.GetLoadedModules())
				foreach (var i in module.GetTypes()) {
					if (i.IsAbstract || !PluginDiscovery.HasAccessibleDefConstructor(i))
						continue;

					if (typeof(Protection).IsAssignableFrom(i)) {
						var prot = (Protection)Activator.CreateInstance(i);
						ctx.AddProtection(Info.FromComponent(prot, ctx.PluginPath));
					}
					else if (typeof(Packer).IsAssignableFrom(i)) {
						var packer = (Packer)Activator.CreateInstance(i);
						ctx.AddPacker(Info.FromComponent(packer, ctx.PluginPath));
					}
				}
		}

		public static void LoadComponents(IList<ConfuserComponent> protections, IList<ConfuserComponent> packers, string pluginPath) {
			var ctx = new CrossDomainContext(protections, packers, pluginPath);
			AppDomain appDomain = AppDomain.CreateDomain("");
			appDomain.SetData("ctx", ctx);
			appDomain.DoCallBack(CrossDomainLoadComponents);
			AppDomain.Unload(appDomain);
		}

		public static void RemoveComponents(IList<ConfuserComponent> protections, IList<ConfuserComponent> packers, string pluginPath) {
			protections.RemoveWhere(comp => comp is InfoComponent && ((InfoComponent)comp).info.path == pluginPath);
			packers.RemoveWhere(comp => comp is InfoComponent && ((InfoComponent)comp).info.path == pluginPath);
		}

		class CrossDomainContext : MarshalByRefObject {
			readonly IList<ConfuserComponent> packers;
			readonly string pluginPath;
			readonly IList<ConfuserComponent> protections;

			public CrossDomainContext(IList<ConfuserComponent> protections, IList<ConfuserComponent> packers, string pluginPath) {
				this.protections = protections;
				this.packers = packers;
				this.pluginPath = pluginPath;
			}

			public string PluginPath {
				get { return pluginPath; }
			}

			public void AddProtection(Info info) {
				foreach (var comp in protections) {
					if (comp.Id == info.id)
						return;
				}
				protections.Add(new InfoComponent(info));
			}

			public void AddPacker(Info info) {
				foreach (var comp in packers) {
					if (comp.Id == info.id)
						return;
				}
				packers.Add(new InfoComponent(info));
			}
		}

		[Serializable]
		class Info {
			public string desc;
			public string fullId;
			public string id;
			public string name;
			public string path;

			public static Info FromComponent(ConfuserComponent component, string pluginPath) {
				var ret = new Info();
				ret.name = component.Name;
				ret.desc = component.Description;
				ret.id = component.Id;
				ret.fullId = component.FullId;
				ret.path = pluginPath;
				return ret;
			}
		}

		class InfoComponent : ConfuserComponent {
			public readonly Info info;

			public InfoComponent(Info info) {
				this.info = info;
			}

			public override string Name {
				get { return info.name; }
			}

			public override string Description {
				get { return info.desc; }
			}

			public override string Id {
				get { return info.id; }
			}

			public override string FullId {
				get { return info.fullId; }
			}

			protected override void Initialize(ConfuserContext context) {
				throw new NotSupportedException();
			}

			protected override void PopulatePipeline(ProtectionPipeline pipeline) {
				throw new NotSupportedException();
			}
		}
	}
}
```

`ConfuserEx/ConfuserEx.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">

  <Import Project="..\ConfuserEx.Common.props" Condition="Exists('..\ConfuserEx.Common.props')" />

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <UseWPF>true</UseWPF>
    <SignAssembly>true</SignAssembly>
    <AssemblyOriginatorKeyFile>..\ConfuserEx.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>

  <PropertyGroup Label="Assembly Information">
    <Title>ConfuserEx</Title>
    <Description>Graphical Interface for the ConfuserEx open-source protector for .NET assemblies.</Description>
    <ApplicationIcon>ConfuserEx.ico</ApplicationIcon>
  </PropertyGroup>

  <ItemGroup Label="Nuget Dependencies">
    <PackageReference Include="MvvmLightLibs" Version="5.4.1.1" />
    <PackageReference Include="Ookii.Dialogs.Wpf" Version="4.0.0" />
  </ItemGroup>
  
  <ItemGroup Label="Project Dependencies">
    <ProjectReference Include="..\Confuser.Core\Confuser.Core.csproj" />
    <ProjectReference Include="..\Confuser.Protections\Confuser.Protections.csproj" />
    <ProjectReference Include="..\Confuser.Renamer\Confuser.Renamer.csproj" />
  </ItemGroup>
  
  <ItemGroup>
    <Resource Include="Resources\*.png" />
    <Resource Include="ConfuserEx.ico" />
    <Resource Include="Resources\FontAwesome.otf" />
  </ItemGroup>

  <Import Project="..\ConfuserEx.Common.targets" Condition="Exists('..\ConfuserEx.Common.targets')" />

</Project>

```

`ConfuserEx/EmptyToBoolConverter.cs`:

```cs
using System;
using System.Globalization;
using System.Windows.Data;

namespace ConfuserEx {
	[ValueConversion(typeof(string), typeof(bool), ParameterType = typeof(bool))]
	[ValueConversion(typeof(string), typeof(bool), ParameterType = typeof(string))]
	public class EmptyToBoolConverter : IValueConverter {
		public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
			bool stateIfEmpty = true;
			switch (parameter) {
				case bool boolParameter:
					stateIfEmpty = boolParameter;
					break;
				case string strParameter when bool.TryParse(strParameter, out var parsedStrParameter):
					stateIfEmpty = parsedStrParameter;
					break;
			}

			if (value == null) return stateIfEmpty;
			if (!(value is string strValue)) return stateIfEmpty;

			return string.IsNullOrEmpty(strValue) ? stateIfEmpty : !stateIfEmpty;
		}

		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) => 
			throw new NotSupportedException();
	}
}

```

`ConfuserEx/EnumValuesExtension.cs`:

```cs
using System;
using System.Windows.Markup;

namespace ConfuserEx {
	public class EnumValuesExtension : MarkupExtension {
		readonly Type enumType;

		public EnumValuesExtension(Type enumType) {
			this.enumType = enumType;
		}

		public override object ProvideValue(IServiceProvider serviceProvider) {
			return Enum.GetValues(enumType);
		}
	}
}
```

`ConfuserEx/FileDragDrop.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using ConfuserEx.ViewModel;
using GalaSoft.MvvmLight.CommandWpf;

namespace ConfuserEx {
	public class FileDragDrop {
		public static readonly DependencyProperty CommandProperty =
			DependencyProperty.RegisterAttached("Command", typeof(ICommand), typeof(FileDragDrop), new UIPropertyMetadata(null, OnCommandChanged));

		public static ICommand FileCmd = new DragDropCommand(
			data => {
				Debug.Assert(data.Item2.GetDataPresent(DataFormats.FileDrop));
				if (data.Item1 is TextBox) {
					string file = ((string[])data.Item2.GetData(DataFormats.FileDrop))[0];
					Debug.Assert(File.Exists(file));
					((TextBox)data.Item1).Text = file;
				}
				else if (data.Item1 is ListBox) {
					var files = (string[])data.Item2.GetData(DataFormats.FileDrop);
					Debug.Assert(files.All(file => File.Exists(file)));
					var list = (IList<StringItem>)((ListBox)data.Item1).ItemsSource;
					foreach (string file in files)
						list.Add(new StringItem(file));
				}
				else
					throw new NotSupportedException();
			}, data => {
				if (!data.Item2.GetDataPresent(DataFormats.FileDrop))
					return false;
				return ((string[])data.Item2.GetData(DataFormats.FileDrop)).All(file => File.Exists(file));
			});


		public static ICommand DirectoryCmd = new DragDropCommand(
			data => {
				Debug.Assert(data.Item2.GetDataPresent(DataFormats.FileDrop));
				if (data.Item1 is TextBox) {
					string dir = ((string[])data.Item2.GetData(DataFormats.FileDrop))[0];
					Debug.Assert(Directory.Exists(dir));
					((TextBox)data.Item1).Text = dir;
				}
				else if (data.Item1 is ListBox) {
					var dirs = (string[])data.Item2.GetData(DataFormats.FileDrop);
					Debug.Assert(dirs.All(dir => Directory.Exists(dir)));
					var list = (IList<StringItem>)((ListBox)data.Item1).ItemsSource;
					foreach (string dir in dirs)
						list.Add(new StringItem(dir));
				}
				else
					throw new NotSupportedException();
			}, data => {
				if (!data.Item2.GetDataPresent(DataFormats.FileDrop))
					return false;
				return ((string[])data.Item2.GetData(DataFormats.FileDrop)).All(dir => Directory.Exists(dir));
			});

		public static ICommand GetCommand(DependencyObject obj) {
			return (ICommand)obj.GetValue(CommandProperty);
		}

		public static void SetCommand(DependencyObject obj, ICommand value) {
			obj.SetValue(CommandProperty, value);
		}

		static void OnCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
			var elem = (UIElement)d;
			if (e.NewValue != null) {
				elem.AllowDrop = true;
				elem.PreviewDragOver += OnDragOver;
				elem.PreviewDrop += OnDrop;
			}
			else {
				elem.AllowDrop = false;
				elem.PreviewDragOver -= OnDragOver;
				elem.PreviewDrop -= OnDrop;
			}
		}

		static void OnDragOver(object sender, DragEventArgs e) {
			ICommand cmd = GetCommand((DependencyObject)sender);
			e.Effects = DragDropEffects.None;
			if (cmd is DragDropCommand) {
				if (cmd.CanExecute(Tuple.Create((UIElement)sender, e.Data)))
					e.Effects = DragDropEffects.Link;
			}
			else {
				if (cmd.CanExecute(e.Data))
					e.Effects = DragDropEffects.Link;
			}
			e.Handled = true;
		}

		static void OnDrop(object sender, DragEventArgs e) {
			ICommand cmd = GetCommand((DependencyObject)sender);
			if (cmd is DragDropCommand) {
				if (cmd.CanExecute(Tuple.Create((UIElement)sender, e.Data)))
					cmd.Execute(Tuple.Create((UIElement)sender, e.Data));
			}
			else {
				if (cmd.CanExecute(e.Data))
					cmd.Execute(e.Data);
			}
			e.Handled = true;
		}


		class DragDropCommand : RelayCommand<Tuple<UIElement, IDataObject>> {
			public DragDropCommand(Action<Tuple<UIElement, IDataObject>> execute, Func<Tuple<UIElement, IDataObject>, bool> canExecute)
				: base(execute, canExecute) { }
		}
	}
}
```

`ConfuserEx/InvertBoolConverter.cs`:

```cs
using System;
using System.Diagnostics;
using System.Globalization;
using System.Windows.Data;

namespace ConfuserEx {
	internal class InvertBoolConverter : IValueConverter {
		public static readonly InvertBoolConverter Instance = new InvertBoolConverter();
		InvertBoolConverter() { }

		public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
			Debug.Assert(value is bool);
			Debug.Assert(targetType == typeof(bool));
			return !(bool)value;
		}

		public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) {
			throw new NotSupportedException();
		}
	}
}
```

`ConfuserEx/MainWindow.xaml`:

```xaml
<Window x:Class="ConfuserEx.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        Title="{Binding Title}" Width="800" Height="600" Style="{StaticResource DarkWindow}">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <ToolBar Grid.Row="0" Grid.ColumnSpan="2" ToolBarTray.IsLocked="True" ToolBar.OverflowMode="Never"
                 KeyboardNavigation.TabNavigation="Continue">
            <Button Command="{Binding NewProject}">
                <StackPanel Orientation="Horizontal">
                    <Image Source="{StaticResource New}" Margin="0,0,4,0" />
                    <TextBlock Text="New project" VerticalAlignment="Center" />
                </StackPanel>
            </Button>
            <Button Command="{Binding OpenProject}">
                <StackPanel Orientation="Horizontal">
                    <Image Source="{StaticResource Open}" Margin="0,0,4,0" />
                    <TextBlock Text="Open project" VerticalAlignment="Center" />
                </StackPanel>
            </Button>
            <Button Command="{Binding SaveProject}">
                <StackPanel Orientation="Horizontal">
                    <Image Source="{StaticResource Save}" Margin="0,0,4,0" />
                    <TextBlock Text="Save project" VerticalAlignment="Center" />
                </StackPanel>
            </Button>
            <Button ContextMenuService.IsEnabled="False" Click="OpenMenu">
                <StackPanel Orientation="Horizontal">
                    <Image Source="{StaticResource Tools}" Margin="0,0,4,0" />
                    <TextBlock Text="Tools" VerticalAlignment="Center" />
                    <Path Data="M 0.5 4 L 6.5 4 L 3.5 9 Z" Fill="{StaticResource Foreground}" Margin="4,0,0,0"
                          VerticalAlignment="Center" />
                </StackPanel>
                <Button.ContextMenu>
                    <ContextMenu
                        DataContext="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Self}}">
                        <MenuItem Header="Stack Trace Decoder" Command="{Binding Decode}">
                            <MenuItem.Icon>
                                <Image Source="{StaticResource Decode}" />
                            </MenuItem.Icon>
                        </MenuItem>
                    </ContextMenu>
                </Button.ContextMenu>
            </Button>
        </ToolBar>
        <TabControl Grid.Row="1" Grid.ColumnSpan="2" Margin="10" ItemsSource="{Binding Tabs}" Padding="5"
                    SelectedIndex="0" local:Skin.TabsDisabled="{Binding NavigationDisabled}">
            <TabControl.ItemContainerStyle>
                <Style TargetType="{x:Type TabItem}" BasedOn="{StaticResource {x:Type TabItem}}">
                    <Setter Property="Width" Value="80" />
                    <Setter Property="Header" Value="{Binding Header}" />
                </Style>
            </TabControl.ItemContainerStyle>
        </TabControl>
    </Grid>
</Window>
```

`ConfuserEx/MainWindow.xaml.cs`:

```cs
using System;
using System.ComponentModel;
using System.IO;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Xml;
using Confuser.Core.Project;
using ConfuserEx.ViewModel;

namespace ConfuserEx {
	public partial class MainWindow : Window {
		public MainWindow() {
			InitializeComponent();

			var app = new AppVM();
			app.Project = new ProjectVM(new ConfuserProject(), null);
			app.FileName = "Unnamed.crproj";

			app.Tabs.Add(new ProjectTabVM(app));
			app.Tabs.Add(new SettingsTabVM(app));
			app.Tabs.Add(new ProtectTabVM(app));
			app.Tabs.Add(new AboutTabVM(app));

			LoadProj(app);

			DataContext = app;
		}

		void OpenMenu(object sender, RoutedEventArgs e) {
			var btn = (Button)sender;
			ContextMenu menu = btn.ContextMenu;
			menu.PlacementTarget = btn;
			menu.Placement = PlacementMode.MousePoint;
			menu.IsOpen = true;
		}

		void LoadProj(AppVM app) {
			var args = Environment.GetCommandLineArgs();
			if (args.Length != 2 || !File.Exists(args[1]))
				return;

			string fileName = Path.GetFullPath(args[1]);
			try {
				var xmlDoc = new XmlDocument();
				xmlDoc.Load(fileName);
				var proj = new ConfuserProject();
				proj.Load(xmlDoc);
				app.Project = new ProjectVM(proj, fileName);
				app.FileName = fileName;
			}
			catch {
				MessageBox.Show("Invalid project!", "ConfuserEx", MessageBoxButton.OK, MessageBoxImage.Error);
			}
		}

		protected override void OnClosing(CancelEventArgs e) {
			base.OnClosing(e);
			e.Cancel = !((AppVM)DataContext).OnWindowClosing();
		}
	}
}
```

`ConfuserEx/Resources/CREDITS`:

```
Icons adapted from http://flaticons.net
```

`ConfuserEx/Skin.cs`:

```cs
using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;

namespace ConfuserEx {
	public class Skin {
		public static readonly DependencyProperty EmptyPromptProperty =
			DependencyProperty.RegisterAttached("EmptyPrompt", typeof(string), typeof(Skin), new UIPropertyMetadata(null));

		public static readonly DependencyProperty TabsDisabledProperty =
			DependencyProperty.RegisterAttached("TabsDisabled", typeof(bool), typeof(Skin), new UIPropertyMetadata(false));

		public static readonly DependencyProperty FocusOverlayProperty =
			DependencyProperty.RegisterAttached("FocusOverlay", typeof(bool), typeof(Skin), new UIPropertyMetadata(true));

		public static readonly DependencyProperty RTBDocumentProperty =
			DependencyProperty.RegisterAttached("RTBDocument", typeof(FlowDocument), typeof(Skin), new FrameworkPropertyMetadata(null, OnRTBDocumentChanged));

		public static string GetEmptyPrompt(DependencyObject obj) {
			return (string)obj.GetValue(EmptyPromptProperty);
		}

		public static void SetEmptyPrompt(DependencyObject obj, string value) {
			obj.SetValue(EmptyPromptProperty, value);
		}

		public static bool GetFocusOverlay(DependencyObject obj) {
			return (bool)obj.GetValue(FocusOverlayProperty);
		}

		public static void SetFocusOverlay(DependencyObject obj, bool value) {
			obj.SetValue(FocusOverlayProperty, value);
		}

		public static bool GetTabsDisabled(DependencyObject obj) {
			return (bool)obj.GetValue(TabsDisabledProperty);
		}

		public static void SetTabsDisabled(DependencyObject obj, bool value) {
			obj.SetValue(TabsDisabledProperty, value);
		}

		public static void OnRTBDocumentChanged(DependencyObject d, DependencyPropertyChangedEventArgs dpe) {
			var rtb = (RichTextBox)d;
			if (dpe.NewValue != null) {
				rtb.Document = (FlowDocument)dpe.NewValue;
				rtb.TextChanged += (sender, e) => rtb.ScrollToEnd();
			}
			else
				rtb.Document = new FlowDocument();
		}

		public static FlowDocument GetRTBDocument(DependencyObject obj) {
			return (FlowDocument)obj.GetValue(RTBDocumentProperty);
		}

		public static void SetRTBDocument(DependencyObject obj, FlowDocument value) {
			obj.SetValue(RTBDocumentProperty, value);
		}
	}
}
```

`ConfuserEx/Skin.xaml`:

```xaml
<ResourceDictionary
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="clr-namespace:ConfuserEx">

    <DrawingBrush x:Key="WindowBackground" TileMode="Tile" Viewport="0,0,10,10" ViewportUnits="Absolute">
        <DrawingBrush.Drawing>
            <GeometryDrawing>
                <GeometryDrawing.Brush>
                    <LinearGradientBrush SpreadMethod="Repeat" StartPoint="0,0" EndPoint="1,1">
                        <LinearGradientBrush.RelativeTransform>
                            <ScaleTransform ScaleX="0.5" ScaleY="0.5" />
                        </LinearGradientBrush.RelativeTransform>
                        <GradientStop Offset="0" Color="#101010" />
                        <GradientStop Offset="0.5" Color="#101010" />
                        <GradientStop Offset="0.5" Color="#202020" />
                        <GradientStop Offset="1" Color="#202020" />
                    </LinearGradientBrush>
                </GeometryDrawing.Brush>
                <GeometryDrawing.Geometry>
                    <RectangleGeometry Rect="0,0,10,10" />
                </GeometryDrawing.Geometry>
            </GeometryDrawing>
        </DrawingBrush.Drawing>
    </DrawingBrush>

    <SolidColorBrush x:Key="ControlBackground" Color="#ff202020" />
    <SolidColorBrush x:Key="LightBackground" Color="#ff282828" />
    <SolidColorBrush x:Key="Border" Color="#ffa0a0a0" />
    <SolidColorBrush x:Key="Foreground" Color="#fff0f0f0" />

    <SolidColorBrush x:Key="DisabledBackground" Color="#ff505050" />
    <SolidColorBrush x:Key="DisabledForeground" Color="#ff808080" />

    <SolidColorBrush x:Key="SelectedBackground" Color="#ffa0a0a0" />
    <SolidColorBrush x:Key="SelectedForeground" Color="#ff202020" />

    <SolidColorBrush x:Key="HighlightBackground" Color="#ff404040" />
    <SolidColorBrush x:Key="DownBackground" Color="#ff303030" />

    <SolidColorBrush x:Key="HighlightOverlay" Color="#20ffffff" />

    <ControlTemplate x:Key="WindowTemplateKey" TargetType="{x:Type Window}">
        <Border BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}"
                Background="{TemplateBinding Background}">
            <Grid>
                <AdornerDecorator>
                    <ContentPresenter />
                </AdornerDecorator>
                <ResizeGrip x:Name="WindowResizeGrip" HorizontalAlignment="Right" IsTabStop="false"
                            Visibility="Collapsed" VerticalAlignment="Bottom" />
            </Grid>
        </Border>
        <ControlTemplate.Triggers>
            <MultiTrigger>
                <MultiTrigger.Conditions>
                    <Condition Property="ResizeMode" Value="CanResizeWithGrip" />
                    <Condition Property="WindowState" Value="Normal" />
                </MultiTrigger.Conditions>
                <Setter Property="Visibility" TargetName="WindowResizeGrip" Value="Visible" />
            </MultiTrigger>
        </ControlTemplate.Triggers>
    </ControlTemplate>

    <Style x:Key="DarkWindow" TargetType="{x:Type Window}">
        <Setter Property="Background" Value="{StaticResource WindowBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="FontFamily" Value="Open Sans" />
        <Setter Property="FontSize" Value="12" />
        <Setter Property="UseLayoutRounding" Value="True" />
        <Setter Property="TextOptions.TextFormattingMode" Value="Ideal" />
        <Setter Property="TextOptions.TextRenderingMode" Value="Grayscale" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Window}">
                    <Border BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}">
                        <AdornerDecorator>
                            <ContentPresenter />
                        </AdornerDecorator>
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="ResizeMode" Value="CanResizeWithGrip">
                <Setter Property="Template" Value="{StaticResource WindowTemplateKey}" />
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style TargetType="{x:Type Label}">
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="HorizontalContentAlignment" Value="Left" />
        <Setter Property="VerticalContentAlignment" Value="Top" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Label}">
                    <Border Padding="{TemplateBinding Padding}">
                        <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}"
                                          RecognizesAccessKey="True" />
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="ToolBarVerticalOverflowButtonStyle" TargetType="{x:Type ToggleButton}">
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ToggleButton}">
                    <Border x:Name="Bd" Background="{TemplateBinding Background}" SnapsToDevicePixels="true"
                            BorderThickness="1">
                        <Canvas HorizontalAlignment="Right" Height="6" Margin="2,7,2,2" SnapsToDevicePixels="true"
                                VerticalAlignment="Bottom" Width="7">
                            <Path Data="M 1.5 1 L 1.5 6" Stroke="White" />
                            <Path Data="M 0.5 0 L 0.5 5" Stroke="{TemplateBinding Foreground}" />
                            <Path Data="M 3.5 0.5 L 7 3.5 L 4 6.5 Z" Fill="White" />
                            <Path Data="M 3 -0.5 L 6 2.5 L 3 5.5 Z" Fill="{TemplateBinding Foreground}" />
                        </Canvas>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsKeyboardFocused" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="ToolBarHorizontalOverflowButtonStyle" TargetType="{x:Type ToggleButton}">
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ToggleButton}">
                    <Border x:Name="Bd" Background="{TemplateBinding Background}" CornerRadius="0,3,3,0"
                            SnapsToDevicePixels="true">
                        <Canvas HorizontalAlignment="Right" Height="7" Margin="7,2,2,2" SnapsToDevicePixels="true"
                                VerticalAlignment="Bottom" Width="6">
                            <Path Data="M 1.5 1.5 L 6 1.5" Stroke="{TemplateBinding Foreground}" />
                            <Path Data="M 0.5 4 L 6.5 4 L 3.5 7 Z" Fill="{TemplateBinding Foreground}" />
                        </Canvas>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsKeyboardFocused" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="ToolBarThumbStyle" TargetType="{x:Type Thumb}">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Thumb}">
                    <Border Background="Transparent" Padding="{TemplateBinding Padding}" SnapsToDevicePixels="True">
                        <Rectangle>
                            <Rectangle.Fill>
                                <DrawingBrush TileMode="Tile" Viewbox="0,0,4,4" Viewport="0,0,4,4"
                                              ViewportUnits="Absolute" ViewboxUnits="Absolute">
                                    <DrawingBrush.Drawing>
                                        <DrawingGroup>
                                            <GeometryDrawing Brush="{StaticResource Foreground}"
                                                             Geometry="M 0 0 L 0 2 L 2 2 L 2 0 z" />
                                        </DrawingGroup>
                                    </DrawingBrush.Drawing>
                                </DrawingBrush>
                            </Rectangle.Fill>
                        </Rectangle>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Cursor" Value="SizeAll" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type ToolBar}">
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="0,0,0,1" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ToolBar}">
                    <Grid x:Name="Grid" SnapsToDevicePixels="true">
                        <Border x:Name="MainPanelBorder" BorderBrush="{TemplateBinding BorderBrush}"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                Background="{TemplateBinding Background}" Padding="{TemplateBinding Padding}">
                            <DockPanel KeyboardNavigation.TabIndex="1" KeyboardNavigation.TabNavigation="Local">
                                <Thumb x:Name="ToolBarThumb" Margin="-3,-1,0,0" Padding="6,5,1,6"
                                       Style="{StaticResource ToolBarThumbStyle}" Width="10" />
                                <ContentPresenter x:Name="ToolBarHeader" ContentSource="Header"
                                                  HorizontalAlignment="Center" Margin="4,0,4,0"
                                                  SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                                  VerticalAlignment="Center" />
                                <ToolBarPanel x:Name="PART_ToolBarPanel" IsItemsHost="true" Margin="2"
                                              SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                                <Grid x:Name="OverflowGrid" DockPanel.Dock="Right" Margin="2,2,3,2">
                                    <ToggleButton x:Name="OverflowButton" ClickMode="Press" FocusVisualStyle="{x:Null}"
                                                  IsChecked="{Binding IsOverflowOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                                                  IsEnabled="{TemplateBinding HasOverflowItems}"
                                                  Style="{StaticResource ToolBarHorizontalOverflowButtonStyle}" />
                                    <Popup x:Name="OverflowPopup" AllowsTransparency="true" Focusable="false"
                                           IsOpen="{Binding IsOverflowOpen, RelativeSource={RelativeSource TemplatedParent}}"
                                           PopupAnimation="{DynamicResource {x:Static SystemParameters.ComboBoxPopupAnimationKey}}"
                                           Placement="Bottom" StaysOpen="false">
                                        <Border BorderBrush="{StaticResource Border}" BorderThickness="1"
                                                Background="{StaticResource LightBackground}">
                                            <ToolBarOverflowPanel x:Name="PART_ToolBarOverflowPanel"
                                                                  KeyboardNavigation.DirectionalNavigation="Cycle"
                                                                  FocusVisualStyle="{x:Null}" Focusable="true"
                                                                  Margin="2"
                                                                  SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                                                  KeyboardNavigation.TabNavigation="Cycle"
                                                                  WrapWidth="200" />
                                        </Border>
                                    </Popup>
                                </Grid>
                            </DockPanel>
                        </Border>
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsOverflowOpen" Value="true">
                            <Setter Property="IsEnabled" TargetName="ToolBarThumb" Value="false" />
                        </Trigger>
                        <Trigger Property="Header" Value="{x:Null}">
                            <Setter Property="Visibility" TargetName="ToolBarHeader" Value="Collapsed" />
                        </Trigger>
                        <Trigger Property="ToolBarTray.IsLocked" Value="true">
                            <Setter Property="Visibility" TargetName="ToolBarThumb" Value="Collapsed" />
                        </Trigger>
                        <Trigger Property="ToolBar.OverflowMode" Value="Never">
                            <Setter Property="Visibility" TargetName="OverflowGrid" Value="Collapsed" />
                        </Trigger>
                        <Trigger Property="Orientation" Value="Vertical">
                            <Setter Property="Margin" TargetName="Grid" Value="1,3,1,1" />
                            <Setter Property="Style" TargetName="OverflowButton"
                                    Value="{StaticResource ToolBarVerticalOverflowButtonStyle}" />
                            <Setter Property="Height" TargetName="ToolBarThumb" Value="10" />
                            <Setter Property="Width" TargetName="ToolBarThumb" Value="Auto" />
                            <Setter Property="Margin" TargetName="ToolBarThumb" Value="-1,-3,0,0" />
                            <Setter Property="Padding" TargetName="ToolBarThumb" Value="5,6,6,1" />
                            <Setter Property="Margin" TargetName="ToolBarHeader" Value="0,0,0,4" />
                            <Setter Property="Margin" TargetName="PART_ToolBarPanel" Value="1,0,2,2" />
                            <Setter Property="DockPanel.Dock" TargetName="ToolBarThumb" Value="Top" />
                            <Setter Property="DockPanel.Dock" TargetName="ToolBarHeader" Value="Top" />
                            <Setter Property="HorizontalAlignment" TargetName="OverflowGrid" Value="Stretch" />
                            <Setter Property="VerticalAlignment" TargetName="OverflowGrid" Value="Bottom" />
                            <Setter Property="Placement" TargetName="OverflowPopup" Value="Right" />
                            <Setter Property="Margin" TargetName="MainPanelBorder" Value="0,0,0,11" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="{x:Static ToolBar.ButtonStyleKey}" TargetType="{x:Type Button}">
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Padding" Value="4" />
        <Setter Property="Margin" Value="2" />
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="BorderBrush" Value="Transparent" />
        <Setter Property="HorizontalAlignment" Value="Center" />
        <Setter Property="VerticalAlignment" Value="Center" />
        <Setter Property="HorizontalContentAlignment" Value="Center" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Button}">
                    <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}" Padding="{TemplateBinding Padding}"
                            SnapsToDevicePixels="true">
                        <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsKeyboardFocused" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource HighlightBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsPressed" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource DownBackground}" />
                            <Setter Property="BorderBrush" TargetName="Bd" Value="{StaticResource Border}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type TabControl}">
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Margin" Value="0" />
        <Setter Property="Padding" Value="1" />
        <Setter Property="MinWidth" Value="10" />
        <Setter Property="MinHeight" Value="10" />
        <Setter Property="HorizontalContentAlignment" Value="Center" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type TabControl}">
                    <Grid ClipToBounds="true" SnapsToDevicePixels="true" KeyboardNavigation.TabNavigation="Local">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition x:Name="ColumnDefinition0" />
                            <ColumnDefinition x:Name="ColumnDefinition1" Width="0" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition x:Name="RowDefinition0" Height="Auto" />
                            <RowDefinition x:Name="RowDefinition1" Height="*" />
                        </Grid.RowDefinitions>
                        <TabPanel x:Name="HeaderPanel" Background="Transparent" Grid.Column="0" IsItemsHost="true"
                                  Margin="0,2,2,-1" Grid.Row="0" KeyboardNavigation.TabIndex="1" Panel.ZIndex="1"
                                  IsEnabled="{Binding Path=(local:Skin.TabsDisabled), RelativeSource={RelativeSource TemplatedParent}, Converter={x:Static local:InvertBoolConverter.Instance}}" />
                        <Grid x:Name="ContentPanel" Grid.Column="0"
                              KeyboardNavigation.DirectionalNavigation="Contained" Grid.Row="1"
                              KeyboardNavigation.TabIndex="2" KeyboardNavigation.TabNavigation="Local">
                            <Border BorderBrush="{TemplateBinding BorderBrush}"
                                    BorderThickness="{TemplateBinding BorderThickness}"
                                    Background="{TemplateBinding Background}"
                                    Padding="{TemplateBinding Padding}">
                                <ContentPresenter x:Name="PART_SelectedContentHost" ContentSource="SelectedContent"
                                                  Margin="2,2,2,2"
                                                  SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                            </Border>
                        </Grid>
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="TabStripPlacement" Value="Bottom">
                            <Setter Property="Grid.Row" TargetName="HeaderPanel" Value="1" />
                            <Setter Property="Grid.Row" TargetName="ContentPanel" Value="0" />
                            <Setter Property="Height" TargetName="RowDefinition0" Value="*" />
                            <Setter Property="Height" TargetName="RowDefinition1" Value="Auto" />
                            <Setter Property="Margin" TargetName="HeaderPanel" Value="2,0,2,2" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Left">
                            <Setter Property="Grid.Row" TargetName="HeaderPanel" Value="0" />
                            <Setter Property="Grid.Row" TargetName="ContentPanel" Value="0" />
                            <Setter Property="Grid.Column" TargetName="HeaderPanel" Value="0" />
                            <Setter Property="Grid.Column" TargetName="ContentPanel" Value="1" />
                            <Setter Property="Width" TargetName="ColumnDefinition0" Value="Auto" />
                            <Setter Property="Width" TargetName="ColumnDefinition1" Value="*" />
                            <Setter Property="Height" TargetName="RowDefinition0" Value="*" />
                            <Setter Property="Height" TargetName="RowDefinition1" Value="0" />
                            <Setter Property="Margin" TargetName="HeaderPanel" Value="2,2,0,2" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Right">
                            <Setter Property="Grid.Row" TargetName="HeaderPanel" Value="0" />
                            <Setter Property="Grid.Row" TargetName="ContentPanel" Value="0" />
                            <Setter Property="Grid.Column" TargetName="HeaderPanel" Value="1" />
                            <Setter Property="Grid.Column" TargetName="ContentPanel" Value="0" />
                            <Setter Property="Width" TargetName="ColumnDefinition0" Value="*" />
                            <Setter Property="Width" TargetName="ColumnDefinition1" Value="Auto" />
                            <Setter Property="Height" TargetName="RowDefinition0" Value="*" />
                            <Setter Property="Height" TargetName="RowDefinition1" Value="0" />
                            <Setter Property="Margin" TargetName="HeaderPanel" Value="0,2,2,2" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="TabItemFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Rectangle Margin="4,4,4,2" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                               StrokeThickness="1"
                               StrokeDashArray="1 2" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type TabItem}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource TabItemFocusVisual}" />
        <Setter Property="Padding" Value="15,6,15,6" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="HorizontalContentAlignment" Value="Stretch" />
        <Setter Property="VerticalContentAlignment" Value="Stretch" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type TabItem}">
                    <Grid x:Name="Grid" Margin="0,0,-1,0">
                        <Border x:Name="Border" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="1,1,1,0"
                                Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
                            <ContentPresenter ContentSource="Header"
                                              HorizontalAlignment="{Binding HorizontalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}"
                                              Margin="{TemplateBinding Padding}" RecognizesAccessKey="True"
                                              SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                              VerticalAlignment="{Binding VerticalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}" />
                        </Border>
                        <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0" />
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsSelected" Value="true">
                            <Setter Property="Panel.ZIndex" Value="1" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Bottom">
                            <Setter Property="BorderThickness" TargetName="Border" Value="1,0,1,1" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Left">
                            <Setter Property="BorderThickness" TargetName="Border" Value="1,1,0,1" />
                            <Setter Property="Margin" TargetName="Grid" Value="0,0,0,-1" />
                        </Trigger>
                        <Trigger Property="TabStripPlacement" Value="Right">
                            <Setter Property="BorderThickness" TargetName="Border" Value="0,1,1,1" />
                            <Setter Property="Margin" TargetName="Grid" Value="0,0,0,-1" />
                        </Trigger>
                        <Trigger Property="IsSelected" Value="false">
                            <Setter Property="Background" TargetName="Border" Value="Transparent" />
                        </Trigger>
                        <MultiTrigger>
                            <MultiTrigger.Conditions>
                                <Condition Property="IsMouseOver" Value="false" />
                                <Condition Property="IsSelected" Value="false" />
                            </MultiTrigger.Conditions>
                            <Setter Property="BorderBrush" TargetName="Border" Value="Transparent" />
                        </MultiTrigger>
                        <MultiTrigger>
                            <MultiTrigger.Conditions>
                                <Condition Property="IsMouseOver" Value="true" />
                                <Condition Property="IsSelected" Value="false" />
                            </MultiTrigger.Conditions>
                            <Setter Property="Opacity" TargetName="Overlay" Value="1" />
                        </MultiTrigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <PopupAnimation x:Key="{x:Static SystemParameters.MenuPopupAnimationKey}">None</PopupAnimation>

    <Style TargetType="{x:Type ContextMenu}">
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ContextMenu}">
                    <Border Background="Transparent" Padding="5">
                        <Border.Effect>
                            <DropShadowEffect BlurRadius="4" Opacity="0.8" ShadowDepth="1" />
                        </Border.Effect>
                        <Border BorderBrush="{TemplateBinding BorderBrush}"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                Background="{TemplateBinding Background}">
                            <ScrollViewer CanContentScroll="True"
                                          Style="{DynamicResource {ComponentResourceKey ResourceId=MenuScrollViewer, TypeInTargetAssembly={x:Type FrameworkElement}}}">
                                <ItemsPresenter KeyboardNavigation.DirectionalNavigation="Cycle"
                                                Margin="{TemplateBinding Padding}"
                                                SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                            </ScrollViewer>
                        </Border>
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <ControlTemplate x:Key="{x:Static MenuItem.SubmenuItemTemplateKey}" TargetType="{x:Type MenuItem}">
        <Border x:Name="Border" Padding="{TemplateBinding Padding}" Background="Transparent">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto" SharedSizeGroup="Icon" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="Auto" SharedSizeGroup="Shortcut" />
                    <ColumnDefinition Width="13" />
                </Grid.ColumnDefinitions>
                <ContentPresenter x:Name="Icon" Margin="6,0,6,0" VerticalAlignment="Center" ContentSource="Icon" />
                <Border x:Name="Check" Width="13" Height="13" Visibility="Collapsed" Margin="6,0,6,0"
                        Background="Transparent">
                    <Path x:Name="CheckMark" Width="7" Height="7" Visibility="Hidden" SnapsToDevicePixels="False"
                          Stroke="{StaticResource Foreground}" StrokeThickness="2" Data="M 0 0 L 7 7 M 0 7 L 7 0" />
                </Border>
                <ContentPresenter x:Name="HeaderHost" Grid.Column="1" ContentSource="Header" VerticalAlignment="Center"
                                  RecognizesAccessKey="True" />
                <TextBlock x:Name="InputGestureText" Grid.Column="2" Text="{TemplateBinding InputGestureText}"
                           VerticalAlignment="Center" Margin="10,0,0,0" />
            </Grid>
        </Border>
        <ControlTemplate.Triggers>
            <Trigger Property="Icon" Value="{x:Null}">
                <Setter TargetName="Icon" Property="Visibility" Value="Hidden" />
            </Trigger>
            <Trigger Property="IsChecked" Value="true">
                <Setter TargetName="CheckMark" Property="Visibility" Value="Visible" />
            </Trigger>
            <Trigger Property="IsCheckable" Value="true">
                <Setter TargetName="Check" Property="Visibility" Value="Visible" />
                <Setter TargetName="Icon" Property="Visibility" Value="Hidden" />
            </Trigger>
            <Trigger Property="IsHighlighted" Value="true">
                <Setter TargetName="Border" Property="Background" Value="{StaticResource HighlightBackground}" />
            </Trigger>
            <Trigger Property="IsEnabled" Value="false">
                <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
            </Trigger>
        </ControlTemplate.Triggers>
    </ControlTemplate>

    <Style x:Key="{x:Type MenuItem}" TargetType="{x:Type MenuItem}">
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Padding" Value="5,4,5,4" />
        <Style.Triggers>
            <Trigger Property="Role" Value="SubmenuItem">
                <Setter Property="Template" Value="{StaticResource {x:Static MenuItem.SubmenuItemTemplateKey}}" />
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style x:Key="{x:Static MenuItem.SeparatorStyleKey}" TargetType="{x:Type Separator}">
        <Setter Property="Background" Value="{StaticResource Border}" />
        <Setter Property="Margin" Value="2" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Separator}">
                    <Border
                        BorderBrush="{TemplateBinding BorderBrush}"
                        BorderThickness="{TemplateBinding BorderThickness}"
                        Background="{TemplateBinding Background}"
                        Height="1"
                        SnapsToDevicePixels="true" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type Separator}">
        <Setter Property="Background" Value="{StaticResource Border}" />
        <Setter Property="Margin" Value="2" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Separator}">
                    <Border
                        BorderBrush="{TemplateBinding BorderBrush}"
                        BorderThickness="{TemplateBinding BorderThickness}"
                        Background="{TemplateBinding Background}"
                        Height="1"
                        SnapsToDevicePixels="true" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="ButtonFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Border>
                        <Rectangle Margin="4" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                                   StrokeThickness="1" StrokeDashArray="1 2" />
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type Button}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource ButtonFocusVisual}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="Padding" Value="0" />
        <Setter Property="HorizontalContentAlignment" Value="Center" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Button}">
                    <Border x:Name="ContentContainer" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="1"
                            Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
                        <Grid>
                            <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                              Margin="{TemplateBinding Padding}" RecognizesAccessKey="True"
                                              SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                              VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                            <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsDefaulted" Value="true">
                            <Setter Property="BorderThickness" TargetName="ContentContainer" Value="2" />
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Opacity" TargetName="Overlay" Value="1" />
                        </Trigger>
                        <Trigger Property="IsPressed" Value="true">
                            <Setter Property="Opacity" TargetName="Overlay" Value="0.7" />
                        </Trigger>
                        <Trigger Property="ToggleButton.IsChecked" Value="true">
                            <Setter Property="Opacity" TargetName="Overlay" Value="1" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type TextBox}">
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Padding" Value="1" />
        <Setter Property="KeyboardNavigation.TabNavigation" Value="None" />
        <Setter Property="HorizontalContentAlignment" Value="Left" />
        <Setter Property="FocusVisualStyle" Value="{x:Null}" />
        <Setter Property="AllowDrop" Value="true" />
        <Setter Property="ScrollViewer.PanningMode" Value="VerticalFirst" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="SelectionBrush" Value="{StaticResource Foreground}" />
        <Setter Property="SelectionOpacity" Value="0.2" />
        <Setter Property="CaretBrush" Value="{StaticResource Border}" />
        <Setter Property="ContextMenu">
            <Setter.Value>
                <ContextMenu>
                    <MenuItem Header="Undo" Command="ApplicationCommands.Undo" />
                    <MenuItem Header="Redo" Command="ApplicationCommands.Redo" />
                    <Separator />
                    <MenuItem Header="Cut" Command="ApplicationCommands.Cut" />
                    <MenuItem Header="Copy" Command="ApplicationCommands.Copy" />
                    <MenuItem Header="Paste" Command="ApplicationCommands.Paste" />
                </ContextMenu>
            </Setter.Value>
        </Setter>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type TextBox}">
                    <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}">
                        <Grid>
                            <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0" />
                            <ScrollViewer x:Name="PART_ContentHost" />
                            <Label x:Name="Prompt" Opacity="0"
                                   Content="{Binding Path=(local:Skin.EmptyPrompt), RelativeSource={RelativeSource TemplatedParent}}"
                                   IsHitTestVisible="False"
                                   VerticalContentAlignment="{TemplateBinding VerticalContentAlignment}"
                                   HorizontalContentAlignment="{TemplateBinding HorizontalContentAlignment}" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource DisabledBackground}" />
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                        <MultiTrigger>
                            <MultiTrigger.Conditions>
                                <Condition Property="IsFocused" Value="true" />
                                <Condition Property="local:Skin.FocusOverlay" Value="true" />
                            </MultiTrigger.Conditions>
                            <Setter Property="Opacity" TargetName="Overlay" Value="0.5" />
                        </MultiTrigger>
                        <Trigger Property="Text" Value="">
                            <Setter Property="Opacity" TargetName="Prompt" Value="0.5" />
                        </Trigger>
                        <Trigger Property="Text" Value="{x:Null}">
                            <Setter Property="Opacity" TargetName="Prompt" Value="0.5" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type PasswordBox}">
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Padding" Value="1" />
        <Setter Property="KeyboardNavigation.TabNavigation" Value="None" />
        <Setter Property="HorizontalContentAlignment" Value="Left" />
        <Setter Property="FocusVisualStyle" Value="{x:Null}" />
        <Setter Property="AllowDrop" Value="true" />
        <Setter Property="ScrollViewer.PanningMode" Value="VerticalFirst" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="SelectionBrush" Value="{StaticResource Foreground}" />
        <Setter Property="SelectionOpacity" Value="0.2" />
        <Setter Property="CaretBrush" Value="{StaticResource Border}" />
        <Setter Property="PasswordChar" Value="●" />
        <Setter Property="ContextMenu">
            <Setter.Value>
                <ContextMenu>
                    <MenuItem Header="Paste" Command="ApplicationCommands.Paste" />
                </ContextMenu>
            </Setter.Value>
        </Setter>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type PasswordBox}">
                    <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}">
                        <Grid>
                            <ScrollViewer x:Name="PART_ContentHost" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource DisabledBackground}" />
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type RichTextBox}">
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Padding" Value="1" />
        <Setter Property="KeyboardNavigation.TabNavigation" Value="None" />
        <Setter Property="HorizontalContentAlignment" Value="Left" />
        <Setter Property="FocusVisualStyle" Value="{x:Null}" />
        <Setter Property="AllowDrop" Value="true" />
        <Setter Property="ScrollViewer.PanningMode" Value="VerticalFirst" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="SelectionBrush" Value="{StaticResource Foreground}" />
        <Setter Property="SelectionOpacity" Value="0.2" />
        <Setter Property="CaretBrush" Value="{StaticResource Border}" />
        <Setter Property="ContextMenu">
            <Setter.Value>
                <ContextMenu>
                    <MenuItem Header="Undo" Command="ApplicationCommands.Undo" />
                    <MenuItem Header="Redo" Command="ApplicationCommands.Redo" />
                    <Separator />
                    <MenuItem Header="Cut" Command="ApplicationCommands.Cut" />
                    <MenuItem Header="Copy" Command="ApplicationCommands.Copy" />
                    <MenuItem Header="Paste" Command="ApplicationCommands.Paste" />
                </ContextMenu>
            </Setter.Value>
        </Setter>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RichTextBox}">
                    <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}">
                        <Grid>
                            <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0" />
                            <ScrollViewer x:Name="PART_ContentHost" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource DisabledBackground}" />
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                        <Trigger Property="IsFocused" Value="true">
                            <Setter Property="Opacity" TargetName="Overlay" Value="0.5" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="CheckRadioFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Rectangle Margin="14,0,0,0" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                               StrokeThickness="1" StrokeDashArray="1 2" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="EmptyCheckBoxFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Rectangle Margin="1" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                               StrokeThickness="1" StrokeDashArray="1 2" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type CheckBox}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource CheckRadioFocusVisual}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource LightBackground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Padding" Value="5,0,0,0" />
        <Setter Property="FocusVisualStyle" Value="{StaticResource EmptyCheckBoxFocusVisual}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type CheckBox}">
                    <BulletDecorator Background="Transparent" SnapsToDevicePixels="true">
                        <BulletDecorator.Bullet>
                            <Border x:Name="CheckMarkBorder" BorderBrush="{TemplateBinding BorderBrush}"
                                    BorderThickness="{TemplateBinding BorderThickness}"
                                    Background="{TemplateBinding Background}">
                                <Rectangle x:Name="CheckMark" Fill="{TemplateBinding Foreground}"
                                           FlowDirection="LeftToRight" Height="9" Margin="2" Width="9" />
                            </Border>
                        </BulletDecorator.Bullet>
                        <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          Margin="{TemplateBinding Padding}" RecognizesAccessKey="True"
                                          SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                    </BulletDecorator>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsChecked" Value="false">
                            <Setter Property="Visibility" TargetName="CheckMark" Value="Hidden" />
                        </Trigger>
                        <Trigger Property="IsChecked" Value="{x:Null}">
                            <Setter Property="Fill" TargetName="CheckMark" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="CheckMarkBorder"
                                    Value="{StaticResource HighlightBackground}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Background" TargetName="CheckMarkBorder"
                                    Value="{StaticResource DisabledBackground}" />
                            <Setter Property="Fill" TargetName="CheckMark" Value="{StaticResource DisabledForeground}" />
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type RadioButton}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource CheckRadioFocusVisual}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource LightBackground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Padding" Value="5,0,0,0" />
        <Setter Property="FocusVisualStyle" Value="{StaticResource EmptyCheckBoxFocusVisual}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RadioButton}">
                    <BulletDecorator Background="Transparent" SnapsToDevicePixels="true">
                        <BulletDecorator.Bullet>
                            <Grid>
                                <Ellipse x:Name="CheckMarkBorder" Stroke="{TemplateBinding BorderBrush}"
                                        StrokeThickness="{TemplateBinding BorderThickness}"
                                        Fill="{TemplateBinding Background}" />
                                <Ellipse x:Name="CheckMark" Fill="{TemplateBinding Foreground}"
                                               FlowDirection="LeftToRight" Height="7" Margin="3" Width="7" />
                            </Grid>
                        </BulletDecorator.Bullet>
                        <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          Margin="{TemplateBinding Padding}" RecognizesAccessKey="True"
                                          SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                    </BulletDecorator>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsChecked" Value="false">
                            <Setter Property="Visibility" TargetName="CheckMark" Value="Hidden" />
                        </Trigger>
                        <Trigger Property="IsChecked" Value="{x:Null}">
                            <Setter Property="Fill" TargetName="CheckMark" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Fill" TargetName="CheckMarkBorder"
                                    Value="{StaticResource HighlightBackground}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Fill" TargetName="CheckMarkBorder"
                                    Value="{StaticResource DisabledBackground}" />
                            <Setter Property="Fill" TargetName="CheckMark" Value="{StaticResource DisabledForeground}" />
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type ListBox}">
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="ScrollViewer.HorizontalScrollBarVisibility" Value="Auto" />
        <Setter Property="ScrollViewer.VerticalScrollBarVisibility" Value="Auto" />
        <Setter Property="ScrollViewer.CanContentScroll" Value="true" />
        <Setter Property="ScrollViewer.PanningMode" Value="Both" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ListBox}">
                    <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
                        <Grid>
                            <ScrollViewer Focusable="false" Padding="{TemplateBinding Padding}">
                                <ItemsPresenter SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                            </ScrollViewer>
                            <Label x:Name="Prompt" Opacity="0"
                                   Content="{Binding Path=(local:Skin.EmptyPrompt), RelativeSource={RelativeSource TemplatedParent}}"
                                   IsHitTestVisible="False" VerticalContentAlignment="Center"
                                   HorizontalContentAlignment="Center" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Background" TargetName="Bd"
                                    Value="{DynamicResource {x:Static SystemColors.WindowBrushKey}}" />
                        </Trigger>
                        <Trigger Property="IsGrouping" Value="true">
                            <Setter Property="ScrollViewer.CanContentScroll" Value="false" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Items.Count, RelativeSource={x:Static RelativeSource.Self}}"
                                     Value="0">
                            <Setter Property="Opacity" TargetName="Prompt" Value="0.5" />
                        </DataTrigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type ListBoxItem}">
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="HorizontalContentAlignment"
                Value="{Binding HorizontalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}" />
        <Setter Property="VerticalContentAlignment"
                Value="{Binding VerticalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}" />
        <Setter Property="Padding" Value="5,3,5,3" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ListBoxItem}">
                    <Grid>
                        <Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                Background="{TemplateBinding Background}" Padding="{TemplateBinding Padding}"
                                SnapsToDevicePixels="true">
                            <ContentPresenter HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                              SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                              VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                        </Border>
                        <Border x:Name="Overlay" Background="{StaticResource HighlightOverlay}" Opacity="0"
                                IsHitTestVisible="False" />
                    </Grid>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsSelected" Value="true">
                            <Setter Property="Background" TargetName="Bd" Value="{StaticResource SelectedBackground}" />
                            <Setter Property="Foreground" Value="{StaticResource SelectedForeground}" />
                        </Trigger>
                        <MultiTrigger>
                            <MultiTrigger.Conditions>
                                <Condition Property="IsMouseOver" Value="true" />
                                <Condition Property="IsSelected" Value="false" />
                            </MultiTrigger.Conditions>
                            <Setter Property="Opacity" TargetName="Overlay" Value="1" />
                        </MultiTrigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type ScrollViewer}">
        <Setter Property="OverridesDefaultStyle" Value="True" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ScrollViewer}">
                    <Grid x:Name="Grid" Background="{TemplateBinding Background}">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*" />
                            <ColumnDefinition Width="Auto" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="*" />
                            <RowDefinition Height="Auto" />
                        </Grid.RowDefinitions>
                        <Rectangle x:Name="Corner" Grid.Column="1" Fill="{StaticResource ControlBackground}"
                                   Grid.Row="1" />
                        <ScrollContentPresenter x:Name="PART_ScrollContentPresenter"
                                                CanContentScroll="{TemplateBinding CanContentScroll}"
                                                CanHorizontallyScroll="False" CanVerticallyScroll="False"
                                                ContentTemplate="{TemplateBinding ContentTemplate}"
                                                Content="{TemplateBinding Content}" Grid.Column="0"
                                                Margin="{TemplateBinding Padding}" Grid.Row="0" />
                        <ScrollBar x:Name="PART_VerticalScrollBar"
                                   AutomationProperties.AutomationId="VerticalScrollBar" Cursor="Arrow" Grid.Column="1"
                                   Maximum="{TemplateBinding ScrollableHeight}" Minimum="0" Grid.Row="0"
                                   Visibility="{TemplateBinding ComputedVerticalScrollBarVisibility}"
                                   Value="{Binding VerticalOffset, Mode=OneWay, RelativeSource={RelativeSource TemplatedParent}}"
                                   ViewportSize="{TemplateBinding ViewportHeight}" />
                        <ScrollBar x:Name="PART_HorizontalScrollBar"
                                   AutomationProperties.AutomationId="HorizontalScrollBar" Cursor="Arrow"
                                   Grid.Column="0" Maximum="{TemplateBinding ScrollableWidth}" Minimum="0"
                                   Orientation="Horizontal" Grid.Row="1"
                                   Visibility="{TemplateBinding ComputedHorizontalScrollBarVisibility}"
                                   Value="{Binding HorizontalOffset, Mode=OneWay, RelativeSource={RelativeSource TemplatedParent}}"
                                   ViewportSize="{TemplateBinding ViewportWidth}" />
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style x:Key="ScrollBarLineButtonStyle" TargetType="{x:Type RepeatButton}">
        <Setter Property="OverridesDefaultStyle" Value="true" />
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="Foreground" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="0" />
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="IsTabStop" Value="false" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RepeatButton}">
                    <Border BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}" Height="{TemplateBinding Height}"
                            Width="{TemplateBinding Width}">
                        <Path x:Name="Path" Data="{Binding Content, RelativeSource={RelativeSource TemplatedParent}}"
                              Fill="{TemplateBinding Foreground}" HorizontalAlignment="Center"
                              VerticalAlignment="Center" />
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Fill" TargetName="Path" Value="{StaticResource Foreground}" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="VerticalScrollBarPageButtonStyle" TargetType="{x:Type RepeatButton}">
        <Setter Property="OverridesDefaultStyle" Value="true" />
        <Setter Property="IsTabStop" Value="false" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="MinWidth" Value="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
        <Setter Property="MinHeight"
                Value="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RepeatButton}">
                    <Rectangle Fill="Transparent" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="ScrollBarThumb" TargetType="{x:Type Thumb}">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type Thumb}">
                    <Border BorderBrush="Transparent" Background="{StaticResource Border}" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style x:Key="HorizontalScrollBarPageButtonStyle" TargetType="{x:Type RepeatButton}">
        <Setter Property="OverridesDefaultStyle" Value="true" />
        <Setter Property="IsTabStop" Value="false" />
        <Setter Property="Focusable" Value="false" />
        <Setter Property="MinHeight" Value="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}" />
        <Setter Property="MinWidth"
                Value="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type RepeatButton}">
                    <Rectangle Fill="Transparent" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Style TargetType="{x:Type ScrollBar}">
        <Setter Property="Stylus.IsPressAndHoldEnabled" Value="false" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="false" />
        <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="0" />
        <Setter Property="Width" Value="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
        <Setter Property="MinWidth" Value="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ScrollBar}">
                    <Grid Background="{TemplateBinding Background}">
                        <Grid.RowDefinitions>
                            <RowDefinition
                                MaxHeight="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}" />
                            <RowDefinition Height="0.00001*" />
                            <RowDefinition
                                MaxHeight="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}" />
                        </Grid.RowDefinitions>
                        <Viewbox Stretch="Fill">
                            <RepeatButton Content="M 0 4 L 7 4 L 3.5 0 Z" Command="{x:Static ScrollBar.LineUpCommand}"
                                          Height="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}"
                                          MinWidth="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}"
                                          Style="{StaticResource ScrollBarLineButtonStyle}" />
                        </Viewbox>
                        <Rectangle Fill="Transparent" Grid.Row="1" />
                        <Track x:Name="PART_Track" IsDirectionReversed="true" Grid.Row="1">
                            <Track.DecreaseRepeatButton>
                                <RepeatButton Command="{x:Static ScrollBar.PageUpCommand}"
                                              Style="{StaticResource VerticalScrollBarPageButtonStyle}" />
                            </Track.DecreaseRepeatButton>
                            <Track.IncreaseRepeatButton>
                                <RepeatButton Command="{x:Static ScrollBar.PageDownCommand}"
                                              Style="{StaticResource VerticalScrollBarPageButtonStyle}" />
                            </Track.IncreaseRepeatButton>
                            <Track.Thumb>
                                <Thumb Style="{StaticResource ScrollBarThumb}" Margin="2,0,2,0" />
                            </Track.Thumb>
                        </Track>
                        <Viewbox Grid.Row="2" Stretch="Fill">
                            <RepeatButton Content="M 0 0 L 3.5 4 L 7 0 Z"
                                          Command="{x:Static ScrollBar.LineDownCommand}"
                                          Height="{DynamicResource {x:Static SystemParameters.VerticalScrollBarButtonHeightKey}}"
                                          MinWidth="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}"
                                          Style="{StaticResource ScrollBarLineButtonStyle}" />
                        </Viewbox>
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="Orientation" Value="Horizontal">
                <Setter Property="Width" Value="Auto" />
                <Setter Property="MinWidth" Value="0" />
                <Setter Property="Height"
                        Value="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}" />
                <Setter Property="MinHeight"
                        Value="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}" />
                <Setter Property="Template">
                    <Setter.Value>
                        <ControlTemplate TargetType="{x:Type ScrollBar}">
                            <Grid Background="{TemplateBinding Background}">
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition
                                        MaxWidth="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
                                    <ColumnDefinition Width="0.00001*" />
                                    <ColumnDefinition
                                        MaxWidth="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
                                </Grid.ColumnDefinitions>
                                <Viewbox Stretch="Fill">
                                    <RepeatButton Content="M 0 4 L 4 8 L 4 0 Z"
                                                  Command="{x:Static ScrollBar.LineLeftCommand}"
                                                  MinHeight="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}"
                                                  Style="{StaticResource ScrollBarLineButtonStyle}"
                                                  Width="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
                                </Viewbox>
                                <Rectangle Fill="Transparent" Grid.Column="1" />
                                <Track x:Name="PART_Track" Grid.Column="1">
                                    <Track.DecreaseRepeatButton>
                                        <RepeatButton Command="{x:Static ScrollBar.PageLeftCommand}"
                                                      Style="{StaticResource HorizontalScrollBarPageButtonStyle}" />
                                    </Track.DecreaseRepeatButton>
                                    <Track.IncreaseRepeatButton>
                                        <RepeatButton Command="{x:Static ScrollBar.PageRightCommand}"
                                                      Style="{StaticResource HorizontalScrollBarPageButtonStyle}" />
                                    </Track.IncreaseRepeatButton>
                                    <Track.Thumb>
                                        <Thumb Style="{StaticResource ScrollBarThumb}" Margin="0,2,0,2" />
                                    </Track.Thumb>
                                </Track>
                                <Viewbox Grid.Column="2" Stretch="Fill">
                                    <RepeatButton Content="M 0 0 L 0 8 L 4 4 Z"
                                                  Command="{x:Static ScrollBar.LineRightCommand}"
                                                  MinHeight="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarHeightKey}}"
                                                  Style="{StaticResource ScrollBarLineButtonStyle}"
                                                  Width="{DynamicResource {x:Static SystemParameters.HorizontalScrollBarButtonWidthKey}}" />
                                </Viewbox>
                            </Grid>
                        </ControlTemplate>
                    </Setter.Value>
                </Setter>
            </Trigger>
        </Style.Triggers>
    </Style>

    <PopupAnimation x:Key="{x:Static SystemParameters.ComboBoxPopupAnimationKey}">None</PopupAnimation>
    <Style x:Key="ComboBoxFocusVisual">
        <Setter Property="Control.Template">
            <Setter.Value>
                <ControlTemplate>
                    <Rectangle Margin="4,4,21,4" SnapsToDevicePixels="true" Stroke="{StaticResource Border}"
                               StrokeThickness="1" StrokeDashArray="1 2" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <Geometry x:Key="DownArrowGeometry">M 0 0 L 3.5 4 L 7 0 Z</Geometry>
    <Style x:Key="ComboBoxTransparentButtonStyle" TargetType="{x:Type ToggleButton}">
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="Width" Value="Auto" />
        <Setter Property="Height" Value="Auto" />
        <Setter Property="Background" Value="Transparent" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1,0,0,0" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ToggleButton}">
                    <DockPanel Background="{TemplateBinding Background}" LastChildFill="false"
                               SnapsToDevicePixels="true">
                        <Border x:Name="Border" BorderBrush="{TemplateBinding BorderBrush}"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                Background="{StaticResource ControlBackground}" DockPanel.Dock="Right"
                                Width="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}">
                            <Path Data="{StaticResource DownArrowGeometry}" Fill="{TemplateBinding Foreground}"
                                  HorizontalAlignment="Center" VerticalAlignment="Center" />
                        </Border>
                    </DockPanel>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="true">
                            <Setter Property="Background" TargetName="Border"
                                    Value="{StaticResource HighlightBackground}" />
                        </Trigger>
                        <DataTrigger
                            Binding="{Binding IsDropDownOpen, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type ComboBox}}}"
                            Value="true">
                            <Setter Property="Background" TargetName="Border"
                                    Value="{StaticResource HighlightBackground}" />
                        </DataTrigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="IsEnabled" Value="false">
                <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
            </Trigger>
        </Style.Triggers>
    </Style>
    <Style x:Key="ComboBoxEditableTextBox" TargetType="{x:Type TextBox}">
        <Setter Property="OverridesDefaultStyle" Value="true" />
        <Setter Property="AllowDrop" Value="true" />
        <Setter Property="MinWidth" Value="0" />
        <Setter Property="MinHeight" Value="0" />
        <Setter Property="FocusVisualStyle" Value="{x:Null}" />
        <Setter Property="ScrollViewer.PanningMode" Value="VerticalFirst" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type TextBox}">
                    <ScrollViewer x:Name="PART_ContentHost" Background="Transparent" Focusable="false"
                                  HorizontalScrollBarVisibility="Hidden" VerticalScrollBarVisibility="Hidden" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    <ControlTemplate x:Key="ComboBoxEditableTemplate" TargetType="{x:Type ComboBox}">
        <Border BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}"
                Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
            <Grid>
                <Border x:Name="Border" BorderBrush="{StaticResource Border}" BorderThickness="2"
                        Background="{TemplateBinding Background}">
                    <Popup x:Name="PART_Popup" AllowsTransparency="true" Focusable="False"
                           IsOpen="{TemplateBinding IsDropDownOpen}"
                           PopupAnimation="{DynamicResource {x:Static SystemParameters.ComboBoxPopupAnimationKey}}"
                           Placement="Bottom">
                        <Border x:Name="DropDownBorder" BorderBrush="{StaticResource Border}" BorderThickness="1"
                                Background="{StaticResource ControlBackground}"
                                MaxHeight="{TemplateBinding MaxDropDownHeight}"
                                MinWidth="{Binding ActualWidth, ElementName=Border}">
                            <ScrollViewer x:Name="DropDownScrollViewer">
                                <Grid RenderOptions.ClearTypeHint="Enabled">
                                    <Canvas HorizontalAlignment="Left" Height="0" VerticalAlignment="Top" Width="0">
                                        <Rectangle x:Name="OpaqueRect"
                                                   Fill="{Binding Background, ElementName=DropDownBorder}"
                                                   Height="{Binding ActualHeight, ElementName=DropDownBorder}"
                                                   Width="{Binding ActualWidth, ElementName=DropDownBorder}" />
                                    </Canvas>
                                    <ItemsPresenter x:Name="ItemsPresenter"
                                                    KeyboardNavigation.DirectionalNavigation="Contained"
                                                    SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                                </Grid>
                            </ScrollViewer>
                        </Border>
                    </Popup>
                </Border>
                <ToggleButton ClickMode="Press" Focusable="false"
                              IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                              Margin="2" MinWidth="0" MinHeight="0"
                              Style="{StaticResource ComboBoxTransparentButtonStyle}" Width="Auto" />
                <DockPanel Margin="2">
                    <FrameworkElement DockPanel.Dock="Right"
                                      Width="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
                    <TextBox x:Name="PART_EditableTextBox"
                             HorizontalContentAlignment="{TemplateBinding HorizontalContentAlignment}"
                             IsReadOnly="{Binding IsReadOnly, RelativeSource={RelativeSource TemplatedParent}}"
                             Margin="{TemplateBinding Padding}" Style="{StaticResource ComboBoxEditableTextBox}"
                             VerticalContentAlignment="{TemplateBinding VerticalContentAlignment}" />
                </DockPanel>
            </Grid>
        </Border>
        <ControlTemplate.Triggers>
            <Trigger Property="HasItems" Value="false">
                <Setter Property="MinHeight" TargetName="DropDownBorder" Value="95" />
            </Trigger>
            <Trigger Property="IsEnabled" Value="false">
                <Setter Property="Foreground" Value="{DynamicResource DisabledForeground}" />
                <Setter Property="Background" Value="{DynamicResource DisabledBackground}" />
            </Trigger>
            <Trigger Property="IsGrouping" Value="true">
                <Setter Property="ScrollViewer.CanContentScroll" Value="false" />
            </Trigger>
            <Trigger Property="ScrollViewer.CanContentScroll" SourceName="DropDownScrollViewer" Value="false">
                <Setter Property="Canvas.Top" TargetName="OpaqueRect"
                        Value="{Binding VerticalOffset, ElementName=DropDownScrollViewer}" />
                <Setter Property="Canvas.Left" TargetName="OpaqueRect"
                        Value="{Binding HorizontalOffset, ElementName=DropDownScrollViewer}" />
            </Trigger>
        </ControlTemplate.Triggers>
    </ControlTemplate>
    <Style TargetType="{x:Type ComboBox}">
        <Setter Property="FocusVisualStyle" Value="{StaticResource ComboBoxFocusVisual}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Margin" Value="0,0,0,0" />
        <Setter Property="Padding" Value="2,1" />
        <Setter Property="ScrollViewer.HorizontalScrollBarVisibility" Value="Auto" />
        <Setter Property="ScrollViewer.VerticalScrollBarVisibility" Value="Auto" />
        <Setter Property="ScrollViewer.CanContentScroll" Value="true" />
        <Setter Property="ScrollViewer.PanningMode" Value="Both" />
        <Setter Property="Stylus.IsFlicksEnabled" Value="False" />
        <Setter Property="VerticalContentAlignment" Value="Center" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ComboBox}">
                    <Border x:Name="Border" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}" SnapsToDevicePixels="true">
                        <Grid>
                            <Popup x:Name="PART_Popup" AllowsTransparency="true" Focusable="False"
                                   IsOpen="{TemplateBinding IsDropDownOpen}"
                                   PopupAnimation="{DynamicResource {x:Static SystemParameters.ComboBoxPopupAnimationKey}}"
                                   Placement="Bottom">
                                <Border x:Name="DropDownBorder" BorderBrush="{StaticResource Border}"
                                        BorderThickness="1" Background="{StaticResource ControlBackground}"
                                        MaxHeight="{TemplateBinding MaxDropDownHeight}"
                                        MinWidth="{Binding ActualWidth, ElementName=Border}">
                                    <Border.Effect>
                                        <DropShadowEffect BlurRadius="4" Opacity="0.8" ShadowDepth="1" />
                                    </Border.Effect>
                                    <ScrollViewer x:Name="DropDownScrollViewer">
                                        <Grid RenderOptions.ClearTypeHint="Enabled">
                                            <Canvas HorizontalAlignment="Left" Height="0" VerticalAlignment="Top"
                                                    Width="0">
                                                <Rectangle x:Name="OpaqueRect"
                                                           Fill="{Binding Background, ElementName=DropDownBorder}"
                                                           Height="{Binding ActualHeight, ElementName=DropDownBorder}"
                                                           Width="{Binding ActualWidth, ElementName=DropDownBorder}" />
                                            </Canvas>
                                            <ItemsPresenter x:Name="ItemsPresenter"
                                                            KeyboardNavigation.DirectionalNavigation="Contained"
                                                            SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" />
                                        </Grid>
                                    </ScrollViewer>
                                </Border>
                            </Popup>
                            <DockPanel Margin="2">
                                <FrameworkElement DockPanel.Dock="Right"
                                                  Width="{DynamicResource {x:Static SystemParameters.VerticalScrollBarWidthKey}}" />
                                <Border Margin="{TemplateBinding Padding}">
                                    <ContentPresenter ContentTemplate="{TemplateBinding SelectionBoxItemTemplate}"
                                                      ContentTemplateSelector="{TemplateBinding ItemTemplateSelector}"
                                                      Content="{TemplateBinding SelectionBoxItem}"
                                                      ContentStringFormat="{TemplateBinding SelectionBoxItemStringFormat}"
                                                      HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                                      Margin="1,1,1,1"
                                                      SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
                                                      VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                                </Border>
                            </DockPanel>
                            <ToggleButton ClickMode="Press" Focusable="false"
                                          IsChecked="{Binding IsDropDownOpen, Mode=TwoWay, RelativeSource={RelativeSource TemplatedParent}}"
                                          Style="{StaticResource ComboBoxTransparentButtonStyle}" Width="Auto" />
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="HasItems" Value="false">
                            <Setter Property="MinHeight" TargetName="DropDownBorder" Value="95" />
                        </Trigger>
                        <Trigger Property="IsEnabled" Value="false">
                            <Setter Property="Foreground" Value="{DynamicResource DisabledForeground}" />
                            <Setter Property="Background" Value="{DynamicResource DisabledBackground}" />
                        </Trigger>
                        <Trigger Property="IsGrouping" Value="true">
                            <Setter Property="ScrollViewer.CanContentScroll" Value="false" />
                        </Trigger>
                        <Trigger Property="ScrollViewer.CanContentScroll" SourceName="DropDownScrollViewer"
                                 Value="false">
                            <Setter Property="Canvas.Top" TargetName="OpaqueRect"
                                    Value="{Binding VerticalOffset, ElementName=DropDownScrollViewer}" />
                            <Setter Property="Canvas.Left" TargetName="OpaqueRect"
                                    Value="{Binding HorizontalOffset, ElementName=DropDownScrollViewer}" />
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <Trigger Property="IsEditable" Value="true">
                <Setter Property="IsTabStop" Value="false" />
                <Setter Property="Padding" Value="1" />
                <Setter Property="Template" Value="{StaticResource ComboBoxEditableTemplate}" />
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style TargetType="{x:Type ComboBoxItem}">
        <Setter Property="MinHeight" Value="20" />
        <Setter Property="FocusVisualStyle" Value="{x:Null}" />
        <Setter Property="Padding" Value="4,2" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ComboBoxItem}">
                    <Border x:Name="ListBoxItemRoot" BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            Background="{TemplateBinding Background}">
                        <ContentPresenter ContentTemplate="{TemplateBinding ContentTemplate}"
                                          Content="{TemplateBinding Content}"
                                          HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                                          Margin="{TemplateBinding Padding}"
                                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
        <Style.Triggers>
            <MultiTrigger>
                <MultiTrigger.Conditions>
                    <Condition Property="IsMouseOver" Value="True" />
                    <Condition Property="IsSelected" Value="False" />
                </MultiTrigger.Conditions>
                <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
            </MultiTrigger>
            <MultiDataTrigger>
                <MultiDataTrigger.Conditions>
                    <Condition Binding="{Binding IsSelected, RelativeSource={RelativeSource Self}}" Value="True" />
                    <Condition
                        Binding="{Binding IsEditable, RelativeSource={RelativeSource FindAncestor, AncestorLevel=1, AncestorType={x:Type ComboBox}}}"
                        Value="True" />
                </MultiDataTrigger.Conditions>
                <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
            </MultiDataTrigger>
            <MultiDataTrigger>
                <MultiDataTrigger.Conditions>
                    <Condition Binding="{Binding IsFocused, RelativeSource={RelativeSource Self}}" Value="True" />
                    <Condition
                        Binding="{Binding IsEditable, RelativeSource={RelativeSource FindAncestor, AncestorLevel=1, AncestorType={x:Type ComboBox}}}"
                        Value="False" />
                </MultiDataTrigger.Conditions>
                <Setter Property="Background" Value="{StaticResource HighlightBackground}" />
            </MultiDataTrigger>
            <Trigger Property="IsEnabled" Value="False">
                <Setter Property="Foreground" Value="{StaticResource DisabledForeground}" />
            </Trigger>
        </Style.Triggers>
    </Style>

    <Style TargetType="{x:Type ProgressBar}">
        <Setter Property="Background" Value="{StaticResource ControlBackground}" />
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="BorderBrush" Value="{StaticResource Border}" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type ProgressBar}">
                    <Grid MinHeight="14" MinWidth="200" Background="{TemplateBinding Background}">
                        <VisualStateManager.VisualStateGroups>
                            <VisualStateGroup x:Name="CommonStates">
                                <VisualState x:Name="Determinate" />
                                <VisualState x:Name="Indeterminate">
                                    <Storyboard>
                                        <ObjectAnimationUsingKeyFrames Duration="0"
                                                                       Storyboard.TargetName="PART_Indicator"
                                                                       Storyboard.TargetProperty="Background">
                                            <DiscreteObjectKeyFrame KeyTime="0">
                                                <DiscreteObjectKeyFrame.Value>
                                                    <SolidColorBrush Color="Transparent" />
                                                </DiscreteObjectKeyFrame.Value>
                                            </DiscreteObjectKeyFrame>
                                        </ObjectAnimationUsingKeyFrames>

                                        <ObjectAnimationUsingKeyFrames Duration="0"
                                                                       Storyboard.TargetName="Animation"
                                                                       Storyboard.TargetProperty="Visibility">
                                            <DiscreteObjectKeyFrame KeyTime="0">
                                                <DiscreteObjectKeyFrame.Value>
                                                    <Visibility>Visible</Visibility>
                                                </DiscreteObjectKeyFrame.Value>
                                            </DiscreteObjectKeyFrame>
                                        </ObjectAnimationUsingKeyFrames>

                                        <DoubleAnimation
                                            Storyboard.TargetName="animTranslate"
                                            Storyboard.TargetProperty="X"
                                            From="0" To="50" Duration="0:0:1" RepeatBehavior="Forever" />
                                    </Storyboard>
                                </VisualState>
                            </VisualStateGroup>
                        </VisualStateManager.VisualStateGroups>
                        <Border x:Name="PART_Track"
                                BorderThickness="{TemplateBinding BorderThickness}"
                                BorderBrush="{TemplateBinding BorderBrush}" />
                        <Border x:Name="PART_Indicator"
                                HorizontalAlignment="Left"
                                Background="{TemplateBinding Foreground}"
                                Margin="3">
                            <Border x:Name="Animation" Visibility="Hidden">
                                <Border.Background>
                                    <DrawingBrush TileMode="Tile" Viewport="0,0,25,25" ViewportUnits="Absolute">
                                        <DrawingBrush.Transform>
                                            <TranslateTransform x:Name="animTranslate" />
                                        </DrawingBrush.Transform>
                                        <DrawingBrush.Drawing>
                                            <GeometryDrawing>
                                                <GeometryDrawing.Brush>
                                                    <LinearGradientBrush SpreadMethod="Repeat" StartPoint="0,0"
                                                                         EndPoint="1,1">
                                                        <LinearGradientBrush.RelativeTransform>
                                                            <ScaleTransform ScaleX="0.5" ScaleY="0.5" />
                                                        </LinearGradientBrush.RelativeTransform>
                                                        <GradientStop Offset="0" Color="Transparent" />
                                                        <GradientStop Offset="0.5" Color="Transparent" />
                                                        <GradientStop Offset="0.5"
                                                                      Color="{Binding Foreground, Converter={x:Static local:BrushToColorConverter.Instance}, RelativeSource={RelativeSource Mode=TemplatedParent}}" />
                                                        <GradientStop Offset="1"
                                                                      Color="{Binding Foreground, Converter={x:Static local:BrushToColorConverter.Instance}, RelativeSource={RelativeSource Mode=TemplatedParent}}" />
                                                    </LinearGradientBrush>
                                                </GeometryDrawing.Brush>
                                                <GeometryDrawing.Geometry>
                                                    <RectangleGeometry Rect="0,0,10,10" />
                                                </GeometryDrawing.Geometry>
                                            </GeometryDrawing>
                                        </DrawingBrush.Drawing>
                                    </DrawingBrush>
                                </Border.Background>
                            </Border>
                        </Border>
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

    <Style TargetType="{x:Type Hyperlink}">
        <Style.Triggers>
            <Trigger Property="IsMouseOver" Value="True">
                <Setter Property="TextBlock.TextDecorations" Value="Underline" />
            </Trigger>
        </Style.Triggers>
        <Setter Property="Foreground" Value="{StaticResource Foreground}" />
        <Setter Property="TextBlock.TextDecorations" Value="{x:Null}" />
    </Style>
</ResourceDictionary>

```

`ConfuserEx/StackTraceDecoder.xaml`:

```xaml
<Window x:Class="ConfuserEx.StackTraceDecoder"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        Style="{StaticResource DarkWindow}" ShowInTaskbar="False"
        Title="Stack Trace Decoder" Height="400" Width="600">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>
        <Border Grid.RowSpan="2" Grid.Column="0" BorderThickness="0,0,1,0" BorderBrush="{StaticResource Border}" Margin="5">
            <StackPanel VerticalAlignment="Center">
                <RadioButton x:Name="optSym" Margin="5" IsChecked="True">Symbol Map</RadioButton>
                <RadioButton x:Name="optPass" Margin="5">Password</RadioButton>
            </StackPanel>
        </Border>
        <DockPanel Grid.Row="0" Grid.Column="1" Visibility="{Binding IsChecked, ElementName=optSym, Converter={x:Static local:BoolToVisibilityConverter.Instance}}">
            <Label DockPanel.Dock="Left" VerticalAlignment="Center" HorizontalAlignment="Right">Symbol Map:</Label>
            <Button DockPanel.Dock="Right" Margin="5" VerticalAlignment="Center" Height="26" Width="25"
                    Click="ChooseMapPath">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf141;" Height="10px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
            <TextBox x:Name="PathBox" Grid.Row="1" Grid.Column="1" Margin="5" VerticalContentAlignment="Center"
                     local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />
        </DockPanel>
        <DockPanel Grid.Row="0" Grid.Column="1" Visibility="{Binding IsChecked, ElementName=optPass, Converter={x:Static local:BoolToVisibilityConverter.Instance}}">
            <Label DockPanel.Dock="Left" VerticalAlignment="Center" HorizontalAlignment="Right">Password:</Label>
            <PasswordBox x:Name="PassBox" Margin="5" VerticalContentAlignment="Center"/>
        </DockPanel>
        <DockPanel Grid.Row="1" Grid.Column="1">
            <Button DockPanel.Dock="Right" Margin="5" Padding="10,0,10,0" Click="Decode_Click" IsDefault="True">Decode!</Button>
            <Label x:Name="status" HorizontalAlignment="Left" VerticalAlignment="Center" Margin="5,2,10,2" />
        </DockPanel>
        <TextBox x:Name="stackTrace" Grid.ColumnSpan="2" Grid.Row="2" Margin="5" AcceptsReturn="True" FontFamily="Consolas"
                 ScrollViewer.HorizontalScrollBarVisibility="Auto" ScrollViewer.VerticalScrollBarVisibility="Visible"
                 TextWrapping="Wrap"/>
    </Grid>
</Window>

```

`ConfuserEx/StackTraceDecoder.xaml.cs`:

```cs
using System.Windows;
using Confuser.Renamer;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx {
	/// <summary>
	///     Interaction logic for StackTraceDecoder.xaml
	/// </summary>
	public partial class StackTraceDecoder {
		MessageDeobfuscator _messageDeobfuscator;

		public StackTraceDecoder() => InitializeComponent();

		void ChooseMapPath(object sender, RoutedEventArgs e) {
			var ofd = new VistaOpenFileDialog();
			ofd.Filter = "Symbol maps (*.map)|*.map|All Files (*.*)|*.*";
			if (ofd.ShowDialog() ?? false) {
				PathBox.Text = ofd.FileName;
			}
		}

		void Decode_Click(object sender, RoutedEventArgs e) {
			bool error = false;
			if (optSym.IsChecked ?? true) {
				var path = PathBox.Text.Trim(' ', '"');
				string shortPath = path;
				if (path.Length > 35)
					shortPath = "..." + path.Substring(path.Length - 35, 35);

				try {
					_messageDeobfuscator = MessageDeobfuscator.Load(path);
					status.Content = "Loaded symbol map from '" + shortPath + "' successfully.";
				}
				catch {
					status.Content = "Failed to load symbol map from '" + shortPath + "'.";
					error = true;
				}
			}
			else {
				_messageDeobfuscator = new MessageDeobfuscator(PassBox.Password);
			}

			if (!error) {
				stackTrace.Text = _messageDeobfuscator.DeobfuscateMessage(stackTrace.Text);
			}
		}
	}
}

```

`ConfuserEx/ViewModel/IViewModel.cs`:

```cs
using System;

namespace ConfuserEx.ViewModel {
	public interface IViewModel<TModel> {
		TModel Model { get; }
	}
}
```

`ConfuserEx/ViewModel/Project/ProjectModuleVM.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Reflection;
using System.Threading;
using Confuser.Core.Project;

namespace ConfuserEx.ViewModel {
	public class ProjectModuleVM : ViewModelBase, IViewModel<ProjectModule>, IRuleContainer {
		readonly ProjectModule module;
		readonly ProjectVM parent;
		string asmName = "Unknown";
		string simpleName;
		bool isSelected;

		public ProjectModuleVM(ProjectVM parent, ProjectModule module) {
			this.parent = parent;
			this.module = module;

			ObservableCollection<ProjectRuleVM> rules = Utils.Wrap(module.Rules, rule => new ProjectRuleVM(parent, rule));
			rules.CollectionChanged += (sender, e) => parent.IsModified = true;
			Rules = rules;

			if (module.Path != null) {
				SimpleName = System.IO.Path.GetFileName(module.Path);
				LoadAssemblyName();
			}
		}

		public bool IsSelected {
			get { return isSelected; }
			set { SetProperty(ref isSelected, value, "IsSelected"); }
		}

		public ProjectModule Module {
			get { return module; }
		}

		public string Path {
			get { return module.Path; }
			set {
				if (SetProperty(module.Path != value, val => module.Path = val, value, "Path")) {
					parent.IsModified = true;
					SimpleName = System.IO.Path.GetFileName(module.Path);
					LoadAssemblyName();
				}
			}
		}

		public string SimpleName {
			get { return simpleName; }
			private set { SetProperty(ref simpleName, value, "SimpleName"); }
		}

		public string AssemblyName {
			get { return asmName; }
			private set { SetProperty(ref asmName, value, "AssemblyName"); }
		}

		public string SNKeyPath {
			get { return module.SNKeyPath; }
			set {
				if (SetProperty(module.SNKeyPath != value, val => module.SNKeyPath = val, value, "SNKeyPath"))
					parent.IsModified = true;
			}
		}

		public string SNKeyPassword {
			get { return module.SNKeyPassword; }
			set {
				if (SetProperty(module.SNKeyPassword != value, val => module.SNKeyPassword = val, value, "SNKeyPassword"))
					parent.IsModified = true;
			}
		}

		public string SNSigKeyPath {
			get { return module.SNSigKeyPath; }
			set {
				if (SetProperty(module.SNSigKeyPath != value, val => module.SNSigKeyPath = val, value, "SNSigKeyPath"))
					parent.IsModified = true;
			}
		}

		public string SNSigKeyPassword {
			get { return module.SNSigKeyPassword; }
			set {
				if (SetProperty(module.SNSigKeyPassword != value, val => module.SNSigKeyPassword = val, value, "SNSigKeyPassword"))
					parent.IsModified = true;
			}
		}

		public string SNPubKeyPath {
			get { return module.SNPubKeyPath; }
			set {
				if (SetProperty(module.SNPubKeyPath != value, val => module.SNPubKeyPath = val, value, "SNPubKeyPath"))
					parent.IsModified = true;
			}
		}

		public string SNPubSigKeyPath {
			get { return module.SNPubSigKeyPath; }
			set {
				if (SetProperty(module.SNPubSigKeyPath != value, val => module.SNPubSigKeyPath = val, value, "SNPubSigKeyPath"))
					parent.IsModified = true;
			}
		}

		public bool SNDelaySig {
			get { return module.SNDelaySig; }
			set {
				if (SetProperty(module.SNDelaySig != value, val => module.SNDelaySig = val, value, "SNDelaySig"))
					parent.IsModified = true;
			}
		}

		public IList<ProjectRuleVM> Rules { get; private set; }

		ProjectModule IViewModel<ProjectModule>.Model {
			get { return module; }
		}

		void LoadAssemblyName() {
			AssemblyName = "Loading...";
			ThreadPool.QueueUserWorkItem(_ => {
				try {
					string path = System.IO.Path.Combine(parent.BaseDirectory, Path);
					if (!string.IsNullOrEmpty(parent.FileName))
						path = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(parent.FileName), path);
					AssemblyName name = System.Reflection.AssemblyName.GetAssemblyName(path);
					AssemblyName = name.FullName;
				}
				catch {
					AssemblyName = "Unknown";
				}
			});
		}
	}
}

```

`ConfuserEx/ViewModel/Project/ProjectRuleVM.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.Core.Project.Patterns;

namespace ConfuserEx.ViewModel {
	internal interface IRuleContainer {
		IList<ProjectRuleVM> Rules { get; }
	}

	public class ProjectRuleVM : ViewModelBase, IViewModel<Rule> {
		readonly ProjectVM parent;
		readonly Rule rule;
		string error;
		PatternExpression exp;

		public ProjectRuleVM(ProjectVM parent, Rule rule) {
			this.parent = parent;
			this.rule = rule;

			ObservableCollection<ProjectSettingVM<Protection>> protections = Utils.Wrap(rule, setting => new ProjectSettingVM<Protection>(parent, setting));
			protections.CollectionChanged += (sender, e) => parent.IsModified = true;
			Protections = protections;

			ParseExpression();
		}

		public ProjectVM Project {
			get { return parent; }
		}

		public string Pattern {
			get { return rule.Pattern; }
			set {
				if (SetProperty(rule.Pattern != value, val => rule.Pattern = val, value, "Pattern")) {
					parent.IsModified = true;
					ParseExpression();
				}
			}
		}

		public PatternExpression Expression {
			get { return exp; }
			set { SetProperty(ref exp, value, "Expression"); }
		}

		public string ExpressionError {
			get { return error; }
			set { SetProperty(ref error, value, "ExpressionError"); }
		}

		public ProtectionPreset Preset {
			get { return rule.Preset; }
			set {
				if (SetProperty(rule.Preset != value, val => rule.Preset = val, value, "Preset"))
					parent.IsModified = true;
			}
		}

		public bool Inherit {
			get { return rule.Inherit; }
			set {
				if (SetProperty(rule.Inherit != value, val => rule.Inherit = val, value, "Inherit"))
					parent.IsModified = true;
			}
		}

		public IList<ProjectSettingVM<Protection>> Protections { get; private set; }

		Rule IViewModel<Rule>.Model {
			get { return rule; }
		}

		void ParseExpression() {
			if (Pattern == null)
				return;
			PatternExpression expression;
			try {
				expression = new PatternParser().Parse(Pattern);
				ExpressionError = null;
			}
			catch (Exception e) {
				ExpressionError = e.Message;
				expression = null;
			}
			Expression = expression;
		}
	}
}
```

`ConfuserEx/ViewModel/Project/ProjectSettingVM.cs`:

```cs
using System;
using Confuser.Core.Project;

namespace ConfuserEx.ViewModel {
	public class ProjectSettingVM<T> : ViewModelBase, IViewModel<SettingItem<T>> {
		readonly ProjectVM parent;
		readonly SettingItem<T> setting;

		public ProjectSettingVM(ProjectVM parent, SettingItem<T> setting) {
			this.parent = parent;
			this.setting = setting;
		}

		public string Id {
			get { return setting.Id; }
			set {
				if (SetProperty(setting.Id != value, val => setting.Id = val, value, "Id"))
					parent.IsModified = true;
			}
		}

		public SettingItemAction Action {
			get { return setting.Action; }
			set {
				if (SetProperty(setting.Action != value, val => setting.Action = val, value, "Action"))
					parent.IsModified = true;
			}
		}

		SettingItem<T> IViewModel<SettingItem<T>>.Model {
			get { return setting; }
		}
	}
}
```

`ConfuserEx/ViewModel/Project/ProjectVM.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Reflection;
using Confuser.Core;
using Confuser.Core.Project;

namespace ConfuserEx.ViewModel {
	public class ProjectVM : ViewModelBase, IViewModel<ConfuserProject>, IRuleContainer {
		readonly ConfuserProject proj;
		bool modified;
		ProjectSettingVM<Packer> packer;

		public ProjectVM(ConfuserProject proj, string fileName) {
			this.proj = proj;
			FileName = fileName;

			ObservableCollection<ProjectModuleVM> modules = Utils.Wrap(proj, module => new ProjectModuleVM(this, module));
			modules.CollectionChanged += (sender, e) => IsModified = true;
			Modules = modules;

			ObservableCollection<StringItem> plugins = Utils.Wrap(proj.PluginPaths, path => new StringItem(path));
			plugins.CollectionChanged += (sender, e) => IsModified = true;
			Plugins = plugins;

			ObservableCollection<StringItem> probePaths = Utils.Wrap(proj.ProbePaths, path => new StringItem(path));
			probePaths.CollectionChanged += (sender, e) => IsModified = true;
			ProbePaths = probePaths;

			ObservableCollection<ProjectRuleVM> rules = Utils.Wrap(proj.Rules, rule => new ProjectRuleVM(this, rule));
			rules.CollectionChanged += (sender, e) => IsModified = true;
			Rules = rules;

			Protections = new ObservableCollection<ConfuserComponent>();
			Packers = new ObservableCollection<ConfuserComponent>();
			ComponentDiscovery.LoadComponents(Protections, Packers, Assembly.Load("Confuser.Protections").Location);
			ComponentDiscovery.LoadComponents(Protections, Packers, Assembly.Load("Confuser.Renamer").Location);
			ComponentDiscovery.LoadComponents(Protections, Packers, Assembly.Load("Confuser.Core").Location);
		}

		public ConfuserProject Project {
			get { return proj; }
		}

		public bool IsModified {
			get { return modified; }
			set { SetProperty(ref modified, value, "IsModified"); }
		}

		public string Seed {
			get { return proj.Seed; }
			set { SetProperty(proj.Seed != value, val => proj.Seed = val, value, "Seed"); }
		}

		public bool Debug {
			get { return proj.Debug; }
			set { SetProperty(proj.Debug != value, val => proj.Debug = val, value, "Debug"); }
		}

		public string BaseDirectory {
			get { return proj.BaseDirectory; }
			set { SetProperty(proj.BaseDirectory != value, val => proj.BaseDirectory = val, value, "BaseDirectory"); }
		}

		public string OutputDirectory {
			get { return proj.OutputDirectory; }
			set { SetProperty(proj.OutputDirectory != value, val => proj.OutputDirectory = val, value, "OutputDirectory"); }
		}

		public ProjectSettingVM<Packer> Packer {
			get {
				if (proj.Packer == null)
					packer = null;
				else
					packer = new ProjectSettingVM<Packer>(this, proj.Packer);
				return packer;
			}
			set {
				var vm = (IViewModel<SettingItem<Packer>>)value;
				bool changed = (vm == null && proj.Packer != null) || (vm != null && proj.Packer != vm.Model);
				SetProperty(changed, val => proj.Packer = val == null ? null : val.Model, vm, "Packer");
			}
		}

		public IList<ProjectModuleVM> Modules { get; private set; }
		public IList<StringItem> Plugins { get; private set; }
		public IList<StringItem> ProbePaths { get; private set; }

		public ObservableCollection<ConfuserComponent> Protections { get; private set; }
		public ObservableCollection<ConfuserComponent> Packers { get; private set; }
		public IList<ProjectRuleVM> Rules { get; private set; }

		public string FileName { get; set; }

		ConfuserProject IViewModel<ConfuserProject>.Model {
			get { return proj; }
		}

		protected override void OnPropertyChanged(string property) {
			base.OnPropertyChanged(property);
			if (property != "IsModified")
				IsModified = true;
		}
	}
}

```

`ConfuserEx/ViewModel/StringItem.cs`:

```cs
using System;

namespace ConfuserEx.ViewModel {
	public class StringItem : IViewModel<string> {
		public StringItem(string item) {
			Item = item;
		}

		public string Item { get; private set; }

		string IViewModel<string>.Model {
			get { return Item; }
		}

		public override string ToString() {
			return Item;
		}
	}
}
```

`ConfuserEx/ViewModel/UI/AboutTabVM.cs`:

```cs
using System;
using System.Diagnostics;
using System.Linq;
using System.Windows.Input;
using System.Windows.Media.Imaging;
using GalaSoft.MvvmLight.CommandWpf;

namespace ConfuserEx.ViewModel {
	internal class AboutTabVM : TabViewModel {
		public AboutTabVM(AppVM app)
			: base(app, "About") {
			var decoder = new IconBitmapDecoder(new Uri("pack://application:,,,/ConfuserEx.ico"), BitmapCreateOptions.DelayCreation, BitmapCacheOption.OnDemand);

			Icon = decoder.Frames.First(frame => frame.Width == 64);
		}

		public ICommand LaunchBrowser {
			get { return new RelayCommand<string>(site => Process.Start(site)); }
		}

		public BitmapSource Icon { get; private set; }
	}
}
```

`ConfuserEx/ViewModel/UI/AppVM.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Windows;
using System.Windows.Input;
using System.Xml;
using Confuser.Core;
using Confuser.Core.Project;
using GalaSoft.MvvmLight.CommandWpf;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx.ViewModel {
	public class AppVM : ViewModelBase {
		readonly IList<TabViewModel> tabs = new ObservableCollection<TabViewModel>();
		string fileName;
		bool navDisabled;
		bool firstSaved;

		ProjectVM proj;

		public bool NavigationDisabled {
			get { return navDisabled; }
			set { SetProperty(ref navDisabled, value, "NavigationDisabled"); }
		}

		public ProjectVM Project {
			get { return proj; }
			set {
				if (proj != null)
					proj.PropertyChanged -= OnProjectPropertyChanged;

				SetProperty(ref proj, value, "Project");

				if (proj != null)
					proj.PropertyChanged += OnProjectPropertyChanged;
			}
		}

		public string FileName {
			get { return fileName; }
			set {
				SetProperty(ref fileName, value, "Project");
				OnPropertyChanged("Title");
			}
		}

		public string Title {
			get {
				return string.Format("{0}{1} - {2}",
				                     Path.GetFileName(fileName),
				                     (proj.IsModified ? "*" : ""),
				                     ConfuserEngine.Version);
			}
		}

		public IList<TabViewModel> Tabs {
			get { return tabs; }
		}

		public ICommand NewProject {
			get { return new RelayCommand(NewProj, () => !NavigationDisabled); }
		}

		public ICommand OpenProject {
			get { return new RelayCommand(OpenProj, () => !NavigationDisabled); }
		}

		public ICommand SaveProject {
			get { return new RelayCommand(() => SaveProj(), () => !NavigationDisabled); }
		}

		public ICommand Decode {
			get { return new RelayCommand(() => new StackTraceDecoder { Owner = Application.Current.MainWindow }.ShowDialog(), () => !NavigationDisabled); }
		}

		public bool OnWindowClosing() {
			return PromptSave();
		}

		bool SaveProj() {
			if (!firstSaved || !File.Exists(FileName)) {
				var sfd = new VistaSaveFileDialog();
				sfd.FileName = FileName;
				sfd.Filter = "ConfuserEx Projects (*.crproj)|*.crproj|All Files (*.*)|*.*";
				sfd.DefaultExt = ".crproj";
				sfd.AddExtension = true;
				if (!(sfd.ShowDialog(Application.Current.MainWindow) ?? false) || sfd.FileName == null)
					return false;
				FileName = sfd.FileName;
			}
			ConfuserProject proj = ((IViewModel<ConfuserProject>)Project).Model;
			proj.Save().Save(FileName);
			Project.IsModified = false;
			firstSaved = true;
			return true;
		}

		bool PromptSave() {
			if (!Project.IsModified)
				return true;
			switch (MessageBox.Show("The current project has unsaved changes. Do you want to save them?", "ConfuserEx", MessageBoxButton.YesNoCancel, MessageBoxImage.Question)) {
				case MessageBoxResult.Yes:
					return SaveProj();
				case MessageBoxResult.No:
					return true;
				case MessageBoxResult.Cancel:
					return false;
			}
			return false;
		}

		void NewProj() {
			if (!PromptSave())
				return;

			Project = new ProjectVM(new ConfuserProject(), null);
			FileName = "Unnamed.crproj";
		}

		void OpenProj() {
			if (!PromptSave())
				return;

			var ofd = new VistaOpenFileDialog();
			ofd.Filter = "ConfuserEx Projects (*.crproj)|*.crproj|All Files (*.*)|*.*";
			if ((ofd.ShowDialog(Application.Current.MainWindow) ?? false) && ofd.FileName != null) {
				string fileName = ofd.FileName;
				try {
					var xmlDoc = new XmlDocument();
					xmlDoc.Load(fileName);
					var proj = new ConfuserProject();
					proj.Load(xmlDoc);
					Project = new ProjectVM(proj, fileName);
					FileName = fileName;
				}
				catch {
					MessageBox.Show("Invalid project!", "ConfuserEx", MessageBoxButton.OK, MessageBoxImage.Error);
				}
			}
		}

		void OnProjectPropertyChanged(object sender, PropertyChangedEventArgs e) {
			if (e.PropertyName == "IsModified")
				OnPropertyChanged("Title");
		}

		protected override void OnPropertyChanged(string property) {
			base.OnPropertyChanged(property);
			if (property == "Project")
				LoadPlugins();
		}

		void LoadPlugins() {
			foreach (var plugin in Project.Plugins) {
				try {
					ComponentDiscovery.LoadComponents(Project.Protections, Project.Packers, plugin.Item);
				}
				catch {
					MessageBox.Show("Failed to load plugin '" + plugin + "'.");
				}
			}
		}
	}
}

```

`ConfuserEx/ViewModel/UI/ProjectTabVM.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Input;
using Confuser.Core.Project;
using ConfuserEx.Views;
using GalaSoft.MvvmLight.CommandWpf;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx.ViewModel {
	public class ProjectTabVM : TabViewModel {
		public ProjectTabVM(AppVM app)
			: base(app, "Project") { }

		public ICommand DragDrop {
			get {
				return new RelayCommand<IDataObject>(data => {
					foreach (string file in (string[])data.GetData(DataFormats.FileDrop))
						AddModule(file);
				}, data => {
					if (!data.GetDataPresent(DataFormats.FileDrop))
						return false;
					var files = (string[])data.GetData(DataFormats.FileDrop);
					bool ret = files.All(file => File.Exists(file));
					return ret;
				});
			}
		}

		public ICommand ChooseBaseDir {
			get {
				return new RelayCommand(() => {
					var fbd = new VistaFolderBrowserDialog();
					fbd.SelectedPath = App.Project.BaseDirectory;
					if (fbd.ShowDialog() ?? false) {
						App.Project.BaseDirectory = fbd.SelectedPath;
						App.Project.OutputDirectory = Path.Combine(App.Project.BaseDirectory, "Confused");
					}
				});
			}
		}

		public ICommand ChooseOutputDir {
			get {
				return new RelayCommand(() => {
					var fbd = new VistaFolderBrowserDialog();
					fbd.SelectedPath = App.Project.OutputDirectory;
					if (fbd.ShowDialog() ?? false) {
						App.Project.OutputDirectory = fbd.SelectedPath;
					}
				});
			}
		}

		public ICommand Add {
			get {
				return new RelayCommand(() => {
					var ofd = new VistaOpenFileDialog();
					ofd.Filter = ".NET assemblies (*.exe, *.dll)|*.exe;*.dll|All Files (*.*)|*.*";
					ofd.Multiselect = true;
					if (ofd.ShowDialog() ?? false) {
						foreach (var file in ofd.FileNames)
							AddModule(file);
					}
				});
			}
		}

		public ICommand Remove {
			get {
				return new RelayCommand(() => {
					Debug.Assert(App.Project.Modules.Any(m => m.IsSelected));
					string msg = "Are you sure to remove selected modules?\r\nAll settings specific to it would be lost!";
					if (MessageBox.Show(msg, "ConfuserEx", MessageBoxButton.YesNo, MessageBoxImage.Question) == MessageBoxResult.Yes) {
						foreach (var item in App.Project.Modules.Where(m => m.IsSelected).ToList())
							App.Project.Modules.Remove(item);
					}
				}, () => App.Project.Modules.Any(m => m.IsSelected));
			}
		}

		public ICommand Edit {
			get {
				return new RelayCommand<ProjectModuleVM>(module => {
					if (module is null) {
						Debug.Assert(App.Project.Modules.Count(m => m.IsSelected) == 1);
						module = App.Project.Modules.Single(m => m.IsSelected);
					}
					var dialog = new ProjectModuleView(module);
					dialog.Owner = Application.Current.MainWindow;
					dialog.ShowDialog();
				}, module => !(module is null) || App.Project.Modules.Count(m => m.IsSelected) == 1);
			}
		}

		public ICommand Advanced {
			get {
				return new RelayCommand(() => {
					var dialog = new ProjectTabAdvancedView(App.Project);
					dialog.Owner = Application.Current.MainWindow;
					dialog.ShowDialog();
				});
			}
		}

		void AddModule(string file) {
			if (!File.Exists(file)) {
				MessageBox.Show(string.Format("File '{0}' does not exists!", file), "ConfuserEx", MessageBoxButton.OK, MessageBoxImage.Error);
				return;
			}
			if (string.IsNullOrEmpty(App.Project.BaseDirectory)) {
				string directory = Path.GetDirectoryName(file);
				App.Project.BaseDirectory = directory;
				App.Project.OutputDirectory = Path.Combine(directory, "Confused");
			}
			var module = new ProjectModuleVM(App.Project, new ProjectModule());
			try {
				module.Path = Confuser.Core.Utils.GetRelativePath(file, App.Project.BaseDirectory) ?? file;
			}
			catch {
				module.Path = file;
			}
			App.Project.Modules.Add(module);
		}
	}
}

```

`ConfuserEx/ViewModel/UI/ProtectTabVM.cs`:

```cs
using System;
using System.IO;
using System.Threading;
using System.Windows;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using Confuser.Core;
using Confuser.Core.Project;
using GalaSoft.MvvmLight.CommandWpf;

namespace ConfuserEx.ViewModel {
	internal class ProtectTabVM : TabViewModel, ILogger {
		readonly Paragraph documentContent;
		CancellationTokenSource cancelSrc;
		double? progress = 0;
		bool? result;

		public ProtectTabVM(AppVM app)
			: base(app, "Protect!") {
			documentContent = new Paragraph();
			LogDocument = new FlowDocument();
			LogDocument.Blocks.Add(documentContent);
		}

		public ICommand ProtectCmd {
			get { return new RelayCommand(DoProtect, () => !App.NavigationDisabled); }
		}

		public ICommand CancelCmd {
			get { return new RelayCommand(DoCancel, () => App.NavigationDisabled); }
		}

		public double? Progress {
			get { return progress; }
			set { SetProperty(ref progress, value, "Progress"); }
		}

		public FlowDocument LogDocument { get; private set; }

		public bool? Result {
			get { return result; }
			set { SetProperty(ref result, value, "Result"); }
		}

		void DoProtect() {
			var parameters = new ConfuserParameters();
			parameters.Project = ((IViewModel<ConfuserProject>)App.Project).Model;
			if (File.Exists(App.FileName))
				Environment.CurrentDirectory = Path.GetDirectoryName(App.FileName);
			parameters.Logger = this;

			documentContent.Inlines.Clear();
			cancelSrc = new CancellationTokenSource();
			Result = null;
			Progress = null;
			begin = DateTime.Now;
			App.NavigationDisabled = true;

			ConfuserEngine.Run(parameters, cancelSrc.Token)
			              .ContinueWith(_ =>
			                            Application.Current.Dispatcher.BeginInvoke(new Action(() => {
				                            Progress = 0;
				                            App.NavigationDisabled = false;
				                            CommandManager.InvalidateRequerySuggested();
			                            })));
		}

		void DoCancel() {
			cancelSrc.Cancel();
		}

		void AppendLine(string format, Brush foreground, params object[] args) {
			Application.Current.Dispatcher.BeginInvoke(new Action(() => {
				documentContent.Inlines.Add(new Run(string.Format(format, args)) { Foreground = foreground });
				documentContent.Inlines.Add(new LineBreak());
			}));
		}

		#region Logger Impl

		DateTime begin;

		void ILogger.Debug(string msg) {
			AppendLine("[DEBUG] {0}", Brushes.Gray, msg);
		}

		void ILogger.DebugFormat(string format, params object[] args) {
			AppendLine("[DEBUG] {0}", Brushes.Gray, string.Format(format, args));
		}

		void ILogger.Info(string msg) {
			AppendLine(" [INFO] {0}", Brushes.White, msg);
		}

		void ILogger.InfoFormat(string format, params object[] args) {
			AppendLine(" [INFO] {0}", Brushes.White, string.Format(format, args));
		}

		void ILogger.Warn(string msg) {
			AppendLine(" [WARN] {0}", Brushes.Yellow, msg);
		}

		void ILogger.WarnFormat(string format, params object[] args) {
			AppendLine(" [WARN] {0}", Brushes.Yellow, string.Format(format, args));
		}

		void ILogger.WarnException(string msg, Exception ex) {
			AppendLine(" [WARN] {0}", Brushes.Yellow, msg);
			AppendLine("Exception: {0}", Brushes.Yellow, ex);
		}

		void ILogger.Error(string msg) {
			AppendLine("[ERROR] {0}", Brushes.Red, msg);
		}

		void ILogger.ErrorFormat(string format, params object[] args) {
			AppendLine("[ERROR] {0}", Brushes.Red, string.Format(format, args));
		}

		void ILogger.ErrorException(string msg, Exception ex) {
			AppendLine("[ERROR] {0}", Brushes.Red, msg);
			AppendLine("Exception: {0}", Brushes.Red, ex);
		}

		void ILogger.Progress(int progress, int overall) {
			Progress = (double)progress / overall;
		}

		void ILogger.EndProgress() {
			Progress = null;
		}

		void ILogger.Finish(bool successful) {
			DateTime now = DateTime.Now;
			string timeString = string.Format(
				"at {0}, {1}:{2:d2} elapsed.",
				now.ToShortTimeString(),
				(int)now.Subtract(begin).TotalMinutes,
				now.Subtract(begin).Seconds);
			if (successful)
				AppendLine("Finished {0}", Brushes.Lime, timeString);
			else
				AppendLine("Failed {0}", Brushes.Red, timeString);
			Result = successful;
		}

		#endregion
	}
}

```

`ConfuserEx/ViewModel/UI/SettingsTabVM.cs`:

```cs
using System;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using System.Windows.Input;
using Confuser.Core;
using Confuser.Core.Project;
using ConfuserEx.Views;
using GalaSoft.MvvmLight.CommandWpf;

namespace ConfuserEx.ViewModel {
	internal class SettingsTabVM : TabViewModel {
		bool hasPacker;
		IRuleContainer selectedList;
		int selectedRuleIndex;

		public SettingsTabVM(AppVM app)
			: base(app, "Settings") {
			app.PropertyChanged += (sender, e) => {
				if (e.PropertyName == "Project")
					InitProject();
			};
			InitProject();
		}

		public bool HasPacker {
			get { return hasPacker; }
			set { SetProperty(ref hasPacker, value, "HasPacker"); }
		}

		public IList ModulesView { get; private set; }

		public IRuleContainer SelectedList {
			get { return selectedList; }
			set {
				if (SetProperty(ref selectedList, value, "SelectedList"))
					SelectedRuleIndex = value.Rules.Any() ? 0 : -1;
			}
		}

		public int SelectedRuleIndex {
			get { return selectedRuleIndex; }
			set { SetProperty(ref selectedRuleIndex, value, "SelectedRuleIndex"); }
		}

		public ICommand Add {
			get {
				var cmd =  new RelayCommand(() => {
					Debug.Assert(SelectedList != null);

					var rule = new ProjectRuleVM(App.Project, new Rule());
					rule.Pattern = "true";
					SelectedList.Rules.Add(rule);
					SelectedRuleIndex = SelectedList.Rules.Count - 1;
				}, () => SelectedList != null);

				return cmd;
			}
		}

		public ICommand Remove {
			get {
				var cmd = new RelayCommand(() => {
					int selIndex = SelectedRuleIndex;
					Debug.Assert(SelectedList != null);
					Debug.Assert(selIndex != -1);

					ProjectRuleVM rule = SelectedList.Rules[selIndex];
					SelectedList.Rules.RemoveAt(selIndex);
					SelectedRuleIndex = selIndex >= SelectedList.Rules.Count ? SelectedList.Rules.Count - 1 : selIndex;
				}, () => SelectedRuleIndex != -1 && SelectedList != null);

				return cmd;
			}
		}

		public ICommand Edit {
			get {
				var cmd = new RelayCommand<ProjectRuleVM>(rule => {
					if (rule is null) {
						Debug.Assert(SelectedRuleIndex != -1);
						rule = SelectedList.Rules[SelectedRuleIndex];
					}
					var dialog = new ProjectRuleView(App.Project, rule);
					dialog.Owner = Application.Current.MainWindow;
					dialog.ShowDialog();
					dialog.Cleanup();
				}, rule => !(rule is null) || (SelectedRuleIndex != -1 && SelectedList != null));

				return cmd;
			}
		}

		void InitProject() {
			ModulesView = new CompositeCollection {
				App.Project,
				new CollectionContainer { Collection = App.Project.Modules }
			};
			OnPropertyChanged("ModulesView");
			HasPacker = App.Project.Packer != null;

			if (SelectedList is null)
				SelectedList = ModulesView[0] as IRuleContainer;
		}

		protected override void OnPropertyChanged(string property) {
			if (property == "HasPacker") {
				if (hasPacker && App.Project.Packer == null)
					App.Project.Packer = new ProjectSettingVM<Packer>(App.Project, new SettingItem<Packer> { Id = App.Project.Packers[0].Id });
				else if (!hasPacker)
					App.Project.Packer = null;
			}
			base.OnPropertyChanged(property);
		}
	}
}

```

`ConfuserEx/ViewModel/UI/TabViewModel.cs`:

```cs
using System;

namespace ConfuserEx.ViewModel {
	public abstract class TabViewModel : ViewModelBase {
		protected TabViewModel(AppVM app, string header) {
			App = app;
			Header = header;
		}

		public AppVM App { get; private set; }
		public string Header { get; private set; }
	}
}
```

`ConfuserEx/ViewModel/Utils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Linq;

namespace ConfuserEx.ViewModel {
	public static class Utils {
		public static ObservableCollection<T> Wrap<T>(IList<T> list) {
			var ret = new ObservableCollection<T>(list);

			ret.CollectionChanged += (sender, e) => {
				var collection = (ObservableCollection<T>)sender;
				switch (e.Action) {
					case NotifyCollectionChangedAction.Reset:
						list.Clear();
						foreach (T item in collection)
							list.Add(item);
						break;

					case NotifyCollectionChangedAction.Add:
						for (int i = 0; i < e.NewItems.Count; i++)
							list.Insert(e.NewStartingIndex + i, (T)e.NewItems[i]);
						break;

					case NotifyCollectionChangedAction.Remove:
						for (int i = 0; i < e.OldItems.Count; i++)
							list.RemoveAt(e.OldStartingIndex);
						break;

					case NotifyCollectionChangedAction.Move:
						list.RemoveAt(e.OldStartingIndex);
						list.Insert(e.NewStartingIndex, (T)e.NewItems[0]);
						break;

					case NotifyCollectionChangedAction.Replace:
						list[e.NewStartingIndex] = (T)e.NewItems[0];
						break;
				}
			};
			return ret;
		}

		public static ObservableCollection<TViewModel> Wrap<TModel, TViewModel>(IList<TModel> list, Func<TModel, TViewModel> transform) where TViewModel : IViewModel<TModel> {
			var ret = new ObservableCollection<TViewModel>(list.Select(item => transform(item)));

			ret.CollectionChanged += (sender, e) => {
				var collection = (ObservableCollection<TViewModel>)sender;
				switch (e.Action) {
					case NotifyCollectionChangedAction.Reset:
						list.Clear();
						foreach (TViewModel item in collection)
							list.Add(item.Model);
						break;

					case NotifyCollectionChangedAction.Add:
						for (int i = 0; i < e.NewItems.Count; i++)
							list.Insert(e.NewStartingIndex + i, ((TViewModel)e.NewItems[i]).Model);
						break;

					case NotifyCollectionChangedAction.Remove:
						for (int i = 0; i < e.OldItems.Count; i++)
							list.RemoveAt(e.OldStartingIndex);
						break;

					case NotifyCollectionChangedAction.Move:
						list.RemoveAt(e.OldStartingIndex);
						list.Insert(e.NewStartingIndex, ((TViewModel)e.NewItems[0]).Model);
						break;

					case NotifyCollectionChangedAction.Replace:
						list[e.NewStartingIndex] = ((TViewModel)e.NewItems[0]).Model;
						break;
				}
			};
			return ret;
		}
	}
}
```

`ConfuserEx/ViewModel/ViewModelBase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace ConfuserEx.ViewModel {
	public class ViewModelBase : INotifyPropertyChanged {
		// http://stackoverflow.com/a/1316417/462805

		public event PropertyChangedEventHandler PropertyChanged;

		protected virtual void OnPropertyChanged(string property) {
			if (PropertyChanged != null)
				PropertyChanged(this, new PropertyChangedEventArgs(property));
		}

		protected bool SetProperty<T>(ref T field, T value, string property) {
			if (!EqualityComparer<T>.Default.Equals(field, value)) {
				field = value;
				OnPropertyChanged(property);
				return true;
			}
			return false;
		}

		protected bool SetProperty<T>(bool changed, Action<T> setter, T value, string property) {
			if (changed) {
				setter(value);
				OnPropertyChanged(property);
				return true;
			}
			return false;
		}
	}
}
```

`ConfuserEx/Views.xaml`:

```xaml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <ResourceDictionary.MergedDictionaries>
        <ResourceDictionary Source="Views\ProjectTabView.xaml" />
        <ResourceDictionary Source="Views\SettingsTabView.xaml" />
        <ResourceDictionary Source="Views\ProtectTabView.xaml" />
        <ResourceDictionary Source="Views\AboutTabView.xaml" />
    </ResourceDictionary.MergedDictionaries>
</ResourceDictionary>
```

`ConfuserEx/Views/AboutTabView.xaml`:

```xaml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:ConfuserEx"
                    xmlns:vm="clr-namespace:ConfuserEx.ViewModel"
                    xmlns:core="clr-namespace:Confuser.Core;assembly=Confuser.Core">
    <DataTemplate DataType="{x:Type vm:AboutTabVM}">
        <Grid Background="Transparent" Margin="10" x:Name="Root">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="400px" />
                <ColumnDefinition Width="*" />
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition Height="70px" />
                <RowDefinition Height="*" />
            </Grid.RowDefinitions>

            <Grid Grid.Row="0" Grid.Column="0" HorizontalAlignment="Center">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="70px" />
                    <ColumnDefinition Width="*" />
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="*" />
                    <RowDefinition Height="*" />
                </Grid.RowDefinitions>
                <Image Grid.Row="0" Grid.Column="0" Grid.RowSpan="2" Source="{Binding Icon}" Width="64" Height="64" />
                <Label Grid.Row="0" Grid.Column="1" FontSize="20" Content="ConfuserEx" Foreground="#ffffff" />
                <TextBox Grid.Row="1" Grid.Column="1" FontSize="14" Text="{x:Static core:ConfuserEngine.Version}"
                         Foreground="#a0a0a0" BorderThickness="0" VerticalAlignment="Center" Background="Transparent"
                         IsReadOnly="True" IsReadOnlyCaretVisible="True" local:Skin.FocusOverlay="False" />
            </Grid>

            <DockPanel Grid.Row="1" Grid.Column="0" Margin="10" LastChildFill="True"
                       VerticalAlignment="Stretch" HorizontalAlignment="Stretch">

                <Separator DockPanel.Dock="Top" />
                <Separator DockPanel.Dock="Bottom" />

                <StackPanel TextBlock.FontSize="13" VerticalAlignment="Center" HorizontalAlignment="Stretch">
                    <Label FontWeight="Bold">ConfuserEx, a .NET protector</Label>
                    <Label>Developed by Martin Karing, open sourced under MIT license.</Label>
                    <Label>
                        <TextBlock>
                            <Hyperlink NavigateUri="https://mkaring.github.io/ConfuserEx/"
                                       Command="{Binding LaunchBrowser}"
                                       CommandParameter="https://mkaring.github.io/ConfuserEx/">
                                Visit the project page for details.
                            </Hyperlink>
                        </TextBlock>
                    </Label>
                    <Label Height="20px" />

                    <Label>If you like it or find it useful,</Label>
                    <Label>
                        <TextBlock>
                            <Hyperlink NavigateUri="https://mkaring.github.io/ConfuserEx/#donation"
                                       Command="{Binding LaunchBrowser}"
                                       CommandParameter="https://mkaring.github.io/ConfuserEx/#donation">
                                feel free to support the project by making a donation!
                            </Hyperlink>
                        </TextBlock>
                    </Label>
                </StackPanel>
            </DockPanel>

            <StackPanel Grid.Column="1" Grid.RowSpan="2" TextBlock.FontSize="13" Margin="10"
                        VerticalAlignment="Stretch" HorizontalAlignment="Center">
                <Label HorizontalContentAlignment="Center">Special Thanks to:</Label>
                <Label HorizontalContentAlignment="Center">Ki</Label>
                <Label HorizontalContentAlignment="Center">0xd4d</Label>
                <Label HorizontalContentAlignment="Center">CodeCracker</Label>
                <Label HorizontalContentAlignment="Center">JeRRy</Label>
                <Label HorizontalContentAlignment="Center">kao</Label>
                <Label HorizontalContentAlignment="Center">Kurapica</Label>
                <Label HorizontalContentAlignment="Center">UbbeLoL</Label>
                <Label HorizontalContentAlignment="Center">whoknows</Label>
                <Label HorizontalContentAlignment="Center">Members of Black Storm Forum</Label>
                <Label HorizontalContentAlignment="Center">and You!</Label>
            </StackPanel>
        </Grid>
    </DataTemplate>
</ResourceDictionary>

```

`ConfuserEx/Views/ProjectModuleView.xaml`:

```xaml
<Window x:Class="ConfuserEx.Views.ProjectModuleView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        xmlns:vm="clr-namespace:ConfuserEx.ViewModel" 
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="d"
        Title="{Binding Path, StringFormat=Edit module \'{0}\'...}" Style="{StaticResource DarkWindow}"
        SizeToContent="WidthAndHeight" ShowInTaskbar="False" ResizeMode="NoResize" 
        d:DataContext="{d:DesignInstance vm:ProjectModuleVM}">
    <Grid Margin="5">
        <Grid.Resources>
            <Style TargetType="{x:Type Label}" BasedOn="{StaticResource {x:Type Label}}">
                <Style.Setters>
                    <Setter Property="HorizontalContentAlignment" Value="Right" />
                    <Setter Property="VerticalContentAlignment" Value="Center" />
                    <Setter Property="Padding" Value="0 0 5 0" />
                </Style.Setters>
            </Style>
            <Style TargetType="{x:Type TextBox}" BasedOn="{StaticResource {x:Type TextBox}}">
                <Style.Setters>
                    <Setter Property="VerticalContentAlignment" Value="Center" />
                    <Setter Property="Margin" Value="5" />
                </Style.Setters>
            </Style>
            <Style TargetType="{x:Type Button}" x:Key="FilesystemSelectButton" BasedOn="{StaticResource {x:Type Button}}">
                <Style.Setters>
                    <Setter Property="ContentTemplate">
                        <Setter.Value>
                            <DataTemplate>
                                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf141;" Height="10px" TextOptions.TextRenderingMode="GrayScale" />
                            </DataTemplate>
                        </Setter.Value>
                    </Setter>
                    <Setter Property="Height" Value="26" />
                    <Setter Property="Margin" Value="5" />
                    <Setter Property="VerticalAlignment" Value="Center" />
                </Style.Setters>
            </Style>
            <local:EmptyToBoolConverter x:Key="EmptyToBoolConverter" />
        </Grid.Resources>
        <Grid.RowDefinitions>
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="150px" />
            <ColumnDefinition Width="250px" />
            <ColumnDefinition Width="35px" />
        </Grid.ColumnDefinitions>

        <Label Content="Assembly Path:" Grid.Row="0" Grid.Column="0" />
        <TextBox Grid.Row="0" Grid.Column="1" Grid.ColumnSpan="2"
                 Text="{Binding Path, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />

        <Label Grid.Row="1" Grid.Column="0" Content="Strong Name" FontWeight="Bold" />
        <Separator Grid.Row="1" Grid.Column="1" Grid.ColumnSpan="2" VerticalAlignment="Center"/>

        <Label Content="Key Path:" Grid.Row="2" Grid.Column="0" />
        <TextBox x:Name="StrongNameKeyPathTextBox" Grid.Row="2" Grid.Column="1"
                 Text="{Binding SNKeyPath, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />
        <Button Grid.Row="2" Grid.Column="2" Click="ChooseSNKey" Style="{StaticResource FilesystemSelectButton}" />

        <Label Content="Key Password:" Grid.Row="3" Grid.Column="0" />
        <TextBox x:Name="StrongNameKeyPasswordTextBox" Grid.Row="3" Grid.Column="1" Grid.ColumnSpan="2"
                 Text="{Binding SNKeyPassword, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 IsEnabled="{Binding SNKeyPath, Converter={StaticResource EmptyToBoolConverter}, ConverterParameter=false}"/>

        <Label Grid.Row="4" Grid.Column="0" Content="Enhanced Strong Name" FontWeight="Bold" />
        <Separator Grid.Row="4" Grid.Column="1" Grid.ColumnSpan="2" VerticalAlignment="Center"/>

        <Label Content="Signature Key Path:" Grid.Row="5" Grid.Column="0" />
        <TextBox x:Name="StrongNameSigKeyPathTextBox" Grid.Row="5" Grid.Column="1"
                 Text="{Binding SNSigKeyPath, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />
        <Button Grid.Row="5" Grid.Column="2" Click="ChooseSNSigKey" Style="{StaticResource FilesystemSelectButton}" />

        <Label Content="Signature Key Password:" Grid.Row="6" Grid.Column="0" />
        <TextBox x:Name="StrongNameSigKeyPasswordTextBox" Grid.Row="6" Grid.Column="1" Grid.ColumnSpan="2"
                 Text="{Binding SNSigKeyPassword, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 IsEnabled="{Binding SNSigKeyPath, Converter={StaticResource EmptyToBoolConverter}, ConverterParameter=false}" />

        <Label Content="Signature Public Key Path:" Grid.Row="7" Grid.Column="0" />
        <TextBox x:Name="StrongNamePubSigKeyPathTextBox" Grid.Row="7" Grid.Column="1"
                 Text="{Binding SNPubSigKeyPath, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />
        <Button Grid.Row="7" Grid.Column="2" Click="ChooseSNPublicSigKey" Style="{StaticResource FilesystemSelectButton}" />

        <Label Content="Identity Key Path:" Grid.Row="8" Grid.Column="0" />
        <TextBox x:Name="StrongNameIdentKeyPathTextBox" Grid.Row="8" Grid.Column="1"
                 Text="{Binding SNKeyPath, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />
        <Button Grid.Row="8" Grid.Column="2" Click="ChooseSNKey" Style="{StaticResource FilesystemSelectButton}" />

        <Label Content="Identity Key Password:" Grid.Row="9" Grid.Column="0" />
        <TextBox x:Name="StrongNameIdentKeyPasswordTextBox" Grid.Row="9" Grid.Column="1" Grid.ColumnSpan="2"
                 Text="{Binding SNKeyPassword, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 IsEnabled="{Binding SNKeyPath, Converter={StaticResource EmptyToBoolConverter}, ConverterParameter=false}" />

        <Label Content="Identity Public Key Path:" Grid.Row="10" Grid.Column="0" />
        <TextBox x:Name="StrongNamePubKeyPathTextBox" Grid.Row="10" Grid.Column="1"
                 Text="{Binding SNPubKeyPath, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}" />
        <Button Grid.Row="10" Grid.Column="2" Click="ChooseSNPublicKey" Style="{StaticResource FilesystemSelectButton}" />

        <Button Grid.Row="11" Grid.Column="0" Grid.ColumnSpan="3" HorizontalAlignment="Right" Content="Done"
                Width="70" Margin="5" Click="Done" />
    </Grid>
</Window>

```

`ConfuserEx/Views/ProjectModuleView.xaml.cs`:

```cs
using System;
using System.Windows;
using System.Windows.Controls;
using ConfuserEx.ViewModel;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx.Views {
	public partial class ProjectModuleView : Window {
		readonly ProjectModuleVM module;

		public ProjectModuleView(ProjectModuleVM module) {
			InitializeComponent();
			this.module = module;
			DataContext = module;
		}

		void Done(object sender, RoutedEventArgs e) {
			DialogResult = true;
		}

		void ChooseSNKey(object sender, RoutedEventArgs e) => 
			module.SNKeyPath = ChooseKey();

		void ChooseSNSigKey(object sender, RoutedEventArgs e) => 
			module.SNSigKeyPath = ChooseKey();

		void ChooseSNPublicKey(object sender, RoutedEventArgs e) =>
			module.SNPubKeyPath = ChooseKey();

		void ChooseSNPublicSigKey(object sender, RoutedEventArgs e) =>
			module.SNPubSigKeyPath = ChooseKey();

		string ChooseKey() {
			var ofd = new VistaOpenFileDialog {
				Filter = "Supported Key Files (*.snk, *.pfx)|*.snk;*.pfx|All Files (*.*)|*.*"
			};

			return ofd.ShowDialog() ?? false ? ofd.FileName : null;
		}
	}
}

```

`ConfuserEx/Views/ProjectRuleView.xaml`:

```xaml
<Window x:Class="ConfuserEx.Views.ProjectRuleView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        xmlns:core="clr-namespace:Confuser.Core;assembly=Confuser.Core"
        xmlns:proj="clr-namespace:Confuser.Core.Project;assembly=Confuser.Core"
        Title="Edit rule..." Height="600" Width="400" x:Name="View"
        Style="{StaticResource DarkWindow}" ShowInTaskbar="False" ResizeMode="NoResize">
    <Grid Margin="5">
        <Grid.Resources>
            <local:ComponentConverter x:Key="ProtConverter"
                                      xmlns:PresentationOptions="http://schemas.microsoft.com/winfx/2006/xaml/presentation/options"
                                      PresentationOptions:Freeze="True"
                                      Components="{Binding Project.Protections}" />
        </Grid.Resources>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="36px" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="25px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="36px" />
            <RowDefinition Height="25px" />
            <RowDefinition Height="*" />
            <RowDefinition Height="40px" />
        </Grid.RowDefinitions>

        <Label Grid.Row="0" Grid.ColumnSpan="2" Content="Pattern:" VerticalAlignment="Center"
               HorizontalAlignment="Left" />

        <TextBox x:Name="pattern" Grid.Row="1" Grid.ColumnSpan="2"
                 Text="{Binding Pattern, UpdateSourceTrigger=PropertyChanged}" FontFamily="Consolas" Margin="5"
                 VerticalContentAlignment="Center" />
        <Image x:Name="errorImg" Grid.Row="1" Grid.ColumnSpan="2" Source="{StaticResource Error}"
               Width="16px" Height="16px" ToolTip="{Binding ExpressionError}" Margin="0,0,10,0"
               Visibility="Hidden" HorizontalAlignment="Right" />

        <DockPanel Grid.Row="2" Grid.ColumnSpan="2" LastChildFill="False">
            <Label DockPanel.Dock="Left" Content="Preset : " VerticalAlignment="Center" />
            <ComboBox DockPanel.Dock="Left" SelectedItem="{Binding Preset, UpdateSourceTrigger=PropertyChanged}"
                      Margin="5" Width="100" VerticalAlignment="Center"
                      ItemsSource="{local:EnumValues {x:Type core:ProtectionPreset}}" />
            <CheckBox DockPanel.Dock="Right" Content="Inherit protections"
                      IsChecked="{Binding Inherit}" Margin="5" VerticalAlignment="Center" />
        </DockPanel>

        <Label Grid.Row="3" Content="Protections:" VerticalAlignment="Center"
               HorizontalAlignment="Left" />

        <ListBox x:Name="prots" Grid.Row="4" Margin="5"
                 ItemsSource="{Binding Protections}" Grid.IsSharedSizeScope="True">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition SharedSizeGroup="Action" />
                            <ColumnDefinition Width="10px" />
                            <ColumnDefinition SharedSizeGroup="Protection" />
                        </Grid.ColumnDefinitions>
                        <ComboBox Grid.Column="0" Width="80" SelectedItem="{Binding Action}" IsEnabled="True"
                                  ItemsSource="{local:EnumValues {x:Type proj:SettingItemAction}}" />
                        <local:CompComboBox Grid.Column="2" Width="150"
                                            Components="{Binding Project.Protections, ElementName=View}"
                                            SelectedComponent="{Binding Id, Converter={StaticResource ProtConverter}, Mode=TwoWay}" />
                    </Grid>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <DockPanel Grid.Row="4" Grid.Column="1" LastChildFill="False">
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="AddBtn">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="RemoveBtn">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
        </DockPanel>

        <Button Grid.Row="5" Grid.ColumnSpan="2" HorizontalAlignment="Right"
                Margin="5" Width="70" Content="Done" Click="Done" />
    </Grid>
</Window>
```

`ConfuserEx/Views/ProjectRuleView.xaml.cs`:

```cs
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Media;
using Confuser.Core;
using Confuser.Core.Project;
using ConfuserEx.ViewModel;
using GalaSoft.MvvmLight.CommandWpf;

namespace ConfuserEx.Views {
	public partial class ProjectRuleView : Window {
		readonly ProjectVM proj;
		readonly ProjectRuleVM rule;

		public ProjectRuleView(ProjectVM proj, ProjectRuleVM rule) {
			InitializeComponent();
			this.rule = rule;
			this.proj = proj;
			DataContext = rule;

			rule.PropertyChanged += OnPropertyChanged;
			CheckValidity();
		}

		public ProjectVM Project {
			get { return proj; }
		}

		public override void OnApplyTemplate() {
			base.OnApplyTemplate();

			AddBtn.Command = new RelayCommand(() => {
				var prot = new ProjectSettingVM<Protection>(proj, new SettingItem<Protection>());
				prot.Id = proj.Protections[0].Id;
				rule.Protections.Add(prot);
			});
			RemoveBtn.Command = new RelayCommand(() => {
				int selIndex = prots.SelectedIndex;
				Debug.Assert(selIndex != -1);

				rule.Protections.RemoveAt(prots.SelectedIndex);
				prots.SelectedIndex = selIndex >= rule.Protections.Count ? rule.Protections.Count - 1 : selIndex;
			}, () => prots.SelectedIndex != -1);

			prots.SelectionChanged += (sender, args) => (RemoveBtn.Command as RelayCommand)?.RaiseCanExecuteChanged();
		}

		public void Cleanup() {
			rule.PropertyChanged -= OnPropertyChanged;
		}

		void OnPropertyChanged(object sender, PropertyChangedEventArgs e) {
			if (e.PropertyName == "Expression")
				CheckValidity();
		}

		void CheckValidity() {
			if (rule.Expression == null) {
				pattern.BorderBrush = Brushes.Red;
				errorImg.Visibility = Visibility.Visible;
			}
			else {
				pattern.ClearValue(BorderBrushProperty);
				errorImg.Visibility = Visibility.Hidden;
			}
		}

		void Done(object sender, RoutedEventArgs e) {
			DialogResult = true;
		}
	}
}

```

`ConfuserEx/Views/ProjectTabAdvancedView.xaml`:

```xaml
<Window x:Class="ConfuserEx.Views.ProjectTabAdvancedView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:ConfuserEx"
        Title="Advanced Settings..." Height="400" Width="600"
        Style="{StaticResource DarkWindow}" ShowInTaskbar="False" ResizeMode="NoResize">
    <Grid Margin="5">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="36px" />
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="36px" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="36px" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <Label Grid.Row="0" Grid.Column="0" Content="Probe Paths :" Margin="5" VerticalAlignment="Center" />
        <ListBox Grid.Row="1" Grid.Column="0" Margin="5" x:Name="ProbePaths" ItemsSource="{Binding ProbePaths}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.DirectoryCmd}"
                 ScrollViewer.CanContentScroll="False" />
        <StackPanel Grid.Row="1" Grid.Column="1">
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="AddProbe">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="RemoveProbe">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
        </StackPanel>

        <Label Grid.Row="0" Grid.Column="2" Content="Plugins :" Margin="5" VerticalAlignment="Center" />
        <ListBox Grid.Row="1" Grid.Column="2" Margin="5" x:Name="PluginPaths" ItemsSource="{Binding Plugins}"
                 local:FileDragDrop.Command="{x:Static local:FileDragDrop.FileCmd}"
                 ScrollViewer.CanContentScroll="False" />
        <StackPanel Grid.Row="1" Grid.Column="3">
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="AddPlugin">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
            <Button Height="26" Margin="5" DockPanel.Dock="Top" x:Name="RemovePlugin">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>
        </StackPanel>
    </Grid>
</Window>
```

`ConfuserEx/Views/ProjectTabAdvancedView.xaml.cs`:

```cs
using System;
using System.Diagnostics;
using System.Windows;
using ConfuserEx.ViewModel;
using GalaSoft.MvvmLight.CommandWpf;
using Ookii.Dialogs.Wpf;

namespace ConfuserEx.Views {
	public partial class ProjectTabAdvancedView : Window {
		readonly ProjectVM project;

		public ProjectTabAdvancedView(ProjectVM project) {
			InitializeComponent();
			this.project = project;
			DataContext = project;
		}

		public override void OnApplyTemplate() {
			base.OnApplyTemplate();

			AddPlugin.Command = new RelayCommand(() => {
				var ofd = new VistaOpenFileDialog();
				ofd.Filter = ".NET assemblies (*.exe, *.dll)|*.exe;*.dll|All Files (*.*)|*.*";
				ofd.Multiselect = true;
				if (ofd.ShowDialog() ?? false) {
					foreach (string plugin in ofd.FileNames) {
						try {
							ComponentDiscovery.LoadComponents(project.Protections, project.Packers, plugin);
							project.Plugins.Add(new StringItem(plugin));
						}
						catch {
							MessageBox.Show("Failed to load plugin '" + plugin + "'.");
						}
					}
				}
			});

			RemovePlugin.Command = new RelayCommand(() => {
				int selIndex = PluginPaths.SelectedIndex;
				Debug.Assert(selIndex != -1);

				string plugin = project.Plugins[selIndex].Item;
				ComponentDiscovery.RemoveComponents(project.Protections, project.Packers, plugin);
				project.Plugins.RemoveAt(selIndex);

				PluginPaths.SelectedIndex = selIndex >= project.Plugins.Count ? project.Plugins.Count - 1 : selIndex;
			}, () => PluginPaths.SelectedIndex != -1);


			AddProbe.Command = new RelayCommand(() => {
				var fbd = new VistaFolderBrowserDialog();
				if (fbd.ShowDialog() ?? false)
					project.ProbePaths.Add(new StringItem(fbd.SelectedPath));
			});

			RemoveProbe.Command = new RelayCommand(() => {
				int selIndex = ProbePaths.SelectedIndex;
				Debug.Assert(selIndex != -1);
				project.ProbePaths.RemoveAt(selIndex);
				ProbePaths.SelectedIndex = selIndex >= project.ProbePaths.Count ? project.ProbePaths.Count - 1 : selIndex;
			}, () => ProbePaths.SelectedIndex != -1);
		}
	}
}
```

`ConfuserEx/Views/ProjectTabView.xaml`:

```xaml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:ConfuserEx"
                    xmlns:vm="clr-namespace:ConfuserEx.ViewModel">
    <DataTemplate DataType="{x:Type vm:ProjectTabVM}">
        <Grid Background="Transparent" x:Name="PART_ProjectTabGrid">
            <Grid.RowDefinitions>
                <RowDefinition Height="36px" />
                <RowDefinition Height="36px" />
                <RowDefinition Height="36px" />
                <RowDefinition Height="*" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="150px" />
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="36px" />
            </Grid.ColumnDefinitions>
            <Label Content="Base Directory : " Grid.Row="0" Grid.Column="0" HorizontalContentAlignment="Right"
                   VerticalContentAlignment="Center" />
            <TextBox Grid.Row="0" Grid.Column="1" Margin="5" VerticalContentAlignment="Center"
                     Text="{Binding App.Project.BaseDirectory, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                     local:FileDragDrop.Command="{x:Static local:FileDragDrop.DirectoryCmd}" />
            <Button Grid.Row="0" Grid.Column="2" Margin="5" VerticalAlignment="Center" Height="26"
                    Command="{Binding ChooseBaseDir}">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf141;" Height="10px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>

            <Label Content="Output Directory : " Grid.Row="1" Grid.Column="0" HorizontalContentAlignment="Right"
                   VerticalContentAlignment="Center" />
            <TextBox Grid.Row="1" Grid.Column="1" Margin="5" VerticalContentAlignment="Center"
                     Text="{Binding App.Project.OutputDirectory, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                     local:FileDragDrop.Command="{x:Static local:FileDragDrop.DirectoryCmd}" />
            <Button Grid.Row="1" Grid.Column="2" Margin="5" VerticalAlignment="Center" Height="26"
                    Command="{Binding ChooseOutputDir}">
                <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf141;" Height="10px"
                           TextOptions.TextRenderingMode="GrayScale" />
            </Button>

            <Grid Grid.Row="2" Grid.ColumnSpan="3">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="150px" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="Auto" />
                </Grid.ColumnDefinitions>
                <Label Content="Seed : " Grid.Column="0" HorizontalContentAlignment="Right"
                       VerticalContentAlignment="Center" />
                <TextBox Grid.Column="1" Margin="5" VerticalContentAlignment="Center"
                         Text="{Binding App.Project.Seed, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                         local:Skin.EmptyPrompt="Leave blank for random seed" />
                <CheckBox Grid.Column="2" Content="Generate Debug Symbols" VerticalAlignment="Center" Margin="5"
                          IsChecked="{Binding App.Project.Debug, Mode=TwoWay}" />
            </Grid>

            <ListBox Grid.Row="3" Grid.ColumnSpan="2" Margin="5" local:Skin.EmptyPrompt="Drag input modules here"
                     ItemsSource="{Binding App.Project.Modules}" HorizontalContentAlignment="Stretch"
                     SelectionMode="Extended" ScrollViewer.HorizontalScrollBarVisibility="Disabled"
                     Grid.IsSharedSizeScope="True" local:FileDragDrop.Command="{Binding DragDrop}"
                     ScrollViewer.CanContentScroll="False">
                <ListBox.ItemTemplate>
                    <DataTemplate DataType="{x:Type vm:ProjectModuleVM}">
                        <Grid>
                            <Grid.InputBindings>
                                <MouseBinding Gesture="LeftDoubleClick" 
                                              Command="{Binding DataContext.Edit, ElementName=PART_ProjectTabGrid}" 
                                              CommandParameter="{Binding}" />
                            </Grid.InputBindings>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto" />
                                <ColumnDefinition Width="*" />
                            </Grid.ColumnDefinitions>
                            <TextBlock Grid.Column="0" Text="{Binding AssemblyName}"
                                       TextAlignment="Left" Margin="0,0,5,0" TextTrimming="CharacterEllipsis" />
                            <TextBlock Grid.Column="1" Text="{Binding Path}"
                                       TextAlignment="Right" Margin="5,0,0,0" TextTrimming="CharacterEllipsis" />
                        </Grid>
                    </DataTemplate>
                </ListBox.ItemTemplate>
                <ListBox.ItemContainerStyle>
                    <Style TargetType="{x:Type ListBoxItem}" BasedOn="{StaticResource {x:Type ListBoxItem}}">
                        <Setter Property="IsSelected" Value="{Binding IsSelected}" />
                    </Style>
                </ListBox.ItemContainerStyle>
            </ListBox>
            <DockPanel Grid.Row="3" Grid.Column="2" LastChildFill="False">
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Add}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Remove}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Edit}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf044;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Bottom" Command="{Binding Advanced}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf013;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
            </DockPanel>
        </Grid>
    </DataTemplate>
</ResourceDictionary>

```

`ConfuserEx/Views/ProtectTabView.xaml`:

```xaml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:ConfuserEx"
                    xmlns:vm="clr-namespace:ConfuserEx.ViewModel">
    <DataTemplate DataType="{x:Type vm:ProtectTabVM}">
        <Grid Background="Transparent">
            <Grid.RowDefinitions>
                <RowDefinition Height="40px" />
                <RowDefinition Height="*" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="100px" />
                <ColumnDefinition Width="100px" />
            </Grid.ColumnDefinitions>

            <ProgressBar x:Name="progress" Grid.Row="0" Grid.Column="0" Margin="5"
                         Value="{Binding Progress}" Minimum="0" Maximum="1" />
            <Button Grid.Row="0" Grid.Column="1" Margin="5" Content="Protect!" Command="{Binding ProtectCmd}" />
            <Button Grid.Row="0" Grid.Column="2" Margin="5" Content="Cancel" Command="{Binding CancelCmd}" />
            <RichTextBox x:Name="log" Grid.Row="1" Grid.ColumnSpan="3" Margin="5" FontFamily="Consolas"
                         IsReadOnly="True" IsReadOnlyCaretVisible="True" local:Skin.RTBDocument="{Binding LogDocument}"
                         VerticalScrollBarVisibility="Visible" />
        </Grid>
        <DataTemplate.Triggers>
            <DataTrigger Binding="{Binding Progress}" Value="{x:Null}">
                <Setter TargetName="progress" Property="IsIndeterminate" Value="True" />
            </DataTrigger>
            <DataTrigger Binding="{Binding Result}" Value="True">
                <Setter TargetName="log" Property="BorderBrush" Value="#40ff40" />
            </DataTrigger>
            <DataTrigger Binding="{Binding Result}" Value="False">
                <Setter TargetName="log" Property="BorderBrush" Value="#ff4040" />
            </DataTrigger>
        </DataTemplate.Triggers>
    </DataTemplate>
</ResourceDictionary>
```

`ConfuserEx/Views/SettingsTabView.xaml`:

```xaml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:ConfuserEx"
                    xmlns:vm="clr-namespace:ConfuserEx.ViewModel">
    <DataTemplate DataType="{x:Type vm:SettingsTabVM}">
        <Grid Background="Transparent" x:Name="PART_SettingsTabGrid">
            <Grid.Resources>
                <local:ComponentConverter x:Key="PackerConverter" x:Shared="False"
                                          Components="{Binding App.Project.Packers}" />
            </Grid.Resources>

            <Grid.RowDefinitions>
                <RowDefinition Height="40px" />
                <RowDefinition Height="40px" />
                <RowDefinition Height="*" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="200px" />
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="36px" />
            </Grid.ColumnDefinitions>

            <StackPanel Grid.Row="0" Grid.ColumnSpan="3" Orientation="Horizontal" Margin="5">
                <CheckBox Content="Packer : " VerticalAlignment="Center" HorizontalAlignment="Right"
                          Margin="5,0,0,0" IsChecked="{Binding HasPacker}" />
                <local:CompComboBox Width="300" Components="{Binding App.Project.Packers}" Margin="5,0,0,0"
                                    IsEnabled="{Binding HasPacker}" HorizontalAlignment="Left"
                                    VerticalAlignment="Center"
                                    SelectedComponent="{Binding App.Project.Packer.Id, Converter={StaticResource PackerConverter}, Mode=TwoWay}" />
            </StackPanel>

            <Label Grid.Row="1" Grid.Column="0" Content="Modules : " VerticalAlignment="Bottom"
                   HorizontalAlignment="Left" Margin="5,0,0,0" />
            <Label Grid.Row="1" Grid.Column="1" Content="Rules : " VerticalAlignment="Bottom"
                   HorizontalAlignment="Left" Margin="5,0,0,0" />

            <ListBox Grid.Row="2" Grid.Column="0" Margin="5" ItemsSource="{Binding ModulesView}"
                     SelectedItem="{Binding SelectedList}">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <TextBlock>
                            <TextBlock.Text>
                                <PriorityBinding>
                                    <Binding Path="SimpleName" />
                                    <Binding Source="&lt;Global settings&gt;" />
                                </PriorityBinding>
                            </TextBlock.Text>
                        </TextBlock>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
            <ListBox Grid.Row="2" Grid.Column="1" Margin="5" FontFamily="Consolas"
                     ItemsSource="{Binding SelectedList.Rules}"
                     SelectedIndex="{Binding SelectedRuleIndex}"
                     HorizontalContentAlignment="Stretch">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <TextBlock x:Name="txt" Text="{Binding Pattern}">
                            <TextBlock.InputBindings>
                                <MouseBinding Gesture="LeftDoubleClick" 
                                              Command="{Binding DataContext.Edit, ElementName=PART_SettingsTabGrid}" 
                                              CommandParameter="{Binding}" />
                            </TextBlock.InputBindings>
                        </TextBlock>
                        <DataTemplate.Triggers>
                            <DataTrigger Binding="{Binding Expression}" Value="{x:Null}">
                                <Setter TargetName="txt" Property="Foreground" Value="Red" />
                            </DataTrigger>
                        </DataTemplate.Triggers>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>

            <DockPanel Grid.Row="2" Grid.Column="2" LastChildFill="False">
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Add}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf067;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Remove}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf068;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
                <Button Height="26" Margin="5" DockPanel.Dock="Top" Command="{Binding Edit}">
                    <TextBlock FontSize="14px" FontFamily="{DynamicResource FontAwesome}" Text="&#xf044;" Height="12px"
                               TextOptions.TextRenderingMode="GrayScale" />
                </Button>
            </DockPanel>
        </Grid>
    </DataTemplate>
</ResourceDictionary>

```

`ConfuserEx/app.config`:

```config
<?xml version="1.0"?>

<configuration>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Practices.ServiceLocation" publicKeyToken="31BF3856AD364E35"
                          culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.2.0.0" newVersion="1.2.0.0" />
      </dependentAssembly>
    </assemblyBinding>
    <loadFromRemoteSources enabled="true" />
  </runtime>
</configuration>
```

`GlobalAssemblyInfo.cs`:

```cs
using System.Reflection;

[assembly: AssemblyProduct("ConfuserEx")]
[assembly: AssemblyCompany("Ki")]
[assembly: AssemblyCopyright("Copyright (C) Ki 2014")]

#if DEBUG

[assembly: AssemblyConfiguration("Debug")]
#else

[assembly: AssemblyConfiguration("Release")]
#endif

```

`LICENSE.md`:

```md
Copyright (c) 2014 yck1509  
Copyright (c) 2018 Martin Karing

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
# ConfuserEx

[![Build status][img_build]][build]
[![Test status][img_test]][test]
[![CodeFactor][img_codefactor]][codefactor]
[![Gitter Chat][img_gitter]][gitter]
[![MIT License][img_license]][license]

ConfuserEx is a open-source protector for .NET applications.
It is the successor of [Confuser][confuser] project.

## Features

* Supports .NET Framework 2.0/3.0/3.5/4.0/4.5/4.6/4.7/4.8
* Symbol renaming (Support WPF/BAML)
* Protection against debuggers/profilers
* Protection against memory dumping
* Protection against tampering (method encryption)
* Control flow obfuscation
* Constant/resources encryption
* Reference hiding proxies
* Disable decompilers
* Embedding dependency
* Compressing output
* Extensible plugin API
* Many more are coming!

# Usage

```Batchfile
Confuser.CLI.exe <path to project file>
```

The project file is a ConfuserEx Project (`*.crproj`).
The format of project file can be found in [docs\ProjectFormat.md][project_format]

# Bug Report

See the [Issues Report][issues] section of website.

# License

Licensed under the MIT license. See [LICENSE.md][license] for details.

# Credits

**[0xd4d]** for his awesome work and extensive knowledge!

[0xd4d]: https://github.com/0xd4d
[build]: https://ci.appveyor.com/project/mkaring/confuserex/branch/master
[codefactor]: https://www.codefactor.io/repository/github/mkaring/confuserex/overview/master
[confuser]: http://confuser.codeplex.com
[issues]: https://github.com/mkaring/ConfuserEx/issues
[gitter]: https://gitter.im/ConfuserEx/community
[license]: LICENSE.md
[project_format]: docs/ProjectFormat.md
[test]: https://ci.appveyor.com/project/mkaring/confuserex/branch/master/tests

[img_build]: https://img.shields.io/appveyor/ci/mkaring/ConfuserEx/master.svg?style=flat
[img_codefactor]: https://www.codefactor.io/repository/github/mkaring/confuserex/badge/master
[img_gitter]: https://img.shields.io/gitter/room/mkaring/ConfuserEx.svg?style=flat
[img_license]: https://img.shields.io/github/license/mkaring/ConfuserEx.svg?style=flat
[img_test]: https://img.shields.io/appveyor/tests/mkaring/ConfuserEx/master.svg?style=flat&compact_message

```

`Tests/118_EnhancedStrongName.Test/118_EnhancedStrongName.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>EnhancedStrongName.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\118_EnhancedStrongName\118_EnhancedStrongName.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Include="..\118_EnhancedStrongName\*.snk" Link="%(FileName).snk">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>

```

`Tests/118_EnhancedStrongName.Test/EnhancedStrongNameTest.cs`:

```cs
using System;
using System.IO;
using System.Threading.Tasks;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace EnhancedStrongName.Test {
	public class EnhancedStrongNameTest : TestBase {
		public EnhancedStrongNameTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "core")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/118")]
		public async Task EnhancedStrongName() =>
			await Run("118_EnhancedStrongName.exe",
				new[] {"My strong key token: 79A18AF4CEA8A9BD", "My signature is valid!"},
				NoProtections,
				projectModuleAction: projectModule => {
					projectModule.SNSigKeyPath = Path.Combine(Environment.CurrentDirectory, "SignatureKey.snk");
					projectModule.SNPubSigKeyPath = Path.Combine(Environment.CurrentDirectory, "SignaturePubKey.snk");
					projectModule.SNKeyPath = Path.Combine(Environment.CurrentDirectory, "IdentityKey.snk");
					projectModule.SNPubKeyPath = Path.Combine(Environment.CurrentDirectory, "IdentityPubKey.snk");
				});
	}
}

```

`Tests/118_EnhancedStrongName/118_EnhancedStrongName.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>EnhancedStrongName</RootNamespace>
    <SignAssembly>true</SignAssembly>
    <DelaySign>true</DelaySign>
    <AssemblyOriginatorKeyFile>IdentityPubKey.snk</AssemblyOriginatorKeyFile>
  </PropertyGroup>

  <Target Name="PostBuild" AfterTargets="PostBuildEvent">
    <Exec Command="&quot;$(SDK40ToolsPath)sn.exe&quot; -Ra &quot;$(TargetPath)&quot; &quot;$(ProjectDir)SignatureKey.snk&quot;" />
  </Target>

</Project>

```

`Tests/118_EnhancedStrongName/Attributes.cs`:

```cs
[assembly: System.Reflection.AssemblySignatureKey(
	"002400000c8000009400000006020000002400005253413100040000010001003dbf2a4a3ec2fdc1d1fbb41ada405236cfd7d60d9bc35107ac747bb0ab741136ec4e9f2ec380a5ce55c360db4e64df3b8f02eb81ecf47122ccda5c7e5a14b3bac847eac14223827586270a8a39383d4d09b73c19858fd28d9a21375019f9fe3563315e60ee7dfa3c9b8b11226ec678a244153e9c32d723c7f43e91ff389fff9f",
	"0f3904690b927bc2a63f3466de2f7899840782f9ed7905f3445d2709e83076d8365be7b2d3d59ef47936633dfda3106654c63172747e2fb037989b98161830c89e128fa5788c83341fae908de677e2c0dc2f73bda4d54f7dac4ef1b53c8bdac84a547223e9060f4e7b5cfae14dad6c56aabdbb09c784fe1c81bbdc1eee491704")
]

```

`Tests/118_EnhancedStrongName/IClrStrongName.cs`:

```cs
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;

namespace EnhancedStrongName {
	[ComConversionLoss, Guid("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown), SecurityCritical]
	[ComImport]
	internal interface IClrStrongName {
		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromAssemblyFile([MarshalAs(UnmanagedType.LPStr)] [In] string pszFilePath, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromAssemblyFileW([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromBlob([In] IntPtr pbBlob, [MarshalAs(UnmanagedType.U4)] [In] int cchBlob, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromFile([MarshalAs(UnmanagedType.LPStr)] [In] string pszFilePath, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromFileW([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int GetHashFromHandle([In] IntPtr hFile, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int piHashAlg, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbHash, [MarshalAs(UnmanagedType.U4)] [In] int cchHash, [MarshalAs(UnmanagedType.U4)] out int pchHash);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameCompareAssemblies([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzAssembly1, [MarshalAs(UnmanagedType.LPWStr)] [In] string pwzAssembly2, [MarshalAs(UnmanagedType.U4)] out int dwResult);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameFreeBuffer([In] IntPtr pbMemory);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameGetBlob([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] [Out] byte[] pbBlob, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int pcbBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameGetBlobFromImage([In] IntPtr pbBase, [MarshalAs(UnmanagedType.U4)] [In] int dwLength, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [Out] byte[] pbBlob, [MarshalAs(UnmanagedType.U4)] [In] [Out] ref int pcbBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameGetPublicKey([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] [In] byte[] pbKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbKeyBlob, out IntPtr ppbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbPublicKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameHashSize([MarshalAs(UnmanagedType.U4)] [In] int ulHashAlg, [MarshalAs(UnmanagedType.U4)] out int cbSize);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyDelete([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyGen([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.U4)] [In] int dwFlags, out IntPtr ppbKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyGenEx([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.U4)] [In] int dwFlags, [MarshalAs(UnmanagedType.U4)] [In] int dwKeySize, out IntPtr ppbKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameKeyInstall([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] [In] byte[] pbKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameSignatureGeneration([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.LPWStr)] [In] string pwzKeyContainer, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [In] byte[] pbKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbKeyBlob, [In] [Out] IntPtr ppbSignatureBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSignatureBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameSignatureGenerationEx([MarshalAs(UnmanagedType.LPWStr)] [In] string wszFilePath, [MarshalAs(UnmanagedType.LPWStr)] [In] string wszKeyContainer, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] [In] byte[] pbKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbKeyBlob, [In] [Out] IntPtr ppbSignatureBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSignatureBlob, [MarshalAs(UnmanagedType.U4)] [In] int dwFlags);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameSignatureSize([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [In] byte[] pbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbSize);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameSignatureVerification([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.U4)] [In] int dwInFlags, [MarshalAs(UnmanagedType.U4)] out int dwOutFlags);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameSignatureVerificationEx([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, [MarshalAs(UnmanagedType.I1)] [In] bool fForceVerification, [MarshalAs(UnmanagedType.I1)] out bool fWasVerified);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		[return: MarshalAs(UnmanagedType.U4)]
		int StrongNameSignatureVerificationFromImage([In] IntPtr pbBase, [MarshalAs(UnmanagedType.U4)] [In] int dwLength, [MarshalAs(UnmanagedType.U4)] [In] int dwInFlags, [MarshalAs(UnmanagedType.U4)] out int dwOutFlags);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameTokenFromAssembly([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameTokenFromAssemblyEx([MarshalAs(UnmanagedType.LPWStr)] [In] string pwzFilePath, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken, out IntPtr ppbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] out int pcbPublicKeyBlob);

		[MethodImpl(MethodImplOptions.PreserveSig | MethodImplOptions.InternalCall)]
		int StrongNameTokenFromPublicKey([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [In] byte[] pbPublicKeyBlob, [MarshalAs(UnmanagedType.U4)] [In] int cbPublicKeyBlob, out IntPtr ppbStrongNameToken, [MarshalAs(UnmanagedType.U4)] out int pcbStrongNameToken);
	}
}

```

`Tests/118_EnhancedStrongName/Program.cs`:

```cs
using System;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace EnhancedStrongName {
	public class Program {
		internal static int Main(string[] args) {
			Console.WriteLine("START");
			var assembly = typeof(Program).Assembly;
			var assemblyName = new AssemblyName(assembly.FullName);

			Console.WriteLine("My strong key token: " + BytesToString(assemblyName.GetPublicKeyToken()));

			var clrStrongName = (IClrStrongName)RuntimeEnvironment.GetRuntimeInterfaceAsObject(
				new Guid("B79B0ACD-F5CD-409b-B5A5-A16244610B92"),
				new Guid("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D"));

			int result = clrStrongName.StrongNameSignatureVerificationEx(assembly.Location, true, out var verified);
			if (result == 0 && verified)
				Console.WriteLine("My signature is valid!");

			Console.WriteLine("END");
			return 42;
		}

		private static string BytesToString(byte[] data) {
			var builder = new StringBuilder();
			foreach (var val in data) {
				builder.AppendFormat("{0:X2}", val);
			}
			return builder.ToString();
		}
	}
}

```

`Tests/123_InheritCustomAttr.Test/123_InheritCustomAttr.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>InheritCustomAttr.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\123_InheritCustomAttr\123_InheritCustomAttr.csproj" />
  </ItemGroup>

</Project>

```

`Tests/123_InheritCustomAttr.Test/InheritCustomAttributeTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.Renamer;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace _123_InheritCustomAttr.Test {
	public class InheritCustomAttributeTest : TestBase {
		public InheritCustomAttributeTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[MemberData(nameof(InheritCustomAttributeData))]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/123")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/161")]
		public async Task InheritCustomAttribute(string renameMode, bool flatten) =>
			await Run(
				"123_InheritCustomAttr.exe",
				new[] {"Monday", "43", "1"},
				new SettingItem<Protection>("rename") {{"mode", renameMode}, {"flatten", flatten ? "True" : "False"}},
				$"_{renameMode}_{flatten}",
				l => Assert.False(l.StartsWith("[WARN]"), "Logged line may not start with [WARN]\r\n" + l));

		public static IEnumerable<object[]> InheritCustomAttributeData() {
			foreach (var renameMode in new [] { nameof(RenameMode.Unicode), nameof(RenameMode.ASCII), nameof(RenameMode.Letters), nameof(RenameMode.Debug), nameof(RenameMode.Retain) })
				foreach (var flatten in new [] { true, false })
					yield return new object[] { renameMode, flatten };
		}
	}
}

```

`Tests/123_InheritCustomAttr/123_InheritCustomAttr.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>InheritCustomAttr</RootNamespace>
    <StartupObject>InheritCustomAttr.Program</StartupObject>
  </PropertyGroup>

</Project>

```

`Tests/123_InheritCustomAttr/C.cs`:

```cs
using System;

namespace InheritCustomAttr {
	abstract class C : I<DayOfWeek>, IDayOfWeek {
		[My(Value = 1)]
		public abstract DayOfWeek T { get; }
	}
}

```

`Tests/123_InheritCustomAttr/D.cs`:

```cs
using System;

namespace InheritCustomAttr {
	class D : C {
		#pragma warning disable CS0067
		// Just here to make sure it works.
		public event EventHandler<EventArgs> TestEvent;
		#pragma warning restore CS0067

		// this property should inherit the MyAttribute from its base class
		public override DayOfWeek T { get => DayOfWeek.Monday; }

		public virtual int U => 42;
	}
}

```

`Tests/123_InheritCustomAttr/E.cs`:

```cs
namespace InheritCustomAttr {
	// this should inherit T with the MyAttribute from its base class D, C
	sealed class E : D {
		public override int U => 43;
	}
}

```

`Tests/123_InheritCustomAttr/ExtReference/C.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace InheritCustomAttr.ExtReference {
	class C<TKey, TValue> : IExt<TKey, TValue>, IDictionary<TKey, TValue>, IDictionary {
		public TValue this[TKey key] { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
		public object this[object key] { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }

		public string Ext => throw new NotImplementedException();

		public int Count => throw new NotImplementedException();

		public ICollection<TKey> Keys => throw new NotImplementedException();

		public ICollection<TValue> Values => throw new NotImplementedException();

		public bool IsReadOnly => throw new NotImplementedException();

		public bool IsFixedSize => throw new NotImplementedException();

		public object SyncRoot => throw new NotImplementedException();

		public bool IsSynchronized => throw new NotImplementedException();

		ICollection IDictionary.Keys => throw new NotImplementedException();

		ICollection IDictionary.Values => throw new NotImplementedException();

		public void Add(TKey key, TValue value) => throw new NotImplementedException();

		public void Add(KeyValuePair<TKey, TValue> item) => throw new NotImplementedException();

		public void Add(object key, object value) => throw new NotImplementedException();

		public void Clear() => throw new NotImplementedException();

		public bool Contains(KeyValuePair<TKey, TValue> item) => throw new NotImplementedException();

		public bool Contains(object key) => throw new NotImplementedException();

		public bool ContainsKey(TKey key) => throw new NotImplementedException();

		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex) => throw new NotImplementedException();

		public void CopyTo(Array array, int index) => throw new NotImplementedException();

		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() => throw new NotImplementedException();

		public bool Remove(TKey key) => throw new NotImplementedException();

		public bool Remove(KeyValuePair<TKey, TValue> item) => throw new NotImplementedException();

		public void Remove(object key) => throw new NotImplementedException();

		public bool TryGetValue(TKey key, out TValue value) => throw new NotImplementedException();

		IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();

		IDictionaryEnumerator IDictionary.GetEnumerator() => throw new NotImplementedException();
	}
}

```

`Tests/123_InheritCustomAttr/ExtReference/IExt.cs`:

```cs
namespace InheritCustomAttr.ExtReference {
	interface IExt : IRoot {
		string Ext { get; }
	}
}

```

`Tests/123_InheritCustomAttr/ExtReference/IExt`2.cs`:

```cs
using System.Collections.Generic;

namespace InheritCustomAttr.ExtReference {
	interface IExt<TKey, TValue> : IExt, IDictionary<TKey, TValue> {
	}
}

```

`Tests/123_InheritCustomAttr/ExtReference/IRoot.cs`:

```cs
namespace InheritCustomAttr.ExtReference {
	interface IRoot {
		int Count { get; }
	}
}

```

`Tests/123_InheritCustomAttr/I.cs`:

```cs
namespace InheritCustomAttr {
	interface I<TM> {
		TM T { get; }
	}
}

```

`Tests/123_InheritCustomAttr/IDayOfWeek.cs`:

```cs
using System;

namespace InheritCustomAttr {
	interface IDayOfWeek {
		DayOfWeek T { get; }
	}
}

```

`Tests/123_InheritCustomAttr/MyAttribute.cs`:

```cs
using System;

namespace InheritCustomAttr {

	[System.AttributeUsage(AttributeTargets.All, Inherited = true, AllowMultiple = true)]
	sealed class MyAttribute : Attribute {
		public int Value { get; set; }
	}
}

```

`Tests/123_InheritCustomAttr/Program.cs`:

```cs
using System;

namespace InheritCustomAttr {
	class Program {
		static int Main(string[] args) {
			Console.WriteLine("START");
			var e = new E();
			Console.WriteLine(e.T);
			Console.WriteLine(e.U);
			// the following statement will crash the program after protection
			Console.WriteLine((Attribute.GetCustomAttributes(typeof(E).GetProperty("T"), typeof(MyAttribute))[0] as MyAttribute).Value);
			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/161_DynamicTypeRename.Test/161_DynamicTypeRename.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>DynamicTypeRename.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\161_DynamicTypeRename\161_DynamicTypeRename.csproj" />
  </ItemGroup>

</Project>

```

`Tests/161_DynamicTypeRename.Test/RenameDynamicMethodTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.Renamer;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace DynamicTypeRename.Test {
	public class RenameDynamicTypeTest : TestBase {
		public RenameDynamicTypeTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[MemberData(nameof(RenameDynamicTypeData))]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/161")]
		public async Task RenameDynamicType(string renameMode, bool flatten) =>
			await Run(
				"161_DynamicTypeRename.exe",
				new [] {
					"Type declaration done",
					"Dynamic type created",
					"Fields in type: 1",
					"Fetching field value is okay"
				},
				new SettingItem<Protection>("rename") {
					{ "mode", renameMode },
					{ "flatten", flatten.ToString() }
				},
				$"_{renameMode}_{flatten}"
			);

		public static IEnumerable<object[]> RenameDynamicTypeData() {
			foreach (var renameMode in new [] { nameof(RenameMode.Unicode), nameof(RenameMode.ASCII), nameof(RenameMode.Letters), nameof(RenameMode.Debug), nameof(RenameMode.Retain) })
				foreach (var flatten in new [] { true, false })
					yield return new object[] { renameMode, flatten };
		}
	}
}

```

`Tests/161_DynamicTypeRename/161_DynamicTypeRename.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>DynamicTypeRename</RootNamespace>
    <StartupObject>DynamicTypeRename.Program</StartupObject>
  </PropertyGroup>

</Project>

```

`Tests/161_DynamicTypeRename/Program.cs`:

```cs
using System;
using System.Reflection;
using System.Reflection.Emit;

namespace DynamicTypeRename {
	public delegate void TestDelegate<T>();

	class Program {
		static int Main(string[] args) {
			Console.WriteLine("START");
			var assemblyName = new AssemblyName("DynamicAssembly");
			var assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave);
			var moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name, assemblyName.Name + ".dll");

			var typeBuilder = moduleBuilder.DefineType("DynamicType", TypeAttributes.Public | TypeAttributes.Sealed);
			var genericTypes = typeBuilder.DefineGenericParameters("T");

			typeBuilder.DefineField("DynamicField", typeof(TestDelegate<>).MakeGenericType(genericTypes[0]), FieldAttributes.Public | FieldAttributes.Static);
			Console.WriteLine("Type declaration done");

			var dynamicType = typeBuilder.CreateType();
			var genericDynamicType = dynamicType.MakeGenericType(typeof(string));
			Console.WriteLine("Dynamic type created");

			var fields = genericDynamicType.GetFields();
			Console.WriteLine("Fields in type: " + fields.Length);

			if (fields.Length == 1) {
				fields[0].GetValue(null);
				Console.WriteLine("Fetching field value is okay");
			}

			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/193_ConstantsInlining.Lib/193_ConstantsInlining.Lib.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ConstantsInlining.Lib</RootNamespace>
  </PropertyGroup>

  <!--
    Optimize the assembly in all cases, to allow the unit test case to work. 
    Allows the JIT compiler to inline code. This is required for the unit test.  
  -->
  <PropertyGroup Label="Optimize Build always">
    <Optimize>true</Optimize>
    <DebugType>full</DebugType>
  </PropertyGroup>

</Project>

```

`Tests/193_ConstantsInlining.Lib/ExternalClass.cs`:

```cs
using System.Runtime.CompilerServices;

namespace ConstantsInlining.Lib {
	public static class ExternalClass {
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static string GetText() => "From External";
	}
}

```

`Tests/193_ConstantsInlining.Test/193_ConstantsInlining.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ConstantsInlining.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\193_ConstantsInlining\193_ConstantsInlining.csproj" />
  </ItemGroup>

</Project>

```

`Tests/193_ConstantsInlining.Test/ConstantInliningTest.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace ConstantsInlining.Test {
	public class ConstantInliningTest : TestBase {
		public ConstantInliningTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "constants")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/193")]
		public async Task ConstantInlining() =>
			await Run(new[] {"193_ConstantsInlining.exe", "193_ConstantsInlining.Lib.dll"},
				new[] {"From External"},
				new SettingItem<Protection>("constants") {{"elements", "S"}});
	}
}

```

`Tests/193_ConstantsInlining/193_ConstantsInlining.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ConstantsInlining</RootNamespace>
  </PropertyGroup>

  <!--
    Optimize the assembly in all cases, to allow the unit test case to work. 
    Allows the JIT compiler to inline code. This is required for the unit test.  
  -->
  <PropertyGroup Label="Optimize Build always">
    <Optimize>true</Optimize>
    <DebugType>full</DebugType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\193_ConstantsInlining.Lib\193_ConstantsInlining.Lib.csproj" />
  </ItemGroup>

</Project>

```

`Tests/193_ConstantsInlining/Program.cs`:

```cs
using System;

namespace ConstantsInlining {
	public class Program {
		static int Main(string[] args) {
			Console.WriteLine("START");
			Console.WriteLine(Lib.ExternalClass.GetText());
			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/244_ClrProtection.Test/244_ClrProtection.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ClrProtection.Test</RootNamespace>
    <IsPackable>false</IsPackable>
    <PlatformTarget>x86</PlatformTarget>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\244_ClrProtection\244_ClrProtection.vcxproj" />
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
  </ItemGroup>

</Project>

```

`Tests/244_ClrProtection.Test/ProtectClrAssemblyTest.cs`:

```cs
using System;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace ClrProtection.Test {
	public class ProtectClrAssemblyTest : TestBase {
		public ProtectClrAssemblyTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "anti tamper")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/244")]
		public Task AntiTamperProtection() => Run(
			"244_ClrProtection.exe",
			Array.Empty<String>(),
			new SettingItem<Protection>("anti tamper"),
			$"_{nameof(AntiTamperProtection)}");

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "resources")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/244")]
		public Task ResourceProtection() => Run(
			"244_ClrProtection.exe",
			Array.Empty<String>(),
			new SettingItem<Protection>("resources"),
			$"_{nameof(ResourceProtection)}");

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "typescramble")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/244")]
		public Task TypeScrambleProtection() => Run(
			"244_ClrProtection.exe",
			Array.Empty<String>(),
			new SettingItem<Protection>("typescramble"),
			$"_{nameof(TypeScrambleProtection)}");

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "anti tamper")]
		[Trait("Protection", "resources")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/244")]
		public Task AntiTamperResourceProtection() => Run(
			"244_ClrProtection.exe",
			Array.Empty<String>(),
			new[] {new SettingItem<Protection>("anti tamper"), new SettingItem<Protection>("resources") },
			$"_{nameof(AntiTamperResourceProtection)}");
	}
}

```

`Tests/244_ClrProtection/244_ClrProtection.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{73f11ee8-f565-479e-8366-bd74ee467ce8}</ProjectGuid>
    <RootNamespace>My244ClrProtection</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <TargetFrameworkVersion>v4.6.1</TargetFrameworkVersion>
    <PlatformToolset Condition="$(MSBuildVersion) &gt;= 17">v143</PlatformToolset>
    <PlatformToolset Condition="$(MSBuildVersion) &lt; 17">v142</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <CLRSupport>true</CLRSupport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <CLRSupport>true</CLRSupport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <CLRSupport>true</CLRSupport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <CLRSupport>true</CLRSupport>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Program.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Tests/244_ClrProtection/244_ClrProtection.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Ressourcendateien">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Program.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Tests/244_ClrProtection/Program.cpp`:

```cpp
using namespace System;

int main()
{
	Console::WriteLine("START");
	Console::WriteLine("END");
    return 42;
}

```

`Tests/252_ComplexInterfaceRenaming.Test/252_ComplexInterfaceRenaming.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ComplexInterfaceRenaming.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\252_ComplexInterfaceRenaming\252_ComplexInterfaceRenaming.csproj" />
  </ItemGroup>

</Project>

```

`Tests/252_ComplexInterfaceRenaming.Test/RenameComplexInterfaceTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.Renamer;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace ComplexInterfaceRenaming.Test {
	public class RenameComplexInterfaceTest : TestBase {
		public RenameComplexInterfaceTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[MemberData(nameof(RenameDynamicTypeData))]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/252")]
		public async Task RenameComplexInterfaces(string renameMode, bool flatten) =>
			await Run(
				"252_ComplexInterfaceRenaming.exe",
				new[] {
					"Operator: I'm a operator.",
					"Operator(IOperator): I'm a operator.",
					"Operator(IName): I'm a operator.",
					"Manager: I'm a manager!",
					"Manager(IWorker): I'm a manager!",
					"Manager(IOperator): I'm a manager!",
					"Manager(IName): I'm a manager!",
					"Working: abc"
				},
				new SettingItem<Protection>("rename") {
					{ "mode", renameMode },
					{ "flatten", flatten.ToString() }
				},
				$"_{renameMode}_{flatten}"
			);

		public static IEnumerable<object[]> RenameDynamicTypeData() {
			foreach (var renameMode in new[] { nameof(RenameMode.Unicode), nameof(RenameMode.ASCII), nameof(RenameMode.Letters), nameof(RenameMode.Debug), nameof(RenameMode.Retain) })
				foreach (var flatten in new[] { true, false })
					yield return new object[] { renameMode, flatten };
		}
	}
}

```

`Tests/252_ComplexInterfaceRenaming/252_ComplexInterfaceRenaming.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ComplexInterfaceRenaming</RootNamespace>
    <StartupObject>ComplexInterfaceRenaming.Program</StartupObject>
  </PropertyGroup>

</Project>

```

`Tests/252_ComplexInterfaceRenaming/IC.cs`:

```cs
namespace ComplexInterfaceRenaming {
	public interface IC {
		void C(string x);
	}
}

```

`Tests/252_ComplexInterfaceRenaming/IName.cs`:

```cs
namespace ComplexInterfaceRenaming {
	public interface IName {
		string Name { get; }
	}
}

```

`Tests/252_ComplexInterfaceRenaming/IOperator.cs`:

```cs
namespace ComplexInterfaceRenaming {
	public interface IOperator {
		string Name { get; }
		void Operate();
	}
}

```

`Tests/252_ComplexInterfaceRenaming/IWorker.cs`:

```cs
namespace ComplexInterfaceRenaming
{
  public interface IWorker : IName, IC {}
}

```

`Tests/252_ComplexInterfaceRenaming/Manager.cs`:

```cs
using System;

namespace ComplexInterfaceRenaming {
	internal sealed class Manager : Worker, IWorker, IOperator
	{
		public string Name => "I'm a manager!";

		public void Operate() => throw new NotImplementedException();
	}
}

```

`Tests/252_ComplexInterfaceRenaming/Operator.cs`:

```cs
using System;

namespace ComplexInterfaceRenaming {
	internal sealed class Operator : IC, IOperator, IName {
		public string Name { get; set; }

		public void C(string x) => throw new NotImplementedException();

		void IOperator.Operate() => throw new NotImplementedException();
	}
}

```

`Tests/252_ComplexInterfaceRenaming/Program.cs`:

```cs
using System;

namespace ComplexInterfaceRenaming {
	public class Program {
		static int Main(string[] args) {
			Console.WriteLine("START");
			var op = new Operator {
				Name = "I'm a operator."
			};
			Console.WriteLine("Operator: " + op.Name);
			Console.WriteLine("Operator(IOperator): " + (op as IOperator).Name);
			Console.WriteLine("Operator(IName): " + (op as IName).Name);

			var manager = new Manager();
			Console.WriteLine("Manager: " + manager.Name);
			Console.WriteLine("Manager(IWorker): " + (manager as IWorker).Name);
			Console.WriteLine("Manager(IOperator): " + (manager as IOperator).Name);
			Console.WriteLine("Manager(IName): " + (manager as IName).Name);
			manager.C("abc");

			Console.WriteLine("END");

			return 42;
		}
	}
}

```

`Tests/252_ComplexInterfaceRenaming/Worker.cs`:

```cs
using System;

namespace ComplexInterfaceRenaming {
	internal class Worker {
		public void C(string x) => Console.WriteLine("Working: " + x);
	}
}

```

`Tests/270_EnumArrayConstantProtection.Test/270_EnumArrayConstantProtection.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>EnumArrayConstantProtection.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\270_EnumArrayConstantProtection\270_EnumArrayConstantProtection.csproj" />
  </ItemGroup>

</Project>

```

`Tests/270_EnumArrayConstantProtection.Test/ConstantProtectionTest.cs`:

```cs
using System;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace EnumArrayConstantProtection.Test {
	public class ConstantProtectionTest : TestBase {
		public ConstantProtectionTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "constants")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/270")]
		public async Task ConstantsProtection() =>
			await Run(
				"270_EnumArrayConstantProtection.exe",
				new[] {
					"Enum Array OK",
					"String Array OK"
				},
				new SettingItem<Protection>("constants") { { "elements", "SI" } }
			);
	}
}

```

`Tests/270_EnumArrayConstantProtection/270_EnumArrayConstantProtection.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ConstantProtection</RootNamespace>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

</Project>

```

`Tests/270_EnumArrayConstantProtection/Level.cs`:

```cs
namespace EnumArrayConstantProtection {
	public enum Level : long {
		A = 1,
		B = 2,
		C = 4,
		D = 8,
		E = 1073741824
	}
}

```

`Tests/270_EnumArrayConstantProtection/Program.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;

namespace EnumArrayConstantProtection {
	public class Program {
		[SuppressMessage("Style", "IDE0060:Remove unused parameters", Justification = "Required signature")]
		static int Main(string[] args) {
			Console.WriteLine("START");
			Console.WriteLine(Get(Level.A, Level.E, Level.D));
			Console.WriteLine(Get("abc", "def", "ghi"));
			Console.WriteLine("END");
			return 42;
		}

		[SuppressMessage("Style", "IDE0060:Remove unused parameters", Justification = "Just for testing.")]
		private static string Get(params Level[] levels) => "Enum Array OK";

		private static string Get(params string[] texts) => "String Array OK";
	}
}

```

`Tests/306_ComplexClassStructureRename.Lib/306_ComplexClassStructureRename.Lib.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ComplexClassStructureRename.Lib</RootNamespace>
  </PropertyGroup>

</Project>

```

`Tests/306_ComplexClassStructureRename.Lib/ITestEvents.cs`:

```cs
namespace ComplexClassStructureRename.Lib {
	public interface ITestEvents {
		void FireLog(string message);
	}
}

```

`Tests/306_ComplexClassStructureRename.Lib/InternalBaseClass.cs`:

```cs
namespace ComplexClassStructureRename.Lib {
	internal class InternalBaseClass {
		public virtual void FireLog(string message) { }
	}
}

```

`Tests/306_ComplexClassStructureRename.Lib/InternalClass1.cs`:

```cs
using System;

namespace ComplexClassStructureRename.Lib {
	internal class InternalClass1 : InternalBaseClass {
		public new void FireLog(string message) => 
			Console.WriteLine("InternalClass1: " + message);
	}
}

```

`Tests/306_ComplexClassStructureRename.Lib/InternalClass2.cs`:

```cs
namespace ComplexClassStructureRename.Lib {
	internal class InternalClass2 : InternalBaseClass, ITestEvents { }
}

```

`Tests/306_ComplexClassStructureRename.Lib/MyTest.cs`:

```cs
namespace ComplexClassStructureRename.Lib {
	internal class MyTest {
		readonly InternalClass1 _test1 = new InternalClass1();
		readonly InternalClass2 _test2 = new InternalClass2();

		public void Test() {
			_test1.FireLog("test1 Hello");
			_test2.FireLog("test2 Hello");
		}

	}
}

```

`Tests/306_ComplexClassStructureRename.Lib/PublicClass1.cs`:

```cs
using System.Reflection;

namespace ComplexClassStructureRename.Lib {
	[Obfuscation(Exclude = false, Feature = "-rename")]
	public class PublicClass1 : ITestEvents {
		public void FireLog(string message) { }
	}
}

```

`Tests/306_ComplexClassStructureRename.Lib/PublicClass2.cs`:

```cs
using System.Reflection;

namespace ComplexClassStructureRename.Lib {
	[Obfuscation(Exclude = false, Feature = "-rename")]
	public class PublicClass2 {
		readonly MyTest _test = new MyTest();

		public void Test() => _test.Test();
	}
}

```

`Tests/306_ComplexClassStructureRename.Test/306_ComplexClassStructureRename.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ComplexClassStructureRename.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\306_ComplexClassStructureRename\306_ComplexClassStructureRename.csproj" />
  </ItemGroup>
</Project>

```

`Tests/306_ComplexClassStructureRename.Test/ComplexRenameTest.cs`:

```cs
using System;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace ComplexClassStructureRename.Test {
	public class ComplexRenameTest : TestBase {
		public ComplexRenameTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/306")]
		public async Task ComplexClassStructureRename() =>
			await Run(
				new[] {
					"306_ComplexClassStructureRename.exe",
					"306_ComplexClassStructureRename.Lib.dll"
				},
				new[] {
					"InternalClass1: test1 Hello"
				},
				new SettingItem<Protection>("rename") { 
					{ "mode", "sequential" },
					{ "renPublic", "true" },
					{ "flatten", "false" }
				}
			);
	}
}

```

`Tests/306_ComplexClassStructureRename/306_ComplexClassStructureRename.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ComplexClassStructureRename</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\306_ComplexClassStructureRename.Lib\306_ComplexClassStructureRename.Lib.csproj" />
  </ItemGroup>

</Project>

```

`Tests/306_ComplexClassStructureRename/Program.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using ComplexClassStructureRename.Lib;

[assembly: Obfuscation(Exclude = false, Feature = "-rename")]

namespace ComplexClassStructureRename {
	public class Program {
		[SuppressMessage("Style", "IDE0060:Remove unused parameters", Justification = "Required signature")]
		static int Main(string[] args) {
			Console.WriteLine("START");

			var t = new PublicClass2();
			t.Test();

			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/342_InterfaceRenamingLoop.Test/342_InterfaceRenamingLoop.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>InterfaceRenamingLoop.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\342_InterfaceRenamingLoop\342_InterfaceRenamingLoop.csproj" />
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
  </ItemGroup>

</Project>

```

`Tests/342_InterfaceRenamingLoop.Test/InterfaceRenamingLoopTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.Renamer;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace InterfaceRenamingLoop.Test {
	public class InterfaceRenamingLoopTest : TestBase {
		public InterfaceRenamingLoopTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[MemberData(nameof(RenameInterfaceLoopTestData))]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/342")]
		public async Task RenameInterfaceLoop(string renameMode) =>
			await Run(
				"342_InterfaceRenamingLoop.exe",
				Array.Empty<string>(),
				new SettingItem<Protection>("rename") {
					{ "mode", renameMode }
				},
				$"_{renameMode}"
			);

		public static IEnumerable<object[]> RenameInterfaceLoopTestData() {
			foreach (var renameMode in new[] { nameof(RenameMode.Unicode), nameof(RenameMode.Debug), nameof(RenameMode.Sequential) })
				yield return new object[] { renameMode };
		}
	}
}

```

`Tests/342_InterfaceRenamingLoop/342_InterfaceRenamingLoop.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>InterfaceRenamingLoop</RootNamespace>
    <StartupObject>InterfaceRenamingLoop.Program</StartupObject>
  </PropertyGroup>

</Project>

```

`Tests/342_InterfaceRenamingLoop/CBase.cs`:

```cs
namespace InterfaceRenamingLoop {
	internal class CBase {
		public virtual void TestEvent(int code, string description) {

		}
	}
}

```

`Tests/342_InterfaceRenamingLoop/ClassA.cs`:

```cs
namespace InterfaceRenamingLoop {
	internal class ClassA : CBase, IAEvents {
		public void TestA(int errorCode) {

		}
		public override void TestEvent(int code, string description) {

		}
	}
}

```

`Tests/342_InterfaceRenamingLoop/ClassB.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace InterfaceRenamingLoop {
	internal class ClassB : ClassA {
	}
}

```

`Tests/342_InterfaceRenamingLoop/IAEvents.cs`:

```cs
namespace InterfaceRenamingLoop {
	internal interface IAEvents {
		void TestA(int errorCode);
		void TestEvent(int errorCode, string description);
	}
}

```

`Tests/342_InterfaceRenamingLoop/Program.cs`:

```cs
using System;

namespace InterfaceRenamingLoop {
	public class Program {
		internal static int Main(string[] args) {
			Console.WriteLine("START");
			
			var test = new ClassB();
			test.TestEvent(0, "TEST");

			Console.WriteLine("END");

			return 42;
		}
	}
}

```

`Tests/345_RenameDynamicParameter.Test/345_RenameDynamicParameter.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>RenameDynamicParameter.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\345_RenameDynamicParameter\345_RenameDynamicParameter.csproj" />
  </ItemGroup>

</Project>

```

`Tests/345_RenameDynamicParameter.Test/RenameDynamicParameterTest.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace SignatureMismatch.Test {
	public class RenameDynamicParameterTest : TestBase {
		public RenameDynamicParameterTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/345")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/349")]
		public async Task RenameDynamicParameter() =>
			await Run(
				"345_RenameDynamicParameter.exe",
				new[] {
					"static message",
					"dynamic message",
					"Overload String: Test",
					"Overload Integer: 1",
					"Override String: Test",
					"Override Integer: 1",
					"Field Value: 1",
					"Ctor String Value",
					"Ctor Integer Value: 1"
				},
				new SettingItem<Protection>("rename")
			);
	}
}

```

`Tests/345_RenameDynamicParameter/345_RenameDynamicParameter.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>RenameDynamicParameter</RootNamespace>
    <StartupObject>RenameDynamicParameter.Program</StartupObject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CSharp" Version="4.7.0" />
  </ItemGroup>

</Project>
```

`Tests/345_RenameDynamicParameter/ConstructorTestClass.cs`:

```cs
using System;

namespace RenameDynamicParameter {
	public class ConstructorTestClass {
		private string _message;

		private ConstructorTestClass(int value) : this("Ctor Integer Value: " + value) { }
		private ConstructorTestClass(string message) => _message = message;

		private void WriteMessage() => Console.WriteLine(_message);

		public static void TestInteger() {
			var instance = new ConstructorTestClass((dynamic)GetInteger());
			instance.WriteMessage();
		}

		public static void TestString() {
			var instance = new ConstructorTestClass((dynamic)GetString());
			instance.WriteMessage();
		}

		private static object GetInteger() => 1;
		private static object GetString() => "Ctor String Value";
	}
}

```

`Tests/345_RenameDynamicParameter/FieldTestClass.cs`:

```cs
using System;

namespace RenameDynamicParameter {
	public class FieldTestClass {
		private int _storage;

		private void FieldTestMethod() => Console.WriteLine("Field Value: " + _storage);

		public void TestDynamic() {
			_storage = (dynamic)GetInteger();
			FieldTestMethod();
		}

		private static object GetInteger() => 1;
	}
}

```

`Tests/345_RenameDynamicParameter/OverloadTestClass.cs`:

```cs
using System;

namespace RenameDynamicParameter {
	public static class OverloadTestClass {
		private static void OverloadTestMethod(int strobj) => Console.WriteLine("Overload Integer: " + strobj);
		private static void OverloadTestMethod(string strobj) => Console.WriteLine("Overload String: " + strobj);

		public static void TestInteger() => OverloadTestMethod((dynamic)GetInteger());
		public static void TestString() => OverloadTestMethod((dynamic)GetString());

		private static object GetInteger() => 1;
		private static object GetString() => "Test";
	}
}

```

`Tests/345_RenameDynamicParameter/OverrideBaseTestClass.cs`:

```cs
using System;

namespace RenameDynamicParameter {
	public abstract class OverrideBaseTestClass {
		protected void OverrideTestMethod(int strobj) => Console.WriteLine("Override Integer: " + strobj);
		protected abstract void OverrideTestMethod(string strobj);
	}
}

```

`Tests/345_RenameDynamicParameter/OverrideTestClass.cs`:

```cs
using System;

namespace RenameDynamicParameter {
	public class OverrideTestClass : OverrideBaseTestClass {
		protected override void OverrideTestMethod(string strobj) => Console.WriteLine("Override String: " + strobj);

		public void TestInteger() => OverrideTestMethod((dynamic)GetInteger());
		public void TestString() => OverrideTestMethod((dynamic)GetString());

		private static object GetInteger() => 1;
		private static object GetString() => "Test";
	}
}

```

`Tests/345_RenameDynamicParameter/Program.cs`:

```cs
using System;

namespace RenameDynamicParameter {
	public class Program {
		internal static int Main(string[] args) {
			Console.WriteLine("START");
			
			SimpleTestClass.TestStatic();
			SimpleTestClass.TestDynamic();

			OverloadTestClass.TestString();
			OverloadTestClass.TestInteger();

			var overrideTest = new OverrideTestClass();
			overrideTest.TestString();
			overrideTest.TestInteger();

			var fieldTest = new FieldTestClass();
			fieldTest.TestDynamic();

			ConstructorTestClass.TestString();
			ConstructorTestClass.TestInteger();

			Console.WriteLine("END");

			return 42;
		}
	}
}

```

`Tests/345_RenameDynamicParameter/SimpleTestClass.cs`:

```cs
using System;

namespace RenameDynamicParameter {
	public static class SimpleTestClass {
		private static void SimpleTestMethod(object strobj) => Console.WriteLine(strobj);

		public static void TestDynamic() => SimpleTestMethod((dynamic)"dynamic message");
		public static void TestStatic() => SimpleTestMethod("static message");
	}
}

```

`Tests/389_MixedCultureCasing.Test/389_MixedCultureCasing.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>MixedCultureCasing.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\389_MixedCultureCasing\389_MixedCultureCasing.csproj" />
  </ItemGroup>

</Project>
```

`Tests/389_MixedCultureCasing.Test/MixedCultureCasingTest.cs`:

```cs
using System;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace MixedCultureCasing.Test
{
    public class MixedCultureCasingTest : TestBase {
		public MixedCultureCasingTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/389")]
		public async Task MixedCultureCasing() =>
			await Run(
				new [] {
					"389_MixedCultureCasing.exe",
					@"de-DE\389_MixedCultureCasing.resources.dll"
				},
				new [] {
					"Test 1 (neutral)",
					"Test 1 (deutsch)",
					"Test 2 (neutral)",
					"Test 2 (deutsch)"
				},
				new SettingItem<Protection>("rename")
			);
	}
}

```

`Tests/389_MixedCultureCasing/389_MixedCultureCasing.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>MixedCultureCasing</RootNamespace>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <Compile Update="Resource1.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resource1.resx</DependentUpon>
    </Compile>
    <Compile Update="Resource2.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resource2.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Resource1.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resource1.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <EmbeddedResource Update="Resource2.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resource2.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

</Project>

```

`Tests/389_MixedCultureCasing/Program.cs`:

```cs
using System;
using System.Globalization;

namespace MixedCultureCasing {
	public class Program {
		internal static int Main(string[] args) {
			Console.WriteLine("START");
			
			Resource1.Culture = CultureInfo.GetCultureInfo("en-US");
			Console.WriteLine(Resource1.Test1);

			Resource1.Culture = CultureInfo.GetCultureInfo("de-DE");
			Console.WriteLine(Resource1.Test1);
			
			Resource2.Culture = CultureInfo.GetCultureInfo("en-US");
			Console.WriteLine(Resource2.Test2);

			Resource2.Culture = CultureInfo.GetCultureInfo("de-DE");
			Console.WriteLine(Resource2.Test2);

			Console.WriteLine("END");

			return 42;
		}
	}
}

```

`Tests/389_MixedCultureCasing/Resource1.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MixedCultureCasing {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resource1 {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resource1() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("MixedCultureCasing.Resource1", typeof(Resource1).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Test 1 (neutral) ähnelt.
        /// </summary>
        internal static string Test1 {
            get {
                return ResourceManager.GetString("Test1", resourceCulture);
            }
        }
    }
}

```

`Tests/389_MixedCultureCasing/Resource1.de-DE.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Test1" xml:space="preserve">
    <value>Test 1 (deutsch)</value>
  </data>
</root>
```

`Tests/389_MixedCultureCasing/Resource1.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Test1" xml:space="preserve">
    <value>Test 1 (neutral)</value>
  </data>
</root>
```

`Tests/389_MixedCultureCasing/Resource2.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MixedCultureCasing {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resource2 {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resource2() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("MixedCultureCasing.Resource2", typeof(Resource2).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Test 2 (neutral) ähnelt.
        /// </summary>
        internal static string Test2 {
            get {
                return ResourceManager.GetString("Test2", resourceCulture);
            }
        }
    }
}

```

`Tests/389_MixedCultureCasing/Resource2.de-de.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Test2" xml:space="preserve">
    <value>Test 2 (deutsch)</value>
  </data>
</root>
```

`Tests/389_MixedCultureCasing/Resource2.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Test2" xml:space="preserve">
    <value>Test 2 (neutral)</value>
  </data>
</root>
```

`Tests/421_NewtonsoftJsonSerialization.Test/421_NewtonsoftJsonSerialization.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>NewtonsoftJsonSerialization.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\421_NewtonsoftJsonSerialization\421_NewtonsoftJsonSerialization.csproj" />
  </ItemGroup>

</Project>

```

`Tests/421_NewtonsoftJsonSerialization.Test/NewtonsoftJsonTest.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace NewtonsoftJsonSerialization.Test {
	public class NewtonsoftJsonTest : TestBase {
		public NewtonsoftJsonTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/421")]
		public async Task SignatureMismatch() =>
			await Run(
				new[] {
					"421_NewtonsoftJsonSerialization.exe",
					"external:Newtonsoft.Json.dll"
				},
				new [] {
					"{\"a\":\"a\",\"b\":\"b\",\"c\":\"c\"}",
					"{\"a\":\"a\",\"b\":\"b\",\"c\":\"c\"}"
				},
				new SettingItem<Protection>("rename")
			);
	}
}

```

`Tests/421_NewtonsoftJsonSerialization/421_NewtonsoftJsonSerialization.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>NewtonsoftJsonSerialization</RootNamespace>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
  </ItemGroup>

</Project>

```

`Tests/421_NewtonsoftJsonSerialization/ObfExcluded.cs`:

```cs
using System.Reflection;
using Newtonsoft.Json;

namespace NewtonsoftJsonSerialization {
	[Obfuscation(Exclude = true)]
	internal class ObfExcluded {
		[JsonProperty("a")] public string a;

		[JsonProperty("b")] public string b;

		[JsonProperty("c")] public string c;

		public ObfExcluded(string a, string b, string c) {
			this.a = a;
			this.b = b;
			this.c = c;
		}

		public override string ToString() => JsonConvert.SerializeObject(this);
	}
}

```

`Tests/421_NewtonsoftJsonSerialization/ObfMarkedWithAttribute.cs`:

```cs
using Newtonsoft.Json;

namespace NewtonsoftJsonSerialization {
	[JsonObject]
	internal class ObfMarkedWithAttribute {
		[JsonProperty("a")] public string a;

		[JsonProperty("b")] public string b;

		[JsonProperty("c")] public string c;

		public ObfMarkedWithAttribute(string a, string b, string c) {
			this.a = a;
			this.b = b;
			this.c = c;
		}

		public override string ToString() => JsonConvert.SerializeObject(this);
	}
}

```

`Tests/421_NewtonsoftJsonSerialization/Program.cs`:

```cs
using System;

namespace NewtonsoftJsonSerialization {
	class Program {
		static int Main(string[] args) {
			Console.WriteLine("START");

			Console.WriteLine(new ObfMarkedWithAttribute("a", "b", "c").ToString());
			Console.WriteLine(new ObfExcluded("a", "b", "c").ToString());

			Console.WriteLine("END");

			return 42;
		}
	}
}

```

`Tests/470_ImplementationInBaseClass.Test/470_ImplementationInBaseClass.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ImplementationInBaseClass.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\470_ImplementationInBaseClass\470_ImplementationInBaseClass.csproj" />
  </ItemGroup>

</Project>

```

`Tests/470_ImplementationInBaseClass.Test/RenameTest.cs`:

```cs
using System.Collections.Generic;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.Renamer;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace ImplementationInBaseClass.Test
{
	public class RenameTest : TestBase
	{
		public RenameTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[MemberData(nameof(ResolveNameData))]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/470")]
		public async Task ResolveNameLoop(RenameMode mode, bool flatten) =>
			await Run(
				new[] {
					"470_ImplementationInBaseClass.exe"
				},
				new[] {
					"Called MyMethod",
					"Called MyMethod",
					"Called MyMethod",
					"Called MyMethod"
				},
				new SettingItem<Protection>("rename") {
					{ "mode", mode.ToString() },
					{ "renPublic", "true" },
					{ "flatten", flatten.ToString() }
				},
				$"_{mode}_{flatten}"
			);

		public static IEnumerable<object[]> ResolveNameData() {
			foreach (var renameMode in new[] { RenameMode.Unicode, RenameMode.Sequential })
				foreach (var flatten in new[] { true, false })
					yield return new object[] { renameMode, flatten };
		}
	}
}

```

`Tests/470_ImplementationInBaseClass/470_ImplementationInBaseClass.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>ImplementationInBaseClass</RootNamespace>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

</Project>

```

`Tests/470_ImplementationInBaseClass/IMyInterfaceA.cs`:

```cs
namespace ImplementationInBaseClass {
	public interface IMyInterfaceA {
		void MyMethod();
	}
}

```

`Tests/470_ImplementationInBaseClass/IMyInterfaceB.cs`:

```cs
namespace ImplementationInBaseClass {
	public interface IMyInterfaceB {
		void MyMethod();
	}
}

```

`Tests/470_ImplementationInBaseClass/IMyInterfaceC.cs`:

```cs
namespace ImplementationInBaseClass {
	public interface IMyInterfaceC {
		void MyMethod();
	}
}

```

`Tests/470_ImplementationInBaseClass/MyBaseClass.cs`:

```cs
using System;

namespace ImplementationInBaseClass {
	internal abstract class MyBaseClass {
		public void MyMethod() => Console.WriteLine("Called " + nameof(MyMethod));
	}
}

```

`Tests/470_ImplementationInBaseClass/MyClassA.cs`:

```cs
namespace ImplementationInBaseClass {
	internal class MyClassA : MyBaseClass, IMyInterfaceA {
	}
}

```

`Tests/470_ImplementationInBaseClass/MyClassB.cs`:

```cs
namespace ImplementationInBaseClass {
	internal class MyClassB : MyBaseClass, IMyInterfaceB {
	}
}

```

`Tests/470_ImplementationInBaseClass/MyClassB2.cs`:

```cs
namespace ImplementationInBaseClass {
	internal class MyClassB2 : MyBaseClass, IMyInterfaceB {
	}
}

```

`Tests/470_ImplementationInBaseClass/MyClassC.cs`:

```cs
namespace ImplementationInBaseClass {
	internal class MyClassC : MyBaseClass, IMyInterfaceC {
	}
}

```

`Tests/470_ImplementationInBaseClass/Program.cs`:

```cs
using System;

namespace ImplementationInBaseClass {
	internal class Program {
		internal static int Main(string[] args) {
			Console.WriteLine("START");

			var classA = new MyClassA();
			classA.MyMethod();

			var classB = new MyClassB();
			classB.MyMethod();

			var classB2 = new MyClassB2();
			classB2.MyMethod();

			var classC = new MyClassC();
			classC.MyMethod();

			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/78_SignatureMismatch.Test/78_SignatureMismatch.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>SignatureMismatch.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\78_SignatureMismatch\78_SignatureMismatch.csproj" />
  </ItemGroup>

</Project>

```

`Tests/78_SignatureMismatch.Test/SignatureMismatchTest.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace SignatureMismatch.Test {
	public class SignatureMismatchTest : TestBase {
		public SignatureMismatchTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/78")]
		public async Task SignatureMismatch() =>
			await Run(
				"78_SignatureMismatch.exe",
				new [] {
					"Dictionary created",
					"Dictionary count: 1",
					"[Test1] = Test2"
				},
				new SettingItem<Protection>("rename")
			);
	}
}

```

`Tests/78_SignatureMismatch/78_SignatureMismatch.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>SignatureMismatch</RootNamespace>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

</Project>

```

`Tests/78_SignatureMismatch/EasyDict.cs`:

```cs
using System.Collections;
using System.Collections.Generic;

namespace SignatureMismatch {
	public class EasyDict<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>> {
		private readonly Dictionary<TKey, TValue> _dict;

		public EasyDict() => _dict = new Dictionary<TKey, TValue>();

		public EasyDict(int capacity) => _dict = new Dictionary<TKey, TValue>(capacity);

		public int Count => _dict.Count;

		public IEnumerable<TValue> Values => _dict.Values;

		public TValue this[TKey key] {
			get => _dict.TryGetValue(key, out var value) ? value : default;
			set => _dict[key] = value;
		}

		public void Add(TKey key, TValue value) => _dict[key] = value;

		public void Clear() => _dict.Clear();

		public bool ContainsKey(TKey key) => _dict.ContainsKey(key);

		IEnumerator IEnumerable.GetEnumerator() => _dict.GetEnumerator();

		IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator() => _dict.GetEnumerator();

		public bool Remove(TKey key) => _dict.Remove(key);

		public bool TryGetValue(TKey key, out TValue value) => _dict.TryGetValue(key, out value);
	}
}

```

`Tests/78_SignatureMismatch/EasyFile.cs`:

```cs
using System;

namespace SignatureMismatch {
	public abstract class File<T> : IEquatable<File<T>>
		where T : class {
		public string Name { get; set; } = "";

		public T Data { get; }

		public File(T data) {
			Data = data ?? throw new ArgumentNullException(nameof(data));
		}

		public override bool Equals(object obj) => Equals(obj as File<T>);

		public bool Equals(File<T> other) {
			if (ReferenceEquals(this, other)) {
				return true;
			}

			if (other is null) {
				return false;
			}

			if (string.IsNullOrEmpty(Name) && string.IsNullOrEmpty(other.Name)) {
				return Data.Equals(other.Data);
			}

			return Name == other.Name;
		}

		public override int GetHashCode() {
			return string.IsNullOrEmpty(Name)
				? Data.GetHashCode()
				: Name.GetHashCode();
		}
	}

	public class TextFile : File<string> {
		public TextFile(string name, string code)
			: base(code) {
			Name = name ?? throw new ArgumentNullException(nameof(name));
		}

		public override string ToString() => !string.IsNullOrEmpty(Name)
			? Name
			: Data;
	}
}

```

`Tests/78_SignatureMismatch/Program.cs`:

```cs
using System;

namespace SignatureMismatch {
	class Program {
		static int Main(string[] args) {
			Console.WriteLine("START");
			var dict = new EasyDict<string, string> {
				{ "Test1", "Test2" }
			};
			Console.WriteLine("Dictionary created");
			Console.WriteLine($"Dictionary count: {dict.Count:d}");

			var file = new TextFile("filename", "text");

			foreach (var kvp in dict) 
				Console.WriteLine($"[{kvp.Key}] = {kvp.Value}");
			
			Console.WriteLine("END");

            return 42;
		}
	}
}

```

`Tests/AntiTamper.Test/AntiTamper.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\AntiTamper\AntiTamper.csproj" />
  </ItemGroup>

</Project>

```

`Tests/AntiTamper.Test/AntiTamperTest.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace AntiTamper.Test {
	public sealed class AntiTamperTest : TestBase {
		public AntiTamperTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[InlineData("normal")]
		[InlineData("anti")]
		[InlineData("jit", Skip = "Runtime Component of the JIT AntiTamper protection is broken.")]
		[Trait("Category", "Protection")]
		[Trait("Protection", "anti tamper")]
		public Task ProtectAntiTamperAndExecute(string antiTamperMode) {
			if (antiTamperMode == "jit") return Task.CompletedTask;

			return Run("AntiTamper.exe",
				new[] { "This is a test." },
				new SettingItem<Protection>("anti tamper") { { "mode", antiTamperMode } },
				"_" + antiTamperMode);
		}
	}
}

```

`Tests/AntiTamper/AntiTamper.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <OutputType>Exe</OutputType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>

  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

</Project>

```

`Tests/AntiTamper/Program.cs`:

```cs
using System;

namespace AntiTamper {
	public class Program {
		internal static int Main(string[] args) {
			Console.WriteLine("START");
			Console.WriteLine(Properties.Resources.Test);
			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/AntiTamper/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AntiTamper.Properties {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("AntiTamper.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die This is a test. ähnelt.
        /// </summary>
        internal static string Test {
            get {
                return ResourceManager.GetString("Test", resourceCulture);
            }
        }
    }
}

```

`Tests/AntiTamper/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Test" xml:space="preserve">
    <value>This is a test.</value>
  </data>
</root>
```

`Tests/BlockingReferences.Test/BlockingReferences.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net461</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\BlockingReferences\BlockingReferences.csproj" />
      <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    </ItemGroup>
</Project>

```

`Tests/BlockingReferences.Test/Program.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace BlockingReferences.Test {
	public class BlockingReferencesTest : TestBase {
		public BlockingReferencesTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/379")]
		public async Task BlockingReferences() =>
			await BlockingReferencesInternal("BlockingReferences.exe", "BlockingReferencesHelper.dll");

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/379")]
		public async Task BlockingReferencesReverse() =>
			await BlockingReferencesInternal("BlockingReferencesHelper.dll", "BlockingReferences.exe");

		private async Task BlockingReferencesInternal(params string[] files) =>
			await Run(
				files,
				new[] {
					"",
					"Implementation2",
				},
				new SettingItem<Protection>("rename") {
					["renPublic"] = "true",
					["mode"] = "decodable"
				},
				outputAction: line => {
					Assert.DoesNotContain("[WARN] Failed to rename all targeted members", line);
				}
			);
	}
}

```

`Tests/BlockingReferences/BlockingReferences.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
      <OutputType>Exe</OutputType>
      <TargetFramework>net461</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\BlockingReferencesHelper\BlockingReferencesHelper.csproj" />
    </ItemGroup>

</Project>

```

`Tests/BlockingReferences/Program.cs`:

```cs
using System;
using BlockingReferencesHelper;

namespace BlockingReferences {
	public interface IBaseInterface {
		string Method();
	}

	public class Implementation1 : BaseImplementation<string>, IBaseInterface {
	}

	public class Implementation2 : BaseImplementation<string>, IBaseInterface {
		public override string Method() => "Implementation2";
	}

	public static class Program {
		public static int Main() {
			Console.WriteLine("START");
			Console.WriteLine(new Implementation1().Method());
			Console.WriteLine(new Implementation2().Method());
			Console.WriteLine("END");

			return 42;
		}
	}
}

```

`Tests/BlockingReferencesHelper/BaseImplementation.cs`:

```cs
namespace BlockingReferencesHelper {
	public class BaseImplementation<T> {
		public virtual T Method() => default;
	}
}

```

`Tests/BlockingReferencesHelper/BlockingReferencesHelper.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net461</TargetFramework>
    </PropertyGroup>

</Project>

```

`Tests/CompressorWithResx.Test/CompressTest.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace CompressorWithResx.Test {
	public sealed class CompressTest : TestBase {
		public CompressTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[MemberData(nameof(CompressAndExecuteTestData))]
		[Trait("Category", "Packer")]
		[Trait("Packer", "compressor")]
		public async Task CompressAndExecuteTest(string compatKey, string deriverKey, string resourceProtectionMode) =>
			await Run(
				new[] {"CompressorWithResx.exe", Path.Combine("de", "CompressorWithResx.resources.dll")},
				new[] {"Test (fallback)", "Test (deutsch)"},
				resourceProtectionMode != "none"
					? new SettingItem<Protection>("resources") {{"mode", resourceProtectionMode}}
					: null,
				$"_{compatKey}_{deriverKey}_{resourceProtectionMode}",
				packer: new SettingItem<Packer>("compressor") {{"compat", compatKey}, {"key", deriverKey}});

		public static IEnumerable<object[]> CompressAndExecuteTestData() {
			foreach (var compressorCompatKey in new [] { "true", "false" })
				foreach (var compressorDeriveKey in new [] { "normal", "dynamic" })
					foreach (var resourceProtectionMode in new [] { "none", "normal", "dynamic" })
						yield return new object[] { compressorCompatKey, compressorDeriveKey, resourceProtectionMode };
		}
	}
}

```

`Tests/CompressorWithResx.Test/CompressorWithResx.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\CompressorWithResx\CompressorWithResx.csproj" />
  </ItemGroup>

</Project>

```

`Tests/CompressorWithResx/CompressorWithResx.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <OutputType>Exe</OutputType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>

  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

</Project>

```

`Tests/CompressorWithResx/Program.cs`:

```cs
using System;

namespace CompressorWithResx {
	public class Program {
		internal static int Main(string[] args) {
			Console.WriteLine("START");
			Properties.Resources.Culture = new System.Globalization.CultureInfo("en-US");
			Console.WriteLine(Properties.Resources.TestString);
			Properties.Resources.Culture = new System.Globalization.CultureInfo("de-DE");
			Console.WriteLine(Properties.Resources.TestString);
			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/CompressorWithResx/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace CompressorWithResx.Properties {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("CompressorWithResx.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Test (fallback) ähnelt.
        /// </summary>
        internal static string TestString {
            get {
                return ResourceManager.GetString("TestString", resourceCulture);
            }
        }
    }
}

```

`Tests/CompressorWithResx/Properties/Resources.de.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TestString" xml:space="preserve">
    <value>Test (deutsch)</value>
  </data>
</root>
```

`Tests/CompressorWithResx/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TestString" xml:space="preserve">
    <value>Test (fallback)</value>
  </data>
</root>
```

`Tests/Confuser.Core.Test/Confuser.Core.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Moq" Version="4.17.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
  </ItemGroup>

</Project>

```

`Tests/Confuser.Core.Test/Helpers.cs`:

```cs
using dnlib.DotNet;
using Moq;
using Xunit;

namespace Confuser.Core.Test {
	internal static class Helpers {
		internal static ModuleDefMD LoadTestModuleDef() {
			var asmResolver = new AssemblyResolver { EnableTypeDefCache = true };
			asmResolver.DefaultModuleContext = new ModuleContext(asmResolver);
			var options = new ModuleCreationOptions(asmResolver.DefaultModuleContext) {
				TryToLoadPdbFromDisk = false
			};

            asmResolver.AddToCache(ModuleDefMD.Load(typeof(Mock).Module, options));
            asmResolver.AddToCache(ModuleDefMD.Load(typeof(FactAttribute).Module, options));

            var thisModule = ModuleDefMD.Load(typeof(Helpers).Module, options);
            asmResolver.AddToCache(thisModule);

			return thisModule;
		}
	}
}

```

`Tests/Confuser.Core.Test/Services/TraceServiceTest.cs`:

```cs
using System;
using System.Linq;
using Confuser.Core.Services;
using dnlib.DotNet.Emit;
using Xunit;

namespace Confuser.Core.Test.Services {
	public class TraceServiceTest {
		public static readonly Type Int = typeof(int);
		static Type GetType(object v) => v.GetType();

#pragma warning disable IDE0051 // Remove unused private member
#pragma warning disable IDE0060 // Remove unused parameter
		private void X(int a, int b) { }
#pragma warning restore IDE0060 // Remove unused parameter
#pragma warning restore IDE0051 // Remove unused private member

		static void TestReferenceMethod() => typeof(TraceServiceTest).GetMethod("X", new[] { GetType(1) ?? Int });

		[Fact]
		public void TraceTestReferenceMethodTest() {
			var moduleDef = Helpers.LoadTestModuleDef();
			var thisTypeDef = moduleDef.Find("Confuser.Core.Test.Services.TraceServiceTest", false);
			var refMethod = thisTypeDef.FindMethod(nameof(TestReferenceMethod));

			var traceService = new TraceService();
			var methodTrace = traceService.Trace(refMethod);

			var getMethodCall = refMethod.Body.Instructions.Single(i =>
				i.OpCode == OpCodes.Call && i.Operand.ToString().Contains("GetMethod"));
			var arguments = methodTrace.TraceArguments(getMethodCall);

			Assert.NotNull(arguments);
		}
	}
}

```

`Tests/Confuser.Core.Test/UtilsTest.cs`:

```cs
using System.Collections.Generic;
using Xunit;

namespace Confuser.Core.Test {
	public class UtilsTest {
		[Theory]
		[MemberData(nameof(BuildRelativePathTestData))]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/413")]
		public void BuildRelativePath(string baseDirectory, string fileReference, string expectedRelativePath) => 
			Assert.Equal(expectedRelativePath, Utils.GetRelativePath(fileReference, baseDirectory), ignoreCase: true);

		public static IEnumerable<object[]> BuildRelativePathTestData() {
			yield return new object[] { "C:\\Test", "C:\\Test\\Asm.dll", "Asm.dll" };
			yield return new object[] { "C:\\Test\\", "C:\\Test\\Asm.dll", "Asm.dll" };
			yield return new object[] { "C:\\Test", "C:\\Test\\Test2\\Asm.dll", "Test2\\Asm.dll" };
			yield return new object[] { "C:\\Test\\", "C:\\Test\\Test2\\Asm.dll", "Test2\\Asm.dll" };
			yield return new object[] { "C:\\Test", "C:\\Test\\Test2\\Test3\\Asm.dll", "Test2\\Test3\\Asm.dll" };
			yield return new object[] { "C:\\Test\\", "C:\\Test\\Test2\\Test3\\Asm.dll", "Test2\\Test3\\Asm.dll" };
			yield return new object[] { "C:\\Test", "C:\\Test2\\Asm.dll", null };
			yield return new object[] { "C:\\Test\\", "C:\\Test2\\Asm.dll", null };

			// Only for case insensitive file systems (windows)
			yield return new object[] { "C:\\Test", "c:\\test\\test2\\test3\\asm.dll", "Test2\\Test3\\Asm.dll" };
			yield return new object[] { "C:\\Test", "C:\\TEST\\TEST2\\TEST3\\ASM.DLL", "Test2\\Test3\\Asm.dll" };
		}
	}
}

```

`Tests/Confuser.Renamer.Test/AbstractAttribute.cs`:

```cs
using System;

namespace Confuser.Renamer.Test {
	public class AbstractAttribute : Attribute {
		public int Value { get; set; }
	}
}

```

`Tests/Confuser.Renamer.Test/Analyzers/ManifestResourceAnalyzerTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Confuser.Core.Services;
using Confuser.Renamer.Analyzers;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Xunit;

namespace Confuser.Renamer.Test.Analyzers {
	public sealed class ManifestResourceAnalyzerTest {
		private static Stream GetManifestStreamSource() =>
			typeof(ManifestResourceAnalyzerTest).Assembly.GetManifestResourceStream(typeof(ManifestResourceAnalyzerTest), "Test_Resource.txt");
		private static Stream GetManifestStreamResult() =>
			typeof(ManifestResourceAnalyzerTest).Assembly.GetManifestResourceStream("Confuser.Renamer.Test.Analyzers.Test_Resource.txt");

		[Fact]
		public void TestReferenceMethod1Test() {
			var moduleDef = Helpers.LoadTestModuleDef();
			var thisTypeDef = moduleDef.Find(typeof(ManifestResourceAnalyzerTest).FullName, false);
			var refMethod = thisTypeDef.FindMethod(nameof(GetManifestStreamSource));

			var traceService = new TraceService();
			ManifestResourceAnalyzer.PreRename(moduleDef, traceService, refMethod);

			CompareMethodBody(refMethod.Body, thisTypeDef.FindMethod(nameof(GetManifestStreamResult)).Body);
		}

		private static void CompareMethodBody(CilBody body1, CilBody body2) {
			Assert.Equal(body1.HasInstructions, body2.HasInstructions);
			if (!body1.HasInstructions) return;

			Assert.Equal(body1.Instructions.Count, body2.Instructions.Count);
			for (var i = 0; i < body1.Instructions.Count; i++) {
				var instruction1 = body1.Instructions[i];
				var instruction2 = body2.Instructions[i];

				Assert.Equal(instruction1.OpCode, instruction2.OpCode);
				if (instruction1.Operand is IMethodDefOrRef methodRef1) {
					var methodRef2 = Assert.IsAssignableFrom<IMethodDefOrRef>(instruction2.Operand);
					Assert.Equal(methodRef1.FullName, methodRef2.FullName);
				} else {
					Assert.Equal(instruction1.Operand, instruction2.Operand);
				}
			}
		}
	}
}

```

`Tests/Confuser.Renamer.Test/Analyzers/ReflectionAnalyzerTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Confuser.Core.Services;
using Confuser.Renamer.Analyzers;
using Confuser.UnitTest;
using dnlib.DotNet;
using Moq;
using Xunit;
using Xunit.Abstractions;
using ILogger = Confuser.Core.ILogger;

namespace Confuser.Renamer.Test.Analyzers {
	public sealed class ReflectionAnalyzerTest {
#pragma warning disable IDE0044 // Add readonly modifier
		private string _referenceField;
#pragma warning restore IDE0044 // Add readonly modifier
		private readonly ITestOutputHelper _outputHelper;

		public ReflectionAnalyzerTest(ITestOutputHelper outputHelper) =>
			_outputHelper = outputHelper ?? throw new ArgumentNullException(nameof(outputHelper));

		private ILogger CreateLogger() => new XunitLogger(_outputHelper);

		private string ReferenceProperty { get; }

		private void TestReferenceMethod1() {
			var method1 = typeof(ReflectionAnalyzerTest).GetMethod(nameof(TestReferenceMethod1));
			Assert.Null(method1);
			var method2 = typeof(ReflectionAnalyzerTest).GetMethod(nameof(TestReferenceMethod1), BindingFlags.NonPublic | BindingFlags.Instance);
			Assert.NotNull(method2);
			var method3 = typeof(ReflectionAnalyzerTest).GetMethod(nameof(TestReferenceMethod1), BindingFlags.NonPublic | BindingFlags.Instance, null, CallingConventions.Standard, new Type[] { typeof(string) }, null);
			Assert.Null(method3);
		}

		[SuppressMessage("Usage", "xUnit1013:Public method should be marked as test", Justification = "It's not a test!")]
		public void TestReferenceField1() {
			var field1 = typeof(ReflectionAnalyzerTest).GetField(nameof(_referenceField));
			Assert.Null(field1);
			var field2 = typeof(ReflectionAnalyzerTest).GetField(nameof(_referenceField), BindingFlags.NonPublic | BindingFlags.Instance);
			Assert.NotNull(field2);
		}
		
		[SuppressMessage("Usage", "xUnit1013:Public method should be marked as test", Justification = "It's not a test!")]
		public void TestReferenceProperty1() {
			var prop1 = typeof(ReflectionAnalyzerTest).GetProperty(nameof(ReferenceProperty));
			Assert.Null(prop1);
			var prop2 = typeof(ReflectionAnalyzerTest).GetProperty(nameof(ReferenceProperty), BindingFlags.NonPublic | BindingFlags.Instance);
			Assert.NotNull(prop2);
		}

		[Fact]
		public void TestReferenceMethod1Test() {
			TestReferenceMethod1();

			var moduleDef = Helpers.LoadTestModuleDef();
			var thisTypeDef = moduleDef.Find("Confuser.Renamer.Test.Analyzers.ReflectionAnalyzerTest", false);
			var refMethod = thisTypeDef.FindMethod(nameof(TestReferenceMethod1));

			var nameService = Mock.Of<INameService>();
			Mock.Get(nameService).Setup(s => s.SetCanRename(refMethod, false));
			Mock.Get(nameService).Setup(s => s.SetCanRename(refMethod, false));
			Mock.Get(nameService).Setup(s => s.GetReferences(refMethod)).Returns(new List<INameReference>());

			var traceService = new TraceService();
			var analyzer = new ReflectionAnalyzer();
			analyzer.Analyze(nameService, traceService, new List<ModuleDef>() { moduleDef }, CreateLogger(), refMethod);

			Mock.Get(nameService).VerifyAll();
		}

		[Fact]
		public void TestReferenceField1Test() {
			TestReferenceField1();

			var moduleDef = Helpers.LoadTestModuleDef();
			var thisTypeDef = moduleDef.Find("Confuser.Renamer.Test.Analyzers.ReflectionAnalyzerTest", false);
			var refMethod = thisTypeDef.FindMethod(nameof(TestReferenceField1));
			var refField = thisTypeDef.FindField(nameof(_referenceField));

			var nameService = Mock.Of<INameService>();
			Mock.Get(nameService).Setup(s => s.SetCanRename(refField, false));
			Mock.Get(nameService).Setup(s => s.SetCanRename(refField, false));

			var traceService = new TraceService();
			var analyzer = new ReflectionAnalyzer();

			analyzer.Analyze(nameService, traceService, new List<ModuleDef>() { moduleDef }, CreateLogger(), refMethod);

			Mock.Get(nameService).VerifyAll();
		}

		[Fact]
		public void TestReferenceProperty1Test() {
			TestReferenceProperty1();

			var moduleDef = Helpers.LoadTestModuleDef();
			var thisTypeDef = moduleDef.Find("Confuser.Renamer.Test.Analyzers.ReflectionAnalyzerTest", false);
			var refMethod = thisTypeDef.FindMethod(nameof(TestReferenceProperty1));
			var refProp = thisTypeDef.FindProperty(nameof(ReferenceProperty));

			var nameService = Mock.Of<INameService>();
			Mock.Get(nameService).Setup(s => s.SetCanRename(refProp, false));
			Mock.Get(nameService).Setup(s => s.SetCanRename(refProp, false));
			Mock.Get(nameService).Setup(s => s.GetReferences(refProp)).Returns(new List<INameReference>());

			var traceService = new TraceService();
			var analyzer = new ReflectionAnalyzer();
			analyzer.Analyze(nameService, traceService, new List<ModuleDef>() { moduleDef }, CreateLogger(), refMethod);

			Mock.Get(nameService).VerifyAll();
		}
	}
}

```

`Tests/Confuser.Renamer.Test/Analyzers/TypeBlobAnalyzerTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Confuser.Renamer.Analyzers;
using Confuser.UnitTest;
using dnlib.DotNet;
using Moq;
using Xunit;
using Xunit.Abstractions;

namespace Confuser.Renamer.Test.Analyzers {
	[Implementation(Value = 5)]
	public class TypeBlobAnalyzerTest {
		private readonly ITestOutputHelper outputHelper;

		public TypeBlobAnalyzerTest(ITestOutputHelper outputHelper) =>
			this.outputHelper = outputHelper ?? throw new ArgumentNullException(nameof(outputHelper));

        [Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/84")]
		public void AnalyseAttributeTest() {
			var moduleDef = Helpers.LoadTestModuleDef();
            
			var nameService = Mock.Of<INameService>();

            void VerifyLog(string message) {
                Assert.DoesNotContain("Failed to resolve CA field", message);
                Assert.DoesNotContain("Failed to resolve CA property", message);
			}

            TypeBlobAnalyzer.Analyze(nameService, new List<ModuleDefMD>() { moduleDef }, new XunitLogger(outputHelper, VerifyLog), moduleDef);

			Mock.Get(nameService).VerifyAll();
		}
	}
}

```

`Tests/Confuser.Renamer.Test/Confuser.Renamer.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Moq" Version="4.17.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\..\Confuser.Renamer\Confuser.Renamer.csproj" />
  </ItemGroup>

</Project>

```

`Tests/Confuser.Renamer.Test/Helpers.cs`:

```cs
using dnlib.DotNet;
using Moq;
using Xunit;

namespace Confuser.Renamer.Test {
	internal static class Helpers {
		internal static ModuleDefMD LoadTestModuleDef() {
			var asmResolver = new AssemblyResolver { EnableTypeDefCache = true };
			asmResolver.DefaultModuleContext = new ModuleContext(asmResolver);
			var options = new ModuleCreationOptions(asmResolver.DefaultModuleContext) {
				TryToLoadPdbFromDisk = false
			};

            asmResolver.AddToCache(ModuleDefMD.Load(typeof(Mock).Module, options));
            asmResolver.AddToCache(ModuleDefMD.Load(typeof(FactAttribute).Module, options));

            var thisModule = ModuleDefMD.Load(typeof(VTableTest).Module, options);
            asmResolver.AddToCache(thisModule);

			return thisModule;
		}
	}
}

```

`Tests/Confuser.Renamer.Test/ImplementationAttribute.cs`:

```cs
using System;

namespace Confuser.Renamer.Test {
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class ImplementationAttribute : AbstractAttribute {
	}
}

```

`Tests/Confuser.Renamer.Test/VTableTest.cs`:

```cs
using System;
using System.Collections.Generic;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace Confuser.Renamer.Test {
	public class VTableTest {
		private readonly ITestOutputHelper outputHelper;

		public VTableTest(ITestOutputHelper outputHelper) =>
			this.outputHelper = outputHelper ?? throw new ArgumentNullException(nameof(outputHelper));

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/34")]
		public void DuplicatedMethodSignatureTest() {
			var refClass = new VTableTestRefClass();
			Assert.Equal(1, refClass.TestMethod(new List<string>()));
			Assert.Equal(2, refClass.TestMethod2(new List<string>()));
			var refInterface = refClass as VTableTestRefInterface<string>;
			Assert.NotNull(refInterface);
			Assert.Equal(1, refInterface.TestMethod(new List<string>()));
			Assert.Equal(2, refInterface.TestMethod2(new List<string>()));
			int CallGenericFunction<T>(VTableTestRefInterface<T> refIfc) => refIfc.TestMethod(new List<T>());
			Assert.Equal(1, CallGenericFunction(refInterface));

			var moduleDef = Helpers.LoadTestModuleDef();
			var refClassTypeDef = moduleDef.Find("Confuser.Renamer.Test.VTableTestRefClass", false);
			
			Assert.NotNull(refClassTypeDef);
			var vTableStorage = new VTableStorage(new XunitLogger(outputHelper));
			var refClassVTable = vTableStorage.GetVTable(refClassTypeDef);
			Assert.NotNull(refClassVTable);
		}
	}

	internal class VTableTestRefClass : VTableTestRefInterface<string> {
		public int TestMethod(List<string> values) => 1;
		public int TestMethod2(List<string> values) => 2;
	}

	internal interface VTableTestRefInterface<T> {
		int TestMethod(List<string> values);
		int TestMethod(List<T> values);
		int TestMethod2(List<string> values);
	}
}

```

`Tests/Confuser.UnitTest/Confuser.UnitTest.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="..\ConfuserEx.Common.props" Condition="Exists('..\ConfuserEx.Common.props')" />

  <PropertyGroup Label="Assembly Settings">
    <TargetFramework>net461</TargetFramework>
  </PropertyGroup>

  <ItemGroup Label="Nuget Dependencies">
    <PackageReference Include="xunit" Version="2.4.1" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.0.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.4.3" />
  </ItemGroup>

  <ItemGroup Label="Project Dependencies">
    <ProjectReference Include="..\..\Confuser.Protections\Confuser.Protections.csproj" />
  </ItemGroup>

  <Import Project="..\ConfuserEx.Common.targets" Condition="Exists('..\ConfuserEx.Common.targets')" />

</Project>

```

`Tests/Confuser.UnitTest/FileUtilities.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;

namespace Confuser.UnitTest {
	public static class FileUtilities {
		public static void ClearOutput(string outputFile) {
			try {
				if (File.Exists(outputFile)) {
					File.Delete(outputFile);
				}
			}
			catch (UnauthorizedAccessException) { }
			var debugSymbols = Path.ChangeExtension(outputFile, "pdb");
			try {
				if (File.Exists(debugSymbols)) {
					File.Delete(debugSymbols);
				}
			}
			catch (UnauthorizedAccessException) { }

			try {
				var directoryName = Path.GetDirectoryName(outputFile);
				if (Directory.Exists(directoryName) && !Directory.EnumerateFileSystemEntries(directoryName).Any()) {
					Directory.Delete(directoryName);
				}
			}
			catch (UnauthorizedAccessException) { }
		}

		public static byte[] ComputeFileChecksum(string file) {
			if (file == null) throw new ArgumentNullException(nameof(file));
			if (!File.Exists(file)) throw new FileNotFoundException($"File: {file}");

			using (var checksum = SHA1.Create()) {
				using (var fs = File.OpenRead(file)) {
					return checksum.ComputeHash(fs);
				}
			}
		}
	}
}

```

`Tests/Confuser.UnitTest/TestBase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Xunit;
using Xunit.Abstractions;
using Xunit.Sdk;

namespace Confuser.UnitTest {
	public abstract class TestBase {
		private const string _externalPrefix = "external:";

		readonly ITestOutputHelper outputHelper;

		protected static IEnumerable<SettingItem<Protection>> NoProtections => Enumerable.Empty<SettingItem<Protection>>();

		protected TestBase(ITestOutputHelper outputHelper) =>
			this.outputHelper = outputHelper ?? throw new ArgumentNullException(nameof(outputHelper));

		protected Task Run(string inputFileName, string[] expectedOutput, SettingItem<Protection> protection,
			string outputDirSuffix = "", Action<string> outputAction = null, SettingItem<Packer> packer = null,
			Action<ProjectModule> projectModuleAction = null, Func<string, Task> postProcessAction = null,
			string seed = null, bool checkOutput = true) =>

			Run(new[] { inputFileName }, expectedOutput, protection, outputDirSuffix, outputAction, packer,
				projectModuleAction, postProcessAction, seed, checkOutput);

		protected Task Run(string inputFileName, string[] expectedOutput, IEnumerable<SettingItem<Protection>> protections,
			string outputDirSuffix = "", Action<string> outputAction = null, SettingItem<Packer> packer = null,
			Action<ProjectModule> projectModuleAction = null, Func<string, Task> postProcessAction = null) =>

			Run(new[] { inputFileName }, expectedOutput, protections, outputDirSuffix, outputAction, packer,
				projectModuleAction, postProcessAction);

		protected Task Run(string[] inputFileNames, string[] expectedOutput, SettingItem<Protection> protection,
			string outputDirSuffix = "", Action<string> outputAction = null, SettingItem<Packer> packer = null,
			Action<ProjectModule> projectModuleAction = null, Func<string, Task> postProcessAction = null,
			string seed = null, bool checkOutput = true) {
			var protections = (protection is null) ? Enumerable.Empty<SettingItem<Protection>>() : new[] { protection };
			return Run(inputFileNames, expectedOutput, protections, outputDirSuffix, outputAction, packer, projectModuleAction, postProcessAction, seed, checkOutput);
		}

		protected async Task Run(string[] inputFileNames, string[] expectedOutput, IEnumerable<SettingItem<Protection>> protections,
			string outputDirSuffix = "", Action<string> outputAction = null, SettingItem<Packer> packer = null,
			Action<ProjectModule> projectModuleAction = null, Func<string, Task> postProcessAction = null,
			string seed = null, bool checkOutput = true) {

			var baseDir = Environment.CurrentDirectory;
			var outputDir = Path.Combine(baseDir, "obfuscated" + outputDirSuffix);
			if (Directory.Exists(outputDir)) {
				Directory.Delete(outputDir, true);
			}

			string firstFileName = GetFileName(inputFileNames[0]);
			string entryInputFileName = Path.Combine(baseDir, firstFileName);
			var entryOutputFileName = Path.Combine(outputDir, firstFileName);
			var proj = new ConfuserProject {
				BaseDirectory = baseDir,
				OutputDirectory = outputDir,
				Packer = packer,
				Seed = seed
			};

			foreach (string name in inputFileNames) {
				var projectModule = new ProjectModule {
					Path = Path.Combine(baseDir, GetFileName(name)),
					IsExternal = IsExternal(name)
				};
				projectModuleAction?.Invoke(projectModule);
				proj.Add(projectModule);
			}

			var rule = new Rule();
			rule.AddRange(protections);
			if (rule.Count > 0)
				proj.Rules.Add(rule);

			var parameters = new ConfuserParameters {
				Project = proj,
				Logger = new XunitLogger(outputHelper, outputAction)
			};

			await ConfuserEngine.Run(parameters);

			for (var index = 0; index < inputFileNames.Length; index++) {
				string name = GetFileName(inputFileNames[index]);
				string outputName = Path.Combine(outputDir, name);

				bool exists;
				if (index == 0) {
					Assert.True(File.Exists(outputName));
					exists = true;
				}
				else {
					exists = File.Exists(outputName);
				}

				if (exists) {
					// Check if output assemblies is obfuscated
					Assert.NotEqual(FileUtilities.ComputeFileChecksum(Path.Combine(baseDir, name)),
						FileUtilities.ComputeFileChecksum(outputName));
				}
				else if (IsExternal(inputFileNames[index])) {
					File.Copy(
						Path.Combine(baseDir, GetFileName(inputFileNames[index])),
						Path.Combine(outputDir, GetFileName(inputFileNames[index])));
				}
			}

			if (Path.GetExtension(entryInputFileName) == ".exe") {
				var info = new ProcessStartInfo(entryOutputFileName) {
					RedirectStandardOutput = true,
					RedirectStandardError = true,
					UseShellExecute = false
				};
				using (var process = Process.Start(info)) {
					using (var stdout = process.StandardOutput) {
						try {
							if (checkOutput) {
								Assert.Equal("START", await stdout.ReadLineAsync());

								foreach (string line in expectedOutput) {
									Assert.Equal(line, await stdout.ReadLineAsync());
								}

								Assert.Equal("END", await stdout.ReadLineAsync());
								Assert.Empty(await stdout.ReadToEndAsync());
							}
						}
						catch (XunitException) {
							try {
								LogRemainingStream("Remaining standard output:", stdout);
								using (var stderr = process.StandardError) {
									LogRemainingStream("Remaining standard error:", stderr);
								}
							}
							catch {
								// ignore
							}
							throw;
						}
					}

					using (var stderr = process.StandardError) {
						Assert.Empty(await stderr.ReadToEndAsync());
					}

					Assert.True(process.HasExited);
					Assert.Equal(42, process.ExitCode);
				}
			}

			if (!(postProcessAction is null))
				await postProcessAction.Invoke(outputDir);
		}

		private void LogRemainingStream(string header, StreamReader reader) {
			var remainingOutput = reader.ReadToEnd();
			if (!string.IsNullOrWhiteSpace(remainingOutput)) {
				outputHelper.WriteLine(header);
				outputHelper.WriteLine(remainingOutput.Trim());
			}
		}

		private static string GetFileName(string name) {
			if (IsExternal(name))
				return name.Substring(_externalPrefix.Length);
			return name;
		}

		private static bool IsExternal(string name) => name.StartsWith(_externalPrefix, StringComparison.OrdinalIgnoreCase);
	}
}

```

`Tests/Confuser.UnitTest/XUnitLogger.cs`:

```cs
using System;
using Confuser.Core;
using Xunit.Abstractions;

namespace Confuser.UnitTest {
	public sealed class XunitLogger : ILogger {
		private readonly ITestOutputHelper _outputHelper;
		private readonly Action<string> _outputAction;

		public XunitLogger(ITestOutputHelper outputHelper) : this(outputHelper, null) { }

		public XunitLogger(ITestOutputHelper outputHelper, Action<string> outputAction) {
			_outputHelper = outputHelper ?? throw new ArgumentNullException(nameof(outputHelper));
			_outputAction = outputAction;
		}

		void ILogger.Debug(string msg) =>
			ProcessOutput("[DEBUG] " + msg);

		void ILogger.DebugFormat(string format, params object[] args) =>
			ProcessOutput("[DEBUG] " + format, args);

		void ILogger.EndProgress() { }

		void ILogger.Error(string msg) =>
			throw new Exception(msg);

		void ILogger.ErrorException(string msg, Exception ex) =>
			throw new Exception(msg, ex);

		void ILogger.ErrorFormat(string format, params object[] args) =>
			throw new Exception(string.Format(format, args));

		void ILogger.Finish(bool successful) =>
			ProcessOutput("[DONE]");

		void ILogger.Info(string msg) =>
			ProcessOutput("[INFO] " + msg);

		void ILogger.InfoFormat(string format, params object[] args) =>
			ProcessOutput("[INFO] " + format, args);

		void ILogger.Progress(int progress, int overall) { }

		void ILogger.Warn(string msg) =>
			ProcessOutput("[WARN] " + msg);

		void ILogger.WarnException(string msg, Exception ex) =>
			ProcessOutput("[WARN] " + msg + Environment.NewLine + ex.ToString());

		void ILogger.WarnFormat(string format, params object[] args) =>
			ProcessOutput("[WARN] " + format, args);

		private void ProcessOutput(string format, params object[] args) => 
			ProcessOutput(string.Format(format, args));

		private void ProcessOutput(string message) {
			_outputAction?.Invoke(message);
			_outputHelper.WriteLine(message);
		}
	}
}

```

`Tests/IncorrectRedirectToGac.Test/IncorrectRedirectToGac.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
      <TargetFramework>net472</TargetFramework>
      <IsPackable>false</IsPackable>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
      <ProjectReference Include="..\IncorrectRedirectToGac\IncorrectRedirectToGac.csproj" />
    </ItemGroup>

</Project>

```

`Tests/IncorrectRedirectToGac.Test/IncorrectRedirectToGacTest.cs`:

```cs
using System.Collections.Generic;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace IncorrectRedirectToGac.Test {
	public class IncorrectRedirectToGacTest : TestBase {
		public IncorrectRedirectToGacTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "core")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/144")]
		public async Task IncorrectRedirectToGac() =>
			await Run(
				new [] { "IncorrectRedirectToGac.exe", "Microsoft.Build.Framework.dll" }, new string[0], NoProtections
			);

		[Fact]
		[Trait("Category", "core")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/144")]
		public async Task IncorrectExternalRedirectToGac() =>
			await Run(
				new [] { "IncorrectRedirectToGac.exe", "external:Microsoft.Build.Framework.dll" }, new string[0], NoProtections, outputDirSuffix: "_external"
			);

		[Theory]
		[MemberData(nameof(IncorrectRedirectToGacPackerTestData))]
		[Trait("Category", "core")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/144")]
		public async Task IncorrectRedirectToGacPacker(string compatKey, string deriverKey) =>
			await Run(
				new [] { "IncorrectRedirectToGac.exe", "Microsoft.Build.Framework.dll" }, 
				new string[0], 
				NoProtections,
				outputDirSuffix: $"_packer_{compatKey}_{deriverKey}",
				packer: new SettingItem<Packer>("compressor") {{"compat", compatKey}, {"key", deriverKey}}
			);

		public static IEnumerable<object[]> IncorrectRedirectToGacPackerTestData() {
			foreach (var compressorCompatKey in new [] { "true", "false" })
				foreach (var compressorDeriveKey in new [] { "normal", "dynamic" })
					yield return new object[] { compressorCompatKey, compressorDeriveKey };
		}
	}
}

```

`Tests/IncorrectRedirectToGac/IncorrectRedirectToGac.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net472</TargetFramework>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Build.Framework" Version="16.11.0" />
  </ItemGroup>

</Project>

```

`Tests/IncorrectRedirectToGac/Program.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using Microsoft.Build.Framework;

namespace IncorrectRedirectToGac {
	public static class Program {
		public static int Main() {
			Console.WriteLine("START");
			var engine = new Engine();
			if (engine.BuildProjectFile("", null, null, null)) {
				Console.WriteLine("END");
			}

			return 42;
		}
	}

	class Engine : IBuildEngine5 {
		public bool IsRunningMultipleNodes => throw new NotImplementedException();

		public bool ContinueOnError => throw new NotImplementedException();

		public int LineNumberOfTaskNode => throw new NotImplementedException();

		public int ColumnNumberOfTaskNode => throw new NotImplementedException();

		public string ProjectFileOfTaskNode => throw new NotImplementedException();

		public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties,
			IDictionary targetOutputs, string toolsVersion) => true;

		public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties,
			IDictionary targetOutputs) => true;

		public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames,
			IDictionary[] globalProperties, IList<string>[] removeGlobalProperties, string[] toolsVersion,
			bool returnTargetOutputs) =>
			throw new NotImplementedException();

		public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames,
			IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, string[] toolsVersion,
			bool useResultsCache, bool unloadProjectsOnCompletion) =>
			throw new NotImplementedException();

		public object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime) => throw new NotImplementedException();

		public void LogCustomEvent(CustomBuildEventArgs e) => throw new NotImplementedException();

		public void LogErrorEvent(BuildErrorEventArgs e) => throw new NotImplementedException();

		public void LogMessageEvent(BuildMessageEventArgs e) => throw new NotImplementedException();

		public void LogTelemetry(string eventName, IDictionary<string, string> properties) => throw new NotImplementedException();

		public void LogWarningEvent(BuildWarningEventArgs e) => throw new NotImplementedException();

		public void Reacquire() => throw new NotImplementedException();

		public void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime,
			bool allowEarlyCollection) =>
			throw new NotImplementedException();

		public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime) => throw new NotImplementedException();

		public void Yield() => throw new NotImplementedException();
	}
}

```

`Tests/MessageDeobfuscation.Test/MessageDeobfuscation.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
    <RootNamespace>MessageDeobfuscation.Test</RootNamespace>
  </PropertyGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\MessageDeobfuscation\MessageDeobfuscation.csproj" />
    <ProjectReference Include="..\MethodOverloading\MethodOverloading.csproj" />
  </ItemGroup>
</Project>

```

`Tests/MessageDeobfuscation.Test/MessageDeobfuscationTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.Renamer;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace MessageDeobfuscation.Test {
	public class MessageDeobfuscationTest : TestBase {
		readonly string _expectedDeobfuscatedOutput = String.Join(Environment.NewLine,
			"Exception",
			"   at MessageDeobfuscation.Class.NestedClass.Method(String )",
			"   at MessageDeobfuscation.Program.Main()");

		const string Password = "password";
		const string Seed = "seed";

		public MessageDeobfuscationTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[MemberData(nameof(RenameModeAndExpectedObfuscatedOutput))]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		public async Task MessageDeobfuscationWithSymbolsMap(string renameMode, string[] expectedObfuscatedOutput) =>
			await Run(
				"MessageDeobfuscation.exe",
				expectedObfuscatedOutput,
				new SettingItem<Protection>("rename") { ["mode"] = renameMode },
				$"SymbolsMap_{renameMode}",
				seed: "1234",
				postProcessAction: outputPath => {
					var deobfuscator = MessageDeobfuscator.Load(Path.Combine(outputPath, "symbols.map"));
					var deobfuscatedMessage =
						deobfuscator.DeobfuscateMessage(string.Join(Environment.NewLine, expectedObfuscatedOutput));

					string classId, nestedClassId, methodId, fieldId, propertyId, eventId;
					if (renameMode == nameof(RenameMode.Decodable)) {
						classId = "_OokpKOmal5JNZMPvSAFgHLHjBke";
						nestedClassId = "_tc5CFDIJ2J9Fx3ehd3sgjTMAxCaA";
						methodId = "_zbgDV4jbK6Oi9WBq66uG2ct7IoRA";
						fieldId = "_QHxqC1xaBFmUQawCZSOQpattICo";
						propertyId = "_FJthtfOBOiQFgVDIymbi3wwJoeN";
						eventId = "_cbPBZqkDuaNXOkmJtacrG2uYfZs";
					}
					else {
						classId = "_F";
						nestedClassId = "_D";
						methodId = "_c";
						fieldId = "_C";
						propertyId = "_e";
						eventId = "_A";
					}

					void CheckName(string expectedFullName, string expectedShortName, string obfuscatedName) {
						var fullName = deobfuscator.DeobfuscateSymbol(obfuscatedName, false);
						Assert.Equal(expectedFullName, fullName);
						Assert.Equal(expectedShortName, MessageDeobfuscator.ExtractShortName(fullName));
					}

					CheckName("MessageDeobfuscation.Class", "MessageDeobfuscation.Class",
						classId);
					CheckName("MessageDeobfuscation.Class/NestedClass", "NestedClass",
						nestedClassId);
					CheckName("MessageDeobfuscation.Class::Method(System.String,System.Int32)", "Method",
						methodId);
					CheckName("MessageDeobfuscation.Class::Field", "Field",
						fieldId);
					CheckName("MessageDeobfuscation.Class::Property", "Property",
						propertyId);
					CheckName("MessageDeobfuscation.Class::Event", "Event",
						eventId);

					Assert.Equal(_expectedDeobfuscatedOutput, deobfuscatedMessage);
					return Task.Delay(0);
				}
			);

		public static IEnumerable<object[]> RenameModeAndExpectedObfuscatedOutput() =>
			new[] {
				new object[] {
					nameof(RenameMode.Decodable),
					new[] {
						"Exception",
						"   at _OokpKOmal5JNZMPvSAFgHLHjBke._tc5CFDIJ2J9Fx3ehd3sgjTMAxCaA._8Tq88jpv7mEXkEMavg6AaMFsXJt(String )",
						"   at _ykdLsBmsKGrd6fxeEseqJs8XlpP._tfvbqapfg44suL8taZVvOKM4AoG()"
					}
				},
				new object[] {
					nameof(RenameMode.Sequential), new[] {
						"Exception",
						"   at _F._D._B(String )",
						"   at _b._E()"
					}
				}
			};

		[Fact]
		[Trait("Category", "Protection")]
		public async Task CheckGeneratedPassword() {
			string actualPassword1 = null, actualPassword2 = null;
			await RunDeobfuscationWithPassword(true, null, "_0", Array.Empty<string>(),
				outputPath => {
				actualPassword1 = File.ReadAllText(Path.Combine(outputPath, CoreComponent.PasswordFileName));
				Assert.True(Guid.TryParse(actualPassword1, out _));
				return Task.Delay(0);
			});
			await RunDeobfuscationWithPassword(true, null, "_1", Array.Empty<string>(),
				outputPath => {
				actualPassword2 = File.ReadAllText(Path.Combine(outputPath, CoreComponent.PasswordFileName));
				Assert.True(Guid.TryParse(actualPassword2, out _));
				return Task.Delay(0);
			});
			Assert.NotEqual(actualPassword1, actualPassword2);
		}

		[Fact]
		[Trait("Category", "Protection")]
		public async Task CheckPasswordDependsOnSeed() {
			var expectedObfuscatedOutput = new[] {
				"Exception",
				"   at oZuuchQgRo99FxO43G5kj2LB6aE3b$hsLiIOVL3cn0lg.98C7L64wnMJK6DFKHzyWSw8.at9I2jHJrbSIlewmDrNXdMI(String )",
				"   at EcGxTPKtKIEeZuP3ekjPVhrVKQsiovm5zMkq5xfZbt1V.AiskF07vqbD8ZFG03Jyiiu8()"
			};
			await RunDeobfuscationWithPassword(true, Seed, "_0", expectedObfuscatedOutput,
				outputPath => {
					Assert.Equal(Seed, File.ReadAllText(Path.Combine(outputPath, CoreComponent.PasswordFileName)));
				return Task.Delay(0);
			});
			await RunDeobfuscationWithPassword(true, Seed, "_1", expectedObfuscatedOutput,
				outputPath => {
					Assert.Equal(Seed, File.ReadAllText(Path.Combine(outputPath, CoreComponent.PasswordFileName)));
				return Task.Delay(0);
			});
		}

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		public async Task MessageDeobfuscationWithPassword() {
			var expectedObfuscatedOutput = new[] {
				"Exception",
				"   at oQmpV$y2k2b9P3d6GP1cxGPuRtKaNIZvZcKpZXSfKFG8.99_z9Rxdp_fWfuD3fr45FSA.at9DaPNMANuLaMV_3scPWDU(String )",
				"   at EbUjRcrC76NnA7RJlhQffrfp$vMGHdDfqtVFtWrAOPyD.AkpOh$3Zo3M8ga5lTY9etcM()"
			};
			await RunDeobfuscationWithPassword(false, null, "", expectedObfuscatedOutput, outputPath => {
				var deobfuscator = new MessageDeobfuscator(Password);
				var deobfuscatedMessage =
					deobfuscator.DeobfuscateMessage(string.Join(Environment.NewLine, expectedObfuscatedOutput));

				void CheckName(string expectedName, string obfuscatedName) {
					var name = deobfuscator.DeobfuscateSymbol(obfuscatedName, true);
					Assert.Equal(expectedName, name);
				}

				CheckName("MessageDeobfuscation.Class", "oQmpV$y2k2b9P3d6GP1cxGPuRtKaNIZvZcKpZXSfKFG8");
				CheckName("NestedClass", "CE8t0VDPQk9$jgv1XuRwt1k");
				CheckName("Method", "jevJU4p4yNrAYGqN7GkRWaI");
				CheckName("Field", "3IS4xsnUsvDQZop6e4WmNVw");
				CheckName("Property", "917VMBMNYHd0kfnnNkgeJ10");
				CheckName("Event", "AIyINk7kgFLFc73Md8Nu8Z0");

				Assert.Equal(_expectedDeobfuscatedOutput, deobfuscatedMessage);
				return Task.Delay(0);
			});
		}

		async Task RunDeobfuscationWithPassword(bool generatePassword, string seed, string suffix,
			string[] expectedObfuscatedOutput, Func<string, Task> postProcessAction) => await Run(
			"MessageDeobfuscation.exe",
			expectedObfuscatedOutput,
			new SettingItem<Protection>("rename") {
				["mode"] = "reversible",
				["password"] = Password,
				["generatePassword"] = generatePassword.ToString()
			},
			$"Password_{(generatePassword ? $"Random{(seed != null ? "_Seed" : "")}{suffix}" : $"Hardcoded{suffix}")}",
			checkOutput: !generatePassword || seed != null,
			seed: seed,
			postProcessAction: postProcessAction
		);
	}
}

```

`Tests/MessageDeobfuscation/MessageDeobfuscation.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
    <RootNamespace>MessageDeobfuscation</RootNamespace>
  </PropertyGroup>

</Project>

```

`Tests/MessageDeobfuscation/Program.cs`:

```cs
using System;
using System.Globalization;
using System.Threading;

namespace MessageDeobfuscation {
	class Class {
		public string Method(string param1, int param2) => "method";

		public string Field = "field";

		public string Property => "property";

		public event EventHandler<string> Event;

		public class NestedClass {
			internal string Method(string param) => throw new Exception($"Exception");
		}
	}

	public class Program {
		public static int Main() {
			// Setting the culture is required, to get a consistent error output
			Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
			Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;

			Console.WriteLine("START");
			try {
				new Class.NestedClass().Method("param");
			}
			catch (Exception ex) {
				Console.WriteLine(ex.Message);
				Console.WriteLine(ex.StackTrace);
			}
			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/MethodOverloading.Test/MethodOverloading.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>MethodOverloading.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\MethodOverloading\MethodOverloading.csproj" />
  </ItemGroup>

</Project>

```

`Tests/MethodOverloading.Test/MethodOverloadingTest.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace MethodOverloading.Test {
	public class MethodOverloadingTest : TestBase {
		public MethodOverloadingTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[MemberData(nameof(MethodOverloadingData))]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/230")]
		public async Task MethodOverloading(bool shortNames, bool preserveGenericParams) =>
			await Run(
				"MethodOverloading.exe",
				new [] {
					"1",
					"Hello world",
					"object",
					"2",
					"test",
					"5",
					"class",
					"class2",
					"class3",
					"class4",
					"class5",
					"BaseClassVirtualMethod",
					"ClassVirtualMethod",
					"ClassVirtualMethod"
				},
				new SettingItem<Protection>("rename") {
					["mode"] = "decodable",
					["shortNames"] = shortNames.ToString().ToLowerInvariant(),
					["preserveGenericParams"] = preserveGenericParams.ToString().ToLowerInvariant()
				},
				(shortNames ? "_shortnames" : "_fullnames") + (preserveGenericParams ? "_preserveGenericParams" : ""),
				seed: "seed",
				postProcessAction: outputPath => {
					var symbolsPath = Path.Combine(outputPath, "symbols.map");
					var symbols = File.ReadAllLines(symbolsPath).Select(line => {
						var parts = line.Split('\t');
						return new KeyValuePair<string, string>(parts[0], parts[1]);
					}).ToDictionary(keyValue => keyValue.Key, keyValue => keyValue.Value);

					if (shortNames) {
						Assert.Equal("MethodOverloading.Class", symbols["_iyWU2GdYVZxajP8BQlt8KKTy6qQ"]);
						Assert.Equal("MethodOverloading.Program/NestedClass", symbols["_CZIbNVHU7wPJyGhgOcTnIUsFtC0"]);
						Assert.Equal("OverloadedMethod", symbols["_phF8iy7Y79cwt3EaAFmJzW2bGch"]);
						Assert.Equal("Field", symbols["_6V1A5bTBinvE5uHIpOLYRNJLPo1"]);
						Assert.Equal("Property", symbols["_R1FgkOY1t1oZChSgmkBM94XFyCj"]);
						Assert.Equal("Event", symbols["_N2jFMB56aV9SI9hlSxW0X97PYvG"]);
					}
					else {
						Assert.Equal("MethodOverloading.Class", symbols["_iyWU2GdYVZxajP8BQlt8KKTy6qQ"]);
						Assert.Equal("MethodOverloading.Program/NestedClass", symbols["_CZIbNVHU7wPJyGhgOcTnIUsFtC0"]);
						Assert.Equal("MethodOverloading.Program::OverloadedMethod(System.Object[])", symbols["_LzCBuBOSn49xbtKNsjuJxQZPIEW"]);
						Assert.Equal("MethodOverloading.Program::OverloadedMethod(System.String)", symbols["_ywSbkiShk8k3qj7bBrEWEUfs9Km"]);
						Assert.Equal("MethodOverloading.BaseClass::Field", symbols["_yqni8M5s0WdS43DWP1TXNaYbKEH"]);
						Assert.Equal("MethodOverloading.BaseClass::Property", symbols["_3gBBhEIMEfnKvvSRKFDeTcFgGUPb"]);
						Assert.Equal("MethodOverloading.BaseClass::Event", symbols["_MbPHu2jYmPBHHFrz4bK83xDAwLH"]);
					}

					return Task.Delay(0);
				}
			);

		public static IEnumerable<object[]> MethodOverloadingData() {
			foreach (var shortNames in new[] {false, true}) {
				foreach (var preserveGenericParams in new[] {false, true}) {
					yield return new object[] {shortNames, preserveGenericParams};
				}
			}
		}
	}
}

```

`Tests/MethodOverloading/MethodOverloading.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>MethodOverloading</RootNamespace>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

</Project>

```

`Tests/MethodOverloading/Program.cs`:

```cs
using System;

namespace A {
	public static class X
	{
	}
}

namespace B {
	public static class X
	{
	}
}

namespace MethodOverloading {
	public interface IInterface {
		string Method(string param);
	}

	public class BaseClass {
		public string Method(string param) => param;

		public virtual string VirtualMethod() => "BaseClassVirtualMethod";

		public string Field = "field";

		public string Property => "property";

		public event EventHandler<string> Event;
	}

	public class Class : BaseClass, IInterface {
		public override string VirtualMethod() => "ClassVirtualMethod";
	}

	public interface IInterface2<Result> {
		string Method2(Result param);
	}

	public class BaseClass2 {
		public string Method2(string param) => param;
	}

	public class Class2 : BaseClass2, IInterface2<string> {
	}

	public class Class3 {
		public string Method3(string param) => "class3";
	}

	public class Class4 {
		public string Method3(string param) => "class4";
	}

	public interface Interface5 {
		string Method5(string param);
	}

	public class BaseClass5<T> {
		public virtual T Method5(T param) => param;
	}

	public class Class5 : BaseClass5<string>, Interface5 {
	}

	[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = false)]
	sealed class MyAttribute : Attribute
	{
		public MyAttribute(Type type)
		{
		}
	}

	[My(typeof(A.X))]
	[My(typeof(B.X))]
	public class Program {
		public class NestedClass {
			public override string ToString() => "test";
		}

		public static int OverloadedMethod(int param) => param;

		public static string OverloadedMethod(string param) => param;

		public static object OverloadedMethod(object[] objects) => objects[0];

		public static object OverloadedMethod(bool cond, float param1, double param2) => cond ? param1 : param2;

		public static NestedClass OverloadedMethod(NestedClass nestedClass) => nestedClass;

		public static T OverloadedMethod<T>(T param) => param;

		static int Main(string[] args) {
			Console.WriteLine("START");
			Console.WriteLine(OverloadedMethod(1));
			Console.WriteLine(OverloadedMethod("Hello world"));
			Console.WriteLine(OverloadedMethod(new object[] { "object" }));
			Console.WriteLine(OverloadedMethod(false, 1.0f, 2.0));
			Console.WriteLine(OverloadedMethod(new NestedClass()));
			Console.WriteLine(OverloadedMethod((byte)5));
			Console.WriteLine(new Class().Method("class"));
			Console.WriteLine(new Class2().Method2("class2"));
			Console.WriteLine(new Class3().Method3("class3"));
			Console.WriteLine(new Class4().Method3("class4"));
			Console.WriteLine(new Class5().Method5("class5"));
			Console.WriteLine(new BaseClass().VirtualMethod());
			BaseClass baseClass = new Class();
			Console.WriteLine(baseClass.VirtualMethod());
			Console.WriteLine(new Class().VirtualMethod());
			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/ReferenceProxy.Test/ReferenceProxy.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>False</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\ReferenceProxy\ReferenceProxy.csproj" />
  </ItemGroup>


</Project>

```

`Tests/ReferenceProxy.Test/ReferenceProxyTest.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace ReferenceProxy.Test {
	public class ReferenceProxyTest : TestBase {
		public ReferenceProxyTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Theory]
		[MemberData(nameof(ReferenceProxyData))]
		[Trait("Category", "Protection")]
		[Trait("Protection", "ref proxy")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/229")]
		public async Task ReferenceProxy(string mode, string encoding, bool internalRefs, bool typeErasure) =>
			await Run(
				"ReferenceProxy.exe",
				Array.Empty<string>(),
				new SettingItem<Protection>("ref proxy") {
					["mode"] = mode,
					["encoding"] = encoding,
					["internal"] = internalRefs.ToString(),
					["typeErasure"] = typeErasure.ToString()
				},
				outputDirSuffix: $"_{mode}_{encoding}_{internalRefs}_{typeErasure}"
			);

		public static IEnumerable<object[]> ReferenceProxyData() {
			foreach (var mode in new[] { "mild", "strong" })
				foreach (var encoding in new[] { "normal", "expression", "x86" })
					foreach (var internalRefs in new[] { true, false })
						foreach (var typeErasure in new[] { true, false }) {
							if (mode.Equals("mild") && !encoding.Equals("normal")) continue;
							yield return new object[] { mode, encoding, internalRefs, typeErasure };
						}
		}
	}
}

```

`Tests/ReferenceProxy/Program.cs`:

```cs
using System;

namespace ReferenceProxy {
	class Program {
		static int Main(string[] args) {
			Console.WriteLine("START");
			foreach (var arg in args)
				Console.WriteLine(arg);
			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/ReferenceProxy/ReferenceProxy.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <StartupObject>ReferenceProxy.Program</StartupObject>
  </PropertyGroup>

</Project>

```

`Tests/SignatureMismatch2.Test/SignatureMismatch2.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>SignatureMismatch2.Test</RootNamespace>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\SignatureMismatch2\SignatureMismatch2.csproj" />
  </ItemGroup>

</Project>

```

`Tests/SignatureMismatch2.Test/SignatureMismatch2Test.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace SignatureMismatch2.Test {
	public class SignatureMismatch2Test : TestBase {
		public SignatureMismatch2Test(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/187")]
		public async Task SignatureMismatch2() =>
			await Run(
				new [] { "SignatureMismatch2.exe", "SignatureMismatch2Helper.dll" },
				new [] { "External", "External" },
				new SettingItem<Protection>("rename") { ["renPublic"] = "true" }
			);
	}
}

```

`Tests/SignatureMismatch2/Program.cs`:

```cs
using System;
using SignatureMismatch2Helper;

namespace SignatureMismatch {
	public interface IInterface
	{
		void Method(External obj);
	}

	public class Class : IInterface
	{
		public void Method(External obj) => Console.WriteLine(obj.Name);
	}

	public interface IInterface2<Result> {
		void Method(Result obj);
	}

	public class Class2 : IInterface2<External> {
		public void Method(External obj) => Console.WriteLine(obj.Name);
	}

	public class Program {
		static int Main(string[] args) {
			Console.WriteLine("START");
			new Class().Method(new External());
			new Class2().Method(new External());
			Console.WriteLine("END");

			return 42;
		}
	}
}

```

`Tests/SignatureMismatch2/SignatureMismatch2.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>SignatureMismatch</RootNamespace>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\SignatureMismatch2Helper\SignatureMismatch2Helper.csproj" />
  </ItemGroup>

</Project>

```

`Tests/SignatureMismatch2Helper/External.cs`:

```cs
namespace SignatureMismatch2Helper {
	public class External
	{
		public virtual string Name => "External";
	}
}

```

`Tests/SignatureMismatch2Helper/SignatureMismatch2Helper.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <RootNamespace>SignatureMismatch</RootNamespace>
    <LangVersion>7.3</LangVersion>
  </PropertyGroup>

</Project>

```

`Tests/TypeScrambler.Test/TypeScrambler.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\TypeScrambler\TypeScrambler.csproj" />
  </ItemGroup>

</Project>
```

`Tests/TypeScrambler.Test/TypeScramblerTest.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace TypeScrambler.Test {
	public sealed class TypeScramblerTest : TestBase {
		public TypeScramblerTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "typescramble")]
		public async Task ScrambleAndExecuteTest()  =>
			await Run("TypeScrambler.exe",
				new[] {
					"Text from WriteTextToConsole",
					"Static Text",
					"Non-Static Text",
					"Text from generic method",
					"Text from generic class",
					"Text from Resources",
					"Text from implicit interface implementation.",
					"Text from implicit interface implementation.", 
					"Text from explicit interface implementation.", 
					"Text from static generic method.",
					"From the factory: Test"
				},
				new SettingItem<Protection>("typescramble"));
	}
}

```

`Tests/TypeScrambler/ExplicitInterface.cs`:

```cs
namespace TypeScrambler {
	internal class ExplicitInterface : ITestInterface {
		string ITestInterface.GetText() => "Text from explicit interface implementation.";
	}
}

```

`Tests/TypeScrambler/FactoryPattern.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TypeScrambler {
	internal sealed class FactoryPattern {
		internal string Message { get; }
		private FactoryPattern(string message) => Message = $"From the factory: {message}";

		internal static FactoryPattern Create(string message) => new FactoryPattern(message);
	}
}

```

`Tests/TypeScrambler/GenericClass.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace TypeScrambler {
	internal class GenericClass<T> where T : IEnumerable<char> {
		public IEnumerable<char> GetReverse(T input) => input.Reverse();
	}
}

```

`Tests/TypeScrambler/ITestInterface.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TypeScrambler {
	internal interface ITestInterface {
		string GetText();
	}
}

```

`Tests/TypeScrambler/ImplicitInterface.cs`:

```cs
namespace TypeScrambler {
	internal class ImplicitInterface : ITestInterface {
		public string GetText() => "Text from implicit interface implementation.";
	}
}

```

`Tests/TypeScrambler/Program.cs`:

```cs
using System;
using System.Linq;

namespace TypeScrambler {
	public class Program {
		internal static int Main(string[] args) {
			Console.WriteLine("START");
			TestClass.WriteTextToConsole();
			Console.WriteLine(TestClass.GetTextStatic());

			var instance = new TestClass();
			Console.WriteLine(instance.GetText());

			Console.WriteLine(instance.GetTextFromGeneric("Text from generic method".AsEnumerable()));

			var genericInstance = new GenericClass<string>();
			Console.WriteLine(new String(genericInstance.GetReverse("ssalc cireneg morf txeT").ToArray()));

			Console.WriteLine(Properties.Resources.Test);

			var implInterface = new ImplicitInterface();
			Console.WriteLine(implInterface.GetText());
			Console.WriteLine(((ITestInterface)implInterface).GetText());

			var explInterface = new ExplicitInterface();
			Console.WriteLine(((ITestInterface)explInterface).GetText());

			Console.WriteLine(TestClass.GetTextStaticGeneric("Text from static generic method."));

			Console.WriteLine(FactoryPattern.Create("Test").Message);

			Console.WriteLine("END");
			return 42;
		}
	}
}

```

`Tests/TypeScrambler/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace TypeScrambler.Properties {
    using System;
    
    
    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    // -Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    // mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("TypeScrambler.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        ///   Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Sucht eine lokalisierte Zeichenfolge, die Text from Resources ähnelt.
        /// </summary>
        internal static string Test {
            get {
                return ResourceManager.GetString("Test", resourceCulture);
            }
        }
    }
}

```

`Tests/TypeScrambler/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Test" xml:space="preserve">
    <value>Text from Resources</value>
  </data>
</root>
```

`Tests/TypeScrambler/TestClass.cs`:

```cs
using System;

namespace TypeScrambler {
	internal class TestClass {
		public static void WriteTextToConsole() => Console.WriteLine("Text from WriteTextToConsole");

		public static string GetTextStatic() => "Static Text";

		public static string GetTextStaticGeneric<T>(T input) => input.ToString();

		public string GetText() => "Non-Static Text";

		public string GetTextFromGeneric<T>(T input) => input.ToString();
	}
}

```

`Tests/TypeScrambler/TypeScrambler.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <OutputType>Exe</OutputType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>

  <ItemGroup>
    <Compile Update="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

</Project>

```

`Tests/VisualBasicRenamingResx.Test/RenamingTest.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace VisualBasicRenamingResx.Test{
	public sealed class RenamingTest : TestBase {
		public RenamingTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/25")]
		public async Task ProtectAndExecuteTest() =>
			await Run("VisualBasicRenamingResx.exe",
				new[] {"Test (neutral)"},
				new SettingItem<Protection>("rename"));
	}
}

```

`Tests/VisualBasicRenamingResx.Test/VisualBasicRenamingResx.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\VisualBasicRenamingResx\VisualBasicRenamingResx.vbproj" />
  </ItemGroup>

</Project>

```

`Tests/VisualBasicRenamingResx/My Project/Resources.Designer.vb`:

```vb
'------------------------------------------------------------------------------
' <auto-generated>
'     Dieser Code wurde von einem Tool generiert.
'     Laufzeitversion:4.0.30319.42000
'
'     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
'     der Code erneut generiert wird.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict On
Option Explicit On

Imports System

Namespace My.Resources
    
    'Diese Klasse wurde von der StronglyTypedResourceBuilder automatisch generiert
    '-Klasse über ein Tool wie ResGen oder Visual Studio automatisch generiert.
    'Um einen Member hinzuzufügen oder zu entfernen, bearbeiten Sie die .ResX-Datei und führen dann ResGen
    'mit der /str-Option erneut aus, oder Sie erstellen Ihr VS-Projekt neu.
    '''<summary>
    '''  Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    '''</summary>
    <Global.System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0"),  _
     Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
     Global.Microsoft.VisualBasic.HideModuleNameAttribute()>  _
    Friend Module Resources
        
        Private resourceMan As Global.System.Resources.ResourceManager
        
        Private resourceCulture As Global.System.Globalization.CultureInfo
        
        '''<summary>
        '''  Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
        '''</summary>
        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
        Friend ReadOnly Property ResourceManager() As Global.System.Resources.ResourceManager
            Get
                If Object.ReferenceEquals(resourceMan, Nothing) Then
                    Dim temp As Global.System.Resources.ResourceManager = New Global.System.Resources.ResourceManager("VisualBasicRenamingResx.Resources", GetType(Resources).Assembly)
                    resourceMan = temp
                End If
                Return resourceMan
            End Get
        End Property
        
        '''<summary>
        '''  Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
        '''  Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
        '''</summary>
        <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
        Friend Property Culture() As Global.System.Globalization.CultureInfo
            Get
                Return resourceCulture
            End Get
            Set
                resourceCulture = value
            End Set
        End Property
        
        '''<summary>
        '''  Sucht eine lokalisierte Zeichenfolge, die Test (neutral) ähnelt.
        '''</summary>
        Friend ReadOnly Property TestString() As String
            Get
                Return ResourceManager.GetString("TestString", resourceCulture)
            End Get
        End Property
    End Module
End Namespace

```

`Tests/VisualBasicRenamingResx/My Project/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TestString" xml:space="preserve">
    <value>Test (neutral)</value>
  </data>
</root>
```

`Tests/VisualBasicRenamingResx/Program.vb`:

```vb
Public Class Program
	Friend Shared Function Main(args As String()) As Integer
		Console.WriteLine("START")
		Console.WriteLine(My.Resources.TestString)
		Console.WriteLine("END")
		Return 42
	End Function
End Class

```

`Tests/VisualBasicRenamingResx/VisualBasicRenamingResx.vbproj`:

```vbproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <OutputType>Exe</OutputType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>

  <ItemGroup>
    <Compile Update="My Project\Resources.Designer.vb">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Update="Properties\Resources.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="My Project\Resources.resx">
      <Generator>VbMyResourcesResXFileCodeGenerator</Generator>
      <CustomToolNamespace>My.Resources</CustomToolNamespace>
      <LastGenOutput>Resources.Designer.vb</LastGenOutput>
    </EmbeddedResource>
    <EmbeddedResource Update="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>

</Project>

```

`Tests/WinFormsRenaming.Test/RenameDataPropertyNameTest.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace WinFormsRenaming.Test {
	public class RenameDataPropertyNameTest : TestBase {
		public RenameDataPropertyNameTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Technology", "Windows Forms")]
		[Trait("Issue", "https://github.com/mkaring/ConfuserEx/issues/54")]
		public async Task RenameWindowsFormsTest() =>
			await Run(
				"WinFormsRenaming.dll",
				null,
				new SettingItem<Protection>("rename"),
				outputAction: message => Assert.DoesNotContain("Failed to extract binding property name in", message));
	}
}

```

`Tests/WinFormsRenaming.Test/WinFormsRenaming.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\WinFormsRenaming\WinFormsRenaming.csproj" />
  </ItemGroup>

</Project>

```

`Tests/WinFormsRenaming/DataBoundElement.cs`:

```cs
namespace WinFormsRenaming {
	internal class DataBoundElement {
		public string BoundProperty { get; set; }
	}
}

```

`Tests/WinFormsRenaming/DataGridViewForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace WinFormsRenaming {
	public class DataGridViewForm : Form {
		internal string TestProperty { get; set; }

		public DataGridViewForm() {
			var grid = new DataGridView();
			grid.Columns.Add(new DataGridViewTextBoxColumn() { DataPropertyName = nameof(DataBoundElement.BoundProperty) });
			grid.DataSource = new List<DataBoundElement>() { new DataBoundElement() { BoundProperty = "Test" } };

			grid.DataBindings.Add(new Binding(nameof(DataBoundElement.BoundProperty), grid.DataSource, nameof(TestProperty)));

			Controls.Add(grid);
		}
	}
}

```

`Tests/WinFormsRenaming/WinFormsRenaming.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">

  <PropertyGroup>
    <OutputType>Library</OutputType>
    <TargetFramework>net461</TargetFramework>
    <UseWindowsForms>true</UseWindowsForms>
  </PropertyGroup>

</Project>

```

`Tests/WpfRenaming.Test/ProcessWpfTest.cs`:

```cs
using System.Threading.Tasks;
using Confuser.Core;
using Confuser.Core.Project;
using Confuser.UnitTest;
using Xunit;
using Xunit.Abstractions;

namespace WpfRenaming.Test {
	public class ProcessWpfTest : TestBase {
		public ProcessWpfTest(ITestOutputHelper outputHelper) : base(outputHelper) { }

		/// <see cref="https://github.com/mkaring/ConfuserEx/issues/1"/>
		[Fact]
		[Trait("Category", "Analysis")]
		[Trait("Protection", "rename")]
		[Trait("Technology", "WPF")]
		public async Task ProcessWithoutObfuscationTest() =>
			await Run(
				"WpfRenaming.dll",
				null,
				NoProtections);

		[Fact]
		[Trait("Category", "Protection")]
		[Trait("Protection", "rename")]
		[Trait("Technology", "WPF")]
		public async Task ProcessWithObfuscationTest() =>
			await Run(
				"WpfRenaming.dll",
				null,
				new SettingItem<Protection>("rename"));
	}
}

```

`Tests/WpfRenaming.Test/WpfRenaming.Test.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net461</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\Confuser.UnitTest\Confuser.UnitTest.csproj" />
    <ProjectReference Include="..\WpfRenaming\WpfRenaming.csproj" />
  </ItemGroup>

</Project>

```

`Tests/WpfRenaming/TestData.xml`:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<root>
  <Node DisplayValuePath="TestProperty">
	<ChildNode>Test1</ChildNode>
	<ChildNode>Test2</ChildNode>
  </Node>
  <Node>Node2</Node>
</root>

```

`Tests/WpfRenaming/UserControl1.xaml`:

```xaml
<UserControl x:Class="WpfRenaming.UserControl1"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:local="clr-namespace:WpfRenaming"
             xmlns:sys="clr-namespace:System;assembly=mscorlib"
             mc:Ignorable="d" 
             d:DesignHeight="450" d:DesignWidth="800">
    <UserControl.DataContext>
        <local:UserControl1Context />
    </UserControl.DataContext>
    <UserControl.Resources>
        <XmlDataProvider x:Key="xmlData" Source="pack://siteoforigin:,,,/TestData.xml" XPath="/root" />
        <ControlTemplate x:Key="TestReferemce">
            <ControlTemplate.TargetType>
                <x:Type TypeName="local:UserControl1Context" />
            </ControlTemplate.TargetType>
        </ControlTemplate>
    </UserControl.Resources>
    <StackPanel>
        <TextBlock>[1234567</TextBlock>
        <TextBlock>,]</TextBlock>
        <Label Content="{Binding TestProperty}" />
        <Label Content="{Binding (local:UserControl1Context.TestProperty)}" />
        <Label Content="{Binding TestListProperty[0]}" />
        <Label Content="{Binding (local:UserControl1Context.TestListProperty)[0]}" />
        <Label Content="{Binding [(sys:Int32)0]}" />
        <Label Content="{Binding Item[1]}" />
        <Label Content="{Binding [Foo]}" />
        <Label Content="{Binding Item[Bar]}" />
        <TreeView ItemsSource="{Binding Source={StaticResource xmlData}, XPath=./*}" />
    </StackPanel>
</UserControl>

```

`Tests/WpfRenaming/UserControl1.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace WpfRenaming {
	/// <summary>
	/// Interaktionslogik für UserControl1.xaml
	/// </summary>
	public partial class UserControl1 : UserControl {
		public UserControl1() {
			InitializeComponent();
		}
	}
}

```

`Tests/WpfRenaming/UserControl1Context.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WpfRenaming {
	internal class UserControl1Context {
		public string TestProperty => "This is from a property!";

		public string[] TestListProperty => new string[] { "Index 1", "Index 2" };

		public string this[int index] {
			get => $"Integer Indxer: {index}";
		}

		public string this[long index] {
			get => $"Long Indexer: {index}";
		}

		public string this[string index] {
			get => $"String Indexer: {index}";
		}
	}
}

```

`Tests/WpfRenaming/WpfRenaming.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">

  <PropertyGroup>
    <OutputType>Library</OutputType>
    <TargetFramework>net461</TargetFramework>
    <UseWPF>true</UseWPF>
  </PropertyGroup>

  <ItemGroup>
    <Resource Include="TestData.xml" />
  </ItemGroup>

</Project>
```

`additional/ilspy.crproj`:

```crproj
<?xml version="1.0" encoding="utf-8"?>
<project baseDir="." outputDir="Confused" xmlns="http://confuser.codeplex.com">
    <rule preset="none" pattern="true">
        <protection id="anti debug" />
        <protection id="anti dump" />
        <protection id="anti ildasm" />
        <protection id="anti tamper" />
        <protection id="constants" />
        <protection id="ctrl flow" />
        <protection id="invalid metadata" />
        <protection id="ref proxy" />
        <protection id="rename" />
        <protection id="resources" />
    </rule>
    <module path="ICSharpCode.AvalonEdit.dll" />
    <module path="ICSharpCode.Decompiler.dll" />
    <module path="ICSharpCode.NRefactory.dll" />
    <module path="ICSharpCode.NRefactory.CSharp.dll" />
    <module path="ICSharpCode.NRefactory.VB.dll" />
    <module path="ICSharpCode.TreeView.dll" />
    <module path="ILSpy.BamlDecompiler.Plugin.dll" />
    <module path="ILSpy.exe" />
    <module path="ILSpy.SharpDevelop.LGPL.dll" />
    <module path="Mono.Cecil.dll" />
    <module path="Mono.Cecil.Pdb.dll" />
</project>
```

`additional/pdn.crproj`:

```crproj
<?xml version="1.0" encoding="utf-8"?>
<project baseDir="." outputDir="Confused" xmlns="http://confuser.codeplex.com">
    <rule preset="none" pattern="true">
        <protection id="anti debug" />
        <protection id="anti dump" />
        <protection id="anti ildasm" />
        <protection id="anti tamper" />
        <protection id="constants" />
        <protection id="ctrl flow" />
        <protection id="invalid metadata" />
        <protection id="ref proxy" />
        <protection id="rename" />
        <protection id="resources" />
    </rule>
    <rule preset="none" pattern="namespace('PaintDotNet.Menus') and match-name('Menu(|Item|Base)$')">
        <protection id="rename" action="remove" />
    </rule>
    <rule preset="none" pattern="namespace('PaintDotNet.Menus') and match-type-name('Menu$') and match-name('^menu')">
        <protection id="rename" action="remove" />
    </rule>
    <rule preset="none" pattern="namespace('PaintDotNet.Tools') and match-name('Tool(|Base)$')">
        <protection id="rename" action="remove" />
    </rule>
    <rule preset="none" pattern="namespace('PaintDotNet.IndirectUI') and match-type-name('PropertyControl') and (member-type('method') or member-type('property'))">
        <protection id="rename" action="remove" />
    </rule>
    <module path="PaintDotNet.exe" />
    <module path="PaintDotNet.Base.dll" />
    <module path="PaintDotNet.Core.dll" />
    <module path="PaintDotNet.Data.dll" />
    <module path="PaintDotNet.Effects.dll" />
    <module path="PaintDotNet.Resources.dll" />
    <module path="PaintDotNet.SystemLayer.dll" />
</project>
```

`appveyor.yml`:

```yml
version: '{build}'
image: Visual Studio 2022
configuration: Release
platform: Any CPU
skip_commits:
  files:
  - .github/*
  - doc/*
  - readme.md
  - license.md

environment:
  CHOCO_API_KEY:
    secure: oSM1kJpS3CZN3XVnDWMEGfivr5hW3NR6KRsCjqAimtrv9zvbPObZLgsJ3ZthmkQs

nuget:
  disable_publish_on_pr: true

install:
- cmd: git submodule update --init --recursive

before_build:
- cmd: msbuild Confuser2.sln /t:Restore /logger:"C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"

build:
  project: Confuser2.sln
  verbosity: minimal

after_build:
- pwsh: >-
    Push-Location Confuser.CLI\bin\$env:CONFIGURATION\net461;
    . 7z a ..\..\..\..\ConfuserEx-CLI.zip "-xr!*.pdb" "-xr!*.xml";
    Pop-Location
- pwsh: >-
    Push-Location ConfuserEx\bin\$env:CONFIGURATION\net461;
    . 7z a ..\..\..\..\ConfuserEx-GUI.zip "-xr!*.pdb" "-xr!*.xml";
    Pop-Location
- pwsh: >-
    Push-Location Confuser.CLI\bin\$env:CONFIGURATION\net461;
    . 7z a ..\..\..\..\ConfuserEx.zip "-xr!*.pdb" "-xr!*.xml";
    Pop-Location;
    Push-Location ConfuserEx\bin\$env:CONFIGURATION\net461;
    . 7z a ..\..\..\..\ConfuserEx.zip "-xr!*.pdb" "-xr!*.xml" -y;
    Pop-Location

artifacts:
- path: ConfuserEx*.zip
- path: Confuser.MSBuild.Tasks/bin/Release/*.nupkg
  name: ConfuserEx.MSBuild

for:
-
  branches:
    except:
      - master

  build:
    publish_nuget: false

deploy:
- provider: GitHub
  tag: $(APPVEYOR_REPO_TAG_NAME)
  description: "ConfuserEx $(APPVEYOR_REPO_TAG_NAME) Release"
  auth_token:
    secure: k2MIY7tKQEsg6+w3QIxMx6ptoBccUgOadKA1I8O9myFZS4SBdEINCbjGwALZrhdm
  on:
    APPVEYOR_REPO_TAG: true
- provider: NuGet
  api_key:
    secure: KSGvC66WIcadFq9WgN+SQVRAkYFojRmqmmiDlJP4CqmpZOGcOgT0tgg1MkWw6glg
  on:
    APPVEYOR_REPO_TAG: true
- provider: NuGet
  server: https://nuget.pkg.github.com/mkaring/index.json
  api_key:
    secure: k2MIY7tKQEsg6+w3QIxMx6ptoBccUgOadKA1I8O9myFZS4SBdEINCbjGwALZrhdm
  username:
    secure: NGDRiYcrJaLN2PkRszWIVg==
  on:
    APPVEYOR_REPO_TAG: true
after_deploy:
- pwsh: >-
    if ($env:APPVEYOR_REPO_TAG -eq $true) {
        Copy-Item -Path ConfuserEx.zip -Destination .\chocolatey-packages\confuserex\tools
        Copy-Item -Path ConfuserEx-CLI.zip -Destination .\chocolatey-packages\confuserex.portable\tools
        .\chocolatey-packages\New-ChocolateyPackage.ps1 -PackageVersion $env:APPVEYOR_REPO_TAG_NAME
        choco apikey --key $env:CHOCO_API_KEY --source https://push.chocolatey.org/
        Get-ChildItem -Path .\chocolatey-packages -Filter *.nupkg | ForEach-Object {
            choco push $_.FullName --source https://push.chocolatey.org/
        }
    }

```

`chocolatey-packages/New-ChocolateyPackage.ps1`:

```ps1
[CmdletBinding()]
param (
	[Parameter(Mandatory=$true)]
	[string]
	$PackageVersion
)

if ($PackageVersion.StartsWith('v')) {
	$PackageVersion = $PackageVersion.Substring(1)
}

Push-Location $PSScriptRoot
try {
	Get-ChildItem .\ -Directory | ForEach-Object {
		Get-ChildItem $_.FullName -Filter *.nuspec | Remove-Item -Force -ErrorAction SilentlyContinue

		$packageHash = Get-ChildItem $_.FullName -Filter tools\*.zip |
			Select-Object -First 1 |
			Get-FileHash -Algorithm SHA256

		$replaceDict = @{
			'{{PACKAGEVERSION}}' = $PackageVersion;
			'{{CHECKSUMTYPE}}' = $packageHash.Algorithm;
			'{{CHECKSUM}}' = $packageHash.Hash
		}

		Get-ChildItem $_.FullName -Filter *.template -Recurse |
			ForEach-Object {
				Get-Content -Path $_.FullName |
					ForEach-Object {
						$line = $_
						$replaceDict.GetEnumerator() | ForEach-Object {
							$line = $line -replace $_.Key, $_.Value
						}
						$line
					} |
					Out-File (Join-Path $_.Directory $_.BaseName)
			}
	}

	Get-ChildItem *.nuspec -Recurse -Depth 1 | ForEach-Object { . choco pack $_.FullName }
} finally {
	Pop-Location
}

```

`chocolatey-packages/confuserex.portable/confuserex.portable.nuspec.template`:

```template
<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd">
  <metadata>
    <id>confuserex.portable</id>
    <version>{{PACKAGEVERSION}}</version>
    <owners>mkaring</owners>
    <title>ConfuserEx (CLI)</title>
    <authors>Martin Karing</authors>
    <projectUrl>https://mkaring.github.io/ConfuserEx/</projectUrl>
    <iconUrl>https://mkaring.github.io/ConfuserEx/assets/ConfuserEx.png</iconUrl>
    <licenseUrl>https://github.com/mkaring/ConfuserEx/blob/v{{PACKAGEVERSION}}/LICENSE.md</licenseUrl>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <projectSourceUrl>https://github.com/mkaring/ConfuserEx/tree/v{{PACKAGEVERSION}}</projectSourceUrl>
    <packageSourceUrl>https://github.com/mkaring/ConfuserEx/tree/v{{PACKAGEVERSION}}/chocolatey-packages/confuserex.portable</packageSourceUrl>
    <docsUrl>https://github.com/mkaring/ConfuserEx/wiki</docsUrl>
    <bugTrackerUrl>https://github.com/mkaring/ConfuserEx/issues</bugTrackerUrl>
    <tags>confuserex cil confuser dnlib dotnet il msil net .net obfuscator packer protector</tags>
    <summary>ConfuserEx is a open-source protector for .NET applications.</summary>
    <description><![CDATA[ConfuserEx is a open-source protector for .NET applications.
It is the successor of [Confuser](http://confuser.codeplex.com) project.

# Features

* Supports .NET Framework 2.0/3.0/3.5/4.0/4.5/4.6/4.7
* Symbol renaming (Support WPF/BAML)
* Protection against debuggers/profilers
* Protection against memory dumping
* Protection against tampering (method encryption)
* Control flow obfuscation
* Constant/resources encryption
* Reference hiding proxies
* Disable decompilers
* Embedding dependency
* Compressing output
* Extensible plugin API
* Many more are coming!

# Commandline package

This package of ConfuserEx only contains the command line tools.
If you require the user interface as well, please use the [ConfuserEx](https://chocolatey.org/packages/confuserex) package.

# Usage

```Batchfile
Confuser.CLI.exe <path to project file>
```

The project file is a ConfuserEx Project (*.crproj).
The format of project file can be found in [docs\ProjectFormat.md](https://github.com/mkaring/ConfuserEx/blob/v{{PACKAGEVERSION}}/docs/ProjectFormat.md)]]></description>
    <releaseNotes>[View on GitHub](https://github.com/mkaring/ConfuserEx/releases/tag/v{{PACKAGEVERSION}})</releaseNotes>
    <dependencies>
      <dependency id="dotnetfx" version="4.6.1.0" />
    </dependencies>
  </metadata>
  <files>
    <file src="tools\**" target="tools" />
    <file src="legal\LICENSE.md" target="legal" />
    <file src="legal\VERIFICATION.txt" target="legal" />
  </files>
</package>

```

`chocolatey-packages/confuserex.portable/legal/LICENSE.md`:

```md
Copyright (c) 2014 
```

`chocolatey-packages/confuserex.portable/legal/VERIFICATION.txt.template`:

```template
VERIFICATION
Verification is intended to assist the Chocolatey moderators and community
in verifying that this package's contents are trustworthy.

The archives containing the application can be downloaded from the Github releases
page of the project and can be verified like this:

1. Download the following installers:
  Zip: https://github.com/mkaring/ConfuserEx/releases/download/v{{PACKAGEVERSION}}/ConfuserEx-CLI.zip

2. You can use one of the following methods to obtain the checksum
  - Use powershell function 'Get-Filehash'
  - Use chocolatey utility 'checksum.exe'

  checksum type: {{CHECKSUMTYPE}}
  checksum     : {{CHECKSUM}}

File 'LICENSE.md' is obtained from <https://github.com/mkaring/ConfuserEx/blob/v{{PACKAGEVERSION}}/LICENSE.md>

```

`chocolatey-packages/confuserex.portable/tools/chocolateyInstall.ps1`:

```ps1
$ErrorActionPreference = 'Stop'

$toolsDir = $(Split-Path -parent $MyInvocation.MyCommand.Definition)

$filePath = Join-Path $toolsDir "ConfuserEx-CLI.zip"

$packageArgs = @{
  packageName = 'confuserex.commandline'
  destination = "$toolsDir"
  file        = $filePath
}
Get-ChocolateyUnzip @packageArgs
Remove-Item $filePath

```

`chocolatey-packages/confuserex/confuserex.nuspec.template`:

```template
<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd">
  <metadata>
    <id>confuserex</id>
    <version>{{PACKAGEVERSION}}</version>
    <owners>mkaring</owners>
    <title>ConfuserEx</title>
    <authors>Martin Karing</authors>
    <projectUrl>https://mkaring.github.io/ConfuserEx/</projectUrl>
    <iconUrl>https://mkaring.github.io/ConfuserEx/assets/ConfuserEx.png</iconUrl>
    <licenseUrl>https://github.com/mkaring/ConfuserEx/blob/v{{PACKAGEVERSION}}/LICENSE.md</licenseUrl>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <projectSourceUrl>https://github.com/mkaring/ConfuserEx/tree/v{{PACKAGEVERSION}}</projectSourceUrl>
    <packageSourceUrl>https://github.com/mkaring/ConfuserEx/tree/v{{PACKAGEVERSION}}/chocolatey-packages/confuserex</packageSourceUrl>
    <docsUrl>https://github.com/mkaring/ConfuserEx/wiki</docsUrl>
    <bugTrackerUrl>https://github.com/mkaring/ConfuserEx/issues</bugTrackerUrl>
    <tags>confuserex cil confuser dnlib dotnet il msil net .net obfuscator packer protector</tags>
    <summary>ConfuserEx is a open-source protector for .NET applications.</summary>
    <description><![CDATA[ConfuserEx is a open-source protector for .NET applications.
It is the successor of [Confuser](http://confuser.codeplex.com) project.

# Features

* Supports .NET Framework 2.0/3.0/3.5/4.0/4.5/4.6/4.7
* Symbol renaming (Support WPF/BAML)
* Protection against debuggers/profilers
* Protection against memory dumping
* Protection against tampering (method encryption)
* Control flow obfuscation
* Constant/resources encryption
* Reference hiding proxies
* Disable decompilers
* Embedding dependency
* Compressing output
* Extensible plugin API
* Many more are coming!

# Usage

```Batchfile
Confuser.CLI.exe <path to project file>
```

The project file is a ConfuserEx Project (*.crproj).
The format of project file can be found in [docs\ProjectFormat.md](https://github.com/mkaring/ConfuserEx/blob/v{{PACKAGEVERSION}}/docs/ProjectFormat.md)]]></description>
    <releaseNotes>[View on GitHub](https://github.com/mkaring/ConfuserEx/releases/tag/v{{PACKAGEVERSION}})</releaseNotes>
    <dependencies>
      <dependency id="dotnetfx" version="4.6.1.0" />
    </dependencies>
  </metadata>
  <files>
    <file src="tools\**" target="tools" />
    <file src="legal\LICENSE.md" target="legal" />
    <file src="legal\VERIFICATION.txt" target="legal" />
  </files>
</package>

```

`chocolatey-packages/confuserex/legal/LICENSE.md`:

```md
Copyright (c) 2014 
```

`chocolatey-packages/confuserex/legal/VERIFICATION.txt.template`:

```template
VERIFICATION
Verification is intended to assist the Chocolatey moderators and community
in verifying that this package's contents are trustworthy.

The archives containing the application can be downloaded from the Github releases
page of the project and can be verified like this:

1. Download the following installers:
  Zip: https://github.com/mkaring/ConfuserEx/releases/download/v{{PACKAGEVERSION}}/ConfuserEx.zip

2. You can use one of the following methods to obtain the checksum
  - Use powershell function 'Get-Filehash'
  - Use chocolatey utility 'checksum.exe'

  checksum type: {{CHECKSUMTYPE}}
  checksum     : {{CHECKSUM}}

File 'LICENSE.md' is obtained from <https://github.com/mkaring/ConfuserEx/blob/v{{PACKAGEVERSION}}/LICENSE.md>

```

`chocolatey-packages/confuserex/tools/chocolateyInstall.ps1`:

```ps1
$ErrorActionPreference = 'Stop'

$toolsDir = $(Split-Path -parent $MyInvocation.MyCommand.Definition)

$filePath = Join-Path $toolsDir "ConfuserEx.zip"

$packageArgs = @{
  packageName = 'confuserex'
  destination = "$toolsDir"
  file        = "$filePath"
}
Get-ChocolateyUnzip @packageArgs
Remove-Item $filePath

New-Item "$($packageArgs.destination)\ConfuserEx.exe.gui" -Type file -Force | Out-Null

```

`docs/DeclarativeObfuscation.txt`:

```txt
ConfuserEx declarative obfuscation:

Attribute semantics:
ApplyToMembers: The children uses this protection settings as base.
Exclude: No protection will be applied to this item.
!ApplyToMembers + !Exclude: The protection settings just apply to this item.
ApplyToMembers + Exclude: This item and its chilren will have no protection.	

Pattern examples:

generate debug symbol:true
random seed:ABCDEFG
strong name key:C:\key.snk
strong name key password:hunter2
packer:compressor(mode=dynamic)
namespace 'ConfuserEx.CLI':preset(normal);+rename;anti tamper(mode=jit,key=dynamic);-anti debug
preset(none);+rename;

Usage examples:

[assembly: Obfuscation(Exclude = false, Feature = "preset(minimum);+ctrl flow;-anti debug;+rename(mode=letters,flatten=false);")]
[assembly: Obfuscation(Exclude = false, Feature = "random seed: Hello!")]
[assembly: Obfuscation(Exclude = false, Feature = "namespace 'Test':-rename")]
namespace Test {
	[Obfuscation(Exclude = false, Feature = "constants")]
	class Program {
		public static void Main() {
			Console.WriteLine("Hi");
		}
	}
}
```

`docs/ProjectFormat.md`:

```md
ConfuserEx Project Format
=======================

ConfuserEx projects (*.crproj) is an XML formatted document describing the ConfuserEx project.

For details of the format, please refer to the XML schema at `Confuser.Core\Project\ConfuserPrj.xsd`.

Element `project`
-----------------

Element `project` is the root element of the project document.

**Attributes:**

`outputDir`:  
The directory which ConfuserEx stores the output files.

`baseDir`:  
The base directory of all relative path used in the project document.
If this attribute value is also a relative path, the result depends on the implementation.
In the offical implementation (Confuser.CLI), it would be based on the location of project file.
 
`seed`:  
The seed of the random generator in protection process.

`debug`:  
Indicates whether the debug symbols (*.pdb) are generated.
Currently unused.

**Elements:**

`rule`:  
The global protection rules applied to all modules.
Optional.

`packer`:  
The packer setting.
Optional.
Currently unused.

`module`:  
The settings of individual modules.

`probePath`:  
The directories in which ConfuserEx searches for dependencies.


Element `module`
----------------

Element `module` describes the settings of individual modules.

**Attributes:**

`path`:  
The path of the module.

`snKey`:  
The path to the Strong Name Key used to sign the module.
Optional.

`snKeyPass`:  
The password of the SNK if a PFX container is used in `snKey`.
Optional.

**Elements:**

`rule`:  
The protection rules applied to the module.


Element `rule`
--------------

Element `rule` describes a rule that determine how the protections are applied.

**Attributes:**

`inherit`:  
Indicates whether this rule inherits the settings from the previous rules.
Default to `true`.

`pattern`:  
The pattern expression used to match the target components of this rule.

`preset`:  
The protection preset of the rule.
Possible values are `none`, `minimum`, `normal`, `aggressive` and `maximum`.
Default to `none`.

**Elements:**

`protection`:  
The protection settings.

Element `protection` and `packer`
---------------------------------

Element `protection` and `packer` describe the settings of individual protection/packer.

**Attributes:**

`action`:  
Indicates whether the protection are to be added or removed from settings.
Possible values are `add` and `remove`.
Default to `add`.

`id`:  
The identifier of the protection/packer.

**Elements:**

`argument`:  
The arguments that passed to the protection.
Optional.

Element `argument`
------------------

An argument that is passed to a protection.

**Attributes:**

`name`:
The name of the argument.

`value`:
The value of the argument.

Applying rules
--------------
The rules are applied from global rules (in `project` element) to local rules (in `module` element), from begin to end.
ConfuserEx will keep a list of protections for every items, and applies the rules in order.

For each rules, ConfuserEx will do:

1. If the item does not match with the rule's pattern, skip the rule.
2. If the rule does not inherit previous settings (i.e. no `inherit`), clear the marking on the item.
3. Mark the items with the protections contained in the specified `preset` value of the rule.
4. For each protection settings in the rule:
5. If `action` is remove, remove the protection from the marking.
6. If `action` is add, add the protection settings to marking.

The pattern is a simple function-based expression that evaluated for every items. If it is evaluated to `true`, the item is matched with the pattern.

Here are some example expressions:
`true`: Matches all items.
`name('X')`: Matches all items that has name 'X'.
`member-type('type') and full-name('NS.Type')`: Matches types that have full name 'NS.Type'.

Examples
----------------
ConfuserEx projects that work for ILSpy and PaintDotNet can be found under `additional` directory as examples.

```

`docs/docs.shfbproj`:

```shfbproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <PropertyGroup>
    <!-- The configuration and platform will be used to determine which assemblies to include from solution and
				 project documentation sources -->
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{e8d8557e-206d-4f31-97b0-2caa1a598169}</ProjectGuid>
    <SHFBSchemaVersion>1.9.9.0</SHFBSchemaVersion>
    <!-- AssemblyName, Name, and RootNamespace are not used by SHFB but Visual Studio adds them anyway -->
    <AssemblyName>Documentation</AssemblyName>
    <RootNamespace>Documentation</RootNamespace>
    <Name>Documentation</Name>
    <!-- SHFB properties -->
    <FrameworkVersion>.NET Framework 3.5</FrameworkVersion>
    <OutputPath>docs\</OutputPath>
    <HtmlHelpName>Confuser</HtmlHelpName>
    <Language>en-US</Language>
    <DocumentationSources>
      <DocumentationSource sourceFile="Confuser.Core\Confuser.Core.csproj" />
      <DocumentationSource sourceFile="Confuser.CLI\Confuser.CLI.csproj" />
      <DocumentationSource sourceFile="Confuser.Protections\Confuser.Protections.csproj" />
      <DocumentationSource sourceFile="Confuser.Renamer\Confuser.Renamer.csproj" />
    </DocumentationSources>
    <MaximumGroupParts>2</MaximumGroupParts>
    <NamespaceGrouping>False</NamespaceGrouping>
    <SyntaxFilters>C#</SyntaxFilters>
    <SdkLinkTarget>Blank</SdkLinkTarget>
    <RootNamespaceContainer>False</RootNamespaceContainer>
    <PresentationStyle>VS2010</PresentationStyle>
    <Preliminary>False</Preliminary>
    <NamingMethod>MemberName</NamingMethod>
    <HelpTitle>Confuser</HelpTitle>
    <ContentPlacement>AboveNamespaces</ContentPlacement>
    <BuildAssemblerVerbosity>OnlyWarningsAndErrors</BuildAssemblerVerbosity>
    <HelpFileFormat>HtmlHelp1, Website</HelpFileFormat>
    <IndentHtml>False</IndentHtml>
    <KeepLogFile>True</KeepLogFile>
    <DisableCodeBlockComponent>False</DisableCodeBlockComponent>
    <CppCommentsFixup>False</CppCommentsFixup>
    <CleanIntermediates>True</CleanIntermediates>
    <WebsiteSdkLinkType>None</WebsiteSdkLinkType>
    <HtmlSdkLinkType>None</HtmlSdkLinkType>
    <IncludeFavorites>False</IncludeFavorites>
    <BinaryTOC>True</BinaryTOC>
    <ComponentConfigurations>
      <ComponentConfig id="IntelliSense Component" enabled="True">
        <component id="IntelliSense Component">
          <!-- Output options (optional)
  Attributes:
    Include namespaces (false by default)
    Namespaces comments filename ("Namespaces" if not specified or empty)
    Output folder (current folder if not specified or empty) -->
          <output includeNamespaces="false" namespacesFile="Namespaces" folder="{@OutputFolder}" />
        </component>
      </ComponentConfig>
    </ComponentConfigurations>
  </PropertyGroup>
  <!-- There are no properties for these groups.  AnyCPU needs to appear in order for Visual Studio to perform
			 the build.  The others are optional common platform types that may appear. -->
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x64' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x64' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|Win32' ">
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|Win32' ">
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="Confuser.Core\Confuser.Core.csproj">
      <Name>Confuser.Core</Name>
      <Project>{BEB67A6E-4C54-4DE5-8C6B-2C12F44A7B92}</Project>
    </ProjectReference>
    <ProjectReference Include="dnlib\src\dnlib.csproj">
      <Name>dnlib</Name>
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
    </ProjectReference>
  </ItemGroup>
  <!-- Import the SHFB build targets -->
  <Import Project="$(SHFBROOT)\SandcastleHelpFileBuilder.targets" />
</Project>
```

`version.json`:

```json
{
  "$schema": "https://raw.githubusercontent.com/dotnet/Nerdbank.GitVersioning/master/src/NerdBank.GitVersioning/version.schema.json",
  "version": "1.7.0-alpha.{height}",
  "semVer1NumericIdentifierPadding": 4,
  "publicReleaseRefSpec": [
    "^refs/tags/v\\d+\\.\\d+"
  ]
}
```