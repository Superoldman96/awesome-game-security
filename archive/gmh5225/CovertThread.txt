Project Path: arc_gmh5225_CovertThread_zlh0s_vy

Source Tree:

```txt
arc_gmh5225_CovertThread_zlh0s_vy
├── CovertThread.sln
├── CovertThread.vcxproj
├── CovertThread.vcxproj.filters
├── Files
│   ├── Array.cpp
│   ├── Array.h
│   ├── CIA32.h
│   ├── CPE.h
│   ├── CTypes.h
│   ├── CovertThread.cpp
│   ├── Handlers.cpp
│   ├── Handlers.h
│   ├── HandlersASM.asm
│   ├── Memory.cpp
│   ├── Memory.h
│   ├── PageSpace.cpp
│   ├── PageSpace.h
│   ├── PageSpaceASM.asm
│   ├── ROPGadgets.cpp
│   ├── ROPGadgets.h
│   ├── Utils.cpp
│   └── Utils.h
└── README.md

```

`CovertThread.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.33214.272
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CovertThread", "CovertThread.vcxproj", "{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|ARM.ActiveCfg = Debug|ARM
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|ARM.Build.0 = Debug|ARM
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|ARM.Deploy.0 = Debug|ARM
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|ARM64.Build.0 = Debug|ARM64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|x64.ActiveCfg = Debug|x64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|x64.Build.0 = Debug|x64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|x64.Deploy.0 = Debug|x64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|x86.ActiveCfg = Debug|Win32
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|x86.Build.0 = Debug|Win32
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Debug|x86.Deploy.0 = Debug|Win32
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|ARM.ActiveCfg = Release|ARM
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|ARM.Build.0 = Release|ARM
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|ARM.Deploy.0 = Release|ARM
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|ARM64.ActiveCfg = Release|ARM64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|ARM64.Build.0 = Release|ARM64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|ARM64.Deploy.0 = Release|ARM64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|x64.ActiveCfg = Release|x64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|x64.Build.0 = Release|x64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|x64.Deploy.0 = Release|x64
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|x86.ActiveCfg = Release|Win32
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|x86.Build.0 = Release|Win32
		{A71E7DA1-4E0A-4775-8BCD-706638ABB36A}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B9E5B095-0F9D-4DE1-A27C-52AEF948674B}
	EndGlobalSection
EndGlobal

```

`CovertThread.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{a71e7da1-4e0a-4775-8bcd-706638abb36a}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>CovertThread</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <CharacterSet>Unicode</CharacterSet>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath)</LibraryPath>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <IncludePath>C:\source\common\include\kernel;C:\source\common\include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\source\common\lib;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <SDLCheck>false</SDLCheck>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <ConformanceMode>false</ConformanceMode>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <DebugInformationFormat>None</DebugInformationFormat>
      <AdditionalOptions>/Zc:noexceptTypes- /kernel %(ClCompile.AdditionalOptions)</AdditionalOptions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DisableSpecificWarnings>4603;4627;4986;4987;26812;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>driver_entry</EntryPointSymbol>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <Profile>false</Profile>
      <AdditionalOptions>/IGNORE:4099 /nocoffgrpinfo /EMITPOGOPHASEINFO /IGNORE:4254 /LTCG /kernel /MERGE:.rdata=.data /MERGE:.pdata=.data %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <SDLCheck>false</SDLCheck>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <ConformanceMode>false</ConformanceMode>
      <DisableSpecificWarnings>4748;4603;4627;4986;4987;26812;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <AdditionalOptions>/Zc:noexceptTypes- /kernel %(ClCompile.AdditionalOptions) %(AdditionalOptions)</AdditionalOptions>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <AdditionalOptions>/IGNORE:4099 /IGNORE:4254 /kernel /MERGE:.rdata=.data /MERGE:.pdata=.data %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Files\Array.cpp" />
    <ClCompile Include="files\CovertThread.cpp" />
    <ClCompile Include="Files\Handlers.cpp" />
    <ClCompile Include="Files\Memory.cpp" />
    <ClCompile Include="Files\PageSpace.cpp" />
    <ClCompile Include="Files\ROPGadgets.cpp" />
    <ClCompile Include="Files\Utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Files\Array.h" />
    <ClInclude Include="Files\CIA32.h" />
    <ClInclude Include="Files\CPE.h" />
    <ClInclude Include="Files\CTypes.h" />
    <ClInclude Include="Files\Handlers.h" />
    <ClInclude Include="Files\Memory.h" />
    <ClInclude Include="Files\PageSpace.h" />
    <ClInclude Include="Files\ROPGadgets.h" />
    <ClInclude Include="Files\Utils.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Files\HandlersASM.asm" />
    <MASM Include="Files\PageSpaceASM.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`CovertThread.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{a0949259-ad30-4ea9-9e3c-3d54e7ae987c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{ae917a1d-9a79-4b3a-948b-e43b07fa681b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="files\CovertThread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Files\Memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Files\Handlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Files\PageSpace.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Files\ROPGadgets.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Files\Utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Files\Array.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Files\CIA32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\CTypes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\CPE.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\Handlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\PageSpace.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\ROPGadgets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Files\Array.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Files\HandlersASM.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="Files\PageSpaceASM.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Files/Array.cpp`:

```cpp
#include <ntddk.h>

#include "Array.h"
#include "Memory.h"

bool Array::Expand()
{
	if (!buffer)
		return false;

	capacity *= 2;

	void* newBuffer = AllocatePool(capacity * typeSize, POOL_FLAG_NON_PAGED);
	if (!newBuffer)
		return false;

	memcpy(newBuffer, buffer, size * typeSize);
	ExFreePool(buffer);
	buffer = newBuffer;
	return true;
}

Array::Array(uint64 typeSize)
{
	size = 0;
	capacity = 10;
	this->typeSize = typeSize;

	buffer = AllocatePool(capacity * typeSize, POOL_FLAG_NON_PAGED);
}

Array::Array(uint64 initialCapacity, uint64 typeSize)
{
	size = 0;
	capacity = initialCapacity;
	this->typeSize = typeSize;

	buffer = AllocatePool(capacity * typeSize, POOL_FLAG_NON_PAGED);
}

Array::~Array()
{
	if (buffer)
		ExFreePool(buffer);
}

void Array::Push(const void* value)
{
	if (size == capacity)
		if (!Expand())
			return;

	memcpy(reinterpret_cast<uint8*>(buffer) + typeSize * size++, &value, typeSize);
}

void* Array::Get(uint64 idx)
{
	return reinterpret_cast<uint8*>(buffer) + typeSize * idx;
}
```

`Files/Array.h`:

```h
#pragma once
#include "CTypes.h"

/*
	Note: You can use templates instead of doing it this way. 
	I just wanted to do it without them.
*/

class Array
{
public:
	void* buffer;
	uint64 typeSize;
	uint64 capacity;
	uint64 size;

	/*
		Expands the size of the array.

		@return True if the expansion succeeded, false otherwise
	*/
	bool Expand();

	/*
		Create an Array with default capacity.

		@param typeSize - The size of the type to store in the array
	*/
	Array(uint64 typeSize);

	/*
		Create an Array with an initial capacity.

		@param initialCapacity - The initial capacity of the array
		@param typeSize - The size of the type to store in the array
	*/
	Array(uint64 initialCapacity, uint64 typeSize);

	/*
		Free an Array
	*/
	~Array();

	/*
		Inserts a value into the end of the array.

		@param value - The value to insert
	*/
	void Push(const void* value);

	/*
		Gets a value at the specified index.

		@param idx - The index of the value

		@return The address of the value at the specified index
	*/
	void* Get(uint64 idx);

#define ARRAY_GET(type, arr, idx) *reinterpret_cast<type*>(arr->Get(idx))
};
```

`Files/CIA32.h`:

```h
#pragma once
#include <xmmintrin.h>

#include "CTypes.h"

#define BIT_FLAG(index) (1llu << index)

#define PAGE_4K 0x1000
#define PAGE_SIZE 0x1000
#define PAGE_2MB PAGE_4K * PageTableEntries
#define PAGE_1GB PAGE_4K * PageTableEntries * PageTableEntries

#define PAGE_MASK (~(PAGE_SIZE - 1))
#define PAGE_2MB_MASK (~(PAGE_2MB - 1))
#define PAGE_4K_ALIGN(address) (void*)((uint64)address & PAGE_MASK)
#define PAGE_2MB_ALIGN(address) (void*)((uint64)address & PAGE_2MB_MASK)
#define PAGE_ROUND(address) (void*)((uint64)(PAGE_4K_ALIGN((uint64)address - 1)) + PAGE_SIZE)

#define KERNEL_CANONICAL (0xFFFFULL << 48)

#define MSR_LSTAR 0xC0000082UL

#if defined(_MSC_EXTENSIONS)
#pragma warning(push)
#pragma warning(disable: 4201)
#endif

/*
	General Purpose Registers
*/

union RFlags
{
	uint64 all;

	struct
	{
		uint64 cf : 1;
		uint64 reserved1 : 1; /* Always 1 */
		uint64 pf : 1;
		uint64 reserved2 : 1; /* Always 0 */
		uint64 af : 1;
		uint64 reserved3 : 1; /* Always 0 */
		uint64 zf : 1;
		uint64 sf : 1;
		uint64 tf : 1;
		uint64 intf : 1;
		uint64 df : 1;
		uint64 of : 1;
		uint64 iopl : 2;
		uint64 nt : 1;
		uint64 reserved4 : 1; /* Always 0 */
		uint64 rf : 1;
		uint64 vm : 1;
		uint64 ac : 1;
		uint64 vif : 1;
		uint64 vip : 1;
		uint64 id : 1;
		uint64 reserved5 : 42; /* Always 0 */
	};
};

/*
	Interrupts
*/

#define IDT_TYPE_INTERRUPT_GATE 0xE
#define IDT_TYPE_TRAP_GATE 0xF

#define INTERRUPT_VECTOR_DE 0
#define INTERRUPT_VECTOR_DB 1
#define INTERRUPT_VECTOR_NMI 2
#define INTERRUPT_VECTOR_BP 3
#define INTERRUPT_VECTOR_GP 13
#define INTERRUPT_VECTOR_PF 14

#include <pshpack1.h>
struct IDTR
{
	uint16 limit;
	uint64 base;
};
#include <poppack.h>

union IDTEntry
{
	uint64 all[2];

	struct
	{
		uint64 baseLow : 16;
		uint64 segmentSelector : 16;
		uint64 ist : 3;
		uint64 reserved1 : 5;
		uint64 type : 4;
		uint64 reserved2 : 1;
		uint64 dpl : 2;
		uint64 p : 1;
		uint64 baseMiddle : 16;
		uint64 baseHigh : 32;
		uint64 reserved3 : 32;
	};
};

inline constexpr int IDTEntries = 256;

struct InterruptFrame
{
	uint64 rip;
	uint64 cs;
	uint64 rflags;
	uint64 rsp;
	uint64 ss;
};

struct InterruptFrameErrorCode
{
	uint64 errorCode;
	InterruptFrame frame;
};

/*
	Segmentation
*/

#define CODE_DATA_TYPE_WRITE BIT_FLAG(1)

#define CODE_DATA_TYPE_READ BIT_FLAG(1)
#define CODE_DATA_TYPE_CONFORMING BIT_FLAG(2)
#define CODE_DATA_TYPE_EXECUTE BIT_FLAG(3)
#define CODE_DATA_TYPE_EXECUTE_CONFORMING_READ (CODE_DATA_TYPE_EXECUTE | CODE_DATA_TYPE_CONFORMING | CODE_DATA_TYPE_READ)

#define SYSTEM_TYPE_NOT_BUSY (BIT_FLAG(3) | BIT_FLAG(0))

#define MAX_GDT_SIZE 8196
#define MAX_GDT_LIMIT (MAX_GDT_SIZE - 1)

typedef IDTR GDTR;

union SegmentSelector
{
	uint16 all;
	struct
	{
		uint16 rpl : 2;					// Requested Privilege Level
		uint16 ti : 1;					// Table Indicator
		uint16 index: 13;
	};
};

union SegmentDescriptor32
{
	uint64 all;
	struct
	{
		uint64 segmentLimitLow : 16;
		uint64 baseLow : 16;
		uint64 baseMid : 8;
		uint64 type : 4;
		uint64 descriptorType : 1;
		uint64 dpl : 2;					// Descriptor Privilege Level
		uint64 p : 1;					// Present
		uint64 segmentLimitHigh : 4;
		uint64 system : 1;
		uint64 longMode : 1;
		uint64 defaultBig : 1;
		uint64 granularity : 1;
		uint64 baseHigh : 8;
	};
};

union SegmentDescriptor64
{
	uint64 all[2];
	struct
	{
		SegmentDescriptor32 desc;
		uint32 baseUpper;
		uint32 setZero;
	};
};

/*
	Debug Registers
*/

typedef uint64 DR0;
typedef uint64 DR1;
typedef uint64 DR2;
typedef uint64 DR3;

union DR7
{
	uint64 all;

	struct
	{
		uint64 l0 : 1;
		uint64 g0 : 1;
		uint64 l1 : 1;
		uint64 g1 : 1;
		uint64 l2 : 1;
		uint64 g2 : 1;
		uint64 l3 : 1;
		uint64 g3 : 1;
		uint64 le : 1;
		uint64 ge : 1;
		uint64 set_10_1 : 1;
		uint64 rtm : 1;
		uint64 set_12_0 : 1;
		uint64 gd : 1;
		uint64 set_14_15_0 : 2;
		uint64 rw0 : 2;
		uint64 len0 : 2;
		uint64 rw1 : 2;
		uint64 len1 : 2;
		uint64 rw2 : 2;
		uint64 len2 : 2;
		uint64 rw3 : 2;
		uint64 len3 : 2;

	};
};

/*
	Control Registers
*/

union CR0
{
	uint64 all;

	struct
	{
		uint64 pe : 1;			// [0] Protected mode enabled
		uint64 mp : 1;			// [1] Monitor co-processor
		uint64 em : 1;			// [2] Emulation
		uint64 ts : 1;			// [3] Task switched
		uint64 et : 1;			// [4] Extension type
		uint64 ne : 1;			// [5] Numeric error
		uint64 reserved_1 : 10;	// [6:15]
		uint64 wp : 1;			// [16] Write protect
		uint64 reserved_2 : 1;		// [17]
		uint64 am : 1;			// [18] Alignment mask
		uint64 reserved_3 : 10;	// [19:28]
		uint64 nw : 1;			// [29] Not write-through
		uint64 cd : 1;			// [30] Cache disable
		uint64 pg : 1;			// [31] Paging
		uint64 reserved_4 : 32;	// [32:63]
	};
};

union CR3
{
	uint64 all;

	struct
	{
		uint64 ignored1 : 3;		// [0:2]
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 ignored2 : 7;		// [5:11]
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 16;	// [48:63]
	} pcide0;

	struct
	{
		uint64 pcid : 12; 			// [0:11] Process context identifier
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 15;		// [48:62]
		uint64 cacheTLB : 1;		// [63]
	} pcide1;

	struct
	{
		uint64 varied : 12;
		uint64 pfn : 36;
		uint64 reserved : 16;
	};
};

union CR4
{
	uint64 all;
	struct
	{
		uint64 vme : 1;
		uint64 pvi : 1;
		uint64 tsd : 1;
		uint64 de : 1;
		uint64 pse : 1;
		uint64 pae : 1;
		uint64 mce : 1;
		uint64 pge : 1;
		uint64 pce : 1;
		uint64 osfxsr : 1;
		uint64 osxmmexcpt : 1;
		uint64 umip : 1;
		uint64 la57 : 1;
		uint64 vmxe : 1;
		uint64 smxe : 1;
		uint64 reserved1 : 1;
		uint64 fsgsbase : 1;
		uint64 pcide : 1;
		uint64 osxsave : 1;
		uint64 kl : 1;
		uint64 smep : 1;
		uint64 smap : 1;
		uint64 pke : 1;
		uint64 cet : 1;
		uint64 pks : 1;
		uint64 reserved2 : 39;
	};
};

/*
	Page Tables
*/

#define TABLE_FLAG_READ		BIT_FLAG(0)
#define TABLE_FLAG_WRITE	BIT_FLAG(1)
#define TABLE_FLAG_USERMODE BIT_FLAG(2)
#define TABLE_FLAG_NX		BIT_FLAG(63)

#define TABLE_LEVEL_PML4 4
#define TABLE_LEVEL_PDPT 3
#define TABLE_LEVEL_PD 2
#define TABLE_LEVEL_PT 1
#define TABLE_LEVEL_ENTRY 0

union PML4E
{
	uint64 all;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 ignored_1 : 1;		// [6]
		uint64 ps : 1;			// [7] Page size (must be zero)
		uint64 ignored_2 : 4;		// [8:11]
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 4;		// [48:51]
		uint64 ignored_3 : 11;		// [52:62]
		uint64 xd : 1;			// [63] Execute disable
	};
};

union PDPTE
{
	uint64 all;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 d : 1;				// [6] Dirty
		uint64 ps : 1;				// [7] Page size
		uint64 g : 1;				// [8] Global
		uint64 ignored_1 : 3;		// [9:11]
		uint64 pat : 1;			// [12] Page access type
		uint64 reserved_1 : 17;	// [13:29]
		uint64 pfn : 18;			// [30:47] Page frame number
		uint64 reserved_2 : 4;		// [48:51]
		uint64 ignored_2 : 7;		// [52:58]
		uint64 pk : 4;			// [59:62] Protection key
		uint64 xd : 1;			// [63] Execute disable
	} map;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 ignored_1 : 1;		// [6]
		uint64 ps : 1;			// [7] Page size
		uint64 ignored_2 : 4;		// [8:11]
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 4;		// [48:51]
		uint64 ignored_3 : 11;		// [52:62]
		uint64 xd : 1;			// [63] Execute disable
	} ref;
};

union PDE
{
	uint64 all;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 d : 1;				// [6] Dirty
		uint64 ps : 1;			// [7] Page size
		uint64 g : 1;				// [8] Global
		uint64 ignored_1 : 3;		// [9:11]
		uint64 pat : 1;			// [12] Page access type
		uint64 reserved_1 : 8;		// [13:20]
		uint64 pfn : 27;			// [21:47] Page frame number
		uint64 reserved_2 : 4;		// [48:51]
		uint64 ignored_2 : 7;		// [52:58]
		uint64 pk : 4;			// [59:62] Protection key
		uint64 xd : 1;			// [63] Execute disable
	} map;

	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 ignored_1 : 1;		// [6]
		uint64 ps : 1;			// [7] Page size
		uint64 ignored_2 : 4;		// [8:11]
		uint64 pfn : 36;			// [12:47] Page frame number
		uint64 reserved_1 : 4;		// [48:51]
		uint64 ignored_3 : 11;		// [52:62]
		uint64 xd : 1;			// [63] Execute disable
	} ref;
};

union PTE
{
	uint64 all;
	struct
	{
		uint64 p : 1;				// [0] Present
		uint64 rw : 1;			// [1] Read/Write; if 0, writes may not be allowed
		uint64 us : 1;			// [2] User/Supervisor; if 0, user-mode accesses are not allowed
		uint64 pwt : 1;			// [3] Page-level write-through
		uint64 pcd : 1;			// [4] Page-level cache disable
		uint64 a : 1;				// [5] Accessed
		uint64 d : 1;				// [6] Dirty
		uint64 pat : 1;			// [7] Page access type
		uint64 g : 1;             // [8] Global
		uint64 ignored_1 : 3;		// [9:11]
		uint64 pfn : 36;          // [12:47] Page frame number
		uint64 reserved_1 : 4;		// [48:51]
		uint64 ignored_2 : 7;		// [52:58]
		uint64 pk : 4;			// [59:62] Protection key
		uint64 xd : 1;            // [63] Execute disable
	};
};

inline constexpr int PageTableEntries = (PAGE_SIZE / sizeof(PTE));

/*
	Memory
*/

union VAddress
{
	uint64 all;

	struct
	{
		uint64 offset : 12;
		uint64 pt : 9;
		uint64 pd : 9;
		uint64 pdpt : 9;
		uint64 pml4 : 9;
		uint64 reserved : 16;
	};
};

#if defined(_MSC_EXTENSIONS)
#pragma warning(pop)
#endif
```

`Files/CPE.h`:

```h
#pragma once
#include <ntddk.h>
#include <ntimage.h>

#include "CTypes.h"
#include "Array.h"

#define IMAGE_PE_SIGNATURE 0x00004550  // PE00

#define NT_HEADERS(mod) reinterpret_cast<IMAGE_NT_HEADERS64*>(reinterpret_cast<uint8*>(mod) + reinterpret_cast<IMAGE_DOS_HEADER*>(mod)->e_lfanew)
```

`Files/CTypes.h`:

```h
#pragma once
#include <xmmintrin.h>

typedef __m128				uint128;
typedef unsigned __int64	uint64;
typedef unsigned __int32	uint32;
typedef unsigned __int16	uint16;
typedef unsigned __int8		uint8;

typedef __int64				int64;
typedef __int32				int32;
typedef __int16				int16;
typedef __int8				int8;

typedef unsigned long long	ulonglong;
typedef unsigned long		ulong;
typedef unsigned short		ushort;
typedef unsigned char		uchar;

typedef wchar_t wchar;

#ifdef _WIN64
	typedef unsigned __int64 uintn;
	typedef __int64 intn;
#else
	typedef unsigned __int32 uintn;
	typedef __int32 intn;
#endif
```

`Files/CovertThread.cpp`:

```cpp
#include <ntddk.h>
#include <intrin.h>
#include <xmmintrin.h>

#include "CIA32.h"
#include "CPE.h"
#include "Memory.h"
#include "ROPGadgets.h"
#include "Handlers.h"
#include "PageSpace.h"
#include "Utils.h"

extern "C" void* PsTerminateSystemThreadAddress = nullptr;

/*
	Backburner:

	Perhaps save IDTR and CR3 at start of interrupt handler, then load the new IDTR and the custom CR3.
	This could be more stable, but it should already be good enough.

	There are likely some redundancies in the ROP gadgets that could be removed/replaced.

	Some of the code, primarily the assembly, could be refactored.

	Add comments that correspond to sections detailed in the article.
	For example: 
		Discuss why PsTerminateSystemThreadAddress is used in the article, 
		then link that section here in a comment.
*/

/*
	Runs all necessary setup functions.

	@return True if the setup was successful, false otherwise
*/
bool Startup()
{
	PsTerminateSystemThreadAddress = &PsTerminateSystemThread;

	if (!FindAllOffsets())
	{
		DbgPrint("Failed to find all offsets\n");
		return false;
	}

	if (!FindSelfReferencingPML4())
	{
		DbgPrint("Failed to find the self referencing PML4\n");
		return false;
	}

	DbgPrint("PML4: 0x%p\n", PML4V);
	DbgPrint("Self referencing PML4 PFN: 0x%llx\n\n", PML4V[SelfReferencingPML4Idx].pfn);

	if (!CollectROPGadgets())
	{
		DbgPrint("Failed to collect all ROP gadgets\n");
		return false;
	}
	
	if (!CreateIDT())
	{
		DbgPrint("Failed to create IDT\n");
		return false;
	}

	if (!CreatePageSpaces())
	{
		FreeIDT();
		DbgPrint("Failed to create page spaces\n");
		return false;
	}

	return true;
}

/*
	A third thread for demonstration purposes.

	@param context - The starting context
*/
void ThirdThread(void* context)
{
	UNREFERENCED_PARAMETER(context);

	for (int i = 0; i < 10; ++i)
	{
		DbgPrint("In third thread\n");
		Sleep(1000);
	}
}

/*
	A second thread for demonstration purposes.

	@param context - The starting context
*/
void SecondThread(void* context)
{
	UNREFERENCED_PARAMETER(context);

	for (int i = 0; i < 10; ++i)
	{
		DbgPrint("In second thread\n");
		Sleep(1000);
	}
}

/*
	Creates a covert thread at the start address with the context specified.

	@param startAddress - The starting address for the thread
	@param context - The starting context

	@return True if the thread creation was successful, false otherwise
*/
bool CreateThread(void* startAddress, void* context)
{
	/*
		Forces only one thread to be created at a time.
	*/
	while (_interlockedbittestandset64(&StartInfo.lock, 0))
	{
		Sleep(10);
	}

	static bool init = false;
	if (!init)
	{
		if (!Startup())
		{
			_interlockedbittestandreset64(&StartInfo.lock, 0);
			DbgPrint("Failed to perform startup\n");
			return false;
		}

		init = true;
	}
	else
	{
		CR3 customCR3 = CreateCustomCR3ThreadCopy();
		if (!customCR3.all)
		{
			_interlockedbittestandreset64(&StartInfo.lock, 0);
			DbgPrint("Failed to create custom CR3 thread copy\n");
			return false;
		}

		ThreadInfo* info = NewThreadInfo(customCR3);
		if (!info)
		{
			_interlockedbittestandreset64(&StartInfo.lock, 0);
			DbgPrint("Failed to create custom CR3 thread copy\n");
			return false;
		}

		StartInfo.threadInfo = info;
	}

	StartInfo.context = context;
	StartInfo.startAddress = startAddress;

	OBJECT_ATTRIBUTES obj{ 0 };
	InitializeObjectAttributes(&obj, nullptr, OBJ_KERNEL_HANDLE, nullptr, nullptr);

	HANDLE threadHandle = nullptr;
	if (!NT_SUCCESS(PsCreateSystemThread(&threadHandle, GENERIC_ALL, &obj,
		nullptr, nullptr, reinterpret_cast<PKSTART_ROUTINE>(MovCR3RCX), reinterpret_cast<void*>(TransitionalCR3.all))))
	{
		_interlockedbittestandreset64(&StartInfo.lock, 0);
		DbgPrint("Failed to create system thread\n");
		return false;
	}

	if (threadHandle)
		ZwClose(threadHandle);

	return true;
}

/*
	The first thread for demonstration purposes.

	@param context - The starting context
*/
void StartRoutine(void* context)
{
	UNREFERENCED_PARAMETER(context);

	/*
		We can create new threads within our thread.
	*/
	if (!CreateThread(ThirdThread, nullptr))
	{
		DbgPrint("Failed to create third thread\n");
		return;
	}

	for (int i = 0; i < 5; ++i)
	{
		/*
			We can allocate memory.
		*/
		void* pool = AllocatePool(0x20, POOL_FLAG_NON_PAGED);
		if (pool)
		{
			DbgPrint("Pool allocated: 0x%p\n", pool);
			FreePool(pool);
		}

		void* memory = AllocateContiguousMemory(0x20, PAGE_READWRITE);
		if (memory)
		{
			DbgPrint("Memory allocated: 0x%p\n", memory);
			FreeContiguousMemory(memory);
		}

		/*
			We can print.
		*/
		DbgPrint("In Start Routine\n");

		/*
			We can sleep.
		*/
		Sleep(1000);
	}
}

/*
	The initial entry point.

	@param DriverObject - The driver object
	@param RegistryPath - The registry path

	@return An NTSTATUS value
*/
NTSTATUS DriverEntry(DRIVER_OBJECT* DriverObject, UNICODE_STRING* RegistryPath)
{
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);
	
	void** addressOfReturnAddress = reinterpret_cast<void**>(_AddressOfReturnAddress());
	void* mod = FindModuleStart(&FindModuleStart);
	if (!mod)
	{
		DbgPrint("Unable to find module start\n");
		return STATUS_UNSUCCESSFUL;
	}

	/*
		For safe exiting purposes
	*/
	if (*addressOfReturnAddress >= mod && *addressOfReturnAddress <
		(reinterpret_cast<uint8*>(mod) + NT_HEADERS(mod)->OptionalHeader.SizeOfImage))
	{
		DbgPrint("Please ensure that DriverEntry is the first function called within this driver\n");
		return STATUS_UNSUCCESSFUL;
	}

	DriverEntryExitSync = 0;
	if (!CreateThread(StartRoutine, nullptr))
	{
		DbgPrint("Failed to create thread\n");
		return STATUS_UNSUCCESSFUL;
	}

	if (!CreateThread(SecondThread, nullptr))
	{
		DbgPrint("Failed to create second thread\n");
		SafeExit(addressOfReturnAddress, STATUS_UNSUCCESSFUL);
	}

	SafeExit(addressOfReturnAddress, STATUS_SUCCESS);
}
```

`Files/Handlers.cpp`:

```cpp
#include <ntddk.h>
#include <intrin.h>

#include "Memory.h"
#include "Handlers.h"
#include "PageSpace.h"

bool InterruptDispatch(InterruptContext* context)
{
	if (context->vector == INTERRUPT_VECTOR_BP)
	{
		if (*reinterpret_cast<uint8*>(context->iFrame.frame.rip) == 0xCC)
			context->iFrame.frame.rip++;

		return true;
	}

	return false;
}

void* GetHandlerAddress(int idx)
{
	IDTR idtr{ 0 };
	__sidt(&idtr);

	if (!idtr.base)
	{
		DbgPrint("Invalid IDT base\n");
		return nullptr;
	}

	IDTEntry* handler = &reinterpret_cast<IDTEntry*>(idtr.base)[idx];
	if (!handler || !handler->p)
	{
		DbgPrint("Invalid handler\n");
		return nullptr;
	}

	return reinterpret_cast<void*>(
		((handler->baseHigh << 32) |
			(handler->baseMiddle << 16) |
			(handler->baseLow)));
}

bool CreateIDT()
{
	__sidt(&OldIDTR);
	if (!OldIDTR.base)
	{
		DbgPrint("Invalid IDT base\n");
		return false;
	}

	void* idt = AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE);
	if (!idt)
	{
		DbgPrint("Failed to allocate IDT\n");
		return false;
	}

	DbgPrint("New IDT: 0x%p\n", idt);

	memcpy(idt, reinterpret_cast<void*>(OldIDTR.base), PAGE_SIZE);

	for (int i = 0; i < IDTEntries; ++i)
	{
		uint64 handler = reinterpret_cast<uint64>(
			INTERRUPT_HANDLER_STUB_ADDRESS(i));

		IDTEntry* entry = &reinterpret_cast<IDTEntry*>(idt)[i];
		entry->baseLow = handler & MAXUINT16;
		entry->baseMiddle = (handler >> 16) & MAXUINT16;
		entry->baseHigh = (handler >> 32) & MAXUINT32;

		entry->type = IDT_TYPE_INTERRUPT_GATE;
	}

	NewIDTR = OldIDTR;
	NewIDTR.base = reinterpret_cast<uint64>(idt);

	return true;
}

void FreeIDT()
{
	if (NewIDTR.base)
		FreeContiguousMemory(reinterpret_cast<void*>(NewIDTR.base));
}
```

`Files/Handlers.h`:

```h
#pragma once
#include "CIA32.h"

/*
	Every handler starts 8-byte aligned.
	Handler:
	push vector (2 bytes)
	jmp InterruptDispatchGate (5 bytes)
*/
#define INTERRUPT_HANDLER_STUB_ADDRESS(idx) reinterpret_cast<void*>(reinterpret_cast<uint64>(&InterruptHandlerStub) + (idx * sizeof(uint64)))

struct InterruptContext
{
	uint64 r15;
	uint64 r14;
	uint64 r13;
	uint64 r12;
	uint64 r11;
	uint64 r10;
	uint64 r9;
	uint64 r8;
	uint64 rdi;
	uint64 rsi;
	uint64 rbp;
	uint64 dummy;
	uint64 rbx;
	uint64 rdx;
	uint64 rcx;
	uint64 rax;
	bool hasErrorCode;
	uint64 vector;
	InterruptFrameErrorCode iFrame;
};

/*
	The starting address for all interrupt handler stubs.
*/
extern "C" void InterruptHandlerStub(void);

/*
	A generic interrupt handler called by each interrupt handler stub.
*/
extern "C" void InterruptDispatchGate(void);

/*
	The initial entry handler for new covert threads.
*/
extern "C" void EntryHandler(void);

/*
	A generic interrupt handler called by the interrupt dispatch gate.

	@param context - Information about the interrupt

	@return True if the interrupt was handled, false otherwise (original interrupt handler must be called)
*/
extern "C" bool InterruptDispatch(InterruptContext* context);

/*
	Gets an interrupt handler address at the specified index.

	@param idx - The interrupt handler's index

	@return The interrupt handler address
*/
void* GetHandlerAddress(int idx);

/*
	Creates the interrupt descriptor table (IDT).

	@return True if the IDT was created successfully, false otherwise
*/
bool CreateIDT();

/*
	Frees the IDT that was created.
*/
extern "C" void FreeIDT();

extern "C" inline IDTR NewIDTR{ 0 };
extern "C" inline IDTR OldIDTR{ 0 };
```

`Files/HandlersASM.asm`:

```asm
extern InterruptDispatch : proc
extern FindCurrentThreadInfo : proc
extern GetCurrentDirectoryTable : proc
extern PFNToVirtInPageSpace : proc
extern FlushCaches : proc

extern TransitionalCR3 : qword
extern SystemCR3 : qword
extern NewIDTR : fword
extern OldIDTR : fword
extern EntryShellcodeTotalSize : qword
extern ModuleBase : qword
extern ModuleSize : qword
extern ThreadInfoSize : qword

extern MovCR3RAXGadget : qword
extern PopRAXGadget : qword
extern MovCR3RCX : qword
extern PopRCXGadget : qword
extern PopRDXGadget : qword
extern CLIGadget : qword
extern PopfqGadget : qword
extern IretqGadget : qword
extern MovCR3RSI : qword

extern SelfReferencingPML4Idx : qword

; 0x80 bytes pushed
PUSHAQ macro
	push rax
	push rcx
	push rdx
	push rbx
	push 0			; RSP dummy
	push rbp
	push rsi
	push rdi
	push r8
	push r9
	push r10
	push r11
	push r12
	push r13
	push r14
	push r15
endm

; 0x80 bytes popped
POPAQ macro
	pop r15
	pop r14
	pop r13
	pop r12
	pop r11
	pop r10
	pop r9
	pop r8
	pop rdi
	pop rsi
	pop rbp
	add rsp, 8h		; RSP dummy
	pop rbx
	pop rdx
	pop rcx
	pop rax
endm

.const
	ROP_CHAIN_SIZE equ 48h
	INTERRUPT_STACK_SIZE equ 80h

	INTERRUPT_STACK_KEY equ 0ce1444d5109fa547h

.code

	ALIGN 10h
	InterruptHandlerStub proc

	counter = 0

	REPEAT 256
		ALIGN 8
									; push counter (saves memory this way)
		db 6Ah
		db counter
	counter = counter + 1

		jmp InterruptDispatchGate
	ENDM

	InterruptHandlerStub endp

	InterruptDispatchGate proc
		and qword ptr [rsp], 0FFh
		bt rsp, 3
		jc ErrorCode
		push [rsp]					; Shift vector for fake error code (maintains consistent RSP value)
		push 0						; hasErrorCode (false)
		jmp ContinueHandling

	ErrorCode:
		push 1						; hasErrorCode (true)

	ContinueHandling:
		cmp qword ptr [rsp + 8], 0Eh
		jnz NormalHandling
		test qword ptr [rsp], 1
		jz NormalHandling
		bt qword ptr [rsp + 10h], 4
		jnc NormalHandling
		push rax
		push rcx
		mov rax, cr2
		mov rcx, ModuleBase
		cmp rax, rcx
		jl ExternalExecution
		add rcx, ModuleSize
		cmp rax, rcx
		pop rcx
		pop rax
		jge ExternalExecution2
		jmp NormalHandling

	ExternalExecution:
		pop rcx
		pop rax
	ExternalExecution2:
		PUSHAQ

		sub rsp, 80h
		movaps xmmword ptr [rsp + 20h], xmm0
		movaps xmmword ptr [rsp + 30h], xmm1
		movaps xmmword ptr [rsp + 40h], xmm2
		movaps xmmword ptr [rsp + 50h], xmm3
		movaps xmmword ptr [rsp + 60h], xmm4
		movaps xmmword ptr [rsp + 70h], xmm5

		call GetCurrentDirectoryTable
		mov [rsp + 0F8h], rax

		call FindCurrentThreadInfo

		movaps xmm0, xmmword ptr [rsp + 20h]
		movaps xmm1, xmmword ptr [rsp + 30h]
		movaps xmm2, xmmword ptr [rsp + 40h]
		movaps xmm3, xmmword ptr [rsp + 50h]
		movaps xmm4, xmmword ptr [rsp + 60h]
		movaps xmm5, xmmword ptr [rsp + 70h]
		add rsp, 80h

		mov rdx, ThreadInfoSize
		lea rcx, [rax + rdx]
		mov rax, [rsp + 0B0h]					; RSP Value
		mov rdx, [rsp + 0B8h]					; SS Value
		mov [rcx - 8], rdx
		lea rdx, [rax + 8]
		mov [rcx - 10h], rdx
		mov rdx, [rsp + 0A8h]					; RFLAGS Value
		mov [rcx - 18h], rdx
		mov rdx, [rsp + 0A0h]					; CS Value
		mov [rcx - 20h], rdx
		mov rdx, [rax]
		mov [rcx - 28h], rdx

		mov rdx, cr3
		mov [rcx - 30h], rdx
		sidt fword ptr [rcx - 40h]
		lea rdx, [ExternalCallReturnHandler]
		mov [rcx - 48h], rdx
		mov rdx, [rsp + 48h]
		mov [rcx - 50h], rdx
		mov rdx, [rsp + 50h]
		mov [rcx - 58h], rdx

		mov rdx, TransitionalCR3
		mov [rsp + 48h], rdx
		lea rdx, [rcx - 58h]
		mov [rsp + 50h], rdx

		mov rdx, MovCR3RSI
		mov [rax], rdx

		POPAQ

		mov [rsp], rax
		mov rax, IretqGadget
		mov [rsp + 10h], rax
		mov rax, MovCR3RAXGadget
		mov [rsp + 8], rax 
		mov rax, TransitionalCR3
		mov cr3, rax
		lidt fword ptr [OldIDTR]
		pop rax
		test rax, rax
		jz UseSystemDefault
		jmp LeaveInterruptHandler

	NormalHandling:

		PUSHAQ
		mov rcx, rsp
		
		sub rsp, 80h
		movaps xmmword ptr [rsp + 20h], xmm0
		movaps xmmword ptr [rsp + 30h], xmm1
		movaps xmmword ptr [rsp + 40h], xmm2
		movaps xmmword ptr [rsp + 50h], xmm3
		movaps xmmword ptr [rsp + 60h], xmm4
		movaps xmmword ptr [rsp + 70h], xmm5

		call InterruptDispatch

		movaps xmm0, xmmword ptr [rsp + 20h]
		movaps xmm1, xmmword ptr [rsp + 30h]
		movaps xmm2, xmmword ptr [rsp + 40h]
		movaps xmm3, xmmword ptr [rsp + 50h]
		movaps xmm4, xmmword ptr [rsp + 60h]
		movaps xmm5, xmmword ptr [rsp + 70h]
		add rsp, 80h

		test al, al
		jz Original
		POPAQ

		add rsp, 18h						; Remove the hasErrorCode, interrupt vector, and error code
		iretq

	Original:
		pop r15
		pop r14
		pop r13
		pop r12
		pop r11
		pop r10
		pop r9
		pop r8
		pop rdi
		pop rsi
		pop rbp
		add rsp, 8h								; RSP dummy
		pop rbx

		mov rcx, [rsp + 48h]
		add rcx, INTERRUPT_STACK_SIZE
		mov rdx, rcx
		shl rcx, 16
		shr rcx, 28
		shl rcx, 3
		xor rax, rax
		mov rax, 0FFFFh
		shl rax, 9
		or rax, SelfReferencingPML4Idx
		shl rax, 39
		or rcx, rax
		test byte ptr [rcx], 1
		jnz ValidPage
		mov rax, 0FFFh
		neg rax
		and rdx, rax
		sub rdx, 8

	ValidPage:
		mov rcx, rdx
		mov rax, [rsp + 48h]
		mov rdx, INTERRUPT_STACK_KEY
		add rcx, 8
		
	FindStackKey:
		sub rcx, 8h
		cmp rdx, qword ptr [rcx]
		jz FoundStackKey
		cmp rcx, rax
		jnz FindStackKey
		jmp NoPriorInterrupt

	FoundStackKey:
		mov rdx, rcx
		mov rax, [rsp + 30h]
		mov rcx, MovCR3RCX
		cmp rax, rcx
		jl NotEntryShellcode
		add rcx, EntryShellcodeTotalSize
		cmp rax, rcx
		jge NotEntryShellcode
		jmp PriorInterrupt

	NotEntryShellcode:
		lea rcx, [EntryHandler]
		cmp rax, rcx
		jl NoPriorInterrupt
		lea rcx, [EntryHandlerEnd]
		cmp rax, rcx
		jge NoPriorInterrupt
		
	PriorInterrupt:							; Use prior interrupt frame (right above the stack key) then do everything else the same
		sub rdx, 28h
		xor rcx, rcx

	CopyPriorInterruptFrame:
		mov rax, [rdx + rcx]
		mov [rsp + rcx + 30h], rax
		add rcx, 8h
		cmp rcx, 28h
		jnz CopyPriorInterruptFrame

	NoPriorInterrupt:
		lea rax, [rsp + 58h]				; End of interrupt frame
		mov rcx, [rsp + 48h]				; Interrupt frame RSP

		cmp rax, rcx						; Check if we switched stacks on the interrupt
		jz NoIST
		add rax, 8h
		cmp rax, rcx
		jz NoIST
		jmp IST

	NoIST:
		lea rax, [rsp]
		sub rsp, INTERRUPT_STACK_SIZE
		xor rcx, rcx

	ShiftStack:
		mov rdx, [rax]
		mov [rsp + rcx], rdx
		add rax, 8h
		add rcx, 8h
		cmp rcx, 58h
		jnz ShiftStack

	IST:
		mov rax, [rsp + 48h]
		mov rcx, INTERRUPT_STACK_KEY
		mov [rax - 8], rcx
		sub rax, 30h
		xor rcx, rcx
		
	CopyInterruptFrame:
		mov rdx, [rsp + rcx + 30h]
		mov [rax + rcx], rdx
		add rcx, 8h
		cmp rcx, 28h
		jnz CopyInterruptFrame

		sub rax, ROP_CHAIN_SIZE
		mov [rsp + 48h], rax
		add rax, ROP_CHAIN_SIZE

	SetupROPChain:
		mov rcx, [rsp + 10h]
		mov [rax - 8h], rcx

		mov rcx, [rsp + 8]
		mov [rax - 10h], rcx

		mov rcx, [rsp]
		mov [rax - 18h], rcx

		mov rcx, cr3
		mov [rax - 20h], rcx

		sidt fword ptr [rax - 30h]

		mov rcx, MovCR3RCX
		mov [rax - 38h], rcx

		mov rcx, TransitionalCR3
		mov [rax - 40h], rcx

		mov rcx, PopRCXGadget
		mov [rax - 48h], rcx

		mov rcx, CLIGadget
		mov [rsp + 30h], rcx

		pop rdx

		mov rax, [rsp + 18h]				; Interrupt vector
		shl rax, 1							; Double it

		mov rcx, qword ptr [OldIDTR + 2]
		lea rcx, [rcx + rax * 8]

		xor rax, rax
		mov al, byte ptr [rcx + 5]
		and al, 1
		shl rax, 9
		pushfq
		or qword ptr [rsp], rax

		mov eax, dword ptr [rcx + 8]
		shl rax, 16
		mov ax, word ptr [rcx + 6]
		shl rax, 16
		mov ax, word ptr [rcx]

		lea rcx, [rsp + 18h]				; hasErrorCode (bool)
		test byte ptr [rcx], 1
		jnz HasErrorCode
		pop rcx
		mov [rsp + 18h], rcx
		pop rcx
		jmp Finish

	HasErrorCode:
		pop rcx
		mov [rsp + 10h], rcx
		mov rcx, [rsp + 8]
		xchg rcx, [rsp]

	Finish:
		mov [rsp + 18h], rax

		mov rax, PopfqGadget
		mov [rsp + 8], rax

		mov rax, PopRAXGadget
		push rax

		mov rax, MovCR3RAXGadget
		push rax

		mov rax, TransitionalCR3
		mov cr3, rax
		lidt fword ptr [OldIDTR]

		mov rax, rsp
		and rsp, -16
		PUSHAQ

		sub rsp, 80h
		movaps xmmword ptr [rsp + 20h], xmm0
		movaps xmmword ptr [rsp + 30h], xmm1
		movaps xmmword ptr [rsp + 40h], xmm2
		movaps xmmword ptr [rsp + 50h], xmm3
		movaps xmmword ptr [rsp + 60h], xmm4
		movaps xmmword ptr [rsp + 70h], xmm5

		call GetCurrentDirectoryTable

		movaps xmm0, xmmword ptr [rsp + 20h]
		movaps xmm1, xmmword ptr [rsp + 30h]
		movaps xmm2, xmmword ptr [rsp + 40h]
		movaps xmm3, xmmword ptr [rsp + 50h]
		movaps xmm4, xmmword ptr [rsp + 60h]
		movaps xmm5, xmmword ptr [rsp + 70h]
		add rsp, 80h

		pop r15
		pop r14
		pop r13
		pop r12
		pop r11
		pop r10
		pop r9
		pop r8
		pop rdi
		pop rsi
		pop rbp
		add rsp, 8h		; RSP dummy
		pop rbx
		pop rdx
		pop rcx

		mov rsp, [rsp]

		test rax, rax
		jz UseSystemDefault
		jmp LeaveInterruptHandler

	UseSystemDefault:
		mov rax, SystemCR3

		; Stack:

		; MovCR3RAXGadget Address					(RAX contains CurrentDirectoryTableBase value or SystemCR3)
		; PopRAXGadget Address
		; Original RAX Value
		; PopfqGadget Address
		; RFLAGS Value
		; Original Interrupt Handler Address
		; Error Code								(Depends on the interrupt)
		; Interrupt Frame							(RIP modified to CLIGadget, RSP modified to the re-entry ROP chain (see immediately below))
		
		; PopRCXGadget Address
		; TransitionalCR3 Value
		; MovCR3RCX Address
		; IDTR Value
		; CR3 Value
		; Original RDX Value
		; Original RCX Value
		; Original RAX Value
		; Original Interrupt Frame
		; INTERRUPT_STACK_KEY
		; ...										(Original stack at interruption)
	
	LeaveInterruptHandler:
		btr rax, 63
		ret

	InterruptDispatchGate endp

	EntryHandler proc
		lidt fword ptr [rsp]
		add rsp, 10h

		pop rax
		mov cr3, rax

		pop rdx
		pop rcx
		pop rax

		iretq

	EntryHandler endp
	EntryHandlerEnd:

	ExternalCallReturnHandler proc
		mov rsi, [rbp]
		lidt fword ptr [rbp + 18h]
		mov rcx, [rbp + 28h]
		mov cr3, rcx
		push [rbp + 50h]
		push [rbp + 48h]
		push [rbp + 40h]
		push [rbp + 38h]
		push [rbp + 30h]
		mov rbp, [rbp + 8h]

		push rax
		sub rsp, 20h

		call GetCurrentDirectoryTable
		mov rcx, rax
		shl rcx, 16
		shr rcx, 28
		call PFNToVirtInPageSpace

		xor rcx, rcx
		or rcx, 0FFFFh
		shl rcx, 9
		or rcx, SelfReferencingPML4Idx
		shl rcx, 9
		or rcx, SelfReferencingPML4Idx
		shl rcx, 9
		or rcx, SelfReferencingPML4Idx
		shl rcx, 9
		or rcx, SelfReferencingPML4Idx
		shl rcx, 12

		xor rdx, rdx
	CopyLowerPML4Es:
		mov r8, [rax + rdx * 8]
		mov [rcx + rdx * 8], r8
		bts qword ptr [rcx + rdx * 8], 63
		inc rdx
		cmp rdx, 256
		jnz CopyLowerPML4Es

		call FlushCaches

		add rsp, 20h
		pop rax
		iretq

	ExternalCallReturnHandler endp

end
```

`Files/Memory.cpp`:

```cpp
#include <ntddk.h>
#include <intrin.h>

#include "Memory.h"

bool FindSelfReferencingPML4()
{
	CR3 cr3{ __readcr3() };

	PToV result = PToV::PFNToVirt(cr3.pfn);
	PML4E* pml4 = reinterpret_cast<PML4E*>(result.virt);
	if (!pml4)
	{
		result.Close();
		return false;
	}

	for (int i = PageTableEntries - 1; i >= 0; --i)
	{
		if (pml4[i].p && pml4[i].pfn == cr3.pfn)
		{
			SelfReferencingPML4Idx = i;
			result.Close();
			return true;
		}
	}

	result.Close();
	return false;
}

void* GetTable(void* address, int tableLevel)
{
	if (tableLevel == TABLE_LEVEL_PML4)
		return PML4V;

	uint64 table = KERNEL_CANONICAL;

	for (int i = 1; i <= tableLevel; ++i)
	{
		table |= (SelfReferencingPML4Idx << (
			12 + (9 * (TABLE_LEVEL_PML4 - i))));
	}

	uint64 addr = reinterpret_cast<uint64>(address);
	addr &= (~KERNEL_CANONICAL);

	table |= ((addr >> (9 * tableLevel)) & (~0b111111111111));

	return reinterpret_cast<void*>(table);
}

void* AllocateContiguousMemory(size_t size, ULONG protect, bool zero)
{
	PHYSICAL_ADDRESS high{ 0 };
	high.QuadPart = ~0llu;

	void* mem = MmAllocateContiguousNodeMemory(size, PHYSICAL_ADDRESS{ 0 },
		high, PHYSICAL_ADDRESS{ 0 }, protect, MM_ANY_NODE_OK);

	if (mem && zero)
		RtlSecureZeroMemory(mem, size);

	return mem;
}

void FreeContiguousMemory(void* address)
{
	MmFreeContiguousMemory(address);
}

void* AllocatePool(size_t size, uint64 flags, bool zero)
{
	void* pool = ExAllocatePool2(flags, size, 'enoN');
	if (pool && zero)
		RtlSecureZeroMemory(pool, size);

	return pool;
}

void FreePool(void* pool)
{
	ExFreePool(pool);
}

uint64 VirtToPhys(void* virt)
{
	return MmGetPhysicalAddress(virt).QuadPart;
}

uint64 VirtToPFN(void* virt)
{
	return VirtToPhys(virt) >> 12;
}

PToV PToV::PhysToVirt(uint64 phys)
{
	/*
		Why? System page tables cannot be mapped
		with MmMapIoSpaceEx and some physical addresses 
		cannot be resolved using MmGetVirtualForPhysical.
	*/

	PHYSICAL_ADDRESS address{ 0 };
	address.QuadPart = phys;

	PToV result{ 0 };

	result.virt = MmMapIoSpaceEx(address, PAGE_SIZE, PAGE_READWRITE);
	if (result.virt)
	{
		result.usedMmMapIoSpace = true;
	}
	else
	{
		result.usedMmMapIoSpace = false;
		result.virt = MmGetVirtualForPhysical(address);
	}

	return result;
}

PToV PToV::PFNToVirt(uint64 pfn)
{
	return PhysToVirt(pfn << 12);
}

void PToV::Close()
{
	if (virt && usedMmMapIoSpace)
	{
		MmUnmapIoSpace(virt, PAGE_SIZE);
		virt = nullptr;
		usedMmMapIoSpace = false;
	}
}

/*
	Populates all non-present entries in the current table from the table-to-copy.

	@param currentTable - The table to populate
	@param tableToCopy - The table to use for population
	@param setXD - Set the XD bit or not
*/
void PopulateTable(void* currentTable, void* tableToCopy, bool setXD)
{
	for (int i = 0; i < PageTableEntries; ++i)
	{
		if (!reinterpret_cast<PTE*>(currentTable)[i].p)
		{
			reinterpret_cast<PTE*>(currentTable)[i].all = reinterpret_cast<PTE*>(tableToCopy)[i].all;
			if (setXD)
				reinterpret_cast<PTE*>(currentTable)[i].xd = true;
		}
			
	}
}

PToV ContextualizeTable(void* currentTable, Array* memoryArray, 
void* address, int tableLevel, int stopLevel, bool setXD)
{
	int idx = ((reinterpret_cast<uint64>(address) >> 
		(12 + (9 * (tableLevel - 1)))) & 0b111111111);

	PTE* entry = &reinterpret_cast<PTE*>(currentTable)[idx];
	PTE* tableToCopy = reinterpret_cast<PTE*>(GetTable(address, tableLevel));
	
	PopulateTable(currentTable, tableToCopy, setXD);
	entry->xd = false;

	if (tableLevel == stopLevel)
		return PToV{ currentTable, false };

	if (entry->pfn == tableToCopy[idx].pfn)
	{
		void* lower = AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE);
		if (!lower)
			return PToV{ nullptr, false };

		memoryArray->Push(lower);
		entry->pfn = VirtToPFN(lower);
		return ContextualizeTable(lower, memoryArray, 
			address, tableLevel - 1, stopLevel, setXD);
	}
	
	PToV result = PToV::PFNToVirt(entry->pfn);
	PToV ret = ContextualizeTable(result.virt, memoryArray, 
		address, tableLevel - 1, stopLevel, setXD);

	if (ret.virt == result.virt)
		return result;

	result.Close();
	return ret;
}

bool ContextualizeTable(void* currentTable, Array* memoryArray, 
	void* address, size_t size, int tableLevel, int stopLevel, bool setXD)
{
	uint64 start = reinterpret_cast<uint64>(PAGE_ALIGN(address));
	uint64 end = reinterpret_cast<uint64>(PAGE_ROUND(start + size));

	while (start < end)
	{
		PToV result = ContextualizeTable(currentTable, memoryArray, 
			reinterpret_cast<void*>(start), tableLevel, stopLevel, setXD);

		if (!result.virt)
			return false;

		result.Close();

		start += PAGE_4K;
	}

	return true;
}

void FlushCaches(void* address)
{
	CR4 cr4{ __readcr4() };
	if (cr4.pcide || cr4.pge)
	{
		cr4.pge = ~(cr4.pge);
		__writecr4(cr4.all);
		cr4.pge = ~(cr4.pge);
		__writecr4(cr4.all);
	}
	else
	{
		__writecr3(__readcr3());
	}

	__wbinvd();
	__invlpg(address);
}

void* __cdecl operator new(uint64 size)
{
	return AllocatePool(size, POOL_FLAG_NON_PAGED);
}

void* __cdecl operator new[](uint64 size)
{
	return operator new(size);
}

void __cdecl operator delete(void* ptr)
{
	FreePool(ptr);
}

void __cdecl operator delete(void* ptr, uint64 size)
{
	UNREFERENCED_PARAMETER(size);
	operator delete(ptr);
}

void __cdecl operator delete[](void* ptr)
{
	operator delete(ptr);
}

void __cdecl operator delete[](void* ptr, uint64 size)
{
	UNREFERENCED_PARAMETER(size);
	operator delete(ptr);
}
```

`Files/Memory.h`:

```h
#pragma once
#include "CIA32.h"
#include "Array.h"

#define PML4V reinterpret_cast<PML4E*>(KERNEL_CANONICAL |						\
	(SelfReferencingPML4Idx << 39) | (SelfReferencingPML4Idx << 30) |			\
	(SelfReferencingPML4Idx << 21) | (SelfReferencingPML4Idx << 12))			\

#define PDPTV(pml4Idx) reinterpret_cast<PDPTE*>(KERNEL_CANONICAL |				\
	(SelfReferencingPML4Idx << 39) | (SelfReferencingPML4Idx << 30) |			\
	(SelfReferencingPML4Idx << 21) | (pml4Idx << 12))							\

#define PDV(pml4Idx, pdptIdx) reinterpret_cast<PDE*>(KERNEL_CANONICAL |			\
	(SelfReferencingPML4Idx << 39) | (SelfReferencingPML4Idx << 30) |			\
	(pml4Idx << 21) | (pdptIdx << 12))											\

#define PTV(pml4Idx, pdptIdx, pdIdx) reinterpret_cast<PTE*>(KERNEL_CANONICAL |	\
	(SelfReferencingPML4Idx << 39) | (pml4Idx << 30) |							\
	(pdptIdx << 21) | (pdIdx << 12))											\

class PToV
{
public:
	void* virt;
	bool usedMmMapIoSpace;

	/*
		Converts a physical address to a virtual address.

		@param phys - The physical address to convert

		@return A populated PToV class
	*/
	static PToV PhysToVirt(uint64 phys);

	/*
		Converts a page frame number (PFN) to a virtual address.

		@param pfn - The pfn to convert

		@return A populated PToV class
	*/
	static PToV PFNToVirt(uint64 pfn);

	/*
		Closes a PToV instance.
	*/
	void Close();
};

extern "C" inline uint64 SelfReferencingPML4Idx = PageTableEntries;

/*
	Finds the self-referencing PML4 index in the page tables.

	@return True if the self-referencing PML4 index was found, false otherwise
*/
bool FindSelfReferencingPML4();

/*
	Gets a page table at the specified table level for the given address.

	@param address - The address to get the table for
	@param tableLevel - The table level to get

	@return The page table at the specified table level for the given address
*/
void* GetTable(void* address, int tableLevel);

/*
	Allocates contiguous memory using MmAllocateContiguousNodeMemory.

	@param size - The size of the memory to allocate
	@param protect - The memory protection for the allocated memory
	@param zero - Zero the memory or not

	@return The contiguous memory allocation if successful, nullptr otherwise
*/
void* AllocateContiguousMemory(size_t size, ULONG protect, bool zero = true);

/*
	Frees contiguous memory using MmFreeContiguousMemory.

	@param address - The address of the contiguous memory
*/
void FreeContiguousMemory(void* address);

/*
	Allocates a pool using ExAllocatePool2.

	@param size - The size of the pool to allocate
	@param flags - The flags for the allocated pool
	@param zero - Zero the pool or not

	@return The pool allocation if successful, nullptr otherwise
*/
void* AllocatePool(size_t size, uint64 flags, bool zero = true);

/*
	Frees a pool using ExFreePool.

	@param pool - The address of the pool.
*/
extern "C" void FreePool(void* pool);

/*
	Converts a virtual address to a physical address.

	@param virt - The virtual address to convert

	@return A physical address
*/
uint64 VirtToPhys(void* virt);

/*
	Converts a virtual address to a PFN.

	@param virt - The virtual address to convert

	@return A PFN
*/
uint64 VirtToPFN(void* virt);

/*
	Contextualizes the current table for the given address such that all further mappings
	from the table level to the stop level are unique for the current table.

	@param currentTable - The current table to contexualize
	@param memoryArray - An Array to keep track of all allocated memory
	@param address - The virtual address to use for contextualizing
	@param tableLevel - The current table level
	@param stopLevel - The table level to stop at
	@param setXD - Set the execute-disable (XD) bit or not

	@return A populated PToV class if successful, zeroed PToV class otherwise
*/
PToV ContextualizeTable(void* currentTable, Array* memoryArray, void* address, int tableLevel, int stopLevel, bool setXD);

/*
	Contextualizes the current table for the given address + size such that all further mappings
	from the table level to the stop level are unique for the current table.

	@param currentTable - The current table to contexualize
	@param memoryArray - An Array to keep track of all allocated memory
	@param address - The virtual address to use for contextualizing
	@param size - The size from the address to contextualize
	@param tableLevel - The current table level
	@param stopLevel - The table level to stop at
	@param setXD - Set the execute-disable (XD) bit or not

	@return True if successful, false otherwise
*/
bool ContextualizeTable(void* currentTable, Array* memoryArray,
	void* address, size_t size, int tableLevel, int stopLevel, bool setXD);

/*
	Flushes the translation lookaside buffer (TLB) and instruction cache.

	@param address - A specific address within the TLB to flush
*/
extern "C" void FlushCaches(void* address);

/*
	Overrides for the default memory operators.
*/
void* __cdecl operator new(uint64 size);
void* __cdecl operator new[](uint64 size);
void __cdecl operator delete(void* ptr);
void __cdecl operator delete(void* ptr, uint64 size);
void __cdecl operator delete[](void* ptr);
void __cdecl operator delete[](void* ptr, uint64 size);
```

`Files/PageSpace.cpp`:

```cpp
#include <ntifs.h>
#include <intrin.h>

#include "PageSpace.h"
#include "Memory.h"
#include "CPE.h"
#include "Handlers.h"
#include "Utils.h"
#include "Array.h"
#include "ROPGadgets.h"

struct GlobalPTE
{
	PTE* pte;
	bool global;
};

extern "C" const size_t EntryShellcodeTotalSize = sizeof(EntryShellcode) + MovCR3RCXSize;
extern "C" const size_t ThreadInfoSize = sizeof(ThreadInfo);

Array* GlobalPTEs = nullptr;
Array* PageSpaceMemory = nullptr;

/*
	Gets the original module's PFN.

	@param moduleBase - The starting virtual address for the module

	@return The PFN for the module
*/
uint64 GetOriginalModulePFN(void* moduleBase)
{
	CR3 cr3{ __readcr3() };
	PToV result = PToV::PFNToVirt(cr3.pfn);

	uint64 originalModulePFN = reinterpret_cast<PML4E*>(
		result.virt)[VAddress{ reinterpret_cast<uint64>(moduleBase) }.pml4].pfn;

	result.Close();

	return originalModulePFN;
}

/*
	Creates the module page space for the covert thread to execute in.

	@return The module page space PML4 address if successful, nullptr otherwise
*/
void* CreateModulePageSpace()
{
	SystemCR3.all = __readcr3();
	SystemCR3.pcide1.cacheTLB = false;

	CR3 customCR3{ __readcr3() };
	customCR3.pcide1.cacheTLB = false;

	ModuleBase = FindModuleStart(&FindModuleStart);
	if (!ModuleBase)
	{
		DbgPrint("Failed to find module start\n");
		return nullptr;
	}

	void* pml4 = AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE);
	if (!pml4)
	{
		DbgPrint("Failed to allocate new PML4\n");
		return nullptr;
	}
	
	PageSpaceMemory->Push(pml4);
	customCR3.pfn = VirtToPFN(pml4);

	ThreadInfo* info = NewThreadInfo(customCR3);
	if (!info)
	{
		DbgPrint("Failed to create new thread info\n");
		return nullptr;
	}

	StartInfo.threadInfo = info;

	auto nt = NT_HEADERS(ModuleBase);
	ModuleSize = nt->OptionalHeader.SizeOfImage;

	if (!ContextualizeTable(pml4, PageSpaceMemory, ModuleBase,
		ModuleSize, TABLE_LEVEL_PML4, TABLE_LEVEL_PT, true))
	{
		DbgPrint("Failed to map pages in custom table\n");
		return nullptr;
	}

	DbgPrint("New module page space PML4: 0x%p\n", pml4);
	DbgPrint("Module base: 0x%p\n", ModuleBase);

	reinterpret_cast<PML4E*>(pml4)[SelfReferencingPML4Idx].pfn = customCR3.pfn;
	reinterpret_cast<PML4E*>(pml4)[SelfReferencingPML4Idx].xd = false;

	DbgPrint("Custom CR3: 0x%llx\n", customCR3.all);

	for (int i = PageTableEntries - 1; i >= 256; --i)
	{
		PML4E* pml4e = &reinterpret_cast<PML4E*>(pml4)[i];
		if (pml4e->p)
			continue;

		pml4e->p = true;
		pml4e->rw = true;
		pml4e->us = false;
		pml4e->xd = false;

		if (MapIndex)
		{
			NewModulePTEStart = &reinterpret_cast<PTE*>(
				GetTable(ModuleBase, TABLE_LEVEL_PT))[
					VAddress{ reinterpret_cast<uint64>(ModuleBase) }.pt];

			pml4e->pfn = GetOriginalModulePFN(ModuleBase);

			reinterpret_cast<VAddress*>(
				&NewModulePTEStart)->pdpt = i;

			break;
		}
		else
		{
			MapIndex = i;
		}
	}

	return pml4;
}

/*
	Performs a context-specific patch for the specified table.

	@param currentTable - The table to perform the context-specific patch
	@param address - The address at which the patch should be made
	@param shellcode - The shellcode to insert
	@param shellcodeSize - The size of the shellcode
	@param startLevel - The starting page table level

	@return True if successful, false otherwise
*/
bool PageSpacePatch(void* currentTable, void* address, void* shellcode, size_t shellcodeSize, int startLevel)
{
	VAddress va{ reinterpret_cast<uint64>(address) };
	size_t copiedSize = 0;

	do
	{
		/*
			Contextualize to the PT level
		*/
		PToV ctx = ContextualizeTable(currentTable, 
			PageSpaceMemory, address, startLevel, TABLE_LEVEL_PT, false);

		if (!ctx.virt)
		{
			DbgPrint("Failed to contextualize table\n");
			return false;
		}

		PTE* pte = &reinterpret_cast<PTE*>(ctx.virt)[va.pt];
		size_t currentCopySize = min(PAGE_SIZE - va.offset, shellcodeSize);

		PTE* originalPTE = &reinterpret_cast<PTE*>(
			GetTable(address, TABLE_LEVEL_PT))[va.pt];

		/*
			Check if we have already contextualized this entry or if
			we need to add a new custom mapping.
		*/
		if (pte->pfn == originalPTE->pfn)
		{
			/*
				Remove the global flag from the original PTE
				so that there are no TLB conflicts with
				our patch. Save this info to restore it
				when we are done.
			*/
			if (originalPTE->g)
			{
				GlobalPTE gPTE{ originalPTE, true };
				GlobalPTEs->Push(&gPTE);
				originalPTE->g = false;
			}

			void* buffer = AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE);
			if (!buffer)
			{
				DbgPrint("Failed to allocate buffer\n");
				ctx.Close();
				return false;
			}
			PageSpaceMemory->Push(buffer);

			void* page = PAGE_ALIGN(va.all);
			if (!page)
			{
				DbgPrint("Failed to get page to copy\n");
				ctx.Close();
				return false;
			}

			memcpy(buffer, page, PAGE_SIZE);
			memcpy(reinterpret_cast<uint8*>(buffer) + va.offset,
				reinterpret_cast<uint8*>(shellcode) + copiedSize, currentCopySize);

			pte->pfn = VirtToPFN(buffer);
			pte->g = false;
		}
		else
		{
			/*
				Another patch was already made here, just use
				that existing mapping.
			*/
			PToV result = PToV::PFNToVirt(pte->pfn);
			memcpy(reinterpret_cast<uint8*>(result.virt) + va.offset,
				reinterpret_cast<uint8*>(shellcode) + copiedSize, currentCopySize);
			result.Close();
		}

		ctx.Close();

		va.all += currentCopySize;
		copiedSize += currentCopySize;
		shellcodeSize -= currentCopySize;
	} while (shellcodeSize);

	return true;
}

/*
	Creates a page space for IDT shadowing.

	@return True if successful, false otherwise
*/
bool CreateIDTPageSpace()
{
	TransitionalCR3.all = __readcr3();
	TransitionalCR3.pcide1.cacheTLB = false;

	void* pml4 = AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE);
	if (!pml4)
	{
		DbgPrint("Failed to allocate new IDT page space PML4\n");
		return false;
	}

	PageSpaceMemory->Push(pml4);
	if (!ContextualizeTable(pml4, PageSpaceMemory, ModuleBase,
		ModuleSize, TABLE_LEVEL_PML4, TABLE_LEVEL_PT, false))
	{
		DbgPrint("Failed to map pages in custom table\n");
		return nullptr;
	}

	/*
		push interruptVector
		jmp [rip]
		address
	*/
	static uint8 deShellCode[16] =
	{
		0x6A, 0x00,
		0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	*reinterpret_cast<uint64*>(&deShellCode[8]) = 
		reinterpret_cast<uint64>(&InterruptDispatchGate);

	void* deHandler = GetHandlerAddress(INTERRUPT_VECTOR_DE);
	if (!deHandler || !PageSpacePatch(pml4, deHandler,
		deShellCode, sizeof(deShellCode), TABLE_LEVEL_PML4))
	{
		DbgPrint("Failed to perform DE handler page space patch\n");
		return false;
	}

	deHandler = reinterpret_cast<uint8*>(deHandler) + 2;

	/*
		push interruptVector
		jmp rel32
	*/
	static uint8 genericShellCode[7] =
	{
		0x6A, 0x00,
		0xE9, 0x00, 0x00, 0x00, 0x00
	};

	for (int i = 1; i < IDTEntries; ++i)
	{
		void* handler = GetHandlerAddress(i);
		if (!handler)
			continue;

		int rva = static_cast<int>(reinterpret_cast<uint64>(deHandler) - 
			(reinterpret_cast<uint64>(handler) + sizeof(genericShellCode)));

		*reinterpret_cast<char*>(&genericShellCode[1]) = static_cast<char>(i);
		*reinterpret_cast<int*>(&genericShellCode[3]) = rva;

		if (!PageSpacePatch(pml4, handler, genericShellCode, 
			sizeof(genericShellCode), TABLE_LEVEL_PML4))
		{
			DbgPrint("Failed to perform handler %d page space patch\n", i);
			return false;
		}
	}

	*reinterpret_cast<void**>(&EntryShellcode[3 + DEADLOCK_SIZE]) = MovCR3RCX;

	*reinterpret_cast<uint64*>(&EntryShellcode[0x29 + DEADLOCK_SIZE]) =
		reinterpret_cast<uint64>(&EnterModulePageSpace);

	*reinterpret_cast<void**>(&EntryShellcode[0x34 + DEADLOCK_SIZE]) = &StartInfo;
	*reinterpret_cast<void**>(&EntryShellcode[0x59 + DEADLOCK_SIZE]) = &NewIDTR;

	*reinterpret_cast<uint64*>(&EntryShellcode[0x82 + DEADLOCK_SIZE]) =
		reinterpret_cast<uint64>(&EntryHandler);

	if (!PageSpacePatch(pml4, reinterpret_cast<uint8*>(MovCR3RCX) + MovCR3RCXSize,
		EntryShellcode, sizeof(EntryShellcode), TABLE_LEVEL_PML4))
	{
		DbgPrint("Failed to perform mov cr3, rcx page space patch\n");
		return false;
	}

	/*
		cli
		jmp [rbp + 0x10]
	*/
	static uint8 externalCallReturnShellcode[] =
	{ 
		0xFA, 
		0xFF, 0x65, 0x10 
	};

	if (!PageSpacePatch(pml4, reinterpret_cast<uint8*>(MovCR3RSI) + MovCR3RSISize,
		externalCallReturnShellcode, sizeof(externalCallReturnShellcode), TABLE_LEVEL_PML4))
	{
		DbgPrint("Failed to perform mov cr3, rsi page space patch\n");
		return false;
	}

	TransitionalCR3.pfn = VirtToPFN(pml4);
	reinterpret_cast<PML4E*>(pml4)[SelfReferencingPML4Idx].pfn = TransitionalCR3.pfn;
	reinterpret_cast<PML4E*>(pml4)[SelfReferencingPML4Idx].xd = false;

	DbgPrint("New IDT page space PML4: 0x%p\n", pml4);
	DbgPrint("Transitional CR3: 0x%llx\n\n", TransitionalCR3.all);
	return true;
}

bool CreatePageSpaces()
{
	if (!NewIDTR.base)
	{
		DbgPrint("Please call CreatePageSpaces after CreateIDT\n");
		return false;
	}

	InitializeListHead(&ThreadInfoList);

	PageSpaceMemory = new Array(sizeof(void*));

	if (!PageSpaceMemory)
	{
		DbgPrint("Failed to allocate page space memory array\n");
		return false;
	}

	GlobalPTEs = new Array(sizeof(GlobalPTE));
	if (!GlobalPTEs)
	{
		CleanupPageSpaces();
		DbgPrint("Failed to allocate global PTEs memory array\n");
		return false;
	}

	/*
		Guarantees we are in the system process.
	*/
	KAPC_STATE state{ 0 };
	KeStackAttachProcess(reinterpret_cast<PRKPROCESS>(
		PsInitialSystemProcess), &state);
	
	void* pml4 = CreateModulePageSpace();
	if (!pml4)
	{
		KeUnstackDetachProcess(&state);
		CleanupPageSpaces();
		DbgPrint("Failed to create module page space\n");
		return false;
	}

	if (!CreateIDTPageSpace())
	{
		KeUnstackDetachProcess(&state);
		CleanupPageSpaces();
		DbgPrint("Failed to create IDT page space\n");
		return false;
	}

	KeUnstackDetachProcess(&state);
	return true;
}

CR3 CreateCustomCR3ThreadCopy()
{
	if (!ThreadInfoList.Blink ||
		ThreadInfoList.Blink == &ThreadInfoList)
	{
		DbgPrint("ThreadInfoList is invalid\n");
		return CR3{ 0 };
	}

	ThreadInfo* firstInfo = CONTAINING_RECORD(ThreadInfoList.Blink, ThreadInfo, list);
	if (!firstInfo || !firstInfo->customCR3.all)
	{
		DbgPrint("First inserted ThreadInfo is invalid\n");
		return CR3{ 0 };
	}

	void* newPML4 = AllocateContiguousMemory(PAGE_SIZE, PAGE_READWRITE);
	if (!newPML4)
	{
		DbgPrint("Failed to allocate new PML4\n");
		return CR3{ 0 };
	}

	PageSpaceMemory->Push(newPML4);

	PToV result = PToV::PFNToVirt(firstInfo->customCR3.pfn);
	if (!result.virt)
	{
		DbgPrint("Failed to convert PFN to virt\n");
		return CR3{ 0 };
	}

	memcpy(newPML4, result.virt, PAGE_SIZE);
	result.Close();

	CR3 newCR3{ firstInfo->customCR3 };
	newCR3.pfn = VirtToPFN(newPML4);

	reinterpret_cast<PML4E*>(newPML4)[SelfReferencingPML4Idx].pfn = newCR3.pfn;
	reinterpret_cast<PML4E*>(newPML4)[SelfReferencingPML4Idx].xd = false;

	return newCR3;
}

ThreadInfo* NewThreadInfo(CR3 customCR3)
{
	static volatile long threadInfoWriteLock = 0;

	ThreadInfo* info = new ThreadInfo
	{ 
		nullptr, nullptr, customCR3,
		nullptr, 0, 0
	};

	if (!info)
	{
		DbgPrint("Failed to allocate new thread info\n");
		return nullptr;
	}

	PToV result = PToV::PFNToVirt(customCR3.pfn);

	if (!ContextualizeTable(result.virt, PageSpaceMemory, ModuleBase,
		ModuleSize, TABLE_LEVEL_PML4, TABLE_LEVEL_PT, true))
	{
		result.Close();
		DbgPrint("Failed to synchronize pages in custom table\n");
		return nullptr;
	}

	result.Close();

	while (_interlockedbittestandset(&threadInfoWriteLock, 0))
	{
		Sleep(1);
	}

	InsertHeadList(&ThreadInfoList, &info->list);

	_interlockedbittestandreset(&threadInfoWriteLock, 0);

	return info;
}

ThreadInfo* FindCurrentThreadInfo()
{
	if (!ThreadInfoList.Flink)
		return nullptr;

	for (PLIST_ENTRY entry = ThreadInfoList.Flink;
		entry != &ThreadInfoList; entry = entry->Flink)
	{
		ThreadInfo* info = CONTAINING_RECORD(entry, ThreadInfo, list);
		if (info->kthread == GetCurrentThread())
			return info;
	}

	return nullptr;
}

/*
	Safely frees all thread info.
*/
void CleanupThreadInfo()
{
	if (!ThreadInfoList.Flink)
		return;

	for (PLIST_ENTRY entry = ThreadInfoList.Flink; 
		entry != &ThreadInfoList; entry = entry->Flink)
	{
		ThreadInfo* info = CONTAINING_RECORD(entry, ThreadInfo, list);
		if (!info)
			continue;

		if (info->kthread)
			while (!info->notRunning && info->kthread != GetCurrentThread())
				Sleep(10);

		FreePool(info);
	}

	InitializeListHead(&ThreadInfoList);
}

void CleanupPageSpaces()
{
	CleanupThreadInfo();

	for (uint64 i = 0; i < PageSpaceMemory->size; ++i)
	{
		void* allocation = ARRAY_GET(void*, PageSpaceMemory, i);
		if (!allocation)
			continue;

		FreeContiguousMemory(allocation);
	}

	for (uint64 i = 0; i < GlobalPTEs->size; ++i)
	{
		GlobalPTE& gPTE = ARRAY_GET(GlobalPTE, GlobalPTEs, i);
		if (!gPTE.pte || !gPTE.global)
			continue;

		gPTE.pte->g = true;
	}

	if (GlobalPTEs)
		delete GlobalPTEs;

	if(PageSpaceMemory)
		delete PageSpaceMemory;
}

void* PFNToVirtInPageSpace(uint64 pfn)
{
	ThreadInfo* info = FindCurrentThreadInfo();
	if (!info)
		return nullptr;

	CR3 cr3{ __readcr3() };
	if (cr3.all != info->customCR3.all)
		return nullptr;

	PML4E* pml4 = PML4V;
	pml4[MapIndex].pfn = pfn;

	void* virt = PDPTV(MapIndex);
	FlushCaches(virt);

	return virt;
}
```

`Files/PageSpace.h`:

```h
#pragma once
#include "CIA32.h"
#include "Array.h"
#include "ROPGadgets.h"

struct ThreadInfo
{
	LIST_ENTRY list;
	CR3 customCR3;
	void* kthread;
	volatile long long notRunning;
	struct
	{
		uint64 rsi;
		uint64 rbp;
		void* returnAddress;
		IDTR idtr;
		CR3 cr3;
		InterruptFrame frame;
	} ExternalReturnInfo;
};

struct ThreadStartInfo
{
	void* context;
	void* startAddress;
	volatile long long lock;
	ThreadInfo* threadInfo;

	/*
		This won't change after initialization.
		Here purely for convenience.
	*/
	uint32 KThreadOffset;
};

/*
	Creates the page spaces for the covert threads.

	@return True if successful, false otherwise
*/
bool CreatePageSpaces();

/*
	Creates a custom CR3 copy for a new thread.

	@return A CR3 copy for a new thread
*/
CR3 CreateCustomCR3ThreadCopy();

/*
	Creates new thread info for a new thread.

	@param customCR3 - The custom CR3 for the new thread info

	@return A pointer to a ThreadInfo structure if successful, nullptr otherwise
*/
ThreadInfo* NewThreadInfo(CR3 customCR3);

/*
	Finds the current thread's ThreadInfo.

	@return A pointer to a ThreadInfo structure if successful, nullptr otherwise
*/
extern "C" ThreadInfo* FindCurrentThreadInfo();

/*
	Safely frees all memory allocated for the page spaces.
*/
extern "C" void CleanupPageSpaces();

/*
	Converts a PFN to a virtual address. Only useable within the page space.

	@param pfn - The PFN to convert

	@return The converted virtual address
*/
extern "C" void* PFNToVirtInPageSpace(uint64 pfn);

/*
	Converts a physical address to a virtual address. Only useable within the page space.

	@param phys - The physical address to convert

	@return The converted virtual address
*/
inline void* PhysToVirtInPageSpace(uint64 phys)
{
	uint64 offset = phys & 0xFFF;
	return reinterpret_cast<uint8*>(
		PFNToVirtInPageSpace(phys >> 12)) + offset;
}

/*
	The code that actually enters the module page space for newly created covert threads.
*/
extern "C" void EnterModulePageSpace(void);

/*
	Safely exits from the DriverEntry function once covert threads have been created.

	@param addressOfReturnAddress - The address of the return address for DriverEntry
	@param status - The NTSTATUS to return for the DriverEntry function
*/
extern "C" __declspec(noreturn) void SafeExit(void** addressOfReturnAddress, NTSTATUS status);

extern "C" inline void* NewModulePTEStart = nullptr;
extern "C" inline void* ModuleBase = nullptr;
extern "C" inline size_t ModuleSize = 0;
extern "C" inline CR3 TransitionalCR3{ 0 };
extern "C" inline CR3 SystemCR3{ 0 };
extern "C" inline uint64 MapIndex = 0;

inline ThreadStartInfo StartInfo{ 0 };
inline LIST_ENTRY ThreadInfoList{ 0 };
extern "C" inline volatile long long DriverEntryExitSync = 0;

/*
	Deadlock for debugging with GDB.
*/
#define USE_DEADLOCK 0
#if (USE_DEADLOCK == 1)
#define DEADLOCK_SIZE 4
#else
#define DEADLOCK_SIZE 0
#endif

/*
	cli
	movabs rcx, 0xdeadbeefcafebeef
	cmp qword ptr [rsp - 8], rcx
	jz Continue
	xor rcx, rcx
	mov cx, ss
	push rcx
	lea rcx, [rsp + 8]
	push rcx
	pushfq
	xor rcx, rcx
	mov cx, cs
	push rcx
	movabs rcx, 0xdeadbeefcafebeef
	push rcx
	movabs rcx, 0xdeadbeefcafebeef
	push [rcx + 0x8]
	push [rcx]
	push rdx
	mov rax, [rcx + 0x18]
	push [rax + 0x10]
	xor rdx, rdx
	mov edx, dword ptr [rcx + 0x20]
	mov rdx, gs:[rdx]
	mov [rax + 0x18], rdx
	movabs rax, 0xdeadbeefcafebeef
	sub rsp, 0x10
	mov dx, word ptr [rax]
	mov word ptr [rsp], dx
	mov rdx, qword ptr [rax + 2]
	mov qword ptr [rsp + 2], rdx
	lock btr qword ptr [rcx + 0x10], 0

Continue:
	jmp [rip]
	0xdeadbeefcafebeef
*/
inline uint8 EntryShellcode[] =
{
	0xFA, 
#if (USE_DEADLOCK == 1)
	0xF3, 0x90, 0xEB, 0xFC, 
#endif
	
	0x48, 0xB9, 0xEF, 0xBE, 0xFE, 0xCA, 0xEF, 0xBE, 0xAD, 0xDE, 0x48, 0x39, 0x4C, 0x24, 0xF8, 0x74, 0x6A, 0x48, 0x31, 0xC9, 0x66, 0x8C, 0xD1, 0x51, 0x48, 0x8D, 0x4C, 0x24, 0x08, 0x51, 0x9C, 0x48, 0x31, 0xC9, 0x66, 0x8C, 0xC9, 0x51, 0x48, 0xB9, 0xEF, 0xBE, 0xFE, 0xCA, 0xEF, 0xBE, 0xAD, 0xDE, 0x51, 0x48, 0xB9, 0xEF, 0xBE, 0xFE, 0xCA, 0xEF, 0xBE, 0xAD, 0xDE, 0xFF, 0x71, 0x08, 0xFF, 0x31, 0x52, 0x48, 0x8B, 0x41, 0x18, 0xFF, 0x70, 0x10, 0x48, 0x31, 0xD2, 0x8B, 0x51, 0x20, 0x65, 0x48, 0x8B, 0x12, 0x48, 0x89, 0x50, 0x18, 0x48, 0xB8, 0xEF, 0xBE, 0xFE, 0xCA, 0xEF, 0xBE, 0xAD, 0xDE, 0x48, 0x83, 0xEC, 0x10, 0x66, 0x8B, 0x10, 0x66, 0x89, 0x14, 0x24, 0x48, 0x8B, 0x50, 0x02, 0x48, 0x89, 0x54, 0x24, 0x02, 0xF0, 0x48, 0x0F, 0xBA, 0x71, 0x10, 0x00, 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,

	0xEF, 0xBE, 0xFE, 0xCA, 0xEF, 0xBE, 0xAD, 0xDE,
};
```

`Files/PageSpaceASM.asm`:

```asm
extern CleanupPageSpaces : proc
extern FreeIDT : proc
extern PFNToVirtInPageSpace : proc
extern FindCurrentThreadInfo : proc

extern PsTerminateSystemThreadAddress : qword

extern NewModulePTEStart : qword
extern ModuleSize : qword

extern TransitionalCR3 : qword
extern SystemCR3 : qword
extern NewIDTR : fword
extern OldIDTR : fword
extern SelfReferencingPML4Idx : qword

extern DriverEntryExitSync : qword
extern MovCR3RAXGadget : qword
extern IretqGadget : qword
extern MovRDXMemoryRAXGadget : qword
extern PopRAXGadget : qword

Array struct
	buffer dq ?
	typeSize dq ?
	capacity dq ?
	arraySize dq ?
Array ends

.const
	STATUS_SUCCESS equ 0

.data
	ThreadCount dd 0
	Init db 0

.code

	ChangeModuleExecutionPermissions proc
		mov rax, NewModulePTEStart
		mov r8, ModuleSize
		shr r8, 12
		xor rdx, rdx

	ModifyPTE:
		lea r9, [rax + rdx * 8]

		test rcx, 1
		jz ResetBit
		bts qword ptr [r9], 63
		jmp Continue
	ResetBit:
		btr qword ptr [r9], 63

	Continue:
		inc rdx
		cmp rdx, r8
		jne ModifyPTE

		mov rax, cr4
		xor rax, 10000000b
		mov cr4, rax
		xor rax, 10000000b
		mov cr4, rax
		wbinvd
		ret
	ChangeModuleExecutionPermissions endp

	EnterModulePageSpace proc
		push rax

		lea rax, [ThreadCount]
		mov ecx, 1
		lock xadd dword ptr [rax], ecx
		sti
		cmp rcx, 0
		jnz NoFixups

	WaitForExit:
		mov rax, qword ptr [DriverEntryExitSync]
		test rax, rax
		jz WaitForExit

		cli
		mov rcx, 1
		call ChangeModuleExecutionPermissions
		lock inc byte ptr [Init]
		sti

	NoFixups:
	WaitForFixup:
		mov al, byte ptr [Init]
		test al, al
		jz WaitForFixup

		pop rax
		sub rsp, 28h
		call rax
		add rsp, 28h

		cli
		xor r8, r8
		lock dec ThreadCount
		jnz NoRestore
		
		xor rcx, rcx
		call ChangeModuleExecutionPermissions

		mov r8, 1

	NoRestore:
		mov rax, TransitionalCR3
		mov cr3, rax
		lidt fword ptr [OldIDTR]
		test r8, r8
		jz TerminateThread

		mov rax, SystemCR3
		mov cr3, rax
		
		sti
		sub rsp, 28h
		call FreeIDT
		call CleanupPageSpaces
		
		mov rcx, STATUS_SUCCESS
		call [PsTerminateSystemThreadAddress]
		add rsp, 28h
		ret

	TerminateThread:
		xor rax, rax
		mov ax, ss
		push rax
		lea rax, [rsp + 8]
		push rax
		pushfq
		bts qword ptr [rsp], 9
		xor rax, rax
		mov ax, cs
		push rax
		mov rax, PsTerminateSystemThreadAddress
		push rax
		mov rax, IretqGadget
		push rax
		mov rax, MovCR3RAXGadget
		push rax
		mov rax, MovRDXMemoryRAXGadget
		push rax

		sub rsp, 20h
		call FindCurrentThreadInfo
		add rsp, 20h

		lea rdx, [rax + 20h]
		mov rax, SystemCR3
		mov rcx, STATUS_SUCCESS
		
		ret

	EnterModulePageSpace endp

	SafeExit proc
		mov rsp, rcx
		mov rax, 1
		mov rcx, PopRAXGadget
		push rdx
		push rcx
		lea rdx, [DriverEntryExitSync]
		
		mov rcx, MovRDXMemoryRAXGadget
		jmp rcx

	SafeExit endp

end
```

`Files/ROPGadgets.cpp`:

```cpp
#include <intrin.h>

#include "ROPGadgets.h"
#include "Utils.h"
#include "CPE.h"

/*
	You can scan more modules than just ntoskrnl.
	In fact, this is probably a good idea for
	randomization purposes.
*/
bool CollectROPGadgets()
{
	void* ntoskrnl = FindKernelBase();

	if (!ntoskrnl)
		return false;
	
	DbgPrint("ntoskrnl: 0x%p\n", ntoskrnl);

	auto nt = NT_HEADERS(ntoskrnl);
	auto section = IMAGE_FIRST_SECTION(nt);

	uint8* textSection = reinterpret_cast<uint8*>(ntoskrnl);
	size_t textSectionSize = 0;

	for (uint16 i = 0; i < nt->FileHeader.NumberOfSections; ++i, ++section)
	{
		if (strcmp(reinterpret_cast<char*>(section->Name), ".text") == 0)
		{
			textSection += section->VirtualAddress;
			textSectionSize = section->Misc.VirtualSize;
			break;
		}
	}

	if (!textSection)
		return false;

	DbgPrint("ntoskrnl .text: 0x%p\n", textSection);

	/*
		mov cr3, rax
		ret
	*/
	MovCR3RAXGadget = FindPattern(textSection, "\x0F\x22\xD8\xC3", "xxxx", textSectionSize);
	if (!MovCR3RAXGadget)
		return false;

	DbgPrint("mov cr3, rax gadget: 0x%p\n", MovCR3RAXGadget);

	/*
		pop rax
		ret
	*/
	PopRAXGadget = FindPattern(textSection, "\x58\xC3", "xx", textSectionSize);
	if (!PopRAXGadget)
		return false;

	DbgPrint("pop rax gadget: 0x%p\n", PopRAXGadget);

	/*
		mov cr3, rcx
	*/
	MovCR3RCX = FindPattern(textSection, "\x0F\x22\xD9", "xxx", textSectionSize);
	if (!MovCR3RCX)
		return false;

	DbgPrint("mov cr3, rcx: 0x%p\n", MovCR3RCX);

	/*
		pop rcx
		ret
	*/
	PopRCXGadget = FindPattern(textSection, "\x59\xC3", "xx", textSectionSize);
	if (!PopRCXGadget)
		return false;

	DbgPrint("pop rcx gadget: 0x%p\n", PopRCXGadget);

	/*
		pop rdx
		ret
	*/
	PopRDXGadget = FindPattern(textSection, "\x5A\xC3", "xx", textSectionSize);
	if (!PopRDXGadget)
		return false;

	DbgPrint("pop rdx gadget: 0x%p\n", PopRDXGadget);

	/*
		cli
		ret
	*/
	CLIGadget = FindPattern(textSection, "\xFA\xC3", "xx", textSectionSize);
	if (!CLIGadget)
		return false;

	DbgPrint("cli gadget: 0x%p\n", CLIGadget);

	/*
		popfq
		ret
	*/
	PopfqGadget = FindPattern(textSection, "\x9D\xC3", "xx", textSectionSize);
	if (!PopfqGadget)
		return false;

	DbgPrint("popfq gadget: 0x%p\n", PopfqGadget);

	/*
		iretq
	*/
	IretqGadget = FindPattern(textSection, "\x48\xCF", "xx", textSectionSize);
	if (!IretqGadget)
		return false;

	DbgPrint("iretq gadget: 0x%p\n", IretqGadget);

	/*
		mov cr3, rsi
	*/
	MovCR3RSI = FindPattern(textSection, "\x0F\x22\xDE", "xxx", textSectionSize);
	if (!MovCR3RSI)
		return false;

	DbgPrint("mov cr3, rsi: 0x%p\n", MovCR3RSI);

	/*
		mov [rdx], rax
		ret
	*/
	MovRDXMemoryRAXGadget = FindPattern(textSection, 
		"\x48\x89\x02\xC3", "xxxx", textSectionSize);

	if (!MovRDXMemoryRAXGadget)
		return false;

	DbgPrint("mov [rdx], rax gadget: 0x%p\n\n", MovRDXMemoryRAXGadget);

	return true;
}
```

`Files/ROPGadgets.h`:

```h
#pragma once
#include "CIA32.h"

/*
	Collects the addresses of all return oriented programming (ROP) gadgets.

	@return True if all ROP gadgets were found, false otherwise
*/
bool CollectROPGadgets();

extern "C" inline void* MovCR3RAXGadget = nullptr;
extern "C" inline void* PopRAXGadget = nullptr;
constexpr size_t MovCR3RCXSize = 3;
extern "C" inline void* MovCR3RCX = nullptr;
extern "C" inline void* PopRCXGadget = nullptr;
extern "C" inline void* PopRDXGadget = nullptr;
extern "C" inline void* CLIGadget = nullptr;
extern "C" inline void* PopfqGadget = nullptr;
extern "C" inline void* IretqGadget = nullptr;
constexpr size_t MovCR3RSISize = 3;
extern "C" inline void* MovCR3RSI = nullptr;
extern "C" inline void* MovRDXMemoryRAXGadget = nullptr;
```

`Files/Utils.cpp`:

```cpp
#include <intrin.h>

#include "Utils.h"
#include "CPE.h"
#include "CIA32.h"
#include "PageSpace.h"

void* FindModuleStart(void* address)
{
	if (!address)
		return nullptr;

	uint8* start = reinterpret_cast<uint8*>(
		PAGE_ALIGN(address));

	do
	{
		start -= PAGE_SIZE;
	} while (reinterpret_cast<IMAGE_DOS_HEADER*>(start)->e_magic != IMAGE_DOS_SIGNATURE ||
		reinterpret_cast<IMAGE_DOS_HEADER*>(start)->e_lfanew >= (PAGE_SIZE - sizeof(uint32)) ||
		reinterpret_cast<IMAGE_NT_HEADERS64*>(start + reinterpret_cast<IMAGE_DOS_HEADER*>(start)->e_lfanew)->Signature != IMAGE_PE_SIGNATURE);
	
	return start;
}

void* FindKernelBase()
{
	void* base = nullptr;
	return RtlPcToFileHeader(reinterpret_cast<void*>(
		__readmsr(MSR_LSTAR)), &base);
}

/*
	Credits to BTBD on GitHub for these two functions.
*/

/*
	Checks if the pattern and mask are a match.

	@param base - The base address to start pattern matching
	@param pattern - The pattern to use
	@param mask - The mask for the pattern

	@return True if the pattern and mask match, false otherwise
*/
bool CheckMask(char* base, const char* pattern, const char* mask)
{
	for (; *mask; ++base, ++pattern, ++mask)
		if (*mask == 'x' && *base != *pattern)
			return false;

	return true;
}

void* FindPattern(void* base, const char* pattern,
	const char* mask, uintn size)
{
	size -= strlen(mask);

	auto address = reinterpret_cast<char*>(base);
	for (uintn i = 0; i <= size; ++i, ++address)
		if (CheckMask(address, pattern, mask))
			return address;

	return nullptr;
}

void* ResolveRVA(void* base, uint8 instSize, uint8 rvaSize)
{
	auto rvaStart = reinterpret_cast<uint8*>(base) + (instSize - rvaSize);
	auto resolvedAddress = reinterpret_cast<uint8*>(base) + instSize;

	switch (rvaSize)
	{
	case 4:
		resolvedAddress += *reinterpret_cast<int*>(rvaStart);
		break;
	case 2:
		resolvedAddress += *reinterpret_cast<short*>(rvaStart);
		break;
	case 1:
		resolvedAddress += *reinterpret_cast<char*>(rvaStart);
		break;
	default:
		return nullptr;
	}

	return resolvedAddress;
}

bool FindKThreadOffset()
{
	for (uint32 i = 0; i < PAGE_SIZE; i += 8)
	{
		void* value = reinterpret_cast<void*>(__readgsqword(i));
		if (KeGetCurrentThread() == value)
		{
			DbgPrint("KThread Offset: 0x%lx\n", i);
			StartInfo.KThreadOffset = i;
			return true;
		}
	}

	return false;
}

uint32 KProcessIdx = 0;
bool FindKProcessIdx()
{
	void** kthread = reinterpret_cast<void**>(GetCurrentThread());
	for (uint32 i = 0; i < (PAGE_SIZE / sizeof(void*)); ++i)
	{
		void* value = kthread[i];
		if (IoGetCurrentProcess() == value)
		{
			DbgPrint("KProcess Offset: 0x%llx\n", (i * sizeof(void*)));
			KProcessIdx = i;
			return true;
		}
	}

	return false;
}

uint32 DirectoryTableBaseIdx = 0;
bool FindDirectoryTableBaseIdx()
{
	uint64* kprocess = reinterpret_cast<uint64*>(GetGurrentProcess());
	for (uint32 i = 0; i < (PAGE_SIZE / sizeof(uint64)); ++i)
	{
		uint64 value = kprocess[i];
		if (CR3{ __readcr3() }.pfn == CR3{ value }.pfn)
		{
			DbgPrint("DirectoryTableBase Offset: 0x%llx\n\n", (i * sizeof(uint64)));
			DirectoryTableBaseIdx = i;
			return true;
		}
	}

	return false;
}

/*
	Dynamic finding of offsets.
*/
bool FindAllOffsets()
{
	if (!FindKThreadOffset())
		return false;

	if (!FindKProcessIdx())
		return false;

	if (!FindDirectoryTableBaseIdx())
		return false;

	return true;
}

void* GetCurrentThread()
{
	return reinterpret_cast<void*>(__readgsqword(StartInfo.KThreadOffset));
}

void* GetGurrentProcess()
{
	return reinterpret_cast<void**>(GetCurrentThread())[KProcessIdx];
}

uint64 GetCurrentDirectoryTable()
{
	return reinterpret_cast<uint64*>(GetGurrentProcess())[DirectoryTableBaseIdx];
}

void Sleep(long long milliseconds)
{
	LARGE_INTEGER delay{ 0 };
	delay.QuadPart = milliseconds * -10000;

	KeDelayExecutionThread(KernelMode, false, &delay);
}
```

`Files/Utils.h`:

```h
#pragma once
#include "CTypes.h"

/*
	Finds a module's PE header from an address within the module.

	@param address - An address within the module

	@return The module's PE header address if successful, nullptr otherwise
*/
void* FindModuleStart(void* address);

/*
	Finds ntoskrnl's PE header.

	@return ntoskrnl's PE header address if successful, nullptr otherwise
*/
void* FindKernelBase();

/*
	Finds an address matching the pattern and mask specified.

	@param base - The base address to start searching at
	@param pattern - The pattern to search for
	@param mask - The mask for the pattern
	@param size - The size to search from the base

	@return The address matching the pattern and mask if successful, nullptr otherwise
*/
void* FindPattern(void* base, const char* pattern,
	const char* mask, uintn size);

/*
	Resolves a rip-relative virtual address (RVA) to an absolute virtual address.

	@param base - The base address to use for the absolute virtual address
	@param instSize - The size of the instruction
	@param rvaSize - The size of the RVA

	@return The absolute virtual address if successful, nullptr otherwise
*/
void* ResolveRVA(void* base, uint8 instSize, uint8 rvaSize = 4);

/*
	Finds the KTHREAD* CurrentThread offset within the KPRCB.

	@return True if the offset was found, false otherwise
*/
bool FindKThreadOffset();

/*
	Finds the KPROCESS* Process index within the KTHREAD.

	@return True if the index was found, false otherwise
*/
bool FindKProcessIdx();

/*
	Finds the DirectoryTableBase index within the KPROCESS.

	@return True if the index was found, false otherwise
*/
bool FindDirectoryTableBaseIdx();

/*
	Finds all offsets and indices needed from the NT structures.

	@return True if all offsets and indices were found, false otherwise
*/
bool FindAllOffsets();

/*
	Gets the current thread.

	@return The address of the current thread's KTHREAD
*/
void* GetCurrentThread();

/*
	Gets the current process.

	@return The address of the current process' KPROCESS
*/
void* GetGurrentProcess();

/*
	Gets the current directory table base.

	@return The current directory table base.
*/
extern "C" uint64 GetCurrentDirectoryTable();

/*
	Sleeps the current thread for the specified number of milliseconds.

	@param milliseconds - The number of milliseconds to sleep for
*/
void Sleep(long long milliseconds);

/*
	Function exported by ntoskrnl.
*/
extern "C" void* RtlPcToFileHeader(void* PcValue, void** BaseOfImage);
```

`README.md`:

```md
# CovertThread
This project is a demonstration of how one can create system threads on Windows that are almost completely transparent to the system (i.e., they do not appear to be malicious or from an unknown source). Inspired by [this similar project](https://github.com/thesecretclub/callout-poc), CovertThread aims to extend the capabilities by removing an entire loaded module from the system page tables and preventing individual thread introspection via non-maskable interrupts (NMIs). The project demonstrates an example of how to initialize the custom address space (which includes a fully controlled interrupt descriptor table (IDT)) and how one can create threads from both outside and within this new address space. This address space allows for direct function execution with no macros or additional function calls necessary, making it exeptionally easy to use.

## Write-up
I intend to release a detailed write-up with figures and in-depth explanations of design choices in the near future.
 

```