Project Path: arc_gmh5225_Diglett_l9kmap7a

Source Tree:

```txt
arc_gmh5225_Diglett_l9kmap7a
├── Diglett.sln
├── DiglettClient
│   ├── Client.cpp
│   ├── Client.h
│   ├── DiglettClient.vcxproj
│   ├── DiglettClient.vcxproj.filters
│   └── InputParser.h
├── DiglettDriver
│   ├── Common.h
│   ├── DiglettDriver.vcxproj
│   ├── DiglettDriver.vcxproj.filters
│   ├── Draw.cpp
│   ├── Draw.h
│   ├── Driver.cpp
│   ├── Driver.h
│   ├── Globals.h
│   ├── Hook.h
│   ├── PEHdr.h
│   ├── PEHdr2.h
│   ├── SysCall.asm
│   ├── Thread.cpp
│   ├── Thread.h
│   ├── Utility.cpp
│   ├── Utility.h
│   └── asmstubs.h
├── Diglettoutput.png
├── README.md
└── diglett.png

```

`Diglett.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31829.152
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Diglett", "DiglettDriver\DiglettDriver.vcxproj", "{A2D95A16-9A85-4061-B474-D77A252EBCE2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DiglettClient", "DiglettClient\DiglettClient.vcxproj", "{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM.ActiveCfg = Debug|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM.Build.0 = Debug|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM.Deploy.0 = Debug|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM64.Build.0 = Debug|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x64.ActiveCfg = Debug|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x64.Build.0 = Debug|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x64.Deploy.0 = Debug|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x86.ActiveCfg = Debug|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x86.Build.0 = Debug|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Debug|x86.Deploy.0 = Debug|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM.ActiveCfg = Release|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM.Build.0 = Release|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM.Deploy.0 = Release|ARM
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM64.ActiveCfg = Release|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM64.Build.0 = Release|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|ARM64.Deploy.0 = Release|ARM64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x64.ActiveCfg = Release|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x64.Build.0 = Release|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x64.Deploy.0 = Release|x64
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x86.ActiveCfg = Release|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x86.Build.0 = Release|Win32
		{A2D95A16-9A85-4061-B474-D77A252EBCE2}.Release|x86.Deploy.0 = Release|Win32
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Debug|ARM.ActiveCfg = Debug|Win32
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Debug|ARM64.ActiveCfg = Debug|Win32
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Debug|x64.ActiveCfg = Debug|x64
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Debug|x64.Build.0 = Debug|x64
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Debug|x64.Deploy.0 = Debug|x64
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Debug|x86.ActiveCfg = Debug|Win32
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Debug|x86.Build.0 = Debug|Win32
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Release|ARM.ActiveCfg = Release|Win32
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Release|ARM64.ActiveCfg = Release|Win32
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Release|x64.ActiveCfg = Release|x64
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Release|x64.Build.0 = Release|x64
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Release|x86.ActiveCfg = Release|Win32
		{A65B5854-74F5-4C5D-8F4F-ECE6ACAAEAA4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {353E8AC0-8867-4B77-A0C5-C2DFB8974CDC}
	EndGlobalSection
EndGlobal

```

`DiglettClient/Client.cpp`:

```cpp
#include <Windows.h>
#include <algorithm>
#include <iostream>

#include "../DiglettDriver/Common.h"
#include "InputParser.h"
#include "Client.h"

int main(int argc, char** argv) {
	std::cout << "Opening handle to Psched device object...\n\n";
	// open handle to device
	HANDLE hDevice = CreateFile(L"\\\\.\\NUL", GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
	if (hDevice == INVALID_HANDLE_VALUE) {
		Logger(LOGLVL::ERR, "Failed to open handle...");
		std::cout << "GetLastError():  " << std::hex << GetLastError() << std::endl;
		system("pause");
		return 1;
	}
	
	bool loop = true;
	//std::string line;
	char line[MAX_LINE_LEN];

	while (loop) {
		std::cout << "DIGLETT> ";
		std::cin.clear();
		std::cin.getline(line, MAX_LINE_LEN);
		
		loop = CmdHandler(hDevice, line);
	}
	
	CloseHandle(hDevice);
	Logger(LOGLVL::INFO, "Handle to driver closed.");
	system("pause");
	return 0;
}

void OutputRequest(PMD_MODULE_DATA data)
{
	std::cout << "\nArguments Sent: " << std::endl;
	std::cout << "\tisAddr: " << data->isAddr << std::endl;
	std::cout << "\tAddress: 0x" << std::hex << data->address << std::endl;
	std::cout << "\tSize: 0x" << std::hex << data->size << std::endl;
	std::cout << "\tmoduleName: " << data->moduleName << std::endl;
}

void OutputRequest(PECHO_DATA echoData)
{
	std::cout << "\nArguments Sent: " << std::endl;
	std::cout << "\tMessage: " << echoData->strEcho << std::endl;
}

bool CmdHandler(HANDLE hDevice, char* line) {
	MD_MODULE_DATA data = {};
	ECHO_DATA echoData = {};
	DWORD returned = 0;
	BOOL success = false;
	InputParser input(line);
	InputParser::OP_RESULT parserResult;

	bool dumpCmd = input.CheckCmd("dump");
	bool helpCmd = input.CheckCmd("help");
	bool echoCmd = input.CheckCmd("echo");
	bool exitCmd = input.CheckCmd("exit");
	bool fastIoCmd = input.CheckCmd("fastio");

	bool modFlag = input.CmdOptionExists("-m");
	bool addrFlag = input.CmdOptionExists("-a");
	bool sizeFlag = input.CmdOptionExists("-l");

	if (helpCmd) {
		std::cout << "\t\t" << "dump " << " " << "[-a <address> -l <length>] | [-m <module_name>]" << std::endl;
		std::cout << "\t\t" << "echo " << " " << "[-m <message>]" << std::endl;
		std::cout << "\t\t" << "exit " << std::endl;
		return PROMPT;
	}
	else if (dumpCmd)
	{
		// dump for address and size
		if (addrFlag && sizeFlag && !modFlag) {
			std::string address = input.GetCmdOption("-a");
			std::string size = input.GetCmdOption("-l");
			parserResult = InputParser::IsAddressValid(address);
			if (!parserResult) {
				// make space for the null char
				size_t length = address.length() + 1 - 2;
				char* pAddr = new char[length];
				strcpy_s(pAddr, length, address.c_str() + 2);
				UINT64 baseAddr = input.ConvertToU64(pAddr, length);
				parserResult = input.IsLengthValid(baseAddr ,size);
				if (!parserResult)
				{
					length = size.length() + 1 - 2;
					char* pAddr2 = new char[length];
					strcpy_s(pAddr2, length, size.c_str() + 2);
					UINT64 len = input.ConvertToU64(pAddr2, length);
					data.isAddr = true;
					data.address = baseAddr;
					data.size = len;
					Logger(LOGLVL::INFO, "Sending dump request with:");
					OutputRequest(&data);
					//success = DeviceIoControl(hDevice, IOCTL_DUMP_KERNEL_MODULE, &data, sizeof(data), nullptr, 0, &returned, nullptr);
					success = true;
					if (success)
						Logger(LOGLVL::INFO, "Dump request succeeded.\n");
					else
						Logger(LOGLVL::ERR, "Dump request failed!\n");
					return PROMPT;
				} else {
					Logger(parserResult);
					return PROMPT;
				}
			} else {
				Logger(parserResult);
				return PROMPT;
			}
		}
		// dump for module name
		else if (modFlag && !addrFlag && !sizeFlag)
		{
			std::string modName = input.GetCmdOption("-m");
			strcpy_s(data.moduleName, MAX_NAME_LENGTH ,modName.c_str());
			OutputRequest(&data);
			success = DeviceIoControl(hDevice, IOCTL_ECHO_REQUEST, &data, sizeof(data), nullptr, 0, &returned, nullptr);
			success = true;
			if (success)
				Logger(LOGLVL::INFO, "Dump request succeeded.\n");
			else
				Logger(LOGLVL::ERR, "Dump request failed!\n");
			return PROMPT;
		}
		else {
			Logger(LOGLVL::INFO, "Usage: dump [-a <address> -l <length>] | [-m <module_name>]");
			return PROMPT;
		}
	}
	else if (echoCmd && modFlag)
	{
		std::string message = input.GetCmdOption("-m");
		strcpy_s(echoData.strEcho, MAX_NAME_LENGTH, message.c_str());
		OutputRequest(&echoData);
		success = DeviceIoControl(hDevice, IOCTL_ECHO_REQUEST, &echoData, sizeof(echoData), nullptr, 0, &returned, nullptr);
		std::cout << "GetLastError(): 0x" << std::hex << GetLastError() << std::endl;
		if (success)
			Logger(LOGLVL::INFO, "Dump request succeeded.\n");
		else
			Logger(LOGLVL::ERR, "Dump request failed!\n");
		return PROMPT;
	}
	else if (fastIoCmd)
	{
		Logger(LOGLVL::INFO, "Attempting fastio!\n");
		success = DeviceIoControl(hDevice, IOCTL_ECHO_REQUEST, nullptr, 0, nullptr, 0, nullptr, nullptr);
		std::cout << "GetLastError(): 0x" << std::hex << GetLastError() << std::endl;
		return PROMPT;
	}
	else if (exitCmd)
	{
		return EXIT;
	}
	else {
		Logger(LOGLVL::WARN, "Unrecognized command, use help for commands.");
		return PROMPT;
	}
	
}

void Logger(LOGLVL LogLvl, const char* message) {
	switch (LogLvl)
	{
	case LOGLVL::INFO:
		std::cout << "\n\n" << CLIENT_NAME << " [INFO] " << message << std::endl << std::endl;
		break;
	case LOGLVL::WARN:
		std::cout << "\n\n" << CLIENT_NAME << " [WARN] " << message << std::endl << std::endl;
		break;
	case LOGLVL::ERR:
		std::cout << "\n\n" << CLIENT_NAME << " [ERROR] " << message << std::endl << std::endl;
		break;
	default:
		break;
	}
}

void Logger(InputParser::OP_RESULT result) {
	switch (result)
	{
	case InputParser::OP_SUCCESS:
		break;
	case InputParser::INVALID_ADDR:
		Logger(LOGLVL::WARN, "Invalid address given, expecting kernel address in range 0xFFFF0000_00000000 - 0xFFFFFFFF_FFFFFFFF");
		break;
	case InputParser::INVALID_HEX:
		Logger(LOGLVL::WARN, "Invalid hex value given, use format 0xDEADBEEFDEADBEEF");
		break;
	case InputParser::INVALID_SIZE:
		Logger(LOGLVL::WARN, "Size is outside of kernel range 0xFFFF0000_00000000 - 0xFFFFFFFF_FFFFFFFF");
		break;
	case InputParser::ERR_OVERFLOW:
		Logger(LOGLVL::WARN, "Address arithmetic caused overflow!  Invalid range.");
		break;
	default:
		break;
	}
}
```

`DiglettClient/Client.h`:

```h
#pragma once
#define CLIENT_NAME "[DIGLETT] "

enum class LOGLVL {
    INFO,
    WARN,
    ERR
};

void OutputRequest(PMD_MODULE_DATA data);
bool CmdHandler(HANDLE hDevice, char* line);
void Logger(LOGLVL LVL, const char* message);
void Logger(InputParser::OP_RESULT result);
```

`DiglettClient/DiglettClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{a65b5854-74f5-4c5d-8f4f-ece6acaaeaa4}</ProjectGuid>
    <RootNamespace>MemoryDumperClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.22000.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Client.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Client.h" />
    <ClInclude Include="InputParser.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DiglettClient/DiglettClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Client.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="InputParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Client.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DiglettClient/InputParser.h`:

```h
#pragma once


#include <vector>
#include <string>
#include <sstream>
#include <regex>

#define MAX_LINE_LEN 60
#define PROMPT true;
#define EXIT false;

/// <summary>
/// 
/// </summary>
class InputParser {
public:
    std::vector<UINT64> u64Values;

    enum OP_RESULT {
        OP_SUCCESS,
        INVALID_ADDR,
        INVALID_HEX,
        INVALID_SIZE,
        ERR_OVERFLOW
    };
    
    InputParser(char* line) {
        std::string s = line;
        std::stringstream ss(s);
        std::istream_iterator<std::string> begin(ss);
        std::istream_iterator<std::string> end;
        this->tokens = new std::vector<std::string>(begin, end);
        //std::copy(tokens->begin(), tokens->end(), std::ostream_iterator<std::string>(std::cout, "\n"));
    }

    ~InputParser() {
        delete this->tokens;
    }

    const std::string& GetCmdOption(const std::string& option) const {
        std::vector<std::string>::const_iterator itr;
        itr = std::find(this->tokens->begin(), this->tokens->end(), option);
        if (itr != this->tokens->end() && ++itr != this->tokens->end()) {
            return *itr;
        }
        static const std::string empty_string("");
        return empty_string;
    }

    bool CmdOptionExists(const std::string& option) const {
        return std::find((this->tokens->begin() + 1), this->tokens->end(), option)
            != this->tokens->end();
    }
    bool CheckCmd(const std::string& cmd) {
        return this->tokens->front() == cmd;
    }

    static OP_RESULT IsHexStringValid(const std::string& hexStr) {
        if (std::regex_match(hexStr, std::regex("[0][x][a-fA-F0-9]+.*")))
            return OP_SUCCESS;

        return INVALID_HEX;
    }
    
    /// <summary>
    /// Check if address is valid
    /// </summary>
    /// <param name="addr">18 character address</param>
    /// <returns></returns>

    static OP_RESULT IsAddressValid(const std::string& addr) {
        auto searchResults = std::smatch{};
        if (std::regex_match(addr, std::regex("[0][x][a-fA-F0-9]{16}.*")))
            return OP_SUCCESS;

        return INVALID_ADDR;
    }

    OP_RESULT IsLengthValid(UINT64 baseAddr, const std::string& lengthStr) {
        if (IsHexStringValid(lengthStr))
            return INVALID_HEX;

        std::string cpylengthStr = lengthStr.substr(2, lengthStr.length());
        UINT64 addr = ConvertToU64(cpylengthStr.c_str(), cpylengthStr.length());

        // overflow check
        UINT64 maxAddr = 0;
        if (!IsOverflow(&maxAddr, baseAddr, addr)) {
            if (!(KERNEL_MIN_ADDR < maxAddr) && (maxAddr < KERNEL_MAX_ADDR))
                return INVALID_SIZE;
        }
        else
            return ERR_OVERFLOW;
        

        return OP_SUCCESS;
    }

    static OP_RESULT IsOverflow(UINT64* result, UINT64 a, UINT64 b)
    {
        if (a > UINT64_MAX - b)
            return ERR_OVERFLOW;

        *result = a + b;
        return OP_SUCCESS;
    }

    static int Char2int(char input) {
        if (input >= '0' && input <= '9')
            return input - '0';
        if (input >= 'A' && input <= 'F')
            return input - 'A' + 10;
        if (input >= 'a' && input <= 'f')
            return input - 'a' + 10;
    }

    static unsigned char FromHex(char c) {
        switch (c)
        {
        case '0': return 0;
        case '1': return 1;
        case '2': return 2;
        case '3': return 3;
        case '4': return 4;
        case '5': return 5;
        case '6': return 6;
        case '7': return 7;
        case '8': return 8;
        case '9': return 9;
        case 'a':
        case 'A':
            return 10;
        case 'b':
        case 'B':
            return 11;
        case 'c':
        case 'C':
            return 12;
        case 'd':
        case 'D':
            return 13;
        case 'e':
        case 'E': 
            return 14;
        case 'f':
        case 'F':
            return 15;
        default:
            break;
        }
        return 0xFF;
    }

    /// <summary>
    /// Converts and stores char arr to U64 
    /// </summary>
    /// <param name="addr"></param>
    /// <param name="len"></param>
    /// <returns>returns the U64 that was just pushed</returns>
    UINT64 ConvertToU64(const char* addr, size_t len) {
        UINT64 pAddr = 0;
        len -= 2;
        for (size_t i = 0; i <= len; i++)
        {
            char test = addr[len - i];
            auto val = FromHex(addr[len - i]);
            auto power = pow(16, i);
            UINT64 signifdigit = (UINT64)pow(16, i) * (UINT64)FromHex(addr[len - i]);
            pAddr += signifdigit;
        }
        return pAddr;
    }

    void PushU64(UINT64 val) {
        u64Values.push_back(val);
    }
private:
    std::vector <std::string> *tokens = nullptr;
};
```

`DiglettDriver/Common.h`:

```h
#pragma once

#define CUSTOM_STATUS 0x12345678
#define MEMORY_DUMPER_DEVICE 0x8540
#define KERNEL_MAX_ADDR 0xFFFFFFFFFFFFFFFF
#define KERNEL_MIN_ADDR 0xFFFF000000000000

#define IOCTL_ECHO_REQUEST CTL_CODE(MEMORY_DUMPER_DEVICE, \
	0x8000, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_DRAW_START CTL_CODE(MEMORY_DUMPER_DEVICE, \
	0x2010, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_DRAW_STOP CTL_CODE(MEMORY_DUMPER_DEVICE, \
	0x2B1A, METHOD_NEITHER, FILE_ANY_ACCESS)



#define MAX_NAME_LENGTH 20


typedef struct _MODULE_DATA {
	bool isAddr = false;
	UINT64 address = 0;
	UINT64 size = 0;
	char moduleName[MAX_NAME_LENGTH] = { 0 };
} MD_MODULE_DATA, *PMD_MODULE_DATA;

typedef struct _ECHO_DATA {
	char strEcho[MAX_NAME_LENGTH];
} ECHO_DATA, *PECHO_DATA;
```

`DiglettDriver/DiglettDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A2D95A16-9A85-4061-B474-D77A252EBCE2}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>MemoryDumper</RootNamespace>
    <ProjectName>Diglett</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Windows Driver</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Windows Driver</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ShowIncludes>true</ShowIncludes>
      <BufferSecurityCheck>true</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <SetChecksum>false</SetChecksum>
      <AdditionalOptions>/verbose %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ShowIncludes>true</ShowIncludes>
    </ClCompile>
    <Link>
      <AdditionalOptions>/verbose %(AdditionalOptions)</AdditionalOptions>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Draw.cpp" />
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="Thread.cpp" />
    <ClCompile Include="Utility.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Common.h" />
    <ClInclude Include="Draw.h" />
    <ClInclude Include="Driver.h" />
    <ClInclude Include="Globals.h" />
    <ClInclude Include="Hook.h" />
    <ClInclude Include="PEHdr.h" />
    <ClInclude Include="Thread.h" />
    <ClInclude Include="Utility.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DiglettDriver/DiglettDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utility.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Draw.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Thread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PEHdr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utility.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Draw.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Thread.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Globals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DiglettDriver/Draw.cpp`:

```cpp
#pragma once
#include "Thread.h"
#include "Globals.h"
#include <ntifs.h>

void DrawMain(PVOID StartContext)
{
    UNREFERENCED_PARAMETER(StartContext);
    SpoofThread(DiglettDrv::gKernBase);
    LogInfo("DrawMain thread started");
    while (DiglettDrv::gRunThread)
    {
        LARGE_INTEGER li;
        li.QuadPart = -10000000;
        KeDelayExecutionThread(KernelMode, FALSE, &li);
    }
    LogInfo("DrawMain thread stopped");
}
```

`DiglettDriver/Draw.h`:

```h
#pragma once
#include <windef.h>

void DrawMain(PVOID StartContext);
```

`DiglettDriver/Driver.cpp`:

```cpp
#pragma once
#include "Utility.h"
#include "Driver.h"
#include "Common.h"
#include "Draw.h"

void* gOriginalDispatchFunctionArray[IRP_MJ_MAXIMUM_FUNCTION];
PFAST_IO_DEVICE_CONTROL gOriginalFastIoControl = NULL;

namespace DiglettDrv
{
    void* gKernBase;
    bool gRunThread;
}


#ifdef LEGIT_DRIVER
    NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
#else
    extern "C" NTSTATUS DriverEntry()
#endif // LEGIT_DRIVER
{
        DiglettDrv::gKernBase = (void*)GetNtoskrnlBaseAddress();
#ifdef LEGIT_DRIVER
        UNREFERENCED_PARAMETER(RegistryPath);
        Log("DriverEntry() Starting Diglett as legit driver!");
        Log("Current IRQL: %d", (int)KeGetCurrentIrql());
        DriverObject->DriverUnload = Unload;

        // Create a device object for the usermode application to use
        UNICODE_STRING devName = RTL_CONSTANT_STRING(L"\\Device\\Diglett");

        PDEVICE_OBJECT DeviceObject;
        NTSTATUS status = IoCreateDevice(DriverObject, 0, &devName, FILE_DEVICE_UNKNOWN, 0, FALSE, &DeviceObject);

        // error check for successful driver object creation
        if (!NT_SUCCESS(status))
        {
            LogError("Failed to create device object (0x%08X)", status);
            return status;
        }

        // provide symbolic link to device object to make accessible to usermode
        UNICODE_STRING symLink = RTL_CONSTANT_STRING(L"\\??\\Diglett");
        status = IoCreateSymbolicLink(&symLink, &devName);

        // error check for sym link creation
        if (!NT_SUCCESS(status))
        {
            LogError("Failed to create symbolic link (0x%08X)", status);
            IoDeleteDevice(DeviceObject);
            return status;
        }

        LogInfo("Driver initialized successfully");
#else
        Log("DriverEntry() Starting Diglett as manually mapped driver!\n");
#endif // LEGIT_DRIVER
    
    UINT64 outBase = 0;
    UINT64 outSize = 0;
    Utility::GetUserModBase("unused.dll", 6088, &outBase, &outSize);

#ifdef USERLAND_COMMUNICATE
    SetHook(true);
#endif // USERLAND_COMMUNICATE

#ifdef USE_SYSTEM_THREAD
    HANDLE threadHandle;
    PsCreateSystemThread(&threadHandle, GENERIC_ALL, 0, 0, 0, DrawThread, 0);
    ZwClose(threadHandle);
#endif // USE_SYSTEM_THREAD

    LogInfo("~DriverEntry()");
    return STATUS_SUCCESS;
}

#ifdef LEGIT_DRIVER
    void Unload(_In_ PDRIVER_OBJECT DriverObject)
    {
#ifdef USERLAND_COMMUNICATE
        SetHook(false);
#endif // USERLAND_COMMUNICATE

        UNICODE_STRING symLink = RTL_CONSTANT_STRING(L"\\??\\Diglett");
        // delete sym link
        IoDeleteSymbolicLink(&symLink);

        // delete device object
        IoDeleteDevice(DriverObject->DeviceObject);
        LogInfo("Diglett unloaded");
    }
#endif // LEGIT_DRIVER


bool IsValidPEHeader(_In_ const uintptr_t pHead)
{
    // ideally should parse the PT so this can't be IAT spoofed
    if (!MmIsAddressValid((PVOID)pHead))
    {
#ifdef VERBOSE_LOG
        LogError("Was unable to read page @ 0x%p", (PVOID)pHead);
#endif
        return false;
    }

    if (!pHead)
    {
        LogInfo("pHead is null @ 0x%p", (PVOID)pHead);
        return false;
    }

    if (reinterpret_cast<PIMAGE_DOS_HEADER>(pHead)->e_magic != E_MAGIC)
    {
        //LogInfo("pHead is != 0x%02x @ %p", E_MAGIC, (PVOID)pHead);
        return false;
    }

    const auto ntHeader = reinterpret_cast<PIMAGE_NT_HEADERS64>(pHead + reinterpret_cast<PIMAGE_DOS_HEADER>(pHead)->e_lfanew);

    // avoid reading a page not paged in
    if (reinterpret_cast<PIMAGE_DOS_HEADER>(pHead)->e_lfanew > 0x1000)
    {
        LogInfo("pHead->e_lfanew > 0x1000 , doesn't seem valid @ 0x%p", (PVOID)pHead);
        return false;
    }

    if (ntHeader->Signature != NT_HDR_SIG)
    {
        LogInfo("ntHeader->Signature != 0x%02x @ 0x%p", NT_HDR_SIG, (PVOID)pHead);
        return false;
    }

    LogInfo("Found valid PE header @ 0x%p", (PVOID)pHead);
    return true;
}

// @ Barakat , GS Register, reverse page walk until MZ header of ntos
// https://gist.github.com/Barakat/34e9924217ed81fd78c9c92d746ec9c6
// Lands above nt module, but can page fault! Tweak to check PTE's instead of using MmIsAddressValid.  Refer to:  https://www.unknowncheats.me/forum/anti-cheat-bypass/437451-whats-proper-write-read-physical-memory.html
uintptr_t GetNtoskrnlBaseAddress()
{
#pragma pack(push, 1)
    typedef struct
    {
        UCHAR Padding[4];
        PVOID InterruptServiceRoutine;
    } IDT_ENTRY;
#pragma pack(pop)

    // Find the address of IdtBase using gs register.
    const auto idt_base = reinterpret_cast<IDT_ENTRY*>(__readgsqword(0x38));

    // Find the address of the first (or any) interrupt service routine.
    const auto first_isr_address = idt_base[0].InterruptServiceRoutine;

    // Align the address on page boundary.
    auto pageInNtoskrnl = reinterpret_cast<uintptr_t>(first_isr_address) & ~static_cast<uintptr_t>(0xfff);

    // Traverse pages backward until we find the PE signature (MZ) of ntoskrnl.exe in the beginning of some page.
    while (!IsValidPEHeader(pageInNtoskrnl))
    {
        pageInNtoskrnl -= 0x1000;
    }

    // Now we have the base address of ntoskrnl.exe
    return pageInNtoskrnl;
}

// Communication method via hook in legit driver control handler
//NTSTATUS Hk_DeviceControl(PDEVICE_OBJECT tcpipDevObj, PIRP Irp)
//{
//    LogInfo("Hooked routine executed!\n");
//
//    // In the context of tcpip thread
//    auto stack = IoGetCurrentIrpStackLocation(Irp);
//    auto status = STATUS_SUCCESS;
//
//    switch (stack->Parameters.DeviceIoControl.IoControlCode)
//    {
//    case IOCTL_ECHO_REQUEST: {
//        LogInfo("IOCTL_ECHO_REQUEST received!!\n");
//        if (stack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ECHO_DATA))
//        {
//            status = STATUS_BUFFER_TOO_SMALL;
//            break;
//        }
//
//        auto data = (PECHO_DATA)stack->Parameters.DeviceIoControl.Type3InputBuffer;
//
//        if (data == nullptr)
//        {
//            status = STATUS_SUCCESS; // <- TEST
//            //status = STATUS_INVALID_PARAMETER;
//            break;
//        }
//
//        LogInfo("Echo request output: %s\n", data->strEcho);
//        Irp->IoStatus.Status = CUSTOM_STATUS;
//        Irp->IoStatus.Information = 0;
//        IoCompleteRequest(Irp, IO_NO_INCREMENT);
//        return CUSTOM_STATUS;
//    }
//    default:
//        LogInfo("Unrecognized IoControlCode, forwarding to original DeviceControl.\n");
//        return origDeviceControl(tcpipDevObj, Irp);
//    }
//
//    Irp->IoStatus.Status = status;
//    Irp->IoStatus.Information = 0;
//    IoCompleteRequest(Irp, IO_NO_INCREMENT);
//    return status;
//}

/* hook/unhook driver */
NTSTATUS SetHook(BOOL setHook)
{
    UNICODE_STRING driverName;
    UNICODE_STRING newDrvName;
    //PDRIVER_OBJECT tcpipDrvObj;
    DRIVER_OBJECT myDummyDriver;
    PDEVICE_OBJECT tcpipDevice;
    PDRIVER_OBJECT DriverObject = NULL;
    NTSTATUS status;
    PDRIVER_OBJECT dummyDriver;
    //HANDLE fileHandle;
    //UNICODE_STRING fileName = RTL_CONSTANT_STRING(L"\\DosDevices\\C:\\\\Windows\\System32\\drivers\\tcpip.sys");
    //OBJECT_ATTRIBUTES objAttr;
    //IO_STATUS_BLOCK ioStatusBlock;

    // Psched works well!
    //RtlInitUnicodeString(&driverName, L"\\Driver\\Psched");
    RtlInitUnicodeString(&driverName, L"\\Driver\\Null");

    status = ObReferenceObjectByName(&driverName, OBJ_CASE_INSENSITIVE, NULL, 0,
        *IoDriverObjectType, KernelMode, NULL, (PVOID*)&DriverObject);

    if (!NT_SUCCESS(status)) {
        LogError("Failed to obtain DriverObject (0x%08X)", status);
        return status;
    }

    if (setHook)
    {
        LogInfo("Hooking Null driver major funcs...");
        for (int i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
            //save the original pointer in case we need to restore it later
            gOriginalDispatchFunctionArray[i] = DriverObject->MajorFunction[i];
            //replace the pointer with our own pointer
            if (i == IRP_MJ_CREATE)
            {
                DriverObject->MajorFunction[i] = Hk_Create;
                LogInfo("\tHooked IRP_MJ_CREATE");
                LogInfo("\t\tOld: %p", gOriginalDispatchFunctionArray[i]);
                LogInfo("\t\tNew: %p", DriverObject->MajorFunction[i]);
            }
            if (i == IRP_MJ_DEVICE_CONTROL)
            {
                DriverObject->MajorFunction[i] = Hk_DeviceControl;
                LogInfo("\tHooked IRP_MJ_DEVICE_CONTROL");
                LogInfo("\t\tOld: %p", gOriginalDispatchFunctionArray[i]);
                LogInfo("\t\tNew: %p", DriverObject->MajorFunction[i]);
            }
        }
        
        LogInfo("Hooking Null driver object FastIoDispatch->FastIoDeviceControl...");
        gOriginalFastIoControl = DriverObject->FastIoDispatch->FastIoDeviceControl;
        DriverObject->FastIoDispatch->FastIoDeviceControl = (PFAST_IO_DEVICE_CONTROL)Hk_FastIoDispatch;
        LogInfo("\t\tOld: %p", gOriginalFastIoControl);
        LogInfo("\t\tNew: %p", DriverObject->FastIoDispatch->FastIoDeviceControl);
    }
    else
    {
        for (int i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
            DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)gOriginalDispatchFunctionArray[i];
        }
        LogInfo("Unhooked Null driver major functions...");

        DriverObject->FastIoDispatch->FastIoDeviceControl = gOriginalFastIoControl;
        LogInfo("\tUnhooked ->FastIoDispatch->FastIoDeviceControl");
    }

    //cleanup
    ObDereferenceObject(DriverObject);

    return STATUS_SUCCESS;
}

BOOLEAN Hk_FastIoDispatch(
    _In_ _FILE_OBJECT* FileObject,
    _In_ BOOLEAN Wait,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _In_ ULONG IoControlCode,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ _DEVICE_OBJECT* DeviceObject)
{
    LogInfo("Hk_FastIoDispatch executed in Diglett!");

    switch (IoControlCode)
    {
    case IOCTL_DRAW_START: {
        DiglettDrv::gRunThread = true;
        LogInfo("Starting Draw Thread.");
        HANDLE threadHandle;
        PsCreateSystemThread(&threadHandle, GENERIC_ALL, 0, 0, 0, DrawMain, 0);
        ZwClose(threadHandle);
        break;
    }
    case IOCTL_DRAW_STOP: {
        LogInfo("Stopping Draw Thread.");
        DiglettDrv::gRunThread = false;
        break;
    }
    default:
        break;
    }

    if (!gOriginalFastIoControl)
    {
        return 0;
    }
    
    return gOriginalFastIoControl(
        FileObject,
        Wait,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength,
        IoControlCode,
        IoStatus,
        DeviceObject);
}

NTSTATUS Hk_DeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    LogInfo("IRP_MJ_DEVICE_CONTROL hook executed in Diglett!");
    return ((DevCtrlPtr)(gOriginalDispatchFunctionArray[IRP_MJ_DEVICE_CONTROL]))(DeviceObject, Irp);
}

NTSTATUS Hk_Create(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    LogInfo("IRP_MJ_CREATE hook executed in Diglett!");
    return ((DevCtrlPtr)(gOriginalDispatchFunctionArray[IRP_MJ_CREATE]))(DeviceObject, Irp);
}

PLOAD_IMAGE_NOTIFY_ROUTINE ImageNotifyRoutine(PUNICODE_STRING FullImageName, HANDLE ProcID, PIMAGE_INFO ImageInfo)
{
    UNREFERENCED_PARAMETER(ImageInfo);
    UNREFERENCED_PARAMETER(ProcID);

    if (wcsstr(FullImageName->Buffer, L"\\EasyAntiCheat.sys"))
    {
        //KdPrint(("[NOMAD] [INFO] !  Dumping!\n"));
        //UINT64 base = (UINT64)ImageInfo->ImageBase;
        //DumpKernelModule("WinKernelProgDrv.sys");
    }

    return STATUS_SUCCESS;
}
```

`DiglettDriver/Driver.h`:

```h
#pragma once
#include <ntifs.h>
#include <windef.h>
#include <ntstrsafe.h>
#include "PEHdr.h"

//#define USERLAND_COMMUNICATE
#define LEGIT_DRIVER
#define DEBUG

// @jk2
#ifdef DEBUG
#define Log(format, ...) DbgPrint("[DIGLETT] " format "\n", __VA_ARGS__)
#define LogInfo(format, ...) DbgPrint("[DIGLETT] [INFO] " format "\n", __VA_ARGS__)
#define LogError(format, ...) DbgPrint("[DIGLETT] [ERROR] " format "\n", __VA_ARGS__)

#else
#define Log(format, ...) 
#define LogInfo(format, ...) 
#define LogError(format, ...)

#endif

#define MAX_NAME_LEN 25
#define WINAPI_IMPORT_COUNT 1
#define PAGE_SIZE 0x1000
#define PML4_OFFSET_MASK 0b00000000 11111111 00000000 00000000 00000000 00000000 00000000 00000000

#define ZW_QUERY_INFO 0
#define SYSTEM_MODULE_INFORMATION 0x0B

union _KWAIT_STATUS_REGISTER
{
    UCHAR Flags;                                                            //0x0
    UCHAR State : 3;                                                          //0x0
    UCHAR Affinity : 1;                                                       //0x0
    UCHAR Priority : 1;                                                       //0x0
    UCHAR Apc : 1;                                                            //0x0
    UCHAR UserApc : 1;                                                        //0x0
    UCHAR Alert : 1;                                                          //0x0
};

union _PS_CLIENT_SECURITY_CONTEXT
{
    ULONGLONG ImpersonationData;                                            //0x0
    VOID* ImpersonationToken;                                               //0x0
    ULONGLONG ImpersonationLevel : 2;                                         //0x0
    ULONGLONG EffectiveOnly : 1;                                              //0x0
};

struct _EX_PUSH_LOCK
{
    union
    {
        struct
        {
            ULONGLONG Locked : 1;                                             //0x0
            ULONGLONG Waiting : 1;                                            //0x0
            ULONGLONG Waking : 1;                                             //0x0
            ULONGLONG MultipleShared : 1;                                     //0x0
            ULONGLONG Shared : 60;                                            //0x0
        };
        ULONGLONG Value;                                                    //0x0
        VOID* Ptr;                                                          //0x0
    };
};

struct _PS_PROPERTY_SET
{
    struct _LIST_ENTRY ListHead;                                            //0x0
    ULONGLONG Lock;                                                         //0x10
};

struct _KTHREAD
{
    struct _DISPATCHER_HEADER Header;                                       //0x0
    VOID* SListFaultAddress;                                                //0x18
    ULONGLONG QuantumTarget;                                                //0x20
    VOID* InitialStack;                                                     //0x28
    VOID* volatile StackLimit;                                              //0x30
    VOID* StackBase;                                                        //0x38
    ULONGLONG ThreadLock;                                                   //0x40
    volatile ULONGLONG CycleTime;                                           //0x48
    ULONG CurrentRunTime;                                                   //0x50
    ULONG ExpectedRunTime;                                                  //0x54
    VOID* KernelStack;                                                      //0x58
    struct _XSAVE_FORMAT* StateSaveArea;                                    //0x60
    struct _KSCHEDULING_GROUP* volatile SchedulingGroup;                    //0x68
    union _KWAIT_STATUS_REGISTER WaitRegister;                              //0x70
    volatile UCHAR Running;                                                 //0x71
    UCHAR Alerted[2];                                                       //0x72
    union
    {
        struct
        {
            ULONG AutoBoostActive : 1;                                        //0x74
            ULONG ReadyTransition : 1;                                        //0x74
            ULONG WaitNext : 1;                                               //0x74
            ULONG SystemAffinityActive : 1;                                   //0x74
            ULONG Alertable : 1;                                              //0x74
            ULONG UserStackWalkActive : 1;                                    //0x74
            ULONG ApcInterruptRequest : 1;                                    //0x74
            ULONG QuantumEndMigrate : 1;                                      //0x74
            ULONG UmsDirectedSwitchEnable : 1;                                //0x74
            ULONG TimerActive : 1;                                            //0x74
            ULONG SystemThread : 1;                                           //0x74
            ULONG ProcessDetachActive : 1;                                    //0x74
            ULONG CalloutActive : 1;                                          //0x74
            ULONG ScbReadyQueue : 1;                                          //0x74
            ULONG ApcQueueable : 1;                                           //0x74
            ULONG ReservedStackInUse : 1;                                     //0x74
            ULONG UmsPerformingSyscall : 1;                                   //0x74
            ULONG TimerSuspended : 1;                                         //0x74
            ULONG SuspendedWaitMode : 1;                                      //0x74
            ULONG SuspendSchedulerApcWait : 1;                                //0x74
            ULONG CetUserShadowStack : 1;                                     //0x74
            ULONG BypassProcessFreeze : 1;                                    //0x74
            ULONG Reserved : 10;                                              //0x74
        };
        LONG MiscFlags;                                                     //0x74
    };
    union
    {
        struct
        {
            ULONG ThreadFlagsSpare : 2;                                       //0x78
            ULONG AutoAlignment : 1;                                          //0x78
            ULONG DisableBoost : 1;                                           //0x78
            ULONG AlertedByThreadId : 1;                                      //0x78
            ULONG QuantumDonation : 1;                                        //0x78
            ULONG EnableStackSwap : 1;                                        //0x78
            ULONG GuiThread : 1;                                              //0x78
            ULONG DisableQuantum : 1;                                         //0x78
            ULONG ChargeOnlySchedulingGroup : 1;                              //0x78
            ULONG DeferPreemption : 1;                                        //0x78
            ULONG QueueDeferPreemption : 1;                                   //0x78
            ULONG ForceDeferSchedule : 1;                                     //0x78
            ULONG SharedReadyQueueAffinity : 1;                               //0x78
            ULONG FreezeCount : 1;                                            //0x78
            ULONG TerminationApcRequest : 1;                                  //0x78
            ULONG AutoBoostEntriesExhausted : 1;                              //0x78
            ULONG KernelStackResident : 1;                                    //0x78
            ULONG TerminateRequestReason : 2;                                 //0x78
            ULONG ProcessStackCountDecremented : 1;                           //0x78
            ULONG RestrictedGuiThread : 1;                                    //0x78
            ULONG VpBackingThread : 1;                                        //0x78
            ULONG ThreadFlagsSpare2 : 1;                                      //0x78
            ULONG EtwStackTraceApcInserted : 8;                               //0x78
        };
        volatile LONG ThreadFlags;                                          //0x78
    };
    volatile UCHAR Tag;                                                     //0x7c
    UCHAR SystemHeteroCpuPolicy;                                            //0x7d
    UCHAR UserHeteroCpuPolicy : 7;                                            //0x7e
    UCHAR ExplicitSystemHeteroCpuPolicy : 1;                                  //0x7e
    union
    {
        struct
        {
            UCHAR RunningNonRetpolineCode : 1;                                //0x7f
            UCHAR SpecCtrlSpare : 7;                                          //0x7f
        };
        UCHAR SpecCtrl;                                                     //0x7f
    };
    ULONG SystemCallNumber;                                                 //0x80
    ULONG ReadyTime;                                                        //0x84
    VOID* FirstArgument;                                                    //0x88
    struct _KTRAP_FRAME* TrapFrame;                                         //0x90
    union
    {
        struct _KAPC_STATE ApcState;                                        //0x98
        struct
        {
            UCHAR ApcStateFill[43];                                         //0x98
            CHAR Priority;                                                  //0xc3
            ULONG UserIdealProcessor;                                       //0xc4
        };
    };
    volatile LONGLONG WaitStatus;                                           //0xc8
    struct _KWAIT_BLOCK* WaitBlockList;                                     //0xd0
    union
    {
        struct _LIST_ENTRY WaitListEntry;                                   //0xd8
        struct _SINGLE_LIST_ENTRY SwapListEntry;                            //0xd8
    };
    struct _DISPATCHER_HEADER* volatile Queue;                              //0xe8
    VOID* Teb;                                                              //0xf0
    ULONGLONG RelativeTimerBias;                                            //0xf8
    struct _KTIMER Timer;                                                   //0x100
    union
    {
        struct _KWAIT_BLOCK WaitBlock[4];                                   //0x140
        struct
        {
            UCHAR WaitBlockFill4[20];                                       //0x140
            ULONG ContextSwitches;                                          //0x154
        };
        struct
        {
            UCHAR WaitBlockFill5[68];                                       //0x140
            volatile UCHAR State;                                           //0x184
            CHAR Spare13;                                                   //0x185
            UCHAR WaitIrql;                                                 //0x186
            CHAR WaitMode;                                                  //0x187
        };
        struct
        {
            UCHAR WaitBlockFill6[116];                                      //0x140
            ULONG WaitTime;                                                 //0x1b4
        };
        struct
        {
            UCHAR WaitBlockFill7[164];                                      //0x140
            union
            {
                struct
                {
                    SHORT KernelApcDisable;                                 //0x1e4
                    SHORT SpecialApcDisable;                                //0x1e6
                };
                ULONG CombinedApcDisable;                                   //0x1e4
            };
        };
        struct
        {
            UCHAR WaitBlockFill8[40];                                       //0x140
            struct _KTHREAD_COUNTERS* ThreadCounters;                       //0x168
        };
        struct
        {
            UCHAR WaitBlockFill9[88];                                       //0x140
            struct _XSTATE_SAVE* XStateSave;                                //0x198
        };
        struct
        {
            UCHAR WaitBlockFill10[136];                                     //0x140
            VOID* volatile Win32Thread;                                     //0x1c8
        };
        struct
        {
            UCHAR WaitBlockFill11[176];                                     //0x140
            struct _UMS_CONTROL_BLOCK* Ucb;                                 //0x1f0
            struct _KUMS_CONTEXT_HEADER* volatile Uch;                      //0x1f8
        };
    };
    union
    {
        volatile LONG ThreadFlags2;                                         //0x200
        struct
        {
            ULONG BamQosLevel : 8;                                            //0x200
            ULONG ThreadFlags2Reserved : 24;                                  //0x200
        };
    };
    ULONG Spare21;                                                          //0x204
    struct _LIST_ENTRY QueueListEntry;                                      //0x208
    union
    {
        volatile ULONG NextProcessor;                                       //0x218
        struct
        {
            ULONG NextProcessorNumber : 31;                                   //0x218
            ULONG SharedReadyQueue : 1;                                       //0x218
        };
    };
    LONG QueuePriority;                                                     //0x21c
    struct _KPROCESS* Process;                                              //0x220
    union
    {
        struct _GROUP_AFFINITY UserAffinity;                                //0x228
        struct
        {
            UCHAR UserAffinityFill[10];                                     //0x228
            CHAR PreviousMode;                                              //0x232
            CHAR BasePriority;                                              //0x233
            union
            {
                CHAR PriorityDecrement;                                     //0x234
                struct
                {
                    UCHAR ForegroundBoost : 4;                                //0x234
                    UCHAR UnusualBoost : 4;                                   //0x234
                };
            };
            UCHAR Preempted;                                                //0x235
            UCHAR AdjustReason;                                             //0x236
            CHAR AdjustIncrement;                                           //0x237
        };
    };
    ULONGLONG AffinityVersion;                                              //0x238
    union
    {
        struct _GROUP_AFFINITY Affinity;                                    //0x240
        struct
        {
            UCHAR AffinityFill[10];                                         //0x240
            UCHAR ApcStateIndex;                                            //0x24a
            UCHAR WaitBlockCount;                                           //0x24b
            ULONG IdealProcessor;                                           //0x24c
        };
    };
    ULONGLONG NpxState;                                                     //0x250
    union
    {
        struct _KAPC_STATE SavedApcState;                                   //0x258
        struct
        {
            UCHAR SavedApcStateFill[43];                                    //0x258
            UCHAR WaitReason;                                               //0x283
            CHAR SuspendCount;                                              //0x284
            CHAR Saturation;                                                //0x285
            USHORT SListFaultCount;                                         //0x286
        };
    };
    union
    {
        struct _KAPC SchedulerApc;                                          //0x288
        struct
        {
            UCHAR SchedulerApcFill0[1];                                     //0x288
            UCHAR ResourceIndex;                                            //0x289
        };
        struct
        {
            UCHAR SchedulerApcFill1[3];                                     //0x288
            UCHAR QuantumReset;                                             //0x28b
        };
        struct
        {
            UCHAR SchedulerApcFill2[4];                                     //0x288
            ULONG KernelTime;                                               //0x28c
        };
        struct
        {
            UCHAR SchedulerApcFill3[64];                                    //0x288
            struct _KPRCB* volatile WaitPrcb;                               //0x2c8
        };
        struct
        {
            UCHAR SchedulerApcFill4[72];                                    //0x288
            VOID* LegoData;                                                 //0x2d0
        };
        struct
        {
            UCHAR SchedulerApcFill5[83];                                    //0x288
            UCHAR CallbackNestingLevel;                                     //0x2db
            ULONG UserTime;                                                 //0x2dc
        };
    };
    struct _KEVENT SuspendEvent;                                            //0x2e0
    struct _LIST_ENTRY ThreadListEntry;                                     //0x2f8
    struct _LIST_ENTRY MutantListHead;                                      //0x308
    UCHAR AbEntrySummary;                                                   //0x318
    UCHAR AbWaitEntryCount;                                                 //0x319
    UCHAR AbAllocationRegionCount;                                          //0x31a
    CHAR SystemPriority;                                                    //0x31b
    ULONG SecureThreadCookie;                                               //0x31c
    struct _KLOCK_ENTRY* LockEntries;                                       //0x320
    struct _SINGLE_LIST_ENTRY PropagateBoostsEntry;                         //0x328
    struct _SINGLE_LIST_ENTRY IoSelfBoostsEntry;                            //0x330
    UCHAR PriorityFloorCounts[16];                                          //0x338
    UCHAR PriorityFloorCountsReserved[16];                                  //0x348
    ULONG PriorityFloorSummary;                                             //0x358
    volatile LONG AbCompletedIoBoostCount;                                  //0x35c
    volatile LONG AbCompletedIoQoSBoostCount;                               //0x360
    volatile SHORT KeReferenceCount;                                        //0x364
    UCHAR AbOrphanedEntrySummary;                                           //0x366
    UCHAR AbOwnedEntryCount;                                                //0x367
    ULONG ForegroundLossTime;                                               //0x368
    union
    {
        struct _LIST_ENTRY GlobalForegroundListEntry;                       //0x370
        struct
        {
            struct _SINGLE_LIST_ENTRY ForegroundDpcStackListEntry;          //0x370
            ULONGLONG InGlobalForegroundList;                               //0x378
        };
    };
    LONGLONG ReadOperationCount;                                            //0x380
    LONGLONG WriteOperationCount;                                           //0x388
    LONGLONG OtherOperationCount;                                           //0x390
    LONGLONG ReadTransferCount;                                             //0x398
    LONGLONG WriteTransferCount;                                            //0x3a0
    LONGLONG OtherTransferCount;                                            //0x3a8
    struct _KSCB* QueuedScb;                                                //0x3b0
    volatile ULONG ThreadTimerDelay;                                        //0x3b8
    union
    {
        volatile LONG ThreadFlags3;                                         //0x3bc
        struct
        {
            ULONG ThreadFlags3Reserved : 8;                                   //0x3bc
            ULONG PpmPolicy : 2;                                              //0x3bc
            ULONG ThreadFlags3Reserved2 : 22;                                 //0x3bc
        };
    };
    ULONGLONG TracingPrivate[1];                                            //0x3c0
    VOID* SchedulerAssist;                                                  //0x3c8
    VOID* volatile AbWaitObject;                                            //0x3d0
    ULONG ReservedPreviousReadyTimeValue;                                   //0x3d8
    ULONGLONG KernelWaitTime;                                               //0x3e0
    ULONGLONG UserWaitTime;                                                 //0x3e8
    union
    {
        struct _LIST_ENTRY GlobalUpdateVpThreadPriorityListEntry;           //0x3f0
        struct
        {
            struct _SINGLE_LIST_ENTRY UpdateVpThreadPriorityDpcStackListEntry; //0x3f0
            ULONGLONG InGlobalUpdateVpThreadPriorityList;                   //0x3f8
        };
    };
    LONG SchedulerAssistPriorityFloor;                                      //0x400
    ULONG Spare28;                                                          //0x404
    ULONGLONG EndPadding[5];                                                //0x408
};

struct _ETHREAD
{
    struct _KTHREAD Tcb;                                                    //0x0
    union _LARGE_INTEGER CreateTime;                                        //0x430
    union
    {
        union _LARGE_INTEGER ExitTime;                                      //0x438
        struct _LIST_ENTRY KeyedWaitChain;                                  //0x438
    };
    union
    {
        struct _LIST_ENTRY PostBlockList;                                   //0x448
        struct
        {
            VOID* ForwardLinkShadow;                                        //0x448
            VOID* StartAddress;                                             //0x450
        };
    };
    union
    {
        struct _TERMINATION_PORT* TerminationPort;                          //0x458
        struct _ETHREAD* ReaperLink;                                        //0x458
        VOID* KeyedWaitValue;                                               //0x458
    };
    ULONGLONG ActiveTimerListLock;                                          //0x460
    struct _LIST_ENTRY ActiveTimerListHead;                                 //0x468
    struct _CLIENT_ID Cid;                                                  //0x478
    union
    {
        struct _KSEMAPHORE KeyedWaitSemaphore;                              //0x488
        struct _KSEMAPHORE AlpcWaitSemaphore;                               //0x488
    };
    union _PS_CLIENT_SECURITY_CONTEXT ClientSecurity;                       //0x4a8
    struct _LIST_ENTRY IrpList;                                             //0x4b0
    ULONGLONG TopLevelIrp;                                                  //0x4c0
    struct _DEVICE_OBJECT* DeviceToVerify;                                  //0x4c8
    VOID* Win32StartAddress;                                                //0x4d0
    VOID* ChargeOnlySession;                                                //0x4d8
    VOID* LegacyPowerObject;                                                //0x4e0
    struct _LIST_ENTRY ThreadListEntry;                                     //0x4e8
    struct _EX_RUNDOWN_REF RundownProtect;                                  //0x4f8
    struct _EX_PUSH_LOCK ThreadLock;                                        //0x500
    ULONG ReadClusterSize;                                                  //0x508
    volatile LONG MmLockOrdering;                                           //0x50c
    union
    {
        ULONG CrossThreadFlags;                                             //0x510
        struct
        {
            ULONG Terminated : 1;                                             //0x510
            ULONG ThreadInserted : 1;                                         //0x510
            ULONG HideFromDebugger : 1;                                       //0x510
            ULONG ActiveImpersonationInfo : 1;                                //0x510
            ULONG HardErrorsAreDisabled : 1;                                  //0x510
            ULONG BreakOnTermination : 1;                                     //0x510
            ULONG SkipCreationMsg : 1;                                        //0x510
            ULONG SkipTerminationMsg : 1;                                     //0x510
            ULONG CopyTokenOnOpen : 1;                                        //0x510
            ULONG ThreadIoPriority : 3;                                       //0x510
            ULONG ThreadPagePriority : 3;                                     //0x510
            ULONG RundownFail : 1;                                            //0x510
            ULONG UmsForceQueueTermination : 1;                               //0x510
            ULONG IndirectCpuSets : 1;                                        //0x510
            ULONG DisableDynamicCodeOptOut : 1;                               //0x510
            ULONG ExplicitCaseSensitivity : 1;                                //0x510
            ULONG PicoNotifyExit : 1;                                         //0x510
            ULONG DbgWerUserReportActive : 1;                                 //0x510
            ULONG ForcedSelfTrimActive : 1;                                   //0x510
            ULONG SamplingCoverage : 1;                                       //0x510
            ULONG ReservedCrossThreadFlags : 8;                               //0x510
        };
    };
    union
    {
        ULONG SameThreadPassiveFlags;                                       //0x514
        struct
        {
            ULONG ActiveExWorker : 1;                                         //0x514
            ULONG MemoryMaker : 1;                                            //0x514
            ULONG StoreLockThread : 2;                                        //0x514
            ULONG ClonedThread : 1;                                           //0x514
            ULONG KeyedEventInUse : 1;                                        //0x514
            ULONG SelfTerminate : 1;                                          //0x514
            ULONG RespectIoPriority : 1;                                      //0x514
            ULONG ActivePageLists : 1;                                        //0x514
            ULONG SecureContext : 1;                                          //0x514
            ULONG ZeroPageThread : 1;                                         //0x514
            ULONG WorkloadClass : 1;                                          //0x514
            ULONG ReservedSameThreadPassiveFlags : 20;                        //0x514
        };
    };
    union
    {
        ULONG SameThreadApcFlags;                                           //0x518
        struct
        {
            UCHAR OwnsProcessAddressSpaceExclusive : 1;                       //0x518
            UCHAR OwnsProcessAddressSpaceShared : 1;                          //0x518
            UCHAR HardFaultBehavior : 1;                                      //0x518
            volatile UCHAR StartAddressInvalid : 1;                           //0x518
            UCHAR EtwCalloutActive : 1;                                       //0x518
            UCHAR SuppressSymbolLoad : 1;                                     //0x518
            UCHAR Prefetching : 1;                                            //0x518
            UCHAR OwnsVadExclusive : 1;                                       //0x518
            UCHAR SystemPagePriorityActive : 1;                               //0x519
            UCHAR SystemPagePriority : 3;                                     //0x519
            UCHAR AllowUserWritesToExecutableMemory : 1;                      //0x519
            UCHAR AllowKernelWritesToExecutableMemory : 1;                    //0x519
            UCHAR OwnsVadShared : 1;                                          //0x519
        };
    };
    UCHAR CacheManagerActive;                                               //0x51c
    UCHAR DisablePageFaultClustering;                                       //0x51d
    UCHAR ActiveFaultCount;                                                 //0x51e
    UCHAR LockOrderState;                                                   //0x51f
    ULONG PerformanceCountLowReserved;                                      //0x520
    LONG PerformanceCountHighReserved;                                      //0x524
    ULONGLONG AlpcMessageId;                                                //0x528
    union
    {
        VOID* AlpcMessage;                                                  //0x530
        ULONG AlpcReceiveAttributeSet;                                      //0x530
    };
    struct _LIST_ENTRY AlpcWaitListEntry;                                   //0x538
    LONG ExitStatus;                                                        //0x548
    ULONG CacheManagerCount;                                                //0x54c
    ULONG IoBoostCount;                                                     //0x550
    ULONG IoQoSBoostCount;                                                  //0x554
    ULONG IoQoSThrottleCount;                                               //0x558
    ULONG KernelStackReference;                                             //0x55c
    struct _LIST_ENTRY BoostList;                                           //0x560
    struct _LIST_ENTRY DeboostList;                                         //0x570
    ULONGLONG BoostListLock;                                                //0x580
    ULONGLONG IrpListLock;                                                  //0x588
    VOID* ReservedForSynchTracking;                                         //0x590
    struct _SINGLE_LIST_ENTRY CmCallbackListHead;                           //0x598
    struct _GUID* ActivityId;                                               //0x5a0
    struct _SINGLE_LIST_ENTRY SeLearningModeListHead;                       //0x5a8
    VOID* VerifierContext;                                                  //0x5b0
    VOID* AdjustedClientToken;                                              //0x5b8
    VOID* WorkOnBehalfThread;                                               //0x5c0
    struct _PS_PROPERTY_SET PropertySet;                                    //0x5c8
    VOID* PicoContext;                                                      //0x5e0
    ULONGLONG UserFsBase;                                                   //0x5e8
    ULONGLONG UserGsBase;                                                   //0x5f0
    struct _THREAD_ENERGY_VALUES* EnergyValues;                             //0x5f8
    union
    {
        ULONGLONG SelectedCpuSets;                                          //0x600
        ULONGLONG* SelectedCpuSetsIndirect;                                 //0x600
    };
    struct _EJOB* Silo;                                                     //0x608
    struct _UNICODE_STRING* ThreadName;                                     //0x610
    struct _CONTEXT* SetContextState;                                       //0x618
    ULONG LastExpectedRunTime;                                              //0x620
    ULONG HeapData;                                                         //0x624
    struct _LIST_ENTRY OwnerEntryListHead;                                  //0x628
    ULONGLONG DisownedOwnerEntryListLock;                                   //0x638
    struct _LIST_ENTRY DisownedOwnerEntryListHead;                          //0x640
    //struct _KLOCK_ENTRY LockEntries[6];                                     //0x650
    VOID* CmDbgInfo;                                                        //0x890
};

typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef unsigned long long uint64_t;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

extern "C"
{
	__declspec(dllimport) NTSTATUS ZwQuerySystemInformation(
		ULONG InfoClass,
		PVOID Buffer,
		ULONG Length,
		PULONG ReturnLength
	);

	NTKERNELAPI PVOID NTAPI RtlFindExportsRoutineByName(
		_In_ PVOID ImageBase,
		_In_ PCCH RoutineName
	);

	NTKERNELAPI PPEB PsGetProcessPeb(
		_In_ PEPROCESS Process
	);

	NTSTATUS NTAPI MmCopyVirtualMemory(
		PEPROCESS SourceProcess,
		PVOID SourceAddress,
		PEPROCESS TargetProcess,
		PVOID TargetAddress,
		SIZE_T BufferSize,
		KPROCESSOR_MODE PreviousMode,
		PSIZE_T ReturnSize
	);

	NTKERNELAPI NTSTATUS ObReferenceObjectByName(
		__in PUNICODE_STRING ObjectName,
		__in ULONG Attributes,
		__in_opt PACCESS_STATE AccessState,
		__in_opt ACCESS_MASK DesiredAccess,
		__in POBJECT_TYPE ObjectType,
		__in KPROCESSOR_MODE AccessMode,
		__inout_opt PVOID ParseContext,
		__out PVOID* Object
	);

	NTSTATUS NTAPI IoCreateDriver(
		_In_opt_ PUNICODE_STRING DriverName,
		_In_ PDRIVER_INITIALIZE InitializationFunction
	);

    NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(
            __in PEPROCESS Process
    );

	typedef void (*GenericFuncPtr)();
	typedef NTSTATUS(*ZwQuerySysInfoPtr)(ULONG, PVOID, ULONG, PULONG);
	typedef NTSTATUS(*DevCtrlPtr)(PDEVICE_OBJECT, PIRP Irp);

}

extern "C" __declspec(dllimport) POBJECT_TYPE * IoDriverObjectType;

PLOAD_IMAGE_NOTIFY_ROUTINE ImageNotifyRoutine(_In_ PUNICODE_STRING FullImageName, _In_ HANDLE ProcID, _In_ PIMAGE_INFO ImageInfo);
NTSTATUS DummyDrv_Init(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);
NTSTATUS SetHook(BOOL setHook);
NTSTATUS Hk_Create(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS Hk_DeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);
uintptr_t GetNtoskrnlBaseAddress();
BOOLEAN Hk_FastIoDispatch(
    _In_ struct _FILE_OBJECT* FileObject,
    _In_ BOOLEAN Wait,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _In_ ULONG IoControlCode,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ struct _DEVICE_OBJECT* DeviceObject
);

#ifdef LEGIT_DRIVER
void Unload(_In_ PDRIVER_OBJECT DriverObject);
#endif
```

`DiglettDriver/Globals.h`:

```h
#pragma once

namespace DiglettDrv
{
	extern void* gKernBase;
	extern bool gRunThread;
}


```

`DiglettDriver/Hook.h`:

```h
#pragma once

```

`DiglettDriver/PEHdr.h`:

```h
// From winnnt.h
#pragma once
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
#define IMAGE_SIZEOF_SHORT_NAME              8
#define E_MAGIC 0x5A4D
#define NT_HDR_SIG 0x4550

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
	WORD   e_magic;                     // Magic number
	WORD   e_cblp;                      // Bytes on last page of file
	WORD   e_cp;                        // Pages in file
	WORD   e_crlc;                      // Relocations
	WORD   e_cparhdr;                   // Size of header in paragraphs
	WORD   e_minalloc;                  // Minimum extra paragraphs needed
	WORD   e_maxalloc;                  // Maximum extra paragraphs needed
	WORD   e_ss;                        // Initial (relative) SS value
	WORD   e_sp;                        // Initial SP value
	WORD   e_csum;                      // Checksum
	WORD   e_ip;                        // Initial IP value
	WORD   e_cs;                        // Initial (relative) CS value
	WORD   e_lfarlc;                    // File address of relocation table
	WORD   e_ovno;                      // Overlay number
	WORD   e_res[4];                    // Reserved words
	WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
	WORD   e_oeminfo;                   // OEM information; e_oemid specific
	WORD   e_res2[10];                  // Reserved words
	LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;

typedef struct _IMAGE_SECTION_HEADER {
	BYTE  Name[8];
	union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
	} Misc;
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
	DWORD PointerToRawData;
	DWORD PointerToRelocations;
	DWORD PointerToLinenumbers;
	WORD  NumberOfRelocations;
	WORD  NumberOfLinenumbers;
	DWORD Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD   VirtualAddress;
	DWORD   Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_FILE_HEADER {
	WORD    Machine;
	WORD    NumberOfSections;
	DWORD   TimeDateStamp;
	DWORD   PointerToSymbolTable;
	DWORD   NumberOfSymbols;
	WORD    SizeOfOptionalHeader;
	WORD    Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD        Magic;
	BYTE        MajorLinkerVersion;
	BYTE        MinorLinkerVersion;
	DWORD       SizeOfCode;
	DWORD       SizeOfInitializedData;
	DWORD       SizeOfUninitializedData;
	DWORD       AddressOfEntryPoint;
	DWORD       BaseOfCode;
	ULONGLONG   ImageBase;
	DWORD       SectionAlignment;
	DWORD       FileAlignment;
	WORD        MajorOperatingSystemVersion;
	WORD        MinorOperatingSystemVersion;
	WORD        MajorImageVersion;
	WORD        MinorImageVersion;
	WORD        MajorSubsystemVersion;
	WORD        MinorSubsystemVersion;
	DWORD       Win32VersionValue;
	DWORD       SizeOfImage;
	DWORD       SizeOfHeaders;
	DWORD       CheckSum;
	WORD        Subsystem;
	WORD        DllCharacteristics;
	ULONGLONG   SizeOfStackReserve;
	ULONGLONG   SizeOfStackCommit;
	ULONGLONG   SizeOfHeapReserve;
	ULONGLONG   SizeOfHeapCommit;
	DWORD       LoaderFlags;
	DWORD       NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD   Characteristics;
	DWORD   TimeDateStamp;
	WORD    MajorVersion;
	WORD    MinorVersion;
	DWORD   Name;
	DWORD   Base;
	DWORD   NumberOfFunctions;
	DWORD   NumberOfNames;
	DWORD   AddressOfFunctions;
	DWORD   AddressOfNames;
	DWORD   AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;

typedef struct _SYSTEM_MODULE_ENTRY {
	ULONG  Unused;
	ULONG  Always0;
	PVOID  ModuleBaseAddress;
	ULONG  ModuleSize;
	ULONG  Unknown;
	ULONG  ModuleEntryIndex;
	USHORT ModuleNameLength;
	USHORT ModuleNameOffset;
	CHAR   ModuleName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;		// using https://doxygen.reactos.org/da/dda/filesystems_2udfs_2Include_2ntddk__ex_8h_source.html#l00074


```

`DiglettDriver/PEHdr2.h`:

```h
// From winnnth  Use this for redefinition issues.
#pragma once
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
	WORD   e_magic;                     // Magic number
	WORD   e_cblp;                      // Bytes on last page of file
	WORD   e_cp;                        // Pages in file
	WORD   e_crlc;                      // Relocations
	WORD   e_cparhdr;                   // Size of header in paragraphs
	WORD   e_minalloc;                  // Minimum extra paragraphs needed
	WORD   e_maxalloc;                  // Maximum extra paragraphs needed
	WORD   e_ss;                        // Initial (relative) SS value
	WORD   e_sp;                        // Initial SP value
	WORD   e_csum;                      // Checksum
	WORD   e_ip;                        // Initial IP value
	WORD   e_cs;                        // Initial (relative) CS value
	WORD   e_lfarlc;                    // File address of relocation table
	WORD   e_ovno;                      // Overlay number
	WORD   e_res[4];                    // Reserved words
	WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
	WORD   e_oeminfo;                   // OEM information; e_oemid specific
	WORD   e_res2[10];                  // Reserved words
	LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;

typedef struct _IMAGE_SECTION_HEADER {
	BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
	} Misc;
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
	DWORD PointerToRawData;
	DWORD PointerToRelocations;
	DWORD PointerToLinenumbers;
	WORD  NumberOfRelocations;
	WORD  NumberOfLinenumbers;
	DWORD Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD   VirtualAddress;
	DWORD   Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_FILE_HEADER {
	WORD    Machine;
	WORD    NumberOfSections;
	DWORD   TimeDateStamp;
	DWORD   PointerToSymbolTable;
	DWORD   NumberOfSymbols;
	WORD    SizeOfOptionalHeader;
	WORD    Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, * PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS, *PPIMAGE_NT_HEADERS;

```

`DiglettDriver/SysCall.asm`:

```asm
bits 64

global add

section .data

section .text

add:
    mov   eax, [esp+4]   ; argument 1
    add   eax, [esp+8]   ; argument 2
    ret
```

`DiglettDriver/Thread.cpp`:

```cpp
#include "Thread.h"

void SpoofThread(PVOID newThreadEntry)
{
    LogInfo("Main thread started\n");
    auto increment = 0;
    HANDLE ourThread = PsGetCurrentThreadId();
    LogInfo("Our thread id:  %llu\n", (unsigned long long)ourThread);
    auto cpuIndex = KeGetCurrentProcessorNumber();
    LogInfo("Running on CPU: %lu", cpuIndex);

    PKTHREAD thisThread = (PKTHREAD)__readgsqword(0x188);

    LogInfo("Hiding system thread.");
    thisThread = reinterpret_cast<PKTHREAD>(KeGetCurrentThread());
    LogInfo("\t\t\tKTHREAD->SystemThread = %lu", thisThread->SystemThread);
    thisThread->SystemThread = 0;
    LogInfo("\t\t\tKTHREAD->SystemThread = %lu", thisThread->SystemThread);

    LogInfo("Spoofing thread entry point.");
    _ETHREAD* myThread = reinterpret_cast<_ETHREAD*>(thisThread);
    
    LogInfo("\t\t\tOld: _ETHREAD->StartAddress = %p", myThread->StartAddress);
    // kernBase + 0x3000;
    myThread->StartAddress = newThreadEntry;
    LogInfo("\t\t\tNew: _ETHREAD->StartAddress = %p", myThread->StartAddress);
    
    LogInfo("\t\t\tOld:  _ETHREAD->Win32StartAddress = %p", myThread->Win32StartAddress);
    myThread->Win32StartAddress = newThreadEntry;
    LogInfo("\t\t\tNew:  _ETHREAD->Win32StartAddress = %p", myThread->Win32StartAddress);
}
```

`DiglettDriver/Thread.h`:

```h
#pragma once
#include "Driver.h"

void SpoofThread(PVOID newThreadEntry);
```

`DiglettDriver/Utility.cpp`:

```cpp
#pragma once
#include "Utility.h"
#include <windef.h>
#include <ntstrsafe.h>
#include <intrin.h>


NTSTATUS Utility::GetProcessBaseAddress(IN UINT32 pid, _Out_ PVOID* procBase)
{
	PEPROCESS pProcess = NULL;
	if (pid == 0)
		return STATUS_UNSUCCESSFUL;

	NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)pid, &pProcess);
	if (NtRet != STATUS_SUCCESS)
		return NtRet;

	*procBase = PsGetProcessSectionBaseAddress(pProcess);
	ObDereferenceObject(pProcess);
}

DWORD Utility::GetUserDirectoryTableBaseOffset()
{
	RTL_OSVERSIONINFOW ver = { 0 };
	RtlGetVersion(&ver);

	switch (ver.dwBuildNumber)
	{
	case WINDOWS_1803:
		return 0x0278;
		break;
	case WINDOWS_1809:
		return 0x0278;
		break;
	case WINDOWS_1903:
		return 0x0280;
		break;
	case WINDOWS_1909:
		return 0x0280;
		break;
	case WINDOWS_2004:
		return 0x0388;
		break;
	case WINDOWS_20H2:
		return 0x0388;
		break;
	case WINDOWS_21H1:
		return 0x0388;
		break;
	default:
		return 0x0388;
	}
}

//check normal dirbase if 0 then get from UserDirectoryTableBas
ULONG_PTR Utility::GetProcessCr3(PEPROCESS pProcess)
{
	PUCHAR process = (PUCHAR)pProcess;
	ULONG_PTR process_dirbase = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
	if (process_dirbase == 0)
	{
		DWORD UserDirOffset = GetUserDirectoryTableBaseOffset();
		ULONG_PTR process_userdirbase = *(PULONG_PTR)(process + UserDirOffset);
		return process_userdirbase;
	}
	return process_dirbase;
}

ULONG_PTR Utility::GetKernelDirBase()
{
	PUCHAR process = (PUCHAR)PsGetCurrentProcess();
	ULONG_PTR dirTableBase = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
	return dirTableBase;
}

NTSTATUS Utility::ReadVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* read)
{
	uint64_t paddress = TranslateLinearAddress(dirbase, address);
	return ReadPhysicalAddress(paddress, (uint64_t)buffer, size, read);
}

NTSTATUS Utility::WriteVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* written)
{
	uint64_t paddress = TranslateLinearAddress(dirbase, address);
	return WritePhysicalAddress(paddress, (uint64_t)buffer, size, written);
}

NTSTATUS Utility::ReadPhysicalAddress(uint64_t TargetAddress, uint64_t lpBuffer, SIZE_T Size, SIZE_T* BytesRead)
{
	MM_COPY_ADDRESS AddrToRead = { 0 };
	AddrToRead.PhysicalAddress.QuadPart = (UINT64)TargetAddress;
	return MmCopyMemory((PVOID)lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, BytesRead);
}

//MmMapIoSpaceEx limit is page 4096 byte
NTSTATUS Utility::WritePhysicalAddress(uint64_t TargetAddress, uint64_t lpBuffer, SIZE_T Size, SIZE_T* BytesWritten)
{
	if (!TargetAddress)
		return STATUS_UNSUCCESSFUL;

	PHYSICAL_ADDRESS AddrToWrite = { 0 };
	AddrToWrite.QuadPart = (UINT64)TargetAddress;

	PVOID pmapped_mem = MmMapIoSpaceEx(AddrToWrite, Size, PAGE_READWRITE);

	if (!pmapped_mem)
		return STATUS_UNSUCCESSFUL;

	memcpy(pmapped_mem, (PVOID)lpBuffer, Size);

	*BytesWritten = Size;
	MmUnmapIoSpace(pmapped_mem, Size);
	return STATUS_SUCCESS;
}

uint64_t Utility::TranslateLinearAddress(uint64_t directoryTableBase, uint64_t virtualAddress) {
	directoryTableBase &= ~0xf;

	uint64_t pageOffset = virtualAddress & ~(~0ul << PAGE_OFFSET_SIZE);
	uint64_t pte = ((virtualAddress >> 12) & (0x1ffll));
	uint64_t pt = ((virtualAddress >> 21) & (0x1ffll));
	uint64_t pd = ((virtualAddress >> 30) & (0x1ffll));
	uint64_t pdp = ((virtualAddress >> 39) & (0x1ffll));

	SIZE_T readsize = 0;
	uint64_t pdpe = 0;
	ReadPhysicalAddress(directoryTableBase + 8 * pdp, (uint64_t)&pdpe, sizeof(pdpe), &readsize);
	if (~pdpe & 1)
		return 0;

	uint64_t pde = 0;
	ReadPhysicalAddress((pdpe & PMASK) + 8 * pd, (uint64_t)&pde, sizeof(pde), &readsize);
	if (~pde & 1)
		return 0;

	/* 1GB large page, use pde's 12-34 bits */
	if (pde & 0x80)
		return (pde & (~0ull << 42 >> 12)) + (virtualAddress & ~(~0ull << 30));

	uint64_t pteAddr = 0;
	ReadPhysicalAddress((pde & PMASK) + 8 * pt, (uint64_t)&pteAddr, sizeof(pteAddr), &readsize);
	if (~pteAddr & 1)
		return 0;

	/* 2MB large page */
	if (pteAddr & 0x80)
		return (pteAddr & PMASK) + (virtualAddress & ~(~0ull << 21));

	virtualAddress = 0;
	ReadPhysicalAddress((pteAddr & PMASK) + 8 * pte, (uint64_t)&virtualAddress, sizeof(virtualAddress), &readsize);
	virtualAddress &= PMASK;

	if (!virtualAddress)
		return 0;

	return virtualAddress + pageOffset;
}

NTSTATUS Utility::ReadProcessMemory(UINT32 pid, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* read)
{
	PEPROCESS pProcess = NULL;
	if (pid == 0) return STATUS_UNSUCCESSFUL;

	NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)pid, &pProcess);
	if (NtRet != STATUS_SUCCESS) return NtRet;

	ULONG_PTR process_dirbase = GetProcessCr3(pProcess);
	ObDereferenceObject(pProcess);

	SIZE_T CurOffset = 0;
	SIZE_T TotalSize = size;
	while (TotalSize)
	{

		uint64_t CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
		if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

		ULONG64 ReadSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
		SIZE_T BytesRead = 0;
		NtRet = ReadPhysicalAddress(CurPhysAddr, ((ULONG64)AllocatedBuffer + CurOffset), ReadSize, &BytesRead);
		TotalSize -= BytesRead;
		CurOffset += BytesRead;
		if (NtRet != STATUS_SUCCESS) break;
		if (BytesRead == 0) break;
	}

	*read = CurOffset;
	return NtRet;
}

NTSTATUS Utility::WriteProcessMemory(UINT32 pid, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* written)
{
	PEPROCESS pProcess = NULL;
	if (pid == 0) return STATUS_UNSUCCESSFUL;

	NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)pid, &pProcess);
	if (NtRet != STATUS_SUCCESS) return NtRet;

	ULONG_PTR process_dirbase = GetProcessCr3(pProcess);
	ObDereferenceObject(pProcess);

	SIZE_T CurOffset = 0;
	SIZE_T TotalSize = size;
	while (TotalSize)
	{
		uint64_t CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
		if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

		ULONG64 WriteSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
		SIZE_T BytesWritten = 0;
		NtRet = WritePhysicalAddress(CurPhysAddr, ((ULONG64)AllocatedBuffer + CurOffset), WriteSize, &BytesWritten);
		TotalSize -= BytesWritten;
		CurOffset += BytesWritten;
		if (NtRet != STATUS_SUCCESS) break;
		if (BytesWritten == 0) break;
	}

	*written = CurOffset;
	return NtRet;
}

/// <summary>
/// Dynamic importing via a documented method
/// </summary>
/// <param name="pWinPrims">Array that holds WinPrimitive pointers</param>
/// <param name="names">names of routines to import</param>
/// <returns></returns>
NTSTATUS Utility::ImportWinPrimitives(_Out_ GenericFuncPtr(pWinPrims[]), IN wchar_t* names[])
{
	LogInfo("Importing windows primitives\n");

	UNICODE_STRING uniNames[WINAPI_IMPORT_COUNT];

	for (size_t i = 0; i < WINAPI_IMPORT_COUNT; i++)
	{
		RtlInitUnicodeString(&uniNames[i], names[i]);
	}

	for (size_t i = 0; i < WINAPI_IMPORT_COUNT; i++)
	{
		pWinPrims[i] = (GenericFuncPtr)MmGetSystemRoutineAddress(&uniNames[i]);
		if (pWinPrims[i] == NULL)
		{
			LogError("Failed to import %ls\n", uniNames[i].Buffer);
			return STATUS_UNSUCCESSFUL;
		}
		else
		{
			LogInfo("Succesfully imported %ls at %p\n", uniNames[i].Buffer, pWinPrims[i]);
		}
	}
	return STATUS_SUCCESS;
}

NTSTATUS Utility::Sleep(IN LONG milliseconds)
{
	LARGE_INTEGER interval;
	interval.QuadPart = -(10ll * milliseconds);

	return KeDelayExecutionThread(KernelMode, FALSE, &interval);
}

BOOL Utility::GetUserModBase(PCHAR modName, UINT64 pid, PUINT64 outBase, PUINT64 outSize)
{
	LogInfo("Outputting modules for PID: %llu", pid);
	PEPROCESS process = NULL;
	PsLookupProcessByProcessId((HANDLE)pid, &process);
	if (!process)
	{
		LogInfo("Failed to retrieve EPROCESS struct");
		return false;
	}
	LogInfo("\nPEPROCESS: 0x%p", process);

	// virtual address is in context of that process

	const auto peb = PsGetProcessPeb(process);
	LogInfo("\nPEB: 0x%p", peb);

	// Change cr3 so that translation in the CPU as we need to access virtual address from game

	const auto dirBase = GetProcessCr3(process);
	LogInfo("\nDirectory Base: 0x%p", (PVOID)dirBase);

	// Loop through peb->ldr->InMemoryOrderModuleList
	UINT64 ldrAddr = NULL;
	SIZE_T read = 0;

	// ldr offset on 21H1 0x18
	NTSTATUS status = ReadVirtual(dirBase, ((UINT64)peb + 0x18), (uint8_t*)&ldrAddr, 0x8, &read);
	if (!NT_SUCCESS(status))
	{
		LogInfo("Failed to read Peb->Ldr");
		return false;
	}
	LogInfo("\nPeb->Ldr: 0x%p", (PVOID)ldrAddr);

	PLIST_ENTRY inMemoryOrderModuleList;
	read = 0;
	// InMemoryOrderModList offset 0x20 on 21H1
	status = ReadVirtual(dirBase, (uint64_t)(ldrAddr + 0x20), (uint8_t*)&inMemoryOrderModuleList, 0x8, &read);
	if (!NT_SUCCESS(status))
	{
		LogInfo("Failed to read Peb->Ldr->InMemoryOrderModuleList");
		return false;
	}

	LogInfo("\nPeb->Ldr->InMemoryOrderModuleList.Flink: 0x%p", inMemoryOrderModuleList);


	const auto calling_process_cr3 = __readcr3();
	const auto games_cr3 = GetProcessCr3(process); //(UINT64)((BYTE*)process + 0x28);

	//PLDR_DATA_TABLE_ENTRY
	//LogInfo("\nPeb->Ldr->InMemoryOrderModuleList.Flink->FullDllName: %wZ", ((PLDR_DATA_TABLE_ENTRY)inMemoryOrderModuleList->Flink)->FullDllName);

	//PLIST_ENTRY head = inMemoryOrderModuleList;//(PLIST_ENTRY)(((UINT64) *((PVOID*)((UINT64)peb + 0xC))) + 0x14);
	PLIST_ENTRY head = (PLIST_ENTRY)(ldrAddr + 0x20);
	PLIST_ENTRY next;

	//LogInfo("head: %p", head);
	//LogInfo("head->Flink: %p", head->Flink);
	PLDR_DATA_TABLE_ENTRY entry;
	int i = 0;
	//KIRQL oldIrql = KeGetCurrentIrql();
	// IRQL_NOT_LESS_OR_EQUAL

//	__writecr8(0xF);
	//auto oldIrql = KeRaiseIrqlToDpcLevel();
	//_disable();
//	LogInfo("oldIrql: %d", oldIrql);

	//__writecr3(games_cr3);

	//LogInfo("head->Flink: %p", head->Flink);
	//next = head->Flink;
	//entry = (PLDR_DATA_TABLE_ENTRY)next;
	//LogInfo("entry->FullDllName: %wZ", &(entry->FullDllName));

	//next = next->Flink;
	//entry = (PLDR_DATA_TABLE_ENTRY)next;
	//LogInfo("entry->FullDllName: %wZ", &(entry->FullDllName));

	//LogInfo("head->Flink: %wZ", &(((PLDR_DATA_TABLE_ENTRY)head)->FullDllName));
	//__writecr3(games_cr3);
	KAPC_STATE ApcState;
#ifndef LEGIT_DRIVER
	auto oldIrql = KeGetCurrentIrql();
	__writecr8(0xF);
	__writecr3(games_cr3);
	__try
	{
		for (next = head->Flink; next != head; next = next->Flink) {
			// Check if BaseDllName matches our target
			entry = (PLDR_DATA_TABLE_ENTRY)next;
			LogInfo("entry->FullDllName: %wZ", &(entry->FullDllName));
			LogInfo("entry->DllBase: %p", &(entry->DllBase));
		}
	}
	__except (GetExceptionCode() == STATUS_ACCESS_VIOLATION)
	{
		LogInfo("Custom SEH for STATUS_ACCESS_VIOLATION executed");
	}
	__writecr3(calling_process_cr3);
	__writecr8(oldIrql);
#else
	KeStackAttachProcess(process, &ApcState);

	for (next = head->Flink; next != head; next = next->Flink) {
		// Check if BaseDllName matches our target
		entry = (PLDR_DATA_TABLE_ENTRY)next;
		LogInfo("entry->FullDllName: %wZ", &(entry->FullDllName));
		LogInfo("entry->DllBase: %p", &(entry->DllBase));
	}

	//const auto base = (uintptr_t)cur_entry->DllBase;
	//const auto size = (size_t)cur_entry->SizeOfImage;

	// Detach, we are now back in the address space of our calling process

	KeUnstackDetachProcess(&ApcState);
#endif // LEGIT_DRIVER



	//LogInfo("Thread dies? 1");
	//__writecr3(calling_process_cr3);
	//_enable();
	//KeLowerIrql(oldIrql);
//	__writecr8(oldIrql);
	ObDereferenceObject(process);
	//*outBase = base;
	//*outSize = size;
	return true;
}

/// <summary>
/// Search for pattern https://github.com/DarthTon/Blackbone/blob/a672509b5458efeb68f65436259b96fa8cd4dcfc/src/BlackBoneDrv/Utils.c#L199
/// </summary>
/// <param name="pattern">Pattern to search for</param>
/// <param name="wildcard">Used wildcard</param>
/// <param name="len">Pattern length</param>
/// <param name="base">Base address for searching</param>
/// <param name="size">Address range to search in</param>
/// <param name="ppFound">Found location</param>
/// <returns>Status code</returns>
NTSTATUS Utility::SearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, _Out_ PVOID* ppFound)
{
	ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
	if (ppFound == NULL || pattern == NULL || base == NULL)
		return STATUS_INVALID_PARAMETER;

	for (ULONG_PTR i = 0; i < size - len; i++)
	{
		BOOLEAN found = TRUE;
		for (ULONG_PTR j = 0; j < len; j++)
		{
			if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
			{
				found = FALSE;
				break;
			}
		}

		if (found != FALSE)
		{
			*ppFound = (PUCHAR)base + i;
			return STATUS_SUCCESS;
		}
	}

	return STATUS_NOT_FOUND;
}

```

`DiglettDriver/Utility.h`:

```h
#pragma once
#include <ntifs.h>
#include "Driver.h"

typedef unsigned char uint8_t;
typedef unsigned long long uint64_t;

//https://ntdiff.github.io/
#define WINDOWS_1803 17134
#define WINDOWS_1809 17763
#define WINDOWS_1903 18362
#define WINDOWS_1909 18363
#define WINDOWS_2004 19041
#define WINDOWS_20H2 19569
#define WINDOWS_21H1 20180

#define PAGE_OFFSET_SIZE 12
static const uint64_t PMASK = (~0xfull << 8) & 0xfffffffffull;

class Utility
{
public:
	static NTSTATUS GetProcessBaseAddress(_In_ UINT32 pid, _Out_ PVOID* procBase);
	static DWORD GetUserDirectoryTableBaseOffset();
	static ULONG_PTR GetProcessCr3(PEPROCESS pProcess);
	static ULONG_PTR GetKernelDirBase();
	static NTSTATUS ReadVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* read);
	static NTSTATUS WriteVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* written);
	static NTSTATUS ReadPhysicalAddress(uint64_t TargetAddress, uint64_t lpBuffer, SIZE_T Size, SIZE_T* BytesRead);
	static NTSTATUS WritePhysicalAddress(uint64_t TargetAddress, uint64_t lpBuffer, SIZE_T Size, SIZE_T* BytesWritten);
	static uint64_t TranslateLinearAddress(uint64_t directoryTableBase, uint64_t virtualAddress);
	static NTSTATUS ReadProcessMemory(UINT32 pid, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* read);
	static NTSTATUS WriteProcessMemory(UINT32 pid, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* written);
	static NTSTATUS ImportWinPrimitives(_Out_ GenericFuncPtr pWinPrims[], _In_ wchar_t* names[]);
	static BOOL GetUserModBase(PCHAR modName, UINT64 pid, PUINT64 outBase, PUINT64 outSize);
	static NTSTATUS Sleep(_In_ LONG milliseconds);
	NTSTATUS SearchPattern(_In_ PCUCHAR pattern, _In_ UCHAR wildcard, _In_ ULONG_PTR len, _In_ const VOID* base, _In_ ULONG_PTR size, _Out_ PVOID* ppFound);
	static NTSTATUS SpoofThread();
	static NTSTATUS UnSpoofThread();

private:
	PRTL_PROCESS_MODULES outProcMods = NULL;
	DevCtrlPtr origDeviceControl = NULL;
	volatile bool runThread = true;
	uintptr_t kernBase = NULL;
};

```

`DiglettDriver/asmstubs.h`:

```h
extern "C" void mysyscall();
```

`README.md`:

```md
<img src="diglett.png" width="350" height="300">

# Diglett
Does his best to hide in kernel-land

## Detection Mitigations
**Thread**
- Hides system thread
- Changes entry address

<img src="Diglettoutput.png" width="475" height="300">

```