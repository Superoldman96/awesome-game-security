Project Path: arc_gmh5225_obfuscation_analysis_2etw5vtd

Source Tree:

```txt
arc_gmh5225_obfuscation_analysis_2etw5vtd
├── LICENSE
├── README.md
├── __init__.py
├── examples
│   ├── README.md
│   └── samples.zip
├── imgs
│   ├── log_output.png
│   ├── mba_simplification_workflow.gif
│   ├── opaque_predicates.png
│   ├── plugin_menu.png
│   ├── plugin_settings.png
│   └── simplified_mba.png
├── msynth_oracle.pickle
├── obfuscation_analysis
│   ├── __init__.py
│   ├── features.py
│   ├── mba
│   │   ├── __init__.py
│   │   ├── simplifer.py
│   │   ├── slicing.py
│   │   └── translation.py
│   └── utils.py
├── plugin.json
└── requirements.txt

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`README.md`:

```md
# Obfuscation Analysis (v1.0)
Authors: **Tim Blazytko & Nicolò Altamura**

_Analyze and simplify obfuscated code_


## Description:

_Obfuscation Analysis_ is a Binary Ninja plugin that takes the pain out of working with heavily protected binaries.
It bundles a handful of focused helpers that let you

* simplify Mixed-Boolean Arithmetic (MBA) expressions in one click (based on [msynth](https://github.com/mrphrazer/msynth))
* locate and scrub functions with broken disassembly

Some example use cases can be found in [examples](./examples). The plugin complements [Obfuscation Detection](https://github.com/mrphrazer/obfuscation_detection/): once suspicious functions are flagged, _Obfuscation Analysis_ helps you clean and understand them. More helpers will be added over time.


## Core Features

* simplify Mixed-Boolean Arithmetic obfuscation in Binary Ninja's decompiler view
* identify and remove functions with broken disassembly
* efficient and architecture-agnostic implementation
* runs as a background task
* careful error handling: concise user messages, full trace in the Debug log


## Installation

The tool can be installed using Binary Ninja's plugin manager.

For a manual installation, follow these steps in Binary Ninja's plugin folder:

```
git clone https://github.com/mrphrazer/obfuscation_analysis.git
cd obfuscation_analysis

# optionally: use a virtual environment
python -m venv obfana-env
source obfana-env/bin/activate

# install requirements
pip install -r requirements.txt
```

If you use a virtual environment, you'll need to manually set the `site-packages` path in the Binary Ninja settings.


## Usage

The plugin is available from **Binary Ninja’s** top-bar menu under `Plugins -> Obfuscation Analysis`.

<p align="left">
<img alt="Plugin Menu" src="imgs/plugin_menu.png" width="500"/>
</p>


### MBA Simplification

To simplify arithmetic obfuscation, first highlight the HLIL expression you want to simplify in the decompiler view. Next, choose `Plugins -> Obfuscation Analysis -> MBA Simplification -> Slice & Simplify`. The plugin resolves the full computation, runs it through msynth, and inserts the simplified result as a comment on the same line. The short animation below shows the entire workflow:

<p align="left">
<img alt="MBA Simplification Workflow" src="imgs/mba_simplification_workflow.gif"/>
</p>

MBA simplification relies on msynth. By default, the plugin uses [msynth’s default simplification oracle](https://github.com/mrphrazer/msynth?tab=readme-ov-file#pre-computed-simplification-lookup-tables), which ships with the plugin and is pre-configured. If you want to use a larger or custom oracle, set `obfuscation_analysis.mba_oracle_path` manually or browse to the file in Binary Ninja’s Settings window.

<p align="left">
<img alt="Plugin Settings" src="imgs/plugin_settings.png" width="500"/>
</p>

If something goes wrong the plugin writes a concise user-level message to the Log pane; switch the log view to `Debug` to see the full traceback.

<p align="left">
<img alt="Log Output" src="imgs/log_output.png"/>
</p>


## Features

The plugin ships focused helpers that target common roadblocks you hit when reversing protected binaries, each runnable as a background task from the UI or head-less scripts. Below are the features currently available.


### Corrupted Functions

Corrupted Functions are functions whose disassembly shows undefined artefacts—empty basic blocks, invalid or overlapping instructions, and the like. This helper walks the entire BinaryView, flags functions with those symptoms, and lists them such that the analyst can quickly inspect code that was mis-parsed or deliberately obfuscated. An optional remove action erases every flagged function and forces a fresh analysis, cleaning up the function list. It is particularly useful for locating

* data blobs that the disassembler mistakenly promoted to code
* obfuscation stubs that break straight-line disassembly
* functions using overlapping instructions or mis-aligned jumps
* problems with newer architectures where uncommon instructions are encountered


### MBA Simplification

Mixed-Boolean Arithmetic (MBA) is an obfuscation technique that buries simple computations in long chains of arithmetic and Boolean operations. This feature simplifies such expressions in the decompiler. When you pick an HLIL instruction, the plugin collects its complete computation chain with an SSA backward slice restricted to the current basic block, translates that slice to Miasm IR, feeds it into msynth, and finally adds the simplified result as a comment in the decompiler view. This feature allows you to

* collapse multi-line MBA tangles into a single, readable equation
* resolve opaque predicates that rely on MBAs
* fold convoluted constant encodings down to their literal value


## Limitations

The plugin has a few caveats you should be aware of, most of them related to the MBA simplification pipeline:

* **Binary Ninja bug**: on BN 5.0 stable, the backward-slicing step may fail because of missing HLIL type-casts: https://github.com/Vector35/binaryninja-api/issues/6371; the issue is fixed in *5.1.7477-de* and newer

* **slice confined to one basic block**: variable definitions located in predecessor blocks are ignored (often control-flow dependent), so some MBA terms may stay partially resolved

* **HLIL to Miasm IR translation gaps**: not every HLIL construct has a sound Miasm equivalent; when translation fails the expression is skipped and an error is logged

* **IL coverage**: control-flow nodes and floating-point operations are currently not translated

* **inherited msynth constraints** : MBA simplification inherits all [msynth limitations](https://github.com/mrphrazer/msynth/blob/main/README.md#limitations-and-future-work)


## Contact

For more information, contact Tim Blazytko ([@mr_phrazer](https://x.com/mr_phrazer)) or Nicolò Altamura ([@nicolodev](https://x.com/nicolodev)).

```

`__init__.py`:

```py
"""
Binary Ninja plugin entrypoint for *Obfuscation Analysis*.

Registers UI commands, user-visible settings, and wires them to the
background-thread helpers.
"""
from pathlib import Path
from binaryninja import PluginCommand
from binaryninja.settings import Settings

from .obfuscation_analysis import (identify_corrupted_functions_bg,
                                   remove_corrupted_functions_bg,
                                   simplify_hlil_instruction_bg)

# ----------------------------------------------------------------------
#  Command registrations
# ----------------------------------------------------------------------

PluginCommand.register_for_high_level_il_instruction(
    "Obfuscation Analysis\\MBA Simplification\\Slice && Simplify",
    (
        "Back-slice the selected HLIL expression, translate it to Miasm IR, "
        "run msynth for Mixed-Boolean Arithmetic (MBA) simplification, and "
        "annotate the result as a decompiler comment."
    ),
    simplify_hlil_instruction_bg,
)

PluginCommand.register(
    "Obfuscation Analysis\\Corrupted Functions\\Identify Corrupted Functions",
    (
        "Scan the binary for functions that contain undefined or overlapping "
        "instructions (typical artefacts of failed disassembly)."
    ),
    identify_corrupted_functions_bg,
)

PluginCommand.register(
    "Obfuscation Analysis\\Corrupted Functions\\Remove Corrupted Functions",
    (
        "Remove all functions with corrupted disassembly from the BinaryView "
        "and trigger re-analysis to clean up the function list."
    ),
    remove_corrupted_functions_bg,
)

# ----------------------------------------------------------------------
#  User-visible settings
# ----------------------------------------------------------------------

plugin_dir = Path(__file__).resolve().parent
mba_oracle_path = f"{plugin_dir}/msynth_oracle.pickle"

Settings().register_group("obfuscation_analysis", "Obfuscation Analysis")
Settings().register_setting(
    "obfuscation_analysis.mba_oracle_path",
    f'''{{
        "description" : "Absolute path to the oracle database shipped with msynth. Required for MBA simplification.", 
        "title" : "msynth Oracle DB Path", 
        "default" : "{mba_oracle_path}", 
        "type" : "string",
        "requiresRestart": true,
        "optional": false,
        "uiSelectionAction": "file"
    }}'''
)

```

`examples/README.md`:

```md
# Example Use Cases

The samples provided in `samples.zip` can be used to test the plugin and reproduce the results. To unpack, use the password "infected" or the following command:

```bash
$ unzip -P infected samples.zip
```


## Hiding Arithmetic Computations

`challenge.bin` packs several function-local MBA expressions that hide otherwise trivial calculations.  Applying `Slice & Simplify` on the return instructions collapse the MBAs into their readable form.

<p align="left">
<img alt="Opaque Predicates" src="../imgs/simplified_mba.png"/>
</p>


## Opaque Predicates

`opaque_malware.bin` relies on MBA-based opaque predicates to obfuscate its control flow. Each predicate is limited to a single basic block and evaluates to aconstant 0 or 1, but the original expression is purposefully convoluted. Running the simplifier on these branches reveals the constant outcome, making the hidden control-flow obvious.

<p align="left">
<img alt="Opaque Predicates" src="../imgs/opaque_predicates.png"/>
</p>


```

`obfuscation_analysis/__init__.py`:

```py
from __future__ import annotations

from typing import Callable, Generic, TypeVar

from binaryninja.binaryview import BinaryView
from binaryninja.highlevelil import HighLevelILInstruction
from binaryninja.plugin import BackgroundTaskThread

from .features import (
    simplify_hlil_mba_slice_at,
    identify_corrupted_functions,
    remove_corrupted_functions,
)

# ---------------------------------------------------------------------------
# Internal background-task wrappers
# ---------------------------------------------------------------------------

T = TypeVar("T")  # generic parameter type for BGTask1Param


class BGTask(BackgroundTaskThread):
    """
    Background task that forwards **only** the :class:`~binaryninja.binaryview.BinaryView`
    to the worker function.

    Parameters
    ----------
    bv :
        BinaryView on which *fn* will be executed.
    msg :
        Short status string shown in Binary Ninja’s task manager.
    fn :
        Callable expecting **one** positional argument `(bv)`.  It is run in
        the worker thread created by Binary Ninja.
    """

    def __init__(self, bv: BinaryView, msg: str, fn: Callable[[BinaryView], None]):
        super().__init__(msg, True)
        self._bv: BinaryView = bv
        self._fn: Callable[[BinaryView], None] = fn

    def run(self) -> None:
        """Entrypoint executed inside the BN worker thread."""
        self._fn(self._bv)


class BGTask1Param(BackgroundTaskThread, Generic[T]):
    """
    Background task that forwards the :class:`BinaryView` and one additional
    parameter `param` to the worker function.

    Parameters
    ----------
    bv :
        Active BinaryView.
    param :
        Extra argument forwarded verbatim to *fn*.
    msg :
        Status text for Binary Ninja’s task pane.
    fn :
        Callable expecting two positional arguments `(bv, param)`.
    """

    def __init__(
        self,
        bv: BinaryView,
        param: T,
        msg: str,
        fn: Callable[[BinaryView, T], None],
    ):
        super().__init__(msg, True)
        self._bv: BinaryView = bv
        self._param: T = param
        self._fn: Callable[[BinaryView, T], None] = fn

    def run(self) -> None:
        """Entrypoint executed inside the BN worker thread."""
        self._fn(self._bv, self._param)


# ---------------------------------------------------------------------------
# Public helpers used by the plugin’s UI commands
# ---------------------------------------------------------------------------

def simplify_hlil_instruction_bg(
    bv: BinaryView,
    instruction: HighLevelILInstruction,
) -> None:
    """
    Launch *Mixed-Boolean Arithmetic* (MBA) simplification for **one** HLIL
    instruction in a background thread.

    Workflow
    --------
    1. Slice the selected HLIL node to its basic block in SSA form.
    2. Translate the slice to Miasm IR.
    3. Pass the IR to *msynth* for MBA simplification.
    4. Attach the simplified expression as a decompiler comment.

    Parameters
    ----------
    bv :
        Active BinaryView.
    instruction :
        HLIL node picked by the user via the decompiler view.
    """
    BGTask1Param(
        bv=bv,
        param=instruction,
        msg="Simplifying MBA (BB slice)",
        fn=simplify_hlil_mba_slice_at,
    ).start()


def identify_corrupted_functions_bg(bv: BinaryView) -> None:
    """
    Start a background scan that identifies functions whose disassembly shows
    *undefined* or *overlapping* instructions—common artefacts of failed
    linear sweep or mis-decoded basic blocks.

    Parameters
    ----------
    bv :
        Active BinaryView to be inspected.
    """
    BGTask(
        bv=bv,
        msg="Scanning corrupted functions",
        fn=identify_corrupted_functions,
    ).start()


def remove_corrupted_functions_bg(bv: BinaryView) -> None:
    """
    Remove every function flagged as *corrupted* and trigger a full
    re-analysis.

    Parameters
    ----------
    bv :
        Active BinaryView to be cleaned up.
    """
    BGTask(
        bv=bv,
        msg="Removing corrupted functions",
        fn=remove_corrupted_functions,
    ).start()
```

`obfuscation_analysis/features.py`:

```py
from typing import Iterable

from binaryninja.binaryview import BinaryView
from binaryninja.function import Function
from binaryninja.highlevelil import HighLevelILInstruction

from .mba.simplifer import get_simplifier
from .mba.slicing import backward_slice_basic_block_level
from .utils import find_corrupted_functions, user_error


def simplify_hlil_mba_slice_at(
    bv: BinaryView,
    instruction: HighLevelILInstruction,
) -> None:
    """
    Slice-and-simplify one HLIL instruction with msynth and drop the
    result as a user comment.

    Workflow
    --------
    1. Backward slice (single BB) –  
       `backward_slice_basic_block_level` resolves the instruction’s SSA
       dependency chain and translates the fully-inlined expression to
       Miasm IR.
    2. MBA simplification –  
       The cached simplifier canonicalises the Mixed-
       Boolean Arithmetic (MBA) expression.
    3. Annotate –  
       The simplified expression is attached as a decompiler comment at the
       instruction’s address.

    Error handling
    --------------
    * Any failure in translation or simplification is caught locally.  
    * A concise red line appears in Binary Ninja’s log; the full traceback
      is available when *Debug Log* is enabled.  
    * The function then returns early, leaving no partial comment behind.

    Parameters
    ----------
    bv :
        The active :class:`BinaryView`; needed only for architecture
        pointer-size information inside the slice routine.
    instruction :
        The HLIL instruction currently selected by the user.

    Side effects
    ------------
    * On success, a comment is written into
      ``instruction.function.source_function`` at `instruction.address`.
    * No value is returned; caller need not inspect a result.
    """

# backward slice in SSA form
    try:
        expr_m2 = backward_slice_basic_block_level(
            bv, instruction, instruction.function.ssa_form)
        # if assignment, only take right-hand side
        if expr_m2.is_assign():
            expr_m2 = expr_m2.src
    except Exception as err:
        user_error(
            f"Failed to translate HLIL expression at {hex(instruction.address)} to Miasm IR: {err}", exc=err)
        return

    # get simplifier
    simplifier = get_simplifier()
    if simplifier is None:
        return

    # simplify
    try:
        simplified = simplifier.simplify(expr_m2)
    except Exception as err:
        user_error(
            f"Could not simplify HLIL expression at address {hex(instruction.address)} using msynth: {err}", exc=err)
        return

    # add simplified expression as comment
    instruction.function.source_function.set_comment_at(
        instruction.address,
        str(simplified).replace("#0", ""),
    )


def identify_corrupted_functions(bv: BinaryView) -> None:
    """
    Emit a diagnostic list of functions with corrupted disassembly.

    A function is treated as corrupted, which typically happens if the linear sweep 
    created overlapping or undefined instructions—common in packed/obfuscated binaries.

    Parameters
    ----------
    bv : BinaryView
        Active BinaryView to scan.
    """
    for func in find_corrupted_functions(bv):
        print(f"Corrupted disassembly at {func.name} (0x{func.start:x})")


def remove_corrupted_functions(bv: BinaryView) -> None:
    """
    Remove (undefine) every corrupted function and force Binary Ninja to
    re-analyse the binary.

    Useful for cleaning up the function list when heavy obfuscation causes
    a flood of bogus or partially decoded functions.

    Note: In some cases this might be too aggressive.

    Parameters
    ----------
    bv : BinaryView
        Active BinaryView to clean up.
    """
    for func in find_corrupted_functions(bv):
        print(f"Removing corrupted function {func.name} (0x{func.start:x})")
        bv.remove_function(func)

    # Enforce re-analysis
    bv.update_analysis()

```

`obfuscation_analysis/mba/simplifer.py`:

```py
"""
Singleton wrapper around msynth’s `Simplifier`.

*  Lazy-initialised the first time `get_simplifier` is called.
*  Thread-safe via a tiny `threading.Lock`.
*  Emits concise user errors (with full trace in *Debug* log) when the
   oracle path is missing or the initialisation fails.
"""
from __future__ import annotations

from pathlib import Path
from threading import Lock
from typing import Optional

from binaryninja.settings import Settings
from msynth import Simplifier

from ..utils import user_error

# ----------------------------------------------------------------------
# Internal singleton state
# ----------------------------------------------------------------------

_MBA_SIMPLIFIER: Optional[Simplifier] = None
_LOCK = Lock()  # guards first-time creation


# ----------------------------------------------------------------------
# Public helpers
# ----------------------------------------------------------------------

def get_simplifier() -> Optional[Simplifier]:
    """
    Return the global `Simplifier` instance, creating it on first use.

    On failure (oracle not configured / not found / msynth error) a concise
    message is logged and `None` is returned, so callers can fall back gracefully.

    Returns
    -------
    Simplifier | None
    """
    global _MBA_SIMPLIFIER

    # fast path
    if _MBA_SIMPLIFIER is not None:
        return _MBA_SIMPLIFIER

    # thread-safe lazy init
    with _LOCK:
        if _MBA_SIMPLIFIER is not None:
            return _MBA_SIMPLIFIER

        oracle_path = Settings().get_string(
            "obfuscation_analysis.mba_oracle_path"
        ).strip()

        # ---- configuration sanity checks --------------------------------
        if not oracle_path:
            user_error(
                "msynth oracle path not configured – set it under "
                "Settings → Obfuscation Analysis."
            )
            return None

        if not Path(oracle_path).exists():
            user_error(f"Oracle database for msynth not found: {oracle_path}")
            return None

        # ---- create Simplifier ------------------------------------------
        try:
            _MBA_SIMPLIFIER = Simplifier(oracle_path=oracle_path)
        except Exception as err:  # pragma: no cover
            user_error(
                "Failed to initialise msynth simplifier – see Debug Log.",
                exc=err,
            )
            _MBA_SIMPLIFIER = None

    return _MBA_SIMPLIFIER


def set_simplifier(simplifier: Simplifier) -> None:
    """
    Manually inject a pre-created `Simplifier`.
    """
    global _MBA_SIMPLIFIER
    with _LOCK:
        _MBA_SIMPLIFIER = simplifier

```

`obfuscation_analysis/mba/slicing.py`:

```py
from __future__ import annotations

from typing import Optional

from binaryninja import SSAVariable
from binaryninja.binaryview import BinaryView
from binaryninja.highlevelil import (HighLevelILFunction,
                                     HighLevelILInstruction, HighLevelILVarPhi)
from miasm.expression.expression import Expr

from .translation import hlil_to_miasm, ssa_variable_to_miasm


def backward_slice_basic_block_level(
    bv: BinaryView,
    instr: HighLevelILInstruction,
    hlil: HighLevelILFunction,
) -> Optional[Expr]:
    """
    Statically backward-slice instr inside its HLIL basic block, recursively
    inlining SSA definitions, and return the resolved expression in Miasm IR.

    Algorithm (single basic block)
    ------------------------------
    1. Translate the root `instr.ssa_form` to Miasm (`expr_m2`).
    2. Build a work-list with every SSA variable the root expression reads.
    3. While the work-list is not empty:  
       a. Pop one SSA variable.  
       b. Fetch its definition. Skip if it lies outside the same basic block
          or is a `HLIL_VAR_PHI`.  
       c. Translate the definition’s *source* to Miasm; if translation
          raises an *Exception*, skip that variable.  
       d. Immediately substitute the SSA variable in `expr_m2` with the
          translated sub-expression.  
       e. Push every *new* SSA variable the definition reads onto the
          work-list.

    Limitations
    -----------
    * Only register SSA variables are inlined; memory SSA is ignored.
    * Definitions in predecessor blocks are not followed.
    * Unsupported HLIL -> Miasm constructs are silently skipped.

    Returns
    -------
    Expr
        Fully inlined Miasm expression.
    """
    # fetch HLIL basic block
    cur_basic_block = hlil.get_basic_block_at(instr.instr_index)
    # get SSA form
    expr = instr.ssa_form
    # set HLIL root to SSA basic block
    start_bb = cur_basic_block.start
    end_bb = cur_basic_block.end

    # init expression in miasm IR
    expr_m2 = hlil_to_miasm(bv, expr)

    # init worklist with variable uses (variables in a SSA form)
    worklist = [v for v in set(expr.ssa_form.vars_read)
                if isinstance(v, SSAVariable) and hlil.get_ssa_var_definition(v) != None]

    # replacement dictionary for miasm expression
    replacements = {}

    # process worklist
    while len(worklist) > 0:
        # pop variable from stack
        variable = worklist.pop(-1)

        # get variable definition
        definition = hlil.get_ssa_var_definition(variable)

        # skip if no definition
        if definition is None:
            continue

        # skip definitions outside the current basic block
        if definition.instr_index < start_bb or definition.instr_index > end_bb:
            continue

        # skip SSA phi functions
        if isinstance(definition, HighLevelILVarPhi):
            continue

        # replace SSA variable with its definition in miasm IR
        replacements[ssa_variable_to_miasm(
            variable)] = hlil_to_miasm(bv, definition.src)
        expr_m2 = expr_m2.replace_expr(replacements)

        # add variable uses to worklist
        for v in set(definition.vars_read):
            if hlil.get_ssa_var_definition(v) != None:
                worklist.append(v)

    return expr_m2

```

`obfuscation_analysis/mba/translation.py`:

```py
from binaryninja.highlevelil import *
from binaryninja.variable import Variable
from miasm.expression.expression import *
from binaryninja.binaryview import BinaryView


def variable_to_miasm(v: Variable) -> ExprId:
    """
    Convert a non-SSA Binary Ninja `Variable to a Miasm.

    The original variable name is kept verbatim and the bit-width is taken
    from `v.type.width` (bytes -> bits).
    """
    name = v.name
    size = v.type.width * 8
    return ExprId(name, size)


def ssa_variable_to_miasm(v: Variable) -> ExprId:
    """
    Convert a Binary Ninja SSA variable to a Miasm `ExprId`.

    The SSA index is appended as `name#version` so each version receives
    a unique Miasm identifier.

    Example
    -------
    `eax@3` -> `ExprId("eax#3", 32)`
    """
    name = f"{v.name}#{v.version}"
    size = v.type.width * 8
    return ExprId(name, size)


def mem_variable_to_miasm(v: Variable) -> ExprMem:
    """
    Return a Miasm `ExprMem` that models [*v]`.

    Internally this calls `ssa_variable_to_miasm` to obtain the
    address expression and wraps it in an `ExprMem` of matching
    bit-width.
    """
    size = v.type.width * 8
    return ExprMem(ssa_variable_to_miasm(v), size)


def hlil_to_miasm(
    bv: BinaryView,
    expr: ExpressionIndex,
) -> Expr:
    """
    Recursively translate a Binary Ninja HLIL expression to a Miasm
    Expr.

    The routine walks the HLIL AST and builds a semantically equivalent Miasm tree.  Only
    side-effect-free value expressions are supported; control-flow
    constructs (`if`, `switch`, loops, `goto`, PHI nodes, …) raise an
    Exception.

    Parameters
    ----------
    bv :
        BinaryView.
        Needed mainly for pointer size (`bv.arch.address_size`).
    expr :
        Any for of HLIL Expression,. `ExpressionIndex`
        (SSA or non-SSA).

    Returns
    -------
    Expr
        A Miasm expression whose bit-width matches ``expr.size``.
        The function never returns ``None``—translation failures are
        signalled via an ``Exception``.

    Raises
    ------
    Exception
        When *expr* (or any of its children) represents a construct that
        cannot be mapped to Miasm IR—for example:

        * High-level control flow (`HLIL_IF`, `HLIL_SWITCH`, …)
        * SSA PHI or memory-PHI nodes
        * Intrinsic or unimplemented HLIL operations

    Notes
    -----
    * Integer widths are expressed in **bits** (``expr.size * 8``), as
      required by Miasm.
    * SSA variables are rendered as ``name#version`` to keep each version
      distinct within the IR.
    * For double-precision divisions/modulos (e.g. ``DIVU_DP``) the result
      is truncated with :class:`~miasm.expression.expression.ExprSlice`
      because Miasm internally yields the full 128-bit quotient/remainder.
    """
    match expr.operation:

        case HighLevelILOperation.HLIL_IF:
            # translate only condition
            return hlil_to_miasm(bv, expr.condition)

        case HighLevelILOperation.HLIL_JUMP:
            # translate jump target
            return hlil_to_miasm(bv, expr.operands[0])

        case HighLevelILOperation.HLIL_LABEL:
            return ExprId(expr.target, expr.size)

        case HighLevelILOperation.HLIL_ASSIGN_MEM_SSA:
            lhs = hlil_to_miasm(bv, expr.dest)
            rhs = hlil_to_miasm(bv, expr.src)
            return ExprAssign(lhs, rhs)

        # assignment
        case HighLevelILOperation.HLIL_VAR_INIT:
            lhs = variable_to_miasm(expr.dest)
            rhs = hlil_to_miasm(bv, expr.src)
            if lhs is not None and rhs is not None:
                return ExprAssign(lhs, rhs)

        case HighLevelILOperation.HLIL_ADDRESS_OF:
            name = f"&{expr.operands[0]}"
            size = 8 * bv.arch.address_size
            return ExprId(name, size)

        case HighLevelILOperation.HLIL_DEREF_SSA:
            ex = hlil_to_miasm(bv, expr.operands[0])
            return ExprMem(ex, 8 * expr.size)

        case HighLevelILOperation.HLIL_CONST_PTR:
            ex = ExprInt(expr.operands[0], expr.size * 8)
            return ex

        case HighLevelILOperation.HLIL_IMPORT:
            ex = ExprInt(expr.operands[0], expr.size * 8)
            return ExprId(ex, expr.size)

        # SSA assignment
        case HighLevelILOperation.HLIL_VAR_INIT_SSA:
            lhs = ssa_variable_to_miasm(expr.dest)
            rhs = hlil_to_miasm(bv, expr.src)
            return ExprAssign(lhs, rhs)

        case HighLevelILOperation.HLIL_ASSIGN:
            lhs = hlil_to_miasm(bv, expr.dest)
            rhs = hlil_to_miasm(bv, expr.src)
            return ExprAssign(lhs, rhs)

        # part of a struct
        case HighLevelILOperation.HLIL_STRUCT_FIELD:
            src = hlil_to_miasm(bv, expr.src)
            return ExprSlice(src, expr.offset * 8, expr.offset * 8 + expr.size * 8)

        case HighLevelILOperation.HLIL_ARRAY_INDEX_SSA:
            base_memory = hlil_to_miasm(bv, expr.src)
            indexed = hlil_to_miasm(bv, expr.index)
            return ExprMem(base_memory + (indexed * ExprInt(expr.size, bv.arch.address_size * 8)), expr.size * 8)

        case HighLevelILOperation.HLIL_SPLIT:
            low = hlil_to_miasm(bv, expr.low)
            high = hlil_to_miasm(bv, expr.high)
            return ExprCompose(low, high)

        # variables
        case HighLevelILOperation.HLIL_VAR:
            return variable_to_miasm(expr.operands[0])

        # SSA variables
        case HighLevelILOperation.HLIL_VAR_SSA:
            return ssa_variable_to_miasm(expr.var)

        # constant
        case HighLevelILOperation.HLIL_CONST:
            value = expr.constant
            size = expr.size * 8
            return ExprInt(value, size)

        # binary arithmetic/logical operations
        case HighLevelILOperation.HLIL_ADD:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return left + right

        case HighLevelILOperation.HLIL_SUB:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return left - right

        case HighLevelILOperation.HLIL_SBB:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return left - right

        case HighLevelILOperation.HLIL_AND:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return left & right

        case HighLevelILOperation.HLIL_OR:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return left | right

        case HighLevelILOperation.HLIL_XOR:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return left ^ right

        case HighLevelILOperation.HLIL_MUL:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return left * right

        case HighLevelILOperation.HLIL_DIVS:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return ExprOp("s/", left, right)

        case HighLevelILOperation.HLIL_ASR:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return left >> right

        case HighLevelILOperation.HLIL_LSL:
            left = hlil_to_miasm(bv, expr.left)
            right = hlil_to_miasm(bv, expr.right).zeroExtend(left.size)
            return left << right

        case HighLevelILOperation.HLIL_LSR:
            left = hlil_to_miasm(bv, expr.left)
            right = hlil_to_miasm(bv, expr.right).zeroExtend(left.size)
            return left >> right

        case HighLevelILOperation.HLIL_DIVU_DP:
            left = hlil_to_miasm(bv, expr.left)
            right = hlil_to_miasm(bv, expr.right).zeroExtend(left.size)
            # the slice here is needed because we're talking about double precision (128bit)
            return ExprSlice(ExprOp("%", left, right), 0, expr.size * 8)

        case HighLevelILOperation.HLIL_DIVS_DP:
            left = hlil_to_miasm(bv, expr.left)
            right = hlil_to_miasm(bv, expr.right).signExtend(left.size)
            # the slice here is needed because we're talking about double precision (128bit)
            return ExprSlice(ExprOp("%", left, right), 0, expr.size * 8)

        case HighLevelILOperation.HLIL_MODU:
            left = hlil_to_miasm(bv, expr.left)
            right = hlil_to_miasm(bv, expr.right).zeroExtend(left.size)
            return ExprOp("%", left, right)

        case HighLevelILOperation.HLIL_MODU_DP:
            left = hlil_to_miasm(bv, expr.left)
            right = hlil_to_miasm(bv, expr.right).zeroExtend(left.size)
            # the slice here is needed because we're talking about double precision (128bit)
            return ExprSlice(ExprOp("%", left, right), 0, expr.size * 8)

        case HighLevelILOperation.HLIL_MODS_DP:
            left = hlil_to_miasm(bv, expr.left)
            right = hlil_to_miasm(bv, expr.right).zeroExtend(left.size)
            # the slice here is needed because we're talking about double precision (128bit)
            return ExprSlice(ExprOp("%s", left, right), 0, expr.size * 8)

        case HighLevelILOperation.HLIL_ROR:
            left = hlil_to_miasm(bv, expr.left)
            right = hlil_to_miasm(bv, expr.right)
            return ExprOp(">>>", left, right)

        case HighLevelILOperation.HLIL_ROL:
            left = hlil_to_miasm(bv, expr.left)
            right = hlil_to_miasm(bv, expr.right)
            return ExprOp("<<<", left, right)

        # binary comparison
        case HighLevelILOperation.HLIL_CMP_E:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return ExprOp("==", left, right).zeroExtend(8)

        case HighLevelILOperation.HLIL_CMP_NE:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return (~ExprOp("==", left, right)).zeroExtend(8)

        case HighLevelILOperation.HLIL_CMP_ULT:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return expr_is_unsigned_lower(left, right).zeroExtend(8)

        case HighLevelILOperation.HLIL_CMP_ULE:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return expr_is_unsigned_lower_or_equal(left, right).zeroExtend(8)

        case HighLevelILOperation.HLIL_CMP_UGE:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return expr_is_unsigned_greater_or_equal(left, right).zeroExtend(8)

        case HighLevelILOperation.HLIL_CMP_UGT:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return expr_is_unsigned_greater(left, right).zeroExtend(8)

        case HighLevelILOperation.HLIL_CMP_SGT:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return expr_is_signed_greater(left, right).zeroExtend(8)

        case HighLevelILOperation.HLIL_CMP_SGE:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return expr_is_signed_greater_or_equal(left, right).zeroExtend(8)

        case HighLevelILOperation.HLIL_CMP_SLE:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return expr_is_signed_lower_or_equal(left, right).zeroExtend(8)

        case HighLevelILOperation.HLIL_CMP_SLT:
            left, right = hlil_to_miasm(
                bv, expr.left), hlil_to_miasm(bv, expr.right)
            return expr_is_signed_lower(left, right).zeroExtend(8)

        # unary operations
        case HighLevelILOperation.HLIL_NEG:
            src = hlil_to_miasm(bv, expr.src)
            return -src

        case HighLevelILOperation.HLIL_NOT:
            src = hlil_to_miasm(bv, expr.src)
            return ~src

        case HighLevelILOperation.HLIL_LOW_PART:
            src = hlil_to_miasm(bv, expr.src)
            return ExprSlice(src, 0, expr.size * 8)

        case HighLevelILOperation.HLIL_ZX:
            src = hlil_to_miasm(bv, expr.src)
            return src.zeroExtend(expr.size * 8)

        case HighLevelILOperation.HLIL_SX:
            src = hlil_to_miasm(bv, expr.src)
            return src.signExtend(expr.size * 8)

        case HighLevelILOperation.HLIL_RET:
            # ensure return has arguments
            if len(expr.src) != 0:
                return hlil_to_miasm(bv, expr.src[0])

        # unsupported control-flow operations
        case HighLevelILOperation.HLIL_GOTO | HighLevelILOperation.HLIL_CASE | HighLevelILOperation.HLIL_DO_WHILE_SSA | HighLevelILOperation.HLIL_WHILE_SSA | HighLevelILOperation.HLIL_SWITCH | HighLevelILOperation.HLIL_BREAK:
            raise Exception(
                f"Unsupported translation for control-flow operation: {expr.core_instr}")

        # unssupported special operations that cannot be semantically represented in MiasmIR
        case HighLevelILOperation.HLIL_VAR_PHI | HighLevelILOperation.HLIL_ASSIGN_UNPACK | HighLevelILOperation.HLIL_MEM_PHI\
            | HighLevelILOperation.HLIL_UNDEF | HighLevelILOperation.HLIL_NOP | HighLevelILOperation.HLIL_CONTINUE\
                | HighLevelILOperation.HLIL_NORET | HighLevelILOperation.HLIL_CALL_SSA | HighLevelILOperation.HLIL_VAR_DECLARE:
            raise Exception(
                f"Unsupported translation for special operation: {expr.core_instr}")

        case _:
            raise Exception(
                f"Unsupported translation for operation: {expr.core_instr}")

```

`obfuscation_analysis/utils.py`:

```py
from __future__ import annotations

import traceback
from typing import Iterable, Optional

from binaryninja.binaryview import BinaryView
from binaryninja.function import Function
from binaryninja.log import log_debug, log_error
from binaryninja.lowlevelil import LowLevelILOperation


def find_corrupted_functions(bv: BinaryView) -> Iterable[Function]:
    """
    Internal generator yielding every function whose disassembly is deemed
    corrupted.

    Parameters
    ----------
    bv : BinaryView
        Active BinaryView to inspect.

    Yields
    ------
    Function
        Each function that appears to contain undefined or overlapping
        instructions.
    """
    for func in bv.functions:
        if has_undefined_instructions(func):
            yield func


def has_undefined_instructions(func: Function) -> bool:
    """
    Return **True** if *func* appears to have *broken* disassembly.

    A function is flagged when **any** of the following hold:

    1. In LLIL form the basic block’s terminator is `LLIL_UNDEF`.
    2. In linear disassembly view a basic block is either
       * empty,
       * marked by Binary Ninja as `has_invalid_instructions`,
         **or**  
       * ends with an instruction that renders as ``"??"``.

    These conditions catch the most common artefacts produced by badly
    obfuscated or partially decoded functions.

    Parameters
    ----------
    func : Function
        Binary Ninja function object to test.

    Returns
    -------
    bool
        ``True`` if the function looks corrupted, ``False`` otherwise.
    """
    # LLIL checks
    if func.llil_if_available is not None:
        # basic block has no instructions or contains the LLIL_UNDEF operation
        for bb in func.llil_if_available.basic_blocks:
            if len(bb) == 0:
                return True
            if bb[-1].operation is LowLevelILOperation.LLIL_UNDEF:
                return True

    # disassembly checks
    for bb in func.basic_blocks:
        # basic block is empty or has invalid instructions
        if bb.has_invalid_instructions or len(bb) == 0:
            return True
        try:
            # final mnemonic string for the last instruction is "??"
            if bb[-1][0][0] == "??":
                return True
        except Exception:
            return True

    return False


def log_stacktrace(prefix: Optional[str] = None) -> None:
    """
    Push the current exception’s traceback to Binary Ninja’s *Debug* log.

    Call this inside an `except` block after the exception object has
    been caught (so that `traceback` can access the active exception).

    Parameters
    ----------
    prefix : str, optional
        Text prepended to the stack trace—handy for contextual markers.
    """
    stack_str = traceback.format_exc()
    if prefix:
        stack_str = f"{prefix.rstrip()}:\n{stack_str}"
    log_debug(stack_str, "ObfAnalysis")


def user_error(msg: str, *, exc: Exception | None = None) -> None:
    """
    Emit a single, user-visible error line and (optionally) dump the
    full traceback to the Debug log.

    Typical usage inside an `except` block:

    .. code-block:: python

        try:
            ...
        except Exception as err:
            user_error("Translation failed.", exc=err)

    Parameters
    ----------
    msg : str
        Short, high-level explanation.
    exc : Exception, optional
        The caught exception.  When provided, a full stack trace is visible only when the user
        enables Debug Log in Binary Ninja.  If `None` (default), no
        traceback is emitted.
    """
    # log user error
    log_error(f"{msg}", "ObfAnalysis")
    # stacktrace
    if exc is not None:
        log_stacktrace("Stacktrace:")

```

`plugin.json`:

```json
{
   "pluginmetadataversion": 2,
   "name": "Obfuscation Analysis",
   "author": "Tim Blazytko, Nicolò Altamura",
   "type": [
      "helper"
   ],
   "api": [
      "python3"
   ],
   "description": "Analyze and simplify obfuscated code",
   "longdescription": "",
   "license": {
      "name": "GPL-2.0",
      "text": "Copyright 2025 Tim Blazytko, Nicolò Altamura\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, see <http://www.gnu.org/licenses/>."
   },
   "platforms": [
      "Darwin",
      "Windows",
      "Linux"
   ],
   "installinstructions": {
      "Darwin": "",
      "Windows": "",
      "Linux": ""
   },
   "version": "1.0",
   "minimumbinaryninjaversion": 5336
}

```

`requirements.txt`:

```txt
msynth @ git+https://github.com/mrphrazer/msynth@d719a58
miasm @ git+https://github.com/cea-sec/miasm@90dc167
z3-solver
wheel


```