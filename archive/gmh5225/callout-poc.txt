Project Path: arc_gmh5225_callout-poc_9pu84lf1

Source Tree:

```txt
arc_gmh5225_callout-poc_9pu84lf1
├── LICENSE
├── README.md
├── callout-poc
│   ├── asm_callout.asm
│   ├── callout-poc.inf
│   ├── callout-poc.vcxproj
│   ├── callout-poc.vcxproj.filters
│   ├── callout.h
│   ├── main.c
│   └── util.h
├── callout-poc.sln
└── img
    ├── expected.png
    └── stack.png

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Drew P. (reserveblue@protonmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# callout-poc
This repository includes an example proof-of-concept of callout threads and the callout mechanism (see the [article](https://secret.club/2021/01/12/callout.html)). The project is licensed under the MIT license.

Example of expected kernel debugger output on running the POC:

![](../main/img/expected.png)

Example of spoofed stack frame:

![](../main/img/stack.png)
```

`callout-poc.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "callout-poc", "callout-poc\callout-poc.vcxproj", "{284B06D6-2209-4E86-BAAE-8D74616F7B1A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|ARM.ActiveCfg = Debug|ARM
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|ARM.Build.0 = Debug|ARM
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|ARM.Deploy.0 = Debug|ARM
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|ARM64.Build.0 = Debug|ARM64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|x64.ActiveCfg = Debug|x64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|x64.Build.0 = Debug|x64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|x64.Deploy.0 = Debug|x64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|x86.ActiveCfg = Debug|Win32
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|x86.Build.0 = Debug|Win32
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Debug|x86.Deploy.0 = Debug|Win32
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|ARM.ActiveCfg = Release|ARM
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|ARM.Build.0 = Release|ARM
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|ARM.Deploy.0 = Release|ARM
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|ARM64.ActiveCfg = Release|ARM64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|ARM64.Build.0 = Release|ARM64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|ARM64.Deploy.0 = Release|ARM64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|x64.ActiveCfg = Release|x64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|x64.Build.0 = Release|x64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|x64.Deploy.0 = Release|x64
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|x86.ActiveCfg = Release|Win32
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|x86.Build.0 = Release|Win32
		{284B06D6-2209-4E86-BAAE-8D74616F7B1A}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {23D8A0BA-C4E0-4BAA-A239-57646035219F}
	EndGlobalSection
EndGlobal

```

`callout-poc/asm_callout.asm`:

```asm
;	Copyright (c) 2021 by Drew P. (reserveblue@protonmail.com)
;
;	Permission is hereby granted, free of charge, to any person obtaining a copy
;	of this software and associated documentation files (the "Software"), to deal
;	in the Software without restriction, including without limitation the rights
;	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;	copies of the Software, and to permit persons to whom the Software is
;	furnished to do so, subject to the following conditions:
;
;	The above copyright notice and this permission notice shall be included in all
;	copies or substantial portions of the Software.
;
;	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;	SOFTWARE.

.code

extern g_ret_instruction_addr:qword
extern g_rop_gadget_addr:qword

align 10h

;void *callout_invoke(void *function, void *old_kernel_stack, size_t stack_arg_count, size_t eflags_xor, void *r1, void *r2, void *r3, void *r4, ...)
;note that the old_kernel_stack is always misaligned; it is always aligned to 8 bytes.
callout_invoke proc

push rdi
push rsi
push rbp

mov rax, rcx ;put function pointer into rax as we need to overwrite rcx
lea r10, [rsp + 20h] ;stack context at function call (before call instruction to this function, taking into account the register pushes and return address push)
sub rsp, 10h ;align the stack if an odd number of registers are preserved; this should subtract only 8 bytes instead of 16 out if an even number of registers are pushed as the stack would be aligned. note that alignment is a relative term for the sub rsp, 8 that would normally occur (see the iret frame right below)
;because of this, there is also an add rsp, 8 at the end of the function; this can be removed if this instruction only subtracts 8 bytes

;push iret frame into rdx
sub rdx, 138h ;28h for the iret frame + E8h for the stack pointer offset + 8 bytes for alignment + 20h for the function call frame

mov rcx, [g_ret_instruction_addr]
mov [rdx + 110h], rcx ;rip

mov ecx, cs
mov [rdx + 118h], rcx ;cs

pushfq
pop rcx
mov [rdx + 120h], rcx ;rflags

lea rcx, [return_loc]
mov [rsp], rcx							;the relevant stack memory is allocated above! make sure your alignment is correct
mov [rdx + 128h], rsp ;rsp to load

mov ecx, ss
mov [rdx + 130h], rcx ;ss

;confuse someone by putting some address on this otherwise unused space
mov rcx, [g_ret_instruction_addr]
mov [rdx + 28h], rcx

;keep this in rbp. this will be used by our ROP gadget to jump back here
lea rbp, [rdx + 28h]

;if we have more than 4 args, we need to push args on to the stack
test r8, r8
jz no_sub_rsp

lea r11, [r8 * 8] ;total bytes allocated
sub rdx, r11

;we must always call the function with a misaligned stack (rather, including the return address; before the function is called, the stack is aligned)
;this function has three sections: the entry, the stack argument handling, and the call. the entry always has an aligned stack and the call always has a misaligned stack
;to keep the stack misaligned by the end we must keep the stack aligned in this function
;however, if the caller specifies an odd amount of stack arguments, we misalign the stack (r8 * 8 will be a multiple of 8 and not of 16)
;so, to fix this, we can simply re-align the stack by subtracting an extra argument (AND rsp by ~0xF, making it conditionally aligned)
and rdx, 0FFFFFFFFFFFFFFF0h

;copy bytes from our special stack to this stack
lea rsi, [r10 + 40h] ;register to hold source; points to first stack argument (the 40h is due to register shadow (20h) plus the first 4 arguments (4 * 8 = 20h) pushed to the function)
lea rdi, [rdx + 20h] ;register to hold dest; points to first stack argument (add 20h as otherwise the arguments would be inside of the shadow space)
mov rcx, r8 ;register to hold size (movsq mul by 8)

rep movsq ;set stack args

;NO TRACES
xor esi, esi
xor edi, edi

no_sub_rsp:

;so far:
;rdx holds the stack pointer we need to load
;rax holds the address of the function we need to call
;r9 holds the value used to xor rflags
;r10 holds our original stack pointer
;rbp holds an address loaded by an IRET

;construct an IRET frame

;simulate a call
mov rcx, [g_rop_gadget_addr]
sub rdx, 8
mov [rdx], rcx

mov ecx, ss
push rcx		;ss		+ 20h
push rdx		;rsp	+ 18h
pushfq			;rflags	+ 10h

xor [rsp], r9

mov ecx, cs
push rcx		;cs		+ 8h
push rax		;rip	+ 0

;rax can be cleared
xor eax, eax

;set arguments
mov rcx, [r10 + 20h]
mov rdx, [r10 + 28h]
mov r8, [r10 + 30h]
mov r9, [r10 + 38h]

;r10 can be cleared
xor r10, r10

;at this point, the only register with incriminating evidence is RBP - which points to the IRET (part of the) kernel stack
;as well, we have this information left over on the kernel stack with no real way to clear it
;although finding it would be nigh impossible since it's likely to get wiped anyways, meaning the only real marking is RBP and the iret stack allocation (which is pointed to by RBP)
;as well as the function's return address being set to a fixed iret pattern (too non-specific to check?)
;the stack may also not be perfectly normal and contain random pool allocations which don't point to any code
iretq

align 10h
;when that function returns, it goes to a routine like
;mov rsp, rbp
;mov rbp, [rbp + offset]
;add rsp, offset
;iretq
;so by setting rbp to a valid IRET stack (after adding the rsp offset), we can have it load back our stack and instruction pointer - with interrupts disabled
;the only problem is that putting our instruction pointer here would leave it exposed on the stack - which is solved by having it point towards a RET instruction (which is valid) and pushing return_loc on to the stack that is loaded (our stack)
;which means that this routine loads our stack, disables interrupts, jumps to a ret instruction, causing it to return here - all with interrupts disabled and no obvious traces on the kernel stack
;we may have to add 8 to rsp, depending on if we had to align it earlier

return_loc:
add rsp, 8
pop rbp
pop rsi
pop rdi

ret

callout_invoke endp


align 10h

;void callout_bugcheck(void)
callout_bugcheck proc

;construct an iret frame
;give it a zeroed or garbage stack and instruction pointer
;this will cause it to page fault (bad RIP) which will then cause another page fault (bad RSP) which will cause a double fault
xor eax, eax

mov ebx, ss
push rbx        ;ss		+ 20h
push rax        ;rsp	+ 18h
pushfq          ;rflags	+ 10h

mov ebx, cs
push rbx        ;cs		+ 8h
push rax		;rip	+ 0

;clear registers
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx
xor esi, esi
xor edi, edi
xor ebp, ebp
xor r8, r8
xor r9, r9
xor r10, r10
xor r11, r11
xor r12, r12
xor r13, r13
xor r14, r14
xor r15, r15

iretq

callout_bugcheck endp

end
```

`callout-poc/callout-poc.inf`:

```inf
;
; callout-poc.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=CPOC
DriverVer=0
CatalogFile=callout-poc.cat
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Strings]
ManufacturerName="Secret Club"
ClassName=""
DiskName="callout-poc Source Disk"

```

`callout-poc/callout-poc.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{284B06D6-2209-4E86-BAAE-8D74616F7B1A}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>callout_poc</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="callout-poc.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm_callout.asm" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="callout.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`callout-poc/callout-poc.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="callout-poc.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm_callout.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="callout.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`callout-poc/callout.h`:

```h
/*
	Copyright (c) 2021 by Drew P. (reserveblue@protonmail.com)

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

#pragma once
#include <ntifs.h>

#define CALLOUT_ENABLE_INTERRUPT_FLAG (0x200)

//function: the address of the function to call
//old_kernel_stack: the stack it will use; the given address of the original kernel stack (e.g. kernel_stack_preserve)
//stack_arg_count: the amount of stack arguments; if you pass more than 4 arguments, you have (arg_count - 4) amount of stack arguments. if you pass fewer than 4 arguments, stack_arg_count must be zero.
//eflags_xor: the value that eflags will be xored by; use a value 0x200 (CALLOUT_ENABLE_INTERRUPT_FLAG) to enable interrupts if they are disabled, for example.
//the register arguments, r1-r4, are directly given as x64 fastcall argument registers; on function entry, r1 = rcx, r2 = rdx, r3 = r8, and r4 = r9.
//this also beckons an expectation of stack layout. do not redefine this function to have a fewer number of required register arguments.
//furthermore, unused arguments should be initialized with NULL/0 to prevent information leaks.
//the remaning variadic arguments are simply given to the function as-is.
//if the function you are calling returns an argument with a value greater than the size of a GPR (8 bytes), you must call it with r1 pointing to a variable of that type.
//note that the return value of the function will point to the buffer you had allocated and given in r1.
//also important to note: this function does not support the calling of functions that return floating-point values as the value will be present in XMM0.

//if you think this is cumbersome, you are welcome to make a wrapper/alternative like this:
//void *callout_invoke_wrapper(void *function, void *old_kernel_stack, size_t stack_arg_count, size_t eflags_xor, ...);
//and to use a macro/C++ to fill in the gaps; or to use C++ to default-initialize unused register parameters to 0/NULL.

//it is also easily possible to adapt this to a floating-point return type by defining a duplicate version of this function that returns a floating point value, noting, of course, that you likely will not run into that situation.
extern void *callout_invoke(void *function, void *old_kernel_stack, size_t stack_arg_count, size_t eflags_xor, void *r1, void *r2, void *r3, void *r4, ...);

//traceless bugcheck; minidumps will show absolutely no discernable context.
extern __declspec(noreturn) void callout_bugcheck(void);
```

`callout-poc/main.c`:

```c
/*
	Copyright (c) 2021 by Drew P. (reserveblue@protonmail.com)

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

#include "callout.h"
#include "util.h"
#include <ntimage.h>

uintptr_t g_ret_instruction_addr = 0; //referenced by asm_callout
uintptr_t g_rop_gadget_addr = 0; //referenced by asm_callout

static void thread_boostrapper(void *start_context, void *kernel_stack_preserve)
{
	UNREFERENCED_PARAMETER(start_context);

	//missing, or can optionally be added:
	//-free startup shellcode
	//-spoof thread start address
	//-find all references to the startup shellcode in the original kernel stack and remove them

	//we can otherwise execute regularly. note the limitations of callouts:
	//-certain blocking operations (e.g. file I/O) may unpredictably cause crashes if used excessively
	//-the thread must constantly run with interrupts disabled until it performs a callout. until then, all blocking must involve a callout; either to a NOP/PAUSE, or to KeDelayExecutionThread or similar
		//-in other words, non-callout blocking (e.g. a while (true) or even a simple spin loop) must involve a callout.
	//-interrupts are disabled; you can not read or write paged memory without a callout. this can potentially be mitigated with an imported memcpy (NOTING CAREFULLY TO NOT PREVENT THE COMPILER FROM INSERTING ITS OWN MEMCPY! YOU WANT THE MEMCPY EXPORTED BY NTOSKRNL.EXE)

	//here, we can mostly do what we want.
	callout_invoke((void *)DbgPrintEx, kernel_stack_preserve, 3, CALLOUT_ENABLE_INTERRUPT_FLAG, (void *)DPFLTR_IHVDRIVER_ID, (void *)0, "Test of printing. varargs: %u %u %u %u\n", (void *)1, 2, 3, 4);

	//we can even sleep...
	LARGE_INTEGER sleep_interval;
	sleep_interval.QuadPart = (ULONG64)-(1000 * 1000 * 10);

	callout_invoke((void *)KeDelayExecutionThread, kernel_stack_preserve, 0, CALLOUT_ENABLE_INTERRUPT_FLAG, (void *)KernelMode, (void *)TRUE, &sleep_interval, NULL);
	callout_invoke((void *)DbgPrintEx, kernel_stack_preserve, 0, CALLOUT_ENABLE_INTERRUPT_FLAG, (void *)DPFLTR_IHVDRIVER_ID, (void *)0, "(Probably) slept for one second\n", NULL);

	//...or allocate memory...
	size_t *const alloc_base = callout_invoke((void *)ExAllocatePool, kernel_stack_preserve, 0, CALLOUT_ENABLE_INTERRUPT_FLAG, (void *)NonPagedPool, (void *)sizeof(size_t), NULL, NULL);

	if (alloc_base)
	{
		callout_invoke((void *)DbgPrintEx, kernel_stack_preserve, 0, CALLOUT_ENABLE_INTERRUPT_FLAG, (void *)DPFLTR_IHVDRIVER_ID, (void *)0, "Alloc succeeded 0x%llX\n", alloc_base);
		callout_invoke((void *)ExFreePoolWithTag, kernel_stack_preserve, 0, CALLOUT_ENABLE_INTERRUPT_FLAG, alloc_base, NULL, NULL, NULL);
	}
	else
	{
		//system out of memory?
		callout_invoke((void *)DbgPrintEx, kernel_stack_preserve, 0, CALLOUT_ENABLE_INTERRUPT_FLAG, (void *)DPFLTR_IHVDRIVER_ID, (void *)0, "Alloc failed\n", NULL);
	}

	//and we can enter an infinite loop.
	for (size_t i = 0;; i++)
	{
		callout_invoke((void *)KeDelayExecutionThread, kernel_stack_preserve, 0, CALLOUT_ENABLE_INTERRUPT_FLAG, (void *)KernelMode, (void *)TRUE, &sleep_interval, NULL);
		callout_invoke((void *)DbgPrintEx, kernel_stack_preserve, 0, CALLOUT_ENABLE_INTERRUPT_FLAG, (void *)DPFLTR_IHVDRIVER_ID, (void *)0, "iter %u\n", (void *)i);
	}
}

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);

	const uintptr_t ntoskrnl_base = util_get_kernel_module("ntoskrnl.exe");
	
	const IMAGE_DOS_HEADER *const dos_header = (void *)ntoskrnl_base;
	const IMAGE_NT_HEADERS64 *const nt_header = (void *)(ntoskrnl_base + dos_header->e_lfanew);

	const size_t ntoskrnl_size = nt_header->OptionalHeader.SizeOfImage;

	//this is just a POC. lazily increment the start address past the file header to what is likely the start of the nonpaged text section of ntoskrnl.exe
	const uintptr_t likely_code_section = ntoskrnl_base + 0x1000;
	const size_t likely_code_size = ntoskrnl_size - 0x1000;

	g_ret_instruction_addr = (uintptr_t)util_generic_sigscan_within_module(likely_code_section, likely_code_size, (const UCHAR *)"\xC3", "x");

	if (!g_ret_instruction_addr)
		return STATUS_INTERNAL_ERROR; //something REALLY went wrong...

	//48 8B E5 48 8B AD ? ? ? ? 48 81 C4 ? ? ? ? 48 CF
	/*
	mov rsp, rbp
	mov rbp, [rbp+????????h]	;4 byte reference
	add rsp, ????????h	;ditto
	iretq

	note that the first offset does not matter but the second offset is assumed to never change. it is therefore hardcoded within the assembly routines and assumed to be 0xE8.
	*/
	g_rop_gadget_addr = (uintptr_t)util_generic_sigscan_within_module(likely_code_section, likely_code_size, (const UCHAR *)"\x48\x8B\xE5\x48\x8B\xAD\x00\x00\x00\x00\x48\x81\xC4\x00\x00\x00\x00\x48\xCF", "xxxxxx????xxx????xx");

	if (!g_rop_gadget_addr)
		return STATUS_INTERNAL_ERROR;

	const size_t stack_size = 0x1000 * 8;
	const uintptr_t real_stack = (uintptr_t)ExAllocatePoolWithTag(NonPagedPool, stack_size, 'COPC');

	if (!real_stack)
		return STATUS_INTERNAL_ERROR; //failed to allocate stack memory

	memset((void *)real_stack, 0, stack_size);

	/*
	cli
	mov rdx, rsp ;store stack pointer; this value is always unaligned
	mov rsp, ????????????????h ;stack pointer to load
	movabs rax, ????????????????h ;routine to jump to
	jmp rax
	*/
	const UCHAR thread_start_shellcode[] = { 0xFA, 0x48, 0x89, 0xE2, 0x48, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0 };
	UCHAR *const shellcode_base = ExAllocatePoolWithTag(NonPagedPool, sizeof(thread_start_shellcode), 'COPC');

	if (!shellcode_base)
		return STATUS_INTERNAL_ERROR;

	//note that shellcode_base is not freed in this implementation, and neither is the real thread stack.
	memcpy(shellcode_base, &thread_start_shellcode[0], sizeof(thread_start_shellcode));

	*(ULONG64 *)(&shellcode_base[6]) = real_stack + stack_size - 40; //allocate an aligned stack frame for the real stack; and point the stack pointer to the stack base
	*(ULONG64 *)(&shellcode_base[0x10]) = (uintptr_t)thread_boostrapper;

	//create system thread
	OBJECT_ATTRIBUTES object_attr;
	InitializeObjectAttributes(&object_attr, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

	HANDLE thread_handle = NULL;
	const NTSTATUS status = PsCreateSystemThread(&thread_handle, 0, &object_attr, NULL, NULL, (PKSTART_ROUTINE)shellcode_base, NULL);

	if (!NT_SUCCESS(status))
		return status;

	ZwClose(thread_handle);
	return STATUS_SUCCESS;
}
```

`callout-poc/util.h`:

```h
/*
	Copyright (c) 2021 by Drew P. (reserveblue@protonmail.com)

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

#pragma once
#include <ntifs.h>

//!!!this may not resolve for some older or newer windows versions!!!
extern __declspec(dllimport) NTSTATUS ZwQuerySystemInformation(
	_In_      ULONG SystemInformationClass,
	_Inout_   void *SystemInformation,
	_In_      ULONG SystemInformationLength,
	_Out_opt_ ULONG *ReturnLength
);

//find the base address of a kernel module/driver given its ascii-converted name
//this function is kind of bad, but should generally work for most (if not all) people
static uintptr_t util_get_kernel_module(const char *module_name)
{
	typedef struct _RTL_PROCESS_MODULE_INFORMATION
	{
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];
	} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

	typedef struct _RTL_PROCESS_MODULES
	{
		ULONG NumberOfModules;
		RTL_PROCESS_MODULE_INFORMATION Modules[1];
	} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

	//try to allocate enough space for the RTL_PROCESS_MODULES struct and all the modules that follow
	ULONG needed_bytes = 8192;
	void *buffer_bytes = ExAllocatePoolWithTag(PagedPool, needed_bytes, 'COPC');

	if (!buffer_bytes)
		return 0;

	NTSTATUS last_status = ZwQuerySystemInformation(11, buffer_bytes, needed_bytes, &needed_bytes);

	while (last_status == STATUS_INFO_LENGTH_MISMATCH)
	{
		//we don't have enough bytes
		ExFreePool(buffer_bytes);
		buffer_bytes = ExAllocatePoolWithTag(PagedPool, needed_bytes, 'COPC');

		if (!buffer_bytes)
			return 0;

		last_status = ZwQuerySystemInformation(11, buffer_bytes, needed_bytes, &needed_bytes);
	}

	if (!NT_SUCCESS(last_status) && last_status != STATUS_INFO_LENGTH_MISMATCH)
	{
		ExFreePool(buffer_bytes);
		return 0;
	}

	const RTL_PROCESS_MODULES *const process_modules = (RTL_PROCESS_MODULES *)buffer_bytes;
	uintptr_t result = 0;

	//loop through modules
	for (ULONG i = 0; i < process_modules->NumberOfModules; i++)
	{
		//OffsetToFileName is the offset from the full path to the filename of the module
		if (!_stricmp((char *)(process_modules->Modules[i].FullPathName + process_modules->Modules[i].OffsetToFileName), module_name))
		{
			result = (uintptr_t)(process_modules->Modules[i].ImageBase);
			break;
		}
	}

	ExFreePool(buffer_bytes);
	return result;
}

//simple and bad signature scan. this will check the entire module indiscriminately; it may or may not run into unmapped sections or return pointers into non-code sections.
//this function only returns the address in which the signature had appeared. if no signature is found, the function returns NULL.
static void *util_generic_sigscan_within_module(uintptr_t base, size_t size, const UCHAR *sig, const char *mask)
{
	const size_t pattern_size = strlen(mask);
	uintptr_t rva = 0;

	for (; rva < size - pattern_size + 1; rva++)
	{
		BOOLEAN bytes_fit_pattern = TRUE;

		//search at this rva for the pattern
		for (size_t i = 0; i < pattern_size; i++)
		{
			if (mask[i] == 'x' && (*(UCHAR *)(i + rva + base) != sig[i]))
			{
				bytes_fit_pattern = FALSE;
				break;
			}
		}

		if (bytes_fit_pattern)
			return (void *)(rva + base);
	}

	return NULL;
}
```