Project Path: arc_gmh5225_Csgo-Full-kernel_s3hoaws4

Source Tree:

```txt
arc_gmh5225_Csgo-Full-kernel_s3hoaws4
├── CsgoFullKernel
│   ├── Cheat Driver.sln
│   ├── Cheat Driver.vcxproj
│   ├── Cheat Driver.vcxproj.filters
│   ├── CheatDriver.inf
│   ├── Csgo.h
│   ├── Drawing.h
│   ├── Keymap.h
│   ├── Main.cpp
│   ├── Memory.h
│   ├── Misc.h
│   ├── Modules.h
│   ├── Mouse.h
│   ├── Nt.h
│   ├── Offsets.h
│   └── VkCodes.h
└── README.md

```

`CsgoFullKernel/Cheat Driver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32228.343
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Cheat Driver", "Cheat Driver.vcxproj", "{A6577777-B76A-4FCD-B672-8BC8DD9D6165}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|ARM.ActiveCfg = Debug|ARM
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|ARM.Build.0 = Debug|ARM
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|ARM.Deploy.0 = Debug|ARM
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|ARM64.Build.0 = Debug|ARM64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|x64.ActiveCfg = Debug|x64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|x64.Build.0 = Debug|x64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|x64.Deploy.0 = Debug|x64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|x86.ActiveCfg = Debug|Win32
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|x86.Build.0 = Debug|Win32
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Debug|x86.Deploy.0 = Debug|Win32
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|ARM.ActiveCfg = Release|ARM
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|ARM.Build.0 = Release|ARM
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|ARM.Deploy.0 = Release|ARM
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|ARM64.ActiveCfg = Release|ARM64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|ARM64.Build.0 = Release|ARM64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|ARM64.Deploy.0 = Release|ARM64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|x64.ActiveCfg = Release|x64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|x64.Build.0 = Release|x64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|x64.Deploy.0 = Release|x64
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|x86.ActiveCfg = Release|Win32
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|x86.Build.0 = Release|Win32
		{A6577777-B76A-4FCD-B672-8BC8DD9D6165}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7B1C978A-5DA8-4488-A191-881D7001FAD5}
	EndGlobalSection
EndGlobal

```

`CsgoFullKernel/Cheat Driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A6577777-B76A-4FCD-B672-8BC8DD9D6165}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Cheat_Driver</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>MultiByte</CharacterSet>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>MultiByte</CharacterSet>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="CheatDriver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Csgo.h" />
    <ClInclude Include="Drawing.h" />
    <ClInclude Include="Keymap.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="Misc.h" />
    <ClInclude Include="Modules.h" />
    <ClInclude Include="Mouse.h" />
    <ClInclude Include="Nt.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="VkCodes.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`CsgoFullKernel/Cheat Driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="CheatDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Misc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Nt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Modules.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Drawing.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Mouse.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Csgo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Keymap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VkCodes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CsgoFullKernel/CheatDriver.inf`:

```inf
;
; CheatDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=CheatDriver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
CheatDriver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
CheatDriver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%CheatDriver.DeviceDesc%=CheatDriver_Device, Root\CheatDriver ; TODO: edit hw-id

[CheatDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
CheatDriver.sys

;-------------- Service installation
[CheatDriver_Device.NT.Services]
AddService = CheatDriver,%SPSVCINST_ASSOCSERVICE%, CheatDriver_Service_Inst

; -------------- CheatDriver driver install sections
[CheatDriver_Service_Inst]
DisplayName    = %CheatDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\CheatDriver.sys

;
;--- CheatDriver_Device Coinstaller installation ------
;

[CheatDriver_Device.NT.CoInstallers]
AddReg=CheatDriver_Device_CoInstaller_AddReg
CopyFiles=CheatDriver_Device_CoInstaller_CopyFiles

[CheatDriver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[CheatDriver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[CheatDriver_Device.NT.Wdf]
KmdfService =  CheatDriver, CheatDriver_wdfsect
[CheatDriver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "CheatDriver Installation Disk"
CheatDriver.DeviceDesc = "CheatDriver Device"
CheatDriver.SVCDESC = "CheatDriver Service"

```

`CsgoFullKernel/Csgo.h`:

```h
#pragma once
#include "Modules.h"
#include "Drawing.h"
#include "Mouse.h"
#include "Offsets.h"
#include "Keymap.h"


void ExitThread()
{
	Print("exiting systhem thread");
	if (isWin32Thread)
		UnspoofWin32Thread();

	PsTerminateSystemThread(STATUS_SUCCESS);
}

bool SaveWhileLoop()
{
	if (!UpdateKeyMap())
		ExitThread();

	if (!KeyDown(VK_NUMPAD5))
	{
		return true;
	}

	ExitThread();
}

Vector2 WorldToScreen(Vector3& pos, MAT4X4& g_viewMatrix)
{
	float _x = g_viewMatrix.c[0][0] * pos.x + g_viewMatrix.c[0][1] * pos.y + g_viewMatrix.c[0][2] * pos.z + g_viewMatrix.c[0][3];
	float _y = g_viewMatrix.c[1][0] * pos.x + g_viewMatrix.c[1][1] * pos.y + g_viewMatrix.c[1][2] * pos.z + g_viewMatrix.c[1][3];

	float w = g_viewMatrix.c[3][0] * pos.x + g_viewMatrix.c[3][1] * pos.y + g_viewMatrix.c[3][2] * pos.z + g_viewMatrix.c[3][3];

	if (w < 0.01f)
		return { 0,0 };


	float inv_w = 1.f / w;
	_x *= inv_w;
	_y *= inv_w;

	float x = targetWindowWidth * .5f;
	float y = targetWindowHeight * .5f;

	x += 0.5f * _x * targetWindowWidth + 0.5f;
	y -= 0.5f * _y * targetWindowHeight + 0.5f;

	return { x,y };
}

void CsgoMain()
{
	Print("csgo main");

	while (SaveWhileLoop())
	{

		if (!SpoofWin32Thread())
			continue;

		//check if cs focused
		if (!IsWindowFocused("csgo.exe"))
		{
			Print("cs not focused\n");
			Sleep(100);
			UnspoofWin32Thread();
			continue;
		}

		hdc = NtUserGetDC(0);
		if (!hdc)
		{
			Print("failed to get userdc");
			UnspoofWin32Thread();
			continue;
		}

		brush = NtGdiCreateSolidBrush(RGB(255, 0, 0), NULL);
		if (!brush)
		{
			Print("failed create brush");
			NtUserReleaseDC(hdc);
			UnspoofWin32Thread();
			continue;
		}


		DWORD localplayer = ReadMemory<DWORD>(clientBase + dwLocalPlayer);
		DWORD localTeam = ReadMemory<DWORD>(localplayer + m_iTeamNum);//fixed


		Vector3 punchAngle = ReadMemory<Vector3>(localplayer + m_aimPunchAngle);


		punchAngle.x = punchAngle.x * 12; punchAngle.y = punchAngle.y * 12;
		float x = targetWindowWidth / 2 - punchAngle.y;
		float y = targetWindowHeight / 2 + punchAngle.x;

		
		RECT rect = { x - 2, y - 2, x + 2, y + 2 };
		FrameRect(hdc, &rect, brush, 2);


		MAT4X4 viewMatrix = ReadMemory<MAT4X4>(clientBase + dwViewMatrix);

		for (size_t i = 0; i < 32; i++)
		{
			DWORD currEnt = ReadMemory<DWORD>(clientBase + dwEntityList + (i * 0x10));
			if (!currEnt)
				continue;

			int entHealth = ReadMemory<int>(currEnt + m_iHealth);
			if (0 >= entHealth)
				continue;

			DWORD dormant = ReadMemory<DWORD>(currEnt + m_bDormant);
			if (dormant)
				continue;

			DWORD teamNum = ReadMemory<DWORD>(currEnt + m_iTeamNum);
			if (teamNum == localTeam)
				continue;

			Vector3 feetPos = ReadMemory<Vector3>(currEnt + m_vecOrigin);
			Vector2 feetPosScreen = WorldToScreen(feetPos, viewMatrix);

			DWORD bonePtr = ReadMemory<DWORD>(currEnt + m_dwBoneMatrix);
			MAT3X4 boneMatrix = ReadMemory<MAT3X4>(bonePtr + 0x30 * 8); //head
			Vector3 headPos = { boneMatrix.c[0][3], boneMatrix.c[1][3], boneMatrix.c[2][3] };
			headPos.z += 8.75;
			Vector2 headScreen = WorldToScreen(headPos, viewMatrix);

			int height = headScreen.y - feetPosScreen.y;
			int width = height / 4;

			float Entity_x = feetPosScreen.x - width;
			float Entity_y = feetPosScreen.y;
			float Entity_w = height / 2;

			RECT boxEsp = { Entity_x + Entity_w, Entity_y + height, Entity_x, Entity_y };
			FrameRect(hdc, &boxEsp, brush, 1);
		}


		NtGdiDeleteObjectApp(brush);
		NtUserReleaseDC(hdc);


		UnspoofWin32Thread();
		YieldProcessor();
	}
}
```

`CsgoFullKernel/Drawing.h`:

```h
#pragma once
#include "Nt.h"

bool isWin32Thread = false;

PETHREAD GetValidWin32Thread(PVOID* win32Thread)
{
	int currentThreadId = 1;
	NTSTATUS status = STATUS_SUCCESS;
	do
	{
		PETHREAD currentEthread = 0;
		status = PsLookupThreadByThreadId((HANDLE)currentThreadId, &currentEthread);

		if (!NT_SUCCESS(status) || !currentEthread)
		{
			currentThreadId++;
			continue;
		}

		if (PsIsThreadTerminating(currentEthread))
		{
			currentThreadId++;
			continue;
		}

		PVOID Win32Thread = PsGetThreadWin32Thread(currentEthread);
		//memcpy(&Win32Thread, (PVOID)((UINT64)currentEthread + win32ThreadOffset), sizeof(PVOID));

		if (Win32Thread)
		{
			PEPROCESS threadOwner = PsGetThreadProcess(currentEthread);
			char procName[15];
			memcpy(&procName, PsGetProcessImageFileName(threadOwner), sizeof(procName));
			if (!strcmp(procName, "explorer.exe"))
			{
				*win32Thread = Win32Thread;
				return currentEthread;
			}
		}
		currentThreadId++;
	} while (0x3000 > currentThreadId);

	return 0;
}

inline void SpoofWin32Thread(PVOID newWin32Value, PEPROCESS newProcess, CLIENT_ID newClientId)
{
	PKTHREAD currentThread = KeGetCurrentThread();
	
	PsSetThreadWin32Thread(currentThread, newWin32Value, PsGetThreadWin32Thread(currentThread));

	PVOID processPtr = (PVOID)((char*)currentThread + processOffset);
	memcpy(processPtr, &newProcess, sizeof(PEPROCESS));

	PVOID clientIdPtr = (PVOID)((char*)currentThread + cidOffset);
	memcpy(clientIdPtr, &newClientId, sizeof(CLIENT_ID));
}

KAPC_STATE apc = { 0 };

PVOID currentWin32Thread = 0;
PEPROCESS currentProcess = 0;
PETHREAD currentThread = 0;
CLIENT_ID currentCid = { 0 };

HDC hdc;
HBRUSH brush;

bool SpoofWin32Thread()
{

	if (isWin32Thread)
	{
		Print("already win32\n");
		return true;
	}

	PVOID targetWin32Thread = 0;
	PETHREAD targetThread = GetValidWin32Thread(&targetWin32Thread);
	if (!targetWin32Thread || !targetThread)
	{
		Print("failed to find win32thread");
		return false;
	}
	PEPROCESS targetProcess = PsGetThreadProcess(targetThread);

	CLIENT_ID targetCid = { 0 };
	memcpy(&targetCid, (PVOID)((char*)targetThread + cidOffset), sizeof(CLIENT_ID));

	KeStackAttachProcess(targetProcess, &apc);
	SpoofWin32Thread(targetWin32Thread, targetProcess, targetCid);

	isWin32Thread = true;
}

void UnspoofWin32Thread()
{
	if (!isWin32Thread)
		return;

	SpoofWin32Thread(currentWin32Thread, currentProcess, currentCid);
	KeUnstackDetachProcess(&apc);
	isWin32Thread = false;
}


NTSTATUS InitDrawing()
{
	PVOID win32kBase = (PVOID)GetKernelModuleBase("win32kbase.sys");
	PVOID win32kfullBase = (PVOID)GetKernelModuleBase("win32kfull.sys");

	if (!win32kBase || !win32kfullBase)
	{
		Print("Could not find kernel module bases");
		return STATUS_UNSUCCESSFUL;
	}

	NtUserGetDCPtr = RtlFindExportedRoutineByName(win32kBase, "NtUserGetDC");
	NtGdiPatBltPtr = RtlFindExportedRoutineByName(win32kfullBase, "NtGdiPatBlt");
	NtGdiSelectBrushPtr = RtlFindExportedRoutineByName(win32kBase, "GreSelectBrush");
	NtUserReleaseDCPtr = RtlFindExportedRoutineByName(win32kBase, "NtUserReleaseDC");
	NtGdiCreateSolidBrushPtr = RtlFindExportedRoutineByName(win32kfullBase, "NtGdiCreateSolidBrush");
	NtGdiDeleteObjectAppPtr = RtlFindExportedRoutineByName(win32kBase, "NtGdiDeleteObjectApp");
	NtGdiExtTextOutWPtr = RtlFindExportedRoutineByName(win32kfullBase, "NtGdiExtTextOutW");
	NtGdiHfontCreatePtr = RtlFindExportedRoutineByName(win32kfullBase, "hfontCreate");
	NtGdiSelectFontPtr = RtlFindExportedRoutineByName(win32kfullBase, "NtGdiSelectFont");


	if (!NtUserGetDCPtr || !NtGdiPatBltPtr || !NtGdiSelectBrushPtr ||
		!NtUserReleaseDCPtr || !NtGdiCreateSolidBrushPtr || !NtGdiDeleteObjectAppPtr
		|| !NtGdiExtTextOutWPtr || !NtGdiHfontCreatePtr || !NtGdiSelectFontPtr)
	{
		Print("Could not find kernel functions required for drawing");
		return STATUS_UNSUCCESSFUL;
	}

	Print("found everything");
	return STATUS_SUCCESS;
}

inline bool InWindow(const RECT* rect)
{
	float windowLeft = targetWindowPosX;
	float windowRight = targetWindowPosX + targetWindowWidth;
	float windowTop = targetWindowPosY;
	float windowBottom = targetWindowPosY + targetWindowHeight;

	if (rect->right > windowRight || rect->left < windowLeft || rect->bottom > windowBottom || rect->top < windowTop)
		return false;

	return true;
}

INT FrameRect(HDC hdc, CONST RECT* rect, HBRUSH hbr, int thickness)
{
	if (!InWindow(rect))
		return 0;


	HBRUSH oldBrush = NtGdiSelectBrush(hdc, hbr);
	if (!oldBrush)
	{
		Print("failed to get brush");
		return 0;
	}

	RECT r = *rect;

	NtGdiPatBlt(hdc, r.left, r.top, thickness, r.bottom - r.top, PATCOPY);
	NtGdiPatBlt(hdc, r.right - thickness, r.top, thickness, r.bottom - r.top, PATCOPY);
	NtGdiPatBlt(hdc, r.left, r.top, r.right - r.left, thickness, PATCOPY);
	NtGdiPatBlt(hdc, r.left, r.bottom - thickness, r.right - r.left, thickness, PATCOPY);

	NtGdiSelectBrush(hdc, oldBrush);
	return 1;
}
```

`CsgoFullKernel/Keymap.h`:

```h
#pragma once

PEPROCESS csrssProc = nullptr;
PVOID gafAsyncKeyStatePtr = 0;


BYTE keystateBitmap[256 * 2 / 8];
BYTE keystateRecentBitmap[256 / 8];


NTSTATUS InitKeyMap()
{
    PVOID win32kBase = (PVOID)GetKernelModuleBase("win32kbase.sys");
    gafAsyncKeyStatePtr = RtlFindExportedRoutineByName(win32kBase, "gafAsyncKeyState");
    if (!gafAsyncKeyStatePtr)
    {
        Print("Failed to get gafAsyncKeyState\n");
        return STATUS_UNSUCCESSFUL;
    }

    NTSTATUS status = GetProcByName("csrss.exe", &csrssProc, 1);
    if (!NT_SUCCESS(status))
    {
        Print("Failed to get csrss process %x\n", status);
        return status;
    }

    if (!csrssProc)
    {
        Print("Invalid csrss process\n");
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

bool KeyDown(BYTE vk) 
{
	return keystateBitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2;
}

bool WasKeyDown(BYTE vk) 
{
	bool result = keystateRecentBitmap[vk / 8] & 1 << vk % 8;
	keystateRecentBitmap[vk / 8] &= ~(1 << vk % 8);
	return result;
}

bool UpdateKeyMap() 
{
    SpoofWin32Thread();

    auto prevKeystateBitmap = keystateBitmap;
    SIZE_T size = 0;
    NTSTATUS status = MmCopyVirtualMemory(csrssProc, gafAsyncKeyStatePtr, PsGetCurrentProcess(), &keystateBitmap, sizeof(keystateBitmap), KernelMode, &size);
    if (!NT_SUCCESS(status))
    {
        Print("Failed to copy bitmap %x\n", status);
        UnspoofWin32Thread();
        return false;
    }

    for (auto vk = 0u; vk < 256; ++vk) 
    {
        if ((keystateBitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2) &&
            !(prevKeystateBitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2))
            keystateRecentBitmap[vk / 8] |= 1 << vk % 8;
    }

    UnspoofWin32Thread();
    return true;
}
```

`CsgoFullKernel/Main.cpp`:

```cpp
#include "Csgo.h"

void MainThread()
{
	Print("doin the thing");
	currentProcess = IoGetCurrentProcess();
	currentThread = KeGetCurrentThread();
	memcpy(&currentCid, (PVOID)((char*)currentThread + cidOffset), sizeof(CLIENT_ID));

	NTSTATUS status = STATUS_SUCCESS;
	Print("waiting for csgo.exe...");

	while (SaveWhileLoop())
	{
		status = GetProcByName("csgo.exe", &targetApplication, 0);
		if (NT_SUCCESS(status))
			break;

		Sleep(300);
	}

	Print("found csgo");


	Print("getting pid...");
	HANDLE procId = PsGetProcessId(targetApplication);

	if (!procId)
	{
		Print("failed to find proc id");
		ExitThread();
	}
	pid = (ULONG)procId;
	Print("got pid %i", pid);


	int count = 0;
	while (!GetModuleBasex86(targetApplication, L"serverbrowser.dll"))
	{
		SaveWhileLoop();
		if (count >= 30) //wait 30 sec then abort
		{
			Print("failed to get serverbrowser dll\n");
			ExitThread();
		}
		count++;
		Sleep(1000);
	}


	clientBase = GetModuleBasex86(targetApplication, L"client.dll");
	if (!clientBase)
	{
		Print("failed to get clientBase");
		ExitThread();
	}

	engineBase = GetModuleBasex86(targetApplication, L"engine.dll");
	if (!engineBase)
	{
		Print("failed to get engineBase");
		ExitThread();
	}


	CsgoMain();
	ExitThread();
}


extern "C" NTSTATUS DriverEntry()
{
	Print("welcome");
	NTSTATUS status = STATUS_SUCCESS;


	status = InitWindowUtils();
	if (!NT_SUCCESS(status))
	{
		Print("failed to init window utils");
		return STATUS_UNSUCCESSFUL;
	}

	status = InitKeyMap();
	if (!NT_SUCCESS(status))
	{
		Print("failed to init keymap");
		return STATUS_UNSUCCESSFUL;
	}

	status = InitMouse(&mouseObject);
	if (!NT_SUCCESS(status))
	{
		Print("failed to init mouse");
		return STATUS_UNSUCCESSFUL;
	}

	status = InitDrawing();
	if (!NT_SUCCESS(status))
	{
		Print("failed to init drawing");
		return STATUS_UNSUCCESSFUL;
	}

	
	status = StartThread(MainThread);
	if (!NT_SUCCESS(status))
	{
		Print("failed to start thread");
		return STATUS_UNSUCCESSFUL;
	}

	return STATUS_SUCCESS;
}

```

`CsgoFullKernel/Memory.h`:

```h
#pragma once
#include "Nt.h"

PEPROCESS targetApplication = nullptr;
ULONG pid = NULL;
UINT64 clientBase = NULL;
UINT64 engineBase = NULL;

template<typename t>
t ReadMemory(UINT64 addr)
{
	t buffer;

	SIZE_T copiedBytes = 0;
	MmCopyVirtualMemory(targetApplication, (PVOID)addr, PsGetCurrentProcess(), &buffer, sizeof(t), KernelMode, &copiedBytes);

	return buffer;
}


template<typename t>
NTSTATUS ReadVirtual(PEPROCESS process, uintptr_t addr, t* buffer)
{
	if (!process || !addr || !buffer)
		return STATUS_INVALID_PARAMETER;

	SIZE_T copiedBytes = 0;
	return MmCopyVirtualMemory(process, (PVOID)addr, PsGetCurrentProcess(), buffer, sizeof(t), KernelMode, &copiedBytes);
}

template<typename t>
NTSTATUS WriteVirtual(PEPROCESS process, uintptr_t addr, t* buffer)
{
	if (!process || !addr || !buffer)
		return STATUS_INVALID_PARAMETER;

	SIZE_T copiedBytes = 0;
	return MmCopyVirtualMemory(PsGetCurrentProcess(), buffer, process, (PVOID)addr, sizeof(t), KernelMode, &copiedBytes);
}




```

`CsgoFullKernel/Misc.h`:

```h
#pragma once
#include "Memory.h"

void Sleep(int ms)
{
	LARGE_INTEGER time = { 0 };
	time.QuadPart = -(ms) * 10 * 1000;
	KeDelayExecutionThread(KernelMode, TRUE, &time);
}


NTSTATUS GetProcessBaseAddress(int pid, ULONG64* baseAddr)
{
	PEPROCESS eproc = NULL;
	if (pid == 0) 
		return STATUS_INVALID_PARAMETER;

	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)pid, &eproc);
	if (!NT_SUCCESS(status)) 
		return status;

	PVOID base = PsGetProcessSectionBaseAddress(eproc);

	ObDereferenceObject(eproc);
	*baseAddr = (ULONG64)base;

	return STATUS_SUCCESS;
}


NTSTATUS StartThread(PVOID start)
{
	HANDLE threadHandle = NULL;
	NTSTATUS status = PsCreateSystemThread(&threadHandle, NULL, NULL, NULL, NULL, (PKSTART_ROUTINE)start, NULL);

	if (!NT_SUCCESS(status))
	{
		Print("failed to create system thread, %x", status);
		return status;
	}

	ZwClose(threadHandle);
	return STATUS_SUCCESS;
}





inline ULONG RandomNumber()
{
	ULONG64 tickCount;
	KeQueryTickCount(&tickCount);

	return RtlRandomEx((PULONG)&tickCount);
}

void WriteRandom(ULONG64 addr, ULONG size)
{
	for (size_t i = 0; i < size; i++)
	{
		*(char*)(addr + i) = RandomNumber() % 255;
	}
}

PVOID AllocatePoolMemory(ULONG size)
{
	return ExAllocatePool(NonPagedPool, size);
}

void FreePoolMemory(PVOID base, ULONG size)
{
	for (size_t i = 0; i < size; i++)
	{
		*(char*)((UINT64)base + i) = RandomNumber() % 255;
	}
	ExFreePoolWithTag(base, 0);
}

PVOID QuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInfoClass, ULONG* size)
{
	int currAttempt = 0;
	int maxAttempt = 20;


QueryTry:
	if (currAttempt >= maxAttempt)
		return 0;

	currAttempt++;
	ULONG neededSize = 0;
	ZwQuerySystemInformation(SystemInfoClass, NULL, neededSize, &neededSize);
	if (!neededSize)
		goto QueryTry;

	ULONG allocationSize = neededSize;
	PVOID informationBuffer = AllocatePoolMemory(allocationSize);
	if (!informationBuffer)
		goto QueryTry;

	NTSTATUS status = ZwQuerySystemInformation(SystemInfoClass, informationBuffer, neededSize, &neededSize);
	if (!NT_SUCCESS(status))
	{
		FreePoolMemory(informationBuffer, allocationSize);
		goto QueryTry;
	}

	*size = allocationSize;
	return informationBuffer;
}


NTSTATUS GetProcByName(const char* name, PEPROCESS* process, int iteration)
{
	ANSI_STRING nameAnsi;
	RtlInitAnsiString(&nameAnsi, name);

	UNICODE_STRING nameUnicode;
	NTSTATUS status = RtlAnsiStringToUnicodeString(&nameUnicode, &nameAnsi, true);
	if (!NT_SUCCESS(status))
	{
		Print("Failed to translate cstr to unicode str %x\n", status);
		return status;
	}

	ULONG size = 0;
	PSYSTEM_PROCESS_INFORMATION procInfo = (PSYSTEM_PROCESS_INFORMATION)QuerySystemInformation(SystemProcessInformation, &size);
	if (!procInfo || !size)
	{
		Print("Failed to query process information\n");
		return status;
	}

	PSYSTEM_PROCESS_INFORMATION currEntry = procInfo;

	int currIteration = 0;

	while (true)
	{
		if (!RtlCompareUnicodeString(&nameUnicode, &currEntry->ImageName, true))
		{
			if (currIteration != iteration)
			{
				currIteration++;

				if (!currEntry->NextEntryOffset)
					break;

				currEntry = (PSYSTEM_PROCESS_INFORMATION)((char*)currEntry + currEntry->NextEntryOffset);
				continue;
			}

			if (0 >= currEntry->NumberOfThreads)
			{
				Print("process has no active threads\n");
				if (!currEntry->NextEntryOffset)
					break;

				currEntry = (PSYSTEM_PROCESS_INFORMATION)((char*)currEntry + currEntry->NextEntryOffset);
				continue;
			}

			ULONGLONG pid = currEntry->UniqueProcessId;
			PEPROCESS foundProcess = 0;
			status = PsLookupProcessByProcessId((HANDLE)pid, &foundProcess);
			if (!NT_SUCCESS(status))
			{
				Print("failed to lookup process by id %x\n", status);
				if (!currEntry->NextEntryOffset)
					break;

				currEntry = (PSYSTEM_PROCESS_INFORMATION)((char*)currEntry + currEntry->NextEntryOffset);
				continue;
			}

			FreePoolMemory(procInfo, size);
			Print("found process with pid %i\n", pid);
			*process = foundProcess;
			return STATUS_SUCCESS;
		}

		if (!currEntry->NextEntryOffset)
			break;

		currEntry = (PSYSTEM_PROCESS_INFORMATION)((char*)currEntry + currEntry->NextEntryOffset);
	}

	FreePoolMemory(procInfo, size);
	return STATUS_NOT_FOUND;
}


UINT64 GetKernelModuleBase(const char* name)
{
	ULONG size = 0;
	PSYSTEM_MODULE_INFORMATION moduleInformation = (PSYSTEM_MODULE_INFORMATION)QuerySystemInformation(SystemModuleInformation, &size);

	if (!moduleInformation || !size)
		return 0;

	for (size_t i = 0; i < moduleInformation->Count; i++)
	{
		char* fileName = (char*)moduleInformation->Module[i].FullPathName + moduleInformation->Module[i].OffsetToFileName;
		if (!strcmp(fileName, name))
		{
			UINT64 imageBase = (UINT64)moduleInformation->Module[i].ImageBase;
			FreePoolMemory(moduleInformation, size);
			return imageBase;
		}
	}

	FreePoolMemory(moduleInformation, size);
}

NTSTATUS InitWindowUtils()
{
	PVOID win32kBase = (PVOID)GetKernelModuleBase("win32kfull.sys");
	NtUserGetForegroundWindowPtr = RtlFindExportedRoutineByName(win32kBase, "NtUserGetForegroundWindow");
	NtUserQueryWindowPtr = RtlFindExportedRoutineByName(win32kBase, "NtUserQueryWindow");

	if (!NtUserGetForegroundWindowPtr || !NtUserQueryWindowPtr)
	{
		Print("Failed to get window shit\n");
		return STATUS_UNSUCCESSFUL;
	}

	return STATUS_SUCCESS;
}


bool IsProcessName(const char* name, PEPROCESS process)
{
	char procName[15];
	memcpy(&procName, PsGetProcessImageFileName(process), sizeof(procName));
	if (!strcmp((char*)&procName, name))
		return true;

	else
		return false;
}

bool IsProcessName(const char* name, int pid)
{
	PEPROCESS process = 0;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)pid, &process);
	if (!NT_SUCCESS(status))
	{
		Print("Failed to get process with pid %i", pid);
		return false;
	}

	if (!process)
	{
		Print("Failed to get process");
		return false;
	}

	char procName[15];
	memcpy(&procName, PsGetProcessImageFileName(process), sizeof(procName));

	ObfDereferenceObject(process);


	if (!strcmp((char*)&procName, name))
		return true;

	else
	{
		//Print("proc name %s\n", procName);
		return false;
	}
}

bool IsWindowFocused(const char* name)
{
	HWND foreGroundWindow = NtUserGetForegroundWindow();
	UINT64 pid = NtUserQueryWindow(foreGroundWindow, QUERY_THREAD_PROCESS_ID);
	return IsProcessName(name, pid);
}
```

`CsgoFullKernel/Modules.h`:

```h
#pragma once
#include "Misc.h"


bool Is32Bit(PEPROCESS process)
{
	return PsGetProcessWow64Process(process);
}

ULONG GetModuleBasex86(PEPROCESS proc, PCWSTR modName) 
{

	UNICODE_STRING module_name;
	RtlInitUnicodeString(&module_name, modName);

	PPEB32 pPeb = (PPEB32)PsGetProcessWow64Process(proc);// get Process PEB for the x86 part, function is unexported and undoc

	if (!pPeb) {
		return 0; // failed
	}

	KAPC_STATE state;

	KeStackAttachProcess(proc, &state);

	PPEB_LDR_DATA32 pLdr = (PPEB_LDR_DATA32)pPeb->Ldr;

	if (!pLdr) {
		KeUnstackDetachProcess(&state);
		return 0; // failed
	}

	UNICODE_STRING name;

	// loop the linked list
	for (PLIST_ENTRY32 list = (PLIST_ENTRY32)pLdr->InLoadOrderModuleList.Flink;
		list != &pLdr->InLoadOrderModuleList; list = (PLIST_ENTRY32)list->Flink) {
		PLDR_DATA_TABLE_ENTRY32 pEntry =
			CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);
		// since the PEB is x86, the DLL is x86, and so the base address is in x86 (4 byte as compared to 8 byte)
		// and the UNICODE STRING is in 32 bit(UNICODE_STRING32), and because there is no viable conversion
		// we are just going to force everything in.
		// believe me it works.
		UNICODE_STRING DLLname;
		DLLname.Length = pEntry->BaseDllName.Length;
		DLLname.MaximumLength = pEntry->BaseDllName.MaximumLength;
		DLLname.Buffer = (PWCH)pEntry->BaseDllName.Buffer;

		if (RtlCompareUnicodeString(&DLLname, &module_name, TRUE) ==
			0) {
			ULONG baseAddr = pEntry->DllBase;
			KeUnstackDetachProcess(&state);
			return baseAddr;
		}
	}

	KeUnstackDetachProcess(&state);

	return 0; // failed
}

ULONG64 GetModuleBasex64(PEPROCESS proc, PCWSTR modName)
{
	UNICODE_STRING moduleName;
	RtlInitUnicodeString(&moduleName, modName);

	PPEB pPeb = (PPEB)PsGetProcessPeb(proc); // get Process PEB, function is unexported and undoc

	if (!pPeb) {
		return 0; // failed
	}

	KAPC_STATE state;

	KeStackAttachProcess(proc, &state);

	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;

	if (!pLdr) {
		KeUnstackDetachProcess(&state);
		return 0; // failed
	}

	UNICODE_STRING name;

	// loop the linked list
	for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->ModuleListLoadOrder.Flink;
		list != &pLdr->ModuleListLoadOrder; list = (PLIST_ENTRY)list->Flink) {
		PLDR_DATA_TABLE_ENTRY pEntry =
			CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
		if (RtlCompareUnicodeString(&pEntry->BaseDllName, &moduleName, TRUE) ==
			0) {
			ULONG64 baseAddr = (ULONG64)pEntry->DllBase;
			KeUnstackDetachProcess(&state);
			return baseAddr;
		}
	}

	KeUnstackDetachProcess(&state);

	return 0; // failed
}

```

`CsgoFullKernel/Mouse.h`:

```h
#pragma once
#include "Misc.h"



extern "C" POBJECT_TYPE * IoDriverObjectType;

typedef VOID
(*MouseClassServiceCallback)(
	PDEVICE_OBJECT DeviceObject,
	PMOUSE_INPUT_DATA InputDataStart,
	PMOUSE_INPUT_DATA InputDataEnd,
	PULONG InputDataConsumed
	);

typedef struct _MOUSE_OBJECT
{
	PDEVICE_OBJECT mouse_device;
	MouseClassServiceCallback service_callback;
} MOUSE_OBJECT, * PMOUSE_OBJECT;

MOUSE_OBJECT mouseObject;

NTSTATUS InitMouse(PMOUSE_OBJECT mouse_obj)
{
	UNICODE_STRING class_string;
	RtlInitUnicodeString(&class_string, L"\\Driver\\MouClass");

	PDRIVER_OBJECT class_driver_object = NULL;
	NTSTATUS status = ObReferenceObjectByName(&class_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType, KernelMode, NULL, (PVOID*)&class_driver_object);
	if (!NT_SUCCESS(status)) { return status; }

	UNICODE_STRING hid_string;
	RtlInitUnicodeString(&hid_string, L"\\Driver\\MouHID");

	PDRIVER_OBJECT hid_driver_object = NULL;
	status = ObReferenceObjectByName(&hid_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType, KernelMode, NULL, (PVOID*)&hid_driver_object);
	if (!NT_SUCCESS(status))
	{
		if (class_driver_object) { ObDereferenceObject(class_driver_object); }
		return status;
	}

	PVOID class_driver_base = NULL;

	PDEVICE_OBJECT hid_device_object = hid_driver_object->DeviceObject;
	while (hid_device_object && !mouse_obj->service_callback)
	{
		PDEVICE_OBJECT class_device_object = class_driver_object->DeviceObject;
		while (class_device_object && !mouse_obj->service_callback)
		{
			if (!class_device_object->NextDevice && !mouse_obj->mouse_device)
			{
				mouse_obj->mouse_device = class_device_object;
			}

			PULONG_PTR device_extension = (PULONG_PTR)hid_device_object->DeviceExtension;
			ULONG_PTR device_ext_size = ((ULONG_PTR)hid_device_object->DeviceObjectExtension - (ULONG_PTR)hid_device_object->DeviceExtension) / 4;
			class_driver_base = class_driver_object->DriverStart;
			for (ULONG_PTR i = 0; i < device_ext_size; i++)
			{
				if (device_extension[i] == (ULONG_PTR)class_device_object && device_extension[i + 1] > (ULONG_PTR)class_driver_object)
				{
					mouse_obj->service_callback = (MouseClassServiceCallback)(device_extension[i + 1]);
					break;
				}
			}
			class_device_object = class_device_object->NextDevice;
		}
		hid_device_object = hid_device_object->AttachedDevice;
	}

	if (!mouse_obj->mouse_device)
	{
		PDEVICE_OBJECT target_device_object = class_driver_object->DeviceObject;
		while (target_device_object)
		{
			if (!target_device_object->NextDevice)
			{
				mouse_obj->mouse_device = target_device_object;
				break;
			}
			target_device_object = target_device_object->NextDevice;
		}
	}

	ObDereferenceObject(class_driver_object);
	ObDereferenceObject(hid_driver_object);


	return STATUS_SUCCESS;
}


#define MOUSE_LEFT_DOWN   0x0001  // Left Button changed to down.
#define MOUSE_LEFT_UP     0x0002  // Left Button changed to up.
#define MOUSE_RIGHT_DOWN  0x0004  // Right Button changed to down.
#define MOUSE_RIGHT_UP    0x0008  // Right Button changed to up.
#define MOUSE_MIDDLE_DOWN 0x0010  // Middle Button changed to down.
#define MOUSE_MIDDLE_UP   0x0020  // Middle Button changed to up.


void MouseMove(long x, long y)
{
	ULONG input_data;
	MOUSE_INPUT_DATA mid = { 0 };

	mid.LastX = x;
	mid.LastY = y;
	mid.ButtonFlags = 0;
	mid.Flags = MOUSE_MOVE_RELATIVE;


	mouseObject.service_callback(mouseObject.mouse_device, &mid, (PMOUSE_INPUT_DATA)&mid + 1, &input_data);
}

void MouseClick(unsigned short button)
{
	ULONG input_data;
	MOUSE_INPUT_DATA mid = { 0 };

	mid.LastX = 0;
	mid.LastY = 0;
	mid.ButtonFlags = button;
	mid.Flags = MOUSE_MOVE_ABSOLUTE;

	mouseObject.service_callback(mouseObject.mouse_device, &mid, (PMOUSE_INPUT_DATA)&mid + 1, &input_data);
}


```

`CsgoFullKernel/Nt.h`:

```h
#pragma once
#include <Ntifs.h>
#include <WinDef.h>
#include <wingdi.h>
#include <ntddmou.h>
#include "VkCodes.h"

extern "C" int _fltused = 0;


typedef struct Vector2
{
	float x, y;
};

typedef struct Vector3
{
	float x, y, z;
};

typedef struct _MAT4X4
{
	float c[4][4];
}MAT4X4, * PMAT4X4;

typedef struct _MAT3X4
{
	float c[3][4];
}MAT3X4, * PMAT3X4;



float targetWindowWidth = 1920;
float targetWindowHeight = 1080;
float targetWindowPosX = 0;
float targetWindowPosY = 0;


#define Print(fmt, ...) DbgPrint("[s11]: " fmt, ##__VA_ARGS__)
#define MAX_PATH 260


//this is the same in every windows version
ULONG processOffset = 0x220; //_KTHREAD->_KPROCESS* Process;
ULONG cidOffset = 0x478; //_ETHREAD->_CLIENT_ID Cid;  


typedef DWORD LFTYPE;

extern "C"
{
	NTSTATUS NTAPI MmCopyVirtualMemory(PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize);
	NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(PEPROCESS Process);
	NTKERNELAPI PVOID NTAPI PsGetProcessWow64Process(IN PEPROCESS Process);
	NTKERNELAPI PPEB NTAPI PsGetProcessPeb(IN PEPROCESS Process);
	NTSTATUS NTAPI ZwQuerySystemInformation(ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
	NTKERNELAPI PVOID NTAPI RtlFindExportedRoutineByName(PVOID ImageBase, PCCH RoutineNam);
	NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName(PUNICODE_STRING ObjectName,ULONG Attributes,PACCESS_STATE AccessState,ACCESS_MASK DesiredAccess,POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID ParseContext, PVOID* Object);

	NTKERNELAPI PVOID __fastcall PsGetProcessImageFileName(PEPROCESS process);
	NTKERNELAPI PVOID PsGetThreadWin32Thread(PKTHREAD thread);
	NTKERNELAPI PVOID PsSetThreadWin32Thread(PKTHREAD thread, PVOID wantedValue, PVOID compareValue);
}


typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;


typedef struct _SYSTEM_MODULE_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	/* 0x0000 */ ULONG NextEntryOffset;
	/* 0x0004 */ ULONG NumberOfThreads;
	/* 0x0008 */ LARGE_INTEGER WorkingSetPrivateSize;
	/* 0x0010 */ ULONG HardFaultCount;
	/* 0x0014 */ ULONG NumberOfThreadsHighWatermark;
	/* 0x0018 */ ULONGLONG CycleTime;
	/* 0x0020 */ LARGE_INTEGER CreateTime;
	/* 0x0028 */ LARGE_INTEGER UserTime;
	/* 0x0030 */ LARGE_INTEGER KernelTime;
	/* 0x0038 */ UNICODE_STRING ImageName;
	/* 0x0048 */ KPRIORITY BasePriority;
	/* 0x004C */ ULONG Padding1;
	/* 0x0050 */ ULONGLONG UniqueProcessId;
	/* 0x0058 */ ULONGLONG InheritedFromUniqueProcessId;
	/* 0x0060 */ ULONG HandleCount;
	/* 0x0064 */ ULONG SessionId;
	/* 0x0068 */ ULONG_PTR UniqueProcessKey;
	/* 0x0070 */ SIZE_T PeakVirtualSize;
	/* 0x0078 */ SIZE_T VirtualSize;
	/* 0x0080 */ ULONG PageFaultCount;
	/* 0x0084 */ ULONG Padding2;
	/* 0x0088 */ SIZE_T PeakWorkingSetSize;
	/* 0x0090 */ SIZE_T WorkingSetSize;
	/* 0x0098 */ SIZE_T QuotaPeakPagedPoolUsage;
	/* 0x00A0 */ SIZE_T QuotaPagedPoolUsage;
	/* 0x00A8 */ SIZE_T QuotaPeakNonPagedPoolUsage;
	/* 0x00B0 */ SIZE_T QuotaNonPagedPoolUsage;
	/* 0x00B8 */ SIZE_T PagefileUsage;
	/* 0x00C0 */ SIZE_T PeakPagefileUsage;
	/* 0x00C8 */ SIZE_T PrivatePageCount;
	/* 0x00D0 */ LARGE_INTEGER ReadOperationCount;
	/* 0x00D8 */ LARGE_INTEGER WriteOperationCount;
	/* 0x00E0 */ LARGE_INTEGER OtherOperationCount;
	/* 0x00E8 */ LARGE_INTEGER ReadTransferCount;
	/* 0x00F0 */ LARGE_INTEGER WriteTransferCount;
	/* 0x00F8 */ LARGE_INTEGER OtherTransferCount;
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION; /* size: 0x0100 */

C_ASSERT(sizeof(SYSTEM_PROCESS_INFORMATION) == 0x100);

PVOID NtUserGetForegroundWindowPtr = 0;

HWND NtUserGetForegroundWindow(void)
{
	auto fn = reinterpret_cast<HWND(*)(void)>(NtUserGetForegroundWindowPtr);
	return fn();
}

PVOID NtUserQueryWindowPtr = 0;

#define QUERY_FOREGROUNDWINDOW 7
#define QUERY_THREAD_PROCESS_ID 1
#define QUERY_THREAD_ID 2
#define QUERY_IS_WINDOW_HUNG 5 //this one could be wrong but it does something along those lines

//no fucking clue what the rest of the codes do. they query something from the wnd stuct which I have not worked with so /shrug

UINT64 NtUserQueryWindow(HWND window, int queryType)
{
	auto fn = reinterpret_cast<DWORD(*)(HWND, int)>(NtUserQueryWindowPtr);
	return fn(window, queryType);
}


PVOID NtUserGetDCPtr = 0;
PVOID NtGdiSelectBrushPtr = 0;
PVOID NtGdiPatBltPtr = 0;
PVOID NtUserReleaseDCPtr = 0;
PVOID NtGdiCreateSolidBrushPtr = 0;
PVOID NtGdiDeleteObjectAppPtr = 0;
PVOID NtGdiExtTextOutWPtr = 0;
PVOID NtGdiHfontCreatePtr = 0;
PVOID NtGdiSelectFontPtr = 0;

inline HDC NtUserGetDC(HWND hwnd)
{
	auto fn = reinterpret_cast<HDC(*)(HWND hwnd)>(NtUserGetDCPtr);
	return fn(hwnd);
}

inline HBRUSH NtGdiSelectBrush(HDC hdc, HBRUSH hbrush)
{
	auto fn = reinterpret_cast<HBRUSH(*)(HDC hdc, HBRUSH hbrush)>(NtGdiSelectBrushPtr);
	return fn(hdc, hbrush);
}

inline BOOL NtGdiPatBlt(HDC hdcDest, INT x, INT y, INT cx, INT cy, DWORD dwRop)
{
	auto fn = reinterpret_cast<BOOL(*)(HDC hdcDest, INT x, INT y, INT cx, INT cy, DWORD dwRop)>(NtGdiPatBltPtr);
	return fn(hdcDest, x, y, cx, cy, dwRop);
}

inline int NtUserReleaseDC(HDC hdc)
{
	auto fn = reinterpret_cast<int(*)(HDC hdc)>(NtUserReleaseDCPtr);
	return fn(hdc);
}

inline HBRUSH NtGdiCreateSolidBrush(COLORREF cr, HBRUSH hbr)
{
	auto fn = reinterpret_cast<HBRUSH(*)(COLORREF cr, HBRUSH hbr)>(NtGdiCreateSolidBrushPtr);
	return fn(cr, hbr);
}

inline BOOL NtGdiDeleteObjectApp(HANDLE hobj)
{
	auto fn = reinterpret_cast<BOOL(*)(HANDLE hobj)>(NtGdiDeleteObjectAppPtr);
	return fn(hobj);
}

inline BOOL NtGdiExtTextOutW(HDC hDC, INT XStart, INT YStart, UINT fuOptions, LPRECT UnsafeRect, LPWSTR UnsafeString, INT Count, LPINT UnsafeDx, DWORD dwCodePage)
{
	auto fn = reinterpret_cast<BOOL(*)(HDC hDC, INT XStart, INT YStart, UINT fuOptions, LPRECT UnsafeRect, LPWSTR UnsafeString, INT Count, LPINT UnsafeDx, DWORD dwCodePage)>(NtGdiExtTextOutWPtr);
	return fn(hDC, XStart, YStart, fuOptions, UnsafeRect, UnsafeString, Count, UnsafeDx, dwCodePage);
}

inline HFONT NtGdiHfontCreate(PENUMLOGFONTEXDVW pelfw, ULONG cjElfw, LFTYPE lft, FLONG fl, PVOID pvCliData)
{
	auto fn = reinterpret_cast<HFONT(*)(PENUMLOGFONTEXDVW pelfw, ULONG cjElfw, LFTYPE lft, FLONG fl, PVOID pvCliData)>(NtGdiHfontCreatePtr);
	return fn(pelfw, cjElfw, lft, fl, pvCliData);
}

inline HFONT NtGdiSelectFont(HDC hdc, HFONT hfont)
{
	auto fn = reinterpret_cast<HFONT(*)(HDC hdc, HFONT hfont)>(NtGdiSelectFontPtr);
	return fn(hdc, hfont);
}


typedef struct _PEB_LDR_DATA {
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandle;
	LIST_ENTRY ModuleListLoadOrder;
	LIST_ENTRY ModuleListMemoryOrder;
	LIST_ENTRY ModuleListInitOrder;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef void(__stdcall* PPS_POST_PROCESS_INIT_ROUTINE)(void); // not exported

typedef struct _PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, * PPEB;

typedef struct _PEB32 {
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG Ldr;
	ULONG ProcessParameters;
	ULONG SubSystemData;
	ULONG ProcessHeap;
	ULONG FastPebLock;
	ULONG AtlThunkSListPtr;
	ULONG IFEOKey;
	ULONG CrossProcessFlags;
	ULONG UserSharedInfoPtr;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	ULONG ApiSetMap;
} PEB32, * PPEB32;

typedef struct _PEB_LDR_DATA32 {
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;  // in bytes
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;  // LDR_*
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	PVOID SectionPointer;
	ULONG CheckSum;
	ULONG TimeDateStamp;
	//    PVOID			LoadedImports;
	//    // seems they are exist only on XP !!! PVOID
	//    EntryPointActivationContext;	// -same-
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;


```

`CsgoFullKernel/Offsets.h`:

```h
namespace hazedumper {

	namespace netvars {
		#define cs_gamerules_data  0x0
		#define m_ArmorValue  0x117CC
		#define m_Collision  0x320
		#define m_CollisionGroup  0x474
		#define m_Local  0x2FCC
		#define m_MoveType  0x25C
		#define m_OriginalOwnerXuidHigh  0x31D4
		#define m_OriginalOwnerXuidLow  0x31D0
		#define m_SurvivalGameRuleDecisionTypes  0x1328
		#define m_SurvivalRules  0xD00
		#define m_aimPunchAngle  0x303C
		#define m_aimPunchAngleVel  0x3048
		#define m_angEyeAnglesX  0x117D0
		#define m_angEyeAnglesY  0x117D4
		#define m_bBombDefused  0x29C0
		#define m_bBombPlanted  0x9A5
		#define m_bBombTicking  0x2990
		#define m_bFreezePeriod  0x20
		#define m_bGunGameImmunity  0x9990
		#define m_bHasDefuser  0x117DC
		#define m_bHasHelmet  0x117C0
		#define m_bInReload  0x32B5
		#define m_bIsDefusing  0x997C
		#define m_bIsQueuedMatchmaking  0x74
		#define m_bIsScoped  0x9974
		#define m_bIsValveDS  0x7C
		#define m_bSpotted  0x93D
		#define m_bSpottedByMask  0x980
		#define m_bStartedArming  0x3400
		#define m_bUseCustomAutoExposureMax  0x9D9
		#define m_bUseCustomAutoExposureMin  0x9D8
		#define m_bUseCustomBloomScale  0x9DA
		#define m_clrRender  0x70
		#define m_dwBoneMatrix  0x26A8
		#define m_fAccuracyPenalty  0x3340
		#define m_fFlags  0x104
		#define m_flC4Blow  0x29A0
		#define m_flCustomAutoExposureMax  0x9E0
		#define m_flCustomAutoExposureMin  0x9DC
		#define m_flCustomBloomScale  0x9E4
		#define m_flDefuseCountDown  0x29BC
		#define m_flDefuseLength  0x29B8
		#define m_flFallbackWear  0x31E0
		#define m_flFlashDuration  0x10470
		#define m_flFlashMaxAlpha  0x1046C
		#define m_flLastBoneSetupTime  0x2928
		#define m_flLowerBodyYawTarget  0x9ADC
		#define m_flNextAttack  0x2D80
		#define m_flNextPrimaryAttack  0x3248
		#define m_flSimulationTime  0x268
		#define m_flTimerLength  0x29A4
		#define m_hActiveWeapon  0x2F08
		#define m_hBombDefuser  0x29C4
		#define m_hMyWeapons  0x2E08
		#define m_hObserverTarget  0x339C
		#define m_hOwner  0x29DC
		#define m_hOwnerEntity  0x14C
		#define m_hViewModel  0x3308
		#define m_iAccountID  0x2FD8
		#define m_iClip1  0x3274
		#define m_iCompetitiveRanking  0x1A84
		#define m_iCompetitiveWins  0x1B88
		#define m_iCrosshairId  0x11838
		#define m_iDefaultFOV  0x333C
		#define m_iEntityQuality  0x2FBC
		#define m_iFOV  0x31F4
		#define m_iFOVStart  0x31F8
		#define m_iGlowIndex  0x10488
		#define m_iHealth  0x100
		#define m_iItemDefinitionIndex  0x2FBA
		#define m_iItemIDHigh  0x2FD0
		#define m_iMostRecentModelBoneCounter  0x2690
		#define m_iObserverMode  0x3388
		#define m_iShotsFired  0x103E0
		#define m_iState  0x3268
		#define m_iTeamNum  0xF4
		#define m_lifeState  0x25F
		#define m_nBombSite  0x2994
		#define m_nFallbackPaintKit  0x31D8
		#define m_nFallbackSeed  0x31DC
		#define m_nFallbackStatTrak  0x31E4
		#define m_nForceBone  0x268C
		#define m_nModelIndex  0x258
		#define m_nTickBase  0x3440
		#define m_nViewModelIndex  0x29D0
		#define m_rgflCoordinateFrame  0x444
		#define m_szCustomName  0x304C
		#define m_szLastPlaceName  0x35C4
		#define m_thirdPersonViewAngles  0x31E8
		#define m_vecOrigin  0x138
		#define m_vecVelocity  0x114
		#define m_vecViewOffset  0x108
		#define m_viewPunchAngle  0x3030
		#define m_zoomLevel  0x33E0
	} // namespace netvars
	namespace signatures {
		#define anim_overlays  0x2990
		#define clientstate_choked_commands  0x4D30
		#define clientstate_delta_ticks  0x174
		#define clientstate_last_outgoing_command  0x4D2C
		#define clientstate_net_channel  0x9C
		#define convar_name_hash_table  0x2F190
		#define dwClientState  0x58CFDC
		#define dwClientState_GetLocalPlayer  0x180
		#define dwClientState_IsHLTV  0x4D48
		#define dwClientState_Map  0x28C
		#define dwClientState_MapDirectory  0x188
		#define dwClientState_MaxPlayer  0x388
		#define dwClientState_PlayerInfo  0x52C0
		#define dwClientState_State  0x108
		#define dwClientState_ViewAngles  0x4D90
		#define dwEntityList  0x4DDB8FC
		#define dwForceAttack  0x320BDC8
		#define dwForceAttack2  0x320BDD4
		#define dwForceBackward  0x320BE10
		#define dwForceForward  0x320BE04
		#define dwForceJump  0x52858DC
		#define dwForceLeft  0x320BE1C
		#define dwForceRight  0x320BE28
		#define dwGameDir  0x62B900
		#define dwGameRulesProxy  0x52F910C
		#define dwGetAllClasses  0xDE9C9C
		#define dwGlobalVars  0x58CCE0
		#define dwGlowObjectManager  0x53245E8
		#define dwInput  0x522CED0
		#define dwInterfaceLinkList  0x96EF44
		#define dwLocalPlayer  0xDBF4BC
		#define dwMouseEnable  0xDC51C8
		#define dwMouseEnablePtr  0xDC5198
		#define dwPlayerResource  0x320A160
		#define dwRadarBase  0x5210674
		#define dwSensitivity  0xDC5064
		#define dwSensitivityPtr  0xDC5038
		#define dwSetClanTag  0x8A410
		#define dwViewMatrix  0x4DCD214
		#define dwWeaponTable  0x522D994
		#define dwWeaponTableIndex  0x326C
		#define dwYawPtr  0xDC4E28
		#define dwZoomSensitivityRatioPtr  0xDCB610
		#define dwbSendPackets  0xD8452
		#define dwppDirect3DDevice9  0xA6050
		#define find_hud_element  0x281D5A80
		#define force_update_spectator_glow  0x3BE35A
		#define interface_engine_cvar  0x3EA3C
		#define is_c4_owner  0x3CB3D0
		#define m_bDormant  0xED
		#define m_bIsLocalPlayer  0x3628
		#define m_flSpawnTime  0x103C0
		#define m_pStudioHdr  0x2950
		#define m_pitchClassPtr  0x5210910
		#define m_yawClassPtr  0xDC4E28
		#define model_ambient_min  0x590054
		#define set_abs_angles  0x1E59F0
		#define set_abs_origin  0x1E5830
	} // namespace signatures
} // namespace hazedumper
```

`CsgoFullKernel/VkCodes.h`:

```h
#pragma once

#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02
#define VK_CANCEL         0x03
#define VK_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */
#define VK_XBUTTON1       0x05    /* NOT contiguous with L & RBUTTON */
#define VK_XBUTTON2       0x06    /* NOT contiguous with L & RBUTTON */
#define VK_BACK           0x08
#define VK_TAB            0x09
#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D
#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14
#define VK_KANA           0x15
#define VK_HANGEUL        0x15  /* old name - should be here for compatibility */
#define VK_HANGUL         0x15
#define VK_IME_ON         0x16
#define VK_JUNJA          0x17
#define VK_FINAL          0x18
#define VK_HANJA          0x19
#define VK_KANJI          0x19
#define VK_IME_OFF        0x1A
#define VK_ESCAPE         0x1B
#define VK_CONVERT        0x1C
#define VK_NONCONVERT     0x1D
#define VK_ACCEPT         0x1E
#define VK_MODECHANGE     0x1F
#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F
#define VK_LWIN           0x5B
#define VK_RWIN           0x5C
#define VK_APPS           0x5D
#define VK_SLEEP          0x5F
#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define VK_F1             0x70
#define VK_F2             0x71
#define VK_F3             0x72
#define VK_F4             0x73
#define VK_F5             0x74
#define VK_F6             0x75
#define VK_F7             0x76
#define VK_F8             0x77
#define VK_F9             0x78
#define VK_F10            0x79
#define VK_F11            0x7A
#define VK_F12            0x7B
#define VK_F13            0x7C
#define VK_F14            0x7D
#define VK_F15            0x7E
#define VK_F16            0x7F
#define VK_F17            0x80
#define VK_F18            0x81
#define VK_F19            0x82
#define VK_F20            0x83
#define VK_F21            0x84
#define VK_F22            0x85
#define VK_F23            0x86
#define VK_F24            0x87
#define VK_NAVIGATION_VIEW     0x88 // reserved
#define VK_NAVIGATION_MENU     0x89 // reserved
#define VK_NAVIGATION_UP       0x8A // reserved
#define VK_NAVIGATION_DOWN     0x8B // reserved
#define VK_NAVIGATION_LEFT     0x8C // reserved
#define VK_NAVIGATION_RIGHT    0x8D // reserved
#define VK_NAVIGATION_ACCEPT   0x8E // reserved
#define VK_NAVIGATION_CANCEL   0x8F // reserved
#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91
#define VK_OEM_NEC_EQUAL  0x92   // '=' key on numpad
#define VK_OEM_FJ_JISHO   0x92   // 'Dictionary' key
#define VK_OEM_FJ_MASSHOU 0x93   // 'Unregister word' key
#define VK_OEM_FJ_TOUROKU 0x94   // 'Register word' key
#define VK_OEM_FJ_LOYA    0x95   // 'Left OYAYUBI' key
#define VK_OEM_FJ_ROYA    0x96   // 'Right OYAYUBI' key
#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5
#define VK_BROWSER_BACK        0xA6
#define VK_BROWSER_FORWARD     0xA7
#define VK_BROWSER_REFRESH     0xA8
#define VK_BROWSER_STOP        0xA9
#define VK_BROWSER_SEARCH      0xAA
#define VK_BROWSER_FAVORITES   0xAB
#define VK_BROWSER_HOME        0xAC
#define VK_VOLUME_MUTE         0xAD
#define VK_VOLUME_DOWN         0xAE
#define VK_VOLUME_UP           0xAF
#define VK_MEDIA_NEXT_TRACK    0xB0
#define VK_MEDIA_PREV_TRACK    0xB1
#define VK_MEDIA_STOP          0xB2
#define VK_MEDIA_PLAY_PAUSE    0xB3
#define VK_LAUNCH_MAIL         0xB4
#define VK_LAUNCH_MEDIA_SELECT 0xB5
#define VK_LAUNCH_APP1         0xB6
#define VK_LAUNCH_APP2         0xB7
#define VK_OEM_1          0xBA   // ';:' for US
#define VK_OEM_PLUS       0xBB   // '+' any country
#define VK_OEM_COMMA      0xBC   // ',' any country
#define VK_OEM_MINUS      0xBD   // '-' any country
#define VK_OEM_PERIOD     0xBE   // '.' any country
#define VK_OEM_2          0xBF   // '/?' for US
#define VK_OEM_3          0xC0   // '`~' for US
#define VK_GAMEPAD_A                         0xC3 // reserved
#define VK_GAMEPAD_B                         0xC4 // reserved
#define VK_GAMEPAD_X                         0xC5 // reserved
#define VK_GAMEPAD_Y                         0xC6 // reserved
#define VK_GAMEPAD_RIGHT_SHOULDER            0xC7 // reserved
#define VK_GAMEPAD_LEFT_SHOULDER             0xC8 // reserved
#define VK_GAMEPAD_LEFT_TRIGGER              0xC9 // reserved
#define VK_GAMEPAD_RIGHT_TRIGGER             0xCA // reserved
#define VK_GAMEPAD_DPAD_UP                   0xCB // reserved
#define VK_GAMEPAD_DPAD_DOWN                 0xCC // reserved
#define VK_GAMEPAD_DPAD_LEFT                 0xCD // reserved
#define VK_GAMEPAD_DPAD_RIGHT                0xCE // reserved
#define VK_GAMEPAD_MENU                      0xCF // reserved
#define VK_GAMEPAD_VIEW                      0xD0 // reserved
#define VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON    0xD1 // reserved
#define VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON   0xD2 // reserved
#define VK_GAMEPAD_LEFT_THUMBSTICK_UP        0xD3 // reserved
#define VK_GAMEPAD_LEFT_THUMBSTICK_DOWN      0xD4 // reserved
#define VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT     0xD5 // reserved
#define VK_GAMEPAD_LEFT_THUMBSTICK_LEFT      0xD6 // reserved
#define VK_GAMEPAD_RIGHT_THUMBSTICK_UP       0xD7 // reserved
#define VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN     0xD8 // reserved
#define VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT    0xD9 // reserved
#define VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT     0xDA // reserved
#define VK_OEM_4          0xDB  //  '[{' for US
#define VK_OEM_5          0xDC  //  '\|' for US
#define VK_OEM_6          0xDD  //  ']}' for US
#define VK_OEM_7          0xDE  //  ''"' for US
#define VK_OEM_8          0xDF
#define VK_OEM_AX         0xE1  //  'AX' key on Japanese AX kbd
#define VK_OEM_102        0xE2  //  "<>" or "\|" on RT 102-key kbd.
#define VK_ICO_HELP       0xE3  //  Help key on ICO
#define VK_ICO_00         0xE4  //  00 key on ICO
#define VK_PROCESSKEY     0xE5
#define VK_ICO_CLEAR      0xE6
#define VK_PACKET         0xE7
#define VK_OEM_RESET      0xE9
#define VK_OEM_JUMP       0xEA
#define VK_OEM_PA1        0xEB
#define VK_OEM_PA2        0xEC
#define VK_OEM_PA3        0xED
#define VK_OEM_WSCTRL     0xEE
#define VK_OEM_CUSEL      0xEF
#define VK_OEM_ATTN       0xF0
#define VK_OEM_FINISH     0xF1
#define VK_OEM_COPY       0xF2
#define VK_OEM_AUTO       0xF3
#define VK_OEM_ENLW       0xF4
#define VK_OEM_BACKTAB    0xF5
#define VK_ATTN           0xF6
#define VK_CRSEL          0xF7
#define VK_EXSEL          0xF8
#define VK_EREOF          0xF9
#define VK_PLAY           0xFA
#define VK_ZOOM           0xFB
#define VK_NONAME         0xFC
#define VK_PA1            0xFD
#define VK_OEM_CLEAR      0xFE

```

`README.md`:

```md
# Csgo Full kernel
 csgo external running from kernelmode

```