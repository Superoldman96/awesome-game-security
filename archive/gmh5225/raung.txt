Project Path: arc_gmh5225_raung_53_m5b2s

Source Tree:

```txt
arc_gmh5225_raung_53_m5b2s
├── LICENSE
├── README.md
├── build.gradle.kts
├── buildSrc
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── kotlin
│               ├── raung.java-common.gradle.kts
│               └── raung.java-library.gradle.kts
├── config
│   ├── checkstyle
│   │   └── checkstyle.xml
│   └── code-formatter
│       ├── eclipse.importorder
│       └── eclipse.xml
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── raung-asm
│   ├── build.gradle.kts
│   └── src
│       ├── main
│       │   └── java
│       │       └── io
│       │           └── github
│       │               └── skylot
│       │                   └── raung
│       │                       └── asm
│       │                           ├── RaungAsm.java
│       │                           ├── api
│       │                           │   └── IRaungAsm.java
│       │                           └── impl
│       │                               ├── RaungAsmBuilder.java
│       │                               ├── RaungAsmExecutor.java
│       │                               ├── asm
│       │                               │   ├── InsnAnnotationNode.java
│       │                               │   ├── RaungAsmWriter.java
│       │                               │   └── RaungClassWriter.java
│       │                               ├── parser
│       │                               │   ├── RaungParser.java
│       │                               │   ├── RaungTokenizer.java
│       │                               │   ├── code
│       │                               │   │   ├── AnnotationParser.java
│       │                               │   │   ├── InvokeDynamicParser.java
│       │                               │   │   ├── OpCodeParser.java
│       │                               │   │   ├── SwitchParser.java
│       │                               │   │   └── ValueParser.java
│       │                               │   ├── data
│       │                               │   │   ├── AutoOption.java
│       │                               │   │   ├── ClassData.java
│       │                               │   │   ├── CommonData.java
│       │                               │   │   ├── FieldData.java
│       │                               │   │   ├── MethodData.java
│       │                               │   │   ├── RaungLabel.java
│       │                               │   │   ├── RaungLocalVar.java
│       │                               │   │   ├── TryCatchBlock.java
│       │                               │   │   └── TypeRefPathData.java
│       │                               │   ├── directives
│       │                               │   │   ├── ClassDirectives.java
│       │                               │   │   ├── FieldDirectives.java
│       │                               │   │   ├── IDirectivesProcessor.java
│       │                               │   │   └── MethodDirectives.java
│       │                               │   └── utils
│       │                               │       └── StringAsmUtils.java
│       │                               └── utils
│       │                                   ├── AsmLibException.java
│       │                                   ├── RaungAsmException.java
│       │                                   ├── RaungAsmTokenException.java
│       │                                   └── ValidateAsmArgs.java
│       └── test
│           ├── java
│           │   └── io
│           │       └── github
│           │           └── skylot
│           │               └── raung
│           │                   └── asm
│           │                       └── tests
│           │                           ├── api
│           │                           │   └── IntegrationTest.java
│           │                           └── integration
│           │                               ├── annotations
│           │                               │   └── TestAsmFieldAnnotations.java
│           │                               ├── conditions
│           │                               │   └── TestAsmAuto.java
│           │                               └── other
│           │                                   ├── TestAsmHelloWorld.java
│           │                                   └── TestStringConcatJava11.java
│           └── resources
│               └── raung
│                   ├── annotations
│                   │   └── TestAsmFieldAnnotations.raung
│                   ├── conditions
│                   │   └── TestAsmAuto.raung
│                   └── other
│                       ├── TestAsmHelloWorld.raung
│                       └── TestStringConcatJava11.raung
├── raung-cli
│   ├── build.gradle.kts
│   └── src
│       └── main
│           ├── java
│           │   └── io
│           │       └── github
│           │           └── skylot
│           │               └── raung
│           │                   └── cli
│           │                       ├── RaungArgs.java
│           │                       └── RaungCLI.java
│           └── resources
│               └── logback.xml
├── raung-common
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── java
│               └── io
│                   └── github
│                       └── skylot
│                           └── raung
│                               └── common
│                                   ├── AnnotationType.java
│                                   ├── Directive.java
│                                   ├── DirectiveScope.java
│                                   ├── JavaOpCodeFormat.java
│                                   ├── JavaOpCodes.java
│                                   ├── RaungAccessFlags.java
│                                   ├── asm
│                                   │   ├── HandleTag.java
│                                   │   ├── StackType.java
│                                   │   ├── TypeRef.java
│                                   │   └── TypeRefFormat.java
│                                   └── utils
│                                       ├── FileUtils.java
│                                       ├── JavaVersion.java
│                                       ├── LimitedInputStream.java
│                                       ├── StringCommonUtils.java
│                                       └── ZipUtils.java
├── raung-disasm
│   ├── build.gradle.kts
│   └── src
│       ├── main
│       │   └── java
│       │       └── io
│       │           └── github
│       │               └── skylot
│       │                   └── raung
│       │                       └── disasm
│       │                           ├── RaungDisasm.java
│       │                           ├── api
│       │                           │   ├── IRaungDisasm.java
│       │                           │   └── RaungDisasmPreset.java
│       │                           └── impl
│       │                               ├── RaungDisasmBuilder.java
│       │                               ├── RaungDisasmExecutor.java
│       │                               ├── utils
│       │                               │   ├── ListUtils.java
│       │                               │   ├── RaungDisasmException.java
│       │                               │   ├── RaungTypes.java
│       │                               │   ├── RaungWriter.java
│       │                               │   ├── StringDisasmUtils.java
│       │                               │   ├── TypeRefUtils.java
│       │                               │   └── ValidateDisasmArgs.java
│       │                               └── visitors
│       │                                   ├── RaungAnnotationVisitor.java
│       │                                   ├── RaungClassVisitor.java
│       │                                   ├── RaungFieldVisitor.java
│       │                                   ├── RaungMethodVisitor.java
│       │                                   └── data
│       │                                       ├── LabelData.java
│       │                                       ├── LocalVar.java
│       │                                       └── TryCatchBlock.java
│       └── test
│           ├── java
│           │   └── io
│           │       └── github
│           │           └── skylot
│           │               └── raung
│           │                   └── disasm
│           │                       ├── impl
│           │                       │   └── utils
│           │                       │       └── TestJavaVersion.java
│           │                       └── tests
│           │                           ├── api
│           │                           │   └── IntegrationTest.java
│           │                           ├── functional
│           │                           │   └── RaungDisasmTest.java
│           │                           └── integration
│           │                               ├── TestFieldAnnotations.java
│           │                               └── TestHelloWorld.java
│           └── resources
│               └── logback.xml
├── raung-tests
│   ├── build.gradle.kts
│   └── src
│       └── test
│           ├── java
│           │   └── io
│           │       └── github
│           │           └── skylot
│           │               └── raung
│           │                   └── tests
│           │                       ├── api
│           │                       │   └── IntegrationTest.java
│           │                       └── integration
│           │                           ├── TestConditions.java
│           │                           ├── TestHelloWorld.java
│           │                           ├── TestInvokeDynamic.java
│           │                           ├── TestLoadConst.java
│           │                           ├── TestParser.java
│           │                           ├── TestStringEscape.java
│           │                           ├── TestSwitch.java
│           │                           ├── TestTryCatch.java
│           │                           ├── annotations
│           │                           │   └── TestAnnotations.java
│           │                           ├── attributes
│           │                           │   ├── TestMethodParam.java
│           │                           │   └── TestNestHostAndMember.java
│           │                           ├── insns
│           │                           │   └── TestJSR.java
│           │                           └── other
│           │                               ├── TestAnonymousAndLambda.java
│           │                               └── TestNewFrameType.java
│           └── resources
│               └── raung
│                   ├── attributes
│                   │   ├── TestMethodParam.raung
│                   │   ├── TestNestHost.raung
│                   │   └── TestNestMember.raung
│                   ├── insns
│                   │   └── TestJSR.raung
│                   └── other
│                       └── TestNewFrameType.raung
└── settings.gradle.kts

```

`LICENSE`:

```
MIT License

Copyright (c) 2021-present Skylot and other contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Raung

[![Build](https://github.com/skylot/raung/actions/workflows/build.yml/badge.svg?branch=main)](https://github.com/skylot/raung/actions/workflows/build.yml)
![Java 11+](https://img.shields.io/badge/Java-11%2B-blue)
[![Maven Central](https://img.shields.io/maven-central/v/io.github.skylot/raung-asm?style=flat)](https://search.maven.org/search?q=raung)
[![License](https://img.shields.io/github/license/skylot/raung)](https://github.com/skylot/raung/blob/main/LICENSE)

**raung** - yet another assembler/disassembler for java bytecode.

Similar to [Krakatau](https://github.com/Storyyeller/Krakatau) and [Smali](https://github.com/JesusFreke/smali),
based on [ASM](https://asm.ow2.io/) library.

> [!WARNING]
> This project at a very early stage of development, many features not yet finished and syntax not stable.

### Syntax example:
```java
.version 52
.class public HelloWorld
.source "HelloWorld.java"

.method public static main([Ljava/lang/String;)V
	.max stack 2
	.max locals 1

	.local 0 "args" [Ljava/lang/String;
	.line 4
	getstatic java/lang/System out Ljava/io/PrintStream;
	ldc "Hello, World!"
	invokevirtual java/io/PrintStream println (Ljava/lang/String;)V
	.line 5
	return
.end method
```

---------------------------------------
*Licensed under the MIT License*

```

`build.gradle.kts`:

```kts
import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask
import java.util.*

plugins {
	id("com.github.ben-manes.versions") version "0.51.0"
	id("se.patrikerdes.use-latest-versions") version "0.2.18"
	id("com.diffplug.spotless") version "6.25.0"
}

repositories {
	mavenCentral()
	google()
}

// TODO: move to `raung.java-common` base configuration
allprojects {
	apply(plugin = "java")
	apply(plugin = "checkstyle")
	apply(plugin = "com.github.ben-manes.versions")
	apply(plugin = "se.patrikerdes.use-latest-versions")
	apply(plugin = "com.diffplug.spotless")

	spotless {
		java {
			importOrderFile("${rootDir}/config/code-formatter/eclipse.importorder")
			eclipse().configFile("${rootDir}/config/code-formatter/eclipse.xml")
			removeUnusedImports()
			encoding("UTF-8")
			trimTrailingWhitespace()
			endWithNewline()
		}
		format("misc") {
			target("**/*.gradle.kts", "**/*.md", "**/.gitignore")
			targetExclude(".gradle/**", ".idea/**", "*/build/**")
			indentWithTabs()
			trimTrailingWhitespace()
			endWithNewline()
		}
	}
}

tasks.withType<DependencyUpdatesTask> {
	rejectVersionIf {
		isNonStable(candidate.version)
	}
}

fun isNonStable(version: String): Boolean {
	val stableKeyword = listOf("RELEASE", "FINAL", "GA").any { version.uppercase(Locale.getDefault()).contains(it) }
	val regex = "^[0-9,.v-]+(-r)?$".toRegex()
	val isStable = stableKeyword || regex.matches(version)
	return isStable.not()
}


var libProjects = listOf(":raung-common", ":raung-asm", ":raung-disasm")

tasks.register("publishLocal") {
	group = "raung"
	description = "Publish library packages into Maven local repo"

	libProjects.forEach {
		dependsOn(tasks.getByPath("$it:publishToMavenLocal"))
	}
}
tasks.register("publish") {
	group = "raung"
	description = "Publish library packages into Maven Central repo"

	libProjects.forEach {
		dependsOn(tasks.getByPath("$it:publish"))
	}
}

tasks.register("dist", Copy::class) {
	group = "raung"
	description = "Build raung-cli distribution package"

	from(tasks.getByPath(":raung-cli:distZip"))
	into(layout.buildDirectory.dir("dist"))
}

tasks.register("cleanBuild", Delete::class) {
	group = "raung"
	description = "Remove all build directories"

	delete(layout.buildDirectory)
}

tasks.getByName("clean").dependsOn("cleanBuild")

```

`buildSrc/build.gradle.kts`:

```kts
plugins {
	`kotlin-dsl`
}

repositories {
	gradlePluginPortal()
}

```

`buildSrc/src/main/kotlin/raung.java-common.gradle.kts`:

```kts
plugins {
	java
	checkstyle
}

group = "io.github.skylot.raung"
version = System.getenv("RAUNG_VERSION") ?: "dev"

java {
	sourceCompatibility = JavaVersion.VERSION_11
	targetCompatibility = JavaVersion.VERSION_11
}

repositories {
	mavenCentral()
}

dependencies {
	testImplementation("ch.qos.logback:logback-classic:1.5.7")
	testImplementation("org.assertj:assertj-core:3.26.3")

	testImplementation("org.junit.jupiter:junit-jupiter:5.11.0")
	testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

tasks.test {
	useJUnitPlatform()
}

```

`buildSrc/src/main/kotlin/raung.java-library.gradle.kts`:

```kts
plugins {
	id("raung.java-common")

	`java-library`
	`maven-publish`
	signing
}

dependencies {
	api("org.slf4j:slf4j-api:2.0.16")
}

group = "io.github.skylot"
version = System.getenv("RAUNG_VERSION") ?: "dev"

java {
	withJavadocJar()
	withSourcesJar()
}
publishing {
	publications {
		create<MavenPublication>("mavenJava") {
			artifactId = project.name
			from(components["java"])
			versionMapping {
				usage("java-api") {
					fromResolutionOf("runtimeClasspath")
				}
				usage("java-runtime") {
					fromResolutionResult()
				}
			}
			pom {
				name.set(project.name)
				description.set("Assembler/disassembler for java bytecode")
				url.set("https://github.com/skylot/raung")
				licenses {
					license {
						name.set("MIT License")
						url.set("http://www.opensource.org/licenses/mit-license.php")
					}
				}
				developers {
					developer {
						id.set("skylot")
						name.set("Skylot")
						email.set("skylot@gmail.com")
						url.set("https://github.com/skylot")
					}
				}
				scm {
					connection.set("scm:git:git://github.com/skylot/raung.git")
					developerConnection.set("scm:git:ssh://github.com:skylot/raung.git")
					url.set("https://github.com/skylot/raung")
				}
			}
		}
	}
	repositories {
		maven {
			val releasesRepoUrl = uri("https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/")
			val snapshotsRepoUrl = uri("https://s01.oss.sonatype.org/content/repositories/snapshots/")
			url = if (version.toString().endsWith("SNAPSHOT")) snapshotsRepoUrl else releasesRepoUrl
			credentials {
				username = project.properties["ossrhUser"].toString()
				password = project.properties["ossrhPassword"].toString()
			}
		}
	}
}

signing {
	setRequired(gradle.taskGraph.hasTask("publish"))
	sign(publishing.publications["mavenJava"])
}

tasks.javadoc {
	val stdOptions = options as StandardJavadocDocletOptions
	if (JavaVersion.current().isJava9Compatible) {
		stdOptions.addBooleanOption("html5", true)
	}
	// disable 'missing' warnings
	stdOptions.addStringOption("Xdoclint:all,-missing", "-quiet")
}

```

`config/checkstyle/checkstyle.xml`:

```xml
<?xml version="1.0" ?>

<!DOCTYPE module PUBLIC
		"-//Puppy Crawl//DTD Check Configuration 1.2//EN"
		"http://www.puppycrawl.com/dtds/configuration_1_2.dtd">

<module name="Checker">
	<property name="fileExtensions" value="java, properties, xml"/>
	<property name="charset" value="UTF-8"/>

	<module name="TreeWalker">
		<property name="tabWidth" value="4"/>
		<module name="RegexpSinglelineJava">
			<property name="format" value="^\t* "/>
			<property name="message" value="Indent must use tab characters"/>
			<property name="ignoreComments" value="true"/>
		</module>
		<module name="RegexpSinglelineJava">
			<property name="format" value="^(?!\s+\* $).*?\s+$"/>
			<property name="message" value="Line has trailing spaces."/>
		</module>
		<module name="AvoidEscapedUnicodeCharacters">
			<property name="allowEscapesForControlCharacters" value="true"/>
			<property name="allowByTailComment" value="true"/>
			<property name="allowNonPrintableEscapes" value="true"/>
		</module>

		<module name="EmptyLineSeparator">
			<property name="allowNoEmptyLineBetweenFields" value="true"/>
			<property name="allowMultipleEmptyLines" value="false"/>
		</module>

		<!-- whitespaces -->
		<module name="SingleSpaceSeparator"/>
		<module name="GenericWhitespace"/>
		<module name="MethodParamPad"/>
		<module name="NoWhitespaceBefore"/>
		<module name="OperatorWrap"/>
		<module name="ParenPad"/>
		<module name="TypecastParenPad"/>
		<module name="WhitespaceAfter"/>
		<module name="WhitespaceAround">
			<property name="allowEmptyMethods" value="true"/>
		</module>
		<!-- <module name="EmptyForIteratorPad"/> -->
		<!-- <module name="NoWhitespaceAfter"/>-->

		<module name="NoLineWrap"/>

		<module name="IllegalImport"/> <!-- defaults to sun.* packages -->
		<module name="RedundantImport"/>
		<module name="UnusedImports"/>
		<!-- <module name="AvoidStarImport"/> -->

		<module name="NeedBraces"/>
		<module name="LeftCurly"/>
		<module name="RightCurly"/>
		<module name="EmptyCatchBlock">
			<property name="exceptionVariableName" value="expected|ignore"/>
		</module>

		<!-- naming -->
		<module name="PackageName"/>
		<module name="TypeName"/>
		<module name="InterfaceTypeParameterName"/>
		<module name="ClassTypeParameterName"/>
		<module name="StaticVariableName"/>
		<module name="ConstantName"/>
		<module name="MemberName"/>
		<module name="MethodName"/>
		<module name="MethodTypeParameterName"/>
		<module name="ParameterName"/>
		<module name="LambdaParameterName"/>
		<module name="LocalVariableName"/>
		<module name="LocalFinalVariableName"/>
		<module name="CatchParameterName"/>
		<!-- <module name="HiddenField"/> -->

		<!-- annotations -->
		<module name="AnnotationLocation"/>
		<module name="AnnotationUseStyle">
			<property name="elementStyle" value="compact"/>
		</module>
		<module name="MissingOverride"/>
		<!-- <module name="MissingDeprecated"/> -->

		<module name="ModifierOrder"/>
		<!-- <module name="RedundantModifier"/> -->
		<!-- <module name="ParameterNumber"/> -->

		<module name="EmptyStatement"/>
		<module name="DefaultComesLast"/>
		<module name="EqualsHashCode"/>
		<module name="FallThrough"/>
		<!-- <module name="IllegalCatch"/> -->
		<module name="IllegalThrows"/>
		<module name="IllegalType"/>
		<module name="InnerAssignment"/>
		<module name="MultipleVariableDeclarations"/>
		<module name="NoClone"/>
		<module name="NoFinalizer"/>
		<module name="OneStatementPerLine"/>
		<module name="PackageDeclaration"/>
		<module name="StringLiteralEquality"/>

		<!-- design -->
		<module name="OneTopLevelClass"/>
		<module name="MutableException"/>
		<module name="InterfaceIsType"/>
		<module name="ThrowsCount">
			<property name="max" value="2"/>
		</module>

		<!-- misc -->
		<module name="ArrayTypeStyle"/>
		<module name="OuterTypeFilename"/>

		<!-- sizes -->
		<module name="OuterTypeNumber"/>

		<module name="SuppressWarningsHolder"/>

		<module name="IllegalType"/>
	</module>

	<module name="NewlineAtEndOfFile"/>
	<module name="SuppressWarningsFilter"/>
</module>

```

`config/code-formatter/eclipse.importorder`:

```importorder
#Import Order
0=java
1=javax
2=com
3=org
4=
5=io.github.skylot.raung
6=\#

```

`config/code-formatter/eclipse.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<profiles version="16">
    <profile kind="CodeFormatterProfile" name="raung eclipse" version="16">
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_ellipsis" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_for_statment" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_logical_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_method_invocation" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_after_imports" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_switch_statement" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.format_javadoc_comments" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.indentation.size" value="4"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_enum_constant_declaration" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.align_with_spaces" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.disabling_tag" value="@formatter:off"/>
        <setting id="org.eclipse.jdt.core.formatter.continuation_indentation" value="2"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_enum_constants" value="48"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_imports" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_after_package" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_if_while_statement" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.indent_root_tags" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.enabling_tag" value="@formatter:on"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.count_line_length_from_starting_position" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_multiplicative_operator" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_parameterized_type_references" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_logical_operator" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_annotation_declaration_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_enum_constant" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_multiplicative_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_block" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.align_tags_descriptions_grouped" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.line_length" value="100"/>
        <setting id="org.eclipse.jdt.core.formatter.use_on_off_tags" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_method_body_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_loop_body_block_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_method_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_enum_constant_declaration_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.align_variable_declarations_on_columns" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_type_declaration_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_catch_clause" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_additive_operator" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_relational_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_multiplicative_operator" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_anonymous_type_declaration_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_shift_operator" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_block" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_lambda_body" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.compact_else_if" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_bitwise_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_type_parameters" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_compact_loops" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_simple_for_body_on_same_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_relational_operator" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_unary_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_annotation" value="separate_lines_if_wrapped"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_ellipsis" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_additive_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_string_concatenation" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.format_line_comments" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.align_type_members_on_columns" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_assignment" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_module_statements" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.align_tags_names_descriptions" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_if_then_body_block_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_conditional_expression" value="48"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.align_assignment_statements_on_columns" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_block_in_case" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_conditional_expression_chain" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.format_header" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_additive_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_method_declaration" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.join_wrapped_lines" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_conditional_operator" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_shift_operator" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.align_fields_grouping_blank_lines" value="2147483647"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_bitwise_operator" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_resources_in_try" value="80"/>
        <setting id="org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_try_clause" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_code_block_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.tabulation.size" value="4"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_bitwise_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.format_source_code" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_field" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer" value="2"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_method" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_assignment_operator" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_switch" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_type_annotation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.format_html" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_method_delcaration" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_compact_if" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_lambda_body_block_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_empty_lines" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_type_arguments" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_unary_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_label" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_member_type" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_logical_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_bitwise_operator" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_relational_operator" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.format_block_comments" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_lambda_arrow" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.indent_tag_description" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_string_concatenation" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_body" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_multiple_fields" value="16"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_simple_while_body_on_same_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_array_initializer" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_logical_operator" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_shift_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.parentheses_positions_in_lambda_declaration" value="common_lines"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_shift_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_simple_do_while_body_on_same_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_enum_declaration_on_one_line" value="one_line_never"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_constant" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.brace_position_for_type_declaration" value="end_of_line"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_multiplicative_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_before_package" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.alignment_for_expressions_in_for_loop_header" value="0"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_additive_operator" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.keep_simple_getter_setter_on_one_line" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_string_concatenation" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_lambda_arrow" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.join_lines_in_comments" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.comment.indent_parameter_description" value="false"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.tabulation.char" value="tab"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_relational_operator" value="insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.wrap_before_string_concatenation" value="true"/>
        <setting id="org.eclipse.jdt.core.formatter.blank_lines_between_import_groups" value="1"/>
        <setting id="org.eclipse.jdt.core.formatter.lineSplit" value="140"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation" value="do not insert"/>
        <setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch" value="insert"/>
    </profile>
</profiles>

```

`gradle.properties`:

```properties
org.gradle.warning.mode=all
org.gradle.parallel=true

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionSha256Sum=5b9c5eb3f9fc2c94abaea57d90bd78747ca117ddbbf96c859d3741181a12bf2a
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`raung-asm/build.gradle.kts`:

```kts
plugins {
	id("raung.java-library")
}

dependencies {
	api(project(":raung-common"))

	api("org.ow2.asm:asm-util:9.7")
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/RaungAsm.java`:

```java
package io.github.skylot.raung.asm;

import io.github.skylot.raung.asm.api.IRaungAsm;
import io.github.skylot.raung.asm.impl.RaungAsmBuilder;

public class RaungAsm {
	/**
	 * API entry point. Check {@link IRaungAsm} for available methods.
	 * Usage example:
	 * <br>
	 *
	 * <pre>
	 * RaungAsm.create()
	 * 		.input(Paths.get("inputDirOrFile"))
	 * 		.output(Paths.get("outputDir"))
	 * 		.execute();
	 * </pre>
	 */
	public static IRaungAsm create() {
		return new RaungAsmBuilder();
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/api/IRaungAsm.java`:

```java
package io.github.skylot.raung.asm.api;

import java.io.InputStream;
import java.nio.file.Path;
import java.util.List;

public interface IRaungAsm {

	/**
	 * List of files or directories (will preform recursive search for '.raung' files).
	 */
	IRaungAsm inputs(List<Path> inputs);

	/**
	 * Single file or directory (will preform recursive search for '.raung' files).
	 * Can be called several times if needed.
	 */
	IRaungAsm input(Path input);

	/**
	 * Directory or single file (only for single input).
	 * Optional - current dir will be used if not set.
	 */
	IRaungAsm output(Path out);

	/**
	 * Execute according to provided options.
	 */
	void execute();

	/**
	 * Single mode: process specified input file and return result as a byte array.
	 * Any set inputs or output will be ignored.
	 */
	byte[] executeForSingleClass(Path input);

	/**
	 * Single mode: process specified input stream and return result as a byte array.
	 * Any set inputs or output will be ignored.
	 */
	byte[] executeForInputStream(InputStream input);

	/**
	 * Single mode: process specified input raung code and return result as a byte array.
	 * Any set inputs or output will be ignored.
	 */
	byte[] executeForString(String raungCodeStr);
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/RaungAsmBuilder.java`:

```java
package io.github.skylot.raung.asm.impl;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import io.github.skylot.raung.asm.api.IRaungAsm;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;

public class RaungAsmBuilder implements IRaungAsm {
	private List<Path> inputs;
	private Path output;

	@Override
	public IRaungAsm inputs(List<Path> inputs) {
		this.inputs = inputs;
		return this;
	}

	@Override
	public IRaungAsm input(Path input) {
		if (this.inputs == null) {
			this.inputs = new ArrayList<>();
		}
		this.inputs.add(input);
		return this;
	}

	@Override
	public IRaungAsm output(Path out) {
		this.output = out;
		return this;
	}

	public List<Path> getInputs() {
		return inputs;
	}

	public Path getOutput() {
		return output;
	}

	@Override
	public void execute() {
		RaungAsmExecutor.process(this);
	}

	@Override
	public byte[] executeForSingleClass(Path input) {
		return RaungAsmExecutor.processSingleClass(this, input);
	}

	@Override
	public byte[] executeForInputStream(InputStream input) {
		try {
			return RaungAsmExecutor.processInputStream(this, input, "<input>");
		} catch (RaungAsmException e) {
			throw e;
		} catch (Exception e) {
			throw new RaungAsmException("Failed to process input stream", e);
		}
	}

	@Override
	public byte[] executeForString(String code) {
		try (InputStream input = new ByteArrayInputStream(code.getBytes(StandardCharsets.UTF_8))) {
			return RaungAsmExecutor.processInputStream(this, input, "<input>");
		} catch (RaungAsmException e) {
			throw e;
		} catch (Exception e) {
			throw new RaungAsmException("Failed to process input code", e);
		}
	}

	@Override
	public String toString() {
		return "RaungAsmArgs{input=" + inputs + ", output=" + output + '}';
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/RaungAsmExecutor.java`:

```java
package io.github.skylot.raung.asm.impl;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Objects;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;

import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.github.skylot.raung.asm.impl.asm.RaungAsmWriter;
import io.github.skylot.raung.asm.impl.parser.RaungParser;
import io.github.skylot.raung.asm.impl.parser.data.ClassData;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;
import io.github.skylot.raung.asm.impl.utils.ValidateAsmArgs;
import io.github.skylot.raung.common.utils.FileUtils;

public class RaungAsmExecutor {
	private static final Logger LOG = LoggerFactory.getLogger(RaungAsmExecutor.class);

	public static void process(RaungAsmBuilder args) {
		ValidateAsmArgs.process(args);
		String ext = FileUtils.getExt(args.getOutput());
		if (ext == null) {
			saveToDir(args);
		} else {
			switch (ext) {
				case "jar":
					saveToJar(args);
					break;
				case "class":
					saveToClass(args);
					break;
			}
		}
	}

	public static byte[] processSingleClass(RaungAsmBuilder args, Path inputPath) {
		FileUtils.checkInputFile(inputPath);
		ValidateAsmArgs.processOptions(args);
		return runForSingleClass(args, inputPath).getBytes();
	}

	public static byte[] processInputStream(RaungAsmBuilder args, InputStream input, @Nullable String fileName) {
		ValidateAsmArgs.processOptions(args);
		return runForInputStream(args, input, fileName).getBytes();
	}

	public static ClassData runForSingleClass(RaungAsmBuilder args, Path inputPath) {
		try (InputStream input = Files.newInputStream(inputPath);
				RaungParser parser = new RaungParser(args, input, inputPath.toString())) {
			return RaungAsmWriter.buildCls(parser.parse());
		} catch (IOException e) {
			throw new RaungAsmException("Failed to assemble input", e);
		}
	}

	private static ClassData runForInputStream(RaungAsmBuilder args, InputStream input, @Nullable String fileName) {
		try (RaungParser parser = new RaungParser(args, input, fileName)) {
			return RaungAsmWriter.buildCls(parser.parse());
		} catch (IOException e) {
			throw new RaungAsmException("Failed to assemble input", e);
		}
	}

	private static void saveToDir(RaungAsmBuilder args) {
		throw new RaungAsmException("Not implemented yet");
	}

	private static void saveToClass(RaungAsmBuilder args) {
		Path input = args.getInputs().get(0);
		try {
			byte[] bytes = runForSingleClass(args, input).getBytes();
			Files.write(args.getOutput(), bytes, StandardOpenOption.CREATE, StandardOpenOption.WRITE);
		} catch (Exception e) {
			throw new RaungAsmException("Failed to save class file from " + input.toAbsolutePath(), e);
		}
	}

	private static void saveToJar(RaungAsmBuilder args) {
		Path jarPath = args.getOutput();
		LOG.info("Saving to jar: {}", jarPath);
		try (JarOutputStream jar = new JarOutputStream(Files.newOutputStream(args.getOutput()))) {
			for (Path input : args.getInputs()) {
				processInputForJar(input, jar, args);
			}
		} catch (IOException e) {
			throw new RaungAsmException("Process failed", e);
		}
	}

	private static void processInputForJar(Path input, JarOutputStream jar, RaungAsmBuilder args) throws IOException {
		Path resources = input.resolve("resources");
		boolean checkResources = Files.isDirectory(resources);
		for (Path file : FileUtils.expandDir(input)) {
			String ext = FileUtils.getExt(file);
			if (Objects.equals(ext, "raung")) {
				ClassData cls = runForSingleClass(args, file);
				JarEntry entry = new JarEntry(cls.getName() + ".class");
				jar.putNextEntry(entry);
				jar.write(cls.getBytes());
				jar.closeEntry();
			} else if (checkResources && file.startsWith(resources)) {
				Path resFile = resources.relativize(file);
				JarEntry entry = new JarEntry(resFile.toString());
				jar.putNextEntry(entry);
				jar.write(Files.readAllBytes(file));
				jar.closeEntry();
			}
		}
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/asm/InsnAnnotationNode.java`:

```java
package io.github.skylot.raung.asm.impl.asm;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AnnotationNode;

import io.github.skylot.raung.asm.impl.parser.data.TypeRefPathData;

public class InsnAnnotationNode extends AnnotationNode {
	private final boolean visible;
	private final TypeRefPathData pathData;

	public InsnAnnotationNode(String type, boolean visible, TypeRefPathData pathData) {
		super(Opcodes.ASM9, type);
		this.visible = visible;
		this.pathData = pathData;
	}

	public String getType() {
		return desc;
	}

	public boolean isVisible() {
		return visible;
	}

	public TypeRefPathData getPathData() {
		return pathData;
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/asm/RaungAsmWriter.java`:

```java
package io.github.skylot.raung.asm.impl.asm;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;

import io.github.skylot.raung.asm.impl.parser.data.ClassData;
import io.github.skylot.raung.asm.impl.parser.data.FieldData;
import io.github.skylot.raung.asm.impl.parser.data.MethodData;
import io.github.skylot.raung.asm.impl.parser.data.TypeRefPathData;

public class RaungAsmWriter {

	public static ClassData buildCls(ClassData cls) {
		ClassWriter cw = cls.visitCls();
		cw.visitEnd();
		return cls;
	}

	public static ClassWriter visitCls(ClassData cls) {
		ClassWriter cw = new RaungClassWriter(cls);
		int version = cls.getVersion() == 0 ? 52 : cls.getVersion();
		cw.visit(version, cls.getAccessFlags(), cls.getName(),
				cls.getSignature(), cls.getSuperCls(),
				cls.getInterfaces().toArray(new String[0]));
		String source = cls.getSource();
		if (source != null) {
			cw.visitSource(source, null);
		}
		return cw;
	}

	public static MethodVisitor visitMethod(MethodData mth) {
		ClassWriter cw = mth.getClassData().visitCls();
		return cw.visitMethod(mth.getAccessFlags(), mth.getName(), mth.getDescriptor(),
				mth.getSignature(), mth.getThrows().toArray(new String[0]));
	}

	public static FieldVisitor visitField(ClassWriter cw, FieldData field) {
		return cw.visitField(field.getAccessFlags(), field.getName(),
				field.getType(), field.getSignature(), field.getValue());
	}

	public static void attachInsnAnnotation(MethodData methodData, InsnAnnotationNode insnAnn) {
		TypeRefPathData pathData = insnAnn.getPathData();
		int typeRef = pathData.getTypeRef().getValue();
		AnnotationVisitor av = methodData.getAsmMethodVisitor()
				.visitInsnAnnotation(typeRef, pathData.getPath(), insnAnn.getType(), insnAnn.isVisible());
		insnAnn.accept(av);
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/asm/RaungClassWriter.java`:

```java
package io.github.skylot.raung.asm.impl.asm;

import org.objectweb.asm.ClassWriter;

import io.github.skylot.raung.asm.impl.parser.data.ClassData;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;

public class RaungClassWriter extends ClassWriter {

	public RaungClassWriter(ClassData cls) {
		super(cls.getAuto().getAsmComputeFlag());
	}

	/**
	 * Default implementation will try to load classes with `Class.forName()`
	 */
	@Override
	protected String getCommonSuperClass(String type1, String type2) {
		if (isJavaStdLib(type1) && isJavaStdLib(type2)) {
			return super.getCommonSuperClass(type1, type2);
		}
		// TODO: try to search and load these classes to get class hierarchy
		throw new RaungAsmException("Can't calculate common super class for types: " + type1 + " and " + type2
				+ ". Try to remove '.auto frames' and manually set '.max' and '.stack' directives.");
	}

	private boolean isJavaStdLib(String type) {
		return type.startsWith("java/");
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/RaungParser.java`:

```java
package io.github.skylot.raung.asm.impl.parser;

import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayDeque;
import java.util.Objects;
import java.util.Queue;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import io.github.skylot.raung.asm.impl.RaungAsmBuilder;
import io.github.skylot.raung.asm.impl.parser.RaungTokenizer.TokenType;
import io.github.skylot.raung.asm.impl.parser.data.ClassData;
import io.github.skylot.raung.asm.impl.parser.directives.ClassDirectives;
import io.github.skylot.raung.asm.impl.utils.AsmLibException;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;
import io.github.skylot.raung.asm.impl.utils.RaungAsmTokenException;
import io.github.skylot.raung.common.Directive;
import io.github.skylot.raung.common.RaungAccessFlags;

public class RaungParser implements Closeable {
	private final RaungAsmBuilder args;
	private final RaungTokenizer tokenizer;
	@Nullable
	private final String fileName;

	private final Queue<String> tokensAhead = new ArrayDeque<>();

	public RaungParser(RaungAsmBuilder args, InputStream in, @Nullable String fileName) {
		this.args = args;
		this.tokenizer = new RaungTokenizer(Objects.requireNonNull(in));
		this.fileName = fileName;
	}

	public ClassData parse() {
		try {
			ClassData classData = new ClassData();
			while (true) {
				Directive directive = readDirective();
				if (directive == null) {
					break;
				}
				ClassDirectives.process(directive, this, classData);
			}
			return classData;
		} catch (AsmLibException e) {
			throw new RaungAsmException(buildErrorMsg("Asm lib error", e, 0), e);
		} catch (RaungAsmTokenException e) {
			throw new RaungAsmException(buildErrorMsg("Parse error", e, e.getOffsetInToken()), e);
		} catch (Exception e) {
			throw new RaungAsmException(buildErrorMsg("Parse error", e, 0), e);
		}
	}

	@NotNull
	private String buildErrorMsg(String desc, Exception e, int offset) {
		return desc + "\n" + tokenizer.formatMsgForCurrentPosition(offset, e.getMessage(), fileName);
	}

	@Override
	public void close() throws IOException {
		tokenizer.close();
	}

	public RaungAsmBuilder getArgs() {
		return args;
	}

	private TokenType consumeNext() {
		if (!tokensAhead.isEmpty()) {
			return TokenType.TOKEN;
		}
		return tokenizer.next();
	}

	private String consumeToken() {
		if (!tokensAhead.isEmpty()) {
			return tokensAhead.poll();
		}
		return tokenizer.getToken();
	}

	private void pushTokenBack(String token) {
		tokensAhead.offer(token);
	}

	public void consumeToken(String expectedToken) {
		TokenType tokenType = consumeNext();
		if (tokenType != TokenType.TOKEN) {
			throw new RaungAsmException(String.format("Expected '%s', got '%s'", expectedToken, tokenType));
		}
		String token = consumeToken();
		if (!token.equals(expectedToken)) {
			throw new RaungAsmException(String.format("Expected '%s' instead '%s'", expectedToken, token));
		}
	}

	public String tryGetToken() {
		if (consumeNext() == TokenType.TOKEN) {
			return consumeToken();
		}
		return null;
	}

	public String peekToken() {
		String token = skipToToken();
		if (token != null) {
			pushTokenBack(token);
		}
		return token;
	}

	public boolean hasToken() {
		return consumeNext() == TokenType.TOKEN;
	}

	@Nullable
	public Directive readDirective() {
		String token = skipToToken();
		if (token == null) {
			return null;
		}
		Directive directive = Directive.parseToken(token);
		if (directive == null) {
			throw new RaungAsmException("Unknown directive", token);
		}
		return directive;
	}

	@Nullable
	public String skipToToken() {
		while (true) {
			TokenType tokenType = consumeNext();
			if (tokenType == TokenType.TOKEN) {
				return consumeToken();
			}
			if (tokenType == TokenType.FILE_END) {
				return null;
			}
		}
	}

	public String readToken() {
		TokenType tokenType = consumeNext();
		if (tokenType == TokenType.TOKEN) {
			return consumeToken();
		}
		throw new RaungAsmException("Expect token but got " + tokenType);
	}

	public String readType() {
		// TODO check type correctness
		return readToken();
	}

	public int readInt() {
		String token = readToken();
		try {
			return Integer.parseInt(token);
		} catch (NumberFormatException e) {
			throw new RaungAsmException("Expect integer number but got", token);
		}
	}

	public String readString() {
		String token = readToken();
		if (token.charAt(0) == '"') {
			token = token.substring(1);
		}
		int last = token.length() - 1;
		if (token.charAt(last) == '"') {
			token = token.substring(0, last);
		}
		return token;
	}

	public int readAccessFlags(RaungAccessFlags.Scope scope) {
		int accFlags = 0;
		while (true) {
			if (consumeNext() != TokenType.TOKEN) {
				break;
			}
			String token = consumeToken();
			int flag;
			if (token.startsWith("0x")) {
				flag = Integer.parseInt(token.substring(2), 16);
			} else {
				flag = RaungAccessFlags.parseToken(token, scope);
				if (flag == -1) {
					pushTokenBack(token);
					break;
				}
			}
			accFlags |= flag;
		}
		return accFlags;
	}

	public void lineEnd() {
		if (consumeNext() == TokenType.TOKEN) {
			throw new RaungAsmException("Unexpected token", consumeToken());
		}
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/RaungTokenizer.java`:

```java
package io.github.skylot.raung.asm.impl.parser;

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import io.github.skylot.raung.asm.impl.utils.RaungAsmException;

import static io.github.skylot.raung.common.utils.StringCommonUtils.repeat;

public class RaungTokenizer implements Closeable {

	private final Reader reader;
	private final StringBuilder lineBuffer = new StringBuilder();
	private final StringBuilder tokenBuffer = new StringBuilder();

	private State savedState = State.NONE;
	private int line = 1;
	private int column = 1;

	public RaungTokenizer(InputStream in) {
		this.reader = new BufferedReader(new InputStreamReader(in));
	}

	public String getToken() {
		return tokenBuffer.toString();
	}

	@Override
	public void close() throws IOException {
		reader.close();
	}

	public enum TokenType {
		LINE_END,
		FILE_END,
		TOKEN
	}

	public enum State {
		NONE,
		STRING,
		STRING_ESCAPE,
		COMMENT,
		TOKEN,
		AT_LINE_END,
		AT_FILE_END,
		AT_ASSIGN,
	}

	public TokenType next() {
		StringBuilder buf = this.tokenBuffer;
		buf.setLength(0);
		TokenType returnType = processSavedState();
		if (returnType != null) {
			return returnType;
		}
		State state = savedState;
		try {
			while (true) {
				int cp = reader.read();
				if (cp == -1) {
					if (state == State.TOKEN) {
						savedState = State.AT_FILE_END;
						return TokenType.TOKEN;
					}
					return TokenType.FILE_END;
				}
				column++;
				lineBuffer.appendCodePoint(cp);

				switch (cp) {
					case '\n':
					case '\r':
						return processEndLine(state, cp);

					case '#':
						state = processComment(buf, state);
						if (state == null) {
							return TokenType.TOKEN;
						}
						break;

					case '"':
						if (state != State.COMMENT) {
							buf.append('"');
							if (state == State.STRING) {
								savedState = State.NONE;
								return TokenType.TOKEN;
							}
							state = State.STRING;
						}
						break;

					case '\\':
						if (state == State.STRING_ESCAPE) {
							buf.append("\\\\"); // ignore this escape (will handle in value parser)
							state = State.STRING;
						} else {
							state = State.STRING_ESCAPE;
						}
						break;

					default:
						state = appendChar(buf, state, cp);
						if (state == null) {
							return TokenType.TOKEN;
						}
						break;
				}
			}
		} catch (IOException e) {
			throw new RaungAsmException("Read error", e);
		}
	}

	@Nullable
	private TokenType processSavedState() {
		switch (savedState) {
			case AT_FILE_END:
				savedState = State.NONE;
				return TokenType.FILE_END;

			case AT_LINE_END:
				savedState = State.NONE;
				newLine();
				return TokenType.LINE_END;

			case AT_ASSIGN:
				savedState = State.NONE;
				tokenBuffer.append('=');
				return TokenType.TOKEN;
		}
		return null;
	}

	@NotNull
	private TokenType processEndLine(State state, int cp) throws IOException {
		consumeCharIf(cp == '\n' ? '\r' : '\n');
		switch (state) {
			case COMMENT:
				savedState = State.AT_LINE_END;
				return TokenType.LINE_END;

			case TOKEN:
				savedState = State.AT_LINE_END;
				return TokenType.TOKEN;

			default:
				newLine();
				return TokenType.LINE_END;
		}
	}

	@Nullable
	private State processComment(StringBuilder buf, State state) {
		if (state == State.TOKEN) {
			savedState = State.COMMENT;
			return null;
		}
		if (state == State.STRING) {
			buf.append('#');
			return state;
		}
		return State.COMMENT;
	}

	@Nullable
	private State appendChar(StringBuilder buf, State state, int cp) {
		if (state == State.COMMENT) {
			// skip to line end
			return state;
		}
		if (state == State.STRING_ESCAPE) {
			buf.append('\\');
			state = State.STRING;
		}
		if (state == State.STRING) {
			if (cp < 0xFF) {
				buf.append((char) cp);
			} else {
				buf.append(new String(Character.toChars(cp)));
			}
			return state;
		}
		boolean space;
		if (cp < 0xFF) {
			char ch = (char) cp;
			if (ch == '=') {
				if (state == State.TOKEN) {
					savedState = State.AT_ASSIGN;
					return null;
				} else {
					buf.append(ch);
					return null;
				}
			}
			space = ch <= 32;
			if (!space) {
				buf.append(ch);
			}
		} else {
			space = Character.isWhitespace(cp);
			if (!space) {
				buf.append(new String(Character.toChars(cp)));
			}
		}
		if (state == State.TOKEN) {
			if (space) {
				return null;
			}
		} else {
			if (!space) {
				state = State.TOKEN;
			}
		}
		return state;
	}

	private void newLine() {
		line++;
		column = 1;
		lineBuffer.setLength(0);
	}

	private void consumeCharIf(char ch) throws IOException {
		Reader r = this.reader;
		r.mark(1);
		int cp = r.read();
		if (cp != ch) {
			r.reset();
		}
	}

	public String formatMsgForCurrentPosition(int offsetInToken, String msg, @Nullable String fileName) {
		int tokenLen = tokenBuffer.length();
		int lineOffset = column - tokenLen - 1 + offsetInToken;
		String lineNum = Integer.toString(line);
		String contextPadding = repeat(' ', lineNum.length() + 1) + '|';
		String markPadding = contextPadding + repeat(' ', lineOffset - 1);
		return repeat(' ', lineNum.length() + 1)
				+ "at " + fileName + ':' + lineNum + ':' + lineOffset + '\n'
				+ contextPadding + '\n'
				+ lineNum + " |" + readFullLine() + '\n'
				+ markPadding + '^' + repeat('~', tokenLen - 1 - offsetInToken) + '\n'
				+ markPadding + msg + '\n';
	}

	private String readFullLine() {
		if (savedState == State.AT_LINE_END || savedState == State.AT_FILE_END) {
			return lineBuffer.toString().replaceAll("[\n\r]", "");
		}
		try {
			while (true) {
				int cp = this.reader.read();
				if (cp == -1 || cp == '\n' || cp == '\r') {
					break;
				}
				lineBuffer.appendCodePoint(cp);
			}
		} catch (Exception e) {
			// ignore
		}
		return lineBuffer.toString();
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/code/AnnotationParser.java`:

```java
package io.github.skylot.raung.asm.impl.parser.code;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.TypePath;
import org.objectweb.asm.TypeReference;

import io.github.skylot.raung.asm.impl.asm.InsnAnnotationNode;
import io.github.skylot.raung.asm.impl.parser.RaungParser;
import io.github.skylot.raung.asm.impl.parser.data.CommonData;
import io.github.skylot.raung.asm.impl.parser.data.MethodData;
import io.github.skylot.raung.asm.impl.parser.data.TypeRefPathData;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;
import io.github.skylot.raung.common.AnnotationType;
import io.github.skylot.raung.common.asm.TypeRef;

import static io.github.skylot.raung.common.Directive.END;

public class AnnotationParser {

	public static void process(RaungParser parser, CommonData data) {
		boolean visible = parseVisibility(parser);
		String type = parser.readType();
		AnnotationVisitor av = data.visitAnnotation(type, visible);
		parse(av, parser, AnnotationType.NORMAL);
	}

	public static void processParamAnnotation(RaungParser parser, MethodData methodData) {
		int parameter = parser.readInt();
		boolean visible = parseVisibility(parser);
		String type = parser.readType();
		AnnotationVisitor av = methodData.getAsmMethodVisitor().visitParameterAnnotation(parameter, type, visible);
		parse(av, parser, AnnotationType.PARAM);
	}

	public static void processTypeAnnotation(RaungParser parser, CommonData data) {
		boolean visible = parseVisibility(parser);
		String type = parser.readType();
		parser.lineEnd();
		TypeRefPathData pathData = parseRef(parser);
		int typeRefValue = pathData.getTypeRef().getValue();
		AnnotationVisitor av = data.visitTypeAnnotation(typeRefValue, pathData.getPath(), type, visible);
		parse(av, parser, AnnotationType.TYPE);
	}

	public static void processInsnAnnotation(RaungParser parser, MethodData methodData) {
		boolean visible = parseVisibility(parser);
		String type = parser.readType();
		parser.lineEnd();
		TypeRefPathData pathData = parseRef(parser);
		InsnAnnotationNode av = new InsnAnnotationNode(type, visible, pathData);
		parse(av, parser, AnnotationType.INSN);
		methodData.setAnnotationForNextInsn(av);
	}

	public static void processAnnotationDefaultValue(RaungParser parser, MethodData methodData) {
		parser.lineEnd();
		AnnotationVisitor av = methodData.getAsmMethodVisitor().visitAnnotationDefault();
		// read only one value
		parseValue(av, parser, null);
		av.visitEnd();
		parser.lineEnd();
		parser.consumeToken(".end");
		parser.consumeToken(AnnotationType.DEFAULT.getName());
		parser.lineEnd();
	}

	private static boolean parseVisibility(RaungParser parser) {
		String visType = parser.readToken();
		switch (visType) {
			case "runtime":
				return true;
			case "build":
				return false;
			default:
				throw new RaungAsmException("Unknown annotation type '" + visType + "'. Expecting 'build' or 'runtime'");
		}
	}

	private static void parse(AnnotationVisitor av, RaungParser parser, AnnotationType type) {
		while (true) {
			String nameToken = parser.skipToToken();
			if (nameToken == null) {
				throw new RaungAsmException("Unexpected end of file");
			}
			if (nameToken.equals(END.token())) {
				parser.consumeToken(type.getName());
				av.visitEnd();
				parser.lineEnd();
				return;
			}
			if (nameToken.startsWith(".")) {
				processDirective(av, parser, nameToken);
			} else {
				parser.consumeToken("=");
				parseValue(av, parser, nameToken);
			}
			parser.lineEnd();
		}
	}

	private static void parseValue(AnnotationVisitor av, RaungParser parser, @Nullable String nameToken) {
		String valueToken = parser.readToken();
		if (valueToken.startsWith(".")) {
			processSubValue(av, parser, nameToken, valueToken);
		} else {
			av.visit(nameToken, ValueParser.process(valueToken));
		}
	}

	private static void processSubValue(AnnotationVisitor av, RaungParser parser, @Nullable String name, String valueToken) {
		switch (valueToken) {
			case ".enum":
				String owner = parser.readType();
				String value = parser.readToken();
				av.visitEnum(name, owner, value);
				break;

			case ".array":
				parser.lineEnd();
				AnnotationVisitor arrayVisitor = av.visitArray(name);
				parseSubArray(arrayVisitor, parser);
				arrayVisitor.visitEnd();
				break;

			default:
				throw new RaungAsmException("Unknown annotation sub value directive", valueToken);
		}
	}

	private static void processDirective(AnnotationVisitor av, RaungParser parser, String nameToken) {
		switch (nameToken) {

			default:
				throw new RaungAsmException("Unknown annotation directive", nameToken);
		}
	}

	private static TypeRefPathData parseRef(RaungParser parser) {
		parser.consumeToken(".ref");
		String refType = parser.readToken();
		TypeRef ref = TypeRef.getByName(refType);
		if (ref == null) {
			throw new RaungAsmException("Unknown type reference sort", refType);
		}
		int sort = ref.getValue();
		TypeRefPathData path = new TypeRefPathData();
		parseTypeReference(parser, ref, sort, path);
		String token = parser.tryGetToken();
		if (token != null) {
			path.setPath(TypePath.fromString(token));
			parser.lineEnd();
		}
		return path;
	}

	private static void parseTypeReference(RaungParser parser, TypeRef ref, int sort, TypeRefPathData path) {
		switch (ref.getFormat()) {
			case NO_ARGS:
				path.setTypeRef(TypeReference.newTypeReference(sort));
				break;
			case TYPE_PARAM_INDEX:
				path.setTypeRef(TypeReference.newTypeParameterReference(sort, parser.readInt()));
				break;
			case TYPE_PARAM_BOUND_INDEX:
				path.setTypeRef(TypeReference.newTypeParameterBoundReference(sort, parser.readInt(), parser.readInt()));
				break;
			case SUPER_TYPE_INDEX:
				path.setTypeRef(TypeReference.newSuperTypeReference(parser.readInt()));
				break;
			case FORMAL_PARAM_INDEX:
				path.setTypeRef(TypeReference.newFormalParameterReference(parser.readInt()));
				break;
			case EXCEPTION_INDEX:
				path.setTypeRef(TypeReference.newExceptionReference(parser.readInt()));
				break;
			case TRY_CATCH_BLOCK_INDEX:
				path.setTypeRef(TypeReference.newTryCatchReference(parser.readInt()));
				break;
			case TYPE_ARGUMENT_INDEX:
				path.setTypeRef(TypeReference.newTypeArgumentReference(sort, parser.readInt()));
				break;
		}
	}

	private static void parseSubArray(AnnotationVisitor av, RaungParser parser) {
		while (true) {
			String token = parser.readToken();
			if (token.startsWith(".")) {
				if (token.equals(END.token())) {
					parser.consumeToken("array");
					return;
				}
				processSubValue(av, parser, null, token);
			} else {
				av.visit(null, ValueParser.process(token));
			}
			parser.lineEnd();
		}
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/code/InvokeDynamicParser.java`:

```java
package io.github.skylot.raung.asm.impl.parser.code;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.Handle;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;

import io.github.skylot.raung.asm.impl.parser.RaungParser;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;
import io.github.skylot.raung.common.asm.HandleTag;

public class InvokeDynamicParser {

	public static void parse(MethodVisitor mv, RaungParser parser) {
		String name = parser.readToken();
		String descriptor = parser.readToken();
		Handle handle = null;
		List<Object> args = new ArrayList<>(3);
		while (true) {
			String token = parser.skipToToken();
			if (token == null) {
				throw new RaungAsmException("Missing '.end invokedynamic' directive");
			}
			if (token.equals(".end")) {
				parser.consumeToken("invokedynamic");
				break;
			}
			if (token.equals(".handle")) {
				handle = parseHandle(parser);
			} else if (token.equals(".arg")) {
				parseArg(parser, args);
			} else {
				throw new RaungAsmException("Unexpected token for 'invokedynamic' scope", token);
			}
		}
		mv.visitInvokeDynamicInsn(name, descriptor, handle, args.toArray(new Object[0]));
	}

	private static Handle parseHandle(RaungParser parser) {
		String tagStr = parser.readToken();
		HandleTag tag = HandleTag.getByName(tagStr);
		if (tag == null) {
			throw new RaungAsmException("Unknown handle tag", tagStr);
		}
		String owner = parser.readToken();
		String name = parser.readToken();
		String descriptor = parser.readToken();
		parser.lineEnd();
		boolean itf = tag == HandleTag.INVOKEINTERFACE;
		return new Handle(tag.getTag(), owner, name, descriptor, itf);
	}

	private static void parseArg(RaungParser parser, List<Object> args) {
		int index = parser.readInt();
		String token = parser.readToken();
		if (token.startsWith(".")) {
			switch (token) {
				case ".handle":
					args.add(index, parseHandle(parser));
					break;
				case ".methodtype":
					args.add(index, parseMethodType(parser));
					break;
				default:
					throw new RaungAsmException("Unknown directive for 'invokedynamic' scope", token);
			}
		} else {
			args.add(ValueParser.process(token));
		}
	}

	private static Type parseMethodType(RaungParser parser) {
		return Type.getMethodType(parser.readToken());
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/code/OpCodeParser.java`:

```java
package io.github.skylot.raung.asm.impl.parser.code;

import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import io.github.skylot.raung.asm.impl.parser.RaungParser;
import io.github.skylot.raung.asm.impl.parser.data.MethodData;
import io.github.skylot.raung.asm.impl.parser.data.RaungLabel;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;
import io.github.skylot.raung.common.JavaOpCodeFormat;
import io.github.skylot.raung.common.JavaOpCodes;

public class OpCodeParser {

	public static void process(MethodData mth, MethodVisitor mv, RaungParser parser, String token) {
		int opcode = JavaOpCodes.getOpcode(token);
		if (opcode == -1) {
			throw new RaungAsmException("Unknown opcode", token);
		}
		JavaOpCodeFormat format = JavaOpCodes.getFormat(opcode);
		parseOpcode(mth, mv, parser, opcode, token, format);
		parser.lineEnd();
		mth.addInsn();
	}

	private static void parseOpcode(MethodData mth, MethodVisitor mv, RaungParser parser,
			int opcode, String token, JavaOpCodeFormat format) {
		switch (format) {
			case NO_ARGS:
				mv.visitInsn(opcode);
				break;

			case INT:
				mv.visitIntInsn(opcode, parser.readInt());
				break;

			case TYPE:
				mv.visitTypeInsn(opcode, parser.readToken());
				break;

			case FIELD:
				mv.visitFieldInsn(opcode, parser.readToken(), parser.readToken(), parser.readToken());
				break;

			case METHOD:
				String owner = null;
				boolean isInterface = opcode == Opcodes.INVOKEINTERFACE;
				if (!isInterface) {
					// read optional 'interface' token
					String nextToken = parser.readToken();
					if (nextToken.equals("interface")) {
						isInterface = true;
					} else {
						owner = nextToken;
					}
				}
				if (owner == null) {
					owner = parser.readToken();
				}
				String name = parser.readToken();
				String descriptor = parser.readToken();
				mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
				break;

			case VAR:
				mv.visitVarInsn(opcode, parser.readInt());
				break;

			case JUMP:
				String labelName = parser.readToken();
				mv.visitJumpInsn(opcode, RaungLabel.ref(mth, labelName));
				break;

			case LDC:
				mv.visitLdcInsn(ValueParser.process(parser.readToken()));
				break;

			case IINC:
				mv.visitIincInsn(parser.readInt(), parser.readInt());
				break;

			case NEW_ARRAY:
				mv.visitIntInsn(Opcodes.NEWARRAY, parser.readInt());
				break;

			case NEW_MULTI_ARRAY:
				mv.visitMultiANewArrayInsn(parser.readType(), parser.readInt());
				break;

			case SWITCH:
				SwitchParser.parse(mth, mv, parser, token);
				break;

			case INVOKE_DYNAMIC:
				InvokeDynamicParser.parse(mv, parser);
				break;

			case UNKNOWN:
				throw new RaungAsmException("TODO: Missing format for opcode: "
						+ "0x" + Integer.toHexString(opcode) + " (" + JavaOpCodes.getName(opcode) + ")");

			default:
				throw new RaungAsmException("TODO: Missing parser for opcode: "
						+ "0x" + Integer.toHexString(opcode) + " (" + JavaOpCodes.getName(opcode) + ")");
		}
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/code/SwitchParser.java`:

```java
package io.github.skylot.raung.asm.impl.parser.code;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;

import io.github.skylot.raung.asm.impl.parser.RaungParser;
import io.github.skylot.raung.asm.impl.parser.data.MethodData;
import io.github.skylot.raung.asm.impl.parser.data.RaungLabel;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;

public class SwitchParser {

	public static void parse(MethodData mth, MethodVisitor mv, RaungParser parser, String token) {
		parser.lineEnd();
		Label defLabel = null;
		List<Integer> keys = new ArrayList<>();
		List<RaungLabel> labels = new ArrayList<>();
		while (true) {
			String key = parser.skipToToken();
			if (key == null) {
				throw new RaungAsmException("Missing switch end");
			}
			if (key.equals(".end")) {
				parser.consumeToken(token);
				break;
			}
			if (key.equals("default")) {
				defLabel = RaungLabel.ref(mth, parser.readToken());
			} else {
				keys.add(Integer.parseInt(key));
				labels.add(RaungLabel.ref(mth, parser.readToken()));
			}
		}
		if (defLabel == null) {
			throw new RaungAsmException("'default' case is required in switch");
		}
		int[] keysArr = toIntArray(keys);
		check(keysArr);
		Label[] labelsArr = labels.toArray(new Label[0]);

		boolean canUseTableSwitch = isTableSwitch(keysArr);
		boolean isTableSwitch = token.equals("tableswitch");
		if (isTableSwitch && !canUseTableSwitch) {
			throw new RaungAsmException("Can't use tableswitch, keys are not sequential");
		}
		boolean autoSwitch = token.equals("switch");
		if (isTableSwitch || (autoSwitch && canUseTableSwitch)) {
			int min = keysArr[0];
			int max = keysArr[keysArr.length - 1];
			mv.visitTableSwitchInsn(min, max, defLabel, labelsArr);
		} else {
			mv.visitLookupSwitchInsn(defLabel, keysArr, labelsArr);
		}
	}

	private static boolean isTableSwitch(int[] keys) {
		int last = keys.length - 1;
		for (int i = 0; i < last; i++) {
			int a = keys[i];
			int b = keys[i + 1];
			if (a + 1 != b) {
				return false;
			}
		}
		return true;
	}

	private static int[] toIntArray(List<Integer> list) {
		int size = list.size();
		int[] arr = new int[size];
		for (int i = 0; i < size; i++) {
			arr[i] = list.get(i);
		}
		return arr;
	}

	private static void check(int[] keys) {
		int last = keys.length - 1;
		for (int i = 0; i < last; i++) {
			int a = keys[i];
			int b = keys[i + 1];
			if (a == b) {
				throw new RaungAsmException("Switch keys should be different: " + a);
			}
			if (a > b) {
				throw new RaungAsmException("Switch keys should be sorted: " + a + " occur before " + b);
			}
		}
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/code/ValueParser.java`:

```java
package io.github.skylot.raung.asm.impl.parser.code;

import org.objectweb.asm.Type;

import io.github.skylot.raung.asm.impl.parser.utils.StringAsmUtils;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;

public class ValueParser {

	public static Object process(String token) {
		char firstChar = token.charAt(0);
		if (firstChar == '"') {
			// String
			return StringAsmUtils.unescapeString(token.substring(1, token.length() - 1));
		}
		if (firstChar == 'L') {
			// Object
			return Type.getObjectType(token.substring(1, token.length() - 1));
		}
		if (firstChar == '-' || firstChar == '+' || Character.isDigit(firstChar)) {
			if (token.endsWith("L")) {
				return Long.parseLong(token.substring(0, token.length() - 1));
			}
			if (token.endsWith("f")) {
				return Float.parseFloat(token.substring(0, token.length() - 1));
			}
			if (token.contains(".")) {
				return Double.parseDouble(token);
			}
			return Integer.parseInt(token);
		}
		int dotIdx = token.indexOf('.');
		if (dotIdx != -1) {
			if (dotIdx == token.length()) {
				throw new RaungAsmException("Unknown value format: " + token);
			}
			return parseSpecialValue(token.substring(0, dotIdx), token.substring(dotIdx + 1));
		}
		if (token.equals("true")) {
			return Boolean.TRUE;
		}
		if (token.equals("false")) {
			return Boolean.FALSE;
		}
		// TODO: type ??
		return Type.getObjectType(token);
	}

	private static Object parseSpecialValue(String type, String value) {
		switch (type) {
			case "Double":
				return parseSpecialDouble(value);
			case "Float":
				return parseSpecialFloat(value);

			default:
				throw new RaungAsmException("Unknown special value: " + type + "." + value);
		}
	}

	private static Object parseSpecialDouble(String value) {
		switch (value) {
			case "NaN":
				return Double.NaN;
			case "MAX_VALUE":
				return Double.MAX_VALUE;
			case "MIN_VALUE":
				return Double.MIN_VALUE;
			case "POSITIVE_INFINITY":
				return Double.POSITIVE_INFINITY;
			case "NEGATIVE_INFINITY":
				return Double.NEGATIVE_INFINITY;

			default:
				throw new RaungAsmException("Unknown Double special value: " + value);
		}
	}

	private static Object parseSpecialFloat(String value) {
		switch (value) {
			case "NaN":
				return Float.NaN;
			case "MAX_VALUE":
				return Float.MAX_VALUE;
			case "MIN_VALUE":
				return Float.MIN_VALUE;
			case "POSITIVE_INFINITY":
				return Float.POSITIVE_INFINITY;
			case "NEGATIVE_INFINITY":
				return Float.NEGATIVE_INFINITY;

			default:
				throw new RaungAsmException("Unknown Float special value: " + value);
		}
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/data/AutoOption.java`:

```java
package io.github.skylot.raung.asm.impl.parser.data;

import org.objectweb.asm.ClassWriter;

public enum AutoOption {
	DISABLE(0),
	MAXS(ClassWriter.COMPUTE_MAXS),
	FRAMES(ClassWriter.COMPUTE_FRAMES);

	private final int asmComputeFlag;

	AutoOption(int asmComputeFlag) {
		this.asmComputeFlag = asmComputeFlag;
	}

	public int getAsmComputeFlag() {
		return asmComputeFlag;
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/data/ClassData.java`:

```java
package io.github.skylot.raung.asm.impl.parser.data;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.TypePath;

import io.github.skylot.raung.asm.impl.asm.RaungAsmWriter;

public class ClassData extends CommonData {
	private ClassWriter classWriter;

	private int version;
	private String superCls;
	private final List<String> interfaces = new ArrayList<>();
	private String source;
	private AutoOption auto = AutoOption.DISABLE;

	private final List<FieldData> fields = new ArrayList<>();
	private final List<MethodData> methods = new ArrayList<>();

	public int getVersion() {
		return version;
	}

	public void setVersion(int version) {
		this.version = version;
	}

	public String getSuperCls() {
		if (superCls == null) {
			return "java/lang/Object";
		}
		return superCls;
	}

	public void setSuperCls(String superCls) {
		this.superCls = superCls;
	}

	public List<String> getInterfaces() {
		return interfaces;
	}

	public String getSource() {
		return source;
	}

	public void setSource(String source) {
		this.source = source;
	}

	public List<FieldData> getFields() {
		return fields;
	}

	public List<MethodData> getMethods() {
		return methods;
	}

	public byte[] getBytes() {
		return classWriter.toByteArray();
	}

	public boolean isVisited() {
		return classWriter != null;
	}

	public AutoOption getAuto() {
		return auto;
	}

	public void setAuto(AutoOption auto) {
		this.auto = auto;
	}

	public ClassWriter visitCls() {
		if (classWriter == null) {
			classWriter = RaungAsmWriter.visitCls(this);
		}
		return classWriter;
	}

	@Override
	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
		return visitCls().visitAnnotation(descriptor, visible);
	}

	@Override
	public AnnotationVisitor visitTypeAnnotation(int ref, TypePath path, String descriptor, boolean visible) {
		return visitCls().visitTypeAnnotation(ref, path, descriptor, visible);
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/data/CommonData.java`:

```java
package io.github.skylot.raung.asm.impl.parser.data;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.TypePath;

public abstract class CommonData {
	private int accessFlags;
	private String name;
	private String signature;

	public abstract AnnotationVisitor visitAnnotation(String descriptor, boolean visible);

	public abstract AnnotationVisitor visitTypeAnnotation(int ref, TypePath path, String descriptor, boolean visible);

	public String getSignature() {
		return signature;
	}

	public void setSignature(String signature) {
		this.signature = signature;
	}

	public int getAccessFlags() {
		return accessFlags;
	}

	public void setAccessFlags(int accessFlags) {
		this.accessFlags = accessFlags;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/data/FieldData.java`:

```java
package io.github.skylot.raung.asm.impl.parser.data;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.TypePath;

import io.github.skylot.raung.asm.impl.asm.RaungAsmWriter;

public class FieldData extends CommonData {
	private final ClassData classData;

	private String type;
	private Object value;

	private FieldVisitor fieldVisitor;

	public FieldData(ClassData classData) {
		this.classData = classData;
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	public Object getValue() {
		return value;
	}

	public void setValue(Object value) {
		this.value = value;
	}

	public boolean isVisited() {
		return fieldVisitor != null;
	}

	public FieldVisitor getAsmVisitor() {
		if (this.fieldVisitor == null) {
			this.fieldVisitor = RaungAsmWriter.visitField(classData.visitCls(), this);
		}
		return this.fieldVisitor;
	}

	@Override
	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
		return getAsmVisitor().visitAnnotation(descriptor, visible);
	}

	@Override
	public AnnotationVisitor visitTypeAnnotation(int ref, TypePath path, String descriptor, boolean visible) {
		return getAsmVisitor().visitTypeAnnotation(ref, path, descriptor, visible);
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/data/MethodData.java`:

```java
package io.github.skylot.raung.asm.impl.parser.data;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.TypePath;

import io.github.skylot.raung.asm.impl.asm.InsnAnnotationNode;
import io.github.skylot.raung.asm.impl.asm.RaungAsmWriter;

public class MethodData extends CommonData {
	private final ClassData classData;

	private String descriptor;
	private final List<String> throwsList = new ArrayList<>();
	private int maxStack = 0;
	private int maxLocals = 0;

	private MethodVisitor methodVisitor;
	private int insnsCount = 0;

	private Map<Integer, RaungLocalVar> localVars;
	private final List<RaungLabel> labels = new ArrayList<>();
	private final List<TryCatchBlock> catchBlocks = new ArrayList<>();
	private final Map<String, RaungLabel> labelsMap = new HashMap<>();
	private InsnAnnotationNode insnAnnotationNode;

	public MethodData(ClassData classData) {
		this.classData = classData;
	}

	public int getMaxStack() {
		return maxStack;
	}

	public void setMaxStack(int maxStack) {
		this.maxStack = maxStack;
	}

	public int getMaxLocals() {
		return maxLocals;
	}

	public void setMaxLocals(int maxLocals) {
		this.maxLocals = maxLocals;
	}

	public ClassData getClassData() {
		return classData;
	}

	public MethodVisitor getAsmMethodVisitor() {
		if (methodVisitor == null) {
			this.methodVisitor = RaungAsmWriter.visitMethod(this);
		}
		return methodVisitor;
	}

	public String getDescriptor() {
		return descriptor;
	}

	public void setDescriptor(String descriptor) {
		this.descriptor = descriptor;
	}

	public List<String> getThrows() {
		return throwsList;
	}

	public void addThrow(String type) {
		this.throwsList.add(type);
	}

	public int getInsnsCount() {
		return insnsCount;
	}

	public void addInsn() {
		insnsCount++;
		if (insnAnnotationNode != null) {
			RaungAsmWriter.attachInsnAnnotation(this, insnAnnotationNode);
			insnAnnotationNode = null;
		}
	}

	public void addLocalVar(RaungLocalVar localVar) {
		if (localVars == null) {
			localVars = new HashMap<>();
		}
		localVars.put(localVar.getNumber(), localVar);
	}

	@Nullable
	public RaungLocalVar getLocalVar(int number) {
		if (this.localVars == null) {
			return null;
		}
		return this.localVars.get(number);
	}

	public Collection<RaungLocalVar> getLocalVars() {
		if (this.localVars == null) {
			return Collections.emptyList();
		}
		return this.localVars.values();
	}

	public void addLabel(RaungLabel label) {
		this.labels.add(label);
		this.labelsMap.put(label.getName(), label);
	}

	@Nullable
	public RaungLabel getLabel(String name) {
		return this.labelsMap.get(name);
	}

	@Nullable
	public RaungLabel getLabel(int pos) {
		for (RaungLabel label : this.labels) {
			if (label.getPos() == pos) {
				return label;
			}
		}
		return null;
	}

	public List<RaungLabel> getLabels() {
		return labels;
	}

	public void setAnnotationForNextInsn(InsnAnnotationNode annotationNode) {
		this.insnAnnotationNode = annotationNode;
	}

	public InsnAnnotationNode getInsnAnnotationNode() {
		return insnAnnotationNode;
	}

	public void addTryCatchBlock(TryCatchBlock tryCatchBlock) {
		this.catchBlocks.add(tryCatchBlock);
	}

	public List<TryCatchBlock> getCatchBlocks() {
		return catchBlocks;
	}

	@Override
	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
		return getAsmMethodVisitor().visitAnnotation(descriptor, visible);
	}

	@Override
	public AnnotationVisitor visitTypeAnnotation(int ref, TypePath path, String descriptor, boolean visible) {
		return getAsmMethodVisitor().visitTypeAnnotation(ref, path, descriptor, visible);
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/data/RaungLabel.java`:

```java
package io.github.skylot.raung.asm.impl.parser.data;

import org.objectweb.asm.Label;

public class RaungLabel extends Label {
	private final String name;
	private int pos = -1;

	public static RaungLabel makeNew(MethodData mth, String labelName) {
		RaungLabel label = new RaungLabel(labelName);
		mth.addLabel(label);
		return label;
	}

	public static RaungLabel ref(MethodData mth, String labelName) {
		RaungLabel existLabel = mth.getLabel(labelName);
		if (existLabel != null) {
			return existLabel;
		}
		return makeNew(mth, labelName);
	}

	private RaungLabel(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public int getPos() {
		return pos;
	}

	public void setPos(int pos) {
		this.pos = pos;
	}

	@Override
	public String toString() {
		return "Label{" + name + " at " + pos + '}';
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/data/RaungLocalVar.java`:

```java
package io.github.skylot.raung.asm.impl.parser.data;

import org.jetbrains.annotations.Nullable;

public class RaungLocalVar {
	private final int number;
	private final String name;
	private final String type;
	@Nullable
	private final String signature;

	private final RaungLabel startLabel;

	private boolean visited;

	public RaungLocalVar(int number, String name, String type, @Nullable String signature, RaungLabel startLabel) {
		this.number = number;
		this.name = name;
		this.type = type;
		this.signature = signature;
		this.startLabel = startLabel;
	}

	public int getNumber() {
		return number;
	}

	public String getName() {
		return name;
	}

	public String getType() {
		return type;
	}

	public String getSignature() {
		return signature;
	}

	public RaungLabel getStartLabel() {
		return startLabel;
	}

	public boolean isVisited() {
		return visited;
	}

	public void setVisited(boolean visited) {
		this.visited = visited;
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/data/TryCatchBlock.java`:

```java
package io.github.skylot.raung.asm.impl.parser.data;

public class TryCatchBlock implements Comparable<TryCatchBlock> {
	private final int id;
	private final RaungLabel start;
	private final RaungLabel end;
	private final RaungLabel handler;
	private final String type;

	public TryCatchBlock(int id, RaungLabel start, RaungLabel end, RaungLabel handler, String type) {
		this.id = id;
		this.start = start;
		this.end = end;
		this.handler = handler;
		this.type = type;
	}

	public int getId() {
		return id;
	}

	public RaungLabel getStart() {
		return start;
	}

	public RaungLabel getEnd() {
		return end;
	}

	public RaungLabel getHandler() {
		return handler;
	}

	public String getType() {
		return type;
	}

	@Override
	public int compareTo(TryCatchBlock other) {
		return Integer.compare(this.id, other.id);
	}

	@Override
	public String toString() {
		return "TryCatchBlock{id=" + id
				+ ", start=" + start + ", end=" + end
				+ ", handler=" + handler + ", type='" + type + "'}";
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/data/TypeRefPathData.java`:

```java
package io.github.skylot.raung.asm.impl.parser.data;

import org.objectweb.asm.TypePath;
import org.objectweb.asm.TypeReference;

public class TypeRefPathData {
	private TypeReference typeRef;
	private TypePath path;

	public TypeReference getTypeRef() {
		return typeRef;
	}

	public void setTypeRef(TypeReference typeRef) {
		this.typeRef = typeRef;
	}

	public TypePath getPath() {
		return path;
	}

	public void setPath(TypePath path) {
		this.path = path;
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/directives/ClassDirectives.java`:

```java
package io.github.skylot.raung.asm.impl.parser.directives;

import java.util.EnumMap;
import java.util.Map;

import io.github.skylot.raung.asm.impl.parser.RaungParser;
import io.github.skylot.raung.asm.impl.parser.code.AnnotationParser;
import io.github.skylot.raung.asm.impl.parser.data.AutoOption;
import io.github.skylot.raung.asm.impl.parser.data.ClassData;
import io.github.skylot.raung.asm.impl.parser.data.FieldData;
import io.github.skylot.raung.asm.impl.parser.data.MethodData;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;
import io.github.skylot.raung.common.Directive;
import io.github.skylot.raung.common.RaungAccessFlags.Scope;
import io.github.skylot.raung.common.utils.JavaVersion;

import static io.github.skylot.raung.common.Directive.ANNOTATION;
import static io.github.skylot.raung.common.Directive.AUTO;
import static io.github.skylot.raung.common.Directive.CLASS;
import static io.github.skylot.raung.common.Directive.FIELD;
import static io.github.skylot.raung.common.Directive.IMPLEMENTS;
import static io.github.skylot.raung.common.Directive.INNERCLASS;
import static io.github.skylot.raung.common.Directive.METHOD;
import static io.github.skylot.raung.common.Directive.NEST;
import static io.github.skylot.raung.common.Directive.OUTERCLASS;
import static io.github.skylot.raung.common.Directive.SIGNATURE;
import static io.github.skylot.raung.common.Directive.SOURCE;
import static io.github.skylot.raung.common.Directive.SUPER;
import static io.github.skylot.raung.common.Directive.TYPE_ANNOTATION;
import static io.github.skylot.raung.common.Directive.VERSION;

public class ClassDirectives {

	private static final Map<Directive, IDirectivesProcessor<ClassData>> PROCESSOR_MAP;

	static {
		Map<Directive, IDirectivesProcessor<ClassData>> map = new EnumMap<>(Directive.class);
		map.put(VERSION, ClassDirectives::processVersion);
		map.put(CLASS, ClassDirectives::processClass);
		map.put(SUPER, ClassDirectives::processSuper);
		map.put(IMPLEMENTS, ClassDirectives::processInterface);
		map.put(SIGNATURE, ClassDirectives::processSignature);
		map.put(INNERCLASS, ClassDirectives::processInnerClass);
		map.put(OUTERCLASS, ClassDirectives::processOuterClass);
		map.put(NEST, ClassDirectives::processNest);
		map.put(SOURCE, ClassDirectives::processSource);
		map.put(AUTO, ClassDirectives::processAuto);
		map.put(FIELD, ClassDirectives::processField);
		map.put(METHOD, ClassDirectives::processMethod);
		map.put(ANNOTATION, AnnotationParser::process);
		map.put(TYPE_ANNOTATION, AnnotationParser::processTypeAnnotation);
		PROCESSOR_MAP = map;
	}

	public static void process(Directive token, RaungParser parser, ClassData cw) {
		IDirectivesProcessor<ClassData> processor = PROCESSOR_MAP.get(token);
		if (processor == null) {
			throw new RaungAsmException("Unexpected class directive", token.token());
		}
		processor.process(parser, cw);
	}

	private static void processVersion(RaungParser parser, ClassData classData) {
		checkClassHeader(classData, VERSION);
		int clsVersion;
		String version = "";
		try {
			version = parser.readToken();
			int point = version.indexOf('.');
			if (point == -1) {
				clsVersion = Integer.parseInt(version);
			} else {
				int major = Integer.parseInt(version.substring(0, point));
				int minor = Integer.parseInt(version.substring(point + 1));
				clsVersion = JavaVersion.getRaw(major, minor);
			}
			classData.setVersion(clsVersion);
		} catch (Exception e) {
			throw new RaungAsmException("Failed to parse class version number: " + version, e);
		}
		parser.lineEnd();
	}

	private static void processClass(RaungParser parser, ClassData classData) {
		checkClassHeader(classData, CLASS);
		classData.setAccessFlags(parser.readAccessFlags(Scope.CLASS));
		classData.setName(parser.readToken());
		parser.lineEnd();
	}

	private static void processSuper(RaungParser parser, ClassData classData) {
		checkClassHeader(classData, SUPER);
		classData.setSuperCls(parser.readType());
		parser.lineEnd();
	}

	private static void processInterface(RaungParser parser, ClassData classData) {
		checkClassHeader(classData, INNERCLASS);
		classData.getInterfaces().add(parser.readType());
		parser.lineEnd();
	}

	private static void processSignature(RaungParser parser, ClassData classData) {
		checkClassHeader(classData, SIGNATURE);
		classData.setSignature(parser.readToken());
		parser.lineEnd();
	}

	private static void processSource(RaungParser parser, ClassData classData) {
		checkClassHeader(classData, SOURCE);
		classData.setSource(parser.readString());
		parser.lineEnd();
	}

	private static void processInnerClass(RaungParser parser, ClassData classData) {
		int accessFlags = parser.readAccessFlags(Scope.CLASS);
		String inner = parser.readToken();
		String outer = parser.readType();
		String name = parser.tryGetToken();
		if (name != null) {
			parser.lineEnd();
		} else {
			name = classData.getName();
		}
		classData.visitCls().visitInnerClass(name, outer, inner, accessFlags);
	}

	private static void processOuterClass(RaungParser parser, ClassData classData) {
		String owner = parser.readType();
		String name = parser.readToken();
		String descriptor = parser.readToken();
		classData.visitCls().visitOuterClass(owner, name, descriptor);
	}

	private static void processAuto(RaungParser parser, ClassData classData) {
		checkClassHeader(classData, AUTO);
		String token = parser.readToken();
		switch (token) {
			case "disable":
				classData.setAuto(AutoOption.DISABLE);
				break;
			case "maxs":
				classData.setAuto(AutoOption.MAXS);
				break;
			case "frames":
				classData.setAuto(AutoOption.FRAMES);
				break;

			default:
				throw new RaungAsmException("Unknown auto type: " + token + ", should be one of: 'disable', 'maxs' or 'frames'");
		}
	}

	private static void checkClassHeader(ClassData classData, Directive directive) {
		if (classData.isVisited()) {
			throw new RaungAsmException(directive.token() + " directive should be placed before class body (i.e fields or methods)");
		}
	}

	private static void processNest(RaungParser parser, ClassData classData) {
		String ref = parser.readToken();
		switch (ref) {
			case "host":
				classData.visitCls().visitNestHost(parser.readType());
				break;
			case "member":
				classData.visitCls().visitNestMember(parser.readType());
				break;
			default:
				throw new RaungAsmException("Unknown nest ref type: '" + ref + "', expected 'host' or 'member'");
		}
	}

	private static void processField(RaungParser parser, ClassData classData) {
		FieldData field = FieldDirectives.parseField(classData, parser);
		classData.getFields().add(field);
	}

	private static void processMethod(RaungParser parser, ClassData classData) {
		classData.visitCls();
		MethodData mth = MethodDirectives.parseMethod(classData, parser);
		classData.getMethods().add(mth);
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/directives/FieldDirectives.java`:

```java
package io.github.skylot.raung.asm.impl.parser.directives;

import java.util.EnumMap;
import java.util.Map;

import io.github.skylot.raung.asm.impl.parser.RaungParser;
import io.github.skylot.raung.asm.impl.parser.code.AnnotationParser;
import io.github.skylot.raung.asm.impl.parser.code.ValueParser;
import io.github.skylot.raung.asm.impl.parser.data.ClassData;
import io.github.skylot.raung.asm.impl.parser.data.FieldData;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;
import io.github.skylot.raung.common.Directive;
import io.github.skylot.raung.common.RaungAccessFlags.Scope;

import static io.github.skylot.raung.common.Directive.ANNOTATION;
import static io.github.skylot.raung.common.Directive.END;
import static io.github.skylot.raung.common.Directive.SIGNATURE;
import static io.github.skylot.raung.common.Directive.TYPE_ANNOTATION;

public class FieldDirectives {

	private static final Map<Directive, IDirectivesProcessor<FieldData>> PROCESSOR_MAP;

	static {
		Map<Directive, IDirectivesProcessor<FieldData>> map = new EnumMap<>(Directive.class);
		map.put(SIGNATURE, FieldDirectives::processSignature);
		map.put(ANNOTATION, AnnotationParser::process);
		map.put(TYPE_ANNOTATION, AnnotationParser::processTypeAnnotation);
		PROCESSOR_MAP = map;
	}

	public static FieldData parseField(ClassData classData, RaungParser parser) {
		FieldData field = new FieldData(classData);
		field.setAccessFlags(parser.readAccessFlags(Scope.FIELD));
		field.setName(parser.readToken());
		field.setType(parser.readType());
		String assign = parser.tryGetToken();
		if (assign != null) {
			if (!assign.equals("=")) {
				throw new RaungAsmException("Unexpected token after field definition", assign);
			}
			Object value = ValueParser.process(parser.readToken());
			field.setValue(value);
			parser.lineEnd();
		}
		parseDirectives(parser, field);
		field.getAsmVisitor().visitEnd();
		return field;
	}

	private static void parseDirectives(RaungParser parser, FieldData field) {
		String token = parser.peekToken();
		if (token == null) {
			return;
		}
		Directive nextToken = Directive.parseToken(token);
		if (nextToken == null || !nextToken.isAllowedInField()) {
			return;
		}
		while (true) {
			Directive directive = parser.readDirective();
			if (directive == null) {
				return;
			}
			if (directive == END) {
				parser.consumeToken("field");
				parser.lineEnd();
				return;
			}
			if (!directive.isAllowedInField()) {
				throw new RaungAsmException("Directive '" + directive.token() + "' not allowed in field scope");
			}
			process(directive, parser, field);
		}
	}

	private static void process(Directive token, RaungParser parser, FieldData cw) {
		IDirectivesProcessor<FieldData> processor = PROCESSOR_MAP.get(token);
		if (processor == null) {
			throw new RaungAsmException("Unexpected field directive", token.token());
		}
		processor.process(parser, cw);
	}

	private static void processSignature(RaungParser parser, FieldData field) {
		field.setSignature(parser.readToken());
		parser.lineEnd();
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/directives/IDirectivesProcessor.java`:

```java
package io.github.skylot.raung.asm.impl.parser.directives;

import io.github.skylot.raung.asm.impl.parser.RaungParser;

public interface IDirectivesProcessor<T> {
	void process(RaungParser parser, T writer);
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/directives/MethodDirectives.java`:

```java
package io.github.skylot.raung.asm.impl.parser.directives;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import io.github.skylot.raung.asm.impl.parser.RaungParser;
import io.github.skylot.raung.asm.impl.parser.code.AnnotationParser;
import io.github.skylot.raung.asm.impl.parser.code.OpCodeParser;
import io.github.skylot.raung.asm.impl.parser.data.ClassData;
import io.github.skylot.raung.asm.impl.parser.data.MethodData;
import io.github.skylot.raung.asm.impl.parser.data.RaungLabel;
import io.github.skylot.raung.asm.impl.parser.data.RaungLocalVar;
import io.github.skylot.raung.asm.impl.parser.data.TryCatchBlock;
import io.github.skylot.raung.asm.impl.utils.AsmLibException;
import io.github.skylot.raung.asm.impl.utils.RaungAsmException;
import io.github.skylot.raung.common.Directive;
import io.github.skylot.raung.common.RaungAccessFlags.Scope;
import io.github.skylot.raung.common.asm.StackType;

import static io.github.skylot.raung.common.Directive.ANNOTATION;
import static io.github.skylot.raung.common.Directive.ANNOTATION_DEFAULT_VALUE;
import static io.github.skylot.raung.common.Directive.CATCH;
import static io.github.skylot.raung.common.Directive.END;
import static io.github.skylot.raung.common.Directive.INSN_ANNOTATION;
import static io.github.skylot.raung.common.Directive.LINE;
import static io.github.skylot.raung.common.Directive.LOCAL;
import static io.github.skylot.raung.common.Directive.MAX;
import static io.github.skylot.raung.common.Directive.PARAM;
import static io.github.skylot.raung.common.Directive.PARAM_ANNOTATION;
import static io.github.skylot.raung.common.Directive.SIGNATURE;
import static io.github.skylot.raung.common.Directive.STACK;
import static io.github.skylot.raung.common.Directive.THROW;
import static io.github.skylot.raung.common.Directive.TYPE_ANNOTATION;

public class MethodDirectives {

	private static final Map<Directive, IDirectivesProcessor<MethodData>> PROCESSOR_MAP;

	static {
		Map<Directive, IDirectivesProcessor<MethodData>> map = new EnumMap<>(Directive.class);
		map.put(THROW, MethodDirectives::processThrows);
		map.put(SIGNATURE, MethodDirectives::processSignature);
		map.put(MAX, MethodDirectives::processMax);
		map.put(LINE, MethodDirectives::processLine);
		map.put(LOCAL, MethodDirectives::processLocal);
		map.put(PARAM, MethodDirectives::processParam);
		map.put(STACK, MethodDirectives::processStack);
		map.put(CATCH, MethodDirectives::processCatch);
		map.put(ANNOTATION, AnnotationParser::process);
		map.put(TYPE_ANNOTATION, AnnotationParser::processTypeAnnotation);
		map.put(PARAM_ANNOTATION, AnnotationParser::processParamAnnotation);
		map.put(INSN_ANNOTATION, AnnotationParser::processInsnAnnotation);
		map.put(ANNOTATION_DEFAULT_VALUE, AnnotationParser::processAnnotationDefaultValue);
		PROCESSOR_MAP = map;
	}

	public static MethodData parseMethod(ClassData classData, RaungParser parser) {
		MethodData mth = new MethodData(classData);
		mth.setAccessFlags(parser.readAccessFlags(Scope.METHOD));
		String nameToken = parser.readToken();
		int argsStart = nameToken.indexOf('(');
		if (argsStart == -1) {
			throw new RaungAsmException("Incorrect method description", nameToken);
		}
		mth.setName(nameToken.substring(0, argsStart));
		mth.setDescriptor(nameToken.substring(argsStart));
		parser.lineEnd();
		while (true) {
			String token = parser.skipToToken();
			if (token == null) {
				throw new RaungAsmException("Unexpected method end");
			}
			switch (token.charAt(0)) {
				case '.':
					Directive directive = Directive.parseToken(token);
					if (directive == null) {
						throw new RaungAsmException("Unknown directive", token);
					}
					if (directive == END) {
						if (processEnd(mth, parser)) {
							return mth;
						}
					} else {
						process(directive, parser, mth);
					}
					break;

				case ':':
					processLabel(mth, parser, token);
					break;

				default:
					OpCodeParser.process(mth, mth.getAsmMethodVisitor(), parser, token);
					break;
			}
		}
	}

	private static boolean processEnd(MethodData mth, RaungParser parser) {
		String token = parser.readToken();
		switch (token) {
			case "local":
				processLocalEnd(parser, mth);
				return false;

			case "method":
				processMethodEnd(mth);
				return true;

			default:
				throw new RaungAsmException("Unexpected token for .end", token);
		}
	}

	private static void process(Directive token, RaungParser parser, MethodData methodData) {
		IDirectivesProcessor<MethodData> processor = PROCESSOR_MAP.get(token);
		if (processor == null) {
			throw new RaungAsmException("Not a method directive", token.token());
		}
		processor.process(parser, methodData);
	}

	private static void processThrows(RaungParser parser, MethodData methodData) {
		methodData.addThrow(parser.readType());
		parser.lineEnd();
	}

	private static void processSignature(RaungParser parser, MethodData methodData) {
		methodData.setSignature(parser.readToken());
		parser.lineEnd();
	}

	private static void processMax(RaungParser parser, MethodData methodData) {
		String type = parser.readToken();
		switch (type) {
			case "stack":
				methodData.setMaxStack(parser.readInt());
				break;
			case "locals":
				methodData.setMaxLocals(parser.readInt());
				break;
			default:
				throw new RaungAsmException("Unknown max type: '" + type + "'. Should be 'stack' or 'locals'");
		}
		parser.lineEnd();
	}

	private static void processParam(RaungParser parser, MethodData methodData) {
		int flags = parser.readAccessFlags(Scope.PARAM);
		String name = parser.readToken();
		parser.lineEnd();
		methodData.getAsmMethodVisitor().visitParameter(name, flags);
	}

	private static void processLocal(RaungParser parser, MethodData methodData) {
		int varNum = parser.readInt();
		String name = parser.readString();
		String type = parser.readToken();
		String signature = parser.tryGetToken();
		if (signature != null) {
			parser.lineEnd();
		}
		RaungLabel startLabel = attachLabel(methodData, null);
		methodData.addLocalVar(new RaungLocalVar(varNum, name, type, signature, startLabel));
	}

	private static void processLocalEnd(RaungParser parser, MethodData methodData) {
		int varNum = parser.readInt();
		parser.lineEnd();
		RaungLabel endLabel = attachLabel(methodData, null);
		RaungLocalVar localVar = methodData.getLocalVar(varNum);
		if (localVar == null) {
			throw new RaungAsmException("Unknown local variable with number: " + varNum);
		}
		visitLocalVar(methodData, localVar, endLabel);
	}

	private static void visitLocalVar(MethodData methodData, RaungLocalVar localVar, RaungLabel endLabel) {
		methodData.getAsmMethodVisitor().visitLocalVariable(localVar.getName(), localVar.getType(),
				localVar.getSignature(), localVar.getStartLabel(), endLabel, localVar.getNumber());
		localVar.setVisited(true);
	}

	private static void processLine(RaungParser parser, MethodData methodData) {
		int line = parser.readInt();
		methodData.getAsmMethodVisitor().visitLineNumber(line, attachLabel(methodData, null));
		parser.lineEnd();
	}

	private static void processLabel(MethodData mth, RaungParser parser, String labelName) {
		parser.lineEnd();
		RaungLabel existLabel = mth.getLabel(labelName);
		if (existLabel != null) {
			if (existLabel.getPos() != -1) {
				throw new RaungAsmException("Label already defined with name: " + labelName);
			}
			visitLabel(mth, existLabel);
		} else {
			attachLabel(mth, labelName);
		}
	}

	private static RaungLabel attachLabel(MethodData mth, @Nullable String name) {
		int pos = mth.getInsnsCount();
		RaungLabel existLabel = mth.getLabel(pos);
		if (existLabel != null) {
			return existLabel;
		}
		String labelName;
		if (name != null) {
			labelName = name;
		} else {
			// internal label (don't appear in code)
			labelName = String.format("#L%d", pos);
		}
		RaungLabel label = RaungLabel.makeNew(mth, labelName);
		return visitLabel(mth, label);
	}

	private static RaungLabel visitLabel(MethodData mth, RaungLabel label) {
		label.setPos(mth.getInsnsCount());
		mth.getAsmMethodVisitor().visitLabel(label);
		return label;
	}

	private static void processMethodEnd(MethodData mth) {
		MethodVisitor mv = mth.getAsmMethodVisitor();
		visitTryCatchBlocks(mth);
		visitLocalVars(mth);
		try {
			mv.visitMaxs(mth.getMaxStack(), mth.getMaxLocals());
			mv.visitEnd();
		} catch (Exception e) {
			throw new AsmLibException("Failed to build method: " + mth.getName() + mth.getDescriptor()
					+ ". Error: " + e.getMessage(), e);
		}
	}

	private static void visitTryCatchBlocks(MethodData mth) {
		List<TryCatchBlock> tryCatchBlocks = mth.getCatchBlocks();
		if (tryCatchBlocks.isEmpty()) {
			return;
		}
		Collections.sort(tryCatchBlocks);
		MethodVisitor visitor = mth.getAsmMethodVisitor();
		for (TryCatchBlock tcb : tryCatchBlocks) {
			visitor.visitTryCatchBlock(tcb.getStart(), tcb.getEnd(), tcb.getHandler(), tcb.getType());
		}
	}

	private static void visitLocalVars(MethodData mth) {
		List<RaungLocalVar> notVisitedLocalVars = mth.getLocalVars().stream()
				.filter(lv -> !lv.isVisited())
				.collect(Collectors.toList());
		if (notVisitedLocalVars.isEmpty()) {
			return;
		}
		RaungLabel endLabel = attachLabel(mth, null);
		for (RaungLocalVar localVar : notVisitedLocalVars) {
			if (!localVar.isVisited()) {
				visitLocalVar(mth, localVar, endLabel);
			}
		}
	}

	private static void processStack(RaungParser parser, MethodData methodData) {
		String type = parser.readToken();
		MethodVisitor mv = methodData.getAsmMethodVisitor();
		switch (type) {
			case "same":
				mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);
				break;

			case "same1":
				Object value = parseStackType(parser.readToken(), parser, methodData);
				mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { value });
				break;

			case "chop":
				mv.visitFrame(Opcodes.F_CHOP, parser.readInt(), null, 0, null);
				break;

			case "append": {
				parser.lineEnd();
				List<Object> locals = new ArrayList<>();
				while (true) {
					String token = parser.skipToToken();
					if (token == null) {
						throw new RaungAsmException("Unexpected end of .stack directive");
					}
					if (token.equals(".end")) {
						parser.consumeToken("stack");
						break;
					}
					locals.add(parseStackType(token, parser, methodData));
				}
				mv.visitFrame(Opcodes.F_APPEND, locals.size(), locals.toArray(new Object[0]), 0, null);
				break;
			}
			case "full": {
				parseCompleteFrame(Opcodes.F_FULL, parser, methodData, mv);
				break;
			}
			case "new": {
				parseCompleteFrame(Opcodes.F_NEW, parser, methodData, mv);
				break;
			}

			default:
				throw new RaungAsmException("Unexpected stack type: " + type);
		}
		parser.lineEnd();
	}

	private static void parseCompleteFrame(int frameType, RaungParser parser, MethodData methodData, MethodVisitor mv) {
		parser.lineEnd();
		List<Object> locals = new ArrayList<>();
		List<Object> stack = new ArrayList<>();
		while (true) {
			String token = parser.skipToToken();
			if (token == null) {
				throw new RaungAsmException("Unexpected end of .stack directive");
			}
			if (token.equals(".end")) {
				parser.consumeToken("stack");
				break;
			}
			switch (token) {
				case "local":
					parser.readInt();
					locals.add(parseStackType(parser.readToken(), parser, methodData));
					break;
				case "stack":
					parser.readInt();
					stack.add(parseStackType(parser.readToken(), parser, methodData));
					break;
			}
			parser.lineEnd();
		}
		mv.visitFrame(frameType,
				locals.size(), locals.toArray(new Object[0]),
				stack.size(), stack.toArray(new Object[0]));
	}

	private static Object parseStackType(String token, RaungParser parser, MethodData methodData) {
		StackType type = StackType.getByName(token);
		if (type != null) {
			return type.getValue();
		}
		if (token.equals("Uninitialized")) {
			String label = parser.readToken();
			return RaungLabel.ref(methodData, label);
		}
		// should be type
		return token;
	}

	private static void processCatch(RaungParser parser, MethodData methodData) {
		int id;
		String typeStr;
		String token = parser.readToken();
		if (token.startsWith("@")) {
			id = Integer.parseInt(token.substring(1));
			typeStr = parser.readType();
		} else {
			id = Integer.MAX_VALUE;
			typeStr = token;
		}
		RaungLabel startLabel = RaungLabel.ref(methodData, parser.readToken());
		parser.consumeToken("..");
		RaungLabel endLabel = RaungLabel.ref(methodData, parser.readToken());
		parser.consumeToken("goto");
		RaungLabel handlerLabel = RaungLabel.ref(methodData, parser.readToken());
		String type = typeStr.equals("all") ? null : typeStr;
		methodData.addTryCatchBlock(new TryCatchBlock(id, startLabel, endLabel, handlerLabel, type));
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/parser/utils/StringAsmUtils.java`:

```java
package io.github.skylot.raung.asm.impl.parser.utils;

import io.github.skylot.raung.asm.impl.utils.RaungAsmTokenException;

public class StringAsmUtils {

	public static String unescapeString(String str) {
		int len = str.length();
		if (len == 0) {
			return "";
		}
		if (str.indexOf('\\') == -1) {
			return str;
		}
		StringBuilder sb = new StringBuilder();
		boolean escape = false;
		int offset = 0;
		while (offset < len) {
			int codePoint = str.codePointAt(offset);
			if (escape) {
				escape = false;
				if (codePoint == 'u') {
					offset += processUnicodeChar(str, offset, len, sb);
				} else {
					char c = processSingleChar(codePoint);
					if (c == 0) {
						String ch = new StringBuilder().appendCodePoint(codePoint).toString();
						throw new RaungAsmTokenException("Unexpected escape for char: " + ch, offset + 1);
					}
					sb.append(c);
					offset++;
				}
			} else {
				if (codePoint == '\\') {
					escape = true;
					offset++;
				} else {
					sb.appendCodePoint(codePoint);
					offset += Character.charCount(codePoint);
				}
			}
		}
		return sb.toString();
	}

	private static char processSingleChar(int codePoint) {
		switch (codePoint) {
			case 'n':
				return '\n';
			case 'r':
				return '\r';
			case 't':
				return '\t';
			case 'b':
				return '\b';
			case 'f':
				return '\f';
			case '\'':
				return '\'';
			case '\"':
				return '\"';
			case '\\':
				return '\\';
			default:
				return 0;
		}
	}

	private static int processUnicodeChar(String str, int offset, int len, StringBuilder sb) {
		int start = offset + 1;
		if (start + 4 > len) {
			throw new RaungAsmTokenException("Truncated unicode sequence", start);
		}
		String unicodeIdStr = str.substring(start, start + 4);
		try {
			int unicodeCodePoint = Integer.parseInt(unicodeIdStr, 16);
			sb.appendCodePoint(unicodeCodePoint);
			return 5;
		} catch (NumberFormatException e) {
			throw new RaungAsmTokenException("Malformed unicode number: " + unicodeIdStr, start + 1);
		}
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/utils/AsmLibException.java`:

```java
package io.github.skylot.raung.asm.impl.utils;

public class AsmLibException extends RuntimeException {
	public AsmLibException(String message, Throwable cause) {
		super(message, cause);
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/utils/RaungAsmException.java`:

```java
package io.github.skylot.raung.asm.impl.utils;

public class RaungAsmException extends RuntimeException {
	public RaungAsmException(String message) {
		super(message);
	}

	public RaungAsmException(String message, String token) {
		super(message + ": '" + token + "'");
	}

	public RaungAsmException(String message, Throwable cause) {
		super(message, cause);
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/utils/RaungAsmTokenException.java`:

```java
package io.github.skylot.raung.asm.impl.utils;

public class RaungAsmTokenException extends RuntimeException {
	private final int offsetInToken;

	public RaungAsmTokenException(String message, int offset) {
		super(message);
		this.offsetInToken = offset;
	}

	public int getOffsetInToken() {
		return offsetInToken;
	}
}

```

`raung-asm/src/main/java/io/github/skylot/raung/asm/impl/utils/ValidateAsmArgs.java`:

```java
package io.github.skylot.raung.asm.impl.utils;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.github.skylot.raung.asm.impl.RaungAsmBuilder;
import io.github.skylot.raung.common.utils.FileUtils;

public class ValidateAsmArgs {
	private static final Logger LOG = LoggerFactory.getLogger(ValidateAsmArgs.class);

	public static void process(RaungAsmBuilder args) {
		if (args.getInputs().isEmpty()) {
			throw new RaungAsmException("Empty inputs");
		}
		for (Path input : args.getInputs()) {
			if (!Files.exists(input)) {
				throw new RaungAsmException("Input not found: " + input.toAbsolutePath());
			}
		}
		Path output = args.getOutput();
		if (output == null) {
			args.output(getOutDirFromInputs(args.getInputs()));
		}
		processOptions(args);
	}

	public static void processOptions(RaungAsmBuilder args) {
		LOG.trace("Effective args: {}", args);
	}

	private static Path getOutDirFromInputs(List<Path> inputs) {
		Path input = inputs.get(0);
		Path parent = FileUtils.getParentDir(input);
		String fileName = input.getFileName().toString();
		Path candidate = parent.resolve(fileName + ".jar");
		if (!Files.exists(candidate)) {
			return candidate;
		}
		return parent.resolve(fileName + "-raung.jar");
	}
}

```

`raung-asm/src/test/java/io/github/skylot/raung/asm/tests/api/IntegrationTest.java`:

```java
package io.github.skylot.raung.asm.tests.api;

import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.util.TraceClassVisitor;

import io.github.skylot.raung.asm.RaungAsm;

import static org.assertj.core.api.Assertions.assertThat;

public class IntegrationTest {

	protected String asmCls() {
		String filePath = getTestPkg() + "/" + getTestName() + ".raung";
		String resPath = "/raung/" + filePath;
		InputStream stream = this.getClass().getResourceAsStream(resPath);
		assertThat(stream).describedAs("Raung file not found: %s", resPath).isNotNull();
		byte[] bytes = RaungAsm.create().executeForInputStream(stream);
		String result = parseWithASM(bytes);
		printCode(result);
		return result;
	}

	public String getTestName() {
		return this.getClass().getSimpleName();
	}

	public String getTestPkg() {
		return this.getClass().getPackage().getName()
				.replace("io.github.skylot.raung.asm.tests.integration.", "");
	}

	private static String parseWithASM(byte[] bytes) {
		StringWriter out = new StringWriter();
		TraceClassVisitor tcv = new TraceClassVisitor(new PrintWriter(out));
		new ClassReader(bytes).accept(tcv, 0);
		return out.toString();
	}

	private void printCode(String code) {
		System.out.println("===================================");
		System.out.println(code);
		System.out.println("===================================");
	}
}

```

`raung-asm/src/test/java/io/github/skylot/raung/asm/tests/integration/annotations/TestAsmFieldAnnotations.java`:

```java
package io.github.skylot.raung.asm.tests.integration.annotations;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.asm.tests.api.IntegrationTest;

import static org.assertj.core.api.Assertions.assertThat;

public class TestAsmFieldAnnotations extends IntegrationTest {

	@Test
	public void test() {
		assertThat(asmCls())
				.containsOnlyOnce("public I field1")
				.containsOnlyOnce(
						"@Lio/github/skylot/raung/disasm/tests/integration/TestFieldAnnotations$TestCls$A;(value=2, s=\"A\") // invisible");
	}
}

```

`raung-asm/src/test/java/io/github/skylot/raung/asm/tests/integration/conditions/TestAsmAuto.java`:

```java
package io.github.skylot.raung.asm.tests.integration.conditions;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.asm.tests.api.IntegrationTest;

import static org.assertj.core.api.Assertions.assertThat;

public class TestAsmAuto extends IntegrationTest {

	@Test
	public void test() {
		assertThat(asmCls())
				.containsOnlyOnce("FRAME SAME1 I");
	}
}

```

`raung-asm/src/test/java/io/github/skylot/raung/asm/tests/integration/other/TestAsmHelloWorld.java`:

```java
package io.github.skylot.raung.asm.tests.integration.other;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.asm.tests.api.IntegrationTest;

import static org.assertj.core.api.Assertions.assertThat;

public class TestAsmHelloWorld extends IntegrationTest {

	@Test
	public void test() {
		assertThat(asmCls())
				.containsOnlyOnce("GETSTATIC java/lang/System.out : Ljava/io/PrintStream;")
				.containsOnlyOnce("LDC \"Hello, World!\"")
				.containsOnlyOnce("INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V");
	}
}

```

`raung-asm/src/test/java/io/github/skylot/raung/asm/tests/integration/other/TestStringConcatJava11.java`:

```java
package io.github.skylot.raung.asm.tests.integration.other;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.asm.tests.api.IntegrationTest;

import static org.assertj.core.api.Assertions.assertThat;

public class TestStringConcatJava11 extends IntegrationTest {

	@Test
	public void test() {
		assertThat(asmCls())
				.containsOnlyOnce("INVOKEDYNAMIC makeConcatWithConstants(Ljava/lang/String;)Ljava/lang/String;")
				.containsOnlyOnce("java/lang/invoke/StringConcatFactory.makeConcatWithConstants")
				.containsOnlyOnce("\"test\"");
	}
}

```

`raung-asm/src/test/resources/raung/annotations/TestAsmFieldAnnotations.raung`:

```raung
.version 60

.class public io/github/skylot/raung/disasm/tests/integration/TestFieldAnnotations$TestCls
.super java/lang/Object
.source "TestFieldAnnotations.java"   #comment

.field public field1 I
    .annotation build Lio/github/skylot/raung/disasm/tests/integration/TestFieldAnnotations$TestCls$A;
        value = 2
        s = "A"
    .end annotation
.end field

```

`raung-asm/src/test/resources/raung/conditions/TestAsmAuto.raung`:

```raung
.version 50
.class final conditions/TestAsmConditions
.auto frames

.field final synthetic val$a Ljava/util/Set;
.field final synthetic val$b Ljava/util/Set;

.method public contains(Ljava/lang/Object;)Z
    .local 0 "this" Lconditions/TestAsmConditions;
    .local 1 "o" Ljava/lang/Object;
    .line 451
    aload 0
    getfield conditions/TestAsmConditions val$a Ljava/util/Set;
    aload 1
    invokeinterface java/util/Set contains (Ljava/lang/Object;)Z  # interface
    ifne :L1
    aload 0
    getfield conditions/TestAsmConditions val$b Ljava/util/Set;
    aload 1
    invokeinterface java/util/Set contains (Ljava/lang/Object;)Z  # interface
    ifeq :L2
  :L1
    iconst_1
    goto :L3
  :L2
    iconst_0
  :L3
    ireturn
.end method

```

`raung-asm/src/test/resources/raung/other/TestAsmHelloWorld.raung`:

```raung
.version 52
.class public super io/github/skylot/raung/disasm/tests/integration/TestHelloWorld$TestCls
.super java/lang/Object
.source "TestHelloWorld.java"

.method public <init>()V
    .max stack 1
    .max locals 1

    .line 11
    aload 0
    invokespecial java/lang/Object <init> ()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .max stack 2
    .max locals 1

    .line 13
    getstatic java/lang/System out Ljava/io/PrintStream;
    ldc "Hello, World!"
    invokevirtual java/io/PrintStream println (Ljava/lang/String;)V
    .line 14
    return
.end method

```

`raung-asm/src/test/resources/raung/other/TestStringConcatJava11.raung`:

```raung
.version 55
.class public others/TestStringConcatJava11

.method public test(Ljava/lang/String;)Ljava/lang/String;
    .max stack 1
    .max locals 2

    aload 1
    invokedynamic makeConcatWithConstants (Ljava/lang/String;)Ljava/lang/String;
        .handle invoke-static java/lang/invoke/StringConcatFactory makeConcatWithConstants (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;
        .arg 0 "test"
    .end invokedynamic
    areturn
.end method

```

`raung-cli/build.gradle.kts`:

```kts
plugins {
	id("raung.java-common")

	application
}

dependencies {
	implementation(project(":raung-asm"))
	implementation(project(":raung-disasm"))

	implementation("info.picocli:picocli:4.7.6")
	implementation("ch.qos.logback:logback-classic:1.5.7")
}

application {
	mainClass.set("io.github.skylot.raung.cli.RaungCLI")
	applicationName = "raung"
}

```

`raung-cli/src/main/java/io/github/skylot/raung/cli/RaungArgs.java`:

```java
package io.github.skylot.raung.cli;

import java.nio.file.Path;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.function.Function;

import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Level;
import picocli.AutoComplete;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Model.CommandSpec;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;
import picocli.CommandLine.Spec;

import io.github.skylot.raung.asm.RaungAsm;
import io.github.skylot.raung.disasm.RaungDisasm;
import io.github.skylot.raung.disasm.api.IRaungDisasm;
import io.github.skylot.raung.disasm.api.RaungDisasmPreset;

@Command(
		name = "raung",
		description = "Assembler/disassembler for java bytecode",
		subcommands = {
				RaungArgs.AsmArgs.class,
				RaungArgs.DisasmArgs.class,
				AutoComplete.GenerateCompletion.class
		},
		mixinStandardHelpOptions = true
)
public class RaungArgs implements Callable<Integer> {
	private static final Logger LOG = LoggerFactory.getLogger(RaungArgs.class);

	@Command(
			name = "assemble",
			aliases = { "a", "asm" },
			description = "Assemble .class or .jar from .raung files",
			mixinStandardHelpOptions = true,
			sortOptions = false
	)
	@SuppressWarnings({ "FieldCanBeLocal", "FieldMayBeFinal", "unused" })
	public static class AsmArgs implements Runnable {
		@Parameters(paramLabel = "INPUTS", arity = "1..*", description = "input directories or *.raung files")
		private List<Path> inputs;

		@Option(names = { "-o", "--output" }, description = "Output *.jar, *.class file or directory")
		private Path output;

		public void run() {
			RaungAsm.create()
					.inputs(inputs)
					.output(output)
					.execute();
			LOG.info("done");
		}
	}

	@Command(
			name = "disassemble",
			aliases = { "d", "dis" },
			description = "Disassemble .class or .jar to .raung files",
			mixinStandardHelpOptions = true,
			sortOptions = false,
			usageHelpWidth = 200 // avoid wrapping for long descriptions
	)
	@SuppressWarnings({ "FieldCanBeLocal", "FieldMayBeFinal", "unused" })
	public static class DisasmArgs implements Runnable {
		@Parameters(paramLabel = "INPUTS", arity = "1..*", description = "*.jar or *.class files")
		private List<Path> files;

		@Option(names = { "-o", "--output" }, description = "Output directory")
		private Path output;

		@Option(names = { "-p", "--preset" }, description = "Options preset name:\n${sys:RAUNG_DISASM_PRESETS_LIST}")
		private String preset = RaungDisasmPreset.DEFAULT.getName();

		@Option(names = { "-d", "--no-debug-info" }, description = "Don't add debug info")
		private boolean debugInfo = true;

		@Option(names = { "--auto-max" }, description = "Use '.auto maxs' and remove '.max' directives")
		private Boolean autoMax;

		@Option(names = { "--auto-frames" }, description = "Use '.auto frames' and remove '.max' and '.stack' directives")
		private Boolean autoFrames;

		@Option(names = { "--auto-switches" }, description = "Use auto switch instead 'table' and 'lookup'")
		private Boolean autoSwitch;

		@Option(names = { "--save-catch-numbers" }, description = "Save optional catch number to preserve order on rebuild")
		private Boolean catchNumber;

		@Option(names = { "-v", "--verbose" }, description = "Verbose logging")
		private boolean verbose = false;

		public static void initVars() {
			System.setProperty("RAUNG_DISASM_PRESETS_LIST", RaungDisasmPreset.buildFormattedList());
		}

		public void run() {
			applyLogLevel(verbose);
			IRaungDisasm disasm = RaungDisasm.create()
					.inputs(files)
					.output(output)
					.preset(RaungDisasmPreset.getByName(preset));
			if (!debugInfo) {
				disasm.ignoreDebugInfo();
			}
			set(autoMax, disasm::autoMax);
			set(autoFrames, disasm::autoFrames);
			set(autoSwitch, disasm::autoSwitch);
			set(catchNumber, disasm::saveCatchNumber);

			disasm.execute();
			LOG.info("done");
		}
	}

	@Spec
	CommandSpec spec;

	@Override
	public Integer call() {
		// empty input -> just print help
		spec.commandLine().usage(System.out);
		return 1;
	}

	public static CommandLine buildParser() {
		DisasmArgs.initVars();
		CommandLine cmd = new CommandLine(new RaungArgs());
		CommandLine gen = cmd.getSubcommands().get("generate-completion");
		gen.getCommandSpec().usageMessage().hidden(true);
		return cmd;
	}

	private static void applyLogLevel(boolean verbose) {
		if (verbose) {
			((ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.DEBUG);
		}
	}

	private static <T> void set(@Nullable T value, Function<T, IRaungDisasm> method) {
		if (value != null) {
			method.apply(value);
		}
	}
}

```

`raung-cli/src/main/java/io/github/skylot/raung/cli/RaungCLI.java`:

```java
package io.github.skylot.raung.cli;

public class RaungCLI {

	public static void main(String[] args) {
		int exitCode = RaungArgs.buildParser().execute(args);
		System.exit(exitCode);
	}
}

```

`raung-cli/src/main/resources/logback.xml`:

```xml
<configuration>
	<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
		<encoder>
			<pattern>%-5level - %msg%n</pattern>
		</encoder>
	</appender>

	<root level="INFO">
		<appender-ref ref="STDOUT"/>
	</root>
</configuration>

```

`raung-common/build.gradle.kts`:

```kts
plugins {
	id("raung.java-library")
}

dependencies {
	api("org.ow2.asm:asm:9.7")

	compileOnlyApi("org.jetbrains:annotations:24.1.0")
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/AnnotationType.java`:

```java
package io.github.skylot.raung.common;

public enum AnnotationType {
	NORMAL("annotation"),
	TYPE("type_annotation"),
	PARAM("param_annotation"),
	DEFAULT("default"),
	SUB("sub_annotation"),
	INSN("insn_annotation"),
	ARRAY("array");

	private final String name;

	AnnotationType(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/Directive.java`:

```java
package io.github.skylot.raung.common;

import java.util.HashMap;
import java.util.Map;

import org.jetbrains.annotations.Nullable;

import static io.github.skylot.raung.common.DirectiveScope.SCOPE_ALL;
import static io.github.skylot.raung.common.DirectiveScope.SCOPE_CLASS;
import static io.github.skylot.raung.common.DirectiveScope.SCOPE_METHOD;

@SuppressWarnings("SpellCheckingInspection")
public enum Directive {
	VERSION(".version", SCOPE_CLASS),
	CLASS(".class", SCOPE_CLASS),
	SUPER(".super", SCOPE_CLASS),
	IMPLEMENTS(".implements", SCOPE_CLASS),
	SOURCE(".source", SCOPE_CLASS),
	SIGNATURE(".signature", SCOPE_ALL),
	INNERCLASS(".innerclass", SCOPE_CLASS),
	OUTERCLASS(".outerclass", SCOPE_CLASS),
	NEST(".nest", SCOPE_CLASS),
	AUTO(".auto", SCOPE_CLASS),
	FIELD(".field", SCOPE_CLASS),
	METHOD(".method", SCOPE_CLASS),
	ENUM(".enum", SCOPE_CLASS),
	ANNOTATION(".annotation", SCOPE_ALL),
	TYPE_ANNOTATION('.' + AnnotationType.TYPE.getName(), SCOPE_ALL),
	INSN_ANNOTATION('.' + AnnotationType.INSN.getName(), SCOPE_METHOD),
	PARAM_ANNOTATION('.' + AnnotationType.PARAM.getName(), SCOPE_METHOD),
	ANNOTATION_DEFAULT_VALUE('.' + AnnotationType.DEFAULT.getName(), SCOPE_METHOD),
	MAX(".max", SCOPE_METHOD),
	THROW(".throw", SCOPE_METHOD),
	LINE(".line", SCOPE_METHOD),
	LOCAL(".local", SCOPE_METHOD),
	PARAM(".param", SCOPE_METHOD),
	STACK(".stack", SCOPE_METHOD),
	CATCH(".catch", SCOPE_METHOD),
	END(".end", SCOPE_ALL);

	private final String token;
	private final int scope;

	Directive(String token, int scope) {
		this.token = token;
		this.scope = scope;
	}

	public String token() {
		return this.token;
	}

	private static final Map<String, Directive> TOKENS_MAP;

	static {
		Directive[] values = values();
		Map<String, Directive> map = new HashMap<>(values.length);
		for (Directive value : values) {
			map.put(value.token, value);
		}
		TOKENS_MAP = map;
	}

	@Nullable
	public static Directive parseToken(String str) {
		return TOKENS_MAP.get(str);
	}

	public boolean isAllowedInField() {
		return DirectiveScope.hasField(this.scope);
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/DirectiveScope.java`:

```java
package io.github.skylot.raung.common;

public class DirectiveScope {

	public static final int SCOPE_CLASS = 1;
	public static final int SCOPE_FIELD = 2;
	public static final int SCOPE_METHOD = 4;

	public static final int SCOPE_ALL = SCOPE_CLASS | SCOPE_FIELD | SCOPE_METHOD;

	public static boolean hasRoot(int scope) {
		return (scope & SCOPE_CLASS) != 0;
	}

	public static boolean hasField(int scope) {
		return (scope & SCOPE_FIELD) != 0;
	}

	public static boolean hasMethod(int scope) {
		return (scope & SCOPE_METHOD) != 0;
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/JavaOpCodeFormat.java`:

```java
package io.github.skylot.raung.common;

public enum JavaOpCodeFormat {
	UNKNOWN,
	NO_ARGS,
	INT,
	TYPE,
	FIELD,
	METHOD,
	VAR,
	JUMP,

	// special cases
	NEW_ARRAY,
	NEW_MULTI_ARRAY,
	IINC,
	LDC,
	SWITCH,
	INVOKE_DYNAMIC,
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/JavaOpCodes.java`:

```java
package io.github.skylot.raung.common;

import java.util.HashMap;
import java.util.Map;

import static io.github.skylot.raung.common.JavaOpCodeFormat.FIELD;
import static io.github.skylot.raung.common.JavaOpCodeFormat.IINC;
import static io.github.skylot.raung.common.JavaOpCodeFormat.INT;
import static io.github.skylot.raung.common.JavaOpCodeFormat.INVOKE_DYNAMIC;
import static io.github.skylot.raung.common.JavaOpCodeFormat.JUMP;
import static io.github.skylot.raung.common.JavaOpCodeFormat.LDC;
import static io.github.skylot.raung.common.JavaOpCodeFormat.METHOD;
import static io.github.skylot.raung.common.JavaOpCodeFormat.NEW_ARRAY;
import static io.github.skylot.raung.common.JavaOpCodeFormat.NEW_MULTI_ARRAY;
import static io.github.skylot.raung.common.JavaOpCodeFormat.NO_ARGS;
import static io.github.skylot.raung.common.JavaOpCodeFormat.SWITCH;
import static io.github.skylot.raung.common.JavaOpCodeFormat.TYPE;
import static io.github.skylot.raung.common.JavaOpCodeFormat.UNKNOWN;
import static io.github.skylot.raung.common.JavaOpCodeFormat.VAR;

@SuppressWarnings("SpellCheckingInspection")
public class JavaOpCodes {
	private static final int OPCODES_COUNT = 0xCA;

	private static final String[] OPCODES = new String[OPCODES_COUNT];
	private static final Map<String, Integer> NAMES_MAP = new HashMap<>(OPCODES_COUNT);
	private static final JavaOpCodeFormat[] OPCODES_FORMAT = new JavaOpCodeFormat[OPCODES_COUNT];

	static {
		add(0x0, "nop", NO_ARGS);
		add(0x1, "aconst_null", NO_ARGS);
		add(0x2, "iconst_m1", NO_ARGS);
		add(0x3, "iconst_0", NO_ARGS);
		add(0x4, "iconst_1", NO_ARGS);
		add(0x5, "iconst_2", NO_ARGS);
		add(0x6, "iconst_3", NO_ARGS);
		add(0x7, "iconst_4", NO_ARGS);
		add(0x8, "iconst_5", NO_ARGS);
		add(0x9, "lconst_0", NO_ARGS);
		add(0xa, "lconst_1", NO_ARGS);
		add(0xb, "fconst_0", NO_ARGS);
		add(0xc, "fconst_1", NO_ARGS);
		add(0xd, "fconst_2", NO_ARGS);
		add(0xe, "dconst_0", NO_ARGS);
		add(0xf, "dconst_1", NO_ARGS);
		add(0x10, "bipush", INT);
		add(0x11, "sipush", INT);
		add(0x12, "ldc", LDC);
		add(0x13, "ldc_w", LDC);
		add(0x14, "ldc2_w", LDC);
		add(0x15, "iload", VAR);
		add(0x16, "lload", VAR);
		add(0x17, "fload", VAR);
		add(0x18, "dload", VAR);
		add(0x19, "aload", VAR);
		add(0x1a, "iload_0", NO_ARGS);
		add(0x1b, "iload_1", NO_ARGS);
		add(0x1c, "iload_2", NO_ARGS);
		add(0x1d, "iload_3", NO_ARGS);
		add(0x1e, "lload_0", NO_ARGS);
		add(0x1f, "lload_1", NO_ARGS);
		add(0x20, "lload_2", NO_ARGS);
		add(0x21, "lload_3", NO_ARGS);
		add(0x22, "fload_0", NO_ARGS);
		add(0x23, "fload_1", NO_ARGS);
		add(0x24, "fload_2", NO_ARGS);
		add(0x25, "fload_3", NO_ARGS);
		add(0x26, "dload_0", NO_ARGS);
		add(0x27, "dload_1", NO_ARGS);
		add(0x28, "dload_2", NO_ARGS);
		add(0x29, "dload_3", NO_ARGS);
		add(0x2a, "aload_0", NO_ARGS);
		add(0x2b, "aload_1", NO_ARGS);
		add(0x2c, "aload_2", NO_ARGS);
		add(0x2d, "aload_3", NO_ARGS);
		add(0x2e, "iaload", NO_ARGS);
		add(0x2f, "laload", NO_ARGS);
		add(0x30, "faload", NO_ARGS);
		add(0x31, "daload", NO_ARGS);
		add(0x32, "aaload", NO_ARGS);
		add(0x33, "baload", NO_ARGS);
		add(0x34, "caload", NO_ARGS);
		add(0x35, "saload", NO_ARGS);
		add(0x36, "istore", VAR);
		add(0x37, "lstore", VAR);
		add(0x38, "fstore", VAR);
		add(0x39, "dstore", VAR);
		add(0x3a, "astore", VAR);
		add(0x3b, "istore_0", NO_ARGS);
		add(0x3c, "istore_1", NO_ARGS);
		add(0x3d, "istore_2", NO_ARGS);
		add(0x3e, "istore_3", NO_ARGS);
		add(0x3f, "lstore_0", NO_ARGS);
		add(0x40, "lstore_1", NO_ARGS);
		add(0x41, "lstore_2", NO_ARGS);
		add(0x42, "lstore_3", NO_ARGS);
		add(0x43, "fstore_0", NO_ARGS);
		add(0x44, "fstore_1", NO_ARGS);
		add(0x45, "fstore_2", NO_ARGS);
		add(0x46, "fstore_3", NO_ARGS);
		add(0x47, "dstore_0", NO_ARGS);
		add(0x48, "dstore_1", NO_ARGS);
		add(0x49, "dstore_2", NO_ARGS);
		add(0x4a, "dstore_3", NO_ARGS);
		add(0x4b, "astore_0", NO_ARGS);
		add(0x4c, "astore_1", NO_ARGS);
		add(0x4d, "astore_2", NO_ARGS);
		add(0x4e, "astore_3", NO_ARGS);
		add(0x4f, "iastore", NO_ARGS);
		add(0x50, "lastore", NO_ARGS);
		add(0x51, "fastore", NO_ARGS);
		add(0x52, "dastore", NO_ARGS);
		add(0x53, "aastore", NO_ARGS);
		add(0x54, "bastore", NO_ARGS);
		add(0x55, "castore", NO_ARGS);
		add(0x56, "sastore", NO_ARGS);
		add(0x57, "pop", NO_ARGS);
		add(0x58, "pop2", NO_ARGS);
		add(0x59, "dup", NO_ARGS);
		add(0x5a, "dup_x1", NO_ARGS);
		add(0x5b, "dup_x2", NO_ARGS);
		add(0x5c, "dup2", NO_ARGS);
		add(0x5d, "dup2_x1", NO_ARGS);
		add(0x5e, "dup2_x2", NO_ARGS);
		add(0x5f, "swap", NO_ARGS);
		add(0x60, "iadd", NO_ARGS);
		add(0x61, "ladd", NO_ARGS);
		add(0x62, "fadd", NO_ARGS);
		add(0x63, "dadd", NO_ARGS);
		add(0x64, "isub", NO_ARGS);
		add(0x65, "lsub", NO_ARGS);
		add(0x66, "fsub", NO_ARGS);
		add(0x67, "dsub", NO_ARGS);
		add(0x68, "imul", NO_ARGS);
		add(0x69, "lmul", NO_ARGS);
		add(0x6a, "fmul", NO_ARGS);
		add(0x6b, "dmul", NO_ARGS);
		add(0x6c, "idiv", NO_ARGS);
		add(0x6d, "ldiv", NO_ARGS);
		add(0x6e, "fdiv", NO_ARGS);
		add(0x6f, "ddiv", NO_ARGS);
		add(0x70, "irem", NO_ARGS);
		add(0x71, "lrem", NO_ARGS);
		add(0x72, "frem", NO_ARGS);
		add(0x73, "drem", NO_ARGS);
		add(0x74, "ineg", NO_ARGS);
		add(0x75, "lneg", NO_ARGS);
		add(0x76, "fneg", NO_ARGS);
		add(0x77, "dneg", NO_ARGS);
		add(0x78, "ishl", NO_ARGS);
		add(0x79, "lshl", NO_ARGS);
		add(0x7a, "ishr", NO_ARGS);
		add(0x7b, "lshr", NO_ARGS);
		add(0x7c, "iushr", NO_ARGS);
		add(0x7d, "lushr", NO_ARGS);
		add(0x7e, "iand", NO_ARGS);
		add(0x7f, "land", NO_ARGS);
		add(0x80, "ior", NO_ARGS);
		add(0x81, "lor", NO_ARGS);
		add(0x82, "ixor", NO_ARGS);
		add(0x83, "lxor", NO_ARGS);
		add(0x84, "iinc", IINC);
		add(0x85, "i2l", NO_ARGS);
		add(0x86, "i2f", NO_ARGS);
		add(0x87, "i2d", NO_ARGS);
		add(0x88, "l2i", NO_ARGS);
		add(0x89, "l2f", NO_ARGS);
		add(0x8a, "l2d", NO_ARGS);
		add(0x8b, "f2i", NO_ARGS);
		add(0x8c, "f2l", NO_ARGS);
		add(0x8d, "f2d", NO_ARGS);
		add(0x8e, "d2i", NO_ARGS);
		add(0x8f, "d2l", NO_ARGS);
		add(0x90, "d2f", NO_ARGS);
		add(0x91, "i2b", NO_ARGS);
		add(0x92, "i2c", NO_ARGS);
		add(0x93, "i2s", NO_ARGS);
		add(0x94, "lcmp", NO_ARGS);
		add(0x95, "fcmpl", NO_ARGS);
		add(0x96, "fcmpg", NO_ARGS);
		add(0x97, "dcmpl", NO_ARGS);
		add(0x98, "dcmpg", NO_ARGS);
		add(0x99, "ifeq", JUMP);
		add(0x9a, "ifne", JUMP);
		add(0x9b, "iflt", JUMP);
		add(0x9c, "ifge", JUMP);
		add(0x9d, "ifgt", JUMP);
		add(0x9e, "ifle", JUMP);
		add(0x9f, "if_icmpeq", JUMP);
		add(0xa0, "if_icmpne", JUMP);
		add(0xa1, "if_icmplt", JUMP);
		add(0xa2, "if_icmpge", JUMP);
		add(0xa3, "if_icmpgt", JUMP);
		add(0xa4, "if_icmple", JUMP);
		add(0xa5, "if_acmpeq", JUMP);
		add(0xa6, "if_acmpne", JUMP);
		add(0xa7, "goto", JUMP);
		add(0xa8, "jsr", JUMP);
		add(0xa9, "ret", VAR);
		add(0xaa, "tableswitch", SWITCH);
		add(0xab, "lookupswitch", SWITCH);
		add(0xac, "ireturn", NO_ARGS);
		add(0xad, "lreturn", NO_ARGS);
		add(0xae, "freturn", NO_ARGS);
		add(0xaf, "dreturn", NO_ARGS);
		add(0xb0, "areturn", NO_ARGS);
		add(0xb1, "return", NO_ARGS);
		add(0xb2, "getstatic", FIELD);
		add(0xb3, "putstatic", FIELD);
		add(0xb4, "getfield", FIELD);
		add(0xb5, "putfield", FIELD);
		add(0xb6, "invokevirtual", METHOD);
		add(0xb7, "invokespecial", METHOD);
		add(0xb8, "invokestatic", METHOD);
		add(0xb9, "invokeinterface", METHOD);
		add(0xba, "invokedynamic", INVOKE_DYNAMIC);
		add(0xbb, "new", TYPE);
		add(0xbc, "newarray", NEW_ARRAY);
		add(0xbd, "anewarray", TYPE);
		add(0xbe, "arraylength", NO_ARGS);
		add(0xbf, "athrow", NO_ARGS);
		add(0xc0, "checkcast", TYPE);
		add(0xc1, "instanceof", TYPE);
		add(0xc2, "monitorenter", NO_ARGS);
		add(0xc3, "monitorexit", NO_ARGS);
		add(0xc4, "wide", UNKNOWN);
		add(0xc5, "multianewarray", NEW_MULTI_ARRAY);
		add(0xc6, "ifnull", JUMP);
		add(0xc7, "ifnonnull", JUMP);
		add(0xc9, "jsr_w", JUMP);

		alias("switch", 0xaa);
	}

	private static void add(int opcode, String name, JavaOpCodeFormat format) {
		OPCODES[opcode] = name;
		NAMES_MAP.put(name, opcode);
		OPCODES_FORMAT[opcode] = format;
	}

	private static void alias(String name, int opcode) {
		NAMES_MAP.put(name, opcode);
	}

	public static String getName(int opcode) {
		return OPCODES[opcode];
	}

	public static int getOpcode(String name) {
		Integer opcode = NAMES_MAP.get(name);
		if (opcode == null) {
			return -1;
		}
		return opcode;
	}

	public static JavaOpCodeFormat getFormat(int opcode) {
		return OPCODES_FORMAT[opcode];
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/RaungAccessFlags.java`:

```java
package io.github.skylot.raung.common;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RaungAccessFlags {
	public static final int PUBLIC = 0x1;
	public static final int PRIVATE = 0x2;
	public static final int PROTECTED = 0x4;
	public static final int STATIC = 0x8;
	public static final int FINAL = 0x10;
	public static final int SYNCHRONIZED = 0x20;
	public static final int SUPER = 0x20;
	public static final int VOLATILE = 0x40;
	public static final int BRIDGE = 0x40;
	public static final int TRANSIENT = 0x80;
	public static final int VARARGS = 0x80;
	public static final int NATIVE = 0x100;
	public static final int INTERFACE = 0x200;
	public static final int ABSTRACT = 0x400;
	public static final int STRICT = 0x800;
	public static final int SYNTHETIC = 0x1000;
	public static final int ANNOTATION = 0x2000;
	public static final int ENUM = 0x4000;
	public static final int MODULE = 0x8000;
	public static final int MANDATED = 0x8000;
	public static final int CONSTRUCTOR = 0x10000;
	public static final int DECLARED_SYNCHRONIZED = 0x20000;

	private static final List<AccFlagsInfo> FLAGS_LIST = new ArrayList<>();
	private static final Map<String, AccFlagsInfo> FLAGS_MAP = new HashMap<>();

	public enum Scope {
		CLASS(1),
		FIELD(2),
		METHOD(4),
		PARAM(8),
		ANY(15);

		private final int flag;

		Scope(int flag) {
			this.flag = flag;
		}

		public int getFlag() {
			return flag;
		}
	}

	private static final class AccFlagsInfo {
		String name;
		int accessFlag;
		int scopeFlags;

		public AccFlagsInfo(String name, int accessFlag, int scopeFlags) {
			this.name = name;
			this.accessFlag = accessFlag;
			this.scopeFlags = scopeFlags;
		}
	}

	static {
		add("public", RaungAccessFlags.PUBLIC, Scope.ANY);
		add("private", RaungAccessFlags.PRIVATE, Scope.ANY);
		add("protected", RaungAccessFlags.PROTECTED, Scope.ANY);
		add("static", RaungAccessFlags.STATIC, Scope.ANY);
		add("final", RaungAccessFlags.FINAL, Scope.ANY);
		add("synthetic", RaungAccessFlags.SYNTHETIC, Scope.ANY);
		add("super", RaungAccessFlags.SUPER, Scope.CLASS);

		add("interface", RaungAccessFlags.INTERFACE, Scope.CLASS);
		add("annotation", RaungAccessFlags.ANNOTATION, Scope.CLASS);
		add("module", RaungAccessFlags.MODULE, Scope.CLASS);

		add("enum", RaungAccessFlags.ENUM, Scope.CLASS, Scope.FIELD);

		add("abstract", RaungAccessFlags.ABSTRACT, Scope.CLASS, Scope.METHOD);

		add("constructor", RaungAccessFlags.CONSTRUCTOR, Scope.METHOD);
		add("synchronized", RaungAccessFlags.SYNCHRONIZED, Scope.METHOD);
		add("varargs", RaungAccessFlags.VARARGS, Scope.METHOD);
		add("bridge", RaungAccessFlags.BRIDGE, Scope.METHOD);
		add("native", RaungAccessFlags.NATIVE, Scope.METHOD);
		add("strict", RaungAccessFlags.STRICT, Scope.METHOD);

		add("transient", RaungAccessFlags.TRANSIENT, Scope.FIELD);
		add("volatile", RaungAccessFlags.VOLATILE, Scope.FIELD);
		add("mandated", RaungAccessFlags.MANDATED, Scope.PARAM);
	}

	private static void add(String name, int accessFlag, Scope scope) {
		add(new AccFlagsInfo(name, accessFlag, scope.getFlag()));
	}

	private static void add(String name, int accessFlag, Scope scope, Scope secondScope) {
		add(new AccFlagsInfo(name, accessFlag, scope.getFlag() | secondScope.getFlag()));
	}

	private static void add(AccFlagsInfo info) {
		FLAGS_LIST.add(info);
		FLAGS_MAP.put(info.name, info);
	}

	public static int parseToken(String token, Scope scope) {
		AccFlagsInfo info = FLAGS_MAP.get(token);
		if (info == null || (info.scopeFlags & scope.getFlag()) == 0) {
			return -1;
		}
		return info.accessFlag;
	}

	public static String format(int flags, Scope scope) {
		if (flags == 0) {
			return "";
		}
		int remFlags = flags;
		int scopeFlag = scope.getFlag();
		StringBuilder sb = new StringBuilder();
		for (AccFlagsInfo flag : FLAGS_LIST) {
			if (hasFlag(remFlags, flag.accessFlag) && hasFlag(flag.scopeFlags, scopeFlag)) {
				remFlags &= ~flag.accessFlag;
				sb.append(flag.name).append(' ');
			}
		}
		if (remFlags != 0) {
			sb.append("0x").append(Integer.toHexString(remFlags)).append(' ');
		}
		return sb.toString();
	}

	private static boolean hasFlag(int flags, int flagValue) {
		return (flags & flagValue) != 0;
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/asm/HandleTag.java`:

```java
package io.github.skylot.raung.common.asm;

import java.util.HashMap;
import java.util.Map;

import org.objectweb.asm.Opcodes;

public enum HandleTag {

	GETFIELD(Opcodes.H_GETFIELD, "get-field"),
	GETSTATIC(Opcodes.H_GETSTATIC, "get-static"),
	PUTFIELD(Opcodes.H_PUTFIELD, "put-field"),
	PUTSTATIC(Opcodes.H_PUTSTATIC, "put-static"),
	INVOKEVIRTUAL(Opcodes.H_INVOKEVIRTUAL, "invoke-virtual"),
	INVOKESTATIC(Opcodes.H_INVOKESTATIC, "invoke-static"),
	INVOKESPECIAL(Opcodes.H_INVOKESPECIAL, "invoke-special"),
	NEWINVOKESPECIAL(Opcodes.H_NEWINVOKESPECIAL, "new-invoke-special"),
	INVOKEINTERFACE(Opcodes.H_INVOKEINTERFACE, "invoke-interface");

	private final int tag;
	private final String name;

	HandleTag(int tag, String name) {
		this.tag = tag;
		this.name = name;
	}

	public int getTag() {
		return tag;
	}

	public String getName() {
		return name;
	}

	private static final HandleTag[] VALUES_ARRAY;
	private static final Map<String, HandleTag> NAMES_MAP;

	static {
		HandleTag[] values = values();
		HandleTag[] valuesArr = new HandleTag[10];
		Map<String, HandleTag> namesMap = new HashMap<>(values.length);
		for (HandleTag value : values) {
			valuesArr[value.tag] = value;
			namesMap.put(value.name, value);
		}
		VALUES_ARRAY = valuesArr;
		NAMES_MAP = namesMap;
	}

	public static HandleTag getByName(String name) {
		return NAMES_MAP.get(name);
	}

	public static HandleTag getByValue(int value) {
		return VALUES_ARRAY[value];
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/asm/StackType.java`:

```java
package io.github.skylot.raung.common.asm;

import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Map;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.Opcodes;

public enum StackType {
	TOP(Opcodes.TOP, "Top"),
	INTEGER(Opcodes.INTEGER, "int"),
	FLOAT(Opcodes.FLOAT, "float"),
	DOUBLE(Opcodes.DOUBLE, "double"),
	LONG(Opcodes.LONG, "long"),
	NULL(Opcodes.NULL, "null"),
	UNINIT_THIS(Opcodes.UNINITIALIZED_THIS, "UninitializedThis");

	private final Integer value;
	private final String name;

	StackType(Integer value, String name) {
		this.value = value;
		this.name = name;
	}

	public Integer getValue() {
		return value;
	}

	public String getName() {
		return name;
	}

	private static final Map<Integer, StackType> VALUES_MAP;
	private static final Map<String, StackType> NAMES_MAP;

	static {
		StackType[] values = values();
		Map<Integer, StackType> valuesMap = new IdentityHashMap<>(values.length);
		Map<String, StackType> namesMap = new HashMap<>(values.length);
		for (StackType value : values) {
			valuesMap.put(value.value, value);
			namesMap.put(value.name, value);
		}
		VALUES_MAP = valuesMap;
		NAMES_MAP = namesMap;
	}

	public static StackType getByName(String name) {
		return NAMES_MAP.get(name);
	}

	@Nullable
	public static StackType getByValue(Integer value) {
		return VALUES_MAP.get(value);
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/asm/TypeRef.java`:

```java
package io.github.skylot.raung.common.asm;

import java.util.HashMap;
import java.util.Map;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.TypeReference;

import static io.github.skylot.raung.common.asm.TypeRefFormat.FORMAL_PARAM_INDEX;
import static io.github.skylot.raung.common.asm.TypeRefFormat.NO_ARGS;
import static io.github.skylot.raung.common.asm.TypeRefFormat.SUPER_TYPE_INDEX;
import static io.github.skylot.raung.common.asm.TypeRefFormat.TYPE_ARGUMENT_INDEX;
import static io.github.skylot.raung.common.asm.TypeRefFormat.TYPE_PARAM_BOUND_INDEX;
import static io.github.skylot.raung.common.asm.TypeRefFormat.TYPE_PARAM_INDEX;

public enum TypeRef {
	CLASS_TYPE_PARAMETER(TypeReference.CLASS_TYPE_PARAMETER, "class_type_parameter", TYPE_PARAM_INDEX),
	CLASS_TYPE_PARAMETER_BOUND(TypeReference.CLASS_TYPE_PARAMETER_BOUND, "class_type_parameter_bound", TYPE_PARAM_BOUND_INDEX),
	METHOD_TYPE_PARAMETER(TypeReference.METHOD_TYPE_PARAMETER, "method_type_parameter", TYPE_PARAM_INDEX),
	METHOD_TYPE_PARAMETER_BOUND(TypeReference.METHOD_TYPE_PARAMETER_BOUND, "method_type_parameter_bound", TYPE_PARAM_BOUND_INDEX),
	METHOD_FORMAL_PARAMETER(TypeReference.METHOD_FORMAL_PARAMETER, "method_formal_parameter", FORMAL_PARAM_INDEX),
	METHOD_INVOCATION_TYPE_ARGUMENT(TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT, "method_invocation_type_argument", TYPE_ARGUMENT_INDEX),
	CLASS_EXTENDS(TypeReference.CLASS_EXTENDS, "class_extends", SUPER_TYPE_INDEX),
	CAST(TypeReference.CAST, "cast", TYPE_ARGUMENT_INDEX),
	FIELD(TypeReference.FIELD, "field", NO_ARGS),
	METHOD_RETURN(TypeReference.METHOD_RETURN, "method_return", NO_ARGS),
	NEW(TypeReference.NEW, "new", NO_ARGS),
	LOCAL_VARIABLE(TypeReference.LOCAL_VARIABLE, "local_variable", NO_ARGS);

	private final int value;
	private final String name;
	private final TypeRefFormat format;

	TypeRef(int value, String name, TypeRefFormat format) {
		this.value = value;
		this.name = name;
		this.format = format;
	}

	public int getValue() {
		return value;
	}

	public String getName() {
		return name;
	}

	public TypeRefFormat getFormat() {
		return format;
	}

	private static final TypeRef[] ARR_BY_VALUE;
	private static final Map<String, TypeRef> MAP_BY_NAME;

	static {
		TypeRef[] values = values();
		TypeRef[] arr = new TypeRef[0x50];
		Map<String, TypeRef> map = new HashMap<>(values.length);
		for (TypeRef ref : values) {
			arr[ref.value] = ref;
			map.put(ref.name, ref);
		}
		ARR_BY_VALUE = arr;
		MAP_BY_NAME = map;
	}

	public static TypeRef getByValue(int value) {
		return ARR_BY_VALUE[value];
	}

	@Nullable
	public static TypeRef getByName(String name) {
		return MAP_BY_NAME.get(name);
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/asm/TypeRefFormat.java`:

```java
package io.github.skylot.raung.common.asm;

public enum TypeRefFormat {
	NO_ARGS,
	TYPE_PARAM_INDEX,
	TYPE_PARAM_BOUND_INDEX,
	SUPER_TYPE_INDEX,
	FORMAL_PARAM_INDEX,
	EXCEPTION_INDEX,
	TRY_CATCH_BLOCK_INDEX,
	TYPE_ARGUMENT_INDEX,
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/utils/FileUtils.java`:

```java
package io.github.skylot.raung.common.utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;

import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FileUtils {
	private static final Logger LOG = LoggerFactory.getLogger(FileUtils.class);

	public static List<Path> expandDirs(List<Path> paths) {
		List<Path> files = new ArrayList<>(paths.size());
		for (Path path : paths) {
			if (Files.isDirectory(path)) {
				expandDir(path, files);
			} else {
				files.add(path);
			}
		}
		Collections.sort(files);
		return files;
	}

	public static List<Path> expandDir(Path path) {
		if (Files.isDirectory(path)) {
			List<Path> files = new ArrayList<>();
			expandDir(path, files);
			Collections.sort(files);
			return files;
		}
		return Collections.singletonList(path);
	}

	private static void expandDir(Path dir, List<Path> files) {
		try (Stream<Path> walk = Files.walk(dir, FileVisitOption.FOLLOW_LINKS)) {
			walk.filter(Files::isRegularFile).forEach(files::add);
		} catch (Exception e) {
			LOG.error("Failed to list files in directory: {}", dir, e);
		}
	}

	public static Path getParentDir(Path path) {
		Path parent = path.getParent();
		if (parent == null) {
			return Paths.get(".");
		}
		return parent;
	}

	public static void makeDirsForFile(Path file) {
		if (file != null) {
			makeDirs(file.getParent());
		}
	}

	private static final Object MKDIR_SYNC = new Object();

	public static void makeDirs(@Nullable Path dir) {
		if (dir != null) {
			synchronized (MKDIR_SYNC) {
				try {
					Files.createDirectories(dir);
				} catch (IOException e) {
					throw new RuntimeException("Can't create directory " + dir, e);
				}
			}
		}
	}

	public static void saveFile(Path output, String fileName, String code) {
		Path file = output.resolve(fileName);
		saveFile(file, code);
	}

	public static void saveFile(Path file, String code) {
		makeDirsForFile(file);
		try (Writer writer = Files.newBufferedWriter(file, StandardCharsets.UTF_8)) {
			writer.write(code);
		} catch (Exception e) {
			throw new RuntimeException("File save failed: " + file.toAbsolutePath(), e);
		}
	}

	public static void saveInputStream(Path output, String fileName, InputStream inputStream) {
		Path file = output.resolve(fileName);
		makeDirsForFile(file);
		try {
			Files.copy(inputStream, file, StandardCopyOption.REPLACE_EXISTING);
		} catch (Exception e) {
			throw new RuntimeException("File save failed: " + file.toAbsolutePath(), e);
		}
	}

	@Nullable
	public static String getExt(@Nullable Path path) {
		if (path == null) {
			return null;
		}
		String name = path.getFileName().toString();
		int extIdx = name.lastIndexOf('.');
		if (extIdx == -1 || extIdx == name.length() - 1) {
			return null;
		}
		return name.substring(extIdx + 1);
	}

	public static void checkInputFile(Path file) {
		if (file == null) {
			throw new IllegalArgumentException("Input file should be set");
		}
		if (!Files.exists(file)) {
			throw new IllegalArgumentException("File not found: " + file.toAbsolutePath());
		}
		if (Files.isDirectory(file)) {
			throw new IllegalArgumentException("Expect file but ogt directory: " + file.toAbsolutePath());
		}
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/utils/JavaVersion.java`:

```java
package io.github.skylot.raung.common.utils;

import java.util.HashMap;
import java.util.Map;

import org.jetbrains.annotations.Nullable;

public enum JavaVersion {
	JAVA_1_0_2(45, "1.0.2"),
	JAVA_1_1(getRaw(45, 3), "1.1"),
	JAVA_1_2(46, "1.2"),
	JAVA_1_3(47, "1.3"),
	JAVA_1_4(48, "1.4"),
	JAVA_1_5(49, "5.0"),
	JAVA_6(50, "6"),
	JAVA_7(51, "7"),
	JAVA_8(52, "8"),
	JAVA_9(53, "9"),
	JAVA_10(54, "10"),
	JAVA_11(55, "11"),
	JAVA_12(56, "12"),
	JAVA_13(57, "13"),
	JAVA_14(58, "14"),
	JAVA_15(59, "15"),
	JAVA_16(60, "16"),
	JAVA_17(61, "17"),
	JAVA_18(62, "18"),
	JAVA_19(63, "19"),
	JAVA_20(64, "20"),
	JAVA_21(65, "21");

	private static final Map<Integer, JavaVersion> MAP;

	static {
		JavaVersion[] values = values();
		Map<Integer, JavaVersion> map = new HashMap<>(values.length);
		for (JavaVersion value : values) {
			map.put(value.rawVersion, value);
		}
		MAP = map;
	}

	private final int rawVersion;
	private final String name;

	JavaVersion(int rawVersion, String name) {
		this.rawVersion = rawVersion;
		this.name = name;
	}

	public int getRawVersion() {
		return rawVersion;
	}

	public String getName() {
		return name;
	}

	public int getMajor() {
		return getMajor(rawVersion);
	}

	public int getMinor() {
		return getMinor(rawVersion);
	}

	public static int getMajor(int rawVersion) {
		return rawVersion & 0xFFFF;
	}

	public static int getMinor(int rawVersion) {
		return (rawVersion & 0xFFFF0000) >> 16;
	}

	public static int getRaw(int major, int minor) {
		return minor << 16 | major;
	}

	public static final int PREVIEW_VERSION = 0xFFFF0000;

	public static boolean isPreview(int rawVersion) {
		return (rawVersion & PREVIEW_VERSION) == PREVIEW_VERSION;
	}

	public static String getNameStr(int rawVersion) {
		StringBuilder sb = new StringBuilder("Java ");
		int major = getMajor(rawVersion);
		boolean preview = isPreview(rawVersion);
		int searchVersion = preview ? major : rawVersion;
		JavaVersion version = MAP.get(searchVersion);
		if (version != null) {
			sb.append(version.name);
		} else {
			if (!preview) {
				int minor = getMinor(rawVersion);
				if (minor != 0) {
					return getNameStr(getRaw(major, 0)) + " (with unknown minor: " + minor + ')';
				}
			}
			// try approximation :)
			int verDiff = major - getMajor(JAVA_18.rawVersion);
			if (verDiff > 0) {
				sb.append(18 + verDiff).append(" (approximated)");
			} else {
				sb.append("unknown version");
			}
		}
		if (preview) {
			sb.append(" preview");
		}
		return sb.toString();
	}

	public static String formatVersionNumber(int rawVersion) {
		int major = getMajor(rawVersion);
		int minor = getMinor(rawVersion);
		if (minor == 0) {
			return Integer.toString(major);
		}
		return major + "." + minor;
	}

	@Nullable
	public static JavaVersion get(int rawVersion) {
		return MAP.get(rawVersion);
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/utils/LimitedInputStream.java`:

```java
package io.github.skylot.raung.common.utils;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

public class LimitedInputStream extends FilterInputStream {

	private final long maxSize;

	private long currentPos;

	protected LimitedInputStream(InputStream in, long maxSize) {
		super(in);
		this.maxSize = maxSize;
	}

	private void checkPos() {
		if (currentPos > maxSize) {
			throw new IllegalStateException("Read limit exceeded");
		}
	}

	@Override
	public int read() throws IOException {
		int data = super.read();
		if (data != -1) {
			currentPos++;
			checkPos();
		}
		return data;
	}

	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		int count = super.read(b, off, len);
		if (count > 0) {
			currentPos += count;
			checkPos();
		}
		return count;
	}

	@Override
	public long skip(long n) throws IOException {
		long skipped = super.skip(n);
		if (skipped != 0) {
			currentPos += skipped;
			checkPos();
		}
		return skipped;
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/utils/StringCommonUtils.java`:

```java
package io.github.skylot.raung.common.utils;

public class StringCommonUtils {

	public static String repeat(char ch, int count) {
		if (count <= 0) {
			return "";
		}
		StringBuilder sb = new StringBuilder(count);
		for (int i = 0; i < count; i++) {
			sb.append(ch);
		}
		return sb.toString();
	}
}

```

`raung-common/src/main/java/io/github/skylot/raung/common/utils/ZipUtils.java`:

```java
package io.github.skylot.raung.common.utils;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ZipUtils {
	private static final Logger LOG = LoggerFactory.getLogger(ZipUtils.class);

	// size of uncompressed zip entry shouldn't be bigger of compressed in MAX_SIZE_DIFF times
	private static final int MAX_SIZE_DIFF = 100;
	private static final int MAX_ENTRIES_COUNT = 100_000;

	private ZipUtils() {
	}

	private static boolean isInSubDirectoryInternal(File baseDir, File canonFile) {
		if (canonFile == null) {
			return false;
		}
		if (canonFile.equals(baseDir)) {
			return true;
		}
		return isInSubDirectoryInternal(baseDir, canonFile.getParentFile());
	}

	public static boolean isInSubDirectory(File baseDir, File file) {
		try {
			file = file.getCanonicalFile();
			baseDir = baseDir.getCanonicalFile();
		} catch (IOException e) {
			return false;
		}
		return isInSubDirectoryInternal(baseDir, file);
	}

	// checks that entry name contains no any traversals
	// and prevents cases like "../classes.dex", to limit output only to the specified directory
	public static boolean isValidZipEntryName(String entryName) {
		try {
			File currentPath = new File(".").getCanonicalFile();
			File canonical = new File(currentPath, entryName).getCanonicalFile();
			if (isInSubDirectoryInternal(currentPath, canonical)) {
				return true;
			}
			LOG.error("Path traversal attack detected, invalid name: {}", entryName);
			return false;
		} catch (Exception e) {
			LOG.error("Path traversal attack detected, invalid name: {}", entryName);
			return false;
		}
	}

	public static boolean isZipBomb(ZipEntry entry) {
		long compressedSize = entry.getCompressedSize();
		long uncompressedSize = entry.getSize();
		if (compressedSize < 0 || uncompressedSize < 0) {
			LOG.error("Zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",
					compressedSize, uncompressedSize, entry.getName());
			return true;
		}
		if (compressedSize * MAX_SIZE_DIFF < uncompressedSize) {
			LOG.error("Zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",
					compressedSize, uncompressedSize, entry.getName());
			return true;
		}
		return false;
	}

	public static boolean isValidZipEntry(ZipEntry entry) {
		return isValidZipEntryName(entry.getName())
				&& !isZipBomb(entry);
	}

	public static InputStream getInputStreamForEntry(ZipFile zipFile, ZipEntry entry) throws IOException {
		InputStream in = zipFile.getInputStream(entry);
		LimitedInputStream limited = new LimitedInputStream(in, entry.getSize());
		return new BufferedInputStream(limited);
	}

	/**
	 * Visit valid entries in zip file.
	 * Return not null value from visitor to stop iteration.
	 */
	@Nullable
	public static <R> R visitZipEntries(File file, BiFunction<ZipFile, ZipEntry, R> visitor) {
		try (ZipFile zip = new ZipFile(file)) {
			Enumeration<? extends ZipEntry> entries = zip.entries();
			int entriesProcessed = 0;
			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement();
				if (isValidZipEntry(entry)) {
					R result = visitor.apply(zip, entry);
					if (result != null) {
						return result;
					}
					entriesProcessed++;
					if (entriesProcessed > MAX_ENTRIES_COUNT) {
						throw new IllegalStateException("Zip entries count limit exceeded: " + MAX_ENTRIES_COUNT
								+ ", last entry: " + entry.getName());
					}
				}
			}
		} catch (Exception e) {
			throw new RuntimeException("Failed to process zip file: " + file.getAbsolutePath(), e);
		}
		return null;
	}

	public static void readZipEntries(File file, BiConsumer<ZipEntry, InputStream> visitor) {
		visitZipEntries(file, (zip, entry) -> {
			if (!entry.isDirectory()) {
				try (InputStream in = getInputStreamForEntry(zip, entry)) {
					visitor.accept(entry, in);
				} catch (Exception e) {
					throw new RuntimeException("Error process zip entry: " + entry.getName());
				}
			}
			return null;
		});
	}
}

```

`raung-disasm/build.gradle.kts`:

```kts
plugins {
	id("raung.java-library")
}

dependencies {
	api(project(":raung-common"))
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/RaungDisasm.java`:

```java
package io.github.skylot.raung.disasm;

import io.github.skylot.raung.disasm.api.IRaungDisasm;
import io.github.skylot.raung.disasm.impl.RaungDisasmBuilder;

public class RaungDisasm {

	/**
	 * API entry point. Check {@link IRaungDisasm} for available methods.
	 * Usage example:
	 * <br>
	 *
	 * <pre>
	 * RaungDisasm.create()
	 * 		.input(Paths.get("inputDirOrFile"))
	 * 		.output(Paths.get("outputDir"))
	 * 		.execute();
	 * </pre>
	 */
	public static IRaungDisasm create() {
		return new RaungDisasmBuilder();
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/api/IRaungDisasm.java`:

```java
package io.github.skylot.raung.disasm.api;

import java.io.InputStream;
import java.nio.file.Path;
import java.util.List;

public interface IRaungDisasm {

	/**
	 * List of files or directories (will preform recursive search for .jar or .class files).
	 */
	IRaungDisasm inputs(List<Path> inputs);

	/**
	 * Single file or directory (will preform recursive search for .jar or .class files).
	 * Can be called several times if needed.
	 */
	IRaungDisasm input(Path input);

	/**
	 * Directory or single file (only for single input).
	 * Optional - current dir will be used if not set.
	 */
	IRaungDisasm output(Path out);

	/**
	 * Set predefined set of options, see {@link RaungDisasmPreset}.
	 * Caution: this method will overwrite all previously set options (except 'inputs' and 'output')
	 */
	IRaungDisasm preset(RaungDisasmPreset preset);

	/**
	 * Don't add debug information (var names and line numbers)
	 */
	IRaungDisasm ignoreDebugInfo();

	/**
	 * Add optional catch number (allow preserving try-catches order).
	 * Default to false;
	 */
	IRaungDisasm saveCatchNumber(boolean save);

	/**
	 * Remove '.max' add '.auto maxs'
	 */
	IRaungDisasm autoMax(boolean auto);

	/**
	 * Remove '.max' and '.stack' add '.auto frames'
	 */
	IRaungDisasm autoFrames(boolean auto);

	/**
	 * Use switch with type autodetect: 'table' or 'lookup'
	 */
	IRaungDisasm autoSwitch(boolean auto);

	/**
	 * Preform disassemble according to provided options.
	 */
	void execute();

	/**
	 * Single mode: process specified input file and return result as string.
	 * Any set inputs or output will be ignored.
	 */
	String executeForSingleClass(Path input);

	/**
	 * Single mode: process specified input stream and return result as string.
	 * Any set inputs or output will be ignored.
	 */
	String executeForInputStream(InputStream input);

	/**
	 * Single mode: process specified input class file bytes and return result as string.
	 * Any set inputs or output will be ignored.
	 */
	String executeForBytes(byte[] bytes);
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/api/RaungDisasmPreset.java`:

```java
package io.github.skylot.raung.disasm.api;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

public enum RaungDisasmPreset implements Consumer<IRaungDisasm> {
	DEFAULT(
			"default",
			"Balanced options for read and edit") {
		@Override
		public void accept(IRaungDisasm args) {
			args.saveCatchNumber(false);
			args.autoFrames(false);
			args.autoSwitch(false);
		}
	},
	REBUILD(
			"rebuild",
			"Save additional data for rebuild result stability") {
		@Override
		public void accept(IRaungDisasm args) {
			args.saveCatchNumber(true);
			args.autoFrames(false);
			args.autoSwitch(false);
		}
	},
	AUTO(
			"auto",
			"Omit information that can be calculated automatically (maxs, frames, switches)") {
		@Override
		public void accept(IRaungDisasm args) {
			args.saveCatchNumber(false);
			args.autoFrames(true);
			args.autoSwitch(true);
		}
	};

	private final String name;
	private final String description;

	RaungDisasmPreset(String name, String description) {
		this.name = name;
		this.description = description;
	}

	public String getName() {
		return name;
	}

	public String getDescription() {
		return description;
	}

	private static final Map<String, RaungDisasmPreset> MAP;

	static {
		RaungDisasmPreset[] values = values();
		Map<String, RaungDisasmPreset> map = new HashMap<>(values.length);
		for (RaungDisasmPreset preset : values) {
			map.put(preset.name, preset);
		}
		MAP = map;
	}

	public static RaungDisasmPreset getByName(String name) {
		RaungDisasmPreset preset = MAP.get(name);
		if (preset == null) {
			throw new IllegalArgumentException("Unknown preset name: "
					+ "'" + name + "', possible values:\n" + buildFormattedList());
		}
		return preset;
	}

	public static String buildFormattedList() {
		RaungDisasmPreset[] values = values();
		List<String> lines = new ArrayList<>(values.length);
		for (RaungDisasmPreset preset : values) {
			lines.add(String.format(" %s - %s", preset.name, preset.description));
		}
		return String.join("\n", lines);
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/RaungDisasmBuilder.java`:

```java
package io.github.skylot.raung.disasm.impl;

import java.io.InputStream;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import io.github.skylot.raung.disasm.api.IRaungDisasm;
import io.github.skylot.raung.disasm.api.RaungDisasmPreset;
import io.github.skylot.raung.disasm.impl.utils.RaungDisasmException;

public class RaungDisasmBuilder implements IRaungDisasm {

	private List<Path> inputs;
	private Path output;

	private boolean ignoreDebugInfo = false;
	private boolean saveCatchNumber = false;

	private boolean autoMax = false;
	private boolean autoFrames = false;
	private boolean autoSwitch = false;

	@Override
	public IRaungDisasm inputs(List<Path> inputs) {
		this.inputs = inputs;
		return this;
	}

	@Override
	public IRaungDisasm input(Path input) {
		if (this.inputs == null) {
			this.inputs = new ArrayList<>();
		}
		this.inputs.add(input);
		return this;
	}

	@Override
	public IRaungDisasm output(Path out) {
		this.output = out;
		return this;
	}

	@Override
	public IRaungDisasm preset(RaungDisasmPreset preset) {
		preset.accept(this);
		return this;
	}

	@Override
	public IRaungDisasm ignoreDebugInfo() {
		this.ignoreDebugInfo = true;
		return this;
	}

	@Override
	public IRaungDisasm saveCatchNumber(boolean save) {
		this.saveCatchNumber = save;
		return this;
	}

	@Override
	public IRaungDisasm autoMax(boolean auto) {
		this.autoMax = auto;
		return this;
	}

	@Override
	public IRaungDisasm autoFrames(boolean auto) {
		this.autoFrames = auto;
		return this;
	}

	@Override
	public IRaungDisasm autoSwitch(boolean auto) {
		this.autoSwitch = auto;
		return this;
	}

	public boolean isSaveCatchNumber() {
		return saveCatchNumber;
	}

	public List<Path> getInputs() {
		return inputs;
	}

	public Path getOutput() {
		return output;
	}

	public boolean isIgnoreDebugInfo() {
		return ignoreDebugInfo;
	}

	public boolean isAutoMax() {
		return autoMax;
	}

	public boolean isAutoFrames() {
		return autoFrames;
	}

	public boolean isAutoSwitch() {
		return autoSwitch;
	}

	@Override
	public void execute() {
		RaungDisasmExecutor.process(this);
	}

	@Override
	public String executeForSingleClass(Path input) {
		return RaungDisasmExecutor.processSingleClass(this, input);
	}

	@Override
	public String executeForInputStream(InputStream input) {
		try {
			return RaungDisasmExecutor.processInputStream(this, input);
		} catch (Exception e) {
			throw new RaungDisasmException("Failed to process input stream", e);
		}
	}

	@Override
	public String executeForBytes(byte[] bytes) {
		try {
			return RaungDisasmExecutor.processBytes(this, bytes);
		} catch (Exception e) {
			throw new RaungDisasmException("Failed to process input bytes", e);
		}
	}

	@Override
	public String toString() {
		return "RaungDisasmBuilder{"
				+ "inputs=" + inputs
				+ ", output=" + output
				+ ", ignoreDebugInfo=" + ignoreDebugInfo
				+ ", saveCatchNumber=" + saveCatchNumber
				+ ", autoMax=" + autoMax
				+ ", autoFrames=" + autoFrames
				+ ", autoSwitch=" + autoSwitch
				+ '}';
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/RaungDisasmExecutor.java`:

```java
package io.github.skylot.raung.disasm.impl;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.List;
import java.util.Objects;

import org.objectweb.asm.ClassReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.github.skylot.raung.common.utils.FileUtils;
import io.github.skylot.raung.common.utils.ZipUtils;
import io.github.skylot.raung.disasm.impl.utils.RaungDisasmException;
import io.github.skylot.raung.disasm.impl.utils.ValidateDisasmArgs;
import io.github.skylot.raung.disasm.impl.visitors.RaungClassVisitor;

public class RaungDisasmExecutor {
	private static final Logger LOG = LoggerFactory.getLogger(RaungDisasmExecutor.class);

	public static void process(RaungDisasmBuilder args) {
		ValidateDisasmArgs.process(args);
		processFiles(args);
	}

	public static String processSingleClass(RaungDisasmBuilder args, Path clsFile) {
		FileUtils.checkInputFile(clsFile);
		ValidateDisasmArgs.processOptions(args);
		return runForSingleClass(args, clsFile).getResult();
	}

	public static String processInputStream(RaungDisasmBuilder args, InputStream in) throws IOException {
		ValidateDisasmArgs.processOptions(args);
		return runForInputStream(args, in).getResult();
	}

	public static String processBytes(RaungDisasmBuilder args, byte[] bytes) {
		ValidateDisasmArgs.processOptions(args);
		return execute(args, new ClassReader(bytes)).getResult();
	}

	private static RaungClassVisitor runForSingleClass(RaungDisasmBuilder args, Path clsFile) {
		try (InputStream in = new BufferedInputStream(Files.newInputStream(clsFile, StandardOpenOption.READ))) {
			return runForInputStream(args, in);
		} catch (IOException e) {
			throw new RaungDisasmException("Failed to process class file: " + clsFile, e);
		}
	}

	private static RaungClassVisitor runForInputStream(RaungDisasmBuilder args, InputStream in) throws IOException {
		return execute(args, new ClassReader(in));
	}

	private static RaungClassVisitor execute(RaungDisasmBuilder args, ClassReader reader) {
		RaungClassVisitor visitor = new RaungClassVisitor(args);
		reader.accept(visitor, 0); // TODO: add option for skip frames (if '.auto frames' will be used)
		return visitor;
	}

	private static void processFiles(RaungDisasmBuilder args) {
		Path output = args.getOutput();
		boolean isOutputRaungFile = Objects.equals(FileUtils.getExt(output), "raung");
		List<Path> inputFiles = FileUtils.expandDirs(args.getInputs());
		if (inputFiles.size() == 1 && inputFiles.get(0).getFileName().toString().endsWith(".class")) {
			// single class file as input
			Path inputFile = inputFiles.get(0);
			RaungClassVisitor rcv = runForSingleClass(args, inputFile);
			if (output == null) {
				// save single class disasm to '.raung' file with same base name
				String fileName = inputFile.getFileName().toString();
				String baseFileName = fileName.substring(0, fileName.length() - 6) + ".raung";
				Path raungFile = inputFile.toAbsolutePath().getParent().resolve(baseFileName);
				LOG.info("Saving to {}", raungFile);
				FileUtils.saveFile(raungFile, rcv.getResult());
				return;
			}
			if (isOutputRaungFile) {
				FileUtils.saveFile(output, rcv.getResult());
				return;
			}
			// output is directory
			saveResult(args, rcv);
			return;
		}
		// save multiple results to directory
		if (isOutputRaungFile || Files.isRegularFile(output)) {
			throw new RaungDisasmException("Expect output to be directory, got file: " + output);
		}
		for (Path input : inputFiles) {
			runForFile(args, input);
		}
	}

	private static void runForFile(RaungDisasmBuilder args, Path inputFile) {
		String fileName = inputFile.getFileName().toString();
		if (fileName.endsWith(".class")) {
			saveResult(args, runForSingleClass(args, inputFile));
			return;
		}
		if (fileName.endsWith(".jar") || fileName.endsWith(".zip")) {
			runForZip(args, inputFile);
		}
	}

	private static void runForZip(RaungDisasmBuilder args, Path zipPath) {
		Path resDir = args.getOutput().resolve("resources");
		ZipUtils.visitZipEntries(zipPath.toFile(), (zip, entry) -> {
			String entryName = entry.getName();
			if (entryName.endsWith(".class")) {
				try (InputStream in = ZipUtils.getInputStreamForEntry(zip, entry)) {
					saveResult(args, runForInputStream(args, in));
				} catch (Exception e) {
					LOG.error("Error process zip entry: {}", entry.getName(), e);
				}
			} else if (!entry.isDirectory()) {
				// save resources
				try (InputStream in = ZipUtils.getInputStreamForEntry(zip, entry)) {
					FileUtils.saveInputStream(resDir, entryName, in);
				} catch (Exception e) {
					LOG.error("Error process zip entry: {}", entry.getName(), e);
				}
			}
			return null;
		});
	}

	private static void saveResult(RaungDisasmBuilder args, RaungClassVisitor rcv) {
		String fileName = rcv.getClsFullName().replace('/', File.separatorChar) + ".raung";
		FileUtils.saveFile(args.getOutput(), fileName, rcv.getResult());
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/utils/ListUtils.java`:

```java
package io.github.skylot.raung.disasm.impl.utils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.jetbrains.annotations.Nullable;

public class ListUtils {

	public static <T> List<T> fromNullable(@Nullable List<T> list) {
		return list == null ? Collections.emptyList() : list;
	}

	public static <T> List<T> addToNullable(@Nullable List<T> list, T obj) {
		List<T> result = list == null ? new ArrayList<>() : list;
		result.add(obj);
		return result;
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/utils/RaungDisasmException.java`:

```java
package io.github.skylot.raung.disasm.impl.utils;

public class RaungDisasmException extends RuntimeException {
	public RaungDisasmException(String message) {
		super(message);
	}

	public RaungDisasmException(String message, Throwable cause) {
		super(message, cause);
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/utils/RaungTypes.java`:

```java
package io.github.skylot.raung.disasm.impl.utils;

import java.lang.reflect.Array;

import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Type;

import io.github.skylot.raung.common.asm.HandleTag;

public class RaungTypes {

	public static String format(Object value) {
		if (value == null) {
			return "null";
		}
		if (value instanceof String) {
			return StringDisasmUtils.escapeString(((String) value));
		}
		if (value instanceof Type) {
			return formatType(value);
		}
		if (value instanceof Number) {
			if (value instanceof Integer) {
				return value.toString();
			}
			if (value instanceof Float) {
				return formatFloat((Float) value);
			}
			if (value instanceof Long) {
				return String.valueOf(value) + 'L';
			}
			if (value instanceof Double) {
				return formatDouble((Double) value);
			}
			return value.toString();
		}
		if (value.getClass().isArray()) {
			return formatConstArray(value);
		}
		if (value instanceof Boolean) {
			return value.toString();
		}
		if (value instanceof Handle) {
			return formatHandle(((Handle) value));
		}
		if (value instanceof ConstantDynamic) {
			return "ConstantDynamic:" + value;
		}
		throw new RaungDisasmException("Unexpected type of constant value: " + value
				+ ", class: " + value.getClass().getName());
	}

	private static String formatType(Object value) {
		Type type = (Type) value;
		switch (type.getSort()) {
			case Type.OBJECT:
				return type.getDescriptor();
			case Type.ARRAY:
				return type.toString();
			case Type.METHOD:
				return ".methodtype " + type.getDescriptor();
			default:
				throw new RaungDisasmException("Unexpected type of constant value: " + value
						+ ", class: " + value.getClass().getName());
		}
	}

	private static String formatConstArray(Object value) {
		int length = Array.getLength(value);
		if (length == 0) {
			return "{ }";
		}
		StringBuilder sb = new StringBuilder();
		sb.append("{ ").append(Array.get(value, 0));
		for (int i = 1; i < length; i++) {
			sb.append(", ").append(Array.get(value, i));
		}
		sb.append(" }");
		return sb.toString();
	}

	private static String formatDouble(double value) {
		if (Double.isNaN(value)) {
			return "Double.NaN";
		}
		if (value == Double.POSITIVE_INFINITY) {
			return "Double.POSITIVE_INFINITY";
		}
		if (value == Double.NEGATIVE_INFINITY) {
			return "Double.NEGATIVE_INFINITY";
		}
		if (value == Double.MIN_VALUE) {
			return "Double.MIN_VALUE";
		}
		if (value == Double.MAX_VALUE) {
			return "Double.MAX_VALUE";
		}
		return Double.toString(value);
	}

	private static String formatFloat(float value) {
		if (Float.isNaN(value)) {
			return "Float.NaN";
		}
		if (value == Float.POSITIVE_INFINITY) {
			return "Float.POSITIVE_INFINITY";
		}
		if (value == Float.NEGATIVE_INFINITY) {
			return "Float.NEGATIVE_INFINITY";
		}
		if (value == Float.MIN_VALUE) {
			return "Float.MIN_VALUE";
		}
		if (value == Float.MAX_VALUE) {
			return "Float.MAX_VALUE";
		}
		return Float.toString(value) + 'f';
	}

	public static String formatHandle(Handle handle) {
		return ".handle " + HandleTag.getByValue(handle.getTag()).getName()
				+ " " + handle.getOwner() + ' ' + handle.getName() + ' ' + handle.getDesc();
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/utils/RaungWriter.java`:

```java
package io.github.skylot.raung.disasm.impl.utils;

import io.github.skylot.raung.common.Directive;

@SuppressWarnings("UnusedReturnValue")
public class RaungWriter {
	public static final String NL = System.lineSeparator();
	public static final String INDENT_STR = "  ";

	private final StringBuilder sb = new StringBuilder();
	private String indentStr = "";
	private int indent = 0;

	public RaungWriter newLine() {
		sb.append(NL);
		return this;
	}

	public RaungWriter startLine() {
		sb.append(NL);
		sb.append(indentStr);
		return this;
	}

	public RaungWriter startLine(String line) {
		startLine();
		sb.append(line);
		return this;
	}

	public RaungWriter startLine(Directive directive) {
		startLine();
		add(directive);
		return this;
	}

	public RaungWriter add(Directive directive) {
		sb.append(directive.token());
		sb.append(' ');
		return this;
	}

	public RaungWriter add(String str) {
		sb.append(str);
		return this;
	}

	public RaungWriter addString(String str) {
		sb.append('"');
		sb.append(str);
		sb.append('"');
		return this;
	}

	public RaungWriter add(int number) {
		sb.append(number);
		return this;
	}

	public RaungWriter add(char ch) {
		sb.append(ch);
		return this;
	}

	public RaungWriter space() {
		sb.append(' ');
		return this;
	}

	public void add(RaungWriter rw) {
		sb.append(rw.getCode());
	}

	public int getIndent() {
		return indent;
	}

	public RaungWriter setIndent(int indentValue) {
		indent = indentValue;
		indentStr = buildIndentStr();
		return this;
	}

	public RaungWriter increaseIndent() {
		indent++;
		indentStr = buildIndentStr();
		return this;
	}

	public RaungWriter decreaseIndent() {
		indent--;
		indentStr = buildIndentStr();
		return this;
	}

	private String buildIndentStr() {
		switch (indent) {
			case 0:
				return "";
			case 1:
				return INDENT_STR;
			case 2:
				return INDENT_STR + INDENT_STR;
			default:
				StringBuilder indSb = new StringBuilder(INDENT_STR.length() * indent);
				for (int i = 0; i < indent; i++) {
					indSb.append(INDENT_STR);
				}
				return indSb.toString();
		}
	}

	public RaungWriter clear() {
		sb.setLength(0);
		return this;
	}

	public String getCode() {
		return sb.toString();
	}

	@Override
	public String toString() {
		return getCode();
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/utils/StringDisasmUtils.java`:

```java
package io.github.skylot.raung.disasm.impl.utils;

import org.jetbrains.annotations.Nullable;

public class StringDisasmUtils {

	public static String escapeString(String str) {
		int len = str.length();
		if (len == 0) {
			return "\"\"";
		}
		StringBuilder sb = new StringBuilder();
		sb.append('"');
		int offset = 0;
		while (offset < len) {
			int codePoint = str.codePointAt(offset);
			processCharInsideString(codePoint, sb);
			offset += Character.charCount(codePoint);
		}
		sb.append('"');
		return sb.toString();
	}

	private static void processCharInsideString(int codePoint, StringBuilder sb) {
		String str = getSpecialStringForChar(codePoint);
		if (str != null) {
			sb.append(str);
			return;
		}
		if (isPrintable(codePoint)) {
			sb.appendCodePoint(codePoint);
		} else {
			sb.append("\\u").append(String.format("%04x", codePoint));
		}
	}

	private static boolean isPrintable(int codePoint) {
		if (Character.isISOControl(codePoint)) {
			return false;
		}
		if (Character.isWhitespace(codePoint)) {
			// don't print whitespaces other than standard one
			return codePoint == ' ';
		}
		switch (Character.getType(codePoint)) {
			case Character.CONTROL:
			case Character.FORMAT:
			case Character.PRIVATE_USE:
			case Character.SURROGATE:
			case Character.UNASSIGNED:
				return false;
		}
		return true;
	}

	@Nullable
	private static String getSpecialStringForChar(int c) {
		switch (c) {
			case '\n':
				return "\\n";
			case '\r':
				return "\\r";
			case '\t':
				return "\\t";
			case '\b':
				return "\\b";
			case '\f':
				return "\\f";
			case '\'':
				return "'";
			case '"':
				return "\\\"";
			case '\\':
				return "\\\\";

			default:
				return null;
		}
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/utils/TypeRefUtils.java`:

```java
package io.github.skylot.raung.disasm.impl.utils;

import org.objectweb.asm.TypePath;
import org.objectweb.asm.TypeReference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.github.skylot.raung.common.asm.TypeRef;

public class TypeRefUtils {
	private static final Logger LOG = LoggerFactory.getLogger(TypeRefUtils.class);

	public static String formatPath(int typeRef, TypePath typePath) {
		TypeReference typeReference = new TypeReference(typeRef);
		int sort = typeReference.getSort();
		TypeRef raungTypeRef = TypeRef.getByValue(sort);
		if (raungTypeRef == null) {
			String sortStr = rawSortFormat(typeReference, sort);
			LOG.warn("TODO: Missing type reference info: {}", sortStr);
			return sortStr;
		}
		StringBuilder sb = new StringBuilder(raungTypeRef.getName());
		appendArgs(raungTypeRef, typeReference, sb);
		if (typePath != null) {
			sb.append(' ').append(typePath);
		}
		return sb.toString();
	}

	private static void appendArgs(TypeRef refType, TypeReference ref, StringBuilder sb) {
		switch (refType.getFormat()) {
			case NO_ARGS:
				break;
			case TYPE_PARAM_INDEX:
				sb.append(' ').append(ref.getTypeParameterIndex());
				break;
			case TYPE_PARAM_BOUND_INDEX:
				sb.append(' ').append(ref.getTypeParameterIndex()).append(' ').append(ref.getTypeParameterBoundIndex());
				break;
			case SUPER_TYPE_INDEX:
				sb.append(' ').append(ref.getSuperTypeIndex());
				break;
			case FORMAL_PARAM_INDEX:
				sb.append(' ').append(ref.getFormalParameterIndex());
				break;
			case EXCEPTION_INDEX:
				sb.append(' ').append(ref.getExceptionIndex());
				break;
			case TRY_CATCH_BLOCK_INDEX:
				sb.append(' ').append(ref.getTryCatchBlockIndex());
				break;
			case TYPE_ARGUMENT_INDEX:
				sb.append(' ').append(ref.getTypeArgumentIndex());
				break;
			default:
				throw new RaungDisasmException("Unsupported type reference sort: " + refType);
		}
	}

	@Deprecated
	private static String rawSortFormat(TypeReference typeReference, int sort) {
		switch (sort) {
			case TypeReference.CLASS_TYPE_PARAMETER:
				return "CLASS_TYPE_PARAMETER " + typeReference.getTypeParameterIndex();
			case TypeReference.METHOD_TYPE_PARAMETER:
				return "METHOD_TYPE_PARAMETER " + typeReference.getTypeParameterIndex();
			case TypeReference.CLASS_EXTENDS:
				return "CLASS_EXTENDS " + typeReference.getSuperTypeIndex();
			case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
				return "CLASS_TYPE_PARAMETER_BOUND " + typeReference.getTypeParameterIndex()
						+ " " + typeReference.getTypeParameterBoundIndex();
			case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
				return "METHOD_TYPE_PARAMETER_BOUND " + typeReference.getTypeParameterIndex()
						+ " " + typeReference.getTypeParameterBoundIndex();
			case TypeReference.FIELD:
				return "FIELD";
			case TypeReference.METHOD_RETURN:
				return "METHOD_RETURN";
			case TypeReference.METHOD_RECEIVER:
				return "METHOD_RECEIVER";
			case TypeReference.METHOD_FORMAL_PARAMETER:
				return "METHOD_FORMAL_PARAMETER " + typeReference.getFormalParameterIndex();
			case TypeReference.THROWS:
				return "THROWS " + typeReference.getExceptionIndex();
			case TypeReference.LOCAL_VARIABLE:
				return "LOCAL_VARIABLE";
			case TypeReference.RESOURCE_VARIABLE:
				return "RESOURCE_VARIABLE";
			case TypeReference.EXCEPTION_PARAMETER:
				return "EXCEPTION_PARAMETER " + typeReference.getTryCatchBlockIndex();
			case TypeReference.INSTANCEOF:
				return "INSTANCEOF";
			case TypeReference.NEW:
				return "NEW";
			case TypeReference.CONSTRUCTOR_REFERENCE:
				return "CONSTRUCTOR_REFERENCE";
			case TypeReference.METHOD_REFERENCE:
				return "METHOD_REFERENCE";
			case TypeReference.CAST:
				return "CAST " + typeReference.getTypeArgumentIndex();
			case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
				return "CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT " + typeReference.getTypeArgumentIndex();
			case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
				return "METHOD_INVOCATION_TYPE_ARGUMENT " + typeReference.getTypeArgumentIndex();
			case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
				return "CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT " + typeReference.getTypeArgumentIndex();
			case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
				return "METHOD_REFERENCE_TYPE_ARGUMENT " + typeReference.getTypeArgumentIndex();
			default:
				throw new RaungDisasmException("Unexpected type reference sort: " + sort);
		}
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/utils/ValidateDisasmArgs.java`:

```java
package io.github.skylot.raung.disasm.impl.utils;

import java.nio.file.Files;
import java.nio.file.Path;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.github.skylot.raung.disasm.impl.RaungDisasmBuilder;

public class ValidateDisasmArgs {
	private static final Logger LOG = LoggerFactory.getLogger(ValidateDisasmArgs.class);

	public static void process(RaungDisasmBuilder args) {
		if (args.getInputs().isEmpty()) {
			throw new RaungDisasmException("Empty inputs");
		}
		for (Path input : args.getInputs()) {
			if (!Files.exists(input)) {
				throw new RaungDisasmException("Input not found: " + input.toAbsolutePath());
			}
		}
		processOptions(args);
	}

	public static void processOptions(RaungDisasmBuilder args) {
		if (args.isAutoFrames()) {
			args.autoMax(true);
		}
		LOG.trace("Effective args: {}", args);
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/visitors/RaungAnnotationVisitor.java`:

```java
package io.github.skylot.raung.disasm.impl.visitors;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.TypePath;

import io.github.skylot.raung.common.AnnotationType;
import io.github.skylot.raung.common.Directive;
import io.github.skylot.raung.disasm.impl.utils.RaungTypes;
import io.github.skylot.raung.disasm.impl.utils.RaungWriter;
import io.github.skylot.raung.disasm.impl.utils.TypeRefUtils;

public class RaungAnnotationVisitor extends AnnotationVisitor {

	public static RaungAnnotationVisitor buildAnnotation(RaungClassVisitor clsVisitor, String descriptor, boolean visible) {
		RaungWriter writer = clsVisitor.getWriter();
		RaungAnnotationVisitor annotationVisitor = new RaungAnnotationVisitor(clsVisitor, writer, AnnotationType.NORMAL);
		writer.startLine(Directive.ANNOTATION).add(visible ? "runtime" : "build").space().add(descriptor);
		writer.increaseIndent();
		return annotationVisitor;
	}

	public static AnnotationVisitor buildTypeAnnotation(RaungClassVisitor clsVisitor,
			int typeRef, TypePath typePath, String descriptor, boolean visible) {
		RaungWriter writer = clsVisitor.getWriter();
		RaungAnnotationVisitor annotationVisitor = new RaungAnnotationVisitor(clsVisitor, writer, AnnotationType.TYPE);
		writer.startLine(Directive.TYPE_ANNOTATION).add(visible ? "runtime" : "build").space().add(descriptor);
		writer.increaseIndent();
		String ref = TypeRefUtils.formatPath(typeRef, typePath);
		if (!ref.isEmpty()) {
			writer.startLine(".ref").space().add(ref);
		}
		return annotationVisitor;
	}

	public static AnnotationVisitor buildParamAnnotation(RaungClassVisitor clsVisitor, int parameter, String descriptor, boolean visible) {
		RaungWriter writer = clsVisitor.getWriter();
		RaungAnnotationVisitor av = new RaungAnnotationVisitor(clsVisitor, writer, AnnotationType.PARAM);
		writer.startLine(Directive.PARAM_ANNOTATION).add(parameter).space()
				.add(visible ? "runtime" : "build").space().add(descriptor);
		writer.increaseIndent();
		return av;
	}

	public static AnnotationVisitor buildDefaultValueVisitor(RaungClassVisitor classVisitor) {
		RaungWriter writer = classVisitor.getWriter();
		RaungAnnotationVisitor av = new RaungAnnotationVisitor(classVisitor, writer, AnnotationType.DEFAULT);
		writer.startLine(Directive.ANNOTATION_DEFAULT_VALUE);
		writer.increaseIndent();
		return av;
	}

	public static RaungAnnotationVisitor buildInsnAnnotation(RaungClassVisitor clsVisitor, RaungWriter writer,
			int typeRef, TypePath typePath, String descriptor, boolean visible) {
		RaungAnnotationVisitor annotationVisitor = new RaungAnnotationVisitor(clsVisitor, writer, AnnotationType.INSN);
		writer.startLine(Directive.INSN_ANNOTATION).add(visible ? "runtime" : "build").space().add(descriptor);
		writer.increaseIndent();
		String ref = TypeRefUtils.formatPath(typeRef, typePath);
		if (!ref.isEmpty()) {
			writer.startLine(".ref").space().add(ref);
		}
		return annotationVisitor;
	}

	private final RaungClassVisitor clsVisitor;
	private final AnnotationType type;
	private final RaungWriter writer;

	private RaungAnnotationVisitor(RaungClassVisitor clsVisitor, RaungWriter writer, AnnotationType type) {
		super(clsVisitor.getApi());
		this.clsVisitor = clsVisitor;
		this.writer = writer;
		this.type = type;
	}

	@Override
	public void visit(@Nullable String name, Object value) {
		startAssign(name).add(RaungTypes.format(value));
	}

	@Override
	public void visitEnum(@Nullable String name, String descriptor, String value) {
		startAssign(name).add(Directive.ENUM).add(descriptor).space().add(value);
	}

	@Override
	public AnnotationVisitor visitAnnotation(@Nullable String name, String descriptor) {
		startAssign(name)
				.add('.').add(AnnotationType.SUB.getName()).space().add(descriptor)
				.increaseIndent();
		return new RaungAnnotationVisitor(this.clsVisitor, writer, AnnotationType.SUB);
	}

	@Override
	public AnnotationVisitor visitArray(@Nullable String name) {
		startAssign(name)
				.add('.').add(AnnotationType.ARRAY.getName())
				.increaseIndent();
		return new RaungAnnotationVisitor(this.clsVisitor, writer, AnnotationType.ARRAY);
	}

	@Override
	public void visitEnd() {
		writer.decreaseIndent()
				.startLine(".end ").add(this.type.getName());
	}

	private RaungWriter startAssign(String name) {
		writer.startLine();
		if (name != null) {
			writer.add(name).add(" = ");
		}
		return writer;
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/visitors/RaungClassVisitor.java`:

```java
package io.github.skylot.raung.disasm.impl.visitors;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.RecordComponentVisitor;
import org.objectweb.asm.TypePath;

import io.github.skylot.raung.common.Directive;
import io.github.skylot.raung.common.RaungAccessFlags;
import io.github.skylot.raung.common.utils.JavaVersion;
import io.github.skylot.raung.disasm.impl.RaungDisasmBuilder;
import io.github.skylot.raung.disasm.impl.utils.RaungTypes;
import io.github.skylot.raung.disasm.impl.utils.RaungWriter;

import static io.github.skylot.raung.common.RaungAccessFlags.Scope.CLASS;
import static io.github.skylot.raung.common.RaungAccessFlags.Scope.FIELD;
import static io.github.skylot.raung.common.RaungAccessFlags.Scope.METHOD;

public class RaungClassVisitor extends ClassVisitor {

	private final RaungWriter writer = new RaungWriter();
	private final RaungDisasmBuilder args;

	private String clsFullName;

	public RaungClassVisitor(RaungDisasmBuilder args) {
		super(Opcodes.ASM9);
		this.args = args;
	}

	@Override
	public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
		writer.add(Directive.VERSION.token()).space()
				.add(JavaVersion.formatVersionNumber(version))
				.add("  # ").add(JavaVersion.getNameStr(version));
		writer.startLine(Directive.CLASS).add(RaungAccessFlags.format(access, CLASS)).add(name);
		if (!superName.equals("java/lang/Object")) {
			writer.startLine(Directive.SUPER).add(superName);
		}
		for (String iface : interfaces) {
			writer.startLine(Directive.IMPLEMENTS).add(iface);
		}
		if (signature != null) {
			writer.startLine(Directive.SIGNATURE).add(signature);
		}
		this.clsFullName = name;

		if (args.isAutoFrames()) {
			writer.startLine(".auto frames");
		} else if (args.isAutoMax()) {
			writer.startLine(".auto maxs");
		}
	}

	@Override
	public void visitSource(String source, String debug) {
		writer.startLine(Directive.SOURCE).add('"').add(source).add('"');
	}

	@Override
	public ModuleVisitor visitModule(String name, int access, String version) {
		writer.startLine("# TODO: module");
		return null;
	}

	@Override
	public void visitNestHost(String nestHost) {
		writer.newLine().startLine(Directive.NEST).add("host").space().add(nestHost);
	}

	@Override
	public void visitNestMember(String nestMember) {
		writer.newLine().startLine(Directive.NEST).add("member").space().add(nestMember);
	}

	@Override
	public void visitOuterClass(String owner, String name, String descriptor) {
		writer.newLine()
				.startLine(Directive.OUTERCLASS)
				.add(owner).space().add(name).space().add(descriptor);
	}

	@Override
	public void visitInnerClass(String name, String outerName, String innerName, int access) {
		writer.startLine()
				.startLine(Directive.INNERCLASS)
				.add(RaungAccessFlags.format(access, CLASS))
				.add(innerName).space()
				.add(outerName);
		if (!name.equals(clsFullName)) {
			writer.space().add(name);
		}
	}

	@Override
	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
		return RaungAnnotationVisitor.buildAnnotation(this, descriptor, visible);
	}

	@Override
	public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {
		return RaungAnnotationVisitor.buildTypeAnnotation(this, typeRef, typePath, descriptor, visible);
	}

	@Override
	public void visitAttribute(Attribute attribute) {
		writer.startLine("# TODO: class attribute: " + attribute);
	}

	@Override
	public void visitPermittedSubclass(String permittedSubclass) {
		writer.startLine("# TODO: class permitted subclass: " + permittedSubclass);
	}

	@Override
	public RecordComponentVisitor visitRecordComponent(String name, String descriptor, String signature) {
		writer.startLine("# TODO: record component: " + name + " " + descriptor + " " + signature);
		return null;
	}

	@Override
	public FieldVisitor visitField(int access, String name, String descriptor, @Nullable String signature, Object value) {
		writer.startLine()
				.startLine(Directive.FIELD)
				.add(RaungAccessFlags.format(access, FIELD))
				.add(name).space()
				.add(descriptor);
		if (value != null) {
			writer.add(" = ").add(RaungTypes.format(value));
		}
		boolean closeField = false;
		writer.increaseIndent();
		if (signature != null) {
			writer.startLine(Directive.SIGNATURE).add(signature);
			closeField = true;
		}
		return new RaungFieldVisitor(this, closeField);
	}

	@Override
	public MethodVisitor visitMethod(int access, String name, String descriptor,
			@Nullable String signature, @Nullable String[] exceptions) {
		writer.newLine()
				.startLine(Directive.METHOD)
				.add(RaungAccessFlags.format(access, METHOD))
				.add(name).add(descriptor)
				.setIndent(2);
		if (exceptions != null) {
			for (String exc : exceptions) {
				writer.startLine(Directive.THROW).add(exc);
			}
		}
		if (signature != null) {
			writer.startLine(Directive.SIGNATURE).add(signature);
		}
		return new RaungMethodVisitor(this, name + descriptor);
	}

	@Override
	public void visitEnd() {
		writer.newLine();
	}

	public int getApi() {
		return api;
	}

	public RaungWriter getWriter() {
		return writer;
	}

	public RaungDisasmBuilder getArgs() {
		return args;
	}

	public String getClsFullName() {
		return clsFullName;
	}

	public String getResult() {
		return writer.getCode();
	}

	@Override
	public String toString() {
		return clsFullName;
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/visitors/RaungFieldVisitor.java`:

```java
package io.github.skylot.raung.disasm.impl.visitors;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.TypePath;

import io.github.skylot.raung.disasm.impl.utils.RaungWriter;

public class RaungFieldVisitor extends FieldVisitor {
	private final RaungWriter writer;
	private final RaungClassVisitor clsVisitor;
	private boolean closeField;

	public RaungFieldVisitor(RaungClassVisitor clsVisitor, boolean closeField) {
		super(clsVisitor.getApi());
		this.clsVisitor = clsVisitor;
		this.writer = clsVisitor.getWriter();
		this.closeField = closeField;
	}

	@Override
	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
		this.closeField = true;
		return RaungAnnotationVisitor.buildAnnotation(clsVisitor, descriptor, visible);
	}

	@Override
	public AnnotationVisitor visitTypeAnnotation(int typeRef, @Nullable TypePath typePath, String descriptor, boolean visible) {
		this.closeField = true;
		return RaungAnnotationVisitor.buildTypeAnnotation(clsVisitor, typeRef, typePath, descriptor, visible);
	}

	@Override
	public void visitAttribute(Attribute attribute) {
		this.closeField = true;
		writer.startLine("# TODO: field attribute: " + attribute);
	}

	@Override
	public void visitEnd() {
		writer.decreaseIndent();
		if (closeField) {
			writer.startLine(".end field");
		}
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/visitors/RaungMethodVisitor.java`:

```java
package io.github.skylot.raung.disasm.impl.visitors;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;

import io.github.skylot.raung.common.Directive;
import io.github.skylot.raung.common.JavaOpCodes;
import io.github.skylot.raung.common.RaungAccessFlags;
import io.github.skylot.raung.common.asm.StackType;
import io.github.skylot.raung.disasm.impl.utils.RaungDisasmException;
import io.github.skylot.raung.disasm.impl.utils.RaungTypes;
import io.github.skylot.raung.disasm.impl.utils.RaungWriter;
import io.github.skylot.raung.disasm.impl.utils.TypeRefUtils;
import io.github.skylot.raung.disasm.impl.visitors.data.LabelData;
import io.github.skylot.raung.disasm.impl.visitors.data.LocalVar;
import io.github.skylot.raung.disasm.impl.visitors.data.TryCatchBlock;

public class RaungMethodVisitor extends MethodVisitor {
	private final RaungClassVisitor classVisitor;
	private final RaungWriter writer;
	private final String mthShortId;

	private final RaungWriter tempWriter = new RaungWriter();

	private final List<String> insns = new ArrayList<>();
	private final Map<Label, LabelData> labels = new IdentityHashMap<>();
	private final Map<Integer, RaungWriter> insnAttachments = new HashMap<>();

	private int catchCount;

	public RaungMethodVisitor(RaungClassVisitor classVisitor, String mthShortId) {
		super(classVisitor.getApi());
		this.classVisitor = classVisitor;
		this.writer = classVisitor.getWriter();
		this.mthShortId = mthShortId;
	}

	@Override
	public void visitParameter(String name, int access) {
		writer.startLine(".param")
				.space().add(RaungAccessFlags.format(access, RaungAccessFlags.Scope.PARAM))
				.add(name);
	}

	@Override
	public AnnotationVisitor visitAnnotationDefault() {
		return RaungAnnotationVisitor.buildDefaultValueVisitor(this.classVisitor);
	}

	@Override
	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
		return RaungAnnotationVisitor.buildAnnotation(this.classVisitor, descriptor, visible);
	}

	@Override
	public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {
		return RaungAnnotationVisitor.buildTypeAnnotation(this.classVisitor, typeRef, typePath, descriptor, visible);
	}

	@Override
	public AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {
		// attach annotation to last instruction
		int insn = insns.size() - 1;
		if (insn < 0) {
			throw new RaungDisasmException("No instructions to attach annotation");
		}
		RaungWriter rw = insnAttachments.computeIfAbsent(insn, i -> new RaungWriter().setIndent(writer.getIndent()));
		return RaungAnnotationVisitor.buildInsnAnnotation(classVisitor, rw, typeRef, typePath, descriptor, visible);
	}

	@Override
	public void visitAnnotableParameterCount(int parameterCount, boolean visible) {
		// ignore
	}

	@Override
	public AnnotationVisitor visitParameterAnnotation(int parameter, String descriptor, boolean visible) {
		return RaungAnnotationVisitor.buildParamAnnotation(this.classVisitor, parameter, descriptor, visible);
	}

	@Override
	public void visitAttribute(Attribute attribute) {
		// TODO
		writer.startLine("# attribute " + attribute);
	}

	@Override
	public void visitCode() {
	}

	@Override
	public void visitFrame(int type, int numLocal, Object[] local, int numStack, Object[] stack) {
		if (classVisitor.getArgs().isAutoFrames()) {
			return;
		}
		RaungWriter rw = tmpWriter();
		rw.add(Directive.STACK);
		switch (type) {
			case Opcodes.F_SAME:
				rw.add("same");
				break;

			case Opcodes.F_SAME1:
				rw.add("same1").space().add(formatStackType(stack[0]));
				break;

			case Opcodes.F_CHOP:
				rw.add("chop").space().add(numLocal);
				break;

			case Opcodes.F_APPEND:
				rw.add("append");
				rw.setIndent(writer.getIndent() + 2);
				for (int i = 0; i < numLocal; i++) {
					rw.startLine(formatStackType(local[i]));
				}
				rw.setIndent(writer.getIndent());
				rw.startLine(".end stack");
				break;

			case Opcodes.F_FULL:
				rw.add("full");
				writeCompleteFrame(rw, numLocal, local, numStack, stack);
				break;

			case Opcodes.F_NEW:
				rw.add("new");
				writeCompleteFrame(rw, numLocal, local, numStack, stack);
				break;

			default:
				throw new RaungDisasmException("Unexpected frame type: " + type);
		}
		insns.add(rw.getCode());
	}

	private void writeCompleteFrame(RaungWriter rw, int numLocal, Object[] local, int numStack, Object[] stack) {
		rw.setIndent(writer.getIndent() + 2);
		for (int i = 0; i < numStack; i++) {
			rw.startLine("stack ").add(i).space().add(formatStackType(stack[i]));
		}
		for (int i = 0; i < numLocal; i++) {
			rw.startLine("local ").add(i).space().add(formatStackType(local[i]));
		}
		rw.setIndent(writer.getIndent());
		rw.startLine(".end stack");
	}

	private String formatStackType(Object value) {
		if (value instanceof String) {
			return (String) value;
		}
		if (value instanceof Integer) {
			StackType type = StackType.getByValue((Integer) value);
			if (type == null) {
				throw new RaungDisasmException("Unknown primitive stack type: " + value);
			}
			return type.getName();
		}
		if (value instanceof Label) {
			Label lbl = (Label) value;
			LabelData labelData = getLabelData(lbl);
			labelData.addUse();
			return "Uninitialized " + labelData.getName();
		}
		throw new IllegalArgumentException("Unknown stack type: " + value + ", class: " + value.getClass().getName());
	}

	@Override
	public void visitInsn(int opcode) {
		insns.add(JavaOpCodes.getName(opcode));
	}

	@Override
	public void visitIntInsn(int opcode, int operand) {
		insns.add(formatInsn(opcode).add(operand).getCode());
	}

	@Override
	public void visitVarInsn(int opcode, int var) {
		insns.add(formatInsn(opcode).add(var).getCode());
	}

	@Override
	public void visitTypeInsn(int opcode, String type) {
		insns.add(formatInsn(opcode).add(type).getCode());
	}

	@Override
	public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {
		insns.add(formatInsn(opcode).add(owner).space().add(name).space().add(descriptor).getCode());
	}

	@Override
	public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
		RaungWriter rw = formatInsn(opcode);
		if (isInterface && opcode != Opcodes.INVOKEINTERFACE) {
			rw.add("interface ");
		}
		rw.add(owner).space().add(name).space().add(descriptor);
		insns.add(rw.getCode());
	}

	@Override
	public void visitInvokeDynamicInsn(String name, String descriptor, Handle mthHandle, Object... args) {
		RaungWriter rw = tmpWriter().add("invokedynamic").space().add(name).space().add(descriptor);
		rw.setIndent(writer.getIndent() + 2);
		rw.startLine(RaungTypes.formatHandle(mthHandle));
		for (int i = 0; i < args.length; i++) {
			rw.startLine(".arg").space().add(i).space().add(RaungTypes.format(args[i]));
		}
		rw.setIndent(writer.getIndent());
		rw.startLine(".end invokedynamic");
		insns.add(rw.getCode());
	}

	@Override
	public void visitJumpInsn(int opcode, Label label) {
		LabelData ld = getLabelData(label).addUse();
		insns.add(formatInsn(opcode).add(ld.getName()).getCode());
	}

	@Override
	public void visitLdcInsn(Object value) {
		boolean wide = value instanceof Long || value instanceof Double;
		String insn = wide ? "ldc2_w" : "ldc";
		insns.add(tmpWriter().add(insn).space().add(RaungTypes.format(value)).getCode());
	}

	@Override
	public void visitIincInsn(int var, int increment) {
		insns.add(tmpWriter().add("iinc").space().add(var).space().add(increment).getCode());
	}

	@Override
	public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
		String switchType = classVisitor.getArgs().isAutoSwitch() ? "switch" : "tableswitch";
		RaungWriter rw = tmpWriter().add(switchType);
		rw.setIndent(writer.getIndent() + 1);
		int l = 0;
		for (int i = min; i <= max; i++) {
			LabelData label = getLabelData(labels[l++]).addUse();
			rw.startLine().add(i).space().add(label.getName());
		}
		rw.startLine("default ").add(getLabelData(dflt).addUse().getName());
		rw.setIndent(writer.getIndent());
		rw.startLine(".end ").add(switchType);
		insns.add(rw.getCode());
	}

	@Override
	public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
		String switchType = classVisitor.getArgs().isAutoSwitch() ? "switch" : "lookupswitch";
		RaungWriter rw = tmpWriter().add(switchType);
		rw.setIndent(writer.getIndent() + 1);
		int len = keys.length;
		for (int i = 0; i < len; i++) {
			LabelData label = getLabelData(labels[i]).addUse();
			rw.startLine().add(keys[i]).space().add(label.getName());
		}
		rw.startLine("default ").add(getLabelData(dflt).addUse().getName());
		rw.setIndent(writer.getIndent());
		rw.startLine(".end ").add(switchType);
		insns.add(rw.getCode());
	}

	@Override
	public void visitMultiANewArrayInsn(String descriptor, int numDimensions) {
		insns.add(tmpWriter().add("multianewarray").space().add(descriptor).space().add(numDimensions).getCode());
	}

	@Override
	public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {
		LabelData startLabel = getLabelData(start).addUse();
		LabelData endLabel = getLabelData(end).addUse();
		LabelData handlerLabel = getLabelData(handler).addUse();
		TryCatchBlock tryCatchBlock = new TryCatchBlock(catchCount++, startLabel, endLabel, handlerLabel, type);
		endLabel.addCatch(tryCatchBlock);
	}

	@Override
	public AnnotationVisitor visitTryCatchAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {
		// TODO
		writer.startLine("# try-catch annotation " + TypeRefUtils.formatPath(typeRef, typePath) + " " + descriptor + " " + visible);
		return null;
	}

	@Override
	public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {
		if (addDebugInfo()) {
			LocalVar var = new LocalVar(index, name, descriptor, signature);
			getLabelData(start).addStartVars(var);
			getLabelData(end).addEndVar(var);
		}
	}

	@Override
	public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index,
			String descriptor, boolean visible) {
		// TODO: support local variable annotations
		return null;
	}

	@Override
	public void visitLineNumber(int line, Label start) {
		if (addDebugInfo()) {
			LabelData ld = getLabelData(start);
			ld.setLine(line);
		}
	}

	@Override
	public void visitLabel(Label label) {
		LabelData ld = getLabelData(label);
		ld.setInsnRef(insns.size()); // for next insn
		// System.out.println("DISASM visit label: " + ld);
	}

	@Override
	public void visitMaxs(int maxStack, int maxLocals) {
		if (classVisitor.getArgs().isAutoMax()) {
			return;
		}
		writer.startLine(".max stack").space().add(maxStack);
		writer.startLine(".max locals").space().add(maxLocals);
		writer.newLine();
	}

	@Override
	public void visitEnd() {
		try {
			Map<Integer, LabelData> labelsMap = new HashMap<>();
			for (LabelData ld : labels.values()) {
				LabelData prevLabel = labelsMap.put(ld.getInsnRef(), ld);
				if (prevLabel != null) {
					throw new RaungDisasmException("Duplicate label, " + ld + ", prev: " + prevLabel);
				}
			}
			int insnsCount = insns.size();
			for (int i = 0; i < insnsCount; i++) {
				LabelData labelData = labelsMap.get(i);
				if (labelData != null) {
					handleLabelDataBeforeInsn(labelData);
				}
				addInsnAttachments(i);
				writer.startLine(insns.get(i));
				if (labelData != null) {
					handleLabelDataAfterInsn(labelData, i == insnsCount - 1);
				}
			}
			writer.setIndent(0);
			writer.startLine(".end method");
		} catch (Exception e) {
			throw new RaungDisasmException("Failed to process method: " + this, e);
		}
	}

	private void addInsnAttachments(int insnOffset) {
		RaungWriter rw = insnAttachments.get(insnOffset);
		if (rw != null) {
			writer.add(rw);
		}
	}

	private void handleLabelDataBeforeInsn(LabelData labelData) {
		if (labelData.getUseCount() != 0) {
			writer.decreaseIndent();
			writer.startLine().add(labelData.getName());
			writer.increaseIndent();
		}
		for (LocalVar startVar : labelData.getStartVars()) {
			writer.startLine(".local")
					.space().add(startVar.getIndex())
					.space().addString(startVar.getName())
					.space().add(startVar.getType());
			if (startVar.getSignature() != null) {
				writer.space().add(startVar.getSignature());
			}
		}
		for (TryCatchBlock catchBlock : labelData.getCatches()) {
			String type = catchBlock.getType();
			writer.startLine(Directive.CATCH);
			if (classVisitor.getArgs().isSaveCatchNumber()) {
				writer.add('@').add(catchBlock.getId()).space();
			}
			writer.add(type == null ? "all" : type)
					.space().add(catchBlock.getStart().getName())
					.space().add("..")
					.space().add(catchBlock.getEnd().getName())
					.space().add("goto").space().add(catchBlock.getHandler().getName());
		}
		for (Integer line : labelData.getLines()) {
			writer.startLine(".line ").add(line);
		}
	}

	private void handleLabelDataAfterInsn(LabelData labelData, boolean lastInsn) {
		if (!lastInsn && !labelData.getEndVars().isEmpty()) {
			for (LocalVar endVar : labelData.getEndVars()) {
				writer.startLine(".end local ").add(endVar.getIndex()).add(" # ").addString(endVar.getName());
			}
		}
	}

	private LabelData getLabelData(Label label) {
		return labels.computeIfAbsent(label, l -> new LabelData(label, String.format(":L%d", labels.size())));
	}

	private RaungWriter tmpWriter() {
		return tempWriter.clear();
	}

	private RaungWriter formatInsn(int opcode) {
		return tmpWriter().add(JavaOpCodes.getName(opcode)).space();
	}

	private boolean addDebugInfo() {
		return !classVisitor.getArgs().isIgnoreDebugInfo();
	}

	@Override
	public String toString() {
		return classVisitor + "->" + mthShortId;
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/visitors/data/LabelData.java`:

```java
package io.github.skylot.raung.disasm.impl.visitors.data;

import java.util.List;

import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.Label;

import io.github.skylot.raung.disasm.impl.utils.ListUtils;

public class LabelData {
	private final Label label;
	private final String name;
	private int insnRef;
	private int useCount;
	private @Nullable List<LocalVar> startVars;
	private @Nullable List<LocalVar> endVars;
	private @Nullable List<TryCatchBlock> catches;
	private @Nullable List<Integer> lines;

	public LabelData(Label label, String name) {
		this.label = label;
		this.name = name;
	}

	public Label getLabel() {
		return label;
	}

	public String getName() {
		return name;
	}

	public int getInsnRef() {
		return insnRef;
	}

	public void setInsnRef(int insnRef) {
		this.insnRef = insnRef;
	}

	public int getUseCount() {
		return useCount;
	}

	public LabelData addUse() {
		this.useCount++;
		return this;
	}

	public List<LocalVar> getStartVars() {
		return ListUtils.fromNullable(startVars);
	}

	public void addStartVars(LocalVar var) {
		this.startVars = ListUtils.addToNullable(startVars, var);
	}

	public List<LocalVar> getEndVars() {
		return ListUtils.fromNullable(endVars);
	}

	public void addEndVar(LocalVar var) {
		this.endVars = ListUtils.addToNullable(endVars, var);
	}

	public List<TryCatchBlock> getCatches() {
		return ListUtils.fromNullable(catches);
	}

	public void addCatch(TryCatchBlock block) {
		this.catches = ListUtils.addToNullable(catches, block);
	}

	public List<Integer> getLines() {
		return ListUtils.fromNullable(lines);
	}

	public void setLine(int line) {
		this.lines = ListUtils.addToNullable(lines, line);
	}

	@Override
	public String toString() {
		return name + " at " + insnRef;
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/visitors/data/LocalVar.java`:

```java
package io.github.skylot.raung.disasm.impl.visitors.data;

public class LocalVar {
	private final int index;
	private final String name;
	private final String type;
	private final String signature;

	public LocalVar(int index, String name, String type, String signature) {
		this.index = index;
		this.name = name;
		this.type = type;
		this.signature = signature;
	}

	public int getIndex() {
		return index;
	}

	public String getName() {
		return name;
	}

	public String getType() {
		return type;
	}

	public String getSignature() {
		return signature;
	}

	@Override
	public String toString() {
		return name + " : " + type;
	}
}

```

`raung-disasm/src/main/java/io/github/skylot/raung/disasm/impl/visitors/data/TryCatchBlock.java`:

```java
package io.github.skylot.raung.disasm.impl.visitors.data;

import org.jetbrains.annotations.Nullable;

public class TryCatchBlock {
	private final int id;
	private final LabelData start;
	private final LabelData end;
	private final LabelData handler;
	@Nullable
	private final String type;

	public TryCatchBlock(int id, LabelData start, LabelData end, LabelData handler, @Nullable String type) {
		this.id = id;
		this.start = start;
		this.end = end;
		this.handler = handler;
		this.type = type;
	}

	public int getId() {
		return id;
	}

	public LabelData getStart() {
		return start;
	}

	public LabelData getEnd() {
		return end;
	}

	public LabelData getHandler() {
		return handler;
	}

	@Nullable
	public String getType() {
		return type;
	}
}

```

`raung-disasm/src/test/java/io/github/skylot/raung/disasm/impl/utils/TestJavaVersion.java`:

```java
package io.github.skylot.raung.disasm.impl.utils;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.common.utils.JavaVersion;

import static io.github.skylot.raung.common.utils.JavaVersion.JAVA_17;
import static io.github.skylot.raung.common.utils.JavaVersion.JAVA_1_1;
import static io.github.skylot.raung.common.utils.JavaVersion.JAVA_21;
import static io.github.skylot.raung.common.utils.JavaVersion.JAVA_8;
import static io.github.skylot.raung.common.utils.JavaVersion.PREVIEW_VERSION;
import static io.github.skylot.raung.common.utils.JavaVersion.getNameStr;
import static org.assertj.core.api.Assertions.assertThat;

class TestJavaVersion {

	@Test
	public void various() {
		assertThat(getNameStr(JAVA_1_1.getRawVersion())).isEqualTo("Java 1.1");
		assertThat(getNameStr(JAVA_8.getRawVersion())).isEqualTo("Java 8");
		assertThat(getNameStr(JAVA_17.getRawVersion() | PREVIEW_VERSION)).isEqualTo("Java 17 preview");
		assertThat(getNameStr(JAVA_21.getRawVersion() + 1)).isEqualTo("Java 22 (approximated)");
		assertThat(getNameStr((JAVA_21.getRawVersion() + 2) | PREVIEW_VERSION)).isEqualTo("Java 23 (approximated) preview");

		assertThat(JAVA_1_1.getMajor()).isEqualTo(45);
		assertThat(JAVA_1_1.getMinor()).isEqualTo(3);

		assertThat(getNameStr(JavaVersion.getRaw(JAVA_17.getMajor(), 1))).isEqualTo("Java 17 (with unknown minor: 1)");
	}
}

```

`raung-disasm/src/test/java/io/github/skylot/raung/disasm/tests/api/IntegrationTest.java`:

```java
package io.github.skylot.raung.disasm.tests.api;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import io.github.skylot.raung.disasm.RaungDisasm;

import static org.junit.jupiter.api.Assertions.fail;

public class IntegrationTest {

	protected String disasmCls(Class<?> cls) {
		try {
			Path input = locateClassFile(cls);
			String code = disasmSingleClass(input);
			printCode(code);
			return code;
		} catch (Exception e) {
			fail("Class disasm failed", e);
			return null;
		}
	}

	private String disasmSingleClass(Path input) {
		return RaungDisasm.create().executeForSingleClass(input);
	}

	private Path locateClassFile(Class<?> cls) {
		try {
			Path path = Paths.get(cls.getProtectionDomain().getCodeSource().getLocation().toURI());
			if (Files.isDirectory(path)) {
				String clsFile = cls.getName().replace('.', '/') + ".class";
				Path file = path.resolve(clsFile);
				System.out.println("Class file location: " + file);
				return file;
			}
			return path;
		} catch (Exception e) {
			fail("Failed to find class file location: " + cls.getName(), e);
			return null;
		}
	}

	private void printCode(String code) {
		System.out.println("===================================");
		System.out.println(code);
		System.out.println("===================================");
	}
}

```

`raung-disasm/src/test/java/io/github/skylot/raung/disasm/tests/functional/RaungDisasmTest.java`:

```java
package io.github.skylot.raung.disasm.tests.functional;

import java.nio.file.Paths;
import java.util.Collections;

import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import io.github.skylot.raung.disasm.RaungDisasm;

class RaungDisasmTest {

	@Test
	@Disabled
	public void testUsage() {
		RaungDisasm.create()
				.inputs(Collections.emptyList())
				.output(null)
				.ignoreDebugInfo()
				.execute();
	}

	@Test
	@Disabled
	public void testUsageSingle() {
		RaungDisasm.create()
				.input(Paths.get("inputDir"))
				.output(Paths.get("outputDir"))
				.execute();
	}
}

```

`raung-disasm/src/test/java/io/github/skylot/raung/disasm/tests/integration/TestFieldAnnotations.java`:

```java
package io.github.skylot.raung.disasm.tests.integration;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.disasm.tests.api.IntegrationTest;

import static org.assertj.core.api.Assertions.assertThat;

public class TestFieldAnnotations extends IntegrationTest {

	public static class TestCls {
		@A(value = { 2, 3 }, s = "A", b = @B(value = E.E2, arr = { E.E1 }))
		public int field1 = 7;

		public static @interface A {
			String s();

			int[] value();

			B b();
		}

		public static @interface B {
			E value();

			E[] arr() default {};
		}

		public static enum E {
			E1, E2
		}
	}

	@Test
	public void test() {
		assertThat(disasmCls(TestCls.class))
				.containsOnlyOnce(".field public field1 I")
				.containsOnlyOnce(".end field");
	}
}

```

`raung-disasm/src/test/java/io/github/skylot/raung/disasm/tests/integration/TestHelloWorld.java`:

```java
package io.github.skylot.raung.disasm.tests.integration;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.disasm.tests.api.IntegrationTest;

import static org.assertj.core.api.Assertions.assertThat;

public class TestHelloWorld extends IntegrationTest {

	public static class TestCls {
		public static void main(String[] args) {
			System.out.println("Hello, World!");
		}
	}

	@Test
	public void test() {
		assertThat(disasmCls(TestCls.class))
				.containsOnlyOnce("getstatic java/lang/System out Ljava/io/PrintStream;")
				.containsOnlyOnce("ldc \"Hello, World!\"")
				.containsOnlyOnce("invokevirtual java/io/PrintStream println (Ljava/lang/String;)V");
	}
}

```

`raung-disasm/src/test/resources/logback.xml`:

```xml
<configuration>

	<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
		<encoder>
			<pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>
		</encoder>
	</appender>

	<root level="DEBUG">
		<appender-ref ref="STDOUT"/>
	</root>

</configuration>

```

`raung-tests/build.gradle.kts`:

```kts
plugins {
	id("raung.java-common")
}

dependencies {
	testImplementation(project(":raung-asm"))
	testImplementation(project(":raung-disasm"))

	testCompileOnly("org.jetbrains:annotations:24.1.0")
	testImplementation("commons-io:commons-io:2.16.1")
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/api/IntegrationTest.java`:

```java
package io.github.skylot.raung.tests.api;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import org.assertj.core.util.diff.DiffUtils;
import org.assertj.core.util.diff.Patch;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.util.CheckClassAdapter;
import org.objectweb.asm.util.TraceClassVisitor;

import io.github.skylot.raung.asm.RaungAsm;
import io.github.skylot.raung.disasm.RaungDisasm;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.fail;

public class IntegrationTest {

	protected String runChecksFor(Class<?> cls) {
		try {
			Path classFile = locateClassFile(cls);
			return runChecksFor(classFile);
		} catch (Exception e) {
			fail("Check failed", e);
			return null;
		}
	}

	protected String runChecksForClassFile(String clsFilePath) {
		try {
			return runChecksFor(Paths.get(clsFilePath));
		} catch (Exception e) {
			fail("Check failed", e);
			return null;
		}
	}

	protected String runChecksForRaung() {
		return runChecksForRaung(this.getClass().getSimpleName());
	}

	protected String runChecksForRaung(String fileName) {
		try {
			String disasm = loadRaungFile(fileName);
			byte[] bytes = assembleClass(disasm);
			String rebuild = disasmFromBytes(bytes);
			compareResults("Raung diff", disasm, rebuild);
			checkClassWithAsm(bytes);
			return rebuild;
		} catch (Exception e) {
			fail("Check failed", e);
			return null;
		}
	}

	private String runChecksFor(Path classFile) {
		try {
			String disasm = disasmFromFile(classFile);
			printCode(disasm);
			byte[] bytes = assembleClass(disasm);

			compareResults("ASM diff", disasmWithASM(classFile), disasmWithASM(bytes));
			compareResults("Raung diff", disasm, disasmFromBytes(bytes));
			checkClassWithAsm(bytes);
			return disasm;
		} catch (Exception e) {
			fail("Check failed", e);
			return null;
		}
	}

	protected void runChecksWithInnerClasses(Class<?> cls) {
		runChecksFor(cls);
		for (Class<?> innerCls : cls.getClasses()) {
			runChecksWithInnerClasses(innerCls);
		}
	}

	private String disasmFromFile(Path input) {
		return RaungDisasm.create().executeForSingleClass(input);
	}

	private String disasmFromBytes(byte[] bytes) throws IOException {
		try (InputStream input = new ByteArrayInputStream(bytes)) {
			return RaungDisasm.create().executeForInputStream(input);
		}
	}

	private byte[] assembleClass(String code) throws IOException {
		try (InputStream input = new ByteArrayInputStream(code.getBytes(StandardCharsets.UTF_8))) {
			return RaungAsm.create().executeForInputStream(input);
		}
	}

	private void checkClassWithAsm(byte[] bytes) {
		StringWriter results = new StringWriter();
		CheckClassAdapter.verify(new ClassReader(bytes), false, new PrintWriter(results));
		assertThat(results.toString()).isEmpty();
	}

	private static String disasmWithASM(byte[] bytes) throws IOException {
		return disasmWithASM(new ByteArrayInputStream(bytes));
	}

	private static String disasmWithASM(Path file) throws IOException {
		return disasmWithASM(Files.newInputStream(file));
	}

	private static String disasmWithASM(InputStream in) throws IOException {
		StringWriter out = new StringWriter();
		TraceClassVisitor tcv = new TraceClassVisitor(new PrintWriter(out));
		new ClassReader(in).accept(tcv, 0);
		return out.toString();
	}

	private Path locateClassFile(Class<?> cls) {
		try {
			Path path = Paths.get(cls.getProtectionDomain().getCodeSource().getLocation().toURI());
			if (Files.isDirectory(path)) {
				String clsFile = cls.getName().replace('.', '/') + ".class";
				Path file = path.resolve(clsFile);
				System.out.println("Class file location: " + file);
				return file;
			}
			return path;
		} catch (Exception e) {
			fail("Failed to find class file location: " + cls.getName(), e);
			return null;
		}
	}

	private String loadRaungFile(String fileName) throws IOException {
		Class<?> thisCls = this.getClass();
		String pkg = thisCls.getPackage().getName().replace("io.github.skylot.raung.tests.integration.", "");
		String filePath = "/raung/" + pkg.replace('.', '/') + '/' + fileName + ".raung";
		try (InputStream in = Objects.requireNonNull(thisCls.getResourceAsStream(filePath));
				ByteArrayOutputStream out = new ByteArrayOutputStream()) {
			byte[] buffer = new byte[1024];
			while (true) {
				int r = in.read(buffer);
				if (r == -1) {
					break;
				}
				out.write(buffer, 0, r);
			}
			return out.toString(StandardCharsets.UTF_8);
		}
	}

	private void printCode(String code) {
		System.out.println("===================================");
		System.out.println(code);
		System.out.println("===================================");
	}

	protected void compareResults(String message, String firstStr, String secondStr) {
		if (!firstStr.equals(secondStr)) {
			// print short diff
			printDiff(message, firstStr, secondStr);
			// IntelliJ IDEA will suggest viewing nice full diff
			assertEquals(firstStr, secondStr, message);
		}
	}

	private void printDiff(String message, String first, String second) {
		Patch<String> diff = DiffUtils.diff(toLines(first), toLines(second));
		System.out.println("-------------- " + message + " --------------");
		diff.getDeltas().forEach(System.out::println);
		System.out.println("--------------------------------------");
	}

	private List<String> toLines(String str) {
		List<String> list = new ArrayList<>();
		Collections.addAll(list, str.split("\n"));
		return list;
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/TestConditions.java`:

```java
package io.github.skylot.raung.tests.integration;

import java.util.HashSet;
import java.util.Set;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

public class TestConditions extends IntegrationTest {

	public static class TestCls {
		private Set<Object> firstSet = new HashSet<>();
		private Set<Object> secondSet = new HashSet<>();

		public boolean contains(Object o) {
			if (this.firstSet.contains(o)) {
				return true;
			}
			if (this.secondSet.contains(o)) {
				return true;
			}
			return false;
		}
	}

	@Test
	public void test() {
		runChecksFor(TestCls.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/TestHelloWorld.java`:

```java
package io.github.skylot.raung.tests.integration;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

public class TestHelloWorld extends IntegrationTest {

	public static class TestCls {
		public static void main(String[] args) {
			System.out.println("Hello, World!");
		}
	}

	@Test
	public void test() {
		runChecksFor(TestCls.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/TestInvokeDynamic.java`:

```java
package io.github.skylot.raung.tests.integration;

import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

public class TestInvokeDynamic extends IntegrationTest {

	public static class TestCls {
		public String test(Stream<String> strings) {
			return strings.map(String::trim).collect(Collectors.joining());
		}
	}

	@Test
	public void test() {
		runChecksFor(TestCls.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/TestLoadConst.java`:

```java
package io.github.skylot.raung.tests.integration;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

public class TestLoadConst extends IntegrationTest {

	public static class TestCls {
		public static Class<?>[] testTypes() {
			return new Class[] { Integer.class, Float[].class };
		}

		@SuppressWarnings("UnnecessaryBoxing")
		public static String testSimpleTypes() {
			return Float.valueOf(3.0f) + " " + Double.valueOf(7.0)
					+ Byte.valueOf((byte) 11) + Short.valueOf((short) 17)
					+ Character.valueOf((char) 21) + '1';
		}

		public static double[] testSpecialCasesDouble() {
			return new double[] {
					Double.NaN,
					Double.MAX_VALUE,
					Double.MAX_VALUE,
					Double.POSITIVE_INFINITY,
					Double.NEGATIVE_INFINITY,
			};
		}

		public static float[] testSpecialCasesFloat() {
			return new float[] {
					Float.NaN,
					Float.MAX_VALUE,
					Float.MAX_VALUE,
					Float.POSITIVE_INFINITY,
					Float.NEGATIVE_INFINITY,
			};
		}
	}

	@Test
	public void test() {
		runChecksFor(TestCls.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/TestParser.java`:

```java
package io.github.skylot.raung.tests.integration;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

public class TestParser extends IntegrationTest {

	public static class TestCls {
		// field name can be read as access flag
		public final int constructor = 1;
	}

	@Test
	public void test() {
		runChecksFor(TestCls.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/TestStringEscape.java`:

```java
package io.github.skylot.raung.tests.integration;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

@SuppressWarnings("AvoidEscapedUnicodeCharacters")
public class TestStringEscape extends IntegrationTest {
	public static class TestCls {
		static final String FORMAT = "\n\r\t\b\f\\\"' ";
		static final String EMOJI = "😀😂👍\uD83C\uDF5E\uD83C\uDF54\uD83C\uDF69\uD83C\uDF6B\uD83C\uDF61\uD83C\uDF50";
		static final String RANDOM = "❶⚙ⴗ░⢈⛂⋰Ⰴ⢂⪞⅗⢋❤⺾ⓓ\u209E⏮☎❍\u2E57⬸ⶭ⬶†⧘\u2EFCⵓⱞ\u2FDC⎋ⵠ⟂⋳⾆ⲛ≻◴⩨⪨\u2BDF❭⚥⩜┼"
				+ "\u2BD3⛑⊼Ⓢ↩Ⱜ⭿⬘⪙\u2B97⬒\u2BD7☚\u2E69⩤⨲Ⰺ⌘⻖Ⱋ☕\u2E59ℌ\u2E53⛵⟙⎕⅏☞⺨◕⅀✀⑁⬄ⷊ⡶⓯◫◻⩊⦹⌧⡋Ⲯ∸ ↟⸉■⚲ⰹ↞⤄⫵⣰";
	}

	@Test
	public void test() {
		runChecksFor(TestCls.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/TestSwitch.java`:

```java
package io.github.skylot.raung.tests.integration;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

public class TestSwitch extends IntegrationTest {

	public static class TestCls {

		public int testLookupSwitch(int i) {
			switch (i) {
				case 1:
					return 1;
				case 7:
					return 7;
				case 11:
					return 11;
				default:
					return 42;
			}
		}

		public int testTableSwitch(int i) {
			switch (i) {
				case 1:
					return 0;
				case 2:
					return 1;
				case 3:
					return 2;
				default:
					return 42;
			}
		}
	}

	@Test
	public void test() {
		runChecksFor(TestCls.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/TestTryCatch.java`:

```java
package io.github.skylot.raung.tests.integration;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

public class TestTryCatch extends IntegrationTest {

	public static class TestCls {
		private static final Object MKDIR_SYNC = new Object();

		public static void makeDirs(Path dir) {
			if (dir != null) {
				synchronized (MKDIR_SYNC) {
					try {
						createDirs(dir);
					} catch (IOException e) {
						throw new RuntimeException("Can't create directory " + dir);
					}
				}
			}
		}

		private static void createDirs(Path dir) throws IOException {
			Files.createDirectories(dir);
		}
	}

	@Test
	public void test() {
		runChecksFor(TestCls.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/annotations/TestAnnotations.java`:

```java
package io.github.skylot.raung.tests.integration.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Field;
import java.util.Arrays;

import org.jetbrains.annotations.Nullable;
import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

public class TestAnnotations extends IntegrationTest {

	public static class TestCls {
		@Nullable
		@A(bool = false)
		private static Field field;

		@Retention(RetentionPolicy.RUNTIME)
		@Target({ ElementType.FIELD, ElementType.METHOD })
		public @interface A {
			boolean bool();
		}

		@Retention(RetentionPolicy.RUNTIME)
		@Target({ ElementType.TYPE_PARAMETER, ElementType.PARAMETER, ElementType.METHOD, ElementType.LOCAL_VARIABLE })
		public @interface B {
			int i() default 7;
		}

		public static class C<K, @B(i = 2) V> {
		}

		@SuppressWarnings("ModifierOrder")
		public @B void test1(@B(i = 0) int i, @Nullable String s) {
		}

		public <V> void test2() {
			@SuppressWarnings("unchecked")
			// @Nullable // TODO: support local var annotations
			V[][] copy = (@Nullable V[][]) new Object[1][2];
			System.out.println(Arrays.deepToString(copy));
		}
	}

	@Test
	public void test() {
		runChecksWithInnerClasses(TestCls.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/attributes/TestMethodParam.java`:

```java
package io.github.skylot.raung.tests.integration.attributes;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

import static org.assertj.core.api.Assertions.assertThat;

public class TestMethodParam extends IntegrationTest {

	private static class TestCls {
		private String docName;

		public void setDocName(final String docName) {
			this.docName = docName;
		}
	}

	@Test
	public void test() {
		runChecksFor(TestCls.class);
	}

	@Test
	public void testAsm() {
		assertThat(runChecksForRaung())
				.containsOnlyOnce(".param final docName");
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/attributes/TestNestHostAndMember.java`:

```java
package io.github.skylot.raung.tests.integration.attributes;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

import static org.assertj.core.api.Assertions.assertThat;

public class TestNestHostAndMember extends IntegrationTest {

	@Test
	public void testHost() {
		assertThat(runChecksForRaung("TestNestHost"))
				.containsOnlyOnce(".nest host");
	}

	@Test
	public void testMember() {
		assertThat(runChecksForRaung("TestNestMember"))
				.containsOnlyOnce(".nest member");
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/insns/TestJSR.java`:

```java
package io.github.skylot.raung.tests.integration.insns;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

import static org.assertj.core.api.Assertions.assertThat;

public class TestJSR extends IntegrationTest {

	@Test
	public void test() {
		assertThat(runChecksForRaung())
				.contains("jsr :L3", "ret 5");
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/other/TestAnonymousAndLambda.java`:

```java
package io.github.skylot.raung.tests.integration.other;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

public class TestAnonymousAndLambda extends IntegrationTest {

	public static class TestCls {
		@SuppressWarnings("Convert2Lambda")
		public Runnable testAnonymous() {
			return new Runnable() {
				@Override
				public void run() {
					System.out.println("run");
				}
			};
		}

		public Runnable testLambda() {
			return () -> System.out.println("run");
		}
	}

	@Test
	public void test() {
		runChecksWithInnerClasses(TestAnonymousAndLambda.class);
	}
}

```

`raung-tests/src/test/java/io/github/skylot/raung/tests/integration/other/TestNewFrameType.java`:

```java
package io.github.skylot.raung.tests.integration.other;

import org.junit.jupiter.api.Test;

import io.github.skylot.raung.tests.api.IntegrationTest;

/**
 * Check 'new' type for 'stack'
 */
public class TestNewFrameType extends IntegrationTest {
	@Test
	public void test() {
		runChecksForRaung();
	}
}

```

`raung-tests/src/test/resources/raung/attributes/TestMethodParam.raung`:

```raung
.version 52  # Java 8
.class attributes/TestMethodParam

.field private docName Ljava/lang/String;

.method public setDocName(Ljava/lang/String;)V
    .param final docName
    .max stack 2
    .max locals 2

    .local 0 "this" attributes/TestMethodParam
    .local 1 "docName" Ljava/lang/String;
    .line 275
    aload 0
    aload 1
    putfield attributes/TestMethodParam docName Ljava/lang/String;
    .line 276
    return
.end method

```

`raung-tests/src/test/resources/raung/attributes/TestNestHost.raung`:

```raung
.version 61  # Java 17
.class attributes/TestNestHostAndMember$1

.nest host attributes/TestNestHostAndMember

```

`raung-tests/src/test/resources/raung/attributes/TestNestMember.raung`:

```raung
.version 61  # Java 17
.class attributes/TestNestHostAndMember$1

.nest member attributes/TestNestHostAndMember$2

```

`raung-tests/src/test/resources/raung/insns/TestJSR.raung`:

```raung
.version 45.3  # Java 1.1
.class insns/TestJSR

.method public test(Ljava/net/URL;)Ljava/lang/String;
    .throw java/io/IOException
    .max stack 2
    .max locals 6

    .local 0 "this" Linsns/TestJSR;
    .local 1 "url" Ljava/net/URL;
    .line 88
    aload 1
    invokevirtual java/net/URL openStream ()Ljava/io/InputStream;
    astore 2
  :L0
    .local 2 "in" Ljava/io/InputStream;
    .line 89
    .line 90
    aload 0
    aload 2
    invokevirtual insns/TestJSR call (Ljava/io/InputStream;)Ljava/lang/String;
    astore 3
    jsr :L3
    aload 3
    areturn
  :L1
    .catch all :L0 .. :L1 goto :L1
    .line 89
    astore 4
    jsr :L3
    aload 4
    athrow
  :L3
    astore 5
    .line 92
    aload 2
    invokevirtual java/io/InputStream close ()V
    .line 89
    ret 5
.end method

.method public call(Ljava/io/InputStream;)Ljava/lang/String;
    .throw java/io/IOException
    .max stack 1
    .max locals 2

    ldc ""
    areturn
.end method

```

`raung-tests/src/test/resources/raung/other/TestNewFrameType.raung`:

```raung
.version 45.3  # Java 1.1
.class public final super b

.field public static a [[B

.field public static a B

.field public static b B

.field public static b [[B

.field public static c B

.field public static d B

.field public static a Z

.method public static a(I)V
    .max stack 5
    .max locals 3

    getstatic b a B
    getstatic b b B
    iadd
    i2b
    putstatic b a B
    getstatic b a B
    bipush 24
    if_icmple :L0
    iconst_0
    putstatic b a B
    bipush 12
    istore 1
  :L1
    .stack new
        local 0 int
        local 1 int
    .end stack
    iload 1
    iconst_1
    if_icmplt :L2
    iconst_0
    istore 2
  :L3
    .stack new
        local 0 int
        local 1 int
        local 2 int
    .end stack
    iload 2
    bipush 12
    if_icmpge :L4
    getstatic b a [[B
    iload 2
    aaload
    iload 1
    getstatic b a [[B
    iload 2
    aaload
    iload 1
    iconst_1
    isub
    baload
    bastore
    iinc 2 1
    goto :L3
  :L4
    .stack new
        local 0 int
        local 1 int
        local 2 int
    .end stack
    iinc 1 -1
    goto :L1
  :L2
    .stack new
        local 0 int
        local 1 int
    .end stack
    iload 0
    invokestatic b b (I)V
  :L0
    .stack new
        local 0 int
    .end stack
    getstatic b a Z
    ifeq :L5
    getstatic b c B
    getstatic b d B
    iadd
    i2b
    putstatic b c B
    getstatic b c B
    bipush 24
    if_icmple :L5
    iconst_0
    putstatic b c B
    bipush 12
    istore 1
  :L6
    .stack new
        local 0 int
        local 1 int
    .end stack
    iload 1
    iconst_1
    if_icmplt :L7
    iconst_0
    istore 2
  :L8
    .stack new
        local 0 int
        local 1 int
        local 2 int
    .end stack
    iload 2
    bipush 12
    if_icmpge :L9
    getstatic b b [[B
    iload 2
    aaload
    iload 1
    getstatic b b [[B
    iload 2
    aaload
    iload 1
    iconst_1
    isub
    baload
    bastore
    iinc 2 1
    goto :L8
  :L9
    .stack new
        local 0 int
        local 1 int
        local 2 int
    .end stack
    iinc 1 -1
    goto :L6
  :L7
    .stack new
        local 0 int
        local 1 int
    .end stack
    iload 0
    invokestatic b b (I)V
  :L5
    .stack new
        local 0 int
    .end stack
    return
.end method

```

`settings.gradle.kts`:

```kts
rootProject.name = "raung"

include("raung-common", "raung-asm", "raung-disasm", "raung-cli", "raung-tests")

```