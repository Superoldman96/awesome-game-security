Project Path: arc_gmh5225_R6-Internal-V3_6460ysvd

Source Tree:

```txt
arc_gmh5225_R6-Internal-V3_6460ysvd
├── README.md
├── module
│   ├── Cheat.h
│   ├── Direct.asm
│   ├── Direct.h
│   ├── DynamicPad.h
│   ├── GameManager.h
│   ├── Hexrays.h
│   ├── Memory.h
│   ├── Offsets.h
│   ├── Player.h
│   ├── RoundManager.h
│   ├── SDK.h
│   ├── VTable.h
│   ├── Vectors.h
│   ├── XorString.h
│   ├── dllmain.cpp
│   ├── module.vcxproj
│   └── module.vcxproj.filters
└── module.sln

```

`README.md`:

```md
# R6 Internal

```

`module.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32630.192
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "module", "module\module.vcxproj", "{C9D3DB3A-3ED2-4DB9-B843-D18155FDF12B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C9D3DB3A-3ED2-4DB9-B843-D18155FDF12B}.Debug|x64.ActiveCfg = Debug|x64
		{C9D3DB3A-3ED2-4DB9-B843-D18155FDF12B}.Debug|x64.Build.0 = Debug|x64
		{C9D3DB3A-3ED2-4DB9-B843-D18155FDF12B}.Debug|x86.ActiveCfg = Debug|Win32
		{C9D3DB3A-3ED2-4DB9-B843-D18155FDF12B}.Debug|x86.Build.0 = Debug|Win32
		{C9D3DB3A-3ED2-4DB9-B843-D18155FDF12B}.Release|x64.ActiveCfg = Release|x64
		{C9D3DB3A-3ED2-4DB9-B843-D18155FDF12B}.Release|x64.Build.0 = Release|x64
		{C9D3DB3A-3ED2-4DB9-B843-D18155FDF12B}.Release|x86.ActiveCfg = Release|Win32
		{C9D3DB3A-3ED2-4DB9-B843-D18155FDF12B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {00499CA3-A416-49A9-8C28-13760C1BD989}
	EndGlobalSection
EndGlobal

```

`module/Cheat.h`:

```h
// Cheat.h
#pragma once 
#include <Windows.h> // dangerous
#include <cstdint> 
#include "SDK.h"
   
namespace Cheat
{ 
	auto Run( ) -> void
	{  
		try
		{
			SDK::Manager::InitializeManagers( );

			for ( ;; Sleep( 1 ) )
			{
				auto StateID = SDK::RoundManager->RoundState( ); 
				if ( StateID == SDK::StateID::ActionPhase || StateID == SDK::StateID::PreperationPhase )
				{
					auto Controller = SDK::GameManager->Controller( 0 );
					auto ActiveWeapon = Controller->PawnComponent( )->ActorDescriptor( )->ActiveWeapon( );
					  
					if ( GetAsyncKeyState( VK_MBUTTON ) )  
						ActiveWeapon->Shoot( );

					ActiveWeapon->SetSpread( 0.0f ); 
				}
			}
		}
		catch ( ... )
		{    

		} 
	}
}
```

`module/Direct.h`:

```h
// Direct.h
#pragma once
#include <cstdint>

namespace Direct
{  
	auto ImageBase( ) -> std::uint64_t
	{
		return ( std::uint64_t ) GetModuleHandleW( NULL ); // Detected
	}
}

```

`module/DynamicPad.h`:

```h
// DynamicPad.h
#pragma once

#define STR_MERGE_IMPL(a, b) a##b
#define STR_MERGE(a, b) STR_MERGE_IMPL(a, b)
#define MAKE_PAD(size) STR_MERGE(_pad, __COUNTER__)[size]
#define MEMBER(type, name, offset) struct {unsigned char MAKE_PAD(offset); type name;}
 
```

`module/GameManager.h`:

```h
// GameManager.h
#pragma once
#include <cstdint>
#include <numeric>

#include "Direct.h" 
#include "DynamicPad.h" 
#include "Offsets.h"
#include "VTable.h"

#include "Player.h"

namespace SDK
{
	namespace Manager
	{
		class _GameManager
		{
		public:
			union
			{
				VTable::Table* vtable;
				MEMBER( std::uint64_t, pControllerList, 0x70 );
			};  

			auto ControllerList( ) -> std::uint64_t
			{
				return this->pControllerList - 0x4A;
			}

			auto Controller( auto idx ) -> SDK::Player::_Entity*
			{
				return *reinterpret_cast< SDK::Player::_Entity** >( ( this->ControllerList( ) + ( idx * 8i64 ) ) );
			}
		};

		auto GetGameManager( ) -> _GameManager*  
		{ 
			return reinterpret_cast< _GameManager* >( std::rotl( *( uint64_t* ) ( Direct::ImageBase( ) + Offsets::GameManager ) - 0x24, 0x1A ) );
		}
	} 

	inline Manager::_GameManager* GameManager;
}
```

`module/Hexrays.h`:

```h
/* This file contains definitions used in the Hex-Rays decompiler output. It has type definitions and convenience macros to make the output more readable. Copyright (c) 2007-2020 Hex-Rays */

#ifndef HEXRAYS_DEFS_H
#define HEXRAYS_DEFS_H

#if defined(__GNUC__)
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8 char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif
typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types. They are used when the decompiler does not know
// anything about the type except its size.
#define _BYTE uint8
#define _WORD uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif

// Non-standard boolean types. They are used when the decompiler cannot use
// the standard "bool" type because of the size mistmatch but the possible
// values are only 0 and 1. See also 'BOOL' type below.
typedef int8 _BOOL1;
typedef int16 _BOOL2;
typedef int32 _BOOL4;
typedef int64 _BOOL8;

#ifndef _WINDOWS_
typedef int8 BYTE;
typedef int16 WORD;
typedef int32 DWORD;
typedef int32 LONG;
typedef int BOOL;       // uppercase BOOL is usually 4 bytes
#endif
typedef int64 QWORD;
#ifndef __cplusplus
typedef int bool;       // we want to use bool in our C programs
#endif

#define __pure // pure function:
                // when given the same arguments, always returns the same value
                // has no side effects

// Non-returning function
#if defined(__GNUC__)
#define __noreturn __attribute__((noreturn))
#else
#define __noreturn __declspec(noreturn)
#endif


#ifndef NULL
#define NULL 0
#endif

// Some convenience macros to make partial accesses nicer
#define LAST_IND(x,part_type) (sizeof(x)/sizeof(part_type) - 1)
#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
# define LOW_IND(x,part_type) LAST_IND(x,part_type)
# define HIGH_IND(x,part_type) 0
#else
# define HIGH_IND(x,part_type) LAST_IND(x,part_type)
# define LOW_IND(x,part_type) 0
#endif
// first unsigned macros:
#define BYTEn(x, n) (*((_BYTE*)&(x)+n))
#define WORDn(x, n) (*((_WORD*)&(x)+n))
#define DWORDn(x, n) (*((_DWORD*)&(x)+n))

#define LOBYTE(x) BYTEn(x,LOW_IND(x,_BYTE))
#define LOWORD(x) WORDn(x,LOW_IND(x,_WORD))
#define LODWORD(x) DWORDn(x,LOW_IND(x,_DWORD))
#define HIBYTE(x) BYTEn(x,HIGH_IND(x,_BYTE))
#define HIWORD(x) WORDn(x,HIGH_IND(x,_WORD))
#define HIDWORD(x) DWORDn(x,HIGH_IND(x,_DWORD))
#define BYTE1(x) BYTEn(x, 1) // byte 1 (counting from 0)
#define BYTE2(x) BYTEn(x, 2)
#define BYTE3(x) BYTEn(x, 3)
#define BYTE4(x) BYTEn(x, 4)
#define BYTE5(x) BYTEn(x, 5)
#define BYTE6(x) BYTEn(x, 6)
#define BYTE7(x) BYTEn(x, 7)
#define BYTE8(x) BYTEn(x, 8)
#define BYTE9(x) BYTEn(x, 9)
#define BYTE10(x) BYTEn(x, 10)
#define BYTE11(x) BYTEn(x, 11)
#define BYTE12(x) BYTEn(x, 12)
#define BYTE13(x) BYTEn(x, 13)
#define BYTE14(x) BYTEn(x, 14)
#define BYTE15(x) BYTEn(x, 15)
#define WORD1(x) WORDn(x, 1)
#define WORD2(x) WORDn(x, 2) // third word of the object, unsigned
#define WORD3(x) WORDn(x, 3)
#define WORD4(x) WORDn(x, 4)
#define WORD5(x) WORDn(x, 5)
#define WORD6(x) WORDn(x, 6)
#define WORD7(x) WORDn(x, 7)

// now signed macros (the same but with sign extension)
#define SBYTEn(x, n) (*((int8*)&(x)+n))
#define SWORDn(x, n) (*((int16*)&(x)+n))
#define SDWORDn(x, n) (*((int32*)&(x)+n))

#define SLOBYTE(x) SBYTEn(x,LOW_IND(x,int8))
#define SLOWORD(x) SWORDn(x,LOW_IND(x,int16))
#define SLODWORD(x) SDWORDn(x,LOW_IND(x,int32))
#define SHIBYTE(x) SBYTEn(x,HIGH_IND(x,int8))
#define SHIWORD(x) SWORDn(x,HIGH_IND(x,int16))
#define SHIDWORD(x) SDWORDn(x,HIGH_IND(x,int32))
#define SBYTE1(x) SBYTEn(x, 1)
#define SBYTE2(x) SBYTEn(x, 2)
#define SBYTE3(x) SBYTEn(x, 3)
#define SBYTE4(x) SBYTEn(x, 4)
#define SBYTE5(x) SBYTEn(x, 5)
#define SBYTE6(x) SBYTEn(x, 6)
#define SBYTE7(x) SBYTEn(x, 7)
#define SBYTE8(x) SBYTEn(x, 8)
#define SBYTE9(x) SBYTEn(x, 9)
#define SBYTE10(x) SBYTEn(x, 10)
#define SBYTE11(x) SBYTEn(x, 11)
#define SBYTE12(x) SBYTEn(x, 12)
#define SBYTE13(x) SBYTEn(x, 13)
#define SBYTE14(x) SBYTEn(x, 14)
#define SBYTE15(x) SBYTEn(x, 15)
#define SWORD1(x) SWORDn(x, 1)
#define SWORD2(x) SWORDn(x, 2)
#define SWORD3(x) SWORDn(x, 3)
#define SWORD4(x) SWORDn(x, 4)
#define SWORD5(x) SWORDn(x, 5)
#define SWORD6(x) SWORDn(x, 6)
#define SWORD7(x) SWORDn(x, 7)

// Generate a pair of operands. S stands for 'signed'
#define __SPAIR16__(high, low) (((int16) (high) << 8) | (uint8) (low))
#define __SPAIR32__(high, low) (((int32) (high) << 16) | (uint16)(low))
#define __SPAIR64__(high, low) (((int64) (high) << 32) | (uint32)(low))
#define __SPAIR128__(high, low) (((int128) (high) << 64) | (uint64)(low))
#define __PAIR16__(high, low) (((uint16) (high) << 8) | (uint8) (low))
#define __PAIR32__(high, low) (((uint32) (high) << 16) | (uint16)(low))
#define __PAIR64__(high, low) (((uint64) (high) << 32) | (uint32)(low))
#define __PAIR128__(high, low) (((uint128)(high) << 64) | (uint64)(low))

// Helper functions to represent some assembly instructions.

#ifdef __cplusplus

// compile time assertion
#define __CASSERT_N0__(l) COMPILE_TIME_ASSERT_ ## l
#define __CASSERT_N1__(l) __CASSERT_N0__(l)
#define CASSERT(cnd) typedef char __CASSERT_N1__(__LINE__) [(cnd) ? 1 : -1]

// check that unsigned multiplication does not overflow
template<class T> bool is_mul_ok( T count, T elsize )
{

    CASSERT( T( -1 ) > 0 ); // make sure T is unsigned
    if ( elsize == 0 || count == 0 )
        return true;
    return count <= T( -1 ) / elsize;
}

// multiplication that saturates (yields the biggest value) instead of overflowing
// such a construct is useful in "operator new[]"
template<class T> bool saturated_mul( T count, T elsize )
{

    return is_mul_ok( count, elsize ) ? count * elsize : T( -1 );
}

#include <stddef.h> // for size_t

// memcpy() with determined behavoir: it always copies
// from the start to the end of the buffer
// note: it copies byte by byte, so it is not equivalent to, for example, rep movsd
inline void* qmemcpy( void* dst, const void* src, size_t cnt )
{

    char* out = ( char* ) dst;
    const char* in = ( const char* ) src;
    while ( cnt > 0 )
    {

        *out++ = *in++;
        --cnt;
    }
    return dst;
}

// rotate left
template<class T> T __ROL__( T value, int count )
{

    const uint nbits = sizeof( T ) * 8;

    if ( count > 0 )
    {

        count %= nbits;
        T high = value >> ( nbits - count );
        if ( T( -1 ) < 0 ) // signed value
            high &= ~( ( T( -1 ) << count ) );
        value <<= count;
        value |= high;
    }
    else
    {

        count = -count % nbits;
        T low = value << ( nbits - count );
        value >>= count;
        value |= low;
    }
    return value;
}

inline uint8  __ROL1__( uint8  value, int count ) {
    return __ROL__( ( uint8 ) value, count );
}
inline uint16 __ROL2__( uint16 value, int count ) {
    return __ROL__( ( uint16 ) value, count );
}
inline uint32 __ROL4__( uint32 value, int count ) {
    return __ROL__( ( uint32 ) value, count );
}
inline uint64 __ROL8__( uint64 value, int count ) {
    return __ROL__( ( uint64 ) value, count );
}
inline uint8  __ROR1__( uint8  value, int count ) {
    return __ROL__( ( uint8 ) value, -count );
}
inline uint16 __ROR2__( uint16 value, int count ) {
    return __ROL__( ( uint16 ) value, -count );
}
inline uint32 __ROR4__( uint32 value, int count ) {
    return __ROL__( ( uint32 ) value, -count );
}
inline uint64 __ROR8__( uint64 value, int count ) {
    return __ROL__( ( uint64 ) value, -count );
}

// the carry flag of a left shift
template<class T> int8 __MKCSHL__( T value, uint count )
{

    const uint nbits = sizeof( T ) * 8;
    count %= nbits;

    return ( value >> ( nbits - count ) ) & 1;
}

// the carry flag of a right shift
template<class T> int8 __MKCSHR__( T value, uint count )
{

    return ( value >> ( count - 1 ) ) & 1;
}

// sign flag
template<class T> int8 __SETS__( T x )
{

    if ( sizeof( T ) == 1 )
        return int8( x ) < 0;
    if ( sizeof( T ) == 2 )
        return int16( x ) < 0;
    if ( sizeof( T ) == 4 )
        return int32( x ) < 0;
    return int64( x ) < 0;
}

// overflow flag of subtraction (x-y)
template<class T, class U> int8 __OFSUB__( T x, U y )
{

    if ( sizeof( T ) < sizeof( U ) )
    {

        U x2 = x;
        int8 sx = __SETS__( x2 );
        return ( sx ^ __SETS__( y ) ) & ( sx ^ __SETS__( U( x2 - y ) ) );
    }
    else
    {

        T y2 = y;
        int8 sx = __SETS__( x );
        return ( sx ^ __SETS__( y2 ) ) & ( sx ^ __SETS__( T( x - y2 ) ) );
    }
}

// overflow flag of addition (x+y)
template<class T, class U> int8 __OFADD__( T x, U y )
{

    if ( sizeof( T ) < sizeof( U ) )
    {

        U x2 = x;
        int8 sx = __SETS__( x2 );
        return ( ( 1 ^ sx ) ^ __SETS__( y ) ) & ( sx ^ __SETS__( U( x2 + y ) ) );
    }
    else
    {

        T y2 = y;
        int8 sx = __SETS__( x );
        return ( ( 1 ^ sx ) ^ __SETS__( y2 ) ) & ( sx ^ __SETS__( T( x + y2 ) ) );
    }
}

// https://en.wikipedia.org/wiki/Carry_flag#Carry_flag_vs._borrow_flag
#if defined(__ARM__) || defined(__PPC__)
#define SUB_WITH_CARRY 1
#else
#define SUB_WITH_CARRY 0
#endif

// carry flag of subtraction (x-y)
template<class T, class U> int8 __CFSUB__( T x, U y )
{

    int size = sizeof( T ) > sizeof( U ) ? sizeof( T ) : sizeof( U );
    bool res;
    if ( size == 1 )
        res = uint8( x ) < uint8( y );
    else if ( size == 2 )
        res = uint16( x ) < uint16( y );
    else if ( size == 4 )
        res = uint32( x ) < uint32( y );
    else
        res = uint64( x ) < uint64( y );
#if SUB_WITH_CARRY
    res = !res;
#endif
    return res;
}

// carry flag of addition (x+y)
template<class T, class U> int8 __CFADD__( T x, U y )
{

    int size = sizeof( T ) > sizeof( U ) ? sizeof( T ) : sizeof( U );
    if ( size == 1 )
        return uint8( x ) > uint8( x + y );
    if ( size == 2 )
        return uint16( x ) > uint16( x + y );
    if ( size == 4 )
        return uint32( x ) > uint32( x + y );
    return uint64( x ) > uint64( x + y );
}

// carry flag of subtraction with carry
template<class T, class U> int8 __CFSUB__( T x, U y, int8 cf )
{

#if SUB_WITH_CARRY
    cf = !cf;
#endif
    return __CFADD__( y, cf ) ^ __CFSUB( x, y + cf );
}

// overflow flag of subtraction with carry
template<class T, class U> int8 __OFSUB__( T x, U y, int8 cf )
{

#if SUB_WITH_CARRY
    cf = !cf;
#endif
    return __OFADD__( y, cf ) ^ __OFSUB( x, y + cf );
}

inline uint8   abs8( int8     x ) {
    return x >= 0 ? x : -x;
}
inline uint16  abs16( int16   x ) {
    return x >= 0 ? x : -x;
}
inline uint32  abs32( int32   x ) {
    return x >= 0 ? x : -x;
}
inline uint64  abs64( int64   x ) {
    return x >= 0 ? x : -x;
}
//inline uint128 abs128(int128 x) { return x >= 0 ? x : -x; }

#include <string.h> // for memcpy
#include <type_traits> // for enable_if

template <typename T, typename F>
inline typename std::enable_if<sizeof( T ) <= sizeof( F ), T>::type __coerce( F f )
{

    T t;
    memcpy( &t, &f, sizeof( T ) );
    return t;
}
#define COERCE_FLOAT(v) __coerce<float>(v)
#define COERCE_DOUBLE(v) __coerce<double>(v)
#define COERCE_LONG_DOUBLE(v) __coerce<long double>(v)
#define COERCE_UNSIGNED_INT(v) __coerce<unsigned int>(v)
#define COERCE_UNSIGNED_INT64(v) __coerce<uint64>(v)

#else // C++
// For C, we just provide macros, they are not quite correct.
#define __ROL__(x, y) __rotl__(x, y) // Rotate left
#define __ROR__(x, y) __rotr__(x, y) // Rotate right
#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x<<y)
#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x>>y)
#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)
#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)
#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)
#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)

#define abs8(x) (int8) ((int8) (x) >= 0 ? (x) : -(x))
#define abs16(x) (int16) ((int16) (x) >= 0 ? (x) : -(x))
#define abs32(x) (int32) ((int32) (x) >= 0 ? (x) : -(x))
#define abs64(x) (int64) ((int64) (x) >= 0 ? (x) : -(x))
#define abs128(x) (int128)((int128)(x) >= 0 ? (x) : -(x))

#endif // C++

#if defined(__MIPS__)
// traps for MIPS arithmetic operation
void __noreturn __integer_oveflow( void ); // SIGFPE/FPE_INTOVF
void __noreturn __divide_by_zero( void );  // SIGFPE/FPE_INTDIV
void __noreturn __trap( uint16 trapcode ); // SIGTRAP
void __noreturn __break( uint16 code, uint16 subcode );
#endif

// No definition for rcl/rcr because the carry flag is unknown
#define __RCL__(x, y) invalid_operation // Rotate left thru carry
#define __RCR__(x, y) invalid_operation // Rotate right thru carry
#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL
#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR
#define __SETP__(x, y) invalid_operation // Generate parity flag for (x-y)

// In the decompilation listing there are some objects declared as _UNKNOWN
// because we could not determine their types. Since the C compiler does not
// accept void item declarations, we replace them by anything of our choice,
// for example a char:

#define _UNKNOWN char

//#ifdef _MSC_VER
//#define snprintf _snprintf
//#define vsnprintf _vsnprintf
//#endif

// The ADJ() macro is used for shifted pointers.
// While compilers do not understand it, it makes the code more readable.
// A shifted pointer is declared like this, for example:
// char *__shifted(mystruct,8) p;
// It means: while 'p' points to 'char', it also points to the middle of 'mystruct'.
// More precisely, it is at the offset of 8 bytes from the beginning of 'mystruct'.
//
// The ADJ() macro performs the necessary adjustment.
// The __parentof() and __deltaof() functions are made up, they do not exist.
// __parentof() returns the parent structure type.
// __deltaof() returns the shift amount.

#define ADJ(p) (__parentof(p) *)(p-__deltaof(p))

#endif // HEXRAYS_DEFS_H

```

`module/Memory.h`:

```h
// Memory.h
#pragma once
#include <cstdint>

namespace Memory
{
	inline bool CheckValid( std::uint64_t ptr )
	{
		return ( ptr > 0x00010000 && ptr < 0x7FFFFFFEFFFF );
	}
}
```

`module/Offsets.h`:

```h
// Offsets.h
#pragma once
#include <cstdint>

namespace Offsets
{
	inline constexpr std::uint64_t GameManager = 0x81F7A60;
	inline constexpr std::uint64_t RoundManager = 0x7583058;
}
```

`module/Player.h`:

```h
// Player.h
#pragma once
#include <cstdint>
#include <numeric>

#include "Direct.h" 
#include "DynamicPad.h" 
#include "Offsets.h"
#include "VTable.h"

namespace SDK
{ 
	namespace Player
	{
		class _PawnComponent;
		class _ActorDescriptor;
		class _WeaponManager;

		class _Entity
		{
		public:
			union
			{
				VTable::Table* vtable;
				MEMBER( std::uint64_t, pPawnComponent, 0x38 );
			};

			auto PawnComponent( ) -> _PawnComponent*  
			{
				if ( !this->pPawnComponent )
					return {};

				return reinterpret_cast< _PawnComponent* >( ( ( this->pPawnComponent - 0x46 ) ^ 0x7F ) + 0x4B10EB6F874EE4C7 );
			} 
		};

		class _PawnComponent
		{
		public:
			union
			{
				VTable::Table* vtable;
				MEMBER( std::uint64_t, pActorDescriptor, 0x18 );
			};

			auto ActorDescriptor( ) -> _ActorDescriptor*  
			{
				if ( !this->pActorDescriptor )
					return {};

				return reinterpret_cast< _ActorDescriptor* >( ( ( this->pActorDescriptor - 0x64 ) ^ 0x47A9D613D41EBE75 ) - 0x12 );
			} 
		};

		class _ActorDescriptor // base entity
		{
		public:
			union
			{
				VTable::Table* vtable;
				MEMBER( std::uint64_t, pComponentList, 0xD8 );  
				MEMBER( std::uint8_t, pComponentListSize, 0xE0 );  
				MEMBER( std::uint8_t, pWeaponIndex, 0x221 ); 
			};
			 
			auto GetComponent( std::uint8_t idx ) -> std::uint64_t
			{
				if ( idx > this->pComponentListSize )
					return {};

				return *( std::uint64_t* ) ( this->pComponentList + ( idx * sizeof( std::uint64_t ) ) );
			}

			auto ActiveWeapon( ) -> _WeaponManager*  
			{     
				auto CurrentWeapon = std::rotl( *( std::uint64_t* ) ( ( *( std::uint64_t* ) ( ( *( std::uint64_t* ) ( ( *( uint64_t* ) ( this->GetComponent( this->pWeaponIndex ) + 0x68 ) ^ 0x4310901AECDBC648i64 ) + 0x702BB7122605A1Ci64 ) ) + 0x1B0 ) ) + 0x268 ) - 0x6B88C874D9CB6D0Ai64, 0x2E ) - 0x8855542A312108Bi64; // Lets not talk about this...
				
				if ( !CurrentWeapon )
					return { }; 

				return reinterpret_cast< _WeaponManager* >( CurrentWeapon );
			} 
		};

		class _WeaponManager
		{
		public:
			union
			{
				VTable::Table* vtable;
				MEMBER( std::uint32_t, pWeaponSpread, 0x30 );
			};

			auto Shoot( ) -> void	// Shoot Wrapper
			{
				reinterpret_cast						// call
					< void( __fastcall* )( __int64 ) >	// declaration
					( Direct::ImageBase( ) + 0x788690 )	// address
					( ( __int64 ) this );				// parameter
			}
			auto SetSpread( std::uint32_t value ) ->void
			{
				this->pWeaponSpread = std::rotr<uint32_t>( std::rotr<uint32_t>( *( uint32_t* ) ( &value ), 24 ) + 1992768509, 1 );
			}
		};
	}
}

```

`module/RoundManager.h`:

```h
// RoundManager.h
#pragma once
#include <cstdint>
#include <numeric>

#include "Direct.h" 
#include "DynamicPad.h" 
#include "Offsets.h"
#include "VTable.h"
 
namespace SDK
{
	enum class StateID : std::uint32_t
	{
		RoundSwap = 0,
		OperatorSelection,
		PreperationPhase,
		ActionPhase,
		RoundEnd,
		MainMenu
	};

	namespace Manager
	{
		class _RoundManager
		{
		public:
			union
			{
				VTable::Table* vtable;
				MEMBER( std::uint32_t, pRoundState, 0xF8 );
			};

			auto RoundState( ) -> StateID
			{
				return static_cast< StateID >( ( ( this->pRoundState ^ 0x98A1F310 ) >> 0x6 ) - 0x27 );
			}
		};

		auto GetRoundManager( ) -> _RoundManager*
		{
			return reinterpret_cast< _RoundManager* >( std::rotl( *( std::uint64_t* ) ( Direct::ImageBase() + Offsets::RoundManager ) + 0x2C797E6189BC6F4D, 0x2D ) + 0x377614FB328C2FA0 );
		}
	}

	inline Manager::_RoundManager* RoundManager;
}
```

`module/SDK.h`:

```h
// SDK.h
#include "GameManager.h"
#include "RoundManager.h"
 
namespace SDK
{
	namespace Manager
	{
		auto InitializeManagers( ) -> BOOL
		{
			SDK::RoundManager = GetRoundManager( ); 
			if ( !SDK::RoundManager )
			{
				MessageBoxA( 0, x( "RoundManager Invalid" ), x( "InitializeManagers" ), MB_ICONERROR );
				return FALSE;
			}

			SDK::GameManager = GetGameManager( );
			if ( !SDK::GameManager )
			{
				MessageBoxA( 0, x( "GameManager Invalid" ), x( "InitializeManagers" ), MB_ICONERROR );
				return FALSE;
			}
			return TRUE;
		}
	}  
}

```

`module/VTable.h`:

```h
// VTable.h
#pragma once

#include <cstdint>
#include "Memory.h"

namespace VTable
{
	auto estimate_count( std::uint64_t* vmt ) -> size_t
	{
		auto method_count = 0;
		for ( auto idx = 0;; method_count++, idx++ ) { if ( !vmt[ idx ] ) break; }

		return method_count;
	}

	struct Table
	{
		template <size_t idx, typename T> auto get_idx( ) const noexcept -> const T
		{
			return reinterpret_cast< const T* >( this )[ idx ];
		}

		template <size_t off, typename T> auto get_off( ) const noexcept -> const T
		{
			return *reinterpret_cast< const T* >( reinterpret_cast< std::uintptr_t >( this ) + off );
		}
	};
}
```

`module/Vectors.h`:

```h
#pragma once

#include <cstdint>
#include <xmmintrin.h>
#include <math.h>

namespace std
{
	class vec2_t
	{
	public:
		float x, y;

		inline vec2_t( )
		{
			x = y = 0.f;
		}

		inline vec2_t( float _x, float _y )
		{
			x = _x; y = _y;
		}
	};

	class vec3_t
	{
	public:
		float x, y, z;

		inline vec3_t( )
		{
			x = y = z = 0.f;
		}

		inline vec3_t( float _x, float _y, float _z )
		{
			x = _x; y = _y; z = _z;
		}

		vec3_t operator-( vec3_t v )
		{
			vec3_t ret;
			ret.x = this->x - v.x;
			ret.y = this->y - v.y;
			ret.z = this->z - v.z;
			return ret;
		}
		vec3_t operator*( float f )
		{
			vec3_t ret;
			ret.x = this->x * f;
			ret.y = this->y * f;
			ret.z = this->z * f;
			return ret;
		}

		vec3_t operator-( float f )
		{
			vec3_t ret;
			ret.x = this->x - f;
			ret.y = this->y - f;
			ret.z = this->z - f;
			return ret;
		}

		vec3_t operator/( float f )
		{
			vec3_t ret;
			ret.x = this->x / f;
			ret.y = this->y / f;
			ret.z = this->z / f;
			return ret;
		}

		void normalize( )
		{
			while ( this->x > 180.0f ) {
				this->x -= 360.0f;
			}
			while ( this->x < -180.0f ) {
				this->x += 360.0f;
			}
			while ( this->y > 180.0f ) {
				this->y -= 360.0f;
			}
			while ( this->y < -180.0f ) {
				this->y += 360.0f;
			}
			this->z = 0.0f;
		}

		inline float dot( vec3_t v )
		{
			return this->x * v.x + this->y * v.y + this->z * v.z;
		}

		inline float angle( vec3_t dst )
		{
			float _x = this->x - dst.x; //calculating number to square in next step
			float _y = this->y - dst.y;
			float dist;

			dist = pow( _x, 2 ) + pow( _y, 2 );       //calculating Euclidean distance
			dist = sqrt( dist );

			return dist;
		}
	};

	class vec4_t
	{
	public:
		float x, y, z, w;

		inline vec4_t( )
		{
			x = y = z = w = 0.f;
		}

		inline vec4_t( float _x, float _y, float _z, float _w )
		{
			x = _x; y = _y; z = _z; w = _w;
		}
	};
}
 

```

`module/XorString.h`:

```h
#pragma once

#include <type_traits>

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter( T* data )
		{
			crypt( data );
		}

		__forceinline T* get( )
		{
			return _storage;
		}

		__forceinline int size( ) // (w)char count
		{
			return _size;
		}

		__forceinline  char key( )
		{
			return _key1;
		}

		__forceinline  T* encrypt( )
		{
			if ( !isEncrypted( ) )
				crypt( _storage );

			return _storage;
		}

		__forceinline  T* decrypt( )
		{
			if ( isEncrypted( ) )
				crypt( _storage );

			return _storage;
		}

		__forceinline bool isEncrypted( )
		{
			return _storage[ _size - 1 ] != 0;
		}

		__forceinline void clear( ) // set full storage to 0
		{
			for ( int i = 0; i < _size; i++ )
			{
				_storage[ i ] = 0;
			}
		}

		__forceinline operator T* ( )
		{
			decrypt( );

			return _storage;
		}

	private:
		__forceinline constexpr void crypt( T* data )
		{
			for ( int i = 0; i < _size; i++ )
			{
				_storage[ i ] = data[ i ] ^ ( _key1 + i % ( 1 + _key2 ) );
			}
		}

		T _storage[ _size ]{};
	};
}

#define x(str) _x(str).decrypt()
#define _x(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()
```

`module/dllmain.cpp`:

```cpp
// dllmain.cpp  
#define WIN32_LEAN_AND_MEAN 
#include <windows.h>
#include "XorString.h"
#include "Cheat.h"
BOOL DoOnce = false;
BOOL __stdcall DllMain( HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved )
{
    if ( !DoOnce )
    {
        DoOnce = true;
        CreateThread( 0, 0, ( LPTHREAD_START_ROUTINE ) Cheat::Run, 0, 0, 0 ); // detected
    }
    return TRUE;
}


```

`module/module.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c9d3db3a-3ed2-4db9-b843-d18155fdf12b}</ProjectGuid>
    <RootNamespace>module</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;MODULE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;MODULE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;MODULE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;MODULE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <ExceptionHandling>Async</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Cheat.h" />
    <ClInclude Include="Direct.h" />
    <ClInclude Include="DynamicPad.h" />
    <ClInclude Include="GameManager.h" />
    <ClInclude Include="Hexrays.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="Player.h" />
    <ClInclude Include="RoundManager.h" />
    <ClInclude Include="SDK.h" />
    <ClInclude Include="Vectors.h" />
    <ClInclude Include="VTable.h" />
    <ClInclude Include="XorString.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Direct.asm">
      <FileType>Document</FileType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`module/module.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\SDK">
      <UniqueIdentifier>{6a1aebee-e33c-4512-8585-816ab1d00b2a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Utility">
      <UniqueIdentifier>{9a7ffa4f-b503-445c-8fff-01c02a927776}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\SDK\Managers">
      <UniqueIdentifier>{db777e9e-b460-4bd2-a4a4-73aaf7a6a886}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\SDK\GameClasses">
      <UniqueIdentifier>{ce409372-ca50-4cb6-972d-f4121141eaef}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Cheat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK.h">
      <Filter>Header Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="RoundManager.h">
      <Filter>Header Files\SDK\Managers</Filter>
    </ClInclude>
    <ClInclude Include="Direct.h">
      <Filter>Header Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="Hexrays.h">
      <Filter>Header Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="DynamicPad.h">
      <Filter>Header Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="XorString.h">
      <Filter>Header Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="VTable.h">
      <Filter>Header Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Header Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="Vectors.h">
      <Filter>Header Files\Utility</Filter>
    </ClInclude>
    <ClInclude Include="GameManager.h">
      <Filter>Header Files\SDK\Managers</Filter>
    </ClInclude>
    <ClInclude Include="Player.h">
      <Filter>Header Files\SDK\GameClasses</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Direct.asm">
      <Filter>Header Files\Utility</Filter>
    </MASM>
  </ItemGroup>
</Project>
```