Project Path: arc_gmh5225_dumpulator_kg972nnv

Source Tree:

```txt
arc_gmh5225_dumpulator_kg972nnv
├── LICENSE
├── README.md
├── pyproject.toml
├── setup.cfg
├── setup.py
├── src
│   ├── dumpulator
│   │   ├── __init__.py
│   │   ├── dumpulator.py
│   │   ├── native.py
│   │   ├── ntenums.py
│   │   ├── ntprimitives.py
│   │   ├── ntstructs.py
│   │   └── ntsyscalls.py
│   └── minidump
│       ├── README.md
│       ├── __amain__.py
│       ├── __init__.py
│       ├── __main__.py
│       ├── _version.py
│       ├── aminidumpfile.py
│       ├── aminidumpreader.py
│       ├── common_structs.py
│       ├── constants.py
│       ├── directory.py
│       ├── exceptions.py
│       ├── header.py
│       ├── minidumpfile.py
│       ├── minidumpreader.py
│       ├── minidumpshell.py
│       ├── streams
│       │   ├── CommentStreamA.py
│       │   ├── CommentStreamW.py
│       │   ├── ContextStream.py
│       │   ├── ExceptionStream.py
│       │   ├── FunctionTableStream.py
│       │   ├── HandleDataStream.py
│       │   ├── HandleOperationListStream.py
│       │   ├── JavaScriptDataStream.py
│       │   ├── LastReservedStream.py
│       │   ├── Memory64ListStream.py
│       │   ├── MemoryInfoListStream.py
│       │   ├── MemoryListStream.py
│       │   ├── MiscInfoStream.py
│       │   ├── ModuleListStream.py
│       │   ├── ProcessVmCountersStream.py
│       │   ├── SystemInfoStream.py
│       │   ├── SystemMemoryInfoStream.py
│       │   ├── ThreadExListStream.py
│       │   ├── ThreadInfoListStream.py
│       │   ├── ThreadListStream.py
│       │   ├── TokenStream.py
│       │   ├── UnloadedModuleListStream.py
│       │   └── __init__.py
│       ├── utils
│       │   ├── __init__.py
│       │   ├── createminidump.py
│       │   ├── privileges.py
│       │   ├── privileges_types.py
│       │   └── winapi
│       │       ├── __init__.py
│       │       ├── defines.py
│       │       ├── kernel32.py
│       │       ├── psapi.py
│       │       └── version.py
│       ├── win_datatypes.py
│       └── writer.py
├── tests
│   ├── StringEncryptionFun
│   │   ├── StringEncryptionFun
│   │   │   ├── StringEncryptionFun.vcxproj
│   │   │   ├── StringEncryptionFun.vcxproj.filters
│   │   │   ├── decryption.cpp
│   │   │   └── main.cpp
│   │   └── StringEncryptionFun.sln
│   ├── emulate-process.py
│   ├── execute-dump.py
│   ├── getting-started.py
│   ├── getting-started32.py
│   └── x64dbg-tracedump.py
└── utils
    ├── parse_phnt.py
    └── phnt.c

```

`LICENSE`:

```
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
# dumpulator

**Note: This is a work-in-progress prototype, please treat it as such.**

An easy-to-use library for emulating code in minidump files.

There is an [introduction video](https://m.youtube.com/watch?v=4Pfu98Xx9Yo) with [OALabs](https://oalabs.openanalysis.net) available!

## Examples

### Calling a function

The example below opens `StringEncryptionFun_x64.dmp` (download a copy [here](https://github.com/mrexodia/dumpulator/releases/download/v0.0.1/StringEncryptionFun_x64.dmp)), allocates some memory and calls the decryption function at `0x140001000` to decrypt the string at `0x140017000`:

```python
from dumpulator import Dumpulator

dp = Dumpulator("StringEncryptionFun_x64.dmp")
temp_addr = dp.allocate(256)
dp.call(0x140001000, [temp_addr, 0x140017000])
decrypted = dp.read_str(temp_addr)
print(f"decrypted: '{decrypted}'")
```

The `StringEncryptionFun_x64.dmp` is collected at the entry point of the `tests/StringEncryptionFun` example. You can get the compiled binaries for `StringEncryptionFun` [here](https://github.com/mrexodia/dumpulator/releases/download/v0.0.1/StringEncryptionFun.7z)

### Tracing execution

```python
from dumpulator import Dumpulator

dp = Dumpulator("StringEncryptionFun_x64.dmp", trace=True)
dp.start(dp.regs.rip)
```

This will create `StringEncryptionFun_x64.dmp.trace` with a list of instructions executed and some helpful indications when switching modules etc. Note that tracing _significantly_ slows down emulation and it's mostly meant for debugging.

### Reading utf-16 strings

```python
from dumpulator import Dumpulator

dp = Dumpulator("my.dmp")
buf = dp.call(0x140001000)
dp.read_str(buf, encoding='utf-16')
```

### Running a snippet of code

Say you have the following function:

```
00007FFFC81C06C0 | mov qword ptr [rsp+0x10],rbx       ; prolog_start
00007FFFC81C06C5 | mov qword ptr [rsp+0x18],rsi
00007FFFC81C06CA | push rbp
00007FFFC81C06CB | push rdi
00007FFFC81C06CC | push r14
00007FFFC81C06CE | lea rbp,qword ptr [rsp-0x100]
00007FFFC81C06D6 | sub rsp,0x200                      ; prolog_end
00007FFFC81C06DD | mov rax,qword ptr [0x7FFFC8272510]
```

You only want to execute the prolog and set up some registers:

```python
from dumpulator import Dumpulator

prolog_start = 0x00007FFFC81C06C0
# we want to stop the instruction after the prolog
prolog_end = 00007FFFC81C06D6 + 7

dp = Dumpulator("my.dmp", quiet=True)
dp.regs.rcx = 0x1337
dp.start(start=prolog_start, end=prolog_end)
print(f"rsp: {hex(dp.regs.rsp)}")
```

The `quiet` flag suppresses the logs about DLLs loaded and memory regions set up (for use in scripts where you want to reduce log spam).

## Collecting the dump

There is a simple [x64dbg](https://github.com/x64dbg/x64dbg) plugin available called [MiniDumpPlugin](https://github.com/mrexodia/MiniDumpPlugin/releases). To create a dump, pause execution and execute the command `MiniDump my.dmp`.

## Installation

From [PyPI](https://pypi.org/project/dumpulator) (latest [release](https://github.com/mrexodia/dumpulator/releases)):

```
python -m pip install dumpulator
```

To install from source:

```
python setup.py install
```

Install for a development environment:

```
python setup.py develop
```

## Related work

- [Dumpulator-IDA](https://github.com/michaeljgoodman/Dumpulator-IDA): This project is a small POC plugin for launching dumpulator emulation within IDA, passing it addresses from your IDA view using the context menu.
- [wtf](https://github.com/0vercl0k/wtf): Distributed, code-coverage guided, customizable, cross-platform snapshot-based fuzzer designed for attacking user and / or kernel-mode targets running on Microsoft Windows
- [speakeasy](https://github.com/mandiant/speakeasy): Windows sandbox on top of unicorn.
- [qiling](https://github.com/qilingframework/qiling): Binary emulation framework on top of unicorn.

What sets dumpulator apart from sandboxes like speakeasy and qiling is that the full process memory is available. This improves performance because you can emulate large parts of malware without ever leaving unicorn. Additionally only syscalls have to be emulated to provide a realistic Windows environment (since everything actually _is_ a legitimate process environment).

## Credits

- [herrcore](https://twitter.com/herrcore) for inspiring me to make this
- [secret club](https://secret.club)

```

`pyproject.toml`:

```toml
# Source: https://packaging.python.org/tutorials/packaging-projects/#creating-pyproject-toml

[build-system]
requires = [
    "setuptools>=42",
    "wheel"
]
build-backend = "setuptools.build_meta"

```

`setup.cfg`:

```cfg
# Source: https://packaging.python.org/tutorials/packaging-projects/#configuring-metadata

[metadata]
name = dumpulator
version = v0.0.3
author = Duncan Ogilvie
author_email = dumpulator@mrexodia.re
description = An easy-to-use library for emulating code in minidump files.
long_description = file: README.md
long_description_content_type = text/markdown
url = https://github.com/mrexodia/dumpulator
project_urls =
    Bug Tracker = https://github.com/mrexodia/dumpulator/issues
classifiers =
    Programming Language :: Python :: 3
    License :: OSI Approved :: Boost Software License 1.0 (BSL-1.0)
    Operating System :: OS Independent

[options]
package_dir =
    = src
packages = find:
python_requires = >=3.6
install_requires =
    #minidump ~=0.0.21 # this library has a bug, is vendored locally
    unicorn ~=1.0.3
    pefile >=2021.9.3
    capstone ~=4.0.2

[options.packages.find]
where = src

```

`setup.py`:

```py
#!/usr/bin/env python

# Based on: https://stackoverflow.com/a/62983901/1806760

import setuptools
import os

if __name__ == "__main__":
    ref_name = os.getenv("GITHUB_REF_NAME")
    if ref_name:
        from pkg_resources import parse_version
        try:
            parse_version(ref_name)
            print(f"injecting version = {ref_name} into setup.cfg")
            with open("setup.cfg", "r") as f:
                lines = f.readlines()
            with open("setup.cfg", "w") as f:
                for line in lines:
                    if line.startswith("version = "):
                        line = f"version = {ref_name}\n"
                    f.write(line)
        except:
            pass

    setuptools.setup()

```

`src/dumpulator/__init__.py`:

```py
from .dumpulator import Dumpulator
from .ntsyscalls import syscall

```

`src/dumpulator/dumpulator.py`:

```py
import traceback
from enum import Enum
from typing import List, Union

from minidump.minidumpfile import *
from unicorn import *
from unicorn.x86_const import *
from pefile import *
import inspect
from .native import *
from capstone import *
from collections import OrderedDict

syscall_functions = {}


CAVE_ADDR = 0x5000
CAVE_SIZE = 0x1000
# GDT Constants needed to set our emulator into protected mode
# Access bits
class GDT_ACCESS_BITS:
    ProtMode32 = 0x4
    PresentBit = 0x80
    Ring3 = 0x60
    Ring0 = 0
    DataWritable = 0x2
    CodeReadable = 0x2
    DirectionConformingBit = 0x4
    Code = 0x18
    Data = 0x10

class GDT_FLAGS:
    Ring3 = 0x3
    Ring0 = 0


def map_unicorn_perms(protect: AllocationProtect):
    if isinstance(protect, int):
        protect = AllocationProtect(protect)
    mapping = {
        AllocationProtect.PAGE_EXECUTE: UC_PROT_EXEC | UC_PROT_READ,
        AllocationProtect.PAGE_EXECUTE_READ: UC_PROT_EXEC | UC_PROT_READ,
        AllocationProtect.PAGE_EXECUTE_READWRITE: UC_PROT_ALL,
        AllocationProtect.PAGE_EXECUTE_WRITECOPY: UC_PROT_ALL,
        AllocationProtect.PAGE_NOACCESS: UC_PROT_NONE,
        AllocationProtect.PAGE_READONLY: UC_PROT_READ,
        AllocationProtect.PAGE_READWRITE: UC_PROT_READ | UC_PROT_WRITE,
        AllocationProtect.PAGE_WRITECOPY: UC_PROT_READ | UC_PROT_WRITE,
    }
    return mapping.get(protect, UC_PROT_NONE)


class Registers:
    def __init__(self, uc: Uc, x64):
        self._uc = uc
        self._x64 = x64
        self._regmap = {
            "ah": UC_X86_REG_AH,
            "al": UC_X86_REG_AL,
            "ax": UC_X86_REG_AX,
            "bh": UC_X86_REG_BH,
            "bl": UC_X86_REG_BL,
            "bp": UC_X86_REG_BP,
            "bpl": UC_X86_REG_BPL,
            "bx": UC_X86_REG_BX,
            "ch": UC_X86_REG_CH,
            "cl": UC_X86_REG_CL,
            "cs": UC_X86_REG_CS,
            "cx": UC_X86_REG_CX,
            "dh": UC_X86_REG_DH,
            "di": UC_X86_REG_DI,
            "dil": UC_X86_REG_DIL,
            "dl": UC_X86_REG_DL,
            "ds": UC_X86_REG_DS,
            "dx": UC_X86_REG_DX,
            "eax": UC_X86_REG_EAX,
            "ebp": UC_X86_REG_EBP,
            "ebx": UC_X86_REG_EBX,
            "ecx": UC_X86_REG_ECX,
            "edi": UC_X86_REG_EDI,
            "edx": UC_X86_REG_EDX,
            "eflags": UC_X86_REG_EFLAGS,
            "eip": UC_X86_REG_EIP,
            "es": UC_X86_REG_ES,
            "esi": UC_X86_REG_ESI,
            "esp": UC_X86_REG_ESP,
            "fpsw": UC_X86_REG_FPSW,
            "fs": UC_X86_REG_FS,
            "gs": UC_X86_REG_GS,
            "ip": UC_X86_REG_IP,
            "rax": UC_X86_REG_RAX,
            "rbp": UC_X86_REG_RBP,
            "rbx": UC_X86_REG_RBX,
            "rcx": UC_X86_REG_RCX,
            "rdi": UC_X86_REG_RDI,
            "rdx": UC_X86_REG_RDX,
            "rip": UC_X86_REG_RIP,
            "rsi": UC_X86_REG_RSI,
            "rsp": UC_X86_REG_RSP,
            "si": UC_X86_REG_SI,
            "sil": UC_X86_REG_SIL,
            "sp": UC_X86_REG_SP,
            "spl": UC_X86_REG_SPL,
            "ss": UC_X86_REG_SS,
            "cr0": UC_X86_REG_CR0,
            "cr1": UC_X86_REG_CR1,
            "cr2": UC_X86_REG_CR2,
            "cr3": UC_X86_REG_CR3,
            "cr4": UC_X86_REG_CR4,
            "cr8": UC_X86_REG_CR8,
            "dr0": UC_X86_REG_DR0,
            "dr1": UC_X86_REG_DR1,
            "dr2": UC_X86_REG_DR2,
            "dr3": UC_X86_REG_DR3,
            "dr4": UC_X86_REG_DR4,
            "dr5": UC_X86_REG_DR5,
            "dr6": UC_X86_REG_DR6,
            "dr7": UC_X86_REG_DR7,
            "fp0": UC_X86_REG_FP0,
            "fp1": UC_X86_REG_FP1,
            "fp2": UC_X86_REG_FP2,
            "fp3": UC_X86_REG_FP3,
            "fp4": UC_X86_REG_FP4,
            "fp5": UC_X86_REG_FP5,
            "fp6": UC_X86_REG_FP6,
            "fp7": UC_X86_REG_FP7,
            "k0": UC_X86_REG_K0,
            "k1": UC_X86_REG_K1,
            "k2": UC_X86_REG_K2,
            "k3": UC_X86_REG_K3,
            "k4": UC_X86_REG_K4,
            "k5": UC_X86_REG_K5,
            "k6": UC_X86_REG_K6,
            "k7": UC_X86_REG_K7,
            "mm0": UC_X86_REG_MM0,
            "mm1": UC_X86_REG_MM1,
            "mm2": UC_X86_REG_MM2,
            "mm3": UC_X86_REG_MM3,
            "mm4": UC_X86_REG_MM4,
            "mm5": UC_X86_REG_MM5,
            "mm6": UC_X86_REG_MM6,
            "mm7": UC_X86_REG_MM7,
            "r8": UC_X86_REG_R8,
            "r9": UC_X86_REG_R9,
            "r10": UC_X86_REG_R10,
            "r11": UC_X86_REG_R11,
            "r12": UC_X86_REG_R12,
            "r13": UC_X86_REG_R13,
            "r14": UC_X86_REG_R14,
            "r15": UC_X86_REG_R15,
            "st0": UC_X86_REG_ST0,
            "st1": UC_X86_REG_ST1,
            "st2": UC_X86_REG_ST2,
            "st3": UC_X86_REG_ST3,
            "st4": UC_X86_REG_ST4,
            "st5": UC_X86_REG_ST5,
            "st6": UC_X86_REG_ST6,
            "st7": UC_X86_REG_ST7,
            "xmm0": UC_X86_REG_XMM0,
            "xmm1": UC_X86_REG_XMM1,
            "xmm2": UC_X86_REG_XMM2,
            "xmm3": UC_X86_REG_XMM3,
            "xmm4": UC_X86_REG_XMM4,
            "xmm5": UC_X86_REG_XMM5,
            "xmm6": UC_X86_REG_XMM6,
            "xmm7": UC_X86_REG_XMM7,
            "xmm8": UC_X86_REG_XMM8,
            "xmm9": UC_X86_REG_XMM9,
            "xmm10": UC_X86_REG_XMM10,
            "xmm11": UC_X86_REG_XMM11,
            "xmm12": UC_X86_REG_XMM12,
            "xmm13": UC_X86_REG_XMM13,
            "xmm14": UC_X86_REG_XMM14,
            "xmm15": UC_X86_REG_XMM15,
            "xmm16": UC_X86_REG_XMM16,
            "xmm17": UC_X86_REG_XMM17,
            "xmm18": UC_X86_REG_XMM18,
            "xmm19": UC_X86_REG_XMM19,
            "xmm20": UC_X86_REG_XMM20,
            "xmm21": UC_X86_REG_XMM21,
            "xmm22": UC_X86_REG_XMM22,
            "xmm23": UC_X86_REG_XMM23,
            "xmm24": UC_X86_REG_XMM24,
            "xmm25": UC_X86_REG_XMM25,
            "xmm26": UC_X86_REG_XMM26,
            "xmm27": UC_X86_REG_XMM27,
            "xmm28": UC_X86_REG_XMM28,
            "xmm29": UC_X86_REG_XMM29,
            "xmm30": UC_X86_REG_XMM30,
            "xmm31": UC_X86_REG_XMM31,
            "ymm0": UC_X86_REG_YMM0,
            "ymm1": UC_X86_REG_YMM1,
            "ymm2": UC_X86_REG_YMM2,
            "ymm3": UC_X86_REG_YMM3,
            "ymm4": UC_X86_REG_YMM4,
            "ymm5": UC_X86_REG_YMM5,
            "ymm6": UC_X86_REG_YMM6,
            "ymm7": UC_X86_REG_YMM7,
            "ymm8": UC_X86_REG_YMM8,
            "ymm9": UC_X86_REG_YMM9,
            "ymm10": UC_X86_REG_YMM10,
            "ymm11": UC_X86_REG_YMM11,
            "ymm12": UC_X86_REG_YMM12,
            "ymm13": UC_X86_REG_YMM13,
            "ymm14": UC_X86_REG_YMM14,
            "ymm15": UC_X86_REG_YMM15,
            "ymm16": UC_X86_REG_YMM16,
            "ymm17": UC_X86_REG_YMM17,
            "ymm18": UC_X86_REG_YMM18,
            "ymm19": UC_X86_REG_YMM19,
            "ymm20": UC_X86_REG_YMM20,
            "ymm21": UC_X86_REG_YMM21,
            "ymm22": UC_X86_REG_YMM22,
            "ymm23": UC_X86_REG_YMM23,
            "ymm24": UC_X86_REG_YMM24,
            "ymm25": UC_X86_REG_YMM25,
            "ymm26": UC_X86_REG_YMM26,
            "ymm27": UC_X86_REG_YMM27,
            "ymm28": UC_X86_REG_YMM28,
            "ymm29": UC_X86_REG_YMM29,
            "ymm30": UC_X86_REG_YMM30,
            "ymm31": UC_X86_REG_YMM31,
            "zmm0": UC_X86_REG_ZMM0,
            "zmm1": UC_X86_REG_ZMM1,
            "zmm2": UC_X86_REG_ZMM2,
            "zmm3": UC_X86_REG_ZMM3,
            "zmm4": UC_X86_REG_ZMM4,
            "zmm5": UC_X86_REG_ZMM5,
            "zmm6": UC_X86_REG_ZMM6,
            "zmm7": UC_X86_REG_ZMM7,
            "zmm8": UC_X86_REG_ZMM8,
            "zmm9": UC_X86_REG_ZMM9,
            "zmm10": UC_X86_REG_ZMM10,
            "zmm11": UC_X86_REG_ZMM11,
            "zmm12": UC_X86_REG_ZMM12,
            "zmm13": UC_X86_REG_ZMM13,
            "zmm14": UC_X86_REG_ZMM14,
            "zmm15": UC_X86_REG_ZMM15,
            "zmm16": UC_X86_REG_ZMM16,
            "zmm17": UC_X86_REG_ZMM17,
            "zmm18": UC_X86_REG_ZMM18,
            "zmm19": UC_X86_REG_ZMM19,
            "zmm20": UC_X86_REG_ZMM20,
            "zmm21": UC_X86_REG_ZMM21,
            "zmm22": UC_X86_REG_ZMM22,
            "zmm23": UC_X86_REG_ZMM23,
            "zmm24": UC_X86_REG_ZMM24,
            "zmm25": UC_X86_REG_ZMM25,
            "zmm26": UC_X86_REG_ZMM26,
            "zmm27": UC_X86_REG_ZMM27,
            "zmm28": UC_X86_REG_ZMM28,
            "zmm29": UC_X86_REG_ZMM29,
            "zmm30": UC_X86_REG_ZMM30,
            "zmm31": UC_X86_REG_ZMM31,
            "r8b": UC_X86_REG_R8B,
            "r9b": UC_X86_REG_R9B,
            "r10b": UC_X86_REG_R10B,
            "r11b": UC_X86_REG_R11B,
            "r12b": UC_X86_REG_R12B,
            "r13b": UC_X86_REG_R13B,
            "r14b": UC_X86_REG_R14B,
            "r15b": UC_X86_REG_R15B,
            "r8d": UC_X86_REG_R8D,
            "r9d": UC_X86_REG_R9D,
            "r10d": UC_X86_REG_R10D,
            "r11d": UC_X86_REG_R11D,
            "r12d": UC_X86_REG_R12D,
            "r13d": UC_X86_REG_R13D,
            "r14d": UC_X86_REG_R14D,
            "r15d": UC_X86_REG_R15D,
            "r8w": UC_X86_REG_R8W,
            "r9w": UC_X86_REG_R9W,
            "r10w": UC_X86_REG_R10W,
            "r11w": UC_X86_REG_R11W,
            "r12w": UC_X86_REG_R12W,
            "r13w": UC_X86_REG_R13W,
            "r14w": UC_X86_REG_R14W,
            "r15w": UC_X86_REG_R15W,
            "idtr": UC_X86_REG_IDTR,
            "gdtr": UC_X86_REG_GDTR,
            "ldtr": UC_X86_REG_LDTR,
            "tr": UC_X86_REG_TR,
            "fpcw": UC_X86_REG_FPCW,
            "fptag": UC_X86_REG_FPTAG,
            "msr": UC_X86_REG_MSR,
            "mxcsr": UC_X86_REG_MXCSR,
            "fs_base": UC_X86_REG_FS_BASE,
            "gs_base": UC_X86_REG_GS_BASE,
        }
        if unicorn.__version__[0] < '2':
            self._regmap.update({
                "riz": UC_X86_REG_RIZ,
                "cr5": UC_X86_REG_CR5,
                "cr6": UC_X86_REG_CR6,
                "cr7": UC_X86_REG_CR7,
                "cr9": UC_X86_REG_CR9,
                "cr10": UC_X86_REG_CR10,
                "cr11": UC_X86_REG_CR11,
                "cr12": UC_X86_REG_CR12,
                "cr13": UC_X86_REG_CR13,
                "cr14": UC_X86_REG_CR14,
                "cr15": UC_X86_REG_CR15,
                "dr8": UC_X86_REG_DR8,
                "dr9": UC_X86_REG_DR9,
                "dr10": UC_X86_REG_DR10,
                "dr11": UC_X86_REG_DR11,
                "dr12": UC_X86_REG_DR12,
                "dr13": UC_X86_REG_DR13,
                "dr14": UC_X86_REG_DR14,
                "dr15": UC_X86_REG_DR15,
                "rflags": UC_X86_REG_EFLAGS,
            })
        else:
            self._regmap.update({
                "flags": UC_X86_REG_FLAGS,
                "rflags": UC_X86_REG_RFLAGS
            })
        if self._x64:
            self._regmap.update({
                "cax": UC_X86_REG_RAX,
                "cbx": UC_X86_REG_RBX,
                "ccx": UC_X86_REG_RCX,
                "cdx": UC_X86_REG_RDX,
                "cbp": UC_X86_REG_RBP,
                "csp": UC_X86_REG_RSP,
                "csi": UC_X86_REG_RSI,
                "cdi": UC_X86_REG_RDI,
                "cip": UC_X86_REG_RIP,
            })
        else:
            self._regmap.update({
                "cax": UC_X86_REG_EAX,
                "cbx": UC_X86_REG_EBX,
                "ccx": UC_X86_REG_ECX,
                "cdx": UC_X86_REG_EDX,
                "cbp": UC_X86_REG_EBP,
                "csp": UC_X86_REG_ESP,
                "csi": UC_X86_REG_ESI,
                "cdi": UC_X86_REG_EDI,
                "cip": UC_X86_REG_EIP,
            })

    def __getattr__(self, name: str):
        return self._uc.reg_read(self._regmap[name])

    def __setattr__(self, name: str, value):
        if name.startswith("_"):
            object.__setattr__(self, name, value)
        else:
            self._uc.reg_write(self._regmap[name], value)

    # value = dp.regs[myname]
    def __getitem__(self, name: str):
        return self.__getattr__(name)

    # dp.regs[myname] = value
    def __setitem__(self, name: str, value):
        return self.__setattr__(name, value)


class Arguments:
    def __init__(self, uc: Uc, regs: Registers, x64):
        self._uc = uc
        self._regs = regs
        self._x64 = x64

    def __getitem__(self, index):
        regs = self._regs

        if not self._x64:
            arg_addr = regs.esp + (index + 2) * 4
            data = self._uc.mem_read(arg_addr, 4)
            return struct.unpack("<I", data)[0]

        if index == 0:
            return regs.rcx
        elif index == 1:
            return regs.rdx
        elif index == 2:
            return regs.r8
        elif index == 3:
            return regs.r9
        elif index < 20:
            arg_addr = regs.rsp + (index + 1) * 8
            data = self._uc.mem_read(arg_addr, 8)
            return struct.unpack("<Q", data)[0]
        else:
            raise Exception("not implemented!")

    def __setitem__(self, index, value):
        if not self._x64:
            raise Exception("not implemented!")
        regs = self._regs
        if index == 0:
            regs.rcx = value
        elif index == 1:
            regs.rdx = value
        elif index == 2:
            regs.r8 = value
        elif index == 3:
            regs.r9 = value
        else:
            raise Exception("not implemented!")


class Dumpulator(Architecture):
    def __init__(self, minidump_file, *, trace=False, quiet=False, thread_id=None):
        self._quiet = quiet

        # Load the minidump
        self._minidump = MinidumpFile.parse(minidump_file)
        if thread_id is None and self._minidump.exception is not None:
            thread_id = self._minidump.exception.exception_records[0].ThreadId
        if thread_id is None:
            thread = self._minidump.threads.threads[0]
        else:
            thread = self._find_thread(thread_id)

        super().__init__(type(thread.ContextObject) is not WOW64_CONTEXT)
        self.addr_mask = 0xFFFFFFFFFFFFFFFF if self._x64 else 0xFFFFFFFF

        if trace:
            self.trace = open(minidump_file + ".trace", "w")
        else:
            self.trace = None

        self.last_module: Optional[MinidumpModule] = None

        mode = UC_MODE_64 if self._x64 else UC_MODE_32
        self._uc = Uc(UC_ARCH_X86, mode)

        mode = CS_MODE_64 if self._x64 else CS_MODE_32
        self.cs = Cs(CS_ARCH_X86, mode)
        self.cs.detail = True

        self.regs = Registers(self._uc, self._x64)
        self.args = Arguments(self._uc, self.regs, self._x64)
        self._allocate_base = None
        self._allocate_size = 1024 * 1024 * 10  # NOTE: 10 megs
        self._allocate_ptr = None
        self._setup_emulator(thread)
        self.exit_code = None
        self.syscalls = []
        self._setup_syscalls()
        self.exports = self._setup_exports()

    def _find_thread(self, thread_id):
        for i in range(0, len(self._minidump.threads.threads)):
            thread = self._minidump.threads.threads[i]
            if thread.ThreadId == thread_id:
                return thread
        raise Exception(f"Thread 0x{thread_id:x} ({thread_id}) not found!")

    def info(self, message: str):
        if not self._quiet:
            print(message)

    def error(self, message: str):
        print(message)

    # Source: https://github.com/mandiant/speakeasy/blob/767edd2272510a5badbab89c5f35d43a94041378/speakeasy/windows/winemu.py#L533
    def _setup_gdt(self, teb_addr):
        """
        Set up the GDT so we can access segment registers correctly
        This will be done a little differently depending on architecture
        """

        GDT_SIZE = 0x1000
        PAGE_SIZE = 0x1000
        ENTRY_SIZE = 0x8
        num_gdt_entries = 31
        gdt_addr = 0x3000

        # For a detailed explaination of whats happening here, see:
        # https://wiki.osdev.org/Global_Descriptor_Table
        # We need to init the GDT so that shellcode can accurately access
        # segment registers which is needed for TEB access in user mode

        def _make_entry(index, base, access, limit=0xFFFFF000, flags=0x4):
            access |= (GDT_ACCESS_BITS.PresentBit | GDT_ACCESS_BITS.DirectionConformingBit)
            entry = 0xFFFF & limit
            entry |= (0xFFFFFF & base) << 16
            entry |= (0xFF & access) << 40
            entry |= (0xFF & (limit >> 16)) << 48
            entry |= (0xFF & flags) << 52
            entry |= (0xFF & (base >> 24)) << 56
            entry = entry.to_bytes(8, 'little')

            offset = index * ENTRY_SIZE
            self.write(gdt_addr + offset, entry)

        def _create_selector(index, flags):
            return flags | (index << 3)

        self._uc.mem_map(gdt_addr, GDT_SIZE)

        access = (GDT_ACCESS_BITS.Data | GDT_ACCESS_BITS.DataWritable |
                  GDT_ACCESS_BITS.Ring3)
        _make_entry(16, 0, access)

        access = (GDT_ACCESS_BITS.Code | GDT_ACCESS_BITS.CodeReadable |
                  GDT_ACCESS_BITS.Ring3)
        _make_entry(17, 0, access)

        access = (GDT_ACCESS_BITS.Data | GDT_ACCESS_BITS.DataWritable |
                  GDT_ACCESS_BITS.Ring0)
        _make_entry(18, 0, access)

        # WIP: Wow64 transition
        # See: https://github.com/unicorn-engine/unicorn/issues/626#issuecomment-242826990
        access = (GDT_ACCESS_BITS.Code | GDT_ACCESS_BITS.CodeReadable |
                  GDT_ACCESS_BITS.Ring3)
        _make_entry(6, 0, access, flags=0x4 | 0x2)
        # print(f"wow64: {_create_selector(6, GDT_FLAGS.Ring3):0x}")

        self.regs.gdtr = (0, gdt_addr, num_gdt_entries * ENTRY_SIZE - 1, 0x0)
        selector = _create_selector(16, GDT_FLAGS.Ring3)
        self.regs.ds = selector
        selector = _create_selector(17, GDT_FLAGS.Ring3)
        self.regs.cs = selector
        selector = _create_selector(18, GDT_FLAGS.Ring0)
        self.regs.ss = selector

        if not self._x64:
            # FS segment needed for PEB access at fs:[0x30]

            access = (GDT_ACCESS_BITS.Data | GDT_ACCESS_BITS.DataWritable |
                      GDT_ACCESS_BITS.Ring3)
            _make_entry(19, teb_addr, access)

            selector = _create_selector(19, GDT_FLAGS.Ring3)
            self.regs.fs = selector

        else:
            # GS Segment needed for PEB access at gs:[0x60]

            access = (GDT_ACCESS_BITS.Data | GDT_ACCESS_BITS.DataWritable |
                      GDT_ACCESS_BITS.Ring3)
            _make_entry(15, teb_addr, access, limit=PAGE_SIZE)

            selector = _create_selector(15, GDT_FLAGS.Ring3)
            self.regs.gs = selector

    def _setup_emulator(self, thread):
        # set up hooks
        self._uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED | UC_HOOK_MEM_FETCH_UNMAPPED | UC_HOOK_MEM_READ_PROT | UC_HOOK_MEM_WRITE_PROT | UC_HOOK_MEM_FETCH_PROT, _hook_mem, user_data=self)
        #self._uc.hook_add(UC_HOOK_MEM_FETCH_UNMAPPED, _hook_mem, user_data=self)
        if self.trace:
            self._uc.hook_add(UC_HOOK_CODE, _hook_code, user_data=self)
        #self._uc.hook_add(UC_HOOK_MEM_READ_INVALID, self._hook_mem, user_data=None)
        #self._uc.hook_add(UC_HOOK_MEM_WRITE_INVALID, self._hook_mem, user_data=None)
        self._uc.hook_add(UC_HOOK_INSN, _hook_syscall, user_data=self, arg1=UC_X86_INS_SYSCALL)
        self._uc.hook_add(UC_HOOK_INSN, _hook_syscall, user_data=self, arg1=UC_X86_INS_SYSENTER)
        self._uc.hook_add(UC_HOOK_INTR, _hook_interrupt, user_data=self)
        self._uc.hook_add(UC_HOOK_INSN_INVALID, _hook_invalid, user_data=self)

        # map in codecave
        self._uc.mem_map(CAVE_ADDR, CAVE_SIZE)
        self._uc.mem_write(CAVE_ADDR, b"\xCC" * CAVE_SIZE)

        info: MinidumpMemoryInfo
        for info in self._minidump.memory_info.infos:
            emu_addr = info.BaseAddress & self.addr_mask
            if info.State == MemoryState.MEM_COMMIT:
                self.info(f"mapped base: 0x{emu_addr:x}, size: 0x{info.RegionSize:x}, protect: {info.Protect}")
                self._uc.mem_map(emu_addr, info.RegionSize, map_unicorn_perms(info.Protect))
            elif info.State == MemoryState.MEM_FREE and emu_addr > 0x10000 and info.RegionSize >= self._allocate_size:
                self._allocate_base = emu_addr

        memory = self._minidump.get_reader().get_buffered_reader()
        seg: MinidumpMemorySegment
        for seg in self._minidump.memory_segments_64.memory_segments:
            emu_addr = seg.start_virtual_address & self.addr_mask
            self.info(f"initialize base: 0x{emu_addr:x}, size: 0x{seg.size:x}")
            memory.move(seg.start_virtual_address)
            assert memory.current_position == seg.start_virtual_address
            data = memory.read(seg.size)
            self._uc.mem_write(emu_addr, data)

        if self._x64:
            context: CONTEXT = thread.ContextObject
            self.regs.mxcsr = context.MxCsr
            self.regs.eflags = context.EFlags
            self.regs.dr0 = context.Dr0
            self.regs.dr1 = context.Dr1
            self.regs.dr2 = context.Dr2
            self.regs.dr3 = context.Dr3
            self.regs.dr6 = context.Dr6
            self.regs.dr7 = context.Dr7
            self.regs.rax = context.Rax
            self.regs.rcx = context.Rcx
            self.regs.rdx = context.Rdx
            self.regs.rbx = context.Rbx
            self.regs.rsp = context.Rsp
            self.regs.rbp = context.Rbp
            self.regs.rsi = context.Rsi
            self.regs.rdi = context.Rdi
            self.regs.r8 = context.R8
            self.regs.r9 = context.R9
            self.regs.r10 = context.R10
            self.regs.r11 = context.R11
            self.regs.r12 = context.R12
            self.regs.r13 = context.R13
            self.regs.r14 = context.R14
            self.regs.r15 = context.R15
            self.regs.rip = context.Rip
        else:
            context: WOW64_CONTEXT = thread.ContextObject
            self.regs.eflags = context.EFlags
            self.regs.dr0 = context.Dr0
            self.regs.dr1 = context.Dr1
            self.regs.dr2 = context.Dr2
            self.regs.dr3 = context.Dr3
            self.regs.dr6 = context.Dr6
            self.regs.dr7 = context.Dr7
            self.regs.eax = context.Eax
            self.regs.ecx = context.Ecx
            self.regs.edx = context.Edx
            self.regs.ebx = context.Ebx
            self.regs.esp = context.Esp
            self.regs.ebp = context.Ebp
            self.regs.esi = context.Esi
            self.regs.edi = context.Edi
            self.regs.eip = context.Eip

        # Remove the trap flag
        self.regs.eflags &= ~0x100

        # Set up TEB
        self.teb = thread.Teb & 0xFFFFFFFFFFFFF000
        self._setup_gdt(self.teb)
        self.regs.gs_base = self.teb

        # https://en.wikipedia.org/wiki/Win32_Thread_Information_Block
        # Handle PEB
        # Retrieve console handle
        if self._x64:
            # https://www.vergiliusproject.com/kernels/x64/Windows%2011/21H2%20(RTM)/_TEB
            self.peb = self.read_ptr(self.teb + 0x60)
            # https://www.vergiliusproject.com/kernels/x64/Windows%2011/21H2%20(RTM)/_PEB
            process_parameters = self.read_ptr(self.peb + 0x20)
            # https://www.vergiliusproject.com/kernels/x64/Windows%2011/21H2%20(RTM)/_RTL_USER_PROCESS_PARAMETERS
            self.console_handle = self.read_ptr(process_parameters + 0x10)
            self.stdin_handle = self.read_ptr(process_parameters + 0x20)
            self.stdout_handle = self.read_ptr(process_parameters + 0x28)
            self.stderr_handle = self.read_ptr(process_parameters + 0x30)
        else:
            # https://www.vergiliusproject.com/kernels/x86/Windows%2010/2110%2021H2%20(November%202021%20Update)/_TEB
            self.peb = self.read_ptr(self.teb + 0x30)
            # https://www.vergiliusproject.com/kernels/x86/Windows%2010/2110%2021H2%20(November%202021%20Update)/_PEB
            process_parameters = self.read_ptr(self.peb + 0x10)
            # https://www.vergiliusproject.com/kernels/x86/Windows%2010/2110%2021H2%20(November%202021%20Update)/_RTL_USER_PROCESS_PARAMETERS
            self.console_handle = self.read_ptr(process_parameters + 0x10)
            self.stdin_handle = self.read_ptr(process_parameters + 0x18)
            self.stdout_handle = self.read_ptr(process_parameters + 0x1c)
            self.stderr_handle = self.read_ptr(process_parameters + 0x20)
        self.info(f"TEB: 0x{self.teb:x}, PEB: 0x{self.peb:x}")
        self.info(f"  ConsoleHandle: 0x{self.console_handle:x}")
        self.info(f"  StandardInput: 0x{self.stdin_handle:x}")
        self.info(f"  StandardOutput: 0x{self.stdout_handle:x}")
        self.info(f"  StandardError: 0x{self.stderr_handle:x}")

    def _setup_exports(self):
        exports = {}
        for module in self._minidump.modules.modules:
            module_name = module.name.split('\\')[-1].lower()
            self.info(f"{module_name} 0x{module.baseaddress:x}[0x{module.size:x}]")
            for export in self._parse_module_exports(module):
                if export.name:
                    name = export.name.decode("utf-8")
                else:
                    name = f"#{export.ordinal}"
                exports[module.baseaddress + export.address] = f"{module_name}:{name}"
        return exports

    def _find_module(self, name) -> MinidumpModule:
        module: MinidumpModule
        for module in self._minidump.modules.modules:
            filename = module.name.split('\\')[-1].lower()
            if filename == name.lower():
                return module
        raise Exception(f"Module '{name}' not found")

    def find_module_by_addr(self, address) -> Optional[MinidumpModule]:
        module: MinidumpModule
        for module in self._minidump.modules.modules:
            if module.baseaddress <= address < module.baseaddress + module.size:
                return module
        return None

    def _parse_module_exports(self, module):
        try:
            module_data = self.read(module.baseaddress, module.size)
        except UcError:
            self.error(f"Failed to read module data")
            return []
        pe = PE(data=module_data, fast_load=True)
        # Hack to adjust pefile to accept in-memory modules
        for section in pe.sections:
            # Potentially interesting members: Misc_PhysicalAddress, Misc_VirtualSize, SizeOfRawData
            section.PointerToRawData = section.VirtualAddress
            section.PointerToRawData_adj = section.VirtualAddress
        # Parser exports and find the syscall indices
        pe.parse_data_directories(directories=[DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_EXPORT"]])
        return pe.DIRECTORY_ENTRY_EXPORT.symbols if hasattr(pe, "DIRECTORY_ENTRY_EXPORT") else []

    def _setup_syscalls(self):
        # Load the ntdll module from memory
        ntdll = self._find_module("ntdll.dll")
        syscalls = []
        for export in self._parse_module_exports(ntdll):
            if export.name and export.name.startswith(b"Zw"):
                syscalls.append((export.address, export.name.decode("utf-8")))
            elif export.name == b"Wow64Transition":
                addr = ntdll.baseaddress + export.address
                patch_addr = self.read_ptr(addr)
                self.info(f"Patching Wow64Transition: {addr:0x} -> {patch_addr:0x}")
                # See: https://opcode0x90.wordpress.com/2007/05/18/kifastsystemcall-hook/
                # mov edx, esp; sysenter; ret
                KiFastSystemCall = b"\x8B\xD4\x0F\x34\xC3"
                self.write(patch_addr, KiFastSystemCall)

        syscalls.sort()
        for index, (rva, name) in enumerate(syscalls):
            cb = syscall_functions.get(name, None)
            argcount = 0
            if cb:
                argspec = inspect.getfullargspec(cb)
                argcount = len(argspec.args) - 1
            self.syscalls.append((name, cb, argcount))

    def push(self, value):
        csp = self.regs.csp - self.ptr_size()
        self.write_ptr(csp, value)
        self.regs.csp = csp

    def read(self, addr, size):
        return self._uc.mem_read(addr, size)

    def write(self, addr, data):
        self._uc.mem_write(addr, data)

    def protect(self, addr, size, protect):
        perms = map_unicorn_perms(protect)
        self._uc.mem_protect(addr, size, perms)

    def call(self, addr, args: List[int]=[], regs: dict={}, count=0):
        # allow passing custom registers
        for name, value in regs.items():
            self.regs.__setattr__(name, value)

        # set up arguments
        if self._x64:
            for index, value in enumerate(args):
                self.args[index] = value
        else:
            for value in reversed(args):
                self.push(value)
        # push return address
        self.push(CAVE_ADDR)
        # start emulation
        self.start(addr, end=CAVE_ADDR, count=count)
        return self.regs.cax

    def allocate(self, size):
        if not self._allocate_ptr:
            self._uc.mem_map(self._allocate_base, self._allocate_size)
            self._allocate_ptr = self._allocate_base

        ptr = self._allocate_ptr + size
        if ptr > self._allocate_base + self._allocate_size:
            raise Exception("not enough room to allocate!")
        self._allocate_ptr = ptr
        return ptr

    def start(self, begin, end=0xffffffffffffffff, count=0):
        try:
            self._uc.emu_start(begin, until=end, count=count)
            self.info(f'emulation finished, cip = {self.regs.cip:0x}')
            if self.exit_code is not None:
                self.info(f"exit code: {self.exit_code}")
        except UcError as err:
            self.error(f'error: {err}, cip = {self.regs.cip:0x}')

    def stop(self, exit_code=None):
        self.exit_code = int(exit_code)
        self._uc.emu_stop()

    def NtCurrentProcess(self):
        return 0xFFFFFFFFFFFFFFFF if self._x64 else 0xFFFFFFFF

    def NtCurrentThread(self):
        return 0xFFFFFFFFFFFFFFFE if self._x64 else 0xFFFFFFFE


def _hook_mem(uc: Uc, access, address, size, value, dp: Dumpulator):
    if access == UC_MEM_READ_UNMAPPED:
        dp.error(f"unmapped read from {address:0x}[{size:0x}], cip = {dp.regs.cip:0x}")
    elif access == UC_MEM_WRITE_UNMAPPED:
        dp.error(f"unmapped write to {address:0x}[{size:0x}] = {value:0x}, cip = {dp.regs.cip:0x}")

    elif access == UC_MEM_FETCH_UNMAPPED:
        dp.error(f"unmapped fetch of {address:0x}[{size:0x}] = {value:0x}, cip = {dp.regs.cip:0x}")
    return False

def _get_regs(instr):
    regs = OrderedDict()
    for op in instr.operands:
        if op.type == CS_OP_REG:
            regs[instr.reg_name(op.value.reg)] = None
        elif op.type == CS_OP_MEM:
            if op.value.mem.base != 0:
                regs[instr.reg_name(op.value.mem.base)] = None
            if op.value.mem.index != 0:
                regs[instr.reg_name(op.value.mem.index)] = None
    for reg in instr.regs_read:
        regs[instr.reg_name(reg)] = None
    for reg in instr.regs_write:
        regs[instr.reg_name(reg)] = None
    return regs

def _hook_code(uc: Uc, address, size, dp: Dumpulator):
    code = dp.read(address, size)
    instr = next(dp.cs.disasm(code, address, 1))
    address_name = dp.exports.get(address, "")

    module = ""
    if dp.last_module and dp.last_module.baseaddress <= address < dp.last_module.baseaddress + dp.last_module.size:
        # same module again
        pass
    else:
        # new module
        dp.last_module = dp.find_module_by_addr(address)
        if dp.last_module:
            module = dp.last_module.name.split("\\")[-1].lower()

    if address_name:
        address_name = " " + address_name
    elif module:
        address_name = " " + module

    line = f"0x{address:x}{address_name}|{instr.mnemonic}"
    if instr.op_str:
        line += " "
        line += instr.op_str
    for reg in _get_regs(instr):
        line += f"|{reg}=0x{dp.regs.__getattr__(reg):x}"
    line += "\n"
    dp.trace.write(line)
    return True


def _arg_to_string(arg):
    if isinstance(arg, Enum):
        return arg.name
    elif isinstance(arg, int):
        return hex(arg)
    elif isinstance(arg, PVOID):
        return hex(arg.ptr)
    raise NotImplemented()


def _arg_type_string(arg):
    if isinstance(arg, PVOID) and arg.type is not None:
        return arg.type.__name__ + "*"
    return type(arg).__name__


def _hook_interrupt(uc: Uc, number, dp: Dumpulator):
    dp.error(f"interrupt {number}, cip = {dp.regs.cip:0x}")
    uc.emu_stop()


def _hook_syscall(uc: Uc, dp: Dumpulator):
    index = dp.regs.cax & 0xffff
    if index < len(dp.syscalls):
        name, cb, argcount = dp.syscalls[index]
        if cb:
            argspec = inspect.getfullargspec(cb)
            args = []

            def syscall_arg(index):
                if index == 0 and dp.ptr_size() == 8:
                    return dp.regs.r10
                return dp.args[index]

            dp.info(f"syscall: {name}(")
            for i in range(0, argcount):
                argname = argspec.args[1 + i]
                argtype = argspec.annotations[argname]
                argvalue = syscall_arg(i)
                if issubclass(argtype, PVOID):
                    argvalue = argtype(argvalue, dp)
                elif issubclass(argtype, Enum):
                    try:
                        argvalue = argtype(dp.args[i])
                    except KeyError as x:
                        raise Exception(f"Unknown enum value {dp.args[i]} for {type(argtype)}")
                else:
                    argvalue = argtype(argvalue)
                args.append(argvalue)

                comma = ","
                if i + 1 == argcount:
                    comma = ""

                dp.info(f"    {_arg_type_string(argvalue)} {argname} = {_arg_to_string(argvalue)}{comma}")
            dp.info(")")
            try:
                status = cb(dp, *args)
                dp.info(f"status = {status:x}")
                dp.regs.cax = status
                dp.regs.ccx = dp.regs.cip + 2
            except Exception as exc:
                sys.stderr = sys.stdout
                traceback.print_exception(type(exc), exc, exc.__traceback__)
                dp.error(f"Exception thrown during syscall implementation, stopping emulation!")
                uc.emu_stop()
        else:
            dp.error(f"syscall index: {index:0x} -> {name} not implemented!")
            uc.emu_stop()
    else:
        dp.error(f"syscall index {index:0x} out of range")
        uc.emu_stop()

def _hook_invalid(uc: Uc, address, dp: Dumpulator):
    dp.error(f"invalid instruction at {address:0x}")
    return False

```

`src/dumpulator/native.py`:

```py
import struct
from typing import Optional
from .ntenums import *
from .ntprimitives import *
from .ntstructs import *

STATUS_SUCCESS = 0
STATUS_NOT_IMPLEMENTED = 0xC0000002
STATUS_ACCESS_DENIED = 0xC0000022
STATUS_PRIVILEGE_NOT_HELD = 0xC0000061

MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_READWRITE = 0x4

# Temporary manual definitions

class IO_APC_ROUTINE:
    pass

class IO_STATUS_BLOCK:
    pass

class LARGE_INTEGER:
    pass

class UNICODE_STRING:
    pass

def round_to_pages(size):
    return (size + 0xFFF) & 0xFFFFFFFFFFFFF000

```

`src/dumpulator/ntenums.py`:

```py
# Automatically generated with parse_phnt.py, do not edit
from enum import Enum
from .ntprimitives import make_global

class EVENT_TYPE(Enum):
    NotificationEvent = 0
    SynchronizationEvent = 1
make_global(EVENT_TYPE)

class TIMER_TYPE(Enum):
    NotificationTimer = 0
    SynchronizationTimer = 1
make_global(TIMER_TYPE)

class WAIT_TYPE(Enum):
    WaitAll = 0
    WaitAny = 1
    WaitNotification = 2
make_global(WAIT_TYPE)

class NT_PRODUCT_TYPE(Enum):
    NtProductWinNt = 1
    NtProductLanManNt = 2
    NtProductServer = 3
make_global(NT_PRODUCT_TYPE)

class SUITE_TYPE(Enum):
    SmallBusiness = 0
    Enterprise = 1
    BackOffice = 2
    CommunicationServer = 3
    TerminalServer = 4
    SmallBusinessRestricted = 5
    EmbeddedNT = 6
    DataCenter = 7
    SingleUserTS = 8
    Personal = 9
    Blade = 10
    EmbeddedRestricted = 11
    SecurityAppliance = 12
    StorageServer = 13
    ComputeServer = 14
    WHServer = 15
    PhoneNT = 16
    MaxSuiteType = 17
make_global(SUITE_TYPE)

class KTHREAD_STATE(Enum):
    Initialized = 0
    Ready = 1
    Running = 2
    Standby = 3
    Terminated = 4
    Waiting = 5
    Transition = 6
    DeferredReady = 7
    GateWaitObsolete = 8
    WaitingForProcessInSwap = 9
    MaximumThreadState = 10
make_global(KTHREAD_STATE)

class KHETERO_CPU_POLICY(Enum):
    KHeteroCpuPolicyAll = 0
    KHeteroCpuPolicyLarge = 1
    KHeteroCpuPolicyLargeOrIdle = 2
    KHeteroCpuPolicySmall = 3
    KHeteroCpuPolicySmallOrIdle = 4
    KHeteroCpuPolicyDynamic = 5
    KHeteroCpuPolicyStaticMax = 6
    KHeteroCpuPolicyBiasedSmall = 7
    KHeteroCpuPolicyBiasedLarge = 8
    KHeteroCpuPolicyDefault = 9
    KHeteroCpuPolicyMax = 10
make_global(KHETERO_CPU_POLICY)

class KWAIT_REASON(Enum):
    Executive = 0
    FreePage = 1
    PageIn = 2
    PoolAllocation = 3
    DelayExecution = 4
    Suspended = 5
    UserRequest = 6
    WrExecutive = 7
    WrFreePage = 8
    WrPageIn = 9
    WrPoolAllocation = 10
    WrDelayExecution = 11
    WrSuspended = 12
    WrUserRequest = 13
    WrEventPair = 14
    WrQueue = 15
    WrLpcReceive = 16
    WrLpcReply = 17
    WrVirtualMemory = 18
    WrPageOut = 19
    WrRendezvous = 20
    WrKeyedEvent = 21
    WrTerminated = 22
    WrProcessInSwap = 23
    WrCpuRateControl = 24
    WrCalloutStack = 25
    WrKernel = 26
    WrResource = 27
    WrPushLock = 28
    WrMutex = 29
    WrQuantumEnd = 30
    WrDispatchInt = 31
    WrPreempted = 32
    WrYieldExecution = 33
    WrFastMutex = 34
    WrGuardedMutex = 35
    WrRundown = 36
    WrAlertByThreadId = 37
    WrDeferredPreempt = 38
    WrPhysicalFault = 39
    MaximumWaitReason = 40
make_global(KWAIT_REASON)

class KPROFILE_SOURCE(Enum):
    ProfileTime = 0
    ProfileAlignmentFixup = 1
    ProfileTotalIssues = 2
    ProfilePipelineDry = 3
    ProfileLoadInstructions = 4
    ProfilePipelineFrozen = 5
    ProfileBranchInstructions = 6
    ProfileTotalNonissues = 7
    ProfileDcacheMisses = 8
    ProfileIcacheMisses = 9
    ProfileCacheMisses = 10
    ProfileBranchMispredictions = 11
    ProfileStoreInstructions = 12
    ProfileFpInstructions = 13
    ProfileIntegerInstructions = 14
    Profile2Issue = 15
    Profile3Issue = 16
    Profile4Issue = 17
    ProfileSpecialInstructions = 18
    ProfileTotalCycles = 19
    ProfileIcacheIssues = 20
    ProfileDcacheAccesses = 21
    ProfileMemoryBarrierCycles = 22
    ProfileLoadLinkedIssues = 23
    ProfileMaximum = 24
make_global(KPROFILE_SOURCE)

class LDR_DDAG_STATE(Enum):
    LdrModulesMerged = -5
    LdrModulesInitError = -4
    LdrModulesSnapError = -3
    LdrModulesUnloaded = -2
    LdrModulesUnloading = -1
    LdrModulesPlaceHolder = 0
    LdrModulesMapping = 1
    LdrModulesMapped = 2
    LdrModulesWaitingForDependencies = 3
    LdrModulesSnapping = 4
    LdrModulesSnapped = 5
    LdrModulesCondensed = 6
    LdrModulesReadyToInit = 7
    LdrModulesInitializing = 8
    LdrModulesReadyToRun = 9
make_global(LDR_DDAG_STATE)

class LDR_DLL_LOAD_REASON(Enum):
    LoadReasonStaticDependency = 0
    LoadReasonStaticForwarderDependency = 1
    LoadReasonDynamicForwarderDependency = 2
    LoadReasonDelayloadDependency = 3
    LoadReasonDynamicLoad = 4
    LoadReasonAsImageLoad = 5
    LoadReasonAsDataLoad = 6
    LoadReasonEnclavePrimary = 7
    LoadReasonEnclaveDependency = 8
    LoadReasonUnknown = -1
make_global(LDR_DLL_LOAD_REASON)

class FILTER_BOOT_OPTION_OPERATION(Enum):
    FilterBootOptionOperationOpenSystemStore = 0
    FilterBootOptionOperationSetElement = 1
    FilterBootOptionOperationDeleteElement = 2
    FilterBootOptionOperationMax = 3
make_global(FILTER_BOOT_OPTION_OPERATION)

class EVENT_INFORMATION_CLASS(Enum):
    EventBasicInformation = 0
make_global(EVENT_INFORMATION_CLASS)

class MUTANT_INFORMATION_CLASS(Enum):
    MutantBasicInformation = 0
    MutantOwnerInformation = 1
make_global(MUTANT_INFORMATION_CLASS)

class SEMAPHORE_INFORMATION_CLASS(Enum):
    SemaphoreBasicInformation = 0
make_global(SEMAPHORE_INFORMATION_CLASS)

class TIMER_INFORMATION_CLASS(Enum):
    TimerBasicInformation = 0
make_global(TIMER_INFORMATION_CLASS)

class TIMER_SET_INFORMATION_CLASS(Enum):
    TimerSetCoalescableTimer = 0
    MaxTimerInfoClass = 1
make_global(TIMER_SET_INFORMATION_CLASS)

class WNF_STATE_NAME_LIFETIME(Enum):
    WnfWellKnownStateName = 0
    WnfPermanentStateName = 1
    WnfPersistentStateName = 2
    WnfTemporaryStateName = 3
make_global(WNF_STATE_NAME_LIFETIME)

class WNF_STATE_NAME_INFORMATION(Enum):
    WnfInfoStateNameExist = 0
    WnfInfoSubscribersPresent = 1
    WnfInfoIsQuiescent = 2
make_global(WNF_STATE_NAME_INFORMATION)

class WNF_DATA_SCOPE(Enum):
    WnfDataScopeSystem = 0
    WnfDataScopeSession = 1
    WnfDataScopeUser = 2
    WnfDataScopeProcess = 3
    WnfDataScopeMachine = 4
make_global(WNF_DATA_SCOPE)

class WORKERFACTORYINFOCLASS(Enum):
    WorkerFactoryTimeout = 0
    WorkerFactoryRetryTimeout = 1
    WorkerFactoryIdleTimeout = 2
    WorkerFactoryBindingCount = 3
    WorkerFactoryThreadMinimum = 4
    WorkerFactoryThreadMaximum = 5
    WorkerFactoryPaused = 6
    WorkerFactoryBasicInformation = 7
    WorkerFactoryAdjustThreadGoal = 8
    WorkerFactoryCallbackType = 9
    WorkerFactoryStackInformation = 10
    WorkerFactoryThreadBasePriority = 11
    WorkerFactoryTimeoutWaiters = 12
    WorkerFactoryFlags = 13
    WorkerFactoryThreadSoftMaximum = 14
    WorkerFactoryThreadCpuSets = 15
    MaxWorkerFactoryInfoClass = 16
make_global(WORKERFACTORYINFOCLASS)

class SYSTEM_INFORMATION_CLASS(Enum):
    SystemBasicInformation = 0
    SystemProcessorInformation = 1
    SystemPerformanceInformation = 2
    SystemTimeOfDayInformation = 3
    SystemPathInformation = 4
    SystemProcessInformation = 5
    SystemCallCountInformation = 6
    SystemDeviceInformation = 7
    SystemProcessorPerformanceInformation = 8
    SystemFlagsInformation = 9
    SystemCallTimeInformation = 10
    SystemModuleInformation = 11
    SystemLocksInformation = 12
    SystemStackTraceInformation = 13
    SystemPagedPoolInformation = 14
    SystemNonPagedPoolInformation = 15
    SystemHandleInformation = 16
    SystemObjectInformation = 17
    SystemPageFileInformation = 18
    SystemVdmInstemulInformation = 19
    SystemVdmBopInformation = 20
    SystemFileCacheInformation = 21
    SystemPoolTagInformation = 22
    SystemInterruptInformation = 23
    SystemDpcBehaviorInformation = 24
    SystemFullMemoryInformation = 25
    SystemLoadGdiDriverInformation = 26
    SystemUnloadGdiDriverInformation = 27
    SystemTimeAdjustmentInformation = 28
    SystemSummaryMemoryInformation = 29
    SystemMirrorMemoryInformation = 30
    SystemPerformanceTraceInformation = 31
    SystemObsolete0 = 32
    SystemExceptionInformation = 33
    SystemCrashDumpStateInformation = 34
    SystemKernelDebuggerInformation = 35
    SystemContextSwitchInformation = 36
    SystemRegistryQuotaInformation = 37
    SystemExtendServiceTableInformation = 38
    SystemPrioritySeperation = 39
    SystemVerifierAddDriverInformation = 40
    SystemVerifierRemoveDriverInformation = 41
    SystemProcessorIdleInformation = 42
    SystemLegacyDriverInformation = 43
    SystemCurrentTimeZoneInformation = 44
    SystemLookasideInformation = 45
    SystemTimeSlipNotification = 46
    SystemSessionCreate = 47
    SystemSessionDetach = 48
    SystemSessionInformation = 49
    SystemRangeStartInformation = 50
    SystemVerifierInformation = 51
    SystemVerifierThunkExtend = 52
    SystemSessionProcessInformation = 53
    SystemLoadGdiDriverInSystemSpace = 54
    SystemNumaProcessorMap = 55
    SystemPrefetcherInformation = 56
    SystemExtendedProcessInformation = 57
    SystemRecommendedSharedDataAlignment = 58
    SystemComPlusPackage = 59
    SystemNumaAvailableMemory = 60
    SystemProcessorPowerInformation = 61
    SystemEmulationBasicInformation = 62
    SystemEmulationProcessorInformation = 63
    SystemExtendedHandleInformation = 64
    SystemLostDelayedWriteInformation = 65
    SystemBigPoolInformation = 66
    SystemSessionPoolTagInformation = 67
    SystemSessionMappedViewInformation = 68
    SystemHotpatchInformation = 69
    SystemObjectSecurityMode = 70
    SystemWatchdogTimerHandler = 71
    SystemWatchdogTimerInformation = 72
    SystemLogicalProcessorInformation = 73
    SystemWow64SharedInformationObsolete = 74
    SystemRegisterFirmwareTableInformationHandler = 75
    SystemFirmwareTableInformation = 76
    SystemModuleInformationEx = 77
    SystemVerifierTriageInformation = 78
    SystemSuperfetchInformation = 79
    SystemMemoryListInformation = 80
    SystemFileCacheInformationEx = 81
    SystemThreadPriorityClientIdInformation = 82
    SystemProcessorIdleCycleTimeInformation = 83
    SystemVerifierCancellationInformation = 84
    SystemProcessorPowerInformationEx = 85
    SystemRefTraceInformation = 86
    SystemSpecialPoolInformation = 87
    SystemProcessIdInformation = 88
    SystemErrorPortInformation = 89
    SystemBootEnvironmentInformation = 90
    SystemHypervisorInformation = 91
    SystemVerifierInformationEx = 92
    SystemTimeZoneInformation = 93
    SystemImageFileExecutionOptionsInformation = 94
    SystemCoverageInformation = 95
    SystemPrefetchPatchInformation = 96
    SystemVerifierFaultsInformation = 97
    SystemSystemPartitionInformation = 98
    SystemSystemDiskInformation = 99
    SystemProcessorPerformanceDistribution = 100
    SystemNumaProximityNodeInformation = 101
    SystemDynamicTimeZoneInformation = 102
    SystemCodeIntegrityInformation = 103
    SystemProcessorMicrocodeUpdateInformation = 104
    SystemProcessorBrandString = 105
    SystemVirtualAddressInformation = 106
    SystemLogicalProcessorAndGroupInformation = 107
    SystemProcessorCycleTimeInformation = 108
    SystemStoreInformation = 109
    SystemRegistryAppendString = 110
    SystemAitSamplingValue = 111
    SystemVhdBootInformation = 112
    SystemCpuQuotaInformation = 113
    SystemNativeBasicInformation = 114
    SystemErrorPortTimeouts = 115
    SystemLowPriorityIoInformation = 116
    SystemTpmBootEntropyInformation = 117
    SystemVerifierCountersInformation = 118
    SystemPagedPoolInformationEx = 119
    SystemSystemPtesInformationEx = 120
    SystemNodeDistanceInformation = 121
    SystemAcpiAuditInformation = 122
    SystemBasicPerformanceInformation = 123
    SystemQueryPerformanceCounterInformation = 124
    SystemSessionBigPoolInformation = 125
    SystemBootGraphicsInformation = 126
    SystemScrubPhysicalMemoryInformation = 127
    SystemBadPageInformation = 128
    SystemProcessorProfileControlArea = 129
    SystemCombinePhysicalMemoryInformation = 130
    SystemEntropyInterruptTimingInformation = 131
    SystemConsoleInformation = 132
    SystemPlatformBinaryInformation = 133
    SystemPolicyInformation = 134
    SystemHypervisorProcessorCountInformation = 135
    SystemDeviceDataInformation = 136
    SystemDeviceDataEnumerationInformation = 137
    SystemMemoryTopologyInformation = 138
    SystemMemoryChannelInformation = 139
    SystemBootLogoInformation = 140
    SystemProcessorPerformanceInformationEx = 141
    SystemCriticalProcessErrorLogInformation = 142
    SystemSecureBootPolicyInformation = 143
    SystemPageFileInformationEx = 144
    SystemSecureBootInformation = 145
    SystemEntropyInterruptTimingRawInformation = 146
    SystemPortableWorkspaceEfiLauncherInformation = 147
    SystemFullProcessInformation = 148
    SystemKernelDebuggerInformationEx = 149
    SystemBootMetadataInformation = 150
    SystemSoftRebootInformation = 151
    SystemElamCertificateInformation = 152
    SystemOfflineDumpConfigInformation = 153
    SystemProcessorFeaturesInformation = 154
    SystemRegistryReconciliationInformation = 155
    SystemEdidInformation = 156
    SystemManufacturingInformation = 157
    SystemEnergyEstimationConfigInformation = 158
    SystemHypervisorDetailInformation = 159
    SystemProcessorCycleStatsInformation = 160
    SystemVmGenerationCountInformation = 161
    SystemTrustedPlatformModuleInformation = 162
    SystemKernelDebuggerFlags = 163
    SystemCodeIntegrityPolicyInformation = 164
    SystemIsolatedUserModeInformation = 165
    SystemHardwareSecurityTestInterfaceResultsInformation = 166
    SystemSingleModuleInformation = 167
    SystemAllowedCpuSetsInformation = 168
    SystemVsmProtectionInformation = 169
    SystemInterruptCpuSetsInformation = 170
    SystemSecureBootPolicyFullInformation = 171
    SystemCodeIntegrityPolicyFullInformation = 172
    SystemAffinitizedInterruptProcessorInformation = 173
    SystemRootSiloInformation = 174
    SystemCpuSetInformation = 175
    SystemCpuSetTagInformation = 176
    SystemWin32WerStartCallout = 177
    SystemSecureKernelProfileInformation = 178
    SystemCodeIntegrityPlatformManifestInformation = 179
    SystemInterruptSteeringInformation = 180
    SystemSupportedProcessorArchitectures = 181
    SystemMemoryUsageInformation = 182
    SystemCodeIntegrityCertificateInformation = 183
    SystemPhysicalMemoryInformation = 184
    SystemControlFlowTransition = 185
    SystemKernelDebuggingAllowed = 186
    SystemActivityModerationExeState = 187
    SystemActivityModerationUserSettings = 188
    SystemCodeIntegrityPoliciesFullInformation = 189
    SystemCodeIntegrityUnlockInformation = 190
    SystemIntegrityQuotaInformation = 191
    SystemFlushInformation = 192
    SystemProcessorIdleMaskInformation = 193
    SystemSecureDumpEncryptionInformation = 194
    SystemWriteConstraintInformation = 195
    SystemKernelVaShadowInformation = 196
    SystemHypervisorSharedPageInformation = 197
    SystemFirmwareBootPerformanceInformation = 198
    SystemCodeIntegrityVerificationInformation = 199
    SystemFirmwarePartitionInformation = 200
    SystemSpeculationControlInformation = 201
    SystemDmaGuardPolicyInformation = 202
    SystemEnclaveLaunchControlInformation = 203
    SystemWorkloadAllowedCpuSetsInformation = 204
    SystemCodeIntegrityUnlockModeInformation = 205
    SystemLeapSecondInformation = 206
    SystemFlags2Information = 207
    SystemSecurityModelInformation = 208
    SystemCodeIntegritySyntheticCacheInformation = 209
    SystemFeatureConfigurationInformation = 210
    SystemFeatureConfigurationSectionInformation = 211
    SystemFeatureUsageSubscriptionInformation = 212
    SystemSecureSpeculationControlInformation = 213
    SystemSpacesBootInformation = 214
    SystemFwRamdiskInformation = 215
    SystemWheaIpmiHardwareInformation = 216
    SystemDifSetRuleClassInformation = 217
    SystemDifClearRuleClassInformation = 218
    SystemDifApplyPluginVerificationOnDriver = 219
    SystemDifRemovePluginVerificationOnDriver = 220
    SystemShadowStackInformation = 221
    SystemBuildVersionInformation = 222
    SystemPoolLimitInformation = 223
    SystemCodeIntegrityAddDynamicStore = 224
    SystemCodeIntegrityClearDynamicStores = 225
    SystemDifPoolTrackingInformation = 226
    SystemPoolZeroingInformation = 227
    MaxSystemInfoClass = 228
make_global(SYSTEM_INFORMATION_CLASS)

class EVENT_TRACE_INFORMATION_CLASS(Enum):
    EventTraceKernelVersionInformation = 0
    EventTraceGroupMaskInformation = 1
    EventTracePerformanceInformation = 2
    EventTraceTimeProfileInformation = 3
    EventTraceSessionSecurityInformation = 4
    EventTraceSpinlockInformation = 5
    EventTraceStackTracingInformation = 6
    EventTraceExecutiveResourceInformation = 7
    EventTraceHeapTracingInformation = 8
    EventTraceHeapSummaryTracingInformation = 9
    EventTracePoolTagFilterInformation = 10
    EventTracePebsTracingInformation = 11
    EventTraceProfileConfigInformation = 12
    EventTraceProfileSourceListInformation = 13
    EventTraceProfileEventListInformation = 14
    EventTraceProfileCounterListInformation = 15
    EventTraceStackCachingInformation = 16
    EventTraceObjectTypeFilterInformation = 17
    EventTraceSoftRestartInformation = 18
    EventTraceLastBranchConfigurationInformation = 19
    EventTraceLastBranchEventListInformation = 20
    EventTraceProfileSourceAddInformation = 21
    EventTraceProfileSourceRemoveInformation = 22
    EventTraceProcessorTraceConfigurationInformation = 23
    EventTraceProcessorTraceEventListInformation = 24
    EventTraceCoverageSamplerInformation = 25
    EventTraceUnifiedStackCachingInformation = 26
    MaxEventTraceInfoClass = 27
make_global(EVENT_TRACE_INFORMATION_CLASS)

class SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS(Enum):
    SystemCrashDumpDisable = 0
    SystemCrashDumpReconfigure = 1
    SystemCrashDumpInitializationComplete = 2
make_global(SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS)

class SYSTEM_FIRMWARE_TABLE_ACTION(Enum):
    SystemFirmwareTableEnumerate = 0
    SystemFirmwareTableGet = 1
    SystemFirmwareTableMax = 2
make_global(SYSTEM_FIRMWARE_TABLE_ACTION)

class SYSTEM_MEMORY_LIST_COMMAND(Enum):
    MemoryCaptureAccessedBits = 0
    MemoryCaptureAndResetAccessedBits = 1
    MemoryEmptyWorkingSets = 2
    MemoryFlushModifiedList = 3
    MemoryPurgeStandbyList = 4
    MemoryPurgeLowPriorityStandbyList = 5
    MemoryCommandMax = 6
make_global(SYSTEM_MEMORY_LIST_COMMAND)

class SYSTEM_VA_TYPE(Enum):
    SystemVaTypeAll = 0
    SystemVaTypeNonPagedPool = 1
    SystemVaTypePagedPool = 2
    SystemVaTypeSystemCache = 3
    SystemVaTypeSystemPtes = 4
    SystemVaTypeSessionSpace = 5
    SystemVaTypeMax = 6
make_global(SYSTEM_VA_TYPE)

class SYSTEM_STORE_INFORMATION_CLASS(Enum):
    SystemStoreCompressionInformation = 22
make_global(SYSTEM_STORE_INFORMATION_CLASS)

class TPM_BOOT_ENTROPY_RESULT_CODE(Enum):
    TpmBootEntropyStructureUninitialized = 0
    TpmBootEntropyDisabledByPolicy = 1
    TpmBootEntropyNoTpmFound = 2
    TpmBootEntropyTpmError = 3
    TpmBootEntropySuccess = 4
make_global(TPM_BOOT_ENTROPY_RESULT_CODE)

class SYSTEM_PIXEL_FORMAT(Enum):
    SystemPixelFormatUnknown = 0
    SystemPixelFormatR8G8B8 = 1
    SystemPixelFormatR8G8B8X8 = 2
    SystemPixelFormatB8G8R8 = 3
    SystemPixelFormatB8G8R8X8 = 4
make_global(SYSTEM_PIXEL_FORMAT)

class SYSTEM_PROCESS_CLASSIFICATION(Enum):
    SystemProcessClassificationNormal = 0
    SystemProcessClassificationSystem = 1
    SystemProcessClassificationSecureSystem = 2
    SystemProcessClassificationMemCompression = 3
    SystemProcessClassificationRegistry = 4
    SystemProcessClassificationMaximum = 5
make_global(SYSTEM_PROCESS_CLASSIFICATION)

class SYSTEM_ACTIVITY_MODERATION_STATE(Enum):
    SystemActivityModerationStateSystemManaged = 0
    SystemActivityModerationStateUserManagedAllowThrottling = 1
    SystemActivityModerationStateUserManagedDisableThrottling = 2
    MaxSystemActivityModerationState = 3
make_global(SYSTEM_ACTIVITY_MODERATION_STATE)

class SYSTEM_ACTIVITY_MODERATION_APP_TYPE(Enum):
    SystemActivityModerationAppTypeClassic = 0
    SystemActivityModerationAppTypePackaged = 1
    MaxSystemActivityModerationAppType = 2
make_global(SYSTEM_ACTIVITY_MODERATION_APP_TYPE)

class SYSDBG_COMMAND(Enum):
    SysDbgQueryModuleInformation = 0
    SysDbgQueryTraceInformation = 1
    SysDbgSetTracepoint = 2
    SysDbgSetSpecialCall = 3
    SysDbgClearSpecialCalls = 4
    SysDbgQuerySpecialCalls = 5
    SysDbgBreakPoint = 6
    SysDbgQueryVersion = 7
    SysDbgReadVirtual = 8
    SysDbgWriteVirtual = 9
    SysDbgReadPhysical = 10
    SysDbgWritePhysical = 11
    SysDbgReadControlSpace = 12
    SysDbgWriteControlSpace = 13
    SysDbgReadIoSpace = 14
    SysDbgWriteIoSpace = 15
    SysDbgReadMsr = 16
    SysDbgWriteMsr = 17
    SysDbgReadBusData = 18
    SysDbgWriteBusData = 19
    SysDbgCheckLowMemory = 20
    SysDbgEnableKernelDebugger = 21
    SysDbgDisableKernelDebugger = 22
    SysDbgGetAutoKdEnable = 23
    SysDbgSetAutoKdEnable = 24
    SysDbgGetPrintBufferSize = 25
    SysDbgSetPrintBufferSize = 26
    SysDbgGetKdUmExceptionEnable = 27
    SysDbgSetKdUmExceptionEnable = 28
    SysDbgGetTriageDump = 29
    SysDbgGetKdBlockEnable = 30
    SysDbgSetKdBlockEnable = 31
    SysDbgRegisterForUmBreakInfo = 32
    SysDbgGetUmBreakPid = 33
    SysDbgClearUmBreakPid = 34
    SysDbgGetUmAttachPid = 35
    SysDbgClearUmAttachPid = 36
    SysDbgGetLiveKernelDump = 37
make_global(SYSDBG_COMMAND)

class HARDERROR_RESPONSE_OPTION(Enum):
    OptionAbortRetryIgnore = 0
    OptionOk = 1
    OptionOkCancel = 2
    OptionRetryCancel = 3
    OptionYesNo = 4
    OptionYesNoCancel = 5
    OptionShutdownSystem = 6
    OptionOkNoWait = 7
    OptionCancelTryContinue = 8
make_global(HARDERROR_RESPONSE_OPTION)

class HARDERROR_RESPONSE(Enum):
    ResponseReturnToCaller = 0
    ResponseNotHandled = 1
    ResponseAbort = 2
    ResponseCancel = 3
    ResponseIgnore = 4
    ResponseNo = 5
    ResponseOk = 6
    ResponseRetry = 7
    ResponseYes = 8
    ResponseTryAgain = 9
    ResponseContinue = 10
make_global(HARDERROR_RESPONSE)

class ALTERNATIVE_ARCHITECTURE_TYPE(Enum):
    StandardDesign = 0
    NEC98x86 = 1
    EndAlternatives = 2
make_global(ALTERNATIVE_ARCHITECTURE_TYPE)

class ATOM_INFORMATION_CLASS(Enum):
    AtomBasicInformation = 0
    AtomTableInformation = 1
make_global(ATOM_INFORMATION_CLASS)

class SHUTDOWN_ACTION(Enum):
    ShutdownNoReboot = 0
    ShutdownReboot = 1
    ShutdownPowerOff = 2
make_global(SHUTDOWN_ACTION)

class MEMORY_INFORMATION_CLASS(Enum):
    MemoryBasicInformation = 0
    MemoryWorkingSetInformation = 1
    MemoryMappedFilenameInformation = 2
    MemoryRegionInformation = 3
    MemoryWorkingSetExInformation = 4
    MemorySharedCommitInformation = 5
    MemoryImageInformation = 6
    MemoryRegionInformationEx = 7
    MemoryPrivilegedBasicInformation = 8
    MemoryEnclaveImageInformation = 9
    MemoryBasicInformationCapped = 10
    MemoryPhysicalContiguityInformation = 11
    MaxMemoryInfoClass = 12
make_global(MEMORY_INFORMATION_CLASS)

class MEMORY_WORKING_SET_EX_LOCATION(Enum):
    MemoryLocationInvalid = 0
    MemoryLocationResident = 1
    MemoryLocationPagefile = 2
    MemoryLocationReserved = 3
make_global(MEMORY_WORKING_SET_EX_LOCATION)

class MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE(Enum):
    MemoryNotContiguous = 0
    MemoryAlignedAndContiguous = 1
    MemoryNotResident = 2
    MemoryNotEligibleToMakeContiguous = 3
    MemoryContiguityStateMax = 4
make_global(MEMORY_PHYSICAL_CONTIGUITY_UNIT_STATE)

class SECTION_INFORMATION_CLASS(Enum):
    SectionBasicInformation = 0
    SectionImageInformation = 1
    SectionRelocationInformation = 2
    SectionOriginalBaseInformation = 3
    SectionInternalImageInformation = 4
    MaxSectionInfoClass = 5
make_global(SECTION_INFORMATION_CLASS)

class SECTION_INHERIT(Enum):
    ViewShare = 1
    ViewUnmap = 2
make_global(SECTION_INHERIT)

class VIRTUAL_MEMORY_INFORMATION_CLASS(Enum):
    VmPrefetchInformation = 0
    VmPagePriorityInformation = 1
    VmCfgCallTargetInformation = 2
    VmPageDirtyStateInformation = 3
    VmImageHotPatchInformation = 4
    VmPhysicalContiguityInformation = 5
    VmVirtualMachinePrepopulateInformation = 6
    MaxVmInfoClass = 7
make_global(VIRTUAL_MEMORY_INFORMATION_CLASS)

class MEMORY_PARTITION_INFORMATION_CLASS(Enum):
    SystemMemoryPartitionInformation = 0
    SystemMemoryPartitionMoveMemory = 1
    SystemMemoryPartitionAddPagefile = 2
    SystemMemoryPartitionCombineMemory = 3
    SystemMemoryPartitionInitialAddMemory = 4
    SystemMemoryPartitionGetMemoryEvents = 5
    SystemMemoryPartitionMax = 6
make_global(MEMORY_PARTITION_INFORMATION_CLASS)

class OBJECT_INFORMATION_CLASS(Enum):
    ObjectBasicInformation = 0
    ObjectNameInformation = 1
    ObjectTypeInformation = 2
    ObjectTypesInformation = 3
    ObjectHandleFlagInformation = 4
    ObjectSessionInformation = 5
    ObjectSessionObjectInformation = 6
    MaxObjectInfoClass = 7
make_global(OBJECT_INFORMATION_CLASS)

class SYMBOLIC_LINK_INFO_CLASS(Enum):
    SymbolicLinkGlobalInformation = 1
    SymbolicLinkAccessMask = 2
    MaxnSymbolicLinkInfoClass = 3
make_global(SYMBOLIC_LINK_INFO_CLASS)

class PROCESSINFOCLASS(Enum):
    ProcessBasicInformation = 0
    ProcessQuotaLimits = 1
    ProcessIoCounters = 2
    ProcessVmCounters = 3
    ProcessTimes = 4
    ProcessBasePriority = 5
    ProcessRaisePriority = 6
    ProcessDebugPort = 7
    ProcessExceptionPort = 8
    ProcessAccessToken = 9
    ProcessLdtInformation = 10
    ProcessLdtSize = 11
    ProcessDefaultHardErrorMode = 12
    ProcessIoPortHandlers = 13
    ProcessPooledUsageAndLimits = 14
    ProcessWorkingSetWatch = 15
    ProcessUserModeIOPL = 16
    ProcessEnableAlignmentFaultFixup = 17
    ProcessPriorityClass = 18
    ProcessWx86Information = 19
    ProcessHandleCount = 20
    ProcessAffinityMask = 21
    ProcessPriorityBoost = 22
    ProcessDeviceMap = 23
    ProcessSessionInformation = 24
    ProcessForegroundInformation = 25
    ProcessWow64Information = 26
    ProcessImageFileName = 27
    ProcessLUIDDeviceMapsEnabled = 28
    ProcessBreakOnTermination = 29
    ProcessDebugObjectHandle = 30
    ProcessDebugFlags = 31
    ProcessHandleTracing = 32
    ProcessIoPriority = 33
    ProcessExecuteFlags = 34
    ProcessTlsInformation = 35
    ProcessCookie = 36
    ProcessImageInformation = 37
    ProcessCycleTime = 38
    ProcessPagePriority = 39
    ProcessInstrumentationCallback = 40
    ProcessThreadStackAllocation = 41
    ProcessWorkingSetWatchEx = 42
    ProcessImageFileNameWin32 = 43
    ProcessImageFileMapping = 44
    ProcessAffinityUpdateMode = 45
    ProcessMemoryAllocationMode = 46
    ProcessGroupInformation = 47
    ProcessTokenVirtualizationEnabled = 48
    ProcessConsoleHostProcess = 49
    ProcessWindowInformation = 50
    ProcessHandleInformation = 51
    ProcessMitigationPolicy = 52
    ProcessDynamicFunctionTableInformation = 53
    ProcessHandleCheckingMode = 54
    ProcessKeepAliveCount = 55
    ProcessRevokeFileHandles = 56
    ProcessWorkingSetControl = 57
    ProcessHandleTable = 58
    ProcessCheckStackExtentsMode = 59
    ProcessCommandLineInformation = 60
    ProcessProtectionInformation = 61
    ProcessMemoryExhaustion = 62
    ProcessFaultInformation = 63
    ProcessTelemetryIdInformation = 64
    ProcessCommitReleaseInformation = 65
    ProcessDefaultCpuSetsInformation = 66
    ProcessAllowedCpuSetsInformation = 67
    ProcessSubsystemProcess = 68
    ProcessJobMemoryInformation = 69
    ProcessInPrivate = 70
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71
    ProcessIumChallengeResponse = 72
    ProcessChildProcessInformation = 73
    ProcessHighGraphicsPriorityInformation = 74
    ProcessSubsystemInformation = 75
    ProcessEnergyValues = 76
    ProcessPowerThrottlingState = 77
    ProcessReserved3Information = 78
    ProcessWin32kSyscallFilterInformation = 79
    ProcessDisableSystemAllowedCpuSets = 80
    ProcessWakeInformation = 81
    ProcessEnergyTrackingState = 82
    ProcessManageWritesToExecutableMemory = 83
    ProcessCaptureTrustletLiveDump = 84
    ProcessTelemetryCoverage = 85
    ProcessEnclaveInformation = 86
    ProcessEnableReadWriteVmLogging = 87
    ProcessUptimeInformation = 88
    ProcessImageSection = 89
    ProcessDebugAuthInformation = 90
    ProcessSystemResourceManagement = 91
    ProcessSequenceNumber = 92
    ProcessLoaderDetour = 93
    ProcessSecurityDomainInformation = 94
    ProcessCombineSecurityDomainsInformation = 95
    ProcessEnableLogging = 96
    ProcessLeapSecondInformation = 97
    ProcessFiberShadowStackAllocation = 98
    ProcessFreeFiberShadowStackAllocation = 99
    ProcessAltSystemCallInformation = 100
    ProcessDynamicEHContinuationTargets = 101
    ProcessDynamicEnforcedCetCompatibleRanges = 102
    MaxProcessInfoClass = 103
make_global(PROCESSINFOCLASS)

class THREADINFOCLASS(Enum):
    ThreadBasicInformation = 0
    ThreadTimes = 1
    ThreadPriority = 2
    ThreadBasePriority = 3
    ThreadAffinityMask = 4
    ThreadImpersonationToken = 5
    ThreadDescriptorTableEntry = 6
    ThreadEnableAlignmentFaultFixup = 7
    ThreadEventPair = 8
    ThreadQuerySetWin32StartAddress = 9
    ThreadZeroTlsCell = 10
    ThreadPerformanceCount = 11
    ThreadAmILastThread = 12
    ThreadIdealProcessor = 13
    ThreadPriorityBoost = 14
    ThreadSetTlsArrayAddress = 15
    ThreadIsIoPending = 16
    ThreadHideFromDebugger = 17
    ThreadBreakOnTermination = 18
    ThreadSwitchLegacyState = 19
    ThreadIsTerminated = 20
    ThreadLastSystemCall = 21
    ThreadIoPriority = 22
    ThreadCycleTime = 23
    ThreadPagePriority = 24
    ThreadActualBasePriority = 25
    ThreadTebInformation = 26
    ThreadCSwitchMon = 27
    ThreadCSwitchPmu = 28
    ThreadWow64Context = 29
    ThreadGroupInformation = 30
    ThreadUmsInformation = 31
    ThreadCounterProfiling = 32
    ThreadIdealProcessorEx = 33
    ThreadCpuAccountingInformation = 34
    ThreadSuspendCount = 35
    ThreadHeterogeneousCpuPolicy = 36
    ThreadContainerId = 37
    ThreadNameInformation = 38
    ThreadSelectedCpuSets = 39
    ThreadSystemThreadInformation = 40
    ThreadActualGroupAffinity = 41
    ThreadDynamicCodePolicyInfo = 42
    ThreadExplicitCaseSensitivity = 43
    ThreadWorkOnBehalfTicket = 44
    ThreadSubsystemInformation = 45
    ThreadDbgkWerReportActive = 46
    ThreadAttachContainer = 47
    ThreadManageWritesToExecutableMemory = 48
    ThreadPowerThrottlingState = 49
    ThreadWorkloadClass = 50
    MaxThreadInfoClass = 51
make_global(THREADINFOCLASS)

class PROCESS_TLS_INFORMATION_TYPE(Enum):
    ProcessTlsReplaceIndex = 0
    ProcessTlsReplaceVector = 1
    MaxProcessTlsOperation = 2
make_global(PROCESS_TLS_INFORMATION_TYPE)

class PROCESS_WORKING_SET_OPERATION(Enum):
    ProcessWorkingSetSwap = 0
    ProcessWorkingSetEmpty = 1
    ProcessWorkingSetOperationMax = 2
make_global(PROCESS_WORKING_SET_OPERATION)

class PS_PROTECTED_TYPE(Enum):
    PsProtectedTypeNone = 0
    PsProtectedTypeProtectedLight = 1
    PsProtectedTypeProtected = 2
    PsProtectedTypeMax = 3
make_global(PS_PROTECTED_TYPE)

class PS_PROTECTED_SIGNER(Enum):
    PsProtectedSignerNone = 0
    PsProtectedSignerAuthenticode = 1
    PsProtectedSignerCodeGen = 2
    PsProtectedSignerAntimalware = 3
    PsProtectedSignerLsa = 4
    PsProtectedSignerWindows = 5
    PsProtectedSignerWinTcb = 6
    PsProtectedSignerWinSystem = 7
    PsProtectedSignerApp = 8
    PsProtectedSignerMax = 9
make_global(PS_PROTECTED_SIGNER)

class THREAD_UMS_INFORMATION_COMMAND(Enum):
    UmsInformationCommandInvalid = 0
    UmsInformationCommandAttach = 1
    UmsInformationCommandDetach = 2
    UmsInformationCommandQuery = 3
make_global(THREAD_UMS_INFORMATION_COMMAND)

class SUBSYSTEM_INFORMATION_TYPE(Enum):
    SubsystemInformationTypeWin32 = 0
    SubsystemInformationTypeWSL = 1
    MaxSubsystemInformationType = 2
make_global(SUBSYSTEM_INFORMATION_TYPE)

class THREAD_WORKLOAD_CLASS(Enum):
    ThreadWorkloadClassDefault = 0
    ThreadWorkloadClassGraphics = 1
    MaxThreadWorkloadClass = 2
make_global(THREAD_WORKLOAD_CLASS)

class PS_ATTRIBUTE_NUM(Enum):
    PsAttributeParentProcess = 0
    PsAttributeDebugPort = 1
    PsAttributeToken = 2
    PsAttributeClientId = 3
    PsAttributeTebAddress = 4
    PsAttributeImageName = 5
    PsAttributeImageInfo = 6
    PsAttributeMemoryReserve = 7
    PsAttributePriorityClass = 8
    PsAttributeErrorMode = 9
    PsAttributeStdHandleInfo = 10
    PsAttributeHandleList = 11
    PsAttributeGroupAffinity = 12
    PsAttributePreferredNode = 13
    PsAttributeIdealProcessor = 14
    PsAttributeUmsThread = 15
    PsAttributeMitigationOptions = 16
    PsAttributeProtectionLevel = 17
    PsAttributeSecureProcess = 18
    PsAttributeJobList = 19
    PsAttributeChildProcessPolicy = 20
    PsAttributeAllApplicationPackagesPolicy = 21
    PsAttributeWin32kFilter = 22
    PsAttributeSafeOpenPromptOriginClaim = 23
    PsAttributeBnoIsolation = 24
    PsAttributeDesktopAppPolicy = 25
    PsAttributeChpe = 26
    PsAttributeMax = 27
make_global(PS_ATTRIBUTE_NUM)

class PS_STD_HANDLE_STATE(Enum):
    PsNeverDuplicate = 0
    PsRequestDuplicate = 1
    PsAlwaysDuplicate = 2
    PsMaxStdHandleStates = 3
make_global(PS_STD_HANDLE_STATE)

class PS_MITIGATION_OPTION(Enum):
    PS_MITIGATION_OPTION_NX = 0
    PS_MITIGATION_OPTION_SEHOP = 1
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES = 2
    PS_MITIGATION_OPTION_HEAP_TERMINATE = 3
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR = 4
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR = 5
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS = 6
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE = 7
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE = 8
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE = 9
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD = 10
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES = 11
    PS_MITIGATION_OPTION_FONT_DISABLE = 12
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE = 13
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL = 14
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32 = 15
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD = 16
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY = 17
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD = 18
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT = 19
    PS_MITIGATION_OPTION_ROP_STACKPIVOT = 20
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK = 21
    PS_MITIGATION_OPTION_ROP_SIMEXEC = 22
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER = 23
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS = 24
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION = 25
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER = 26
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION = 27
    PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION = 28
    PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE = 29
    PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY = 30
    PS_MITIGATION_OPTION_CET_SHADOW_STACKS = 31
make_global(PS_MITIGATION_OPTION)

class PS_CREATE_STATE(Enum):
    PsCreateInitialState = 0
    PsCreateFailOnFileOpen = 1
    PsCreateFailOnSectionCreate = 2
    PsCreateFailExeFormat = 3
    PsCreateFailMachineMismatch = 4
    PsCreateFailExeName = 5
    PsCreateSuccess = 6
    PsCreateMaximumStates = 7
make_global(PS_CREATE_STATE)

class MEMORY_RESERVE_TYPE(Enum):
    MemoryReserveUserApc = 0
    MemoryReserveIoCompletion = 1
    MemoryReserveTypeMax = 2
make_global(MEMORY_RESERVE_TYPE)

class DBG_STATE(Enum):
    DbgIdle = 0
    DbgReplyPending = 1
    DbgCreateThreadStateChange = 2
    DbgCreateProcessStateChange = 3
    DbgExitThreadStateChange = 4
    DbgExitProcessStateChange = 5
    DbgExceptionStateChange = 6
    DbgBreakpointStateChange = 7
    DbgSingleStepStateChange = 8
    DbgLoadDllStateChange = 9
    DbgUnloadDllStateChange = 10
make_global(DBG_STATE)

class DEBUGOBJECTINFOCLASS(Enum):
    DebugObjectUnusedInformation = 0
    DebugObjectKillProcessOnExitInformation = 1
    MaxDebugObjectInfoClass = 2
make_global(DEBUGOBJECTINFOCLASS)

class FILE_INFORMATION_CLASS(Enum):
    FileDirectoryInformation = 1
    FileFullDirectoryInformation = 2
    FileBothDirectoryInformation = 3
    FileBasicInformation = 4
    FileStandardInformation = 5
    FileInternalInformation = 6
    FileEaInformation = 7
    FileAccessInformation = 8
    FileNameInformation = 9
    FileRenameInformation = 10
    FileLinkInformation = 11
    FileNamesInformation = 12
    FileDispositionInformation = 13
    FilePositionInformation = 14
    FileFullEaInformation = 15
    FileModeInformation = 16
    FileAlignmentInformation = 17
    FileAllInformation = 18
    FileAllocationInformation = 19
    FileEndOfFileInformation = 20
    FileAlternateNameInformation = 21
    FileStreamInformation = 22
    FilePipeInformation = 23
    FilePipeLocalInformation = 24
    FilePipeRemoteInformation = 25
    FileMailslotQueryInformation = 26
    FileMailslotSetInformation = 27
    FileCompressionInformation = 28
    FileObjectIdInformation = 29
    FileCompletionInformation = 30
    FileMoveClusterInformation = 31
    FileQuotaInformation = 32
    FileReparsePointInformation = 33
    FileNetworkOpenInformation = 34
    FileAttributeTagInformation = 35
    FileTrackingInformation = 36
    FileIdBothDirectoryInformation = 37
    FileIdFullDirectoryInformation = 38
    FileValidDataLengthInformation = 39
    FileShortNameInformation = 40
    FileIoCompletionNotificationInformation = 41
    FileIoStatusBlockRangeInformation = 42
    FileIoPriorityHintInformation = 43
    FileSfioReserveInformation = 44
    FileSfioVolumeInformation = 45
    FileHardLinkInformation = 46
    FileProcessIdsUsingFileInformation = 47
    FileNormalizedNameInformation = 48
    FileNetworkPhysicalNameInformation = 49
    FileIdGlobalTxDirectoryInformation = 50
    FileIsRemoteDeviceInformation = 51
    FileUnusedInformation = 52
    FileNumaNodeInformation = 53
    FileStandardLinkInformation = 54
    FileRemoteProtocolInformation = 55
    FileRenameInformationBypassAccessCheck = 56
    FileLinkInformationBypassAccessCheck = 57
    FileVolumeNameInformation = 58
    FileIdInformation = 59
    FileIdExtdDirectoryInformation = 60
    FileReplaceCompletionInformation = 61
    FileHardLinkFullIdInformation = 62
    FileIdExtdBothDirectoryInformation = 63
    FileDispositionInformationEx = 64
    FileRenameInformationEx = 65
    FileRenameInformationExBypassAccessCheck = 66
    FileDesiredStorageClassInformation = 67
    FileStatInformation = 68
    FileMemoryPartitionInformation = 69
    FileStatLxInformation = 70
    FileCaseSensitiveInformation = 71
    FileLinkInformationEx = 72
    FileLinkInformationExBypassAccessCheck = 73
    FileStorageReserveIdInformation = 74
    FileCaseSensitiveInformationForceAccessCheck = 75
    FileMaximumInformation = 76
make_global(FILE_INFORMATION_CLASS)

class IO_PRIORITY_HINT(Enum):
    IoPriorityVeryLow = 0
    IoPriorityLow = 1
    IoPriorityNormal = 2
    IoPriorityHigh = 3
    IoPriorityCritical = 4
    MaxIoPriorityTypes = 5
make_global(IO_PRIORITY_HINT)

class FSINFOCLASS(Enum):
    FileFsVolumeInformation = 1
    FileFsLabelInformation = 2
    FileFsSizeInformation = 3
    FileFsDeviceInformation = 4
    FileFsAttributeInformation = 5
    FileFsControlInformation = 6
    FileFsFullSizeInformation = 7
    FileFsObjectIdInformation = 8
    FileFsDriverPathInformation = 9
    FileFsVolumeFlagsInformation = 10
    FileFsSectorSizeInformation = 11
    FileFsDataCopyInformation = 12
    FileFsMetadataSizeInformation = 13
    FileFsFullSizeInformationEx = 14
    FileFsMaximumInformation = 15
make_global(FSINFOCLASS)

class DIRECTORY_NOTIFY_INFORMATION_CLASS(Enum):
    DirectoryNotifyInformation = 0
    DirectoryNotifyExtendedInformation = 1
make_global(DIRECTORY_NOTIFY_INFORMATION_CLASS)

class IO_COMPLETION_INFORMATION_CLASS(Enum):
    IoCompletionBasicInformation = 0
make_global(IO_COMPLETION_INFORMATION_CLASS)

class IO_SESSION_EVENT(Enum):
    IoSessionEventIgnore = 0
    IoSessionEventCreated = 1
    IoSessionEventTerminated = 2
    IoSessionEventConnected = 3
    IoSessionEventDisconnected = 4
    IoSessionEventLogon = 5
    IoSessionEventLogoff = 6
    IoSessionEventMax = 7
make_global(IO_SESSION_EVENT)

class IO_SESSION_STATE(Enum):
    IoSessionStateCreated = 0
    IoSessionStateInitialized = 1
    IoSessionStateConnected = 2
    IoSessionStateDisconnected = 3
    IoSessionStateDisconnectedLoggedOn = 4
    IoSessionStateLoggedOn = 5
    IoSessionStateLoggedOff = 6
    IoSessionStateTerminated = 7
    IoSessionStateMax = 8
make_global(IO_SESSION_STATE)

class INTERFACE_TYPE(Enum):
    InterfaceTypeUndefined = -1
    Internal = 0
    Isa = 1
    Eisa = 2
    MicroChannel = 3
    TurboChannel = 4
    PCIBus = 5
    VMEBus = 6
    NuBus = 7
    PCMCIABus = 8
    CBus = 9
    MPIBus = 10
    MPSABus = 11
    ProcessorInternal = 12
    InternalPowerBus = 13
    PNPISABus = 14
    PNPBus = 15
    Vmcs = 16
    MaximumInterfaceType = 17
make_global(INTERFACE_TYPE)

class DMA_WIDTH(Enum):
    Width8Bits = 0
    Width16Bits = 1
    Width32Bits = 2
    MaximumDmaWidth = 3
make_global(DMA_WIDTH)

class DMA_SPEED(Enum):
    Compatible = 0
    TypeA = 1
    TypeB = 2
    TypeC = 3
    TypeF = 4
    MaximumDmaSpeed = 5
make_global(DMA_SPEED)

class BUS_DATA_TYPE(Enum):
    ConfigurationSpaceUndefined = -1
    Cmos = 0
    EisaConfiguration = 1
    Pos = 2
    CbusConfiguration = 3
    PCIConfiguration = 4
    VMEConfiguration = 5
    NuBusConfiguration = 6
    PCMCIAConfiguration = 7
    MPIConfiguration = 8
    MPSAConfiguration = 9
    PNPISAConfiguration = 10
    SgiInternalConfiguration = 11
    MaximumBusDataType = 12
make_global(BUS_DATA_TYPE)

class PORT_INFORMATION_CLASS(Enum):
    PortBasicInformation = 0
    PortDumpInformation = 1
make_global(PORT_INFORMATION_CLASS)

class ALPC_PORT_INFORMATION_CLASS(Enum):
    AlpcBasicInformation = 0
    AlpcPortInformation = 1
    AlpcAssociateCompletionPortInformation = 2
    AlpcConnectedSIDInformation = 3
    AlpcServerInformation = 4
    AlpcMessageZoneInformation = 5
    AlpcRegisterCompletionListInformation = 6
    AlpcUnregisterCompletionListInformation = 7
    AlpcAdjustCompletionListConcurrencyCountInformation = 8
    AlpcRegisterCallbackInformation = 9
    AlpcCompletionListRundownInformation = 10
    AlpcWaitForPortReferences = 11
make_global(ALPC_PORT_INFORMATION_CLASS)

class ALPC_MESSAGE_INFORMATION_CLASS(Enum):
    AlpcMessageSidInformation = 0
    AlpcMessageTokenModifiedIdInformation = 1
    AlpcMessageDirectStatusInformation = 2
    AlpcMessageHandleInformation = 3
    MaxAlpcMessageInfoClass = 4
make_global(ALPC_MESSAGE_INFORMATION_CLASS)

class PF_BOOT_PHASE_ID(Enum):
    PfKernelInitPhase = 0
    PfBootDriverInitPhase = 90
    PfSystemDriverInitPhase = 120
    PfSessionManagerInitPhase = 150
    PfSMRegistryInitPhase = 180
    PfVideoInitPhase = 210
    PfPostVideoInitPhase = 240
    PfBootAcceptedRegistryInitPhase = 270
    PfUserShellReadyPhase = 300
    PfMaxBootPhaseId = 900
make_global(PF_BOOT_PHASE_ID)

class PF_ENABLE_STATUS(Enum):
    PfSvNotSpecified = 0
    PfSvEnabled = 1
    PfSvDisabled = 2
    PfSvMaxEnableStatus = 3
make_global(PF_ENABLE_STATUS)

class PREFETCHER_INFORMATION_CLASS(Enum):
    PrefetcherRetrieveTrace = 1
    PrefetcherSystemParameters = 2
    PrefetcherBootPhase = 3
    PrefetcherRetrieveBootLoaderTrace = 4
    PrefetcherBootControl = 5
make_global(PREFETCHER_INFORMATION_CLASS)

class PFS_PRIVATE_PAGE_SOURCE_TYPE(Enum):
    PfsPrivateSourceKernel = 0
    PfsPrivateSourceSession = 1
    PfsPrivateSourceProcess = 2
    PfsPrivateSourceMax = 3
make_global(PFS_PRIVATE_PAGE_SOURCE_TYPE)

class PF_PHASED_SCENARIO_TYPE(Enum):
    PfScenarioTypeNone = 0
    PfScenarioTypeStandby = 1
    PfScenarioTypeHibernate = 2
    PfScenarioTypeFUS = 3
    PfScenarioTypeMax = 4
make_global(PF_PHASED_SCENARIO_TYPE)

class SUPERFETCH_INFORMATION_CLASS(Enum):
    SuperfetchRetrieveTrace = 1
    SuperfetchSystemParameters = 2
    SuperfetchLogEvent = 3
    SuperfetchGenerateTrace = 4
    SuperfetchPrefetch = 5
    SuperfetchPfnQuery = 6
    SuperfetchPfnSetPriority = 7
    SuperfetchPrivSourceQuery = 8
    SuperfetchSequenceNumberQuery = 9
    SuperfetchScenarioPhase = 10
    SuperfetchWorkerPriority = 11
    SuperfetchScenarioQuery = 12
    SuperfetchScenarioPrefetch = 13
    SuperfetchRobustnessControl = 14
    SuperfetchTimeControl = 15
    SuperfetchMemoryListQuery = 16
    SuperfetchMemoryRangesQuery = 17
    SuperfetchTracingControl = 18
    SuperfetchTrimWhileAgingControl = 19
    SuperfetchRepurposedByPrefetch = 20
    SuperfetchInformationMax = 21
make_global(SUPERFETCH_INFORMATION_CLASS)

class PLUGPLAY_EVENT_CATEGORY(Enum):
    HardwareProfileChangeEvent = 0
    TargetDeviceChangeEvent = 1
    DeviceClassChangeEvent = 2
    CustomDeviceEvent = 3
    DeviceInstallEvent = 4
    DeviceArrivalEvent = 5
    PowerEvent = 6
    VetoEvent = 7
    BlockedDriverEvent = 8
    InvalidIDEvent = 9
    MaxPlugEventCategory = 10
make_global(PLUGPLAY_EVENT_CATEGORY)

class PLUGPLAY_CONTROL_CLASS(Enum):
    PlugPlayControlEnumerateDevice = 0
    PlugPlayControlRegisterNewDevice = 1
    PlugPlayControlDeregisterDevice = 2
    PlugPlayControlInitializeDevice = 3
    PlugPlayControlStartDevice = 4
    PlugPlayControlUnlockDevice = 5
    PlugPlayControlQueryAndRemoveDevice = 6
    PlugPlayControlUserResponse = 7
    PlugPlayControlGenerateLegacyDevice = 8
    PlugPlayControlGetInterfaceDeviceList = 9
    PlugPlayControlProperty = 10
    PlugPlayControlDeviceClassAssociation = 11
    PlugPlayControlGetRelatedDevice = 12
    PlugPlayControlGetInterfaceDeviceAlias = 13
    PlugPlayControlDeviceStatus = 14
    PlugPlayControlGetDeviceDepth = 15
    PlugPlayControlQueryDeviceRelations = 16
    PlugPlayControlTargetDeviceRelation = 17
    PlugPlayControlQueryConflictList = 18
    PlugPlayControlRetrieveDock = 19
    PlugPlayControlResetDevice = 20
    PlugPlayControlHaltDevice = 21
    PlugPlayControlGetBlockedDriverList = 22
    PlugPlayControlGetDeviceInterfaceEnabled = 23
    MaxPlugPlayControl = 24
make_global(PLUGPLAY_CONTROL_CLASS)

class POWER_STATE_TYPE(Enum):
    SystemPowerState = 0
    DevicePowerState = 1
make_global(POWER_STATE_TYPE)

class POWER_STATE_HANDLER_TYPE(Enum):
    PowerStateSleeping1 = 0
    PowerStateSleeping2 = 1
    PowerStateSleeping3 = 2
    PowerStateSleeping4 = 3
    PowerStateShutdownOff = 4
    PowerStateShutdownReset = 5
    PowerStateSleeping4Firmware = 6
    PowerStateMaximum = 7
make_global(POWER_STATE_HANDLER_TYPE)

class POWER_REQUEST_ORIGIN(Enum):
    POWER_REQUEST_ORIGIN_DRIVER = 0
    POWER_REQUEST_ORIGIN_PROCESS = 1
    POWER_REQUEST_ORIGIN_SERVICE = 2
make_global(POWER_REQUEST_ORIGIN)

class KEY_INFORMATION_CLASS(Enum):
    KeyBasicInformation = 0
    KeyNodeInformation = 1
    KeyFullInformation = 2
    KeyNameInformation = 3
    KeyCachedInformation = 4
    KeyFlagsInformation = 5
    KeyVirtualizationInformation = 6
    KeyHandleTagsInformation = 7
    KeyTrustInformation = 8
    KeyLayerInformation = 9
    MaxKeyInfoClass = 10
make_global(KEY_INFORMATION_CLASS)

class KEY_SET_INFORMATION_CLASS(Enum):
    KeyWriteTimeInformation = 0
    KeyWow64FlagsInformation = 1
    KeyControlFlagsInformation = 2
    KeySetVirtualizationInformation = 3
    KeySetDebugInformation = 4
    KeySetHandleTagsInformation = 5
    KeySetLayerInformation = 6
    MaxKeySetInfoClass = 7
make_global(KEY_SET_INFORMATION_CLASS)

class KEY_VALUE_INFORMATION_CLASS(Enum):
    KeyValueBasicInformation = 0
    KeyValueFullInformation = 1
    KeyValuePartialInformation = 2
    KeyValueFullInformationAlign64 = 3
    KeyValuePartialInformationAlign64 = 4
    KeyValueLayerInformation = 5
    MaxKeyValueInfoClass = 6
make_global(KEY_VALUE_INFORMATION_CLASS)

class REG_ACTION(Enum):
    KeyAdded = 0
    KeyRemoved = 1
    KeyModified = 2
make_global(REG_ACTION)

class TABLE_SEARCH_RESULT(Enum):
    TableEmptyTree = 0
    TableFoundNode = 1
    TableInsertAsLeft = 2
    TableInsertAsRight = 3
make_global(TABLE_SEARCH_RESULT)

class RTL_GENERIC_COMPARE_RESULTS(Enum):
    GenericLessThan = 0
    GenericGreaterThan = 1
    GenericEqual = 2
make_global(RTL_GENERIC_COMPARE_RESULTS)

class RTL_NORM_FORM(Enum):
    NormOther = 0
    NormC = 1
    NormD = 2
    NormKC = 5
    NormKD = 6
    NormIdna = 13
    DisallowUnassigned = 256
    NormCDisallowUnassigned = 257
    NormDDisallowUnassigned = 258
    NormKCDisallowUnassigned = 261
    NormKDDisallowUnassigned = 262
    NormIdnaDisallowUnassigned = 269
make_global(RTL_NORM_FORM)

class FUNCTION_TABLE_TYPE(Enum):
    RF_SORTED = 0
    RF_UNSORTED = 1
    RF_CALLBACK = 2
    RF_KERNEL_DYNAMIC = 3
make_global(FUNCTION_TABLE_TYPE)

class RTL_PATH_TYPE(Enum):
    RtlPathTypeUnknown = 0
    RtlPathTypeUncAbsolute = 1
    RtlPathTypeDriveAbsolute = 2
    RtlPathTypeDriveRelative = 3
    RtlPathTypeRooted = 4
    RtlPathTypeRelative = 5
    RtlPathTypeLocalDevice = 6
    RtlPathTypeRootLocalDevice = 7
make_global(RTL_PATH_TYPE)

class HEAP_COMPATIBILITY_MODE(Enum):
    HEAP_COMPATIBILITY_STANDARD = 0
    HEAP_COMPATIBILITY_LAL = 1
    HEAP_COMPATIBILITY_LFH = 2
make_global(HEAP_COMPATIBILITY_MODE)

class IMAGE_MITIGATION_POLICY(Enum):
    ImageDepPolicy = 0
    ImageAslrPolicy = 1
    ImageDynamicCodePolicy = 2
    ImageStrictHandleCheckPolicy = 3
    ImageSystemCallDisablePolicy = 4
    ImageMitigationOptionsMask = 5
    ImageExtensionPointDisablePolicy = 6
    ImageControlFlowGuardPolicy = 7
    ImageSignaturePolicy = 8
    ImageFontDisablePolicy = 9
    ImageImageLoadPolicy = 10
    ImagePayloadRestrictionPolicy = 11
    ImageChildProcessPolicy = 12
    ImageSehopPolicy = 13
    ImageHeapPolicy = 14
    MaxImageMitigationPolicy = 15
make_global(IMAGE_MITIGATION_POLICY)

class RTL_IMAGE_MITIGATION_OPTION_STATE(Enum):
    RtlMitigationOptionStateNotConfigured = 0
    RtlMitigationOptionStateOn = 1
    RtlMitigationOptionStateOff = 2
make_global(RTL_IMAGE_MITIGATION_OPTION_STATE)

class APPCONTAINER_SID_TYPE(Enum):
    NotAppContainerSidType = 0
    ChildAppContainerSidType = 1
    ParentAppContainerSidType = 2
    InvalidAppContainerSidType = 3
    MaxAppContainerSidType = 4
make_global(APPCONTAINER_SID_TYPE)

class STATE_LOCATION_TYPE(Enum):
    LocationTypeRegistry = 0
    LocationTypeFileSystem = 1
    LocationTypeMaximum = 2
make_global(STATE_LOCATION_TYPE)

class RTL_BSD_ITEM_TYPE(Enum):
    RtlBsdItemVersionNumber = 0
    RtlBsdItemProductType = 1
    RtlBsdItemAabEnabled = 2
    RtlBsdItemAabTimeout = 3
    RtlBsdItemBootGood = 4
    RtlBsdItemBootShutdown = 5
    RtlBsdSleepInProgress = 6
    RtlBsdPowerTransition = 7
    RtlBsdItemBootAttemptCount = 8
    RtlBsdItemBootCheckpoint = 9
    RtlBsdItemBootId = 10
    RtlBsdItemShutdownBootId = 11
    RtlBsdItemReportedAbnormalShutdownBootId = 12
    RtlBsdItemErrorInfo = 13
    RtlBsdItemPowerButtonPressInfo = 14
    RtlBsdItemChecksum = 15
    RtlBsdPowerTransitionExtension = 16
    RtlBsdItemFeatureConfigurationState = 17
    RtlBsdItemMax = 18
make_global(RTL_BSD_ITEM_TYPE)

class TP_TRACE_TYPE(Enum):
    TpTraceThreadPriority = 1
    TpTraceThreadAffinity = 2
    MaxTpTraceType = 3
make_global(TP_TRACE_TYPE)

class KMTQUERYADAPTERINFOTYPE(Enum):
    KMTQAITYPE_UMDRIVERPRIVATE = 0
    KMTQAITYPE_UMDRIVERNAME = 1
    KMTQAITYPE_UMOPENGLINFO = 2
    KMTQAITYPE_GETSEGMENTSIZE = 3
    KMTQAITYPE_ADAPTERGUID = 4
    KMTQAITYPE_FLIPQUEUEINFO = 5
    KMTQAITYPE_ADAPTERADDRESS = 6
    KMTQAITYPE_SETWORKINGSETINFO = 7
    KMTQAITYPE_ADAPTERREGISTRYINFO = 8
    KMTQAITYPE_CURRENTDISPLAYMODE = 9
    KMTQAITYPE_MODELIST = 10
    KMTQAITYPE_CHECKDRIVERUPDATESTATUS = 11
    KMTQAITYPE_VIRTUALADDRESSINFO = 12
    KMTQAITYPE_DRIVERVERSION = 13
    KMTQAITYPE_UNKNOWN = 14
    KMTQAITYPE_ADAPTERTYPE = 15
    KMTQAITYPE_OUTPUTDUPLCONTEXTSCOUNT = 16
    KMTQAITYPE_WDDM_1_2_CAPS = 17
    KMTQAITYPE_UMD_DRIVER_VERSION = 18
    KMTQAITYPE_DIRECTFLIP_SUPPORT = 19
    KMTQAITYPE_MULTIPLANEOVERLAY_SUPPORT = 20
    KMTQAITYPE_DLIST_DRIVER_NAME = 21
    KMTQAITYPE_WDDM_1_3_CAPS = 22
    KMTQAITYPE_MULTIPLANEOVERLAY_HUD_SUPPORT = 23
    KMTQAITYPE_WDDM_2_0_CAPS = 24
    KMTQAITYPE_NODEMETADATA = 25
    KMTQAITYPE_CPDRIVERNAME = 26
    KMTQAITYPE_XBOX = 27
    KMTQAITYPE_INDEPENDENTFLIP_SUPPORT = 28
    KMTQAITYPE_MIRACASTCOMPANIONDRIVERNAME = 29
    KMTQAITYPE_PHYSICALADAPTERCOUNT = 30
    KMTQAITYPE_PHYSICALADAPTERDEVICEIDS = 31
    KMTQAITYPE_DRIVERCAPS_EXT = 32
    KMTQAITYPE_QUERY_MIRACAST_DRIVER_TYPE = 33
    KMTQAITYPE_QUERY_GPUMMU_CAPS = 34
    KMTQAITYPE_QUERY_MULTIPLANEOVERLAY_DECODE_SUPPORT = 35
    KMTQAITYPE_QUERY_HW_PROTECTION_TEARDOWN_COUNT = 36
    KMTQAITYPE_QUERY_ISBADDRIVERFORHWPROTECTIONDISABLED = 37
    KMTQAITYPE_MULTIPLANEOVERLAY_SECONDARY_SUPPORT = 38
    KMTQAITYPE_INDEPENDENTFLIP_SECONDARY_SUPPORT = 39
    KMTQAITYPE_PANELFITTER_SUPPORT = 40
    KMTQAITYPE_PHYSICALADAPTERPNPKEY = 41
    KMTQAITYPE_GETSEGMENTGROUPSIZE = 42
    KMTQAITYPE_MPO3DDI_SUPPORT = 43
    KMTQAITYPE_HWDRM_SUPPORT = 44
    KMTQAITYPE_MPOKERNELCAPS_SUPPORT = 45
    KMTQAITYPE_MULTIPLANEOVERLAY_STRETCH_SUPPORT = 46
    KMTQAITYPE_GET_DEVICE_VIDPN_OWNERSHIP_INFO = 47
    KMTQAITYPE_QUERYREGISTRY = 48
    KMTQAITYPE_KMD_DRIVER_VERSION = 49
    KMTQAITYPE_BLOCKLIST_KERNEL = 50
    KMTQAITYPE_BLOCKLIST_RUNTIME = 51
    KMTQAITYPE_ADAPTERGUID_RENDER = 52
    KMTQAITYPE_ADAPTERADDRESS_RENDER = 53
    KMTQAITYPE_ADAPTERREGISTRYINFO_RENDER = 54
    KMTQAITYPE_CHECKDRIVERUPDATESTATUS_RENDER = 55
    KMTQAITYPE_DRIVERVERSION_RENDER = 56
    KMTQAITYPE_ADAPTERTYPE_RENDER = 57
    KMTQAITYPE_WDDM_1_2_CAPS_RENDER = 58
    KMTQAITYPE_WDDM_1_3_CAPS_RENDER = 59
    KMTQAITYPE_QUERY_ADAPTER_UNIQUE_GUID = 60
    KMTQAITYPE_NODEPERFDATA = 61
    KMTQAITYPE_ADAPTERPERFDATA = 62
    KMTQAITYPE_ADAPTERPERFDATA_CAPS = 63
    KMTQUITYPE_GPUVERSION = 64
    KMTQAITYPE_DRIVER_DESCRIPTION = 65
    KMTQAITYPE_DRIVER_DESCRIPTION_RENDER = 66
    KMTQAITYPE_SCANOUT_CAPS = 67
    KMTQAITYPE_DISPLAY_UMDRIVERNAME = 68
    KMTQAITYPE_PARAVIRTUALIZATION_RENDER = 69
    KMTQAITYPE_SERVICENAME = 70
    KMTQAITYPE_WDDM_2_7_CAPS = 71
    KMTQAITYPE_TRACKEDWORKLOAD_SUPPORT = 72
make_global(KMTQUERYADAPTERINFOTYPE)

class KMTUMDVERSION(Enum):
    KMTUMDVERSION_DX9 = 0
    KMTUMDVERSION_DX10 = 1
    KMTUMDVERSION_DX11 = 2
    KMTUMDVERSION_DX12 = 3
    NUM_KMTUMDVERSIONS = 4
make_global(KMTUMDVERSION)

class D3DDDIFORMAT(Enum):
    D3DDDIFMT_UNKNOWN = 0
    D3DDDIFMT_R8G8B8 = 20
    D3DDDIFMT_A8R8G8B8 = 21
    D3DDDIFMT_X8R8G8B8 = 22
    D3DDDIFMT_R5G6B5 = 23
    D3DDDIFMT_X1R5G5B5 = 24
    D3DDDIFMT_A1R5G5B5 = 25
    D3DDDIFMT_A4R4G4B4 = 26
    D3DDDIFMT_R3G3B2 = 27
    D3DDDIFMT_A8 = 28
    D3DDDIFMT_A8R3G3B2 = 29
    D3DDDIFMT_X4R4G4B4 = 30
    D3DDDIFMT_A2B10G10R10 = 31
    D3DDDIFMT_A8B8G8R8 = 32
    D3DDDIFMT_X8B8G8R8 = 33
    D3DDDIFMT_G16R16 = 34
    D3DDDIFMT_A2R10G10B10 = 35
    D3DDDIFMT_A16B16G16R16 = 36
    D3DDDIFMT_A8P8 = 40
    D3DDDIFMT_P8 = 41
    D3DDDIFMT_L8 = 50
    D3DDDIFMT_A8L8 = 51
    D3DDDIFMT_A4L4 = 52
    D3DDDIFMT_V8U8 = 60
    D3DDDIFMT_L6V5U5 = 61
    D3DDDIFMT_X8L8V8U8 = 62
    D3DDDIFMT_Q8W8V8U8 = 63
    D3DDDIFMT_V16U16 = 64
    D3DDDIFMT_W11V11U10 = 65
    D3DDDIFMT_A2W10V10U10 = 67
    D3DDDIFMT_UYVY = 1498831189
    D3DDDIFMT_R8G8_B8G8 = 1195525970
    D3DDDIFMT_YUY2 = 844715353
    D3DDDIFMT_G8R8_G8B8 = 1111970375
    D3DDDIFMT_DXT1 = 827611204
    D3DDDIFMT_DXT2 = 844388420
    D3DDDIFMT_DXT3 = 861165636
    D3DDDIFMT_DXT4 = 877942852
    D3DDDIFMT_DXT5 = 894720068
    D3DDDIFMT_D16_LOCKABLE = 70
    D3DDDIFMT_D32 = 71
    D3DDDIFMT_D15S1 = 73
    D3DDDIFMT_D24S8 = 75
    D3DDDIFMT_D24X8 = 77
    D3DDDIFMT_D24X4S4 = 79
    D3DDDIFMT_D16 = 80
    D3DDDIFMT_D32F_LOCKABLE = 82
    D3DDDIFMT_D24FS8 = 83
    D3DDDIFMT_D32_LOCKABLE = 84
    D3DDDIFMT_S8_LOCKABLE = 85
    D3DDDIFMT_S1D15 = 72
    D3DDDIFMT_S8D24 = 74
    D3DDDIFMT_X8D24 = 76
    D3DDDIFMT_X4S4D24 = 78
    D3DDDIFMT_L16 = 81
    D3DDDIFMT_G8R8 = 91
    D3DDDIFMT_R8 = 92
    D3DDDIFMT_VERTEXDATA = 100
    D3DDDIFMT_INDEX16 = 101
    D3DDDIFMT_INDEX32 = 102
    D3DDDIFMT_Q16W16V16U16 = 110
    D3DDDIFMT_MULTI2_ARGB8 = 827606349
    D3DDDIFMT_R16F = 111
    D3DDDIFMT_G16R16F = 112
    D3DDDIFMT_A16B16G16R16F = 113
    D3DDDIFMT_R32F = 114
    D3DDDIFMT_G32R32F = 115
    D3DDDIFMT_A32B32G32R32F = 116
    D3DDDIFMT_CxV8U8 = 117
    D3DDDIFMT_A1 = 118
    D3DDDIFMT_A2B10G10R10_XR_BIAS = 119
    D3DDDIFMT_DXVACOMPBUFFER_BASE = 150
    D3DDDIFMT_PICTUREPARAMSDATA = 150
    D3DDDIFMT_MACROBLOCKDATA = 151
    D3DDDIFMT_RESIDUALDIFFERENCEDATA = 152
    D3DDDIFMT_DEBLOCKINGDATA = 153
    D3DDDIFMT_INVERSEQUANTIZATIONDATA = 154
    D3DDDIFMT_SLICECONTROLDATA = 155
    D3DDDIFMT_BITSTREAMDATA = 156
    D3DDDIFMT_MOTIONVECTORBUFFER = 157
    D3DDDIFMT_FILMGRAINBUFFER = 158
    D3DDDIFMT_DXVA_RESERVED9 = 159
    D3DDDIFMT_DXVA_RESERVED10 = 160
    D3DDDIFMT_DXVA_RESERVED11 = 161
    D3DDDIFMT_DXVA_RESERVED12 = 162
    D3DDDIFMT_DXVA_RESERVED13 = 163
    D3DDDIFMT_DXVA_RESERVED14 = 164
    D3DDDIFMT_DXVA_RESERVED15 = 165
    D3DDDIFMT_DXVA_RESERVED16 = 166
    D3DDDIFMT_DXVA_RESERVED17 = 167
    D3DDDIFMT_DXVA_RESERVED18 = 168
    D3DDDIFMT_DXVA_RESERVED19 = 169
    D3DDDIFMT_DXVA_RESERVED20 = 170
    D3DDDIFMT_DXVA_RESERVED21 = 171
    D3DDDIFMT_DXVA_RESERVED22 = 172
    D3DDDIFMT_DXVA_RESERVED23 = 173
    D3DDDIFMT_DXVA_RESERVED24 = 174
    D3DDDIFMT_DXVA_RESERVED25 = 175
    D3DDDIFMT_DXVA_RESERVED26 = 176
    D3DDDIFMT_DXVA_RESERVED27 = 177
    D3DDDIFMT_DXVA_RESERVED28 = 178
    D3DDDIFMT_DXVA_RESERVED29 = 179
    D3DDDIFMT_DXVA_RESERVED30 = 180
    D3DDDIFMT_DXVA_RESERVED31 = 181
    D3DDDIFMT_DXVACOMPBUFFER_MAX = 181
    D3DDDIFMT_BINARYBUFFER = 199
    D3DDDIFMT_FORCE_UINT = 2147483647
make_global(D3DDDIFORMAT)

class D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING(Enum):
    D3DDDI_VSSLO_UNINITIALIZED = 0
    D3DDDI_VSSLO_PROGRESSIVE = 1
    D3DDDI_VSSLO_INTERLACED_UPPERFIELDFIRST = 2
    D3DDDI_VSSLO_INTERLACED_LOWERFIELDFIRST = 3
    D3DDDI_VSSLO_OTHER = 255
make_global(D3DDDI_VIDEO_SIGNAL_SCANLINE_ORDERING)

class D3DDDI_ROTATION(Enum):
    D3DDDI_ROTATION_IDENTITY = 1
    D3DDDI_ROTATION_90 = 2
    D3DDDI_ROTATION_180 = 3
    D3DDDI_ROTATION_270 = 4
make_global(D3DDDI_ROTATION)

class D3DKMDT_MODE_PRUNING_REASON(Enum):
    D3DKMDT_MPR_UNINITIALIZED = 0
    D3DKMDT_MPR_ALLCAPS = 1
    D3DKMDT_MPR_DESCRIPTOR_MONITOR_SOURCE_MODE = 2
    D3DKMDT_MPR_DESCRIPTOR_MONITOR_FREQUENCY_RANGE = 3
    D3DKMDT_MPR_DESCRIPTOR_OVERRIDE_MONITOR_SOURCE_MODE = 4
    D3DKMDT_MPR_DESCRIPTOR_OVERRIDE_MONITOR_FREQUENCY_RANGE = 5
    D3DKMDT_MPR_DEFAULT_PROFILE_MONITOR_SOURCE_MODE = 6
    D3DKMDT_MPR_DRIVER_RECOMMENDED_MONITOR_SOURCE_MODE = 7
    D3DKMDT_MPR_MONITOR_FREQUENCY_RANGE_OVERRIDE = 8
    D3DKMDT_MPR_CLONE_PATH_PRUNED = 9
    D3DKMDT_MPR_MAXVALID = 10
make_global(D3DKMDT_MODE_PRUNING_REASON)

class D3DKMT_DRIVERVERSION(Enum):
    KMT_DRIVERVERSION_WDDM_1_0 = 1000
    KMT_DRIVERVERSION_WDDM_1_1_PRERELEASE = 1102
    KMT_DRIVERVERSION_WDDM_1_1 = 1105
    KMT_DRIVERVERSION_WDDM_1_2 = 1200
    KMT_DRIVERVERSION_WDDM_1_3 = 1300
    KMT_DRIVERVERSION_WDDM_2_0 = 2000
    KMT_DRIVERVERSION_WDDM_2_1 = 2100
    KMT_DRIVERVERSION_WDDM_2_2 = 2200
    KMT_DRIVERVERSION_WDDM_2_3 = 2300
    KMT_DRIVERVERSION_WDDM_2_4 = 2400
    KMT_DRIVERVERSION_WDDM_2_5 = 2500
    KMT_DRIVERVERSION_WDDM_2_6 = 2600
    KMT_DRIVERVERSION_WDDM_2_7 = 2700
make_global(D3DKMT_DRIVERVERSION)

class D3DKMDT_GRAPHICS_PREEMPTION_GRANULARITY(Enum):
    D3DKMDT_GRAPHICS_PREEMPTION_NONE = 0
    D3DKMDT_GRAPHICS_PREEMPTION_DMA_BUFFER_BOUNDARY = 100
    D3DKMDT_GRAPHICS_PREEMPTION_PRIMITIVE_BOUNDARY = 200
    D3DKMDT_GRAPHICS_PREEMPTION_TRIANGLE_BOUNDARY = 300
    D3DKMDT_GRAPHICS_PREEMPTION_PIXEL_BOUNDARY = 400
    D3DKMDT_GRAPHICS_PREEMPTION_SHADER_BOUNDARY = 500
make_global(D3DKMDT_GRAPHICS_PREEMPTION_GRANULARITY)

class D3DKMDT_COMPUTE_PREEMPTION_GRANULARITY(Enum):
    D3DKMDT_COMPUTE_PREEMPTION_NONE = 0
    D3DKMDT_COMPUTE_PREEMPTION_DMA_BUFFER_BOUNDARY = 100
    D3DKMDT_COMPUTE_PREEMPTION_DISPATCH_BOUNDARY = 200
    D3DKMDT_COMPUTE_PREEMPTION_THREAD_GROUP_BOUNDARY = 300
    D3DKMDT_COMPUTE_PREEMPTION_THREAD_BOUNDARY = 400
    D3DKMDT_COMPUTE_PREEMPTION_SHADER_BOUNDARY = 500
make_global(D3DKMDT_COMPUTE_PREEMPTION_GRANULARITY)

class DXGK_ENGINE_TYPE(Enum):
    DXGK_ENGINE_TYPE_OTHER = 0
    DXGK_ENGINE_TYPE_3D = 1
    DXGK_ENGINE_TYPE_VIDEO_DECODE = 2
    DXGK_ENGINE_TYPE_VIDEO_ENCODE = 3
    DXGK_ENGINE_TYPE_VIDEO_PROCESSING = 4
    DXGK_ENGINE_TYPE_SCENE_ASSEMBLY = 5
    DXGK_ENGINE_TYPE_COPY = 6
    DXGK_ENGINE_TYPE_OVERLAY = 7
    DXGK_ENGINE_TYPE_CRYPTO = 8
    DXGK_ENGINE_TYPE_MAX = 9
make_global(DXGK_ENGINE_TYPE)

class D3DKMT_MIRACAST_DRIVER_TYPE(Enum):
    D3DKMT_MIRACAST_DRIVER_NOT_SUPPORTED = 0
    D3DKMT_MIRACAST_DRIVER_IHV = 1
    D3DKMT_MIRACAST_DRIVER_MS = 2
make_global(D3DKMT_MIRACAST_DRIVER_TYPE)

class D3DKMT_PNP_KEY_TYPE(Enum):
    D3DKMT_PNP_KEY_HARDWARE = 1
    D3DKMT_PNP_KEY_SOFTWARE = 2
make_global(D3DKMT_PNP_KEY_TYPE)

class D3DDDI_QUERYREGISTRY_TYPE(Enum):
    D3DDDI_QUERYREGISTRY_SERVICEKEY = 0
    D3DDDI_QUERYREGISTRY_ADAPTERKEY = 1
    D3DDDI_QUERYREGISTRY_DRIVERSTOREPATH = 2
    D3DDDI_QUERYREGISTRY_DRIVERIMAGEPATH = 3
    D3DDDI_QUERYREGISTRY_MAX = 4
make_global(D3DDDI_QUERYREGISTRY_TYPE)

class D3DDDI_QUERYREGISTRY_STATUS(Enum):
    D3DDDI_QUERYREGISTRY_STATUS_SUCCESS = 0
    D3DDDI_QUERYREGISTRY_STATUS_BUFFER_OVERFLOW = 1
    D3DDDI_QUERYREGISTRY_STATUS_FAIL = 2
    D3DDDI_QUERYREGISTRY_STATUS_MAX = 3
make_global(D3DDDI_QUERYREGISTRY_STATUS)

class D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT(Enum):
    D3DKMT_PreemptionAttempt = 0
    D3DKMT_PreemptionAttemptSuccess = 1
    D3DKMT_PreemptionAttemptMissNoCommand = 2
    D3DKMT_PreemptionAttemptMissNotEnabled = 3
    D3DKMT_PreemptionAttemptMissNextFence = 4
    D3DKMT_PreemptionAttemptMissPagingCommand = 5
    D3DKMT_PreemptionAttemptMissSplittedCommand = 6
    D3DKMT_PreemptionAttemptMissFenceCommand = 7
    D3DKMT_PreemptionAttemptMissRenderPendingFlip = 8
    D3DKMT_PreemptionAttemptMissNotMakingProgress = 9
    D3DKMT_PreemptionAttemptMissLessPriority = 10
    D3DKMT_PreemptionAttemptMissRemainingQuantum = 11
    D3DKMT_PreemptionAttemptMissRemainingPreemptionQuantum = 12
    D3DKMT_PreemptionAttemptMissAlreadyPreempting = 13
    D3DKMT_PreemptionAttemptMissGlobalBlock = 14
    D3DKMT_PreemptionAttemptMissAlreadyRunning = 15
    D3DKMT_PreemptionAttemptStatisticsMax = 16
make_global(D3DKMT_QUERYRESULT_PREEMPTION_ATTEMPT_RESULT)

class D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE(Enum):
    D3DKMT_ClientRenderBuffer = 0
    D3DKMT_ClientPagingBuffer = 1
    D3DKMT_SystemPagingBuffer = 2
    D3DKMT_SystemPreemptionBuffer = 3
    D3DKMT_DmaPacketTypeMax = 4
make_global(D3DKMT_QUERYSTATISTICS_DMA_PACKET_TYPE)

class D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE(Enum):
    D3DKMT_RenderCommandBuffer = 0
    D3DKMT_DeferredCommandBuffer = 1
    D3DKMT_SystemCommandBuffer = 2
    D3DKMT_MmIoFlipCommandBuffer = 3
    D3DKMT_WaitCommandBuffer = 4
    D3DKMT_SignalCommandBuffer = 5
    D3DKMT_DeviceCommandBuffer = 6
    D3DKMT_SoftwareCommandBuffer = 7
    D3DKMT_QueuePacketTypeMax = 8
make_global(D3DKMT_QUERYSTATISTICS_QUEUE_PACKET_TYPE)

class D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS(Enum):
    D3DKMT_AllocationPriorityClassMinimum = 0
    D3DKMT_AllocationPriorityClassLow = 1
    D3DKMT_AllocationPriorityClassNormal = 2
    D3DKMT_AllocationPriorityClassHigh = 3
    D3DKMT_AllocationPriorityClassMaximum = 4
    D3DKMT_MaxAllocationPriorityClass = 5
make_global(D3DKMT_QUERYSTATISTICS_ALLOCATION_PRIORITY_CLASS)

class D3DKMT_QUERYSTATISTICS_TYPE(Enum):
    D3DKMT_QUERYSTATISTICS_ADAPTER = 0
    D3DKMT_QUERYSTATISTICS_PROCESS = 1
    D3DKMT_QUERYSTATISTICS_PROCESS_ADAPTER = 2
    D3DKMT_QUERYSTATISTICS_SEGMENT = 3
    D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT = 4
    D3DKMT_QUERYSTATISTICS_NODE = 5
    D3DKMT_QUERYSTATISTICS_PROCESS_NODE = 6
    D3DKMT_QUERYSTATISTICS_VIDPNSOURCE = 7
    D3DKMT_QUERYSTATISTICS_PROCESS_VIDPNSOURCE = 8
    D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT_GROUP = 9
    D3DKMT_QUERYSTATISTICS_PHYSICAL_ADAPTER = 10
make_global(D3DKMT_QUERYSTATISTICS_TYPE)

class D3DKMT_MEMORY_SEGMENT_GROUP(Enum):
    D3DKMT_MEMORY_SEGMENT_GROUP_LOCAL = 0
    D3DKMT_MEMORY_SEGMENT_GROUP_NON_LOCAL = 1
make_global(D3DKMT_MEMORY_SEGMENT_GROUP)

class D3DKMT_ESCAPETYPE(Enum):
    D3DKMT_ESCAPE_DRIVERPRIVATE = 0
    D3DKMT_ESCAPE_VIDMM = 1
    D3DKMT_ESCAPE_TDRDBGCTRL = 2
    D3DKMT_ESCAPE_VIDSCH = 3
    D3DKMT_ESCAPE_DEVICE = 4
    D3DKMT_ESCAPE_DMM = 5
    D3DKMT_ESCAPE_DEBUG_SNAPSHOT = 6
    D3DKMT_ESCAPE_DRT_TEST = 8
    D3DKMT_ESCAPE_DIAGNOSTICS = 9
    D3DKMT_ESCAPE_OUTPUTDUPL_SNAPSHOT = 10
    D3DKMT_ESCAPE_OUTPUTDUPL_DIAGNOSTICS = 11
    D3DKMT_ESCAPE_BDD_PNP = 12
    D3DKMT_ESCAPE_BDD_FALLBACK = 13
    D3DKMT_ESCAPE_ACTIVATE_SPECIFIC_DIAG = 14
    D3DKMT_ESCAPE_MODES_PRUNED_OUT = 15
    D3DKMT_ESCAPE_WHQL_INFO = 16
    D3DKMT_ESCAPE_BRIGHTNESS = 17
    D3DKMT_ESCAPE_EDID_CACHE = 18
    D3DKMT_ESCAPE_GENERIC_ADAPTER_DIAG_INFO = 19
    D3DKMT_ESCAPE_MIRACAST_DISPLAY_REQUEST = 20
    D3DKMT_ESCAPE_HISTORY_BUFFER_STATUS = 21
    D3DKMT_ESCAPE_MIRACAST_ADAPTER_DIAG_INFO = 23
    D3DKMT_ESCAPE_FORCE_BDDFALLBACK_HEADLESS = 24
    D3DKMT_ESCAPE_REQUEST_MACHINE_CRASH = 25
    D3DKMT_ESCAPE_HMD_GET_EDID_BASE_BLOCK = 26
    D3DKMT_ESCAPE_SOFTGPU_ENABLE_DISABLE_HMD = 27
    D3DKMT_ESCAPE_PROCESS_VERIFIER_OPTION = 28
    D3DKMT_ESCAPE_ADAPTER_VERIFIER_OPTION = 29
    D3DKMT_ESCAPE_IDD_REQUEST = 30
    D3DKMT_ESCAPE_DOD_SET_DIRTYRECT_MODE = 31
    D3DKMT_ESCAPE_LOG_CODEPOINT_PACKET = 32
    D3DKMT_ESCAPE_LOG_USERMODE_DAIG_PACKET = 33
    D3DKMT_ESCAPE_GET_EXTERNAL_DIAGNOSTICS = 34
    D3DKMT_ESCAPE_GET_DISPLAY_CONFIGURATIONS = 36
    D3DKMT_ESCAPE_QUERY_IOMMU_STATUS = 37
    D3DKMT_ESCAPE_CCD_DATABASE = 38
    D3DKMT_ESCAPE_WIN32K_START = 1024
    D3DKMT_ESCAPE_WIN32K_HIP_DEVICE_INFO = 1024
    D3DKMT_ESCAPE_WIN32K_QUERY_CD_ROTATION_BLOCK = 1025
    D3DKMT_ESCAPE_WIN32K_DPI_INFO = 1026
    D3DKMT_ESCAPE_WIN32K_PRESENTER_VIEW_INFO = 1027
    D3DKMT_ESCAPE_WIN32K_SYSTEM_DPI = 1028
    D3DKMT_ESCAPE_WIN32K_BDD_FALLBACK = 1029
    D3DKMT_ESCAPE_WIN32K_DDA_TEST_CTL = 1030
    D3DKMT_ESCAPE_WIN32K_USER_DETECTED_BLACK_SCREEN = 1031
    D3DKMT_ESCAPE_WIN32K_HMD_ENUM = 1032
    D3DKMT_ESCAPE_WIN32K_HMD_CONTROL = 1033
    D3DKMT_ESCAPE_WIN32K_LPMDISPLAY_CONTROL = 1034
make_global(D3DKMT_ESCAPETYPE)

class D3DKMT_VIDMMESCAPETYPE(Enum):
    D3DKMT_VIDMMESCAPETYPE_SETFAULT = 0
    D3DKMT_VIDMMESCAPETYPE_RUN_COHERENCY_TEST = 1
    D3DKMT_VIDMMESCAPETYPE_RUN_UNMAP_TO_DUMMY_PAGE_TEST = 2
    D3DKMT_VIDMMESCAPETYPE_APERTURE_CORRUPTION_CHECK = 3
    D3DKMT_VIDMMESCAPETYPE_SUSPEND_CPU_ACCESS_TEST = 4
    D3DKMT_VIDMMESCAPETYPE_EVICT = 5
    D3DKMT_VIDMMESCAPETYPE_EVICT_BY_NT_HANDLE = 6
    D3DKMT_VIDMMESCAPETYPE_GET_VAD_INFO = 7
    D3DKMT_VIDMMESCAPETYPE_SET_BUDGET = 8
    D3DKMT_VIDMMESCAPETYPE_SUSPEND_PROCESS = 9
    D3DKMT_VIDMMESCAPETYPE_RESUME_PROCESS = 10
    D3DKMT_VIDMMESCAPETYPE_GET_BUDGET = 11
    D3DKMT_VIDMMESCAPETYPE_SET_TRIM_INTERVALS = 12
    D3DKMT_VIDMMESCAPETYPE_EVICT_BY_CRITERIA = 13
    D3DKMT_VIDMMESCAPETYPE_WAKE = 14
    D3DKMT_VIDMMESCAPETYPE_DEFRAG = 15
make_global(D3DKMT_VIDMMESCAPETYPE)

class DXGK_PTE_PAGE_SIZE(Enum):
    DXGK_PTE_PAGE_TABLE_PAGE_4KB = 0
    DXGK_PTE_PAGE_TABLE_PAGE_64KB = 1
make_global(DXGK_PTE_PAGE_SIZE)

class D3DKMT_VAD_ESCAPE_COMMAND(Enum):
    D3DKMT_VAD_ESCAPE_GETNUMVADS = 0
    D3DKMT_VAD_ESCAPE_GETVAD = 1
    D3DKMT_VAD_ESCAPE_GETVADRANGE = 2
    D3DKMT_VAD_ESCAPE_GET_PTE = 3
    D3DKMT_VAD_ESCAPE_GET_GPUMMU_CAPS = 4
    D3DKMT_VAD_ESCAPE_GET_SEGMENT_CAPS = 5
make_global(D3DKMT_VAD_ESCAPE_COMMAND)

class D3DKMT_DEFRAG_ESCAPE_OPERATION(Enum):
    D3DKMT_DEFRAG_ESCAPE_GET_FRAGMENTATION_STATS = 0
    D3DKMT_DEFRAG_ESCAPE_DEFRAG_UPWARD = 1
    D3DKMT_DEFRAG_ESCAPE_DEFRAG_DOWNWARD = 2
    D3DKMT_DEFRAG_ESCAPE_DEFRAG_PASS = 3
    D3DKMT_DEFRAG_ESCAPE_VERIFY_TRANSFER = 4
make_global(D3DKMT_DEFRAG_ESCAPE_OPERATION)

class D3DKMT_TDRDBGCTRLTYPE(Enum):
    D3DKMT_TDRDBGCTRLTYPE_FORCETDR = 0
    D3DKMT_TDRDBGCTRLTYPE_DISABLEBREAK = 1
    D3DKMT_TDRDBGCTRLTYPE_ENABLEBREAK = 2
    D3DKMT_TDRDBGCTRLTYPE_UNCONDITIONAL = 3
    D3DKMT_TDRDBGCTRLTYPE_VSYNCTDR = 4
    D3DKMT_TDRDBGCTRLTYPE_GPUTDR = 5
    D3DKMT_TDRDBGCTRLTYPE_FORCEDODTDR = 6
    D3DKMT_TDRDBGCTRLTYPE_FORCEDODVSYNCTDR = 7
    D3DKMT_TDRDBGCTRLTYPE_ENGINETDR = 8
make_global(D3DKMT_TDRDBGCTRLTYPE)

class D3DKMT_VIDSCHESCAPETYPE(Enum):
    D3DKMT_VIDSCHESCAPETYPE_PREEMPTIONCONTROL = 0
    D3DKMT_VIDSCHESCAPETYPE_SUSPENDSCHEDULER = 1
    D3DKMT_VIDSCHESCAPETYPE_TDRCONTROL = 2
    D3DKMT_VIDSCHESCAPETYPE_SUSPENDRESUME = 3
    D3DKMT_VIDSCHESCAPETYPE_ENABLECONTEXTDELAY = 4
    D3DKMT_VIDSCHESCAPETYPE_CONFIGURE_TDR_LIMIT = 5
    D3DKMT_VIDSCHESCAPETYPE_VGPU_RESET = 6
    D3DKMT_VIDSCHESCAPETYPE_PFN_CONTROL = 7
make_global(D3DKMT_VIDSCHESCAPETYPE)

class D3DKMT_ESCAPE_PFN_CONTROL_COMMAND(Enum):
    D3DKMT_ESCAPE_PFN_CONTROL_DEFAULT = 0
    D3DKMT_ESCAPE_PFN_CONTROL_FORCE_CPU = 1
    D3DKMT_ESCAPE_PFN_CONTROL_FORCE_GPU = 2
make_global(D3DKMT_ESCAPE_PFN_CONTROL_COMMAND)

class D3DKMT_DEVICEESCAPE_TYPE(Enum):
    D3DKMT_DEVICEESCAPE_VIDPNFROMALLOCATION = 0
    D3DKMT_DEVICEESCAPE_RESTOREGAMMA = 1
make_global(D3DKMT_DEVICEESCAPE_TYPE)

class D3DKMT_DMMESCAPETYPE(Enum):
    D3DKMT_DMMESCAPETYPE_UNINITIALIZED = 0
    D3DKMT_DMMESCAPETYPE_GET_SUMMARY_INFO = 1
    D3DKMT_DMMESCAPETYPE_GET_VIDEO_PRESENT_SOURCES_INFO = 2
    D3DKMT_DMMESCAPETYPE_GET_VIDEO_PRESENT_TARGETS_INFO = 3
    D3DKMT_DMMESCAPETYPE_GET_ACTIVEVIDPN_INFO = 4
    D3DKMT_DMMESCAPETYPE_GET_MONITORS_INFO = 5
    D3DKMT_DMMESCAPETYPE_RECENTLY_COMMITTED_VIDPNS_INFO = 6
    D3DKMT_DMMESCAPETYPE_RECENT_MODECHANGE_REQUESTS_INFO = 7
    D3DKMT_DMMESCAPETYPE_RECENTLY_RECOMMENDED_VIDPNS_INFO = 8
    D3DKMT_DMMESCAPETYPE_RECENT_MONITOR_PRESENCE_EVENTS_INFO = 9
    D3DKMT_DMMESCAPETYPE_ACTIVEVIDPN_SOURCEMODESET_INFO = 10
    D3DKMT_DMMESCAPETYPE_ACTIVEVIDPN_COFUNCPATHMODALITY_INFO = 11
    D3DKMT_DMMESCAPETYPE_GET_LASTCLIENTCOMMITTEDVIDPN_INFO = 12
    D3DKMT_DMMESCAPETYPE_GET_VERSION_INFO = 13
    D3DKMT_DMMESCAPETYPE_VIDPN_MGR_DIAGNOSTICS = 14
make_global(D3DKMT_DMMESCAPETYPE)

class D3DKMT_ACTIVATE_SPECIFIC_DIAG_TYPE(Enum):
    D3DKMT_ACTIVATE_SPECIFIC_DIAG_TYPE_EXTRA_CCD_DATABASE_INFO = 0
    D3DKMT_ACTIVATE_SPECIFIC_DIAG_TYPE_MODES_PRUNED = 15
make_global(D3DKMT_ACTIVATE_SPECIFIC_DIAG_TYPE)

class WOW64_SHARED_INFORMATION(Enum):
    SharedNtdll32LdrInitializeThunk = 0
    SharedNtdll32KiUserExceptionDispatcher = 1
    SharedNtdll32KiUserApcDispatcher = 2
    SharedNtdll32KiUserCallbackDispatcher = 3
    SharedNtdll32ExpInterlockedPopEntrySListFault = 4
    SharedNtdll32ExpInterlockedPopEntrySListResume = 5
    SharedNtdll32ExpInterlockedPopEntrySListEnd = 6
    SharedNtdll32RtlUserThreadStart = 7
    SharedNtdll32pQueryProcessDebugInformationRemote = 8
    SharedNtdll32BaseAddress = 9
    SharedNtdll32LdrSystemDllInitBlock = 10
    Wow64SharedPageEntriesCount = 11
make_global(WOW64_SHARED_INFORMATION)

class DOMAIN_INFORMATION_CLASS(Enum):
    DomainPasswordInformation = 1
    DomainGeneralInformation = 2
    DomainLogoffInformation = 3
    DomainOemInformation = 4
    DomainNameInformation = 5
    DomainReplicationInformation = 6
    DomainServerRoleInformation = 7
    DomainModifiedInformation = 8
    DomainStateInformation = 9
    DomainUasInformation = 10
    DomainGeneralInformation2 = 11
    DomainLockoutInformation = 12
    DomainModifiedInformation2 = 13
make_global(DOMAIN_INFORMATION_CLASS)

class DOMAIN_SERVER_ENABLE_STATE(Enum):
    DomainServerEnabled = 1
    DomainServerDisabled = 2
make_global(DOMAIN_SERVER_ENABLE_STATE)

class DOMAIN_SERVER_ROLE(Enum):
    DomainServerRoleBackup = 2
    DomainServerRolePrimary = 3
make_global(DOMAIN_SERVER_ROLE)

class DOMAIN_PASSWORD_CONSTRUCTION(Enum):
    DomainPasswordSimple = 1
    DomainPasswordComplex = 2
make_global(DOMAIN_PASSWORD_CONSTRUCTION)

class DOMAIN_DISPLAY_INFORMATION(Enum):
    DomainDisplayUser = 1
    DomainDisplayMachine = 2
    DomainDisplayGroup = 3
    DomainDisplayOemUser = 4
    DomainDisplayOemGroup = 5
    DomainDisplayServer = 6
make_global(DOMAIN_DISPLAY_INFORMATION)

class DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION(Enum):
    DomainLocalizableAccountsBasic = 1
make_global(DOMAIN_LOCALIZABLE_ACCOUNTS_INFORMATION)

class GROUP_INFORMATION_CLASS(Enum):
    GroupGeneralInformation = 1
    GroupNameInformation = 2
    GroupAttributeInformation = 3
    GroupAdminCommentInformation = 4
    GroupReplicationInformation = 5
make_global(GROUP_INFORMATION_CLASS)

class ALIAS_INFORMATION_CLASS(Enum):
    AliasGeneralInformation = 1
    AliasNameInformation = 2
    AliasAdminCommentInformation = 3
    AliasReplicationInformation = 4
    AliasExtendedInformation = 5
make_global(ALIAS_INFORMATION_CLASS)

class USER_INFORMATION_CLASS(Enum):
    UserGeneralInformation = 1
    UserPreferencesInformation = 2
    UserLogonInformation = 3
    UserLogonHoursInformation = 4
    UserAccountInformation = 5
    UserNameInformation = 6
    UserAccountNameInformation = 7
    UserFullNameInformation = 8
    UserPrimaryGroupInformation = 9
    UserHomeInformation = 10
    UserScriptInformation = 11
    UserProfileInformation = 12
    UserAdminCommentInformation = 13
    UserWorkStationsInformation = 14
    UserSetPasswordInformation = 15
    UserControlInformation = 16
    UserExpiresInformation = 17
    UserInternal1Information = 18
    UserInternal2Information = 19
    UserParametersInformation = 20
    UserAllInformation = 21
    UserInternal3Information = 22
    UserInternal4Information = 23
    UserInternal5Information = 24
    UserInternal4InformationNew = 25
    UserInternal5InformationNew = 26
    UserInternal6Information = 27
    UserExtendedInformation = 28
    UserLogonUIInformation = 29
make_global(USER_INFORMATION_CLASS)

class SECURITY_DB_DELTA_TYPE(Enum):
    SecurityDbNew = 1
    SecurityDbRename = 2
    SecurityDbDelete = 3
    SecurityDbChangeMemberAdd = 4
    SecurityDbChangeMemberSet = 5
    SecurityDbChangeMemberDel = 6
    SecurityDbChange = 7
    SecurityDbChangePassword = 8
make_global(SECURITY_DB_DELTA_TYPE)

class SECURITY_DB_OBJECT_TYPE(Enum):
    SecurityDbObjectSamDomain = 1
    SecurityDbObjectSamUser = 2
    SecurityDbObjectSamGroup = 3
    SecurityDbObjectSamAlias = 4
    SecurityDbObjectLsaPolicy = 5
    SecurityDbObjectLsaTDomain = 6
    SecurityDbObjectLsaAccount = 7
    SecurityDbObjectLsaSecret = 8
make_global(SECURITY_DB_OBJECT_TYPE)

class SAM_ACCOUNT_TYPE(Enum):
    SamObjectUser = 1
    SamObjectGroup = 2
    SamObjectAlias = 3
make_global(SAM_ACCOUNT_TYPE)

class PASSWORD_POLICY_VALIDATION_TYPE(Enum):
    SamValidateAuthentication = 1
    SamValidatePasswordChange = 2
    SamValidatePasswordReset = 3
make_global(PASSWORD_POLICY_VALIDATION_TYPE)

class SAM_VALIDATE_VALIDATION_STATUS(Enum):
    SamValidateSuccess = 0
    SamValidatePasswordMustChange = 1
    SamValidateAccountLockedOut = 2
    SamValidatePasswordExpired = 3
    SamValidatePasswordIncorrect = 4
    SamValidatePasswordIsInHistory = 5
    SamValidatePasswordTooShort = 6
    SamValidatePasswordTooLong = 7
    SamValidatePasswordNotComplexEnough = 8
    SamValidatePasswordTooRecent = 9
    SamValidatePasswordFilterError = 10
make_global(SAM_VALIDATE_VALIDATION_STATUS)

class SAM_GENERIC_OPERATION_TYPE(Enum):
    SamObjectChangeNotificationOperation = 0
make_global(SAM_GENERIC_OPERATION_TYPE)

class VDMSERVICECLASS(Enum):
    VdmStartExecution = 0
    VdmQueueInterrupt = 1
    VdmDelayInterrupt = 2
    VdmInitialize = 3
    VdmFeatures = 4
    VdmSetInt21Handler = 5
    VdmQueryDir = 6
    VdmPrinterDirectIoOpen = 7
    VdmPrinterDirectIoClose = 8
    VdmPrinterInitialize = 9
    VdmSetLdtEntries = 10
    VdmSetProcessLdtInfo = 11
    VdmAdlibEmulation = 12
    VdmPMCliControl = 13
    VdmQueryVdmProcess = 14
make_global(VDMSERVICECLASS)

class TRACE_CONTROL_INFORMATION_CLASS(Enum):
    TraceControlStartLogger = 1
    TraceControlStopLogger = 2
    TraceControlQueryLogger = 3
    TraceControlUpdateLogger = 4
    TraceControlFlushLogger = 5
    TraceControlIncrementLoggerFile = 6
    TraceControlRealtimeConnect = 11
    TraceControlWdiDispatchControl = 13
    TraceControlRealtimeDisconnectConsumerByHandle = 14
    TraceControlReceiveNotification = 16
    TraceControlEnableGuid = 17
    TraceControlSendReplyDataBlock = 18
    TraceControlReceiveReplyDataBlock = 19
    TraceControlWdiUpdateSem = 20
    TraceControlGetTraceGuidList = 21
    TraceControlGetTraceGuidInfo = 22
    TraceControlEnumerateTraceGuids = 23
    TraceControlQueryReferenceTime = 25
    TraceControlTrackProviderBinary = 26
    TraceControlAddNotificationEvent = 27
    TraceControlUpdateDisallowList = 28
    TraceControlUseDescriptorTypeUm = 31
    TraceControlGetTraceGroupList = 32
    TraceControlGetTraceGroupInfo = 33
    TraceControlTraceSetDisallowList = 34
    TraceControlSetCompressionSettings = 35
    TraceControlGetCompressionSettings = 36
    TraceControlUpdatePeriodicCaptureState = 37
    TraceControlGetPrivateSessionTraceHandle = 38
    TraceControlRegisterPrivateSession = 39
    TraceControlQuerySessionDemuxObject = 40
    TraceControlSetProviderBinaryTracking = 41
    TraceControlMaxLoggers = 42
    TraceControlMaxPmcCounter = 43
make_global(TRACE_CONTROL_INFORMATION_CLASS)

class AUDIT_EVENT_TYPE(Enum):
    AuditEventObjectAccess = 0
    AuditEventDirectoryServiceAccess = 1
make_global(AUDIT_EVENT_TYPE)

class TOKEN_TYPE(Enum):
    TokenPrimary = 1
    TokenImpersonation = 2
make_global(TOKEN_TYPE)

class KTMOBJECT_TYPE(Enum):
    KTMOBJECT_TRANSACTION = 0
    KTMOBJECT_TRANSACTION_MANAGER = 1
    KTMOBJECT_RESOURCE_MANAGER = 2
    KTMOBJECT_ENLISTMENT = 3
    KTMOBJECT_INVALID = 4
make_global(KTMOBJECT_TYPE)

class DEVICE_POWER_STATE(Enum):
    PowerDeviceUnspecified = 0
    PowerDeviceD0 = 1
    PowerDeviceD1 = 2
    PowerDeviceD2 = 3
    PowerDeviceD3 = 4
    PowerDeviceMaximum = 5
make_global(DEVICE_POWER_STATE)

class SYSTEM_POWER_STATE(Enum):
    PowerSystemUnspecified = 0
    PowerSystemWorking = 1
    PowerSystemSleeping1 = 2
    PowerSystemSleeping2 = 3
    PowerSystemSleeping3 = 4
    PowerSystemHibernate = 5
    PowerSystemShutdown = 6
    PowerSystemMaximum = 7
make_global(SYSTEM_POWER_STATE)

class ENLISTMENT_INFORMATION_CLASS(Enum):
    EnlistmentBasicInformation = 0
    EnlistmentRecoveryInformation = 1
    EnlistmentCrmInformation = 2
make_global(ENLISTMENT_INFORMATION_CLASS)

class JOBOBJECTINFOCLASS(Enum):
    JobObjectBasicAccountingInformation = 1
    JobObjectBasicLimitInformation = 2
    JobObjectBasicProcessIdList = 3
    JobObjectBasicUIRestrictions = 4
    JobObjectSecurityLimitInformation = 5
    JobObjectEndOfJobTimeInformation = 6
    JobObjectAssociateCompletionPortInformation = 7
    JobObjectBasicAndIoAccountingInformation = 8
    JobObjectExtendedLimitInformation = 9
    JobObjectJobSetInformation = 10
    JobObjectGroupInformation = 11
    JobObjectNotificationLimitInformation = 12
    JobObjectLimitViolationInformation = 13
    JobObjectGroupInformationEx = 14
    JobObjectCpuRateControlInformation = 15
    JobObjectCompletionFilter = 16
    JobObjectCompletionCounter = 17
    JobObjectReserved1Information = 18
    JobObjectReserved2Information = 19
    JobObjectReserved3Information = 20
    JobObjectReserved4Information = 21
    JobObjectReserved5Information = 22
    JobObjectReserved6Information = 23
    JobObjectReserved7Information = 24
    JobObjectReserved8Information = 25
    JobObjectReserved9Information = 26
    JobObjectReserved10Information = 27
    JobObjectReserved11Information = 28
    JobObjectReserved12Information = 29
    JobObjectReserved13Information = 30
    JobObjectReserved14Information = 31
    JobObjectNetRateControlInformation = 32
    JobObjectNotificationLimitInformation2 = 33
    JobObjectLimitViolationInformation2 = 34
    JobObjectCreateSilo = 35
    JobObjectSiloBasicInformation = 36
    JobObjectReserved15Information = 37
    JobObjectReserved16Information = 38
    JobObjectReserved17Information = 39
    JobObjectReserved18Information = 40
    JobObjectReserved19Information = 41
    JobObjectReserved20Information = 42
    JobObjectReserved21Information = 43
    JobObjectReserved22Information = 44
    JobObjectReserved23Information = 45
    JobObjectReserved24Information = 46
    JobObjectReserved25Information = 47
    MaxJobObjectInfoClass = 48
make_global(JOBOBJECTINFOCLASS)

class RESOURCEMANAGER_INFORMATION_CLASS(Enum):
    ResourceManagerBasicInformation = 0
    ResourceManagerCompletionInformation = 1
make_global(RESOURCEMANAGER_INFORMATION_CLASS)

class TOKEN_INFORMATION_CLASS(Enum):
    TokenUser = 1
    TokenGroups = 2
    TokenPrivileges = 3
    TokenOwner = 4
    TokenPrimaryGroup = 5
    TokenDefaultDacl = 6
    TokenSource = 7
    TokenType = 8
    TokenImpersonationLevel = 9
    TokenStatistics = 10
    TokenRestrictedSids = 11
    TokenSessionId = 12
    TokenGroupsAndPrivileges = 13
    TokenSessionReference = 14
    TokenSandBoxInert = 15
    TokenAuditPolicy = 16
    TokenOrigin = 17
    TokenElevationType = 18
    TokenLinkedToken = 19
    TokenElevation = 20
    TokenHasRestrictions = 21
    TokenAccessInformation = 22
    TokenVirtualizationAllowed = 23
    TokenVirtualizationEnabled = 24
    TokenIntegrityLevel = 25
    TokenUIAccess = 26
    TokenMandatoryPolicy = 27
    TokenLogonSid = 28
    TokenIsAppContainer = 29
    TokenCapabilities = 30
    TokenAppContainerSid = 31
    TokenAppContainerNumber = 32
    TokenUserClaimAttributes = 33
    TokenDeviceClaimAttributes = 34
    TokenRestrictedUserClaimAttributes = 35
    TokenRestrictedDeviceClaimAttributes = 36
    TokenDeviceGroups = 37
    TokenRestrictedDeviceGroups = 38
    TokenSecurityAttributes = 39
    TokenIsRestricted = 40
    TokenProcessTrustLevel = 41
    TokenPrivateNameSpace = 42
    TokenSingletonAttributes = 43
    TokenBnoIsolation = 44
    TokenChildProcessFlags = 45
    TokenIsLessPrivilegedAppContainer = 46
    TokenIsSandboxed = 47
    TokenOriginatingProcessTrustLevel = 48
    MaxTokenInfoClass = 49
make_global(TOKEN_INFORMATION_CLASS)

class TRANSACTION_INFORMATION_CLASS(Enum):
    TransactionBasicInformation = 0
    TransactionPropertiesInformation = 1
    TransactionEnlistmentInformation = 2
    TransactionSuperiorEnlistmentInformation = 3
    TransactionBindInformation = 4
    TransactionDTCPrivateInformation = 5
make_global(TRANSACTION_INFORMATION_CLASS)

class TRANSACTIONMANAGER_INFORMATION_CLASS(Enum):
    TransactionManagerBasicInformation = 0
    TransactionManagerLogInformation = 1
    TransactionManagerLogPathInformation = 2
    TransactionManagerRecoveryInformation = 4
    TransactionManagerOnlineProbeInformation = 3
    TransactionManagerOldestTransactionInformation = 5
make_global(TRANSACTIONMANAGER_INFORMATION_CLASS)


```

`src/dumpulator/ntprimitives.py`:

```py
import struct
from typing import Optional
from enum import Enum

class Architecture(object):
    def __init__(self, x64):
        self._x64 = x64

    def ptr_size(self):
        return 8 if self._x64 else 4

    def read(self, addr: int, size: int) -> bytes:
        raise NotImplementedError()

    def write(self, addr: int, data: bytes):
        raise NotImplementedError()

    def read_ptr(self, addr):
        return struct.unpack("<Q" if self._x64 else "<I", self.read(addr, self.ptr_size()))[0]

    def read_ushort(self, addr):
        return struct.unpack("<H", self.read(addr, 2))[0]

    def read_ulong(self, addr):
        return struct.unpack("<I", self.read(addr, 4))[0]

    def read_long(self, addr):
        return struct.unpack("<i", self.read(addr, 4))[0]

    def read_short(self, addr):
        return struct.unpack("<h", self.read(addr, 2))[0]

    def write_ulong(self, addr, value):
        self.write(addr, struct.pack("<I", value))

    def write_long(self, addr, value):
        self.write(addr, struct.pack("<i", value))

    def write_ptr(self, addr, value):
        self.write(addr, struct.pack("<Q" if self._x64 else "<I", value))

    def read_str(self, addr, encoding="utf-8", ):
        data = self.read(addr, 512)

        # Note: this is awful
        if "-16" in encoding:
            nullidx = data.find(b'\0\0')
            if nullidx != -1:
                nullidx += 1
        else:
            nullidx = data.find(b'\0')
        if nullidx != -1:
            data = data[:nullidx]

        return data.decode(encoding)

class PVOID:
    def __init__(self, ptr: int, arch: Architecture):
        self.ptr = ptr
        self.type: Optional[type] = None
        self.arch = arch

    def read(self, size) -> bytes:
        return self.arch.read(self.ptr, size)

    def write(self, data: bytes):
        self.arch.write(self.ptr, data)

    def __getitem__(self, index):
        if self.type is None:
            return self.arch.read_ptr(self.ptr + index * self.arch.ptr_size())
        else:
            assert index == 0  # TODO: sizeof() not yet implemented
            sizeof = self.arch.ptr_size()
            ptr = self.ptr + index * sizeof
            if issubclass(self.type, PVOID):
                return self.type(self.arch.read_ptr(ptr), self.arch)
            else:
                return self.type(PVOID(ptr, self.arch))

    def __int__(self):
        return self.ptr

    def __eq__(self, other):
        return self.ptr == other

    def __ne__(self, other):
        return self.ptr != other

    def __str__(self):
        return f"0x{self:X}"

    def read_str(self, size, encoding="utf8"):
        return self.read(size).decode(encoding)

    def read_unicode_str(self):
        length = self.arch.read_ushort(self.ptr)
        ptr = self.arch.read_ptr(self.ptr + self.arch.ptr_size())
        return self.arch.read(ptr, length).decode("utf-16")

    def read_ptr(self):
        return self.arch.read_ptr(self.ptr)

    def deref(self):
        assert self.type is not None
        return self[0]

def P(t):
    class P(PVOID):
        def __init__(self, ptr, mem_read):
            super().__init__(ptr, mem_read)
            self.type = t
    return P

# Note: this is very WIP
class ArchStream:
    def __init__(self, ptr: PVOID):
        self.ptr = ptr
        self.pos = 0

    @property
    def x64(self):
        return self.ptr.arch.ptr_size() == 8

    def skip(self, size):
        self.pos += size

    def read(self, size):
        data = self.ptr.arch.read(self.ptr.ptr + self.pos, size)
        self.pos += size
        return data

    def read_ushort(self):
        return struct.unpack("<H", self.read(2))[0]

    def read_ulong(self):
        return struct.unpack("<I", self.read(4))[0]

    def read_ptr(self, ptrtype=None):
        ptr = struct.unpack("<Q" if self.x64 else "<I", self.read(self.ptr.arch.ptr_size()))[0]
        m = PVOID(ptr, self.ptr.arch)
        m.type = ptrtype
        return m

class Int(int):
    def __str__(self):
        return f"0x{self:X}"

# Actual primitives
class UCHAR(Int):
    def __new__(cls, value):
        return Int.__new__(cls, value & 0xFF)

class CHAR(Int):
    def __new__(cls, value):
        value = value & 0xFF
        if value & 0x80 != 0:
            value = -((~value) & 0xFF)
        return Int.__new__(cls, value)

class USHORT(Int):
    def __new__(cls, value):
        return Int.__new__(cls, value & 0xFFFF)

class ULONG(Int):
    def __new__(cls, value):
        return Int.__new__(cls, value & 0xFFFFFFFF)

class LONG(Int):
    def __new__(cls, value):
        value = value & 0xFFFFFFFF
        if value & 0x80000000 != 0:
            value = -((~value) & 0xFFFFFFFF)
        return Int.__new__(cls, value)

class ULONG_PTR(Int):
    pass

class SIZE_T(Int):
    pass

class HANDLE(Int):
    pass

# TODO: how does this work in 32 bit?
class ULONG64(Int):
    pass

# Alias types
class ULONGLONG(ULONG64):
    pass

class BYTE(UCHAR):
    pass

class RTL_ATOM(USHORT):
    pass

class NTSTATUS(ULONG):
    pass

class LANGID(USHORT):
    pass

class ALPC_HANDLE(HANDLE):
    pass

class NOTIFICATION_MASK(ULONG):
    pass

class SECURITY_INFORMATION(ULONG):
    pass

class EXECUTION_STATE(ULONG):
    pass

class SE_SIGNING_LEVEL(BYTE):
    pass

class ACCESS_MASK(ULONG):
    pass

class WNF_CHANGE_STAMP(ULONG):
    pass

class KAFFINITY(ULONG_PTR):
    pass

# TODO: should probably be bool
class BOOLEAN(BYTE):
    pass

class LOGICAL(ULONG):
    pass

class LCID(ULONG):
    pass

class PSID(PVOID):
    pass

class PWSTR(PVOID):
    pass

def make_global(t):
    globals().update(t.__members__)

# Some unsupported enum
class LATENCY_TIME(Enum):
    LT_DONT_CARE = 0
    LT_LOWEST_LATENCY = 1
make_global(LATENCY_TIME)

```

`src/dumpulator/ntstructs.py`:

```py
# Automatically generated with parse_phnt.py, do not edit
import struct

from .ntprimitives import PVOID, ArchStream

class ALPC_CONTEXT_ATTR:
    pass

class ALPC_DATA_VIEW_ATTR:
    pass

class ALPC_MESSAGE_ATTRIBUTES:
    pass

class ALPC_PORT_ATTRIBUTES:
    pass

class ALPC_SECURITY_ATTR:
    pass

class BOOT_ENTRY:
    pass

class BOOT_OPTIONS:
    pass

class CLIENT_ID:
    pass

class CONTEXT:
    pass

class CRM_PROTOCOL_ID:
    pass

class CWNF_STATE_NAME:
    pass

class CWNF_TYPE_ID:
    pass

class DBGUI_WAIT_STATE_CHANGE:
    pass

class EFI_DRIVER_ENTRY:
    pass

class ENCLAVE_ROUTINE:
    pass

class EXCEPTION_RECORD:
    pass

class FILE_BASIC_INFORMATION:
    pass

class FILE_IO_COMPLETION_INFORMATION:
    pass

class FILE_NETWORK_OPEN_INFORMATION:
    pass

class FILE_PATH:
    pass

class FILE_SEGMENT_ELEMENT:
    pass

class GENERIC_MAPPING:
    pass

class GROUP_AFFINITY:
    pass

class GUID:
    pass

class INITIAL_TEB:
    pass

class IO_APC_ROUTINE:
    pass

class IO_STATUS_BLOCK:
    pass

class JOB_SET_ARRAY:
    pass

class KEY_VALUE_ENTRY:
    pass

class KTMOBJECT_CURSOR:
    pass

class LARGE_INTEGER:
    pass

class LUID:
    pass

class MEMORY_RANGE_ENTRY:
    pass

class MEM_EXTENDED_PARAMETER:
    pass

class OBJECT_ATTRIBUTES:
    def __init__(self, ptr: PVOID):
        s = ArchStream(ptr)
        self.Length = s.read_ulong()
        if s.x64:
            s.skip(4)
        self.RootDirectory = s.read_ptr()
        self.ObjectName = s.read_ptr(UNICODE_STRING)
        self.Attributes = s.read_ulong()
        if s.x64:
            s.skip(4)
        self.SecurityDescriptor = s.read_ptr()
        self.SecurityQualityOfService = s.read_ptr()

class OBJECT_TYPE_LIST:
    pass

class OWER_ACTION:
    pass

class OWER_INFORMATION_LEVEL:
    pass

class PLUGPLAY_EVENT_BLOCK:
    pass

class PORT_MESSAGE:
    pass

class PORT_VIEW:
    pass

class PRIVILEGE_SET:
    pass

class PROCESSOR_NUMBER:
    pass

class PS_APC_ROUTINE:
    pass

class PS_ATTRIBUTE_LIST:
    pass

class PS_CREATE_INFO:
    pass

class REMOTE_PORT_VIEW:
    pass

class SECURITY_DESCRIPTOR:
    pass

class SECURITY_QUALITY_OF_SERVICE:
    pass

class SID_AND_ATTRIBUTES:
    pass

class T2_CANCEL_PARAMETERS:
    pass

class T2_SET_PARAMETERS:
    pass

class TIMER_APC_ROUTINE:
    pass

class TOKEN_DEFAULT_DACL:
    pass

class TOKEN_GROUPS:
    pass

class TOKEN_MANDATORY_POLICY:
    pass

class TOKEN_OWNER:
    pass

class TOKEN_PRIMARY_GROUP:
    pass

class TOKEN_PRIVILEGES:
    pass

class TOKEN_SECURITY_ATTRIBUTES_INFORMATION:
    pass

class TOKEN_SOURCE:
    pass

class TOKEN_USER:
    pass

class TRANSACTION_NOTIFICATION:
    pass

class ULARGE_INTEGER:
    pass

class UNICODE_STRING:
    def __init__(self, ptr: PVOID):
        s = ArchStream(ptr)
        self.Length = s.read_ushort()
        self.MaximumLength = s.read_ushort()
        if s.x64:
            s.skip(4)
        self.Buffer = s.read_ptr()

    def read_str(self):
        return self.Buffer.read(self.Length).decode("utf-16")

class WNF_DELIVERY_DESCRIPTOR:
    pass

class WNF_STATE_NAME:
    pass


```

`src/dumpulator/ntsyscalls.py`:

```py
import struct
import unicorn
from .dumpulator import Dumpulator, syscall_functions
from .native import *


def syscall(func):
    name: str = func.__name__
    if name.startswith("Nt"):
        name = "Zw" + name[2:]
    syscall_functions[name] = func
    return func

@syscall
def ZwAcceptConnectPort(dp: Dumpulator,
                        PortHandle: P(HANDLE),
                        PortContext: PVOID,
                        ConnectionRequest: P(PORT_MESSAGE),
                        AcceptConnection: BOOLEAN,
                        ServerView: P(PORT_VIEW),
                        ClientView: P(REMOTE_PORT_VIEW)
                        ):
    raise NotImplementedError()

@syscall
def ZwAccessCheck(dp: Dumpulator,
                  SecurityDescriptor: P(SECURITY_DESCRIPTOR),
                  ClientToken: HANDLE,
                  DesiredAccess: ACCESS_MASK,
                  GenericMapping: P(GENERIC_MAPPING),
                  PrivilegeSet: P(PRIVILEGE_SET),
                  PrivilegeSetLength: P(ULONG),
                  GrantedAccess: P(ACCESS_MASK),
                  AccessStatus: P(NTSTATUS)
                  ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckAndAuditAlarm(dp: Dumpulator,
                               SubsystemName: P(UNICODE_STRING),
                               HandleId: PVOID,
                               ObjectTypeName: P(UNICODE_STRING),
                               ObjectName: P(UNICODE_STRING),
                               SecurityDescriptor: P(SECURITY_DESCRIPTOR),
                               DesiredAccess: ACCESS_MASK,
                               GenericMapping: P(GENERIC_MAPPING),
                               ObjectCreation: BOOLEAN,
                               GrantedAccess: P(ACCESS_MASK),
                               AccessStatus: P(NTSTATUS),
                               GenerateOnClose: P(BOOLEAN)
                               ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByType(dp: Dumpulator,
                        SecurityDescriptor: P(SECURITY_DESCRIPTOR),
                        PrincipalSelfSid: PSID,
                        ClientToken: HANDLE,
                        DesiredAccess: ACCESS_MASK,
                        ObjectTypeList: P(OBJECT_TYPE_LIST),
                        ObjectTypeListLength: ULONG,
                        GenericMapping: P(GENERIC_MAPPING),
                        PrivilegeSet: P(PRIVILEGE_SET),
                        PrivilegeSetLength: P(ULONG),
                        GrantedAccess: P(ACCESS_MASK),
                        AccessStatus: P(NTSTATUS)
                        ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByTypeAndAuditAlarm(dp: Dumpulator,
                                     SubsystemName: P(UNICODE_STRING),
                                     HandleId: PVOID,
                                     ObjectTypeName: P(UNICODE_STRING),
                                     ObjectName: P(UNICODE_STRING),
                                     SecurityDescriptor: P(SECURITY_DESCRIPTOR),
                                     PrincipalSelfSid: PSID,
                                     DesiredAccess: ACCESS_MASK,
                                     AuditType: AUDIT_EVENT_TYPE,
                                     Flags: ULONG,
                                     ObjectTypeList: P(OBJECT_TYPE_LIST),
                                     ObjectTypeListLength: ULONG,
                                     GenericMapping: P(GENERIC_MAPPING),
                                     ObjectCreation: BOOLEAN,
                                     GrantedAccess: P(ACCESS_MASK),
                                     AccessStatus: P(NTSTATUS),
                                     GenerateOnClose: P(BOOLEAN)
                                     ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByTypeResultList(dp: Dumpulator,
                                  SecurityDescriptor: P(SECURITY_DESCRIPTOR),
                                  PrincipalSelfSid: PSID,
                                  ClientToken: HANDLE,
                                  DesiredAccess: ACCESS_MASK,
                                  ObjectTypeList: P(OBJECT_TYPE_LIST),
                                  ObjectTypeListLength: ULONG,
                                  GenericMapping: P(GENERIC_MAPPING),
                                  PrivilegeSet: P(PRIVILEGE_SET),
                                  PrivilegeSetLength: P(ULONG),
                                  GrantedAccess: P(ACCESS_MASK),
                                  AccessStatus: P(NTSTATUS)
                                  ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByTypeResultListAndAuditAlarm(dp: Dumpulator,
                                               SubsystemName: P(UNICODE_STRING),
                                               HandleId: PVOID,
                                               ObjectTypeName: P(UNICODE_STRING),
                                               ObjectName: P(UNICODE_STRING),
                                               SecurityDescriptor: P(SECURITY_DESCRIPTOR),
                                               PrincipalSelfSid: PSID,
                                               DesiredAccess: ACCESS_MASK,
                                               AuditType: AUDIT_EVENT_TYPE,
                                               Flags: ULONG,
                                               ObjectTypeList: P(OBJECT_TYPE_LIST),
                                               ObjectTypeListLength: ULONG,
                                               GenericMapping: P(GENERIC_MAPPING),
                                               ObjectCreation: BOOLEAN,
                                               GrantedAccess: P(ACCESS_MASK),
                                               AccessStatus: P(NTSTATUS),
                                               GenerateOnClose: P(BOOLEAN)
                                               ):
    raise NotImplementedError()

@syscall
def ZwAccessCheckByTypeResultListAndAuditAlarmByHandle(dp: Dumpulator,
                                                       SubsystemName: P(UNICODE_STRING),
                                                       HandleId: PVOID,
                                                       ClientToken: HANDLE,
                                                       ObjectTypeName: P(UNICODE_STRING),
                                                       ObjectName: P(UNICODE_STRING),
                                                       SecurityDescriptor: P(SECURITY_DESCRIPTOR),
                                                       PrincipalSelfSid: PSID,
                                                       DesiredAccess: ACCESS_MASK,
                                                       AuditType: AUDIT_EVENT_TYPE,
                                                       Flags: ULONG,
                                                       ObjectTypeList: P(OBJECT_TYPE_LIST),
                                                       ObjectTypeListLength: ULONG,
                                                       GenericMapping: P(GENERIC_MAPPING),
                                                       ObjectCreation: BOOLEAN,
                                                       GrantedAccess: P(ACCESS_MASK),
                                                       AccessStatus: P(NTSTATUS),
                                                       GenerateOnClose: P(BOOLEAN)
                                                       ):
    raise NotImplementedError()

@syscall
def ZwAcquireCMFViewOwnership(dp: Dumpulator,
                              TimeStamp: P(ULONGLONG),
                              tokenTaken: P(BOOLEAN),
                              replaceExisting: BOOLEAN
                              ):
    raise NotImplementedError()

@syscall
def ZwAddAtom(dp: Dumpulator,
              AtomName: PWSTR,
              Length: ULONG,
              Atom: P(RTL_ATOM)
              ):
    raise NotImplementedError()

@syscall
def ZwAddAtomEx(dp: Dumpulator,
                AtomName: PWSTR,
                Length: ULONG,
                Atom: P(RTL_ATOM),
                Flags: ULONG
                ):
    raise NotImplementedError()

@syscall
def ZwAddBootEntry(dp: Dumpulator,
                   BootEntry: P(BOOT_ENTRY),
                   Id: P(ULONG)
                   ):
    raise NotImplementedError()

@syscall
def ZwAddDriverEntry(dp: Dumpulator,
                     DriverEntry: P(EFI_DRIVER_ENTRY),
                     Id: P(ULONG)
                     ):
    raise NotImplementedError()

@syscall
def ZwAdjustGroupsToken(dp: Dumpulator,
                        TokenHandle: HANDLE,
                        ResetToDefault: BOOLEAN,
                        NewState: P(TOKEN_GROUPS),
                        BufferLength: ULONG,
                        PreviousState: P(TOKEN_GROUPS),
                        ReturnLength: P(ULONG)
                        ):
    raise NotImplementedError()

@syscall
def ZwAdjustPrivilegesToken(dp: Dumpulator,
                            TokenHandle: HANDLE,
                            DisableAllPrivileges: BOOLEAN,
                            NewState: P(TOKEN_PRIVILEGES),
                            BufferLength: ULONG,
                            PreviousState: P(TOKEN_PRIVILEGES),
                            ReturnLength: P(ULONG)
                            ):
    raise NotImplementedError()

@syscall
def ZwAdjustTokenClaimsAndDeviceGroups(dp: Dumpulator,
                                       TokenHandle: HANDLE,
                                       UserResetToDefault: BOOLEAN,
                                       DeviceResetToDefault: BOOLEAN,
                                       DeviceGroupsResetToDefault: BOOLEAN,
                                       NewUserState: P(TOKEN_SECURITY_ATTRIBUTES_INFORMATION),
                                       NewDeviceState: P(TOKEN_SECURITY_ATTRIBUTES_INFORMATION),
                                       NewDeviceGroupsState: P(TOKEN_GROUPS),
                                       UserBufferLength: ULONG,
                                       PreviousUserState: P(TOKEN_SECURITY_ATTRIBUTES_INFORMATION),
                                       DeviceBufferLength: ULONG,
                                       PreviousDeviceState: P(TOKEN_SECURITY_ATTRIBUTES_INFORMATION),
                                       DeviceGroupsBufferLength: ULONG,
                                       PreviousDeviceGroups: P(TOKEN_GROUPS),
                                       UserReturnLength: P(ULONG),
                                       DeviceReturnLength: P(ULONG),
                                       DeviceGroupsReturnBufferLength: P(ULONG)
                                       ):
    raise NotImplementedError()

@syscall
def ZwAlertResumeThread(dp: Dumpulator,
                        ThreadHandle: HANDLE,
                        PreviousSuspendCount: P(ULONG)
                        ):
    raise NotImplementedError()

@syscall
def ZwAlertThread(dp: Dumpulator,
                  ThreadHandle: HANDLE
                  ):
    raise NotImplementedError()

@syscall
def ZwAlertThreadByThreadId(dp: Dumpulator,
                            ThreadId: HANDLE
                            ):
    raise NotImplementedError()

@syscall
def ZwAllocateLocallyUniqueId(dp: Dumpulator,
                              Luid: P(LUID)
                              ):
    raise NotImplementedError()

@syscall
def ZwAllocateReserveObject(dp: Dumpulator,
                            MemoryReserveHandle: P(HANDLE),
                            ObjectAttributes: P(OBJECT_ATTRIBUTES),
                            Type: MEMORY_RESERVE_TYPE
                            ):
    raise NotImplementedError()

@syscall
def ZwAllocateUserPhysicalPages(dp: Dumpulator,
                                ProcessHandle: HANDLE,
                                NumberOfPages: P(ULONG_PTR),
                                UserPfnArray: P(ULONG_PTR)
                                ):
    raise NotImplementedError()

@syscall
def ZwAllocateUserPhysicalPagesEx(dp: Dumpulator,
                                  ProcessHandle: HANDLE,
                                  NumberOfPages: P(ULONG_PTR),
                                  UserPfnArray: P(ULONG_PTR),
                                  ExtendedParameters: P(MEM_EXTENDED_PARAMETER),
                                  ExtendedParameterCount: ULONG
                                  ):
    raise NotImplementedError()

@syscall
def ZwAllocateUuids(dp: Dumpulator,
                    Time: P(ULARGE_INTEGER),
                    Range: P(ULONG),
                    Sequence: P(ULONG),
                    Seed: P(CHAR)
                    ):
    raise NotImplementedError()

@syscall
def ZwAllocateVirtualMemory(dp: Dumpulator,
                            ProcessHandle: HANDLE,
                            BaseAddress: P(PVOID),
                            ZeroBits: ULONG_PTR,
                            RegionSize: P(SIZE_T),
                            AllocationType: ULONG,
                            Protect: ULONG
                            ):
    assert ProcessHandle == dp.NtCurrentProcess()
    assert AllocationType == MEM_COMMIT
    assert Protect == PAGE_READWRITE
    base = dp.read_ptr(BaseAddress.ptr)
    size = dp.read_ptr(RegionSize.ptr)
    dp._uc.mem_map(base, size, unicorn.UC_PROT_READ | unicorn.UC_PROT_WRITE)
    return STATUS_SUCCESS

@syscall
def ZwAlpcAcceptConnectPort(dp: Dumpulator,
                            PortHandle: P(HANDLE),
                            ConnectionPortHandle: HANDLE,
                            Flags: ULONG,
                            ObjectAttributes: P(OBJECT_ATTRIBUTES),
                            PortAttributes: P(ALPC_PORT_ATTRIBUTES),
                            PortContext: PVOID,
                            ConnectionRequest: P(PORT_MESSAGE),
                            ConnectionMessageAttributes: P(ALPC_MESSAGE_ATTRIBUTES),
                            AcceptConnection: BOOLEAN
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcCancelMessage(dp: Dumpulator,
                        PortHandle: HANDLE,
                        Flags: ULONG,
                        MessageContext: P(ALPC_CONTEXT_ATTR)
                        ):
    raise NotImplementedError()

@syscall
def ZwAlpcConnectPort(dp: Dumpulator,
                      PortHandle: P(HANDLE),
                      PortName: P(UNICODE_STRING),
                      ObjectAttributes: P(OBJECT_ATTRIBUTES),
                      PortAttributes: P(ALPC_PORT_ATTRIBUTES),
                      Flags: ULONG,
                      RequiredServerSid: PSID,
                      ConnectionMessage: P(PORT_MESSAGE),
                      BufferLength: P(ULONG),
                      OutMessageAttributes: P(ALPC_MESSAGE_ATTRIBUTES),
                      InMessageAttributes: P(ALPC_MESSAGE_ATTRIBUTES),
                      Timeout: P(LARGE_INTEGER)
                      ):
    raise NotImplementedError()

@syscall
def ZwAlpcConnectPortEx(dp: Dumpulator,
                        PortHandle: P(HANDLE),
                        ConnectionPortObjectAttributes: P(OBJECT_ATTRIBUTES),
                        ClientPortObjectAttributes: P(OBJECT_ATTRIBUTES),
                        PortAttributes: P(ALPC_PORT_ATTRIBUTES),
                        Flags: ULONG,
                        ServerSecurityRequirements: P(SECURITY_DESCRIPTOR),
                        ConnectionMessage: P(PORT_MESSAGE),
                        BufferLength: P(SIZE_T),
                        OutMessageAttributes: P(ALPC_MESSAGE_ATTRIBUTES),
                        InMessageAttributes: P(ALPC_MESSAGE_ATTRIBUTES),
                        Timeout: P(LARGE_INTEGER)
                        ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreatePort(dp: Dumpulator,
                     PortHandle: P(HANDLE),
                     ObjectAttributes: P(OBJECT_ATTRIBUTES),
                     PortAttributes: P(ALPC_PORT_ATTRIBUTES)
                     ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreatePortSection(dp: Dumpulator,
                            PortHandle: HANDLE,
                            Flags: ULONG,
                            SectionHandle: HANDLE,
                            SectionSize: SIZE_T,
                            AlpcSectionHandle: P(ALPC_HANDLE),
                            ActualSectionSize: P(SIZE_T)
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreateResourceReserve(dp: Dumpulator,
                                PortHandle: HANDLE,
                                Flags: ULONG,
                                MessageSize: SIZE_T,
                                ResourceId: P(ALPC_HANDLE)
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreateSectionView(dp: Dumpulator,
                            PortHandle: HANDLE,
                            Flags: ULONG,
                            ViewAttributes: P(ALPC_DATA_VIEW_ATTR)
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcCreateSecurityContext(dp: Dumpulator,
                                PortHandle: HANDLE,
                                Flags: ULONG,
                                SecurityAttribute: P(ALPC_SECURITY_ATTR)
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcDeletePortSection(dp: Dumpulator,
                            PortHandle: HANDLE,
                            Flags: ULONG,
                            SectionHandle: ALPC_HANDLE
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcDeleteResourceReserve(dp: Dumpulator,
                                PortHandle: HANDLE,
                                Flags: ULONG,
                                ResourceId: ALPC_HANDLE
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcDeleteSectionView(dp: Dumpulator,
                            PortHandle: HANDLE,
                            Flags: ULONG,
                            ViewBase: PVOID
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcDeleteSecurityContext(dp: Dumpulator,
                                PortHandle: HANDLE,
                                Flags: ULONG,
                                ContextHandle: ALPC_HANDLE
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcDisconnectPort(dp: Dumpulator,
                         PortHandle: HANDLE,
                         Flags: ULONG
                         ):
    raise NotImplementedError()

@syscall
def ZwAlpcImpersonateClientContainerOfPort(dp: Dumpulator,
                                           PortHandle: HANDLE,
                                           Message: P(PORT_MESSAGE),
                                           Flags: ULONG
                                           ):
    raise NotImplementedError()

@syscall
def ZwAlpcImpersonateClientOfPort(dp: Dumpulator,
                                  PortHandle: HANDLE,
                                  Message: P(PORT_MESSAGE),
                                  Flags: PVOID
                                  ):
    raise NotImplementedError()

@syscall
def ZwAlpcOpenSenderProcess(dp: Dumpulator,
                            ProcessHandle: P(HANDLE),
                            PortHandle: HANDLE,
                            PortMessage: P(PORT_MESSAGE),
                            Flags: ULONG,
                            DesiredAccess: ACCESS_MASK,
                            ObjectAttributes: P(OBJECT_ATTRIBUTES)
                            ):
    raise NotImplementedError()

@syscall
def ZwAlpcOpenSenderThread(dp: Dumpulator,
                           ThreadHandle: P(HANDLE),
                           PortHandle: HANDLE,
                           PortMessage: P(PORT_MESSAGE),
                           Flags: ULONG,
                           DesiredAccess: ACCESS_MASK,
                           ObjectAttributes: P(OBJECT_ATTRIBUTES)
                           ):
    raise NotImplementedError()

@syscall
def ZwAlpcQueryInformation(dp: Dumpulator,
                           PortHandle: HANDLE,
                           PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
                           PortInformation: PVOID,
                           Length: ULONG,
                           ReturnLength: P(ULONG)
                           ):
    raise NotImplementedError()

@syscall
def ZwAlpcQueryInformationMessage(dp: Dumpulator,
                                  PortHandle: HANDLE,
                                  PortMessage: P(PORT_MESSAGE),
                                  MessageInformationClass: ALPC_MESSAGE_INFORMATION_CLASS,
                                  MessageInformation: PVOID,
                                  Length: ULONG,
                                  ReturnLength: P(ULONG)
                                  ):
    raise NotImplementedError()

@syscall
def ZwAlpcRevokeSecurityContext(dp: Dumpulator,
                                PortHandle: HANDLE,
                                Flags: ULONG,
                                ContextHandle: ALPC_HANDLE
                                ):
    raise NotImplementedError()

@syscall
def ZwAlpcSendWaitReceivePort(dp: Dumpulator,
                              PortHandle: HANDLE,
                              Flags: ULONG,
                              SendMessageA: P(PORT_MESSAGE),
                              SendMessageAttributes: P(ALPC_MESSAGE_ATTRIBUTES),
                              ReceiveMessage: P(PORT_MESSAGE),
                              BufferLength: P(SIZE_T),
                              ReceiveMessageAttributes: P(ALPC_MESSAGE_ATTRIBUTES),
                              Timeout: P(LARGE_INTEGER)
                              ):
    raise NotImplementedError()

@syscall
def ZwAlpcSetInformation(dp: Dumpulator,
                         PortHandle: HANDLE,
                         PortInformationClass: ALPC_PORT_INFORMATION_CLASS,
                         PortInformation: PVOID,
                         Length: ULONG
                         ):
    raise NotImplementedError()

@syscall
def ZwAreMappedFilesTheSame(dp: Dumpulator,
                            File1MappedAsAnImage: PVOID,
                            File2MappedAsFile: PVOID
                            ):
    raise NotImplementedError()

@syscall
def ZwAssignProcessToJobObject(dp: Dumpulator,
                               JobHandle: HANDLE,
                               ProcessHandle: HANDLE
                               ):
    raise NotImplementedError()

@syscall
def ZwAssociateWaitCompletionPacket(dp: Dumpulator,
                                    WaitCompletionPacketHandle: HANDLE,
                                    IoCompletionHandle: HANDLE,
                                    TargetObjectHandle: HANDLE,
                                    KeyContext: PVOID,
                                    ApcContext: PVOID,
                                    IoStatus: NTSTATUS,
                                    IoStatusInformation: ULONG_PTR,
                                    AlreadySignaled: P(BOOLEAN)
                                    ):
    raise NotImplementedError()

@syscall
def ZwCallbackReturn(dp: Dumpulator,
                     OutputBuffer: PVOID,
                     OutputLength: ULONG,
                     Status: NTSTATUS
                     ):
    raise NotImplementedError()

@syscall
def ZwCallEnclave(dp: Dumpulator,
                  Routine: P(ENCLAVE_ROUTINE),
                  Parameter: PVOID,
                  WaitForThread: BOOLEAN,
                  ReturnValue: P(PVOID)
                  ):
    raise NotImplementedError()

@syscall
def ZwCancelIoFile(dp: Dumpulator,
                   FileHandle: HANDLE,
                   IoStatusBlock: P(IO_STATUS_BLOCK)
                   ):
    raise NotImplementedError()

@syscall
def ZwCancelIoFileEx(dp: Dumpulator,
                     FileHandle: HANDLE,
                     IoRequestToCancel: P(IO_STATUS_BLOCK),
                     IoStatusBlock: P(IO_STATUS_BLOCK)
                     ):
    raise NotImplementedError()

@syscall
def ZwCancelSynchronousIoFile(dp: Dumpulator,
                              ThreadHandle: HANDLE,
                              IoRequestToCancel: P(IO_STATUS_BLOCK),
                              IoStatusBlock: P(IO_STATUS_BLOCK)
                              ):
    raise NotImplementedError()

@syscall
def ZwCancelTimer(dp: Dumpulator,
                  TimerHandle: HANDLE,
                  CurrentState: P(BOOLEAN)
                  ):
    raise NotImplementedError()

@syscall
def ZwCancelTimer2(dp: Dumpulator,
                   TimerHandle: HANDLE,
                   Parameters: P(T2_CANCEL_PARAMETERS)
                   ):
    raise NotImplementedError()

@syscall
def ZwCancelWaitCompletionPacket(dp: Dumpulator,
                                 WaitCompletionPacketHandle: HANDLE,
                                 RemoveSignaledPacket: BOOLEAN
                                 ):
    raise NotImplementedError()

@syscall
def ZwClearEvent(dp: Dumpulator,
                 EventHandle: HANDLE
                 ):
    raise NotImplementedError()

@syscall
def ZwClose(dp: Dumpulator,
            Handle: HANDLE
            ):
    raise NotImplementedError()

@syscall
def ZwCloseObjectAuditAlarm(dp: Dumpulator,
                            SubsystemName: P(UNICODE_STRING),
                            HandleId: PVOID,
                            GenerateOnClose: BOOLEAN
                            ):
    raise NotImplementedError()

@syscall
def ZwCommitComplete(dp: Dumpulator,
                     EnlistmentHandle: HANDLE,
                     TmVirtualClock: P(LARGE_INTEGER)
                     ):
    raise NotImplementedError()

@syscall
def ZwCommitEnlistment(dp: Dumpulator,
                       EnlistmentHandle: HANDLE,
                       TmVirtualClock: P(LARGE_INTEGER)
                       ):
    raise NotImplementedError()

@syscall
def ZwCommitTransaction(dp: Dumpulator,
                        TransactionHandle: HANDLE,
                        Wait: BOOLEAN
                        ):
    raise NotImplementedError()

@syscall
def ZwCompactKeys(dp: Dumpulator,
                  Count: ULONG,
                  KeyArray: P(HANDLE)
                  ):
    raise NotImplementedError()

@syscall
def ZwCompareObjects(dp: Dumpulator,
                     FirstObjectHandle: HANDLE,
                     SecondObjectHandle: HANDLE
                     ):
    raise NotImplementedError()

@syscall
def ZwCompareSigningLevels(dp: Dumpulator,
                           FirstSigningLevel: SE_SIGNING_LEVEL,
                           SecondSigningLevel: SE_SIGNING_LEVEL
                           ):
    raise NotImplementedError()

@syscall
def ZwCompareTokens(dp: Dumpulator,
                    FirstTokenHandle: HANDLE,
                    SecondTokenHandle: HANDLE,
                    Equal: P(BOOLEAN)
                    ):
    raise NotImplementedError()

@syscall
def ZwCompleteConnectPort(dp: Dumpulator,
                          PortHandle: HANDLE
                          ):
    raise NotImplementedError()

@syscall
def ZwCompressKey(dp: Dumpulator,
                  Key: HANDLE
                  ):
    raise NotImplementedError()

@syscall
def ZwConnectPort(dp: Dumpulator,
                  PortHandle: P(HANDLE),
                  PortName: P(UNICODE_STRING),
                  SecurityQos: P(SECURITY_QUALITY_OF_SERVICE),
                  ClientView: P(PORT_VIEW),
                  ServerView: P(REMOTE_PORT_VIEW),
                  MaxMessageLength: P(ULONG),
                  ConnectionInformation: PVOID,
                  ConnectionInformationLength: P(ULONG)
                  ):
    raise NotImplementedError()

@syscall
def ZwContinue(dp: Dumpulator,
               ContextRecord: P(CONTEXT),
               TestAlert: BOOLEAN
               ):
    raise NotImplementedError()

@syscall
def ZwContinueEx(dp: Dumpulator,
                 ContextRecord: P(CONTEXT),
                 ContinueArgument: PVOID
                 ):
    raise NotImplementedError()

@syscall
def ZwCreateDebugObject(dp: Dumpulator,
                        DebugObjectHandle: P(HANDLE),
                        DesiredAccess: ACCESS_MASK,
                        ObjectAttributes: P(OBJECT_ATTRIBUTES),
                        Flags: ULONG
                        ):
    raise NotImplementedError()

@syscall
def ZwCreateDirectoryObject(dp: Dumpulator,
                            DirectoryHandle: P(HANDLE),
                            DesiredAccess: ACCESS_MASK,
                            ObjectAttributes: P(OBJECT_ATTRIBUTES)
                            ):
    raise NotImplementedError()

@syscall
def ZwCreateDirectoryObjectEx(dp: Dumpulator,
                              DirectoryHandle: P(HANDLE),
                              DesiredAccess: ACCESS_MASK,
                              ObjectAttributes: P(OBJECT_ATTRIBUTES),
                              ShadowDirectoryHandle: HANDLE,
                              Flags: ULONG
                              ):
    raise NotImplementedError()

@syscall
def ZwCreateEnclave(dp: Dumpulator,
                    ProcessHandle: HANDLE,
                    BaseAddress: P(PVOID),
                    ZeroBits: ULONG_PTR,
                    Size: SIZE_T,
                    InitialCommitment: SIZE_T,
                    EnclaveType: ULONG,
                    EnclaveInformation: PVOID,
                    EnclaveInformationLength: ULONG,
                    EnclaveError: P(ULONG)
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateEnlistment(dp: Dumpulator,
                       EnlistmentHandle: P(HANDLE),
                       DesiredAccess: ACCESS_MASK,
                       ResourceManagerHandle: HANDLE,
                       TransactionHandle: HANDLE,
                       ObjectAttributes: P(OBJECT_ATTRIBUTES),
                       CreateOptions: ULONG,
                       NotificationMask: NOTIFICATION_MASK,
                       EnlistmentKey: PVOID
                       ):
    raise NotImplementedError()

@syscall
def ZwCreateEvent(dp: Dumpulator,
                  EventHandle: P(HANDLE),
                  DesiredAccess: ACCESS_MASK,
                  ObjectAttributes: P(OBJECT_ATTRIBUTES),
                  EventType: EVENT_TYPE,
                  InitialState: BOOLEAN
                  ):
    raise NotImplementedError()

@syscall
def ZwCreateEventPair(dp: Dumpulator,
                      EventPairHandle: P(HANDLE),
                      DesiredAccess: ACCESS_MASK,
                      ObjectAttributes: P(OBJECT_ATTRIBUTES)
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateFile(dp: Dumpulator,
                 FileHandle: P(HANDLE),
                 DesiredAccess: ACCESS_MASK,
                 ObjectAttributes: P(OBJECT_ATTRIBUTES),
                 IoStatusBlock: P(IO_STATUS_BLOCK),
                 AllocationSize: P(LARGE_INTEGER),
                 FileAttributes: ULONG,
                 ShareAccess: ULONG,
                 CreateDisposition: ULONG,
                 CreateOptions: ULONG,
                 EaBuffer: PVOID,
                 EaLength: ULONG
                 ):
    raise NotImplementedError()

@syscall
def ZwCreateIoCompletion(dp: Dumpulator,
                         IoCompletionHandle: P(HANDLE),
                         DesiredAccess: ACCESS_MASK,
                         ObjectAttributes: P(OBJECT_ATTRIBUTES),
                         Count: ULONG
                         ):
    raise NotImplementedError()

@syscall
def ZwCreateIRTimer(dp: Dumpulator,
                    TimerHandle: P(HANDLE),
                    DesiredAccess: ACCESS_MASK
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateJobObject(dp: Dumpulator,
                      JobHandle: P(HANDLE),
                      DesiredAccess: ACCESS_MASK,
                      ObjectAttributes: P(OBJECT_ATTRIBUTES)
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateJobSet(dp: Dumpulator,
                   NumJob: ULONG,
                   UserJobSet: P(JOB_SET_ARRAY),
                   Flags: ULONG
                   ):
    raise NotImplementedError()

@syscall
def ZwCreateKey(dp: Dumpulator,
                KeyHandle: P(HANDLE),
                DesiredAccess: ACCESS_MASK,
                ObjectAttributes: P(OBJECT_ATTRIBUTES),
                TitleIndex: ULONG,
                Class: P(UNICODE_STRING),
                CreateOptions: ULONG,
                Disposition: P(ULONG)
                ):
    raise NotImplementedError()

@syscall
def ZwCreateKeyedEvent(dp: Dumpulator,
                       KeyedEventHandle: P(HANDLE),
                       DesiredAccess: ACCESS_MASK,
                       ObjectAttributes: P(OBJECT_ATTRIBUTES),
                       Flags: ULONG
                       ):
    raise NotImplementedError()

@syscall
def ZwCreateKeyTransacted(dp: Dumpulator,
                          KeyHandle: P(HANDLE),
                          DesiredAccess: ACCESS_MASK,
                          ObjectAttributes: P(OBJECT_ATTRIBUTES),
                          TitleIndex: ULONG,
                          Class: P(UNICODE_STRING),
                          CreateOptions: ULONG,
                          TransactionHandle: HANDLE,
                          Disposition: P(ULONG)
                          ):
    raise NotImplementedError()

@syscall
def ZwCreateLowBoxToken(dp: Dumpulator,
                        TokenHandle: P(HANDLE),
                        ExistingTokenHandle: HANDLE,
                        DesiredAccess: ACCESS_MASK,
                        ObjectAttributes: P(OBJECT_ATTRIBUTES),
                        PackageSid: PSID,
                        CapabilityCount: ULONG,
                        Capabilities: P(SID_AND_ATTRIBUTES),
                        HandleCount: ULONG,
                        Handles: P(HANDLE)
                        ):
    raise NotImplementedError()

@syscall
def ZwCreateMailslotFile(dp: Dumpulator,
                         FileHandle: P(HANDLE),
                         DesiredAccess: ULONG,
                         ObjectAttributes: P(OBJECT_ATTRIBUTES),
                         IoStatusBlock: P(IO_STATUS_BLOCK),
                         CreateOptions: ULONG,
                         MailslotQuota: ULONG,
                         MaximumMessageSize: ULONG,
                         ReadTimeout: P(LARGE_INTEGER)
                         ):
    raise NotImplementedError()

@syscall
def ZwCreateMutant(dp: Dumpulator,
                   MutantHandle: P(HANDLE),
                   DesiredAccess: ACCESS_MASK,
                   ObjectAttributes: P(OBJECT_ATTRIBUTES),
                   InitialOwner: BOOLEAN
                   ):
    raise NotImplementedError()

@syscall
def ZwCreateNamedPipeFile(dp: Dumpulator,
                          FileHandle: P(HANDLE),
                          DesiredAccess: ULONG,
                          ObjectAttributes: P(OBJECT_ATTRIBUTES),
                          IoStatusBlock: P(IO_STATUS_BLOCK),
                          ShareAccess: ULONG,
                          CreateDisposition: ULONG,
                          CreateOptions: ULONG,
                          NamedPipeType: ULONG,
                          ReadMode: ULONG,
                          CompletionMode: ULONG,
                          MaximumInstances: ULONG,
                          InboundQuota: ULONG,
                          OutboundQuota: ULONG,
                          DefaultTimeout: P(LARGE_INTEGER)
                          ):
    raise NotImplementedError()

@syscall
def ZwCreatePagingFile(dp: Dumpulator,
                       PageFileName: P(UNICODE_STRING),
                       MinimumSize: P(LARGE_INTEGER),
                       MaximumSize: P(LARGE_INTEGER),
                       Priority: ULONG
                       ):
    raise NotImplementedError()

@syscall
def ZwCreatePartition(dp: Dumpulator,
                      PartitionHandle: P(HANDLE),
                      DesiredAccess: ACCESS_MASK,
                      ObjectAttributes: P(OBJECT_ATTRIBUTES),
                      PreferredNode: ULONG
                      ):
    raise NotImplementedError()

@syscall
def ZwCreatePort(dp: Dumpulator,
                 PortHandle: P(HANDLE),
                 ObjectAttributes: P(OBJECT_ATTRIBUTES),
                 MaxConnectionInfoLength: ULONG,
                 MaxMessageLength: ULONG,
                 MaxPoolUsage: ULONG
                 ):
    raise NotImplementedError()

@syscall
def ZwCreatePrivateNamespace(dp: Dumpulator,
                             NamespaceHandle: P(HANDLE),
                             DesiredAccess: ACCESS_MASK,
                             ObjectAttributes: P(OBJECT_ATTRIBUTES),
                             BoundaryDescriptor: PVOID
                             ):
    raise NotImplementedError()

@syscall
def ZwCreateProcess(dp: Dumpulator,
                    ProcessHandle: P(HANDLE),
                    DesiredAccess: ACCESS_MASK,
                    ObjectAttributes: P(OBJECT_ATTRIBUTES),
                    ParentProcess: HANDLE,
                    InheritObjectTable: BOOLEAN,
                    SectionHandle: HANDLE,
                    DebugPort: HANDLE,
                    ExceptionPort: HANDLE
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateProcessEx(dp: Dumpulator,
                      ProcessHandle: P(HANDLE),
                      DesiredAccess: ACCESS_MASK,
                      ObjectAttributes: P(OBJECT_ATTRIBUTES),
                      ParentProcess: HANDLE,
                      Flags: ULONG,
                      SectionHandle: HANDLE,
                      DebugPort: HANDLE,
                      ExceptionPort: HANDLE,
                      JobMemberLevel: ULONG
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateProfile(dp: Dumpulator,
                    ProfileHandle: P(HANDLE),
                    Process: HANDLE,
                    ProfileBase: PVOID,
                    ProfileSize: SIZE_T,
                    BucketSize: ULONG,
                    Buffer: P(ULONG),
                    BufferSize: ULONG,
                    ProfileSource: KPROFILE_SOURCE,
                    Affinity: KAFFINITY
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateProfileEx(dp: Dumpulator,
                      ProfileHandle: P(HANDLE),
                      Process: HANDLE,
                      ProfileBase: PVOID,
                      ProfileSize: SIZE_T,
                      BucketSize: ULONG,
                      Buffer: P(ULONG),
                      BufferSize: ULONG,
                      ProfileSource: KPROFILE_SOURCE,
                      GroupCount: USHORT,
                      GroupAffinity: P(GROUP_AFFINITY)
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateResourceManager(dp: Dumpulator,
                            ResourceManagerHandle: P(HANDLE),
                            DesiredAccess: ACCESS_MASK,
                            TmHandle: HANDLE,
                            RmGuid: P(GUID),
                            ObjectAttributes: P(OBJECT_ATTRIBUTES),
                            CreateOptions: ULONG,
                            Description: P(UNICODE_STRING)
                            ):
    raise NotImplementedError()

@syscall
def ZwCreateSection(dp: Dumpulator,
                    SectionHandle: P(HANDLE),
                    DesiredAccess: ACCESS_MASK,
                    ObjectAttributes: P(OBJECT_ATTRIBUTES),
                    MaximumSize: P(LARGE_INTEGER),
                    SectionPageProtection: ULONG,
                    AllocationAttributes: ULONG,
                    FileHandle: HANDLE
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateSectionEx(dp: Dumpulator,
                      SectionHandle: P(HANDLE),
                      DesiredAccess: ACCESS_MASK,
                      ObjectAttributes: P(OBJECT_ATTRIBUTES),
                      MaximumSize: P(LARGE_INTEGER),
                      SectionPageProtection: ULONG,
                      AllocationAttributes: ULONG,
                      FileHandle: HANDLE,
                      ExtendedParameters: P(MEM_EXTENDED_PARAMETER),
                      ExtendedParameterCount: ULONG
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateSemaphore(dp: Dumpulator,
                      SemaphoreHandle: P(HANDLE),
                      DesiredAccess: ACCESS_MASK,
                      ObjectAttributes: P(OBJECT_ATTRIBUTES),
                      InitialCount: LONG,
                      MaximumCount: LONG
                      ):
    raise NotImplementedError()

@syscall
def ZwCreateSymbolicLinkObject(dp: Dumpulator,
                               LinkHandle: P(HANDLE),
                               DesiredAccess: ACCESS_MASK,
                               ObjectAttributes: P(OBJECT_ATTRIBUTES),
                               LinkTarget: P(UNICODE_STRING)
                               ):
    raise NotImplementedError()

@syscall
def ZwCreateThread(dp: Dumpulator,
                   ThreadHandle: P(HANDLE),
                   DesiredAccess: ACCESS_MASK,
                   ObjectAttributes: P(OBJECT_ATTRIBUTES),
                   ProcessHandle: HANDLE,
                   ClientId: P(CLIENT_ID),
                   ThreadContext: P(CONTEXT),
                   InitialTeb: P(INITIAL_TEB),
                   CreateSuspended: BOOLEAN
                   ):
    raise NotImplementedError()

@syscall
def ZwCreateThreadEx(dp: Dumpulator,
                     ThreadHandle: P(HANDLE),
                     DesiredAccess: ACCESS_MASK,
                     ObjectAttributes: P(OBJECT_ATTRIBUTES),
                     ProcessHandle: HANDLE,
                     StartRoutine: PVOID,
                     Argument: PVOID,
                     CreateFlags: ULONG,
                     ZeroBits: SIZE_T,
                     StackSize: SIZE_T,
                     MaximumStackSize: SIZE_T,
                     AttributeList: P(PS_ATTRIBUTE_LIST)
                     ):
    raise NotImplementedError()

@syscall
def ZwCreateTimer(dp: Dumpulator,
                  TimerHandle: P(HANDLE),
                  DesiredAccess: ACCESS_MASK,
                  ObjectAttributes: P(OBJECT_ATTRIBUTES),
                  TimerType: TIMER_TYPE
                  ):
    raise NotImplementedError()

@syscall
def ZwCreateTimer2(dp: Dumpulator,
                   TimerHandle: P(HANDLE),
                   Reserved1: PVOID,
                   Reserved2: PVOID,
                   Attributes: ULONG,
                   DesiredAccess: ACCESS_MASK
                   ):
    raise NotImplementedError()

@syscall
def ZwCreateToken(dp: Dumpulator,
                  TokenHandle: P(HANDLE),
                  DesiredAccess: ACCESS_MASK,
                  ObjectAttributes: P(OBJECT_ATTRIBUTES),
                  TokenType: TOKEN_TYPE,
                  AuthenticationId: P(LUID),
                  ExpirationTime: P(LARGE_INTEGER),
                  User: P(TOKEN_USER),
                  Groups: P(TOKEN_GROUPS),
                  Privileges: P(TOKEN_PRIVILEGES),
                  Owner: P(TOKEN_OWNER),
                  PrimaryGroup: P(TOKEN_PRIMARY_GROUP),
                  DefaultDacl: P(TOKEN_DEFAULT_DACL),
                  TokenSource: P(TOKEN_SOURCE)
                  ):
    raise NotImplementedError()

@syscall
def ZwCreateTokenEx(dp: Dumpulator,
                    TokenHandle: P(HANDLE),
                    DesiredAccess: ACCESS_MASK,
                    ObjectAttributes: P(OBJECT_ATTRIBUTES),
                    TokenType: TOKEN_TYPE,
                    AuthenticationId: P(LUID),
                    ExpirationTime: P(LARGE_INTEGER),
                    User: P(TOKEN_USER),
                    Groups: P(TOKEN_GROUPS),
                    Privileges: P(TOKEN_PRIVILEGES),
                    UserAttributes: P(TOKEN_SECURITY_ATTRIBUTES_INFORMATION),
                    DeviceAttributes: P(TOKEN_SECURITY_ATTRIBUTES_INFORMATION),
                    DeviceGroups: P(TOKEN_GROUPS),
                    TokenMandatoryPolicy: P(TOKEN_MANDATORY_POLICY),
                    Owner: P(TOKEN_OWNER),
                    PrimaryGroup: P(TOKEN_PRIMARY_GROUP),
                    DefaultDacl: P(TOKEN_DEFAULT_DACL),
                    TokenSource: P(TOKEN_SOURCE)
                    ):
    raise NotImplementedError()

@syscall
def ZwCreateTransaction(dp: Dumpulator,
                        TransactionHandle: P(HANDLE),
                        DesiredAccess: ACCESS_MASK,
                        ObjectAttributes: P(OBJECT_ATTRIBUTES),
                        Uow: P(GUID),
                        TmHandle: HANDLE,
                        CreateOptions: ULONG,
                        IsolationLevel: ULONG,
                        IsolationFlags: ULONG,
                        Timeout: P(LARGE_INTEGER),
                        Description: P(UNICODE_STRING)
                        ):
    raise NotImplementedError()

@syscall
def ZwCreateTransactionManager(dp: Dumpulator,
                               TmHandle: P(HANDLE),
                               DesiredAccess: ACCESS_MASK,
                               ObjectAttributes: P(OBJECT_ATTRIBUTES),
                               LogFileName: P(UNICODE_STRING),
                               CreateOptions: ULONG,
                               CommitStrength: ULONG
                               ):
    raise NotImplementedError()

@syscall
def ZwCreateUserProcess(dp: Dumpulator,
                        ProcessHandle: P(HANDLE),
                        ThreadHandle: P(HANDLE),
                        ProcessDesiredAccess: ACCESS_MASK,
                        ThreadDesiredAccess: ACCESS_MASK,
                        ProcessObjectAttributes: P(OBJECT_ATTRIBUTES),
                        ThreadObjectAttributes: P(OBJECT_ATTRIBUTES),
                        ProcessFlags: ULONG,
                        ThreadFlags: ULONG,
                        ProcessParameters: PVOID,
                        CreateInfo: P(PS_CREATE_INFO),
                        AttributeList: P(PS_ATTRIBUTE_LIST)
                        ):
    raise NotImplementedError()

@syscall
def ZwCreateWaitablePort(dp: Dumpulator,
                         PortHandle: P(HANDLE),
                         ObjectAttributes: P(OBJECT_ATTRIBUTES),
                         MaxConnectionInfoLength: ULONG,
                         MaxMessageLength: ULONG,
                         MaxPoolUsage: ULONG
                         ):
    raise NotImplementedError()

@syscall
def ZwCreateWaitCompletionPacket(dp: Dumpulator,
                                 WaitCompletionPacketHandle: P(HANDLE),
                                 DesiredAccess: ACCESS_MASK,
                                 ObjectAttributes: P(OBJECT_ATTRIBUTES)
                                 ):
    raise NotImplementedError()

@syscall
def ZwCreateWnfStateName(dp: Dumpulator,
                         StateName: P(WNF_STATE_NAME),
                         NameLifetime: WNF_STATE_NAME_LIFETIME,
                         DataScope: WNF_DATA_SCOPE,
                         PersistData: BOOLEAN,
                         TypeId: P(CWNF_TYPE_ID),
                         MaximumStateSize: ULONG,
                         SecurityDescriptor: P(SECURITY_DESCRIPTOR)
                         ):
    raise NotImplementedError()

@syscall
def ZwCreateWorkerFactory(dp: Dumpulator,
                          WorkerFactoryHandleReturn: P(HANDLE),
                          DesiredAccess: ACCESS_MASK,
                          ObjectAttributes: P(OBJECT_ATTRIBUTES),
                          CompletionPortHandle: HANDLE,
                          WorkerProcessHandle: HANDLE,
                          StartRoutine: PVOID,
                          StartParameter: PVOID,
                          MaxThreadCount: ULONG,
                          StackReserve: SIZE_T,
                          StackCommit: SIZE_T
                          ):
    raise NotImplementedError()

@syscall
def ZwDebugActiveProcess(dp: Dumpulator,
                         ProcessHandle: HANDLE,
                         DebugObjectHandle: HANDLE
                         ):
    raise NotImplementedError()

@syscall
def ZwDebugContinue(dp: Dumpulator,
                    DebugObjectHandle: HANDLE,
                    ClientId: P(CLIENT_ID),
                    ContinueStatus: NTSTATUS
                    ):
    raise NotImplementedError()

@syscall
def ZwDelayExecution(dp: Dumpulator,
                     Alertable: BOOLEAN,
                     DelayInterval: P(LARGE_INTEGER)
                     ):
    raise NotImplementedError()

@syscall
def ZwDeleteAtom(dp: Dumpulator,
                 Atom: RTL_ATOM
                 ):
    raise NotImplementedError()

@syscall
def ZwDeleteBootEntry(dp: Dumpulator,
                      Id: ULONG
                      ):
    raise NotImplementedError()

@syscall
def ZwDeleteDriverEntry(dp: Dumpulator,
                        Id: ULONG
                        ):
    raise NotImplementedError()

@syscall
def ZwDeleteFile(dp: Dumpulator,
                 ObjectAttributes: P(OBJECT_ATTRIBUTES)
                 ):
    raise NotImplementedError()

@syscall
def ZwDeleteKey(dp: Dumpulator,
                KeyHandle: HANDLE
                ):
    raise NotImplementedError()

@syscall
def ZwDeleteObjectAuditAlarm(dp: Dumpulator,
                             SubsystemName: P(UNICODE_STRING),
                             HandleId: PVOID,
                             GenerateOnClose: BOOLEAN
                             ):
    raise NotImplementedError()

@syscall
def ZwDeletePrivateNamespace(dp: Dumpulator,
                             NamespaceHandle: HANDLE
                             ):
    raise NotImplementedError()

@syscall
def ZwDeleteValueKey(dp: Dumpulator,
                     KeyHandle: HANDLE,
                     ValueName: P(UNICODE_STRING)
                     ):
    raise NotImplementedError()

@syscall
def ZwDeleteWnfStateData(dp: Dumpulator,
                         StateName: P(CWNF_STATE_NAME),
                         ExplicitScope: PVOID
                         ):
    raise NotImplementedError()

@syscall
def ZwDeleteWnfStateName(dp: Dumpulator,
                         StateName: P(CWNF_STATE_NAME)
                         ):
    raise NotImplementedError()

@syscall
def ZwDeviceIoControlFile(dp: Dumpulator,
                          FileHandle: HANDLE,
                          Event: HANDLE,
                          ApcRoutine: P(IO_APC_ROUTINE),
                          ApcContext: PVOID,
                          IoStatusBlock: P(IO_STATUS_BLOCK),
                          IoControlCode: ULONG,
                          InputBuffer: PVOID,
                          InputBufferLength: ULONG,
                          OutputBuffer: PVOID,
                          OutputBufferLength: ULONG
                          ):
    if FileHandle == dp.console_handle:
        assert IoControlCode == 0x500016
        data = InputBuffer.read(InputBufferLength)
        print(f"InputBuffer: {data.hex()}")

        # TODO: this is totally wrong, but seems to work?
        if dp.ptr_size() == 4:
            buf = InputBuffer.ptr
            params = struct.unpack("<IIII", dp.read(buf, 4 * 4))
            for i, p in enumerate(params):
                print(f"params[{i}] = {p}")

            length = dp.read_ptr(buf + 4 * 4)
            buffer = dp.read_ptr(buf + 4 * 4 + dp.ptr_size())

            ptr1 = dp.read_ptr(buf + 0x18)
            ptr2 = dp.read_ptr(buf + 0x28)
            print(f"ptr1: {ptr1:x}, ptr2: {ptr2:x}")
            dp.write_ptr(ptr2, 0xffffffff)
            print(f"{dp.read_ptr(ptr1):x}")

            print(f"Length: {length}, Buffer: 0x{buffer:x}")
            return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwDisableLastKnownGood(dp: Dumpulator
                           ):
    raise NotImplementedError()

@syscall
def ZwDisplayString(dp: Dumpulator,
                    String: P(UNICODE_STRING)
                    ):
    print("debug: " + String.read_unicode_str())
    return STATUS_PRIVILEGE_NOT_HELD

@syscall
def ZwDrawText(dp: Dumpulator,
               Text: P(UNICODE_STRING)
               ):
    raise NotImplementedError()

@syscall
def ZwDuplicateObject(dp: Dumpulator,
                      SourceProcessHandle: HANDLE,
                      SourceHandle: HANDLE,
                      TargetProcessHandle: HANDLE,
                      TargetHandle: P(HANDLE),
                      DesiredAccess: ACCESS_MASK,
                      HandleAttributes: ULONG,
                      Options: ULONG
                      ):
    raise NotImplementedError()

@syscall
def ZwDuplicateToken(dp: Dumpulator,
                     ExistingTokenHandle: HANDLE,
                     DesiredAccess: ACCESS_MASK,
                     ObjectAttributes: P(OBJECT_ATTRIBUTES),
                     EffectiveOnly: BOOLEAN,
                     TokenType: TOKEN_TYPE,
                     NewTokenHandle: P(HANDLE)
                     ):
    raise NotImplementedError()

@syscall
def ZwEnableLastKnownGood(dp: Dumpulator
                          ):
    raise NotImplementedError()

@syscall
def ZwEnumerateBootEntries(dp: Dumpulator,
                           Buffer: PVOID,
                           BufferLength: P(ULONG)
                           ):
    raise NotImplementedError()

@syscall
def ZwEnumerateDriverEntries(dp: Dumpulator,
                             Buffer: PVOID,
                             BufferLength: P(ULONG)
                             ):
    raise NotImplementedError()

@syscall
def ZwEnumerateKey(dp: Dumpulator,
                   KeyHandle: HANDLE,
                   Index: ULONG,
                   KeyInformationClass: KEY_INFORMATION_CLASS,
                   KeyInformation: PVOID,
                   Length: ULONG,
                   ResultLength: P(ULONG)
                   ):
    raise NotImplementedError()

@syscall
def ZwEnumerateSystemEnvironmentValuesEx(dp: Dumpulator,
                                         InformationClass: ULONG,
                                         Buffer: PVOID,
                                         BufferLength: P(ULONG)
                                         ):
    raise NotImplementedError()

@syscall
def ZwEnumerateTransactionObject(dp: Dumpulator,
                                 RootObjectHandle: HANDLE,
                                 QueryType: KTMOBJECT_TYPE,
                                 ObjectCursor: P(KTMOBJECT_CURSOR),
                                 ObjectCursorLength: ULONG,
                                 ReturnLength: P(ULONG)
                                 ):
    raise NotImplementedError()

@syscall
def ZwEnumerateValueKey(dp: Dumpulator,
                        KeyHandle: HANDLE,
                        Index: ULONG,
                        KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
                        KeyValueInformation: PVOID,
                        Length: ULONG,
                        ResultLength: P(ULONG)
                        ):
    raise NotImplementedError()

@syscall
def ZwExtendSection(dp: Dumpulator,
                    SectionHandle: HANDLE,
                    NewSectionSize: P(LARGE_INTEGER)
                    ):
    raise NotImplementedError()

@syscall
def ZwFilterBootOption(dp: Dumpulator,
                       FilterOperation: FILTER_BOOT_OPTION_OPERATION,
                       ObjectType: ULONG,
                       ElementType: ULONG,
                       Data: PVOID,
                       DataSize: ULONG
                       ):
    raise NotImplementedError()

@syscall
def ZwFilterToken(dp: Dumpulator,
                  ExistingTokenHandle: HANDLE,
                  Flags: ULONG,
                  SidsToDisable: P(TOKEN_GROUPS),
                  PrivilegesToDelete: P(TOKEN_PRIVILEGES),
                  RestrictedSids: P(TOKEN_GROUPS),
                  NewTokenHandle: P(HANDLE)
                  ):
    raise NotImplementedError()

@syscall
def ZwFilterTokenEx(dp: Dumpulator,
                    ExistingTokenHandle: HANDLE,
                    Flags: ULONG,
                    SidsToDisable: P(TOKEN_GROUPS),
                    PrivilegesToDelete: P(TOKEN_PRIVILEGES),
                    RestrictedSids: P(TOKEN_GROUPS),
                    DisableUserClaimsCount: ULONG,
                    UserClaimsToDisable: P(UNICODE_STRING),
                    DisableDeviceClaimsCount: ULONG,
                    DeviceClaimsToDisable: P(UNICODE_STRING),
                    DeviceGroupsToDisable: P(TOKEN_GROUPS),
                    RestrictedUserAttributes: P(TOKEN_SECURITY_ATTRIBUTES_INFORMATION),
                    RestrictedDeviceAttributes: P(TOKEN_SECURITY_ATTRIBUTES_INFORMATION),
                    RestrictedDeviceGroups: P(TOKEN_GROUPS),
                    NewTokenHandle: P(HANDLE)
                    ):
    raise NotImplementedError()

@syscall
def ZwFindAtom(dp: Dumpulator,
               AtomName: PWSTR,
               Length: ULONG,
               Atom: P(RTL_ATOM)
               ):
    raise NotImplementedError()

@syscall
def ZwFlushBuffersFile(dp: Dumpulator,
                       FileHandle: HANDLE,
                       IoStatusBlock: P(IO_STATUS_BLOCK)
                       ):
    raise NotImplementedError()

@syscall
def ZwFlushBuffersFileEx(dp: Dumpulator,
                         FileHandle: HANDLE,
                         Flags: ULONG,
                         Parameters: PVOID,
                         ParametersSize: ULONG,
                         IoStatusBlock: P(IO_STATUS_BLOCK)
                         ):
    raise NotImplementedError()

@syscall
def ZwFlushInstallUILanguage(dp: Dumpulator,
                             InstallUILanguage: LANGID,
                             SetComittedFlag: ULONG
                             ):
    raise NotImplementedError()

@syscall
def ZwFlushInstructionCache(dp: Dumpulator,
                            ProcessHandle: HANDLE,
                            BaseAddress: PVOID,
                            Length: SIZE_T
                            ):
    raise NotImplementedError()

@syscall
def ZwFlushKey(dp: Dumpulator,
               KeyHandle: HANDLE
               ):
    raise NotImplementedError()

@syscall
def ZwFlushProcessWriteBuffers(dp: Dumpulator
                               ):
    raise NotImplementedError()

@syscall
def ZwFlushVirtualMemory(dp: Dumpulator,
                         ProcessHandle: HANDLE,
                         BaseAddress: P(PVOID),
                         RegionSize: P(SIZE_T),
                         IoStatus: P(IO_STATUS_BLOCK)
                         ):
    raise NotImplementedError()

@syscall
def ZwFlushWriteBuffer(dp: Dumpulator
                       ):
    raise NotImplementedError()

@syscall
def ZwFreeUserPhysicalPages(dp: Dumpulator,
                            ProcessHandle: HANDLE,
                            NumberOfPages: P(ULONG_PTR),
                            UserPfnArray: P(ULONG_PTR)
                            ):
    raise NotImplementedError()

@syscall
def ZwFreeVirtualMemory(dp: Dumpulator,
                        ProcessHandle: HANDLE,
                        BaseAddress: P(PVOID),
                        RegionSize: P(SIZE_T),
                        FreeType: ULONG
                        ):
    raise NotImplementedError()

@syscall
def ZwFreezeRegistry(dp: Dumpulator,
                     TimeOutInSeconds: ULONG
                     ):
    raise NotImplementedError()

@syscall
def ZwFreezeTransactions(dp: Dumpulator,
                         FreezeTimeout: P(LARGE_INTEGER),
                         ThawTimeout: P(LARGE_INTEGER)
                         ):
    raise NotImplementedError()

@syscall
def ZwFsControlFile(dp: Dumpulator,
                    FileHandle: HANDLE,
                    Event: HANDLE,
                    ApcRoutine: P(IO_APC_ROUTINE),
                    ApcContext: PVOID,
                    IoStatusBlock: P(IO_STATUS_BLOCK),
                    FsControlCode: ULONG,
                    InputBuffer: PVOID,
                    InputBufferLength: ULONG,
                    OutputBuffer: PVOID,
                    OutputBufferLength: ULONG
                    ):
    raise NotImplementedError()

@syscall
def ZwGetCachedSigningLevel(dp: Dumpulator,
                            File: HANDLE,
                            Flags: P(ULONG),
                            SigningLevel: P(SE_SIGNING_LEVEL),
                            Thumbprint: P(UCHAR),
                            ThumbprintSize: P(ULONG),
                            ThumbprintAlgorithm: P(ULONG)
                            ):
    raise NotImplementedError()

@syscall
def ZwGetCompleteWnfStateSubscription(dp: Dumpulator,
                                      OldDescriptorStateName: P(WNF_STATE_NAME),
                                      OldSubscriptionId: P(ULONG64),
                                      OldDescriptorEventMask: ULONG,
                                      OldDescriptorStatus: ULONG,
                                      NewDeliveryDescriptor: P(WNF_DELIVERY_DESCRIPTOR),
                                      DescriptorSize: ULONG
                                      ):
    raise NotImplementedError()

@syscall
def ZwGetContextThread(dp: Dumpulator,
                       ThreadHandle: HANDLE,
                       ThreadContext: P(CONTEXT)
                       ):
    raise NotImplementedError()

@syscall
def ZwGetCurrentProcessorNumber(dp: Dumpulator
                                ):
    raise NotImplementedError()

@syscall
def ZwGetCurrentProcessorNumberEx(dp: Dumpulator,
                                  ProcNumber: P(PROCESSOR_NUMBER)
                                  ):
    raise NotImplementedError()

@syscall
def ZwGetDevicePowerState(dp: Dumpulator,
                          Device: HANDLE,
                          State: P(DEVICE_POWER_STATE)
                          ):
    raise NotImplementedError()

@syscall
def ZwGetMUIRegistryInfo(dp: Dumpulator,
                         Flags: ULONG,
                         DataSize: P(ULONG),
                         Data: PVOID
                         ):
    raise NotImplementedError()

@syscall
def ZwGetNextProcess(dp: Dumpulator,
                     ProcessHandle: HANDLE,
                     DesiredAccess: ACCESS_MASK,
                     HandleAttributes: ULONG,
                     Flags: ULONG,
                     NewProcessHandle: P(HANDLE)
                     ):
    raise NotImplementedError()

@syscall
def ZwGetNextThread(dp: Dumpulator,
                    ProcessHandle: HANDLE,
                    ThreadHandle: HANDLE,
                    DesiredAccess: ACCESS_MASK,
                    HandleAttributes: ULONG,
                    Flags: ULONG,
                    NewThreadHandle: P(HANDLE)
                    ):
    raise NotImplementedError()

@syscall
def ZwGetNlsSectionPtr(dp: Dumpulator,
                       SectionType: ULONG,
                       SectionData: ULONG,
                       ContextData: PVOID,
                       SectionPointer: P(PVOID),
                       SectionSize: P(ULONG)
                       ):
    raise NotImplementedError()

@syscall
def ZwGetNotificationResourceManager(dp: Dumpulator,
                                     ResourceManagerHandle: HANDLE,
                                     TransactionNotification: P(TRANSACTION_NOTIFICATION),
                                     NotificationLength: ULONG,
                                     Timeout: P(LARGE_INTEGER),
                                     ReturnLength: P(ULONG),
                                     Asynchronous: ULONG,
                                     AsynchronousContext: ULONG_PTR
                                     ):
    raise NotImplementedError()

@syscall
def ZwGetPlugPlayEvent(dp: Dumpulator,
                       EventHandle: HANDLE,
                       Context: PVOID,
                       EventBlock: P(PLUGPLAY_EVENT_BLOCK),
                       EventBufferSize: ULONG
                       ):
    raise NotImplementedError()

@syscall
def ZwGetWriteWatch(dp: Dumpulator,
                    ProcessHandle: HANDLE,
                    Flags: ULONG,
                    BaseAddress: PVOID,
                    RegionSize: SIZE_T,
                    UserAddressArray: P(PVOID),
                    EntriesInUserAddressArray: P(ULONG_PTR),
                    Granularity: P(ULONG)
                    ):
    raise NotImplementedError()

@syscall
def ZwImpersonateAnonymousToken(dp: Dumpulator,
                                ThreadHandle: HANDLE
                                ):
    raise NotImplementedError()

@syscall
def ZwImpersonateClientOfPort(dp: Dumpulator,
                              PortHandle: HANDLE,
                              Message: P(PORT_MESSAGE)
                              ):
    raise NotImplementedError()

@syscall
def ZwImpersonateThread(dp: Dumpulator,
                        ServerThreadHandle: HANDLE,
                        ClientThreadHandle: HANDLE,
                        SecurityQos: P(SECURITY_QUALITY_OF_SERVICE)
                        ):
    raise NotImplementedError()

@syscall
def ZwInitializeEnclave(dp: Dumpulator,
                        ProcessHandle: HANDLE,
                        BaseAddress: PVOID,
                        EnclaveInformation: PVOID,
                        EnclaveInformationLength: ULONG,
                        EnclaveError: P(ULONG)
                        ):
    raise NotImplementedError()

@syscall
def ZwInitializeNlsFiles(dp: Dumpulator,
                         BaseAddress: P(PVOID),
                         DefaultLocaleId: P(LCID),
                         DefaultCasingTableSize: P(LARGE_INTEGER)
                         ):
    raise NotImplementedError()

@syscall
def ZwInitializeRegistry(dp: Dumpulator,
                         BootCondition: USHORT
                         ):
    raise NotImplementedError()

@syscall
def ZwInitiatePowerAction(dp: Dumpulator,
                          SystemAction: P(OWER_ACTION),
                          LightestSystemState: SYSTEM_POWER_STATE,
                          Flags: ULONG,
                          Asynchronous: BOOLEAN
                          ):
    raise NotImplementedError()

@syscall
def ZwIsProcessInJob(dp: Dumpulator,
                     ProcessHandle: HANDLE,
                     JobHandle: HANDLE
                     ):
    raise NotImplementedError()

@syscall
def ZwIsSystemResumeAutomatic(dp: Dumpulator
                              ):
    raise NotImplementedError()

@syscall
def ZwIsUILanguageComitted(dp: Dumpulator
                           ):
    raise NotImplementedError()

@syscall
def ZwListenPort(dp: Dumpulator,
                 PortHandle: HANDLE,
                 ConnectionRequest: P(PORT_MESSAGE)
                 ):
    raise NotImplementedError()

@syscall
def ZwLoadDriver(dp: Dumpulator,
                 DriverServiceName: P(UNICODE_STRING)
                 ):
    raise NotImplementedError()

@syscall
def ZwLoadEnclaveData(dp: Dumpulator,
                      ProcessHandle: HANDLE,
                      BaseAddress: PVOID,
                      Buffer: PVOID,
                      BufferSize: SIZE_T,
                      Protect: ULONG,
                      PageInformation: PVOID,
                      PageInformationLength: ULONG,
                      NumberOfBytesWritten: P(SIZE_T),
                      EnclaveError: P(ULONG)
                      ):
    raise NotImplementedError()

@syscall
def ZwLoadKey(dp: Dumpulator,
              TargetKey: P(OBJECT_ATTRIBUTES),
              SourceFile: P(OBJECT_ATTRIBUTES)
              ):
    raise NotImplementedError()

@syscall
def ZwLoadKey2(dp: Dumpulator,
               TargetKey: P(OBJECT_ATTRIBUTES),
               SourceFile: P(OBJECT_ATTRIBUTES),
               Flags: ULONG
               ):
    raise NotImplementedError()

@syscall
def ZwLoadKeyEx(dp: Dumpulator,
                TargetKey: P(OBJECT_ATTRIBUTES),
                SourceFile: P(OBJECT_ATTRIBUTES),
                Flags: ULONG,
                TrustClassKey: HANDLE,
                Event: HANDLE,
                DesiredAccess: ACCESS_MASK,
                RootHandle: P(HANDLE),
                Reserved: PVOID
                ):
    raise NotImplementedError()

@syscall
def ZwLockFile(dp: Dumpulator,
               FileHandle: HANDLE,
               Event: HANDLE,
               ApcRoutine: P(IO_APC_ROUTINE),
               ApcContext: PVOID,
               IoStatusBlock: P(IO_STATUS_BLOCK),
               ByteOffset: P(LARGE_INTEGER),
               Length: P(LARGE_INTEGER),
               Key: ULONG,
               FailImmediately: BOOLEAN,
               ExclusiveLock: BOOLEAN
               ):
    raise NotImplementedError()

@syscall
def ZwLockProductActivationKeys(dp: Dumpulator,
                                pPrivateVer: P(ULONG),
                                pSafeMode: P(ULONG)
                                ):
    raise NotImplementedError()

@syscall
def ZwLockRegistryKey(dp: Dumpulator,
                      KeyHandle: HANDLE
                      ):
    raise NotImplementedError()

@syscall
def ZwLockVirtualMemory(dp: Dumpulator,
                        ProcessHandle: HANDLE,
                        BaseAddress: P(PVOID),
                        RegionSize: P(SIZE_T),
                        MapType: ULONG
                        ):
    raise NotImplementedError()

@syscall
def ZwMakePermanentObject(dp: Dumpulator,
                          Handle: HANDLE
                          ):
    raise NotImplementedError()

@syscall
def ZwMakeTemporaryObject(dp: Dumpulator,
                          Handle: HANDLE
                          ):
    raise NotImplementedError()

@syscall
def ZwManagePartition(dp: Dumpulator,
                      PartitionInformationClass: MEMORY_PARTITION_INFORMATION_CLASS,
                      PartitionInformation: PVOID,
                      PartitionInformationLength: ULONG
                      ):
    raise NotImplementedError()

@syscall
def ZwMapCMFModule(dp: Dumpulator,
                   What: ULONG,
                   Index: ULONG,
                   CacheIndexOut: P(ULONG),
                   CacheFlagsOut: P(ULONG),
                   ViewSizeOut: P(ULONG),
                   BaseAddress: P(PVOID)
                   ):
    raise NotImplementedError()

@syscall
def ZwMapUserPhysicalPages(dp: Dumpulator,
                           VirtualAddress: PVOID,
                           NumberOfPages: ULONG_PTR,
                           UserPfnArray: P(ULONG_PTR)
                           ):
    raise NotImplementedError()

@syscall
def ZwMapUserPhysicalPagesScatter(dp: Dumpulator,
                                  VirtualAddresses: P(PVOID),
                                  NumberOfPages: ULONG_PTR,
                                  UserPfnArray: P(ULONG_PTR)
                                  ):
    raise NotImplementedError()

@syscall
def ZwMapViewOfSection(dp: Dumpulator,
                       SectionHandle: HANDLE,
                       ProcessHandle: HANDLE,
                       BaseAddress: P(PVOID),
                       ZeroBits: ULONG_PTR,
                       CommitSize: SIZE_T,
                       SectionOffset: P(LARGE_INTEGER),
                       ViewSize: P(SIZE_T),
                       InheritDisposition: SECTION_INHERIT,
                       AllocationType: ULONG,
                       Win32Protect: ULONG
                       ):
    raise NotImplementedError()

@syscall
def ZwModifyBootEntry(dp: Dumpulator,
                      BootEntry: P(BOOT_ENTRY)
                      ):
    raise NotImplementedError()

@syscall
def ZwModifyDriverEntry(dp: Dumpulator,
                        DriverEntry: P(EFI_DRIVER_ENTRY)
                        ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeDirectoryFile(dp: Dumpulator,
                                FileHandle: HANDLE,
                                Event: HANDLE,
                                ApcRoutine: P(IO_APC_ROUTINE),
                                ApcContext: PVOID,
                                IoStatusBlock: P(IO_STATUS_BLOCK),
                                Buffer: PVOID,
                                Length: ULONG,
                                CompletionFilter: ULONG,
                                WatchTree: BOOLEAN
                                ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeDirectoryFileEx(dp: Dumpulator,
                                  FileHandle: HANDLE,
                                  Event: HANDLE,
                                  ApcRoutine: P(IO_APC_ROUTINE),
                                  ApcContext: PVOID,
                                  IoStatusBlock: P(IO_STATUS_BLOCK),
                                  Buffer: PVOID,
                                  Length: ULONG,
                                  CompletionFilter: ULONG,
                                  WatchTree: BOOLEAN,
                                  DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS
                                  ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeKey(dp: Dumpulator,
                      KeyHandle: HANDLE,
                      Event: HANDLE,
                      ApcRoutine: P(IO_APC_ROUTINE),
                      ApcContext: PVOID,
                      IoStatusBlock: P(IO_STATUS_BLOCK),
                      CompletionFilter: ULONG,
                      WatchTree: BOOLEAN,
                      Buffer: PVOID,
                      BufferSize: ULONG,
                      Asynchronous: BOOLEAN
                      ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeMultipleKeys(dp: Dumpulator,
                               MasterKeyHandle: HANDLE,
                               Count: ULONG,
                               SubordinateObjects: P(OBJECT_ATTRIBUTES),
                               Event: HANDLE,
                               ApcRoutine: P(IO_APC_ROUTINE),
                               ApcContext: PVOID,
                               IoStatusBlock: P(IO_STATUS_BLOCK),
                               CompletionFilter: ULONG,
                               WatchTree: BOOLEAN,
                               Buffer: PVOID,
                               BufferSize: ULONG,
                               Asynchronous: BOOLEAN
                               ):
    raise NotImplementedError()

@syscall
def ZwNotifyChangeSession(dp: Dumpulator,
                          SessionHandle: HANDLE,
                          ChangeSequenceNumber: ULONG,
                          ChangeTimeStamp: P(LARGE_INTEGER),
                          Event: IO_SESSION_EVENT,
                          NewState: IO_SESSION_STATE,
                          PreviousState: IO_SESSION_STATE,
                          Payload: PVOID,
                          PayloadSize: ULONG
                          ):
    raise NotImplementedError()

@syscall
def ZwOpenDirectoryObject(dp: Dumpulator,
                          DirectoryHandle: P(HANDLE),
                          DesiredAccess: ACCESS_MASK,
                          ObjectAttributes: P(OBJECT_ATTRIBUTES)
                          ):
    raise NotImplementedError()

@syscall
def ZwOpenEnlistment(dp: Dumpulator,
                     EnlistmentHandle: P(HANDLE),
                     DesiredAccess: ACCESS_MASK,
                     ResourceManagerHandle: HANDLE,
                     EnlistmentGuid: P(GUID),
                     ObjectAttributes: P(OBJECT_ATTRIBUTES)
                     ):
    raise NotImplementedError()

@syscall
def ZwOpenEvent(dp: Dumpulator,
                EventHandle: P(HANDLE),
                DesiredAccess: ACCESS_MASK,
                ObjectAttributes: P(OBJECT_ATTRIBUTES)
                ):
    raise NotImplementedError()

@syscall
def ZwOpenEventPair(dp: Dumpulator,
                    EventPairHandle: P(HANDLE),
                    DesiredAccess: ACCESS_MASK,
                    ObjectAttributes: P(OBJECT_ATTRIBUTES)
                    ):
    raise NotImplementedError()

@syscall
def ZwOpenFile(dp: Dumpulator,
               FileHandle: P(HANDLE),
               DesiredAccess: ACCESS_MASK,
               ObjectAttributes: P(OBJECT_ATTRIBUTES),
               IoStatusBlock: P(IO_STATUS_BLOCK),
               ShareAccess: ULONG,
               OpenOptions: ULONG
               ):
    raise NotImplementedError()

@syscall
def ZwOpenIoCompletion(dp: Dumpulator,
                       IoCompletionHandle: P(HANDLE),
                       DesiredAccess: ACCESS_MASK,
                       ObjectAttributes: P(OBJECT_ATTRIBUTES)
                       ):
    raise NotImplementedError()

@syscall
def ZwOpenJobObject(dp: Dumpulator,
                    JobHandle: P(HANDLE),
                    DesiredAccess: ACCESS_MASK,
                    ObjectAttributes: P(OBJECT_ATTRIBUTES)
                    ):
    raise NotImplementedError()

@syscall
def ZwOpenKey(dp: Dumpulator,
              KeyHandle: P(HANDLE),
              DesiredAccess: ACCESS_MASK,
              ObjectAttributes: P(OBJECT_ATTRIBUTES)
              ):
    raise NotImplementedError()

@syscall
def ZwOpenKeyedEvent(dp: Dumpulator,
                     KeyedEventHandle: P(HANDLE),
                     DesiredAccess: ACCESS_MASK,
                     ObjectAttributes: P(OBJECT_ATTRIBUTES)
                     ):
    raise NotImplementedError()

@syscall
def ZwOpenKeyEx(dp: Dumpulator,
                KeyHandle: P(HANDLE),
                DesiredAccess: ACCESS_MASK,
                ObjectAttributes: P(OBJECT_ATTRIBUTES),
                OpenOptions: ULONG
                ):
    raise NotImplementedError()

@syscall
def ZwOpenKeyTransacted(dp: Dumpulator,
                        KeyHandle: P(HANDLE),
                        DesiredAccess: ACCESS_MASK,
                        ObjectAttributes: P(OBJECT_ATTRIBUTES),
                        TransactionHandle: HANDLE
                        ):
    raise NotImplementedError()

@syscall
def ZwOpenKeyTransactedEx(dp: Dumpulator,
                          KeyHandle: P(HANDLE),
                          DesiredAccess: ACCESS_MASK,
                          ObjectAttributes: P(OBJECT_ATTRIBUTES),
                          OpenOptions: ULONG,
                          TransactionHandle: HANDLE
                          ):
    raise NotImplementedError()

@syscall
def ZwOpenMutant(dp: Dumpulator,
                 MutantHandle: P(HANDLE),
                 DesiredAccess: ACCESS_MASK,
                 ObjectAttributes: P(OBJECT_ATTRIBUTES)
                 ):
    raise NotImplementedError()

@syscall
def ZwOpenObjectAuditAlarm(dp: Dumpulator,
                           SubsystemName: P(UNICODE_STRING),
                           HandleId: PVOID,
                           ObjectTypeName: P(UNICODE_STRING),
                           ObjectName: P(UNICODE_STRING),
                           SecurityDescriptor: P(SECURITY_DESCRIPTOR),
                           ClientToken: HANDLE,
                           DesiredAccess: ACCESS_MASK,
                           GrantedAccess: ACCESS_MASK,
                           Privileges: P(PRIVILEGE_SET),
                           ObjectCreation: BOOLEAN,
                           AccessGranted: BOOLEAN,
                           GenerateOnClose: P(BOOLEAN)
                           ):
    raise NotImplementedError()

@syscall
def ZwOpenPartition(dp: Dumpulator,
                    PartitionHandle: P(HANDLE),
                    DesiredAccess: ACCESS_MASK,
                    ObjectAttributes: P(OBJECT_ATTRIBUTES)
                    ):
    raise NotImplementedError()

@syscall
def ZwOpenPrivateNamespace(dp: Dumpulator,
                           NamespaceHandle: P(HANDLE),
                           DesiredAccess: ACCESS_MASK,
                           ObjectAttributes: P(OBJECT_ATTRIBUTES),
                           BoundaryDescriptor: PVOID
                           ):
    raise NotImplementedError()

@syscall
def ZwOpenProcess(dp: Dumpulator,
                  ProcessHandle: P(HANDLE),
                  DesiredAccess: ACCESS_MASK,
                  ObjectAttributes: P(OBJECT_ATTRIBUTES),
                  ClientId: P(CLIENT_ID)
                  ):
    raise NotImplementedError()

@syscall
def ZwOpenProcessToken(dp: Dumpulator,
                       ProcessHandle: HANDLE,
                       DesiredAccess: ACCESS_MASK,
                       TokenHandle: P(HANDLE)
                       ):
    raise NotImplementedError()

@syscall
def ZwOpenProcessTokenEx(dp: Dumpulator,
                         ProcessHandle: HANDLE,
                         DesiredAccess: ACCESS_MASK,
                         HandleAttributes: ULONG,
                         TokenHandle: P(HANDLE)
                         ):
    raise NotImplementedError()

@syscall
def ZwOpenResourceManager(dp: Dumpulator,
                          ResourceManagerHandle: P(HANDLE),
                          DesiredAccess: ACCESS_MASK,
                          TmHandle: HANDLE,
                          ResourceManagerGuid: P(GUID),
                          ObjectAttributes: P(OBJECT_ATTRIBUTES)
                          ):
    raise NotImplementedError()

@syscall
def ZwOpenSection(dp: Dumpulator,
                  SectionHandle: P(HANDLE),
                  DesiredAccess: ACCESS_MASK,
                  ObjectAttributes: P(OBJECT_ATTRIBUTES)
                  ):
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwOpenSemaphore(dp: Dumpulator,
                    SemaphoreHandle: P(HANDLE),
                    DesiredAccess: ACCESS_MASK,
                    ObjectAttributes: P(OBJECT_ATTRIBUTES)
                    ):
    raise NotImplementedError()

@syscall
def ZwOpenSession(dp: Dumpulator,
                  SessionHandle: P(HANDLE),
                  DesiredAccess: ACCESS_MASK,
                  ObjectAttributes: P(OBJECT_ATTRIBUTES)
                  ):
    raise NotImplementedError()

@syscall
def ZwOpenSymbolicLinkObject(dp: Dumpulator,
                             LinkHandle: P(HANDLE),
                             DesiredAccess: ACCESS_MASK,
                             ObjectAttributes: P(OBJECT_ATTRIBUTES)
                             ):
    raise NotImplementedError()

@syscall
def ZwOpenThread(dp: Dumpulator,
                 ThreadHandle: P(HANDLE),
                 DesiredAccess: ACCESS_MASK,
                 ObjectAttributes: P(OBJECT_ATTRIBUTES),
                 ClientId: P(CLIENT_ID)
                 ):
    raise NotImplementedError()

@syscall
def ZwOpenThreadToken(dp: Dumpulator,
                      ThreadHandle: HANDLE,
                      DesiredAccess: ACCESS_MASK,
                      OpenAsSelf: BOOLEAN,
                      TokenHandle: P(HANDLE)
                      ):
    raise NotImplementedError()

@syscall
def ZwOpenThreadTokenEx(dp: Dumpulator,
                        ThreadHandle: HANDLE,
                        DesiredAccess: ACCESS_MASK,
                        OpenAsSelf: BOOLEAN,
                        HandleAttributes: ULONG,
                        TokenHandle: P(HANDLE)
                        ):
    raise NotImplementedError()

@syscall
def ZwOpenTimer(dp: Dumpulator,
                TimerHandle: P(HANDLE),
                DesiredAccess: ACCESS_MASK,
                ObjectAttributes: P(OBJECT_ATTRIBUTES)
                ):
    raise NotImplementedError()

@syscall
def ZwOpenTransaction(dp: Dumpulator,
                      TransactionHandle: P(HANDLE),
                      DesiredAccess: ACCESS_MASK,
                      ObjectAttributes: P(OBJECT_ATTRIBUTES),
                      Uow: P(GUID),
                      TmHandle: HANDLE
                      ):
    raise NotImplementedError()

@syscall
def ZwOpenTransactionManager(dp: Dumpulator,
                             TmHandle: P(HANDLE),
                             DesiredAccess: ACCESS_MASK,
                             ObjectAttributes: P(OBJECT_ATTRIBUTES),
                             LogFileName: P(UNICODE_STRING),
                             TmIdentity: P(GUID),
                             OpenOptions: ULONG
                             ):
    raise NotImplementedError()

@syscall
def ZwPlugPlayControl(dp: Dumpulator,
                      PnPControlClass: PLUGPLAY_CONTROL_CLASS,
                      PnPControlData: PVOID,
                      PnPControlDataLength: ULONG
                      ):
    raise NotImplementedError()

@syscall
def ZwPowerInformation(dp: Dumpulator,
                       InformationLevel: P(OWER_INFORMATION_LEVEL),
                       InputBuffer: PVOID,
                       InputBufferLength: ULONG,
                       OutputBuffer: PVOID,
                       OutputBufferLength: ULONG
                       ):
    raise NotImplementedError()

@syscall
def ZwPrepareComplete(dp: Dumpulator,
                      EnlistmentHandle: HANDLE,
                      TmVirtualClock: P(LARGE_INTEGER)
                      ):
    raise NotImplementedError()

@syscall
def ZwPrepareEnlistment(dp: Dumpulator,
                        EnlistmentHandle: HANDLE,
                        TmVirtualClock: P(LARGE_INTEGER)
                        ):
    raise NotImplementedError()

@syscall
def ZwPrePrepareComplete(dp: Dumpulator,
                         EnlistmentHandle: HANDLE,
                         TmVirtualClock: P(LARGE_INTEGER)
                         ):
    raise NotImplementedError()

@syscall
def ZwPrePrepareEnlistment(dp: Dumpulator,
                           EnlistmentHandle: HANDLE,
                           TmVirtualClock: P(LARGE_INTEGER)
                           ):
    raise NotImplementedError()

@syscall
def ZwPrivilegeCheck(dp: Dumpulator,
                     ClientToken: HANDLE,
                     RequiredPrivileges: P(PRIVILEGE_SET),
                     Result: P(BOOLEAN)
                     ):
    raise NotImplementedError()

@syscall
def ZwPrivilegedServiceAuditAlarm(dp: Dumpulator,
                                  SubsystemName: P(UNICODE_STRING),
                                  ServiceName: P(UNICODE_STRING),
                                  ClientToken: HANDLE,
                                  Privileges: P(PRIVILEGE_SET),
                                  AccessGranted: BOOLEAN
                                  ):
    raise NotImplementedError()

@syscall
def ZwPrivilegeObjectAuditAlarm(dp: Dumpulator,
                                SubsystemName: P(UNICODE_STRING),
                                HandleId: PVOID,
                                ClientToken: HANDLE,
                                DesiredAccess: ACCESS_MASK,
                                Privileges: P(PRIVILEGE_SET),
                                AccessGranted: BOOLEAN
                                ):
    raise NotImplementedError()

@syscall
def ZwPropagationComplete(dp: Dumpulator,
                          ResourceManagerHandle: HANDLE,
                          RequestCookie: ULONG,
                          BufferLength: ULONG,
                          Buffer: PVOID
                          ):
    raise NotImplementedError()

@syscall
def ZwPropagationFailed(dp: Dumpulator,
                        ResourceManagerHandle: HANDLE,
                        RequestCookie: ULONG,
                        PropStatus: NTSTATUS
                        ):
    raise NotImplementedError()

@syscall
def ZwProtectVirtualMemory(dp: Dumpulator,
                           ProcessHandle: HANDLE,
                           BaseAddress: P(PVOID),
                           RegionSize: P(SIZE_T),
                           NewProtect: ULONG,
                           OldProtect: P(ULONG)
                           ):
    base = BaseAddress.read_ptr() & 0xFFFFFFFFFFFFF000
    size = round_to_pages(RegionSize.read_ptr())

    print(f"protect {base:x}[{size:x}] = {NewProtect:x}")
    dp.protect(base, size, NewProtect)
    # TODO: OldProtect is not implemented
    return STATUS_SUCCESS

@syscall
def ZwPulseEvent(dp: Dumpulator,
                 EventHandle: HANDLE,
                 PreviousState: P(LONG)
                 ):
    raise NotImplementedError()

@syscall
def ZwQueryAttributesFile(dp: Dumpulator,
                          ObjectAttributes: P(OBJECT_ATTRIBUTES),
                          FileInformation: P(FILE_BASIC_INFORMATION)
                          ):
    raise NotImplementedError()

@syscall
def ZwQueryBootEntryOrder(dp: Dumpulator,
                          Ids: P(ULONG),
                          Count: P(ULONG)
                          ):
    raise NotImplementedError()

@syscall
def ZwQueryBootOptions(dp: Dumpulator,
                       BootOptions: P(BOOT_OPTIONS),
                       BootOptionsLength: P(ULONG)
                       ):
    raise NotImplementedError()

@syscall
def ZwQueryDebugFilterState(dp: Dumpulator,
                            ComponentId: ULONG,
                            Level: ULONG
                            ):
    raise NotImplementedError()

@syscall
def ZwQueryDefaultLocale(dp: Dumpulator,
                         UserProfile: BOOLEAN,
                         DefaultLocaleId: P(LCID)
                         ):
    raise NotImplementedError()

@syscall
def ZwQueryDefaultUILanguage(dp: Dumpulator,
                             DefaultUILanguageId: P(LANGID)
                             ):
    raise NotImplementedError()

@syscall
def ZwQueryDirectoryFile(dp: Dumpulator,
                         FileHandle: HANDLE,
                         Event: HANDLE,
                         ApcRoutine: P(IO_APC_ROUTINE),
                         ApcContext: PVOID,
                         IoStatusBlock: P(IO_STATUS_BLOCK),
                         FileInformation: PVOID,
                         Length: ULONG,
                         FileInformationClass: FILE_INFORMATION_CLASS,
                         ReturnSingleEntry: BOOLEAN,
                         FileName: P(UNICODE_STRING),
                         RestartScan: BOOLEAN
                         ):
    raise NotImplementedError()

@syscall
def ZwQueryDirectoryFileEx(dp: Dumpulator,
                           FileHandle: HANDLE,
                           Event: HANDLE,
                           ApcRoutine: P(IO_APC_ROUTINE),
                           ApcContext: PVOID,
                           IoStatusBlock: P(IO_STATUS_BLOCK),
                           FileInformation: PVOID,
                           Length: ULONG,
                           FileInformationClass: FILE_INFORMATION_CLASS,
                           QueryFlags: ULONG,
                           FileName: P(UNICODE_STRING)
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryDirectoryObject(dp: Dumpulator,
                           DirectoryHandle: HANDLE,
                           Buffer: PVOID,
                           Length: ULONG,
                           ReturnSingleEntry: BOOLEAN,
                           RestartScan: BOOLEAN,
                           Context: P(ULONG),
                           ReturnLength: P(ULONG)
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryDriverEntryOrder(dp: Dumpulator,
                            Ids: P(ULONG),
                            Count: P(ULONG)
                            ):
    raise NotImplementedError()

@syscall
def ZwQueryEaFile(dp: Dumpulator,
                  FileHandle: HANDLE,
                  IoStatusBlock: P(IO_STATUS_BLOCK),
                  Buffer: PVOID,
                  Length: ULONG,
                  ReturnSingleEntry: BOOLEAN,
                  EaList: PVOID,
                  EaListLength: ULONG,
                  EaIndex: P(ULONG),
                  RestartScan: BOOLEAN
                  ):
    raise NotImplementedError()

@syscall
def ZwQueryEvent(dp: Dumpulator,
                 EventHandle: HANDLE,
                 EventInformationClass: EVENT_INFORMATION_CLASS,
                 EventInformation: PVOID,
                 EventInformationLength: ULONG,
                 ReturnLength: P(ULONG)
                 ):
    raise NotImplementedError()

@syscall
def ZwQueryFullAttributesFile(dp: Dumpulator,
                              ObjectAttributes: P(OBJECT_ATTRIBUTES),
                              FileInformation: P(FILE_NETWORK_OPEN_INFORMATION)
                              ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationAtom(dp: Dumpulator,
                           Atom: RTL_ATOM,
                           AtomInformationClass: ATOM_INFORMATION_CLASS,
                           AtomInformation: PVOID,
                           AtomInformationLength: ULONG,
                           ReturnLength: P(ULONG)
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationByName(dp: Dumpulator,
                             ObjectAttributes: P(OBJECT_ATTRIBUTES),
                             IoStatusBlock: P(IO_STATUS_BLOCK),
                             FileInformation: PVOID,
                             Length: ULONG,
                             FileInformationClass: FILE_INFORMATION_CLASS
                             ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationEnlistment(dp: Dumpulator,
                                 EnlistmentHandle: HANDLE,
                                 EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
                                 EnlistmentInformation: PVOID,
                                 EnlistmentInformationLength: ULONG,
                                 ReturnLength: P(ULONG)
                                 ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationFile(dp: Dumpulator,
                           FileHandle: HANDLE,
                           IoStatusBlock: P(IO_STATUS_BLOCK),
                           FileInformation: PVOID,
                           Length: ULONG,
                           FileInformationClass: FILE_INFORMATION_CLASS
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationJobObject(dp: Dumpulator,
                                JobHandle: HANDLE,
                                JobObjectInformationClass: JOBOBJECTINFOCLASS,
                                JobObjectInformation: PVOID,
                                JobObjectInformationLength: ULONG,
                                ReturnLength: P(ULONG)
                                ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationPort(dp: Dumpulator,
                           PortHandle: HANDLE,
                           PortInformationClass: PORT_INFORMATION_CLASS,
                           PortInformation: PVOID,
                           Length: ULONG,
                           ReturnLength: P(ULONG)
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationProcess(dp: Dumpulator,
                              ProcessHandle: HANDLE,
                              ProcessInformationClass: PROCESSINFOCLASS,
                              ProcessInformation: PVOID,
                              ProcessInformationLength: ULONG,
                              ReturnLength: P(ULONG)
                              ):
    assert (ProcessHandle == dp.NtCurrentProcess())
    if ProcessInformationClass in [PROCESSINFOCLASS.ProcessDebugPort, PROCESSINFOCLASS.ProcessDebugObjectHandle]:
        assert (ProcessInformationLength == 4)
        dp.write_ulong(ProcessInformation.ptr, 0)
        if ReturnLength != 0:
            dp.write_ulong(ReturnLength.ptr, 4)
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwQueryInformationResourceManager(dp: Dumpulator,
                                      ResourceManagerHandle: HANDLE,
                                      ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
                                      ResourceManagerInformation: PVOID,
                                      ResourceManagerInformationLength: ULONG,
                                      ReturnLength: P(ULONG)
                                      ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationThread(dp: Dumpulator,
                             ThreadHandle: HANDLE,
                             ThreadInformationClass: THREADINFOCLASS,
                             ThreadInformation: PVOID,
                             ThreadInformationLength: ULONG,
                             ReturnLength: P(ULONG)
                             ):
    if ThreadInformationClass == THREADINFOCLASS.ThreadDynamicCodePolicyInfo:
        assert ThreadInformationLength == 4
        assert ReturnLength == 0
        dp.write_ulong(ThreadInformation, 0)
        return STATUS_SUCCESS
    raise Exception()

@syscall
def ZwQueryInformationToken(dp: Dumpulator,
                            TokenHandle: HANDLE,
                            TokenInformationClass: TOKEN_INFORMATION_CLASS,
                            TokenInformation: PVOID,
                            TokenInformationLength: ULONG,
                            ReturnLength: P(ULONG)
                            ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationTransaction(dp: Dumpulator,
                                  TransactionHandle: HANDLE,
                                  TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
                                  TransactionInformation: PVOID,
                                  TransactionInformationLength: ULONG,
                                  ReturnLength: P(ULONG)
                                  ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationTransactionManager(dp: Dumpulator,
                                         TransactionManagerHandle: HANDLE,
                                         TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
                                         TransactionManagerInformation: PVOID,
                                         TransactionManagerInformationLength: ULONG,
                                         ReturnLength: P(ULONG)
                                         ):
    raise NotImplementedError()

@syscall
def ZwQueryInformationWorkerFactory(dp: Dumpulator,
                                    WorkerFactoryHandle: HANDLE,
                                    WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
                                    WorkerFactoryInformation: PVOID,
                                    WorkerFactoryInformationLength: ULONG,
                                    ReturnLength: P(ULONG)
                                    ):
    raise NotImplementedError()

@syscall
def ZwQueryInstallUILanguage(dp: Dumpulator,
                             InstallUILanguageId: P(LANGID)
                             ):
    raise NotImplementedError()

@syscall
def ZwQueryIntervalProfile(dp: Dumpulator,
                           ProfileSource: KPROFILE_SOURCE,
                           Interval: P(ULONG)
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryIoCompletion(dp: Dumpulator,
                        IoCompletionHandle: HANDLE,
                        IoCompletionInformationClass: IO_COMPLETION_INFORMATION_CLASS,
                        IoCompletionInformation: PVOID,
                        IoCompletionInformationLength: ULONG,
                        ReturnLength: P(ULONG)
                        ):
    raise NotImplementedError()

@syscall
def ZwQueryKey(dp: Dumpulator,
               KeyHandle: HANDLE,
               KeyInformationClass: KEY_INFORMATION_CLASS,
               KeyInformation: PVOID,
               Length: ULONG,
               ResultLength: P(ULONG)
               ):
    raise NotImplementedError()

@syscall
def ZwQueryLicenseValue(dp: Dumpulator,
                        ValueName: P(UNICODE_STRING),
                        Type: P(ULONG),
                        Data: PVOID,
                        DataSize: ULONG,
                        ResultDataSize: P(ULONG)
                        ):
    raise NotImplementedError()

@syscall
def ZwQueryMultipleValueKey(dp: Dumpulator,
                            KeyHandle: HANDLE,
                            ValueEntries: P(KEY_VALUE_ENTRY),
                            EntryCount: ULONG,
                            ValueBuffer: PVOID,
                            BufferLength: P(ULONG),
                            RequiredBufferLength: P(ULONG)
                            ):
    raise NotImplementedError()

@syscall
def ZwQueryMutant(dp: Dumpulator,
                  MutantHandle: HANDLE,
                  MutantInformationClass: MUTANT_INFORMATION_CLASS,
                  MutantInformation: PVOID,
                  MutantInformationLength: ULONG,
                  ReturnLength: P(ULONG)
                  ):
    raise NotImplementedError()

@syscall
def ZwQueryObject(dp: Dumpulator,
                  Handle: HANDLE,
                  ObjectInformationClass: OBJECT_INFORMATION_CLASS,
                  ObjectInformation: PVOID,
                  ObjectInformationLength: ULONG,
                  ReturnLength: P(ULONG)
                  ):
    raise NotImplementedError()

@syscall
def ZwQueryOpenSubKeys(dp: Dumpulator,
                       TargetKey: P(OBJECT_ATTRIBUTES),
                       HandleCount: P(ULONG)
                       ):
    raise NotImplementedError()

@syscall
def ZwQueryOpenSubKeysEx(dp: Dumpulator,
                         TargetKey: P(OBJECT_ATTRIBUTES),
                         BufferLength: ULONG,
                         Buffer: PVOID,
                         RequiredSize: P(ULONG)
                         ):
    raise NotImplementedError()

@syscall
def ZwQueryPerformanceCounter(dp: Dumpulator,
                              PerformanceCounter: P(LARGE_INTEGER),
                              PerformanceFrequency: P(LARGE_INTEGER)
                              ):
    raise NotImplementedError()

@syscall
def ZwQueryPortInformationProcess(dp: Dumpulator
                                  ):
    raise NotImplementedError()

@syscall
def ZwQueryQuotaInformationFile(dp: Dumpulator,
                                FileHandle: HANDLE,
                                IoStatusBlock: P(IO_STATUS_BLOCK),
                                Buffer: PVOID,
                                Length: ULONG,
                                ReturnSingleEntry: BOOLEAN,
                                SidList: PVOID,
                                SidListLength: ULONG,
                                StartSid: PSID,
                                RestartScan: BOOLEAN
                                ):
    raise NotImplementedError()

@syscall
def ZwQuerySection(dp: Dumpulator,
                   SectionHandle: HANDLE,
                   SectionInformationClass: SECTION_INFORMATION_CLASS,
                   SectionInformation: PVOID,
                   SectionInformationLength: SIZE_T,
                   ReturnLength: P(SIZE_T)
                   ):
    raise NotImplementedError()

@syscall
def ZwQuerySecurityAttributesToken(dp: Dumpulator,
                                   TokenHandle: HANDLE,
                                   Attributes: P(UNICODE_STRING),
                                   NumberOfAttributes: ULONG,
                                   Buffer: PVOID,
                                   Length: ULONG,
                                   ReturnLength: P(ULONG)
                                   ):
    raise NotImplementedError()

@syscall
def ZwQuerySecurityObject(dp: Dumpulator,
                          Handle: HANDLE,
                          SecurityInformation: SECURITY_INFORMATION,
                          SecurityDescriptor: P(SECURITY_DESCRIPTOR),
                          Length: ULONG,
                          LengthNeeded: P(ULONG)
                          ):
    raise NotImplementedError()

@syscall
def ZwQuerySemaphore(dp: Dumpulator,
                     SemaphoreHandle: HANDLE,
                     SemaphoreInformationClass: SEMAPHORE_INFORMATION_CLASS,
                     SemaphoreInformation: PVOID,
                     SemaphoreInformationLength: ULONG,
                     ReturnLength: P(ULONG)
                     ):
    raise NotImplementedError()

@syscall
def ZwQuerySymbolicLinkObject(dp: Dumpulator,
                              LinkHandle: HANDLE,
                              LinkTarget: P(UNICODE_STRING),
                              ReturnedLength: P(ULONG)
                              ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemEnvironmentValue(dp: Dumpulator,
                                  VariableName: P(UNICODE_STRING),
                                  VariableValue: PWSTR,
                                  ValueLength: USHORT,
                                  ReturnLength: P(USHORT)
                                  ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemEnvironmentValueEx(dp: Dumpulator,
                                    VariableName: P(UNICODE_STRING),
                                    VendorGuid: P(GUID),
                                    Value: PVOID,
                                    ValueLength: P(ULONG),
                                    Attributes: P(ULONG)
                                    ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemInformation(dp: Dumpulator,
                             SystemInformationClass: SYSTEM_INFORMATION_CLASS,
                             SystemInformation: PVOID,
                             SystemInformationLength: ULONG,
                             ReturnLength: P(ULONG)
                             ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemInformationEx(dp: Dumpulator,
                               SystemInformationClass: SYSTEM_INFORMATION_CLASS,
                               InputBuffer: PVOID,
                               InputBufferLength: ULONG,
                               SystemInformation: PVOID,
                               SystemInformationLength: ULONG,
                               ReturnLength: P(ULONG)
                               ):
    raise NotImplementedError()

@syscall
def ZwQuerySystemTime(dp: Dumpulator,
                      SystemTime: P(LARGE_INTEGER)
                      ):
    raise NotImplementedError()

@syscall
def ZwQueryTimer(dp: Dumpulator,
                 TimerHandle: HANDLE,
                 TimerInformationClass: TIMER_INFORMATION_CLASS,
                 TimerInformation: PVOID,
                 TimerInformationLength: ULONG,
                 ReturnLength: P(ULONG)
                 ):
    raise NotImplementedError()

@syscall
def ZwQueryTimerResolution(dp: Dumpulator,
                           MaximumTime: P(ULONG),
                           MinimumTime: P(ULONG),
                           CurrentTime: P(ULONG)
                           ):
    raise NotImplementedError()

@syscall
def ZwQueryValueKey(dp: Dumpulator,
                    KeyHandle: HANDLE,
                    ValueName: P(UNICODE_STRING),
                    KeyValueInformationClass: KEY_VALUE_INFORMATION_CLASS,
                    KeyValueInformation: PVOID,
                    Length: ULONG,
                    ResultLength: P(ULONG)
                    ):
    raise NotImplementedError()

@syscall
def ZwQueryVirtualMemory(dp: Dumpulator,
                         ProcessHandle: HANDLE,
                         BaseAddress: PVOID,
                         MemoryInformationClass: MEMORY_INFORMATION_CLASS,
                         MemoryInformation: PVOID,
                         MemoryInformationLength: SIZE_T,
                         ReturnLength: P(SIZE_T)
                         ):
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwQueryVolumeInformationFile(dp: Dumpulator,
                                 FileHandle: HANDLE,
                                 IoStatusBlock: P(IO_STATUS_BLOCK),
                                 FsInformation: PVOID,
                                 Length: ULONG,
                                 FsInformationClass: FSINFOCLASS
                                 ):
    raise NotImplementedError()

@syscall
def ZwQueryWnfStateData(dp: Dumpulator,
                        StateName: P(CWNF_STATE_NAME),
                        TypeId: P(CWNF_TYPE_ID),
                        ExplicitScope: PVOID,
                        ChangeStamp: P(WNF_CHANGE_STAMP),
                        Buffer: PVOID,
                        BufferSize: P(ULONG)
                        ):
    raise NotImplementedError()

@syscall
def ZwQueryWnfStateNameInformation(dp: Dumpulator,
                                   StateName: P(CWNF_STATE_NAME),
                                   NameInfoClass: WNF_STATE_NAME_INFORMATION,
                                   ExplicitScope: PVOID,
                                   InfoBuffer: PVOID,
                                   InfoBufferSize: ULONG
                                   ):
    raise NotImplementedError()

@syscall
def ZwQueueApcThread(dp: Dumpulator,
                     ThreadHandle: HANDLE,
                     ApcRoutine: P(PS_APC_ROUTINE),
                     ApcArgument1: PVOID,
                     ApcArgument2: PVOID,
                     ApcArgument3: PVOID
                     ):
    raise NotImplementedError()

@syscall
def ZwQueueApcThreadEx(dp: Dumpulator,
                       ThreadHandle: HANDLE,
                       ReserveHandle: HANDLE,
                       ApcRoutine: P(PS_APC_ROUTINE),
                       ApcArgument1: PVOID,
                       ApcArgument2: PVOID,
                       ApcArgument3: PVOID
                       ):
    raise NotImplementedError()

@syscall
def ZwRaiseException(dp: Dumpulator,
                     ExceptionRecord: P(EXCEPTION_RECORD),
                     ContextRecord: P(CONTEXT),
                     FirstChance: BOOLEAN
                     ):
    raise NotImplementedError()

@syscall
def ZwRaiseHardError(dp: Dumpulator,
                     ErrorStatus: NTSTATUS,
                     NumberOfParameters: ULONG,
                     UnicodeStringParameterMask: ULONG,
                     Parameters: P(ULONG_PTR),
                     ValidResponseOptions: ULONG,
                     Response: P(ULONG)
                     ):
    raise NotImplementedError()

@syscall
def ZwReadFile(dp: Dumpulator,
               FileHandle: HANDLE,
               Event: HANDLE,
               ApcRoutine: P(IO_APC_ROUTINE),
               ApcContext: PVOID,
               IoStatusBlock: P(IO_STATUS_BLOCK),
               Buffer: PVOID,
               Length: ULONG,
               ByteOffset: P(LARGE_INTEGER),
               Key: P(ULONG)
               ):
    if FileHandle == dp.stdin_handle:
        result = b"some console input"

        assert Buffer != 0
        assert len(result) <= Length

        Buffer.write(result)

        # https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_status_block
        dp.write_ptr(IoStatusBlock.ptr, STATUS_SUCCESS)
        dp.write_ptr(IoStatusBlock.ptr + dp.ptr_size(), len(result))

        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwReadFileScatter(dp: Dumpulator,
                      FileHandle: HANDLE,
                      Event: HANDLE,
                      ApcRoutine: P(IO_APC_ROUTINE),
                      ApcContext: PVOID,
                      IoStatusBlock: P(IO_STATUS_BLOCK),
                      SegmentArray: P(FILE_SEGMENT_ELEMENT),
                      Length: ULONG,
                      ByteOffset: P(LARGE_INTEGER),
                      Key: P(ULONG)
                      ):
    raise NotImplementedError()

@syscall
def ZwReadOnlyEnlistment(dp: Dumpulator,
                         EnlistmentHandle: HANDLE,
                         TmVirtualClock: P(LARGE_INTEGER)
                         ):
    raise NotImplementedError()

@syscall
def ZwReadRequestData(dp: Dumpulator,
                      PortHandle: HANDLE,
                      Message: P(PORT_MESSAGE),
                      DataEntryIndex: ULONG,
                      Buffer: PVOID,
                      BufferSize: SIZE_T,
                      NumberOfBytesRead: P(SIZE_T)
                      ):
    raise NotImplementedError()

@syscall
def ZwReadVirtualMemory(dp: Dumpulator,
                        ProcessHandle: HANDLE,
                        BaseAddress: PVOID,
                        Buffer: PVOID,
                        BufferSize: SIZE_T,
                        NumberOfBytesRead: P(SIZE_T)
                        ):
    raise NotImplementedError()

@syscall
def ZwRecoverEnlistment(dp: Dumpulator,
                        EnlistmentHandle: HANDLE,
                        EnlistmentKey: PVOID
                        ):
    raise NotImplementedError()

@syscall
def ZwRecoverResourceManager(dp: Dumpulator,
                             ResourceManagerHandle: HANDLE
                             ):
    raise NotImplementedError()

@syscall
def ZwRecoverTransactionManager(dp: Dumpulator,
                                TransactionManagerHandle: HANDLE
                                ):
    raise NotImplementedError()

@syscall
def ZwRegisterProtocolAddressInformation(dp: Dumpulator,
                                         ResourceManager: HANDLE,
                                         ProtocolId: P(CRM_PROTOCOL_ID),
                                         ProtocolInformationSize: ULONG,
                                         ProtocolInformation: PVOID,
                                         CreateOptions: ULONG
                                         ):
    raise NotImplementedError()

@syscall
def ZwRegisterThreadTerminatePort(dp: Dumpulator,
                                  PortHandle: HANDLE
                                  ):
    raise NotImplementedError()

@syscall
def ZwReleaseCMFViewOwnership(dp: Dumpulator
                              ):
    raise NotImplementedError()

@syscall
def ZwReleaseKeyedEvent(dp: Dumpulator,
                        KeyedEventHandle: HANDLE,
                        KeyValue: PVOID,
                        Alertable: BOOLEAN,
                        Timeout: P(LARGE_INTEGER)
                        ):
    raise NotImplementedError()

@syscall
def ZwReleaseMutant(dp: Dumpulator,
                    MutantHandle: HANDLE,
                    PreviousCount: P(LONG)
                    ):
    raise NotImplementedError()

@syscall
def ZwReleaseSemaphore(dp: Dumpulator,
                       SemaphoreHandle: HANDLE,
                       ReleaseCount: LONG,
                       PreviousCount: P(LONG)
                       ):
    raise NotImplementedError()

@syscall
def ZwReleaseWorkerFactoryWorker(dp: Dumpulator,
                                 WorkerFactoryHandle: HANDLE
                                 ):
    raise NotImplementedError()

@syscall
def ZwRemoveIoCompletion(dp: Dumpulator,
                         IoCompletionHandle: HANDLE,
                         KeyContext: P(PVOID),
                         ApcContext: P(PVOID),
                         IoStatusBlock: P(IO_STATUS_BLOCK),
                         Timeout: P(LARGE_INTEGER)
                         ):
    raise NotImplementedError()

@syscall
def ZwRemoveIoCompletionEx(dp: Dumpulator,
                           IoCompletionHandle: HANDLE,
                           IoCompletionInformation: P(FILE_IO_COMPLETION_INFORMATION),
                           Count: ULONG,
                           NumEntriesRemoved: P(ULONG),
                           Timeout: P(LARGE_INTEGER),
                           Alertable: BOOLEAN
                           ):
    raise NotImplementedError()

@syscall
def ZwRemoveProcessDebug(dp: Dumpulator,
                         ProcessHandle: HANDLE,
                         DebugObjectHandle: HANDLE
                         ):
    raise NotImplementedError()

@syscall
def ZwRenameKey(dp: Dumpulator,
                KeyHandle: HANDLE,
                NewName: P(UNICODE_STRING)
                ):
    raise NotImplementedError()

@syscall
def ZwRenameTransactionManager(dp: Dumpulator,
                               LogFileName: P(UNICODE_STRING),
                               ExistingTransactionManagerGuid: P(GUID)
                               ):
    raise NotImplementedError()

@syscall
def ZwReplaceKey(dp: Dumpulator,
                 NewFile: P(OBJECT_ATTRIBUTES),
                 TargetHandle: HANDLE,
                 OldFile: P(OBJECT_ATTRIBUTES)
                 ):
    raise NotImplementedError()

@syscall
def ZwReplacePartitionUnit(dp: Dumpulator,
                           TargetInstancePath: P(UNICODE_STRING),
                           SpareInstancePath: P(UNICODE_STRING),
                           Flags: ULONG
                           ):
    raise NotImplementedError()

@syscall
def ZwReplyPort(dp: Dumpulator,
                PortHandle: HANDLE,
                ReplyMessage: P(PORT_MESSAGE)
                ):
    raise NotImplementedError()

@syscall
def ZwReplyWaitReceivePort(dp: Dumpulator,
                           PortHandle: HANDLE,
                           PortContext: P(PVOID),
                           ReplyMessage: P(PORT_MESSAGE),
                           ReceiveMessage: P(PORT_MESSAGE)
                           ):
    raise NotImplementedError()

@syscall
def ZwReplyWaitReceivePortEx(dp: Dumpulator,
                             PortHandle: HANDLE,
                             PortContext: P(PVOID),
                             ReplyMessage: P(PORT_MESSAGE),
                             ReceiveMessage: P(PORT_MESSAGE),
                             Timeout: P(LARGE_INTEGER)
                             ):
    raise NotImplementedError()

@syscall
def ZwReplyWaitReplyPort(dp: Dumpulator,
                         PortHandle: HANDLE,
                         ReplyMessage: P(PORT_MESSAGE)
                         ):
    raise NotImplementedError()

@syscall
def ZwRequestPort(dp: Dumpulator,
                  PortHandle: HANDLE,
                  RequestMessage: P(PORT_MESSAGE)
                  ):
    raise NotImplementedError()

@syscall
def ZwRequestWaitReplyPort(dp: Dumpulator,
                           PortHandle: HANDLE,
                           RequestMessage: P(PORT_MESSAGE),
                           ReplyMessage: P(PORT_MESSAGE)
                           ):
    raise NotImplementedError()

@syscall
def ZwRequestWakeupLatency(dp: Dumpulator,
                           latency: LATENCY_TIME
                           ):
    raise NotImplementedError()

@syscall
def ZwResetEvent(dp: Dumpulator,
                 EventHandle: HANDLE,
                 PreviousState: P(LONG)
                 ):
    raise NotImplementedError()

@syscall
def ZwResetWriteWatch(dp: Dumpulator,
                      ProcessHandle: HANDLE,
                      BaseAddress: PVOID,
                      RegionSize: SIZE_T
                      ):
    raise NotImplementedError()

@syscall
def ZwRestoreKey(dp: Dumpulator,
                 KeyHandle: HANDLE,
                 FileHandle: HANDLE,
                 Flags: ULONG
                 ):
    raise NotImplementedError()

@syscall
def ZwResumeProcess(dp: Dumpulator,
                    ProcessHandle: HANDLE
                    ):
    raise NotImplementedError()

@syscall
def ZwResumeThread(dp: Dumpulator,
                   ThreadHandle: HANDLE,
                   PreviousSuspendCount: P(ULONG)
                   ):
    raise NotImplementedError()

@syscall
def ZwRevertContainerImpersonation(dp: Dumpulator
                                   ):
    raise NotImplementedError()

@syscall
def ZwRollbackComplete(dp: Dumpulator,
                       EnlistmentHandle: HANDLE,
                       TmVirtualClock: P(LARGE_INTEGER)
                       ):
    raise NotImplementedError()

@syscall
def ZwRollbackEnlistment(dp: Dumpulator,
                         EnlistmentHandle: HANDLE,
                         TmVirtualClock: P(LARGE_INTEGER)
                         ):
    raise NotImplementedError()

@syscall
def ZwRollbackTransaction(dp: Dumpulator,
                          TransactionHandle: HANDLE,
                          Wait: BOOLEAN
                          ):
    raise NotImplementedError()

@syscall
def ZwRollforwardTransactionManager(dp: Dumpulator,
                                    TransactionManagerHandle: HANDLE,
                                    TmVirtualClock: P(LARGE_INTEGER)
                                    ):
    raise NotImplementedError()

@syscall
def ZwSaveKey(dp: Dumpulator,
              KeyHandle: HANDLE,
              FileHandle: HANDLE
              ):
    raise NotImplementedError()

@syscall
def ZwSaveKeyEx(dp: Dumpulator,
                KeyHandle: HANDLE,
                FileHandle: HANDLE,
                Format: ULONG
                ):
    raise NotImplementedError()

@syscall
def ZwSaveMergedKeys(dp: Dumpulator,
                     HighPrecedenceKeyHandle: HANDLE,
                     LowPrecedenceKeyHandle: HANDLE,
                     FileHandle: HANDLE
                     ):
    raise NotImplementedError()

@syscall
def ZwSecureConnectPort(dp: Dumpulator,
                        PortHandle: P(HANDLE),
                        PortName: P(UNICODE_STRING),
                        SecurityQos: P(SECURITY_QUALITY_OF_SERVICE),
                        ClientView: P(PORT_VIEW),
                        RequiredServerSid: PSID,
                        ServerView: P(REMOTE_PORT_VIEW),
                        MaxMessageLength: P(ULONG),
                        ConnectionInformation: PVOID,
                        ConnectionInformationLength: P(ULONG)
                        ):
    raise NotImplementedError()

@syscall
def ZwSerializeBoot(dp: Dumpulator
                    ):
    raise NotImplementedError()

@syscall
def ZwSetBootEntryOrder(dp: Dumpulator,
                        Ids: P(ULONG),
                        Count: ULONG
                        ):
    raise NotImplementedError()

@syscall
def ZwSetBootOptions(dp: Dumpulator,
                     BootOptions: P(BOOT_OPTIONS),
                     FieldsToChange: ULONG
                     ):
    raise NotImplementedError()

@syscall
def ZwSetCachedSigningLevel(dp: Dumpulator,
                            Flags: ULONG,
                            InputSigningLevel: SE_SIGNING_LEVEL,
                            SourceFiles: P(HANDLE),
                            SourceFileCount: ULONG,
                            TargetFile: HANDLE
                            ):
    raise NotImplementedError()

@syscall
def ZwSetContextThread(dp: Dumpulator,
                       ThreadHandle: HANDLE,
                       ThreadContext: P(CONTEXT)
                       ):
    raise NotImplementedError()

@syscall
def ZwSetDebugFilterState(dp: Dumpulator,
                          ComponentId: ULONG,
                          Level: ULONG,
                          State: BOOLEAN
                          ):
    raise NotImplementedError()

@syscall
def ZwSetDefaultHardErrorPort(dp: Dumpulator,
                              DefaultHardErrorPort: HANDLE
                              ):
    raise NotImplementedError()

@syscall
def ZwSetDefaultLocale(dp: Dumpulator,
                       UserProfile: BOOLEAN,
                       DefaultLocaleId: LCID
                       ):
    raise NotImplementedError()

@syscall
def ZwSetDefaultUILanguage(dp: Dumpulator,
                           DefaultUILanguageId: LANGID
                           ):
    raise NotImplementedError()

@syscall
def ZwSetDriverEntryOrder(dp: Dumpulator,
                          Ids: P(ULONG),
                          Count: ULONG
                          ):
    raise NotImplementedError()

@syscall
def ZwSetEaFile(dp: Dumpulator,
                FileHandle: HANDLE,
                IoStatusBlock: P(IO_STATUS_BLOCK),
                Buffer: PVOID,
                Length: ULONG
                ):
    raise NotImplementedError()

@syscall
def ZwSetEvent(dp: Dumpulator,
               EventHandle: HANDLE,
               PreviousState: P(LONG)
               ):
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwSetEventBoostPriority(dp: Dumpulator,
                            EventHandle: HANDLE
                            ):
    raise NotImplementedError()

@syscall
def ZwSetHighEventPair(dp: Dumpulator,
                       EventPairHandle: HANDLE
                       ):
    raise NotImplementedError()

@syscall
def ZwSetHighWaitLowEventPair(dp: Dumpulator,
                              EventPairHandle: HANDLE
                              ):
    raise NotImplementedError()

@syscall
def ZwSetInformationDebugObject(dp: Dumpulator,
                                DebugObjectHandle: HANDLE,
                                DebugObjectInformationClass: DEBUGOBJECTINFOCLASS,
                                DebugInformation: PVOID,
                                DebugInformationLength: ULONG,
                                ReturnLength: P(ULONG)
                                ):
    raise NotImplementedError()

@syscall
def ZwSetInformationEnlistment(dp: Dumpulator,
                               EnlistmentHandle: HANDLE,
                               EnlistmentInformationClass: ENLISTMENT_INFORMATION_CLASS,
                               EnlistmentInformation: PVOID,
                               EnlistmentInformationLength: ULONG
                               ):
    raise NotImplementedError()

@syscall
def ZwSetInformationFile(dp: Dumpulator,
                         FileHandle: HANDLE,
                         IoStatusBlock: P(IO_STATUS_BLOCK),
                         FileInformation: PVOID,
                         Length: ULONG,
                         FileInformationClass: FILE_INFORMATION_CLASS
                         ):
    raise NotImplementedError()

@syscall
def ZwSetInformationJobObject(dp: Dumpulator,
                              JobHandle: HANDLE,
                              JobObjectInformationClass: JOBOBJECTINFOCLASS,
                              JobObjectInformation: PVOID,
                              JobObjectInformationLength: ULONG
                              ):
    raise NotImplementedError()

@syscall
def ZwSetInformationKey(dp: Dumpulator,
                        KeyHandle: HANDLE,
                        KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
                        KeySetInformation: PVOID,
                        KeySetInformationLength: ULONG
                        ):
    raise NotImplementedError()

@syscall
def ZwSetInformationObject(dp: Dumpulator,
                           Handle: HANDLE,
                           ObjectInformationClass: OBJECT_INFORMATION_CLASS,
                           ObjectInformation: PVOID,
                           ObjectInformationLength: ULONG
                           ):
    raise NotImplementedError()

@syscall
def ZwSetInformationProcess(dp: Dumpulator,
                            ProcessHandle: HANDLE,
                            ProcessInformationClass: PROCESSINFOCLASS,
                            ProcessInformation: PVOID,
                            ProcessInformationLength: ULONG
                            ):
    raise NotImplementedError()

@syscall
def ZwSetInformationResourceManager(dp: Dumpulator,
                                    ResourceManagerHandle: HANDLE,
                                    ResourceManagerInformationClass: RESOURCEMANAGER_INFORMATION_CLASS,
                                    ResourceManagerInformation: PVOID,
                                    ResourceManagerInformationLength: ULONG
                                    ):
    raise NotImplementedError()

@syscall
def ZwSetInformationSymbolicLink(dp: Dumpulator,
                                 LinkHandle: HANDLE,
                                 SymbolicLinkInformationClass: SYMBOLIC_LINK_INFO_CLASS,
                                 SymbolicLinkInformation: PVOID,
                                 SymbolicLinkInformationLength: ULONG
                                 ):
    raise NotImplementedError()

@syscall
def ZwSetInformationThread(dp: Dumpulator,
                           ThreadHandle: HANDLE,
                           ThreadInformationClass: THREADINFOCLASS,
                           ThreadInformation: PVOID,
                           ThreadInformationLength: ULONG
                           ):
    if ThreadInformationClass == THREADINFOCLASS.ThreadHideFromDebugger:
        assert ThreadInformation == 0
        assert ThreadInformationLength == 0
        assert ThreadHandle == dp.NtCurrentThread()
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwSetInformationToken(dp: Dumpulator,
                          TokenHandle: HANDLE,
                          TokenInformationClass: TOKEN_INFORMATION_CLASS,
                          TokenInformation: PVOID,
                          TokenInformationLength: ULONG
                          ):
    raise NotImplementedError()

@syscall
def ZwSetInformationTransaction(dp: Dumpulator,
                                TransactionHandle: HANDLE,
                                TransactionInformationClass: TRANSACTION_INFORMATION_CLASS,
                                TransactionInformation: PVOID,
                                TransactionInformationLength: ULONG
                                ):
    raise NotImplementedError()

@syscall
def ZwSetInformationTransactionManager(dp: Dumpulator,
                                       TmHandle: HANDLE,
                                       TransactionManagerInformationClass: TRANSACTIONMANAGER_INFORMATION_CLASS,
                                       TransactionManagerInformation: PVOID,
                                       TransactionManagerInformationLength: ULONG
                                       ):
    raise NotImplementedError()

@syscall
def ZwSetInformationVirtualMemory(dp: Dumpulator,
                                  ProcessHandle: HANDLE,
                                  VmInformationClass: VIRTUAL_MEMORY_INFORMATION_CLASS,
                                  NumberOfEntries: ULONG_PTR,
                                  VirtualAddresses: P(MEMORY_RANGE_ENTRY),
                                  VmInformation: PVOID,
                                  VmInformationLength: ULONG
                                  ):
    raise NotImplementedError()

@syscall
def ZwSetInformationWorkerFactory(dp: Dumpulator,
                                  WorkerFactoryHandle: HANDLE,
                                  WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
                                  WorkerFactoryInformation: PVOID,
                                  WorkerFactoryInformationLength: ULONG
                                  ):
    raise NotImplementedError()

@syscall
def ZwSetIntervalProfile(dp: Dumpulator,
                         Interval: ULONG,
                         Source: KPROFILE_SOURCE
                         ):
    raise NotImplementedError()

@syscall
def ZwSetIoCompletion(dp: Dumpulator,
                      IoCompletionHandle: HANDLE,
                      KeyContext: PVOID,
                      ApcContext: PVOID,
                      IoStatus: NTSTATUS,
                      IoStatusInformation: ULONG_PTR
                      ):
    raise NotImplementedError()

@syscall
def ZwSetIoCompletionEx(dp: Dumpulator,
                        IoCompletionHandle: HANDLE,
                        IoCompletionPacketHandle: HANDLE,
                        KeyContext: PVOID,
                        ApcContext: PVOID,
                        IoStatus: NTSTATUS,
                        IoStatusInformation: ULONG_PTR
                        ):
    raise NotImplementedError()

@syscall
def ZwSetIRTimer(dp: Dumpulator,
                 TimerHandle: HANDLE,
                 DueTime: P(LARGE_INTEGER)
                 ):
    raise NotImplementedError()

@syscall
def ZwSetLdtEntries(dp: Dumpulator,
                    Selector0: ULONG,
                    Entry0Low: ULONG,
                    Entry0Hi: ULONG,
                    Selector1: ULONG,
                    Entry1Low: ULONG,
                    Entry1Hi: ULONG
                    ):
    raise NotImplementedError()

@syscall
def ZwSetLowEventPair(dp: Dumpulator,
                      EventPairHandle: HANDLE
                      ):
    raise NotImplementedError()

@syscall
def ZwSetLowWaitHighEventPair(dp: Dumpulator,
                              EventPairHandle: HANDLE
                              ):
    raise NotImplementedError()

@syscall
def ZwSetQuotaInformationFile(dp: Dumpulator,
                              FileHandle: HANDLE,
                              IoStatusBlock: P(IO_STATUS_BLOCK),
                              Buffer: PVOID,
                              Length: ULONG
                              ):
    raise NotImplementedError()

@syscall
def ZwSetSecurityObject(dp: Dumpulator,
                        Handle: HANDLE,
                        SecurityInformation: SECURITY_INFORMATION,
                        SecurityDescriptor: P(SECURITY_DESCRIPTOR)
                        ):
    raise NotImplementedError()

@syscall
def ZwSetSystemEnvironmentValue(dp: Dumpulator,
                                VariableName: P(UNICODE_STRING),
                                VariableValue: P(UNICODE_STRING)
                                ):
    raise NotImplementedError()

@syscall
def ZwSetSystemEnvironmentValueEx(dp: Dumpulator,
                                  VariableName: P(UNICODE_STRING),
                                  VendorGuid: P(GUID),
                                  Value: PVOID,
                                  ValueLength: ULONG,
                                  Attributes: ULONG
                                  ):
    raise NotImplementedError()

@syscall
def ZwSetSystemInformation(dp: Dumpulator,
                           SystemInformationClass: SYSTEM_INFORMATION_CLASS,
                           SystemInformation: PVOID,
                           SystemInformationLength: ULONG
                           ):
    raise NotImplementedError()

@syscall
def ZwSetSystemPowerState(dp: Dumpulator,
                          SystemAction: P(OWER_ACTION),
                          LightestSystemState: SYSTEM_POWER_STATE,
                          Flags: ULONG
                          ):
    raise NotImplementedError()

@syscall
def ZwSetSystemTime(dp: Dumpulator,
                    SystemTime: P(LARGE_INTEGER),
                    PreviousTime: P(LARGE_INTEGER)
                    ):
    raise NotImplementedError()

@syscall
def ZwSetThreadExecutionState(dp: Dumpulator,
                              NewFlags: EXECUTION_STATE,
                              PreviousFlags: P(EXECUTION_STATE)
                              ):
    raise NotImplementedError()

@syscall
def ZwSetTimer(dp: Dumpulator,
               TimerHandle: HANDLE,
               DueTime: P(LARGE_INTEGER),
               TimerApcRoutine: P(TIMER_APC_ROUTINE),
               TimerContext: PVOID,
               ResumeTimer: BOOLEAN,
               Period: LONG,
               PreviousState: P(BOOLEAN)
               ):
    raise NotImplementedError()

@syscall
def ZwSetTimer2(dp: Dumpulator,
                TimerHandle: HANDLE,
                DueTime: P(LARGE_INTEGER),
                Period: P(LARGE_INTEGER),
                Parameters: P(T2_SET_PARAMETERS)
                ):
    raise NotImplementedError()

@syscall
def ZwSetTimerEx(dp: Dumpulator,
                 TimerHandle: HANDLE,
                 TimerSetInformationClass: TIMER_SET_INFORMATION_CLASS,
                 TimerSetInformation: PVOID,
                 TimerSetInformationLength: ULONG
                 ):
    raise NotImplementedError()

@syscall
def ZwSetTimerResolution(dp: Dumpulator,
                         DesiredTime: ULONG,
                         SetResolution: BOOLEAN,
                         ActualTime: P(ULONG)
                         ):
    raise NotImplementedError()

@syscall
def ZwSetUuidSeed(dp: Dumpulator,
                  Seed: P(CHAR)
                  ):
    raise NotImplementedError()

@syscall
def ZwSetValueKey(dp: Dumpulator,
                  KeyHandle: HANDLE,
                  ValueName: P(UNICODE_STRING),
                  TitleIndex: ULONG,
                  Type: ULONG,
                  Data: PVOID,
                  DataSize: ULONG
                  ):
    raise NotImplementedError()

@syscall
def ZwSetVolumeInformationFile(dp: Dumpulator,
                               FileHandle: HANDLE,
                               IoStatusBlock: P(IO_STATUS_BLOCK),
                               FsInformation: PVOID,
                               Length: ULONG,
                               FsInformationClass: FSINFOCLASS
                               ):
    raise NotImplementedError()

@syscall
def ZwSetWnfProcessNotificationEvent(dp: Dumpulator,
                                     NotificationEvent: HANDLE
                                     ):
    raise NotImplementedError()

@syscall
def ZwShutdownSystem(dp: Dumpulator,
                     Action: SHUTDOWN_ACTION
                     ):
    raise NotImplementedError()

@syscall
def ZwShutdownWorkerFactory(dp: Dumpulator,
                            WorkerFactoryHandle: HANDLE,
                            PendingWorkerCount: P(LONG)
                            ):
    raise NotImplementedError()

@syscall
def ZwSignalAndWaitForSingleObject(dp: Dumpulator,
                                   SignalHandle: HANDLE,
                                   WaitHandle: HANDLE,
                                   Alertable: BOOLEAN,
                                   Timeout: P(LARGE_INTEGER)
                                   ):
    raise NotImplementedError()

@syscall
def ZwSinglePhaseReject(dp: Dumpulator,
                        EnlistmentHandle: HANDLE,
                        TmVirtualClock: P(LARGE_INTEGER)
                        ):
    raise NotImplementedError()

@syscall
def ZwStartProfile(dp: Dumpulator,
                   ProfileHandle: HANDLE
                   ):
    raise NotImplementedError()

@syscall
def ZwStopProfile(dp: Dumpulator,
                  ProfileHandle: HANDLE
                  ):
    raise NotImplementedError()

@syscall
def ZwSubscribeWnfStateChange(dp: Dumpulator,
                              StateName: P(CWNF_STATE_NAME),
                              ChangeStamp: WNF_CHANGE_STAMP,
                              EventMask: ULONG,
                              SubscriptionId: P(ULONG64)
                              ):
    raise NotImplementedError()

@syscall
def ZwSuspendProcess(dp: Dumpulator,
                     ProcessHandle: HANDLE
                     ):
    raise NotImplementedError()

@syscall
def ZwSuspendThread(dp: Dumpulator,
                    ThreadHandle: HANDLE,
                    PreviousSuspendCount: P(ULONG)
                    ):
    raise NotImplementedError()

@syscall
def ZwSystemDebugControl(dp: Dumpulator,
                         Command: SYSDBG_COMMAND,
                         InputBuffer: PVOID,
                         InputBufferLength: ULONG,
                         OutputBuffer: PVOID,
                         OutputBufferLength: ULONG,
                         ReturnLength: P(ULONG)
                         ):
    raise NotImplementedError()

@syscall
def ZwTerminateEnclave(dp: Dumpulator,
                       BaseAddress: PVOID,
                       WaitForThread: BOOLEAN
                       ):
    raise NotImplementedError()

@syscall
def ZwTerminateJobObject(dp: Dumpulator,
                         JobHandle: HANDLE,
                         ExitStatus: NTSTATUS
                         ):
    raise NotImplementedError()

@syscall
def ZwTerminateProcess(dp: Dumpulator,
                       ProcessHandle: HANDLE,
                       ExitStatus: NTSTATUS
                       ):
    assert ProcessHandle == 0 or ProcessHandle == dp.NtCurrentProcess()
    dp.stop(ExitStatus)
    return STATUS_SUCCESS

@syscall
def ZwTerminateThread(dp: Dumpulator,
                      ThreadHandle: HANDLE,
                      ExitStatus: NTSTATUS
                      ):
    assert ThreadHandle == dp.NtCurrentThread()
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwTestAlert(dp: Dumpulator
                ):
    raise NotImplementedError()

@syscall
def ZwThawRegistry(dp: Dumpulator
                   ):
    raise NotImplementedError()

@syscall
def ZwThawTransactions(dp: Dumpulator
                       ):
    raise NotImplementedError()

@syscall
def ZwTraceControl(dp: Dumpulator,
                   TraceInformationClass: TRACE_CONTROL_INFORMATION_CLASS,
                   InputBuffer: PVOID,
                   InputBufferLength: ULONG,
                   TraceInformation: PVOID,
                   TraceInformationLength: ULONG,
                   ReturnLength: P(ULONG)
                   ):
    raise NotImplementedError()

@syscall
def ZwTraceEvent(dp: Dumpulator,
                 TraceHandle: HANDLE,
                 Flags: ULONG,
                 FieldSize: ULONG,
                 Fields: PVOID
                 ):
    raise NotImplementedError()

@syscall
def ZwTranslateFilePath(dp: Dumpulator,
                        InputFilePath: P(FILE_PATH),
                        OutputType: ULONG,
                        OutputFilePath: P(FILE_PATH),
                        OutputFilePathLength: P(ULONG)
                        ):
    raise NotImplementedError()

@syscall
def ZwUmsThreadYield(dp: Dumpulator,
                     SchedulerParam: PVOID
                     ):
    raise NotImplementedError()

@syscall
def ZwUnloadDriver(dp: Dumpulator,
                   DriverServiceName: P(UNICODE_STRING)
                   ):
    raise NotImplementedError()

@syscall
def ZwUnloadKey(dp: Dumpulator,
                TargetKey: P(OBJECT_ATTRIBUTES)
                ):
    raise NotImplementedError()

@syscall
def ZwUnloadKey2(dp: Dumpulator,
                 TargetKey: P(OBJECT_ATTRIBUTES),
                 Flags: ULONG
                 ):
    raise NotImplementedError()

@syscall
def ZwUnloadKeyEx(dp: Dumpulator,
                  TargetKey: P(OBJECT_ATTRIBUTES),
                  Event: HANDLE
                  ):
    raise NotImplementedError()

@syscall
def ZwUnlockFile(dp: Dumpulator,
                 FileHandle: HANDLE,
                 IoStatusBlock: P(IO_STATUS_BLOCK),
                 ByteOffset: P(LARGE_INTEGER),
                 Length: P(LARGE_INTEGER),
                 Key: ULONG
                 ):
    raise NotImplementedError()

@syscall
def ZwUnlockVirtualMemory(dp: Dumpulator,
                          ProcessHandle: HANDLE,
                          BaseAddress: P(PVOID),
                          RegionSize: P(SIZE_T),
                          MapType: ULONG
                          ):
    raise NotImplementedError()

@syscall
def ZwUnmapViewOfSection(dp: Dumpulator,
                         ProcessHandle: HANDLE,
                         BaseAddress: PVOID
                         ):
    raise NotImplementedError()

@syscall
def ZwUnmapViewOfSectionEx(dp: Dumpulator,
                           ProcessHandle: HANDLE,
                           BaseAddress: PVOID,
                           Flags: ULONG
                           ):
    raise NotImplementedError()

@syscall
def ZwUnsubscribeWnfStateChange(dp: Dumpulator,
                                StateName: P(CWNF_STATE_NAME)
                                ):
    raise NotImplementedError()

@syscall
def ZwUpdateWnfStateData(dp: Dumpulator,
                         StateName: P(CWNF_STATE_NAME),
                         Buffer: PVOID,
                         Length: ULONG,
                         TypeId: P(CWNF_TYPE_ID),
                         ExplicitScope: PVOID,
                         MatchingChangeStamp: WNF_CHANGE_STAMP,
                         CheckStamp: LOGICAL
                         ):
    raise NotImplementedError()

@syscall
def ZwVdmControl(dp: Dumpulator,
                 Service: VDMSERVICECLASS,
                 ServiceData: PVOID
                 ):
    raise NotImplementedError()

@syscall
def ZwWaitForAlertByThreadId(dp: Dumpulator,
                             Address: PVOID,
                             Timeout: P(LARGE_INTEGER)
                             ):
    raise NotImplementedError()

@syscall
def ZwWaitForDebugEvent(dp: Dumpulator,
                        DebugObjectHandle: HANDLE,
                        Alertable: BOOLEAN,
                        Timeout: P(LARGE_INTEGER),
                        WaitStateChange: P(DBGUI_WAIT_STATE_CHANGE)
                        ):
    raise NotImplementedError()

@syscall
def ZwWaitForKeyedEvent(dp: Dumpulator,
                        KeyedEventHandle: HANDLE,
                        KeyValue: PVOID,
                        Alertable: BOOLEAN,
                        Timeout: P(LARGE_INTEGER)
                        ):
    raise NotImplementedError()

@syscall
def ZwWaitForMultipleObjects(dp: Dumpulator,
                             Count: ULONG,
                             Handles: P(HANDLE),
                             WaitType: WAIT_TYPE,
                             Alertable: BOOLEAN,
                             Timeout: P(LARGE_INTEGER)
                             ):
    raise NotImplementedError()

@syscall
def ZwWaitForMultipleObjects32(dp: Dumpulator,
                               Count: ULONG,
                               Handles: P(LONG),
                               WaitType: WAIT_TYPE,
                               Alertable: BOOLEAN,
                               Timeout: P(LARGE_INTEGER)
                               ):
    raise NotImplementedError()

@syscall
def ZwWaitForSingleObject(dp: Dumpulator,
                          Handle: HANDLE,
                          Alertable: BOOLEAN,
                          Timeout: P(LARGE_INTEGER)
                          ):
    raise NotImplementedError()

@syscall
def ZwWaitForWorkViaWorkerFactory(dp: Dumpulator,
                                  WorkerFactoryHandle: HANDLE,
                                  MiniPacket: P(FILE_IO_COMPLETION_INFORMATION)
                                  ):
    raise NotImplementedError()

@syscall
def ZwWaitHighEventPair(dp: Dumpulator,
                        EventPairHandle: HANDLE
                        ):
    raise NotImplementedError()

@syscall
def ZwWaitLowEventPair(dp: Dumpulator,
                       EventPairHandle: HANDLE
                       ):
    raise NotImplementedError()

@syscall
def ZwWorkerFactoryWorkerReady(dp: Dumpulator,
                               WorkerFactoryHandle: HANDLE
                               ):
    raise NotImplementedError()

# NOTE: this is not present in phnt
@syscall
def ZwWow64IsProcessorFeaturePresent(dp: Dumpulator,
                                     ProcessorFeature: ULONG
                                     ):
    return 1

@syscall
def ZwWriteFile(dp: Dumpulator,
                FileHandle: HANDLE,
                Event: HANDLE,
                ApcRoutine: P(IO_APC_ROUTINE),
                ApcContext: PVOID,
                IoStatusBlock: P(IO_STATUS_BLOCK),
                Buffer: PVOID,
                Length: ULONG,
                ByteOffset: P(LARGE_INTEGER),
                Key: P(ULONG)
                ):
    if FileHandle in [dp.stdout_handle, dp.stdin_handle]:
        data = Buffer.read_str(Length)
        print(data)
        return STATUS_SUCCESS
    raise NotImplementedError()

@syscall
def ZwWriteFileGather(dp: Dumpulator,
                      FileHandle: HANDLE,
                      Event: HANDLE,
                      ApcRoutine: P(IO_APC_ROUTINE),
                      ApcContext: PVOID,
                      IoStatusBlock: P(IO_STATUS_BLOCK),
                      SegmentArray: P(FILE_SEGMENT_ELEMENT),
                      Length: ULONG,
                      ByteOffset: P(LARGE_INTEGER),
                      Key: P(ULONG)
                      ):
    raise NotImplementedError()

@syscall
def ZwWriteRequestData(dp: Dumpulator,
                       PortHandle: HANDLE,
                       Message: P(PORT_MESSAGE),
                       DataEntryIndex: ULONG,
                       Buffer: PVOID,
                       BufferSize: SIZE_T,
                       NumberOfBytesWritten: P(SIZE_T)
                       ):
    raise NotImplementedError()

@syscall
def ZwWriteVirtualMemory(dp: Dumpulator,
                         ProcessHandle: HANDLE,
                         BaseAddress: PVOID,
                         Buffer: PVOID,
                         BufferSize: SIZE_T,
                         NumberOfBytesWritten: P(SIZE_T)
                         ):
    raise NotImplementedError()

@syscall
def ZwYieldExecution(dp: Dumpulator
                     ):
    raise NotImplementedError()


```

`src/minidump/README.md`:

```md
Patched version, see: https://github.com/skelsec/minidump/pull/28
```

`src/minidump/__amain__.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import logging
import asyncio
from minidump.aminidumpfile import AMinidumpFile
from minidump.common_structs import hexdump
from minidump._version import __banner__

async def run():
	import argparse

	parser = argparse.ArgumentParser(description='A parser for minidumnp files')
	parser.add_argument('minidumpfile', help='path to the minidump file of lsass.exe')
	parser.add_argument('-v', '--verbose', action='count', default=0)
	parser.add_argument('--header', action='store_true', help='File header info')
	parser.add_argument('--modules', action='store_true', help='List modules')
	parser.add_argument('--threads', action='store_true', help='List threads')
	parser.add_argument('--memory', action='store_true', help='List memory')
	parser.add_argument('--sysinfo', action='store_true', help='Show sysinfo')
	parser.add_argument('--comments', action='store_true', help='Show comments')
	parser.add_argument('--exception', action='store_true', help='Show exception records')
	parser.add_argument('--handles', action='store_true', help='List handles')
	parser.add_argument('--misc', action='store_true', help='Show misc info')
	parser.add_argument('--all', action='store_true', help='Show all info')
	parser.add_argument('-r', '--read-addr', type=lambda x: int(x,0), help='Dump a memory region from the process\'s addres space')
	parser.add_argument('-s', '--read-size', type=lambda x: int(x,0), default = 0x20, help='Dump a memory region from the process\'s addres space')
	
	args = parser.parse_args()
	if args.verbose == 0:
		logging.basicConfig(level=logging.INFO)
	elif args.verbose == 1:
		logging.basicConfig(level=logging.DEBUG)
	else:
		logging.basicConfig(level=1)

	print(__banner__)
	

	mf = await AMinidumpFile.parse(args.minidumpfile)
	reader = mf.get_reader()
		
	if args.all or args.threads:
		if mf.threads is not None:
			print(str(mf.threads))
		if mf.threads_ex is not None:
			print(str(mf.threads_ex))
		if mf.thread_info is not None:
			print(str(mf.thread_info))
	if args.all or args.modules:
		if mf.modules is not None:
			print(str(mf.modules))
		if mf.unloaded_modules is not None:
			print(str(mf.unloaded_modules))
	if args.all or args.memory:
		if mf.memory_segments is not None:
			print(str(mf.memory_segments))
		if mf.memory_segments_64 is not None:
			print(str(mf.memory_segments_64))
		if mf.memory_info is not None:
			print(str(mf.memory_info))
	if args.all or args.sysinfo:
		if mf.sysinfo is not None:
			print(str(mf.sysinfo))
	if args.all or args.exception:
		if mf.exception is not None:
			print(str(mf.exception))
	if args.all or args.comments:
		if mf.comment_a is not None:
			print(str(mf.comment_a))
		if mf.comment_w is not None:
			print(str(mf.comment_w))
	if args.all or args.handles:
		if mf.handles is not None:
			print(str(mf.handles))
	if args.all or args.misc:
		if mf.misc_info is not None:
			print(str(mf.misc_info))
	if args.all or args.header:
		print(str(mf.header))
			
	if args.read_addr:
		buff_reader = reader.get_buffered_reader()
		await buff_reader.move(args.read_addr)
		data = await buff_reader.peek(args.read_size)
		print(hexdump(data, start = args.read_addr))

def main():
	asyncio.run(run())

if __name__ == '__main__':
	main()
```

`src/minidump/__init__.py`:

```py
name = "minidump"
```

`src/minidump/__main__.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import logging
from minidump.minidumpfile import MinidumpFile
from minidump.common_structs import hexdump
from minidump.minidumpshell import MinidumpShell
from minidump._version import __banner__


def run():
	import argparse

	parser = argparse.ArgumentParser(description='A parser for minidumnp files')
	parser.add_argument('minidumpfile', help='path to the minidump file of lsass.exe')
	parser.add_argument('-v', '--verbose', action='count', default=0)
	parser.add_argument('-i', '--interactive', action='store_true', help='Interactive minidump shell')
	parser.add_argument('--header', action='store_true', help='File header info')
	parser.add_argument('--modules', action='store_true', help='List modules')
	parser.add_argument('--threads', action='store_true', help='List threads')
	parser.add_argument('--memory', action='store_true', help='List memory')
	parser.add_argument('--sysinfo', action='store_true', help='Show sysinfo')
	parser.add_argument('--comments', action='store_true', help='Show comments')
	parser.add_argument('--exception', action='store_true', help='Show exception records')
	parser.add_argument('--handles', action='store_true', help='List handles')
	parser.add_argument('--misc', action='store_true', help='Show misc info')
	parser.add_argument('--all', action='store_true', help='Show all info')
	parser.add_argument('-r', '--read-addr', type=lambda x: int(x,0), help='Dump a memory region from the process\'s addres space')
	parser.add_argument('-s', '--read-size', type=lambda x: int(x,0), default = 0x20, help='Dump a memory region from the process\'s addres space')
	
	args = parser.parse_args()
	if args.verbose == 0:
		logging.basicConfig(level=logging.INFO)
	elif args.verbose == 1:
		logging.basicConfig(level=logging.DEBUG)
	else:
		logging.basicConfig(level=1)

	print(__banner__)
	
	if args.interactive:
		shell = MinidumpShell()
		shell.do_open(args.minidumpfile)
		shell.cmdloop()

	else:
		
		mf = MinidumpFile.parse(args.minidumpfile)
		reader = mf.get_reader()
		
		if args.all or args.threads:
			if mf.threads is not None:
				print(str(mf.threads))
			if mf.threads_ex is not None:
				print(str(mf.threads_ex))
			if mf.thread_info is not None:
				print(str(mf.thread_info))
		if args.all or args.modules:
			if mf.modules is not None:
				print(str(mf.modules))
			if mf.unloaded_modules is not None:
				print(str(mf.unloaded_modules))
		if args.all or args.memory:
			if mf.memory_segments is not None:
				print(str(mf.memory_segments))
			if mf.memory_segments_64 is not None:
				print(str(mf.memory_segments_64))
			if mf.memory_info is not None:
				print(str(mf.memory_info))
		if args.all or args.sysinfo:
			if mf.sysinfo is not None:
				print(str(mf.sysinfo))
		if args.all or args.exception:
			if mf.exception is not None:
				print(str(mf.exception))
		if args.all or args.comments:
			if mf.comment_a is not None:
				print(str(mf.comment_a))
			if mf.comment_w is not None:
				print(str(mf.comment_w))
		if args.all or args.handles:
			if mf.handles is not None:
				print(str(mf.handles))
		if args.all or args.misc:
			if mf.misc_info is not None:
				print(str(mf.misc_info))
		if args.all or args.header:
			print(str(mf.header))
				
		if args.read_addr:
			buff_reader = reader.get_buffered_reader()
			buff_reader.move(args.read_addr)
			data = buff_reader.peek(args.read_size)
			print(hexdump(data, start = args.read_addr))


if __name__ == '__main__':
	run()
```

`src/minidump/_version.py`:

```py

__version__ = "0.0.21"
__banner__ = \
"""
# minidump %s 
# Author: Tamas Jos @skelsec (skelsecprojects@gmail.com)
""" % __version__
```

`src/minidump/aminidumpfile.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
import sys
import enum
import struct
import logging

from minidump.header import MinidumpHeader
from minidump.aminidumpreader import AMinidumpFileReader
from minidump.streams import *
from minidump.common_structs import *
from minidump.constants import MINIDUMP_STREAM_TYPE
from minidump.directory import MINIDUMP_DIRECTORY


class AsyncFile:
	def __init__(self, filename):
		self.filename = filename
		self.fhandle = open(filename, 'rb')
	
	async def read(self, n = -1):
		return self.fhandle.read(n)

	async def seek(self, n, beg = 0):
		return self.fhandle.seek(n, beg)

	def tell(self):
		return self.fhandle.tell()

class AMinidumpFile:
	def __init__(self):
		self.filename = None
		self.file_handle = None
		self.header = None
		self.directories = []

		self.threads_ex = None
		self.threads = None
		self.modules = None
		self.memory_segments = None
		self.memory_segments_64 = None
		self.sysinfo = None
		self.comment_a = None
		self.comment_w = None
		self.exception = None
		self.handles = None
		self.unloaded_modules = None
		self.misc_info = None
		self.memory_info = None
		self.thread_info = None

	@staticmethod
	async def parse(filename):
		mf = AMinidumpFile()
		mf.filename = filename
		mf.file_handle = AsyncFile(filename)
		await mf._parse()
		return mf

	@staticmethod
	async def parse_external(file_handle, filename = ''):
		"""
		External file handle must be an object that exposes basic file IO functionality
		that you'd get by python's file buffer (read, seek, tell etc.)
		"""
		mf = AMinidumpFile()
		mf.filename = filename
		mf.file_handle = file_handle
		await mf._parse()
		return mf

	@staticmethod
	async def parse_bytes(data):
		return await AMinidumpFile.parse_buff(io.BytesIO(data))

	@staticmethod
	def parse_buff(buffer):
		mf = AMinidumpFile()
		mf.file_handle = buffer
		mf._parse()
		return mf

	def get_reader(self):
		return AMinidumpFileReader(self)

	async def _parse(self):
		await self.__parse_header()
		await self.__parse_directories()

	async def __parse_header(self):
		self.header = await MinidumpHeader.aparse(self.file_handle)
		for i in range(0, self.header.NumberOfStreams):
			await self.file_handle.seek(self.header.StreamDirectoryRva + i * 12, 0 )
			minidump_dir = await MINIDUMP_DIRECTORY.aparse(self.file_handle)
			
			if minidump_dir:
				self.directories.append(minidump_dir)
			else:
				await self.file_handle.seek(self.header.StreamDirectoryRva + i * 12, 0 )
				t = await self.file_handle.read(4)
				user_stream_type_value = int.from_bytes(t, byteorder = 'little', signed = False)
				logging.debug('Found Unknown UserStream directory Type: %x' % (user_stream_type_value))

	async def __parse_directories(self):

		for dir in self.directories:
			if dir.StreamType == MINIDUMP_STREAM_TYPE.UnusedStream:
				logging.debug('Found UnusedStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ReservedStream0:
				logging.debug('Found ReservedStream0 @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ReservedStream1:
				logging.debug('Found ReservedStream1 @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadListStream:
				logging.debug('Found ThreadListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.threads = await MinidumpThreadList.aparse(dir, self.file_handle)
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ModuleListStream:
				logging.debug('Found ModuleListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.modules = await MinidumpModuleList.aparse(dir, self.file_handle)
				#logging.debug(str(modules_list))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MemoryListStream:
				logging.debug('Found MemoryListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_segments = await MinidumpMemoryList.aparse(dir, self.file_handle)
				#logging.debug(str(self.memory_segments))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.SystemInfoStream:
				logging.debug('Found SystemInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.sysinfo = await MinidumpSystemInfo.aparse(dir, self.file_handle)
				#logging.debug(str(self.sysinfo))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadExListStream:
				logging.debug('Found ThreadExListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.threads_ex = await MinidumpThreadExList.aparse(dir, self.file_handle)
				#logging.debug(str(self.threads_ex))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.Memory64ListStream:
				logging.debug('Found Memory64ListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_segments_64 = await MinidumpMemory64List.aparse(dir, self.file_handle)
				#logging.debug(str(self.memory_segments_64))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.CommentStreamA:
				logging.debug('Found CommentStreamA @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.comment_a = await CommentStreamA.aparse(dir, self.file_handle)
				#logging.debug(str(self.comment_a))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.CommentStreamW:
				logging.debug('Found CommentStreamW @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.comment_w = await CommentStreamW.aparse(dir, self.file_handle)
				#logging.debug(str(self.comment_w))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ExceptionStream:
				logging.debug('Found ExceptionStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.exception = await ExceptionList.aparse(dir, self.file_handle)
				#logging.debug(str(self.comment_w))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.HandleDataStream:
				logging.debug('Found HandleDataStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.handles = await MinidumpHandleDataStream.aparse(dir, self.file_handle)
				#logging.debug(str(self.handles))
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.FunctionTableStream:
				logging.debug('Found FunctionTableStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('Parsing of this stream type is not yet implemented!')
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.UnloadedModuleListStream:
				logging.debug('Found UnloadedModuleListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.unloaded_modules = await MinidumpUnloadedModuleList.aparse(dir, self.file_handle)
				#logging.debug(str(self.unloaded_modules))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MiscInfoStream:
				logging.debug('Found MiscInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.misc_info = await MinidumpMiscInfo.aparse(dir, self.file_handle)
				#logging.debug(str(self.misc_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MemoryInfoListStream:
				logging.debug('Found MemoryInfoListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_info = await MinidumpMemoryInfoList.aparse(dir, self.file_handle)
				#logging.debug(str(self.memory_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadInfoListStream:
				logging.debug('Found ThreadInfoListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.thread_info = await MinidumpThreadInfoList.aparse(dir, self.file_handle)
				logging.debug(str(self.thread_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.SystemMemoryInfoStream:
				logging.debug('Found SystemMemoryInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('SystemMemoryInfoStream parsing is not implemented (Missing documentation)')
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.JavaScriptDataStream:
				logging.debug('Found JavaScriptDataStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('JavaScriptDataStream parsing is not implemented (Missing documentation)')

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ProcessVmCountersStream:
				logging.debug('Found ProcessVmCountersStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('ProcessVmCountersStream parsing is not implemented (Missing documentation)')

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.TokenStream:
				logging.debug('Found TokenStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('TokenStream parsing is not implemented (Missing documentation)')

			else:
				logging.debug('Found Unknown Stream! Type: %s @%x Size: %d' % (dir.StreamType.name, dir.Location.Rva, dir.Location.DataSize))

			"""
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.HandleOperationListStream:
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.LastReservedStream:
			
			"""

	def __str__(self):
		t = '== Minidump File ==\n'
		t += str(self.header)
		t += str(self.sysinfo)
		for dir in self.directories:
			t += str(dir) + '\n'
		for mod in self.modules:
			t += str(mod) + '\n'
		if self.memory_segments is not None:
			for segment in self.memory_segments:
				t+= str(segment) + '\n'

		if self.memory_segments_64 is not None:
			for segment in self.memory_segments_64:
				t+= str(segment) + '\n'

		return t

```

`src/minidump/aminidumpreader.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import struct
import ntpath
from .common_structs import *
from .streams.SystemInfoStream import PROCESSOR_ARCHITECTURE


class VirtualSegment:
	def __init__(self, start, end, start_file_address):
		self.start = start
		self.end = end
		self.start_file_address = start_file_address

		self.data = None
	
	def inrange(self, start, end):
		return self.start <= start and end<= self.end

class AMinidumpBufferedMemorySegment:
	def __init__(self, memory_segment, chunksize = 10*1024):
		self.start_address = memory_segment.start_virtual_address
		self.end_address = memory_segment.end_virtual_address
		self.total_size = memory_segment.end_virtual_address - memory_segment.start_virtual_address
		self.start_file_address = memory_segment.start_file_address
		self.chunksize = chunksize
		self.chunks = []

	def inrange(self, position):
		return self.start_address <= position < self.end_address

	def remaining_len(self, position):
		if not self.inrange(position):
			return None
		return self.end_address - position

	async def find(self, file_handle, pattern, startpos):
		data = await self.read(file_handle, 0, -1)
		return data.find(pattern, startpos)

	async def read(self, file_handle, start, end):
		if end is None:
			await file_handle.seek(self.start_file_address + start)
			return await file_handle.read(self.end_address - (self.start_file_address + start))
		
		for chunk in self.chunks:
			if chunk.inrange(start, end):
				return chunk.data[start - chunk.start: end - chunk.start]
		
		if self.total_size <= 2*self.chunksize:
			chunksize = self.total_size
			vs = VirtualSegment(0, chunksize, self.start_file_address)
			await file_handle.seek(self.start_file_address)
			vs.data = await file_handle.read(chunksize)
			self.chunks.append(vs)
			return vs.data[start - vs.start: end - vs.start]

		chunksize = max((end-start), self.chunksize)
		if start + chunksize > self.end_address:
			chunksize = self.end_address - start
		
		vs = VirtualSegment(start, start+chunksize, self.start_file_address + start)
		await file_handle.seek(vs.start_file_address)
		vs.data = await file_handle.read(chunksize)
		self.chunks.append(vs)
		
		return vs.data[start - vs.start: end - vs.start]

class AMinidumpBufferedReader:
	def __init__(self, reader, segment_chunk_size = 10*1024):
		self.reader = reader
		self.memory_segments = []
		self.segment_chunk_size = segment_chunk_size

		self.current_segment = None
		self.current_position = None

	async def _select_segment(self, requested_position):
		"""

		"""
		# check if we have semgnet for requested address in cache
		for memory_segment in self.memory_segments:
			if memory_segment.inrange(requested_position):
				self.current_segment = memory_segment
				self.current_position = requested_position
				return

		# not in cache, check if it's present in memory space. if yes then create a new buffered memeory object, and copy data
		for memory_segment in self.reader.memory_segments:
			if memory_segment.inrange(requested_position):
				newsegment = AMinidumpBufferedMemorySegment(memory_segment, chunksize=self.segment_chunk_size)
				self.memory_segments.append(newsegment)
				self.current_segment = newsegment
				self.current_position = requested_position
				return

		raise Exception('Memory address 0x%08x is not in process memory space' % requested_position)

	async def seek(self, offset, whence = 0):
		"""
		Changes the current address to an offset of offset. The whence parameter controls from which position should we count the offsets.
		0: beginning of the current memory segment
		1: from current position
		2: from the end of the current memory segment
		If you wish to move out from the segment, use the 'move' function
		"""
		if whence == 0:
			t = self.current_segment.start_address + offset
		elif whence == 1:
			t = self.current_position + offset
		elif whence == 2:
			t = self.current_segment.end_address - offset
		else:
			raise Exception('Seek function whence value must be between 0-2')

		if not self.current_segment.inrange(t):
			raise Exception('Seek would cross memory segment boundaries (use move)')

		self.current_position = t
		return

	async def move(self, address):
		"""
		Moves the buffer to a virtual address specified by address
		"""
		await self._select_segment(address)
		return

	async def align(self, alignment = None):
		"""
		Repositions the current reader to match architecture alignment
		"""
		if alignment is None:
			if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
				alignment = 8
			else:
				alignment = 4
		offset = self.current_position % alignment
		if offset == 0:
			return
		offset_to_aligned = (alignment - offset) % alignment
		await self.seek(offset_to_aligned, 1)
		return

	def tell(self):
		"""
		Returns the current virtual address
		"""
		return self.current_position

	async def peek(self, length):
		"""
		Returns up to length bytes from the current memory segment
		"""
		t = self.current_position + length
		if not self.current_segment.inrange(t):
			raise Exception('Would read over segment boundaries!')
		return await self.current_segment.read(self.reader.file_handle, self.current_position - self.current_segment.start_address , t - self.current_segment.start_address)

	async def read(self, size = -1):
		"""
		Returns data bytes of size size from the current segment. If size is -1 it returns all the remaining data bytes from memory segment
		"""
		if size < -1:
			raise Exception('You shouldnt be doing this')
		if size == -1:
			t = self.current_segment.remaining_len(self.current_position)
			if not t:
				return None

			old_new_pos = self.current_position
			self.current_position = self.current_segment.end_address
			return await self.current_segment.read(self.reader.file_handle, old_new_pos - self.current_segment.start_address, None)

		t = self.current_position + size
		if not self.current_segment.inrange(t):
			raise Exception('Would read over segment boundaries!')

		old_new_pos = self.current_position
		self.current_position = t
		return await self.current_segment.read(self.reader.file_handle, old_new_pos - self.current_segment.start_address, t - self.current_segment.start_address)

	async def read_int(self):
		"""
		Reads an integer. The size depends on the architecture.
		Reads a 4 byte small-endian singed int on 32 bit arch
		Reads an 8 byte small-endian singed int on 64 bit arch
		"""
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			t = await self.read(8)
			return int.from_bytes(t, byteorder = 'little', signed = True)
		else:
			t = t = await self.read(4)
			return int.from_bytes(t, byteorder = 'little', signed = True)

	async def read_uint(self):
		"""
		Reads an integer. The size depends on the architecture.
		Reads a 4 byte small-endian unsinged int on 32 bit arch
		Reads an 8 byte small-endian unsinged int on 64 bit arch
		"""
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			t = await self.read(8)
			return int.from_bytes(t, byteorder = 'little', signed = False)
		else:
			t = await self.read(4)
			return int.from_bytes(t, byteorder = 'little', signed = False)

	async def find(self, pattern):
		"""
		Searches for a pattern in the current memory segment
		"""
		pos = await self.current_segment.find(self.reader.file_handle, pattern)
		if pos == -1:
			return -1
		return pos + self.current_position

	async def find_all(self, pattern):
		"""
		Searches for all occurrences of a pattern in the current memory segment, returns all occurrences as a list
		"""
		pos = []
		last_found = -1
		while True:
			last_found = await self.current_segment.find(self.reader.file_handle, pattern, last_found + 1)
			if last_found == -1:
				break
			pos.append(last_found + self.current_segment.start_address)

		return pos

	async def find_global(self, pattern):
		"""
		Searches for the pattern in the whole process memory space and returns the first occurrence.
		This is exhaustive!
		"""
		pos_s = await self.reader.search(pattern)
		if len(pos_s) == 0:
			return -1

		return pos_s[0]

	async def find_all_global(self, pattern):
		"""
		Searches for the pattern in the whole process memory space and returns a list of addresses where the pattern begins.
		This is exhaustive!
		"""
		return await self.reader.search(pattern)

	async def get_ptr(self, pos):
		await self.move(pos)
		return await self.read_uint()
		#raw_data = self.read(pos, self.sizeof_ptr)
		#return struct.unpack(self.unpack_ptr, raw_data)[0]

	async def get_ptr_with_offset(self, pos):
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			await self.move(pos)
			t = await self.read(4)
			ptr = int.from_bytes(t, byteorder = 'little', signed = True)
			return pos + 4 + ptr
		else:
			await self.move(pos)
			return await self.read_uint()

	async def find_in_module(self, module_name, pattern, find_first = False, reverse_order = False):
		t = await self.reader.search_module(module_name, pattern, find_first = find_first, reverse_order = reverse_order,chunksize = self.segment_chunk_size)
		return t




class AMinidumpFileReader:
	def __init__(self, minidumpfile):
		self.modules = minidumpfile.modules.modules
		self.sysinfo = minidumpfile.sysinfo

		if minidumpfile.memory_segments_64:
			self.memory_segments = minidumpfile.memory_segments_64.memory_segments
			self.is_fulldump = True

		else:
			self.memory_segments = minidumpfile.memory_segments.memory_segments
			self.is_fulldump = False

		self.filename = minidumpfile.filename
		self.file_handle = minidumpfile.file_handle

		#reader params
		self.sizeof_long = 4
		self.unpack_long = '<L'
		if minidumpfile.sysinfo.ProcessorArchitecture in [PROCESSOR_ARCHITECTURE.AMD64, PROCESSOR_ARCHITECTURE.AARCH64]:
			self.sizeof_ptr = 8
			self.unpack_ptr = '<Q'
		elif self.sysinfo.ProcessorArchitecture in [PROCESSOR_ARCHITECTURE.INTEL,
				PROCESSOR_ARCHITECTURE.ARM]:
			self.sizeof_ptr = 4
			self.unpack_ptr = '<L'
		else:
			raise Exception('Unknown processor architecture %s! Please fix and submit PR!' % self.sysinfo.ProcessorArchitecture)

	def get_buffered_reader(self, segment_chunk_size = 10*1024):
		return AMinidumpBufferedReader(self, segment_chunk_size = segment_chunk_size)

	def get_module_by_name(self, module_name):
		for mod in self.modules:
			if ntpath.basename(mod.name).lower().find(module_name.lower()) != -1:
				return mod
		return None

	async def search_module(self, module_name, pattern, find_first = False, reverse_order = False, chunksize = 10*1024):
		mod = self.get_module_by_name(module_name)
		if mod is None:
			raise Exception('Could not find module! %s' % module_name)
		needles = []
		for ms in self.memory_segments:
			if mod.baseaddress <= ms.start_virtual_address < mod.endaddress:
				needles += await ms.asearch(pattern, self.file_handle, find_first = find_first, chunksize = chunksize)
				if len(needles) > 0 and find_first is True:
					return needles

		return needles

	async def search(self, pattern, find_first = False, chunksize = 10*1024):
		t = []
		for ms in self.memory_segments:
			t += await ms.asearch(pattern, self.file_handle, find_first = find_first, chunksize = chunksize)

		return t

	async def read(self, virt_addr, size):
		for segment in self.memory_segments:
			if segment.inrange(virt_addr):
				return await segment.aread(virt_addr, size, self.file_handle)
		raise Exception('Address not in memory range! %s' % hex(virt_addr))


```

`src/minidump/common_structs.py`:

```py

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680383(v=vs.85).aspx	
class MINIDUMP_LOCATION_DESCRIPTOR:
	def __init__(self):
		self.DataSize = None
		self.Rva = None

	def get_size(self):
		return 8

	def to_bytes(self):
		t = self.DataSize.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Rva.to_bytes(4, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mld = MINIDUMP_LOCATION_DESCRIPTOR()
		mld.DataSize = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mld.Rva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return mld

	@staticmethod
	async def aparse(buff):
		mld = MINIDUMP_LOCATION_DESCRIPTOR()
		t = await buff.read(4)
		mld.DataSize = int.from_bytes(t, byteorder = 'little', signed = False)
		t = await buff.read(4)
		mld.Rva = int.from_bytes(t, byteorder = 'little', signed = False)
		return mld
	
	def __str__(self):
		t = 'Size: %s File offset: %s' % (self.DataSize, self.Rva)
		return t
		
class MINIDUMP_LOCATION_DESCRIPTOR64:
	def __init__(self):
		self.DataSize = None
		self.Rva = None

	def get_size(self):
		return 16

	def to_bytes(self):
		t = self.DataSize.to_bytes(8, byteorder = 'little', signed = False)
		t += self.Rva.to_bytes(8, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mld = MINIDUMP_LOCATION_DESCRIPTOR64()
		mld.DataSize = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mld.Rva = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		return mld
	
	def __str__(self):
		t = 'Size: %s File offset: %s' % (self.DataSize, self.Rva)
		return t
		
class MINIDUMP_STRING:
	def __init__(self):
		self.Length = None
		self.Buffer = None
	
	@staticmethod
	def parse(buff):
		ms = MINIDUMP_STRING()
		ms.Length = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		ms.Buffer = buff.read(ms.Length)
		return ms

	@staticmethod
	async def aparse(buff):
		ms = MINIDUMP_STRING()
		t = await buff.read(4)
		ms.Length = int.from_bytes(t, byteorder = 'little', signed = False)
		ms.Buffer = await buff.read(ms.Length)
		return ms
		
	@staticmethod
	def get_from_rva(rva, buff):
		pos = buff.tell()
		buff.seek(rva, 0)
		ms = MINIDUMP_STRING.parse(buff)
		buff.seek(pos, 0)
		return ms.Buffer.decode('utf-16-le')
	
	@staticmethod
	async def aget_from_rva(rva, buff):
		pos = buff.tell()
		await buff.seek(rva, 0)
		ms = await MINIDUMP_STRING.aparse(buff)
		await buff.seek(pos, 0)
		return ms.Buffer.decode('utf-16-le')
		
class MinidumpMemorySegment:
	def __init__(self):
		self.start_virtual_address = None
		self.size = None
		self.end_virtual_address = None
		self.start_file_address = None
	
	@staticmethod
	def parse_mini(memory_decriptor, buff):
		"""
		memory_descriptor: MINIDUMP_MEMORY_DESCRIPTOR
		buff: file_handle
		"""
		mms = MinidumpMemorySegment()
		mms.start_virtual_address = memory_decriptor.StartOfMemoryRange
		mms.size = memory_decriptor.DataSize
		mms.start_file_address = memory_decriptor.Rva
		mms.end_virtual_address = mms.start_virtual_address + mms.size
		return mms
	
	@staticmethod
	def parse_full(memory_decriptor, rva):
		mms = MinidumpMemorySegment()
		mms.start_virtual_address = memory_decriptor.StartOfMemoryRange
		mms.size = memory_decriptor.DataSize
		mms.start_file_address = rva
		mms.end_virtual_address = mms.start_virtual_address + mms.size
		return mms		
		
	def inrange(self, virt_addr):
		if virt_addr >= self.start_virtual_address and virt_addr < self.end_virtual_address:
			return True
		return False
	
	def read(self, virtual_address, size, file_handler):
		if virtual_address > self.end_virtual_address or virtual_address < self.start_virtual_address:
			raise Exception('Reading from wrong segment!')
		
		if virtual_address+size > self.end_virtual_address:
			raise Exception('Read would cross boundaries!')
		
		pos = file_handler.tell()
		offset = virtual_address - self.start_virtual_address
		file_handler.seek(self.start_file_address + offset, 0)
		data = file_handler.read(size)
		file_handler.seek(pos, 0)
		return data

	async def aread(self, virtual_address, size, file_handler):
		if virtual_address > self.end_virtual_address or virtual_address < self.start_virtual_address:
			raise Exception('Reading from wrong segment!')
		
		if virtual_address+size > self.end_virtual_address:
			raise Exception('Read would cross boundaries!')
		
		pos = file_handler.tell()
		offset = virtual_address - self.start_virtual_address
		await file_handler.seek(self.start_file_address + offset, 0)
		data = await file_handler.read(size)
		await file_handler.seek(pos, 0)
		return data
		
	def search(self, pattern, file_handler, find_first = False, chunksize = 50*1024):
		if len(pattern) > self.size:
			return []
		pos = file_handler.tell()
		file_handler.seek(self.start_file_address, 0)
		fl = []
		if find_first is True:
			chunksize = min(chunksize, self.size)
			data = b''
			i = 0
			while len(data) < self.size:
				i += 1
				if chunksize > (self.size - len(data)):
					chunksize = (self.size - len(data))
				data += file_handler.read(chunksize)
				marker = data.find(pattern)
				if marker != -1:
					#print('FOUND! size: %s i: %s read: %s perc: %s' % (self.size, i, i*chunksize, 100*((i*chunksize)/self.size)))
					file_handler.seek(pos, 0)
					return [self.start_virtual_address + marker]
			
			
			#print('NOTFOUND! size: %s i: %s read: %s perc %s' % (self.size, i, len(data), 100*(len(data)/self.size) ))
			
		else:
			data = file_handler.read(self.size)
			file_handler.seek(pos, 0)
			
			offset = 0
			while len(data) > len(pattern):
				marker = data.find(pattern)
				if marker == -1:
					return fl
				fl.append(marker + offset + self.start_virtual_address)
				data = data[marker+1:]
				offset += marker + 1
				if find_first is True:
					return fl
		
		file_handler.seek(pos, 0)
		return fl

	async def asearch(self, pattern, file_handler, find_first = False, chunksize = 50*1024):
		if len(pattern) > self.size:
			return []
		pos = file_handler.tell()
		await file_handler.seek(self.start_file_address, 0)
		fl = []
		
		if find_first is True:
			chunksize = min(chunksize, self.size)
			data = b''
			i = 0
			while len(data) < self.size:
				i += 1
				if chunksize > (self.size - len(data)):
					chunksize = (self.size - len(data))
				data += await file_handler.read(chunksize)
				marker = data.find(pattern)
				if marker != -1:
					#print('FOUND! size: %s i: %s read: %s perc: %s' % (self.size, i, i*chunksize, 100*((i*chunksize)/self.size)))
					await file_handler.seek(pos, 0)
					return [self.start_virtual_address + marker]
			
			
			#print('NOTFOUND! size: %s i: %s read: %s perc %s' % (self.size, i, len(data), 100*(len(data)/self.size) ))
		
		else:
			offset = 0
			data = await file_handler.read(self.size)
			await file_handler.seek(pos, 0)
			while len(data) > len(pattern):
				marker = data.find(pattern)
				if marker == -1:
					return fl
				fl.append(marker + offset + self.start_virtual_address)
				data = data[marker+1:]
				offset += marker + 1
				if find_first is True:
					return fl
		
		await file_handler.seek(pos, 0)
		return fl
	
	
	@staticmethod
	def get_header():
		t = [
			'VA Start',
			'RVA',
			'Size',
		]
		return t
	
	def to_row(self):
		t = [
			hex(self.start_virtual_address),
			hex(self.start_file_address),
			hex(self.size)
		]
		return t
		
	def __str__(self):
		t = 'VA Start: %s, RVA: %s, Size: %s' % (hex(self.start_virtual_address), hex(self.start_file_address), hex(self.size))
		return t
		
		

def hexdump( src, length=16, sep='.', start = 0):
	'''
	@brief Return {src} in hex dump.
	@param[in] length	{Int} Nb Bytes by row.
	@param[in] sep		{Char} For the text part, {sep} will be used for non ASCII char.
	@return {Str} The hexdump

	@note Full support for python2 and python3 !
	'''
	result = [];

	# Python3 support
	try:
		xrange(0,1);
	except NameError:
		xrange = range;

	for i in xrange(0, len(src), length):
		subSrc = src[i:i+length];
		hexa = '';
		isMiddle = False;
		for h in xrange(0,len(subSrc)):
			if h == length/2:
				hexa += ' ';
			h = subSrc[h];
			if not isinstance(h, int):
				h = ord(h);
			h = hex(h).replace('0x','');
			if len(h) == 1:
				h = '0'+h;
			hexa += h+' ';
		hexa = hexa.strip(' ');
		text = '';
		for c in subSrc:
			if not isinstance(c, int):
				c = ord(c);
			if 0x20 <= c < 0x7F:
				text += chr(c);
			else:
				text += sep;
		if start == 0:
			result.append(('%08x:  %-'+str(length*(2+1)+1)+'s  |%s|') % (i, hexa, text));
		else:
			result.append(('%08x(+%04x):  %-'+str(length*(2+1)+1)+'s  |%s|') % (start+i, i, hexa, text));
	return '\n'.join(result);
	
def construct_table(lines, separate_head=True):
	"""Prints a formatted table given a 2 dimensional array"""
	#Count the column width
	widths = []
	for line in lines:
			for i,size in enumerate([len(x) for x in line]):
					while i >= len(widths):
							widths.append(0)
					if size > widths[i]:
							widths[i] = size
       
	#Generate the format string to pad the columns
	print_string = ""
	for i,width in enumerate(widths):
			print_string += "{" + str(i) + ":" + str(width) + "} | "
	if (len(print_string) == 0):
			return
	print_string = print_string[:-3]
       
	#Print the actual data
	t = ''
	for i,line in enumerate(lines):
			t += print_string.format(*line) + '\n'
			if (i == 0 and separate_head):
					t += "-"*(sum(widths)+3*(len(widths)-1)) + '\n'
					
	return t

```

`src/minidump/constants.py`:

```py
import enum

class MINIDUMP_STREAM_TYPE(enum.Enum):
	UnusedStream			   	= 0
	ReservedStream0				= 1
	ReservedStream1				= 2
	ThreadListStream		   	= 3
	ModuleListStream		   	= 4
	MemoryListStream		   	= 5
	ExceptionStream				= 6
	SystemInfoStream		   	= 7
	ThreadExListStream		 	= 8
	Memory64ListStream		 	= 9
	CommentStreamA			 	= 10
	CommentStreamW			 	= 11
	HandleDataStream		   	= 12
	FunctionTableStream			= 13
	UnloadedModuleListStream   	= 14
	MiscInfoStream			 	= 15
	MemoryInfoListStream	   	= 16
	ThreadInfoListStream	   	= 17
	HandleOperationListStream  	= 18
	TokenStream 				= 19
	JavaScriptDataStream 		= 20
	SystemMemoryInfoStream 		= 21
	ProcessVmCountersStream 	= 22
	ThreadNamesStream 			= 24
	ceStreamNull 				= 25
	ceStreamSystemInfo 			= 26
	ceStreamException 			= 27
	ceStreamModuleList 			= 28
	ceStreamProcessList 		= 29
	ceStreamThreadList 			= 30
	ceStreamThreadContextList 	= 31
	ceStreamThreadCallStackList = 32
	ceStreamMemoryVirtualList 	= 33
	ceStreamMemoryPhysicalList 	= 34
	ceStreamBucketParameters 	= 35
	ceStreamProcessModuleMap 	= 36
	ceStreamDiagnosisList 		= 37
	LastReservedStream		 	= 0xffff

class MINIDUMP_TYPE(enum.IntFlag):
	MiniDumpNormal                         = 0x00000000
	MiniDumpWithDataSegs                   = 0x00000001
	MiniDumpWithFullMemory                 = 0x00000002
	MiniDumpWithHandleData                 = 0x00000004
	MiniDumpFilterMemory                   = 0x00000008
	MiniDumpScanMemory                     = 0x00000010
	MiniDumpWithUnloadedModules            = 0x00000020
	MiniDumpWithIndirectlyReferencedMemory = 0x00000040
	MiniDumpFilterModulePaths              = 0x00000080
	MiniDumpWithProcessThreadData          = 0x00000100
	MiniDumpWithPrivateReadWriteMemory     = 0x00000200
	MiniDumpWithoutOptionalData            = 0x00000400
	MiniDumpWithFullMemoryInfo             = 0x00000800
	MiniDumpWithThreadInfo                 = 0x00001000
	MiniDumpWithCodeSegs                   = 0x00002000
	MiniDumpWithoutAuxiliaryState          = 0x00004000
	MiniDumpWithFullAuxiliaryState         = 0x00008000
	MiniDumpWithPrivateWriteCopyMemory     = 0x00010000
	MiniDumpIgnoreInaccessibleMemory       = 0x00020000
	MiniDumpWithTokenInformation           = 0x00040000
	MiniDumpWithModuleHeaders              = 0x00080000
	MiniDumpFilterTriage                   = 0x00100000
	MiniDumpValidTypeFlags                 = 0x001fffff
```

`src/minidump/directory.py`:

```py

from minidump.constants import MINIDUMP_STREAM_TYPE
from minidump.common_structs import MINIDUMP_LOCATION_DESCRIPTOR

class MINIDUMP_DIRECTORY:
	def __init__(self):
		self.StreamType = None
		self.Location = None

	def to_bytes(self):
		t = self.StreamType.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Location.to_bytes()
		return t

	@staticmethod
	def get_stream_type_value(buff, peek=False):
		return int.from_bytes(buff.read(4), byteorder = 'little', signed = False)

	@staticmethod
	def parse(buff):

		raw_stream_type_value = MINIDUMP_DIRECTORY.get_stream_type_value(buff)

		# StreamType value that are over 0xffff are considered MINIDUMP_USER_STREAM streams
		# and their format depends on the client used to create the minidump.
		# As per the documentation, this stream should be ignored : https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidumminidump_dirp_stream_type#remarks
		is_user_stream = raw_stream_type_value > MINIDUMP_STREAM_TYPE.LastReservedStream.value
		is_stream_supported = raw_stream_type_value in MINIDUMP_STREAM_TYPE._value2member_map_
		if is_user_stream and not is_stream_supported:
			return None

		md = MINIDUMP_DIRECTORY()
		md.StreamType = MINIDUMP_STREAM_TYPE(raw_stream_type_value)
		md.Location = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		return md

	@staticmethod
	async def aparse(buff):
		
		t = await buff.read(4)
		raw_stream_type_value = int.from_bytes(t, byteorder = 'little', signed = False)

		# StreamType value that are over 0xffff are considered MINIDUMP_USER_STREAM streams
		# and their format depends on the client used to create the minidump.
		# As per the documentation, this stream should be ignored : https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidumminidump_dirp_stream_type#remarks
		is_user_stream = raw_stream_type_value > MINIDUMP_STREAM_TYPE.LastReservedStream.value
		is_stream_supported = raw_stream_type_value in MINIDUMP_STREAM_TYPE._value2member_map_
		if is_user_stream and not is_stream_supported:
			return None

		md = MINIDUMP_DIRECTORY()
		md.StreamType = MINIDUMP_STREAM_TYPE(raw_stream_type_value)
		md.Location = await MINIDUMP_LOCATION_DESCRIPTOR.aparse(buff)
		return md

	def __str__(self):
		t = 'StreamType: %s %s' % (self.StreamType, self.Location)
		return t
```

`src/minidump/exceptions.py`:

```py

class MinidumpException(Exception):
	"""Generic Exception from minidump module"""
	pass
		
class MinidumpHeaderSignatureMismatchException(Exception):
	"""Header signature was not correct"""
	pass
	
class MinidumpHeaderFlagsException(Exception):
	"""Header flags value was not correct"""
	pass
```

`src/minidump/header.py`:

```py
from minidump.constants import MINIDUMP_TYPE
from minidump.exceptions import MinidumpHeaderFlagsException, MinidumpHeaderSignatureMismatchException
import io

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680378(v=vs.85).aspx
class MinidumpHeader:
	def __init__(self):
		self.Signature = 'PMDM'
		self.Version = None
		self.ImplementationVersion = None
		self.NumberOfStreams = None
		self.StreamDirectoryRva = None
		self.CheckSum = 0
		self.Reserved = 0
		self.TimeDateStamp = 0
		self.Flags = None

	def to_bytes(self):
		t = self.Signature.encode('ascii')
		t += self.Version.to_bytes(2, byteorder = 'little', signed = False)
		t += self.ImplementationVersion.to_bytes(2, byteorder = 'little', signed = False)
		t += self.NumberOfStreams.to_bytes(4, byteorder = 'little', signed = False)
		t += self.StreamDirectoryRva.to_bytes(4, byteorder = 'little', signed = False)
		t += self.CheckSum.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Reserved.to_bytes(4, byteorder = 'little', signed = False)
		t += self.TimeDateStamp.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Flags.value.to_bytes(4, byteorder = 'little', signed = False)

		return t

	@staticmethod
	def parse(buff):
		mh = MinidumpHeader()
		mh.Signature = buff.read(4).decode()[::-1]
		if mh.Signature != 'PMDM':
			raise MinidumpHeaderSignatureMismatchException(mh.Signature)
		mh.Version = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		mh.ImplementationVersion = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		mh.NumberOfStreams = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mh.StreamDirectoryRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mh.CheckSum = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mh.Reserved = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mh.TimeDateStamp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		try:
			mh.Flags = MINIDUMP_TYPE(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except Exception as e:
			raise MinidumpHeaderFlagsException('Could not parse header flags!')

		return mh

	@staticmethod
	async def aparse(abuff):
		adata = await abuff.read(32)
		buff = io.BytesIO(adata)
		return MinidumpHeader.parse(buff)

	def __str__(self):
		t = '== MinidumpHeader ==\n'
		t+= 'Signature: %s\n' % self.Signature
		t+= 'Version: %s\n' % self.Version
		t+= 'ImplementationVersion: %s\n' % self.ImplementationVersion
		t+= 'NumberOfStreams: %s\n' % self.NumberOfStreams
		t+= 'StreamDirectoryRva: %s\n' % self.StreamDirectoryRva
		t+= 'CheckSum: %s\n' % self.CheckSum
		t+= 'Reserved: %s\n' % self.Reserved
		t+= 'TimeDateStamp: %s\n' % self.TimeDateStamp
		t+= 'Flags: %s\n' % self.Flags
		return t
```

`src/minidump/minidumpfile.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
import sys
import enum
import struct
import logging

from minidump.header import MinidumpHeader
from minidump.minidumpreader import MinidumpFileReader
from minidump.streams import *
from minidump.common_structs import *
from minidump.constants import MINIDUMP_STREAM_TYPE
from minidump.directory import MINIDUMP_DIRECTORY
from minidump.streams.SystemInfoStream import PROCESSOR_ARCHITECTURE


class MinidumpFile:
	def __init__(self):
		self.filename = None
		self.file_handle = None
		self.header = None
		self.directories = []

		self.threads_ex = None
		self.threads = None
		self.modules = None
		self.memory_segments = None
		self.memory_segments_64 = None
		self.sysinfo = None
		self.comment_a = None
		self.comment_w = None
		self.exception = None
		self.handles = None
		self.unloaded_modules = None
		self.misc_info = None
		self.memory_info = None
		self.thread_info = None

	@staticmethod
	def parse(filename):
		mf = MinidumpFile()
		mf.filename = filename
		mf.file_handle = open(filename, 'rb')
		mf._parse()
		return mf

	@staticmethod
	def parse_external(file_handle, filename = ''):
		"""
		External file handle must be an object that exposes basic file IO functionality
		that you'd get by python's file buffer (read, seek, tell etc.)
		"""
		mf = MinidumpFile()
		mf.filename = filename
		mf.file_handle = file_handle
		mf._parse()
		return mf

	@staticmethod
	def parse_bytes(data):
		return MinidumpFile.parse_buff(io.BytesIO(data))

	@staticmethod
	def parse_buff(buffer):
		mf = MinidumpFile()
		mf.file_handle = buffer
		mf._parse()
		return mf

	def get_reader(self):
		return MinidumpFileReader(self)

	def _parse(self):
		self.__parse_header()
		self.__parse_directories()

	def __parse_header(self):
		self.header = MinidumpHeader.parse(self.file_handle)
		for i in range(0, self.header.NumberOfStreams):
			self.file_handle.seek(self.header.StreamDirectoryRva + i * 12, 0 )
			minidump_dir = MINIDUMP_DIRECTORY.parse(self.file_handle)
			
			if minidump_dir:
				self.directories.append(minidump_dir)
			else:
				self.file_handle.seek(self.header.StreamDirectoryRva + i * 12, 0 )
				user_stream_type_value = MINIDUMP_DIRECTORY.get_stream_type_value(self.file_handle)
				logging.debug('Found Unknown UserStream directory Type: %x' % (user_stream_type_value))

	def __parse_directories(self):

		for dir in self.directories:
			if dir.StreamType == MINIDUMP_STREAM_TYPE.UnusedStream:
				logging.debug('Found UnusedStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ReservedStream0:
				logging.debug('Found ReservedStream0 @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ReservedStream1:
				logging.debug('Found ReservedStream1 @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				continue # Reserved. Do not use this enumeration value.
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadListStream:
				logging.debug('Found ThreadListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.threads = MinidumpThreadList.parse(dir, self.file_handle)
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ModuleListStream:
				logging.debug('Found ModuleListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.modules = MinidumpModuleList.parse(dir, self.file_handle)
				#logging.debug(str(modules_list))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MemoryListStream:
				logging.debug('Found MemoryListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_segments = MinidumpMemoryList.parse(dir, self.file_handle)
				#logging.debug(str(self.memory_segments))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.SystemInfoStream:
				logging.debug('Found SystemInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.sysinfo = MinidumpSystemInfo.parse(dir, self.file_handle)
				#logging.debug(str(self.sysinfo))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadExListStream:
				logging.debug('Found ThreadExListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.threads_ex = MinidumpThreadExList.parse(dir, self.file_handle)
				#logging.debug(str(self.threads_ex))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.Memory64ListStream:
				logging.debug('Found Memory64ListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_segments_64 = MinidumpMemory64List.parse(dir, self.file_handle)
				#logging.debug(str(self.memory_segments_64))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.CommentStreamA:
				logging.debug('Found CommentStreamA @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.comment_a = CommentStreamA.parse(dir, self.file_handle)
				#logging.debug(str(self.comment_a))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.CommentStreamW:
				logging.debug('Found CommentStreamW @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.comment_w = CommentStreamW.parse(dir, self.file_handle)
				#logging.debug(str(self.comment_w))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ExceptionStream:
				logging.debug('Found ExceptionStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.exception = ExceptionList.parse(dir, self.file_handle)
				#logging.debug(str(self.comment_w))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.HandleDataStream:
				logging.debug('Found HandleDataStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.handles = MinidumpHandleDataStream.parse(dir, self.file_handle)
				#logging.debug(str(self.handles))
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.FunctionTableStream:
				logging.debug('Found FunctionTableStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('Parsing of this stream type is not yet implemented!')
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.UnloadedModuleListStream:
				logging.debug('Found UnloadedModuleListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.unloaded_modules = MinidumpUnloadedModuleList.parse(dir, self.file_handle)
				#logging.debug(str(self.unloaded_modules))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MiscInfoStream:
				logging.debug('Found MiscInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.misc_info = MinidumpMiscInfo.parse(dir, self.file_handle)
				#logging.debug(str(self.misc_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.MemoryInfoListStream:
				logging.debug('Found MemoryInfoListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.memory_info = MinidumpMemoryInfoList.parse(dir, self.file_handle)
				#logging.debug(str(self.memory_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ThreadInfoListStream:
				logging.debug('Found ThreadInfoListStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				self.thread_info = MinidumpThreadInfoList.parse(dir, self.file_handle)
				logging.debug(str(self.thread_info))
				continue
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.SystemMemoryInfoStream:
				logging.debug('Found SystemMemoryInfoStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('SystemMemoryInfoStream parsing is not implemented (Missing documentation)')
				continue

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.JavaScriptDataStream:
				logging.debug('Found JavaScriptDataStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('JavaScriptDataStream parsing is not implemented (Missing documentation)')

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.ProcessVmCountersStream:
				logging.debug('Found ProcessVmCountersStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('ProcessVmCountersStream parsing is not implemented (Missing documentation)')

			elif dir.StreamType == MINIDUMP_STREAM_TYPE.TokenStream:
				logging.debug('Found TokenStream @%x Size: %d' % (dir.Location.Rva, dir.Location.DataSize))
				logging.debug('TokenStream parsing is not implemented (Missing documentation)')

			else:
				logging.debug('Found Unknown Stream! Type: %s @%x Size: %d' % (dir.StreamType.name, dir.Location.Rva, dir.Location.DataSize))

			"""
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.HandleOperationListStream:
			elif dir.StreamType == MINIDUMP_STREAM_TYPE.LastReservedStream:
			
			"""
		try:
			self.__parse_thread_context()
		except Exception as e:
			logging.exception('Thread context parsing error!')

	def __parse_thread_context(self):
		if not self.sysinfo or not self.threads:
			return
		for thread in self.threads.threads:
			rva = thread.ThreadContext.Rva
			self.file_handle.seek(rva)
			if self.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
				thread.ContextObject = CONTEXT.parse(self.file_handle)
			elif self.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.INTEL:
				thread.ContextObject = WOW64_CONTEXT.parse(self.file_handle)
			

	def __str__(self):
		t = '== Minidump File ==\n'
		t += str(self.header)
		t += str(self.sysinfo)
		for dir in self.directories:
			t += str(dir) + '\n'
		for mod in self.modules:
			t += str(mod) + '\n'
		if self.memory_segments is not None:
			for segment in self.memory_segments:
				t+= str(segment) + '\n'

		if self.memory_segments_64 is not None:
			for segment in self.memory_segments_64:
				t+= str(segment) + '\n'

		return t

```

`src/minidump/minidumpreader.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import struct
import ntpath
from .common_structs import *
from .streams.SystemInfoStream import PROCESSOR_ARCHITECTURE

class VirtualSegment:
	def __init__(self, start, end, start_file_address):
		self.start = start
		self.end = end
		self.start_file_address = start_file_address

		

		self.data = None
	
	def inrange(self, start, end):
		return self.start <= start and end<= self.end

class MinidumpBufferedMemorySegment:
	def __init__(self, memory_segment, file_handle, chunksize = 10*1024):
		self.start_address = memory_segment.start_virtual_address
		self.end_address = memory_segment.end_virtual_address
		self.total_size = memory_segment.end_virtual_address - memory_segment.start_virtual_address
		self.start_file_address = memory_segment.start_file_address
		self.chunksize = chunksize
		self.chunks = []

	def inrange(self, position):
		return self.start_address <= position < self.end_address

	def remaining_len(self, position):
		if not self.inrange(position):
			return None
		return self.end_address - position

	def find(self, file_handle, pattern, startpos):
		data = self.read(file_handle, 0, -1)
		return data.find(pattern, startpos)

	def read(self, file_handle, start, end):
		if end is None:
			file_handle.seek(self.start_file_address + start)
			return file_handle.read(self.end_address - (self.start_file_address + start))
		
		for chunk in self.chunks:
			if chunk.inrange(start, end):
				return chunk.data[start - chunk.start: end - chunk.start]
		
		if self.total_size <= 2*self.chunksize:
			chunksize = self.total_size
			vs = VirtualSegment(0, chunksize, self.start_file_address)
			file_handle.seek(self.start_file_address)
			vs.data = file_handle.read(chunksize)
			self.chunks.append(vs)
			return vs.data[start - vs.start: end - vs.start]

		chunksize = max((end-start), self.chunksize)
		if start + chunksize > self.end_address:
			chunksize = self.end_address - start
		
		vs = VirtualSegment(start, start+chunksize, self.start_file_address + start)
		file_handle.seek(vs.start_file_address)
		vs.data = file_handle.read(chunksize)
		self.chunks.append(vs)
		
		return vs.data[start - vs.start: end - vs.start]



class MinidumpBufferedReader:
	def __init__(self, reader, segment_chunk_size = 10*1024):
		self.reader = reader
		self.segment_chunk_size = segment_chunk_size
		self.memory_segments = []

		self.current_segment = None
		self.current_position = None

	def _select_segment(self, requested_position):
		"""

		"""
		# check if we have semgnet for requested address in cache
		for memory_segment in self.memory_segments:
			if memory_segment.inrange(requested_position):
				self.current_segment = memory_segment
				self.current_position = requested_position
				return

		# not in cache, check if it's present in memory space. if yes then create a new buffered memeory object, and copy data
		for memory_segment in self.reader.memory_segments:
			if memory_segment.inrange(requested_position):
				newsegment = MinidumpBufferedMemorySegment(memory_segment, self.reader.file_handle, chunksize=self.segment_chunk_size)
				self.memory_segments.append(newsegment)
				self.current_segment = newsegment
				self.current_position = requested_position
				return

		raise Exception('Memory address 0x%08x is not in process memory space' % requested_position)

	def get_reader(self):
		return self.reader

	def seek(self, offset, whence = 0):
		"""
		Changes the current address to an offset of offset. The whence parameter controls from which position should we count the offsets.
		0: beginning of the current memory segment
		1: from current position
		2: from the end of the current memory segment
		If you wish to move out from the segment, use the 'move' function
		"""
		if whence == 0:
			t = self.current_segment.start_address + offset
		elif whence == 1:
			t = self.current_position + offset
		elif whence == 2:
			t = self.current_segment.end_address - offset
		else:
			raise Exception('Seek function whence value must be between 0-2')

		if not self.current_segment.inrange(t):
			raise Exception('Seek would cross memory segment boundaries (use move)')

		self.current_position = t
		return

	def move(self, address):
		"""
		Moves the buffer to a virtual address specified by address
		"""
		self._select_segment(address)
		return

	def align(self, alignment = None):
		"""
		Repositions the current reader to match architecture alignment
		"""
		if alignment is None:
			if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
				alignment = 8
			else:
				alignment = 4
		offset = self.current_position % alignment
		if offset == 0:
			return
		offset_to_aligned = (alignment - offset) % alignment
		self.seek(offset_to_aligned, 1)
		return

	def tell(self):
		"""
		Returns the current virtual address
		"""
		return self.current_position

	def peek(self, length):
		"""
		Returns up to length bytes from the current memory segment
		"""
		t = self.current_position + length
		if not self.current_segment.inrange(t):
			raise Exception('Would read over segment boundaries!')
		return self.current_segment.read(self.reader.file_handle, self.current_position - self.current_segment.start_address , t - self.current_segment.start_address)

	def read(self, size = -1):
		"""
		Returns data bytes of size size from the current segment. If size is -1 it returns all the remaining data bytes from memory segment
		"""
		if size < -1:
			raise Exception('You shouldnt be doing this')
		if size == -1:
			t = self.current_segment.remaining_len(self.current_position)
			if not t:
				return None

			old_new_pos = self.current_position
			self.current_position = self.current_segment.end_address
			return self.current_segment.read(self.reader.file_handle, old_new_pos - self.current_segment.start_address, None)

		t = self.current_position + size
		if not self.current_segment.inrange(t - 1):
			raise Exception('Would read over segment boundaries!')

		old_new_pos = self.current_position
		self.current_position = t
		return self.current_segment.read(self.reader.file_handle, old_new_pos - self.current_segment.start_address, t - self.current_segment.start_address)

	def read_int(self):
		"""
		Reads an integer. The size depends on the architecture.
		Reads a 4 byte small-endian singed int on 32 bit arch
		Reads an 8 byte small-endian singed int on 64 bit arch
		"""
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			return int.from_bytes(self.read(8), byteorder = 'little', signed = True)
		else:
			return int.from_bytes(self.read(4), byteorder = 'little', signed = True)

	def read_uint(self):
		"""
		Reads an integer. The size depends on the architecture.
		Reads a 4 byte small-endian unsinged int on 32 bit arch
		Reads an 8 byte small-endian unsinged int on 64 bit arch
		"""
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			return int.from_bytes(self.read(8), byteorder = 'little', signed = False)
		else:
			return int.from_bytes(self.read(4), byteorder = 'little', signed = False)

	def find(self, pattern):
		"""
		Searches for a pattern in the current memory segment
		"""
		pos = self.current_segment.find(self.reader.file_handle, pattern)
		if pos == -1:
			return -1
		return pos + self.current_position

	def find_all(self, pattern):
		"""
		Searches for all occurrences of a pattern in the current memory segment, returns all occurrences as a list
		"""
		pos = []
		last_found = -1
		while True:
			last_found = self.current_segment.find(self.reader.file_handle, pattern, last_found + 1)
			if last_found == -1:
				break
			pos.append(last_found + self.current_segment.start_address)

		return pos

	def find_global(self, pattern):
		"""
		Searches for the pattern in the whole process memory space and returns the first occurrence.
		This is exhaustive!
		"""
		pos_s = self.reader.search(pattern)
		if len(pos_s) == 0:
			return -1

		return pos_s[0]

	def find_all_global(self, pattern):
		"""
		Searches for the pattern in the whole process memory space and returns a list of addresses where the pattern begins.
		This is exhaustive!
		"""
		return self.reader.search(pattern)

	def get_ptr(self, pos):
		self.move(pos)
		return self.read_uint()
		#raw_data = self.read(pos, self.sizeof_ptr)
		#return struct.unpack(self.unpack_ptr, raw_data)[0]

	def get_ptr_with_offset(self, pos):
		if self.reader.sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.AMD64:
			self.move(pos)
			ptr = int.from_bytes(self.read(4), byteorder = 'little', signed = True)
			return pos + 4 + ptr
		else:
			self.move(pos)
			return self.read_uint()

	def find_in_module(self, module_name, pattern, find_first = False, reverse_order = False):
		t = self.reader.search_module(module_name, pattern, find_first = find_first, reverse_order = reverse_order, chunksize = self.segment_chunk_size)
		return t




class MinidumpFileReader:
	def __init__(self, minidumpfile):
		self.modules = minidumpfile.modules.modules
		self.unloaded_modules = []
		if minidumpfile.unloaded_modules is not None:
			self.unloaded_modules = minidumpfile.unloaded_modules.modules

		self.sysinfo = minidumpfile.sysinfo

		if minidumpfile.memory_segments_64:
			self.memory_segments = minidumpfile.memory_segments_64.memory_segments
			self.is_fulldump = True

		else:
			self.memory_segments = minidumpfile.memory_segments.memory_segments
			self.is_fulldump = False

		self.filename = minidumpfile.filename
		self.file_handle = minidumpfile.file_handle

		#reader params
		self.sizeof_long = 4
		self.unpack_long = '<L'
		if minidumpfile.sysinfo.ProcessorArchitecture in [PROCESSOR_ARCHITECTURE.AMD64, PROCESSOR_ARCHITECTURE.AARCH64]:
			self.sizeof_ptr = 8
			self.unpack_ptr = '<Q'
		elif self.sysinfo.ProcessorArchitecture in [PROCESSOR_ARCHITECTURE.INTEL,
				PROCESSOR_ARCHITECTURE.ARM]:
			self.sizeof_ptr = 4
			self.unpack_ptr = '<L'
		else:
			raise Exception('Unknown processor architecture %s! Please fix and submit PR!' % self.sysinfo.ProcessorArchitecture)

	def get_handler(self):
		return self.file_handle

	def get_memory(self):
		return self.memory_segments

	def get_buffered_reader(self, segment_chunk_size = 10*1024):
		return MinidumpBufferedReader(self, segment_chunk_size = segment_chunk_size)

	def get_module_by_name(self, module_name):
		for mod in self.modules:
			if ntpath.basename(mod.name).lower().find(module_name.lower()) != -1:
				return mod
		return None

	def get_unloaded_by_name(self, module_name):
		for mod in self.unloaded_modules:
			if ntpath.basename(mod.name).find(module_name) != -1:
				return mod
		return None

	def search_module(self, module_name, pattern, find_first = False, reverse_order = False, chunksize = 10*1024):
		mod = self.get_module_by_name(module_name)
		if mod is None:
			mod = self.get_unloaded_by_name(module_name)
			if mod is None:
				raise Exception('Could not find module! %s' % module_name)
		
		needles = []
		for ms in self.memory_segments:
			if mod.baseaddress <= ms.start_virtual_address < mod.endaddress:
				needles+= ms.search(pattern, self.file_handle, find_first = find_first, chunksize = chunksize)
				if len(needles) > 0 and find_first is True:
					return needles


		return needles

	def search(self, pattern, find_first = False, chunksize = 10*1024):
		t = []
		for ms in self.memory_segments:
			t+= ms.search(pattern, self.file_handle, find_first = find_first, chunksize = chunksize)

		return t

	def read(self, virt_addr, size):
		for segment in self.memory_segments:
			if segment.inrange(virt_addr):
				return segment.read(virt_addr, size, self.file_handle)
		raise Exception('Address not in memory range! %s' % hex(virt_addr))


```

`src/minidump/minidumpshell.py`:

```py

import cmd
from minidump.minidumpfile import *
from minidump.common_structs import hexdump

def args2int(x):
	if isinstance(x, int):
		return x
	elif isinstance(x, str):
		if x[:2].lower() == '0x':
			return int(x[2:], 16)
		elif x[:2].lower() == '0b':
			return int(x[2:], 2)
		else:
			return int(x)

	else:
		raise Exception('Unknown integer format! %s' % type(x))

class MinidumpShell(cmd.Cmd):
	intro  = 'Welcome to the minidump shell.   Type help or ? to list commands.\n'
	prompt = '[minidump] '
	mini   = None
	reader = None
	hexdump_size = 16

	def do_open(self, filename):
		"""Opens minidump file"""
		self.mini = MinidumpFile.parse(filename)
		self.reader = self.mini.get_reader().get_buffered_reader()

	def do_threads(self, args):
		"""Lists all thread information (if available)"""
		if self.mini.threads is not None:
			print(str(self.mini.threads))
		if self.mini.threads_ex is not None:
			print(str(self.mini.threads_ex))
		if self.mini.thread_info is not None:
			print(str(self.mini.thread_info))

	def do_memory(self, args):
		"""Lists all memory segments"""
		if self.mini.memory_segments is not None:
			print(str(self.mini.memory_segments))
		if self.mini.memory_segments_64 is not None:
			print(str(self.mini.memory_segments_64))
		if self.mini.memory_info is not None:
			print(str(self.mini.memory_info))

	def do_modules(self, args):
		"""Lists all loaded and unloaded module information (if available)"""
		if self.mini.modules is not None:
			print(str(self.mini.modules))
		if self.mini.unloaded_modules is not None:
			print(str(self.mini.unloaded_modules))

	def do_sysinfo(self, args):
		"""Shows sysinfo (if available)"""
		if self.mini.sysinfo is not None:
			print(str(self.mini.sysinfo))

	def do_exception(self, args):
		"""Shows exception information (if available)"""
		if self.mini.exception is not None:
			print(str(self.mini.exception))

	def do_comments(self, args):
		"""Lists all comments (if any)"""
		if self.mini.comment_a is not None:
			print(str(self.mini.comment_a))
		if self.mini.comment_w is not None:
			print(str(self.mini.comment_w))

	def do_handles(self, args):
		"""Lists all handles (if available)"""
		if self.mini.handles is not None:
			print(str(self.mini.handles))

	def do_misc(self, args):
		"""Lists all miscellaneous info (if available)"""
		if self.mini.misc_info is not None:
			print(str(self.mini.misc_info))

	#### Exit aliases
	def do_quit(self, args):
		"""Quit"""
		return True
	def do_exit(self, args):
		"""Quit"""
		return self.do_quit(None)
	def do_q(self, args):
		"""Quit"""
		return self.do_quit(None)

	###### READER
	def do_printsize(self, printsize):
		"""Changes the hexdump print size to the given bytes/line size (default: 16)"""
		self.hexdump_size = args2int(printsize)

	def update_prompt(self, args):
		pos = self.reader.tell()
		current_segment_start = self.reader.current_segment.start_address
		segment_relative_position = pos - current_segment_start
		self.prompt = "[%s %s+%s] " % (hex(pos), hex(current_segment_start), hex(segment_relative_position))

	def do_tell(self, args):
		"""Shows/refreshes the current position in the process' virtual memory space"""
		x = self.reader.tell()
		if x is None:
			print('Reader not yet positioned! Issue a "move" command with the desired memory address!')
		print(hex(x))
	
	def do_move(self, position):
		"""Sets the current position in the process' virtual memory space"""
		pos = args2int(position)
		self.reader.move(pos)
		self.update_prompt(None)

	def do_read(self, count):
		"""Performs a read of 'count' bytes from the current position and updates the cursor with the bytes read"""
		count = args2int(count)
		pos_before = self.reader.tell()
		data = self.reader.read(count)
		print(hexdump( data, length=self.hexdump_size, sep='.', start = pos_before))
		self.update_prompt(None)

	def do_readi(self, args):
		"""Reads a signed integer starting the current position and updates the cursor with the bytes read. The integer size is determined automatically by the processor architecture information from the dump file"""
		data = self.reader.read_int()
		print('D: %s' % data)
		print('H: %s' % hex(data))
		self.update_prompt(None)

	def do_readui(self, args):
		"""Reads an unsigned integer starting the current position and updates the cursor with the bytes read. The integer size is determined automatically by the processor architecture information from the dump file"""
		data = self.reader.read_uint()
		print('D: %s' % data)
		print('H: %s' % hex(data))
		self.update_prompt(None)

	def do_peek(self, count):
		"""Performs a read of 'count' bytes from the current position but doesn't update the cursor."""
		count = args2int(count)
		pos_before = self.reader.tell()
		data = self.reader.peek(count)
		print(hexdump( data, length=self.hexdump_size, sep='.', start = pos_before))
		self.update_prompt(None)
	

def main():
	import argparse

	parser = argparse.ArgumentParser(description='A parser for minidumnp files')
	parser.add_argument('-f', '--minidumpfile', help='path to the minidump file of lsass.exe')	
	args = parser.parse_args()

	shell = MinidumpShell()
	if args.minidumpfile:
		shell.do_open(args.minidumpfile)
	shell.cmdloop()

if __name__ == '__main__':
	main()
```

`src/minidump/streams/CommentStreamA.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class CommentStreamA:
	def __init__(self):
		self.data = None

	def to_bytes(self):
		return self.data.encode('ascii')
	
	@staticmethod
	def parse(dir, buff):
		csa = CommentStreamA()
		buff.seek(dir.Location.Rva)
		csa.data = buff.read(dir.Location.DataSize).decode()
		return csa

	@staticmethod
	async def aparse(dir, buff):
		csa = CommentStreamA()
		await buff.seek(dir.Location.Rva)
		csdata = await buff.read(dir.Location.DataSize)
		csa.data = csdata.decode()
		return csa
	
	def __str__(self):
		return 'CommentA: %s' % self.data
```

`src/minidump/streams/CommentStreamW.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class CommentStreamW:
	def __init__(self):
		self.data = None

	def to_bytes(self):
		return self.data.encode('utf-16-le')
	
	@staticmethod
	def parse(dir, buff):
		csa = CommentStreamW()
		buff.seek(dir.Location.Rva)
		csa.data = buff.read(dir.Location.DataSize).decode('utf-16-le')
		return csa
	
	@staticmethod
	async def aparse(dir, buff):
		csa = CommentStreamW()
		await buff.seek(dir.Location.Rva)
		csdata = await buff.read(dir.Location.DataSize)
		csa.data = csdata.decode('utf-16-le')
		return csa
		
	def __str__(self):
		return 'CommentW: %s' % self.data
```

`src/minidump/streams/ContextStream.py`:

```py
#!/usr/bin/env python3

# https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/1507%20Threshold%201/_M128A
class M128A:
    def __init__(self):
        self.Low = 0                                        # 0x0 ULONGLONG
        self.High = 0                                       # 0x8 LONGLONG

    @classmethod
    def parse(cls, buff):
        m128a = cls()

        m128a.Low = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
        m128a.High = int.from_bytes(buff.read(8), byteorder = 'little', signed = True)

        return m128a

    @classmethod
    def parse_array(cls, buff, length):
        arr = []
        for i in range(length):
            arr.append(cls.parse(buff))
        return arr

    def __str__(self):
        s = ""
        s += "Low: %x (%d)" % (self.Low, self.Low)
        s += "High: %x (%d)\n" % (self.High, self.High)
        return s


# https://doxygen.reactos.org/df/d06/sdk_2include_2xdk_2arm_2ke_8h_source.html#l00229
class NEON128(M128A):
    # looks to be the same as M128A
    pass


# https://www.vergiliusproject.com/kernels/x64/Windows%20Vista%20%7C%202008/SP2/_XMM_SAVE_AREA32
class XMM_SAVE_AREA32:
    def __init__(self):
        self.ControlWord = 0                               # 0x0 USHORT 
        self.StatusWord = 0                                # 0x2 USHORT 
        self.TagWord = 0                                   # 0x4 UCHAR 
        self.Reserved1 = 0                                 # 0x5 UCHAR 
        self.ErrorOpcode = 0                               # 0x6 USHORT
        self.ErrorOffset = 0                               # 0x8 ULONG
        self.ErrorSelector = 0                             # 0xc USHORT 
        self.Reserved2 = 0                                 # 0xe USHORT 
        self.DataOffset = 0                                # 0x10 ULONG
        self.DataSelector = 0                              # 0x14 USHORT 
        self.Reserved3 = 0                                 # 0x16 USHORT 
        self.MxCsr = 0                                     # 0x18 ULONG
        self.MxCsr_Mask = 0                                # 0x1c ULONG
        self.FloatRegisters = []                           # 0x20 struct M128A[8]
        self.XmmRegisters = []                             # 0xa0 struct M128A[16]
        self.Reserved4 = []                                # 0x1a0 UCHAR[96]

    @classmethod
    def parse(cls, buff):
        xmm = cls()

        xmm.ControlWord = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.StatusWord = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.TagWord = chr(int.from_bytes(buff.read(1), byteorder = 'little', signed = False))
        xmm.Reserved1 = chr(int.from_bytes(buff.read(1), byteorder = 'little', signed = False))
        xmm.ErrorOpcode = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.ErrorOffset = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        xmm.ErrorSelector = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.Reserved2 = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.DataOffset = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        xmm.DataSelector = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.Reserved3 = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
        xmm.MxCsr = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        xmm.MxCsr_Mask = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        xmm.FloatRegisters = M128A.parse_array(buff, 8)
        xmm.XmmRegisters = M128A.parse_array(buff, 16)
        xmm.Reserved4 = [
            chr(int.from_bytes(buff.read(1), byteorder = 'little', signed = False))
            for i in range(96)
        ]

        return xmm

    def __str__(self):
        s = ""
        s += "%s: %x (%d)\n" % ("ControlWord", self.ControlWord, self.ControlWord)
        s += "%s: %x (%d)\n" % ("StatusWord", self.StatusWord, self.StatusWord)
        s += "%s: %s\n" % ("TagWord", self.TagWord)
        s += "%s: %s\n" % ("Reserved1", self.Reserved1)
        s += "%s: %x (%d)\n" % ("ErrorOpcode", self.ErrorOpcode, self.ErrorOpcode)
        s += "%s: %x (%d)\n" % ("ErrorOffset", self.ErrorOffset, self.ErrorOffset)
        s += "%s: %x (%d)\n" % ("ErrorSelector", self.ErrorSelector, self.ErrorSelector)
        s += "%s: %x (%d)\n" % ("Reserved2", self.Reserved2, self.Reserved2)
        s += "%s: %x (%d)\n" % ("DataOffset", self.DataOffset, self.DataOffset)
        s += "%s: %x (%d)\n" % ("DataSelector", self.DataSelector, self.DataSelector)
        s += "%s: %x (%d)\n" % ("Reserved3", self.Reserved3, self.Reserved3)
        s += "%s: %x (%d)\n" % ("MxCsr", self.MxCsr, self.MxCsr)
        s += "%s: %x (%d)\n" % ("MxCsr_Mask", self.MxCsr_Mask, self.MxCsr_Mask)
        s += "%s:\n" % ("FloatRegisters:")
        for freg in self.FloatRegisters:
            s += "\t%s" % (freg)
        s += "%s:\n" % ("XmmRegisters")
        for xreg in self.XmmRegisters:
            s += "\t%s" % (xreg)
        s += "%s: %s\n" % ("Reserved4", "".join(self.Reserved4))

        return s


class CTX_DUMMYSTRUCTNAME:
    def __init__(self):
        # all are M128A
        self.Header = []                # [2]
        self.Legacy = []                # [8]
        self.Xmm0 = 0
        self.Xmm1 = 0
        self.Xmm2 = 0
        self.Xmm3 = 0
        self.Xmm4 = 0
        self.Xmm5 = 0
        self.Xmm6 = 0
        self.Xmm7 = 0
        self.Xmm8 = 0
        self.Xmm9 = 0
        self.Xmm10 = 0
        self.Xmm11 = 0
        self.Xmm12 = 0
        self.Xmm13 = 0
        self.Xmm14 = 0
        self.Xmm15 = 0
    
    @classmethod
    def parse(cls, buff):
        dsn = cls()

        dsn.Header = M128A.parse_array(buff, 2)
        dsn.Legacy = M128A.parse_array(buff, 8)
        dsn.Xmm0 = M128A.parse(buff)
        dsn.Xmm1 = M128A.parse(buff)
        dsn.Xmm2 = M128A.parse(buff)
        dsn.Xmm3 = M128A.parse(buff)
        dsn.Xmm4 = M128A.parse(buff)
        dsn.Xmm5 = M128A.parse(buff)
        dsn.Xmm6 = M128A.parse(buff)
        dsn.Xmm7 = M128A.parse(buff)
        dsn.Xmm8 = M128A.parse(buff)
        dsn.Xmm9 = M128A.parse(buff)
        dsn.Xmm10 = M128A.parse(buff)
        dsn.Xmm11 = M128A.parse(buff)
        dsn.Xmm12 = M128A.parse(buff)
        dsn.Xmm13 = M128A.parse(buff)
        dsn.Xmm14 = M128A.parse(buff)
        dsn.Xmm15 = M128A.parse(buff)

        return dsn

    def __str__(self):
        s = ""
        s += "%s:\n" % ("Header")
        for head in self.Header:
            s += "\t%s" % (head)
        s += "%s:\n" % ("Legacy")
        for leg in self.Legacy:
            s += "\t%s" % (leg)
        s += "%s: %s" % ("Xmm0", self.Xmm0)
        s += "%s: %s" % ("Xmm1", self.Xmm1)
        s += "%s: %s" % ("Xmm2", self.Xmm2)
        s += "%s: %s" % ("Xmm3", self.Xmm3)
        s += "%s: %s" % ("Xmm4", self.Xmm4)
        s += "%s: %s" % ("Xmm5", self.Xmm5)
        s += "%s: %s" % ("Xmm6", self.Xmm6)
        s += "%s: %s" % ("Xmm7", self.Xmm7)
        s += "%s: %s" % ("Xmm8", self.Xmm8)
        s += "%s: %s" % ("Xmm9", self.Xmm9)
        s += "%s: %s" % ("Xmm10", self.Xmm10)
        s += "%s: %s" % ("Xmm11", self.Xmm11)
        s += "%s: %s" % ("Xmm12", self.Xmm12)
        s += "%s: %s" % ("Xmm13", self.Xmm13)
        s += "%s: %s" % ("Xmm14", self.Xmm14)
        s += "%s: %s" % ("Xmm15", self.Xmm15)

        return s


class CTX_DUMMYUNIONNAME:
    def __init__(self):
        self.FltSave = []                  # XMM_SAVE_AREA32
        self.Q = []                        # NEON128 [16]
        self.D = []                        # ULONGLONG [32]
        self.DUMMYSTRUCTNAME = []
        self.S = []                        # DWORD [32]
    
    @classmethod
    def parse(cls, buff):
        dun = cls()

        dun.FltSave = XMM_SAVE_AREA32.parse(buff)
        dun.Q = NEON128.parse_array(buff, 16)
        dun.D = [
            int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
            for i in range(32)
        ]
        dun.DUMMYSTRUCTNAME = CTX_DUMMYSTRUCTNAME.parse(buff)
        dun.S = [
            int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
            for i in range(32)
        ]
        return dun

    def __str__(self):
        s = ""
        s += "%s: %s\n" % ("FltSave", self.FltSave)
        s += "%s:\n" % ("Q")
        for q in self.Q:
            s += "\t%s" % (q.__str__())
        for d in self.D:
            s += "\t%d" % (d)
        s += "%s: %s" % ("DUMMYSTRUCTNAME", self.DUMMYSTRUCTNAME)
        s += "%s:\n" %("S")
        for e in self.S:
            s += "\t%d" % (e)

        return s
        

# https:# docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context
class CONTEXT:
    def __init__(self):
        self.P1Home = 0   # DWORD64
        self.P2Home = 0   # DWORD64
        self.P3Home = 0   # DWORD64
        self.P4Home = 0   # DWORD64
        self.P5Home = 0   # DWORD64
        self.P6Home = 0   # DWORD64
        self.ContextFlags = 0   # DWORD
        self.MxCsr = 0   # DWORD
        self.SegCs = 0   # WORD
        self.SegDs = 0   # WORD
        self.SegEs = 0   # WORD
        self.SegFs = 0   # WORD
        self.SegGs = 0   # WORD
        self.SegSs = 0   # WORD
        self.EFlags = 0   # DWORD
        self.Dr0 = 0   # DWORD64
        self.Dr1 = 0   # DWORD64
        self.Dr2 = 0   # DWORD64
        self.Dr3 = 0   # DWORD64
        self.Dr6 = 0   # DWORD64
        self.Dr7 = 0   # DWORD64
        self.Rax = 0   # DWORD64
        self.Rcx = 0   # DWORD64
        self.Rdx = 0   # DWORD64
        self.Rbx = 0   # DWORD64
        self.Rsp = 0   # DWORD64
        self.Rbp = 0   # DWORD64
        self.Rsi = 0   # DWORD64
        self.Rdi = 0   # DWORD64
        self.R8 = 0    # DWORD64
        self.R9 = 0    # DWORD64
        self.R10 = 0   # DWORD64
        self.R11 = 0   # DWORD64
        self.R12 = 0   # DWORD64
        self.R13 = 0   # DWORD64
        self.R14 = 0   # DWORD64
        self.R15 = 0   # DWORD64
        self.Rip = 0   # DWORD64
        self.DUMMYUNIONNAME = None
        
        self.VectorRegister = []         # M128A   [26]
        self.VectorControl = 0           # DWORD64
        self.DebugControl = 0            # DWORD64
        self.LastBranchToRip = 0         # DWORD64
        self.LastBranchFromRip = 0       # DWORD64
        self.LastExceptionToRip = 0      # DWORD64
        self.LastExceptionFromRip = 0    # DWORD64

    @classmethod
    def parse(cls, buff):
        ctx = cls()
        
        ctx.P1Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P2Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P3Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P4Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P5Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.P6Home = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.ContextFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)   # DWORD
        ctx.MxCsr = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)   # DWORD
        ctx.SegCs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegDs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegEs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegFs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegGs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.SegSs = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)   # WORD
        ctx.EFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)   # DWORD
        ctx.Dr0 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr1 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr2 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr3 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr6 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Dr7 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rax = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rcx = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rdx = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rbx = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rsp = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rbp = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rsi = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rdi = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R8 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R9 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R10 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R11 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R12 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R13 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R14 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.R15 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.Rip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.DUMMYUNIONNAME = CTX_DUMMYUNIONNAME.parse(buff)
        
        ctx.VectorRegister = M128A.parse_array(buff, 26)         # M128A   [26]
        ctx.VectorControl =  int.from_bytes(buff.read(8), byteorder = 'little', signed = False)       # DWORD64
        ctx.DebugControl = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)         # DWORD64
        ctx.LastBranchToRip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)      # DWORD64
        ctx.LastBranchFromRip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)    # DWORD64
        ctx.LastExceptionToRip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)   # DWORD64
        ctx.LastExceptionFromRip = int.from_bytes(buff.read(8), byteorder = 'little', signed = False) # DWORD64

        return ctx

    def __str__(self):
        s = "" 
        s += "%s: 0x%x (%d)\n" % ("P1Home",self.P1Home,self.P1Home)
        s += "%s: 0x%x (%d)\n" % ("P2Home",self.P2Home,self.P2Home)
        s += "%s: 0x%x (%d)\n" % ("P3Home",self.P3Home,self.P3Home)
        s += "%s: 0x%x (%d)\n" % ("P4Home",self.P4Home,self.P4Home)
        s += "%s: 0x%x (%d)\n" % ("P5Home",self.P5Home,self.P5Home)
        s += "%s: 0x%x (%d)\n" % ("P6Home",self.P6Home,self.P6Home)
        s += "%s: 0x%x (%d)\n" % ("ContextFlags",self.ContextFlags,self.ContextFlags)
        s += "%s: 0x%x (%d)\n" % ("MxCsr",self.MxCsr,self.MxCsr)
        s += "%s: 0x%x (%d)\n" % ("SegCs",self.SegCs,self.SegCs)
        s += "%s: 0x%x (%d)\n" % ("SegDs",self.SegDs,self.SegDs)
        s += "%s: 0x%x (%d)\n" % ("SegEs",self.SegEs,self.SegEs)
        s += "%s: 0x%x (%d)\n" % ("SegFs",self.SegFs,self.SegFs)
        s += "%s: 0x%x (%d)\n" % ("SegGs",self.SegGs,self.SegGs)
        s += "%s: 0x%x (%d)\n" % ("SegSs",self.SegSs,self.SegSs)
        s += "%s: 0x%x (%d)\n" % ("EFlags",self.EFlags,self.EFlags)
        s += "%s: 0x%x (%d)\n" % ("Dr0",self.Dr0,self.Dr0)
        s += "%s: 0x%x (%d)\n" % ("Dr1",self.Dr1,self.Dr1)
        s += "%s: 0x%x (%d)\n" % ("Dr2",self.Dr2,self.Dr2)
        s += "%s: 0x%x (%d)\n" % ("Dr3",self.Dr3,self.Dr3)
        s += "%s: 0x%x (%d)\n" % ("Dr6",self.Dr6,self.Dr6)
        s += "%s: 0x%x (%d)\n" % ("Dr7",self.Dr7,self.Dr7)
        s += "%s: 0x%x (%d)\n" % ("Rax",self.Rax,self.Rax)
        s += "%s: 0x%x (%d)\n" % ("Rcx",self.Rcx,self.Rcx)
        s += "%s: 0x%x (%d)\n" % ("Rdx",self.Rdx,self.Rdx)
        s += "%s: 0x%x (%d)\n" % ("Rbx",self.Rbx,self.Rbx)
        s += "%s: 0x%x (%d)\n" % ("Rsp",self.Rsp,self.Rsp)
        s += "%s: 0x%x (%d)\n" % ("Rbp",self.Rbp,self.Rbp)
        s += "%s: 0x%x (%d)\n" % ("Rsi",self.Rsi,self.Rsi)
        s += "%s: 0x%x (%d)\n" % ("Rdi",self.Rdi,self.Rdi)
        s += "%s: 0x%x (%d)\n" % ("R8",self.R8,self.R8)
        s += "%s: 0x%x (%d)\n" % ("R9",self.R9,self.R9)
        s += "%s: 0x%x (%d)\n" % ("R10",self.R10,self.R10)
        s += "%s: 0x%x (%d)\n" % ("R11",self.R11,self.R11)
        s += "%s: 0x%x (%d)\n" % ("R12",self.R12,self.R12)
        s += "%s: 0x%x (%d)\n" % ("R13",self.R13,self.R13)
        s += "%s: 0x%x (%d)\n" % ("R14",self.R14,self.R14)
        s += "%s: 0x%x (%d)\n" % ("R15",self.R15,self.R15)
        s += "%s: 0x%x (%d)\n" % ("Rip",self.Rip,self.Rip)
        s += "%s:" % ("DUMMYUNIONNAME")
        s += self.DUMMYUNIONNAME.__str__()

        return s


# https:# docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-wow64_floating_save_area
class WOW64_FLOATING_SAVE_AREA:
    def __init__(self):
        self.ControlWord = 0  # DWORD
        self.StatusWord = 0   # DWORD
        self.TagWord = 0      # DWORD
        self.ErrorOffset = 0  # DWORD
        self.ErrorSelector = 0  # DWORD
        self.DataOffset = 0  # DWORD
        self.DataSelector = 0 # DWORD
        self.RegisterArea = []  # BYTE
        self.Cr0NpxState = 0  # DWORD
    
    @classmethod
    def parse(cls, buff):
        ctx = cls()
        ctx.ControlWord = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.StatusWord = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.TagWord = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.ErrorOffset = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.ErrorSelector = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.DataOffset = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.DataSelector = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.RegisterArea = int.from_bytes(buff.read(80), byteorder = 'little', signed = False)
        ctx.Cr0NpxState = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        return ctx
        
    def __str__(self):
        s = ''
        s += "ControlWord: %x (%d)\n" % (self.ControlWord, self.ControlWord)
        s += "StatusWord: %x (%d)\n" % (self.StatusWord, self.StatusWord)
        s += "TagWord: %x (%d)\n" % (self.TagWord, self.TagWord)
        s += "ErrorOffset: %x (%d)\n" % (self.ErrorOffset, self.ErrorOffset)
        s += "ErrorSelector: %x (%d)\n" % (self.ErrorSelector, self.ErrorSelector)
        s += "DataOffset: %x (%d)\n" % (self.DataOffset, self.DataOffset)
        s += "DataSelector: %x (%d)\n" % (self.DataSelector, self.DataSelector)
        s += "RegisterArea: %s\n" % str(self.RegisterArea)
        s += "Cr0NpxState: %x (%d)" % (self.Cr0NpxState, self.Cr0NpxState)
        return s

# https:# docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-wow64_context
class WOW64_CONTEXT:
    def __init__(self):
        self.ContextFlags = 0   # DWORD
        self.Dr0 = 0   # DWORD
        self.Dr1 = 0   # DWORD
        self.Dr2 = 0   # DWORD
        self.Dr3 = 0   # DWORD
        self.Dr6 = 0   # DWORD
        self.Dr7 = 0   # DWORD
        self.FloatSave = 0   # WOW64_FLOATING_SAVE_AREA
        self.SegGs = 0   # DWORD
        self.SegFs = 0   # DWORD
        self.SegEs = 0   # DWORD
        self.SegDs = 0   # DWORD
        self.Edi = 0   # DWORD
        self.Esi = 0   # DWORD
        self.Ebx = 0   # DWORD
        self.Edx = 0   # DWORD
        self.Ecx = 0   # DWORD
        self.Eax = 0   # DWORD
        self.Ebp = 0   # DWORD
        self.Eip = 0   # DWORD
        self.SegCs = 0   # DWORD
        self.EFlags = 0   # DWORD
        self.Esp = 0   # DWORD
        self.SegSs = 0   # DWORD
        self.ExtendedRegisters = []   # BYTE

    @classmethod
    def parse(cls, buff):
        ctx = cls()

        ctx.ContextFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr0 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr1 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr2 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr3 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr6 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Dr7 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.FloatSave = WOW64_FLOATING_SAVE_AREA.parse(buff)
        ctx.SegGs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegFs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegEs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegDs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Edi = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Esi = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Ebx = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Edx = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Ecx = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Eax = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Ebp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Eip = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegCs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.EFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.Esp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.SegSs = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
        ctx.ExtendedRegisters = [
            int.from_bytes(buff.read(1), byteorder = 'little', signed = False)
            for i in range(512)
        ]
        return ctx

    def __str__(self):
        s = ''
        s += "%s: %x (%d)\n" % ("ContextFlags", self.ContextFlags, self.ContextFlags)
        s += "%s: %x (%d)\n" % ("Dr0", self.Dr0, self.Dr0)
        s += "%s: %x (%d)\n" % ("Dr1", self.Dr1, self.Dr1)
        s += "%s: %x (%d)\n" % ("Dr2", self.Dr2, self.Dr2)
        s += "%s: %x (%d)\n" % ("Dr3", self.Dr3, self.Dr3)
        s += "%s: %x (%d)\n" % ("Dr6", self.Dr6, self.Dr6)
        s += "%s: %x (%d)\n" % ("Dr7", self.Dr7, self.Dr7)
        s += "%s: %s\n" % ("FloatSave", self.FloatSave.__str__())
        s += "%s: %x (%d)\n" % ("SegGs", self.SegGs, self.SegGs)
        s += "%s: %x (%d)\n" % ("SegFs", self.SegFs, self.SegFs)
        s += "%s: %x (%d)\n" % ("SegEs", self.SegEs, self.SegEs)
        s += "%s: %x (%d)\n" % ("SegDs", self.SegDs, self.SegDs)
        s += "%s: %x (%d)\n" % ("Edi", self.Edi, self.Edi)
        s += "%s: %x (%d)\n" % ("Esi", self.Esi, self.Esi)
        s += "%s: %x (%d)\n" % ("Ebx", self.Ebx, self.Ebx)
        s += "%s: %x (%d)\n" % ("Edx", self.Edx, self.Edx)
        s += "%s: %x (%d)\n" % ("Ecx", self.Ecx, self.Ecx)
        s += "%s: %x (%d)\n" % ("Eax", self.Eax, self.Eax)
        s += "%s: %x (%d)\n" % ("Ebp", self.Ebp, self.Ebp)
        s += "%s: %x (%d)\n" % ("Eip", self.Eip, self.Eip)
        s += "%s: %x (%d)\n" % ("SegCs", self.SegCs, self.SegCs)
        s += "%s: %x (%d)\n" % ("EFlags", self.EFlags, self.EFlags)
        s += "%s: %x (%d)\n" % ("Esp", self.Esp, self.Esp)
        s += "%s: %x (%d)\n" % ("SegSs", self.SegSs, self.SegSs)
        s += "%s: %s\n" % ("ExtendedRegisters", str(self.ExtendedRegisters))

        return s

```

`src/minidump/streams/ExceptionStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
# TODO: implement this better, the ExceptionInformation definition is missing on msdn :(

import io
import enum
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680368(v=vs.85).aspx
class MINIDUMP_EXCEPTION_STREAM:
	def __init__(self):
		self.ThreadId = None
		self.alignment = None
		self.ExceptionRecord = None
		self.ThreadContext = None
	
	@staticmethod
	def parse(buff):
		mes = MINIDUMP_EXCEPTION_STREAM()
		mes.ThreadId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mes.alignment = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mes.ExceptionRecord = MINIDUMP_EXCEPTION.parse(buff)
		mes.ThreadContext = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		return mes

	def __str__(self):
		t  = '== MINIDUMP_EXCEPTION_STREAM ==\n'
		t += 'ThreadId: %s\n' % self.ThreadId
		# t += 'alignment: %s\n' % self.alignment
		t += 'ExceptionRecord:\n %s\n' % str(self.ExceptionRecord)
		t += 'ThreadContext: %s\n' % str(self.ThreadContext)
		return t
	
	@staticmethod
	def get_header():
		return [
			'ThreadId',
			*MINIDUMP_EXCEPTION.get_header()
		]
		

	def to_row(self):
		return [
			'0x%08x' % self.ThreadId,
			*self.ExceptionRecord.to_row()
		]

		
class ExceptionCode(enum.Enum):
	# Not a real exception code, it's just a placeholder to prevent the parser from raising an error
	EXCEPTION_UNKNOWN               = 'EXCEPTION_UNKNOWN_CHECK_RAW'
	EXCEPTION_NONE 					= 0x00

	# Linux SIG values (for crashpad generated dumps)
	EXCEPTION_SIGHUP    			= 0x00000001    # Hangup (POSIX)
	EXCEPTION_SIGINT    			= 0x00000002    # Terminal interrupt (ANSI)
	EXCEPTION_SIGQUIT   			= 0x00000003    # Terminal quit (POSIX)
	EXCEPTION_SIGILL    			= 0x00000004    # Illegal instruction (ANSI)
	EXCEPTION_SIGTRAP   			= 0x00000005    # Trace trap (POSIX)
	EXCEPTION_SIGIOT    			= 0x00000006    # IOT Trap (4.2 BSD)
	EXCEPTION_SIGBUS    			= 0x00000007    # BUS error (4.2 BSD)
	EXCEPTION_SIGFPE    			= 0x00000008    # Floating point exception (ANSI)
	EXCEPTION_SIGKILL   			= 0x00000009    # Kill(can't be caught or ignored) (POSIX)
	EXCEPTION_SIGUSR1   			= 0x0000000A   # User defined signal 1 (POSIX)
	EXCEPTION_SIGSEGV   			= 0x0000000B   # Invalid memory segment access (ANSI)
	EXCEPTION_SIGUSR2   			= 0x0000000C   # User defined signal 2 (POSIX)
	EXCEPTION_SIGPIPE   			= 0x0000000D   # Write on a pipe with no reader, Broken pipe (POSIX)
	EXCEPTION_SIGALRM   			= 0x0000000E   # Alarm clock (POSIX)
	EXCEPTION_SIGTERM   			= 0x0000000F   # Termination (ANSI)
	EXCEPTION_SIGSTKFLT 			= 0x00000010   # Stack fault
	EXCEPTION_SIGCHLD   			= 0x00000011   # Child process has stopped or exited, changed (POSIX)
	EXCEPTION_SIGCONTV  			= 0x00000012   # Continue executing, if stopped (POSIX)
	EXCEPTION_SIGSTOP   			= 0x00000013   # Stop executing(can't be caught or ignored) (POSIX)
	EXCEPTION_SIGTSTP   			= 0x00000014   # Terminal stop signal (POSIX)
	EXCEPTION_SIGTTIN   			= 0x00000015   # Background process trying to read, from TTY (POSIX)
	EXCEPTION_SIGTTOU   			= 0x00000016   # Background process trying to write, to TTY (POSIX)
	EXCEPTION_SIGURG    			= 0x00000017   # Urgent condition on socket (4.2 BSD)
	EXCEPTION_SIGXCPU   			= 0x00000018   # CPU limit exceeded (4.2 BSD)
	EXCEPTION_SIGXFSZ   			= 0x00000019   # File size limit exceeded (4.2 BSD)
	EXCEPTION_SIGVTALRM 			= 0x0000001A   # Virtual alarm clock (4.2 BSD)
	EXCEPTION_SIGPROF   			= 0x0000001B   # Profiling alarm clock (4.2 BSD)
	EXCEPTION_SIGWINCH  			= 0x0000001C   # Window size change (4.3 BSD, Sun)
	EXCEPTION_SIGIO     			= 0x0000001D   # I/O now possible (4.2 BSD)
	EXCEPTION_SIGPWR    			= 0x0000001E   # Power failure restart (System V)

	# Standard Windows exception values
	EXCEPTION_ACCESS_VIOLATION 		= 0xC0000005 	# The thread tried to read from or write to a virtual address for which it does not have the appropriate access.
	EXCEPTION_ARRAY_BOUNDS_EXCEEDED = 0xC000008C 	# The thread tried to access an array element that is out of bounds and the underlying hardware supports bounds checking.
	EXCEPTION_BREAKPOINT 			= 0x80000003 	# A breakpoint was encountered.
	EXCEPTION_DATATYPE_MISALIGNMENT = 0x80000002 	# The thread tried to read or write data that is misaligned on hardware that does not provide alignment. For example, 16-bit values must be aligned on 2-byte boundaries; 32-bit values on 4-byte boundaries, and so on.
	EXCEPTION_FLT_DENORMAL_OPERAND 	= 0xC000008D 	# One of the operands in a floating-point operation is denormal. A denormal value is one that is too small to represent as a standard floating-point value.
	EXCEPTION_FLT_DIVIDE_BY_ZERO 	= 0xC000008E	# The thread tried to divide a floating-point value by a floating-point divisor of zero.
	EXCEPTION_FLT_INEXACT_RESULT 	= 0xC000008F	# The result of a floating-point operation cannot be represented exactly as a decimal fraction.
	EXCEPTION_FLT_INVALID_OPERATION = 0xC0000090	# This exception represents any floating-point exception not included in this list.
	EXCEPTION_FLT_OVERFLOW 			= 0xC0000091 	# The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type.
	EXCEPTION_FLT_STACK_CHECK 		= 0xC0000092	# The stack overflowed or underflowed as the result of a floating-point operation.
	EXCEPTION_FLT_UNDERFLOW 		= 0xC0000093	# The exponent of a floating-point operation is less than the magnitude allowed by the corresponding type.
	EXCEPTION_ILLEGAL_INSTRUCTION 	= 0xC000001D	# The thread tried to execute an invalid instruction.
	EXCEPTION_IN_PAGE_ERROR 		= 0xC0000006	# The thread tried to access a page that was not present, and the system was unable to load the page. For example, this exception might occur if a network connection is lost while running a program over the network.
	EXCEPTION_INT_DIVIDE_BY_ZERO 	= 0xC0000094	# The thread tried to divide an integer value by an integer divisor of zero.
	EXCEPTION_INT_OVERFLOW 			= 0xC0000095	# The result of an integer operation caused a carry out of the most significant bit of the result.
	EXCEPTION_INVALID_DISPOSITION 	= 0xC0000026	# An exception handler returned an invalid disposition to the exception dispatcher. Programmers using a high-level language such as C should never encounter this exception.
	EXCEPTION_NONCONTINUABLE_EXCEPTION =0xC0000025  # The thread tried to continue execution after a noncontinuable exception occurred.
	EXCEPTION_PRIV_INSTRUCTION 		= 0xC0000096	# The thread tried to execute an instruction whose operation is not allowed in the current machine mode.
	EXCEPTION_SINGLE_STEP 			= 0x80000004	# A trace trap or other single-instruction mechanism signaled that one instruction has been executed.
	EXCEPTION_STACK_OVERFLOW 		= 0xC00000FD	# The thread used up its stack.
		
#https://msdn.microsoft.com/en-us/library/windows/desktop/ms680367(v=vs.85).aspx
class MINIDUMP_EXCEPTION:
	def __init__(self):
		self.ExceptionCode = None
		self.ExceptionFlags = None
		self.ExceptionRecord = None
		self.ExceptionAddress = None
		self.NumberParameters = None
		self.__unusedAlignment = None
		self.ExceptionInformation = []
		self.ExceptionCode_raw = None
	
	@staticmethod
	def parse(buff):
		me = MINIDUMP_EXCEPTION()
		me.ExceptionCode_raw = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		try:
			me.ExceptionCode = ExceptionCode(me.ExceptionCode_raw)
		except:
			me.ExceptionCode = ExceptionCode.EXCEPTION_UNKNOWN

		me.ExceptionFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		me.ExceptionRecord = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		me.ExceptionAddress = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		me.NumberParameters = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		me.__unusedAlignment = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(me.NumberParameters):
			me.ExceptionInformation.append(int.from_bytes(buff.read(8), byteorder = 'little', signed = False))
			
		return me

	def __str__(self):
		t  = '== MINIDUExceptionInformationMP_EXCEPTION ==\n'
		t += "ExceptionCode : %s\n" % self.ExceptionCode 
		t += "ExceptionFlags : %s\n" % self.ExceptionFlags 
		t += "ExceptionRecord : %s\n" % self.ExceptionRecord
		t += "ExceptionAddress : 0x%x\n" % self.ExceptionAddress
		t += "NumberParameters : %s\n" % self.NumberParameters
		# t += "__unusedAlignment : %s\n" % self.__unusedAlignment
		t += "ExceptionInformation : %s\n" % ";".join("0x%x" % info for info in self.ExceptionInformation)
		return t

	@staticmethod
	def get_header():
		return [
			'ExceptionCode',
			'ExceptionFlags',
			'ExceptionRecord',
			'ExceptionAddress',
			'ExceptionInformation'
		]
		

	def to_row(self):
		return [
			str(self.ExceptionCode),
			'0x%08x' % self.ExceptionFlags,
			'0x%08x' % self.ExceptionRecord,
			'0x%08x' % self.ExceptionAddress,
			str(self.ExceptionInformation)
		]


class ExceptionList:
	def __init__(self):
		self.exception_records = []
	
	@staticmethod
	def parse(dir, buff):
		t = ExceptionList()
	
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))

		# Unfortunately, we don't have a certain way to figure out how many exception records
		# there is in the stream, so we have to fallback on heuristics (EOF or bad data read)
		#
		# NB : 	some tool only read one exception record : https://github.com/GregTheDev/MinidumpExplorer/blob/a6dd974757c16142eefcfff7d99be10b14f87eaf/MinidumpExplorer/MinidumpExplorer/MainForm.cs#L257
		#		but it's incorrect since we can have an exception chain (double fault, exception catched and re-raised, etc.)
		while chunk.tell() < dir.Location.DataSize:
			mes = MINIDUMP_EXCEPTION_STREAM.parse(chunk)

			# a minidump exception stream is usally padded with zeroes
			# so whenever we parse an exception record with the code EXCEPTION_NONE
			# we can stop.
			if mes.ExceptionRecord.ExceptionCode == ExceptionCode.EXCEPTION_NONE:
				break

			t.exception_records.append(mes)
			
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = ExceptionList()
	
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)

		# Unfortunately, we don't have a certain way to figure out how many exception records
		# there is in the stream, so we have to fallback on heuristics (EOF or bad data read)
		#
		# NB : 	some tool only read one exception record : https://github.com/GregTheDev/MinidumpExplorer/blob/a6dd974757c16142eefcfff7d99be10b14f87eaf/MinidumpExplorer/MinidumpExplorer/MainForm.cs#L257
		#		but it's incorrect since we can have an exception chain (double fault, exception catched and re-raised, etc.)
		while chunk.tell() < dir.Location.DataSize:
			mes = MINIDUMP_EXCEPTION_STREAM.parse(chunk)

			# a minidump exception stream is usally padded with zeroes
			# so whenever we parse an exception record with the code EXCEPTION_NONE
			# we can stop.
			if mes.ExceptionRecord.ExceptionCode == ExceptionCode.EXCEPTION_NONE:
				break

			t.exception_records.append(mes)
			
		return t
	
	def to_table(self):
		t = []
		t.append(MINIDUMP_EXCEPTION_STREAM.get_header())
		for ex_record in self.exception_records:
			t.append(ex_record.to_row())
		return t

	def __str__(self):
		return '== ExceptionList ==\n' + construct_table(self.to_table())
	
```

`src/minidump/streams/FunctionTableStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class MINIDUMP_FUNCTION_TABLE_STREAM:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfDescriptor = None
		self.SizeOfNativeDescriptor = None
		self.SizeOfFunctionEntry = None
		self.NumberOfDescriptors = None
		self.SizeOfAlignPad = None
	
	@staticmethod
	def parse(dir, buff):
		mfts = MINIDUMP_FUNCTION_TABLE_STREAM()
		mfts.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.SizeOfDescriptor = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.SizeOfNativeDescriptor = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.SizeOfFunctionEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.NumberOfDescriptors = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mfts.SizeOfAlignPad = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			
		return mfts
```

`src/minidump/streams/HandleDataStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
import enum
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680372(v=vs.85).aspx
class MINIDUMP_HANDLE_DATA_STREAM:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfDescriptor = None
		self.NumberOfDescriptors = None
		self.Reserved = None
	
	@staticmethod
	def parse(buff):
		mhds = MINIDUMP_HANDLE_DATA_STREAM()
		mhds.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.SizeOfDescriptor = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.NumberOfDescriptors = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.Reserved = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			
		return mhds
	
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680374(v=vs.85).aspx
class MINIDUMP_HANDLE_DESCRIPTOR:
	size = 32
	def __init__(self):
		self.Handle = None
		self.TypeNameRva = None
		self.ObjectNameRva = None
		self.Attributes = None
		self.GrantedAccess = None
		self.HandleCount = None
		self.PointerCount = None
	
	@staticmethod
	def parse(buff):
		mhd = MINIDUMP_HANDLE_DESCRIPTOR()
		mhd.Handle = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mhd.TypeNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.ObjectNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.Attributes = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.GrantedAccess = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.HandleCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.PointerCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		
		return mhd
		
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680373(v=vs.85).aspx
class MINIDUMP_HANDLE_DESCRIPTOR_2:	
	def __init__(self):
		self.Handle = None
		self.TypeNameRva = None
		self.ObjectNameRva = None
		self.Attributes = None
		self.GrantedAccess = None
		self.HandleCount = None
		self.PointerCount = None
		self.ObjectInfoRva = None
		self.Reserved0 = None
	
	@staticmethod
	def parse(buff):
		mhd = MINIDUMP_HANDLE_DESCRIPTOR_2()
		mhd.Handle = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mhd.TypeNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.ObjectNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.Attributes = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.GrantedAccess = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.HandleCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.PointerCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.ObjectInfoRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhd.Reserved0 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return mhd

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680376(v=vs.85).aspx
class MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE(enum.Enum): 
	MiniHandleObjectInformationNone = 0
	MiniThreadInformation1 = 1
	MiniMutantInformation1 = 2
	MiniMutantInformation2 = 3
	MiniProcessInformation1 = 4
	MiniProcessInformation2 = 5
	

class MINIDUMP_HANDLE_OBJECT_INFORMATION:
	def __init__(self):
		self.NextInfoRva = None
		self.InfoType = None
		self.SizeOfInfo = None
		
		#high-level, delete this when documentation becomes available!
		self.info_bytes = None
	
	@staticmethod
	def parse(buff):
		mhoi = MINIDUMP_HANDLE_OBJECT_INFORMATION()
		mhoi.NextInfoRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhoi.InfoType = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhoi.SizeOfInfo = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhoi.info_bytes = buff.read(mhoi.SizeOfInfo)
		return mhoi

	@staticmethod
	async def aparse(buff):
		mhoi = MINIDUMP_HANDLE_OBJECT_INFORMATION()
		t = await buff.read(4)
		mhoi.NextInfoRva = int.from_bytes(t, byteorder = 'little', signed = False)
		t = await buff.read(4)
		mhoi.InfoType = int.from_bytes(t, byteorder = 'little', signed = False)
		t = await buff.read(4)
		mhoi.SizeOfInfo = int.from_bytes(t, byteorder = 'little', signed = False)
		mhoi.info_bytes = await buff.read(mhoi.SizeOfInfo)
		return mhoi
		
class MinidumpHandleObjectInformation:
	def __init__(self):
		self.NextInfo = None
		self.InfoType = None
		self.SizeOfInfo = None
		self.info_bytes = None
	
	@staticmethod
	def parse(mhoi):
		t = MinidumpHandleObjectInformation()
		t.InfoType = mhoi.InfoType
		t.SizeOfInfo = mhoi.SizeOfInfo
		t.info_bytes = mhoi.info_bytes
		return t
	
	def __str__(self):
		return self.info_bytes.hex()
	
	
		
class MinidumpHandleDescriptor:
	def __init__(self):
		self.Handle = None
		self.TypeName = None
		self.ObjectName = None
		self.Attributes = None
		self.GrantedAccess = None
		self.HandleCount = None
		self.PointerCount = None
		self.ObjectInfos = []
	
	@staticmethod
	def parse(t, buff):
		mhd = MinidumpHandleDescriptor()
		mhd.Handle = t.Handle
		if t.TypeNameRva != 0:
			mhd.TypeName = MINIDUMP_STRING.get_from_rva(t.TypeNameRva, buff)
		if t.ObjectNameRva != 0:
			mhd.ObjectName = MINIDUMP_STRING.get_from_rva(t.ObjectNameRva, buff)
		mhd.Attributes = t.Attributes
		mhd.GrantedAccess = t.GrantedAccess
		mhd.HandleCount = t.HandleCount
		mhd.PointerCount = t.PointerCount
		if isinstance(t, MINIDUMP_HANDLE_DESCRIPTOR_2):
			if t.ObjectInfoRva is not None and t.ObjectInfoRva != 0:
				MinidumpHandleDescriptor.walk_objectinfo(mhd, t.ObjectInfoRva, buff)
		return mhd

	@staticmethod
	async def aparse(t, buff):
		mhd = MinidumpHandleDescriptor()
		mhd.Handle = t.Handle
		if t.TypeNameRva != 0:
			mhd.TypeName = await MINIDUMP_STRING.aget_from_rva(t.TypeNameRva, buff)
		if t.ObjectNameRva != 0:
			mhd.ObjectName = await MINIDUMP_STRING.aget_from_rva(t.ObjectNameRva, buff)
		mhd.Attributes = t.Attributes
		mhd.GrantedAccess = t.GrantedAccess
		mhd.HandleCount = t.HandleCount
		mhd.PointerCount = t.PointerCount
		if isinstance(t, MINIDUMP_HANDLE_DESCRIPTOR_2):
			if t.ObjectInfoRva is not None and t.ObjectInfoRva != 0:
				await MinidumpHandleDescriptor.awalk_objectinfo(mhd, t.ObjectInfoRva, buff)
		return mhd
	
	@staticmethod
	def walk_objectinfo(mhd, start, buff):
		while start is not None and start != 0:
			buff.seek(start)
			mhoi = MINIDUMP_HANDLE_OBJECT_INFORMATION.parse(buff)
			t = MinidumpHandleObjectInformation.parse(mhoi)
			mhd.ObjectInfos.append(t)
			start = t.NextInfo

	@staticmethod
	async def awalk_objectinfo(mhd, start, buff):
		while start is not None and start != 0:
			await buff.seek(start)
			mhoi = await MINIDUMP_HANDLE_OBJECT_INFORMATION.aparse(buff)
			t = MinidumpHandleObjectInformation.parse(mhoi)
			mhd.ObjectInfos.append(t)
			start = t.NextInfo
		
		
	def __str__(self):
		t = '== MinidumpHandleDescriptor == \n'
		t += 'Handle 0x%08x ' % self.Handle
		t += 'TypeName %s ' % self.TypeName
		t += 'ObjectName %s ' % self.ObjectName
		t += 'Attributes %s ' % self.Attributes
		t += 'GrantedAccess %s ' % self.GrantedAccess
		t += 'HandleCount %s ' % self.HandleCount
		t += 'PointerCount %s ' % self.PointerCount
		for oi in self.ObjectInfos:
			t += str(oi)
		return t
		
class MinidumpHandleDataStream:
	def __init__(self):
		self.header = None
		self.handles = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpHandleDataStream()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		t.header = MINIDUMP_HANDLE_DATA_STREAM.parse(chunk)
		for _ in range(t.header.NumberOfDescriptors):
			if t.header.SizeOfDescriptor == MINIDUMP_HANDLE_DESCRIPTOR.size:
				mhd = MINIDUMP_HANDLE_DESCRIPTOR.parse(chunk)
				t.handles.append(MinidumpHandleDescriptor.parse(mhd, buff))
			else:
				mhd = MINIDUMP_HANDLE_DESCRIPTOR_2.parse(chunk)
				t.handles.append(MinidumpHandleDescriptor.parse(mhd, buff))
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpHandleDataStream()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		t.header = MINIDUMP_HANDLE_DATA_STREAM.parse(chunk)
		for _ in range(t.header.NumberOfDescriptors):
			if t.header.SizeOfDescriptor == MINIDUMP_HANDLE_DESCRIPTOR.size:
				mhd = MINIDUMP_HANDLE_DESCRIPTOR.parse(chunk)
				r = await MinidumpHandleDescriptor.aparse(mhd, buff)
				t.handles.append(r)
			else:
				mhd = MINIDUMP_HANDLE_DESCRIPTOR_2.parse(chunk)
				r = await MinidumpHandleDescriptor.aparse(mhd, buff)
				t.handles.append(r)
		return t
		
	def __str__(self):
		t  = '== MinidumpHandleDataStream ==\n'
		for handle in self.handles:
			t += str(handle)
		return t
```

`src/minidump/streams/HandleOperationListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class MINIDUMP_HANDLE_OPERATION_LIST:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfEntry = None
		self.NumberOfEntries = None
		self.Reserved = None
	
	@staticmethod
	def parse(dir, buff):
		mhds = MINIDUMP_HANDLE_OPERATION_LIST()
		mhds.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.SizeOfEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.NumberOfEntries = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.Reserved = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			
		return mhds
		
```

`src/minidump/streams/JavaScriptDataStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
#TODO: MSDN gives no info
```

`src/minidump/streams/LastReservedStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
class MINIDUMP_USER_STREAM:
	def __init__(self):
		self.Type = None
		self.BufferSize = None
		self.Buffer = None
	
	@staticmethod
	def parse(buff):
		mus = MINIDUMP_USER_STREAM()
		mus.Type = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mus.BufferSize = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		#this type is PVOID, not sure on the size
		mus.Buffer = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			
		return mus
```

`src/minidump/streams/Memory64ListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680387(v=vs.85).aspx
class MINIDUMP_MEMORY64_LIST:
	def __init__(self):
		self.NumberOfMemoryRanges = None
		self.BaseRva = None
		self.MemoryRanges = []

	def get_size(self):
		return 8 + 8 + len(self.MemoryRanges) * MINIDUMP_MEMORY_DESCRIPTOR64().get_size()

	def to_bytes(self):
		t = len(self.MemoryRanges).to_bytes(8, byteorder = 'little', signed = False)
		t += self.BaseRva.to_bytes(8, byteorder = 'little', signed = False)
		for memrange in self.MemoryRanges:
			t += memrange.to_bytes()
		return t
	
	@staticmethod
	def parse(buff):
		mml = MINIDUMP_MEMORY64_LIST()
		mml.NumberOfMemoryRanges = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mml.BaseRva = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		for _ in range(mml.NumberOfMemoryRanges):
			mml.MemoryRanges.append(MINIDUMP_MEMORY_DESCRIPTOR64.parse(buff))
		
		return mml
		
	def __str__(self):
		t  = '== MINIDUMP_MEMORY64_LIST ==\n'
		t += 'NumberOfMemoryRanges: %s\n' % self.NumberOfMemoryRanges
		t += 'BaseRva: %s\n' % self.BaseRva
		for i in range(self.NumberOfMemoryRanges):
			t += str(self.MemoryRanges[i]) + '\n'
		return t


# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680384(v=vs.85).aspx
class MINIDUMP_MEMORY_DESCRIPTOR64:
	def __init__(self):
		self.StartOfMemoryRange = None
		self.DataSize = None

	def get_size(self):
		return 16

	def to_bytes(self):
		t = self.StartOfMemoryRange.to_bytes(8, byteorder = 'little', signed = False)
		t += self.DataSize.to_bytes(8, byteorder = 'little', signed = False)
		return t
		
	@staticmethod
	def parse(buff):
		md = MINIDUMP_MEMORY_DESCRIPTOR64()
		md.StartOfMemoryRange = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		md.DataSize = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		return md
		
	def __str__(self):
		t = 'Start: %s' % hex(self.StartOfMemoryRange)
		t += 'Size: %s' % self.DataSize
		return t

class MinidumpMemory64List:
	def __init__(self):
		self.memory_segments = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpMemory64List()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_MEMORY64_LIST.parse(chunk)
		rva = mtl.BaseRva
		for mod in mtl.MemoryRanges:
			t.memory_segments.append(MinidumpMemorySegment.parse_full(mod, rva))
			rva += mod.DataSize
		return t

	@staticmethod
	async def aparse(dir, buff):
		mml = MinidumpMemory64List()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_MEMORY64_LIST.parse(chunk)
		rva = mtl.BaseRva
		for mod in mtl.MemoryRanges:
			ms = MinidumpMemorySegment.parse_full(mod, rva)
			mml.memory_segments.append(ms)
			rva += mod.DataSize
		return mml
		
	def to_table(self):
		t = []
		t.append(MinidumpMemorySegment.get_header())
		for mod in self.memory_segments:
			t.append(mod.to_row())
		return t
		
	def __str__(self):
		return '== MinidumpMemory64List ==\n' + construct_table(self.to_table())
	
```

`src/minidump/streams/MemoryInfoListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
import enum
from minidump.common_structs import * 

class AllocationProtect(enum.Enum):
	NONE = 0
	PAGE_EXECUTE = 0x10 #Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation.
						#This flag is not supported by the CreateFileMapping function.

	PAGE_EXECUTE_READ = 0x20 #Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation.
							 #Windows Server 2003 and Windows XP:  This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.

	PAGE_EXECUTE_READWRITE = 0x40 #Enables execute, read-only, or read/write access to the committed region of pages.#Windows Server 2003 and Windows XP:  This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.
	PAGE_EXECUTE_WRITECOPY = 0x80 #Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_EXECUTE_READWRITE, and the change is written to the new page.
	#This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.
	#Windows Vista, Windows Server 2003 and Windows XP:  This attribute is not supported by the CreateFileMapping function until Windows Vista with SP1 and Windows Server 2008.

	PAGE_NOACCESS = 0x01 #Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.
	#This flag is not supported by the CreateFileMapping function.

	PAGE_READONLY = 0x02 #Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If Data Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation.
	PAGE_READWRITE = 0x04 #Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
	PAGE_WRITECOPY = 0x08 #Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_READWRITE, and the change is written to the new page. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
							#This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.

	PAGE_TARGETS_INVALID = 0x40000000
	#Sets all locations in the pages as invalid targets for CFG. Used along with any execute page protection like PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE and PAGE_EXECUTE_WRITECOPY. Any indirect call to locations in those pages will fail CFG checks and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.
	#This flag is not supported by the VirtualProtect or CreateFileMapping functions.

	PAGE_TARGETS_NO_UPDATE = 0x40000000 #Pages in the region will not have their CFG information updated while the protection changes for VirtualProtect. For example, if the pages in the region was allocated using PAGE_TARGETS_INVALID, then the invalid information will be maintained while the page protection changes. This flag is only valid when the protection changes to an executable type like PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE and PAGE_EXECUTE_WRITECOPY. The default behavior for VirtualProtect protection change to executable is to mark all locations as valid call targets for CFG.
	#The following are modifiers that can be used in addition to the options provided in the previous table, except as noted.
	#Constant/value	Description

	PAGE_GUARD = 0x100 #Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION exception and turn off the guard page status. Guard pages thus act as a one-time access alarm. For more information, see Creating Guard Pages.
	#When an access attempt leads the system to turn off guard page status, the underlying page protection takes over.
	#If a guard page exception occurs during a system service, the service typically returns a failure status indicator.
	#This value cannot be used with PAGE_NOACCESS.
	#This flag is not supported by the CreateFileMapping function.

	PAGE_NOCACHE = 0x200
	#Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
	#The PAGE_NOCACHE flag cannot be used with the PAGE_GUARD, PAGE_NOACCESS, or PAGE_WRITECOMBINE flags.
	#The PAGE_NOCACHE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable non-cached memory access for shared memory, specify the SEC_NOCACHE flag when calling the CreateFileMapping function.
	PAGE_WRITECOMBINE = 0x400 #Sets all pages to be write-combined.
	#Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped as write-combined can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
	#The PAGE_WRITECOMBINE flag cannot be specified with the PAGE_NOACCESS, PAGE_GUARD, and PAGE_NOCACHE flags.
	#The PAGE_WRITECOMBINE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable write-combined memory access for shared memory, specify the SEC_WRITECOMBINE flag when calling the CreateFileMapping function.
	#Windows Server 2003 and Windows XP:  This flag is not supported until Windows Server 2003 with SP1.
	
class MemoryType(enum.Enum):
	MEM_IMAGE = 0x1000000 #Indicates that the memory pages within the region are mapped into the view of an image section.
	MEM_MAPPED = 0x40000 #Indicates that the memory pages within the region are mapped into the view of a section.
	MEM_PRIVATE = 0x20000 #Indicates that the memory pages within the region are private (that is, not shared by other processes).
class MemoryState(enum.Enum):
	MEM_COMMIT = 0x1000 #Indicates committed pages for which physical storage has been allocated, either in memory or in the paging file on disk.
	MEM_FREE = 0x10000 #Indicates free pages not accessible to the calling process and available to be allocated. For free pages, the information in the AllocationBase, AllocationProtect, Protect, and Type members is undefined.
	MEM_RESERVE = 0x2000 #Indicates reserved pages where a range of the process's virtual address space is reserved without any physical storage being allocated. For reserved pages, the information in the Protect member is undefined.


# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680385(v=vs.85).aspx
class MINIDUMP_MEMORY_INFO_LIST:
	def __init__(self):
		self.SizeOfHeader = 16
		self.SizeOfEntry = 48
		self.NumberOfEntries = None
		self.entries = []

	def get_size(self):
		return self.SizeOfHeader + len(self.entries)*MINIDUMP_MEMORY_INFO().get_size()

	def to_bytes(self):
		t  = self.SizeOfHeader.to_bytes(4, byteorder = 'little', signed = False)
		t += self.SizeOfEntry.to_bytes(4, byteorder = 'little', signed = False)
		t += len(self.entries).to_bytes(8, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mhds = MINIDUMP_MEMORY_INFO_LIST()
		mhds.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.SizeOfEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mhds.NumberOfEntries = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
			
		return mhds
		
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680386(v=vs.85).aspx	
class MINIDUMP_MEMORY_INFO:
	def __init__(self):
		self.BaseAddress = None
		self.AllocationBase = None
		self.AllocationProtect = None
		self.__alignment1 = 0
		self.RegionSize = None
		self.State = None
		self.Protect = None
		self.Type = None
		self.__alignment2 = 0

	def get_size(self):
		return 8+8+4+4+8+4+4+4+4

	def __str__(self):
		t = ''
		for k in self.__dict__:
			t += '%s : %s\r\n' % (k, str(self.__dict__[k]))
		return t

	def to_bytes(self):
		t = self.BaseAddress.to_bytes(8, byteorder = 'little', signed = False)
		t += self.AllocationBase.to_bytes(8, byteorder = 'little', signed = False)
		t += self.AllocationProtect.to_bytes(4, byteorder = 'little', signed = False)
		t += self.__alignment1.to_bytes(4, byteorder = 'little', signed = False)
		t += self.RegionSize.to_bytes(8, byteorder = 'little', signed = False)
		t += self.State.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Protect.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Type.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.__alignment2.to_bytes(4, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mmi = MINIDUMP_MEMORY_INFO()
		mmi.BaseAddress = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mmi.AllocationBase = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mmi.AllocationProtect = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mmi.__alignment1 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mmi.RegionSize = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		try:
			mmi.State = MemoryState(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except:
			pass
		try:
			mmi.Protect = AllocationProtect(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except:
			pass
		try:
			mmi.Type = MemoryType(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except:
			pass
		mmi.__alignment2 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			
		return mmi
		
class MinidumpMemoryInfo:
	def __init__(self):
		self.BaseAddress = None
		self.AllocationBase = None
		self.AllocationProtect = None
		self.RegionSize = None
		self.State = None
		self.Protect = None
		self.Type = None
	
	@staticmethod
	def parse(t, buff):
		mmi = MinidumpMemoryInfo()
		mmi.BaseAddress = t.BaseAddress
		mmi.AllocationBase = t.AllocationBase
		mmi.AllocationProtect = t.AllocationProtect
		mmi.RegionSize = t.RegionSize
		mmi.State = t.State
		mmi.Protect = t.Protect
		mmi.Type = t.Type
		return mmi
	
	@staticmethod
	def get_header():
		t = [
			'BaseAddress',
			'AllocationBase',
			'AllocationProtect',
			'RegionSize',
			'State',
			'Protect',
			'Type',
		]
		return t

	def to_row(self):
		t = [
			hex(self.BaseAddress),
			hex(self.AllocationBase),
			str(self.AllocationProtect),
			hex(self.RegionSize),
			self.State.name if self.State else 'N/A',
			self.Protect.name if self.Protect else 'N/A',
			self.Type.name if self.Type else 'N/A',
		]
		return t
		
		
class MinidumpMemoryInfoList:
	def __init__(self):
		self.header = None
		self.infos = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpMemoryInfoList()
		buff.seek(dir.Location.Rva)
		data = buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(data)
		t.header = MINIDUMP_MEMORY_INFO_LIST.parse(chunk)
		for _ in range(t.header.NumberOfEntries):
			mi = MINIDUMP_MEMORY_INFO.parse(chunk)
			t.infos.append(MinidumpMemoryInfo.parse(mi, buff))
		
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpMemoryInfoList()
		await buff.seek(dir.Location.Rva)
		data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(data)
		t.header = MINIDUMP_MEMORY_INFO_LIST.parse(chunk)
		for _ in range(t.header.NumberOfEntries):
			mi = MINIDUMP_MEMORY_INFO.parse(chunk)
			t.infos.append(MinidumpMemoryInfo.parse(mi, None))
		
		return t
		
	def to_table(self):
		t = []
		t.append(MinidumpMemoryInfo.get_header())
		for info in self.infos:
			t.append(info.to_row())
		return t
	
	def __str__(self):
		return '== MinidumpMemoryInfoList ==\n' + construct_table(self.to_table())
```

`src/minidump/streams/MemoryListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
from minidump.common_structs import * 

# https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_memory_list
class MINIDUMP_MEMORY_LIST:
	def __init__(self):
		self.NumberOfMemoryRanges = None
		self.MemoryRanges = []

	def to_bytes(self):
		t = len(self.MemoryRanges).to_bytes(4, byteorder = 'little', signed = False)
		for memrange in self.MemoryRanges:
			t += memrange.to_bytes()
		return t
		
	@staticmethod
	def parse(buff):
		mml = MINIDUMP_MEMORY_LIST()
		mml.NumberOfMemoryRanges = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(mml.NumberOfMemoryRanges):
			mml.MemoryRanges.append(MINIDUMP_MEMORY_DESCRIPTOR.parse(buff))
		
		return mml
		
	def __str__(self):
		t  = '== MINIDUMP_MEMORY_LIST ==\n'
		t += 'NumberOfMemoryRanges: %s\n' % self.NumberOfMemoryRanges
		for range in self.MemoryRanges:
			t+= str(range)
		return t

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680384(v=vs.85).aspx		
class MINIDUMP_MEMORY_DESCRIPTOR:
	def __init__(self):
		self.StartOfMemoryRange = None
		self.MemoryLocation = None
		
		#we do not use MemoryLocation but immediately store its fields in this object for easy access
		self.DataSize = None
		self.Rva = None

	def to_bytes(self):
		t = self.StartOfMemoryRange.to_bytes(4, byteorder = 'little', signed = False)
		t += self.MemoryLocation.to_bytes()
		return t
		
	@staticmethod
	def parse(buff):
		md = MINIDUMP_MEMORY_DESCRIPTOR()
		md.StartOfMemoryRange = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		
		#TODO: figure out what the documentation says, the person writign it was probably high...
		# The deal is: RVA sizes differ on where in the file the memory data is stored. but it's not possible to know it up front if we need to read 32 or 64 bytes...
		#
		#if md.StartOfMemoryRange < 0x100000000:
		#	md.MemoryLocation = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		#else:
		#	md.MemoryLocation = MINIDUMP_LOCATION_DESCRIPTOR64.parse(buff)
		
		md.MemoryLocation = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		md.DataSize = md.MemoryLocation.DataSize
		md.Rva = md.MemoryLocation.Rva
		return md
		
	def __str__(self):
		t =  'Start: %s' % hex(self.StartOfMemoryRange)
		t += 'Size: %s' % self.DataSize
		t += 'Rva: %s' % self.Rva
		return t
		
class MinidumpMemoryList:
	def __init__(self):
		self.memory_segments = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpMemoryList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_MEMORY_LIST.parse(chunk)
		for mod in mtl.MemoryRanges:
			t.memory_segments.append(MinidumpMemorySegment.parse_mini(mod, buff))
		return t
	
	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpMemoryList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_MEMORY_LIST.parse(chunk)
		for mod in mtl.MemoryRanges:
			t.memory_segments.append(MinidumpMemorySegment.parse_mini(mod, buff))
		return t
		
	def __str__(self):
		t  = '== MinidumpMemoryList ==\n'
		for mod in self.memory_segments:
			t+= str(mod) + '\n'
		return t
```

`src/minidump/streams/MiscInfoStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
import enum

#https://msdn.microsoft.com/en-us/library/windows/desktop/ms680388(v=vs.85).aspx	
class MinidumpMiscInfo2Flags1(enum.IntFlag):
	MINIDUMP_MISC1_PROCESS_ID = 0x00000001 #ProcessId is used.
	MINIDUMP_MISC1_PROCESS_TIMES = 0x00000002 #ProcessCreateTime, ProcessKernelTime, and ProcessUserTime are used.
	MINIDUMP_MISC1_PROCESSOR_POWER_INFO = 0x00000004 #ProcessorMaxMhz, ProcessorCurrentMhz, ProcessorMhzLimit, ProcessorMaxIdleState, and ProcessorCurrentIdleState are used.

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680389(v=vs.85).aspx
class MinidumpMiscInfoFlags1(enum.IntFlag):
	MINIDUMP_MISC1_PROCESS_ID = 0x00000001 #ProcessId is used.
	MINIDUMP_MISC1_PROCESS_TIMES = 0x00000002 #ProcessCreateTime, ProcessKernelTime, and ProcessUserTime are used.

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680389(v=vs.85).aspx
class MINIDUMP_MISC_INFO:
	size = 24
	def __init__(self):
		self.SizeOfInfo = None
		self.Flags1 = None
		self.ProcessId = None
		self.ProcessCreateTime = None
		self.ProcessUserTime = None
		self.ProcessKernelTime = None
	
	@staticmethod
	def parse(buff):
		mmi = MINIDUMP_MISC_INFO()
		mmi.SizeOfInfo = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mmi.Flags1 = MinidumpMiscInfoFlags1(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		if mmi.Flags1 & MinidumpMiscInfoFlags1.MINIDUMP_MISC1_PROCESS_ID:
			mmi.ProcessId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(4)
		if mmi.Flags1 & MinidumpMiscInfoFlags1.MINIDUMP_MISC1_PROCESS_TIMES:
			mmi.ProcessCreateTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessUserTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessKernelTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(12)
			
		return mmi

#https://msdn.microsoft.com/en-us/library/windows/desktop/ms680388(v=vs.85).aspx		
class MINIDUMP_MISC_INFO_2:
	size = 44
	def __init__(self):
		self.SizeOfInfo = None
		self.Flags1 = None
		self.ProcessId = None
		self.ProcessCreateTime = None
		self.ProcessUserTime = None
		self.ProcessKernelTime = None
		self.ProcessorMaxMhz = None
		self.ProcessorCurrentMhz = None
		self.ProcessorMhzLimit = None
		self.ProcessorMaxIdleState = None
		self.ProcessorCurrentIdleState = None
	
	@staticmethod
	def parse(buff):
		mmi = MINIDUMP_MISC_INFO_2()
		mmi.SizeOfInfo = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mmi.Flags1 = MinidumpMiscInfo2Flags1(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		if mmi.Flags1 & MinidumpMiscInfo2Flags1.MINIDUMP_MISC1_PROCESS_ID:
			mmi.ProcessId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(4)
		if mmi.Flags1 & MinidumpMiscInfo2Flags1.MINIDUMP_MISC1_PROCESS_TIMES:
			mmi.ProcessCreateTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessUserTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessKernelTime = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(12)
		if mmi.Flags1 & MinidumpMiscInfo2Flags1.MINIDUMP_MISC1_PROCESSOR_POWER_INFO:
			mmi.ProcessorMaxMhz = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessorCurrentMhz = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessorMhzLimit = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessorMaxIdleState = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			mmi.ProcessorCurrentIdleState = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			buff.read(20)
		
		return mmi
		
class MinidumpMiscInfo:
	def __init__(self):
		self.ProcessId = None
		self.ProcessCreateTime = None
		self.ProcessUserTime = None
		self.ProcessKernelTime = None
		self.ProcessorMaxMhz = None
		self.ProcessorCurrentMhz = None
		self.ProcessorMhzLimit = None
		self.ProcessorMaxIdleState = None
		self.ProcessorCurrentIdleState = None
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpMiscInfo()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		if dir.Location.DataSize == MINIDUMP_MISC_INFO.size:
			misc = MINIDUMP_MISC_INFO.parse(chunk)
			t.ProcessId = misc.ProcessId
			t.ProcessCreateTime = misc.ProcessCreateTime
			t.ProcessUserTime = misc.ProcessUserTime
			t.ProcessKernelTime = misc.ProcessKernelTime
		else:
			misc = MINIDUMP_MISC_INFO_2.parse(chunk)
			t.ProcessId = misc.ProcessId
			t.ProcessCreateTime = misc.ProcessCreateTime
			t.ProcessUserTime = misc.ProcessUserTime
			t.ProcessKernelTime = misc.ProcessKernelTime
			t.ProcessorMaxMhz = misc.ProcessorMaxMhz
			t.ProcessorCurrentMhz = misc.ProcessorCurrentMhz
			t.ProcessorMhzLimit = misc.ProcessorMhzLimit
			t.ProcessorMaxIdleState = misc.ProcessorMaxIdleState
			t.ProcessorCurrentIdleState = misc.ProcessorCurrentIdleState
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpMiscInfo()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		if dir.Location.DataSize == MINIDUMP_MISC_INFO.size:
			misc = MINIDUMP_MISC_INFO.parse(chunk)
			t.ProcessId = misc.ProcessId
			t.ProcessCreateTime = misc.ProcessCreateTime
			t.ProcessUserTime = misc.ProcessUserTime
			t.ProcessKernelTime = misc.ProcessKernelTime
		else:
			misc = MINIDUMP_MISC_INFO_2.parse(chunk)
			t.ProcessId = misc.ProcessId
			t.ProcessCreateTime = misc.ProcessCreateTime
			t.ProcessUserTime = misc.ProcessUserTime
			t.ProcessKernelTime = misc.ProcessKernelTime
			t.ProcessorMaxMhz = misc.ProcessorMaxMhz
			t.ProcessorCurrentMhz = misc.ProcessorCurrentMhz
			t.ProcessorMhzLimit = misc.ProcessorMhzLimit
			t.ProcessorMaxIdleState = misc.ProcessorMaxIdleState
			t.ProcessorCurrentIdleState = misc.ProcessorCurrentIdleState
		return t
		
	def __str__(self):
		t  = '== MinidumpMiscInfo ==\n'
		t += 'ProcessId %s\n' % self.ProcessId
		t += 'ProcessCreateTime %s\n' % self.ProcessCreateTime
		t += 'ProcessUserTime %s\n' % self.ProcessUserTime
		t += 'ProcessKernelTime %s\n' % self.ProcessKernelTime
		t += 'ProcessorMaxMhz %s\n' % self.ProcessorMaxMhz
		t += 'ProcessorCurrentMhz %s\n' % self.ProcessorCurrentMhz
		t += 'ProcessorMhzLimit %s\n' % self.ProcessorMhzLimit
		t += 'ProcessorMaxIdleState %s\n' % self.ProcessorMaxIdleState
		t += 'ProcessorCurrentIdleState %s\n' % self.ProcessorCurrentIdleState
		return t
```

`src/minidump/streams/ModuleListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
from minidump.common_structs import * 

class MinidumpModule:
	def __init__(self):
		self.name = None
		self.baseaddress = None
		self.size = None
		self.endaddress = None
		
		self.versioninfo = None
		self.checksum = None
		self.timestamp = None
		
	@staticmethod
	def parse(mod, buff):
		"""
		mod: MINIDUMP_MODULE
		buff: file handle
		"""
		mm = MinidumpModule()
		mm.baseaddress = mod.BaseOfImage
		mm.size = mod.SizeOfImage
		mm.checksum = mod.CheckSum
		mm.timestamp = mod.TimeDateStamp
		mm.name = MINIDUMP_STRING.get_from_rva(mod.ModuleNameRva, buff)
		mm.versioninfo = mod.VersionInfo
		mm.endaddress = mm.baseaddress + mm.size
		return mm

	@staticmethod
	async def aparse(mod, buff):
		"""
		mod: MINIDUMP_MODULE
		buff: file handle
		"""
		mm = MinidumpModule()
		mm.baseaddress = mod.BaseOfImage
		mm.size = mod.SizeOfImage
		mm.checksum = mod.CheckSum
		mm.timestamp = mod.TimeDateStamp
		mm.name = await MINIDUMP_STRING.aget_from_rva(mod.ModuleNameRva, buff)
		mm.versioninfo = mod.VersionInfo
		mm.endaddress = mm.baseaddress + mm.size
		return mm
		
	def inrange(self, memory_loc):
		return self.baseaddress <= memory_loc < self.endaddress
	
	@staticmethod
	def get_header():
		return [
			'Module name',
			'BaseAddress',
			'Size',
			'Endaddress',
			'Timestamp',
		]
	
	def to_row(self):
		return [
			str(self.name),
			'0x%08x' % self.baseaddress,
			hex(self.size),
			'0x%08x' % self.endaddress,
			'0x%08x' % self.timestamp,
		]
		
		
	def __str__(self):
		return 'Module name: %s BaseAddress: 0x%08x Size: 0x%x Endaddress: 0x%08x' % (self.name, self.baseaddress, self.size, self.endaddress)
		
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms646997(v=vs.85).aspx
class VS_FIXEDFILEINFO:
	def __init__(self):
		self.dwSignature = None
		self.dwStrucVersion = None
		self.dwFileVersionMS = None
		self.dwFileVersionLS = None
		self.dwProductVersionMS = None
		self.dwProductVersionLS = None
		self.dwFileFlagsMask = None
		self.dwFileFlags = None
		self.dwFileOS = None
		self.dwFileType = None
		self.dwFileSubtype = None
		self.dwFileDateMS = None
		self.dwFileDateLS = None

	def get_size(self):
		return 13*4

	def to_bytes(self):
		t = self.dwSignature.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwStrucVersion.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileVersionMS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileVersionLS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwProductVersionMS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwProductVersionLS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileFlagsMask.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileFlags.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileOS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileType.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileSubtype.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileDateMS.to_bytes(4, byteorder = 'little', signed = False)
		t += self.dwFileDateLS.to_bytes(4, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def from_bytes(data):
		return VS_FIXEDFILEINFO.parse(io.BytesIO(data))

	@staticmethod
	def parse(buff):
		vf = VS_FIXEDFILEINFO()
		vf.dwSignature = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwStrucVersion = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileVersionMS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileVersionLS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwProductVersionMS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwProductVersionLS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileFlagsMask = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileFlags = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileOS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileType = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileSubtype = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileDateMS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		vf.dwFileDateLS = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return vf

	def __str__(self):
		t = ''
		for k in self.__dict__:
			t += '%s : %s\r\n' % (k, str(self.__dict__[k]))
		return t

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680392(v=vs.85).aspx
class MINIDUMP_MODULE:
	def __init__(self):
		self.BaseOfImage = None
		self.SizeOfImage = None
		self.CheckSum = 0
		self.TimeDateStamp = None
		self.ModuleNameRva = None
		self.VersionInfo = None
		self.CvRecord = None
		self.MiscRecord = None
		self.Reserved0 = 0
		self.Reserved1 = 0

		#for writer
		self.ModuleName = None

	def get_size(self):
		return 8+4+4+4+4+8+8+VS_FIXEDFILEINFO().get_size() + 2 * MINIDUMP_LOCATION_DESCRIPTOR().get_size()

	def to_bytes(self):
		t = self.BaseOfImage.to_bytes(8, byteorder = 'little', signed = False)
		t += self.SizeOfImage.to_bytes(4, byteorder = 'little', signed = False)
		t += self.CheckSum.to_bytes(4, byteorder = 'little', signed = False)
		t += self.TimeDateStamp.to_bytes(4, byteorder = 'little', signed = False)
		t += self.ModuleNameRva.to_bytes(4, byteorder = 'little', signed = False)
		t += self.VersionInfo.to_bytes()
		t += self.CvRecord.to_bytes()
		t += self.MiscRecord.to_bytes()
		t += self.Reserved0.to_bytes(8, byteorder = 'little', signed = False)
		t += self.Reserved1.to_bytes(8, byteorder = 'little', signed = False)
		return t
		
	@staticmethod
	def parse(buff):
		mm = MINIDUMP_MODULE()
		mm.BaseOfImage = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mm.SizeOfImage = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mm.CheckSum = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mm.TimeDateStamp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mm.ModuleNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mm.VersionInfo = VS_FIXEDFILEINFO.parse(buff)
		mm.CvRecord = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		mm.MiscRecord = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		mm.Reserved0 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mm.Reserved1 = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		return mm

	def __str__(self):
		t = ''
		for k in self.__dict__:
			t += '%s : %s\r\n' % (k, str(self.__dict__[k]))
		return t
  
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680391(v=vs.85).aspx
class MINIDUMP_MODULE_LIST:
	def __init__(self):
		self.NumberOfModules = None
		self.Modules = []

	def get_size(self):
		return 4 + len(self.Modules) * MINIDUMP_MODULE().get_size()

	def to_bytes(self):
		t = len(self.Modules).to_bytes(4, byteorder = 'little', signed = False)
		for module in self.Modules:
			t += module.to_bytes()
		return t
	
	@staticmethod
	def parse(buff):
		mml = MINIDUMP_MODULE_LIST()
		mml.NumberOfModules = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(mml.NumberOfModules):
			mml.Modules.append(MINIDUMP_MODULE.parse(buff))
			
		return mml
		
class MinidumpModuleList:
	def __init__(self):
		self.modules = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpModuleList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_MODULE_LIST.parse(chunk)
		for mod in mtl.Modules:
			t.modules.append(MinidumpModule.parse(mod, buff))
		return t
	
	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpModuleList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_MODULE_LIST.parse(chunk)
		for mod in mtl.Modules:
			x = await MinidumpModule.aparse(mod, buff)
			t.modules.append(x)
		return t
		
	def to_table(self):
		t = []
		t.append(MinidumpModule.get_header())
		for mod in self.modules:
			t.append(mod.to_row())
		return t
		
	def __str__(self):
		t  = '== ModuleList ==\n' + construct_table(self.to_table())
		return t
		
```

`src/minidump/streams/ProcessVmCountersStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
# TODO: MSD article is missing on this stream :(
```

`src/minidump/streams/SystemInfoStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
import enum
import logging
from minidump.common_structs import *

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class PROCESSOR_ARCHITECTURE(enum.Enum):
	AMD64 = 9 #x64 (AMD or Intel)
	ARM = 5 #ARM
	IA64 = 6 #Intel Itanium
	INTEL = 0 #x86
	AARCH64 = 0x8003 #ARM64
	UNKNOWN = 0xffff #Unknown processor
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class PROCESSOR_LEVEL(enum.Enum):
	INTEL_80386 = 3
	INTEL_80486 = 4
	INTEL_PENTIUM = 5
	INTEL_PENTIUM_PRO = 6 #or Pentium II
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class PRODUCT_TYPE(enum.Enum):
	VER_UNIDENTIFIED_PRODUCT 	= 0x0000000 # Crashpad des not set ProductType value on non-Windows systems
	VER_NT_WORKSTATION 			= 0x0000001 # The system is running Windows XP, Windows Vista, Windows 7, or Windows 8.
	VER_NT_DOMAIN_CONTROLLER 	= 0x0000002 # The system is a domain controller.
	VER_NT_SERVER 				= 0x0000003 # The system is a server.

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class PLATFORM_ID(enum.Enum):
	VER_PLATFORM_WIN32s = 0 #Not supported
	VER_PLATFORM_WIN32_WINDOWS = 1 #Not supported.
	VER_PLATFORM_WIN32_NT = 2 #The operating system platform is Windows.

	# source : https://github.com/chromium/crashpad/blob/4b05be4265c0ffacfce26d7db7644ffbf9037696/minidump/minidump_extensions.h#L239
	VER_PLATFORM_CRASHPAD_MAC       = 0x8101
	VER_PLATFORM_CRASHPAD_IOS       = 0x8102
	VER_PLATFORM_CRASHPAD_LINUX 	= 0x8201
	VER_PLATFORM_CRASHPAD_SOLARIS 	= 0x8202
	VER_PLATFORM_CRASHPAD_ANDROID 	= 0x8203
	VER_PLATFORM_CRASHPAD_PS3       = 0x8204
	VER_PLATFORM_CRASHPAD_NACL      = 0x8205
	VER_PLATFORM_CRASHPAD_FUSCHIA 	= 0x8206
	VER_PLATFORM_CRASHPAD_UNKNOWN 	= 0xffffffff

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class SUITE_MASK(enum.IntFlag):
	VER_SUITE_BACKOFFICE = 0x00000004 #Microsoft BackOffice components are installed.
	VER_SUITE_BLADE = 0x00000400 #Windows Server 2003, Web Edition is installed.
	VER_SUITE_COMPUTE_SERVER = 0x00004000 #Windows Server 2003, Compute Cluster Edition is installed.
	VER_SUITE_DATACENTER = 0x00000080 #Windows Server 2008 R2 Datacenter, Windows Server 2008 Datacenter, or Windows Server 2003, Datacenter Edition is installed.
	VER_SUITE_ENTERPRISE = 0x00000002 #Windows Server 2008 R2 Enterprise, Windows Server 2008 Enterprise, or Windows Server 2003, Enterprise Edition is installed.
	VER_SUITE_EMBEDDEDNT = 0x00000040 #Windows Embedded is installed.
	VER_SUITE_PERSONAL = 0x00000200 #Windows XP Home Edition is installed.
	VER_SUITE_SINGLEUSERTS = 0x00000100 #Remote Desktop is supported, but only one interactive session is supported. This value is set unless the system is running in application server mode.
	VER_SUITE_SMALLBUSINESS = 0x00000001 #Microsoft Small Business Server was once installed on the system, but may have been upgraded to another version of Windows.
	VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020 #Microsoft Small Business Server is installed with the restrictive client license in force.
	VER_SUITE_STORAGE_SERVER = 0x00002000 #Windows Storage Server is installed.
	VER_SUITE_TERMINAL = 0x00000010 # Terminal Services is installed. This value is always set. If VER_SUITE_TERMINAL is set but VER_SUITE_SINGLEUSERTS is not set, the system is running in application server mode.


# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680396(v=vs.85).aspx
class MINIDUMP_SYSTEM_INFO:
	def __init__(self):
		self.ProcessorArchitecture = None
		self.ProcessorLevel = None
		self.ProcessorRevision = None
		self.Reserved0 = None
		self.NumberOfProcessors = None
		self.ProductType = None
		self.MajorVersion = None
		self.MinorVersion = None
		self.BuildNumber = None
		self.PlatformId = None
		self.CSDVersionRva = None
		self.Reserved1 = 0
		self.SuiteMask = None
		self.Reserved2 = 0
		self.VendorId = []
		self.VersionInformation = None
		self.FeatureInformation = None
		self.AMDExtendedCpuFeatures = None
		self.ProcessorFeatures = []

		#for wrtier
		self.CSDVersion = None

	def get_size(self):
		# here we cannot tell upfront what the size will be :(
		return len(self.to_bytes())

	def to_bytes(self, data_buffer = None):
		t = self.ProcessorArchitecture.value.to_bytes(2, byteorder = 'little', signed = False)
		t += self.ProcessorLevel.to_bytes(2, byteorder = 'little', signed = False)
		t += self.ProcessorRevision.to_bytes(2, byteorder = 'little', signed = False)
		#missing filed here?
		t += self.NumberOfProcessors.to_bytes(1, byteorder = 'little', signed = False)
		t += self.ProductType.value.to_bytes(1, byteorder = 'little', signed = False)
		t += self.MajorVersion.to_bytes(4, byteorder = 'little', signed = False)
		t += self.MinorVersion.to_bytes(4, byteorder = 'little', signed = False)
		t += self.BuildNumber.to_bytes(4, byteorder = 'little', signed = False)
		t += self.PlatformId.to_bytes(4, byteorder = 'little', signed = False)
		if data_buffer is None:
			t += self.CSDVersionRva.to_bytes(4, byteorder = 'little', signed = False)
		else:
			pos = data_buffer.tell()
			data_buffer.write(100*b'\x00')
			self.CSDVersionRva = data_buffer.tell()
			data_buffer.write(self.CSDVersion.encode('ascii') + b'\x00')
			pos_end = data_buffer.tell()
			data_buffer.seek(pos,0)
			t += self.CSDVersionRva.to_bytes(4, byteorder = 'little', signed = False)
		#missing filed here?
		t += self.SuiteMask.to_bytes(2, byteorder = 'little', signed = False)
		t += self.Reserved2.to_bytes(2, byteorder = 'little', signed = False)
		if self.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.INTEL:
			for vid in self.VendorId:
				t += vid.to_bytes(4, byteorder = 'little', signed = False)
			t += self.VersionInformation.value.to_bytes(4, byteorder = 'little', signed = False)
			t += self.FeatureInformation.value.to_bytes(4, byteorder = 'little', signed = False)
			t += self.AMDExtendedCpuFeatures.value.to_bytes(4, byteorder = 'little', signed = False)
		else:
			for pf in self.ProcessorFeatures:
				t += pf.to_bytes(8, byteorder = 'little', signed = False)

		if data_buffer is None:
			return t
		else:
			data_buffer.write(t)

	@staticmethod
	def parse(buff):
		msi = MINIDUMP_SYSTEM_INFO()
		msi.ProcessorArchitecture = PROCESSOR_ARCHITECTURE(int.from_bytes(buff.read(2), byteorder = 'little', signed = False))
		msi.ProcessorLevel = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		msi.ProcessorRevision = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		#the below field is present in the documentation from MSDN, however is not present in the actual dump
		#msi.Reserved0 = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		msi.NumberOfProcessors = int.from_bytes(buff.read(1), byteorder = 'little', signed = False)
		msi.ProductType = PRODUCT_TYPE(int.from_bytes(buff.read(1), byteorder = 'little', signed = False))
		msi.MajorVersion = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		msi.MinorVersion = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		msi.BuildNumber = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		msi.PlatformId = PLATFORM_ID(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		msi.CSDVersionRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		#msi.Reserved1 = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		msi.SuiteMask = SUITE_MASK(int.from_bytes(buff.read(2), byteorder = 'little', signed = False))
		msi.Reserved2 = int.from_bytes(buff.read(2), byteorder = 'little', signed = False)
		if msi.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.INTEL:
			for _ in range(3):
				msi.VendorId.append(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
			msi.VersionInformation = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			msi.FeatureInformation = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
			msi.AMDExtendedCpuFeatures = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		else:
			for _ in range(2):
				msi.ProcessorFeatures.append(int.from_bytes(buff.read(8), byteorder = 'little', signed = False))

		return msi

	def __str__(self):
		t = ''
		for k in self.__dict__:
			t += '%s : %s\r\n' % (k, str(self.__dict__[k]))
		return t

class MinidumpSystemInfo:
	def __init__(self):
		self.ProcessorArchitecture = None
		self.ProcessorLevel = None
		self.ProcessorRevision = None
		self.NumberOfProcessors = None
		self.ProductType = None
		self.MajorVersion = None
		self.MinorVersion = None
		self.BuildNumber = None
		self.PlatformId = None
		self.CSDVersion = None
		self.SuiteMask = None
		self.VendorId = None
		self.VersionInformation = None
		self.FeatureInformation = None
		self.AMDExtendedCpuFeatures = None
		self.ProcessorFeatures = None

		#extra
		self.OperatingSystem = None

	def guess_os(self):
		if self.MajorVersion == 10 and self.MinorVersion == 0 and self.ProductType == PRODUCT_TYPE.VER_NT_WORKSTATION:
			self.OperatingSystem = "Windows 10"
		elif self.MajorVersion == 10 and self.MinorVersion == 0 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2016 Technical Preview"
		elif self.MajorVersion == 6 and self.MinorVersion == 3 and self.ProductType == self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows 8.1"
		elif self.MajorVersion == 6 and self.MinorVersion == 3 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2012 R2"
		elif self.MajorVersion == 6 and self.MinorVersion == 2 and self.ProductType == self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows 8"
		elif self.MajorVersion == 6 and self.MinorVersion == 2 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2012"
		elif self.MajorVersion == 6 and self.MinorVersion == 1 and self.ProductType == self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows 7"
		elif self.MajorVersion == 6 and self.MinorVersion == 1 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2008 R2"
		elif self.MajorVersion == 6 and self.MinorVersion == 0 and self.ProductType == self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Vista"
		elif self.MajorVersion == 6 and self.MinorVersion == 0 and self.ProductType != self.ProductType.VER_NT_WORKSTATION:
			self.OperatingSystem =  "Windows Server 2008"
		# Can't accurately report on Windows Server 2003/R2
		# elif (MajorVersion == 5 and MinorVersion == 2 and ProductType == self.ProductType.VER_NT_WORKSTATION)
		#	self.OperatingSystem =  "Windows Vista"
		#elif (MajorVersion == 5 and MinorVersion == 2 and ProductType != self.ProductType.VER_NT_WORKSTATION)
		#	self.OperatingSystem =  "Windows Server 2008"
		elif self.MajorVersion == 5 and self.MinorVersion == 1:
			self.OperatingSystem =  "Windows XP"
		elif self.MajorVersion == 5 and self.MinorVersion == 0:
			self.OperatingSystem =  "Windows 2000"

	@staticmethod
	def parse(dir, buff):
		t = MinidumpSystemInfo()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		si = MINIDUMP_SYSTEM_INFO.parse(chunk)
		t.ProcessorArchitecture = si.ProcessorArchitecture
		t.ProcessorLevel = si.ProcessorLevel
		t.ProcessorRevision = si.ProcessorRevision
		t.NumberOfProcessors = si.NumberOfProcessors
		t.ProductType = si.ProductType
		t.MajorVersion = si.MajorVersion
		t.MinorVersion = si.MinorVersion
		t.BuildNumber = si.BuildNumber
		t.PlatformId = si.PlatformId
		t.CSDVersion = MINIDUMP_STRING.get_from_rva(si.CSDVersionRva, buff)
		t.SuiteMask = si.SuiteMask
		t.VendorId = si.VendorId
		t.VersionInformation = si.VersionInformation
		t.FeatureInformation = si.FeatureInformation
		t.AMDExtendedCpuFeatures = si.AMDExtendedCpuFeatures
		t.ProcessorFeatures = si.ProcessorFeatures
		try:
			t.guess_os()
		except Exception as e:
			logging.log(1, 'Failed to guess OS! MajorVersion: %s MinorVersion %s BuildNumber %s ProductType: %s' % (t.MajorVersion, t.MinorVersion, t.BuildNumber, t.ProductType ))
			t.OperatingSystem = None
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpSystemInfo()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		si = MINIDUMP_SYSTEM_INFO.parse(chunk)
		t.ProcessorArchitecture = si.ProcessorArchitecture
		t.ProcessorLevel = si.ProcessorLevel
		t.ProcessorRevision = si.ProcessorRevision
		t.NumberOfProcessors = si.NumberOfProcessors
		t.ProductType = si.ProductType
		t.MajorVersion = si.MajorVersion
		t.MinorVersion = si.MinorVersion
		t.BuildNumber = si.BuildNumber
		t.PlatformId = si.PlatformId
		t.CSDVersion = await MINIDUMP_STRING.aget_from_rva(si.CSDVersionRva, buff)
		t.SuiteMask = si.SuiteMask
		t.VendorId = si.VendorId
		t.VersionInformation = si.VersionInformation
		t.FeatureInformation = si.FeatureInformation
		t.AMDExtendedCpuFeatures = si.AMDExtendedCpuFeatures
		t.ProcessorFeatures = si.ProcessorFeatures
		try:
			t.guess_os()
		except Exception as e:
			logging.log(1, 'Failed to guess OS! MajorVersion: %s MinorVersion %s BuildNumber %s ProductType: %s' % (t.MajorVersion, t.MinorVersion, t.BuildNumber, t.ProductType ))
			t.OperatingSystem = None
		return t


	def __str__(self):
		t = '== System Info ==\n'
		t += 'ProcessorArchitecture %s\n' % self.ProcessorArchitecture
		t += 'OperatingSystem -guess- %s\n' % self.OperatingSystem
		t += 'ProcessorLevel %s\n' % self.ProcessorLevel
		t += 'ProcessorRevision %s\n' % hex(self.ProcessorRevision)
		t += 'NumberOfProcessors %s\n' % self.NumberOfProcessors
		t += 'ProductType %s\n' % self.ProductType
		t += 'MajorVersion %s\n' % self.MajorVersion
		t += 'MinorVersion %s\n' % self.MinorVersion
		t += 'BuildNumber %s\n' % self.BuildNumber
		t += 'PlatformId %s\n' % self.PlatformId
		t += 'CSDVersion: %s\n' % self.CSDVersion
		t += 'SuiteMask %s\n' % self.SuiteMask
		t += 'VendorId %s\n' % ' '.join( [hex(x) for x in self.VendorId] )
		t += 'VersionInformation %s\n' % self.VersionInformation
		t += 'FeatureInformation %s\n' % self.FeatureInformation
		t += 'AMDExtendedCpuFeatures %s\n' % self.AMDExtendedCpuFeatures
		t += 'ProcessorFeatures %s\n' % ' '.join( [hex(x) for x in self.ProcessorFeatures] )

		return t

```

`src/minidump/streams/SystemMemoryInfoStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
# TODO: Not documented in MSDN :(
```

`src/minidump/streams/ThreadExListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
from minidump.common_structs import * 
from minidump.streams.MemoryListStream import MINIDUMP_MEMORY_DESCRIPTOR

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680399(v=vs.85).aspx
class MINIDUMP_THREAD_EX_LIST:
	def __init__(self):
		self.NumberOfThreads = None
		self.Threads = []
	
	@staticmethod
	def parse(buff):
		mtel = MINIDUMP_THREAD_EX_LIST()
		mtel.NumberOfThreads = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(mtel.NumberOfThreads):
			mtel.Threads.append(MINIDUMP_THREAD_EX.parse(buff))
		
		return mtel
		
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680400(v=vs.85).aspx
class MINIDUMP_THREAD_EX:
	def __init__(self):
		self.ThreadId = None
		self.SuspendCount = None
		self.PriorityClass = None
		self.Priority = None
		self.Teb = None
		self.Stack = None
		self.ThreadContext = None
		self.BackingStore = None
	
	@staticmethod
	def parse(buff):
		mte = MINIDUMP_THREAD_EX()
		mte.ThreadId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mte.SuspendCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mte.PriorityClass = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mte.Priority = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mte.Teb = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mte.Stack = MINIDUMP_MEMORY_DESCRIPTOR.parse(buff)
		mte.ThreadContext = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		mte.BackingStore = MINIDUMP_MEMORY_DESCRIPTOR.parse(buff)
		return mte
	
	@staticmethod
	def get_header():
		return [
			'ThreadId',
			'SuspendCount',
			'PriorityClass',
			'Priority',
			'Teb',
			#'Stack',
			#'ThreadContext',
		]
	
	def to_row(self):
		return [
			hex(self.ThreadId),
			str(self.SuspendCount),
			str(self.PriorityClass),
			str(self.Priority),
			hex(self.Teb),
			#self.Stack,
			#self.ThreadContext,
		]
		
		
class MinidumpThreadExList:
	def __init__(self):
		self.threads = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpThreadExList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_THREAD_EX_LIST.parse(chunk)
		t.threads = mtl.Threads
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpThreadExList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_THREAD_EX_LIST.parse(chunk)
		t.threads = mtl.Threads
		return t
	
	def to_table(self):
		t = []
		t.append(MINIDUMP_THREAD_EX.get_header())
		for thread in self.threads:
			t.append(thread.to_row())
		return t
		
	def __str__(self):
		return '== ThreadExList ==\n' + construct_table(self.to_table())	
	
```

`src/minidump/streams/ThreadInfoListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
import enum
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680510(v=vs.85).aspx
class DumpFlags(enum.Enum):
	MINIDUMP_THREAD_INFO_ERROR_THREAD = 0x00000001 #A placeholder thread due to an error accessing the thread. No thread information exists beyond the thread identifier.
	MINIDUMP_THREAD_INFO_EXITED_THREAD = 0x00000004 #The thread has exited (not running any code) at the time of the dump.
	MINIDUMP_THREAD_INFO_INVALID_CONTEXT = 0x00000010 #Thread context could not be retrieved.
	MINIDUMP_THREAD_INFO_INVALID_INFO = 0x00000008 #Thread information could not be retrieved.
	MINIDUMP_THREAD_INFO_INVALID_TEB = 0x00000020 #TEB information could not be retrieved.
	MINIDUMP_THREAD_INFO_WRITING_THREAD = 0x00000002 #This is the thread that called MiniDumpWriteDump.

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680506(v=vs.85).aspx
class MINIDUMP_THREAD_INFO_LIST:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfEntry = None
		self.NumberOfEntries = None
	
	def to_bytes(self):
		t = self.SizeOfHeader.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.SizeOfEntry.to_bytes(4, byteorder = 'little', signed = False)
		t += self.NumberOfEntries.to_bytes(4, byteorder = 'little', signed = False)
		return t

	@staticmethod
	def parse(buff):
		mtil = MINIDUMP_THREAD_INFO_LIST()
		mtil.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mtil.SizeOfEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mtil.NumberOfEntries = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		
		return mtil
		
	
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680510(v=vs.85).aspx
class MINIDUMP_THREAD_INFO:
	def __init__(self):
		self.ThreadId = None
		self.DumpFlags = None
		self.DumpError = None
		self.ExitStatus = None
		self.CreateTime = None
		self.ExitTime = None
		self.KernelTime = None
		self.UserTime = None
		self.StartAddress = None
		self.Affinity = None

	def to_bytes(self):
		t = self.ThreadId.value.to_bytes(4, byteorder = 'little', signed = False)
		if self.DumpFlags:
			t += self.DumpFlags.value.to_bytes(4, byteorder = 'little', signed = False)
		else:
			t += b'\x00'*4
		t += self.DumpError.to_bytes(4, byteorder = 'little', signed = False)
		t += self.ExitStatus.to_bytes(4, byteorder = 'little', signed = False)
		t += self.CreateTime.to_bytes(8, byteorder = 'little', signed = False)
		t += self.ExitTime.to_bytes(8, byteorder = 'little', signed = False)
		t += self.KernelTime.to_bytes(8, byteorder = 'little', signed = False)
		t += self.UserTime.to_bytes(8, byteorder = 'little', signed = False)
		t += self.StartAddress.to_bytes(8, byteorder = 'little', signed = False)
		t += self.Affinity.to_bytes(8, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mti = MINIDUMP_THREAD_INFO()
		mti.ThreadId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		try:
			mti.DumpFlags = DumpFlags(int.from_bytes(buff.read(4), byteorder = 'little', signed = False))
		except:
			pass
		mti.DumpError = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mti.ExitStatus = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mti.CreateTime = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.ExitTime = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.KernelTime = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.UserTime = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.StartAddress = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mti.Affinity = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		return mti
		
class MinidumpThreadInfo:
	def __init__(self):
		self.ThreadId = None
		self.DumpFlags = None
		self.DumpError = None
		self.ExitStatus = None
		self.CreateTime = None
		self.ExitTime = None
		self.KernelTime = None
		self.UserTime = None
		self.StartAddress = None
		self.Affinity = None
	
	@staticmethod
	def parse(t, buff):
		mti = MinidumpThreadInfo()
		mti.ThreadId = t.ThreadId
		mti.DumpFlags = t.DumpFlags
		mti.DumpError = t.DumpError
		mti.ExitStatus = t.ExitStatus
		mti.CreateTime = t.CreateTime
		mti.ExitTime = t.ExitTime
		mti.KernelTime = t.KernelTime
		mti.UserTime = t.UserTime
		mti.StartAddress = t.StartAddress
		mti.Affinity = t.Affinity
		return mti
	
	@staticmethod
	def get_header():
		return [
			'ThreadId',
			'DumpFlags',
			'DumpError',
			'ExitStatus',
			'CreateTime',
			'ExitTime',
			'KernelTime',
			'UserTime',
			'StartAddress',
			'Affinity',
		]
	
	def to_row(self):
		return [
			hex(self.ThreadId),
			str(self.DumpFlags),
			str(self.DumpError),
			hex(self.ExitStatus),
			str(self.CreateTime),
			str(self.ExitTime),
			str(self.KernelTime),
			str(self.UserTime),
			hex(self.StartAddress),
			str(self.Affinity),
		]
		
	def __str__(self):
		return 'ThreadId: %x DumpFlags: %s DumpError: %s ExitStatus: %x CreateTime: %s ExitTime: %s KernelTime: %s UserTime: %s StartAddress: %x Affinity: %d' % \
			(self.ThreadId, self.DumpFlags, self.DumpError, self.ExitStatus, self.CreateTime, self.ExitTime, self.KernelTime, self.UserTime, self.StartAddress, self.Affinity)
		
class MinidumpThreadInfoList:
	def __init__(self):
		self.header = None
		self.infos = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpThreadInfoList()
		buff.seek(dir.Location.Rva)
		data = buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(data)
		t.header = MINIDUMP_THREAD_INFO_LIST.parse(chunk)
		for _ in range(t.header.NumberOfEntries):
			mi = MINIDUMP_THREAD_INFO.parse(chunk)
			t.infos.append(MinidumpThreadInfo.parse(mi, buff))
		
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpThreadInfoList()
		await buff.seek(dir.Location.Rva)
		data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(data)
		t.header = MINIDUMP_THREAD_INFO_LIST.parse(chunk)
		for _ in range(t.header.NumberOfEntries):
			mi = MINIDUMP_THREAD_INFO.parse(chunk)
			t.infos.append(MinidumpThreadInfo.parse(mi, None))
		
		return t
		
	def to_table(self):
		t = []
		t.append(MinidumpThreadInfo.get_header())
		for info in self.infos:
			t.append(info.to_row())
		return t
		
	def __str__(self):
		return '== ThreadInfoList ==\n' + construct_table(self.to_table())	
	
```

`src/minidump/streams/ThreadListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
import io
from minidump.common_structs import * 
from minidump.streams.MemoryListStream import MINIDUMP_MEMORY_DESCRIPTOR

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680515(v=vs.85).aspx
class MINIDUMP_THREAD_LIST:
	def __init__(self):
		self.NumberOfThreads = None
		self.Threads = []

	def to_bytes(self):
		t = len(self.Threads).to_bytes(4, byteorder = 'little', signed = False)
		for th in self.Threads:
			t += th.to_bytes()
		return t
	
	@staticmethod
	def parse(buff):
		mtl = MINIDUMP_THREAD_LIST()
		mtl.NumberOfThreads = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		for _ in range(mtl.NumberOfThreads):
			mtl.Threads.append(MINIDUMP_THREAD.parse(buff))
		return mtl
	
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680517(v=vs.85).aspx	
class MINIDUMP_THREAD:
	def __init__(self):
		self.ThreadId = None
		self.SuspendCount = None
		self.PriorityClass = None
		self.Priority = None
		self.Teb = None
		self.Stack = None
		self.ThreadContext = None

	def to_bytes(self):
		t  = self.ThreadId.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.SuspendCount.to_bytes(4, byteorder = 'little', signed = False)
		t += self.PriorityClass.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Priority.to_bytes(4, byteorder = 'little', signed = False)
		t += self.Teb.to_bytes(8, byteorder = 'little', signed = False)
		t += self.Stack.to_bytes()
		t += self.ThreadContext.to_bytes()
		return t
	
	@staticmethod
	def parse(buff):
		mt = MINIDUMP_THREAD()
		mt.ThreadId = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mt.SuspendCount = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mt.PriorityClass = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mt.Priority = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mt.Teb = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mt.Stack = MINIDUMP_MEMORY_DESCRIPTOR.parse(buff)
		mt.ThreadContext = MINIDUMP_LOCATION_DESCRIPTOR.parse(buff)
		
		return mt
	
	@staticmethod
	def get_header():
		return [
			'ThreadId',
			'SuspendCount',
			'PriorityClass',
			'Priority',
			'Teb',
			#'Stack',
			#'ThreadContext',
		]
	
	def to_row(self):
		return [
			hex(self.ThreadId),
			str(self.SuspendCount),
			str(self.PriorityClass),
			str(self.Priority),
			hex(self.Teb),
			#self.Stack,
			#self.ThreadContext,
		]
		
class MinidumpThreadList:
	def __init__(self):
		self.threads = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpThreadList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		mtl = MINIDUMP_THREAD_LIST.parse(chunk)
		t.threads = mtl.Threads
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpThreadList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		mtl = MINIDUMP_THREAD_LIST.parse(chunk)
		t.threads = mtl.Threads
		return t
		
	def to_table(self):
		t = []
		t.append(MINIDUMP_THREAD.get_header())
		for thread in self.threads:
			t.append(thread.to_row())
		return t
		
	def __str__(self):
		return 'ThreadList\n' + construct_table(self.to_table())
```

`src/minidump/streams/TokenStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#
# TODO: implement this, no MSDN aricle
```

`src/minidump/streams/UnloadedModuleListStream.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

import io
from minidump.common_structs import * 

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680521(v=vs.85).aspx
class MINIDUMP_UNLOADED_MODULE_LIST:
	def __init__(self):
		self.SizeOfHeader = None
		self.SizeOfEntry = None
		self.NumberOfEntries = None

	def to_bytes(self):
		t  = self.SizeOfHeader.value.to_bytes(4, byteorder = 'little', signed = False)
		t += self.SizeOfEntry.to_bytes(4, byteorder = 'little', signed = False)
		t += self.NumberOfEntries.to_bytes(4, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		muml = MINIDUMP_UNLOADED_MODULE_LIST()
		muml.SizeOfHeader = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		muml.SizeOfEntry = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		muml.NumberOfEntries = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return muml
	
# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680523(v=vs.85).aspx
class MINIDUMP_UNLOADED_MODULE:
	def __init__(self):
		self.BaseOfImage = None
		self.SizeOfImage = None
		self.CheckSum = None
		self.TimeDateStamp = None
		self.ModuleNameRva = None

	def to_bytes(self):
		t  = self.BaseOfImage.value.to_bytes(8, byteorder = 'little', signed = False)
		t += self.SizeOfImage.to_bytes(4, byteorder = 'little', signed = False)
		t += self.CheckSum.to_bytes(4, byteorder = 'little', signed = False)
		t += self.TimeDateStamp.to_bytes(4, byteorder = 'little', signed = False)
		t += self.ModuleNameRva.to_bytes(4, byteorder = 'little', signed = False)
		return t
	
	@staticmethod
	def parse(buff):
		mum = MINIDUMP_UNLOADED_MODULE()
		mum.BaseOfImage = int.from_bytes(buff.read(8), byteorder = 'little', signed = False)
		mum.SizeOfImage = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mum.CheckSum = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mum.TimeDateStamp = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		mum.ModuleNameRva = int.from_bytes(buff.read(4), byteorder = 'little', signed = False)
		return mum

class MinidumpUnloadedModule:
	def __init__(self):
		self.name = None
		self.baseaddress = None
		self.size = None
		self.endaddress = None
		self.memorysegments = [] #list of memory segments the module takes place in
		
		self.checksum = None
		self.timestamp = None
	
	@staticmethod
	def parse(mod, buff):
		"""
		mod: MINIDUMP_MODULE
		buff: file handle
		"""
		mm = MinidumpUnloadedModule()
		mm.baseaddress = mod.BaseOfImage
		mm.size = mod.SizeOfImage
		mm.checksum = mod.CheckSum
		mm.timestamp = mod.TimeDateStamp
		mm.name = MINIDUMP_STRING.get_from_rva(mod.ModuleNameRva, buff)
		mm.endaddress = mm.baseaddress + mm.size
		return mm

	@staticmethod
	async def aparse(mod, buff):
		"""
		mod: MINIDUMP_MODULE
		buff: file handle
		"""
		mm = MinidumpUnloadedModule()
		mm.baseaddress = mod.BaseOfImage
		mm.size = mod.SizeOfImage
		mm.checksum = mod.CheckSum
		mm.timestamp = mod.TimeDateStamp
		mm.name = await MINIDUMP_STRING.aget_from_rva(mod.ModuleNameRva, buff)
		mm.endaddress = mm.baseaddress + mm.size
		return mm
		
	def assign_memory_regions(self, segments):
		for segment in segments:
			if self.baseaddress <= segment.start_virtual_address < self.endaddress:
				self.memorysegments.append(segment)
		
	def __str__(self):
		return 'Unloaded Module name: %s Size: %s BaseAddress: %s' % (self.name, hex(self.size), hex(self.baseaddress))	

	@staticmethod
	def get_header():
		return [
			'Module name',
			'BaseAddress',
			'Size',
			'Endaddress',
		]
	
	def to_row(self):
		return [
			str(self.name),
			'0x%08x' % self.baseaddress,
			hex(self.size),
			'0x%08x' % self.endaddress,
		]
		
	
class MinidumpUnloadedModuleList:
	def __init__(self):
		self.modules = []
	
	@staticmethod
	def parse(dir, buff):
		t = MinidumpUnloadedModuleList()
		buff.seek(dir.Location.Rva)
		chunk = io.BytesIO(buff.read(dir.Location.DataSize))
		muml = MINIDUMP_UNLOADED_MODULE_LIST.parse(chunk)
		for _ in range(muml.NumberOfEntries):
			mod = MINIDUMP_UNLOADED_MODULE.parse(chunk)
			t.modules.append(MinidumpUnloadedModule.parse(mod, buff))
		
		return t

	@staticmethod
	async def aparse(dir, buff):
		t = MinidumpUnloadedModuleList()
		await buff.seek(dir.Location.Rva)
		chunk_data = await buff.read(dir.Location.DataSize)
		chunk = io.BytesIO(chunk_data)
		muml = MINIDUMP_UNLOADED_MODULE_LIST.parse(chunk)
		for _ in range(muml.NumberOfEntries):
			mod = MINIDUMP_UNLOADED_MODULE.parse(chunk)
			dr = await MinidumpUnloadedModule.aparse(mod, buff)
			t.modules.append(dr)
		
		return t
		
	def to_table(self):
		t = []
		t.append(MinidumpUnloadedModule.get_header())
		for mod in self.modules:
			t.append(mod.to_row())
		return t
		
	def __str__(self):
		t  = '== UnloadedModuleList ==\n' + construct_table(self.to_table())
		return t
```

`src/minidump/streams/__init__.py`:

```py
from .CommentStreamA import *
from .CommentStreamW import *
from .ContextStream import *
from .ExceptionStream import *
from .FunctionTableStream import *
from .HandleDataStream import *
from .HandleOperationListStream import *
from .JavaScriptDataStream import *
from .LastReservedStream import *
from .Memory64ListStream import *
from .MemoryInfoListStream import *
from .MemoryListStream import *
from .MiscInfoStream import *
from .ModuleListStream import *
from .ProcessVmCountersStream import *
from .SystemInfoStream import *
from .SystemMemoryInfoStream import *
from .ThreadExListStream import *
from .ThreadInfoListStream import *
from .ThreadListStream import *
from .TokenStream import *
from .UnloadedModuleListStream import *



__CommentStreamA__ = ['CommentStreamA']
__CommentStreamW__ = ['CommentStreamW']
__ContextStream__ = ['CONTEXT', 'CTX_DUMMYSTRUCTNAME', 'CTX_DUMMYUNIONNAME', 'M128A', 'NEON128', 'WOW64_CONTEXT', 'WOW64_FLOATING_SAVE_AREA', 'XMM_SAVE_AREA32']
__ExceptionStream__ = ['ExceptionList']
__FunctionTableStream__ = ['MINIDUMP_FUNCTION_TABLE_STREAM']
__HandleDataStream__ = ['MinidumpHandleDataStream','MINIDUMP_HANDLE_DATA_STREAM']
__HandleOperationListStream__ = ['MINIDUMP_HANDLE_OPERATION_LIST']
__JavaScriptDataStream__ = []
__LastReservedStream__ = ['MINIDUMP_USER_STREAM']
__Memory64ListStream__ = ['MinidumpMemory64List','MINIDUMP_MEMORY_DESCRIPTOR64','MINIDUMP_MEMORY64_LIST',]
__MemoryInfoListStream__ = ['MinidumpMemoryInfoList','MINIDUMP_MEMORY_INFO','MINIDUMP_MEMORY_INFO_LIST','MemoryState','MemoryType','AllocationProtect']
__MemoryListStream__ = ['MinidumpMemoryList', 'MINIDUMP_MEMORY_DESCRIPTOR','MINIDUMP_MEMORY_LIST']
__MiscInfoStream__ = ['MinidumpMiscInfo','MINIDUMP_MISC_INFO_2','MINIDUMP_MISC_INFO','MinidumpMiscInfoFlags1','MinidumpMiscInfo2Flags1']
__ModuleListStream__ = ['MinidumpModule','MinidumpModuleList','VS_FIXEDFILEINFO','MINIDUMP_MODULE','MINIDUMP_MODULE_LIST']
__ProcessVmCountersStream__ = []
__SystemInfoStream__ = ['MinidumpSystemInfo','PROCESSOR_ARCHITECTURE','PROCESSOR_LEVEL', 'PRODUCT_TYPE', 'PLATFORM_ID','SUITE_MASK','MINIDUMP_SYSTEM_INFO']
__SystemMemoryInfoStream__ = []
__ThreadExListStream__ = ['MinidumpThreadExList', 'MINIDUMP_THREAD_EX', 'MINIDUMP_THREAD_EX_LIST']
__ThreadInfoListStream__ = ['MinidumpThreadInfoList','MINIDUMP_THREAD_INFO_LIST', 'MINIDUMP_THREAD_INFO', 'DumpFlags']
__ThreadListStream__ = ['MinidumpThreadList','MINIDUMP_THREAD', 'MINIDUMP_THREAD_LIST']
__TokenStream__ = []
__UnloadedModuleListStream__ = ['MinidumpUnloadedModuleList', 'MINIDUMP_UNLOADED_MODULE', 'MINIDUMP_UNLOADED_MODULE_LIST']

__all__ = __CommentStreamA__ + __CommentStreamW__ + __ContextStream__ + __ExceptionStream__ + __FunctionTableStream__ + __HandleDataStream__ + __HandleOperationListStream__ + __JavaScriptDataStream__ + __LastReservedStream__ + __Memory64ListStream__ + __MemoryInfoListStream__ + __MemoryListStream__ + __MiscInfoStream__ + __ModuleListStream__ + __ProcessVmCountersStream__ + __SystemInfoStream__ + __SystemMemoryInfoStream__ + __ThreadExListStream__ + __ThreadInfoListStream__ + __ThreadListStream__ + __TokenStream__ + __UnloadedModuleListStream__
```

`src/minidump/utils/createminidump.py`:

```py
import os
import sys
import ctypes
import enum
import platform
import logging
import struct

from ctypes.wintypes import HANDLE, BOOL, DWORD, HWND, HINSTANCE, HKEY, LPVOID, LPWSTR, PBOOL
from ctypes import c_ulong, c_char_p, c_int, c_void_p, WinError, get_last_error, windll

from minidump.utils.privileges import enable_debug_privilege

if platform.system() != 'Windows':
	raise Exception('This script will ovbiously only work on Windows')

# https://stackoverflow.com/questions/1405913/how-do-i-determine-if-my-python-shell-is-executing-in-32bit-or-64bit-mode-on-os
IS_PYTHON_64 = False if (8 * struct.calcsize("P")) == 32 else True

class MINIDUMP_TYPE(enum.IntFlag): 
	MiniDumpNormal						  = 0x00000000
	MiniDumpWithDataSegs					= 0x00000001
	MiniDumpWithFullMemory				  = 0x00000002
	MiniDumpWithHandleData				  = 0x00000004
	MiniDumpFilterMemory					= 0x00000008
	MiniDumpScanMemory					  = 0x00000010
	MiniDumpWithUnloadedModules			 = 0x00000020
	MiniDumpWithIndirectlyReferencedMemory  = 0x00000040
	MiniDumpFilterModulePaths			   = 0x00000080
	MiniDumpWithProcessThreadData		   = 0x00000100
	MiniDumpWithPrivateReadWriteMemory	  = 0x00000200
	MiniDumpWithoutOptionalData			 = 0x00000400
	MiniDumpWithFullMemoryInfo			  = 0x00000800
	MiniDumpWithThreadInfo				  = 0x00001000
	MiniDumpWithCodeSegs					= 0x00002000
	MiniDumpWithoutAuxiliaryState		   = 0x00004000
	MiniDumpWithFullAuxiliaryState		  = 0x00008000
	MiniDumpWithPrivateWriteCopyMemory	  = 0x00010000
	MiniDumpIgnoreInaccessibleMemory		= 0x00020000
	MiniDumpWithTokenInformation			= 0x00040000
	MiniDumpWithModuleHeaders			   = 0x00080000
	MiniDumpFilterTriage					= 0x00100000
	MiniDumpValidTypeFlags				  = 0x001fffff
	
class WindowsBuild(enum.Enum):
	WIN_XP  = 2600
	WIN_2K3 = 3790
	WIN_VISTA = 6000
	WIN_7 = 7600
	WIN_8 = 9200
	WIN_BLUE = 9600
	WIN_10_1507 = 10240
	WIN_10_1511 = 10586
	WIN_10_1607 = 14393
	WIN_10_1707 = 15063
	
class WindowsMinBuild(enum.Enum):
	WIN_XP = 2500
	WIN_2K3 = 3000
	WIN_VISTA = 5000
	WIN_7 = 7000
	WIN_8 = 8000
	WIN_BLUE = 9400
	WIN_10 = 9800
	
#utter microsoft bullshit commencing..
def getWindowsBuild():   
    class OSVersionInfo(ctypes.Structure):
        _fields_ = [
            ("dwOSVersionInfoSize" , ctypes.c_int),
            ("dwMajorVersion"      , ctypes.c_int),
            ("dwMinorVersion"      , ctypes.c_int),
            ("dwBuildNumber"       , ctypes.c_int),
            ("dwPlatformId"        , ctypes.c_int),
            ("szCSDVersion"        , ctypes.c_char*128)];
    GetVersionEx = getattr( ctypes.windll.kernel32 , "GetVersionExA")
    version  = OSVersionInfo()
    version.dwOSVersionInfoSize = ctypes.sizeof(OSVersionInfo)
    GetVersionEx( ctypes.byref(version) )    
    return version.dwBuildNumber
	
DELETE = 0x00010000
READ_CONTROL = 0x00020000
WRITE_DAC = 0x00040000
WRITE_OWNER = 0x00080000

SYNCHRONIZE = 0x00100000

STANDARD_RIGHTS_REQUIRED = DELETE | READ_CONTROL | WRITE_DAC | WRITE_OWNER
STANDARD_RIGHTS_ALL = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE

if getWindowsBuild() >= WindowsMinBuild.WIN_VISTA.value:
	PROCESS_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF
else:
	PROCESS_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFF
	
FILE_SHARE_READ = 1
FILE_SHARE_WRITE = 2
FILE_SHARE_DELETE = 4
FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000
FILE_FLAG_BACKUP_SEMANTICS = 0x2000000

FILE_CREATE_NEW = 1
FILE_CREATE_ALWAYS = 2
FILE_OPEN_EXISTING = 3
FILE_OPEN_ALWAYS = 4
FILE_TRUNCATE_EXISTING = 5

FILE_GENERIC_READ = 0x80000000
FILE_GENERIC_WRITE = 0x40000000
FILE_GENERIC_EXECUTE = 0x20000000
FILE_GENERIC_ALL = 0x10000000


FILE_ATTRIBUTE_READONLY = 0x1
FILE_ATTRIBUTE_HIDDEN = 0x2
FILE_ATTRIBUTE_DIRECTORY = 0x10
FILE_ATTRIBUTE_NORMAL = 0x80
FILE_ATTRIBUTE_REPARSE_POINT = 0x400
GENERIC_READ = 0x80000000
FILE_READ_ATTRIBUTES = 0x80

PROCESS_QUERY_INFORMATION = 0x0400
PROCESS_VM_READ = 0x0010

MAX_PATH = 260


"""
class SECURITY_ATTRIBUTES(ctypes.Structure):
    _fields_ = (
        ('length', ctypes.wintypes.DWORD),
        ('p_security_descriptor', ctypes.wintypes.LPVOID),
        ('inherit_handle', ctypes.wintypes.BOOLEAN),
        )
LPSECURITY_ATTRIBUTES = ctypes.POINTER(SECURITY_ATTRIBUTES)	
"""
Psapi = windll.psapi
GetProcessImageFileName = Psapi.GetProcessImageFileNameA
GetProcessImageFileName.restype = ctypes.wintypes.DWORD
QueryFullProcessImageName = ctypes.windll.kernel32.QueryFullProcessImageNameA
QueryFullProcessImageName.restype = ctypes.wintypes.DWORD
EnumProcesses = Psapi.EnumProcesses
EnumProcesses.restype = ctypes.wintypes.DWORD

LPSECURITY_ATTRIBUTES = LPVOID #we dont pass this for now
# https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx
CreateFile = ctypes.windll.kernel32.CreateFileW
CreateFile.argtypes = (
	LPWSTR,
	DWORD,
	DWORD,
    LPSECURITY_ATTRIBUTES,
	DWORD,
	DWORD,
	HANDLE,
    )
CreateFile.restype = ctypes.wintypes.HANDLE

PHANDLE = ctypes.POINTER(HANDLE)
PDWORD = ctypes.POINTER(DWORD)

GetCurrentProcess = ctypes.windll.kernel32.GetCurrentProcess
GetCurrentProcess.argtypes = ()
GetCurrentProcess.restype = HANDLE

# https://msdn.microsoft.com/en-us/library/ms684139.aspx
IsWow64Process  = ctypes.windll.kernel32.IsWow64Process 
IsWow64Process.argtypes = (HANDLE, PBOOL)
IsWow64Process.restype = BOOL

CloseHandle = ctypes.windll.kernel32.CloseHandle
CloseHandle.argtypes = (HANDLE, )
CloseHandle.restype = BOOL

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms684320(v=vs.85).aspx
OpenProcess = ctypes.windll.kernel32.OpenProcess
OpenProcess.argtypes = (DWORD, BOOL, DWORD )
OpenProcess.restype = HANDLE

# https://msdn.microsoft.com/en-us/library/windows/desktop/ms680360(v=vs.85).aspx
MiniDumpWriteDump = ctypes.windll.DbgHelp.MiniDumpWriteDump
MiniDumpWriteDump.argtypes = (HANDLE , DWORD , HANDLE, DWORD, DWORD, DWORD, DWORD)
MiniDumpWriteDump.restype = BOOL

def is64bitProc(process_handle):
	is64 = BOOL()
	res = IsWow64Process(process_handle, ctypes.byref(is64))
	if res == 0:
		logging.warning('Failed to get process version info!')
		WinError(get_last_error())
	return not bool(is64.value)
	
# https://waitfordebug.wordpress.com/2012/01/27/pid-enumeration-on-windows-with-pure-python-ctypes/
def enum_pids():
	
	max_array = c_ulong * 4096 # define long array to capture all the processes
	pProcessIds = max_array() # array to store the list of processes
	pBytesReturned = c_ulong() # the number of bytes returned in the array
	#EnumProcess 
	res = EnumProcesses(
		ctypes.byref(pProcessIds),
		ctypes.sizeof(pProcessIds),
		ctypes.byref(pBytesReturned)
	)
	if res == 0:
		logging.error(WinError(get_last_error()))
		return []
  
	# get the number of returned processes
	nReturned = int(pBytesReturned.value/ctypes.sizeof(c_ulong()))
	return [i for i in pProcessIds[:nReturned]]
	
#https://msdn.microsoft.com/en-us/library/windows/desktop/ms683217(v=vs.85).aspx
def enum_process_names():
	pid_to_name = {}
	
	for pid in enum_pids():
		pid_to_name[pid] = 'Not found'
		process_handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, False, pid)
		if process_handle is None:
			logging.debug('[Enum Processes]Failed to open process PID: %d Reason: %s ' % (pid, WinError(get_last_error())))
			continue
		
		image_name = (ctypes.c_char*MAX_PATH)()
		max_path = DWORD(4096)
		#res = GetProcessImageFileName(process_handle, image_name, MAX_PATH)
		res = QueryFullProcessImageName(process_handle, 0 ,image_name, ctypes.byref(max_path))
		if res == 0:
			logging.debug('[Enum Proceses]Failed GetProcessImageFileName on PID: %d Reason: %s ' % (pid, WinError(get_last_error())))
			continue
		
		pid_to_name[pid] = image_name.value.decode()
	return pid_to_name

def create_dump(pid, output_filename, mindumptype, with_debug = False):
	if with_debug:
		logging.debug('Enabling SeDebugPrivilege')
		assigned = enable_debug_privilege()
		msg = ['failure', 'success'][assigned]
		logging.debug('SeDebugPrivilege assignment %s' % msg)
	
	logging.debug('Opening process PID: %d' % pid)
	process_handle = OpenProcess(PROCESS_ALL_ACCESS, False, pid)
	if process_handle is None:
		logging.warning('Failed to open process PID: %d' % pid)
		logging.error(WinError(get_last_error()))
		return
	logging.debug('Process handle: 0x%04x' % process_handle)
	is64 = is64bitProc(process_handle)
	if is64 != IS_PYTHON_64:
		logging.warning('process architecture mismatch! This could case error! Python arch: %s Target process arch: %s' % ('x86' if not IS_PYTHON_64 else 'x64', 'x86' if not is64 else 'x64'))
	
	logging.debug('Creating file handle for output file')
	file_handle = CreateFile(output_filename, FILE_GENERIC_READ | FILE_GENERIC_WRITE, 0, None,  FILE_CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, None)
	if file_handle == -1:
		logging.warning('Failed to create file')
		logging.error(WinError(get_last_error()))
		return
	logging.debug('Dumping process to file')
	res = MiniDumpWriteDump(process_handle, pid, file_handle, mindumptype, 0,0,0)
	if not bool(res):
		logging.warning('Failed to dump process to file')
		logging.error(WinError(get_last_error()))
	logging.info('Dump file created succsessfully')
	CloseHandle(file_handle)
	CloseHandle(process_handle)
	
def main():
	import argparse

	parser = argparse.ArgumentParser(description='Tool to create process dumps using windows API')
	parser.add_argument('-d', '--with-debug', action='store_true', help='enable SeDebugPrivilege, use this if target process is not in the same user context as your script')
	parser.add_argument('-v', '--verbose', action='count', default=0, help = 'verbosity, add more - see more')
	
	subparsers = parser.add_subparsers(help = 'commands')
	subparsers.required = True
	subparsers.dest = 'command'
	enumerate_group = subparsers.add_parser('enum', help='Enumerate running processes')
	dump_group = subparsers.add_parser('dump', help = 'Dump running process')
	target_group = dump_group.add_mutually_exclusive_group(required=True)
	target_group.add_argument('-p', '--pid', type=int, help='PID of process to dump')
	target_group.add_argument('-n', '--name', help='Name of process to dump')
	dump_group.add_argument('-o', '--outfile', help='Output .dmp file name', required = True)
	
	args = parser.parse_args()
	
	if args.verbose == 0:
		logging.basicConfig(level=logging.INFO)
	elif args.verbose == 1:
		logging.basicConfig(level=logging.DEBUG)
	else:
		logging.basicConfig(level=1)
		
	mindumptype = MINIDUMP_TYPE.MiniDumpNormal | MINIDUMP_TYPE.MiniDumpWithFullMemory
		
	if args.with_debug:
		logging.debug('Enabling SeDebugPrivilege')
		assigned = enable_debug_privilege()
		msg = ['failure', 'success'][assigned]
		logging.debug('SeDebugPrivilege assignment %s' % msg)
	
	if args.command == 'enum':
		pid_to_name = enum_process_names()
		t = [p for p in pid_to_name]
		t.sort()
		for pid in t:
			logging.info('PID: %d Name: %s' % (pid, pid_to_name[pid]))
		return
		
	if args.command == 'dump':
		if args.pid:
			logging.info('Dumpig process PID %d' % args.pid)
			create_dump(args.pid, args.outfile, mindumptype, with_debug = args.with_debug)
		
		if args.name:
			pid_to_name = enum_process_names()
			for pid in pid_to_name:
				if pid_to_name[pid].find(args.name) != -1:
					logging.info('Dumpig process PID %d' % pid)
					create_dump(pid, args.outfile, mindumptype, with_debug = args.with_debug)
					return
			logging.info('Failed to find process by name!')
			
if __name__=='__main__':
	main()

	
```

`src/minidump/utils/privileges.py`:

```py
"""
A module built to test if the current process has the privilege to
create symlinks on Windows.
"""
# https://svn.python.org/projects/python/branches/pep-0384/Lib/test/symlink_support.py

# allow script to run natively under python 2.6+
from __future__ import print_function

import ctypes
from ctypes import wintypes

GetCurrentProcess = ctypes.windll.kernel32.GetCurrentProcess
GetCurrentProcess.restype = wintypes.HANDLE
OpenProcessToken = ctypes.windll.advapi32.OpenProcessToken
OpenProcessToken.argtypes = (wintypes.HANDLE, wintypes.DWORD,
                             ctypes.POINTER(wintypes.HANDLE))
OpenProcessToken.restype = wintypes.BOOL

class LUID(ctypes.Structure):
    _fields_ = [
            ('low_part', wintypes.DWORD),
            ('high_part', wintypes.LONG),
            ]

    def __eq__(self, other):
        return (
                self.high_part == other.high_part and
                self.low_part == other.low_part
                )

    def __ne__(self, other):
        return not (self==other)

LookupPrivilegeValue = ctypes.windll.advapi32.LookupPrivilegeValueW
LookupPrivilegeValue.argtypes = (
        wintypes.LPWSTR, # system name
        wintypes.LPWSTR, # name
        ctypes.POINTER(LUID),
        )
LookupPrivilegeValue.restype = wintypes.BOOL

class TOKEN_INFORMATION_CLASS:
    TokenUser = 1
    TokenGroups = 2
    TokenPrivileges = 3
    # ... see http://msdn.microsoft.com/en-us/library/aa379626%28VS.85%29.aspx

SE_PRIVILEGE_ENABLED_BY_DEFAULT = (0x00000001)
SE_PRIVILEGE_ENABLED            = (0x00000002)
SE_PRIVILEGE_REMOVED            = (0x00000004)
SE_PRIVILEGE_USED_FOR_ACCESS    = (0x80000000)

class LUID_AND_ATTRIBUTES(ctypes.Structure):
    _fields_ = [
            ('LUID', LUID),
            ('attributes', wintypes.DWORD),
            ]

    def is_enabled(self):
        return bool(self.attributes & SE_PRIVILEGE_ENABLED)

    def enable(self):
        self.attributes |= SE_PRIVILEGE_ENABLED

    def get_name(self):
        size = wintypes.DWORD(10240)
        buf = ctypes.create_unicode_buffer(size.value)
        res = LookupPrivilegeName(None, self.LUID, buf, size)
        if res == 0:
            raise RuntimeError
        return buf[:size.value]

    def __str__(self):
        name = self.name
        fmt = ['{name}', '{name} (enabled)'][self.is_enabled()]
        return fmt.format(**vars())

LookupPrivilegeName = ctypes.windll.advapi32.LookupPrivilegeNameW
LookupPrivilegeName.argtypes = (
        wintypes.LPWSTR, # lpSystemName
        ctypes.POINTER(LUID), # lpLuid
        wintypes.LPWSTR, # lpName
        ctypes.POINTER(wintypes.DWORD), #cchName
        )
LookupPrivilegeName.restype = wintypes.BOOL

class TOKEN_PRIVILEGES(ctypes.Structure):
    _fields_ = [
            ('count', wintypes.DWORD),
            ('privileges', LUID_AND_ATTRIBUTES*0),
            ]

    def get_array(self):
        array_type = LUID_AND_ATTRIBUTES*self.count
        privileges = ctypes.cast(self.privileges,
                                 ctypes.POINTER(array_type)).contents
        return privileges

    def __iter__(self):
        return iter(self.get_array())

PTOKEN_PRIVILEGES = ctypes.POINTER(TOKEN_PRIVILEGES)

GetTokenInformation = ctypes.windll.advapi32.GetTokenInformation
GetTokenInformation.argtypes = [
        wintypes.HANDLE, # TokenHandle
        ctypes.c_uint, # TOKEN_INFORMATION_CLASS value
        ctypes.c_void_p, # TokenInformation
        wintypes.DWORD, # TokenInformationLength
        ctypes.POINTER(wintypes.DWORD), # ReturnLength
        ]
GetTokenInformation.restype = wintypes.BOOL

# http://msdn.microsoft.com/en-us/library/aa375202%28VS.85%29.aspx
AdjustTokenPrivileges = ctypes.windll.advapi32.AdjustTokenPrivileges
AdjustTokenPrivileges.restype = wintypes.BOOL
AdjustTokenPrivileges.argtypes = [
        wintypes.HANDLE,                # TokenHandle
        wintypes.BOOL,                  # DisableAllPrivileges
        PTOKEN_PRIVILEGES,              # NewState (optional)
        wintypes.DWORD,                 # BufferLength of PreviousState
        PTOKEN_PRIVILEGES,              # PreviousState (out, optional)
        ctypes.POINTER(wintypes.DWORD), # ReturnLength
        ]

def get_process_token():
    "Get the current process token"
    token = wintypes.HANDLE()
    TOKEN_ALL_ACCESS = 0xf01ff
    res = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, token)
    if not res > 0:
        raise RuntimeError("Couldn't get process token")
    return token

def get_debug_luid():
    symlink_luid = LUID()
    res = LookupPrivilegeValue(None, "SeDebugPrivilege",
                               symlink_luid)
    if not res > 0:
        raise RuntimeError("Couldn't lookup privilege value")
    return symlink_luid

def get_privilege_information():
    "Get all privileges associated with the current process."
    # first call with zero length to determine what size buffer we need

    return_length = wintypes.DWORD()
    params = [
            get_process_token(),
            TOKEN_INFORMATION_CLASS.TokenPrivileges,
            None,
            0,
            return_length,
            ]

    res = GetTokenInformation(*params)

    # assume we now have the necessary length in return_length

    buffer = ctypes.create_string_buffer(return_length.value)
    params[2] = buffer
    params[3] = return_length.value

    res = GetTokenInformation(*params)
    assert res > 0, "Error in second GetTokenInformation (%d)" % res

    privileges = ctypes.cast(buffer, ctypes.POINTER(TOKEN_PRIVILEGES)).contents
    return privileges

def report_privilege_information():
    "Report all privilege information assigned to the current process."
    privileges = get_privilege_information()
    print("found {0} privileges".format(privileges.count))
    tuple(map(print, privileges))

def enable_debug_privilege():
    """
    Try to assign the symlink privilege to the current process token.
    Return True if the assignment is successful.
    """
    # create a space in memory for a TOKEN_PRIVILEGES structure
    #  with one element
    size = ctypes.sizeof(TOKEN_PRIVILEGES)
    size += ctypes.sizeof(LUID_AND_ATTRIBUTES)
    buffer = ctypes.create_string_buffer(size)
    tp = ctypes.cast(buffer, ctypes.POINTER(TOKEN_PRIVILEGES)).contents
    tp.count = 1
    tp.get_array()[0].enable()
    tp.get_array()[0].LUID = get_debug_luid()
    token = get_process_token()
    res = AdjustTokenPrivileges(token, False, tp, 0, None, None)
    if res == 0:
        raise RuntimeError("Error in AdjustTokenPrivileges")

    ERROR_NOT_ALL_ASSIGNED = 1300
    return ctypes.windll.kernel32.GetLastError() != ERROR_NOT_ALL_ASSIGNED

```

`src/minidump/utils/privileges_types.py`:

```py
import enum

class Privileges(enum.Enum):
	SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege" #Required to assign the primary token of a process.
																 #User Right: Replace a process-level token.

	SE_AUDIT_NAME = "SeAuditPrivilege" #Required to generate audit-log entries. Give this privilege to secure servers.
										#User Right: Generate security audits.

	SE_BACKUP_NAME = "SeBackupPrivilege" #Required to perform backup operations. This privilege causes the system to grant all read access control to any file, regardless of the access control list (ACL) specified for the file. Any access request other than read is still evaluated with the ACL. This privilege is required by the RegSaveKey and RegSaveKeyExfunctions. The following access rights are granted if this privilege is held:
	SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege" #Required to receive notifications of changes to files or directories. This privilege also causes the system to skip all traversal access checks. It is enabled by default for all users.
	SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege" #Required to create named file mapping objects in the global namespace during Terminal Services sessions. This privilege is enabled by default for administrators, services, and the local system account.
														#User Right: Create global objects.

	SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege" # Required to create a paging file. #User Right: Create a pagefile.
	SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege" #Required to create a permanent object.
															#User Right: Create permanent shared objects.
	SE_CREATE_SYMBOLIC_LINK_NAME = "SeCreateSymbolicLinkPrivilege" #Required to create a symbolic link.
																		#User Right: Create symbolic links.

	SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege" #Required to create a primary token.
													#User Right: Create a token object.
													#You cannot add this privilege to a user account with the "Create a token object" policy. Additionally, you cannot add this privilege to an owned process using Windows APIs.
													#Windows Server 2003 and Windows XP with SP1 and earlier:  Windows APIs can add this privilege to an owned process.

	SE_DEBUG_NAME = "SeDebugPrivilege" #Required to debug and adjust the memory of a process owned by another account.
										#User Right: Debug programs.

	SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege" #Required to mark user and computer accounts as trusted for delegation.
															  #User Right: Enable computer and user accounts to be trusted for delegation.
	SE_IMPERSONATE_NAME = "SeImpersonatePrivilege" #Required to impersonate.
													#User Right: Impersonate a client after authentication.

	SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege" #Required to increase the base priority of a process.
																  #User Right: Increase scheduling priority.
	SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege" #Required to increase the quota assigned to a process.
														#User Right: Adjust memory quotas for a process.

	SE_INC_WORKING_SET_NAME = "SeIncreaseWorkingSetPrivilege" #Required to allocate more memory for applications that run in the context of users.
																#User Right: Increase a process working set.
	SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege" #Required to load or unload a device driver.
												  #User Right: Load and unload device drivers.
	SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege" #Required to lock physical pages in memory.
													#User Right: Lock pages in memory.
	SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege" #Required to create a computer account.
														#User Right: Add workstations to domain.
	SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege" #Required to enable volume management privileges.
													  #User Right: Manage the files on a volume.
	SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege" #Required to gather profiling information for a single process.
																	#User Right: Profile single process.
	SE_RELABEL_NAME = "SeRelabelPrivilege" #Required to modify the mandatory integrity level of an object.
	#User Right: Modify an object label.

	SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"# Required to shut down a system using a network request.
	#User Right: Force shutdown from a remote system.

	SE_RESTORE_NAME = "SeRestorePrivilege" #Required to perform restore operations. This privilege causes the system to grant all write access control to any file, regardless of the ACL specified for the file. Any access request other than write is still evaluated with the ACL. Additionally, this privilege enables you to set any valid user or group SID as the owner of a file. This privilege is required by the RegLoadKey function. The following access rights are granted if this privilege is held:
	SE_SECURITY_NAME = "SeSecurityPrivilege" #Required to perform a number of security-related functions, such as controlling and viewing audit messages. This privilege identifies its holder as a security operator.
	#User Right: Manage auditing and security log.
	SE_SHUTDOWN_NAME = "SeShutdownPrivilege" #Required to shut down a local system.
	#User Right: Shut down the system.
	SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege" #Required for a domain controller to use the Lightweight Directory Access Protocol directory synchronization services. This privilege enables the holder to read all objects and properties in the directory, regardless of the protection on the objects and properties. By default, it is assigned to the Administrator and LocalSystem accounts on domain controllers.
	#User Right: Synchronize directory service data.
	SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege" #Required to modify the nonvolatile RAM of systems that use this type of memory to store configuration information.
	#User Right: Modify firmware environment values.
	SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege" #Required to gather profiling information for the entire system.
	#User Right: Profile system performance.
	SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege" #Required to modify the system time.
	#User Right: Change the system time.
	SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege" #Required to take ownership of an object without being granted discretionary access. This privilege allows the owner value to be set only to those values that the holder may legitimately assign as the owner of an object.
	#User Right: Take ownership of files or other objects.
	SE_TCB_NAME = "SeTcbPrivilege" #This privilege identifies its holder as part of the trusted computer base. Some trusted protected subsystems are granted this privilege.
	#User Right: Act as part of the operating system.
	SE_TIME_ZONE_NAME = "SeTimeZonePrivilege" #Required to adjust the time zone associated with the computer's internal clock.
	#User Right: Change the time zone.
	SE_TRUSTED_CREDMAN_ACCESS_NAME = "SeTrustedCredManAccessPrivilege"#Required to access Credential Manager as a trusted caller.
	#User Right: Access Credential Manager as a trusted caller.
	SE_UNDOCK_NAME = "SeUndockPrivilege" #Required to undock a laptop.
	#User Right: Remove computer from docking station.
	SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
```

`src/minidump/utils/winapi/defines.py`:

```py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (c) 2009-2018, Mario Vilas
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice,this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""
Common definitions.
"""

# TODO
# + add TCHAR and related types?

import ctypes
import functools

#==============================================================================
# This is used later on to calculate the list of exported symbols.
_all = None
_all = set(vars().keys())
#==============================================================================

# Cygwin compatibility.
try:
    WindowsError
except NameError:
    _gle = None
    class WindowsError(OSError):
        def __init__(self, *args, **kwargs):
            OSError.__init__(self, *args, **kwargs)
            global _gle
            if _gle is None:
                from kernel32 import GetLastError as _gle
            self.winerror = _gle()

    from os import getenv as _real_getenv
    def getenv(key, default=None):
        value = _real_getenv(key, None)
        if value is None:
            value = _real_getenv(key.upper(), default)
        return value

#------------------------------------------------------------------------------

# Some stuff from ctypes we'll be using very frequently.
addressof   = ctypes.addressof
sizeof      = ctypes.sizeof
SIZEOF      = ctypes.sizeof
POINTER     = ctypes.POINTER
WINFUNCTYPE = ctypes.WINFUNCTYPE
windll      = ctypes.windll

# Automatically disable padding of structs and unions on 32 bits.
class Structure(ctypes.Structure):
    if sizeof(ctypes.c_void_p) == 4:
        _pack_ = 1
class Union(ctypes.Union):
    if sizeof(ctypes.c_void_p) == 4:
        _pack_ = 1

# The IronPython implementation of byref() was giving some problems,
# so it's best to replace it with the slower pointer() function.
try:
    ctypes.c_void_p(ctypes.byref(ctypes.c_char()))  # this fails in IronPython
    byref = ctypes.byref
except TypeError:
    byref = ctypes.pointer

# XXX DEBUG
# The following code can be enabled to make the Win32 API wrappers log to
# standard output the dll and function names, the parameter values and the
# return value for each call.

##WIN32_VERBOSE_MODE = True
WIN32_VERBOSE_MODE = False

if WIN32_VERBOSE_MODE:

    class WinDllHook(object):
        def __getattr__(self, name):
            if name.startswith('_'):
                return object.__getattr__(self, name)
            return WinFuncHook(name)

    class WinFuncHook(object):
        def __init__(self, name):
            self.__name = name

        def __getattr__(self, name):
            if name.startswith('_'):
                return object.__getattr__(self, name)
            return WinCallHook(self.__name, name)

    class WinCallHook(object):
        def __init__(self, dllname, funcname):
            self.__dllname = dllname
            self.__funcname = funcname
            self.__func = getattr(getattr(ctypes.windll, dllname), funcname)

        def __copy_attribute(self, attribute):
            try:
                value = getattr(self, attribute)
                setattr(self.__func, attribute, value)
            except AttributeError:
                try:
                    delattr(self.__func, attribute)
                except AttributeError:
                    pass

        def __call__(self, *argv):
            self.__copy_attribute('argtypes')
            self.__copy_attribute('restype')
            self.__copy_attribute('errcheck')
            print("-"*10)
            print("%s ! %s %r" % (self.__dllname, self.__funcname, argv))
            retval = self.__func(*argv)
            print("== %r" % (retval,))
            return retval

    windll = WinDllHook()

#------------------------------------------------------------------------------

def RaiseIfZero(result, func = None, arguments = ()):
    """
    Error checking for most Win32 API calls.

    The function is assumed to return an integer, which is C{0} on error.
    In that case the C{WindowsError} exception is raised.
    """
    if not result:
        raise ctypes.WinError()
    return result

def RaiseIfNotZero(result, func = None, arguments = ()):
    """
    Error checking for some odd Win32 API calls.

    The function is assumed to return an integer, which is zero on success.
    If the return value is nonzero the C{WindowsError} exception is raised.

    This is mostly useful for free() like functions, where the return value is
    the pointer to the memory block on failure or a C{NULL} pointer on success.
    """
    if result:
        raise ctypes.WinError()
    return result

def RaiseIfNotErrorSuccess(result, func = None, arguments = ()):
    """
    Error checking for Win32 Registry API calls.

    The function is assumed to return a Win32 error code. If the code is not
    C{ERROR_SUCCESS} then a C{WindowsError} exception is raised.
    """
    if result != ERROR_SUCCESS:
        raise ctypes.WinError(result)
    return result

class GuessStringType(object):
    """
    Decorator that guesses the correct version (A or W) to call
    based on the types of the strings passed as parameters.

    Calls the B{ANSI} version if the only string types are ANSI.

    Calls the B{Unicode} version if Unicode or mixed string types are passed.

    The default if no string arguments are passed depends on the value of the
    L{t_default} class variable.

    @type fn_ansi: function
    @ivar fn_ansi: ANSI version of the API function to call.
    @type fn_unicode: function
    @ivar fn_unicode: Unicode (wide) version of the API function to call.

    @type t_default: type
    @cvar t_default: Default string type to use.
        Possible values are:
         - type('') for ANSI
         - type(u'') for Unicode
    """

    # ANSI and Unicode types
    t_ansi    = type('')
    t_unicode = type(u'')

    # Default is ANSI for Python 2.x
    t_default = t_ansi

    def __init__(self, fn_ansi, fn_unicode):
        """
        @type  fn_ansi: function
        @param fn_ansi: ANSI version of the API function to call.
        @type  fn_unicode: function
        @param fn_unicode: Unicode (wide) version of the API function to call.
        """
        self.fn_ansi    = fn_ansi
        self.fn_unicode = fn_unicode

        # Copy the wrapped function attributes.
        try:
            self.__name__ = self.fn_ansi.__name__[:-1]  # remove the A or W
        except AttributeError:
            pass
        try:
            self.__module__ = self.fn_ansi.__module__
        except AttributeError:
            pass
        try:
            self.__doc__ = self.fn_ansi.__doc__
        except AttributeError:
            pass

    def __call__(self, *argv, **argd):

        # Shortcut to self.t_ansi
        t_ansi    = self.t_ansi

        # Get the types of all arguments for the function
        v_types   = [ type(item) for item in argv ]
        v_types.extend( [ type(value) for (key, value) in argd.iteritems() ] )

        # Get the appropriate function for the default type
        if self.t_default == t_ansi:
            fn = self.fn_ansi
        else:
            fn = self.fn_unicode

        # If at least one argument is a Unicode string...
        if self.t_unicode in v_types:

            # If al least one argument is an ANSI string,
            # convert all ANSI strings to Unicode
            if t_ansi in v_types:
                argv = list(argv)
                for index in xrange(len(argv)):
                    if v_types[index] == t_ansi:
                        argv[index] = unicode(argv[index])
                for (key, value) in argd.items():
                    if type(value) == t_ansi:
                        argd[key] = unicode(value)

            # Use the W version
            fn = self.fn_unicode

        # If at least one argument is an ANSI string,
        # but there are no Unicode strings...
        elif t_ansi in v_types:

            # Use the A version
            fn = self.fn_ansi

        # Call the function and return the result
        return fn(*argv, **argd)

class DefaultStringType(object):
    """
    Decorator that uses the default version (A or W) to call
    based on the configuration of the L{GuessStringType} decorator.

    @see: L{GuessStringType.t_default}

    @type fn_ansi: function
    @ivar fn_ansi: ANSI version of the API function to call.
    @type fn_unicode: function
    @ivar fn_unicode: Unicode (wide) version of the API function to call.
    """

    def __init__(self, fn_ansi, fn_unicode):
        """
        @type  fn_ansi: function
        @param fn_ansi: ANSI version of the API function to call.
        @type  fn_unicode: function
        @param fn_unicode: Unicode (wide) version of the API function to call.
        """
        self.fn_ansi    = fn_ansi
        self.fn_unicode = fn_unicode

        # Copy the wrapped function attributes.
        try:
            self.__name__ = self.fn_ansi.__name__[:-1]  # remove the A or W
        except AttributeError:
            pass
        try:
            self.__module__ = self.fn_ansi.__module__
        except AttributeError:
            pass
        try:
            self.__doc__ = self.fn_ansi.__doc__
        except AttributeError:
            pass

    def __call__(self, *argv, **argd):

        # Get the appropriate function based on the default.
        if GuessStringType.t_default == GuessStringType.t_ansi:
            fn = self.fn_ansi
        else:
            fn = self.fn_unicode

        # Call the function and return the result
        return fn(*argv, **argd)

def MakeANSIVersion(fn):
    """
    Decorator that generates an ANSI version of a Unicode (wide) only API call.

    @type  fn: callable
    @param fn: Unicode (wide) version of the API function to call.
    """
    @functools.wraps(fn)
    def wrapper(*argv, **argd):
        t_ansi    = GuessStringType.t_ansi
        t_unicode = GuessStringType.t_unicode
        v_types   = [ type(item) for item in argv ]
        v_types.extend( [ type(value) for (key, value) in argd.iteritems() ] )
        if t_ansi in v_types:
            argv = list(argv)
            for index in range(len(argv)):
                if v_types[index] == t_ansi:
                    argv[index] = t_unicode(argv[index])
            for key, value in argd.items():
                if type(value) == t_ansi:
                    argd[key] = t_unicode(value)
        return fn(*argv, **argd)
    return wrapper

def MakeWideVersion(fn):
    """
    Decorator that generates a Unicode (wide) version of an ANSI only API call.

    @type  fn: callable
    @param fn: ANSI version of the API function to call.
    """
    @functools.wraps(fn)
    def wrapper(*argv, **argd):
        t_ansi    = GuessStringType.t_ansi
        t_unicode = GuessStringType.t_unicode
        v_types   = [ type(item) for item in argv ]
        v_types.extend( [ type(value) for (key, value) in argd.iteritems() ] )
        if t_unicode in v_types:
            argv = list(argv)
            for index in range(len(argv)):
                if v_types[index] == t_unicode:
                    argv[index] = t_ansi(argv[index])
            for key, value in argd.items():
                if type(value) == t_unicode:
                    argd[key] = t_ansi(value)
        return fn(*argv, **argd)
    return wrapper

#--- Types --------------------------------------------------------------------
# http://msdn.microsoft.com/en-us/library/aa383751(v=vs.85).aspx

# Map of basic C types to Win32 types
LPVOID      = ctypes.c_void_p
CHAR        = ctypes.c_char
WCHAR       = ctypes.c_wchar
BYTE        = ctypes.c_ubyte
SBYTE       = ctypes.c_byte
WORD        = ctypes.c_uint16
SWORD       = ctypes.c_int16
DWORD       = ctypes.c_uint32
SDWORD      = ctypes.c_int32
QWORD       = ctypes.c_uint64
SQWORD      = ctypes.c_int64
SHORT       = ctypes.c_int16
USHORT      = ctypes.c_uint16
INT         = ctypes.c_int32
UINT        = ctypes.c_uint32
LONG        = ctypes.c_int32
ULONG       = ctypes.c_uint32
LONGLONG    = ctypes.c_int64        # c_longlong
ULONGLONG   = ctypes.c_uint64       # c_ulonglong
LPSTR       = ctypes.c_char_p
LPWSTR      = ctypes.c_wchar_p
INT8        = ctypes.c_int8
INT16       = ctypes.c_int16
INT32       = ctypes.c_int32
INT64       = ctypes.c_int64
UINT8       = ctypes.c_uint8
UINT16      = ctypes.c_uint16
UINT32      = ctypes.c_uint32
UINT64      = ctypes.c_uint64
LONG32      = ctypes.c_int32
LONG64      = ctypes.c_int64
ULONG32     = ctypes.c_uint32
ULONG64     = ctypes.c_uint64
DWORD32     = ctypes.c_uint32
DWORD64     = ctypes.c_uint64
BOOL        = ctypes.c_int32
FLOAT       = ctypes.c_float        # not sure on cygwin
DOUBLE      = ctypes.c_double       # not sure on cygwin

# Map size_t to SIZE_T
try:
    SIZE_T  = ctypes.c_size_t
    SSIZE_T = ctypes.c_ssize_t
except AttributeError:
    # Size of a pointer
    SIZE_T  = {1:BYTE, 2:WORD, 4:DWORD, 8:QWORD}[sizeof(LPVOID)]
    SSIZE_T = {1:SBYTE, 2:SWORD, 4:SDWORD, 8:SQWORD}[sizeof(LPVOID)]
PSIZE_T     = POINTER(SIZE_T)

# Not really pointers but pointer-sized integers
DWORD_PTR   = SIZE_T
ULONG_PTR   = SIZE_T
LONG_PTR    = SIZE_T

# Other Win32 types, more may be added as needed
PVOID       = LPVOID
PPVOID      = POINTER(PVOID)
PSTR        = LPSTR
PWSTR       = LPWSTR
PCHAR       = LPSTR
PWCHAR      = LPWSTR
LPBYTE      = POINTER(BYTE)
LPSBYTE     = POINTER(SBYTE)
LPWORD      = POINTER(WORD)
LPSWORD     = POINTER(SWORD)
LPDWORD     = POINTER(DWORD)
LPSDWORD    = POINTER(SDWORD)
LPULONG     = POINTER(ULONG)
LPLONG      = POINTER(LONG)
PDWORD      = LPDWORD
PDWORD_PTR  = POINTER(DWORD_PTR)
PULONG      = LPULONG
PLONG       = LPLONG
CCHAR       = CHAR
BOOLEAN     = BYTE
PBOOL       = POINTER(BOOL)
LPBOOL      = PBOOL
TCHAR       = CHAR      # XXX ANSI by default?
UCHAR       = BYTE
DWORDLONG   = ULONGLONG
LPDWORD32   = POINTER(DWORD32)
LPULONG32   = POINTER(ULONG32)
LPDWORD64   = POINTER(DWORD64)
LPULONG64   = POINTER(ULONG64)
PDWORD32    = LPDWORD32
PULONG32    = LPULONG32
PDWORD64    = LPDWORD64
PULONG64    = LPULONG64
ATOM        = WORD
HANDLE      = LPVOID
PHANDLE     = POINTER(HANDLE)
LPHANDLE    = PHANDLE
HMODULE     = HANDLE
HINSTANCE   = HANDLE
HTASK       = HANDLE
HKEY        = HANDLE
PHKEY       = POINTER(HKEY)
HDESK       = HANDLE
HRSRC       = HANDLE
HSTR        = HANDLE
HWINSTA     = HANDLE
HKL         = HANDLE
HDWP        = HANDLE
HFILE       = HANDLE
HRESULT     = LONG
HGLOBAL     = HANDLE
HLOCAL      = HANDLE
HGDIOBJ     = HANDLE
HDC         = HGDIOBJ
HRGN        = HGDIOBJ
HBITMAP     = HGDIOBJ
HPALETTE    = HGDIOBJ
HPEN        = HGDIOBJ
HBRUSH      = HGDIOBJ
HMF         = HGDIOBJ
HEMF        = HGDIOBJ
HENHMETAFILE = HGDIOBJ
HMETAFILE   = HGDIOBJ
HMETAFILEPICT = HGDIOBJ
HWND        = HANDLE
NTSTATUS    = LONG
PNTSTATUS   = POINTER(NTSTATUS)
KAFFINITY   = ULONG_PTR
RVA         = DWORD
RVA64       = QWORD
WPARAM      = DWORD
LPARAM      = LPVOID
LRESULT     = LPVOID
ACCESS_MASK = DWORD
REGSAM      = ACCESS_MASK
PACCESS_MASK = POINTER(ACCESS_MASK)
PREGSAM     = POINTER(REGSAM)

# Since the SID is an opaque structure, let's treat its pointers as void*
PSID = PVOID

# typedef union _LARGE_INTEGER {
#   struct {
#     DWORD LowPart;
#     LONG HighPart;
#   } ;
#   struct {
#     DWORD LowPart;
#     LONG HighPart;
#   } u;
#   LONGLONG QuadPart;
# } LARGE_INTEGER,
#  *PLARGE_INTEGER;

# XXX TODO

# typedef struct _FLOAT128 {
#     __int64 LowPart;
#     __int64 HighPart;
# } FLOAT128;
class FLOAT128 (Structure):
    _fields_ = [
        ("LowPart",     QWORD),
        ("HighPart",    QWORD),
    ]
PFLOAT128 = POINTER(FLOAT128)

# typedef struct DECLSPEC_ALIGN(16) _M128A {
#     ULONGLONG Low;
#     LONGLONG High;
# } M128A, *PM128A;
class M128A(Structure):
    _fields_ = [
        ("Low",     ULONGLONG),
        ("High",    LONGLONG),
    ]
PM128A = POINTER(M128A)

#--- Constants ----------------------------------------------------------------

NULL        = None
INFINITE    = -1
TRUE        = 1
FALSE       = 0

# http://blogs.msdn.com/oldnewthing/archive/2004/08/26/220873.aspx
ANYSIZE_ARRAY = 1

# Invalid handle value is -1 casted to void pointer.
try:
    INVALID_HANDLE_VALUE = ctypes.c_void_p(-1).value #-1 #0xFFFFFFFF
except TypeError:
    if sizeof(ctypes.c_void_p) == 4:
        INVALID_HANDLE_VALUE = 0xFFFFFFFF
    elif sizeof(ctypes.c_void_p) == 8:
        INVALID_HANDLE_VALUE = 0xFFFFFFFFFFFFFFFF
    else:
        raise

MAX_MODULE_NAME32   = 255
MAX_PATH            = 260

# Error codes
# TODO maybe add more error codes?
# if they're too many they could be pickled instead,
# or at the very least put in a new file
ERROR_SUCCESS                       = 0
ERROR_INVALID_FUNCTION              = 1
ERROR_FILE_NOT_FOUND                = 2
ERROR_PATH_NOT_FOUND                = 3
ERROR_ACCESS_DENIED                 = 5
ERROR_INVALID_HANDLE                = 6
ERROR_NOT_ENOUGH_MEMORY             = 8
ERROR_INVALID_DRIVE                 = 15
ERROR_NO_MORE_FILES                 = 18
ERROR_BAD_LENGTH                    = 24
ERROR_HANDLE_EOF                    = 38
ERROR_HANDLE_DISK_FULL              = 39
ERROR_NOT_SUPPORTED                 = 50
ERROR_FILE_EXISTS                   = 80
ERROR_INVALID_PARAMETER             = 87
ERROR_BUFFER_OVERFLOW               = 111
ERROR_DISK_FULL                     = 112
ERROR_CALL_NOT_IMPLEMENTED          = 120
ERROR_SEM_TIMEOUT                   = 121
ERROR_INSUFFICIENT_BUFFER           = 122
ERROR_INVALID_NAME                  = 123
ERROR_MOD_NOT_FOUND                 = 126
ERROR_PROC_NOT_FOUND                = 127
ERROR_DIR_NOT_EMPTY                 = 145
ERROR_BAD_THREADID_ADDR             = 159
ERROR_BAD_ARGUMENTS                 = 160
ERROR_BAD_PATHNAME                  = 161
ERROR_ALREADY_EXISTS                = 183
ERROR_INVALID_FLAG_NUMBER           = 186
ERROR_ENVVAR_NOT_FOUND              = 203
ERROR_FILENAME_EXCED_RANGE          = 206
ERROR_MORE_DATA                     = 234

WAIT_TIMEOUT                        = 258

ERROR_NO_MORE_ITEMS                 = 259
ERROR_PARTIAL_COPY                  = 299
ERROR_INVALID_ADDRESS               = 487
ERROR_THREAD_NOT_IN_PROCESS         = 566
ERROR_CONTROL_C_EXIT                = 572
ERROR_UNHANDLED_EXCEPTION           = 574
ERROR_ASSERTION_FAILURE             = 668
ERROR_WOW_ASSERTION                 = 670

ERROR_DBG_EXCEPTION_NOT_HANDLED     = 688
ERROR_DBG_REPLY_LATER               = 689
ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE  = 690
ERROR_DBG_TERMINATE_THREAD          = 691
ERROR_DBG_TERMINATE_PROCESS         = 692
ERROR_DBG_CONTROL_C                 = 693
ERROR_DBG_PRINTEXCEPTION_C          = 694
ERROR_DBG_RIPEXCEPTION              = 695
ERROR_DBG_CONTROL_BREAK             = 696
ERROR_DBG_COMMAND_EXCEPTION         = 697
ERROR_DBG_EXCEPTION_HANDLED         = 766
ERROR_DBG_CONTINUE                  = 767

ERROR_ELEVATION_REQUIRED            = 740
ERROR_NOACCESS                      = 998

ERROR_CIRCULAR_DEPENDENCY           = 1059
ERROR_SERVICE_DOES_NOT_EXIST        = 1060
ERROR_SERVICE_CANNOT_ACCEPT_CTRL    = 1061
ERROR_SERVICE_NOT_ACTIVE            = 1062
ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063
ERROR_EXCEPTION_IN_SERVICE          = 1064
ERROR_DATABASE_DOES_NOT_EXIST       = 1065
ERROR_SERVICE_SPECIFIC_ERROR        = 1066
ERROR_PROCESS_ABORTED               = 1067
ERROR_SERVICE_DEPENDENCY_FAIL       = 1068
ERROR_SERVICE_LOGON_FAILED          = 1069
ERROR_SERVICE_START_HANG            = 1070
ERROR_INVALID_SERVICE_LOCK          = 1071
ERROR_SERVICE_MARKED_FOR_DELETE     = 1072
ERROR_SERVICE_EXISTS                = 1073
ERROR_ALREADY_RUNNING_LKG           = 1074
ERROR_SERVICE_DEPENDENCY_DELETED    = 1075
ERROR_BOOT_ALREADY_ACCEPTED         = 1076
ERROR_SERVICE_NEVER_STARTED         = 1077
ERROR_DUPLICATE_SERVICE_NAME        = 1078
ERROR_DIFFERENT_SERVICE_ACCOUNT     = 1079
ERROR_CANNOT_DETECT_DRIVER_FAILURE  = 1080
ERROR_CANNOT_DETECT_PROCESS_ABORT   = 1081
ERROR_NO_RECOVERY_PROGRAM           = 1082
ERROR_SERVICE_NOT_IN_EXE            = 1083
ERROR_NOT_SAFEBOOT_SERVICE          = 1084

ERROR_DEBUGGER_INACTIVE             = 1284

ERROR_PRIVILEGE_NOT_HELD            = 1314

ERROR_NONE_MAPPED                   = 1332

RPC_S_SERVER_UNAVAILABLE            = 1722

# Standard access rights
DELETE                           = 0x00010000
READ_CONTROL                     = 0x00020000
WRITE_DAC                        = 0x00040000
WRITE_OWNER                      = 0x00080000
SYNCHRONIZE                      = 0x00100000
STANDARD_RIGHTS_REQUIRED         = 0x000F0000
STANDARD_RIGHTS_READ             = READ_CONTROL
STANDARD_RIGHTS_WRITE            = READ_CONTROL
STANDARD_RIGHTS_EXECUTE          = READ_CONTROL
STANDARD_RIGHTS_ALL              = 0x001F0000
SPECIFIC_RIGHTS_ALL              = 0x0000FFFF

#--- Structures ---------------------------------------------------------------

# typedef struct _LSA_UNICODE_STRING {
#   USHORT Length;
#   USHORT MaximumLength;
#   PWSTR Buffer;
# } LSA_UNICODE_STRING,
#  *PLSA_UNICODE_STRING,
#  UNICODE_STRING,
#  *PUNICODE_STRING;
class UNICODE_STRING(Structure):
    _fields_ = [
        ("Length",          USHORT),
        ("MaximumLength",   USHORT),
        ("Buffer",          PVOID),
    ]

# From MSDN:
#
# typedef struct _GUID {
#   DWORD Data1;
#   WORD Data2;
#   WORD Data3;
#   BYTE Data4[8];
# } GUID;
class GUID(Structure):
    _fields_ = [
        ("Data1",   DWORD),
        ("Data2",   WORD),
        ("Data3",   WORD),
        ("Data4",   BYTE * 8),
]

# From MSDN:
#
# typedef struct _LIST_ENTRY {
#     struct _LIST_ENTRY *Flink;
#     struct _LIST_ENTRY *Blink;
# } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
class LIST_ENTRY(Structure):
    _fields_ = [
        ("Flink",   PVOID),     # POINTER(LIST_ENTRY)
        ("Blink",   PVOID),     # POINTER(LIST_ENTRY)
]

#==============================================================================
# This calculates the list of exported symbols.
_all = set(vars().keys()).difference(_all)
##__all__ = [_x for _x in _all if not _x.startswith('_')]
##__all__.sort()
#==============================================================================

```

`src/minidump/utils/winapi/kernel32.py`:

```py
from minidump.utils.winapi.defines import *
import enum


# DWORD WINAPI GetLastError(void);
def GetLastError():
    _GetLastError = windll.kernel32.GetLastError
    _GetLastError.argtypes = []
    _GetLastError.restype  = DWORD
    return _GetLastError()

class WindowsMinBuild(enum.Enum):
	WIN_XP = 2500
	WIN_2K3 = 3000
	WIN_VISTA = 5000
	WIN_7 = 7000
	WIN_8 = 8000
	WIN_BLUE = 9400
	WIN_10 = 9800

#utter microsoft bullshit commencing..
def getWindowsBuild():   
    class OSVersionInfo(ctypes.Structure):
        _fields_ = [
            ("dwOSVersionInfoSize" , ctypes.c_int),
            ("dwMajorVersion"      , ctypes.c_int),
            ("dwMinorVersion"      , ctypes.c_int),
            ("dwBuildNumber"       , ctypes.c_int),
            ("dwPlatformId"        , ctypes.c_int),
            ("szCSDVersion"        , ctypes.c_char*128)];
    GetVersionEx = getattr( ctypes.windll.kernel32 , "GetVersionExA")
    version  = OSVersionInfo()
    version.dwOSVersionInfoSize = ctypes.sizeof(OSVersionInfo)
    GetVersionEx( ctypes.byref(version) )    
    return version.dwBuildNumber

def get_all_access_flags():
    DELETE = 0x00010000
    READ_CONTROL = 0x00020000
    WRITE_DAC = 0x00040000
    WRITE_OWNER = 0x00080000

    SYNCHRONIZE = 0x00100000

    STANDARD_RIGHTS_REQUIRED = DELETE | READ_CONTROL | WRITE_DAC | WRITE_OWNER
    STANDARD_RIGHTS_ALL = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE

    if getWindowsBuild() >= WindowsMinBuild.WIN_VISTA.value:
        return STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF
    else:
        return STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFF

PROCESS_ALL_ACCESS = get_all_access_flags()

# Process access rights for OpenProcess
PROCESS_TERMINATE                 = 0x0001
PROCESS_CREATE_THREAD             = 0x0002
PROCESS_SET_SESSIONID             = 0x0004
PROCESS_VM_OPERATION              = 0x0008
PROCESS_VM_READ                   = 0x0010
PROCESS_VM_WRITE                  = 0x0020
PROCESS_DUP_HANDLE                = 0x0040
PROCESS_CREATE_PROCESS            = 0x0080
PROCESS_SET_QUOTA                 = 0x0100
PROCESS_SET_INFORMATION           = 0x0200
PROCESS_QUERY_INFORMATION         = 0x0400
PROCESS_SUSPEND_RESUME            = 0x0800
PROCESS_QUERY_LIMITED_INFORMATION = 0x1000

# Thread access rights for OpenThread
THREAD_TERMINATE                 = 0x0001
THREAD_SUSPEND_RESUME            = 0x0002
THREAD_ALERT                     = 0x0004
THREAD_GET_CONTEXT               = 0x0008
THREAD_SET_CONTEXT               = 0x0010
THREAD_SET_INFORMATION           = 0x0020
THREAD_QUERY_INFORMATION         = 0x0040
THREAD_SET_THREAD_TOKEN          = 0x0080
THREAD_IMPERSONATE               = 0x0100
THREAD_DIRECT_IMPERSONATION      = 0x0200
THREAD_SET_LIMITED_INFORMATION   = 0x0400
THREAD_QUERY_LIMITED_INFORMATION = 0x0800

# typedef struct DECLSPEC_ALIGN(16) _MEMORY_BASIC_INFORMATION64 {
#     ULONGLONG BaseAddress;
#     ULONGLONG AllocationBase;
#     DWORD     AllocationProtect;
#     DWORD     __alignment1;
#     ULONGLONG RegionSize;
#     DWORD     State;
#     DWORD     Protect;
#     DWORD     Type;
#     DWORD     __alignment2;
# } MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;
class MEMORY_BASIC_INFORMATION64(Structure):
    _fields_ = [
        ('BaseAddress',         ULONGLONG),     # remote pointer
        ('AllocationBase',      ULONGLONG),     # remote pointer
        ('AllocationProtect',   DWORD),
        ('__alignment1',        DWORD),
        ('RegionSize',          ULONGLONG),
        ('State',               DWORD),
        ('Protect',             DWORD),
        ('Type',                DWORD),
        ('__alignment2',        DWORD),
    ]

# typedef struct _MEMORY_BASIC_INFORMATION {
#     PVOID BaseAddress;
#     PVOID AllocationBase;
#     DWORD AllocationProtect;
#     SIZE_T RegionSize;
#     DWORD State;
#     DWORD Protect;
#     DWORD Type;
# } MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
class MEMORY_BASIC_INFORMATION(Structure):
    _fields_ = [
        ('BaseAddress',         SIZE_T),    # remote pointer
        ('AllocationBase',      SIZE_T),    # remote pointer
        ('AllocationProtect',   DWORD),
        ('RegionSize',          SIZE_T),
        ('State',               DWORD),
        ('Protect',             DWORD),
        ('Type',                DWORD),
    ]
PMEMORY_BASIC_INFORMATION = POINTER(MEMORY_BASIC_INFORMATION)


# HANDLE WINAPI OpenProcess(
#   __in  DWORD dwDesiredAccess,
#   __in  BOOL bInheritHandle,
#   __in  DWORD dwProcessId
# );
def OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId):
    _OpenProcess = windll.kernel32.OpenProcess
    _OpenProcess.argtypes = [DWORD, BOOL, DWORD]
    _OpenProcess.restype  = HANDLE

    hProcess = _OpenProcess(dwDesiredAccess, bool(bInheritHandle), dwProcessId)
    if hProcess == NULL:
        raise ctypes.WinError()
    return hProcess

# SIZE_T WINAPI VirtualQueryEx(
#   __in      HANDLE hProcess,
#   __in_opt  LPCVOID lpAddress,
#   __out     PMEMORY_BASIC_INFORMATION lpBuffer,
#   __in      SIZE_T dwLength
# );
def VirtualQueryEx(hProcess, lpAddress):
    _VirtualQueryEx = windll.kernel32.VirtualQueryEx
    _VirtualQueryEx.argtypes = [HANDLE, LPVOID, PMEMORY_BASIC_INFORMATION, SIZE_T]
    _VirtualQueryEx.restype  = SIZE_T

    lpBuffer  = MEMORY_BASIC_INFORMATION()
    dwLength  = sizeof(MEMORY_BASIC_INFORMATION)
    success   = _VirtualQueryEx(hProcess, lpAddress, byref(lpBuffer), dwLength)
    if success == 0:
        raise ctypes.WinError()
    return lpBuffer


# BOOL WINAPI ReadProcessMemory(
#   __in   HANDLE hProcess,
#   __in   LPCVOID lpBaseAddress,
#   __out  LPVOID lpBuffer,
#   __in   SIZE_T nSize,
#   __out  SIZE_T* lpNumberOfBytesRead
# );
def ReadProcessMemory(hProcess, lpBaseAddress, nSize):
    _ReadProcessMemory = windll.kernel32.ReadProcessMemory
    _ReadProcessMemory.argtypes = [HANDLE, LPVOID, LPVOID, SIZE_T, POINTER(SIZE_T)]
    _ReadProcessMemory.restype  = bool

    lpBuffer            = ctypes.create_string_buffer(b'', nSize)
    lpNumberOfBytesRead = SIZE_T(0)
    success = _ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, byref(lpNumberOfBytesRead))
    if not success and GetLastError() != ERROR_PARTIAL_COPY:
        raise ctypes.WinError()
    return str(lpBuffer.raw)[:lpNumberOfBytesRead.value]
```

`src/minidump/utils/winapi/psapi.py`:

```py

from minidump.utils.winapi.defines import *


# typedef struct _MODULEINFO {
#   LPVOID lpBaseOfDll;
#   DWORD  SizeOfImage;
#   LPVOID EntryPoint;
# } MODULEINFO, *LPMODULEINFO;
class MODULEINFO(Structure):
    _fields_ = [
        ("lpBaseOfDll",     LPVOID),    # remote pointer
        ("SizeOfImage",     DWORD),
        ("EntryPoint",      LPVOID),    # remote pointer
]
LPMODULEINFO = POINTER(MODULEINFO)

# BOOL WINAPI EnumProcessModules(
#   __in   HANDLE hProcess,
#   __out  HMODULE *lphModule,
#   __in   DWORD cb,
#   __out  LPDWORD lpcbNeeded
# );
def EnumProcessModules(hProcess):
    _EnumProcessModules = windll.psapi.EnumProcessModules
    _EnumProcessModules.argtypes = [HANDLE, LPVOID, DWORD, LPDWORD]
    _EnumProcessModules.restype = bool
    _EnumProcessModules.errcheck = RaiseIfZero

    size = 0x1000
    lpcbNeeded = DWORD(size)
    unit = sizeof(HMODULE)
    while 1:
        lphModule = (HMODULE * (size // unit))()
        _EnumProcessModules(hProcess, byref(lphModule), lpcbNeeded, byref(lpcbNeeded))
        needed = lpcbNeeded.value
        if needed <= size:
            break
        size = needed
    return [ lphModule[index] for index in range(0, int(needed // unit)) ]

def GetModuleFileNameExW(hProcess, hModule = None):
    _GetModuleFileNameExW = ctypes.windll.psapi.GetModuleFileNameExW
    _GetModuleFileNameExW.argtypes = [HANDLE, HMODULE, LPWSTR, DWORD]
    _GetModuleFileNameExW.restype = DWORD

    nSize = MAX_PATH
    while 1:
        lpFilename = ctypes.create_unicode_buffer(u"", nSize)
        nCopied = _GetModuleFileNameExW(hProcess, hModule, lpFilename, nSize)
        if nCopied == 0:
            raise ctypes.WinError()
        if nCopied < (nSize - 1):
            break
        nSize = nSize + MAX_PATH
    return lpFilename.value

# BOOL WINAPI GetModuleInformation(
#   __in   HANDLE hProcess,
#   __in   HMODULE hModule,
#   __out  LPMODULEINFO lpmodinfo,
#   __in   DWORD cb
# );
def GetModuleInformation(hProcess, hModule, lpmodinfo = None):
    _GetModuleInformation = windll.psapi.GetModuleInformation
    _GetModuleInformation.argtypes = [HANDLE, HMODULE, LPMODULEINFO, DWORD]
    _GetModuleInformation.restype = bool
    _GetModuleInformation.errcheck = RaiseIfZero

    if lpmodinfo is None:
        lpmodinfo = MODULEINFO()
    _GetModuleInformation(hProcess, hModule, byref(lpmodinfo), sizeof(lpmodinfo))
    return lpmodinfo
```

`src/minidump/utils/winapi/version.py`:

```py
from minidump.utils.winapi.defines import *
import ctypes
from ctypes import windll, byref, Structure

class _SYSTEM_INFO_OEM_ID_STRUCT(Structure):
    _fields_ = [
        ("wProcessorArchitecture",  WORD),
        ("wReserved",               WORD),
]

class _SYSTEM_INFO_OEM_ID(Union):
    _fields_ = [
        ("dwOemId",  DWORD),
        ("w",        _SYSTEM_INFO_OEM_ID_STRUCT),
]


class SYSTEM_INFO(Structure):
    _fields_ = [
        ("id",                              _SYSTEM_INFO_OEM_ID),
        ("dwPageSize",                      DWORD),
        ("lpMinimumApplicationAddress",     LPVOID),
        ("lpMaximumApplicationAddress",     LPVOID),
        ("dwActiveProcessorMask",           DWORD_PTR),
        ("dwNumberOfProcessors",            DWORD),
        ("dwProcessorType",                 DWORD),
        ("dwAllocationGranularity",         DWORD),
        ("wProcessorLevel",                 WORD),
        ("wProcessorRevision",              WORD),
    ]

    def __get_dwOemId(self):
        return self.id.dwOemId
    def __set_dwOemId(self, value):
        self.id.dwOemId = value
    dwOemId = property(__get_dwOemId, __set_dwOemId)

    def __get_wProcessorArchitecture(self):
        return self.id.w.wProcessorArchitecture
    def __set_wProcessorArchitecture(self, value):
        self.id.w.wProcessorArchitecture = value
    wProcessorArchitecture = property(__get_wProcessorArchitecture, __set_wProcessorArchitecture)

LPSYSTEM_INFO = ctypes.POINTER(SYSTEM_INFO)

class OSVERSIONINFOW(Structure):
    _fields_ = [
        ("dwOSVersionInfoSize", DWORD),
        ("dwMajorVersion",      DWORD),
        ("dwMinorVersion",      DWORD),
        ("dwBuildNumber",       DWORD),
        ("dwPlatformId",        DWORD),
        ("szCSDVersion",        WCHAR * 128),
    ]

class OSVERSIONINFOEXW(Structure):
    _fields_ = [
        ("dwOSVersionInfoSize", DWORD),
        ("dwMajorVersion",      DWORD),
        ("dwMinorVersion",      DWORD),
        ("dwBuildNumber",       DWORD),
        ("dwPlatformId",        DWORD),
        ("szCSDVersion",        WCHAR * 128),
        ("wServicePackMajor",   WORD),
        ("wServicePackMinor",   WORD),
        ("wSuiteMask",          WORD),
        ("wProductType",        BYTE),
        ("wReserved",           BYTE),
    ]


def GetSystemInfo():
    _GetSystemInfo = windll.kernel32.GetSystemInfo
    _GetSystemInfo.argtypes = [LPSYSTEM_INFO]
    _GetSystemInfo.restype  = None

    sysinfo = SYSTEM_INFO()
    _GetSystemInfo(byref(sysinfo))
    return sysinfo

def GetVersionExW():
    _GetVersionExW = windll.kernel32.GetVersionExW
    _GetVersionExW.argtypes = [POINTER(OSVERSIONINFOEXW)]
    _GetVersionExW.restype  = bool
    _GetVersionExW.errcheck = RaiseIfZero

    osi = OSVERSIONINFOEXW()
    osi.dwOSVersionInfoSize = sizeof(osi)
    try:
        _GetVersionExW(byref(osi))
    except WindowsError:
        osi = OSVERSIONINFOW()
        osi.dwOSVersionInfoSize = sizeof(osi)
        _GetVersionExW.argtypes = [POINTER(OSVERSIONINFOW)]
        _GetVersionExW(byref(osi))
    return osi

def GetFileVersionInfoW(lptstrFilename):
    _GetFileVersionInfoW = windll.version.GetFileVersionInfoW
    _GetFileVersionInfoW.argtypes = [LPWSTR, DWORD, DWORD, LPVOID]
    _GetFileVersionInfoW.restype  = bool
    _GetFileVersionInfoW.errcheck = RaiseIfZero

    _GetFileVersionInfoSizeW = windll.version.GetFileVersionInfoSizeW
    _GetFileVersionInfoSizeW.argtypes = [LPWSTR, LPVOID]
    _GetFileVersionInfoSizeW.restype  = DWORD
    _GetFileVersionInfoSizeW.errcheck = RaiseIfZero

    dwLen = _GetFileVersionInfoSizeW(lptstrFilename, None)
    lpData = ctypes.create_string_buffer(dwLen)  # not a string!
    _GetFileVersionInfoW(lptstrFilename, 0, dwLen, byref(lpData))
    return lpData
```

`src/minidump/win_datatypes.py`:

```py
#!/usr/bin/env python3
#
# Author:
#  Tamas Jos (@skelsec)
#

# https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx

class POINTER:
	def __init__(self, reader, finaltype):
		self.location = reader.tell()
		self.value = reader.read_uint()
		self.finaltype = finaltype
		
	def read(self, reader, override_finaltype = None):
		if self.value == 0:
			return None
		pos = reader.tell()
		reader.move(self.value)
		if override_finaltype:
			data = override_finaltype(reader)
		else:
			data = self.finaltype(reader)
		reader.move(pos)
		return data
	
	def read_raw(self, reader, size ):
		#we do not know the finaltype, just want the data
		if self.value == 0:
			return None
		pos = reader.tell()
		reader.move(self.value)
		data = reader.read(size)
		reader.move(pos)
		return data
		
class PVOID(POINTER):
	def __init__(self, reader):
		super().__init__(reader, None) #with void we cannot determine the final type
		
class BOOL:
	def __init__(self, reader):
		self.value = bool(reader.read_uint())
		
class BOOLEAN:
	def __init__(self, reader):
		self.value = reader.read(1)
		
class BYTE:
	def __init__(self, reader):
		self.value = reader.read(1)
		
class PBYTE(POINTER):
	def __init__(self, reader):
		super().__init__(reader, BYTE)

class CCHAR:
	def __init__(self, reader):
		self.value = reader.read(1).decode('ascii')
		
class CHAR:
	def __init__(self, reader):
		self.value = reader.read(1).decode('ascii')
		
class UCHAR:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(1), byteorder = 'little', signed = False)

class WORD:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(2), byteorder = 'little', signed = False)		

class DWORD:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)
		
class DWORDLONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = False)
		
class DWORD_PTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, DWORD)
		
class DWORD32:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)

class DWORD64:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = False)		

	
class HANDLE:
	def __init__(self, reader):
		self.value = reader.read_uint()
		
class HFILE:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)
		
class HINSTANCE:
	def __init__(self, reader):
		self.value = reader.read_uint()		
		

class HKEY:
	def __init__(self, reader):
		self.value = reader.read_uint()


class HKL:
	def __init__(self, reader):
		self.value = reader.read_uint()
		
class HLOCAL:
	def __init__(self, reader):
		self.value = reader.read_uint()

class INT:
	def __init__(self, reader):
		self.value = reader.read_int()

class INT_PTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, INT)

class UINT8:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(1), byteorder = 'little', signed = False)

class INT8:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(1), byteorder = 'little', signed = True)

class INT16:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(2), byteorder = 'little', signed = True)

class INT32:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = True)

class INT64:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = True)

class LONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = True)

class LONGLONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = True)

class LONG_PTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, LONG)

class LONG32:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = True)

class LONG64():
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = True)

class LPARAM(POINTER):
	def __init__(self, reader):
		super().__init__(reader, LONG)

class LPBOOL(POINTER):
	def __init__(self, reader):
		super().__init__(reader, BOOL)

class LPBYTE(POINTER):
	def __init__(self, reader):
		super().__init__(reader, BYTE)

class ULONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)
		
class ULONGLONG:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = False)

class ULONG32:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(4), byteorder = 'little', signed = False)
		
class ULONG64:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(8), byteorder = 'little', signed = False)
		
class PWSTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, None)
		
class PCHAR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, CHAR)
		
class USHORT:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(2), byteorder = 'little', signed = False)
		
class SHORT:
	def __init__(self, reader):
		self.value = int.from_bytes(reader.read(2), byteorder = 'little', signed = True)
		
#https://msdn.microsoft.com/en-us/library/windows/hardware/ff554296(v=vs.85).aspx
class LIST_ENTRY:
	def __init__(self, reader, finaltype = None):
		self.Flink = POINTER(reader, finaltype)
		self.Blink = POINTER(reader, finaltype)
		
class FILETIME:
	def __init__(self, reader):
		self.dwLowDateTime = DWORD(reader)
		self.dwHighDateTime = DWORD(reader)
		self.value = (self.dwHighDateTime.value << 32) + self.dwLowDateTime.value
		
class PUCHAR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, UCHAR)
		
class PCWSTR(POINTER):
	def __init__(self, reader):
		super().__init__(reader, None)
		
class SIZE_T:
	def __init__(self, reader):
		self.value = reader.read_uint()
		
		

		
```

`src/minidump/writer.py`:

```py
from minidump.constants import MINIDUMP_STREAM_TYPE, MINIDUMP_TYPE
from minidump.header import MinidumpHeader
from minidump.common_structs import MINIDUMP_LOCATION_DESCRIPTOR

from minidump.utils.winapi.version import GetSystemInfo, GetVersionExW
from minidump.utils.winapi.kernel32 import OpenProcess, PROCESS_ALL_ACCESS, VirtualQueryEx, ReadProcessMemory
from minidump.utils.winapi.psapi import EnumProcessModules, GetModuleInformation, GetModuleFileNameExW
from minidump.utils.winapi.version import GetFileVersionInfoW
from minidump.streams import MINIDUMP_SYSTEM_INFO, PROCESSOR_ARCHITECTURE, MINIDUMP_MODULE_LIST, \
	MINIDUMP_MODULE, VS_FIXEDFILEINFO, MINIDUMP_MEMORY_INFO_LIST, MINIDUMP_MEMORY_INFO, \
	AllocationProtect, MemoryType, MemoryState, \
	MINIDUMP_MEMORY64_LIST, MINIDUMP_MEMORY_DESCRIPTOR64

from minidump.streams.SystemInfoStream import PROCESSOR_ARCHITECTURE, PRODUCT_TYPE

from minidump.directory import MINIDUMP_DIRECTORY

import io

class MinidumpSystemReader:
	def __init__(self):
		pass

	def setup(self):
		pass

	def get_sysinfo(self):
		pass

	def get_modules(self):
		pass

	def get_sections(self):
		pass

	def get_memory(self):
		pass

	def get_threads(self):
		pass

	def get_exceptions(self):
		pass

class LiveSystemReader(MinidumpSystemReader):
	def __init__(self, pid):
		MinidumpSystemReader.__init__(self)
		self.pid = pid
		self.process_handle = None
		self.sysinfo = None
		self.meminfolist = None
		self.setup()

	def open_process(self):
		self.process_handle = OpenProcess(PROCESS_ALL_ACCESS, False, self.pid)

	def setup(self):
		self.open_process()

	def get_sysinfo(self):
		#https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo
		sysinfo_raw = GetSystemInfo()
		version_raw = GetVersionExW()

		sysinfo = MINIDUMP_SYSTEM_INFO()
		sysinfo.ProcessorArchitecture = PROCESSOR_ARCHITECTURE(sysinfo_raw.id.w.wProcessorArchitecture)
		sysinfo.ProcessorLevel = sysinfo_raw.wProcessorLevel
		sysinfo.ProcessorRevision = sysinfo_raw.wProcessorRevision
		#sysinfo.Reserved0 = None
		sysinfo.NumberOfProcessors = sysinfo_raw.dwNumberOfProcessors
		sysinfo.ProductType = PRODUCT_TYPE(version_raw.wProductType)
		sysinfo.MajorVersion = version_raw.dwMajorVersion
		sysinfo.MinorVersion = version_raw.dwMinorVersion
		sysinfo.BuildNumber = version_raw.dwBuildNumber
		sysinfo.PlatformId = version_raw.dwPlatformId
		sysinfo.CSDVersionRva = 0
		#sysinfo.Reserved1 = None
		sysinfo.SuiteMask = version_raw.wSuiteMask
		#sysinfo.Reserved2 = None

		sysinfo.CSDVersion = version_raw.szCSDVersion

		#below todo, keeping all zeroes for now..
		if sysinfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE.INTEL:
			sysinfo.VendorId = [0,0,0]
			sysinfo.VersionInformation = 0
			sysinfo.FeatureInformation = 0
			sysinfo.AMDExtendedCpuFeatures = 0
		else:
			sysinfo.ProcessorFeatures = [0,0]

		self.sysinfo_raw = sysinfo_raw

		return sysinfo


	def get_modules(self):
		#https://docs.microsoft.com/en-us/windows/win32/psapi/enumerating-all-modules-for-a-process
		#https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules
		#
		module_list = MINIDUMP_MODULE_LIST()
		for module in EnumProcessModules(self.process_handle):
			print(module)
			modinfo = GetModuleInformation(self.process_handle,module)
			modname = GetModuleFileNameExW(self.process_handle,module)
			fileversion_raw = GetFileVersionInfoW(modname)
			fileversion = VS_FIXEDFILEINFO.from_bytes(fileversion_raw)
			print(modname)
			mmod = MINIDUMP_MODULE()
			mmod.BaseOfImage = modinfo.lpBaseOfDll
			mmod.SizeOfImage = modinfo.SizeOfImage
			mmod.TimeDateStamp = fileversion.dwFileDateMS << 32 + fileversion.dwFileDateLS
			mmod.ModuleNameRva = None
			mmod.VersionInfo = fileversion
			mmod.CvRecord = 0 # TODO?
			mmod.MiscRecord = 0 # TODO?

			mmod.ModuleName = modname

			module_list.Modules.append(mmod)
		
		return module_list

	def get_sections(self):
		#https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex
		if self.sysinfo_raw is None:
			self.get_sysinfo()
		meminfolist = MINIDUMP_MEMORY_INFO_LIST()
		i = self.sysinfo_raw.lpMinimumApplicationAddress
		while i < self.sysinfo_raw.lpMaximumApplicationAddress:
			mi_raw = VirtualQueryEx(self.process_handle, i)
			mi = MINIDUMP_MEMORY_INFO()
			mi.BaseAddress = mi_raw.BaseAddress
			mi.AllocationBase = mi_raw.AllocationBase
			mi.AllocationProtect = mi_raw.AllocationProtect
			mi.RegionSize = mi_raw.RegionSize
			try:
				mi.State = MemoryState(mi_raw.State)
			except:
				mi.State = mi_raw.State
			try:
				mi.Protect = AllocationProtect(mi_raw.Protect)
			except:
				mi.Protect = mi_raw.Protect
			try:
				mi.Type = MemoryType(mi_raw.Type)
			except:
				mi.Type = mi_raw.Type

			meminfolist.entries.append(mi)
			print(str(mi))
			
			i += mi_raw.RegionSize
		self.meminfolist = meminfolist
		return meminfolist
	
	def get_threads(self):
		pass

	def get_exceptions(self):
		pass

	def get_memory(self):
		read_flags = [AllocationProtect.PAGE_EXECUTE_READ,
				AllocationProtect.PAGE_EXECUTE_READWRITE,
				AllocationProtect.PAGE_READONLY,
				AllocationProtect.PAGE_EXECUTE,
				AllocationProtect.PAGE_READWRITE,
				AllocationProtect.PAGE_WRITECOPY
		]
		memlist = MINIDUMP_MEMORY64_LIST()
		for section in self.meminfolist.entries:
			if section.Protect in read_flags:
				memdesc = MINIDUMP_MEMORY_DESCRIPTOR64()
				memdesc.StartOfMemoryRange = section.BaseAddress
				memdesc.DataSize = section.RegionSize
				print(section.Protect)
				data = ReadProcessMemory(self.process_handle, section.BaseAddress, section.RegionSize)
				input(data)
				memlist.MemoryRanges.append(memdesc)

		return memlist


class MinidumpWriter:
	def __init__(self,sysreader):
		self.sysreader = sysreader
		self.output_file = None

		self.streams = {} #stream type -> list of stream objects

		self.header = None
		self.directory_list = []
		self.directory_rva = 28
		self.header_size = None

		self.header_buffer = io.BytesIO()
		self.data_buffer = io.BytesIO()

	def prepare_header(self):
		self.header = MinidumpHeader()
		self.header.Version = 1
		self.header.ImplementationVersion = 1
		self.header.NumberOfStreams = len(self.streams) +1 # +1 is fot he memory info stream
		self.header.StreamDirectoryRva = self.directory_rva
		#self.header.CheckSum = None
		#self.header.Reserved = None
		#self.header.TimeDateStamp = None
		self.header.Flags = MINIDUMP_TYPE.MiniDumpWithFullMemory
		self.header_buffer.write(self.header.to_bytes())

	def prepare_directory(self):
		curr_pos = self.header_size
		for streamtype in self.streams:
			self.streams[streamtype].to_bytes(self.data_buffer)
			directory = MINIDUMP_DIRECTORY()
			directory.StreamType = streamtype
			directory.Location = curr_pos
			self.header_buffer.write(directory.to_bytes())

	def finalize_header(self):
		# currently only using the 32 bit MINIDUMP_LOCATION_DESCRIPTOR, this is because we expect that the header 
		# and any data in the header (including all streams data except memory stream) will not be bigger than 4GB
		# memory stream is a special case, as it cvan be longer than 4GB but the RVA to the beginning of the memory stream 
		# is not expected to be bigger than 4G max.
		# if this becomes the case then this all will fail :)
		header_size = 28
		header_size += len(self.streams) * 8 #this is for the dictionary itself, not the streams
		for stream in self.streams:
			header_size += self.streams[stream].get_size()
		
		header_size += 10 * 1024 #allocating 10k for the memory info

		self.prepare_header()
		self.prepare_directory()

		
		
		

	def create_streams(self):
		sysinfo = self.sysreader.get_sysinfo()
		self.streams[MINIDUMP_STREAM_TYPE.SystemInfoStream] = sysinfo

		print(str(sysinfo))
		moduleinfo = self.sysreader.get_modules()
		self.streams[MINIDUMP_STREAM_TYPE.ModuleListStream] = moduleinfo
		
		sections = self.sysreader.get_sections()
		self.streams[MINIDUMP_STREAM_TYPE.MemoryInfoListStream] = sections
		
		self.finalize_header()

		memory = self.sysreader.get_memory()
		
		
	#def get_total_streams_cnt(self):
	#	total = 0
	#	for t in self.streams:
	#		total += len(t)
	#	return total

	

		

	#def construct_directory(self):
	#
	#	total_streams = self.get_total_streams_cnt()
	#
	#	for stype in self.streams:			
	#		for stream in self.streams[stype]:
	#			
	#			stream
	#
	#			loc = MINIDUMP_LOCATION_DESCRIPTOR()
	#			loc.DataSize = 0
	#			loc.Rva = 0
	#			directory = MINIDUMP_DIRECTORY()
	#			directory.StreamType = stream
	#			self.directory.append()


	def write_header(self):
		hdr_pos = self.hdr_buff.tell()
		self.hdr_buff.seek(0,0)
		self.hdr_buff.write(self.construct_header())
		self.hdr_buff.seek(hdr_pos, 0)
		return


	def construct_directory(self):
		self.sysreader.get_sysinfo(self.hdr_buff, self.data_buff)
		self.stream_cnt += 1
		#modules
		#self.sysreader.get_modules(self.hdr_buff, self.data_buff)
		#self.stream_cnt += 1
		
		#write header
		self.write_header()
		

		#append datastream for memory, with correct rva
		
		#dump memory

	def run(self):
		self.create_streams()


if __name__ == '__main__':
	pid = 9600
	sysreader = LiveSystemReader(pid)
	writer = MinidumpWriter(sysreader)
	writer.run()

```

`tests/StringEncryptionFun/StringEncryptionFun.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StringEncryptionFun", "StringEncryptionFun\StringEncryptionFun.vcxproj", "{4DF88650-7AF7-450C-B867-534D2A5304E1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Debug|x64.ActiveCfg = Debug|x64
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Debug|x64.Build.0 = Debug|x64
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Debug|x86.ActiveCfg = Debug|Win32
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Debug|x86.Build.0 = Debug|Win32
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Release|x64.ActiveCfg = Release|x64
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Release|x64.Build.0 = Release|x64
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Release|x86.ActiveCfg = Release|Win32
		{4DF88650-7AF7-450C-B867-534D2A5304E1}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C233290A-8A7F-4F3C-879D-90EB09B42BEC}
	EndGlobalSection
EndGlobal

```

`tests/StringEncryptionFun/StringEncryptionFun/StringEncryptionFun.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4df88650-7af7-450c-b867-534d2a5304e1}</ProjectGuid>
    <RootNamespace>StringEncryptionFun</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="xorstr.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="decryption.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tests/StringEncryptionFun/StringEncryptionFun/StringEncryptionFun.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="xorstr.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="decryption.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`tests/StringEncryptionFun/StringEncryptionFun/decryption.cpp`:

```cpp
__declspec(noinline) void decrypt(char* decrypted, const char* encrypted)
{
	auto size = *(unsigned short*)encrypted;
	encrypted += 2;
	for (unsigned short i = 0; i < size; i++)
		*decrypted++ = *encrypted++ ^ 0x66;
}
```

`tests/StringEncryptionFun/StringEncryptionFun/main.cpp`:

```cpp
#include <cstdio>

static char g_encrypted[256] = "\x1C\x00\x12\x0e\x0f\x15\x46\x0f\x15\x46\x07\x08\x46\x03\x08\x05\x14\x1f\x16\x12\x03\x02\x46\x15\x12\x14\x0f\x08\x01\x66";

void decrypt(char* decrypted, const char* encrypted);

int main()
{
	char decrypted[256];
	decrypt(decrypted, g_encrypted);
	puts(decrypted);
}
```

`tests/emulate-process.py`:

```py
from dumpulator import Dumpulator, syscall
from dumpulator.native import *

# Dummy syscall implementations

@syscall
def ZwQueryVolumeInformationFile(dp: Dumpulator,
                                 FileHandle: HANDLE,
                                 IoStatusBlock: P(IO_STATUS_BLOCK),
                                 FsInformation: PVOID,
                                 Length: ULONG,
                                 FsInformationClass: FSINFOCLASS
                                 ):
    return STATUS_SUCCESS

@syscall
def ZwOpenKey(dp: Dumpulator,
              KeyHandle: P(HANDLE),
              DesiredAccess: ACCESS_MASK,
              ObjectAttributes: P(OBJECT_ATTRIBUTES)
              ):
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwQueryVirtualMemory(dp: Dumpulator,
                         ProcessHandle: HANDLE,
                         BaseAddress: PVOID,
                         MemoryInformationClass: MEMORY_INFORMATION_CLASS,
                         MemoryInformation: PVOID,
                         MemoryInformationLength: SIZE_T,
                         ReturnLength: P(SIZE_T)
                         ):
    return STATUS_SUCCESS

@syscall
def ZwOpenSection(dp: Dumpulator,
                  SectionHandle: P(HANDLE),
                  DesiredAccess: ACCESS_MASK,
                  ObjectAttributes: P(OBJECT_ATTRIBUTES)
                  ):
    return STATUS_NOT_IMPLEMENTED

@syscall
def ZwSetEvent(dp: Dumpulator,
               EventHandle: HANDLE,
               PreviousState: P(LONG)
               ):
    return STATUS_NOT_IMPLEMENTED

def main():
    dp = Dumpulator("StringEncryptionFun_x64.dmp")
    dp.start(dp.regs.rip)

if __name__ == '__main__':
    main()

```

`tests/execute-dump.py`:

```py
import sys

from dumpulator import Dumpulator

def main():
    if len(sys.argv) < 2:
        print("Usage: execute-dump.py my.dmp")
        sys.exit(1)

    dp = Dumpulator(sys.argv[1], trace=len(sys.argv) > 2)
    dp.start(dp.regs.cip)
    exit_code = dp.exit_code if dp.exit_code is not None else 1
    sys.exit(exit_code)

if __name__ == '__main__':
    main()

```

`tests/getting-started.py`:

```py
from dumpulator import Dumpulator

dp = Dumpulator("StringEncryptionFun_x64.dmp")
temp_addr = dp.allocate(256)
dp.call(0x140001000, [temp_addr, 0x140017000])
decrypted = dp.read_str(temp_addr)
print(f"decrypted: '{decrypted}'")

```

`tests/getting-started32.py`:

```py
from dumpulator import Dumpulator

dp = Dumpulator("StringEncryptionFun_x86.dmp")
temp_addr = dp.allocate(256)
dp.call(0x401000, [temp_addr, 0x413000])
decrypted = dp.read_str(temp_addr)
print(f"decrypted: '{decrypted}'")

```

`tests/x64dbg-tracedump.py`:

```py
# Based on: https://github.com/teemu-l/execution-trace-viewer (MIT)
# Licensed under MIT (not BSL)

import sys
import json
from capstone import *
from operator import attrgetter
from collections import OrderedDict

class TraceData:
    """TraceData class.

    Class for storing execution trace and bookmarks.

    Attributes:
        filename (str): A trace file name.
        arch (str): CPU architecture.
        ip_reg (str): Name of instruction pointer register
        pointer_size (int): Pointer size (4 in x86, 8 in x64)
        regs (dict): Register names and indexes
        trace (list): A list of traced instructions, registers and memory accesses.
        bookmarks (list): A list of bookmarks.
    """

    def __init__(self):
        """Inits TraceData."""
        self.filename = ""
        self.arch = ""
        self.ip_reg = ""
        self.pointer_size = 0
        self.regs = {}
        self.trace = []
        self.bookmarks = []

    def clear(self):
        """Clears trace and all data"""
        self.trace = []
        self.bookmarks = []

    def get_trace(self):
        """Returns a full trace

        Returns:
            list: Trace
        """
        return self.trace

    def get_regs(self):
        """Returns dict of registers and their indexes

        Returns:
            dict: Regs
        """
        return self.regs

    def get_regs_and_values(self, row):
        """Returns dict of registers and their values

        Returns:
            dict: Register names and values
        """
        registers = {}
        try:
            reg_values = self.trace[row]["regs"]
            for reg_name, reg_index in self.regs.items():
                reg_value = reg_values[reg_index]
                registers[reg_name] = reg_value
        except IndexError:
            print(f"Error. Could not get regs from row {row}.")
            return {}
        return registers

    def get_reg_index(self, reg_name):
        """Returns a register index

        Args:
            reg_name (str): Register name
        Returns:
            int: Register index
        """
        try:
            index = self.regs[reg_name]
        except KeyError:
            print("Unknown register")
        return index

    def get_modified_regs(self, row):
        """Returns modfied regs

        Args:
            row (int): Trace row index
        Returns:
            list: List of register names
        """
        modified_regs = []
        reg_values = self.trace[row]["regs"]
        next_row = row + 1
        if next_row < len(self.trace):
            next_row_data = self.trace[next_row]
            for reg_name, reg_index in self.regs.items():
                reg_value = reg_values[reg_index]
                next_reg_value = next_row_data["regs"][reg_index]
                if next_reg_value != reg_value:
                    modified_regs.append(reg_name)
        return modified_regs

    def get_trace_rows(self, rows):
        """Returns a trace of given rows

        Args:
            rows (list): List of trace indexes
        Returns:
            list: Trace
        """
        trace = []
        try:
            trace = [self.trace[int(i)] for i in rows]
        except IndexError:
            print("Error. Could not get trace rows.")
        return trace

    def get_instruction_pointer_name(self):
        """Returns an instruction pointer name

        Returns:
            str: Instruction pointer name
        """
        if self.ip_reg:
            return self.ip_reg
        elif "eip" in self.regs:
            return "eip"
        elif "rip" in self.regs:
            return "rip"
        elif "ip" in self.regs:
            return "ip"
        elif "pc" in self.regs:
            return "pc"
        return ""

    def get_instruction_pointer(self, row):
        """Returns a value of instruction pointer of given row

        Args:
            row: A row index in trace
        Returns:
            int: Address of instruction
        """
        ip = 0
        ip_reg = self.get_instruction_pointer_name()
        try:
            reg_index = self.regs[ip_reg]
            ip = self.trace[row]["regs"][reg_index]
        except IndexError:
            print(f"Error. Could not get IP from row {row}")
        return ip

    def set_comment(self, row, comment):
        """Adds a comment to trace

        Args:
            row (int): Row index in trace
            comment (str): Comment text
        """
        try:
            self.trace[row]["comment"] = str(comment)
        except IndexError:
            print(f"Error. Could not set comment to row {row}")

    def add_bookmark(self, new_bookmark, replace=False):
        """Adds a new bookmark

        Args:
            new_bookmark (Bookmark): A new bookmark
            replace (bool): Replace an existing bookmark if found on same row?
                Defaults to False.
        """
        for i, bookmark in enumerate(self.bookmarks):
            if bookmark.startrow == new_bookmark.startrow:
                if replace:
                    self.bookmarks[i] = new_bookmark
                    print(f"Bookmark at {bookmark.startrow} replaced.")
                else:
                    print(f"Error: bookmark at {bookmark.startrow} already exists.")
                return
        self.bookmarks.append(new_bookmark)
        self.sort_bookmarks()

    def delete_bookmark(self, index):
        """Deletes a bookmark

        Args:
            index (int): Index on bookmark list
        Returns:
            bool: True if bookmark deleted, False otherwise
        """
        try:
            del self.bookmarks[index]
        except IndexError:
            print(f"Error. Could not delete a bookmark {index}")
            return False
        return True

    def sort_bookmarks(self):
        """Sorts bookmarks by startrow"""
        self.bookmarks.sort(key=attrgetter("startrow"))

    def get_bookmark_from_row(self, row):
        """Returns a bookmark for a given trace row.

        Args:
            row (int): Trace row index
        Returns:
            Bookmark: Returns A Bookmark if found, None otherwise.
        """
        for bookmark in self.bookmarks:
            if bookmark.startrow <= row <= bookmark.endrow:
                return bookmark
        return None

    def get_bookmarks(self):
        """Returns all bookmarks

        Returns:
            list: List of bookmarks
        """
        return self.bookmarks

    def set_bookmarks(self, bookmarks):
        """Sets bookmarks

        Args:
            bookmarks (list): Bookmarks
        """
        self.bookmarks = bookmarks

    def clear_bookmarks(self):
        """Clears bookmarks"""
        self.bookmarks = []

# registers for x64dbg traces
# if you want to see more regs, add them here (in correct order)
# check the order of regs from REGISTERCONTEXT:
# https://github.com/x64dbg/x64dbg/blob/development/src/bridge/bridgemain.h#L723
X32_REGS = [
    "eax",
    "ecx",
    "edx",
    "ebx",
    "esp",
    "ebp",
    "esi",
    "edi",
    "eip",
    "eflags",
    "gs",
    "fs",
    "es",
    "ds",
    "cs",
    "ss",
    "dr0",
    "dr1",
    "dr2",
    "dr3",
    "dr6",
    "dr7",
]
X64_REGS = [
    "rax",
    "rcx",
    "rdx",
    "rbx",
    "rsp",
    "rbp",
    "rsi",
    "rdi",
    "r8",
    "r9",
    "r10",
    "r11",
    "r12",
    "r13",
    "r14",
    "r15",
    "rip",
    "eflags",
    "gs",
    "fs",
    "es",
    "ds",
    "cs",
    "ss",
    "dr0",
    "dr1",
    "dr2",
    "dr3",
    "dr6",
    "dr7",
]

def _get_regs(instr):
    regs = OrderedDict()
    for op in instr.operands:
        if op.type == CS_OP_REG:
            regs[instr.reg_name(op.value.reg)] = None
        elif op.type == CS_OP_MEM:
            if op.value.mem.base != 0:
                regs[instr.reg_name(op.value.mem.base)] = None
            if op.value.mem.index != 0:
                regs[instr.reg_name(op.value.mem.index)] = None
    for reg in instr.regs_read:
        regs[instr.reg_name(reg)] = None
    for reg in instr.regs_write:
        regs[instr.reg_name(reg)] = None
    return regs

# TODO: this function uses a lot of ram, modify it do allow accessing the trace as a stream
def open_x64dbg_trace(filename, tracef):
    """Opens x64dbg trace file

    Args:
        filename: name of trace file
        tracef: file handle of txt trace
    Returns:
        TraceData object
    """
    with open(filename, "rb") as f:
        trace_data = TraceData()
        trace_data.filename = filename

        # check first 4 bytes
        magic = f.read(4)
        if magic != b"TRAC":
            raise ValueError("Error, wrong file format.")

        json_length_bytes = f.read(4)
        json_length = int.from_bytes(json_length_bytes, "little")

        # read JSON blob
        json_blob = f.read(json_length)
        json_str = str(json_blob, "utf-8")
        arch = json.loads(json_str)["arch"]

        reg_masks = {}
        reg_indexes = {}
        if arch == "x64":
            regs = X64_REGS
            ip_reg = "rip"
            capstone_mode = CS_MODE_64
            pointer_size = 8  # qword
        else:
            regs = X32_REGS
            ip_reg = "eip"
            capstone_mode = CS_MODE_32
            pointer_size = 4  # dword

        for i, reg in enumerate(regs):
            reg_indexes[reg] = i
            reg_masks[reg] = 0xFFFFFFFFFFFFFFFF >> (64 - pointer_size * 8)
        reg_indexes["rflags"] = reg_indexes["eflags"]

        def add_reg(parent, child, mask):
            reg_indexes[child] = reg_indexes[parent]
            reg_masks[child] = mask

        if pointer_size == 8:
            for reg in X32_REGS[:9]:
                add_reg("r" + reg[1:], reg, 0xFFFFFFFF)

            add_reg("r8", "r8d", 0xFFFFFFFF)
            add_reg("r9", "r9d", 0xFFFFFFFF)
            add_reg("r10", "r10d", 0xFFFFFFFF)
            add_reg("r10", "r11d", 0xFFFFFFFF)
            add_reg("r10", "r12d", 0xFFFFFFFF)
            add_reg("r10", "r13d", 0xFFFFFFFF)
            add_reg("r10", "r14d", 0xFFFFFFFF)
            add_reg("r10", "r15d", 0xFFFFFFFF)

            add_reg("r8", "r8w", 0xFFFF)
            add_reg("r9", "r9w", 0xFFFF)
            add_reg("r10", "r10w", 0xFFFF)
            add_reg("r10", "r11w", 0xFFFF)
            add_reg("r10", "r12w", 0xFFFF)
            add_reg("r10", "r13w", 0xFFFF)
            add_reg("r10", "r14w", 0xFFFF)
            add_reg("r10", "r15w", 0xFFFF)

            add_reg("r8", "r8b", 0xFF)
            add_reg("r9", "r9b", 0xFF)
            add_reg("r10", "r10b", 0xFF)
            add_reg("r10", "r11b", 0xFF)
            add_reg("r10", "r12b", 0xFF)
            add_reg("r10", "r13b", 0xFF)
            add_reg("r10", "r14b", 0xFF)
            add_reg("r10", "r15b", 0xFF)

            add_reg("rsi", "sil", 0xFF)
            add_reg("rdi", "dil", 0xFF)
            add_reg("rbp", "bpl", 0xFF)
            add_reg("rsp", "spl", 0xFF)

        for reg in X32_REGS[:9]:
            add_reg(reg, reg[1:], 0xFFFF)

        add_reg("eax", "al", 0xFF)
        add_reg("eax", "ah", 0xFF00)
        add_reg("ebx", "bl", 0xFF)
        add_reg("ebx", "bh", 0xFF00)
        add_reg("ecx", "cl", 0xFF)
        add_reg("ecx", "ch", 0xFF00)
        add_reg("edx", "dl", 0xFF)
        add_reg("edx", "dh", 0xFF00)

        trace_data.arch = arch
        trace_data.ip_reg = ip_reg
        trace_data.regs = reg_indexes
        trace_data.pointer_size = pointer_size

        md = Cs(CS_ARCH_X86, capstone_mode)
        md.detail = True
        reg_values = [None] * len(regs)
        trace = []
        row_id = 0
        while f.read(1) == b"\x00":
            register_changes = int.from_bytes(f.read(1), "little")
            memory_accesses = int.from_bytes(f.read(1), "little")
            flags_and_opcode_size = int.from_bytes(f.read(1), "little")  # Bitfield
            thread_id_bit = (flags_and_opcode_size >> 7) & 1  # msb
            opcode_size = flags_and_opcode_size & 15  # 4 lsbs

            if thread_id_bit > 0:
                thread_id = int.from_bytes(f.read(4), "little")

            opcodes = f.read(opcode_size)

            register_change_position = []
            for _ in range(register_changes):
                register_change_position.append(int.from_bytes(f.read(1), "little"))

            register_change_new_data = []
            for _ in range(register_changes):
                register_change_new_data.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_flags = []
            for _ in range(memory_accesses):
                memory_access_flags.append(int.from_bytes(f.read(1), "little"))

            memory_access_addresses = []
            for _ in range(memory_accesses):
                memory_access_addresses.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_old_data = []
            for _ in range(memory_accesses):
                memory_access_old_data.append(
                    int.from_bytes(f.read(pointer_size), "little")
                )

            memory_access_new_data = []
            for i in range(memory_accesses):
                if memory_access_flags[i] & 1 == 0:
                    memory_access_new_data.append(
                        int.from_bytes(f.read(pointer_size), "little")
                    )

            reg_id = 0
            regchanges = ""
            for i, change in enumerate(register_change_position):
                reg_id += change
                if reg_id + i < len(regs):
                    reg_values[reg_id + i] = register_change_new_data[i]
                if reg_id + i < len(regs) and row_id > 0:
                    reg_name = regs[reg_id + i]
                    if reg_name is not ip_reg:
                        old_value = trace[-1]["regs"][reg_id + i]
                        new_value = register_change_new_data[i]
                        if old_value != new_value:
                            regchanges += f"{reg_name}: {hex(new_value)} "
                            if 0x7F > new_value > 0x1F:
                                regchanges += f"'{chr(new_value)}' "

            # disassemble
            ip = reg_values[reg_indexes[ip_reg]]
            for _address, _size, mnemonic, op_str in md.disasm_lite(opcodes, ip):
                disasm = mnemonic
                if op_str:
                    disasm += " " + op_str

            def get_reg(name):
                index = reg_indexes[name]
                mask = reg_masks[name]
                val = reg_values[index]
                if mask == 0xFF00:
                    mask = 0xFF
                    val >>= 8
                return val & mask

            # (somewhat) matches format in dumpulator.py _hook_code
            instr = next(md.disasm(opcodes, ip, 1))
            address = ip
            address_name = ""
            line = f"0x{address:x}{address_name}|{instr.mnemonic}"
            if instr.op_str:
                line += " "
                line += instr.op_str
            for reg in _get_regs(instr):
                line += f"|{reg}=0x{get_reg(reg):x}"
            line += "\n"
            tracef.write(line)

            mems = []
            mem = {}
            new_data_counter = 0
            for i in range(memory_accesses):
                flag = memory_access_flags[i]
                value = memory_access_old_data[i]
                mem["access"] = "READ"
                if flag & 1 == 0:
                    value = memory_access_new_data[new_data_counter]
                    mem["access"] = "WRITE"
                    new_data_counter += 1
                else:
                    pass
                    # memory value didn't change
                    # (it is read or overwritten with identical value)
                    # this has to be fixed somehow in x64dbg

                mem["addr"] = memory_access_addresses[i]

                # fix value (x64dbg saves all values as qwords)
                if "qword" in disasm:
                    pass
                elif "dword" in disasm:
                    value &= 0xFFFFFFFF
                elif "word" in disasm:
                    value &= 0xFFFF
                elif "byte" in disasm:
                    value &= 0xFF
                mem["value"] = value
                mems.append(mem.copy())

            if regchanges:
                trace[-1]["regchanges"] = regchanges

            trace_row = {}
            trace_row["id"] = row_id
            trace_row["ip"] = ip
            trace_row["disasm"] = disasm
            trace_row["regs"] = reg_values.copy()
            trace_row["opcodes"] = opcodes.hex()
            trace_row["mem"] = mems.copy()
            # trace_row["comment"] = ""
            trace.append(trace_row)
            row_id += 1

        trace_data.trace = trace
        return trace_data


def main():
    if len(sys.argv) < 2:
        print("Usage: x64dbg-tracedump my.trace64")
        return
    trace_file = sys.argv[1]
    with open(trace_file + ".txt", "w") as tracef:
        data = open_x64dbg_trace(trace_file, tracef)

if __name__ == '__main__':
    main()

```

`utils/parse_phnt.py`:

```py
# pip install libclang
import json
import sys
from typing import *
from clang.cindex import *
from collections import OrderedDict

# Resources:
# https://gregoryszorc.com/blog/2012/05/14/python-bindings-updates-in-clang-3.1/
# https://sudonull.com/post/907-An-example-of-parsing-C-code-using-libclang-in-Python
# https://github.com/StatisKit/AutoWIG
# https://github.com/tekord/Python-Clang-RTTI-Generator-Example

def filter_by_folder(
        nodes: Iterable[Cursor],
        folder: str
) -> Iterable[Cursor]:
    for i in nodes:
        if folder in str(i.location.file):
            yield i

def filter_by_kind(
    nodes: Iterable[Cursor],
    kinds: list
) -> Iterable[Cursor]:
    for i in nodes:
        if i.kind in kinds:
            yield i

class EnumType:
    def __init__(self, name: str):
        self.name = name.lstrip('_')
        self.values: [(str, int)] = []

    def format_python(self):
        r = f"class {self.name}(Enum):\n"
        for name, value in self.values:
            r += f"    {name} = {value}\n"
        r += f"make_global({self.name})\n"
        return r

class FunctionArgument:
    def __init__(self, name: str):
        self.name = name
        self.typename = ""
        self.is_ptr = False


class FunctionType:
    def __init__(self, name: str):
        self.name = name
        self.arguments: [FunctionArgument] = []

    def format_python(self):
        r = "@syscall\n"
        r += f"def {self.name}(dp: Dumpulator"
        indent = (len(self.name) + 5) * ' '
        a: FunctionArgument
        for i, a in enumerate(self.arguments):
            r += ",\n"
            pytype = f"P({a.typename})" if a.is_ptr else a.typename
            r += f"{indent}{a.name}: {pytype}"
        r += "\n"
        r += f"{indent}):\n"
        r += "    raise NotImplementedError()\n"

        return r

# This script was only tested on Windows, Visual Studio 2019
# phnt version: https://github.com/processhacker/phnt/commit/49539260245f4291b699884a9ef4552530c8cfa4
def main():
    if len(sys.argv) < 2:
        print("Usage: parse_phnt.py c:\\projects\\phnt")
        sys.exit(1)

    phnt_dir = sys.argv[1]
    index = Index.create()
    tu = index.parse("phnt.c", args=[f"-I{phnt_dir}"], options=TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD)
    diag: Diagnostic
    parse_errors = False
    for diag in tu.diagnostics:
        if diag.severity in [Diagnostic.Error, Diagnostic.Fatal]:
            print(diag)
            parse_errors = True
    if parse_errors:
        sys.exit(1)

    cursor: Cursor = tu.cursor
    phnt_nodes = list(filter_by_folder(cursor.get_children(), phnt_dir))
    e: Cursor
    system_enums = OrderedDict()

    # This is bad, these CursorKind.XXX are added in cindex.py, no autocomplete possible :(
    for e in filter_by_kind(cursor.get_children(), [CursorKind.ENUM_DECL]):
        if phnt_dir not in str(e.location.file):
            if e.spelling:
                et = EnumType(e.spelling)
                v: Cursor
                for v in e.get_children():
                    et.values.append((v.spelling, v.enum_value))
                if len(et.values) > 0:
                    system_enums[et.name] = et

    phnt_enums = OrderedDict()
    for e in filter_by_kind(phnt_nodes, [CursorKind.ENUM_DECL]):
        if e.spelling:
            et = EnumType(e.spelling)
            v: Cursor
            for v in e.get_children():
                et.values.append((v.spelling, v.enum_value))
            if len(et.values) > 0:
                phnt_enums[et.name] = et

    primitive_types = {
        "PVOID",
        "UCHAR",
        "CHAR",
        "USHORT",
        "ULONG",
        "LONG",
        "ULONG_PTR",
        "SIZE_T",
        "HANDLE",
        "ULONG64",
        "ULONGLONG",  # ULONG64
        "BYTE",  # UCHAR
        "RTL_ATOM",  # USHORT
        "NTSTATUS",  # ULONG
        "LANGID",  # USHORT
        "ALPC_HANDLE",  # HANDLE
        "NOTIFICATION_MASK",  # ULONG
        "SECURITY_INFORMATION",  # ULONG
        "EXECUTION_STATE",  # ULONG
        "SE_SIGNING_LEVEL",  # BYTE
        "ACCESS_MASK",  # ULONG
        "WNF_CHANGE_STAMP",  # ULONG
        "KAFFINITY",  # ULONG_PTR
        "BOOLEAN",  # bool
        "LOGICAL",  # ULONG
        "LCID",  # ULONG
        "LATENCY_TIME",  # Unnamed enum, hacked in by hand
        "PSID",  # PVOID
        "PWSTR",  # PVOID
    }

    f: Cursor
    functions = []
    for f in filter_by_kind(phnt_nodes, [CursorKind.FUNCTION_DECL]):
        if f.spelling.startswith("Zw"):
            ft = FunctionType(f.spelling)
            a: Cursor
            for a in f.get_arguments():
                at = FunctionArgument(a.spelling)
                at.typename = str(a.type.spelling) \
                    .replace("volatile ", "") \
                    .replace("const ", "")

                if at.typename.startswith("P") and at.typename not in phnt_enums and at.typename not in primitive_types:
                    at.is_ptr = True
                    at.typename = at.typename[1:]

                # Hacky workarounds
                if at.typename == "LPGUID":
                    at.is_ptr = True
                    at.typename = "GUID"
                elif at.typename == "VOID *" or at.typename == "void *":
                    at.typename = "PVOID"
                elif at.typename.startswith("struct _") and at.typename.endswith(" *"):
                    assert not at.is_ptr
                    at.is_ptr = True
                    at.typename = at.typename[8:-2]
                elif at.typename.endswith(" *"):
                    assert not at.is_ptr
                    at.is_ptr = True
                    at.typename = at.typename[:-2]
                elif at.typename.endswith(" []"):
                    assert not at.is_ptr
                    at.is_ptr = True
                    at.typename = at.typename[:-3]

                # Make sure the typename is a valid identifier
                if " " in at.typename:
                    ft.arguments.append(at)
                    print(ft.format_python())
                    assert False

                ft.arguments.append(at)
            functions.append(ft)

    unknown_types = set()
    struct_types = set()
    ft: FunctionType
    for ft in functions:
        at: FunctionArgument
        for at in ft.arguments:
            if not at.is_ptr and at.typename not in phnt_enums:
                if at.typename in system_enums:
                    print(f"Merge system enum {at.typename} into phnt_enums")
                    phnt_enums[at.typename] = system_enums[at.typename]
                elif at.typename not in primitive_types:
                    unknown_types.add(at.typename)
            elif at.is_ptr and at.typename not in primitive_types and at.typename not in phnt_enums:
                if at.typename in system_enums:
                    print(f"Merge system enum {at.typename} into phnt_enums")
                    phnt_enums[at.typename] = system_enums[at.typename]
                else:
                    struct_types.add(at.typename)
    print(f"Found {len(unknown_types)} unknown primitive types:")
    for t in unknown_types:
        print("  " + t + ";")

    if len(sys.argv) > 2 and sys.argv[2] == "json":
        with open("ntsyscalls.json", "w") as f:
            data = {}
            for fn in functions:
                args = []
                arg: FunctionArgument
                for arg in fn.arguments:
                    args.append({
                        'name': arg.name,
                        'type': arg.typename + ("*" if arg.is_ptr else "")
                    })
                data[fn.name] = args
            f.write(json.dumps(data, indent=2))
        with open("ntenums.json", "w") as f:
            data = {}
            e: EnumType
            for e in phnt_enums.values():
                values = []
                for name, value in e.values:
                    values.append({
                        'name': name,
                        'value': value
                    })
                data[e.name] = values
            f.write(json.dumps(data, indent=2))
    else:
        with open("ntsyscalls.py", "w") as f:
            for fn in functions:
                f.write(fn.format_python())
                f.write("\n")

        with open("ntenums.py", "w") as f:
            header = """
# Automatically generated with parse_phnt.py, do not edit
from enum import Enum
from .ntprimitives import make_global
            """
            f.write(header.strip() + "\n\n")

            for e in phnt_enums.values():
                f.write(e.format_python())
                f.write("\n")

        with open("ntstructs.py", "w") as f:
            header = """
# Automatically generated with parse_phnt.py, do not edit
            """
            f.write(header.strip() + "\n\n")

            for t in sorted(struct_types):
                f.write(f"class {t}:\n")
                f.write("    pass\n")
                f.write("\n")

if __name__ == '__main__':
    main()

```

`utils/phnt.c`:

```c
#include <phnt_windows.h>
#include <phnt.h>
```