Project Path: arc_gmh5225_Mergen_yxrh8vqe

Source Tree:

```txt
arc_gmh5225_Mergen_yxrh8vqe
├── CMakeLists.txt
├── LICENSE
├── README.md
└── lifter
    ├── CMakeLists.txt
    ├── CustomPasses.cpp
    ├── CustomPasses.h
    ├── LLVM-init.cpp
    ├── LLVM-init.h
    ├── OperandUtils.cpp
    ├── OperandUtils.h
    ├── ROPdetection.cpp
    ├── ROPdetection.h
    ├── Semantics.cpp
    ├── Semantics.h
    ├── includes.h
    ├── lifter.cpp
    ├── lifter.vcxproj
    ├── lifter.vcxproj.filters
    ├── lifter.vcxproj.user
    ├── nacibaba_opts.cpp
    ├── nacibaba_opts.h
    ├── utils.cpp
    └── utils.h

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16.0 FATAL_ERROR)

set(CMAKE_SYSTEM_VERSION 10.0 CACHE STRING "" FORCE)

project(lifter CXX C) # Add C here since we are specifying C standard as well

################################################################################
# Set target arch type if empty. Visual studio solution generator provides it.
################################################################################
if(NOT CMAKE_VS_PLATFORM_NAME)
    set(CMAKE_VS_PLATFORM_NAME "x64")
endif()
message("${CMAKE_VS_PLATFORM_NAME} architecture in use")

if(NOT ("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x64"
     OR "${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x86"))
    message(FATAL_ERROR "${CMAKE_VS_PLATFORM_NAME} arch is not supported!")
endif()

################################################################################
# Global configuration types
################################################################################
set(CMAKE_CONFIGURATION_TYPES
    "Debug"
    "Release"
    CACHE STRING "" FORCE
)

################################################################################
# Global compiler options
################################################################################
if(MSVC)
    # Set C++ standard to C++20
    set(CMAKE_CXX_STANDARD 20)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)

    # Set C standard to ISO C17 (2018)
    set(CMAKE_C_STANDARD 17)
    set(CMAKE_C_STANDARD_REQUIRED ON)

    # remove default flags provided with CMake for MSVC
    set(CMAKE_CXX_FLAGS "")
    set(CMAKE_CXX_FLAGS_DEBUG "")
    set(CMAKE_CXX_FLAGS_RELEASE "")
endif()

################################################################################
# Global linker options
################################################################################
if(MSVC)
    # remove default flags provided with CMake for MSVC
    set(CMAKE_EXE_LINKER_FLAGS "")
    set(CMAKE_MODULE_LINKER_FLAGS "")
    set(CMAKE_SHARED_LINKER_FLAGS "")
    set(CMAKE_STATIC_LINKER_FLAGS "")
    set(CMAKE_EXE_LINKER_FLAGS_DEBUG "${CMAKE_EXE_LINKER_FLAGS}")
    set(CMAKE_MODULE_LINKER_FLAGS_DEBUG "${CMAKE_MODULE_LINKER_FLAGS}")
    set(CMAKE_SHARED_LINKER_FLAGS_DEBUG "${CMAKE_SHARED_LINKER_FLAGS}")
    set(CMAKE_STATIC_LINKER_FLAGS_DEBUG "${CMAKE_STATIC_LINKER_FLAGS}")
    set(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS}")
    set(CMAKE_MODULE_LINKER_FLAGS_RELEASE "${CMAKE_MODULE_LINKER_FLAGS}")
    set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "${CMAKE_SHARED_LINKER_FLAGS}")
    set(CMAKE_STATIC_LINKER_FLAGS_RELEASE "${CMAKE_STATIC_LINKER_FLAGS}")
endif()

################################################################################
# Nuget packages function stub.
################################################################################
function(use_package TARGET PACKAGE VERSION)
    message(WARNING "No implementation of use_package. Create yours. "
                    "Package \"${PACKAGE}\" with version \"${VERSION}\" "
                    "for target \"${TARGET}\" is ignored!")
endfunction()


################################################################################
# Additional Global Settings(add specific info there)
################################################################################
include(CMake/GlobalSettingsInclude.cmake OPTIONAL)

################################################################################
# Use solution folders feature
################################################################################
set_property(GLOBAL PROPERTY USE_FOLDERS ON)

################################################################################
# Sub-projects
################################################################################
add_subdirectory(lifter)

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# Project Overview:
Mergen is a tool engineered to convert Assembly code into LLVM Intermediate Representation (IR).
This tool is designed for:
- The deobfuscation or devirtualization of obfuscated binary code
- The enhancement of the reverse engineering process, making it more efficient and effective, especially for complex software systems.

## Core Objectives:

### Deobfuscation

### Devirtualization

### Optimization

## Diagram
![image](https://github.com/loneicewolf/Mergen/assets/68499986/d557b048-9c77-49f2-82b2-ef299bc783c8)


## Operational Workflow of Mergen:
1. Parsing Assembly to LLVM IR:

    Initial Step: Mergen begins by parsing existing Assembly instructions into LLVM Intermediate Representation.

    Process: It continues this parsing process until it encounters a jump instruction or a return. `asm_to_zydis_to_lift` parses bytes to zydis Instructions to be lifted into llvm ir in the function `liftInstruction`. 

2. Analyzing Jumps and Returns:

    Jump Analysis: When a jump instruction is encountered, Mergen checks if the jump destination is a constant value.

    Return Analysis: For return instructions, the tool assesses whether the `ret` is part of a standard function return or a Return-Oriented Programming gadget used for jumping to the next handler. This involves checking for any modifications to the instruction pointer (xIP).

3. Solving Jump Destinations:

    Destination Resolution: If the jump is not to a constant or the return is identified as an ROP gadget, Mergen resolves where the control flow is intended to jump next.

4. Iterative Parsing and Analysis:

    Looping Process: The tool repeats the process from step 1, parsing subsequent asm instructions into LLVM IR.

    Termination Condition: This iteration continues until Mergen identifies a real `ret` instruction. A real ret is confirmed when the stack pointer (xSP) at the end of the function matches the xSP value at the start of the function.


## Missing features:

### multiple branch support

### identifying inline/outline functions



# Getting in touch
Join our [Mergen Discord Server](https://discord.gg/e3eftYguqB) to trade ideas or just chatting in general.

```

`lifter/CMakeLists.txt`:

```txt
set(PROJECT_NAME lifter)

################################################################################
# Source groups
################################################################################
set(Header_Files
    "includes.h"
    "LLVM-init.h"
    "nacibaba_opts.h"
    "OperandUtils.h"
    "ROPdetection.h"
    "Semantics.h"
    "utils.h"
)
source_group("Header Files" FILES ${Header_Files})

set(Source_Files
    "lifter.cpp"
    "LLVM-init.cpp"
    "nacibaba_opts.cpp"
    "OperandUtils.cpp"
    "ROPdetection.cpp"
    "Semantics.cpp"
    "utils.cpp"
)
source_group("Source Files" FILES ${Source_Files})

set(ALL_FILES
    ${Header_Files}
    ${Source_Files}
)

################################################################################
# Target
################################################################################
add_executable(${PROJECT_NAME} ${ALL_FILES})

use_props(${PROJECT_NAME} "${CMAKE_CONFIGURATION_TYPES}" "${DEFAULT_CXX_PROPS}")
set(ROOT_NAMESPACE lifter)

set_target_properties(${PROJECT_NAME} PROPERTIES
    VS_GLOBAL_KEYWORD "Win32Proj"
)
if("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x64")
    set_target_properties(${PROJECT_NAME} PROPERTIES
        INTERPROCEDURAL_OPTIMIZATION_RELEASE "TRUE"
    )
elseif("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x86")
    set_target_properties(${PROJECT_NAME} PROPERTIES
        INTERPROCEDURAL_OPTIMIZATION_RELEASE "TRUE"
    )
endif()
################################################################################
# Include directories
################################################################################
if("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x64")
    target_include_directories(${PROJECT_NAME} PUBLIC
        "${CMAKE_CURRENT_SOURCE_DIR}/../../zydis-4.0.0/include;"
        "${CMAKE_CURRENT_SOURCE_DIR}/../../llvm-project/llvm/include;"
        "${CMAKE_CURRENT_SOURCE_DIR}/../../zydis-4.0.0/dependencies/zycore/include;"
        "${CMAKE_CURRENT_SOURCE_DIR}/../../llvm-project/llvm/build/include"
    )
endif()

################################################################################
# Compile definitions
################################################################################
if("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x64")
    target_compile_definitions(${PROJECT_NAME} PRIVATE
        "$<$<CONFIG:Debug>:"
            "_DEBUG;"
            "UNICODE;"
            "_UNICODE"
        ">"
        "$<$<CONFIG:Release>:"
            "NDEBUG;"
            "_MBCS"
        ">"
        "_CONSOLE"
    )
elseif("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x86")
    target_compile_definitions(${PROJECT_NAME} PRIVATE
        "$<$<CONFIG:Debug>:"
            "_DEBUG"
        ">"
        "$<$<CONFIG:Release>:"
            "NDEBUG"
        ">"
        "WIN32;"
        "_CONSOLE;"
        "UNICODE;"
        "_UNICODE"
    )
endif()

################################################################################
# Compile and link options
################################################################################
if(MSVC)
    if("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x64")
        target_compile_options(${PROJECT_NAME} PRIVATE
            $<$<CONFIG:Release>:
                /MP;
                /O2;
                /Ob2;
                /Oi;
                /GT;
                /Oy;
                /Gy;
                /Ot
            >
            /permissive-;
            /sdl;
            /arch:AVX2;
            /W3;
            ${DEFAULT_CXX_DEBUG_INFORMATION_FORMAT};
            ${DEFAULT_CXX_EXCEPTION_HANDLING}
        )
    elseif("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x86")
        target_compile_options(${PROJECT_NAME} PRIVATE
            $<$<CONFIG:Release>:
                /Oi;
                /Gy
            >
            /permissive-;
            /sdl;
            /W3;
            ${DEFAULT_CXX_DEBUG_INFORMATION_FORMAT};
            ${DEFAULT_CXX_EXCEPTION_HANDLING}
        )
    endif()
    if("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x64")
        target_link_options(${PROJECT_NAME} PRIVATE
            $<$<CONFIG:Release>:
                /OPT:REF;
                /OPT:ICF
            >
            /DEBUG;
            /SUBSYSTEM:CONSOLE
        )
    elseif("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x86")
        target_link_options(${PROJECT_NAME} PRIVATE
            $<$<CONFIG:Release>:
                /OPT:REF;
                /OPT:ICF
            >
            /DEBUG;
            /SUBSYSTEM:CONSOLE
        )
    endif()
endif()

################################################################################
# Dependencies
################################################################################
if("${CMAKE_VS_PLATFORM_NAME}" STREQUAL "x64")
    set(ADDITIONAL_LIBRARY_DEPENDENCIES
        "$<$<CONFIG:Debug>:"
            "../../zydis-4.0.0/build/Debug/Zydis;"
            "../../zydis-4.0.0/build/zycore/Debug/Zycore;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMCore;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMExecutionEngine;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMC;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMCJIT;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSupport;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMX86CodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMX86Desc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMX86Info;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMOrcTargetProcess;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMOrcShared;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMRuntimeDyld;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMCDisassembler;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAsmPrinter;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMCFGuard;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMGlobalISel;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMInstrumentation;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSelectionDAG;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMTarget;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMBitWriter;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMObjCARCOpts;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMScalarOpts;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAggressiveInstCombine;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMInstCombine;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMCodeGenTypes;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMTransformUtils;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAnalysis;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMProfileData;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSymbolize;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoDWARF;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoPDB;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMObject;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMIRReader;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMBitReader;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMRemarks;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMBitstreamReader;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMCParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMTextAPI;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMBinaryFormat;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMTargetParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoCodeView;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoMSF;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoBTF;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMDemangle;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMPasses;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAArch64AsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMARMAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAVRAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMBPFAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMHexagonAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMLanaiAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMLoongArchAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMipsAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMSP430AsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMPowerPCAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMRISCVAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSparcAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSystemZAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMVEAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyAsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMX86AsmParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAArch64CodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMARMCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAVRCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMBPFCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMHexagonCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMLanaiCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMLoongArchCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMipsCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMSP430CodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMNVPTXCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMPowerPCCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMRISCVCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSparcCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSystemZCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMVECodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMXCoreCodeGen;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAArch64Desc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMARMDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAVRDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMBPFDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMHexagonDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMLanaiDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMLoongArchDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMipsDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMSP430Desc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMNVPTXDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMPowerPCDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMRISCVDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSparcDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSystemZDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMVEDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMXCoreDesc;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAArch64Info;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMARMInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAVRInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMBPFInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMHexagonInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMLanaiInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMLoongArchInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMipsInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMSP430Info;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMNVPTXInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMPowerPCInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMRISCVInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSparcInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMSystemZInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMVEInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMXCoreInfo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMCoroutines;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMExtensions;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMipo;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMIRPrinter;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMVectorize;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAArch64Utils;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUUtils;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMMIRParser;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMARMUtils;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMFrontendOpenMP;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMLinker;"
            "../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyUtils"
        ">"
        "$<$<CONFIG:Release>:"
            "../../zydis-4.0.0/build/Release/Zydis;"
            "../../zydis-4.0.0/build/zycore/Release/Zycore;"
            "../../llvm-project/llvm/build/Release/lib/LLVMCore;"
            "../../llvm-project/llvm/build/Release/lib/LLVMExecutionEngine;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMC;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMCJIT;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSupport;"
            "../../llvm-project/llvm/build/Release/lib/LLVMX86CodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMX86Desc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMX86Info;"
            "../../llvm-project/llvm/build/Release/lib/LLVMOrcTargetProcess;"
            "../../llvm-project/llvm/build/Release/lib/LLVMOrcShared;"
            "../../llvm-project/llvm/build/Release/lib/LLVMRuntimeDyld;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMCDisassembler;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAsmPrinter;"
            "../../llvm-project/llvm/build/Release/lib/LLVMCFGuard;"
            "../../llvm-project/llvm/build/Release/lib/LLVMGlobalISel;"
            "../../llvm-project/llvm/build/Release/lib/LLVMInstrumentation;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSelectionDAG;"
            "../../llvm-project/llvm/build/Release/lib/LLVMCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMTarget;"
            "../../llvm-project/llvm/build/Release/lib/LLVMBitWriter;"
            "../../llvm-project/llvm/build/Release/lib/LLVMObjCARCOpts;"
            "../../llvm-project/llvm/build/Release/lib/LLVMScalarOpts;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAggressiveInstCombine;"
            "../../llvm-project/llvm/build/Release/lib/LLVMInstCombine;"
            "../../llvm-project/llvm/build/Release/lib/LLVMCodeGenTypes;"
            "../../llvm-project/llvm/build/Release/lib/LLVMTransformUtils;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAnalysis;"
            "../../llvm-project/llvm/build/Release/lib/LLVMProfileData;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSymbolize;"
            "../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoDWARF;"
            "../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoPDB;"
            "../../llvm-project/llvm/build/Release/lib/LLVMObject;"
            "../../llvm-project/llvm/build/Release/lib/LLVMIRReader;"
            "../../llvm-project/llvm/build/Release/lib/LLVMBitReader;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMRemarks;"
            "../../llvm-project/llvm/build/Release/lib/LLVMBitstreamReader;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMCParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMTextAPI;"
            "../../llvm-project/llvm/build/Release/lib/LLVMBinaryFormat;"
            "../../llvm-project/llvm/build/Release/lib/LLVMTargetParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoCodeView;"
            "../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoMSF;"
            "../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoBTF;"
            "../../llvm-project/llvm/build/Release/lib/LLVMDemangle;"
            "../../llvm-project/llvm/build/Release/lib/LLVMPasses;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAArch64AsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMARMAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAVRAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMBPFAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMHexagonAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMLanaiAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMLoongArchAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMipsAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMSP430AsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMPowerPCAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMRISCVAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSparcAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSystemZAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMVEAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyAsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMX86AsmParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAArch64CodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMARMCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAVRCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMBPFCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMHexagonCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMLanaiCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMLoongArchCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMipsCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMSP430CodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMNVPTXCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMPowerPCCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMRISCVCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSparcCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSystemZCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMVECodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMXCoreCodeGen;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAArch64Desc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMARMDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAVRDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMBPFDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMHexagonDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMLanaiDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMLoongArchDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMipsDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMSP430Desc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMNVPTXDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMPowerPCDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMRISCVDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSparcDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSystemZDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMVEDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMXCoreDesc;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAArch64Info;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMARMInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAVRInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMBPFInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMHexagonInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMLanaiInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMLoongArchInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMipsInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMSP430Info;"
            "../../llvm-project/llvm/build/Release/lib/LLVMNVPTXInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMPowerPCInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMRISCVInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSparcInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMSystemZInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMVEInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMXCoreInfo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMCoroutines;"
            "../../llvm-project/llvm/build/Release/lib/LLVMExtensions;"
            "../../llvm-project/llvm/build/Release/lib/LLVMipo;"
            "../../llvm-project/llvm/build/Release/lib/LLVMIRPrinter;"
            "../../llvm-project/llvm/build/Release/lib/LLVMVectorize;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAArch64Utils;"
            "../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUUtils;"
            "../../llvm-project/llvm/build/Release/lib/LLVMMIRParser;"
            "../../llvm-project/llvm/build/Release/lib/LLVMARMUtils;"
            "../../llvm-project/llvm/build/Release/lib/LLVMFrontendOpenMP;"
            "../../llvm-project/llvm/build/Release/lib/LLVMLinker;"
            "../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyUtils"
        ">"
        "psapi;"
        "shell32;"
        "ole32;"
        "uuid;"
        "advapi32;"
        "delayimp;"
        "-delayload:shell32.dll;"
        "-delayload:ole32.dll;"
        "kernel32;"
        "user32;"
        "gdi32;"
        "winspool;"
        "oleaut32;"
        "comdlg32"
    )
endif()
target_link_libraries(${PROJECT_NAME} PRIVATE "${ADDITIONAL_LIBRARY_DEPENDENCIES}")


```

`lifter/LLVM-init.cpp`:

```cpp
#pragma once
#include "includes.h"
#include "OperandUtils.h"


```

`lifter/LLVM-init.h`:

```h
#pragma once

#include "includes.h"

```

`lifter/OperandUtils.cpp`:

```cpp
#pragma once
#include "includes.h"

// this file is where helper functions reside.

LPVOID file_base_g_operand;
ZyanU8* data_g_operand;

void initBases2(LPVOID file_base, ZyanU8* data) {
	file_base_g_operand = file_base;
	data_g_operand = data;
}



unordered_map<int,Value*> RegisterList;
unordered_map<Flag, Value*> FlagList;

IntegerType* getIntSize(int size, LLVMContext& context) {
	switch (size) {

	case 1: {
		return llvm::Type::getInt1Ty(context);
	}
	case 8: {
		return llvm::Type::getInt8Ty(context);
	}

	case 16: {
		return llvm::Type::getInt16Ty(context);
	}

	case 32: {
		return llvm::Type::getInt32Ty(context);
	}

	case 64: {
		return llvm::Type::getInt64Ty(context);
	}

	case 128: {
		return llvm::Type::getInt128Ty(context);
	}


	}
}


void Init_Flags2(LLVMContext& context, IRBuilder<>& builder) {

	auto zero = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt1Ty(context), 0);

	FlagList[FLAG_CF] = zero;
	FlagList[FLAG_PF] = zero;
	FlagList[FLAG_AF] = zero;
	FlagList[FLAG_ZF] = zero;
	FlagList[FLAG_SF] = zero;
	FlagList[FLAG_TF] = zero;
	FlagList[FLAG_IF] = zero;
	FlagList[FLAG_DF] = zero;
	FlagList[FLAG_OF] = zero;
}

// responsible of operations on RFLAG
Value* setFlag2(LLVMContext& context, IRBuilder<>& builder, Flag flag, Value* newValue = nullptr) {
	return FlagList[flag] = newValue;
	
}
Value* getFlag2(LLVMContext& context, IRBuilder<>& builder, Flag flag) {
	return FlagList[flag];
}





// instead of 1 variable
// have multiple variables that correspond to the flags

void Init_Flags(LLVMContext& context, IRBuilder<>& builder) {


	auto zero = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), 0);
	auto value = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), 2); // 2nd bit is reserved and always true

	auto flags = RegisterList[ZYDIS_REGISTER_RFLAGS];

	auto new_flag = builder.CreateAdd(zero, value);

	RegisterList[ZYDIS_REGISTER_RFLAGS] = new_flag;
}


//...
unordered_map<int, Value*> getRegisterList() {
	return RegisterList;
}

//...
void setRegisterList(unordered_map<int, Value*> newRegisterList) {
	RegisterList = newRegisterList;
}



Value* memoryAlloc;

void initMemoryAlloc(Value* allocArg) {
	memoryAlloc = allocArg;
}

unordered_map<int, Value*> InitRegisters(LLVMContext& context, IRBuilder<>& builder,Function* function, ZyanU64 rip) {

	int zydisRegister = ZYDIS_REGISTER_RAX; // Replace with desired key

	auto argEnd = function->arg_end();
	for (auto argIt = function->arg_begin(); argIt != argEnd; ++argIt) {

		if ((zydisRegister == ZYDIS_REGISTER_RSP) || (zydisRegister == ZYDIS_REGISTER_ESP)) {
			// we dont want to register Stack Pointer register as an argument, because then it confuses llvm
			zydisRegister++;
			continue;
		}

		llvm::Argument* arg = &*argIt;
		arg->setName(ZydisRegisterGetString((ZydisRegister)zydisRegister));
		// Check if it's the last argument, if its last argument, create a FLAGS argument where we store flags. probably create a struct for it instead
		if (std::next(argIt) == argEnd) {
			arg->setName("memory");
			memoryAlloc = arg;
		}
		else {
			RegisterList[(ZydisRegister)zydisRegister] = arg;
			zydisRegister++;
		}
	}

	// Initialize flag value, it will be always 2
	Init_Flags(context,builder);



	auto zero = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), 0);
	auto value = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), rip); 

	// initialize xIP value, should be function start, its here for stuff like getting .data or calling functions 
	auto new_rip = builder.CreateAdd(zero, value);
	// move initialized value into map
	RegisterList[ZYDIS_REGISTER_RIP] = new_rip;


	// initialize xSP value, as said, when xSP is not a defined value, optimizations get messy.
	auto stackvalue = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), STACKP_VALUE); 
	auto new_stack_pointer = builder.CreateAdd(stackvalue, zero);
	// move initialized value into map
	RegisterList[ZYDIS_REGISTER_RSP] = new_stack_pointer;

	return RegisterList;
}

// get the highest byte
// basically should be 0xFF00
Value* GetValueFromHighByteRegister(LLVMContext& context, IRBuilder<>& builder, int reg) {


	Value* fullRegisterValue = RegisterList[ZydisRegisterGetLargestEnclosing(ZYDIS_MACHINE_MODE_LONG_64,(ZydisRegister)reg) ];  // Assume we fetch the 64-bit RAX, RCX, etc.

	// Right-shift to bring the high-byte to the least-significant position
	Value* shiftedValue = builder.CreateLShr(fullRegisterValue, 8,"highreg");

	// Mask out other bits to extract the high byte
	Value* highByteValue = builder.CreateAnd(shiftedValue, 0xFF);

	return highByteValue;
}



// responsible for retrieving latest llvm SSA value from a asm register
Value* GetRegisterValue(LLVMContext& context, IRBuilder<>& builder, int key) {
	// ZYDIS_REGISTER_RFLAGS is bugged and it will return ZYDIS_REGISTER_NONE

	if (key == ZYDIS_REGISTER_AH || key == ZYDIS_REGISTER_CH || key == ZYDIS_REGISTER_DH || key == ZYDIS_REGISTER_BH) {
		return GetValueFromHighByteRegister(context, builder, key);
	}


	int newKey = (key != ZYDIS_REGISTER_RFLAGS) && (key != ZYDIS_REGISTER_RIP) ? ZydisRegisterGetLargestEnclosing(ZYDIS_MACHINE_MODE_LONG_64, (ZydisRegister)key) : key;


	if (RegisterList.find(newKey) == RegisterList.end()) {
		throw std::runtime_error("register not found"); exit(-1);
	}


	return RegisterList[newKey];

}






Value* SetValueToHighByteRegister(LLVMContext& context, IRBuilder<>& builder, int reg, Value* value) {
	int shiftValue = 8;

	// Convert key for high-byte registers to their 64-bit counterparts
	int fullRegKey = ZydisRegisterGetLargestEnclosing(ZYDIS_MACHINE_MODE_LONG_64, (ZydisRegister)reg);
	Value* fullRegisterValue = RegisterList[fullRegKey];

	// Ensure the value being shifted is of the correct type
	Value* eightBitValue = builder.CreateAnd(value, ConstantInt::get(value->getType(), 0xFF),"eight-bit");
	Value* shiftedValue = builder.CreateShl(eightBitValue, ConstantInt::get(value->getType(), shiftValue),"shl");

	// Create mask and clear the high-byte portion
	Value* mask = ConstantInt::get(Type::getInt64Ty(context), ~(0xFF << shiftValue));
	Value* clearedRegister = builder.CreateAnd(fullRegisterValue, mask,"clear-reg");

	shiftedValue = builder.CreateZExt(shiftedValue, fullRegisterValue->getType() );
	// Set the high-byte portion of the register
	Value* newRegisterValue = builder.CreateOr(clearedRegister, shiftedValue,"high_byte");

	return newRegisterValue;
}

// I dont remember the logic, however it should be related to this snippet:
// mov eax, 0x12345678
//--- eax = 0x12345678
//mov al,  0xFF
// --- eax = 0X123456FF
Value* SetValueToSubRegister(LLVMContext& context, IRBuilder<>& builder, int reg, Value* value) {
	// Convert key for sub-register to their 64-bit counterparts
	int fullRegKey = ZydisRegisterGetLargestEnclosing(ZYDIS_MACHINE_MODE_LONG_64, (ZydisRegister)reg);
	Value* fullRegisterValue = RegisterList[fullRegKey];

	// Mask the full register so that only the sub-register part is set to 0
	Value* maskedFullReg = builder.CreateAnd(fullRegisterValue, 0xFFFFFFFFFFFFFF00,"maskedreg");
	value = builder.CreateZExt(value, fullRegisterValue->getType());
	// Or the masked full register with the sub-register value to set the byte
	Value* updatedReg = builder.CreateOr(maskedFullReg, value,"newreg");

	// Store the updated value back to the full register (if necessary)
	// e.g. RegisterList[fullRegKey] = updatedReg;

	return updatedReg;


}

// same as above but for 16 bits
Value* SetValueToSubRegister2(LLVMContext& context, IRBuilder<>& builder, int reg, Value* value) {
	// Convert key for sub-register to their 64-bit counterparts
	int fullRegKey = ZydisRegisterGetLargestEnclosing(ZYDIS_MACHINE_MODE_LONG_64, (ZydisRegister)reg);
	Value* fullRegisterValue = RegisterList[fullRegKey];

	// Mask the full register so that only the sub-register part is set to 0
	Value* maskedFullReg = builder.CreateAnd(fullRegisterValue, 0xFFFFFFFFFFFF0000, "maskedreg");
	value = builder.CreateZExt(value, fullRegisterValue->getType());
	// Or the masked full register with the sub-register value to set the byte
	Value* updatedReg = builder.CreateOr(maskedFullReg, value, "newreg");

	// Store the updated value back to the full register (if necessary)
	// e.g. RegisterList[fullRegKey] = updatedReg;

	return updatedReg;


}

// responsible for setting a LLVM SSA Value
void SetRegisterValue(LLVMContext& context, IRBuilder<>& builder, int key, Value* value) {
    if ( 
        (key == ZYDIS_REGISTER_AH || key == ZYDIS_REGISTER_CH || key == ZYDIS_REGISTER_DH || key == ZYDIS_REGISTER_BH)) { // handling all 8 sub-registers
        value = SetValueToSubRegister(context, builder, key, value);


    }

	if ( ( (key >= ZYDIS_REGISTER_R8B) && (key <= ZYDIS_REGISTER_R15B) ) || ((key >= ZYDIS_REGISTER_AL) && (key <= ZYDIS_REGISTER_BL)) || ((key >= ZYDIS_REGISTER_SPL) && (key <= ZYDIS_REGISTER_DIL))) {

		value = SetValueToSubRegister(context, builder, key, value);
	}

	if (((key >= ZYDIS_REGISTER_AX) && (key <= ZYDIS_REGISTER_R15W))) {
		value = SetValueToSubRegister2(context, builder, key, value);
	}

    int newKey = (key != ZYDIS_REGISTER_RFLAGS) && (key != ZYDIS_REGISTER_RIP) ? ZydisRegisterGetLargestEnclosing(ZYDIS_MACHINE_MODE_LONG_64, (ZydisRegister)key) : key;

    RegisterList[newKey] = value;
}


// responsible for finding values of addresses ( [] )
Value* GetEffectiveAddress(LLVMContext& context, IRBuilder<>& builder, ZydisDecodedOperand& op, int possiblesize) {
	// First, compute the effective address.
	Value* effectiveAddress = nullptr;

	// Assuming op.mem.base is the base register and op.mem.index is the index register.
	// Also assuming op.mem.scale is the scale factor and op.mem.disp is the displacement.

	Value* baseValue = nullptr;
	if (op.mem.base != ZYDIS_REGISTER_NONE) {
		baseValue = GetRegisterValue(context, builder, op.mem.base);
		baseValue = builder.CreateZExtOrTrunc(baseValue,getIntSize( ZydisRegisterGetWidth(ZYDIS_MACHINE_MODE_LONG_64,op.mem.base), context) );
	}

	Value* indexValue = nullptr;
	if (op.mem.index != ZYDIS_REGISTER_NONE) {
		indexValue = GetRegisterValue(context, builder, op.mem.index);
		if (op.mem.scale > 1) {
			Value* scaleValue = ConstantInt::get(Type::getInt64Ty(context), op.mem.scale);
			indexValue = builder.CreateZExt(indexValue, Type::getInt64Ty(context));
			indexValue = builder.CreateMul(indexValue, scaleValue,"gea");
		}
	}

	if (baseValue && indexValue) {
		indexValue = builder.CreateZExtOrTrunc(indexValue, baseValue->getType(),"indexValue");
		effectiveAddress = builder.CreateAdd(baseValue, indexValue,"bvalueandindexvaluelea");
	}
	else if (baseValue) {
		effectiveAddress = baseValue;
	}
	else if (indexValue) {
		effectiveAddress = indexValue;
	}
	else {
		effectiveAddress = ConstantInt::get(Type::getInt64Ty(context), 0);
	}
	
	if (op.mem.disp.has_displacement) {
		
		Value* dispValue = ConstantInt::get(Type::getInt64Ty(context), (int)(op.mem.disp.value));
		effectiveAddress = builder.CreateAdd(effectiveAddress, dispValue,"effective_address");
	}

	return effectiveAddress;
}
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Value.h"
#include <vector>
#include <cassert>

using namespace llvm;

class ValueByteReference {
public:
	Value* value;
	short byteOffset;

	ValueByteReference(Value* val, short offset) : value(val), byteOffset(offset) {}
};

class lifterMemoryBuffer {
public:
	std::vector<ValueByteReference*> buffer; // Now storing pointers to ValueByteReference

	lifterMemoryBuffer() : buffer(STACKP_VALUE+0x100, nullptr) {} // Initialize with a default size, all nullptrs

	~lifterMemoryBuffer() {
		// Clean up dynamically allocated ValueByteReferences
		for (auto* ref : buffer) {
			delete ref;
		}
	}

	// addValueReference v = 0x12345678 at 0x0
	// v0 v1 v2 v3 =
	// when retrieved
	// v & 0xff + v & 0xff00 + v & 0xff0000 + v & 0xff000000

	void addValueReference(Value* value, unsigned address) {
		unsigned valueSizeInBytes = value->getType()->getIntegerBitWidth() / 8; 
		for (unsigned i = 0; i < valueSizeInBytes; i++) {
			// Ensure the buffer is large enough
			delete buffer[address + i];
			// Create a new reference for each byte
			buffer[address + i] = new ValueByteReference(value, i);
		}
	}

	Value* retrieveCombinedValue(llvm::IRBuilder<>& builder, unsigned startAddress, unsigned byteCount) {
		Value* result = nullptr;
		for (unsigned i = 0; i < byteCount; i++) {
			unsigned currentAddress = startAddress + i;
			if (currentAddress < buffer.size() && buffer[currentAddress] != nullptr) {
				auto* ref = buffer[currentAddress];
				llvm::Value* byteValue = extractByte(builder, ref->value, ref->byteOffset);
				if (!result) {
					result = builder.CreateZExt(byteValue, Type::getIntNTy(builder.getContext(), byteCount * 8));
				}
				else {
					llvm::Value* shiftedByteValue = builder.CreateShl(builder.CreateZExt(byteValue, Type::getIntNTy(builder.getContext(), byteCount*8) ), llvm::APInt(byteCount * 8, i * 8));
					result = builder.CreateAdd(result, shiftedByteValue);
				}
			}

		}
		return result;
	}

private:
	llvm::Value* extractByte(llvm::IRBuilder<>& builder, llvm::Value* value, unsigned byteOffset) {
		// Assuming the value is a 32-bit integer, adjust the shift amount based on the byte offset
		unsigned shiftAmount = byteOffset * 8;
		llvm::Value* shiftedValue = builder.CreateLShr(value, llvm::APInt(value->getType()->getIntegerBitWidth(), shiftAmount), "extractbyte");
		return builder.CreateTrunc(shiftedValue, Type::getInt8Ty(builder.getContext()));
	}
};


lifterMemoryBuffer globalBuffer;

// responsible for retrieving a value in SSA Value map
Value* GetOperandValue(LLVMContext& context, IRBuilder<>& builder, ZydisDecodedOperand& op, int possiblesize) {

	auto type = getIntSize(possiblesize, context);

	switch (op.type) {
		case ZYDIS_OPERAND_TYPE_REGISTER: {
			Value* value = GetRegisterValue(context, builder, op.reg.value);

			

			auto opBitWidth = op.size;  
			auto typeBitWidth = dyn_cast<IntegerType>(value->getType())->getBitWidth();
			auto new_value = 
				builder.CreateZExtOrTrunc(value, type, "trunc");
			return new_value;
		}
		case ZYDIS_OPERAND_TYPE_IMMEDIATE: {
			ConstantInt* val;
			if (op.imm.is_signed) {
				val = (ConstantInt*)llvm::ConstantInt::getSigned(type, op.imm.value.s);
			}
			else {
				val = llvm::ConstantInt::get(context, llvm::APInt(possiblesize, op.imm.value.u));
			}
			return val; 
		}
		case ZYDIS_OPERAND_TYPE_MEMORY: {
			// First, compute the effective address.
			Value* effectiveAddress = nullptr;

			// Assuming op.mem.base is the base register and op.mem.index is the index register.
			// Also assuming op.mem.scale is the scale factor and op.mem.disp is the displacement.

			Value* baseValue = nullptr;
			if (op.mem.base != ZYDIS_REGISTER_NONE) {
				baseValue = GetRegisterValue(context, builder, op.mem.base);



				baseValue = builder.CreateZExt(baseValue, Type::getInt64Ty(context));
			}


			Value* indexValue = nullptr;
			if (op.mem.index != ZYDIS_REGISTER_NONE) {
				indexValue = GetRegisterValue(context,builder,op.mem.index);
				indexValue = builder.CreateSExt(indexValue, Type::getInt64Ty(context));
				if (op.mem.scale > 1) {
					Value* scaleValue = ConstantInt::get(Type::getInt64Ty(context), op.mem.scale);
					indexValue = builder.CreateMul(indexValue, scaleValue);
				}
			}

			if (baseValue && indexValue) {
				effectiveAddress = builder.CreateAdd(baseValue, indexValue,"bvalue_indexvalue");
			}
			else if (baseValue) {
				effectiveAddress = baseValue;
			}
			else if (indexValue) {
				effectiveAddress = indexValue;
			}
			else {
				effectiveAddress = ConstantInt::get(Type::getInt64Ty(context), 0);
			}

			if (op.mem.disp.has_displacement) {
				Value* dispValue = ConstantInt::get(Type::getInt64Ty(context), (int) (op.mem.disp.value) );
				effectiveAddress = builder.CreateAdd(effectiveAddress, dispValue,"memory_addr");
			}

			// Load the value from the computed address.
			Type* loadType = getIntSize(possiblesize,context); // Determine based on op.mem.size or some other attribute
			//Value* pointer = builder.CreateIntToPtr(effectiveAddress, loadType->getPointerTo());

			std::vector<Value*> indices;
			indices.push_back(effectiveAddress); // First index is always 0 in this context
			
			Value* pointer = builder.CreateGEP(Type::getInt8Ty(context), memoryAlloc, indices, "GEPLoadxd-");
			


			if (isa<ConstantInt>(effectiveAddress)) {
				ConstantInt* effectiveAddressInt = dyn_cast<ConstantInt>(effectiveAddress);
				if (!effectiveAddressInt) return nullptr;

				uintptr_t addr = effectiveAddressInt->getZExtValue();
				uintptr_t mappedAddr = address_to_mapped_address(file_base_g_operand, addr);

				unsigned byteSize = loadType->getIntegerBitWidth() / 8;
				uintptr_t tempValue;

				if (mappedAddr > 0) {
					std::memcpy(&tempValue, reinterpret_cast<const void*>(data_g_operand + mappedAddr), byteSize);

					APInt readValue(byteSize * 8, tempValue);
					Constant* newVal = ConstantInt::get(loadType, readValue);
					return newVal;
				}
				
				if (addr > 0 && addr < STACKP_VALUE) { 
					
					auto newval = globalBuffer.retrieveCombinedValue(builder, addr, byteSize);
					return newval;

				}
				
				
			}


			/*
			if (isa<ConstantExpr>(pointer)) {
				if (Value* MapValue = GetMemoryValueFromMap(pointer)) { // MMap
					 return builder.CreateZExtOrTrunc(MapValue, loadType);
				}
				if (Operator* op = dyn_cast<Operator>(pointer)) { // Binary
					if (ConstantInt* CI = dyn_cast<ConstantInt>(op->getOperand(0))) {
						uintptr_t addr = CI->getZExtValue();
						uintptr_t mappedAddr = address_to_mapped_address(file_base_g_operand, addr);
						//cout << "mapppedaddr: " << mappedAddr << " addr: " << addr << "\n";
						if (mappedAddr > 0) {
							unsigned byteSize = loadType->getIntegerBitWidth() / 8;

							uintptr_t tempvalue;
							std::memcpy(&tempvalue, reinterpret_cast<const void*>(data_g_operand + mappedAddr), byteSize);


							APInt readValue(byteSize * 8, tempvalue);
							Constant* newVal = ConstantInt::get(loadType, readValue);
							return newVal;

						}
					}
				}
			}
			*/

			return builder.CreateLoad(loadType, pointer);
		}
		default: {
			throw std::runtime_error("operand type not implemented"); exit(-1);
		}
	}

}

// overwrite the first value with second
Value* merge(LLVMContext& context, IRBuilder<>& builder, Value* existingValue, Value* newValue) {
	// Get the bit width of the existing and new values
	unsigned existingBitWidth = existingValue->getType()->getIntegerBitWidth();
	unsigned newBitWidth = newValue->getType()->getIntegerBitWidth();

	if (newBitWidth >= existingBitWidth) {
		// If the new value is the same size or larger, completely overwrite the existing value
		return newValue;
	}
	// If the new value is smaller, create a mask for the existing value and overwrite it
	// Calculate the mask to keep the upper bits of the existing value
	llvm::APInt maskAPInt = llvm::APInt::getHighBitsSet(existingBitWidth, existingBitWidth - newBitWidth);
	Value* mask = llvm::ConstantInt::get(context, maskAPInt);

	// Apply the mask to the existing value
	Value* maskedExistingValue = builder.CreateAnd(existingValue, mask, "maskedExistingValue");

	// Extend the new value to match the bit width of the existing value
	Value* extendedNewValue = builder.CreateZExt(newValue, existingValue->getType(), "extendedNewValue");

	// Combine the masked existing value with the extended new value
	return builder.CreateOr(maskedExistingValue, extendedNewValue, "mergedValue");
	
}


// responsible for setting a value in SSA Value map
Value* SetOperandValue(LLVMContext& context, IRBuilder<>& builder, ZydisDecodedOperand& op, Value* value) {

	switch (op.type) {
		case ZYDIS_OPERAND_TYPE_REGISTER: {
			GetRegisterValue(context, builder, op.reg.value);
			
			SetRegisterValue(context, builder, op.reg.value, value);
			break;

		}case ZYDIS_OPERAND_TYPE_MEMORY:		{
			// Compute the effective address, as before.
			Value* effectiveAddress = nullptr;

			// Assuming op.mem.base is the base register and op.mem.index is the index register.
			// Also assuming op.mem.scale is the scale factor and op.mem.disp is the displacement.
			// base = zext
			// index = sext
			// imm = sext
			Value* baseValue = nullptr;
			if (op.mem.base != ZYDIS_REGISTER_NONE) {
				baseValue = GetRegisterValue(context, builder, op.mem.base);
				baseValue = builder.CreateZExt(baseValue, Type::getInt64Ty(context));
			}

			Value* indexValue = nullptr;
			if (op.mem.index != ZYDIS_REGISTER_NONE) {
				indexValue = GetRegisterValue(context, builder, op.mem.index);
				indexValue = builder.CreateSExt(indexValue, Type::getInt64Ty(context),"areyouok");
				if (op.mem.scale > 1) {
					Value* scaleValue = ConstantInt::get(Type::getInt64Ty(context), op.mem.scale);
					indexValue = builder.CreateMul(indexValue, scaleValue, "mul_ea");
				}
			}

			if (baseValue && indexValue) {
				effectiveAddress = builder.CreateAdd(baseValue, indexValue,"bvalue_indexvalue_set");
			}
			else if (baseValue) {
				effectiveAddress = baseValue;
			}
			else if (indexValue) {
				effectiveAddress = indexValue;
			}
			else {
				effectiveAddress = ConstantInt::get(Type::getInt64Ty(context), 0);
			}

			if (op.mem.disp.value) {
				Value* dispValue = ConstantInt::get(Type::getInt64Ty(context), op.mem.disp.value);
				effectiveAddress = builder.CreateAdd(effectiveAddress, dispValue,"disp_set");
			}

			// Store the value to the computed address.
			Type* storeType = getIntSize(op.size, context); // Determine based on op.mem.size or some other attribute
			//Value* pointer = builder.CreateIntToPtr(effectiveAddress, storeType->getPointerTo());
			std::vector<Value*> indices;
			indices.push_back(effectiveAddress); // First index is always 0 in this context

			Value* pointer = builder.CreateGEP(Type::getInt8Ty(context), memoryAlloc,indices,"GEPSTORE");
			Value* store = builder.CreateStore(value, pointer);  // Ensure `valueToSet` matches the expected type
			

			if (isa<ConstantInt>(effectiveAddress) ) {

				ConstantInt* effectiveAddressInt = cast<ConstantInt>(effectiveAddress);
				ConstantInt* valueInt = cast<ConstantInt>(value);
				unsigned bitWidth = valueInt->getBitWidth(); 
				uint64_t dataValue = valueInt->getZExtValue(); 

				globalBuffer.addValueReference(valueInt, effectiveAddressInt->getZExtValue());
			}

		
			return store;
		}
		break;

		default: {
			throw std::runtime_error("operand type not implemented"); exit(-1);
		}
	}

}


Value* getMemoryFromValue(LLVMContext& context, IRBuilder<>& builder, Value* value) {

	Type* storeType = value->getType(); // Determine based on op.mem.size or some other attribute
	//Value* pointer = builder.CreateIntToPtr(effectiveAddress, storeType->getPointerTo());
	std::vector<Value*> indices;
	indices.push_back(value); // First index is always 0 in this context

	Value* pointer = builder.CreateGEP(Type::getInt8Ty(context), memoryAlloc, indices, "GEPSTOREVALUE");

	return pointer;

}




Value* getFlag(LLVMContext& context, IRBuilder<>& builder, Flag flag) {
	Value* rflag_var = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);
	Value* position = ConstantInt::get(context, APInt(64, flag));
	// Create the '1 << position' value
	Value* one = ConstantInt::get(context, APInt(64, 1));
	Value* bit_position = builder.CreateShl(one, position, "getflag-shl");

	// Return if the bit at 'position' is set
	Value* and_result = builder.CreateAnd(rflag_var, bit_position, "getflag-and");
	return builder.CreateICmpNE(and_result, ConstantInt::get(context, APInt(64, 0)), "getflag-cmpne");
}

Value* setFlag(LLVMContext& context, IRBuilder<>& builder, Flag flag, Value* newValue) {
	Value* rflag_var = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);
	Value* position = ConstantInt::get(context, APInt(64, flag));
	// Create the '1 << position' value
	Value* one = ConstantInt::get(context, APInt(64, 1));
	Value* bit_position = builder.CreateShl(one, position);

	Value* inverse_mask = builder.CreateNot(bit_position);

	// Clear the flag at 'position' in the rflag_var
	Value* cleared_rflag = builder.CreateAnd(rflag_var, inverse_mask);

	// Shift the new value to the correct position
	Value* shifted_newValue = builder.CreateShl(builder.CreateZExtOrTrunc(newValue, Type::getInt64Ty(context)), position, "flagsetweird");
	SetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS, shifted_newValue);
	return shifted_newValue;
}
```

`lifter/OperandUtils.h`:

```h
#pragma once
#include "includes.h"
Value* GetRegisterValue(LLVMContext& context, IRBuilder<>& builder, int key);

void SetRegisterValue(LLVMContext& context, IRBuilder<>& builder, int key, Value* value);
unordered_map<int, Value*> InitRegisters(LLVMContext& context, IRBuilder<>& builder,Function* function, ZyanU64 rip);

Value* GetOperandValue(LLVMContext& context, IRBuilder<>& builder, ZydisDecodedOperand& op, int possiblesize);
Value* GetEffectiveAddress(LLVMContext& context, IRBuilder<>& builder, ZydisDecodedOperand& op, int possiblesize);
IntegerType* getIntSize(int size, LLVMContext& context);

Value* SetOperandValue(LLVMContext& context, IRBuilder<>& builder, ZydisDecodedOperand& op, Value* value);

unordered_map<int, Value*> getRegisterList();

void setRegisterList(unordered_map<int, Value*> newRegisterList);

Value* setFlag(LLVMContext& context, IRBuilder<>& builder, Flag flag, Value* newValue);
Value* getFlag(LLVMContext& context, IRBuilder<>& builder, Flag flag);


void initBases2(LPVOID file_base, ZyanU8* data);


Value* getMemoryFromValue(LLVMContext& context, IRBuilder<>& builder, Value* value);
```

`lifter/ROPdetection.cpp`:

```cpp
#include "includes.h"
#include "nacibaba_opts.h"
#include "OperandUtils.h"


LPVOID file_base_g;
ZyanU8* data_g;

#pragma once
#ifndef GEPLoadPass_H
#define GEPLoadPass_H

#include "includes.h"
#include "llvm/IR/PassManager.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Constants.h"


class GEPLoadPass : public llvm::PassInfoMixin<GEPLoadPass> {
public:

    // replace(?) if section is in --> IMAGE_SCN_MEM_EXECUTE
    // replace if section is in --> IMAGE_SCN_MEM_READ
    // dont replace if section is in --> IMAGE_SCN_MEM_WRITE
    llvm::PreservedAnalyses run(llvm::Module& M, llvm::ModuleAnalysisManager&) {
        bool hasChanged = false;
        for (auto& F : M) {
            for (auto& BB : F) {
                for (auto& I : BB) {
                    if (auto* GEP = llvm::dyn_cast<llvm::GetElementPtrInst>(&I)) {
                        // Assuming the offset is the last operand
                        auto* OffsetOperand = GEP->getOperand(GEP->getNumOperands() - 1);
                        if (auto* ConstInt = llvm::dyn_cast<llvm::ConstantInt>(OffsetOperand)) {
                            uintptr_t constintvalue = (uintptr_t)ConstInt->getZExtValue();
                            if (uintptr_t offset = address_to_mapped_address(file_base_g, constintvalue)) {
                                for (auto* User : GEP->users()) {
                                    if (auto* LoadInst = llvm::dyn_cast<llvm::LoadInst>(User)) {
                                        llvm::Type* loadType = LoadInst->getType();

                                        // Read the value from the address
                                        unsigned byteSize = loadType->getIntegerBitWidth() / 8;
                                        uintptr_t tempvalue;
                                        // Replace with actual address fetching logic
                                        std::memcpy(&tempvalue, reinterpret_cast<const void*>(data_g + offset), byteSize);

                                        llvm::APInt readValue(byteSize * 8, tempvalue);
                                        llvm::Constant* newVal = llvm::ConstantInt::get(loadType, readValue);

                                        // Replace the load instruction
                                        LoadInst->replaceAllUsesWith(newVal);
                                        hasChanged = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return hasChanged ? llvm::PreservedAnalyses::none() : llvm::PreservedAnalyses::all() ;
    }
};


// here because this case is not properly optimized
// store i64 %arg, ptr yyy
// store i32 constant, ptr yyy
// %x = load i64, ptr %yyy
// %x1 = trunc i64 %x to i32
// this case it should've been
// %x1 = constant, however it doesnt properly optimize, so this is the fix

// while we are doing that, we can just if something is not stored just replace it with 0?
class ReplaceTruncWithLoadPass : public llvm::PassInfoMixin<ReplaceTruncWithLoadPass> {
public:
    llvm::PreservedAnalyses run(llvm::Module& M, llvm::ModuleAnalysisManager&) {
        bool hasChanged = false;
        std::vector<llvm::Instruction*> toRemove;
        for (auto& F : M) {
            for (auto& BB : F) {
                for (auto I = BB.begin(), E = BB.end(); I != E; ) {
                    // Use a temporary iterator to safely remove instructions
                    auto CurrentI = I++;

                    // Check for a trunc instruction
                    if (auto* TruncInst = llvm::dyn_cast<llvm::TruncInst>(&*CurrentI)) {
                        // Check if it truncates from i64 to i32
                        if (TruncInst->getSrcTy()->isIntegerTy(64) && TruncInst->getDestTy()->isIntegerTy(32)) {
                            // Check if the operand of trunc is a load instruction
                            if (auto* LoadInst = llvm::dyn_cast<llvm::LoadInst>(TruncInst->getOperand(0))) {
                                // Create a new load instruction for trunc size
                                llvm::LoadInst* newLoad = new llvm::LoadInst(TruncInst->getType(),
                                    LoadInst->getPointerOperand(),
                                    "passload",
                                    false,
                                    LoadInst);
                                // Replace uses of the trunc instruction with the new load
                                TruncInst->replaceAllUsesWith(newLoad);
                                // Remove the old trunc instruction
                                toRemove.push_back(TruncInst);
                                // Update the flag
                                hasChanged = true;
                            }
                        }
                    }
                }
            }
        }
        for (llvm::Instruction* Inst : toRemove) {
            Inst->eraseFromParent();
        }
        toRemove.clear();
        return hasChanged ? llvm::PreservedAnalyses::none() : llvm::PreservedAnalyses::all();
    }
};


// add new pass for replacing argument %memory with a alloca %memory for the last run,
// will only work for values < STACKP_VALUE
// this will get rid of deadstores, doing it manually 4now, but need2doit

#endif // GEPLoadPass_H


void initDetections(LPVOID file_base, ZyanU8* data) {
    file_base_g = file_base;
    data_g = data;
}



// detects if RSP matches the starting value of RSP
// normal function:
// 
// -- rsp = 0xffff
// push ecx 0xfff8
// ...etc...
// pop ecx  0xffff
// (before ret rsp = 0xffff)
// ret      
// 
// fake ret/function
// 
// -- rsp = 0xffff
// push ecx 0xfff8
// ...etc...
// pop ecx  0xffff
// push (next_handler) 0xfff8
// (before ret rsp = 0xfff8) 
// ret 
//

// basically apply bunch of optimizations and compare RSP
bool doesReturnRsp(Function* clonedFunc, BasicBlock& clonedBB, LPVOID file_base, ZyanU8* data) {
    //create clone of module/function then analyze it.
    file_base_g = file_base;
    data_g = data;

    if (llvm::isa<llvm::ReturnInst>(clonedBB.getTerminator())) {


        if (llvm::ConstantInt* constInt = dyn_cast<llvm::ConstantInt>(clonedBB.getTerminator()->getOperand(0))) {
            return constInt->getZExtValue() == 18446744073709551600;
        }

    }

    auto module = clonedFunc->getParent();
    auto FPM = std::make_unique<legacy::FunctionPassManager>(module);

    FPM.get()->add(createEarlyCSEPass(true));

    FPM.get()->add(create_nacibaba_replace_load_with_store_pass());

    FPM.get()->add(createEarlyCSEPass(true));

    FPM.get()->add(create_nacibaba_replace_load_from_memory(file_base, data));

    FPM.get()->add(createEarlyCSEPass(true));

    FPM.get()->add(create_nacibaba_replace_load_with_store_pass());

    FPM.get()->add(createInstructionCombiningPass());
    FPM.get()->add(createInstSimplifyLegacyPass());
    FPM.get()->add(createConstantHoistingPass());
    FPM.get()->add(createEarlyCSEPass(true));
    FPM.get()->add(createDeadCodeEliminationPass());


    FPM.get()->add(create_nacibaba_replace_load_from_memory(file_base, data));


    FPM.get()->add(createInstructionCombiningPass());

    FPM.get()->add(createInstSimplifyLegacyPass());
    FPM.get()->add(createConstantHoistingPass());

    FPM.get()->add(createEarlyCSEPass(true));
    FPM.get()->add(createDeadCodeEliminationPass());
    FPM.get()->add(createMergedLoadStoreMotionPass());
    //FPM.get()->add(CreateIntToPtrStackDSEPass());

    // create a pass that acatually works to promote memory to register
    // basically search for loads, if we stored a value to that load replace that value
    // problem 1:
    // multiple branches
    // we should fix control flow, then if we get the condition, since its SSA we can use the condition for branches and we create a select.
    //

    FPM.get()->doInitialization();
    FPM.get()->run(*clonedFunc);
    FPM.get()->doFinalization();
    bool result;

    // Check if the instruction is a return instruction
    if (llvm::isa<llvm::ReturnInst>(clonedBB.getTerminator())) {


        if (llvm::ConstantInt* constInt = dyn_cast<llvm::ConstantInt>(clonedBB.getTerminator()->getOperand(0))) {
            return constInt->getZExtValue() == 18446744073709551600;
        }

    }
    


    // after analysis
    return false;
}


//testing stuff......
void test_optxd(Function* clonedFuncx) {
    llvm::PassBuilder passBuilder;

    // Create a new module analysis manager
    llvm::LoopAnalysisManager loopAnalysisManager;
    llvm::FunctionAnalysisManager functionAnalysisManager;
    llvm::CGSCCAnalysisManager cGSCCAnalysisManager;
    llvm::ModuleAnalysisManager moduleAnalysisManager;

    // Register the analysis managers with the PassBuilder
    passBuilder.registerModuleAnalyses(moduleAnalysisManager);
    passBuilder.registerCGSCCAnalyses(cGSCCAnalysisManager);
    passBuilder.registerFunctionAnalyses(functionAnalysisManager);
    passBuilder.registerLoopAnalyses(loopAnalysisManager);
    passBuilder.crossRegisterProxies(loopAnalysisManager, functionAnalysisManager, cGSCCAnalysisManager, moduleAnalysisManager);

    // Create the module pass manager
    llvm::ModulePassManager modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O3);

    passBuilder.registerPipelineParsingCallback([&](llvm::StringRef Name, llvm::ModulePassManager& MPM, llvm::ArrayRef<llvm::PassBuilder::PipelineElement>) {
        if (Name == "gep-load-pass") {
            modulePassManager.addPass(GEPLoadPass());
            return true;
        }
        return false;
    });

    llvm::Module* module = clonedFuncx->getParent();

    bool changed;
    do {
        changed = false;

        size_t beforeSize = module->getInstructionCount();

        // Build and run the optimization pipeline
        modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O3);
        modulePassManager.addPass(GEPLoadPass());

        modulePassManager.addPass(ReplaceTruncWithLoadPass());
        modulePassManager.run(*module, moduleAnalysisManager);

        
        size_t afterSize = module->getInstructionCount();

        // Check if the module has changed
        if (beforeSize != afterSize) {
            changed = true;
        }

    } while (changed);
}

// lol idk, i got frustrated
void final_optpass(Function* clonedFuncx) {
    llvm::PassBuilder passBuilder;

    // Create a new module analysis manager
    llvm::LoopAnalysisManager loopAnalysisManager;
    llvm::FunctionAnalysisManager functionAnalysisManager;
    llvm::CGSCCAnalysisManager cGSCCAnalysisManager;
    llvm::ModuleAnalysisManager moduleAnalysisManager;

    // Register the analysis managers with the PassBuilder
    passBuilder.registerModuleAnalyses(moduleAnalysisManager);
    passBuilder.registerCGSCCAnalyses(cGSCCAnalysisManager);
    passBuilder.registerFunctionAnalyses(functionAnalysisManager);
    passBuilder.registerLoopAnalyses(loopAnalysisManager);
    passBuilder.crossRegisterProxies(loopAnalysisManager, functionAnalysisManager, cGSCCAnalysisManager, moduleAnalysisManager);

    // Create the module pass manager
    llvm::ModulePassManager modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O3);

    passBuilder.registerPipelineParsingCallback([&](llvm::StringRef Name, llvm::ModulePassManager& MPM, llvm::ArrayRef<llvm::PassBuilder::PipelineElement>) {
        if (Name == "gep-load-pass") {
            modulePassManager.addPass(GEPLoadPass());
            return true;
        }
        return false;
    });


    llvm::Module* module = clonedFuncx->getParent();

    bool changed;
    do {
        changed = false;

        size_t beforeSize = module->getInstructionCount();

        // Build and run the optimization pipeline
        modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O3);
        modulePassManager.addPass(GEPLoadPass());
        modulePassManager.addPass(ReplaceTruncWithLoadPass());
        modulePassManager.run(*module, moduleAnalysisManager);

        size_t afterSize = module->getInstructionCount();

        // Check if the module has changed
        if (beforeSize != afterSize) {
            changed = true;
        }

    } while (changed);
}


// check if the flag is a constant
opaque_info isOpaque(Function* clonedFunc , BasicBlock& clonedBB) {
    //create clone of module/function then analyze it.

    auto file_base = file_base_g;
    auto data = data_g;


    opaque_info result = NOT_OPAQUE;

    llvm::ReturnInst* returnInst = dyn_cast<llvm::ReturnInst>(clonedBB.getTerminator());

    // Assuming you want to check the return value of the ReturnInst
    if (returnInst->getReturnValue() != nullptr) {
        // Check if the return value is a constant integer
        if (llvm::ConstantInt* constInt = dyn_cast<llvm::ConstantInt>(returnInst->getReturnValue())) {
            if (constInt->getZExtValue() == 1) {
                result = OPAQUE_TRUE;
                return result;
            }
            else if (constInt->getZExtValue() == 0) {
                result = OPAQUE_FALSE;
                return result;
            }
        }
    }

    llvm::PassBuilder passBuilder;

    // Create a new module analysis manager
    llvm::LoopAnalysisManager loopAnalysisManager;
    llvm::FunctionAnalysisManager functionAnalysisManager;
    llvm::CGSCCAnalysisManager cGSCCAnalysisManager;
    llvm::ModuleAnalysisManager moduleAnalysisManager;

    // Register the analysis managers with the PassBuilder
    passBuilder.registerModuleAnalyses(moduleAnalysisManager);
    passBuilder.registerCGSCCAnalyses(cGSCCAnalysisManager);
    passBuilder.registerFunctionAnalyses(functionAnalysisManager);
    passBuilder.registerLoopAnalyses(loopAnalysisManager);
    passBuilder.crossRegisterProxies(loopAnalysisManager, functionAnalysisManager, cGSCCAnalysisManager, moduleAnalysisManager);

    // Create the module pass manager
    llvm::ModulePassManager modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O3);

    passBuilder.registerPipelineParsingCallback([&](llvm::StringRef Name, llvm::ModulePassManager& MPM, llvm::ArrayRef<llvm::PassBuilder::PipelineElement>) {
        if (Name == "gep-load-pass") {
            modulePassManager.addPass(GEPLoadPass());
            return true;
        }
        return false;
    });


    llvm::Module* module = clonedFunc->getParent();

    bool changed;
    do {
        changed = false;

        

        size_t beforeSize = module->getInstructionCount();

        // Build and run the optimization pipeline

        modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O0);
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(SROAPass(SROAOptions::PreserveCFG)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass(true)));
        modulePassManager.addPass(IPSCCPPass());
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(InstCombinePass()));

        modulePassManager.addPass(createModuleToFunctionPassAdaptor(SROAPass(SROAOptions::PreserveCFG)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass(true)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(InstCombinePass()));

        modulePassManager.addPass(createModuleToFunctionPassAdaptor(ReassociatePass()));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(DSEPass()));

        modulePassManager.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass(true)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(AggressiveInstCombinePass()));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(GVNPass()));

        modulePassManager.addPass(GEPLoadPass());
        modulePassManager.addPass(ReplaceTruncWithLoadPass());



        auto result = modulePassManager.run(*module, moduleAnalysisManager);

#ifdef _DEVELOPMENT
        std::string Filename2 = "output_opaque_opt2.ll";
        std::error_code EC2;
        llvm::raw_fd_ostream OS2(Filename2, EC2);
        clonedFunc->print(OS2);
#endif

        
        size_t afterSize = module->getInstructionCount();

        // Check if the module has changed
        if (beforeSize != afterSize) {
            changed = true;
        }

    } while (changed);


        
    returnInst = dyn_cast<llvm::ReturnInst>(clonedFunc->back().getTerminator());
        // Assuming you want to check the return value of the ReturnInst
        if (returnInst->getReturnValue() != nullptr) {
            // Check if the return value is a constant integer
            if (llvm::ConstantInt* constInt = dyn_cast<llvm::ConstantInt>(returnInst->getReturnValue())) {
                if (constInt->getZExtValue() == 1) {
                    result = OPAQUE_TRUE;
                }
                else if (constInt->getZExtValue() == 0) {
                    result = OPAQUE_FALSE;
                }
            }
        }



    return result;
}


// doesReturnRsp, but zesty
ROP_info isROP(Function* clonedFunc, BasicBlock& clonedBB, uintptr_t &dest) {
    //create clone of module/function then analyze it.

   

    auto file_base = file_base_g;
    auto data = data_g;

    ROP_info result = ROP_return;

    llvm::ReturnInst* returnInst = dyn_cast<llvm::ReturnInst>(clonedBB.getTerminator());
    IRBuilder<> builder(&clonedBB);
    Value* rspvalue = GetRegisterValue(clonedBB.getContext(), builder, ZYDIS_REGISTER_RSP);
    // Check if the integer operand is a constant integer
    if (llvm::ConstantInt* constInt = llvm::dyn_cast<llvm::ConstantInt>(rspvalue)) {
        int64_t rspval = constInt->getSExtValue();
        //cout << "rspval = " << rspval << "\n";
        result = rspval == STACKP_VALUE ? REAL_return : ROP_return;
        if (result == REAL_return) {
            return result;
        }
    }

    if (returnInst->getReturnValue() != nullptr) {
        // Get the value that is being returned
        llvm::Value* returnValue = returnInst->getReturnValue();
        if (llvm::ConstantInt* constInt = llvm::dyn_cast<llvm::ConstantInt>(returnValue)) {
            dest = constInt->getZExtValue();
            return result;
        }
    }
    // instead of passing function, lets pass a new module because this optimization shit only works with the module now
    llvm::PassBuilder passBuilder;

    // Create a new module analysis manager
    llvm::LoopAnalysisManager loopAnalysisManager;
    llvm::FunctionAnalysisManager functionAnalysisManager;
    llvm::CGSCCAnalysisManager cGSCCAnalysisManager;
    llvm::ModuleAnalysisManager moduleAnalysisManager;

    // Register the analysis managers with the PassBuilder
    passBuilder.registerModuleAnalyses(moduleAnalysisManager);
    passBuilder.registerCGSCCAnalyses(cGSCCAnalysisManager);
    passBuilder.registerFunctionAnalyses(functionAnalysisManager);
    passBuilder.registerLoopAnalyses(loopAnalysisManager);
    passBuilder.crossRegisterProxies(loopAnalysisManager, functionAnalysisManager, cGSCCAnalysisManager, moduleAnalysisManager);

    // Create the module pass manager
    llvm::ModulePassManager modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O3);

    passBuilder.registerPipelineParsingCallback([&](llvm::StringRef Name, llvm::ModulePassManager& MPM, llvm::ArrayRef<llvm::PassBuilder::PipelineElement>) {
        if (Name == "gep-load-pass") {
            modulePassManager.addPass(GEPLoadPass());
            return true;
        }
        return false;
    });


    llvm::Module* module = clonedFunc->getParent();

    bool changed;

    do {

        bool haschanged = false;
        changed = false;

        
        size_t beforeSize = module->getInstructionCount();

        // Build and run the optimization pipeline

        modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O0);
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(SROAPass(SROAOptions::PreserveCFG)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass(true)));
        modulePassManager.addPass(IPSCCPPass());
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(InstCombinePass()));

        modulePassManager.addPass(createModuleToFunctionPassAdaptor(SROAPass(SROAOptions::PreserveCFG)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass(true)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(InstCombinePass()));

        modulePassManager.addPass(createModuleToFunctionPassAdaptor(ReassociatePass()));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(DSEPass()));

        modulePassManager.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass(true)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(AggressiveInstCombinePass(  )));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(GVNPass()));
        modulePassManager.addPass(GEPLoadPass());
        modulePassManager.addPass(ReplaceTruncWithLoadPass());




        auto result = modulePassManager.run(*module, moduleAnalysisManager);

#ifdef _DEVELOPMENT
        std::string Filename2 = "output_rop_opt2.ll";
        std::error_code EC2;
        llvm::raw_fd_ostream OS2(Filename2, EC2);
        clonedFunc->print(OS2);
#endif

        
        std::string afterOptimization;
        size_t afterSize = module->getInstructionCount();

        // Check if the module has changed
        if (beforeSize != afterSize) {
            changed = true;
        }

    } while (changed);


    // create a pass that acatually works to promote memory to register
    // basically search for loads, if we stored a value to that load replace that value
    // problem 1:
    // multiple branches
    // we should fix control flow, then if we get the condition, since its SSA we can use the condition for branches and we create a select.
    //


        // Check if the integer operand is a constant integer
    if (llvm::ConstantInt* constInt = llvm::dyn_cast<llvm::ConstantInt>(rspvalue)) {
        int64_t rspval = constInt->getSExtValue();
        //cout << "rspval = " << rspval << "\n";
        result = rspval == STACKP_VALUE ? REAL_return : ROP_return;
        if (result == REAL_return) {
            return result;
       }
    }

    if (returnInst->getReturnValue() != nullptr) {
        // Get the value that is being returned
        llvm::Value* returnValue = returnInst->getReturnValue();
        if (llvm::ConstantInt* constInt = llvm::dyn_cast<llvm::ConstantInt>(returnValue)) {
            dest = constInt->getZExtValue();
           
        }
    }



    // Assuming you want to check the return value of the ReturnInst
    if (returnInst->getReturnValue() != nullptr) {
        // Get the value that is being returned
        llvm::Value* returnValue = returnInst->getReturnValue();
        if (llvm::ConstantInt* constInt = llvm::dyn_cast<llvm::ConstantInt>(returnValue)) {
            dest = constInt->getZExtValue();
        }
    }




    return result;
}

// is a real JOP or a switch case or smt?
JMP_info isJOP(Function* function, uintptr_t& dest) {
    //create clone of module/function then analyze it.

    // check to add if we already know the result


    JMP_info result = REAL_jmp;
    llvm::ReturnInst* returnInst = dyn_cast<llvm::ReturnInst>(function->back().getTerminator());

    if (returnInst = dyn_cast<llvm::ReturnInst>(function->back().getTerminator())) {
        // Assuming you want to check the return value of the ReturnInst
        if (returnInst->getReturnValue() != nullptr) {
            // Check if the return value is a constant integer
            if (llvm::ConstantInt* constInt = dyn_cast<llvm::ConstantInt>(returnInst->getReturnValue())) {
                dest = constInt->getZExtValue();
                result = JOP_jmp;
                return result;
            }
        }
    }

    llvm::ValueToValueMapTy VMap;
    llvm::Function* clonedFunctmp = llvm::CloneFunction(function, VMap);
    std::unique_ptr<Module> destinationModule = std::make_unique<Module>("destination_module", function->getContext());
    clonedFunctmp->removeFromParent();

    // Add the cloned function to the destination module
    destinationModule->getFunctionList().push_back(clonedFunctmp);

    Function* clonedFunc = destinationModule->getFunction(clonedFunctmp->getName());

    // instead of passing function, lets pass a new module because this optimization shit only works with the module now
    llvm::PassBuilder passBuilder;

    // Create a new module analysis manager
    llvm::LoopAnalysisManager loopAnalysisManager;
    llvm::FunctionAnalysisManager functionAnalysisManager;
    llvm::CGSCCAnalysisManager cGSCCAnalysisManager;
    llvm::ModuleAnalysisManager moduleAnalysisManager;

    // Register the analysis managers with the PassBuilder
    passBuilder.registerModuleAnalyses(moduleAnalysisManager);
    passBuilder.registerCGSCCAnalyses(cGSCCAnalysisManager);
    passBuilder.registerFunctionAnalyses(functionAnalysisManager);
    passBuilder.registerLoopAnalyses(loopAnalysisManager);
    passBuilder.crossRegisterProxies(loopAnalysisManager, functionAnalysisManager, cGSCCAnalysisManager, moduleAnalysisManager);

    // Create the module pass manager
    llvm::ModulePassManager modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O3);

    passBuilder.registerPipelineParsingCallback([&](llvm::StringRef Name, llvm::ModulePassManager& MPM, llvm::ArrayRef<llvm::PassBuilder::PipelineElement>) {
        if (Name == "gep-load-pass") {
            modulePassManager.addPass(GEPLoadPass());
            return true;
        }
        return false;
    });


    llvm::Module* module = clonedFunc->getParent();

    bool changed;
    do {
        changed = false;

        size_t beforeSize = module->getInstructionCount();

        // Build and run the optimization pipeline

        modulePassManager = passBuilder.buildPerModuleDefaultPipeline(OptimizationLevel::O0);
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(SROAPass(SROAOptions::PreserveCFG)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass(true)));
        modulePassManager.addPass(IPSCCPPass());
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(InstCombinePass()));

        modulePassManager.addPass(createModuleToFunctionPassAdaptor(SROAPass(SROAOptions::PreserveCFG)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass(true)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(InstCombinePass()));

        modulePassManager.addPass(createModuleToFunctionPassAdaptor(ReassociatePass()));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(DSEPass()));

        modulePassManager.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass(true)));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(AggressiveInstCombinePass()));
        modulePassManager.addPass(createModuleToFunctionPassAdaptor(GVNPass()));
        modulePassManager.addPass(GEPLoadPass());

        modulePassManager.addPass(ReplaceTruncWithLoadPass());



        auto result = modulePassManager.run(*module, moduleAnalysisManager);

        size_t afterSize = module->getInstructionCount();

        // Check if the module has changed
        if (beforeSize != afterSize) {
            changed = true;
        }

    } while (changed);



    //clonedFunc->print(outs());

    //we need to modify here when adding branches
    //maybe we add metadata to return instruction and search it?
    if (returnInst = dyn_cast<llvm::ReturnInst>(clonedFunc->back().getTerminator() )) {
        // Assuming you want to check the return value of the ReturnInst
        if (returnInst->getReturnValue() != nullptr) {
            // Check if the return value is a constant integer
            if (llvm::ConstantInt* constInt = dyn_cast<llvm::ConstantInt>(returnInst->getReturnValue())) {
                dest = constInt->getZExtValue();
                result = JOP_jmp;
            }
        }
    }


#ifdef _DEVELOPMENT
    std::string Filename2 = "output_afterJMP.ll";
    std::error_code EC2;
    llvm::raw_fd_ostream OS2(Filename2, EC2);
    clonedFunc->print(OS2);
#endif

    clonedFunc->eraseFromParent();
    return result;
}
```

`lifter/ROPdetection.h`:

```h
#pragma once
#include "includes.h"

bool doesReturnRsp(Function* clonedFunc, BasicBlock& clonedBB, LPVOID file_base, ZyanU8* data);
void test_optxd(Function* clonedFuncx);

void final_optpass(Function* clonedFuncx);


opaque_info isOpaque(Function* clonedFunc, BasicBlock& clonedBB);

void initDetections(LPVOID file_base, ZyanU8* data);

ROP_info isROP(Function* clonedFunc, BasicBlock& clonedBB, uintptr_t& dest);

JMP_info isJOP(Function* function, uintptr_t& dest);

```

`lifter/Semantics.cpp`:

```cpp
#include "includes.h"
#include "OperandUtils.h"
#include "ROPdetection.h"


/*

        Value* old_flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);



        auto sf = computeSignFlag(builder,Rvalue);
        auto zf = computeZeroFlag(builder,Rvalue);
        auto pf = computeParityFlag(builder,Rvalue);



        Value* new_flags = setFlag(context, builder, old_flags, FLAG_OF, sf);
        new_flags = setFlag(context, builder, old_flags, FLAG_ZF, zf);
        new_flags = setFlag(context, builder, old_flags, FLAG_PF, pf);



        


*/


Value* computeParityFlag(IRBuilder<>& builder, Value* value) {
    // Extract least significant byte
    Value* lsb = builder.CreateAnd(value, ConstantInt::get(value->getType(), 0xFF), "parity-and-lsb");

    // Compute the parity using bitwise operations
    lsb = builder.CreateXor(lsb, builder.CreateLShr(lsb, 4));
    lsb = builder.CreateXor(lsb, builder.CreateLShr(lsb, 2));
    lsb = builder.CreateXor(lsb, builder.CreateLShr(lsb, 1));

    // Extract the least significant bit (this will be our PF flag)
    Value* pf = builder.CreateAnd(lsb, ConstantInt::get(lsb->getType(), 1), "parityflag");

    // Return 1 - pf to match the semantics of the PF flag (1 if even set bits)
    return builder.CreateSub(ConstantInt::get(pf->getType(), 1), pf);
}

Value* computeZeroFlag(IRBuilder<>& builder, Value* value) {
    return builder.CreateICmpEQ(value, ConstantInt::get(value->getType(), 0), "zf");
}

Value* computeSignFlag(IRBuilder<>& builder, Value* value) {
    return builder.CreateICmpSLT(value, ConstantInt::get(value->getType(), 0), "sf");
}


void branchHelper(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses, Value* condition, Value* newRip, string instname, int numbered) {

    auto block = builder.GetInsertBlock();
    block->setName(instname + to_string(numbered));
    auto function = block->getParent();

    auto newcond = builder.CreateZExt(condition, function->getReturnType());
    auto lastinst = builder.CreateRet(newcond);

    llvm::ValueToValueMapTy VMap;
    //function->print(outs());
    llvm::Function* clonedFunctmp = llvm::CloneFunction(function, VMap);
    std::unique_ptr<Module> destinationModule = std::make_unique<Module>("destination_module", context);
    clonedFunctmp->removeFromParent();

    // Add the cloned function to the destination module
    destinationModule->getFunctionList().push_back(clonedFunctmp);

    Function* clonedFunc = destinationModule->getFunction(clonedFunctmp->getName());


    BasicBlock* clonedBlock = block;
    for (auto& blocks : *clonedFunc) {
        if (blocks.getName() == instname + to_string(numbered))
            clonedBlock = &blocks;
    }

#ifdef _DEVELOPMENT
    std::string Filename = "output_opaque_noopt.ll";
    std::error_code EC;
    llvm::raw_fd_ostream OS(Filename, EC);
    function->print(OS);
#endif
    opaque_info opaque = isOpaque(clonedFunc, *clonedBlock);

    lastinst->eraseFromParent();


#ifdef _DEVELOPMENT
    std::string Filename2 = "output_opaque_opt.ll";
    std::error_code EC2;
    llvm::raw_fd_ostream OS2(Filename2, EC2);
    clonedFunc->print(OS2);
#endif

    clonedFunc->eraseFromParent();
    block->setName("previous"+ instname+"-"+to_string(instruction.runtime_address)+"-");
    // i want to create a opaque detector here
    // if opaque, return 1 or 2
    // if not, return 0

    auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);
    auto result = newRip;
    auto dest = instruction.operands[0];
    switch (opaque) {
    case OPAQUE_TRUE: {
        string block_name = instname + "-jump";
        auto bb = llvm::BasicBlock::Create(context, block_name.c_str(), builder.GetInsertBlock()->getParent());

        SetRegisterValue(context, builder, ZYDIS_REGISTER_RIP, result);
        builder.CreateBr(bb);
        blockAddresses->push_back(make_tuple(dest.imm.value.s + instruction.runtime_address, bb, getRegisterList()));
        break;
    }
    case OPAQUE_FALSE: {
        string block_name2 = instname + "-notjump";
        auto bb2 = llvm::BasicBlock::Create(context, block_name2.c_str(), builder.GetInsertBlock()->getParent());
        result = ripval;
        SetRegisterValue(context, builder, ZYDIS_REGISTER_RIP, result);
        builder.CreateBr(bb2);

        blockAddresses->push_back(make_tuple(instruction.runtime_address, bb2, getRegisterList()));
        result = ripval;
        break;
    }
    case NOT_OPAQUE: {
        DebugBreak();
        string block_name = instname + "-jump";
        auto bb = llvm::BasicBlock::Create(context, block_name.c_str(), builder.GetInsertBlock()->getParent());
        string block_name2 = instname + "-notjump";
        auto bb2 = llvm::BasicBlock::Create(context, block_name2.c_str(), builder.GetInsertBlock()->getParent());


        SetRegisterValue(context, builder, ZYDIS_REGISTER_RIP, result);

        result = builder.CreateSelect(condition, newRip, ripval);
        builder.CreateCondBr(condition, bb, bb2);

        auto placeholder = ConstantInt::get(Type::getInt64Ty(context), 0);
        builder.SetInsertPoint(bb);

        builder.CreateRet(placeholder);

        builder.SetInsertPoint(bb2);

        builder.CreateRet(placeholder);

        blockAddresses->push_back(make_tuple(instruction.runtime_address, bb2, getRegisterList()));
        blockAddresses->push_back(make_tuple(dest.imm.value.s + instruction.runtime_address, bb, getRegisterList()));

    }
    }

}



namespace mov {


    void lift_movsb(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        // Fetch values from SI/ESI/RSI and DI/EDI/RDI
        Value* sourceValue = GetRegisterValue(context, builder, ZYDIS_REGISTER_RSI); // Adjust based on operand size
        Value* destValue = GetRegisterValue(context, builder, ZYDIS_REGISTER_RDI);

        // Fetch the byte from source
        Value* byteToMove = builder.CreateLoad(Type::getInt8Ty(context), getMemoryFromValue(context,builder, sourceValue));

        // Store the byte to destination
        builder.CreateStore(byteToMove, getMemoryFromValue(context, builder, destValue));

        // Check the direction flag
        Value* df = getFlag(context, builder, FLAG_DF);

        // Create the value to increment or decrement based on DF
        Value* offset = builder.CreateSelect(df, ConstantInt::get(sourceValue->getType(), -1), ConstantInt::get(sourceValue->getType(), 1));

        // Update SI/ESI/RSI and DI/EDI/RDI
        Value* updatedSource = builder.CreateAdd(sourceValue, offset);
        Value* updatedDest = builder.CreateAdd(destValue, offset);

        SetRegisterValue(context, builder, ZYDIS_REGISTER_RSI, updatedSource); // Adjust based on operand size
        SetRegisterValue(context, builder, ZYDIS_REGISTER_RDI, updatedDest);
    }


    void lift_mov(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];

        auto Rvalue = GetOperandValue(context, builder, src, src.size);


        if ((dest.type == ZYDIS_OPERAND_TYPE_MEMORY) && (src.type == ZYDIS_OPERAND_TYPE_IMMEDIATE) && (src.size < dest.size)) {
            Rvalue = GetOperandValue(context, builder, src, dest.size);

        }


        switch (instruction.info.mnemonic) {
        case ZYDIS_MNEMONIC_MOVSX: {
            Rvalue = builder.CreateSExt(Rvalue, getIntSize(dest.size, context), "movsx-" + to_string(instruction.runtime_address) + "-");
            break;
        }
        case ZYDIS_MNEMONIC_MOVZX: {
            Rvalue = builder.CreateZExt(Rvalue, getIntSize(dest.size, context), "movzx-" + to_string(instruction.runtime_address) + "-");
            break;
        }
        case ZYDIS_MNEMONIC_MOVSXD: {
            Rvalue = builder.CreateSExt(Rvalue, getIntSize(dest.size, context), "movsxd-" + to_string(instruction.runtime_address) + "-");
            break;
        }
        }
        SetOperandValue(context, builder, dest, Rvalue);


    }



};

namespace cmov {




// cmovbe = cmovbz
void lift_cmovbz(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the ZF and CF flags from RFLAGS register
    Value* zf = getFlag(context, builder, FLAG_ZF);
    Value* cf = getFlag(context, builder, FLAG_CF);

    // Check if either ZF or CF is set
    Value* condition = builder.CreateOr(zf, cf, "cmovbz-or");

    // Get values for source and destination operands
    Value* Rvalue = GetOperandValue(context, builder, src, dest.size);
    Value* Dvalue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    Value* result = builder.CreateSelect(condition, Rvalue, Dvalue);

    SetOperandValue(context, builder, dest, result);
}

void lift_cmovnbz(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Retrieve the values
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);
    Value* srcValue = GetOperandValue(context, builder, src, src.size);

    // Retrieve the carry flag (CF) and zero flag (ZF) from the EFLAGS/RFLAGS register
    Value* cf = getFlag(context, builder, FLAG_CF);
    Value* zf = getFlag(context, builder, FLAG_ZF);

    // Check if neither CF nor ZF is set
    Value* nbeCondition = builder.CreateAnd(builder.CreateNot(cf), builder.CreateNot(zf), "nbeCondition");

    // If nbeCondition is true, then the result is the srcValue; otherwise, it's the destValue
    Value* resultValue = builder.CreateSelect(nbeCondition, srcValue, destValue, "cmovnbe");

    // Update the operand with the result
    SetOperandValue(context, builder, dest, resultValue);
}




void lift_cmovz(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
    instruction.info.raw.disp.value;
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Retrieve the values
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);
    Value* srcValue = GetOperandValue(context, builder, src, src.size);

    // Retrieve the zero flag (ZF) from the EFLAGS/RFLAGS register
    Value* zf = getFlag(context, builder, FLAG_ZF);

    // If ZF is set, then the result is the srcValue; otherwise, it's the destValue
    Value* resultValue = builder.CreateSelect(zf, srcValue, destValue, "cmovz");

    // Update the operand with the result
    SetOperandValue(context, builder, dest, resultValue);
}



// cmovnz = cmovne
void lift_cmovnz(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the ZF flag from RFLAGS register
    Value* zf = getFlag(context, builder, FLAG_ZF);
    zf = builder.CreateICmpEQ(zf, ConstantInt::get(Type::getInt1Ty(context), 0));

    // Get values for source and destination operands
    Value* Rvalue = GetOperandValue(context, builder, src, dest.size);
    Value* Dvalue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    Value* result = builder.CreateSelect(zf, Rvalue, Dvalue);

    SetOperandValue(context, builder, dest, result);
}
void lift_cmovl(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current values of the SF and OF flags from RFLAGS register
    Value* sf = getFlag(context, builder, FLAG_SF);
    Value* of = getFlag(context, builder, FLAG_OF);

    // The condition is true if SF is not equal to OF
    Value* condition = builder.CreateICmpNE(sf, of);

    // Retrieve the values for source and destination operands
    Value* srcValue = GetOperandValue(context, builder, src, dest.size);
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);

    // Conditionally move the value based on the condition
    Value* result = builder.CreateSelect(condition, srcValue, destValue);

    // Store the result into the destination operand
    SetOperandValue(context, builder, dest, result);
}


void lift_cmovb(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the CF flag from RFLAGS register
    Value* cf = getFlag(context, builder, FLAG_CF);

    // The condition is true if CF is set (i.e., 1)
    Value* condition = builder.CreateICmpEQ(cf, ConstantInt::get(Type::getInt1Ty(context), 1));

    // Retrieve the values for source and destination operands
    Value* srcValue = GetOperandValue(context, builder, src, dest.size);
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);

    // Conditionally move the value based on the condition
    Value* result = builder.CreateSelect(condition, srcValue, destValue);

    // Store the result into the destination operand
    SetOperandValue(context, builder, dest, result);
}


void lift_cmovnb(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Retrieve the values
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);
    Value* srcValue = GetOperandValue(context, builder, src, src.size);

    // Retrieve the carry flag (CF) from the EFLAGS/RFLAGS register
    Value* cf = getFlag(context, builder, FLAG_CF);

    // If CF is not set, then the result is the srcValue; otherwise, it's the destValue
    Value* resultValue = builder.CreateSelect(builder.CreateNot(cf), srcValue, destValue, "cmovnb");

    // Update the operand with the result
    SetOperandValue(context, builder, dest, resultValue);
}



void lift_cmovns(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the SF flag from RFLAGS register
    Value* sf = getFlag(context, builder, FLAG_SF);

    // Check if SF is clear (i.e., 0)
    Value* condition = builder.CreateICmpEQ(sf, ConstantInt::get(Type::getInt1Ty(context), 0));

    // Retrieve the values for source and destination operands
    Value* srcValue = GetOperandValue(context, builder, src, dest.size);
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);

    // Conditionally move the value based on the condition
    Value* result = builder.CreateSelect(condition, srcValue, destValue);

    // Store the result into the destination operand
    SetOperandValue(context, builder, dest, result);
}
//cmovnl = cmovge
void lift_cmovnl(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the ZF flag from RFLAGS register
    Value* sf = getFlag(context, builder, FLAG_SF);
    sf = builder.CreateICmpEQ(sf, ConstantInt::get(Type::getInt1Ty(context), 0));

    // Get values for source and destination operands
    Value* Rvalue = GetOperandValue(context, builder, src, dest.size);
    Value* Dvalue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    Value* result = builder.CreateSelect(sf, Rvalue, Dvalue);

    SetOperandValue(context, builder, dest, result);
}
void lift_cmovs(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
    // Assuming the first operand is the destination and the second is the source
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the SF flag from RFLAGS register
    Value* sf = getFlag(context, builder, FLAG_SF);

    // Get values for source and destination operands
    Value* srcValue = GetOperandValue(context, builder, src, dest.size);
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    // If SF is set, use srcValue, otherwise keep destValue
    Value* result = builder.CreateSelect(sf, srcValue, destValue);

    // Store the result back to the destination operand
    SetOperandValue(context, builder, dest, result);
}

void lift_cmovnle(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

    // Operands: the first one is the destination, and the second one is the source
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the ZF, SF, and OF flags from RFLAGS register
    Value* zf = getFlag(context, builder, FLAG_ZF);
    Value* sf = getFlag(context, builder, FLAG_SF);
    Value* of = getFlag(context, builder, FLAG_OF);

    // The condition for CMOVNLE is (ZF = 0 AND SF = OF)
    Value* condition = builder.CreateAnd(
        builder.CreateNot(zf, "notZF"),
        builder.CreateICmpEQ(sf, of, "sf_eq_of"),
        "cmovnle_cond"
    );

    // Get values for source and destination operands
    Value* Rvalue = GetOperandValue(context, builder, src, dest.size);
    Value* Dvalue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    Value* result = builder.CreateSelect(condition, Rvalue, Dvalue);

    // Store the result into the destination operand
    SetOperandValue(context, builder, dest, result);
}

void lift_cmovle(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
    // Assuming the first operand is the destination and the second is the source
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Fetch the ZF, SF, and OF flags
    Value* zf = getFlag(context, builder, FLAG_ZF);
    Value* sf = getFlag(context, builder, FLAG_SF);
    Value* of = getFlag(context, builder, FLAG_OF);

    // Compute the condition (ZF = 1) or (SF != OF)
    Value* sf_neq_of = builder.CreateICmpNE(sf, of);
    Value* condition = builder.CreateOr(zf, sf_neq_of, "cmovle-or");

    // Get values for source and destination operands
    Value* srcValue = GetOperandValue(context, builder, src, dest.size);
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    Value* result = builder.CreateSelect(condition, srcValue, destValue);

    // Update the destination operand with the result
    SetOperandValue(context, builder, dest, result);
}


void lift_cmovo(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
    // Assuming the first operand is the destination and the second is the source
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the OF flag from RFLAGS register
    Value* of = getFlag(context, builder, FLAG_OF);

    // Get values for source and destination operands
    Value* srcValue = GetOperandValue(context, builder, src, dest.size);
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    // If OF is set, use srcValue, otherwise keep destValue
    Value* result = builder.CreateSelect(of, srcValue, destValue);

    // Store the result back to the destination operand
    SetOperandValue(context, builder, dest, result);
}
void lift_cmovno(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
    // Assuming the first operand is the destination and the second is the source
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the OF flag from RFLAGS register
    Value* of = getFlag(context, builder, FLAG_OF);

    // Negate the condition since we want the opposite of OF
    of = builder.CreateNot(of, "negateOF");

    // Get values for source and destination operands
    Value* srcValue = GetOperandValue(context, builder, src, dest.size);
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    // If OF is not set (after negation), use srcValue, otherwise keep destValue
    Value* result = builder.CreateSelect(of, srcValue, destValue);

    // Store the result back to the destination operand
    SetOperandValue(context, builder, dest, result);
}



void lift_cmovp(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
    // Assuming the first operand is the destination and the second is the source
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the PF flag from RFLAGS register
    Value* pf = getFlag(context, builder, FLAG_PF);


    // Get values for source and destination operands
    Value* srcValue = GetOperandValue(context, builder, src, dest.size);
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    // If PF is not set (after negation), use srcValue, otherwise keep destValue
    Value* result = builder.CreateSelect(pf, srcValue, destValue);

    // Store the result back to the destination operand
    SetOperandValue(context, builder, dest, result);
}

void lift_cmovnp(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
    // Assuming the first operand is the destination and the second is the source
    auto dest = instruction.operands[0];
    auto src = instruction.operands[1];

    // Get the current value of the PF flag from RFLAGS register
    Value* pf = getFlag(context, builder, FLAG_PF);

    // Negate the PF flag since we are interested in the not parity condition
    pf = builder.CreateNot(pf, "negatePF");

    // Get values for source and destination operands
    Value* srcValue = GetOperandValue(context, builder, src, dest.size);
    Value* destValue = GetOperandValue(context, builder, dest, dest.size);

    // Use the select instruction to conditionally move the value
    // If PF is not set (after negation), use srcValue, otherwise keep destValue
    Value* result = builder.CreateSelect(pf, srcValue, destValue);

    // Store the result back to the destination operand
    SetOperandValue(context, builder, dest, result);
}
}

namespace branches {

    // for now assume every call is fake
    void lift_call(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses) {

        // 0 = function
        // 1 = rip
        // 2 = register rsp
        // 3 = [rsp]
        auto src = instruction.operands[0]; // value that we are pushing
        auto rsp = instruction.operands[2]; // value that we are pushing
        auto rsp_memory = instruction.operands[3]; // value that we are pushing

        auto RspValue = GetOperandValue(context, builder, rsp, rsp.size);

        auto val = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), 8); // assuming its x64
        auto result = builder.CreateSub(RspValue, val, "pushing_newrsp");

        SetOperandValue(context, builder, rsp, result); // sub rsp 8 first,

        auto push_into_rsp = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);

        SetOperandValue(context, builder, rsp_memory, push_into_rsp); // sub rsp 8 first,


        string block_name = "jmp-call";
        auto bb = llvm::BasicBlock::Create(context, block_name.c_str(), builder.GetInsertBlock()->getParent());


        builder.CreateBr(bb);

        uintptr_t test = src.imm.value.s + instruction.runtime_address;
#ifdef _DEVELOPMENT
        cout << "jmp address: " << test << "\n";
#endif
        blockAddresses->push_back(make_tuple(test, bb, getRegisterList()));

    }

    int ret_count = 0;
    void lift_ret(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses, bool* run) {
        // [0] = rip
        // [1] = rsp
        // [2] = [rsp]

        // if its ret 0x10
        // then its
        // [0] = 0x10
        // [1] = rip
        // [2] = rsp
        // [3] = [rsp]

        auto rspaddr = instruction.operands[2];

        auto rsp = ZYDIS_REGISTER_RSP;
        auto rspvalue = GetRegisterValue(context, builder, rsp);
        if (instruction.operands[0].type == ZYDIS_OPERAND_TYPE_IMMEDIATE) {
            rspaddr = instruction.operands[3];
        }

        auto realval = GetOperandValue(context, builder, rspaddr, rspaddr.size);


        auto block = builder.GetInsertBlock();
        block->setName("ret_check" + to_string(ret_count));
        auto function = block->getParent();

        auto lastinst = builder.CreateRet(realval);
#ifdef _DEVELOPMENT
        cout << "rspvalue: "; rspvalue->print(outs()); cout << "\n";
        std::string Filename = "output_rets.ll";
        std::error_code EC;
        llvm::raw_fd_ostream OS(Filename, EC);
        function->print(OS);
#endif

        llvm::ValueToValueMapTy VMap;
        //function->print(outs());
        llvm::Function* clonedFunctmp = llvm::CloneFunction(function, VMap);
        std::unique_ptr<Module> destinationModule = std::make_unique<Module>("destination_module", context);
        clonedFunctmp->removeFromParent();

        // Add the cloned function to the destination module
        destinationModule->getFunctionList().push_back(clonedFunctmp);

        Function* clonedFunc = destinationModule->getFunction(clonedFunctmp->getName());


        BasicBlock* clonedBlock = block;
        for (auto& blocks : *clonedFunc) {
            if (blocks.getName() == "ret_check" + to_string(ret_count))
                clonedBlock = &blocks;
        }


        uintptr_t destination;
#ifdef _DEVELOPMENT
        std::string Filename_before = "output_before_rop_opt.ll";
        std::error_code EC_before;
        llvm::raw_fd_ostream OS_before(Filename_before, EC_before);
        clonedFunc->print(OS_before);
#endif
        ROP_info ROP = isROP(clonedFunc, *clonedBlock, destination);



#ifdef _DEVELOPMENT
        std::string Filename_after = "output_after_rop_opt.ll";
        std::error_code EC_after;
        llvm::raw_fd_ostream OS_after(Filename_after, EC_after);
        clonedFunc->print(OS_after);
#endif
        clonedFunc->eraseFromParent();
        lastinst->eraseFromParent();

        block->setName("previousret_block");

        //cout << "rop value: " << ROP << "\n";
        if (ROP == ROP_return) {
            // can we make it so we remove the store for it?


            //cout << "jmp address: " << destination << "\n";


            block->setName("fake_ret");

            string block_name = "jmp_ret-" + to_string(destination) + "-";
            auto bb = llvm::BasicBlock::Create(context, block_name.c_str(), builder.GetInsertBlock()->getParent());

            auto val = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), 8); // assuming its x64
            auto result = builder.CreateAdd(rspvalue, val, "ret-new-rsp-" + to_string(instruction.runtime_address) + "-");

            if (instruction.operands[0].type == ZYDIS_OPERAND_TYPE_IMMEDIATE) {
                rspaddr = instruction.operands[3];
                auto offset = instruction.operands[0];
                result = builder.CreateSub(rspvalue, ConstantInt::get(rspvalue->getType(), offset.imm.value.u));


            }

            SetRegisterValue(context, builder, rsp, result); // then add rsp 8


            builder.CreateBr(bb);

            blockAddresses->push_back(make_tuple(destination, bb, getRegisterList()));
            (*run) = 0;
        }
        else if (ROP == REAL_return) {

            block->setName("real_ret");
            builder.CreateRet(GetRegisterValue(context, builder, ZYDIS_REGISTER_RAX));
            Function* originalFunc_finalnopt = builder.GetInsertBlock()->getParent();
#ifdef _DEVELOPMENT
            std::string Filename_finalnopt = "output_finalnoopt.ll";
            std::error_code EC_finalnopt;
            llvm::raw_fd_ostream OS_finalnopt(Filename_finalnopt, EC_finalnopt);

            originalFunc_finalnopt->print(OS_finalnopt);
#endif

            llvm::ValueToValueMapTy VMap_finale;
            //function->print(outs());
            llvm::Function* clonedFunc_finale = llvm::CloneFunction(originalFunc_finalnopt, VMap_finale);

            final_optpass(originalFunc_finalnopt);
#ifdef _DEVELOPMENT
            std::string Filename = "output_finalopt.ll";
            std::error_code EC;
            llvm::raw_fd_ostream OS(Filename, EC);
            originalFunc_finalnopt->print(OS);
#endif
            clonedFunc_finale->eraseFromParent();
            (*run) = 0;
        }



    }
    
    void lift_jmp(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses, bool* run) {

        auto dest = instruction.operands[0];

        auto Value = GetOperandValue(context, builder, dest, 64);
        auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);
        auto newRip = builder.CreateAdd(Value, ripval, "jump-xd-" + to_string(instruction.runtime_address) + "-");


        if (dest.type == ZYDIS_OPERAND_TYPE_REGISTER) {
            auto rspvalue = GetOperandValue(context, builder, dest, 64);
            auto trunc = builder.CreateZExtOrTrunc(rspvalue, llvm::Type::getInt64Ty(context), "jmp-register");


            auto block = builder.GetInsertBlock();
            block->setName("jmp_check" + to_string(ret_count));
            auto function = block->getParent();

            auto lastinst = builder.CreateRet(trunc);

#ifdef _DEVELOPMENT
            std::string Filename = "output_beforeJMP.ll";
            std::error_code EC;
            llvm::raw_fd_ostream OS(Filename, EC);
            function->print(OS);
#endif

            uintptr_t destination;
            JMP_info ROP = isJOP(function, destination);


            llvm::ValueToValueMapTy VMap_test;

            lastinst->eraseFromParent();

            block->setName("previousjmp_block");
            //cout << "isJOP:" << ROP << "\n";
            if (ROP == JOP_jmp) {

                string block_name = "jmp-" + to_string(destination) + "-";
                auto bb = llvm::BasicBlock::Create(context, block_name.c_str(), builder.GetInsertBlock()->getParent());

                builder.CreateBr(bb);

                blockAddresses->push_back(make_tuple(destination, bb, getRegisterList()));
                (*run) = 0;
            }
            (*run) = 0;
            //if ROP is not JOP_jmp, then its bugged
            return;
        }


        SetRegisterValue(context, builder, ZYDIS_REGISTER_RIP, newRip);

        uintptr_t test = dest.imm.value.s + instruction.runtime_address;
        //cout << "jmp address: " << test << "\n";

        string block_name = "jmp-" + to_string(test) + "-";
        auto bb = llvm::BasicBlock::Create(context, block_name.c_str(), builder.GetInsertBlock()->getParent());

        builder.CreateBr(bb);

        blockAddresses->push_back(make_tuple(test, bb, getRegisterList()));
        (*run) = 0;

    }

    int branchnumber = 0;
    // jnz and jne
    void lift_jnz(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses) {

        // if 0, then jmp, if not then not jump

        auto zf = getFlag(context, builder, FLAG_ZF);

        auto dest = instruction.operands[0];

        auto Value = GetOperandValue(context, builder, dest, 64);
        auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);

        auto newRip = builder.CreateAdd(Value, ripval, "jnz");


        zf = builder.CreateICmpEQ(zf, ConstantInt::get(Type::getInt1Ty(context), 0));

        branchHelper(context, builder, instruction, blockAddresses, zf, newRip, "jnz", branchnumber);

        branchnumber++;



    }

    void lift_jz(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses) {

        // if 0, then jmp, if not then not jump

        auto zf = getFlag(context, builder, FLAG_ZF);

        auto dest = instruction.operands[0];

        auto Value = GetOperandValue(context, builder, dest, 64);
        auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);

        auto newRip = builder.CreateAdd(Value, ripval, "jnz");



        branchHelper(context, builder, instruction, blockAddresses, zf, newRip, "jz", branchnumber);


        branchnumber++;



    }


    void lift_jbe(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses) {

        // If CF=0 and ZF=0, then jump. Otherwise, do not jump.

        auto cf = getFlag(context, builder, FLAG_CF);
        auto zf = getFlag(context, builder, FLAG_ZF);

        auto dest = instruction.operands[0];

        auto Value = GetOperandValue(context, builder, dest, 64);
        auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);
        auto newRip = builder.CreateAdd(Value, ripval, "jbe");

        // Check if neither CF nor ZF are set
        auto condition = builder.CreateOr(cf, zf, "jbe_Condition");

        branchHelper(context, builder, instruction, blockAddresses, condition, newRip, "jbe", branchnumber);


        branchnumber++;
    }


    // jnbe == ja
    void lift_jnbe(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses) {

        // If CF=0 and ZF=0, then jump. Otherwise, do not jump.

        auto cf = getFlag(context, builder, FLAG_CF);
        auto zf = getFlag(context, builder, FLAG_ZF);

        auto dest = instruction.operands[0];

        auto Value = GetOperandValue(context, builder, dest, 64);
        auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);
        auto newRip = builder.CreateAdd(Value, ripval, "jnbe");

        // Check if neither CF nor ZF are set
        auto condition = builder.CreateAnd(builder.CreateNot(cf, "notCF"), builder.CreateNot(zf, "notZF"), "jnbe_ja_Condition");

        branchHelper(context, builder, instruction, blockAddresses, condition, newRip, "jnbe_ja", branchnumber);

        branchnumber++;
    }


    void lift_jo(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses) {

        // if 0, then jmp, if not then not jump

        auto of = getFlag(context, builder, FLAG_OF);

        auto dest = instruction.operands[0];

        auto Value = GetOperandValue(context, builder, dest, 64);
        auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);

        auto newRip = builder.CreateAdd(Value, ripval, "jo");


        branchHelper(context, builder, instruction, blockAddresses, of, newRip, "jo", branchnumber);

        branchnumber++;
    }


    void lift_jno(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses) {

        // if 0, then jmp, if not then not jump

        auto of = getFlag(context, builder, FLAG_OF);

        auto dest = instruction.operands[0];

        auto Value = GetOperandValue(context, builder, dest, 64);
        auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);

        auto newRip = builder.CreateAdd(Value, ripval, "jno");


        of = builder.CreateNot(of);
        branchHelper(context, builder, instruction, blockAddresses, of, newRip, "jno", branchnumber);

        branchnumber++;
    }   
    
    void lift_jp(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses) {

        // if 0, then jmp, if not then not jump

        auto pf = getFlag(context, builder, FLAG_PF);

        auto dest = instruction.operands[0];

        auto Value = GetOperandValue(context, builder, dest, 64);
        auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);

        auto newRip = builder.CreateAdd(Value, ripval, "jp");


        branchHelper(context, builder, instruction, blockAddresses, pf, newRip, "jp", branchnumber);

        branchnumber++;
    }


    void lift_jnp(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses) {

        // if 0, then jmp, if not then not jump

        auto pf = getFlag(context, builder, FLAG_OF);

        auto dest = instruction.operands[0];

        auto Value = GetOperandValue(context, builder, dest, 64);
        auto ripval = GetRegisterValue(context, builder, ZYDIS_REGISTER_RIP);

        auto newRip = builder.CreateAdd(Value, ripval, "jnp");


        pf = builder.CreateNot(pf);
        branchHelper(context, builder, instruction, blockAddresses, pf, newRip, "jnp", branchnumber);

        branchnumber++;
    }

}


namespace arithmeticsAndLogical {

    void lift_sbb(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];

        Value* destValue = GetOperandValue(context, builder, dest, dest.size);
        Value* srcValue = GetOperandValue(context, builder, src, dest.size);

        // Get the Carry Flag (CF)
        Value* cf = getFlag(context, builder, FLAG_CF);

        // Perform the subtract with borrow operation
        Value* tmpResult = builder.CreateSub(destValue, srcValue, "sbb-tempresult");
        cf = builder.CreateSExtOrTrunc(cf, tmpResult->getType(), "sbb");
        Value* result = builder.CreateSub(tmpResult, cf, "sbb-result");

        // TODO: Update the necessary flags in RFLAGS based on the result (ZF, CF, OF, etc.)

        SetOperandValue(context, builder, dest, result);
    }


    /*
    
    (* RCL and RCR Instructions *)
    SIZE := OperandSize;
    CASE (determine count) OF
        SIZE := 8: tempCOUNT := (COUNT AND 1FH) MOD 9;
        SIZE := 16: tempCOUNT := (COUNT AND 1FH) MOD 17;
        SIZE := 32: tempCOUNT := COUNT AND 1FH;
        SIZE := 64: tempCOUNT := COUNT AND 3FH;
    ESAC;
    IF OperandSize = 64
        THEN COUNTMASK = 3FH;
        ELSE COUNTMASK = 1FH;
    FI;
    (* RCL Instruction Operation *)
    WHILE (tempCOUNT ≠ 0)
        DO
        tempCF := MSB(DEST);
        DEST := (DEST ∗ 2) + CF;
        CF := tempCF;
        tempCOUNT := tempCOUNT – 1;
        OD;
    ELIHW;
    IF (COUNT & COUNTMASK) = 1
        THEN OF := MSB(DEST) XOR CF;
        ELSE OF is undefined;
    FI;
    */
    void lift_rcl(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto count = instruction.operands[1];

        Value* destValue = GetOperandValue(context, builder, dest, dest.size);
        Value* countValue = GetOperandValue(context, builder, count, dest.size);

        // Get the Carry Flag (CF)

        auto flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);
        Value* carryFlagValue = getFlag(context, builder, FLAG_CF);

        Value* concatenated = builder.CreateZExt(destValue, Type::getIntNTy(context, dest.size * 2), "rcl-zext");

        carryFlagValue = builder.CreateZExt(carryFlagValue, concatenated->getType()), "rcl-zext";
        concatenated = builder.CreateOr(concatenated, builder.CreateShl(carryFlagValue, dest.size), "rcl-or");

        countValue = builder.CreateZExt(countValue, concatenated->getType(), "rcr-zext3");
        // Define the fshl intrinsic
        llvm::Function* fshlIntrinsic = llvm::Intrinsic::getDeclaration(
            builder.GetInsertBlock()->getModule(),
            llvm::Intrinsic::fshl,
            concatenated->getType()
        );

        // Use the fshl intrinsic for the main rotation
        Value* rotated = builder.CreateCall(fshlIntrinsic, { concatenated, concatenated, builder.CreateZExtOrTrunc(countValue,concatenated->getType()) }, "rcl-fshr");

        // Extract result and new carry flag
        Value* result = builder.CreateZExtOrTrunc(rotated, destValue->getType(), "rcl-zext");
        Value* newCarryFlag = builder.CreateLShr(rotated, dest.size, "rcl-lshr");

        // Adjust the result using the original value of the carry flag
        // Set the carry flag using newCarryFlag

        auto new_flag = setFlag(context, builder, FLAG_CF, newCarryFlag);

        SetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS, new_flag);
        SetOperandValue(context, builder, dest, result);
    }


    /*
        (* RCL and RCR Instructions *)
    SIZE := OperandSize;
    CASE (determine count) OF
        SIZE := 8: tempCOUNT := (COUNT AND 1FH) MOD 9;
        SIZE := 16: tempCOUNT := (COUNT AND 1FH) MOD 17;
        SIZE := 32: tempCOUNT := COUNT AND 1FH;
        SIZE := 64: tempCOUNT := COUNT AND 3FH;
    ESAC;
    IF OperandSize = 64
        THEN COUNTMASK = 3FH;
        ELSE COUNTMASK = 1FH;
    FI;
    (* RCR Instruction Operation *)
    IF (COUNT & COUNTMASK) = 1
        THEN OF := MSB(DEST) XOR CF;
        ELSE OF is undefined;
    FI;
    WHILE (tempCOUNT ≠ 0)
        DO
        tempCF := LSB(SRC);
        DEST := (DEST / 2) + (CF * 2SIZE);
        CF := tempCF;
        tempCOUNT := tempCOUNT – 1;
        OD;
    ELIHW;

    */
    void lift_rcr(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto count = instruction.operands[1];

        Value* destValue = GetOperandValue(context, builder, dest, dest.size);
        Value* countValue = GetOperandValue(context, builder, count, dest.size);

        // Get the Carry Flag (CF)

        auto flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);
        Value* carryFlagValue = getFlag(context, builder, FLAG_CF);

        Value* concatenated = builder.CreateZExt(destValue, Type::getIntNTy(context, dest.size * 2), "rcr-zext");
        carryFlagValue = builder.CreateZExt(carryFlagValue, concatenated->getType(), "rcr-zext2");
        concatenated = builder.CreateOr(concatenated, builder.CreateShl(carryFlagValue, dest.size), "rcr-or");

        countValue = builder.CreateZExt(countValue, concatenated->getType(), "rcr-zext3");

        // Define the fshl intrinsic
        llvm::Function* fshrIntrinsic = llvm::Intrinsic::getDeclaration(
            builder.GetInsertBlock()->getModule(),
            llvm::Intrinsic::fshl,
            concatenated->getType()
        );

        // Use the fshl intrinsic for the main rotation
        Value* rotated = builder.CreateCall(fshrIntrinsic, { concatenated, concatenated, countValue }, "rcr-fshl");

        // Extract result and new carry flag
        Value* result = builder.CreateZExtOrTrunc(rotated, destValue->getType(), "rcr-zext-" + to_string(instruction.runtime_address) + "-");
        Value* newCarryFlag = builder.CreateLShr(rotated, dest.size, "rcr-lshr-"+to_string(instruction.runtime_address)+"-");

        // Adjust the result using the original value of the carry flag
        // Set the carry flag using newCarryFlag

        auto new_flag = setFlag(context, builder, FLAG_CF, newCarryFlag);

        SetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS, new_flag);
        SetOperandValue(context, builder, dest, result);
    }

    void lift_not(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];

        auto Rvalue = GetOperandValue(context, builder, dest, dest.size);
        Rvalue = builder.CreateNot(Rvalue, "not");
        SetOperandValue(context, builder, dest, Rvalue);


    }

    void lift_neg(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];

        auto Rvalue = GetOperandValue(context, builder, dest, dest.size);
        Rvalue = builder.CreateNeg(Rvalue, "neg");
        SetOperandValue(context, builder, dest, Rvalue);


    }

    /*
    
    IF 64-Bit Mode and using REX.W
        THEN
            countMASK := 3FH;
        ELSE
            countMASK := 1FH;
    FI
    tempCOUNT := (COUNT AND countMASK);
    tempDEST := DEST;
    WHILE (tempCOUNT ≠ 0)
    DO
        IF instruction is SAL or SHL
            THEN
            CF := MSB(DEST);
        ELSE (* Instruction is SAR or SHR *)
            CF := LSB(DEST);
        FI;
        IF instruction is SAL or SHL
            THEN
                DEST := DEST ∗ 2;
        ELSE
            IF instruction is SAR
                THEN
                    DEST := DEST / 2; (* Signed divide, rounding toward negative infinity *)
            ELSE (* Instruction is SHR *)
                DEST := DEST / 2 ; (* Unsigned divide *)
            FI;
        FI;
        tempCOUNT := tempCOUNT – 1;
    OD;

    (* Determine overflow for the various instructions *)
    IF (COUNT and countMASK) = 1
        THEN
        IF instruction is SAL or SHL
            THEN
            OF := MSB(DEST) XOR CF;
        ELSE
        IF instruction is SAR
            THEN
            OF := 0;
        ELSE (* Instruction is SHR *)
            OF := MSB(tempDEST);
        FI;
    FI;

    ELSE IF (COUNT AND countMASK) = 0
        THEN
        All flags unchanged;
    ELSE (* COUNT not 1 or 0 *)
    OF := undefined;
    FI;
    FI;

    */
    void lift_sar(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto count = instruction.operands[1];

        Value* destValue = GetOperandValue(context, builder, dest, dest.size);
        Value* countValue = GetOperandValue(context, builder, count, dest.size);

        unsigned bitWidth = destValue->getType()->getIntegerBitWidth();

        // Clamp countValue to ensure it's within the bit width of destValue
        Value* clampedCount = builder.CreateURem(countValue, ConstantInt::get(countValue->getType(), bitWidth - 1), "clampedCount");

        // Perform the arithmetic right shift
        Value* shiftedValue = builder.CreateAShr(destValue, clampedCount, "sar-ashr-" + to_string(instruction.runtime_address) + "-");


        SetOperandValue(context, builder, dest, shiftedValue);
    }

    void lift_sal(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction);


    void lift_shl(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto count = instruction.operands[1];

        Value* destValue = GetOperandValue(context, builder, dest, dest.size);
        Value* countValue = GetOperandValue(context, builder, count, dest.size);

        auto maxShiftValue = ConstantInt::get(countValue->getType(), destValue->getType()->getIntegerBitWidth() - 1);
        auto clampedCountValue = builder.CreateAnd( maxShiftValue, countValue);

        // Perform the logical left shift
        Value* shiftedValue = builder.CreateShl(destValue, clampedCountValue, "shl-shift");


        // Optionally, update EFLAGS/RFLAGS based on the result if needed. 
        // For instance, setting CF and OF flags based on the SHL result.
        // ...

        SetOperandValue(context, builder, dest, shiftedValue);
    }


    void lift_shr(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto count = instruction.operands[1];

        Value* destValue = GetOperandValue(context, builder, dest, dest.size);
        Value* countValue = GetOperandValue(context, builder, count, dest.size);

        auto maxShiftValue = ConstantInt::get(countValue->getType(), destValue->getType()->getIntegerBitWidth() - 1);
        auto clampedCountValue = builder.CreateAnd(maxShiftValue, countValue);

        // Perform the logical left shift
        Value* shiftedValue = builder.CreateLShr(destValue, clampedCountValue, "shr-shift");


        // Optionally, update EFLAGS/RFLAGS based on the result if needed. 
        // For instance, setting CF and OF flags based on the SHL result.
        // ...

        SetOperandValue(context, builder, dest, shiftedValue);
    }



    void lift_bswap(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];

        auto destValue = GetOperandValue(context, builder, dest, dest.size);
        Value* newswappedvalue = ConstantInt::get(destValue->getType(), 0);
        Value* mask = ConstantInt::get(destValue->getType(), 0xff);
        for (int i = 0; i < destValue->getType()->getIntegerBitWidth() / 8; i++) {
            // 0xff
            // b = a & 0xff >> 0
            // b = 0x78
            // nb |=  b << 24
            // nb |= 0x78000000
            // 0xff00
            // b = a & 0xff00 >> 8
            // b = 0x56
            // nb |= b << 16
            // nb = 0x78560000
            auto byte = builder.CreateLShr(builder.CreateAnd(destValue, mask), i * 8);
            auto shiftby = destValue->getType()->getIntegerBitWidth() - (i + 1) * 8;
            auto newposbyte = builder.CreateShl(byte, shiftby);
            newswappedvalue = builder.CreateOr(newswappedvalue, newposbyte);
            mask = builder.CreateShl(mask, 8);
        }
        SetOperandValue(context, builder, dest, newswappedvalue);
    }
    void lift_bswap2(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];

        auto destValue = GetOperandValue(context, builder, dest, dest.size);

        // Define the intrinsic based on the size of the operand

        /*
        if (ConstantInt* CI = dyn_cast<ConstantInt>(destValue)) {
            // destValue is a ConstantInt
            unsigned size = destValue->getType()->getIntegerBitWidth();

            uint64_t constValue = CI->getZExtValue();
            uint64_t swappedValue = 0;

            for (unsigned i = 0; i < size; i += 8) {
                uint64_t byte_low = (constValue >> i) & 0xff;
                uint64_t byte_high = (constValue >> (size - 8 - i)) & 0xff;

                swappedValue |= (byte_high << i) | (byte_low << (size - 8 - i));
            }

            // Create a new ConstantInt with the byte-swapped value
            Value* newConstInt = ConstantInt::get(context, APInt(size, swappedValue));

            // Replace the original value with the byte-swapped value
            SetOperandValue(context, builder, dest, newConstInt);
            return;
        }*/

        Function* bswapIntrinsic = Intrinsic::getDeclaration(builder.GetInsertBlock()->getModule(), Intrinsic::bswap, destValue->getType());
        // Use the intrinsic
        Value* swappedValue = builder.CreateCall(bswapIntrinsic, destValue, "bswap");
        SetOperandValue(context, builder, dest, swappedValue);



    }


    void lift_xchg(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];

        auto Rvalue = GetOperandValue(context, builder, src, src.size);
        auto Lvalue = GetOperandValue(context, builder, dest, dest.size);

        SetOperandValue(context, builder, dest, Rvalue);
        SetOperandValue(context, builder, src, Lvalue);


    }

    //fix?
    void lift_shld(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto source = instruction.operands[1];
        auto count = instruction.operands[2];

        auto destValue = GetOperandValue(context, builder, dest, dest.size);
        auto sourceValue = GetOperandValue(context, builder, source, dest.size);
        auto countValue = GetOperandValue(context, builder, count, dest.size);

        // Calculate effective shift count (modulo the bit width of destValue)
        unsigned bitWidth = destValue->getType()->getIntegerBitWidth();
        auto effectiveCountValue = builder.CreateURem(countValue, ConstantInt::get(countValue->getType(), bitWidth - 1), "effectiveShiftCount");

        // Shift the destination value to the left
        auto shiftedDest = builder.CreateShl(destValue, effectiveCountValue, "shiftedDest");

        // Calculate the complement of the effective shift count
        auto complementCount = builder.CreateSub(ConstantInt::get(effectiveCountValue->getType(), bitWidth - 1), effectiveCountValue, "complementCount");

        // Shift the source value to the right by complementCount
        auto shiftedSource = builder.CreateLShr(sourceValue, complementCount, "shiftedSource");

        // Combine shiftedDest and shiftedSource
        auto resultValue = builder.CreateOr(shiftedDest, shiftedSource, "shldResult-" + to_string(instruction.runtime_address) + "-");

        // Update the operand with the result
        SetOperandValue(context, builder, dest, resultValue);
    }

    //fix?
    void lift_shrd(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto source = instruction.operands[1];
        auto count = instruction.operands[2];

        auto destValue = GetOperandValue(context, builder, dest, dest.size);
        auto sourceValue = GetOperandValue(context, builder, source, dest.size);
        auto countValue = GetOperandValue(context, builder, count, dest.size);

        // Calculate effective shift count (modulo the bit width of destValue)
        unsigned bitWidth = destValue->getType()->getIntegerBitWidth();
        auto effectiveCountValue = builder.CreateURem(countValue, ConstantInt::get(countValue->getType(), bitWidth - 1), "effectiveShiftCount");

        // Shift the destination value to the right
        auto shiftedDest = builder.CreateLShr(destValue, effectiveCountValue, "shiftedDest");

        // Calculate the complement of the effective shift count
        auto complementCount = builder.CreateSub(ConstantInt::get(effectiveCountValue->getType(), bitWidth - 1), effectiveCountValue, "complementCount");

        // Shift the source value to the left by complementCount
        auto shiftedSource = builder.CreateShl(sourceValue, complementCount, "shiftedSource");

        // Combine shiftedDest and shiftedSource
        auto resultValue = builder.CreateOr(shiftedDest, shiftedSource, "shrdResult-" + to_string(instruction.runtime_address) + "-");

        // Update the operand with the result
        SetOperandValue(context, builder, dest, resultValue);
    }



    void lift_lea(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];

        auto Rvalue = GetEffectiveAddress(context, builder, src, dest.size);

        SetOperandValue(context, builder, dest, Rvalue);


    }


    // extract idiv and mul
    void lift_add_sub(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];

        auto Rvalue = GetOperandValue(context, builder, src, dest.size);
        auto Lvalue = GetOperandValue(context, builder, dest, dest.size);

        Value* result = nullptr;
        switch (instruction.info.mnemonic) {
        case ZYDIS_MNEMONIC_ADD: {result = builder.CreateAdd(Lvalue, Rvalue, "realadd-" + to_string(instruction.runtime_address) + "-"); break; }
        case ZYDIS_MNEMONIC_SUB: {result = builder.CreateSub(Lvalue, Rvalue, "realsub-" + to_string(instruction.runtime_address) + "-"); break; }
        case ZYDIS_MNEMONIC_IMUL: {result = builder.CreateMul(Lvalue, Rvalue); break; }
        case ZYDIS_MNEMONIC_IDIV: {
            result = builder.CreateSDiv(Lvalue, Rvalue);
            auto remained = builder.CreateSRem(Lvalue, Rvalue);

            SetOperandValue(context, builder, instruction.operands[2], remained);
            break; }
        }
        SetOperandValue(context, builder, dest, result);




    }


    // extract xor, and, or, ror and rol


    void lift_xor(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];
        auto srcOp = GetOperandValue(context,builder,src, dest.size);
        auto destOp = GetOperandValue(context,builder,dest, dest.size);
        auto result = builder.CreateXor(destOp,srcOp);

        Value* old_flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);



        auto sf = computeSignFlag(builder, result);
        auto zf = computeZeroFlag(builder, result);
        auto pf = computeParityFlag(builder, result);



        Value* new_flags = setFlag(context, builder, FLAG_OF, sf);
        new_flags = setFlag(context, builder, FLAG_ZF, zf);
        new_flags = setFlag(context, builder, FLAG_PF, pf);



        

        SetOperandValue(context, builder, dest, result);


    }


    void lift_or(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];
        auto srcOp = GetOperandValue(context, builder, src, dest.size);
        auto destOp = GetOperandValue(context, builder, dest, dest.size);
        auto result = builder.CreateOr(destOp, srcOp);

        Value* old_flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);



        auto sf = computeSignFlag(builder, result);
        auto zf = computeZeroFlag(builder, result);
        auto pf = computeParityFlag(builder, result);



        Value* new_flags = setFlag(context, builder, FLAG_OF, sf);
        new_flags = setFlag(context, builder, FLAG_ZF, zf);
        new_flags = setFlag(context, builder, FLAG_PF, pf);



        

        SetOperandValue(context, builder, dest, result);

    }


    void lift_and(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];
        auto srcOp = GetOperandValue(context, builder, src, dest.size);
        auto destOp = GetOperandValue(context, builder, dest, dest.size);
        auto result = builder.CreateAnd(destOp, srcOp);

        Value* old_flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);



        auto sf = computeSignFlag(builder, result);
        auto zf = computeZeroFlag(builder, result);
        auto pf = computeParityFlag(builder, result);



        Value* new_flags = setFlag(context, builder, FLAG_OF, sf);
        new_flags = setFlag(context, builder, FLAG_ZF, zf);
        new_flags = setFlag(context, builder, FLAG_PF, pf);



        

        SetOperandValue(context, builder, dest, result);

    }


    /*
    
    tempCOUNT := (COUNT & COUNTMASK) MOD SIZE
    WHILE (tempCOUNT ≠ 0)
        DO
        tempCF := MSB(DEST);
        DEST := (DEST ∗ 2) + tempCF;
        tempCOUNT := tempCOUNT – 1;
        OD;
    ELIHW;
    IF (COUNT & COUNTMASK) ≠ 0
        THEN CF := LSB(DEST);
    FI;
    IF (COUNT & COUNTMASK) = 1
        THEN OF := MSB(DEST) XOR CF;
        ELSE OF is undefined;
    FI
    */
    void lift_rol(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];
        auto Rvalue = GetOperandValue(context, builder, src, dest.size);
        auto Lvalue = GetOperandValue(context, builder, dest, dest.size);

        auto size = llvm::ConstantInt::getSigned(Lvalue->getType(), Lvalue->getType()->getIntegerBitWidth());
        Rvalue = builder.CreateURem(Rvalue, size);

        //size = Lvalue size
        //uint64_t lValue = Lvalue->getZExtValue();
        //uint64_t rValue = Rvalue->getZExtValue() % size; // Ensure the rotation is within bounds
        //Perform constant rotation left
        //rotatedValue = (lValue << rValue) | (lValue >> (size - rValue));



        // Check if Rvalue is zero, and if so, set result to Lvalue directly
        Value* isZeroRotation = builder.CreateICmpEQ(Rvalue, llvm::ConstantInt::get(Rvalue->getType(), 0));
        Value* shiftedLeft = builder.CreateShl(Lvalue, Rvalue);
        Value* shiftedRight = builder.CreateLShr(Lvalue, builder.CreateSub(size, Rvalue));
        Value* rotatedValue = builder.CreateOr(shiftedLeft, shiftedRight);
        Value* result = builder.CreateSelect(isZeroRotation, Lvalue, rotatedValue, "rol-result-"+to_string(instruction.runtime_address) + "-");


        Value* cf = builder.CreateTrunc(result, Type::getInt1Ty(context), "rol-cf");

        auto msb =  builder.CreateTrunc(builder.CreateLShr(result, builder.CreateSub(size, llvm::ConstantInt::get(context, llvm::APInt(Rvalue->getType()->getIntegerBitWidth(), 1)) ) ), Type::getInt1Ty(context), "ror-msb") ;
        auto ofDefined = builder.CreateTrunc(builder.CreateXor(msb, cf,"rol-of"),cf->getType() );

        // Use Select to choose between defined behavior and keeping the current OF value

        Value* old_flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);


        auto ofCurrent = getFlag(context,builder,FLAG_OF );

        auto isOneBitRotation = builder.CreateICmpEQ(Rvalue, llvm::ConstantInt::get(context, llvm::APInt(Rvalue->getType()->getIntegerBitWidth(), 1)));

        auto of = builder.CreateSelect(isOneBitRotation, ofDefined, ofCurrent, "ror-of");



        Value* new_flags = setFlag(context, builder, FLAG_OF, of);
        new_flags = setFlag(context, builder, FLAG_CF, cf);
        

        SetOperandValue(context, builder, dest, result);


        


    }

    /*
    
    tempCOUNT := (COUNT & COUNTMASK) MOD SIZE
    WHILE (tempCOUNT ≠ 0)
        DO
        tempCF := LSB(SRC);
        DEST := (DEST / 2) + (tempCF ∗ 2SIZE);
        tempCOUNT := tempCOUNT – 1;
        OD;
    ELIHW;
    IF (COUNT & COUNTMASK) ≠ 0
        THEN CF := MSB(DEST);
    FI;
    IF (COUNT & COUNTMASK) = 1
        THEN OF := MSB(DEST) XOR MSB − 1(DEST);
        ELSE OF is undefined;
    FI
    
    */
    void lift_ror(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {


        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];
        auto Rvalue = GetOperandValue(context, builder, src, dest.size);
        auto Lvalue = GetOperandValue(context, builder, dest, dest.size);

        auto size = llvm::ConstantInt::getSigned(Lvalue->getType(), Lvalue->getType()->getIntegerBitWidth());
        Rvalue = builder.CreateURem(Rvalue, size);

        //size = Lvalue size
        //uint64_t lValue = Lvalue->getZExtValue();
        //uint64_t rValue = Rvalue->getZExtValue() % size; // Ensure the rotation is within bounds
        //Perform constant rotation left
        //rotatedValue = (lValue >> rValue) | (lValue << (size - rValue));

        Value* result = builder.CreateOr(builder.CreateLShr(Lvalue, Rvalue), builder.CreateShl(Lvalue, builder.CreateSub(size, Rvalue)),"ror-"+to_string(instruction.runtime_address) + "-");
        auto msb = builder.CreateLShr(result, builder.CreateSub(size, llvm::ConstantInt::get(context, llvm::APInt(Rvalue->getType()->getIntegerBitWidth(), 1))));
        auto secondMsb = builder.CreateLShr(result, builder.CreateSub(size, llvm::ConstantInt::get(context, llvm::APInt(Rvalue->getType()->getIntegerBitWidth(), 2))));
        

        // Use Select to choose between defined behavior and keeping the current OF value

        Value* old_flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);


        auto ofCurrent = getFlag(context, builder, FLAG_OF);

        Value* cf = builder.CreateTrunc(msb, Type::getInt1Ty(context), "ror-cf");

        auto ofDefined = builder.CreateTrunc(builder.CreateXor(msb, secondMsb),cf->getType());

        auto isOneBitRotation = builder.CreateICmpEQ(Rvalue, llvm::ConstantInt::get(context, llvm::APInt(Rvalue->getType()->getIntegerBitWidth(), 1)));

        auto of = builder.CreateSelect(isOneBitRotation, ofDefined, ofCurrent,"ror-of");


        Value* new_flags = setFlag(context, builder, FLAG_OF, of);
        new_flags = setFlag(context, builder, FLAG_CF, cf);


        auto isZeroBitRotation = builder.CreateICmpEQ(Rvalue, llvm::ConstantInt::get(context, llvm::APInt(Rvalue->getType()->getIntegerBitWidth(), 0)), "iszerobit");

        // if its like ror rsi, 0, no effect
        result = builder.CreateSelect(isZeroBitRotation, Lvalue, result,"ror-result");

        SetOperandValue(context, builder, dest, result);

        


    }

    void lift_inc_dec(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto operand = instruction.operands[0];

        Value* originalValue = GetOperandValue(context, builder, operand, operand.size);

        Value* one = ConstantInt::get(originalValue->getType(), 1, true);
        Value* result;

        if (instruction.info.mnemonic == ZYDIS_MNEMONIC_INC) {
            result = builder.CreateAdd(originalValue, one, "inc-" + to_string(instruction.runtime_address) + "-");
        }
        else {
            result = builder.CreateSub(originalValue, one, "dec-" + to_string(instruction.runtime_address) + "-");
        }


        SetOperandValue(context, builder, operand, result);
    }

    void lift_push(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto src = instruction.operands[0]; // value that we are pushing
        auto dest = instruction.operands[2];
        auto rsp = instruction.operands[1];

        auto Rvalue = GetOperandValue(context, builder, src, dest.size);
        auto RspValue = GetOperandValue(context, builder, rsp, dest.size);

        auto val = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), 8); // assuming its x64
        auto result = builder.CreateSub(RspValue, val, "pushing_newrsp-" + to_string(instruction.runtime_address) + "-");

        SetOperandValue(context, builder, rsp, result); // sub rsp 8 first,


        SetOperandValue(context, builder, dest, Rvalue); // then mov rsp, val

    }

    void lift_pushfq(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto src = instruction.operands[2]; // value that we are pushing rflags
        auto dest = instruction.operands[1];  // [rsp]
        auto rsp = instruction.operands[0]; // rsp

        auto Rvalue = GetOperandValue(context, builder, src, dest.size);
        auto RspValue = GetOperandValue(context, builder, rsp, dest.size);

        auto val = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), 8); // assuming its x64
        auto result = builder.CreateSub(RspValue, val);

        SetOperandValue(context, builder, rsp, result); // sub rsp 8 first,


        SetOperandValue(context, builder, dest, Rvalue); // then mov rsp, val

    }

    void lift_pop(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0]; // value that we are pushing
        auto src = instruction.operands[2];
        auto rsp = instruction.operands[1];

        auto Rvalue = GetOperandValue(context, builder, src, dest.size);
        auto RspValue = GetOperandValue(context, builder, rsp, dest.size);

        auto val = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), 8); // assuming its x64
        auto result = builder.CreateAdd(RspValue, val, "popping_new_rsp-" + to_string(instruction.runtime_address) + "-");

        SetOperandValue(context, builder, dest, Rvalue); // mov val, rsp first

        SetOperandValue(context, builder, rsp, result); // then add rsp 8



    }

    void lift_popfq(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[2]; // value that we are pushing
        auto src = instruction.operands[1];  // [rsp]
        auto rsp = instruction.operands[0]; // rsp

        auto Rvalue = GetOperandValue(context, builder, src, dest.size);
        auto RspValue = GetOperandValue(context, builder, rsp, dest.size);

        auto val = (ConstantInt*)llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), 8); // assuming its x64
        auto result = builder.CreateAdd(RspValue, val, "popfq-" + to_string(instruction.runtime_address) + "-");

        SetOperandValue(context, builder, dest, Rvalue);  // mov val, rsp first
        SetOperandValue(context, builder, rsp, result);  // then add rsp 8



    }

    void lift_adc(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];

        Value* destValue = GetOperandValue(context, builder, dest, dest.size);
        Value* srcValue = GetOperandValue(context, builder, src, dest.size);

        // Get the Carry Flag (CF)
        Value* cf = getFlag(context, builder, FLAG_CF);

        // Extend CF to the size of the destination operand to prepare it for addition
        cf = builder.CreateZExt(cf, destValue->getType());

        // Perform addition
        Value* tempResult = builder.CreateAdd(destValue, srcValue, "adc-temp-" + to_string(instruction.runtime_address) + "-");
        Value* result = builder.CreateAdd(tempResult, cf, "adc-result-" + to_string(instruction.runtime_address) + "-");

        // Set the flags:
        /*
        // CF: result is less than either operand, indicating a carry
        Value* newCF = builder.CreateICmpULT(result, tempResult);
        setFlag(context, builder, ZYDIS_REGISTER_RFLAGS, FLAG_CF, newCF);

        // OF: Overflow flag
        Value* overflow = builder.CreateXor(builder.CreateAnd(builder.CreateXor(destValue, srcValue), ConstantInt::get(destValue->getType(), ~0, true)),
            builder.CreateXor(destValue, result));
        Value* newOF = builder.CreateICmpSLT(overflow, ConstantInt::get(destValue->getType(), 0));
        setFlag(context, builder, ZYDIS_REGISTER_RFLAGS, FLAG_OF, newOF);

        // ZF: Zero flag
        Value* newZF = builder.CreateICmpEQ(result, ConstantInt::get(destValue->getType(), 0));
        setFlag(context, builder, ZYDIS_REGISTER_RFLAGS, FLAG_ZF, newZF);

        // SF: Sign flag
        Value* newSF = builder.CreateICmpSLT(result, ConstantInt::get(destValue->getType(), 0));
        setFlag(context, builder, ZYDIS_REGISTER_RFLAGS, FLAG_SF, newSF);
        */
        // Store the result in the destination operand
        SetOperandValue(context, builder, dest, result);
    }
    void lift_xadd(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Assuming the first operand is the destination and the second operand is the source
        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];

        // Retrieve the values
        auto destValue = GetOperandValue(context, builder, dest, dest.size);
        auto srcValue = GetOperandValue(context, builder, src, src.size);

        // Calculate the sum of destValue and srcValue
        Value* sumValue = builder.CreateAdd(destValue, srcValue, "xadd_sum-" + to_string(instruction.runtime_address) + "-");

        // The result to be stored in the destination is sumValue
        SetOperandValue(context, builder, dest, sumValue);

        // The result to be stored in the source is the original destValue
        SetOperandValue(context, builder, src, destValue);

        // Update EFLAGS based on the result (if your framework requires it)
        // For example:
        // - Update overflow and carry flags based on the addition
        // - Update zero, sign, and parity flags based on sumValue
    }

    void lift_test(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        Value* Lvalue = GetOperandValue(context, builder, instruction.operands[0], instruction.operands[0].size);
        Value* Rvalue = GetOperandValue(context, builder, instruction.operands[1], instruction.operands[0].size);

        // Compute the bitwise AND result
        Value* testResult = builder.CreateAnd(Lvalue, Rvalue, "testAnd");

        // OF and CF are cleared
        Value* of = ConstantInt::get(Type::getInt64Ty(context), 0, "of");
        Value* cf = ConstantInt::get(Type::getInt64Ty(context), 0, "cf");

        // Calculate SF, ZF, and PF based on testResult
        Value* sf = builder.CreateICmpSLT(testResult, ConstantInt::get(testResult->getType(), 0), "sf");
        Value* zf = builder.CreateICmpEQ(testResult, ConstantInt::get(testResult->getType(), 0), "zf");
        Value* pf = computeParityFlag(builder, testResult);

        Value* old_flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);

        Value* new_flags = setFlag(context, builder, FLAG_OF, of);
        new_flags = setFlag(context, builder, FLAG_CF, cf);
        new_flags = setFlag(context, builder, FLAG_SF, sf);
        new_flags = setFlag(context, builder, FLAG_ZF, zf);
        new_flags = setFlag(context, builder, FLAG_PF, pf);

        
    }

    void lift_cmp(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Compute the difference

        Value* Lvalue = GetOperandValue(context, builder, instruction.operands[0], instruction.operands[0].size);
        Value* Rvalue = GetOperandValue(context, builder, instruction.operands[1], instruction.operands[0].size);

        Value* cmpResult = builder.CreateSub(Lvalue, Rvalue);

        // Calculate flags based on cmpResult
        Value* signL = builder.CreateICmpSLT(Lvalue, ConstantInt::get(Lvalue->getType(), 0));
        Value* signR = builder.CreateICmpSLT(Rvalue, ConstantInt::get(Rvalue->getType(), 0));
        Value* signResult = builder.CreateICmpSLT(cmpResult, ConstantInt::get(cmpResult->getType(), 0));

        // Overflow flag: (Lsign and not Rsign and not ResultSign) or (not Lsign and Rsign and ResultSign)
        Value* of = builder.CreateOr(
            builder.CreateAnd(signL, builder.CreateAnd(builder.CreateNot(signR), builder.CreateNot(signResult), "cmp-and1-")),
            builder.CreateAnd(builder.CreateNot(signL), builder.CreateAnd(signR, signResult), "cmp-and2-"), "cmp-OF-or"
        );

        Value* cf = builder.CreateICmpULT(Lvalue, Rvalue);
        Value* zf = builder.CreateICmpEQ(cmpResult, ConstantInt::get(cmpResult->getType(), 0));
        Value* sf = builder.CreateICmpSLT(cmpResult, ConstantInt::get(cmpResult->getType(), 0));
        Value* pf = computeParityFlag(builder, cmpResult);

        Value* old_flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);

        Value* new_flags = setFlag(context, builder, FLAG_OF, of);
        new_flags = setFlag(context, builder, FLAG_CF, cf);
        new_flags = setFlag(context, builder, FLAG_SF, sf);
        new_flags = setFlag(context, builder, FLAG_ZF, zf);
        new_flags = setFlag(context, builder, FLAG_PF, pf);

        
    }


}

namespace flagOperation {
    void lift_setnz(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];

        // Get the current value of the ZF flag from RFLAGS register
        Value* zf = getFlag(context, builder, FLAG_ZF);

        // Create a check for ZF being 0 (because SETNZ sets byte to 1 if ZF = 0)
        Value* result = builder.CreateICmpEQ(zf, ConstantInt::get(Type::getInt1Ty(context), 0));

        // Zero extend the result to byte size, since SETNZ works on bytes
        Value* byteResult = builder.CreateZExt(result, Type::getInt8Ty(context));

        // Store the result in the destination operand
        SetOperandValue(context, builder, dest, byteResult);

    }
    void lift_seto(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        // The destination is usually a single byte in memory or a byte-sized register.
        auto dest = instruction.operands[0];

        // Get the current value of the OF flag from RFLAGS register
        Value* of = getFlag(context, builder, FLAG_OF);

        // Convert the i1 (boolean) value of OF to an 8-bit integer
        Value* result = builder.CreateZExt(of, Type::getInt8Ty(context));

        // Store the result into the destination operand
        SetOperandValue(context, builder, dest, result);
    }
    void lift_setno(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        // The destination is usually a single byte in memory or a byte-sized register.
        auto dest = instruction.operands[0];

        // Get the current value of the OF flag from RFLAGS register
        Value* of = getFlag(context, builder, FLAG_OF);

        // We need to invert the value of the OF flag for SETNO.
        Value* notOf = builder.CreateNot(of, "notOF");

        // Convert the i1 (boolean) value of notOf to an 8-bit integer
        Value* result = builder.CreateZExt(notOf, Type::getInt8Ty(context));

        // Store the result into the destination operand
        SetOperandValue(context, builder, dest, result);
    }

    void lift_setnb(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];

        // Get the current value of the CF flag from RFLAGS register
        Value* cf = getFlag(context, builder, FLAG_CF);

        // Check for CF being 0 (because SETNB sets byte to 1 if CF = 0)
        Value* result = builder.CreateICmpEQ(cf, ConstantInt::get(Type::getInt1Ty(context), 0));

        // Zero extend the result to byte size, since SETNB works on bytes
        Value* byteResult = builder.CreateZExt(result, Type::getInt8Ty(context));

        // Store the result in the destination operand
        SetOperandValue(context, builder, dest, byteResult);
    }

    void lift_setbe(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Fetch the CF and ZF flags
        Value* cf = getFlag(context, builder, FLAG_CF);
        Value* zf = getFlag(context, builder, FLAG_ZF);

        // The condition is (CF=1 or ZF=1)
        Value* condition = builder.CreateOr(cf, zf, "setbe-or");

        // Convert condition from i1 to i8
        Value* result = builder.CreateZExt(condition, Type::getInt8Ty(context));

        // Set the result to the destination operand
        auto dest = instruction.operands[0];
        SetOperandValue(context, builder, dest, result);
    }

    void lift_setnbe(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Fetch the CF and ZF flags
        Value* cf = getFlag(context, builder, FLAG_CF);
        Value* zf = getFlag(context, builder, FLAG_ZF);

        // The condition is (CF=0 and ZF=0)
        Value* condition = builder.CreateAnd(builder.CreateNot(cf), builder.CreateNot(zf), "setnbe-and");

        // Convert condition from i1 to i8
        Value* result = builder.CreateZExt(condition, Type::getInt8Ty(context));

        // Set the result to the destination operand
        auto dest = instruction.operands[0];
        SetOperandValue(context, builder, dest, result);
    }


    void lift_setns(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];

        // Get the current value of the SF flag from RFLAGS register
        Value* sf = getFlag(context, builder, FLAG_SF);

        // Check for SF being 0 (because SETNS sets byte to 1 if SF = 0)
        Value* result = builder.CreateICmpEQ(sf, ConstantInt::get(Type::getInt1Ty(context), 0));

        // Zero extend the result to byte size, since SETNS works on bytes
        Value* byteResult = builder.CreateZExt(result, Type::getInt8Ty(context));

        // Store the result in the destination operand
        SetOperandValue(context, builder, dest, byteResult);
    }

    void lift_setp(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Get the PF bit from RFLAGS register
        Value* pf = getFlag(context, builder, FLAG_PF);

        // Convert PF to an 8-bit integer
        Value* result = builder.CreateZExt(pf, Type::getInt8Ty(context));

        // Assuming the first operand is the destination
        auto dest = instruction.operands[0];

        // Set the value of the destination operand
        SetOperandValue(context, builder, dest, result);
    }

    void lift_setnp(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto dest = instruction.operands[0];

        // Retrieve the Parity Flag (PF) from the EFLAGS/RFLAGS register
        Value* pf = getFlag(context, builder, FLAG_PF);

        // The result is 1 if PF is clear and 0 otherwise
        Value* resultValue = builder.CreateSelect(builder.CreateNot(pf),
            ConstantInt::get(Type::getInt8Ty(context), 1),
            ConstantInt::get(Type::getInt8Ty(context), 0),
            "setnp");

        // Update the operand with the result
        SetOperandValue(context, builder, dest, resultValue);
    }


    void lift_setb(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        // The destination is usually a single byte in memory or a byte-sized register.
        auto dest = instruction.operands[0];

        // Get the current value of the CF flag from RFLAGS register
        Value* cf = getFlag(context, builder, FLAG_CF);

        // Convert the i1 (boolean) value of CF to an 8-bit integer
        Value* result = builder.CreateZExt(cf, Type::getInt8Ty(context));

        // Store the result into the destination operand
        SetOperandValue(context, builder, dest, result);
    }


    void lift_sets(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Fetch the SF flag
        Value* sf = getFlag(context, builder, FLAG_SF);

        // Convert SF condition from i1 to i8
        Value* result = builder.CreateZExt(sf, Type::getInt8Ty(context));

        // Set the result to the destination operand
        auto dest = instruction.operands[0];
        SetOperandValue(context, builder, dest, result);
    }


    void lift_setz(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Assuming the operand is the destination
        auto dest = instruction.operands[0];

        // Get the current value of the ZF flag from RFLAGS register
        Value* zf = getFlag(context, builder, FLAG_ZF);

        // ZF is usually represented in LLVM as a i1 type (boolean).
        // Extend this to 8 bits to match the size of the SETZ destination.
        Value* extendedZF = builder.CreateZExt(zf, Type::getInt8Ty(context), "setz_extend");

        // Store the result to the destination operand
        SetOperandValue(context, builder, dest, extendedZF);
    }

    void lift_setnle(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];

        // Get the current values of the ZF, SF, and OF flags from RFLAGS register
        Value* zf = getFlag(context, builder, FLAG_ZF);
        Value* sf = getFlag(context, builder, FLAG_SF);
        Value* of = getFlag(context, builder, FLAG_OF);

        // Check for ZF being 0
        Value* zfNotSet = builder.CreateICmpEQ(zf, ConstantInt::get(Type::getInt1Ty(context), 0));

        // Check for SF=OF
        Value* sfEqualsOf = builder.CreateICmpEQ(sf, of);

        // Combine the two conditions with AND operation
        Value* combinedCondition = builder.CreateAnd(zfNotSet, sfEqualsOf, "setnle-and");

        // Zero extend the result to byte size, since SET instructions work on bytes
        Value* byteResult = builder.CreateZExt(combinedCondition, Type::getInt8Ty(context));

        // Store the result in the destination operand
        SetOperandValue(context, builder, dest, byteResult);
    }

    void lift_setle(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Fetch the ZF, SF, and OF flags
        Value* zf = getFlag(context, builder, FLAG_ZF);
        Value* sf = getFlag(context, builder, FLAG_SF);
        Value* of = getFlag(context, builder, FLAG_OF);

        // Compute the condition (ZF=1) OR (SF != OF)
        Value* sf_ne_of = builder.CreateICmpNE(sf, of);
        Value* condition = builder.CreateOr(zf, sf_ne_of, "setle-or");

        // Convert the condition from i1 to i8
        Value* result = builder.CreateZExt(condition, Type::getInt8Ty(context));

        // Set the result to the destination operand
        auto dest = instruction.operands[0];
        SetOperandValue(context, builder, dest, result);
    }

    void lift_setnl(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Fetch the SF and OF flags
        Value* sf = getFlag(context, builder, FLAG_SF);
        Value* of = getFlag(context, builder, FLAG_OF);

        // Compute the condition (SF = OF)
        Value* condition = builder.CreateICmpEQ(sf, of);

        // Convert the condition from i1 to i8
        Value* result = builder.CreateZExt(condition, Type::getInt8Ty(context));

        // Set the result to the destination operand
        auto dest = instruction.operands[0];
        SetOperandValue(context, builder, dest, result);
    }

    void lift_setl(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Fetch the SF and OF flags
        Value* sf = getFlag(context, builder, FLAG_SF);
        Value* of = getFlag(context, builder, FLAG_OF);

        // Compute the condition (SF != OF)
        Value* condition = builder.CreateICmpNE(sf, of);

        // Convert the condition from i1 to i8
        Value* result = builder.CreateZExt(condition, Type::getInt8Ty(context));

        // Set the result to the destination operand
        auto dest = instruction.operands[0];
        SetOperandValue(context, builder, dest, result);
    }

    void lift_bt(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Assuming the first operand is the destination and the second is the bit index
        auto dest = instruction.operands[0];
        auto bitIndex = instruction.operands[1];

        // Retrieve the values
        auto destValue = GetOperandValue(context, builder, dest, dest.size);
        auto bitIndexValue = GetOperandValue(context, builder, bitIndex, dest.size);

        auto adjustedBitIndexValue = builder.CreateURem(bitIndexValue, ConstantInt::get(bitIndexValue->getType(), destValue->getType()->getIntegerBitWidth()));

        // Create a mask to test the bit
        auto mask = builder.CreateShl(ConstantInt::get(destValue->getType(), 1), adjustedBitIndexValue);


        // Test the bit by performing bitwise AND
        auto testValue = builder.CreateAnd(destValue, mask, "bt");

        // Check if the bit is set. This will be a non-zero value if the bit was set.
        auto isBitSet = builder.CreateICmpNE(testValue, ConstantInt::get(destValue->getType(), 0), "btisbitset");

    }

    void lift_bsf(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];

        // Get value for source operand
        Value* srcValue = GetOperandValue(context, builder, src, src.size);

        // Check if source is zero and set the zero flag accordingly
        Value* isZero = builder.CreateICmpEQ(srcValue, ConstantInt::get(srcValue->getType(), 0));
        setFlag(context, builder, FLAG_ZF, isZero);

        // Use the cttz (count trailing zeros) intrinsic to implement BSF
        Function* cttzIntrinsic = Intrinsic::getDeclaration(
            builder.GetInsertBlock()->getModule(),
            Intrinsic::cttz,
            srcValue->getType()
        );

        // Call the cttz intrinsic
        Value* result = builder.CreateCall(cttzIntrinsic, { srcValue, ConstantInt::get(Type::getInt1Ty(context), 0) });

        // Store the result in the destination operand
        SetOperandValue(context, builder, dest, result);


    }

    void lift_btr(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Assuming the first operand is the destination and the second is the bit index
        auto dest = instruction.operands[0];
        auto bitIndex = instruction.operands[1];

        // Retrieve the values
        auto destValue = GetOperandValue(context, builder, dest, dest.size);
        auto bitIndexValue = GetOperandValue(context, builder, bitIndex, bitIndex.size);

        // Calculate the modulo of the bit index
        auto adjustedBitIndexValue = builder.CreateURem(bitIndexValue, ConstantInt::get(bitIndexValue->getType(), destValue->getType()->getIntegerBitWidth()), "btr-urem");

        adjustedBitIndexValue = builder.CreateZExtOrTrunc(adjustedBitIndexValue, destValue->getType(), "castedBitIndex");

        // Create a mask to test the bit

        // Create a mask to clear the bit
        auto mask = builder.CreateShl(ConstantInt::get(destValue->getType(), 1), adjustedBitIndexValue, "btr-mask");
        mask = builder.CreateNot(mask, "btr-not");

        // Clear the bit
        auto resultValue = builder.CreateAnd(destValue, mask, "btr-clear-" + to_string(instruction.runtime_address) + "-");

        // Update the operand with the result
        SetOperandValue(context, builder, dest, resultValue);



    }

    void lift_bsr(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        auto dest = instruction.operands[0];
        auto src = instruction.operands[1];

        // Retrieve the value for the source operand
        Value* srcValue = GetOperandValue(context, builder, src, src.size);

        // Define the intrinsic for counting leading zeros
        Function* ctlzIntrinsic = Intrinsic::getDeclaration(
            builder.GetInsertBlock()->getModule(),
            Intrinsic::ctlz,
            srcValue->getType()
        );

        // Call the intrinsic to count leading zeros
        Value* leadingZeros = builder.CreateCall(ctlzIntrinsic, { srcValue, ConstantInt::getFalse(context) });

        // Calculate the index of the highest set bit
        Value* bitPosition = builder.CreateSub(
            ConstantInt::get(srcValue->getType(), src.size * 8 - 1),
            leadingZeros
        );

        // Set the result into the destination operand
        SetOperandValue(context, builder, dest, bitPosition);
    }

    void lift_btc(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Assuming the first operand is the destination and the second is the bit index
        auto dest = instruction.operands[0];
        auto bitIndex = instruction.operands[1];

        // Retrieve the values
        auto destValue = GetOperandValue(context, builder, dest, dest.size);
        auto bitIndexValue = GetOperandValue(context, builder, bitIndex, bitIndex.size);

        // Calculate the modulo of the bit index
        auto adjustedBitIndexValue = builder.CreateURem(bitIndexValue, ConstantInt::get(bitIndexValue->getType(), destValue->getType()->getIntegerBitWidth()));

        adjustedBitIndexValue = builder.CreateZExtOrTrunc(adjustedBitIndexValue, destValue->getType(), "castedBitIndex");

        // Create a mask to test the bit
        auto mask = builder.CreateShl(ConstantInt::get(destValue->getType(), 1), adjustedBitIndexValue, "btc-mask");

        // Test the bit by performing bitwise AND
        auto testValue = builder.CreateAnd(destValue, mask, "btc-and");
        auto isBitSet = builder.CreateICmpNE(testValue, ConstantInt::get(destValue->getType(), 0));

        // Toggle the bit by using XOR
        auto resultValue = builder.CreateXor(destValue, mask, "btc-xor");

        // Update the operand with the result
        SetOperandValue(context, builder, dest, resultValue);

        // Decide how to handle isBitSet, which indicates the original state of the bit.
        // As with the BT opcode, you might:
        // 1. Store it in a global variable representing the CF flag.
        // 2. Handle it in some other way based on your lifting design.

        // Placeholder: 
        // StoreBitInFlag(isBitSet); // you'd have to implement StoreBitInFlag
    }




    void lift_lahf(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {


        auto flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);
        auto sf = getFlag(context, builder, FLAG_SF);
        auto zf = getFlag(context, builder, FLAG_ZF);
        auto af = getFlag(context, builder, FLAG_AF);
        auto pf = getFlag(context, builder, FLAG_PF);
        auto cf = getFlag(context, builder, FLAG_CF);

        Value* Rvalue = builder.CreateOr(
            builder.CreateShl(sf, 7),
            builder.CreateOr(
                builder.CreateShl(zf, 6),
                builder.CreateOr(
                    builder.CreateShl(af, 4),
                    builder.CreateOr(
                        builder.CreateShl(pf, 2), cf, "lahf-or-3"), "lahf-or-2"), "lahf-or1"), "lahf-or");


        SetRegisterValue(context, builder, ZYDIS_REGISTER_AH, Rvalue);


    }

    void lift_stc(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {


        auto flags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);

        auto Rvalue = builder.CreateAnd(flags, ConstantInt::get(flags->getType(), 1), "stc-and");


        SetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS, Rvalue);


    }

    void lift_cmc(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        Value* eflags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS); // Or ZYDIS_REGISTER_RFLAGS for 64-bit

        // Get the CF bit
        Value* cf = getFlag(context, builder, FLAG_CF);

        // Toggle the CF bit (complement)
        Value* toggledCF = builder.CreateXor(cf, ConstantInt::get(cf->getType(), 1), "cmd-xor");

        // Set the toggled value back into the EFLAGS/RFLAGS register
        Value* updatedEflags = setFlag(context, builder, FLAG_CF, toggledCF);

        SetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS, updatedEflags); // Or ZYDIS_REGISTER_RFLAGS for 64-bit


    }
    void lift_clc(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        Value* eflags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS); // Or ZYDIS_REGISTER_RFLAGS for 64-bit

        // Clear the CF bit
        Value* clearedCF = ConstantInt::get(Type::getInt1Ty(context), 0);

        // Set the cleared CF value into the EFLAGS/RFLAGS register
        Value* updatedEflags = setFlag(context, builder, FLAG_CF, clearedCF);

        SetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS, updatedEflags); // Or ZYDIS_REGISTER_RFLAGS for 64-bit

    }

    void lift_cld(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        Value* eflags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS); // Or ZYDIS_REGISTER_EFLAGS for 32-bit

        // Clear the DF bit
        Value* clearedDF = ConstantInt::get(Type::getInt1Ty(context), 0);

        // Set the cleared value back into the EFLAGS/RFLAGS register
        Value* updatedEflags = setFlag(context, builder, FLAG_DF, clearedDF);

        SetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS, updatedEflags); // Or ZYDIS_REGISTER_EFLAGS for 32-bit
    }


    void lift_cli(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {

        Value* eflags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS); // Or ZYDIS_REGISTER_RFLAGS for 64-bit

        // Get the CF bit
        Value* intf = getFlag(context, builder, FLAG_IF);

        // Toggle the CF bit (complement)
        Value* resetIF = builder.CreateAnd(intf, ConstantInt::get(intf->getType(), 1), "cliand");

        // Set the toggled value back into the EFLAGS/RFLAGS register
        Value* updatedEflags = setFlag(context, builder, FLAG_IF, resetIF);

        SetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS, updatedEflags); // Or ZYDIS_REGISTER_RFLAGS for 64-bit


    }
    void lift_bts(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        auto base = instruction.operands[0];
        auto offset = instruction.operands[1];

        // Convert the offset into a bit offset
        unsigned baseBitWidth = base.size; // assuming base.size is in bytes

        // Convert the offset into a bit offset
        Value* bitOffset = GetOperandValue(context, builder, offset, offset.size);

        // Mask bitOffset to prevent undefined behavior due to shifting with too large values
        Value* bitOffsetMasked = builder.CreateAnd(bitOffset, ConstantInt::get(bitOffset->getType(), baseBitWidth - 1), "bitOffsetMasked");

        // Extract the bit from the base operand
        Value* baseVal = GetOperandValue(context, builder, base, base.size);
        Value* bit = builder.CreateLShr(baseVal, bitOffsetMasked, "bts-lshr-" + to_string(instruction.runtime_address) + "-");
        bit = builder.CreateAnd(bit, 1, "bts-and");

        // Set the CF in EFLAGS/RFLAGS based on the extracted bit
        Value* eflags = GetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS);
        eflags = setFlag(context, builder, FLAG_CF, bit);
        SetRegisterValue(context, builder, ZYDIS_REGISTER_RFLAGS, eflags);

        // Set the bit in the base operand
        Value* mask = builder.CreateShl(ConstantInt::get(baseVal->getType(), 1), bitOffsetMasked, "bts-shl");
        baseVal = builder.CreateOr(baseVal, mask, "bts-or-" + to_string(instruction.runtime_address) + "-");
        SetOperandValue(context, builder, base, baseVal);
    }


    void lift_cwd(LLVMContext& context, IRBuilder<>& builder) {
        // Get the AX register value
        Value* ax = builder.CreateTrunc(GetRegisterValue(context, builder, ZYDIS_REGISTER_AX), Type::getInt16Ty(context));

        // Right shift by 15 to isolate the sign bit of AX
        Value* signBit = builder.CreateAShr(ax, ConstantInt::get(Type::getInt16Ty(context), 15), "getSignBit");

        // If AX was positive or zero, signBit is now 0; if negative, signBit is now 1.
        // Use signBit to set DX to either 0x0000 (for 0) or 0xFFFF (for 1).
        Value* dx = builder.CreateSelect(
            builder.CreateICmpEQ(signBit, ConstantInt::get(Type::getInt16Ty(context), 0)),
            ConstantInt::get(Type::getInt16Ty(context), 0),
            ConstantInt::get(Type::getInt16Ty(context), 0xFFFF),
            "setDX");

        // Store the result back to DX
        SetRegisterValue(context, builder, ZYDIS_REGISTER_DX, dx);
    }
    void lift_cqo(LLVMContext& context, IRBuilder<>& builder) {
        // Retrieve the RAX register's value
        Value* rax = GetRegisterValue(context, builder, ZYDIS_REGISTER_RAX);

        // Extract the sign bit (MSB) of RAX
        Value* msb = builder.CreateLShr( builder.CreateZExt(rax,Type::getInt64Ty(context) ), 63, "cqo-msb");  // 63 for a 64-bit register
        msb = builder.CreateAnd(msb, 1, "cqo-and");

        // If the MSB is 1, RDX will be all 1's, otherwise, all 0's.
        // This can be achieved by sign extending the MSB to 64 bits.
        Value* rdx = builder.CreateSExt(msb, Type::getInt64Ty(context));

        // Update the RDX register with the computed value
        SetRegisterValue(context, builder, ZYDIS_REGISTER_RDX, rdx);
    }


    void lift_cbw(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction) {
        // Assuming you have a method to get the AL register value
        Value* al = builder.CreateTrunc(GetRegisterValue(context, builder, ZYDIS_REGISTER_AL), Type::getInt8Ty(context));

        // Sign extend AL to 16 bits (i.e., AX's size)
        Value* ax = builder.CreateSExt(al, Type::getInt16Ty(context), "cbw");

        // Store the result back to AX
        SetRegisterValue(context, builder, ZYDIS_REGISTER_AX, ax);
    }

    void lift_cwde(LLVMContext& context, IRBuilder<>& builder) {
        // Get the AX register value
        Value* ax = builder.CreateTrunc(GetRegisterValue(context, builder, ZYDIS_REGISTER_AX), Type::getInt16Ty(context));

        // Sign extend AX to 32 bits (i.e., EAX's size)
        Value* eax = builder.CreateSExt(ax, Type::getInt32Ty(context), "cwde");

        // Store the result back to EAX
        SetRegisterValue(context, builder, ZYDIS_REGISTER_EAX, eax);
    }

    void lift_cdqe(LLVMContext& context, IRBuilder<>& builder) {
        // Get the EAX register value
        Value* eax = builder.CreateZExtOrTrunc(GetRegisterValue(context, builder, ZYDIS_REGISTER_EAX), Type::getInt32Ty(context), "cdqe-trunc");

        // Sign extend EAX to 64 bits (i.e., RAX's size)
        Value* rax = builder.CreateSExt(eax, Type::getInt64Ty(context), "cdqe");

        // Store the result back to RAX
        SetRegisterValue(context, builder, ZYDIS_REGISTER_RAX, rax);
    }

}




void liftInstruction(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses, bool* run) {


    // RIP gets updated before execution of the instruction.
    auto val = llvm::ConstantInt::getSigned(llvm::Type::getInt64Ty(context), instruction.runtime_address);
    SetRegisterValue(context, builder, ZYDIS_REGISTER_RIP, val);



    // switch case for lifting all instructions to llvm equivalent semantics
    // TODO: standardize and make it beautiful, multiple arch support
    // I dont want to explain every asm instruction, so probably skip to OperandUtils.cpp, then ROPdetection.cpp
    switch (instruction.info.mnemonic) {
        // movs
    case ZYDIS_MNEMONIC_MOVUPS:
    case ZYDIS_MNEMONIC_MOVZX:
    case ZYDIS_MNEMONIC_MOVSX:
    case ZYDIS_MNEMONIC_MOVSXD:
    case ZYDIS_MNEMONIC_MOV: {
        mov::lift_mov(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_MOVSB: {
        mov::lift_movsb(context, builder, instruction);
        break;
    }

    //cmov
    case ZYDIS_MNEMONIC_CMOVZ: {
        cmov::lift_cmovz(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVNZ: {
        cmov::lift_cmovnz(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVL: {
        cmov::lift_cmovl(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVB: {
        cmov::lift_cmovb(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVNB: {
        cmov::lift_cmovnb(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVNS: {
        cmov::lift_cmovns(context, builder, instruction);
        break;
    }

    case ZYDIS_MNEMONIC_CMOVBE: {
        cmov::lift_cmovbz(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVNBE: {
        cmov::lift_cmovnbz(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVNL: {
        cmov::lift_cmovnl(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVS: {
        cmov::lift_cmovs(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVNLE: {
        cmov::lift_cmovnle(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVLE: {
        cmov::lift_cmovle(context, builder, instruction);
        break;
    }

    case ZYDIS_MNEMONIC_CMOVO: {
        cmov::lift_cmovo(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVNO: {
        cmov::lift_cmovno(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVP: {
        cmov::lift_cmovp(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMOVNP: {
        cmov::lift_cmovnp(context, builder, instruction);
        break;
    }
    // branches

    case ZYDIS_MNEMONIC_RET: // implement to check if its a real ret or not
    {
        branches::lift_ret(context, builder, instruction, blockAddresses, run);
        break; }

    case ZYDIS_MNEMONIC_JMP: {
        branches::lift_jmp(context, builder, instruction, blockAddresses, run);
        break;
    }

    case ZYDIS_MNEMONIC_JNZ: {
        branches::lift_jnz(context, builder, instruction, blockAddresses);
        break;
    }
    case ZYDIS_MNEMONIC_JZ: {
        branches::lift_jz(context, builder, instruction, blockAddresses);
        break;
    }
    case ZYDIS_MNEMONIC_JNBE: {

        branches::lift_jnbe(context, builder, instruction, blockAddresses);
        break;
    }   
    case ZYDIS_MNEMONIC_JBE: {

        branches::lift_jbe(context, builder, instruction, blockAddresses);
        break;
    }   
    case ZYDIS_MNEMONIC_JO: {

        branches::lift_jo(context, builder, instruction, blockAddresses);
        break;
    }    
    case ZYDIS_MNEMONIC_JNO: {

        branches::lift_jno(context, builder, instruction, blockAddresses);
        break;
    }   
    case ZYDIS_MNEMONIC_JP: {

        branches::lift_jp(context, builder, instruction, blockAddresses);
        break;
    }    
    case ZYDIS_MNEMONIC_JNP: {

        branches::lift_jnp(context, builder, instruction, blockAddresses);
        break;
    }
    // arithmetics and logical operations

    case ZYDIS_MNEMONIC_XCHG: {
        arithmeticsAndLogical::lift_xchg(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_NOT: {
        arithmeticsAndLogical::lift_not(context, builder, instruction);
        break;
    }

    case ZYDIS_MNEMONIC_BSWAP: {
        arithmeticsAndLogical::lift_bswap(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_NEG: {
        arithmeticsAndLogical::lift_neg(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SAR: {
        arithmeticsAndLogical::lift_sar(context, builder, instruction);
        break;
    }

    case ZYDIS_MNEMONIC_SHL: {
        arithmeticsAndLogical::lift_shl(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SHLD: {
        arithmeticsAndLogical::lift_shld(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SHRD: {
        arithmeticsAndLogical::lift_shrd(context, builder, instruction);
        break;

    }

    case ZYDIS_MNEMONIC_SHR: {
        arithmeticsAndLogical::lift_shr(context, builder, instruction);
        break;
    }

    case ZYDIS_MNEMONIC_RCR: {
        arithmeticsAndLogical::lift_rcr(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_RCL: {
        arithmeticsAndLogical::lift_rcl(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SBB: {
        arithmeticsAndLogical::lift_sbb(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_ADC: {
        arithmeticsAndLogical::lift_adc(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_XADD: {
        arithmeticsAndLogical::lift_xadd(context, builder, instruction);
        break;
    }

    case ZYDIS_MNEMONIC_LEA: {
        arithmeticsAndLogical::lift_lea(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_INC:
    case ZYDIS_MNEMONIC_DEC: {
        arithmeticsAndLogical::lift_inc_dec(context, builder, instruction);
        break;
    }

    case ZYDIS_MNEMONIC_IMUL:
    case ZYDIS_MNEMONIC_IDIV:
    case ZYDIS_MNEMONIC_SUB:
    case ZYDIS_MNEMONIC_ADD: {
        arithmeticsAndLogical::lift_add_sub(context, builder, instruction);

        break;
    }

    case ZYDIS_MNEMONIC_XOR: {
        arithmeticsAndLogical::lift_xor(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_OR: {
        arithmeticsAndLogical::lift_or(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_AND: {
        arithmeticsAndLogical::lift_and(context, builder, instruction);

        break;
    }    
    case ZYDIS_MNEMONIC_ROR: {
        arithmeticsAndLogical::lift_ror(context, builder, instruction);

        break;
    }    
    case ZYDIS_MNEMONIC_ROL: {
        arithmeticsAndLogical::lift_rol(context, builder, instruction);

        break;
    }

    case ZYDIS_MNEMONIC_PUSH: {
        arithmeticsAndLogical::lift_push(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_PUSHFQ: {
        arithmeticsAndLogical::lift_pushfq(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_POP: {
        arithmeticsAndLogical::lift_pop(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_POPFQ: {
        arithmeticsAndLogical::lift_popfq(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_TEST: {
        arithmeticsAndLogical::lift_test(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMP: {
        arithmeticsAndLogical::lift_cmp(context, builder, instruction);
        break;
    }

    case ZYDIS_MNEMONIC_CALL: {
        branches::lift_call(context, builder, instruction, blockAddresses);
        break;
    }



    // set and flags
    case ZYDIS_MNEMONIC_SETZ: {
        flagOperation::lift_setz(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETNZ: {
        flagOperation::lift_setnz(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETO: {
        flagOperation::lift_seto(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETNO: {
        flagOperation::lift_setno(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETNB: {
        flagOperation::lift_setnb(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETNBE: {
        flagOperation::lift_setnbe(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETBE: {
        flagOperation::lift_setbe(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETNS: {
        flagOperation::lift_setns(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETP: {
        flagOperation::lift_setp(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETNP: {
        flagOperation::lift_setnp(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETB: {
        flagOperation::lift_setb(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETS: {
        flagOperation::lift_sets(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETNLE: {
        flagOperation::lift_setnle(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETLE: {
        flagOperation::lift_setle(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETNL: {
        flagOperation::lift_setnl(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_SETL: {
        flagOperation::lift_setl(context, builder, instruction);
        break;
    }

    case ZYDIS_MNEMONIC_BTR: {
        flagOperation::lift_btr(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_BSR: {
        flagOperation::lift_bsr(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_BSF: {
        flagOperation::lift_bsf(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_BTC: {
        flagOperation::lift_btc(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_LAHF: {
        flagOperation::lift_lahf(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_STC: {
        flagOperation::lift_stc(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CMC: {
        flagOperation::lift_cmc(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CLC: {
        flagOperation::lift_clc(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CLD: {
        flagOperation::lift_cld(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_CLI: {
        flagOperation::lift_cli(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_BTS: {
        flagOperation::lift_bts(context, builder, instruction);
        break;
    }
    case ZYDIS_MNEMONIC_BT: {
        flagOperation::lift_bt(context, builder, instruction);
        break;
    }
                          
    case ZYDIS_MNEMONIC_CDQ:
    {break; }
    case ZYDIS_MNEMONIC_CWDE: {
        flagOperation::lift_cwde(context, builder);
        break;
    }
    case ZYDIS_MNEMONIC_CWD: {
        flagOperation::lift_cwd(context, builder);
        break;
    }
    case ZYDIS_MNEMONIC_CQO: {
        flagOperation::lift_cqo(context, builder);
        break;
    }
    case ZYDIS_MNEMONIC_CDQE: {
        flagOperation::lift_cdqe(context, builder);
        break;
    }
    case ZYDIS_MNEMONIC_CBW:
    {
        flagOperation::lift_cbw(context, builder, instruction);
        break; }
   

    case ZYDIS_MNEMONIC_NOP: {
        break;
    }

    default: {
        cout << "not implemented: " << instruction.info.mnemonic << " runtime: " << hex << instruction.runtime_address << " " << instruction.text << "\n";
        throw std::runtime_error("not implemented");
        exit(-2);
    }
    }

}
```

`lifter/Semantics.h`:

```h
#pragma once

#include "includes.h"




void liftInstruction(LLVMContext& context, IRBuilder<>& builder, ZydisDisassembledInstruction& instruction, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses, bool* run);
```

`lifter/includes.h`:

```h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#define _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS
#define _SILENCE_ALL_CXX23_DEPRECATION_WARNINGS
#define ZYDIS_STATIC_BUILD
#define _DEVELOPMENT
#pragma warning(disable:4146)
#include <iostream>
#include <vector>
#include <map>
#include <tuple>
#undef min 
#undef max
#include <windows.h>
#undef min 
#undef max
#include <Zydis/Zydis.h>
#include <conio.h>
#include "llvm/Passes/PassBuilder.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "utils.h"

#include "llvm/Transforms/Utils/Cloning.h"
#include "llvm/ADT/APInt.h"
#include "llvm/IR/Verifier.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/GenericValue.h"
#include "llvm/ExecutionEngine/MCJIT.h"
#include "llvm/IR/Argument.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/InstrTypes.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/Transforms/Scalar/DeadStoreElimination.h"
#include "llvm/ADT/APInt.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/PostOrderIterator.h"
#include "llvm/ADT/SetVector.h"
#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Analysis/AliasAnalysis.h"
#include "llvm/Analysis/GlobalsModRef.h"
#include "llvm/Analysis/MemoryBuiltins.h"
#include "llvm/Analysis/MemoryDependenceAnalysis.h"
#include "llvm/Analysis/MemoryLocation.h"
#include "llvm/Analysis/MemorySSA.h"
#include "llvm/Analysis/MemorySSAUpdater.h"
#include "llvm/Analysis/PostDominators.h"
#include "llvm/Analysis/TargetLibraryInfo.h"
#include "llvm/Transforms/Utils/Local.h"
#include "llvm/Analysis/ValueTracking.h"
#include "llvm/IR/Argument.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constant.h"
#include "llvm/IR/Constants.h"
#include "llvm/Analysis/MemorySSA.h"
#include "llvm/Analysis/MemorySSAUpdater.h"
#include "llvm/Analysis/PostDominators.h"
#include "llvm/Analysis/AliasAnalysis.h"
#include "llvm/Transforms/Scalar.h"
#include "llvm/Transforms/Scalar/GVN.h"
#include "llvm/Transforms/Scalar/NewGVN.h"
#include "llvm/Transforms/Scalar/ADCE.h"
#include "llvm/Transforms/Scalar/DCE.h"
#include "llvm/Transforms/Scalar/DeadStoreElimination.h"
#include "llvm/Transforms/Scalar/EarlyCSE.h"
#include "llvm/Transforms/Scalar/Reg2mem.h"
#include "llvm/Transforms/Scalar/Reassociate.h"
#include "llvm/Transforms/Scalar/SCCP.h"
#include "llvm/Transforms/Scalar/SROA.h"
#include "llvm/Transforms/Scalar/MergedLoadStoreMotion.h"
#include "llvm/Transforms/InstCombine/InstCombine.h"
#include "llvm/Transforms/IPO/CrossDSOCFI.h"
#include "llvm/Transforms/IPO/ConstantMerge.h"
#include "llvm/Transforms/IPO/SCCP.h"
#include "llvm/Transforms/Utils/Mem2Reg.h"
#include "llvm/Transforms/Utils.h"

#include "llvm/ADT/Statistic.h"
#include "llvm/Analysis/AliasAnalysis.h"
#include "llvm/Analysis/BasicAliasAnalysis.h"
#include "llvm/Analysis/CGSCCPassManager.h"
#include "llvm/Analysis/GlobalsModRef.h"
#include "llvm/Analysis/InlineAdvisor.h"
#include "llvm/Analysis/ProfileSummaryInfo.h"
#include "llvm/Analysis/ScopedNoAliasAA.h"
#include "llvm/Analysis/TypeBasedAliasAnalysis.h"
#include "llvm/Analysis/MemorySSA.h"
#include "llvm/IR/PassManager.h"
#include "llvm/Passes/OptimizationLevel.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/PGOOptions.h"
#include "llvm/Support/VirtualFileSystem.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Transforms/AggressiveInstCombine/AggressiveInstCombine.h"
#include "llvm/Transforms/Coroutines/CoroCleanup.h"
#include "llvm/Transforms/Coroutines/CoroConditionalWrapper.h"
#include "llvm/Transforms/Coroutines/CoroEarly.h"
#include "llvm/Transforms/Coroutines/CoroElide.h"
#include "llvm/Transforms/Coroutines/CoroSplit.h"
#include "llvm/Transforms/IPO/AlwaysInliner.h"
#include "llvm/Transforms/IPO/Annotation2Metadata.h"
#include "llvm/Transforms/IPO/ArgumentPromotion.h"
#include "llvm/Transforms/IPO/CalledValuePropagation.h"
#include "llvm/Transforms/IPO/ConstantMerge.h"
#include "llvm/Transforms/IPO/CrossDSOCFI.h"
#include "llvm/Transforms/IPO/DeadArgumentElimination.h"
#include "llvm/Transforms/IPO/ElimAvailExtern.h"
#include "llvm/Transforms/IPO/EmbedBitcodePass.h"
#include "llvm/Transforms/IPO/ForceFunctionAttrs.h"
#include "llvm/Transforms/IPO/FunctionAttrs.h"
#include "llvm/Transforms/IPO/GlobalDCE.h"
#include "llvm/Transforms/IPO/GlobalOpt.h"
#include "llvm/Transforms/IPO/GlobalSplit.h"
#include "llvm/Transforms/IPO/HotColdSplitting.h"
#include "llvm/Transforms/IPO/IROutliner.h"
#include "llvm/Transforms/IPO/InferFunctionAttrs.h"
#include "llvm/Transforms/IPO/Inliner.h"
#include "llvm/Transforms/IPO/LowerTypeTests.h"
#include "llvm/Transforms/IPO/MemProfContextDisambiguation.h"
#include "llvm/Transforms/IPO/MergeFunctions.h"
#include "llvm/Transforms/IPO/ModuleInliner.h"
#include "llvm/Transforms/IPO/OpenMPOpt.h"
#include "llvm/Transforms/IPO/PartialInlining.h"
#include "llvm/Transforms/IPO/SCCP.h"
#include "llvm/Transforms/IPO/SampleProfile.h"
#include "llvm/Transforms/IPO/SampleProfileProbe.h"
#include "llvm/Transforms/IPO/SyntheticCountsPropagation.h"
#include "llvm/Transforms/IPO/WholeProgramDevirt.h"
#include "llvm/Transforms/InstCombine/InstCombine.h"
#include "llvm/Transforms/Instrumentation/CGProfile.h"
#include "llvm/Transforms/Instrumentation/ControlHeightReduction.h"
#include "llvm/Transforms/Instrumentation/InstrOrderFile.h"
#include "llvm/Transforms/Instrumentation/InstrProfiling.h"
#include "llvm/Transforms/Instrumentation/MemProfiler.h"
#include "llvm/Transforms/Instrumentation/PGOInstrumentation.h"
#include "llvm/Transforms/Scalar/ADCE.h"
#include "llvm/Transforms/Scalar/AlignmentFromAssumptions.h"
#include "llvm/Transforms/Scalar/AnnotationRemarks.h"
#include "llvm/Transforms/Scalar/BDCE.h"
#include "llvm/Transforms/Scalar/CallSiteSplitting.h"
#include "llvm/Transforms/Scalar/ConstraintElimination.h"
#include "llvm/Transforms/Scalar/CorrelatedValuePropagation.h"
#include "llvm/Transforms/Scalar/DFAJumpThreading.h"
#include "llvm/Transforms/Scalar/DeadStoreElimination.h"
#include "llvm/Transforms/Scalar/DivRemPairs.h"
#include "llvm/Transforms/Scalar/EarlyCSE.h"
#include "llvm/Transforms/Scalar/Float2Int.h"
#include "llvm/Transforms/Scalar/GVN.h"
#include "llvm/Transforms/Scalar/IndVarSimplify.h"
#include "llvm/Transforms/Scalar/InstSimplifyPass.h"
#include "llvm/Transforms/Scalar/JumpThreading.h"
#include "llvm/Transforms/Scalar/LICM.h"
#include "llvm/Transforms/Scalar/LoopDeletion.h"
#include "llvm/Transforms/Scalar/LoopDistribute.h"
#include "llvm/Transforms/Scalar/LoopFlatten.h"
#include "llvm/Transforms/Scalar/LoopIdiomRecognize.h"
#include "llvm/Transforms/Scalar/LoopInstSimplify.h"
#include "llvm/Transforms/Scalar/LoopInterchange.h"
#include "llvm/Transforms/Scalar/LoopLoadElimination.h"
#include "llvm/Transforms/Scalar/LoopPassManager.h"
#include "llvm/Transforms/Scalar/LoopRotation.h"
#include "llvm/Transforms/Scalar/LoopSimplifyCFG.h"
#include "llvm/Transforms/Scalar/LoopSink.h"
#include "llvm/Transforms/Scalar/LoopUnrollAndJamPass.h"
#include "llvm/Transforms/Scalar/LoopUnrollPass.h"
#include "llvm/Transforms/Scalar/LoopVersioningLICM.h"
#include "llvm/Transforms/Scalar/LowerConstantIntrinsics.h"
#include "llvm/Transforms/Scalar/LowerExpectIntrinsic.h"
#include "llvm/Transforms/Scalar/LowerMatrixIntrinsics.h"
#include "llvm/Transforms/Scalar/MemCpyOptimizer.h"
#include "llvm/Transforms/Scalar/MergedLoadStoreMotion.h"
#include "llvm/Transforms/Scalar/NewGVN.h"
#include "llvm/Transforms/Scalar/Reassociate.h"
#include "llvm/Transforms/Scalar/SCCP.h"
#include "llvm/Transforms/Scalar/SROA.h"
#include "llvm/Transforms/Scalar/SimpleLoopUnswitch.h"
#include "llvm/Transforms/Scalar/SimplifyCFG.h"
#include "llvm/Transforms/Scalar/SpeculativeExecution.h"
#include "llvm/Transforms/Scalar/TailRecursionElimination.h"
#include "llvm/Transforms/Scalar/WarnMissedTransforms.h"
#include "llvm/Transforms/Utils/AddDiscriminators.h"
#include "llvm/Transforms/Utils/AssumeBundleBuilder.h"
#include "llvm/Transforms/Utils/CanonicalizeAliases.h"
#include "llvm/Transforms/Utils/CountVisits.h"
#include "llvm/Transforms/Utils/InjectTLIMappings.h"
#include "llvm/Transforms/Utils/LibCallsShrinkWrap.h"
#include "llvm/Transforms/Utils/Mem2Reg.h"
#include "llvm/Transforms/Utils/MoveAutoInit.h"
#include "llvm/Transforms/Utils/NameAnonGlobals.h"
#include "llvm/Transforms/Utils/RelLookupTableConverter.h"
#include "llvm/Transforms/Utils/SimplifyCFGOptions.h"
#include "llvm/Transforms/Vectorize/LoopVectorize.h"
#include "llvm/Transforms/Vectorize/SLPVectorizer.h"
#include "llvm/Transforms/Vectorize/VectorCombine.h"


#include "llvm/Codegen/Passes.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/GenericValue.h"
#include "llvm/ExecutionEngine/MCJIT.h"
#include "llvm/IR/Argument.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/ManagedStatic.h"
#include "llvm/Support/TargetSelect.h"
#include "llvm/Support/raw_ostream.h"

using namespace std;
using namespace llvm;
#define RIP 0x007FFFFFFF400000
#define STACKP_VALUE 0x0000000000200000

enum FlagOperation {
	SET_VALUE,
	SET_ONE,
	SET_ZERO,
	TOGGLE
};


enum Flag {
    FLAG_CF = 0, // Carry flag
    FLAG_PF = 2, // Parity flag
    FLAG_AF = 4, // Adjust flag
    FLAG_ZF = 6, // Zero flag
    FLAG_SF = 7, // Sign flag
    FLAG_TF = 8, // Trap flag
    FLAG_IF = 9, // Interrupt enable flag
    FLAG_DF = 10, // Direction flag
    FLAG_OF = 11, // Overflow flag
    // Add other architecture-specific flags as needed
};


enum opaque_info {
    NOT_OPAQUE = 0,
    OPAQUE_TRUE = 1,
    OPAQUE_FALSE = 2
};


enum ROP_info {
    ROP_return = 0,
    REAL_return = 1,
};

enum JMP_info {
    JOP_jmp = 0,
    REAL_jmp = 1,
};


```

`lifter/lifter.cpp`:

```cpp
// lifter.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include "includes.h"
#include "LLVM-init.h"
#include "Semantics.h"
#include "OperandUtils.h"
#include "ROPdetection.h"
#include "OperandUtils.h"

#define _CRTDBG_MAP_ALLOC
// Function to disassemble and convert


// plan:
// 1- Handle operands, get set etc. (framework for handling instructions)  -done
// ^^^dont forget properly getting highest register
// 
// 1a- Initialize calling stuff, registers - done
// 1b- Get and set registers done
// ^^^dont forget size conversions
// ^^^most of the stuff that elongates the reversing process is writing stuff into memory.
// 
// 2- Handle instructions.  - semi done , added few instructions
// 
// 3- Handle blocks or optimization - working on blocks
// 
// 4- Handle blocks or optimization
//


vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > added_blocks_addresses;
uintptr_t original_address = 0;

// first of all, this function is UGLY af, so I'm sorry you are reading this.
void asm_to_zydis_to_lift(LLVMContext& context, IRBuilder<>& builder, ZyanU8* data, ZyanU64 runtime_address, shared_ptr<vector< tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*> > > > blockAddresses, Function* function, ZyanU64 file_base) {

    // run the loop until we have a reason to end, I believe this should've been removed but its there :trollface:
    bool run = 1;
    while (run) {

        // blockAddresses contains the blocks we want to work on. If there is no block we want to work on, end the loop.
        while (blockAddresses->size() > 0) {

            // find the real address in memory of where we want to continue parsing
            runtime_address = get<0>(blockAddresses->back());
            uintptr_t offset = address_to_mapped_address((LPVOID)file_base, runtime_address);
#ifdef _DEVELOPMENT
            cout << "runtime_addr: " << runtime_address << " offset:" << offset << " byte there: 0x" << (int)*(BYTE*)(file_base + offset) << endl;
            cout << "offset: " << offset << " file_base?: " << original_address << " runtime: " << runtime_address << endl;
#endif






            // not sure what it was supposed to do
            added_blocks_addresses.push_back(blockAddresses->back());
            // set the LLVM builder to work on bb
            builder.SetInsertPoint(get<1>(blockAddresses->back()));



            // we want to store the register list because its SSA.
            setRegisterList(get<2>(blockAddresses->back()));
            // a very simplified representation why:
            // 
            // mov ecx, 10 --- %ecx_0 = 10
            // test eax, eax --- if (!eax) jump branch2;
            // je branch2:
            //
            // branch1:
            // add ecx, 10 --- %ecx_1 = %ecx_0 + 10
            // ret --- ret i64 %ecx_1
            // branch2:
            // sub ecx, 10 --- %ecx_2 = %ecx_0 - 10
            // ret -- ret i64 %ecx_2
            //
            // if we hadn't store the registers then branch 
            // branch2 would thought we still operate on %ecx_1 and since it's in a different branch, it wouldn't work


            // we are working on this block, so remove it from vector
            blockAddresses->pop_back();

            // this is for memory accesses to the binary
            initDetections((LPVOID)file_base, data);
            initBases2((LPVOID)file_base, data);
            size_t last_value;

            //idk?
            bool run = 1;

            //sanity check
            if (!blockAddresses->empty()) {
                last_value = get<0>(blockAddresses->back());
            }
            else {
                // Handle error or set a default value to last_value
                last_value = 0;  // or some other appropriate value or action
            }

            // more loops :trollface:
            ZydisDisassembledInstruction instruction;
            // this loop is responsible of parsing asm into zydis then LLVM.
            for (; run && runtime_address > 0; )
            {
                //the function we know and we love
                ZydisDisassembleIntel(ZYDIS_MACHINE_MODE_LONG_64, runtime_address, data + offset, 15, &instruction);

                if (
                    (blockAddresses->size() == 0 ||
                        (last_value == get<0>(blockAddresses->back()))))
                {

                    // Print current instruction.
                    
#ifdef _DEVELOPMENT
                    cout << instruction.text << "\n";
                    cout << "runtime: " << runtime_address << "\n";
#endif
                    instruction.runtime_address += instruction.info.length;


                    // WHERE THE MAGIC REALLY HAPPENS.
                    liftInstruction(context, builder, instruction, blockAddresses, &run);

                    // i dont remember.
                    offset += instruction.info.length;
                    runtime_address += instruction.info.length;

                    for (auto& b_address : added_blocks_addresses) {
                        if (get<0>(b_address) - file_base == offset) {
                            builder.CreateBr(get<1>(b_address));
                            builder.SetInsertPoint(get<1>(b_address));
                            run = 0;
                            break;
                        }
                    }

                }
                else
                {
                    break;
                }
            }

        }
        run = 0;

        // print the function to a file
        llvm::ValueToValueMapTy VMap;
        std::string Filename = "output_noopts.ll";
        std::error_code EC;
        llvm::raw_fd_ostream OS(Filename, EC);

        function->print(OS, nullptr);

    }
}



void InitFunction_and_LiftInstructions(ZyanU8* data, ZyanU64 runtime_address, uintptr_t file_base) {
    ZydisDecoder decoder;
    ZydisFormatter formatter;

    // Initialize decoder and formatter.
    ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_STACK_WIDTH_64);
    ZydisFormatterInit(&formatter, ZYDIS_FORMATTER_STYLE_INTEL);

    // initialize llvm context and module
    LLVMContext context;
    string mod_name = "my_lifting_module";
    llvm::Module lifting_module = llvm::Module(mod_name.c_str(), context);


    // initialize arguments
    std::vector<llvm::Type*> argTypes;
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getInt64Ty(context)); // 16 regs
    argTypes.push_back(llvm::Type::getVoidTy(context)->getPointerTo()); // 1 off because rsp

    auto functionType = llvm::FunctionType::get(llvm::Type::getInt64Ty(context), argTypes, 0);


    // initialize function
    string function_name = "main";
    auto function = llvm::Function::Create(functionType, llvm::Function::ExternalLinkage, function_name.c_str(), lifting_module);

    // initialize BB(basic block)
    string block_name = "entry";
    auto bb = llvm::BasicBlock::Create(context, block_name.c_str(), function);
    llvm::IRBuilder<> builder = llvm::IRBuilder<>(bb);

    // "link" the arguments to a register map
    auto RegisterList = InitRegisters(context, builder, function, runtime_address);

    ZydisDisassembledInstruction instruction;



    // this works, but its ugly.
    std::shared_ptr<std::vector<std::tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*>>>> blockAddresses = std::make_shared<std::vector<std::tuple<uintptr_t, BasicBlock*, unordered_map<int, Value*>>>>();

    blockAddresses->push_back(make_tuple(runtime_address, bb, RegisterList));

    // WHERE MAGIC HAPPENS.
    asm_to_zydis_to_lift(context, builder, (BYTE*)file_base, runtime_address, blockAddresses, function, file_base);


    // dump the result to output.ll
    std::string Filename = "output.ll";
    std::error_code EC;
    llvm::raw_fd_ostream OS(Filename, EC);

    if (EC) {
        llvm::errs() << "Could not open file: " << EC.message();
        return;
    }

    lifting_module.print(OS, nullptr);
    // Close the output stream
    OS.flush();


    return;
}



int main(int argc, char* argv[])
{
    auto start = std::chrono::high_resolution_clock::now();

    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <filename> <startAddr>" << std::endl;
        _getch();
        return 1;
    }

    const char* filename = argv[1];
    uint64_t startAddr = std::stoull(argv[2], nullptr, 0);


    HANDLE hFile = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        std::cout << "Failed to open the file." << std::endl;
        return 1;
    }

    // probably move this part to a function
    DWORD fileSize = GetFileSize(hFile, NULL);
    HANDLE hMapping = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    LPVOID fileBase = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, fileSize);

    // Parse the PE headers
    PIMAGE_DOS_HEADER dosHeader = static_cast<PIMAGE_DOS_HEADER>(fileBase);
    PIMAGE_NT_HEADERS ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<BYTE*>(fileBase) + dosHeader->e_lfanew);
    PIMAGE_SECTION_HEADER sectionHeader = IMAGE_FIRST_SECTION(ntHeaders);
    auto ADDRESS = ntHeaders->OptionalHeader.ImageBase;
    uintptr_t RVA = static_cast<uintptr_t>(startAddr - ADDRESS);
    uintptr_t fileOffset = RvaToFileOffset(ntHeaders, RVA);
    BYTE* dataAtAddress = reinterpret_cast<BYTE*>(fileBase) + fileOffset;
    cout << hex << "0x" << (int)*dataAtAddress << endl;
    original_address = ADDRESS;
    cout << "address: " << ADDRESS << " filebase: " << (uintptr_t)fileBase << " fOffset: " << fileOffset << " RVA: " << RVA << endl;


    // important part here.
    InitFunction_and_LiftInstructions(dataAtAddress, startAddr, (uintptr_t)fileBase);



    // ending...
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    long long microseconds = std::chrono::duration_cast<std::chrono::microseconds>(
        elapsed).count();
    cout << "\n" << dec << microseconds << " microsecond has past";

    UnmapViewOfFile(fileBase);
    CloseHandle(hMapping);
    CloseHandle(hFile);

}
```

`lifter/lifter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{77360b3e-73d5-4eb4-8f2d-8ba5280ef06c}</ProjectGuid>
    <RootNamespace>lifter</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <EnableASAN>true</EnableASAN>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <EnableASAN>false</EnableASAN>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../../zydis-4.0.0/include;../../llvm-project/llvm/include;../../zydis-4.0.0/dependencies/zycore/include;C:\Users\yusuf\Desktop\Z2LLVM\llvm-project\llvm\build\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>../../zydis-4.0.0/build/Debug/Zydis.lib;../../zydis-4.0.0/build/zycore/Debug/Zycore.lib;../../llvm-project/llvm/build/Debug/lib/LLVMCore.lib;../../llvm-project/llvm/build/Debug/lib/LLVMExecutionEngine.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMC.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMCJIT.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSupport.lib;../../llvm-project/llvm/build/Debug/lib/LLVMX86CodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMX86Desc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMX86Info.lib;../../llvm-project/llvm/build/Debug/lib/LLVMOrcTargetProcess.lib;../../llvm-project/llvm/build/Debug/lib/LLVMOrcShared.lib;../../llvm-project/llvm/build/Debug/lib/LLVMRuntimeDyld.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMCDisassembler.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAsmPrinter.lib;../../llvm-project/llvm/build/Debug/lib/LLVMCFGuard.lib;../../llvm-project/llvm/build/Debug/lib/LLVMGlobalISel.lib;../../llvm-project/llvm/build/Debug/lib/LLVMInstrumentation.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSelectionDAG.lib;../../llvm-project/llvm/build/Debug/lib/LLVMCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMTarget.lib;../../llvm-project/llvm/build/Debug/lib/LLVMBitWriter.lib;../../llvm-project/llvm/build/Debug/lib/LLVMObjCARCOpts.lib;../../llvm-project/llvm/build/Debug/lib/LLVMScalarOpts.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAggressiveInstCombine.lib;../../llvm-project/llvm/build/Debug/lib/LLVMInstCombine.lib;../../llvm-project/llvm/build/Debug/lib/LLVMCodeGenTypes.lib;../../llvm-project/llvm/build/Debug/lib/LLVMTransformUtils.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAnalysis.lib;../../llvm-project/llvm/build/Debug/lib/LLVMProfileData.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSymbolize.lib;../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoDWARF.lib;../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoPDB.lib;../../llvm-project/llvm/build/Debug/lib/LLVMObject.lib;../../llvm-project/llvm/build/Debug/lib/LLVMIRReader.lib;../../llvm-project/llvm/build/Debug/lib/LLVMBitReader.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMRemarks.lib;../../llvm-project/llvm/build/Debug/lib/LLVMBitstreamReader.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMCParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMTextAPI.lib;../../llvm-project/llvm/build/Debug/lib/LLVMBinaryFormat.lib;../../llvm-project/llvm/build/Debug/lib/LLVMTargetParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoCodeView.lib;../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoMSF.lib;../../llvm-project/llvm/build/Debug/lib/LLVMDebugInfoBTF.lib;../../llvm-project/llvm/build/Debug/lib/LLVMDemangle.lib;../../llvm-project/llvm/build/Debug/lib/LLVMPasses.lib;psapi.lib;shell32.lib;ole32.lib;uuid.lib;advapi32.lib;delayimp.lib;-delayload:shell32.dll;-delayload:ole32.dll;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;oleaut32.lib;comdlg32.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAArch64AsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMARMAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAVRAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMBPFAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMHexagonAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMLanaiAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMLoongArchAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMipsAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMSP430AsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMPowerPCAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMRISCVAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSparcAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSystemZAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMVEAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyAsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMX86AsmParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAArch64CodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMARMCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAVRCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMBPFCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMHexagonCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMLanaiCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMLoongArchCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMipsCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMSP430CodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMNVPTXCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMPowerPCCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMRISCVCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSparcCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSystemZCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMVECodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMXCoreCodeGen.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAArch64Desc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMARMDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAVRDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMBPFDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMHexagonDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMLanaiDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMLoongArchDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMipsDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMSP430Desc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMNVPTXDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMPowerPCDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMRISCVDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSparcDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSystemZDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMVEDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMXCoreDesc.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAArch64Info.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMARMInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAVRInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMBPFInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMHexagonInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMLanaiInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMLoongArchInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMipsInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMSP430Info.lib;../../llvm-project/llvm/build/Debug/lib/LLVMNVPTXInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMPowerPCInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMRISCVInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSparcInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMSystemZInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMVEInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMXCoreInfo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMCoroutines.lib;../../llvm-project/llvm/build/Debug/lib/LLVMExtensions.lib;../../llvm-project/llvm/build/Debug/lib/LLVMipo.lib;../../llvm-project/llvm/build/Debug/lib/LLVMIRPrinter.lib;../../llvm-project/llvm/build/Debug/lib/LLVMVectorize.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAArch64Utils.lib;../../llvm-project/llvm/build/Debug/lib/LLVMAMDGPUUtils.lib;../../llvm-project/llvm/build/Debug/lib/LLVMMIRParser.lib;../../llvm-project/llvm/build/Debug/lib/LLVMARMUtils.lib;../../llvm-project/llvm/build/Debug/lib/LLVMFrontendOpenMP.lib;../../llvm-project/llvm/build/Debug/lib/LLVMLinker.lib;../../llvm-project/llvm/build/Debug/lib/LLVMWebAssemblyUtils.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../../zydis/include;../../llvm-project/llvm/include;../../zydis/dependencies/zycore/include;../../llvm-project/llvm/build/include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <Optimization>MaxSpeed</Optimization>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <StringPooling>true</StringPooling>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>../../zydis/ReleaseX64/Zydis.lib;../../zydis/ReleaseX64/Zycore.lib;../../llvm-project/llvm/build/Release/lib/LLVMCore.lib;../../llvm-project/llvm/build/Release/lib/LLVMExecutionEngine.lib;../../llvm-project/llvm/build/Release/lib/LLVMMC.lib;../../llvm-project/llvm/build/Release/lib/LLVMMCJIT.lib;../../llvm-project/llvm/build/Release/lib/LLVMSupport.lib;../../llvm-project/llvm/build/Release/lib/LLVMX86CodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMX86Desc.lib;../../llvm-project/llvm/build/Release/lib/LLVMX86Info.lib;../../llvm-project/llvm/build/Release/lib/LLVMOrcTargetProcess.lib;../../llvm-project/llvm/build/Release/lib/LLVMOrcShared.lib;../../llvm-project/llvm/build/Release/lib/LLVMRuntimeDyld.lib;../../llvm-project/llvm/build/Release/lib/LLVMMCDisassembler.lib;../../llvm-project/llvm/build/Release/lib/LLVMAsmPrinter.lib;../../llvm-project/llvm/build/Release/lib/LLVMCFGuard.lib;../../llvm-project/llvm/build/Release/lib/LLVMGlobalISel.lib;../../llvm-project/llvm/build/Release/lib/LLVMInstrumentation.lib;../../llvm-project/llvm/build/Release/lib/LLVMSelectionDAG.lib;../../llvm-project/llvm/build/Release/lib/LLVMCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMTarget.lib;../../llvm-project/llvm/build/Release/lib/LLVMBitWriter.lib;../../llvm-project/llvm/build/Release/lib/LLVMObjCARCOpts.lib;../../llvm-project/llvm/build/Release/lib/LLVMScalarOpts.lib;../../llvm-project/llvm/build/Release/lib/LLVMAggressiveInstCombine.lib;../../llvm-project/llvm/build/Release/lib/LLVMInstCombine.lib;../../llvm-project/llvm/build/Release/lib/LLVMCodeGenTypes.lib;../../llvm-project/llvm/build/Release/lib/LLVMTransformUtils.lib;../../llvm-project/llvm/build/Release/lib/LLVMAnalysis.lib;../../llvm-project/llvm/build/Release/lib/LLVMProfileData.lib;../../llvm-project/llvm/build/Release/lib/LLVMSymbolize.lib;../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoDWARF.lib;../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoPDB.lib;../../llvm-project/llvm/build/Release/lib/LLVMObject.lib;../../llvm-project/llvm/build/Release/lib/LLVMIRReader.lib;../../llvm-project/llvm/build/Release/lib/LLVMBitReader.lib;../../llvm-project/llvm/build/Release/lib/LLVMAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMRemarks.lib;../../llvm-project/llvm/build/Release/lib/LLVMBitstreamReader.lib;../../llvm-project/llvm/build/Release/lib/LLVMMCParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMTextAPI.lib;../../llvm-project/llvm/build/Release/lib/LLVMBinaryFormat.lib;../../llvm-project/llvm/build/Release/lib/LLVMTargetParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoCodeView.lib;../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoMSF.lib;../../llvm-project/llvm/build/Release/lib/LLVMDebugInfoBTF.lib;../../llvm-project/llvm/build/Release/lib/LLVMDemangle.lib;../../llvm-project/llvm/build/Release/lib/LLVMPasses.lib;psapi.lib;shell32.lib;ole32.lib;uuid.lib;advapi32.lib;delayimp.lib;-delayload:shell32.dll;-delayload:ole32.dll;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;oleaut32.lib;comdlg32.lib;../../llvm-project/llvm/build/Release/lib/LLVMAArch64AsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMARMAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMAVRAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMBPFAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMHexagonAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMLanaiAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMLoongArchAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMMipsAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMMSP430AsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMPowerPCAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMRISCVAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMSparcAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMSystemZAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMVEAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyAsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMX86AsmParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMAArch64CodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMARMCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMAVRCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMBPFCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMHexagonCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMLanaiCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMLoongArchCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMMipsCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMMSP430CodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMNVPTXCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMPowerPCCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMRISCVCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMSparcCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMSystemZCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMVECodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMXCoreCodeGen.lib;../../llvm-project/llvm/build/Release/lib/LLVMAArch64Desc.lib;../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMARMDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMAVRDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMBPFDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMHexagonDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMLanaiDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMLoongArchDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMMipsDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMMSP430Desc.lib;../../llvm-project/llvm/build/Release/lib/LLVMNVPTXDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMPowerPCDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMRISCVDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMSparcDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMSystemZDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMVEDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMXCoreDesc.lib;../../llvm-project/llvm/build/Release/lib/LLVMAArch64Info.lib;../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMARMInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMAVRInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMBPFInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMHexagonInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMLanaiInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMLoongArchInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMMipsInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMMSP430Info.lib;../../llvm-project/llvm/build/Release/lib/LLVMNVPTXInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMPowerPCInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMRISCVInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMSparcInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMSystemZInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMVEInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMXCoreInfo.lib;../../llvm-project/llvm/build/Release/lib/LLVMCoroutines.lib;../../llvm-project/llvm/build/Release/lib/LLVMExtensions.lib;../../llvm-project/llvm/build/Release/lib/LLVMipo.lib;../../llvm-project/llvm/build/Release/lib/LLVMIRPrinter.lib;../../llvm-project/llvm/build/Release/lib/LLVMVectorize.lib;../../llvm-project/llvm/build/Release/lib/LLVMAArch64Utils.lib;../../llvm-project/llvm/build/Release/lib/LLVMAMDGPUUtils.lib;../../llvm-project/llvm/build/Release/lib/LLVMMIRParser.lib;../../llvm-project/llvm/build/Release/lib/LLVMARMUtils.lib;../../llvm-project/llvm/build/Release/lib/LLVMFrontendOpenMP.lib;../../llvm-project/llvm/build/Release/lib/LLVMLinker.lib;../../llvm-project/llvm/build/Release/lib/LLVMWebAssemblyUtils.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <Profile>true</Profile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CustomPasses.cpp" />
    <ClCompile Include="lifter.cpp" />
    <ClCompile Include="LLVM-init.cpp" />
    <ClCompile Include="nacibaba_opts.cpp" />
    <ClCompile Include="OperandUtils.cpp" />
    <ClCompile Include="ROPdetection.cpp" />
    <ClCompile Include="Semantics.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CustomPasses.h" />
    <ClInclude Include="includes.h" />
    <ClInclude Include="LLVM-init.h" />
    <ClInclude Include="nacibaba_opts.h" />
    <ClInclude Include="OperandUtils.h" />
    <ClInclude Include="ROPdetection.h" />
    <ClInclude Include="Semantics.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`lifter/lifter.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="lifter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LLVM-init.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Semantics.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="OperandUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ROPdetection.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="nacibaba_opts.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CustomPasses.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LLVM-init.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Semantics.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="OperandUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ROPdetection.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nacibaba_opts.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CustomPasses.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`lifter/lifter.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`lifter/nacibaba_opts.cpp`:

```cpp
#include "includes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/Pass.h"
#include "llvm/Support/raw_ostream.h"

struct StoreInfo {
    Value* val;          // The value being stored
    unsigned bitWidth;   // The bit width of the value
};

using namespace llvm;

namespace {
    struct ReplaceLoadWithStoreValuePass : public FunctionPass {
        static char ID;
        ReplaceLoadWithStoreValuePass() : FunctionPass(ID) {}



        bool runOnFunction(Function& F) override {
            bool modified = false;
            std::unordered_map<Value*, std::vector<StoreInfo>> latestStore;

            // store t1 x, ptr y
            // load t2, ptr y
            // replace y with alloc, so it should be
            // %z = alloca t (can it be i128 default? 
            //   
            // %0 = alloca i32, i32 2
            // store t1 x, ptr %z
            // load t2, ptr %z
            //
            // lets say
            // push rax
            // mov rax, [rsp+4] 
            //
            // %0 = alloca i64
            // store %rax, %0
            // %gep = getelementptr i32, ptr %0, i32 1 // gep i32 = align by 4; ptr %0 = from pointer 0; i32 1 = first element
            // %newrax = load i64, ptr %gep
            //
            // however in this case we also need to put it to map;
            // currently we do it like this
            // 
            // store t1 x, ptr y
            // load t2, ptr y+4
            // so y and y+4 should share same alloca, but its like
            //
            // store i64 123467812345678, ptr 4
            // load i32, ptr 8




            for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I) {

                if (StoreInst* store = dyn_cast<StoreInst>(&*I)) {
                    Value* storeptr = store->getPointerOperand();
                    Value* val = store->getValueOperand();


                    unsigned bitWidth = val->getType()->getIntegerBitWidth();
                    latestStore[storeptr].emplace_back(StoreInfo{ val, bitWidth });
                }

                // Handling Load Instructions
                else if (LoadInst* load = dyn_cast<LoadInst>(&*I)) {
                    
                    Value* ptr = load->getPointerOperand();
                    
                    unsigned loadBitWidth = load->getType()->getIntegerBitWidth();
                    

                    if (latestStore.find(ptr) != latestStore.end()) {
                        IRBuilder<> builder(load);
                        Value* loadedVal = ConstantInt::get(load->getType(), 0); // Start with 0

                        for (const StoreInfo& storeInfo : latestStore[ptr]) {
       

                            Value* storedVal = storeInfo.val; 
  
                            unsigned storedBitWidth = storeInfo.bitWidth; 
         
                            

                            Value* mask1 = builder.CreateSub(
                                ConstantInt::get(storedVal->getType(), 0),
                                ConstantInt::get(storedVal->getType(), 1),
                                "mask1");
                            

                            if (mask1->getType()->getIntegerBitWidth() != loadBitWidth)
                                mask1 = builder.CreateZExtOrTrunc(mask1, load->getType(), "mask2");

                            Value* final_mask = builder.CreateSub(ConstantInt::get(load->getType(), -1), mask1, "opt_maskfinal");



                            Value* MaskedStored = builder.CreateAnd(final_mask, loadedVal, "opt_masked"); // 0x3131 | 0xff00, storedVal is cleared its not 0x3100


                            if (storedVal->getType()->getIntegerBitWidth() != loadBitWidth )
                                storedVal = builder.CreateZExtOrTrunc(storedVal, load->getType(),"opt_zext");

                            loadedVal = builder.CreateOr(storedVal, MaskedStored,"opt_or");
                            
                            
                        }
                        load->replaceAllUsesWith(loadedVal);
                        modified = true;
                    }
                }
            }
            return modified; // Return true if the IR was modified
        }
    };
}

char ReplaceLoadWithStoreValuePass::ID = 0;

// function pass for replacing loads with store pass
// before pass ->
// store i64 100, ptr some_mem
// %x = load i64, ptr some_mem
// 
// after pass ->
// store i64 100, ptr some_mem
// %x = 100
//
FunctionPass* create_nacibaba_replace_load_with_store_pass() {
    return new ReplaceLoadWithStoreValuePass();
}


namespace {

    struct LoadFromBinaryPass : public FunctionPass {
        static char ID;
        LPVOID binaryBase;
        ZyanU8* data;

        LoadFromBinaryPass(LPVOID base, ZyanU8* fdata) : FunctionPass(ID) {
            binaryBase = base;
            data = fdata;
            // Read the binary into binaryMemory using std::ifstream
            // Set binaryBase to point to binaryMemory.data()
        }


        bool runOnFunction(Function& F) override {
            bool modified = false;
            for (BasicBlock& BB : F) {
                for (Instruction& I : BB) {
                    if (LoadInst* load = dyn_cast<LoadInst>(&I)) {
                        Value* pointerOperand = load->getPointerOperand();
                        
                        if (Operator* op = dyn_cast<Operator>(pointerOperand)) {
                            if (ConstantInt* CI = dyn_cast<ConstantInt>(op->getOperand(0))) {
                                uintptr_t addr = CI->getZExtValue();
                                uintptr_t mappedAddr = address_to_mapped_address(binaryBase, addr);
                                //cout << "mapppedaddr: " << mappedAddr << " addr: " << addr << "\n";
                                if (mappedAddr > 0) {
                                    Type* loadType = load->getType();
                                    unsigned byteSize = loadType->getIntegerBitWidth() / 8;

                                    uintptr_t tempvalue;
                                    std::memcpy(&tempvalue, reinterpret_cast<const void*>( data + mappedAddr), byteSize);


                                    APInt readValue(byteSize * 8, tempvalue);
                                    Constant* newVal = ConstantInt::get(loadType, readValue);
                                    load->replaceAllUsesWith(newVal);

                                    modified = true;
                                }
                            }
                        }
                    }
                }
            }
            return modified;
        }
    };

}  // End of anonymous namespace

char LoadFromBinaryPass::ID = 0;



// basically replace detect binary loads and replace the load with value
//before pass-> 
// %x = load i64, ptr 0x140002000
// after pass ->
// %x = [whatever the value is at 0x140002000, but no load inst]
FunctionPass* create_nacibaba_replace_load_from_memory(LPVOID binaryBase, ZyanU8* data) {
    return new LoadFromBinaryPass(binaryBase, data);
}




struct StoreInfoFinal {
    Value* val;          // The value being stored
    unsigned bitWidth;   // The bit width of the value
    bool ambigous;
};

using namespace llvm;

namespace {
    struct ReplaceLoadWithStoreValuePassFinal : public FunctionPass {
        static char ID;
        ReplaceLoadWithStoreValuePassFinal() : FunctionPass(ID) {}



        bool runOnFunction(Function& F) override {
            bool modified = false;

            // Maintain a map from a memory location to its latest StoreInst

            // change the map into something so we also store store size with store pointer
            // then when when we are going to merge big loadsize with small storesize, search for older store with same storesize then we merge it using masks to extract the smaller loadsize
            // however we still have the problem of pointer not being the same, so maybe using llvm pass makes more sense
            std::map<Value*, std::vector<StoreInfoFinal>> latestStore;


            for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I) {

                if (StoreInst* store = dyn_cast<StoreInst>(&*I)) {
                    Value* ptr = store->getPointerOperand();
                    Value* val = store->getValueOperand();


                    if (!dyn_cast<ConstantExpr>(ptr)) {

                        for (auto& stores : latestStore) {
                            for (auto& stuff : stores.second) {
                                stuff.ambigous = 1;
                            }
                        }
                        continue;
                    }


                    unsigned bitWidth = val->getType()->getIntegerBitWidth();
                    latestStore[ptr].emplace_back(StoreInfoFinal{ val, bitWidth , 0 });

                }

                // Handling Load Instructions
                else if (LoadInst* load = dyn_cast<LoadInst>(&*I)) {
                    Value* ptr = load->getPointerOperand();
                    unsigned loadBitWidth = load->getType()->getIntegerBitWidth();

                    if (latestStore.find(ptr) != latestStore.end()) {

                        IRBuilder<> builder(load);
                        Value* loadedVal = ConstantInt::get(load->getType(), 1337); // Start with 0
                        unsigned maxamb = 0;
                        bool didchange = false;
                        for (const StoreInfoFinal& storeInfo : latestStore[ptr]) {

                            didchange = false;

                            if (storeInfo.ambigous || maxamb > storeInfo.bitWidth) {
                                maxamb = max(maxamb, storeInfo.bitWidth);
                                continue;
                            }

                            Value* storedVal = storeInfo.val;
                            unsigned storedBitWidth = storeInfo.bitWidth;



                            Value* mask1 = builder.CreateSub(
                                ConstantInt::get(storedVal->getType(), 0),
                                ConstantInt::get(storedVal->getType(), 1),
                                "mask1");


                            if (mask1->getType()->getIntegerBitWidth() != loadBitWidth)
                                mask1 = builder.CreateZExtOrTrunc(mask1, load->getType(), "mask2");

                            Value* final_mask = builder.CreateSub(ConstantInt::get(load->getType(), -1), mask1, "opt_maskfinal");
                            Value* MaskedStored = builder.CreateAnd(final_mask, loadedVal, "opt_masked");

                            storedVal = builder.CreateZExtOrTrunc(storedVal, load->getType(), "opt_zext");

                            loadedVal = builder.CreateOr(storedVal, MaskedStored, "opt_or");

                            didchange = true;

                        }

                        if (didchange) {
                            load->replaceAllUsesWith(loadedVal);
                            modified = true;
                        }
                        
                    }
                }
            }
            return modified; // Return true if the IR was modified
        }
    };
}

char ReplaceLoadWithStoreValuePassFinal::ID = 0;

FunctionPass* create_nacibaba_replace_load_with_store_pass_final() {
    return new ReplaceLoadWithStoreValuePassFinal();
}


namespace {
    struct IntToPtrToAllocaPass : public FunctionPass {
        static char ID;
        IntToPtrToAllocaPass() : FunctionPass(ID) {}

        bool runOnFunction(Function& F) override {
            bool modified = false;
            std::unordered_map<Value*, AllocaInst*> intToAllocaMap;  // Change map key type to Value*
            IRBuilder<> Builder(F.getContext());

            for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I) {
                // Handling Store Instructions
                if (StoreInst* store = dyn_cast<StoreInst>(&*I)) {
                    if (IntToPtrInst* I2PInst = dyn_cast<IntToPtrInst>(store->getPointerOperand())) {
                        Value* intVal = I2PInst->getOperand(0);  // Change intVal type to Value*
                        if (intToAllocaMap.find(intVal) == intToAllocaMap.end()) {
                            Builder.SetInsertPoint(&*I);
                            AllocaInst* Alloca = Builder.CreateAlloca(Type::getInt64Ty(F.getContext()));
                            intToAllocaMap[intVal] = Alloca;
                        }
                        store->setOperand(1, intToAllocaMap[intVal]);
                        modified = true;
                    }
                }
                // Handling Load Instructions
                else if (LoadInst* load = dyn_cast<LoadInst>(&*I)) {
                    if (IntToPtrInst* I2PInst = dyn_cast<IntToPtrInst>(load->getPointerOperand())) {
                        Value* intVal = I2PInst->getOperand(0);  // Change intVal type to Value*
                        if (intToAllocaMap.find(intVal) != intToAllocaMap.end()) {
                            load->setOperand(0, intToAllocaMap[intVal]);
                            modified = true;
                        }
                    }
                }
            }
            return modified;
        }
    };
}


char IntToPtrToAllocaPass::ID = 0;
static RegisterPass<IntToPtrToAllocaPass> X("inttoptr-to-alloca", "IntToPtr to Alloca Pass");

FunctionPass* createIntToPtrToAllocaPass() {
    return new IntToPtrToAllocaPass();
}





namespace {

    struct IntToPtrStackDSEPass : public FunctionPass {
        static char ID;

        IntToPtrStackDSEPass() : FunctionPass(ID) {
        }

        bool runOnFunction(Function& F) override {
             bool modified = false;
            std::vector<Instruction*> deleteCandidates;

            for (Instruction& I : instructions(F)) {
                if (LoadInst* load = dyn_cast<LoadInst>(&I)) {
                    if (shouldDelete(load->getPointerOperand())) {
                        deleteCandidates.push_back(load);
                    }
                }
                else if (StoreInst* store = dyn_cast<StoreInst>(&I)) {
                    if (shouldDelete(store->getPointerOperand())) {
                        deleteCandidates.push_back(store);
                    }
                }
            }

            for (Instruction* inst : deleteCandidates) {
                inst->eraseFromParent();
                modified = true;
            }

            return modified;
        }

        bool shouldDelete(Value* ptrOperand) {

            if (auto* ce = dyn_cast<ConstantExpr>(ptrOperand)) {
                if (ce->getOpcode() == Instruction::IntToPtr) {
                    if (auto* ci = dyn_cast<ConstantInt>(ce->getOperand(0))) {
                        return -512 < ( STACKP_VALUE - ci->getZExtValue() ) < 4096; // Assuming STACKP_VALUE is defined
                    }
                }
            }
            return false;
        }
    };

}  // End of anonymous namespace

char IntToPtrStackDSEPass::ID = 0;



// basically replace detect binary loads and replace the load with value
//before pass-> 
// %x = load i64, ptr 0x140002000
// after pass ->
// %x = [whatever the value is at 0x140002000, but no load inst]
FunctionPass* CreateIntToPtrStackDSEPass() {
    return new IntToPtrStackDSEPass();
}

```

`lifter/nacibaba_opts.h`:

```h
#pragma once
#include "includes.h"

FunctionPass* create_nacibaba_replace_load_with_store_pass();

FunctionPass* create_nacibaba_replace_load_from_memory(LPVOID binaryBase, ZyanU8* data);


FunctionPass* create_nacibaba_replace_load_with_store_pass_final();

FunctionPass* createIntToPtrToAllocaPass();
FunctionPass* create_RemoveStackPushes();

FunctionPass* CreateIntToPtrStackDSEPass();
```

`lifter/utils.cpp`:

```cpp
#pragma once
#include "includes.h"

PIMAGE_SECTION_HEADER GetEnclosingSectionHeader(DWORD rva, PIMAGE_NT_HEADERS pNTHeader) {
    PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(pNTHeader);
    for (unsigned i = 0; i < pNTHeader->FileHeader.NumberOfSections; i++, section++) {
        if ((rva >= section->VirtualAddress) &&
            (rva < (section->VirtualAddress + section->Misc.VirtualSize))) {
            return section;
        }
    }
    return 0;
}


uintptr_t RvaToFileOffset(PIMAGE_NT_HEADERS ntHeaders, DWORD rva) {
    PIMAGE_SECTION_HEADER sectionHeader = IMAGE_FIRST_SECTION(ntHeaders);
    for (UINT i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++, sectionHeader++) {
        if (rva >= sectionHeader->VirtualAddress && rva < (sectionHeader->VirtualAddress + sectionHeader->Misc.VirtualSize)) {
            return rva - sectionHeader->VirtualAddress + sectionHeader->PointerToRawData;
        }
    }
    return 0;
}


uintptr_t address_to_mapped_address(LPVOID fileBase, uintptr_t rva) {

    PIMAGE_DOS_HEADER dosHeader = static_cast<PIMAGE_DOS_HEADER>(fileBase);
    PIMAGE_NT_HEADERS ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<BYTE*>(fileBase) + dosHeader->e_lfanew);

    auto ADDRESS = rva - ntHeaders->OptionalHeader.ImageBase;
    return RvaToFileOffset(ntHeaders, ADDRESS);
}
```

`lifter/utils.h`:

```h
#pragma once
#include "includes.h"


PIMAGE_SECTION_HEADER GetEnclosingSectionHeader(DWORD rva, PIMAGE_NT_HEADERS pNTHeader);


uintptr_t RvaToFileOffset(PIMAGE_NT_HEADERS ntHeaders, DWORD rva);


uintptr_t address_to_mapped_address(LPVOID fileBase, uintptr_t rva);
```