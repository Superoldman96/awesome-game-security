Project Path: arc_gmh5225_Polymorphic-Engine_7990u642

Source Tree:

```txt
arc_gmh5225_Polymorphic-Engine_7990u642
├── README.md
├── crypt1.png
├── crypt2.png
├── example
│   ├── README.md
│   ├── pmorph_example
│   │   ├── enc_t.cpp
│   │   ├── enc_t.hpp
│   │   ├── pmorph_example.cpp
│   │   ├── pmorph_example.vcxproj
│   │   ├── pmorph_example.vcxproj.filters
│   │   └── pmorph_example.vcxproj.user
│   └── pmorph_example.sln
└── src
    ├── README.md
    ├── enc_t.cpp
    └── enc_t.hpp

```

`README.md`:

```md
# Polymorphic-Engine

NOTE: __-- MSVC SUPPORT IS EXPIRIMENTAL - LLVM / CLANG ARE THOROUGHLY TESTED --__ :

--------------------------------------------------------------------------------------

__-- FEATURES --__

* Runtime stack polymorphism (locals will be manipulated directly on the stack)
* Runtime heap polymorphism (dynamic polymorphic allocations are supported)


_-- SUPPORTED POLYMORPHIC TYPES--__

*char (e_int8)

*unsigned char (e_uint8)

*short (e_int16)

*unsigned short (e_uint16)

*int (e_int32)

*unsigned int (e_uint32)

*long long (e_int64 on 64 bit applications)

*unsigned long long (e_uint64 on 64 bit applications)


*float (e_float)

*double (e_double)


*std::string (e_string)

*std::wstring(e_wstring)


EXTENDED TYPES (MUST enable extended types in C++ -> Code Generation):

* __m128 (e_m128)
* __m128i (e_m128i)
* __m128d (e_m128d)
* __m256 (e_m256)
* __m256i (e_m256i)
* __m256d (e_m256d)

--------------------------------------------------------------------------------------

As you can see reading over the source, i have attempted to implement support for MSVC and others however have a ways to go with this, it was originally only written for LLVM / clang compiler. 

This is a well tested (in LLVM / clang) and while not perfect, is an effective, basic polymorphic type engine for C++ applications which will prevent security applications such as Antiviruses and Anticheats from creating effective runtime signatures of your program, and above all else greatly obstruct reverse-engineers attempting to steal / crack your source.

This will NOT prevent static disk-signatures of your executables - only make them harder to reverse-engineer and signature during runtime

This class is fully inlined, employing minimalist design and maximum performance + reliability.

--------------------------------------------------------------------------------------

__--HOW-TO--__

* Download enc_t.cpp and enc_t.hpp and include both of these in your project  

* Depending on the pathing structure of both your project and the placement of these specific files - you may need to adjust the include pathing in the source file "enc_t.cpp" to adhere to aformentioned pathing.

* in the source file(s) which you wish to include the project, you can simply use the #include directive to import the library and begin using it as such

```cpp
#include "enc_t.hpp"

int main(){
  crypto::init_constants(); // initialize the namespace globals
  
  // use the namespace throughout application now
  return 0;
}
```

--------------------------------------------------------------------------------------

__--EXAMPLES--__

Example project indicating generalized usage of primitive and extended types included in according folder.

--------------------------------------------------------------------------------------

Demonstration of control flow obfuscation:
__-- Basic "Hello, World!" application before polymorphic type --__
![IDA view of hello world C++ program before polymorphic engine](crypt2.png)

--------------------------------------------------------------------------------------

__-- Basic "Hello, World!" application after polymorphic type --__
(the control flow chart gets more and more messy, the more instances of polymorphic types are instantiated) 
![IDA view of hello world C++ program after polymorphic engine](crypt1.png)

--------------------------------------------------------------------------------------

__--NOTES--__

* at the startup of your application, you MUST instantiate the global variables used by the classes by calling the static init_constants() function in the namespace:

```cpp
#include "enc_t.hpp"

int main(){
  crypto::init_constants(); // initialize the namespace
  
  // use the namespace throughout application now
  return 0;
}
```

* Extended types (SSE / AVX) must be enabled in your project settings if you wish to use the derived polymorphic versions of them.

* When using the e_malloc class to allocate dynamic blocks of memory, i suggest using the UNIQUE macro as such, unless you wish to manually call free() subsequently for every get() call:
```cpp
e_malloc e_malloc_instance(insert_allocation_size); // instantiate polymorphic memory block

auto unique_block_pointer = UNIQUE(e_malloc_instance.get()); // get unique_ptr to memory block (macro will apply custom Decommission object for malloc / free)

// use unique_block_pointer - it will prevent memory leaks on it's own when it goes out of scope
```


--------------------------------------------------------------------------------------

__--TO-DO / GOALS--__

* optimize the e_malloc class - it is the one class here that is terrible performance heavy during runtime and currently, unless used with the UNIQUE macro, prone to memory leaks
* strengthen XOR encryption algorithm and further randomize seeding method, to make this harder than it currently is to reverse.


```

`example/pmorph_example.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33712.159
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pmorph_example", "pmorph_example\pmorph_example.vcxproj", "{D880746A-838E-4359-AAA9-6B10851DE774}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D880746A-838E-4359-AAA9-6B10851DE774}.Debug|x64.ActiveCfg = Debug|x64
		{D880746A-838E-4359-AAA9-6B10851DE774}.Debug|x64.Build.0 = Debug|x64
		{D880746A-838E-4359-AAA9-6B10851DE774}.Debug|x86.ActiveCfg = Debug|Win32
		{D880746A-838E-4359-AAA9-6B10851DE774}.Debug|x86.Build.0 = Debug|Win32
		{D880746A-838E-4359-AAA9-6B10851DE774}.Release|x64.ActiveCfg = Release|x64
		{D880746A-838E-4359-AAA9-6B10851DE774}.Release|x64.Build.0 = Release|x64
		{D880746A-838E-4359-AAA9-6B10851DE774}.Release|x86.ActiveCfg = Release|Win32
		{D880746A-838E-4359-AAA9-6B10851DE774}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F8055A78-0896-4C4F-9313-AB512B21CB39}
	EndGlobalSection
EndGlobal

```

`example/pmorph_example/enc_t.cpp`:

```cpp
#include "enc_t.hpp"

namespace crypto {

	bool crypto::is_init = false;

	unsigned long long crypto::seed = 0x0000000000000000ULL;

}
```

`example/pmorph_example/enc_t.hpp`:

```hpp
#ifndef ENC_T_H
#define ENC_T_H

#pragma region Imports

#include <chrono>
#include <string>
#include <vector>
#include <memory>
#include <cstdlib>
#include <exception>

#pragma endregion

#pragma region Preprocessor 

#pragma region SSE / AVX

#ifdef __AVX__
// fix for an msvc bug where __SSE__ preprocessor refuses to list as active when it should be as avx indicates this features presence as well

#ifndef __SSE__

#define __SSE__

#endif

#ifndef __SSE2__

#define __SSE2__

#endif

#endif

#ifdef __SSE__

#ifdef __clang__

#include <emmintrin.h>

#elif defined(_MSC_VER)

#include <xmmintrin.h> 

#endif

#endif

#ifdef __AVX__

#ifdef __clang__

#include <avxintrin.h>

#elif defined(_MSC_VER)

#include <immintrin.h> 

#endif

#endif

#pragma endregion

#pragma endregion


namespace crypto {

#pragma region Constants

#define NULL 0x0

#pragma endregion

#pragma region Type Definitions

    typedef unsigned char uint8_t;
    typedef unsigned short uint16_t;
    typedef unsigned int uint32_t;

#ifdef _WIN64

    typedef unsigned long long uint64_t;

#endif

    typedef char int8_t;
    typedef short int16_t;
    typedef int int32_t;

#ifdef _WIN64

    typedef long long int64_t;

#endif

#ifdef _WIN64

    typedef unsigned long long uintptr_t;
    typedef unsigned long long size_t;

#elif _WIN32

    typedef unsigned int uintptr_t;
    typedef unsigned int size_t;

#endif

#pragma endregion

#pragma region Globals  =|=  Singleton

    extern unsigned long long seed;
    extern bool is_init;

#pragma endregion

#pragma region Macros

#pragma region Memory

#define RtlZeroMemory(block, size) (memset(block, 0x00ui8, size)) \

#define UNIQUE(param_) std::unique_ptr<unsigned char[], crypto::e_malloc::free_delete_t>(reinterpret_cast<unsigned char*>(param_)) \

#pragma endregion

#pragma region Encryption

// workaround for lack of support for bitwise operations on floating-point types by the C++ standard library
// ensure the type of both arguments is the same. you must declare the argument before passing it, or use  a typecast or the apropriate declaration suffix (e.g 255ULL to declare an unsigned long long with a value of 255 so it won't default to int / short)
#ifdef __clang__
#define XOR_FORCE(val, xor_val) \
    ({ \
        auto _return = (val); \
        auto xor_val_c = (xor_val); \
        auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<decltype(_return)*>(&(_return))); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(const_cast<decltype(xor_val_c)*>(&(xor_val_c))); \
        for(auto x = 0; x < sizeof(decltype(_return)); ++x){ \
            val_ptr[x] ^= xor_ptr[x]; \
        } \
        _return;\
    }) 

// macro for raw / pool allocations arg1: pointer to allocation, arg2: length of allocation in bytes, arg3: encryption key as type reference( in our case unsigned long long / uint64_t)
#define XOR_RAW(val, len, xor_val) \
    ({ \
        auto _return = calloc(len, sizeof(unsigned char)); \
        memcpy(_return, val, len); \
        auto val_ptr = reinterpret_cast<unsigned char*>(_return); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(&(xor_val)); \
        for (auto x = 0; x < len; ++x) { \
            for(auto y = 0; y < sizeof(decltype(xor_val)); ++y){ \
                val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[y % sizeof(decltype(xor_val))]; \
            } \
            for(auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z){ \
                val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[z % sizeof(decltype(xor_val))]; \
            } \
        } \
        reinterpret_cast<decltype(val)>(_return); \
    })

// macro for all native non-string datatypes (almost)
#define XOR_T(val, xor_val) \
    ({ \
        auto _return = (val); \
        auto val_ptr = reinterpret_cast<unsigned char*>(&(_return)); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(&(xor_val)); \
        for (auto x = 0; x < sizeof(decltype(_return)); ++x) { \
            for(auto y = 0; y < sizeof(decltype(xor_val)); ++y){ \
                 val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[y % sizeof(decltype(xor_val))]; \
            } \
            for(auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z){ \
                val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[z % sizeof(decltype(xor_val))]; \
            } \
        } \
        _return; \
    })

// macro for ANSI charset string
#define XOR_STR_T(val, xor_val) \
    ({ \
        auto _return = (val); \
        auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<char*>(_return.data())); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(&(xor_val)); \
        for (auto x = 0; x < ((val.length() * sizeof(char)) + sizeof(char)); ++x) { \
            for(auto y = 0; y < sizeof(decltype(xor_val)) ; ++y){ \
                 val_ptr[x % ((val.length() * sizeof(char)) + sizeof(char))] ^= xor_ptr[y % sizeof(decltype(xor_val))]; \
            } \
            for(auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z){ \
                val_ptr[x % ((val.length() * sizeof(char)) + sizeof(char))] ^= xor_ptr[z % sizeof(decltype(xor_val))]; \
            } \
        } \
        _return; \
    })

//macro for unicode charset string
#define XOR_WSTR_T(val, xor_val) \
    ({ \
        auto _return = (val); \
        auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<wchar_t*>(_return.data())); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(&(xor_val)); \
        for (auto x = 0; x < ((val.length() * sizeof(wchar_t)) + sizeof(wchar_t)); ++x) { \
            for(auto y = 0; y < sizeof(decltype(xor_val)) ; ++y){ \
                 val_ptr[x % ((val.length() * sizeof(wchar_t)) + sizeof(wchar_t))] ^= xor_ptr[y % sizeof(decltype(xor_val))]; \
            } \
            for(auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z){ \
                val_ptr[x % ((val.length() * sizeof(wchar_t)) + sizeof(wchar_t))] ^= xor_ptr[z % sizeof(decltype(xor_val))]; \
            } \
        } \
        _return; \
    })

#elif defined (_MSC_VER)

template<typename T>
__forceinline decltype(auto) XOR_FORCE(T val, T xor_val) {
    T _return = val;
    auto val_ptr = reinterpret_cast<unsigned char*>(&_return);
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (auto x = 0; x < sizeof(T); ++x) {
        val_ptr[x] ^= xor_ptr[x];
    }
    return _return;
}


template<typename T>
__forceinline decltype(auto) XOR_RAW(T* val, size_t len, uintptr_t xor_val) {
    auto _return = static_cast<T*>(malloc(len));
    memcpy(_return, val, len);
    auto val_ptr = reinterpret_cast<unsigned char*>(_return);
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (auto x = 0; x < len; ++x) {
        for (auto y = 0; y < sizeof(decltype(xor_val)); ++y) {
            val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[y % sizeof(decltype(xor_val))];
        }
        for (auto z = sizeof(decltype(xor_val)) - 1; z > -1; --z) {
            val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[z % sizeof(decltype(xor_val))];
        }
    }
    return reinterpret_cast<decltype(val)>(_return);
}


template<typename T>
__forceinline T XOR_T(T val, uintptr_t xor_val) {
    auto _return = val;
    auto val_ptr = reinterpret_cast<unsigned char*>(&_return);
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (auto x = 0; x < sizeof(decltype(_return)); ++x) {
        for (auto y = 0; y < sizeof(xor_val); ++y) {
            val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[y % sizeof(decltype(xor_val))];
        }
        for (auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z) {
            val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[z % sizeof(decltype(xor_val))];
        }
    }
    return _return;
}


template<typename T>
__forceinline decltype(auto) XOR_STR_T(T val, uintptr_t xor_val) {
    T _return = val;
    auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<char*>(_return.data()));
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (auto x = 0; x < ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type)); ++x) {
        for (auto y = 0; y < sizeof(decltype(xor_val)); ++y) {
            val_ptr[x % ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type))] ^= xor_ptr[y % sizeof(decltype(xor_val))];
        }
        for (auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z) {
            val_ptr[x % ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type))] ^= xor_ptr[z % sizeof(decltype(xor_val))];
        }
    }
    return _return;
}


template<typename T>
__forceinline decltype(auto) XOR_WSTR_T(T val, uintptr_t xor_val) {
    T _return = val;
    auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<typename T::value_type*>(_return.data()));
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (int x = 0; x < ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type)); ++x) {
        for (int y = 0; y < sizeof(decltype(xor_val)); ++y) {
            val_ptr[x % ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type))] ^= xor_ptr[y % sizeof(decltype(xor_val))];
        }
        for (int z = (sizeof(decltype(xor_val)) - 1); z > -1; --z) {
            val_ptr[x % ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type))] ^= xor_ptr[z % sizeof(decltype(xor_val))];
        }
    }
    return _return;
}


#endif

#pragma endregion

#pragma endregion

#pragma region Static Methods

    // this must be called once at application startup / or when you wish to begin using any type included in this header
    static void __fastcall init_constants() {
        if (!is_init) {
            auto time_n = std::chrono::high_resolution_clock::now();
            seed = static_cast<unsigned long long>(time_n.time_since_epoch().count());

            is_init = true;
        }
    }

#pragma endregion

#pragma region Types

#pragma region WORD

#pragma region 8-bit

    class e_int8 {

    private:

#pragma region Encrypted value

        char _value;

#pragma endregion

    public:

#pragma region CTOR

        __forceinline __fastcall e_int8(char value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline unsigned char __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }

        __forceinline void __fastcall set(char value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_int8 __fastcall operator+(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_int8 __fastcall operator-(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_int8 __fastcall operator/(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_int8 __fastcall operator*(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int8 __fastcall operator&(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_int8 __fastcall operator|(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_int8 __fastcall operator%(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_int8 __fastcall operator^(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int8 __fastcall operator<<(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_int8 __fastcall operator>>(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_int8& __fastcall operator+=(const char value) {
            this->_value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator-=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator*=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator/=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator%=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator^=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator&=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator|=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator<<=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator>>=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator=(const char value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator char() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_uint8 {
    private:

#pragma region Encrypted value
        unsigned char _value;
#pragma endregion

    public:

#pragma region CTOR
        __forceinline  __fastcall e_uint8(unsigned char value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline unsigned char __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(unsigned char value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_uint8 __fastcall operator+(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_uint8 __fastcall operator-(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_uint8 __fastcall operator/(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_uint8 __fastcall operator*(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint8 __fastcall operator&(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_uint8 __fastcall operator|(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_uint8 __fastcall operator%(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_uint8 __fastcall operator^(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint8 __fastcall operator<<(const char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_uint8 __fastcall operator>>(const char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_uint8& __fastcall operator+=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator-=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator*=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator/=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator%=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator^=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator&=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator|=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator<<=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator>>=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator=(const unsigned char value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator unsigned char() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma region 16-bit

    class e_int16 {

    private:

        short _value;

    public:

#pragma region CTOR

        __forceinline __fastcall e_int16(short value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline short __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }

        __forceinline void __fastcall set(short value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_int16 __fastcall operator+(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_int16 __fastcall operator-(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_int16 __fastcall operator/(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_int16 __fastcall operator*(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int16 __fastcall operator&(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_int16 __fastcall operator|(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_int16 __fastcall operator%(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_int16 __fastcall operator^(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int16 __fastcall operator<<(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_int16 __fastcall operator>>(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_int16& __fastcall operator+=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator-=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator*=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator/=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator%=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator^=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator&=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator|=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator=(const short value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator<<=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator>>=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator short() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_uint16 {
    private:
        unsigned short _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_uint16(unsigned short value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline unsigned short __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(unsigned short value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_uint16 __fastcall operator+(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_uint16 __fastcall operator-(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_uint16 __fastcall operator/(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_uint16 __fastcall operator*(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint16 __fastcall operator&(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_uint16 __fastcall operator|(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_uint16 __fastcall operator%(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_uint16 __fastcall operator^(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint16 __fastcall operator<<(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_uint16 __fastcall operator>>(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_uint16& __fastcall operator+=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator-=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator*=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator/=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator%=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator^=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator&=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator|=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator<<=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator>>=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator=(const unsigned short value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline  __fastcall operator unsigned short() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma region 32-bit

    class e_int32 {
    private:
        int _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_int32(int value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline int __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(int value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_int32 __fastcall operator+(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_int32 __fastcall operator-(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_int32 __fastcall operator/(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_int32 __fastcall operator*(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int32 __fastcall operator&(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_int32 __fastcall operator|(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_int32 __fastcall operator%(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_int32 __fastcall operator^(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int32 __fastcall operator<<(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_int32 __fastcall operator>>(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_int32& __fastcall operator+=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator-=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator*=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator/=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator%=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator^=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator&=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator=(const int value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator|=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator<<=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator>>=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator int() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_uint32 {
    private:
        unsigned int _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_uint32(unsigned int value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline unsigned int __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(unsigned int value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_uint32 __fastcall operator+(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_uint32 __fastcall operator-(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_uint32 __fastcall operator/(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_uint32 __fastcall operator*(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint32 __fastcall operator&(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_uint32 __fastcall operator|(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_uint32 __fastcall operator%(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_uint32 __fastcall operator^(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint32 __fastcall operator<<(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_uint32 __fastcall operator>>(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_uint32& __fastcall operator+=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator-=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator*=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator/=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator%=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator^=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator&=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator|=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator=(const unsigned int value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator<<=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator>>=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator int() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma region 64-bit

    class e_int64 {

    private:

        long long _value;

    public:

#pragma region CTOR

        __forceinline __fastcall e_int64(long long value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline long long __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }

        __forceinline void __fastcall set(long long value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_int64 __fastcall operator+(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_int64 __fastcall operator-(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_int64 __fastcall operator/(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_int64 __fastcall operator*(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int64 __fastcall operator&(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_int64 __fastcall operator|(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_int64 __fastcall operator%(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_int64 __fastcall operator^(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int64 __fastcall operator<<(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_int64 __fastcall operator>>(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_int64& __fastcall operator+=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator-=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator*=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator/=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator%=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator^=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator&=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator|=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator=(const long long value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator<<=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator>>=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator long long() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_uint64 {
    private:
        unsigned long long _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_uint64(unsigned long long value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline unsigned long long __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(unsigned long long value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_uint64 __fastcall operator+(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_uint64 __fastcall operator-(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_uint64 __fastcall operator/(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_uint64 __fastcall operator*(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint64 __fastcall operator&(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_uint64 __fastcall operator|(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_uint64 __fastcall operator%(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_uint64 __fastcall operator^(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint64 __fastcall operator<<(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_uint64 __fastcall operator>>(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_uint64& __fastcall operator+=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator-=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator*=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator/=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator%=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator^=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator&=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator|=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator<<=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator>>=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator=(const unsigned long long value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline  __fastcall operator unsigned long long() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma endregion

#pragma region Floating Point

#pragma region 32-bit

    class e_float {
    private:
        float _value;
    public:

#pragma region CTOR

        __forceinline __fastcall e_float(float value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline float __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }

        __forceinline void __fastcall set(float value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_float __fastcall operator+(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_float __fastcall operator-(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_float __fastcall operator/(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_float __fastcall operator*(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_float __fastcall operator^(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_float& __fastcall operator+=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator-=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator*=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator/=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator^=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed), crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator=(const float value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline  __fastcall operator float() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma region 64-bit

    class e_double {
    private:
        double _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_double(double value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline double __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(double value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_double __fastcall operator+(const double value) const {
            return e_double(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_double __fastcall operator-(const double value) const {
            return e_double(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_double __fastcall operator/(const double value) const {
            return e_double(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_double __fastcall operator*(const double value) const {
            return e_double(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_double __fastcall operator^(const double value) const {
            return e_double(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

        __forceinline e_double& __fastcall operator+=(const double value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator-=(const double value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator*=(const double value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator/=(const double value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator^=(const double value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator=(const double value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator double() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma endregion

#pragma region SSE Types

    //SSE
#ifdef __SSE__

    class e_m128 {
    private:
        __m128 _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m128(__m128 value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m128 __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m128 value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators
#ifdef __clang__ // msvc does not support math operators on vector types

        __forceinline e_m128 __fastcall operator+(const __m128 value) const {
            return e_m128(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m128 __fastcall operator-(const __m128 value) const {
            return e_m128(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m128 __fastcall operator/(const __m128 value) const {
            return e_m128((const __m128)XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m128 __fastcall operator*(const __m128 value) const {
            return e_m128(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m128 __fastcall operator^(const __m128 value) const {
            return e_m128(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m128& __fastcall operator+=(const __m128 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m128& __fastcall operator-=(const __m128 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m128& __fastcall operator*=(const __m128 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m128& __fastcall operator/=(const __m128 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m128& __fastcall operator^=(const __m128 value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m128& __fastcall operator=(const __m128 value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m128() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#ifdef __SSE2__

    class e_m128i {
    private:
        __m128i _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m128i(__m128i value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m128i __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m128i value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__

        __forceinline e_m128i __fastcall operator+(const __m128i value) const {
            return e_m128i(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m128i __fastcall operator-(const __m128i value) const {
            return e_m128i(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m128i __fastcall operator/(const __m128i value) const {
            return e_m128i(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m128i __fastcall operator*(const __m128i value) const {
            return e_m128i(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m128i __fastcall operator^(const __m128i value) const {
            return e_m128i(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m128i& __fastcall operator+=(const __m128i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m128i& __fastcall operator-=(const __m128i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m128i& __fastcall operator*=(const __m128i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m128i& __fastcall operator/=(const __m128i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m128i& __fastcall operator^=(const __m128i value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m128i& __fastcall operator=(const __m128i value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m128i() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_m128d {
    private:
        __m128d _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m128d(__m128d value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m128d __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m128d value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__

        __forceinline e_m128d __fastcall operator+(const __m128d value) const {
            return e_m128d(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m128d __fastcall operator-(const __m128d value) const {
            return e_m128d(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m128d __fastcall operator/(const __m128d value) const {
            return e_m128d(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m128d __fastcall operator*(const __m128d value) const {
            return e_m128d(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m128d __fastcall operator^(const __m128d value) const {
            return e_m128d(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m128d& __fastcall operator+=(const __m128d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m128d& __fastcall operator-=(const __m128d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m128d& __fastcall operator*=(const __m128d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m128d& __fastcall operator/=(const __m128d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m128d& __fastcall operator^=(const __m128d value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m128d& __fastcall operator=(const __m128d value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m128d() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#endif

#endif

#pragma endregion

#pragma region AVX Types

#ifdef __AVX__

    class e_m256 {
    private:
        __m256 _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m256(__m256 value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m256 __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m256 value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__
        __forceinline e_m256 __fastcall operator+(const __m256 value) const {
            return e_m256(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m256 __fastcall operator-(const __m256 value) const {
            return e_m256(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m256 __fastcall operator/(const __m256 value) const {
            return e_m256(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m256 __fastcall operator*(const __m256 value) const {
            return e_m256(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m256 __fastcall operator^(const __m256 value) const {
            return e_m256(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m256& __fastcall operator+=(const __m256 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m256& __fastcall operator-=(const __m256 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m256& __fastcall operator*=(const __m256 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m256& __fastcall operator/=(const __m256 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m256& __fastcall operator^=(const __m256 value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m256& __fastcall operator=(const __m256 value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m256() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_m256i {
    private:
        __m256i _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m256i(__m256i value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m256i __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m256i value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__

        __forceinline e_m256i __fastcall operator+(const __m256i value) const {
            return e_m256i(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m256i __fastcall operator-(const __m256i value) const {
            return e_m256i(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m256i __fastcall operator/(const __m256i value) const {
            return e_m256i(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m256i __fastcall operator*(const __m256i value) const {
            return e_m256i(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m256i __fastcall operator^(const __m256i value) const {
            return e_m256i(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

        

#ifdef __clang__

        __forceinline e_m256i& __fastcall operator+=(const __m256i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m256i& __fastcall operator-=(const __m256i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m256i& __fastcall operator*=(const __m256i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m256i& __fastcall operator/=(const __m256i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m256i& __fastcall operator^=(const __m256i value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m256i& __fastcall operator=(const __m256i value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m256i() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_m256d {
    private:
        __m256d _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m256d(__m256d value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m256d __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m256d value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__

        __forceinline e_m256d __fastcall operator+(const __m256d value) const {
            return e_m256d(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m256d __fastcall operator-(const __m256d value) const {
            return e_m256d(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m256d __fastcall operator/(const __m256d value) const {
            return e_m256d(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m256d __fastcall operator*(const __m256d value) const {
            return e_m256d(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m256d __fastcall operator^(const __m256d value) const {
            return e_m256d(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m256d& __fastcall operator+=(const __m256d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m256d& __fastcall operator-=(const __m256d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m256d& __fastcall operator*=(const __m256d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m256d& __fastcall operator/=(const __m256d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m256d& __fastcall operator^=(const __m256d value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m256d& __fastcall operator=(const __m256d value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline  __fastcall operator __m256d() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#endif

#pragma endregion

#pragma endregion

#pragma region String

    class e_string {

    private:

#pragma region Encrypted value

        std::string _value = "";

#pragma endregion

    public:

#pragma region CTOR

        __forceinline __fastcall e_string(const std::string& value) {
            _value = XOR_STR_T(value, crypto::seed);
        }

        __forceinline __fastcall e_string(const char* value) {
            _value = XOR_STR_T(std::string(value), crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline std::string __fastcall get() const {
            return XOR_STR_T(std::string(_value), crypto::seed);
        }

        __forceinline void __fastcall set(const std::string& value) {
            _value = XOR_STR_T(value, crypto::seed);
        }
        
        __forceinline e_string __fastcall operator+(const std::string& value) const {
            return e_string(XOR_STR_T(std::string(_value), crypto::seed) + value);
        };

        __forceinline e_string& __fastcall operator+=(const std::string& value) {
            _value = XOR_STR_T(static_cast<std::string>(XOR_STR_T(_value, crypto::seed) + value)
                , crypto::seed);
            return *this;
        }

        __forceinline e_string& __fastcall operator=(const std::string& value) {
            set(value);
            return *this;
        }
        
        __forceinline __fastcall operator std::string() const {
            return XOR_STR_T(_value, crypto::seed);
        }

        __forceinline __fastcall ~e_string() {
            //attempt to trigger memory release
            try {
                std::string().swap(_value);
            }
            catch (std::exception& except) {}
        }
        
#pragma endregion

#pragma region Operators

#pragma endregion
    };

    class e_wstring {
    private:

#pragma region Encrypted value

        std::wstring _value = L"";

#pragma endregion

    public:

#pragma region CTOR

        __forceinline __fastcall e_wstring(const std::wstring& value) {
            _value = XOR_WSTR_T(value, crypto::seed);
        }

        __forceinline __fastcall e_wstring(const wchar_t* value) {
            _value = XOR_WSTR_T(std::wstring(value), crypto::seed);
        }

        __forceinline __fastcall e_wstring() {
            _value = L"";
        }

#pragma endregion

#pragma region Accessors

        __forceinline std::wstring __fastcall get() const {
            return XOR_WSTR_T(std::wstring(_value), crypto::seed);
        }

        __forceinline void __fastcall set(const std::wstring& value) {
            _value = XOR_WSTR_T(value, crypto::seed);
        }

        __forceinline void __fastcall reserve(unsigned long count) {
            _value.reserve(count);
        }

        __forceinline bool __fastcall empty() const{
            return _value.empty();
        }

        __forceinline e_wstring __fastcall operator+(const std::wstring& value) const {
            return e_wstring(XOR_WSTR_T(std::wstring(_value), crypto::seed) + value);
        };

        __forceinline e_wstring& __fastcall operator+=(const std::wstring& value) {
            _value = XOR_WSTR_T(static_cast<std::wstring>(XOR_WSTR_T(_value, crypto::seed) + value)
                , crypto::seed);
            return *this;
        }

        __forceinline e_wstring& __fastcall operator=(const std::wstring& value) {
            set(value);
            return *this;
        }

        __forceinline wchar_t& __fastcall operator[](const int index) {
            return XOR_WSTR_T(_value, crypto::seed)[index];
        }

        __forceinline __fastcall operator std::wstring() const {
            return XOR_WSTR_T(_value, crypto::seed);
        }

        __forceinline __fastcall ~e_wstring() {
            //attempt to trigger memory release
            try {
                std::wstring().swap(_value);
            }
            catch (std::exception& except) {}
        }

#pragma endregion

#pragma region Operators

#pragma endregion
    };

#pragma endregion

#pragma region Heap Allocation

    class e_malloc {

    private:

#pragma region Global Variables

        void* local_alloc;
        size_t alloc_size;
        // use this object to track all get() and similar calls throughout object lifespan, these will be explicitly freed in the destructor so the user won't have to explicitly free every time get() is called
        std::vector<void*> pointer_calls{};

#pragma endregion

    public:

#pragma region Proxy objects

#pragma region Decommission proxy

        struct free_delete_t
        {
            void operator()(void* pointer) const
            {
                free(pointer);
            }
        };

#pragma endregion

#pragma region Subscript proxy

        // nested class to support subscript assignment 
        class index_proxy {

        private:

#pragma region Globals

            e_malloc& parent;
            size_t index;

#pragma endregion

        public:
#pragma region Ctor

            index_proxy(size_t index_, e_malloc& instance) : index(index_), parent(instance) { }

#pragma endregion

#pragma region Operator overrides

            uint8_t& operator=(uint8_t value) {
                parent.set(index, value);
                return value;   // return the passed assignment value rather than using up absurd resources to decrypt, re-encrypt everything using get()
            }

            __forceinline __fastcall operator uint8_t() const {
                return parent.get(index);
            }

#pragma endregion

        };

#pragma endregion

#pragma endregion

#pragma region Ctor

        __forceinline __fastcall e_malloc(size_t size) {
            alloc_size = size;
            local_alloc = malloc(size);

            auto enc_alloc = XOR_RAW(local_alloc, size, crypto::seed);

            memcpy(local_alloc, enc_alloc, size);
            free(enc_alloc);
        }

        __forceinline __fastcall e_malloc() {

        }

#pragma endregion

#pragma region Get accessors

        __forceinline void* __fastcall get() {
            return XOR_RAW(local_alloc, alloc_size, crypto::seed);
        }

        __forceinline void* get(uintptr_t pos, size_t length) {
            auto dec_alloc = reinterpret_cast<uint8_t*>(get());

            auto get_alloc = calloc(length, sizeof(uint8_t));

            memcpy(get_alloc, &dec_alloc[pos], length);
            RtlZeroMemory(dec_alloc, alloc_size);
            free(dec_alloc);

            return get_alloc;
        }

        //overload get() for index operations to avoid unnecessary heap allocations and potential memory leaks
        __forceinline uint8_t __fastcall get(size_t index) {
            auto dec_alloc = reinterpret_cast<uint8_t*>(get());

            auto _return = dec_alloc[index];

            RtlZeroMemory(dec_alloc, alloc_size);
            free(dec_alloc);

            return _return;
        }

        template<typename T>
        __forceinline T __fastcall get_t(uintptr_t pos, T& value) {
            auto value_r = reinterpret_cast<T*>(get(pos, sizeof(T)));
            auto _return = *value_r;
            free(value_r);
            return _return;
        }

        __forceinline void* __fastcall get_data_pointer() {
            return local_alloc;
        }

        __forceinline size_t __fastcall get_data_size() {
            return alloc_size;
        }

#pragma endregion

#pragma region Set accessors

        //WARNING: appending length to the allocation here will cause exceptions / UB
        __forceinline void __fastcall set(void* src, uintptr_t pos, size_t length, bool free_src = false) {
            auto dec_alloc = get();

            memcpy(&reinterpret_cast<unsigned char*>(dec_alloc)[pos], src, length);

            auto enc_alloc = XOR_RAW(dec_alloc, length, crypto::seed);
            //free the decryption allocation and local alocation: reminder this class is performance-heavy and should not be used for large allocation pools
            //for security reasons
            RtlZeroMemory(dec_alloc, alloc_size);
            RtlZeroMemory(local_alloc, alloc_size);
            free(dec_alloc);
            dec_alloc = nullptr;
            free(local_alloc);
            local_alloc = nullptr;

            local_alloc = enc_alloc;

            if (free_src)
                free(src);
        }

        __forceinline void __fastcall set(uintptr_t pos, unsigned char value, size_t size) {
            auto dec_alloc = reinterpret_cast<uint8_t*>(get());

            for (auto i = pos; i < (pos + size); ++i) {
                dec_alloc[i] = value;
            }

            auto enc_alloc = XOR_RAW(dec_alloc, alloc_size, crypto::seed);
            //free the decryption allocation and local alocation: reminder this class is performance-heavy and should not be used for large allocation pools
            //for security reasons
            RtlZeroMemory(dec_alloc, alloc_size);
            RtlZeroMemory(local_alloc, alloc_size);
            free(dec_alloc);
            dec_alloc = nullptr;
            free(local_alloc);
            local_alloc = nullptr;

            local_alloc = enc_alloc;
        }

        template<typename T>
        __forceinline void __fastcall set(uintptr_t pos, T value) {
            auto dec_alloc = reinterpret_cast<uint8_t*>(get()); // so we can properly index the allocation 

            T* cast_t = reinterpret_cast<T*>(&dec_alloc[pos]);
            *cast_t = value;

            auto enc_alloc = XOR_RAW(dec_alloc, alloc_size, crypto::seed);
            //free the decryption allocation and local alocation: reminder this class is performance-heavy and should not be used for large allocation pools
            //for security reasons
            RtlZeroMemory(dec_alloc, alloc_size);
            RtlZeroMemory(local_alloc, alloc_size);
            free(local_alloc);
            local_alloc = nullptr;
            free(dec_alloc);
            dec_alloc = nullptr;
            cast_t = nullptr;

            local_alloc = enc_alloc;
        }

#pragma endregion

#pragma region Utility functions

        __forceinline void __fastcall swap(void* src, size_t length, bool free_src = false) {
            //release current resources 
            zero();
            free(local_alloc);
            local_alloc = nullptr;
            alloc_size = 0x0000000000000000ULL;

            auto enc_alloc = XOR_RAW(src, length, crypto::seed);

            alloc_size = length;
            local_alloc = enc_alloc;
        }

        //size is only the length in bytes of the allocation to be appended or destroyed
        __forceinline void __fastcall resize(size_t size) {
            auto dec_alloc = get();

            auto n_local_alloc = realloc(dec_alloc, size);

            if (!n_local_alloc) {
                free(dec_alloc);
                throw std::bad_alloc();
            }

            dec_alloc = NULL; // zero  old pointer ;; useless even if realloc didnt need to move memory
            //zero out the extended memory (if it was being extended rather than shrunk)
            if ((size) > alloc_size)
                RtlZeroMemory(&(reinterpret_cast<uint8_t*>(n_local_alloc)[alloc_size]), (size - alloc_size));

            auto enc_alloc = XOR_RAW(n_local_alloc, size, crypto::seed);
            //free the decryption allocation and local alocation: reminder this class is performance-heavy and should not be used for large allocation pools
            //for security reasons
            RtlZeroMemory(n_local_alloc, alloc_size);
            RtlZeroMemory(local_alloc, alloc_size);
            //realloc() should automatically free dec_alloc if it was moved to new memory
            free(local_alloc);
            local_alloc = nullptr;
            free(n_local_alloc);
            n_local_alloc = nullptr;

            alloc_size = size;
            local_alloc = enc_alloc;
        }

        __forceinline void __fastcall zero() {
            set(0x0000000000000000ULL, 0x00ui8, alloc_size);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_malloc& __fastcall operator=(const std::vector<uint8_t>& value) {
            swap(const_cast<std::vector<uint8_t>*>(&value)->data(), value.size());

            return *this;
        }

        __forceinline __fastcall operator void* () const {
            return XOR_RAW(local_alloc, alloc_size, crypto::seed);
        }

        template<typename T>
        __forceinline __fastcall operator T* () const {
            return reinterpret_cast<T*>(XOR_RAW(local_alloc, alloc_size, crypto::seed));
        }

        index_proxy operator[](size_t index) {
            return index_proxy(index, *this);
        }



#pragma endregion

#pragma region Destructor

        __forceinline void __fastcall destroy(bool zero) {
            if (local_alloc) {
                try {
                    if (zero)
                        RtlZeroMemory(local_alloc, alloc_size);
                    free(local_alloc);
                    local_alloc = nullptr;
                }
                catch (std::exception& except) {}
            }
        }

        __forceinline void __fastcall secure_destroy() {
            destroy(true);
        }
        __forceinline __fastcall ~e_malloc() {
            secure_destroy();
        }

#pragma endregion

    };

#pragma endregion

};

#endif
```

`example/pmorph_example/pmorph_example.cpp`:

```cpp
// pmorph_example.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <cstdlib>
#include "enc_t.hpp"

using namespace crypto;
using namespace std;

int main()
{
    //call our initializer: we need this for the polymorphic seed we will use to encrypt data. this changes at each runtime based on environment variables
    crypto::init_constants();
#pragma region Integral Types

    
    
    e_uint8 test_byte(0xFF);// instantiate encrypted byte with max value

    test_byte = 0xFF; // test assignment operator towards our object by reassigning max byte value

    uint8_t value = test_byte; // operator = etc.. overload will automatially call e_uint8_t.get(), so value will be 0xFF

    cout << "e_uint8_t 0xFF value: " << endl << std::to_string(value) << endl << endl;

    crypto::init_constants();

    e_uint32 test_int(0xFFFFFFFF);// instantiate encrypted byte with max uint value

    test_int = 0xFFFFFFFF; // test assignment operator towards our object by reassigning max uint value

    uint32_t value_int = test_int; // operator = etc.. overload will automatially call e_uint32_t.get(), so value will be 0xFF

    cout << "e_uint32_t 0xFFFFFFFF value: " << endl << std::to_string(value_int) << endl << endl; // should output 4,294,967,295

    // all operators of any kind can be used on the instantiated polymorphic objects as you would with a usual base type integeral T
#pragma endregion

#pragma region Floating Point

    e_double test_double(0.00125); // assign the object a value of 0.00125f

    test_double = 0.00125; // reassign same value to verify functionality

    test_double ^= 1; // perform xor-assignment operation twice to return original value and to test the addition of xor compatibility to some floating point types
    test_double ^= 1;

    double value_double = 0.00125; // retrieve the assigned value

    cout << "e_double 0.00125 value: " << endl << std::to_string(value_double) << endl << endl;


#pragma endregion

#pragma region String Types
    
    e_string test_string("i am polymorphic!");

    test_string += " - and modified!";

    cout << "e_string i am polymorphic! value + test_string: " << endl << test_string.get() << endl << endl;

#pragma endregion

#pragma region Extended vector types

    e_m128 test_vec4(_mm_set_ps(1.f, 2.f, 3.f, 4.f));
    
    cout << "vector4 (__m128) (4, 3, 2, 1) values: " << endl << endl;
    float values[4];
    _mm_store_ps(values, test_vec4);
    for (auto i = 0; i < 4; ++i)
        cout << values[i] << endl << endl;

#pragma endregion

#pragma region Heap allocations

    e_malloc test_heap(5); // declare new heap allocation of size 5 bytes

    test_heap[0] = 0xFF; // use subscript operator to assign each byte a unique value
    test_heap[1] = 0xFE;
    test_heap[2] = 0xFD;
    test_heap[3] = 0xFC;
    test_heap[4] = 0xFB;

    auto data = UNIQUE(test_heap.get()); // use UNIQUE macro to get a unique_ptr object that will dispose when it goes out of scope 
    // if you want you can simply retrieve a pointer to the data 
    // - however you must call free() explicitly when done using it, as it will be a COPY of the actual data stored int the class 

    cout << "e_malloc(5){255, 254, 253, 252, 251} values: " << endl << endl;
    for (auto i = 0; i < 5; ++i)
        cout << std::to_string(data[i]) << endl << endl;

#pragma endregion

    getchar();
}
```

`example/pmorph_example/pmorph_example.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d880746a-838e-4359-aaa9-6b10851de774}</ProjectGuid>
    <RootNamespace>pmorphexample</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <LanguageStandard>stdcpp14</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>
      </EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="enc_t.cpp" />
    <ClCompile Include="pmorph_example.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="enc_t.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`example/pmorph_example/pmorph_example.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pmorph_example.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="enc_t.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="enc_t.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`example/pmorph_example/pmorph_example.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`src/enc_t.cpp`:

```cpp
#include "enc_t.hpp"

namespace crypto {

	bool crypto::is_init = false;

	unsigned long long crypto::seed = 0x0000000000000000ULL;

}
```

`src/enc_t.hpp`:

```hpp
#ifndef ENC_T_H
#define ENC_T_H

#pragma region Imports

#include <chrono>
#include <string>
#include <vector>
#include <memory>
#include <cstdlib>
#include <exception>

#pragma endregion

#pragma region Preprocessor 

#pragma region SSE / AVX

#ifdef __AVX__
// fix for an msvc bug where __SSE__ preprocessor refuses to list as active when it should be as avx indicates this features presence as well

#ifndef __SSE__

#define __SSE__

#endif

#ifndef __SSE2__

#define __SSE2__

#endif

#endif

#ifdef __SSE__

#ifdef __clang__

#include <emmintrin.h>

#elif defined(_MSC_VER)

#include <xmmintrin.h> 

#endif

#endif

#ifdef __AVX__

#ifdef __clang__

#include <avxintrin.h>

#elif defined(_MSC_VER)

#include <immintrin.h> 

#endif

#endif

#pragma endregion

#pragma endregion


namespace crypto {

#pragma region Constants

#define NULL 0x0

#pragma endregion

#pragma region Type Definitions

    typedef unsigned char uint8_t;
    typedef unsigned short uint16_t;
    typedef unsigned int uint32_t;

#ifdef _WIN64

    typedef unsigned long long uint64_t;

#endif

    typedef char int8_t;
    typedef short int16_t;
    typedef int int32_t;

#ifdef _WIN64

    typedef long long int64_t;

#endif

#ifdef _WIN64

    typedef unsigned long long uintptr_t;
    typedef unsigned long long size_t;

#elif _WIN32

    typedef unsigned int uintptr_t;
    typedef unsigned int size_t;

#endif

#pragma endregion

#pragma region Globals  =|=  Singleton

    extern unsigned long long seed;
    extern bool is_init;

#pragma endregion

#pragma region Macros

#pragma region Memory

#define RtlZeroMemory(block, size) (memset(block, 0x00ui8, size)) \

#define UNIQUE(param_) std::unique_ptr<unsigned char[], crypto::e_malloc::free_delete_t>(reinterpret_cast<unsigned char*>(param_)) \

#pragma endregion

#pragma region Encryption

// workaround for lack of support for bitwise operations on floating-point types by the C++ standard library
// ensure the type of both arguments is the same. you must declare the argument before passing it, or use  a typecast or the apropriate declaration suffix (e.g 255ULL to declare an unsigned long long with a value of 255 so it won't default to int / short)
#ifdef __clang__
#define XOR_FORCE(val, xor_val) \
    ({ \
        auto _return = (val); \
        auto xor_val_c = (xor_val); \
        auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<decltype(_return)*>(&(_return))); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(const_cast<decltype(xor_val_c)*>(&(xor_val_c))); \
        for(auto x = 0; x < sizeof(decltype(_return)); ++x){ \
            val_ptr[x] ^= xor_ptr[x]; \
        } \
        _return;\
    }) 

// macro for raw / pool allocations arg1: pointer to allocation, arg2: length of allocation in bytes, arg3: encryption key as type reference( in our case unsigned long long / uint64_t)
#define XOR_RAW(val, len, xor_val) \
    ({ \
        auto _return = calloc(len, sizeof(unsigned char)); \
        memcpy(_return, val, len); \
        auto val_ptr = reinterpret_cast<unsigned char*>(_return); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(&(xor_val)); \
        for (auto x = 0; x < len; ++x) { \
            for(auto y = 0; y < sizeof(decltype(xor_val)); ++y){ \
                val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[y % sizeof(decltype(xor_val))]; \
            } \
            for(auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z){ \
                val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[z % sizeof(decltype(xor_val))]; \
            } \
        } \
        reinterpret_cast<decltype(val)>(_return); \
    })

// macro for all native non-string datatypes (almost)
#define XOR_T(val, xor_val) \
    ({ \
        auto _return = (val); \
        auto val_ptr = reinterpret_cast<unsigned char*>(&(_return)); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(&(xor_val)); \
        for (auto x = 0; x < sizeof(decltype(_return)); ++x) { \
            for(auto y = 0; y < sizeof(decltype(xor_val)); ++y){ \
                 val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[y % sizeof(decltype(xor_val))]; \
            } \
            for(auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z){ \
                val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[z % sizeof(decltype(xor_val))]; \
            } \
        } \
        _return; \
    })

// macro for ANSI charset string
#define XOR_STR_T(val, xor_val) \
    ({ \
        auto _return = (val); \
        auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<char*>(_return.data())); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(&(xor_val)); \
        for (auto x = 0; x < ((val.length() * sizeof(char)) + sizeof(char)); ++x) { \
            for(auto y = 0; y < sizeof(decltype(xor_val)) ; ++y){ \
                 val_ptr[x % ((val.length() * sizeof(char)) + sizeof(char))] ^= xor_ptr[y % sizeof(decltype(xor_val))]; \
            } \
            for(auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z){ \
                val_ptr[x % ((val.length() * sizeof(char)) + sizeof(char))] ^= xor_ptr[z % sizeof(decltype(xor_val))]; \
            } \
        } \
        _return; \
    })

//macro for unicode charset string
#define XOR_WSTR_T(val, xor_val) \
    ({ \
        auto _return = (val); \
        auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<wchar_t*>(_return.data())); \
        auto xor_ptr = reinterpret_cast<unsigned char*>(&(xor_val)); \
        for (auto x = 0; x < ((val.length() * sizeof(wchar_t)) + sizeof(wchar_t)); ++x) { \
            for(auto y = 0; y < sizeof(decltype(xor_val)) ; ++y){ \
                 val_ptr[x % ((val.length() * sizeof(wchar_t)) + sizeof(wchar_t))] ^= xor_ptr[y % sizeof(decltype(xor_val))]; \
            } \
            for(auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z){ \
                val_ptr[x % ((val.length() * sizeof(wchar_t)) + sizeof(wchar_t))] ^= xor_ptr[z % sizeof(decltype(xor_val))]; \
            } \
        } \
        _return; \
    })

#elif defined (_MSC_VER)

template<typename T>
__forceinline decltype(auto) XOR_FORCE(T val, T xor_val) {
    T _return = val;
    auto val_ptr = reinterpret_cast<unsigned char*>(&_return);
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (auto x = 0; x < sizeof(T); ++x) {
        val_ptr[x] ^= xor_ptr[x];
    }
    return _return;
}


template<typename T>
__forceinline decltype(auto) XOR_RAW(T* val, size_t len, uintptr_t xor_val) {
    auto _return = static_cast<T*>(malloc(len));
    memcpy(_return, val, len);
    auto val_ptr = reinterpret_cast<unsigned char*>(_return);
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (auto x = 0; x < len; ++x) {
        for (auto y = 0; y < sizeof(decltype(xor_val)); ++y) {
            val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[y % sizeof(decltype(xor_val))];
        }
        for (auto z = sizeof(decltype(xor_val)) - 1; z > -1; --z) {
            val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[z % sizeof(decltype(xor_val))];
        }
    }
    return reinterpret_cast<decltype(val)>(_return);
}


template<typename T>
__forceinline T XOR_T(T val, uintptr_t xor_val) {
    auto _return = val;
    auto val_ptr = reinterpret_cast<unsigned char*>(&_return);
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (auto x = 0; x < sizeof(decltype(_return)); ++x) {
        for (auto y = 0; y < sizeof(xor_val); ++y) {
            val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[y % sizeof(decltype(xor_val))];
        }
        for (auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z) {
            val_ptr[x % sizeof(decltype(val))] ^= xor_ptr[z % sizeof(decltype(xor_val))];
        }
    }
    return _return;
}


template<typename T>
__forceinline decltype(auto) XOR_STR_T(T val, uintptr_t xor_val) {
    T _return = val;
    auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<char*>(_return.data()));
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (auto x = 0; x < ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type)); ++x) {
        for (auto y = 0; y < sizeof(decltype(xor_val)); ++y) {
            val_ptr[x % ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type))] ^= xor_ptr[y % sizeof(decltype(xor_val))];
        }
        for (auto z = (sizeof(decltype(xor_val)) - 1); z > -1; --z) {
            val_ptr[x % ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type))] ^= xor_ptr[z % sizeof(decltype(xor_val))];
        }
    }
    return _return;
}


template<typename T>
__forceinline decltype(auto) XOR_WSTR_T(T val, uintptr_t xor_val) {
    T _return = val;
    auto val_ptr = reinterpret_cast<unsigned char*>(const_cast<typename T::value_type*>(_return.data()));
    auto xor_ptr = reinterpret_cast<unsigned char*>(&xor_val);
    for (int x = 0; x < ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type)); ++x) {
        for (int y = 0; y < sizeof(decltype(xor_val)); ++y) {
            val_ptr[x % ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type))] ^= xor_ptr[y % sizeof(decltype(xor_val))];
        }
        for (int z = (sizeof(decltype(xor_val)) - 1); z > -1; --z) {
            val_ptr[x % ((val.length() * sizeof(typename T::value_type)) + sizeof(typename T::value_type))] ^= xor_ptr[z % sizeof(decltype(xor_val))];
        }
    }
    return _return;
}


#endif

#pragma endregion

#pragma endregion

#pragma region Static Methods

    // this must be called once at application startup / or when you wish to begin using any type included in this header
    static void __fastcall init_constants() {
        if (!is_init) {
            auto time_n = std::chrono::high_resolution_clock::now();
            seed = static_cast<unsigned long long>(time_n.time_since_epoch().count());

            is_init = true;
        }
    }

#pragma endregion

#pragma region Types

#pragma region WORD

#pragma region 8-bit

    class e_int8 {

    private:

#pragma region Encrypted value

        char _value;

#pragma endregion

    public:

#pragma region CTOR

        __forceinline __fastcall e_int8(char value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline unsigned char __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }

        __forceinline void __fastcall set(char value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_int8 __fastcall operator+(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_int8 __fastcall operator-(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_int8 __fastcall operator/(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_int8 __fastcall operator*(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int8 __fastcall operator&(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_int8 __fastcall operator|(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_int8 __fastcall operator%(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_int8 __fastcall operator^(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int8 __fastcall operator<<(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_int8 __fastcall operator>>(const char value) const {
            return e_int8(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_int8& __fastcall operator+=(const char value) {
            this->_value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator-=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator*=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator/=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator%=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator^=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator&=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator|=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator<<=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator>>=(const char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline e_int8& __fastcall operator=(const char value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator char() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_uint8 {
    private:

#pragma region Encrypted value
        unsigned char _value;
#pragma endregion

    public:

#pragma region CTOR
        __forceinline  __fastcall e_uint8(unsigned char value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline unsigned char __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(unsigned char value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_uint8 __fastcall operator+(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_uint8 __fastcall operator-(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_uint8 __fastcall operator/(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_uint8 __fastcall operator*(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint8 __fastcall operator&(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_uint8 __fastcall operator|(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_uint8 __fastcall operator%(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_uint8 __fastcall operator^(const unsigned char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint8 __fastcall operator<<(const char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_uint8 __fastcall operator>>(const char value) const {
            return e_uint8(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_uint8& __fastcall operator+=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator-=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator*=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator/=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator%=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator^=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator&=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator|=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator<<=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator>>=(const unsigned char value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline e_uint8& __fastcall operator=(const unsigned char value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator unsigned char() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma region 16-bit

    class e_int16 {

    private:

        short _value;

    public:

#pragma region CTOR

        __forceinline __fastcall e_int16(short value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline short __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }

        __forceinline void __fastcall set(short value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_int16 __fastcall operator+(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_int16 __fastcall operator-(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_int16 __fastcall operator/(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_int16 __fastcall operator*(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int16 __fastcall operator&(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_int16 __fastcall operator|(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_int16 __fastcall operator%(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_int16 __fastcall operator^(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int16 __fastcall operator<<(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_int16 __fastcall operator>>(const short value) const {
            return e_int16(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_int16& __fastcall operator+=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator-=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator*=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator/=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator%=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator^=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator&=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator|=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator=(const short value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator<<=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_int16& __fastcall operator>>=(const short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator short() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_uint16 {
    private:
        unsigned short _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_uint16(unsigned short value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline unsigned short __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(unsigned short value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_uint16 __fastcall operator+(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_uint16 __fastcall operator-(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_uint16 __fastcall operator/(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_uint16 __fastcall operator*(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint16 __fastcall operator&(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_uint16 __fastcall operator|(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_uint16 __fastcall operator%(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_uint16 __fastcall operator^(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint16 __fastcall operator<<(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_uint16 __fastcall operator>>(const unsigned short value) const {
            return e_uint16(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_uint16& __fastcall operator+=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator-=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator*=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator/=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator%=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator^=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator&=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator|=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator<<=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator>>=(const unsigned short value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline e_uint16& __fastcall operator=(const unsigned short value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline  __fastcall operator unsigned short() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma region 32-bit

    class e_int32 {
    private:
        int _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_int32(int value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline int __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(int value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_int32 __fastcall operator+(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_int32 __fastcall operator-(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_int32 __fastcall operator/(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_int32 __fastcall operator*(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int32 __fastcall operator&(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_int32 __fastcall operator|(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_int32 __fastcall operator%(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_int32 __fastcall operator^(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int32 __fastcall operator<<(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_int32 __fastcall operator>>(const int value) const {
            return e_int32(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_int32& __fastcall operator+=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator-=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator*=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator/=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator%=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator^=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator&=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator=(const int value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator|=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator<<=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_int32& __fastcall operator>>=(const int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator int() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_uint32 {
    private:
        unsigned int _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_uint32(unsigned int value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline unsigned int __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(unsigned int value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_uint32 __fastcall operator+(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_uint32 __fastcall operator-(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_uint32 __fastcall operator/(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_uint32 __fastcall operator*(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint32 __fastcall operator&(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_uint32 __fastcall operator|(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_uint32 __fastcall operator%(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_uint32 __fastcall operator^(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint32 __fastcall operator<<(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_uint32 __fastcall operator>>(const unsigned int value) const {
            return e_uint32(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_uint32& __fastcall operator+=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator-=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator*=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator/=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator%=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator^=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator&=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator|=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator=(const unsigned int value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator<<=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_uint32& __fastcall operator>>=(const unsigned int value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator int() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma region 64-bit

    class e_int64 {

    private:

        long long _value;

    public:

#pragma region CTOR

        __forceinline __fastcall e_int64(long long value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline long long __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }

        __forceinline void __fastcall set(long long value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_int64 __fastcall operator+(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_int64 __fastcall operator-(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_int64 __fastcall operator/(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_int64 __fastcall operator*(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int64 __fastcall operator&(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_int64 __fastcall operator|(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_int64 __fastcall operator%(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_int64 __fastcall operator^(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_int64 __fastcall operator<<(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_int64 __fastcall operator>>(const long long value) const {
            return e_int64(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_int64& __fastcall operator+=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator-=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator*=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator/=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator%=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator^=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator&=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator|=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator=(const long long value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator<<=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_int64& __fastcall operator>>=(const long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator long long() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_uint64 {
    private:
        unsigned long long _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_uint64(unsigned long long value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline unsigned long long __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(unsigned long long value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_uint64 __fastcall operator+(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_uint64 __fastcall operator-(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_uint64 __fastcall operator/(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_uint64 __fastcall operator*(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint64 __fastcall operator&(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) & value);
        }

        __forceinline e_uint64 __fastcall operator|(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) | value);
        }

        __forceinline e_uint64 __fastcall operator%(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) % value);
        }

        __forceinline e_uint64 __fastcall operator^(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_uint64 __fastcall operator<<(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) << value);
        }

        __forceinline e_uint64 __fastcall operator>>(const unsigned long long value) const {
            return e_uint64(XOR_T(_value, crypto::seed) >> value);
        }

        __forceinline e_uint64& __fastcall operator+=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator-=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator*=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator/=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator%=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) % value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator^=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) ^ value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator&=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) & value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator|=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) | value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator<<=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) << value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator>>=(const unsigned long long value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) >> value, crypto::seed);
            return *this;
        }

        __forceinline e_uint64& __fastcall operator=(const unsigned long long value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline  __fastcall operator unsigned long long() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma endregion

#pragma region Floating Point

#pragma region 32-bit

    class e_float {
    private:
        float _value;
    public:

#pragma region CTOR

        __forceinline __fastcall e_float(float value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline float __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }

        __forceinline void __fastcall set(float value) {
            _value = XOR_T(value, crypto::seed);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_float __fastcall operator+(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_float __fastcall operator-(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_float __fastcall operator/(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_float __fastcall operator*(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_float __fastcall operator^(const float value) const {
            return e_float(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_float& __fastcall operator+=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator-=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator*=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator/=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator^=(const float value) {
            _value = XOR_T(XOR_T(_value, crypto::seed), crypto::seed);
            return *this;
        }

        __forceinline e_float& __fastcall operator=(const float value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline  __fastcall operator float() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma region 64-bit

    class e_double {
    private:
        double _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_double(double value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline double __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(double value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

        __forceinline e_double __fastcall operator+(const double value) const {
            return e_double(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_double __fastcall operator-(const double value) const {
            return e_double(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_double __fastcall operator/(const double value) const {
            return e_double(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_double __fastcall operator*(const double value) const {
            return e_double(XOR_T(_value, crypto::seed) * value);
        }

        __forceinline e_double __fastcall operator^(const double value) const {
            return e_double(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

        __forceinline e_double& __fastcall operator+=(const double value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator-=(const double value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator*=(const double value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator/=(const double value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator^=(const double value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_double& __fastcall operator=(const double value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator double() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#pragma endregion

#pragma endregion

#pragma region SSE Types

    //SSE
#ifdef __SSE__

    class e_m128 {
    private:
        __m128 _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m128(__m128 value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m128 __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m128 value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators
#ifdef __clang__ // msvc does not support math operators on vector types

        __forceinline e_m128 __fastcall operator+(const __m128 value) const {
            return e_m128(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m128 __fastcall operator-(const __m128 value) const {
            return e_m128(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m128 __fastcall operator/(const __m128 value) const {
            return e_m128((const __m128)XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m128 __fastcall operator*(const __m128 value) const {
            return e_m128(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m128 __fastcall operator^(const __m128 value) const {
            return e_m128(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m128& __fastcall operator+=(const __m128 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m128& __fastcall operator-=(const __m128 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m128& __fastcall operator*=(const __m128 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m128& __fastcall operator/=(const __m128 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m128& __fastcall operator^=(const __m128 value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m128& __fastcall operator=(const __m128 value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m128() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#ifdef __SSE2__

    class e_m128i {
    private:
        __m128i _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m128i(__m128i value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m128i __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m128i value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__

        __forceinline e_m128i __fastcall operator+(const __m128i value) const {
            return e_m128i(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m128i __fastcall operator-(const __m128i value) const {
            return e_m128i(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m128i __fastcall operator/(const __m128i value) const {
            return e_m128i(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m128i __fastcall operator*(const __m128i value) const {
            return e_m128i(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m128i __fastcall operator^(const __m128i value) const {
            return e_m128i(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m128i& __fastcall operator+=(const __m128i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m128i& __fastcall operator-=(const __m128i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m128i& __fastcall operator*=(const __m128i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m128i& __fastcall operator/=(const __m128i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m128i& __fastcall operator^=(const __m128i value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m128i& __fastcall operator=(const __m128i value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m128i() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_m128d {
    private:
        __m128d _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m128d(__m128d value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m128d __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m128d value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__

        __forceinline e_m128d __fastcall operator+(const __m128d value) const {
            return e_m128d(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m128d __fastcall operator-(const __m128d value) const {
            return e_m128d(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m128d __fastcall operator/(const __m128d value) const {
            return e_m128d(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m128d __fastcall operator*(const __m128d value) const {
            return e_m128d(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m128d __fastcall operator^(const __m128d value) const {
            return e_m128d(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m128d& __fastcall operator+=(const __m128d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m128d& __fastcall operator-=(const __m128d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m128d& __fastcall operator*=(const __m128d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m128d& __fastcall operator/=(const __m128d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m128d& __fastcall operator^=(const __m128d value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m128d& __fastcall operator=(const __m128d value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m128d() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#endif

#endif

#pragma endregion

#pragma region AVX Types

#ifdef __AVX__

    class e_m256 {
    private:
        __m256 _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m256(__m256 value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m256 __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m256 value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__
        __forceinline e_m256 __fastcall operator+(const __m256 value) const {
            return e_m256(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m256 __fastcall operator-(const __m256 value) const {
            return e_m256(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m256 __fastcall operator/(const __m256 value) const {
            return e_m256(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m256 __fastcall operator*(const __m256 value) const {
            return e_m256(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m256 __fastcall operator^(const __m256 value) const {
            return e_m256(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m256& __fastcall operator+=(const __m256 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m256& __fastcall operator-=(const __m256 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m256& __fastcall operator*=(const __m256 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m256& __fastcall operator/=(const __m256 value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m256& __fastcall operator^=(const __m256 value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m256& __fastcall operator=(const __m256 value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m256() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_m256i {
    private:
        __m256i _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m256i(__m256i value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m256i __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m256i value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__

        __forceinline e_m256i __fastcall operator+(const __m256i value) const {
            return e_m256i(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m256i __fastcall operator-(const __m256i value) const {
            return e_m256i(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m256i __fastcall operator/(const __m256i value) const {
            return e_m256i(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m256i __fastcall operator*(const __m256i value) const {
            return e_m256i(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m256i __fastcall operator^(const __m256i value) const {
            return e_m256i(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

        

#ifdef __clang__

        __forceinline e_m256i& __fastcall operator+=(const __m256i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m256i& __fastcall operator-=(const __m256i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m256i& __fastcall operator*=(const __m256i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m256i& __fastcall operator/=(const __m256i value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m256i& __fastcall operator^=(const __m256i value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m256i& __fastcall operator=(const __m256i value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline __fastcall operator __m256i() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

    class e_m256d {
    private:
        __m256d _value;
    public:

#pragma region CTOR
        __forceinline __fastcall e_m256d(__m256d value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Accessors
        __forceinline __m256d __fastcall get() const {
            return XOR_T(_value, crypto::seed);
        }
        __forceinline void __fastcall set(__m256d value) {
            _value = XOR_T(value, crypto::seed);
        }
#pragma endregion

#pragma region Operators

#ifdef __clang__

        __forceinline e_m256d __fastcall operator+(const __m256d value) const {
            return e_m256d(XOR_T(_value, crypto::seed) + value);
        };

        __forceinline e_m256d __fastcall operator-(const __m256d value) const {
            return e_m256d(XOR_T(_value, crypto::seed) - value);
        }

        __forceinline e_m256d __fastcall operator/(const __m256d value) const {
            return e_m256d(XOR_T(_value, crypto::seed) / value);
        }

        __forceinline e_m256d __fastcall operator*(const __m256d value) const {
            return e_m256d(XOR_T(_value, crypto::seed) * value);
        }

#endif

        __forceinline e_m256d __fastcall operator^(const __m256d value) const {
            return e_m256d(XOR_FORCE(XOR_T(_value, crypto::seed), value));
        }

#ifdef __clang__

        __forceinline e_m256d& __fastcall operator+=(const __m256d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) + value, crypto::seed);
            return *this;
        }

        __forceinline e_m256d& __fastcall operator-=(const __m256d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) - value, crypto::seed);
            return *this;
        }

        __forceinline e_m256d& __fastcall operator*=(const __m256d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) * value, crypto::seed);
            return *this;
        }

        __forceinline e_m256d& __fastcall operator/=(const __m256d value) {
            _value = XOR_T(XOR_T(_value, crypto::seed) / value, crypto::seed);
            return *this;
        }

#endif

        __forceinline e_m256d& __fastcall operator^=(const __m256d value) {
            _value = XOR_T(XOR_FORCE(XOR_T(_value, crypto::seed), value), crypto::seed);
            return *this;
        }

        __forceinline e_m256d& __fastcall operator=(const __m256d value) {
            _value = XOR_T(value, crypto::seed);
            return *this;
        }

        __forceinline  __fastcall operator __m256d() const {
            return XOR_T(_value, crypto::seed);
        }

#pragma endregion
    };

#endif

#pragma endregion

#pragma endregion

#pragma region String

    class e_string {

    private:

#pragma region Encrypted value

        std::string _value = "";

#pragma endregion

    public:

#pragma region CTOR

        __forceinline __fastcall e_string(const std::string& value) {
            _value = XOR_STR_T(value, crypto::seed);
        }

        __forceinline __fastcall e_string(const char* value) {
            _value = XOR_STR_T(std::string(value), crypto::seed);
        }

#pragma endregion

#pragma region Accessors

        __forceinline std::string __fastcall get() const {
            return XOR_STR_T(std::string(_value), crypto::seed);
        }

        __forceinline void __fastcall set(const std::string& value) {
            _value = XOR_STR_T(value, crypto::seed);
        }
        
        __forceinline e_string __fastcall operator+(const std::string& value) const {
            return e_string(XOR_STR_T(std::string(_value), crypto::seed) + value);
        };

        __forceinline e_string& __fastcall operator+=(const std::string& value) {
            _value = XOR_STR_T(static_cast<std::string>(XOR_STR_T(_value, crypto::seed) + value)
                , crypto::seed);
            return *this;
        }

        __forceinline e_string& __fastcall operator=(const std::string& value) {
            set(value);
            return *this;
        }
        
        __forceinline __fastcall operator std::string() const {
            return _value;
            //return XOR_STR_T(_value, crypto::seed);
        }

        __forceinline __fastcall ~e_string() {
            //attempt to trigger memory release
            try {
                std::string().swap(_value);
            }
            catch (std::exception& except) {}
        }
        
#pragma endregion

#pragma region Operators

#pragma endregion
    };

    class e_wstring {
    private:

#pragma region Encrypted value

        std::wstring _value = L"";

#pragma endregion

    public:

#pragma region CTOR

        __forceinline __fastcall e_wstring(const std::wstring& value) {
            _value = XOR_WSTR_T(value, crypto::seed);
        }

        __forceinline __fastcall e_wstring(const wchar_t* value) {
            _value = XOR_WSTR_T(std::wstring(value), crypto::seed);
        }

        __forceinline __fastcall e_wstring() {
            _value = L"";
        }

#pragma endregion

#pragma region Accessors

        __forceinline std::wstring __fastcall get() const {
            return XOR_WSTR_T(std::wstring(_value), crypto::seed);
        }

        __forceinline void __fastcall set(const std::wstring& value) {
            _value = XOR_WSTR_T(value, crypto::seed);
        }

        __forceinline void __fastcall reserve(unsigned long count) {
            _value.reserve(count);
        }

        __forceinline bool __fastcall empty() const{
            return _value.empty();
        }

        __forceinline e_wstring __fastcall operator+(const std::wstring& value) const {
            return e_wstring(XOR_WSTR_T(std::wstring(_value), crypto::seed) + value);
        };

        __forceinline e_wstring& __fastcall operator+=(const std::wstring& value) {
            _value = XOR_WSTR_T(static_cast<std::wstring>(XOR_WSTR_T(_value, crypto::seed) + value)
                , crypto::seed);
            return *this;
        }

        __forceinline e_wstring& __fastcall operator=(const std::wstring& value) {
            set(value);
            return *this;
        }

        __forceinline wchar_t& __fastcall operator[](const int index) {
            return XOR_WSTR_T(_value, crypto::seed)[index];
        }

        __forceinline __fastcall operator std::wstring() const {
            return XOR_WSTR_T(_value, crypto::seed);
        }

        __forceinline __fastcall ~e_wstring() {
            //attempt to trigger memory release
            try {
                std::wstring().swap(_value);
            }
            catch (std::exception& except) {}
        }

#pragma endregion

#pragma region Operators

#pragma endregion
    };

#pragma endregion

#pragma region Heap Allocation

    class e_malloc {

    private:

#pragma region Global Variables

        void* local_alloc;
        size_t alloc_size;
        // use this object to track all get() and similar calls throughout object lifespan, these will be explicitly freed in the destructor so the user won't have to explicitly free every time get() is called
        std::vector<void*> pointer_calls{};

#pragma endregion

    public:

#pragma region Proxy objects

#pragma region Decommission proxy

        struct free_delete_t
        {
            void operator()(void* pointer) const
            {
                free(pointer);
            }
        };

#pragma endregion

#pragma region Subscript proxy

        // nested class to support subscript assignment 
        class index_proxy {

        private:

#pragma region Globals

            e_malloc& parent;
            size_t index;

#pragma endregion

        public:
#pragma region Ctor

            index_proxy(size_t index_, e_malloc& instance) : index(index_), parent(instance) { }

#pragma endregion

#pragma region Operator overrides

            uint8_t& operator=(uint8_t value) {
                parent.set(index, value);
                return value;   // return the passed assignment value rather than using up absurd resources to decrypt, re-encrypt everything using get()
            }

            __forceinline __fastcall operator uint8_t() const {
                return parent.get(index);
            }

#pragma endregion

        };

#pragma endregion

#pragma endregion

#pragma region Ctor

        __forceinline __fastcall e_malloc(size_t size) {
            alloc_size = size;
            local_alloc = malloc(size);

            auto enc_alloc = XOR_RAW(local_alloc, size, crypto::seed);

            memcpy(local_alloc, enc_alloc, size);
            free(enc_alloc);
        }

        __forceinline __fastcall e_malloc() {

        }

#pragma endregion

#pragma region Get accessors

        __forceinline void* __fastcall get() {
            return XOR_RAW(local_alloc, alloc_size, crypto::seed);
        }

        __forceinline void* get(uintptr_t pos, size_t length) {
            auto dec_alloc = reinterpret_cast<uint8_t*>(get());

            auto get_alloc = calloc(length, sizeof(uint8_t));

            memcpy(get_alloc, &dec_alloc[pos], length);
            RtlZeroMemory(dec_alloc, alloc_size);
            free(dec_alloc);

            return get_alloc;
        }

        //overload get() for index operations to avoid unnecessary heap allocations and potential memory leaks
        __forceinline uint8_t __fastcall get(size_t index) {
            auto dec_alloc = reinterpret_cast<uint8_t*>(get());

            auto _return = dec_alloc[index];

            RtlZeroMemory(dec_alloc, alloc_size);
            free(dec_alloc);

            return _return;
        }

        template<typename T>
        __forceinline T __fastcall get_t(uintptr_t pos, T& value) {
            auto value_r = reinterpret_cast<T*>(get(pos, sizeof(T)));
            auto _return = *value_r;
            free(value_r);
            return _return;
        }

        __forceinline void* __fastcall get_data_pointer() {
            return local_alloc;
        }

        __forceinline size_t __fastcall get_data_size() {
            return alloc_size;
        }

#pragma endregion

#pragma region Set accessors

        //WARNING: appending length to the allocation here will cause exceptions / UB
        __forceinline void __fastcall set(void* src, uintptr_t pos, size_t length, bool free_src = false) {
            auto dec_alloc = get();

            memcpy(&reinterpret_cast<unsigned char*>(dec_alloc)[pos], src, length);

            auto enc_alloc = XOR_RAW(dec_alloc, length, crypto::seed);
            //free the decryption allocation and local alocation: reminder this class is performance-heavy and should not be used for large allocation pools
            //for security reasons
            RtlZeroMemory(dec_alloc, alloc_size);
            RtlZeroMemory(local_alloc, alloc_size);
            free(dec_alloc);
            dec_alloc = nullptr;
            free(local_alloc);
            local_alloc = nullptr;

            local_alloc = enc_alloc;

            if (free_src)
                free(src);
        }

        __forceinline void __fastcall set(uintptr_t pos, unsigned char value, size_t size) {
            auto dec_alloc = reinterpret_cast<uint8_t*>(get());

            for (auto i = pos; i < (pos + size); ++i) {
                dec_alloc[i] = value;
            }

            auto enc_alloc = XOR_RAW(dec_alloc, alloc_size, crypto::seed);
            //free the decryption allocation and local alocation: reminder this class is performance-heavy and should not be used for large allocation pools
            //for security reasons
            RtlZeroMemory(dec_alloc, alloc_size);
            RtlZeroMemory(local_alloc, alloc_size);
            free(dec_alloc);
            dec_alloc = nullptr;
            free(local_alloc);
            local_alloc = nullptr;

            local_alloc = enc_alloc;
        }

        template<typename T>
        __forceinline void __fastcall set(uintptr_t pos, T value) {
            auto dec_alloc = reinterpret_cast<uint8_t*>(get()); // so we can properly index the allocation 

            T* cast_t = reinterpret_cast<T*>(&dec_alloc[pos]);
            *cast_t = value;

            auto enc_alloc = XOR_RAW(dec_alloc, alloc_size, crypto::seed);
            //free the decryption allocation and local alocation: reminder this class is performance-heavy and should not be used for large allocation pools
            //for security reasons
            RtlZeroMemory(dec_alloc, alloc_size);
            RtlZeroMemory(local_alloc, alloc_size);
            free(local_alloc);
            local_alloc = nullptr;
            free(dec_alloc);
            dec_alloc = nullptr;
            cast_t = nullptr;

            local_alloc = enc_alloc;
        }

#pragma endregion

#pragma region Utility functions

        __forceinline void __fastcall swap(void* src, size_t length, bool free_src = false) {
            //release current resources 
            zero();
            free(local_alloc);
            local_alloc = nullptr;
            alloc_size = 0x0000000000000000ULL;

            auto enc_alloc = XOR_RAW(src, length, crypto::seed);

            alloc_size = length;
            local_alloc = enc_alloc;
        }

        //size is only the length in bytes of the allocation to be appended or destroyed
        __forceinline void __fastcall resize(size_t size) {
            auto dec_alloc = get();

            auto n_local_alloc = realloc(dec_alloc, size);

            if (!n_local_alloc) {
                free(dec_alloc);
                throw std::bad_alloc();
            }

            dec_alloc = NULL; // zero  old pointer ;; useless even if realloc didnt need to move memory
            //zero out the extended memory (if it was being extended rather than shrunk)
            if ((size) > alloc_size)
                RtlZeroMemory(&(reinterpret_cast<uint8_t*>(n_local_alloc)[alloc_size]), (size - alloc_size));

            auto enc_alloc = XOR_RAW(n_local_alloc, size, crypto::seed);
            //free the decryption allocation and local alocation: reminder this class is performance-heavy and should not be used for large allocation pools
            //for security reasons
            RtlZeroMemory(n_local_alloc, alloc_size);
            RtlZeroMemory(local_alloc, alloc_size);
            //realloc() should automatically free dec_alloc if it was moved to new memory
            free(local_alloc);
            local_alloc = nullptr;
            free(n_local_alloc);
            n_local_alloc = nullptr;

            alloc_size = size;
            local_alloc = enc_alloc;
        }

        __forceinline void __fastcall zero() {
            set(0x0000000000000000ULL, 0x00ui8, alloc_size);
        }

#pragma endregion

#pragma region Operators

        __forceinline e_malloc& __fastcall operator=(const std::vector<uint8_t>& value) {
            swap(const_cast<std::vector<uint8_t>*>(&value)->data(), value.size());

            return *this;
        }

        __forceinline __fastcall operator void* () const {
            return XOR_RAW(local_alloc, alloc_size, crypto::seed);
        }

        template<typename T>
        __forceinline __fastcall operator T* () const {
            return reinterpret_cast<T*>(XOR_RAW(local_alloc, alloc_size, crypto::seed));
        }

        index_proxy operator[](size_t index) {
            return index_proxy(index, *this);
        }



#pragma endregion

#pragma region Destructor

        __forceinline void __fastcall destroy(bool zero) {
            if (local_alloc) {
                try {
                    if (zero)
                        RtlZeroMemory(local_alloc, alloc_size);
                    free(local_alloc);
                    local_alloc = nullptr;
                }
                catch (std::exception& except) {}
            }
        }

        __forceinline void __fastcall secure_destroy() {
            destroy(true);
        }
        __forceinline __fastcall ~e_malloc() {
            secure_destroy();
        }

#pragma endregion

    };

#pragma endregion

};

#endif
```