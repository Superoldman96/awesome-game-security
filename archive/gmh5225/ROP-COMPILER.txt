Project Path: arc_gmh5225_ROP-COMPILER_c0pp0w9s

Source Tree:

```txt
arc_gmh5225_ROP-COMPILER_c0pp0w9s
├── CSGO-Triggerbot-Tutorial.md
├── CheatSourceCodes
│   ├── BF3_MinimapESP.asm
│   ├── BF4_x86_MinimapESP.asm
│   ├── C-PseudoCode
│   │   ├── BF3_MinimapESP.c
│   │   ├── GlowESP.c
│   │   ├── MinimapESP.c
│   │   └── Triggerbot.c
│   ├── CSGO_GlowESP.asm
│   ├── CSGO_MinimapESP.asm
│   └── CSGO_Triggerbot.asm
├── README.md
├── RopCompiler
│   ├── ASSERT.h
│   ├── Compiler.cpp
│   ├── Compiler.h
│   ├── CpuInformation.h
│   ├── GadgetScanner.cpp
│   ├── Gadgets.h
│   ├── GameOffsets.cpp
│   ├── GameOffsets.h
│   ├── Main.cpp
│   ├── RandomGenerator.cpp
│   ├── RandomGenerator.h
│   ├── RopCompiler.vcxproj
│   ├── RopCompiler.vcxproj.filters
│   ├── RopCompiler.vcxproj.user
│   ├── Util.cpp
│   ├── Util.h
│   ├── dbghelp.cpp
│   └── dbghelp.h
├── RopCompiler.sln
└── pictures
    ├── BF3_Minimap.png
    ├── BF3_Minimap1.png
    ├── BF3_Minimap2.png
    ├── BF4_Minimap.png
    ├── CSGO_1.png
    ├── ROP_STACK_1.png
    └── ROP_STACK_2.png

```

`CSGO-Triggerbot-Tutorial.md`:

```md
# CSGO-Triggerbot-Tutorial

Code that has to be modified: <br />
[CSGO_Triggerbot.asm](https://github.com/Speedi13/ROP-COMPILER/blob/master/CheatSourceCodes/CSGO_Triggerbot.asm#L40)

## Step 1
Make sure to disable any Exploit-protection in your AnitVirus software.<br />
You can also try to exclude CSGO from the exploit-protection.

## Step 2 - Trigger key

### Key codes:
https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
<br/>

<img src="https://i.imgur.com/znZyTPL.jpg" alt="Image of Mouse with Labels" width="500"/>

In the [Assembly file](https://github.com/Speedi13/ROP-COMPILER/blob/master/CheatSourceCodes/CSGO_Triggerbot.asm#L40):<br />
```asm
@l_MainLoop:;//EAX => Triggerbot key:
mov eax,0x6;//-> VK_XBUTTON2
;//https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
mov VR9, eax;
```

## Step 3 - Change the trigger key
Lets change the Trigger-bot-key to ``Y``<br />
In the [Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes) you can find:
```
0x59                       Y key
```

You need to change the [source code](https://github.com/Speedi13/ROP-COMPILER/blob/master/CheatSourceCodes/CSGO_Triggerbot.asm#L40) to the following:
```asm
@l_MainLoop:;//EAX => Triggerbot key:
mov eax,0x59;
;//https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
mov VR9, eax;
```

```

`CheatSourceCodes/BF3_MinimapESP.asm`:

```asm
;X86-assembly in Intel syntax with additional virtual registers (VR0 - VR9 and VMM) to ease programming

;//Compiler settings:
;//<cfg=RandomPadding>true</cfg>
;//<cfg=RandomPaddingSize>128</cfg>
;//<cfg=SearchDlls>true</cfg>
;//<cfg=VirtualQuerySearch>false</cfg>
;//<cfg=PrintDebugOutput>false</cfg>

;Virtual registers
;//VR9 => random number
;//VR8 => random number
;//VR7 => random number
;//VR6 => random number
;//VR5 => random number
;//VR4 => random number
;//VR3 => random number
;//VR2 => random number
;//VR1 => random number
;//VR0 => GLOBAL_MinimumAddress
;//read only register:
;//VMM => VirtualAllocEx( hGame, 0, 0x2000, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE );

;//Initial value of the general-purpose register:
;//EAX => Original StackPointer (ESP)

;//Virtual register usage in code below:
;//VR1 -> PlayerListPos
;//VR2 -> PlayerListEnd [ temporary {ClientPlayerManager+9C} ]
;//VR3 -> ClientPlayer |=> ClientSoldierEntity |=> ClientSpottingTargetComponent

;/////////////////////////////// Code Start ///////////////////////////////
@l_Start:
mov eax, 0x2380B58;//fb::ClientGameContext
mov eax, DWORD PTR[eax]

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto l_Start
mov ebx, eax
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Start
;////////////////////////////////////

mov ebx, 0x30;//fb::ClientPlayerManager
add eax, ebx 
mov eax, DWORD PTR[eax]

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto l_Start
mov ebx, eax
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Start
;////////////////////////////////////

mov ebx, 0x9C;//fb::ClientPlayerManager::m_players
add eax, ebx 
mov VR2, eax;//EAX => ClientPlayerManager+9C

mov eax, DWORD PTR[eax];//read m_players->m_firstElement

mov VR1, eax;// VR1 -> PlayerListPos

mov eax, VR2;//EAX => ClientPlayerManager+9C

add eax, 0x4
mov eax, DWORD PTR[eax];//read m_players->m_lastElement

mov VR2, eax;// VR2 -> PlayerListEnd

@Loop1_start:
mov ecx, VR1;// VR1 -> PlayerListPos
mov eax, VR2;// VR2 -> PlayerListEnd
;////////////////////////////////////
;//if ( EAX == ECX ) goto l_Start;
;//if ( PlayerListEnd == PlayerListPos ) goto l_Start;
sub eax, ecx;//COMPARE EAX, ECX
je l_Start;
js l_Start;
;////////////////////////////////////



mov eax, VR1;// VR1 -> PlayerListPos
mov eax, DWORD PTR[eax];//read ClientPlayer pointer

mov VR3, eax;// VR3 -> ClientPlayer

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto Loop1_next
mov ebx, eax;
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc Loop1_next;
;////////////////////////////////////

mov eax, VR3;// VR3 -> ClientPlayer
mov ecx, 0x2142528;//vtable address
mov eax, DWORD PTR[eax];//read ClientPlayer::vtable

;////////////////////////////////////
;//if ( EAX == ECX ) goto Loop1_next;
sub eax, ecx;//COMPARE EAX, ECX
jne Loop1_next;
;////////////////////////////////////

mov eax, VR3;// VR3 -> ClientPlayer
mov ebx, 0x3C0;//ClientPlayer::m_soldier (WeakPtr)
add eax, ebx;
mov eax, DWORD PTR[eax];//read ClientPlayer::m_soldier

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto Loop1_next
mov ebx, eax;
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc Loop1_next;
;////////////////////////////////////

mov eax, DWORD PTR[eax];//read pointer
mov ebx, 0xFFFFFFFC;// -4
add eax, ebx;

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto Loop1_next
mov ebx, eax;
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc Loop1_next;
;////////////////////////////////////

mov VR3, eax;// VR3 -> fb::ClientSoldierEntity

mov eax, DWORD PTR[eax];//fb::ClientSoldierEntity::vtable
mov ecx, 0x214BD40;//vtable address

;////////////////////////////////////
;//if ( EAX == ECX ) goto Loop1_next;
sub eax, ecx;//COMPARE EAX, ECX
jne Loop1_next;
;////////////////////////////////////

mov eax, VR3;// VR3 -> fb::ClientSoldierEntity
mov ebx, 0x440;//=> ( 0x3A0 + (10 * 16) )
add eax, ebx;
mov eax, DWORD PTR[eax];//fb::ClientSpottingTargetComponent
mov VR3, eax;

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto Loop1_next
mov ebx, eax;
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc Loop1_next;
;////////////////////////////////////

mov ebx, eax;
mov eax, DWORD PTR[eax];//fb::ClientSpottingTargetComponent::Vtable
mov ecx, 0x20B2278;//vtable address

;////////////////////////////////////
;//if ( EAX != ECX ) goto Loop1_next;
sub eax, ecx;//COMPARE EAX, ECX
jne Loop1_next;
;////////////////////////////////////

xchg eax, ebx;//Restore EAX
mov eax, VR3;// VR3 -> fb::ClientSpottingTargetComponent
mov ebx, 0x18;//=> m_spotType
add eax, ebx;
mov ebx, 0x1;//SpotType_Active

mov DWORD PTR [eax],ebx

jmp Loop1_next;

;////////////////////////////////////
@Loop1_next:
mov eax, VR1;// VR1 -> PlayerListPos
add eax, 0x4
mov VR1, eax;// VR1 -> PlayerListPos
jmp Loop1_start;
;////////////////////////////////////
nop

;//////////////////////////////// Code End ////////////////////////////////

```

`CheatSourceCodes/BF4_x86_MinimapESP.asm`:

```asm
;X86-assembly in Intel syntax with additional virtual registers (VR0 - VR9 and VMM) to ease programming

;//Compiler settings:
;//<cfg=RandomPadding>true</cfg>
;//<cfg=RandomPaddingSize>128</cfg>
;//<cfg=SearchDlls>true</cfg>
;//<cfg=VirtualQuerySearch>false</cfg>
;//<cfg=PrintDebugOutput>false</cfg>

;Virtual registers
;//VR9 => random number
;//VR8 => random number
;//VR7 => random number
;//VR6 => random number
;//VR5 => random number
;//VR4 => random number
;//VR3 => random number
;//VR2 => random number
;//VR1 => random number
;//VR0 => GLOBAL_MinimumAddress
;//read only register:
;//VMM => VirtualAllocEx( hGame, 0, 0x2000, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE );

;//Initial value of the general-purpose register:
;//EAX => Original StackPointer (ESP)

;//Virtual register usage in code below:
;//VR1 -> PlayerListPos
;//VR2 -> PlayerListEnd [ temporary {ClientPlayerManager+9C} ]
;//VR3 -> ClientPlayer |=> ClientSoldierEntity |=> ClientSpottingTargetComponent
;//VR5 -> SyncedBFSettings
;/////////////////////////////// Code Start ///////////////////////////////
@l_Start:
mov eax, 0x20ED25C;//fb::SyncedBFSettings
mov eax, DWORD PTR[eax]
;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto l_Start
mov ebx, eax
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Start
;////////////////////////////////////
mov VR5, eax
mov ecx, 0x1D7DF6C;//vtable address
mov eax, DWORD PTR[eax];//read SyncedBFSettings::vtable

;////////////////////////////////////
;//if ( EAX != ECX ) goto l_Start;
sub eax, ecx;//COMPARE EAX, ECX
jne l_Start;
;////////////////////////////////////

;//class SyncedBFSettings
;//{
;//public:
;//[...]
;//bool m_AllUnlocksUnlocked; //0x0038
;//bool m_NoMinimap; //0x0039
;//bool m_NoHud; //0x003A
;//bool m_NoMinimapSpotting; //0x003B
;//bool m_No3dSpotting; //0x003C
;//bool m_NoNameTag; //0x003D
;//bool m_OnlySquadLeaderSpawn; //0x003E
;//bool m_TeamSwitchingAllowed; //0x003F
;//bool m_RevertBackToBF3KillerCamera; //0x0040
;//bool m_DisableHitIndicators; //0x0041
   
mov eax, VR5
mov ebx, 0x39;//m_NoMinimap
add eax, ebx 
xchg eax, ebx;// EAX <--> EBX
mov eax, 0x0;//FALSE -> Will enable the Minimap
mov BYTE PTR[ebx], al
;////////////////////////////////////


mov eax, 0x21CC644;//fb::ClientGameContext
mov eax, DWORD PTR[eax]
;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto l_Start
mov ebx, eax
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Start
;////////////////////////////////////

mov ebx, 0x30;//fb::ClientPlayerManager
add eax, ebx 
mov eax, DWORD PTR[eax]

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto l_Start
mov ebx, eax
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Start
;////////////////////////////////////

mov ebx, 0x80;//fb::ClientPlayerManager::m_players
add eax, ebx 
mov VR2, eax;//EAX => ClientPlayerManager+80

mov eax, DWORD PTR[eax];//read m_players->m_firstElement

mov VR1, eax;// VR1 -> PlayerListPos

mov eax, VR2;//EAX => ClientPlayerManager+80

add eax, 0x4
mov eax, DWORD PTR[eax];//read m_players->m_lastElement

mov VR2, eax;// VR2 -> PlayerListEnd

@Loop1_start:
mov ecx, VR1;// VR1 -> PlayerListPos
mov eax, VR2;// VR2 -> PlayerListEnd
;////////////////////////////////////
;//if ( EAX == ECX ) goto l_Start;
;//if ( PlayerListEnd == PlayerListPos ) goto l_Start;
sub eax, ecx;//COMPARE EAX, ECX
je l_Start;
js l_Start;
;////////////////////////////////////

mov eax, VR1;// VR1 -> PlayerListPos
mov eax, DWORD PTR[eax];//read ClientPlayer pointer

mov VR3, eax;// VR3 -> ClientPlayer

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto Loop1_next
mov ebx, eax;
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc Loop1_next;
;////////////////////////////////////

mov eax, VR3;// VR3 -> ClientPlayer
mov ecx, 0x1DE0370;//vtable address
mov eax, DWORD PTR[eax];//read ClientPlayer::vtable

;////////////////////////////////////
;//if ( EAX == ECX ) goto Loop1_next;
sub eax, ecx;//COMPARE EAX, ECX
jne Loop1_next;
;////////////////////////////////////

mov eax, VR3;// VR3 -> ClientPlayer
mov ebx, 0xEE0;//ClientPlayer::m_soldier (WeakPtr)
add eax, ebx;
mov eax, DWORD PTR[eax];//read ClientPlayer::m_soldier

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto Loop1_next
mov ebx, eax;
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc Loop1_next;
;////////////////////////////////////

mov eax, DWORD PTR[eax];//read pointer
mov ebx, 0xFFFFFFFC;// -4
add eax, ebx;

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto Loop1_next
mov ebx, eax;
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc Loop1_next;
;////////////////////////////////////

mov VR3, eax;// VR3 -> fb::ClientSoldierEntity

mov eax, DWORD PTR[eax];//fb::ClientSoldierEntity::vtable
mov ecx, 0x1E8BA98;//vtable address

;////////////////////////////////////
;//if ( EAX == ECX ) goto Loop1_next;
sub eax, ecx;//COMPARE EAX, ECX
jne Loop1_next;
;////////////////////////////////////

mov eax, VR3;// VR3 -> fb::ClientSoldierEntity
mov ebx, 0x73C;//=> ( 0x4FC + (36 * 16) )
add eax, ebx;
mov eax, DWORD PTR[eax];//fb::ClientSpottingTargetComponent
mov VR3, eax;

;////////////////////////////////////
;//if ( EAX < 0x10000 ) goto Loop1_next
mov ebx, eax;
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc Loop1_next;
;////////////////////////////////////

mov ebx, eax;
mov eax, DWORD PTR[eax];//fb::ClientSpottingTargetComponent::Vtable
mov ecx, 0x1D38D90;//vtable address

;////////////////////////////////////
;//if ( EAX != ECX ) goto Loop1_next;
sub eax, ecx;//COMPARE EAX, ECX
jne Loop1_next;
;////////////////////////////////////
xchg eax, ebx;//Restore EAX
mov eax, VR3;// VR3 -> fb::ClientSpottingTargetComponent
mov ebx, 0x28;//=> m_spotType
add eax, ebx;
mov ebx, 0x1;//SpotType_Active

mov DWORD PTR [eax],ebx

jmp Loop1_next;

;////////////////////////////////////
@Loop1_next:
mov eax, VR1;// VR1 -> PlayerListPos
add eax, 0x4
mov VR1, eax;// VR1 -> PlayerListPos
jmp Loop1_start;
;////////////////////////////////////
nop

;//////////////////////////////// Code End ////////////////////////////////

```

`CheatSourceCodes/C-PseudoCode/BF3_MinimapESP.c`:

```c
//C++ interpretation of the BF3_MinimapESP.asm to help understanding how it works

for ( ; ; )
{
	DWORD CGC = *(DWORD*)0x2380B58;
	if ( CGC > 0x10000 )
	{
		DWORD PlayerMgr = *(DWORD*)( CGC + 0x30 );
		if ( PlayerMgr > 0x10000 )
		{
			DWORD PlayerListPos = *(DWORD*)( PlayerMgr + 0x9C + 0 );
			DWORD PlayerListEnd = *(DWORD*)( PlayerMgr + 0x9C + 4 );

			while( PlayerListPos != PlayerListEnd )
			{
				DWORD ClientPlayer = *(DWORD*)(PlayerListPos);
				if ( ClientPlayer > 0x10000 )
				{
					if ( *(DWORD*)ClientPlayer == 0x02142528 )
					{
						

						DWORD WeakPtr = *(DWORD*)( ClientPlayer + 0x3C0 );
						if ( WeakPtr > 0x10000 )
						{
							DWORD ClientSoldierEntity = *(DWORD*)WeakPtr - 4;
							if ( ClientSoldierEntity > 0x10000 )
							{
								if ( *(DWORD*)ClientSoldierEntity == 0x214BD40 )
								{

									DWORD ClientSpottingTargetComponent = *(DWORD*)( ClientSoldierEntity + 0x3A0ui32 + (10ui32 * 16ui32) );
									if ( ClientSpottingTargetComponent > 0x10000 )
									{
										if ( *(DWORD*)ClientSpottingTargetComponent == 0x20B2278 )
										{
											*(DWORD*)( ClientSpottingTargetComponent + 0x18 ) = 1;
										}
									}
								}
							}
						}
					}
				}
				PlayerListPos += 4;
			}
		}
	}
}
```

`CheatSourceCodes/C-PseudoCode/GlowESP.c`:

```c
//C++ interpretation of the CSGO_GlowESP.asm to help understanding how it works

while(true)
{
l_Start:	
	DWORD LocalPlayer = *(DWORD*)OFFSET_LocalPlayer;
	if ( LocalPlayer < 0x10000 ) continue;
	
	DWORD LocalTeamId = *(DWORD*)( LocalPlayer + OFFSET_TeamNum );
	if ( LocalTeamId > 64 ) continue;
	
	DWORD GlowObjectManager = OFFSET_GlowObjectManager;
	
	DWORD ObjectCount = *(DWORD*)( GlowObjectManager + 0x4 + 0x4 + 0x4 );
	DWORD GlowObject = *(DWORD*)GlowObjectManager;
	while(true)
	{
		DWORD Entity = *(DWORD*)( GlowObject + 0 );
		if ( Entity > 0x10000 )
		{
			DWORD ClassId = GetClassID( Entity );
			if ( ClassId == 0x28 )
			{
				DWORD TeamId = *(DWORD*)( Entity + OFFSET_TeamNum );
				if ( TeamId != LocalTeamId )
				{
					*(DWORD*)( GlowObject + 0x04 ) = 0x3F800000;//GlowObject->m_flRed = 1.0f [1.0f => 0x3F800000]
					*(DWORD*)( GlowObject + 0x08 ) = 0x0;//GlowObject->m_flGreen = 0.0f
					*(DWORD*)( GlowObject + 0x0C ) = 0x0;//GlowObject->m_flBlue = 0.0f
					*(DWORD*)( GlowObject + 0x10 ) = 0x3F800000;//GlowObject->m_flAlpha = 1.0f [1.0f => 0x3F800000]
					*(DWORD*)( GlowObject + 0x24 ) = 0x00000001;
				}
			}
		}
l_skip:	
		GlowObject += 0x38;
		ObjectCount -= 1;
		if ( ObjectCount == 0 ) break;
	}
	continue;
};
return;

//class GlowObject 
//{
//public:
//       BaseEntity* m_pEntity; //0x0000 
//       float m_flRed; //0x0004 
//       float m_flGreen; //0x0008 
//       float m_flBlue; //0x000C 
//       float m_flAlpha; //0x0010 
//       char _0x0014[16];
//       BYTE m_bRenderWhenOccluded; //0x0024 
//       BYTE m_bRenderWhenUnoccluded; //0x0025 
//       BYTE m_bFullBloom; //0x0026 
//       uint8_t pad_0027[5];               //0x0027
//       int32_t m_nGlowStyle;              //0x002C
//       int32_t m_nSplitScreenSlot;        //0x0030
//       int32_t m_nNextFreeSlot; //0x0034
//};//Size=0x0038

DWORD GetClassID( DWORD Entity )
{
	DWORD IClientNetworkableVtable = *(DWORD*)(Entity + 0x8);
	if ( IClientNetworkableVtable >= 0x10000 )
	{
		DWORD GetClientClassFunction = *(DWORD*)(IClientNetworkableVtable + 0x8);
		if ( GetClientClassFunction >= 0x10000 )
		{
			DWORD ClientClass = *(DWORD*)(GetClientClassFunction + 0x1);
			if ( ClientClass >= 0x10000 )
			{
				return *(DWORD*)( ClientClass + 0x14 );
			}
		}
	}
	return 0;
}
```

`CheatSourceCodes/C-PseudoCode/MinimapESP.c`:

```c
//C++ interpretation of the CSGO_MinimapESP.asm to help understanding how it works

DWORD VR5 = 0x93D;//m_bSpotted

while(true)
{
	DWORD LocalPlayer = *(DWORD*)OFFSET_LocalPlayer;
	if ( LocalPlayer < 0x10000 ) continue;

	DWORD LocalTeamId = *(DWORD*)( LocalPlayer + OFFSET_TeamNum );
	if ( LocalTeamId > 64 ) continue;
	
	DWORD VR2 = 64;
	DWORD VR9 = OFFSET_EntityList;
	while(true)
	{
		DWORD Entity = *(DWORD*)VR9;
		if (  Entity < 0x10000 ) goto l_skip;
		
		DWORD TeamId = *(DWORD*)( Entity + OFFSET_TeamNum );
		if ( TeamId == LocalPlayer ) goto l_skip;
		
		//*(DWORD*)( Entity + 0x70 ) = 0xFF0000FF;// [RR GG BB AA] m_clrRender
		
		Entity += VR5;
		*(BYTE*)Entity = 1;
		
l_skip:		
		VR9 = VR9 + 0x4 + 0x4 + 0x4 + 0x4;
		
		VR2 = VR2 - 1;
		if ( VR2 == 0 ) break;
	}
}
return;

DWORD GetClassID( DWORD Entity )
{
	DWORD IClientNetworkableVtable = *(DWORD*)(Entity + 0x8);
	if ( IClientNetworkableVtable >= 0x10000 )
	{
		DWORD GetClientClassFunction = *(DWORD*)(IClientNetworkableVtable + 0x8);
		if ( GetClientClassFunction >= 0x10000 )
		{
			DWORD ClientClass = *(DWORD*)(GetClientClassFunction + 0x1);
			if ( ClientClass >= 0x10000 )
			{
				return *(DWORD*)( ClientClass + 0x14 );
			}
		}
	}
	return 0;
}
```

`CheatSourceCodes/C-PseudoCode/Triggerbot.c`:

```c
//C++ interpretation of the CSGO_Triggerbot.asm to help understanding how it works

BOOL AttackState = FALSE;
DWORD TargetPlayer = 0;
while (true)
{
l_MainLoop:	
	Sleep( 20 );
	SHORT KeyState = GetAsyncKeyState( VK_XBUTTON1 );
	if ( KeyState != 0 )
	{
l_KeyDown:		
		DWORD p = *(DWORD*)OFFSET_LocalPlayer;
		if ( p > 0x10000 )
		{
			DWORD LocalTeamId = *(DWORD*)( p + OFFSET_TeamNum );

			DWORD CrosshairId = *(DWORD*)( p + OFFSET_CrosshairId );
			if ( CrosshairId > 0 && CrosshairId < 64 )
			{
				TargetPlayer = *(DWORD*)( (DWORD)OFFSET_EntityList + ( CrosshairId * 0x10 ) );
				if ( TargetPlayer > 0x10000 )
				{
					DWORD TargetTeamId = *(DWORD*)( TargetPlayer + OFFSET_TeamNum );
					if ( LocalTeamId != TargetTeamId )
					{
						if ( AttackState == 0 )
						{
							AttackState = 1;
							*(BOOL*)dwForceAttack = AttackState;
							continue;//goto l_MainLoop
						}
						else
						{
							AttackState = 0;
							*(BOOL*)dwForceAttack = AttackState;
							continue;//goto l_MainLoop
						}
					}
				}
			}
		}
	}
l_KeyUp:	
	if (AttackState != 0)
	{
		*(BOOL*)dwForceAttack = false;
		AttackState = FALSE;
	}
	continue;//goto l_MainLoop;
}
return;
```

`CheatSourceCodes/CSGO_GlowESP.asm`:

```asm
;X86-assembly in Intel syntax with additional virtual registers (VR0 - VR9 and VMM) to ease programming

;//Compiler settings:
;//<cfg=RandomPadding>true</cfg>
;//<cfg=RandomPaddingSize>128</cfg>
;//<cfg=SearchDlls>false</cfg>
;//<cfg=VirtualQuerySearch>true</cfg>
;//<cfg=PrintDebugOutput>false</cfg>

;Virtual registers
;//VR9 => OFFSET_GlowObjectManager
;//VR8 => OFFSET_LocalPlayer
;//VR7 => OFFSET_EntityList
;//VR6 => OFFSET_FORCE_ATTACK
;//VR5 => OFFSET_CrosshairId
;//VR4 => OFFSET_TeamNum
;//VR3 => OFFSET_bSpotted
;//VR2 => random number
;//VR1 => random number
;//VR0 => GLOBAL_MinimumAddress
;//read only register:
;//VMM => VirtualAllocEx( hGame, 0, 0x2000, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE );

;//Initial value of the general-purpose register:
;//EAX => Original StackPointer (ESP)

;//Virtual register usage in code below:
;//VR0 -> Local Team Id
;//VR1 -> Object Count
;//VR2 -> GlowObject / temporary GlowObjectManager
;//VR3 -> Entity
;//VR6 -> GLOBAL_MinimumAddress


;/////////////////////////////// Code Start ///////////////////////////////
;//VR6 => VR0
mov eax, VR0
mov VR6, eax;//OFFSET_FORCE_ATTACK is not needed and gets overwritten!

@l_Start:
mov eax, VR8;//OFFSET_LocalPlayer
mov eax, DWORD PTR[eax]

;//if ( EBX < 0x10000 ) goto l_Start
mov ebx, eax
mov ecx, VR6;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Start

mov ebx, VR4;//OFFSET_TeamNum 
add eax, ebx 
mov eax, DWORD PTR[eax]
mov VR0, eax;//<-- VR0 -> Local TeamId

;//if ( EAX > 64 ) goto l_Start
xchg eax, ecx
mov eax, 64
sub eax, ecx;//COMPARE EAX, ECX
js l_Start


mov eax, VR9;//OFFSET_GlowObjectManager
mov VR2, eax;//VR2 = GlowObjectManager

add eax, 0x4
add eax, 0x4
add eax, 0x4

mov eax, DWORD PTR[eax]
mov VR1, eax;//VR1 = Object Count
mov eax, VR2;//VR2 = GlowObjectManager
mov eax, DWORD PTR[eax]
mov VR2, eax;//VR2 = GlowObject

@l_Loop1:
mov eax, VR2;//VR2 = GlowObject
mov eax, DWORD PTR[eax] ;//eax = GlowObject->m_pEntity
mov VR3, eax;//VR3 -> Entity

;//if ( EAX < 0x10000 ) goto l_skip
mov ebx, eax
mov ecx, VR6;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_skip


mov eax, VR3;//VR3 -> Entity
jmp GetClassID
@GetClassID_Ret:

;//if ( ECX != 0x28 ) goto l_skip
mov eax, 0x28
sub eax, ecx;//COMPARE EAX, ECX
jne l_skip

mov eax, VR3;//VR3 -> Entity
mov ebx, VR4;//VR4 -> OFFSET_TeamNum
add eax, ebx 
mov eax, DWORD PTR[eax];//eax = Entity->m_iTeamNum
mov ecx, eax

mov eax, VR0;//VR0 = Local iTeamNum

;//skip players of same team
;//if ( EAX == ECX ) goto l_skip;
mov ebx, eax
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
je l_skip


mov eax, VR2;//VR2 = GlowObject
add eax, 0x4
mov ebx, 0x3F800000
mov DWORD PTR[eax], ebx;//GlowObject->m_flRed = 1.0f [1.0f => 0x3F800000]
add eax, 0x4
mov ebx, 0x0
mov DWORD PTR[eax], ebx;//GlowObject->m_flGreen = 0.0f
add eax, 0x4
mov DWORD PTR[eax], ebx;//GlowObject->m_flBlue = 0.0f
add eax, 0x4
mov ebx, 0x3F800000
mov DWORD PTR[eax], ebx;//GlowObject->m_flAlpha = 1.0f [1.0f => 0x3F800000]

add eax, 4
add eax, 4
add eax, 4
add eax, 4
add eax, 4
;GlowObject->m_bRenderWhenOccluded = 1
;GlowObject->m_bRenderWhenUnoccluded = 0
;GlowObject->m_bFullBloom = 0
;=> 0x00000101
mov ebx, 0x00000001
mov DWORD PTR[eax], ebx

@l_skip:

mov eax, VR2;//VR2 = GlowObject
mov ebx, 0x38
add eax, ebx ;//GlowObject = GlowObject+0x38
mov VR2, eax;//VR2 = GlowObject

mov eax, VR1;//VR1 = Object Count
dec eax
mov VR1, eax;//VR1 = VR-1

;//if ( EAX != 0 ) goto l_Loop1
mov ecx, 0x00
sub eax, ecx;//COMPARE EAX, ECX
jne l_Loop1

jmp l_Start;//=> Jump back to start

;//////////////////////////////////////////// GetClassId ////////////////////////////////////////////
;//Function GetClassId
;//EAX => Entity
@GetClassID:
mov ecx, eax

add eax, 0x4
add eax, 0x4

mov eax, DWORD PTR[eax]

;//if ( EBX < 0x10000 ) goto l_Fail
mov ebx, eax
mov ecx, VR6;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Fail

add eax, 0x4
add eax, 0x4

mov eax, DWORD PTR[eax]

;//if ( EAX < 0x10000 ) goto l_Fail
mov ebx, eax
mov ecx, VR6;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Fail

inc eax
mov eax, DWORD PTR[eax]

;//if ( EAX < 0x10000 ) goto l_Fail
mov ebx, eax
mov ecx, VR6;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Fail


add eax, 0x4
add eax, 0x4
add eax, 0x4
add eax, 0x4
add eax, 0x4


mov eax, DWORD PTR[eax]
mov ecx, eax

jmp GetClassID_Ret

@l_Fail:
mov ecx, 0x0
jmp GetClassID_Ret
;//////////////////////////////// Code End ////////////////////////////////

```

`CheatSourceCodes/CSGO_MinimapESP.asm`:

```asm
;X86-assembly in Intel syntax with additional virtual registers (VR0 - VR9 and VMM) to ease programming

;//Compiler settings:
;//<cfg=RandomPadding>true</cfg>
;//<cfg=RandomPaddingSize>128</cfg>
;//<cfg=SearchDlls>false</cfg>
;//<cfg=VirtualQuerySearch>true</cfg>
;//<cfg=PrintDebugOutput>false</cfg>

;Virtual registers
;//VR9 => OFFSET_GlowObjectManager
;//VR8 => OFFSET_LocalPlayer
;//VR7 => OFFSET_EntityList
;//VR6 => OFFSET_FORCE_ATTACK
;//VR5 => OFFSET_CrosshairId
;//VR4 => OFFSET_TeamNum
;//VR3 => OFFSET_bSpotted
;//VR2 => random number
;//VR1 => random number
;//VR0 => GLOBAL_MinimumAddress
;//read only register:
;//VMM => VirtualAllocEx( hGame, 0, 0x2000, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE );

;//Initial value of the general-purpose register:
;//EAX => Original StackPointer (ESP)

;//Virtual register usage in code below:
;//VR1 -> PlayerEntity
;//VR2 -> Loop counter
;//VR6 -> Local Team Id
;//VR9 -> PlayerEntity offset

;/////////////////////////////// Code Start ///////////////////////////////

@l_Start:
mov eax, VR8;//OFFSET_LocalPlayer
mov eax, DWORD PTR[eax]

;//if ( EAX < 0x10000 ) goto l_Start
mov ebx, eax
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Start

mov ebx, VR4;//OFFSET_TeamNum 
add eax, ebx 
mov eax, DWORD PTR[eax]
mov VR6, eax;//<-- VR6 -> Local TeamId

;//if ( EAX > 64 ) goto l_Start
xchg eax, ecx
mov eax, 64
sub eax, ecx;//COMPARE EAX, ECX
js l_Start

mov eax, 64
mov VR2, eax;//LoopCounter = 64

mov eax, VR7;//VR7 => OFFSET_EntityList
mov VR9, eax;//VR9 => PlayerEntity offset


@l_Loop:
mov eax, VR9;//VR9 => PlayerEntity offset
mov eax, DWORD PTR[eax];
mov VR1, eax;//VR1 -> Entity

;//if ( EAX < 0x10000 ) goto l_skip
mov ebx, eax
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_skip

jmp GetClassID
@GetClassID_Ret:

;//if ( ECX != 0x28 ) goto l_skip
mov eax, 0x28
sub eax, ecx;//COMPARE EAX, ECX
jne l_skip

mov eax, VR1;//VR1 -> Entity
mov ebx, VR4;//VR4 -> OFFSET_TeamNum
add eax, ebx 
mov eax, DWORD PTR[eax];//eax = Entity->m_iTeamNum
mov ecx, eax

mov eax, VR6;//VR6 = Local iTeamNum

;//skip players of same team
;//if ( EAX == ECX ) goto l_skip;
mov ebx, ecx
mov edx, eax
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, edx;//Restore EAX
je l_skip

mov eax, VR1;//VR1 -> Entity
mov ebx, VR3;//VR3 -> m_bSpotted
add eax, ebx 
mov ebx,1
mov BYTE PTR [eax],bl

;//m_clrRender = 0x70;
;//uncomment code below to color enemy players red

mov eax, VR1;//VR1 -> Entity
mov ebx, 0x70;//m_clrRender
add eax, ebx 
mov ebx,0xFF0000FF;//RR GG BB AA
mov DWORD PTR [eax],ebx


@l_skip:
mov eax, VR9;//VR9 => PlayerEntity offset
add eax, 0x4
add eax, 0x4
add eax, 0x4
add eax, 0x4
mov VR9, eax

mov eax, VR2
dec eax
mov VR2, eax
;//if ( EAX == ECX ) goto l_skip;
mov ecx, 0
sub eax, ecx;//COMPARE EAX, ECX
jne l_Loop

jmp l_Start


;//////////////////////////////////////////// GetClassId ////////////////////////////////////////////
;//Function GetClassId
;//EAX => Entity
@GetClassID:
mov ecx, eax

add eax, 0x4
add eax, 0x4

mov eax, DWORD PTR[eax]

;//if ( EAX < 0x10000 ) goto l_Fail
mov ebx, eax
mov ecx, VR6;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX

jc l_Fail

add eax, 0x4
add eax, 0x4

mov eax, DWORD PTR[eax]

;//if ( EAX < 0x10000 ) goto l_Fail
mov ebx, eax
mov ecx, VR6;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Fail

inc eax
mov eax, DWORD PTR[eax]

;//if ( EAX < 0x10000 ) goto l_Fail
mov ebx, eax
mov ecx, VR6;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_Fail


add eax, 0x4
add eax, 0x4
add eax, 0x4
add eax, 0x4
add eax, 0x4


mov eax, DWORD PTR[eax]
mov ecx, eax

jmp GetClassID_Ret

@l_Fail:
mov ecx, 0x0
jmp GetClassID_Ret
;//////////////////////////////// Code End ////////////////////////////////

```

`CheatSourceCodes/CSGO_Triggerbot.asm`:

```asm
;X86-assembly in Intel syntax with additional virtual registers (VR0 - VR9 and VMM) to ease programming

;//Compiler settings:
;//<cfg=RandomPadding>true</cfg>
;//<cfg=RandomPaddingSize>128</cfg>
;//<cfg=SearchDlls>false</cfg>
;//<cfg=VirtualQuerySearch>true</cfg>
;//<cfg=PrintDebugOutput>false</cfg>

;Virtual registers
;//VR9 => OFFSET_GlowObjectManager
;//VR8 => OFFSET_LocalPlayer
;//VR7 => OFFSET_EntityList
;//VR6 => OFFSET_FORCE_ATTACK
;//VR5 => OFFSET_CrosshairId
;//VR4 => OFFSET_TeamNum
;//VR3 => OFFSET_bSpotted
;//VR2 => random number
;//VR1 => random number
;//VR0 => GLOBAL_MinimumAddress
;//read only register:
;//VMM => VirtualAllocEx( hGame, 0, 0x2000, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE );

;//Initial value of the general-purpose register:
;//EAX => Original StackPointer (ESP)

;//Virtual register usage in code below:
;//VR1 -> Local Team Id
;//VR2 -> AttackState
;//VR3 -> Original Stack Pointer
;//VR9 -> Crosshair id / temporary localplayer / temporary TriggerbotKey

;/////////////////////////////// Code Start ///////////////////////////////
mov VR3, eax;//VR3 => Original Stack Pointer

mov eax, 0x0
mov VR2, eax;//VR2 => 0

@l_MainLoop:;//EAX => Triggerbot key:
mov eax,0x6;//-> VK_XBUTTON2
;//https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
mov VR9, eax;

mov ecx, 0x0
mov eax, VR3;//=> Original Stack Pointer
mov ebx, !kernel32.Sleep
mov DWORD PTR[eax], ebx
add eax, 0x4
mov ebx, #xchg esp,ebx;//return-rop-address will be stored on ebx
mov DWORD PTR[eax], ebx
add eax, 0x4
mov ebx, 13;//13 milli-sec
mov DWORD PTR[eax], ebx
mov eax, VR3;//=> Original Stack Pointer
mov ebx, @l_ReturnFromSleep
;//----------------------------------------------------
xchg eax, esp;//=> Jump to [EAX] -> Sleep
;//----------------------------------------------------
@l_ReturnFromSleep:
mov eax, VR3;//=> Original Stack Pointer
mov ebx, !user32.GetAsyncKeyState
mov DWORD PTR[eax], ebx
add eax, 0x4
mov ebx, #xchg esp,ebx;//return-rop-address will be stored on ebx
mov DWORD PTR[eax], ebx
add eax, 0x4
mov ebx, VR9
mov DWORD PTR[eax], ebx
mov eax, VR3;//=> Original Stack Pointer
mov ebx, @l_ReturnFromGetAsyncKeyState
;//----------------------------------------------------
xchg eax, esp;//=> Jump to [EAX] -> GetAsyncKeyState
;//----------------------------------------------------
@l_ReturnFromGetAsyncKeyState:
mov ecx, 0x0
sub eax, ecx;//COMPARE EAX, ECX
jne l_KeyDown
@l_KeyUp:
;//Below if key is not down:
;//if (AttackState)
;//{
;//	*(bool*)dwForceAttack = false;
;//	AttackState = FALSE;
;//}

;//if ( AttackState == 0 ) goto l_MainLoop;
mov ecx, VR2;//VR2 -> AttackState
mov eax, 0x0
sub eax, ecx;//COMPARE EAX, ECX
je l_MainLoop

;//*(BOOL*)dwForceAttack = false;
mov eax, VR6;//VR6 => OFFSET_FORCE_ATTACK
mov ebx, 0x0
mov DWORD PTR[eax], ebx
mov eax, 0x0
mov VR2, eax;//VR2 -> AttackState
jmp l_MainLoop


@l_KeyDown:
mov eax, VR8;//OFFSET_LocalPlayer
mov eax, DWORD PTR[eax]

mov VR9, eax;//VR9 -> Local PlayerEntity


;//if ( EAX < 0x10000 ) goto l_MainLoop
mov ebx, eax
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_MainLoop

mov ebx, VR4;//OFFSET_TeamNum 
add eax, ebx 
mov eax, DWORD PTR[eax]
mov VR1, eax;//VR1 -> Local TeamId

mov eax, VR9;//VR9 -> Local PlayerEntity
mov ebx, VR5;//OFFSET_CrosshairId

add eax, ebx
mov eax, DWORD PTR[eax]

mov VR9, eax;//VR9 -> CrosshairId

;//if ( CrosshairId > 64 ) goto l_KeyUp;
xchg eax, ecx
mov eax, 0x40
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ecx;//Restore EAX
js l_KeyUp

;//if ( CrosshairId == 0 ) goto l_KeyUp;
mov ecx, 0x0
mov ebx, eax
sub eax, ecx;//COMPARE EAX, ECX
je l_KeyUp


mov ecx, VR9;//VR9 -> CrosshairId
mov eax, 0x0

;//TargetPlayer = *(DWORD_PTR*)( (DWORD_PTR)OFFSET_EntityList + ( CrosshairId * 0x10 ) );


@l_CrosshairIdLoop:
add eax, 0x4
add eax, 0x4
add eax, 0x4
add eax, 0x4

;//dec ecx
xchg eax, ecx;//Swap EAX with ECX
dec eax
xchg eax, ecx;//Swap EAX with ECX

xchg eax, ebx
mov eax, 0x0
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jne l_CrosshairIdLoop

;//EAX = ( CrosshairId * 0x10 )

mov ebx, VR7;//VR7 => OFFSET_EntityList
add eax, ebx ;// eax = OFFSET_EntityList + ( CrosshairId * 0x10 )

mov eax, DWORD PTR[eax]

;//if ( EAX < 0x10000 ) goto l_KeyUp
mov ebx, eax
mov ecx, VR0;//0x10000
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
jc l_KeyUp

mov ebx, VR4;//OFFSET_TeamNum 
add eax, ebx 
mov eax, DWORD PTR[eax];//EAX = Entity->m_iTeamNum
mov ebx, eax
mov ecx, VR1;//VR1 -> Local TeamId

;//if ( EAX == ECX ) goto l_KeyUp
;//if ( Entity->m_iTeamNum == LocalTeamId ) goto l_KeyUp
sub eax, ecx;//COMPARE EAX, ECX
xchg eax, ebx;//Restore EAX
je l_KeyUp

;//Toggle AttackState below:
mov ecx, 0x0
mov eax, VR2;//VR2 -> AttackState
sub eax, ecx;//COMPARE EAX, ECX
je l_SetToTrue

mov ebx, 0x0
mov eax, VR6;//VR6 => OFFSET_FORCE_ATTACK
mov DWORD PTR[eax],ebx;//*(BOOL*)dwForceAttack = FALSE;
mov eax, 0x0
mov VR2, eax;//VR2 -> AttackState = 0
jmp l_MainLoop

@l_SetToTrue:
mov ebx, 0x1
mov eax, VR6;//VR6 => OFFSET_FORCE_ATTACK
mov DWORD PTR[eax],ebx;//*(BOOL*)dwForceAttack = TRUE;
mov eax, 0x1
mov VR2, eax;//VR2 -> AttackState = 1
jmp l_MainLoop
;//////////////////////////////// Code End ////////////////////////////////

```

`README.md`:

```md
# ROP-COMPILER
ROP based CSGO, BF3, BF4 cheat

# What is ROP
The Wikipedia article about it describes it best:
> Return-oriented programming (ROP) is a computer security exploit technique that allows an attacker to execute code in the presence of security defenses such as executable space protection and code signing.[1]
>
> In this technique, an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine's memory, called "gadgets".[2] Each gadget typically ends in a return instruction and is located in a subroutine within the existing program and/or shared library code. Chained together, these gadgets allow an attacker to perform arbitrary operations on a machine employing defenses that thwart simpler attacks.

https://en.wikipedia.org/wiki/Return-oriented_programming

The TL;DR is that return-oriented programming (ROP) is a commonly used technique in exploitation to gain code execution<br />

look below at [Compiler output](https://github.com/Speedi13/ROP-COMPILER/blob/master/README.md#compiler-output)

# Why ROP
CSGO is protected by Valve Anti-Cheat (short VAC)<br />
BF3 and BF4 are protected by PunkBuster (short PB)<br />
ROP should be very difficult to detect for these Anti-Cheats for the following reasons<br />
- The cheats program code consists of a list of volatile memory addresses that change with each game and computer restart
- Afaik VAC prefers to analyze memory pages that are marked as executable but for ROP the list of return-addresses doesn't require to be on an executable memory page. 
- Additionally the ROP-Compiler supports the option of inserting random padding into the ROP-chain.
<br />
So hopefully this cheat will be VAC / PB undetected for ever :wink:<br />

# ROP-Code
- [BF3_MinimapESP.asm](https://github.com/Speedi13/ROP-COMPILER/blob/master/CheatSourceCodes/BF3_MinimapESP.asm)
- [BF4_x86_MinimapESP.asm](https://github.com/Speedi13/ROP-COMPILER/blob/master/CheatSourceCodes/BF4_x86_MinimapESP.asm)
- [CSGO_GlowESP.asm](https://github.com/Speedi13/ROP-COMPILER/blob/master/CheatSourceCodes/CSGO_GlowESP.asm)
- [CSGO_MinimapESP.asm](https://github.com/Speedi13/ROP-COMPILER/blob/master/CheatSourceCodes/CSGO_MinimapESP.asm)
- [CSGO_Triggerbot.asm](https://github.com/Speedi13/ROP-COMPILER/blob/master/CheatSourceCodes/CSGO_Triggerbot.asm)

You can download a compiled binary of the Rop-Compiler from here:<br />
[![DOWNLOAD BUTTON](https://www.unknowncheats.me/forum/ambience/buttons/download_file.gif)](https://www.unknowncheats.me/forum/downloads.php?do=file&id=27687)

For a look into the compiled code look below at [Compiler output](https://github.com/Speedi13/ROP-COMPILER/blob/master/README.md#compiler-output)

# Compiler
## Data-types
In computer science a [Word](https://en.wikipedia.org/wiki/Word_(computer_architecture))s size is determined by the maximal number of bits the processor can process <br />
But Intel and Microsoft define a word as a 16bit number: <br />

| Bits | Bytes | Datatype name |
|---|---|---|
| 16 | 2 | WORD |
| 32 | 4 | DWORD |
| 64 | 8 | QWORD |
| 64 | 8 | DWORD64 |

For all data-types check microsofts documentation:<br />
https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types <br />
## Accessible registers
### Native x86 registers
* EAX => ( Initialized to `GLOBAL_MinimumAddress` )
* ECX
* EDX
* EBX ( is also used by the compiler for jumps and writing to virtual registers )

### added virtual registers
* VR0 => ( Initialized to `GLOBAL_MinimumAddress` )
* VR1 => ( Initialized to random number )
* VR2 => ( Initialized to random number )
* VR3 => ( Initialized to `OFFSET_bSpotted` )
* VR4 => ( Initialized to `OFFSET_TeamNum` )
* VR5 => ( Initialized to `OFFSET_CrosshairId` )
* VR6 => ( Initialized to `OFFSET_FORCE_ATTACK` )
* VR7 => ( Initialized to `OFFSET_EntityList` )
* VR8 => ( Initialized to `OFFSET_LocalPlayer` )
* VR9 => ( Initialized to `OFFSET_GlowObjectManager` )

#### Read only register
* VMM => ( Initialized to the address of a 8192 Byte Read/Write memory page )

## Usable instructions
The instruction set is very limited and can be found in the [>>Gadgets.h<<](https://github.com/Speedi13/ROP-COMPILER/blob/master/RopCompiler/Gadgets.h) header <br />

### Compare two values
it's very rare to find a comparison instruction followed by a return, so I am using a trick:
```asm
;//if ( ECX != 0x28 ) goto l_skip
mov eax, 0x28
sub eax, ecx;//COMPARE EAX, ECX
jne l_skip
```
a substraction in x86 also effects the flags.<br />
so for example:
```asm
mov eax, 0x1
mov ecx, 0x1
sub eax, ecx
```
the ZeroFlag will be set to 1 by the substraction instruction.<br />

## Special instructions
#### Jump labels 
```asm
@l_LabelName:
```

#### Get address of jump label
```asm
mov ebx, @l_LabelName
```
#### Get address of Gadget
```asm
mov ebx, #xchg esp,ebx
```

#### Get address of API function
```asm
mov ebx, !user32.GetAsyncKeyState
```

#### Reading from Virtual Registers
```asm
mov ecx, VR8
```
<sub>the compiler will translate it to (each line a single gadget)</sub><br/>

```asm
xchg eax, ecx
pop eax ;//load virtual register address from stack
mov eax, DWORD PTR[eax]
xchg eax, ecx
```

#### Writing to Virtual Registers
```asm
mov VR8, ecx
```
<sub>note that ebx can't be written directly to a virtual register</sub><br/><br/>
<sub>the compiler will translate it to (each line a single gadget)</sub><br/>

```asm
xchg eax, ecx
pop ebx ;//load virtual register address from stack
mov DWORD PTR[ebx], eax
xchg eax, ecx
```

### Jumps
```asm
jne l_Start
```
note that a jump overwrites the ebx register!<br/>
look at the function `addJumpToRopChain` but basically its using a conditional move
```asm
mov ebx, @l_Start
cmovne esp,ebx
```
only that a conditional move directly to esp is very rare so it's utilizing exchange instructions to be able to use a more commonly used instruction like this: 
```asm
mov ebx, @l_Start
xchg ecx, ebx
mov eax, @l_continue543
cmovne eax,ecx
xchg ecx, ebx
xchg eax, ebp
@l_continue543:
```

## Compiler functions
| Execution order |         Function          | Description |
|---|---------------|---|
|1. | LoadFileToMemory | loads the raw assembly source-code file into memory |
|2. | GetCompilerSettings | searches for the compiler settings |
|3. | InitializeRopGadgets | depending on the compiler settings gadgets specified in the "Gadgets.h" header get searched |
|4. | BringYourOwnGadgets | the gadgets that didn't get found get placed into a with random data-filled buffer |
|5. | CompileCode | calls the four functions below |
|6. | => ReadInCode | the instructions get extracted from the source-code file and stored in the `InstructionCache` struct |
|7. | => ConvertToROP | builds the ROP-chain by retrieving the address of each instruction and adding it to the RopChain vector |
|8. | => HijackThreadStack | creates a new thread with `CreateRemoteThread` and overwrites the threads stack with the Rop-chain at a random position in the stack |
|9. | ==> RelocatingJumps | relocates all jump addresses to the address of the rop-chain in memory |
|10.| RemoveUnusedGadgets | removes not used gadgets from the gadget buffer created by the BringYourOwnGadgets function |
|11.| ResumeThread | starts the execution of the rop-chain |

## Compiler output
using the tool ReClass you can look inspect memory and look at the generated rop-chain<br />
### Raw thread stack
This is how the generated thread-stack (ROP-Chain) looks like:<br /><br />
![Image of rop-chain](https://github.com/Speedi13/ROP-COMPILER/blob/master/pictures/ROP_STACK_1.png)
### Thread stack with gadget code
Now on the right I added the assembler code that is at each address:<br /><br />
![Image of rop-chain](https://github.com/Speedi13/ROP-COMPILER/blob/master/pictures/ROP_STACK_2.png)
### Reclass
For a Tutorial on ReClass look at UC<br />
https://www.unknowncheats.me/forum/general-programming-and-reversing/120805-reclass-usuage-reclass-and-its-content.html

### ret instruction
the return instruction is essential for ROP.<br />
The CPU jumps ( by setting the InstructionPointer [on x86 EIP] ) to an address it reads from the stack<br />
to help understanding the instruction this how the CPU processes the `ret` instruction: 
```cpp
void Ret( )
{
	Eip = *(DWORD*)( Esp + 0x000000 );
	Esp = Esp + 4;
}
```

### pop instruction
gadgets for pop instructions are easy to find and can be used to set a register to a certain value <br />
to help understanding the instruction this how the CPU processes the `pop eax` instruction: <br />
```cpp
void PopEAX( )
{
	Eax = *(DWORD*)( Esp + 0x000000 );
	Esp = Esp + 4;
	Eip = Eip + 1;
}
```

### jumps in ROP
in ROP the stack pointer ESP becomes the instruction pointer so by changing it follwed by a return instruction a jump happens <br />
to do conditional jumps a conditional move instruction can be used:
```cpp
//Unsigned Conditional Jump
//  JE - JZ   - Equal/zero                  - ZF = 1
if ( memcmp( C, "je", 2 ) == 0 || memcmp( C, "jz", 2 ) == 0 )
{
	//"cmove esp,ebx"
	addJumpToRopChain( p, C, 2, "cmove" );
	continue;	
}
```
for unconditional jumps a `pop esp` or a `xchg esp, ebx` can be used<br />

Conditional jump instructions: [page: 184]<br />
https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf#G9.1746

Conditional Move Instructions: [page: 172]<br />
https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf#G9.17648

```

`RopCompiler.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RopCompiler", "RopCompiler\RopCompiler.vcxproj", "{06DE52BE-0E09-4819-B6DD-77E9BB14DFE0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{06DE52BE-0E09-4819-B6DD-77E9BB14DFE0}.Debug|Win32.ActiveCfg = Debug|Win32
		{06DE52BE-0E09-4819-B6DD-77E9BB14DFE0}.Debug|Win32.Build.0 = Debug|Win32
		{06DE52BE-0E09-4819-B6DD-77E9BB14DFE0}.Debug|Win32.Deploy.0 = Debug|Win32
		{06DE52BE-0E09-4819-B6DD-77E9BB14DFE0}.Release|Win32.ActiveCfg = Release|Win32
		{06DE52BE-0E09-4819-B6DD-77E9BB14DFE0}.Release|Win32.Build.0 = Release|Win32
		{06DE52BE-0E09-4819-B6DD-77E9BB14DFE0}.Release|Win32.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`RopCompiler/ASSERT.h`:

```h
#pragma once

#define __WIDE__TEXT(quote) L ## quote
#define __assert__(_Expression) (void)( (!!(_Expression)) || (AssertW(__WIDE__TEXT(#_Expression), __FILEW__, __LINE__), 0) )
#define __ASSERT__( _Expression ) __assert__( _Expression )

void __cdecl AssertW( const wchar_t * _Message, const wchar_t *_File, unsigned _Line);

```

`RopCompiler/Compiler.cpp`:

```cpp
#include <Windows.h>
#include "Util.h"
#include <vector>
#include "ASSERT.h"
#include "Compiler.h"
#include "RandomGenerator.h"
struct CompilerSettings g_CompilerSettings = {};

bool g_ConditionalMoveSupported = false;
bool g_HardwareRngSupported_RDRND = false;
bool g_HardwareRngSupported_RDSEED = false;

struct InstructionCache
{
    char CodeLineForDebugging[128];
    char CodeLine[128];
    int CodeLineIndex;
    bool IsFunctionStart;
    DWORD_PTR CodeOffset;
};
struct RelocationData
{
    struct InstructionCache* JumpTarget;
    DWORD_PTR JumpTargetIndex;
    DWORD_PTR CodeOffset;
};

typedef bool (*t_AdvancedInstructionHandler)( /*IN OUT*/ struct InstructionCache* IC );

std::vector<struct InstructionCache> Instructions;
std::vector<struct RelocationData> Relocations;
std::vector<DWORD_PTR> RopChain;

DWORD_PTR VirtualRegisterAddresses[10] = {};
DWORD_PTR VirtualMemoryRegisterAddresses = 0;

//Reads code to instruction cache vector
void ReadInCode( /*IN*/ const char* TextCode );

//main function: it translates instruction cache to return-address array
void ConvertToROP( /*IN*/ const HANDLE hGame );


void HijackThreadStack  ( /*IN*/ const HANDLE hGame, /*OUT*/ HANDLE* OutThreadHandle, /*OUT*/ DWORD_PTR* StackTable, /*OUT*/ DWORD_PTR* StackTableStart, /*OUT OPTIONAL*/DWORD* outStackTableSize = nullptr );
void CreateRopStack     ( /*IN*/ const HANDLE hGame, /*OUT*/ HANDLE* OutThreadHandle, /*OUT*/ DWORD_PTR* StackTable, /*OUT*/ DWORD_PTR* StackTableStart, /*OUT OPTIONAL*/DWORD* outStackTableSize = nullptr );

//Prints compilation debug info
void PrintDebugOutput( /*IN OPTIONAL*/ DWORD_PTR CallStackStartAddr = NULL );

/////////////////////////////////////////////// compiler utility functions ///////////////////////////////////////////////
/**/struct RopCode* FindMatchingRopGadget( /*IN*/ const char* C, /*IN OPTIONAL*/ bool f = false );                      //
/**/struct RopCode* FindMatchingRopGadgetByOpCode( /*IN*/ const char* C, /*IN*/ BYTE* Code, /*IN*/ BYTE CodeSize );     //
/**/struct InstructionCache* GetJumpTarget( const char* labelName );                                                    //
/**/void addJumpToRopChain( struct InstructionCache* IC, char* InstructionString, BYTE StringOffset, const char* Move );//
/**/bool mov_ptr_eax__ebx( struct InstructionCache* IC );                                                               //
/**/bool mov_byte_ptr__eax__ebx( struct InstructionCache* IC );                                                         //
/**/void RelocatingJumps( const DWORD_PTR RemoteStackTableStartPosition );                                              //
/**/void InsertObfuscationPadding( /*IN OPTIONAL*/ const struct InstructionCache* NextInstruction );                    //
/**/bool IsCodeLineComment(const char c);                                                                               //
/**/bool IsCodeLineEnd(const char c);                                                                                   //
/**/void CopyWithoutSpacesToLower( /*OUT*/ char* out, /*IN*/ const char* in, /*IN*/ const size_t len );                 //
/**/bool mov_ecx__eax( struct InstructionCache* IC );                                                                   //
/**/bool mov_ebx__ecx( struct InstructionCache* IC );                                                                   //
/**/bool mov_ebx__eax( struct InstructionCache* IC );                                                                   //
/**/bool mov_edx__eax( struct InstructionCache* IC );                                                                   //
/**/t_AdvancedInstructionHandler g_AdvancedInstructionHandler[] = {                                                     //
/**/    mov_ecx__eax,                                                                                                   //
/**/    mov_ebx__ecx,                                                                                                   // 
/**/    mov_ebx__eax,                                                                                                   //
/**/    mov_edx__eax,                                                                                                   //
/**/    mov_ptr_eax__ebx,                                                                                               //
/**/    mov_byte_ptr__eax__ebx, };                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define STACK_PADDING if ( g_CompilerSettings.UseRandomPadding == true ){ InsertObfuscationPadding( NULL ); };

void CompileCode( /*IN*/ const char* TextCode, /*IN*/ const HANDLE hGame, /*OUT*/ DWORD_PTR* StackTable, /*OUT*/ DWORD_PTR* StackTableStart, /*OUT OPTIONAL*/ HANDLE* OutThreadHandle )
{
    __ASSERT__( TextCode != NULL );
    __ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );
    __ASSERT__( StackTable != NULL );
    __ASSERT__( StackTableStart != NULL );

    ReadInCode( TextCode );
    ConvertToROP( hGame );

    if ( g_CompilerSettings.HijackThreadStack == true || OutThreadHandle != NULL )
    {
        //don't create our own stack, use the stack of the thread:
        HijackThreadStack( hGame, OutThreadHandle, StackTable, StackTableStart, NULL );
    }
    else
        CreateRopStack( hGame, OutThreadHandle, StackTable, StackTableStart, NULL );

    if ( g_CompilerSettings.PrintDebugOutput == true )
    {
        PrintDebugOutput( *(DWORD_PTR*)StackTableStart );
        system("pause");
    }
}

//main function: it translates instruction cache to return-address array
void ConvertToROP( /*IN*/ const HANDLE hGame )
{
    __ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );

    RopChain.clear();
    Relocations.clear();

    AllocateVirtualRegs(hGame);

    printf("[+] Building ROP-Chain\n");

    for (size_t i = 0; i < (size_t)(Instructions.size()); i++)
    {
        struct InstructionCache* p = &Instructions.at(i);
        if ( p->IsFunctionStart == true )
        {
            p->CodeOffset = (DWORD_PTR)RopChain.size();
            continue;
        }

        char* C = p->CodeLine;
        if ( C[0] == NULL )
            continue;

        RopCode* c = FindMatchingRopGadget( C, true );
        if ( c != NULL )
        {
            if ( g_CompilerSettings.UseRandomPadding == true )
                InsertObfuscationPadding( p );

            p->CodeOffset = (DWORD_PTR)(RopChain.size());
            RopChain.push_back( (DWORD_PTR)c->GetRandomAddress() ); c->RefCntr+=1;

            STACK_PADDING;
            continue;
        }
        else
        {
            //For the instructions below no gadgets are found so they get replaced using gadgets that got found
            const DWORD AdvancedInstructionHandlerSize = (DWORD)( (DWORD)sizeof(g_AdvancedInstructionHandler) / (DWORD)sizeof(t_AdvancedInstructionHandler) );
            bool InstructionHandled = false;
            for (DWORD w = 0; w < (DWORD)AdvancedInstructionHandlerSize; w++)
            {
                if ( g_AdvancedInstructionHandler[w]( p ) == true )
                {
                    InstructionHandled = true;
                    break;
                }
            }
            if ( InstructionHandled == true )
                continue;

            //mov???,???
            if ( C[0] == 'm' && C[1] == 'o' && C[2] == 'v' && C[6] == ',')
            {
                const Regs R = GetReg( &C[3] );
                if ( R <= REG_EDI )
                {
                    //mov R, ??
                    const Regs R2 = GetReg( &C[7] );
                    if ( R2 >= REG_VR0 && R2 <= REG_VMM )
                    {
                        if ( g_CompilerSettings.UseRandomPadding == true )
                            InsertObfuscationPadding( p );
                            
                        if ( R2 <= REG_VR9 )
                        {
                            //mov R, VirtualRegister
                            const BYTE VirtualRegisterIndex = (BYTE)R2 - (BYTE)REG_VR0;

                            char* RegName = RegToString( R );

                            char ExchangeCode[64] = {};
                            sprintf_s( ExchangeCode, "xchg eax, %s", RegName );

                            RopCode* ExchangeEAX_With_R1 = NULL;
                            if ( R != REG_EAX )
                                ExchangeEAX_With_R1 = FindMatchingRopGadget( ExchangeCode );
                            
                            RopCode* SetAddr = FindMatchingRopGadget( "pop eax" );
                            RopCode* ReadVR = FindMatchingRopGadget( "mov eax, DWORD PTR[eax]" );

                            p->CodeOffset = RopChain.size();
                            if ( ExchangeEAX_With_R1 != NULL )
                            {
                                RopChain.push_back( (DWORD_PTR)ExchangeEAX_With_R1->GetRandomAddress() ); ExchangeEAX_With_R1->RefCntr += 1;
                                STACK_PADDING;
                            }
                            RopChain.push_back( (DWORD_PTR)SetAddr->GetRandomAddress() ); SetAddr->RefCntr += 1;
                            RopChain.push_back( (DWORD_PTR)VirtualRegisterAddresses[VirtualRegisterIndex] );
                            STACK_PADDING;
                            RopChain.push_back( (DWORD_PTR)ReadVR->GetRandomAddress() ); ReadVR->RefCntr += 1;
                            STACK_PADDING;
                            if ( ExchangeEAX_With_R1 != NULL )
                            {
                                RopChain.push_back( (DWORD_PTR)ExchangeEAX_With_R1->GetRandomAddress() ); ExchangeEAX_With_R1->RefCntr += 1;
                                STACK_PADDING;
                            }
                            continue;
                        }
                        else 
                        if ( R2 == REG_VMM )
                        {
                            if ( g_CompilerSettings.UseRandomPadding == true )
                                InsertObfuscationPadding( p );

                            char* RegName = RegToString( R );

                            char ReadCode[64] = {};
                            sprintf_s( ReadCode, "pop %s\0", RegName );

                            RopCode* SetRegister = FindMatchingRopGadget( ReadCode );
                            if ( SetRegister == NULL )
                            {
                                printf("[%s] <%u> POP %s NOT FOUND!\n",__FUNCTION__, (UINT)p->CodeLineIndex+1,RegName);
                                system("pause");
                            }
                            else
                            {RopChain.push_back( (DWORD_PTR)SetRegister->GetRandomAddress() );SetRegister->RefCntr += 1;}
                            p->CodeOffset = (DWORD_PTR)RopChain.size() - 1;
                            const DWORD_PTR DwordPtr = (DWORD_PTR)VirtualMemoryRegisterAddresses;
                            RopChain.push_back( (DWORD_PTR)DwordPtr );

                            STACK_PADDING;
                            continue;
                        }
                    }
                    else
                    {
                        if ( C[7] == '@' )
                        {
                            //Get Address of label:
                            char* RegName = RegToString( R );

                            char ReadCode[64] = {};
                            sprintf_s( ReadCode, "pop %s\0", RegName );

                            RopCode* SetRegister = FindMatchingRopGadget( ReadCode );
                            if ( SetRegister == NULL )
                            {
                                printf("[%s] <%u> POP %s NOT FOUND!\n", __FUNCTION__, (UINT)p->CodeLineIndex+1,RegName);
                                system("pause");
                            }
                            else
                            {RopChain.push_back( (DWORD_PTR)SetRegister->GetRandomAddress() );SetRegister->RefCntr += 1;}
                            const DWORD_PTR DwordPtr = (DWORD_PTR)DummyJumpAddress;
                            RopChain.push_back( (DWORD_PTR)DwordPtr );
                            const DWORD CodeOffset = (DWORD)(RopChain.size()) - 1;
                            p->CodeOffset = (DWORD_PTR)( CodeOffset - 1 );

                            RelocationData RelocData = {};
                            ZeroMemory(&RelocData, sizeof(RelocationData) );
                            RelocData.JumpTargetIndex = NULL;
                            RelocData.CodeOffset = CodeOffset;
                            RelocData.JumpTarget = GetJumpTarget( &C[8] );
                            Relocations.push_back( RelocData );

                            STACK_PADDING;
                            continue;

                        }
                        else
                        if ( C[7] == '#' )
                        {
                            //get gadget-addr

                            RopCode* OpCodeAddr = FindMatchingRopGadget( &C[8] );
                            if ( OpCodeAddr == NULL )
                            {
                                printf("[ERROR] gadget not found! {%s}\n",p->CodeLineForDebugging);
                                system("pause");
                                DebugBreak();
                            }
                            else
                            {
                                char* RegName = RegToString( R );

                                char ReadCode[64] = {};
                                sprintf_s( ReadCode, "pop %s\0", RegName );

                                RopCode* SetRegister = FindMatchingRopGadget( ReadCode );
                                if ( SetRegister == NULL )
                                {
                                    printf("[%s] <%u> POP %s NOT FOUND!\n", __FUNCTION__,(UINT)p->CodeLineIndex+1,RegName);
                                    system("pause");
                                }
                                else
                                {RopChain.push_back( (DWORD_PTR)SetRegister->GetRandomAddress() ); SetRegister->RefCntr += 1;}
                                p->CodeOffset = (DWORD_PTR)RopChain.size() - 1;
                                const
                                DWORD_PTR DwordPtr = (DWORD_PTR)OpCodeAddr->GetRandomAddress(); OpCodeAddr->RefCntr += 1;
                                RopChain.push_back( (DWORD_PTR)DwordPtr );

                                STACK_PADDING;
                                continue;
                            }
                        }
                        else
                        if ( C[7] == '!' )
                        {
                            //get API
                            char DllName[64] = {};
                            ZeroMemory(DllName, sizeof(DllName) );

                            char* ExportName = strstr( &C[7],".");

                            DWORD_PTR DllNameSize = (char*)ExportName - (char*)&C[8];
                            memcpy( DllName, &C[8], DllNameSize );
                            DllName[DllNameSize+0] = '.';
                            DllName[DllNameSize+1] = 'd';
                            DllName[DllNameSize+2] = 'l';
                            DllName[DllNameSize+3] = 'l';
                            DllName[DllNameSize+4] = NULL;

                            DWORD_PTR ExportAddress = NULL;

                            ExportName = ExportName + 1;

                            if ( GetRemoteProcessModuleExportAddress( GetProcessId( hGame ), DllName, ExportName, &ExportAddress ) != true )
                            {
                                printf("[ERROR] API Dll [%s] or Export [%s] not found! {%s}\n", DllName, ExportName, p->CodeLineForDebugging );
                                system("pause");
                            }
                            
                            char* RegName = RegToString( R );

                            char ReadCode[64] = {};
                            sprintf_s( ReadCode, "pop %s\0", RegName );

                            RopCode* SetRegister = FindMatchingRopGadget( ReadCode );
                            if ( SetRegister == NULL )
                            {
                                printf("[%s] <%u> POP %s NOT FOUND!\n", __FUNCTION__,(UINT)p->CodeLineIndex+1,RegName);
                                system("pause");
                            }
                            else
                            {RopChain.push_back( (DWORD_PTR)SetRegister->GetRandomAddress() ); SetRegister->RefCntr += 1;}

                            p->CodeOffset = (DWORD_PTR)RopChain.size() - 1;

                            const
                            DWORD_PTR DwordPtr = (DWORD_PTR)ExportAddress;
                            RopChain.push_back( (DWORD_PTR)DwordPtr );

                            STACK_PADDING;
                            continue;

                        }
                        else
                        {
                        //mov R, Constant Number
                        DWORD64 Value64 = NULL;
                        size_t End = NULL;
                        if ( GetHeximalNumber( &C[7], &Value64, &End ) == false )
                             GetDecimalNumber( &C[7], &Value64, &End );
                        
                        if ( End > 0 )
                        {
                            if ( g_CompilerSettings.UseRandomPadding == true )
                                InsertObfuscationPadding( p );

                            char* RegName = RegToString( R );

                            char ReadCode[64] = {};
                            sprintf_s( ReadCode, "pop %s\0", RegName );

                            RopCode* SetRegister = FindMatchingRopGadget( ReadCode );
                            if ( SetRegister == NULL )
                            {
                                printf("[%s] <%u> POP %s NOT FOUND!\n", __FUNCTION__,(UINT)p->CodeLineIndex+1,RegName);
                                system("pause");
                                DebugBreak();
                            }
                            else
                            {
                                p->CodeOffset = (DWORD_PTR)RopChain.size();
                                RopChain.push_back( (DWORD_PTR)SetRegister->GetRandomAddress() ); SetRegister->RefCntr += 1;
                                const DWORD_PTR DwordPtr = (DWORD_PTR)Value64;
                                RopChain.push_back( (DWORD_PTR)DwordPtr );
                            }
                            STACK_PADDING;
                            continue;
                        }
                        }
                    }
                }
                if ( R >= REG_VR0 && R <= REG_VR9 )
                {
                    //mov VirtualRegister, R2

                    const BYTE VirtualRegisterIndex = (BYTE)R - (BYTE)REG_VR0;
                    const Regs R2 = GetReg( &C[7] );
                    if ( R2 >= REG_VR0 )
                    {
                        if ( R2 < REG_ERROR )
                            printf("[%s] ERROR: move from VirtualRegister to VirtualRegister directly not supported yet!\n{%s}\n", __FUNCTION__,p->CodeLineForDebugging);
                        else
                            printf("[%s] ERROR: move from value directly to VirtualRegister directly not supported yet!\n{%s}\n",__FUNCTION__,p->CodeLineForDebugging);
                        system("pause");
                        continue;
                    }
                    if ( R2 == REG_EBX )
                    {
                        printf("[%s] ERROR: EBX can not be written to a VirtualRegister!\n",__FUNCTION__);
                        system("pause");
                        continue;
                    }
                    if ( g_CompilerSettings.UseRandomPadding == true )
                        InsertObfuscationPadding( p );

                    char* RegName = RegToString( R2 );

                    char ExchangeCode[64] = {};
                    sprintf_s( ExchangeCode, "xchg eax, %s", RegName );

                    RopCode* ExchangeEAX_With_R2 = NULL;
                    if ( R2 != REG_EAX )
                        ExchangeEAX_With_R2 = FindMatchingRopGadget( ExchangeCode );

                    //mov DWORD PTR[ebx], eax; "\x89\x03\xC3"

                    RopCode* SetAddr = FindMatchingRopGadget( "pop ebx" );
                    RopCode* SetVR = FindMatchingRopGadget( "mov DWORD PTR[ebx], eax" );

                    p->CodeOffset = (DWORD_PTR)RopChain.size();
                    RopChain.push_back( (DWORD_PTR)SetAddr->GetRandomAddress() ); SetAddr->RefCntr += 1;
                    RopChain.push_back( (DWORD_PTR)VirtualRegisterAddresses[VirtualRegisterIndex] );
                    if ( ExchangeEAX_With_R2 != NULL )
                    {
                        RopChain.push_back( (DWORD_PTR)ExchangeEAX_With_R2->GetRandomAddress() ); ExchangeEAX_With_R2->RefCntr += 1;
                        STACK_PADDING;
                    }
                    STACK_PADDING;
                    RopChain.push_back( (DWORD_PTR)SetVR->GetRandomAddress() ); SetVR->RefCntr += 1;
                    STACK_PADDING;
                    if ( ExchangeEAX_With_R2 != NULL )
                    {
                        RopChain.push_back( (DWORD_PTR)ExchangeEAX_With_R2->GetRandomAddress() ); ExchangeEAX_With_R2->RefCntr += 1;
                        STACK_PADDING;
                    }
                    continue;
                }
            }
            
            //Unsigned Conditional Jumps
            //  JA - JNBE - Above/not below or equal    - (CF or ZF) = 0 
            //  JAE - JNB - Above or equal/not below    - CF = 0
            //  JB - JNAE - Below/not above or equal    - CF = 1
            //  JBE - JNA - Below or equal/not above    - (CF or ZF) = 1
            //  JC        - Carry                       - CF = 1
            //  JE - JZ   - Equal/zero                  - ZF = 1
            //  JNC       - Not carry                   - CF = 0
            //  JNE - JNZ - Not equal/not zero          - ZF = 0
            //  JNP - JPO - Not parity/parity odd       - PF = 0
            //  JP - JPE  - Parity/parity even          - PF = 1
            //  JCXZ      - Register CX is zero         - CX = 0
            //  JECXZ     - Register ECX is zero        - ECX = 0

            //Signed Conditional Jumps
            //  JG/JNLE -   Greater/not less or equal   - ((SF xor OF) or ZF) = 0
            //  JGE/JNL -   Greater or equal/not less   - (SF xor OF) = 0
            //  JL/JNGE -   Less/not greater or equal   - (SF xor OF) = 1
            //  JLE/JNG -   Less or equal/not greater   - ((SF xor OF) or ZF) = 1
            //  JO      -   Overflow                    - OF = 1
            //  JNO     -   Not overflow                - OF = 0
            //  JS      -   Sign (negative)             - SF = 1
            //  JNS     -   Not sign (non-negative)     - SF = 0
            
            //Unsigned Conditional Jumps
            //  JCXZ      - Register CX is zero         - CX = 0
            if ( memcmp( C, "jcxz", 4 ) == 0 || memcmp( C, "jecxz", 5 ) == 0 )
            {
                printf("ERROR UNSUPPORTED JUMP! [%s]\n",C);
                system("pause");
                continue;
            }

            //Signed Conditional Jumps
            //  JG/JNLE -   Greater/not less or equal   - ((SF xor OF) or ZF) = 0
            if ( memcmp( C, "jnle", 4 ) == 0 )
            {
                printf("ERROR UNSUPPORTED JUMP! {3} [%s]\n",C);
                system("pause");
                continue;
            }

            //Signed Conditional Jumps
            //  JGE/JNL -   Greater or equal/not less   - (SF xor OF) = 0
            if ( memcmp( C, "jge", 3 ) == 0 || memcmp( C, "jnl", 3 ) == 0 )
            {
                //RopCode* SetESP = FindMatchingRopGadget( "CMOVGE esp,ebx" );
                addJumpToRopChain( p, C, 3, "CMOVGE" ); 
                continue;
            }
            
            //Signed Conditional Jumps
            //  JG/JNLE -   Greater/not less or equal   - ((SF xor OF) or ZF) = 0
            if ( memcmp( C, "jg", 2 ) == 0 )
            {
                printf("ERROR UNSUPPORTED JUMP! {2} [%s]\n",C);
                system("pause");
                continue;
            }

            //Unsigned Conditional Jumps
            //  JA - JNBE - Above/not below or equal    - (CF or ZF) = 0 
            if ( memcmp( C, "jnbe", 4 ) == 0 )
            {
                //RopCode* SetESP = FindMatchingRopGadget( "CMOVA esp,ebx" );
                addJumpToRopChain( p, C, 4, "CMOVA" );
                continue;
            }

            //Unsigned Conditional Jumps
            //  JAE - JNB - Above or equal/not below    - CF = 0
            if ( memcmp( C, "jae", 3 ) == 0 || memcmp( C, "jnb", 3 ) == 0 )
            {
                //RopCode* SetESP = FindMatchingRopGadget( "CMOVAE esp,ebx" );
                addJumpToRopChain( p, C, 3, "CMOVAE" );
                continue;
            }

            //Unsigned Conditional Jumps
            //  JA - JNBE - Above/not below or equal    - (CF or ZF) = 0 
            if ( memcmp( C, "ja", 2 ) == 0 )
            {
                //RopCode* SetESP = FindMatchingRopGadget( "CMOVA esp,ebx" );
                addJumpToRopChain( p, C, 2, "CMOVA" );
                continue;
            }
            
            //Unsigned Conditional Jumps
            //  JB - JNAE - Below/not above or equal    - CF = 1
            if ( memcmp( C, "jnae", 4 ) == 0 )
            {
                //RopCode* SetESP = FindMatchingRopGadget( "CMOVB esp,ebx" );
                addJumpToRopChain( p, C, 4, "CMOVB" );
                continue;
            }
            

            //Unsigned Conditional Jumps
            //  JBE - JNA - Below or equal/not above    - (CF or ZF) = 1
            if ( memcmp( C, "jbe", 3 ) == 0 || memcmp( C, "jna", 3 ) == 0 )
            {
                //RopCode* SetESP = FindMatchingRopGadget( "CMOVBE esp,ebx" );
                addJumpToRopChain( p, C, 3, "CMOVBE" );
                continue;
            }

            //Unsigned Conditional Jumps
            //  JB - JNAE - Below/not above or equal    - CF = 1
            if ( memcmp( C, "jb", 2 ) == 0 )
            {
                //RopCode* SetESP = FindMatchingRopGadget( "CMOVB esp,ebx" );
                addJumpToRopChain( p, C, 2, "CMOVB" );
                continue;
            }
            

            //Unsigned Conditional Jumps
            //  JC        - Carry                       - CF = 1
            if ( memcmp( C, "jc", 2 ) == 0 )
            {
                //RopCode* SetESP = FindMatchingRopGadget( "CMOVC esp,ebx" );
                addJumpToRopChain( p, C, 2, "CMOVC" );
                continue;
            }

            //Unsigned Conditional Jumps
            //  JE - JZ   - Equal/zero                  - ZF = 1
            if ( memcmp( C, "je", 2 ) == 0 || memcmp( C, "jz", 2 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "cmove esp,ebx" );
                addJumpToRopChain( p, C, 2, "cmove" );
                continue;
                
            }
            
            //Unsigned Conditional Jumps
            //  JNE - JNZ - Not equal/not zero          - ZF = 0
            if ( memcmp( C, "jne", 3 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "cmovne esp,ebx" );
                addJumpToRopChain( p, C, 3, "cmovne" );
                continue;
                
            }
            if ( memcmp( C, "jnz", 3 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "cmovne esp,ebx" );
                addJumpToRopChain( p, C, 3, "cmovne" );
                continue;
            }

            //Unsigned Conditional Jumps
            //  JNC       - Not carry                   - CF = 0
            if ( memcmp( C, "jnc", 3 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVNC esp,ebx" );
                addJumpToRopChain( p, C, 3, "CMOVNC" );
                continue;
            }

            //Unsigned Conditional Jumps
            //  JNP - JPO - Not parity/parity odd       - PF = 0
            if ( memcmp( C, "jnp", 3 ) == 0 || memcmp( C, "jpo", 3 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVNP esp,ebx" );
                addJumpToRopChain( p, C, 3, "CMOVNP" );
                continue;
            }

            //Unsigned Conditional Jumps
            //  JP - JPE  - Parity/parity even          - PF = 1
            if ( memcmp( C, "jpe", 3 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVP esp,ebx" );
                addJumpToRopChain( p, C, 3, "CMOVP" );
                continue;
            }
            if ( memcmp( C, "jp", 2 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVP esp,ebx" );
                addJumpToRopChain( p, C, 2, "CMOVP" );
                continue;
            }
            
            //Signed Conditional Jumps
            //  JL/JNGE -   Less/not greater or equal   - (SF xor OF) = 1
            if ( memcmp( C, "jnge", 4 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVL esp,ebx" );
                addJumpToRopChain( p, C, 4, "CMOVL" );
                continue;
            }

            //Signed Conditional Jumps
            //  JLE/JNG -   Less or equal/not greater   - ((SF xor OF) or ZF) = 1
            if ( memcmp( C, "jle", 3 ) == 0 || memcmp( C, "jng", 3 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVLE esp,ebx" );
                addJumpToRopChain( p, C, 3, "CMOVLE" );
                continue;
            }           

            //Signed Conditional Jumps
            //  JL/JNGE -   Less/not greater or equal   - (SF xor OF) = 1
            if ( memcmp( C, "jl", 2 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVL esp,ebx" );
                addJumpToRopChain( p, C, 2, "CMOVL" );
                continue;
            }
            

            //Signed Conditional Jumps
            //  JO      -   Overflow                    - OF = 1
            if ( memcmp( C, "jo", 2 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVO esp,ebx" );
                addJumpToRopChain( p, C, 2, "CMOVO" );
                continue;
            }
            //Signed Conditional Jumps
            //  JNO     -   Not overflow                - OF = 0
            if ( memcmp( C, "jno", 3 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVNO esp,ebx" );
                addJumpToRopChain( p, C, 3, "CMOVNO" );
                continue;
            }

            //Signed Conditional Jumps
            //  JS      -   Sign (negative)             - SF = 1
            if ( memcmp( C, "js", 2 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "cmovs esp,ebx" );
                addJumpToRopChain( p, C, 2, "cmovs" );
                continue;
            }
            //Signed Conditional Jumps
            //  JNS     -   Not sign (non-negative)     - SF = 0
            if ( memcmp( C, "jns", 3 ) == 0 )
            {
                //struct RopCode* SetESP = FindMatchingRopGadget( "CMOVNS esp,ebx" );
                addJumpToRopChain( p, C, 3, "CMOVNS" );
                continue;
            }
            //JUMP
            if ( memcmp( C, "jmp", 3 ) == 0 )
            {
                const DWORD_PTR JmpToAddress = DummyJumpAddress;
                //pop    esp
                struct RopCode* SetAddr = FindMatchingRopGadget( "pop esp" );

                RopChain.push_back( (DWORD_PTR)SetAddr->GetRandomAddress() );
                RopChain.push_back( JmpToAddress );
                const DWORD CodeOffset = (DWORD)(RopChain.size()) - 1;
                struct RelocationData RelocData = {};
                ZeroMemory(&RelocData, sizeof(RelocationData) );
                RelocData.JumpTargetIndex = NULL;
                RelocData.CodeOffset = CodeOffset;
                RelocData.JumpTarget = GetJumpTarget( &C[3] );
                p->CodeOffset = (DWORD_PTR)( CodeOffset - 1 );
                Relocations.push_back( RelocData );

                STACK_PADDING;
                continue;
            }
        }
        printf("ERROR: UNKNOWN INSTRUCTION at LINE:%u [%s]{%s}!\n", (UINT)p->CodeLineIndex + 1, p->CodeLine, p->CodeLineForDebugging );
        system("pause");
    }

    printf("[+] ROP-Chain compiled!\n");
}

void HijackThreadStack  ( /*IN*/ const HANDLE hGame, /*OUT*/ HANDLE* OutThreadHandle, /*OUT*/ DWORD_PTR* StackTable, /*OUT*/ DWORD_PTR* StackTableStart, /*OUT OPTIONAL*/ DWORD* outStackTableSize )
{
    __ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );
    __ASSERT__( OutThreadHandle != NULL );
    __ASSERT__( StackTable != NULL );
    __ASSERT__( StackTableStart != NULL );

    if ( g_CompilerSettings.HijackThreadStack != true || OutThreadHandle == NULL )
    {
        printf("ERROR: don't call the function HijackThreadStack!!!\n");
        system("pause");
        return CreateRopStack( hGame, OutThreadHandle, StackTable, StackTableStart, outStackTableSize );
    }

    //printf("[+] preparing thread hijacking\n");

    /////////////////////////////////////// WINDOWS STRUCTS ///////////////////////////////////////
    //https://processhacker.sourceforge.io/doc/ntpebteb_8h_source.html#l00166
    struct TEB
    {
        NT_TIB NtTib; //=> winnt.h
        PVOID EnvironmentPointer;
        HANDLE ClientId[2];
        PVOID ActiveRpcHandle;
        PVOID ThreadLocalStoragePointer;
        struct PEB* ProcessEnvironmentBlock;
        //...
    };

    //https://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html#l00700
    typedef struct _THREAD_BASIC_INFORMATION
    {
        NTSTATUS ExitStatus;
        TEB* TebBaseAddress;
        HANDLE ClientId[2];
        ULONG_PTR AffinityMask;
        LONG Priority;
        LONG BasePriority;
    } THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;
    ///////////////////////////////////////////////////////////////////////////////////////////////
    static
    NTSTATUS (__stdcall* fncNtQueryInformationThread)(
      IN HANDLE         ThreadHandle,
      IN UINT           ThreadInformationClass,
      OUT PVOID         ThreadInformation,
      IN ULONG          ThreadInformationLength,
      OUT PULONG        ReturnLength
    ) = NULL;

    if ( fncNtQueryInformationThread == NULL )
    {
        HMODULE hNtDll = GetModuleHandleW( L"ntdll.dll" );
        if ( hNtDll == NULL )
             hNtDll = LoadLibraryW( L"ntdll.dll" );

        void* Function = GetProcAddress( hNtDll, "NtQueryInformationThread" );
        if ( Function == NULL )
             Function = GetProcAddress( hNtDll, "ZwQueryInformationThread" );

         fncNtQueryInformationThread = (decltype(fncNtQueryInformationThread))Function;
    }

    DWORD ThreadResultAddress = NULL;
    DWORD ThreadResultValue = NULL;

    //////////////////////////////////// Setup Thread shellcode ///////////////////////////////////
    BYTE* RemoteShellCodeBuffer = (BYTE*)VirtualAllocEx( hGame, NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );
    if ( RemoteShellCodeBuffer == NULL )
    {
        printf("[%s] ERROR FAILED TO ALLOCATE THREAD STARTUP CODE [0x%X]\n", __FUNCTION__,GetLastError() );
        system("pause");
    }

    BYTE* LocalShellCodeBuffer = (BYTE*)malloc( 0x1000 );
    __ASSERT__( LocalShellCodeBuffer != NULL );

    g_RandomGenerator.GetBuffer( LocalShellCodeBuffer, 0x1000 );

    BYTE ByteCode[] = { 0xC7, 0x05, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, //mov DWORD PTR[0x8],1
                        0xEB, 0xFE, //jmp to itself, endless loop
                      };
    

    DWORD RandomStartOffset = g_RandomGenerator.GetDword() % ( 0x1000ui32 - 0x20ui32 );

    if ( RandomStartOffset < 0x20 )
         RandomStartOffset += 0x20;

    ThreadResultAddress = (DWORD)( (DWORD_PTR)RemoteShellCodeBuffer + (DWORD_PTR)RandomStartOffset - (DWORD_PTR)0x10ui32 );
    ThreadResultValue = g_RandomGenerator.GetDword();

    *(DWORD*)&ByteCode[ 2 ] = ThreadResultAddress;
    *(DWORD*)&ByteCode[ 6 ] = ThreadResultValue;
    memcpy( (void*)( LocalShellCodeBuffer + RandomStartOffset ), ByteCode, ARRAYSIZE(ByteCode) );

    const BOOL bWriteThreadStartCode = 
    WriteProcessMemory( hGame, RemoteShellCodeBuffer, LocalShellCodeBuffer, 0x1000, NULL );
    if ( bWriteThreadStartCode != TRUE )
    {
        printf("[%s] ERROR WRITING THREAD STARTUP CODE [0x%X]\n",__FUNCTION__,GetLastError());
        system("pause");
    }

    free( LocalShellCodeBuffer ); LocalShellCodeBuffer = NULL;
    ///////////////////////////////////////////////////////////////////////////////////////////////

    printf("[+] Creating Rop-Chain Thread\n");

    
    const DWORD RopChainSize = (DWORD)( (DWORD)(RopChain.size()) * sizeof(DWORD_PTR) );
    
    const DWORD StackTableStartOffset = (DWORD)((g_RandomGenerator.GetDword() % (0x6001ui32)) & (DWORD)0xFFFFFFFCui32) + (DWORD)0x4000ui32;

    const DWORD RandomSize = RopChainSize + StackTableStartOffset + (DWORD)0x1000ui32 + (DWORD)(g_RandomGenerator.GetDword() % (DWORD)(0x8001ui32) );
    DWORD RandomStackSize = (RandomSize / (DWORD)0x1000ui32) * (DWORD)0x1000ui32;
    if ( (DWORD)( RandomStackSize % (DWORD)0x1000ui32 ) != NULL )
        RandomStackSize += (DWORD)0x1000ui32;
    
    DWORD ThreadId = 0;
    HANDLE hThreadHandle = CreateRemoteThread( hGame, NULL, RandomStackSize, (LPTHREAD_START_ROUTINE)( RemoteShellCodeBuffer + RandomStartOffset ), (LPVOID)StackTableStart, NULL, &ThreadId );
    if ( hThreadHandle == NULL || hThreadHandle == INVALID_HANDLE_VALUE || ThreadId == 0 )
    {
        printf("ERROR in [%s] CreateRemoteThread: Error:[0x%X] Handle:0x%p ThreadId:0x%X\n", __FUNCTION__, GetLastError(), hThreadHandle, ThreadId );
        ThreadId = 0;
        hThreadHandle = INVALID_HANDLE_VALUE;
        system("pause");
    }
    else
        printf("[+]=> Thread %u started\n",ThreadId);
    
    ///////////////////////////// WAIT FOR THREAD TO REACH SHELLCODE //////////////////////////////
    DWORD Value = 0;
    do
    {
        Value = 0;
        Sleep( 1000 );
        ZeroMemory( (void*)&Value, sizeof(DWORD) );
        ReadProcessMemory( hGame, (LPCVOID)ThreadResultAddress, &Value, sizeof(DWORD), NULL );

    } while ( Value != ThreadResultValue );
    ///////////////////////////////////////////////////////////////////////////////////////////////
    const
    DWORD ThreadSuspendCount = SuspendThread( hThreadHandle );
    if ( ThreadSuspendCount == (DWORD)0xFFFFFFFFui32 )
    {
        printf("[%s] ERROR SuspendThread failed: 0x%X\n", __FUNCTION__, GetLastError());
        system("pause");
    }
    VirtualFreeEx( hGame, RemoteShellCodeBuffer, NULL, MEM_RELEASE );

    //////////////////////////////// GET THREAD STACK INFORMATION /////////////////////////////////
    THREAD_BASIC_INFORMATION ThreadBasicInfo = {};
    ZeroMemory( &ThreadBasicInfo, sizeof(THREAD_BASIC_INFORMATION) );

    ULONG StructSize = 0;
    const NTSTATUS NtStatus =
    fncNtQueryInformationThread( hThreadHandle,
                                0,//=> ThreadInformationBasic
                                &ThreadBasicInfo,
                                sizeof(THREAD_BASIC_INFORMATION),
                                &StructSize );
    if ( NtStatus != (NTSTATUS)(0x00000000l) || StructSize != sizeof(THREAD_BASIC_INFORMATION) )
    {
        printf("[%s] NtQueryInformationThread failed with 0x%X\n", __FUNCTION__ ,NtStatus);
        system("pause");
    }

    void* ThreadEnvironmentBlockAddress = ThreadBasicInfo.TebBaseAddress;
    if ( ThreadEnvironmentBlockAddress == NULL )
    {
        printf("[%s] Failed to retrieve ThreadEnvironmentBlock address!\n", __FUNCTION__);
        system("pause");
    }

    TEB ThreadEnvironmentBlock = {};
    ZeroMemory( &ThreadEnvironmentBlock, sizeof(TEB) );

    const BOOL bTebRead =
    ReadProcessMemory( hGame, (LPCVOID)ThreadEnvironmentBlockAddress, &ThreadEnvironmentBlock, sizeof(TEB), NULL );
    if ( bTebRead != TRUE )
    {
        printf("[%s] FAILED TO READ THREAD TEB [0x%X]\n", __FUNCTION__, GetLastError() );
        system("pause");
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////

    const NT_TIB* ThreadInformationBlock = &ThreadEnvironmentBlock.NtTib;

    const DWORD_PTR StackBufferEnd   = (DWORD_PTR)ThreadInformationBlock->StackBase;
    const DWORD_PTR StackBufferStart = (DWORD_PTR)ThreadInformationBlock->StackLimit;
    if ( StackBufferEnd == NULL || StackBufferStart == NULL )
    {
        printf("[%s] FAILED TO ACCESS THREAD STACK INFORMATION\n", __FUNCTION__);
        system("pause");
    }

    const DWORD_PTR ThreadStackSize = StackBufferEnd - StackBufferStart - (DWORD_PTR)(0x1000);


    printf("[+]=> Thread Stack Address:[0x%p] Size:[0x%X]\n", (PVOID)StackBufferStart, ThreadStackSize );
    
    DWORD_PTR* LocalStackTable = (DWORD_PTR*)malloc( ThreadStackSize + (DWORD_PTR)0x1000 );
    __ASSERT__( LocalStackTable != NULL );

    DWORD_PTR* WriteToTablePtr = (DWORD_PTR*)( (DWORD_PTR)LocalStackTable + StackTableStartOffset );
    g_RandomGenerator.GetBuffer( LocalStackTable, (DWORD)ThreadStackSize );

    
    ///////////////////////////////////////// Relocation //////////////////////////////////////////

    RelocatingJumps( (DWORD_PTR)StackBufferStart + (DWORD_PTR)StackTableStartOffset );

    ///////////////////////////////////////////////////////////////////////////////////////////////


    DWORD_PTR StackTablePos = NULL;
    for (size_t j = NULL; j < (size_t)RopChain.size(); j++)
        WriteToTablePtr[ StackTablePos++ ] = (DWORD_PTR)RopChain.at(j);

    printf("[+] Compiled to RemoteStackTable: [0x%p] Size: [0x%X]\n", (PVOID)StackBufferStart, (DWORD)( (DWORD_PTR)StackTablePos * (DWORD_PTR)sizeof(DWORD_PTR) ) );
    BOOL bWriteDataToStack = FALSE;
    SIZE_T NumberOfBytesWritten = (SIZE_T)NULL;
    DWORD_PTR w = (DWORD_PTR)NULL;
    for ( ; w < ThreadStackSize; w += (DWORD_PTR)(0x1000) )
    {
        LPVOID RemotePageAddress = (LPVOID)( (DWORD_PTR)StackBufferStart + (DWORD_PTR)w );
        LPVOID LocalPageAddress  = (LPVOID)( (DWORD_PTR)LocalStackTable  + (DWORD_PTR)w );

        //Impossible but visual studio complains xD
        if ( RemotePageAddress == NULL || LocalPageAddress == NULL )
        {
            bWriteDataToStack = FALSE;
            break;
        }

        bWriteDataToStack = 
        WriteProcessMemory( hGame, RemotePageAddress, LocalPageAddress, 0x1000, &NumberOfBytesWritten );
        if ( bWriteDataToStack != TRUE || NumberOfBytesWritten != 0x1000 ) break;
    }
    

    if ( bWriteDataToStack != TRUE )
    {
        printf("[%s] FAILED TO WRITE THREAD STACK [0x%X] offset:[0x%X] written:[0x%X]\n",__FUNCTION__,GetLastError(),w,NumberOfBytesWritten);
        system("pause");
    }
    
    //////////////////////////////////// SETUP THREAD CONTEXT /////////////////////////////////////
    CONTEXT ThreadContext = {};
    ZeroMemory( &ThreadContext, sizeof(CONTEXT) );

    ThreadContext.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;

    const BOOL bGetThreadContext = 
    GetThreadContext( hThreadHandle, &ThreadContext );
    if ( bGetThreadContext != TRUE )
    {
        printf("[%s] FAILED TO ACCESS THREAD CONTEXT [0x%X]\n", __FUNCTION__, GetLastError() );
        system("pause");
    }

    ThreadContext.Eax = (StackBufferStart + StackTableStartOffset) - ((DWORD_PTR)0x2A00 + (DWORD_PTR)( ( g_RandomGenerator.GetDword() % 0x400ui32 ) & 0xFFFFFFFC ));
    ThreadContext.Esp = StackBufferStart + (DWORD_PTR)StackTableStartOffset + (DWORD_PTR)sizeof(DWORD_PTR);
    ThreadContext.Eip = WriteToTablePtr[0];

    if ( ThreadContext.Eip == NULL )
    {
        printf("[%s] FIRST TREAD GADGET IS NULL-POINTER\n", __FUNCTION__ );
        system("pause");
    }

    const BOOL bSetThreadContext = 
    SetThreadContext( hThreadHandle, &ThreadContext );

    if ( bSetThreadContext != TRUE )
    {
        printf("[%s] FAILED TO SET THREAD CONTEXT [0x%X]\n", __FUNCTION__,GetLastError());
        system("pause");
    }
    ZeroMemory( &ThreadContext, sizeof(CONTEXT) );
    ///////////////////////////////////////////////////////////////////////////////////////////////


    *(DWORD_PTR*)StackTable = (DWORD_PTR)StackBufferStart;
    *(DWORD_PTR*)StackTableStart = (DWORD_PTR)StackBufferStart + (DWORD_PTR)StackTableStartOffset;
    if ( outStackTableSize != NULL )
         *(DWORD*)outStackTableSize = (DWORD)ThreadStackSize;
    *OutThreadHandle = hThreadHandle;

    free( LocalStackTable ); LocalStackTable = NULL;
}

void CreateRopStack     ( /*IN*/ const HANDLE hGame, /*OUT*/ HANDLE* OutThreadHandle, /*OUT*/ DWORD_PTR* StackTable, /*OUT*/ DWORD_PTR* StackTableStart, /*OUT OPTIONAL*/ DWORD* outStackTableSize )
{
    __ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );
    __ASSERT__( OutThreadHandle != NULL );
    __ASSERT__( StackTable != NULL );
    __ASSERT__( StackTableStart != NULL );

    if ( g_CompilerSettings.HijackThreadStack == true || OutThreadHandle != NULL )
    {
        //don't create our own stack, use the stack of the thread:
        return HijackThreadStack( hGame, OutThreadHandle, StackTable, StackTableStart, outStackTableSize );
    }

    const DWORD StackTableStartOffset = (g_RandomGenerator.GetDword() % (0x3001ui32)) & 0xFFFFFFFC;
    const DWORD RopChainSize = (DWORD)( (DWORD)(RopChain.size()) * sizeof(DWORD_PTR) );

    //Creating our own stack, but it might be a potential detection vector!
    const DWORD RandomSize = RopChainSize + (DWORD)0x1200ui32 + (g_RandomGenerator.GetDword() % (0x6001ui32)) + StackTableStartOffset;
    DWORD StackTableSize = (RandomSize / (DWORD)0x1000ui32) * (DWORD)0x1000ui32;
    if ( (DWORD)( StackTableSize % (DWORD)0x1000ui32 ) != NULL )
        StackTableSize += (DWORD)0x1000ui32;

    
    
    DWORD RandomFlags[] = { PAGE_READWRITE, PAGE_EXECUTE_READWRITE };
    const DWORD ProtectionFlags = *(DWORD*)SelectRandomElement( RandomFlags, getArraySize( RandomFlags, DWORD ), sizeof(DWORD) );
    

    const DWORD_PTR RemoteStackTable = (DWORD_PTR)VirtualAllocEx( hGame, 0, StackTableSize, MEM_COMMIT | MEM_RESERVE, ProtectionFlags );
    if ( RemoteStackTable == NULL )
    {
        printf("[%s] ERROR FAILED TO ALLOCATE REMOTE STACK TABLE [0x%X]\n", __FUNCTION__, GetLastError() );
        system("pause");
    }

    DWORD_PTR* LocalStackTable = (DWORD_PTR*)malloc( StackTableSize );
    __ASSERT__( LocalStackTable != NULL );

    DWORD_PTR* WriteToTablePtr = (DWORD_PTR*)( (DWORD_PTR)LocalStackTable + (DWORD_PTR)StackTableStartOffset );
    __ASSERT__( WriteToTablePtr != NULL );

    g_RandomGenerator.GetBuffer( LocalStackTable, StackTableSize );

    ///////////////////////////////// Relocation /////////////////////////////////

    RelocatingJumps( (DWORD_PTR)RemoteStackTable + (DWORD_PTR)StackTableStartOffset );

    //////////////////////////////////////////////////////////////////////////////

    DWORD StackTablePos = NULL;
    for (size_t j = NULL; j < (size_t)RopChain.size(); j++)
    {
        const DWORD_PTR Value = (DWORD_PTR)RopChain.at(j);
        WriteToTablePtr[ StackTablePos++ ] = Value;
    }

    printf("[+] Compiled to RemoteStackTable: [0x%p] Size: [0x%X]\n", (PVOID)RemoteStackTable, (StackTablePos*sizeof(DWORD_PTR)));
    WriteProcessMemory( hGame, (LPVOID)RemoteStackTable, LocalStackTable, StackTableSize, NULL );
    free( LocalStackTable );

    DWORD NewRandomFlags[] = {  PAGE_READONLY, 
                                PAGE_READWRITE, 
                                PAGE_WRITECOPY, 
                                PAGE_EXECUTE, 
                                PAGE_EXECUTE_READ, 
                                PAGE_EXECUTE_READWRITE, 
                                PAGE_EXECUTE_WRITECOPY };

    DWORD NewProtectionFlags = *(DWORD*)SelectRandomElement( NewRandomFlags, getArraySize( NewRandomFlags, DWORD ), sizeof(DWORD) );
    
    DWORD OldProtection = NULL;
    VirtualProtectEx( hGame, (LPVOID)RemoteStackTable, StackTableSize, NewProtectionFlags, &OldProtection );

    for (DWORD Counter = NULL; Counter < (DWORD)( StackTableSize / (DWORD)0x1000ui32 ); Counter++)
    {
        NewProtectionFlags = *(DWORD*)SelectRandomElement( NewRandomFlags, getArraySize( NewRandomFlags, DWORD ), sizeof(DWORD) );
        OldProtection = NULL;
        VirtualProtectEx( hGame, (BYTE*)RemoteStackTable + (DWORD)(Counter * (DWORD)0x1000ui32), (SIZE_T)0x1000, NewProtectionFlags, &OldProtection );
    }

    *(DWORD_PTR*)StackTable = (DWORD_PTR)RemoteStackTable;
    *(DWORD_PTR*)StackTableStart = (DWORD_PTR)RemoteStackTable + (DWORD_PTR)StackTableStartOffset;
    if ( outStackTableSize != NULL )
         *(DWORD*)outStackTableSize = (DWORD)StackTableSize;
}

//Reads code to instruction cache vector
void ReadInCode( /*IN*/ const char* TextCode )
{
    __ASSERT__( TextCode != NULL );

    Instructions.clear();

    printf("[+] Reading code...\n");

    char CodeLine[128] = {};
    ZeroMemory(CodeLine, sizeof(CodeLine) );

    int CodeLineI = 0;
    int CodeLineCntr = 0;
    for (size_t i = NULL; i < (size_t)strlen(TextCode)+1; i++)
    {
        if ( CodeLineI > 127 ) CodeLineI = 127;
        CodeLine[CodeLineI] = TextCode[i];
        if ( IsCodeLineEnd( TextCode[i] ) == true || IsCodeLineComment( TextCode[i] ) == true )         
        {
            CodeLine[CodeLineI] = 0;

            InstructionCache I = {};
            ZeroMemory(&I, sizeof(InstructionCache) );
            
            CopyWithoutSpacesToLower( I.CodeLine, CodeLine, CodeLineI+1 );
            const size_t len = strlen(I.CodeLine);
            if ( len > 2 )
            {
                I.CodeLineIndex = CodeLineCntr++;
                memcpy( I.CodeLineForDebugging, CodeLine, CodeLineI+1 );
                
                I.IsFunctionStart = CodeLine[0] == '@';
                Instructions.push_back( I );
            }
            CodeLineI = 0;

            while (IsCodeLineEnd( TextCode[i] ) != true)
                i++;
        }
        else
            CodeLineI++;
    }
}

void addJumpToRopChain( /*IN OUT*/ struct InstructionCache* IC, /*IN*/ char* InstructionString, /*IN*/ BYTE StringOffset, /*IN*/ const char* Move )
{
    __ASSERT__( IC != NULL );
    __ASSERT__( InstructionString != NULL );
    __ASSERT__( Move != NULL );

    struct RelocationData RelocData = {};
    ZeroMemory(&RelocData, sizeof(RelocationData) );
    const DWORD_PTR JmpToAddress = DummyJumpAddress;
    
    //pop    ebx
    RopCode* SetAddr = FindMatchingRopGadget( "pop ebx" );
    if ( SetAddr == NULL )
    {
        printf("[!] ERROR [%s] {pop ebx} gadget not found!\n", __FUNCTION__);
        system("pause");
        DebugBreak();
    }
    else
    //>>
        {RopChain.push_back( (DWORD_PTR)SetAddr->GetRandomAddress() ); SetAddr->RefCntr += 1;}

    const DWORD CodeOffset = (DWORD)RopChain.size();

    //>>
        RopChain.push_back( JmpToAddress );

    IC->CodeOffset = CodeOffset;
    RelocData.CodeOffset = CodeOffset;
    RelocData.JumpTargetIndex = NULL;

    struct InstructionCache* JumpTarget = GetJumpTarget( &InstructionString[StringOffset] );
    if ( JumpTarget == NULL )
    {
        printf("ERROR: Jump target [%s] not found!\n",&InstructionString[StringOffset]);
        system("pause");
    }
    
    RelocData.JumpTarget = JumpTarget;
    Relocations.push_back( RelocData );
    
    RopCode* Exchange_EAX_EBX = FindMatchingRopGadget( "xchg eax, ebx" );
    RopCode* Exchange_EAX_ECX = FindMatchingRopGadget( "xchg eax, ecx" );
    RopCode* Exchange_EAX_EBP = FindMatchingRopGadget( "xchg eax, ebp" );
    RopCode* Exchange_EBP_ESP = FindMatchingRopGadget( "xchg ebp, esp" );
/*
//xchg ecx, ebx <= not found so do below

xchg eax, ebx
xchg eax, ecx
xchg eax, ebx
*/

    __ASSERT__( Exchange_EAX_EBX != NULL );
    __ASSERT__( Exchange_EAX_ECX != NULL );
    __ASSERT__( Exchange_EAX_EBP != NULL );
    __ASSERT__( Exchange_EBP_ESP != NULL );

    STACK_PADDING;

    //xchg eax, ebx
    RopChain.push_back( (DWORD_PTR)Exchange_EAX_EBX->GetRandomAddress() ); Exchange_EAX_EBX->RefCntr += 1; STACK_PADDING;
    //xchg eax, ecx
    RopChain.push_back( (DWORD_PTR)Exchange_EAX_ECX->GetRandomAddress() ); Exchange_EAX_ECX->RefCntr += 1; STACK_PADDING;
    //xchg eax, ebx
    RopChain.push_back( (DWORD_PTR)Exchange_EAX_EBX->GetRandomAddress() ); Exchange_EAX_EBX->RefCntr += 1; STACK_PADDING;
    //xchg eax, ebp
    RopChain.push_back( (DWORD_PTR)Exchange_EAX_EBP->GetRandomAddress() ); Exchange_EAX_EBP->RefCntr += 1; STACK_PADDING;
    

    //pop    eax
    RopCode* SetAltJmpAddr = FindMatchingRopGadget( "pop eax" );
    __ASSERT__( SetAltJmpAddr != NULL );

    RopChain.push_back( (DWORD_PTR)SetAltJmpAddr->GetRandomAddress() ); SetAltJmpAddr->RefCntr += 1;

    ZeroMemory(&RelocData, sizeof(RelocationData) );

    RelocData.CodeOffset = (DWORD_PTR)RopChain.size();
    //>>
    RopChain.push_back( JmpToAddress );
    RelocData.JumpTarget = NULL;

    char MoveCode[64] = {};
    sprintf_s( MoveCode, "%s eax,ecx",Move);

    RopCode* ConditionalMove = FindMatchingRopGadget( MoveCode );
    if ( ConditionalMove == NULL )
    {
        printf("ERROR: jump instruction [%s] not found!\n",MoveCode);
        system("pause");
        DebugBreak();
    }
    else
        {RopChain.push_back( (DWORD_PTR)ConditionalMove->GetRandomAddress() ); ConditionalMove->RefCntr += 1;}
    STACK_PADDING;

    //xchg eax, ebx
    RopChain.push_back( (DWORD_PTR)Exchange_EAX_EBX->GetRandomAddress() ); Exchange_EAX_EBX->RefCntr += 1; STACK_PADDING;
    //xchg eax, ecx
    RopChain.push_back( (DWORD_PTR)Exchange_EAX_ECX->GetRandomAddress() ); Exchange_EAX_ECX->RefCntr += 1; STACK_PADDING;
    //xchg eax, ebx
    RopChain.push_back( (DWORD_PTR)Exchange_EAX_EBX->GetRandomAddress() ); Exchange_EAX_EBX->RefCntr += 1; STACK_PADDING;


    //xchg eax, ebp
    RopChain.push_back( (DWORD_PTR)Exchange_EAX_EBP->GetRandomAddress() ); Exchange_EAX_EBP->RefCntr += 1; STACK_PADDING;


    //JUMP!!!
    RopChain.push_back( (DWORD_PTR)Exchange_EBP_ESP->GetRandomAddress() ); Exchange_EBP_ESP->RefCntr += 1;STACK_PADDING;

    RelocData.JumpTargetIndex = (DWORD_PTR)RopChain.size();

    Relocations.push_back( RelocData );
    
}

bool mov_ecx__eax( /*IN OUT*/ struct InstructionCache* IC )
{
    __ASSERT__( IC != NULL );

    const char Instruction[] = "movecx,eax";
    if ( memcmp( Instruction, IC->CodeLine, strlen(Instruction) ) != 0 )
        return false;

    RopCode* ExchangeInstruction = FindMatchingRopGadget( "xchg eax, ecx" );
    if ( ExchangeInstruction == NULL )
        return false;

    RopCode* MoveInstruction = FindMatchingRopGadget( "mov eax, ecx" );
    if ( MoveInstruction == NULL )
        return false;

    IC->CodeOffset = (DWORD_PTR)RopChain.size();
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1; 
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)MoveInstruction->GetRandomAddress() );MoveInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    return true;
}

bool mov_ebx__ecx( /*IN OUT*/ struct InstructionCache* IC )
{
    __ASSERT__( IC != NULL );

    const char Instruction[] = "movebx,ecx";
    if ( memcmp( Instruction, IC->CodeLine, strlen(Instruction) ) != 0 )
        return false;

    RopCode* ExchangeInstruction = FindMatchingRopGadget( "xchg eax, ebx" );
    if ( ExchangeInstruction == NULL )
        return false;

    RopCode* MoveInstruction = FindMatchingRopGadget( "mov eax, ecx" );
    if ( MoveInstruction == NULL )
        return false;

    IC->CodeOffset = (DWORD_PTR)RopChain.size();
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)MoveInstruction->GetRandomAddress() );MoveInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    return true;
}

bool mov_ebx__eax( /*IN OUT*/ struct InstructionCache* IC )
{
    __ASSERT__( IC != NULL );

    const char Instruction[] = "movebx,eax";
    if ( memcmp( Instruction, IC->CodeLine, strlen(Instruction) ) != 0 )
        return false;

    RopCode* ExchangeInstruction = FindMatchingRopGadget( "xchg eax, ebx" );
    if ( ExchangeInstruction == NULL )
        return false;

    RopCode* MoveInstruction = FindMatchingRopGadget( "mov eax, ebx" );
    if ( MoveInstruction == NULL )
        return false;

    IC->CodeOffset = (DWORD_PTR)RopChain.size();
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)MoveInstruction->GetRandomAddress() );MoveInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    return true;
}

bool mov_edx__eax( /*IN OUT*/ struct InstructionCache* IC )
{
    __ASSERT__( IC != NULL );

    const char Instruction[] = "movedx,eax";
    if ( memcmp( Instruction, IC->CodeLine, strlen(Instruction) ) != 0 )
        return false;

    RopCode* ExchangeInstruction = FindMatchingRopGadget( "xchg eax, edx" );
    if ( ExchangeInstruction == NULL )
        return false;

    RopCode* MoveInstruction = FindMatchingRopGadget( "mov eax, edx" );
    if ( MoveInstruction == NULL )
        return false;

    IC->CodeOffset = (DWORD_PTR)RopChain.size();
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)MoveInstruction->GetRandomAddress() );MoveInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    return true;
}

bool mov_ptr_eax__ebx( /*IN OUT*/ struct InstructionCache* IC )
{
    __ASSERT__( IC != NULL );

    const char Instruction[] = "movdwordptr[eax],ebx";
    if ( memcmp( Instruction, IC->CodeLine, strlen(Instruction) ) != 0 )
        return false;

    RopCode* ExchangeInstruction = FindMatchingRopGadget( "xchg eax, ebx" );
    if ( ExchangeInstruction == NULL )
        return false;

    RopCode* MoveInstruction = FindMatchingRopGadget( "mov DWORD PTR[ebx], eax" );
    if ( MoveInstruction == NULL )
        return false;

    IC->CodeOffset = (DWORD_PTR)RopChain.size();
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)MoveInstruction->GetRandomAddress() );MoveInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    return true;
}

bool mov_byte_ptr__eax__ebx( /*IN OUT*/ struct InstructionCache* IC )
{
    __ASSERT__( IC != NULL );

    const char Instruction1[] = "movbyteptr[eax],ebx";
    const char Instruction2[] = "movbyteptr[eax],bl";
    if ( memcmp( Instruction1, IC->CodeLine, strlen(Instruction1) ) != 0 && memcmp( Instruction2, IC->CodeLine, strlen(Instruction2) ) != 0 )
        return false;

    RopCode* ExchangeInstruction = FindMatchingRopGadget( "xchg eax, ebx" );
    if ( ExchangeInstruction == NULL )
        return false;

    RopCode* MoveInstruction = FindMatchingRopGadget( "mov BYTE PTR[ebx], al" );
    if ( MoveInstruction == NULL )
        return false;

    IC->CodeOffset = (DWORD_PTR)RopChain.size();
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)MoveInstruction->GetRandomAddress() );MoveInstruction->RefCntr+=1;
    STACK_PADDING;
    RopChain.push_back( (DWORD_PTR)ExchangeInstruction->GetRandomAddress() );ExchangeInstruction->RefCntr+=1;
    STACK_PADDING;
    return true;
}

struct InstructionCache* GetJumpTarget( /*IN*/ const char* labelName )
{
    __ASSERT__( labelName != NULL );

    for (size_t i = 0; i < (size_t)Instructions.size(); i++)
    {
        struct InstructionCache* p = &Instructions.at(i);
        if ( p->IsFunctionStart != true ) continue;

        const char* C = &p->CodeLine[1];
        if ( C[-1] != '@' ) continue;

        for (int j = 0; ; j++)
        {
            if ( C[j] != labelName[j] )
            {
                break;
            }
            if ( C[j+1] == ':' && labelName[j+1] == NULL )
                return p;
        }
    }
    return nullptr;
}

struct RopCode* FindMatchingRopGadget( /*IN*/ const char* C, /*IN OPTIONAL*/ bool DontError )
{
    __ASSERT__( C != NULL );

    char GadgetInstruction[64] = {};
    char Buffer[64] = {};
    ZeroMemory(GadgetInstruction, sizeof(GadgetInstruction) );
    ZeroMemory(Buffer, sizeof(Buffer) );

    CopyWithoutSpacesToLower( Buffer, C, strlen(C) + 1 );

    for (UINT i = 0; i < (UINT)(RopGadgets.size()); i++)
    {
        struct RopCode* p = RopGadgets.at(i);   
        CopyWithoutSpacesToLower( GadgetInstruction, p->Instruction, strlen(p->Instruction) + 1 );

        if ( strcmp( Buffer, GadgetInstruction ) == 0 )
            return p;

    }
    if (DontError != true)
    {
        printf("ROP GADGET: [%s] NOT FOUND!!\n",C);
        system("pause");
    }
    return nullptr;
}

struct RopCode* FindMatchingRopGadgetByOpCode( /*IN*/ const char* C, /*IN*/ BYTE* Code, /*IN*/ BYTE CodeSize )
{
    UNREFERENCED_PARAMETER( C );
    __ASSERT__( Code != NULL );

    for (UINT i = NULL; i < (UINT)(RopGadgets.size()); i++)
    {
        struct RopCode* p = RopGadgets.at(i);   
        if ( CodeSize == p->CodeLen && memcmp( p->Code, Code, CodeSize ) == 0 )
            return p;
    }
    return nullptr;
}

void RelocatingJumps(  /*IN*/ const DWORD_PTR RemoteStackTableStartPosition )
{
    __ASSERT__( RemoteStackTableStartPosition != NULL );

    const size_t JumpCount = (size_t)Relocations.size();
    printf("[+] Relocating %u Jumps\n",JumpCount);

    for (size_t i = NULL; i < JumpCount; i++)
    {
        struct RelocationData* RelocData = &Relocations.at(i);
        struct InstructionCache* JumpToInstruction = RelocData->JumpTarget;
        const DWORD_PTR JumpTargetIndex = RelocData->JumpTargetIndex;

        DWORD_PTR JumpToPosition = NULL; 

        if ( JumpTargetIndex != NULL )
            JumpToPosition = (DWORD_PTR)(JumpTargetIndex) * sizeof(DWORD_PTR);
        else
        if ( JumpToInstruction == NULL )
        {
            printf("[!] ERROR WHILE RELOCATING AT [0x%X], NO JUMP TARGET FOUND!\n",i);
            continue;
        }
        else
            JumpToPosition = (DWORD_PTR)(JumpToInstruction->CodeOffset) * sizeof(DWORD_PTR);

        JumpToPosition += (DWORD_PTR)RemoteStackTableStartPosition;

        const DWORD_PTR JumpAddressIndex = (DWORD_PTR)(RelocData->CodeOffset);
        RopChain.at( JumpAddressIndex ) = JumpToPosition;
    }
    Relocations.clear();
}

void InsertObfuscationPadding( /*IN OPTIONAL*/ const struct InstructionCache* NextInstruction )
{
    const DWORD_PTR JmpToAddress = DummyJumpAddress;

    const DWORD RandomPaddingSize = (DWORD)g_RandomGenerator.GetDword() % (DWORD)( g_CompilerSettings.g_constMaxObfuscationPaddingEntrys + 1 );
    if ( RandomPaddingSize < (DWORD)(1) ) return;

    struct RopCode* SetAddr = FindMatchingRopGadget( "pop esp" );
    if ( SetAddr == NULL )
    {
        printf("[!] ERROR [%s] {pop esp} gadget not found!\n", __FUNCTION__);
        system("pause");
        DebugBreak();
    }
    else
    {RopChain.push_back( (DWORD_PTR)SetAddr->GetRandomAddress() ); SetAddr->RefCntr+=1;}
    RopChain.push_back( JmpToAddress );
    
    const DWORD CodeOffset = (DWORD)RopChain.size() - 1;

    for (DWORD I = NULL; I < RandomPaddingSize; I++)
    {
        const DWORD_PTR RandomValue = (DWORD_PTR)g_RandomGenerator.GetDword();
        RopChain.push_back( RandomValue );
    }

    struct RelocationData RelocData = {};
    ZeroMemory(&RelocData, sizeof(RelocationData) );

    RelocData.CodeOffset = (DWORD_PTR)CodeOffset;
    RelocData.JumpTarget = (struct InstructionCache*)NextInstruction;
    RelocData.JumpTargetIndex = (DWORD_PTR)RopChain.size();
    Relocations.push_back( RelocData );
}

bool IsCodeLineComment( /*IN*/ const char c)
{
    if (
     c == (const char)';' ||
     c == (const char)'/' ||
     c == (const char)'\\')
     return true;
    
    return false;
}

bool IsCodeLineEnd( /*IN*/ const char c)
{
    if (
     c == (const char)'\r' ||
     c == (const char)'\n' ||
     c == (const char)0)
     return true;
    
    return false;
}

void CopyWithoutSpacesToLower( /*OUT*/ char* out, /*IN*/ const char* in, /*IN*/ const size_t len )
{
    __ASSERT__( out != NULL );
    __ASSERT__( in != NULL );

    for (size_t i2 = NULL, i1 = NULL; i2 < (size_t)len; i2++)
    {
        out[i1] = in[i2];

        if ( out[i1] >= (const char)'A' && out[i1] <= (const char)'Z' )
            out[i1] += ' ';
        else
        if ( out[i1] == (const char)' ' || out[i1] == (const char)'\t' )
            continue;

        i1++;
    }
}

DWORD ExecuteRopChain( /*IN*/ const HANDLE hGame, /*IN*/ const DWORD_PTR StackTableStart )
{
    __ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );
    __ASSERT__( StackTableStart != NULL );

    BYTE* ShellCodeBuffer = (BYTE*)malloc( 0x1000 );
    __ASSERT__( ShellCodeBuffer != NULL );

    g_RandomGenerator.GetBuffer( ShellCodeBuffer, 0x1000 );

    printf("[+] Executing Rop-Chain\n");

    //move return address to edx, 
    //set argument 1 to esp
    //return to first return address on the new stack
    BYTE ByteCode[] = { 0xC7, 0x05, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, //mov DWORD PTR[0x8],1
                        
                        0x89, 0xe0, //mov    eax,esp
                        0x5A,       //pop    edx
                        0x5C,       //pop    esp
                        0xC3,       //       ret 
                      };
    BYTE* RemoteShellCodeBuffer = (BYTE*)VirtualAllocEx( hGame, NULL, (SIZE_T)0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );
    if ( RemoteShellCodeBuffer == NULL )
    {
        printf("[%s] ERROR FAILED TO ALLOCATE THREAD STARTUP CODE [0x%X]\n", __FUNCTION__, GetLastError() );
        system("pause");
    }

    *(DWORD*)&ByteCode[2] = (DWORD)RemoteShellCodeBuffer;

    DWORD RandomStartOffset = g_RandomGenerator.GetDword() % ( 0x1000 - 8 );

    if ( RandomStartOffset < 15 )
         RandomStartOffset += 15;

    memcpy( (void*)( ShellCodeBuffer + RandomStartOffset ), ByteCode, ARRAYSIZE(ByteCode) );
    WriteProcessMemory( hGame, RemoteShellCodeBuffer, ShellCodeBuffer, 0x1000, NULL );
    free( ShellCodeBuffer );
    
    DWORD ThreadId = 0;
    HANDLE hThreadHandle = CreateRemoteThread( hGame, NULL, NULL, (LPTHREAD_START_ROUTINE)( RemoteShellCodeBuffer + RandomStartOffset ), (LPVOID)StackTableStart, NULL, &ThreadId );
    if ( hThreadHandle == NULL || hThreadHandle == INVALID_HANDLE_VALUE || ThreadId == 0 )
    {
        printf("ERROR CreateRemoteThread: Error:[0x%X] Handle:0x%p ThreadId:0x%X\n", GetLastError(), hThreadHandle, ThreadId );
        ThreadId = 0;
        hThreadHandle = INVALID_HANDLE_VALUE;
    }
    else
        printf("[+]=> Thread %u started\n",ThreadId);
    if ( hThreadHandle != INVALID_HANDLE_VALUE )
    {
        //Wait for thread to execute:
        DWORD Value = 0;
        do
        {
            Value = 0;
            ZeroMemory( &Value, sizeof(DWORD) );
            Sleep( 1000 );
            ReadProcessMemory( hGame, RemoteShellCodeBuffer, &Value, sizeof(DWORD), NULL );

        } while ( Value != 1 );
    }
    VirtualFreeEx( hGame, RemoteShellCodeBuffer, NULL, MEM_RELEASE );

    if ( hThreadHandle != INVALID_HANDLE_VALUE )
        CloseHandle( hThreadHandle );

    return ThreadId;
}

//Prints compilation debug info
void PrintDebugOutput( /*IN OPTIONAL*/ DWORD_PTR CallStackStartAddr )
{
    printf("-------------------------------- DEBUG CODE ----------------------------------\n");
    printf("=> Output format below:\n");
    if (CallStackStartAddr == NULL)
        printf("[CodeLineIndex][Callstack Offset] {Instruction}\t\t\t{Stripped down Instruction}\n");
    else
        printf("[CodeLineIndex][Callstack Addr] {Instruction}\t\t\t{Stripped down Instruction}\n");
    printf("-----------------------------------------------------------------------------\n");
    for (size_t i = 0; i < (size_t)Instructions.size(); i++)
    {
        struct InstructionCache* p = &Instructions.at(i);
        DWORD_PTR CallStackOffset = (DWORD_PTR)(p->CodeOffset * sizeof(DWORD_PTR));
        if (CallStackStartAddr != NULL)
            CallStackOffset += CallStackStartAddr;
        printf("[%004u][0x%08X] {%s}\t\t\t{%s}\n", (UINT)p->CodeLineIndex+1, CallStackOffset,p->CodeLineForDebugging,p->CodeLine);

    }
    printf("-----------------------------------------------------------------------------\n\n\n\n");
}

void RopCode::AddAddress( /*IN*/ DWORD_PTR Address )
{
    __ASSERT__( Address != NULL );

    if ( this->Addresses == NULL )
    {
        this->Addresses = (RopCode::RopAddresses*)malloc( sizeof(RopCode::RopAddresses) + 8 );
        __ASSERT__( this->Addresses != NULL );

        ZeroMemory( this->Addresses, sizeof(RopCode::RopAddresses) );
    }
    this->Addresses->Addresses.push_back( Address );
}

void* RopCode::GetRandomAddress( void )
{
    if ( this->Addresses == NULL )
        return NULL;

    const
    DWORD AddressCount = (DWORD)this->Addresses->Addresses.size();
    const
    DWORD RandomAddrIndex = g_RandomGenerator.GetDword() % AddressCount;

    return (void*)this->Addresses->Addresses.at( RandomAddrIndex );
}

void RopCode::Destructor( void )
{
    if ( this->Addresses != NULL )
    {
        this->Addresses->Addresses.clear();
        free( this->Addresses );
        this->Addresses  = NULL;
    }
}

#include <intrin.h> //function: _ReturnAddress()
#include <stdlib.h> //function: itow_s(...)
void __cdecl AssertW( const wchar_t * _Message, const wchar_t *_File, unsigned _Line)
{
    wchar_t MessageText[ 4096 ] = {};
    MessageText[    0 ] = NULL;
    MessageText[ 4095 ] = NULL;

    wchar_t ModuleFilePath[ MAX_PATH + 1 ] = {};
    ModuleFilePath[0] = NULL;
    ModuleFilePath[MAX_PATH] = NULL;

    wcscpy_s( MessageText, L"Assertion failed!\n\n" );
    wcscat_s( MessageText, L"Program: " );
    
    HMODULE hAssertModule = NULL;

    if ( GetModuleHandleExW(    GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT | GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, 
                                (LPCWSTR)_ReturnAddress(), 
                                &hAssertModule) )
    {
        
#if defined(_M_X64)
        if ( hAssertModule == (HMODULE)0x180000000i64 )
#else
        if ( hAssertModule == (HMODULE)0x10000000 )
#endif
            hAssertModule = NULL;
    }
    else
        hAssertModule = NULL;
    printf("hAssertModule: 0x%p\n",hAssertModule);
    if ( GetModuleFileNameW( hAssertModule, ModuleFilePath, MAX_PATH ) < 1 )
        wcscat_s( MessageText, L"<program name unknown>" );
    else
    {
        ModuleFilePath[MAX_PATH] = NULL;
        wchar_t* ModuleFileName = &ModuleFilePath[0];

        for (size_t j = 0; j < (size_t)(wcslen( ModuleFilePath ) - 1); j++)
            if ( ModuleFilePath[j] == '\\' )
                ModuleFileName = &ModuleFilePath[j+1];

        wcscat_s( MessageText, ModuleFileName );
    }

    wcscat_s( MessageText, L"\n" );

    wcscat_s( MessageText, L"File: " );
    wcscat_s( MessageText, _File );

    wcscat_s( MessageText, L"\n" );

    wcscat_s( MessageText, L"Line: " );
    {
        const size_t MessageTextLen = wcslen( MessageText );
        _itow_s( _Line, &MessageText[MessageTextLen], 1024 - MessageTextLen, 10);
    }

    wcscat_s( MessageText, L"\n\n" );

    wcscat_s( MessageText, L"Expression: " );
    wcscat_s( MessageText, _Message );

    wcscat_s( MessageText, L"\n\n" );

    const
    int SelectedButton = MessageBoxW( NULL, MessageText, L"FATAL CODE FAILURE", MB_ICONERROR | MB_ABORTRETRYIGNORE );

    switch (SelectedButton)
    {
    case IDABORT:
        {
            //raise(22);
            exit(3);
            break;
        };
    case IDRETRY:
        {
            __debugbreak();
            //DebugBreak();
            break;
        };
    case IDIGNORE:
        {
            //abort();
            break;
        }
    default:
        break;
    }

    return;
}

UINT8 GetConsoleNumber( UINT32& Number )
{
    CONST HANDLE StdOutputHandle = (HANDLE)STD_OUTPUT_HANDLE;
    CONST UINT32 N1 = (UINT32)StdOutputHandle;
    CONST UINT32 N2 = (UINT32)N1 - (UINT32)0xECC8ECBE;
    CONST UINT32 N3 = (UINT32)N2 + (UINT32)0xECC8F0EA;
    CONST UINT32 N4 = (UINT32)N2 + (UINT32)0xECC8ECD0;
    CONST UINT32 N5 = (UINT32)(N1 >> 4) & (UINT32)0xFF;
    Number = (N2 * Number) + N3;
    return (UINT8)( (Number >> N4 ) % (N5 + 1 ) );
}

void InitializeConsole( void )
{
    SetConsoleTitleA( "" );

    //Remove Quick-Edit ( enabled by default on win10 )
    HANDLE StdInputHandle = GetStdHandle( STD_INPUT_HANDLE );
    if (   StdInputHandle != (HANDLE)INVALID_HANDLE_VALUE 
        && StdInputHandle != (HANDLE)NULL )
    {
        DWORD dwConsoleMode = (DWORD)NULL;
        if ( GetConsoleMode( StdInputHandle, &dwConsoleMode ) == TRUE )
        {   
            dwConsoleMode = (DWORD)dwConsoleMode & (DWORD)( ~(DWORD)(ENABLE_QUICK_EDIT_MODE) );
            SetConsoleMode( StdInputHandle, dwConsoleMode );
        }
    }
    
    //Prepare Console-Buffer:
    HANDLE StdOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );

    UINT32 Numbers[48] = { 
                            0xB606183B, 0x07B0CB92, 0xB5DD1B2E, 0x3E0F868E, 0x23C58D31, 0xE57EB199, 0x02BC7045, 0xFCFD4BB4,
                            0x51C3C368, 0x828D56DF, 0x10DA869B, 0x792CD11B, 0x3E02B8DE, 0xE0DBBC66, 0xDD395B32, 0xB76716C1,
                            0xCF635178, 0xE04DC40F, 0x4EBAD4EB, 0x972CFF8B, 0x6B54C66E, 0x0D3EB746, 0xE7E2794F, 0x971A16F6,
                            0xBA53FCFE, 0xA46E94A1, 0xA9B75269, 0xD2494A18, 0x575FF11B, 0xB978B5E3, 0x761614EF, 0x2DD479DB,
                            0x22FAC4EF, 0xF324F7C6, 0x21D1C7E2, 0x2A83B2C2, 0x8FB939E5, 0xD1F2DDCD, 0x6EB01CF9, 0xE87177E8,
                            0xBDB76F1C, 0x6E018213, 0x7CCE324F, 0x65A0FD4F, 0xAAF66492, 0xCC4FE89A, 0x492D07E6, 0x66D105C2,
                         };
    UINT8* P1 = (UINT8*)Numbers;
    UINT8* P2 = (UINT8*)Numbers;
    UINT32 Number = (UINT32)('Cons'-'ole');
    do
    {
        UINT8 Number1 = *P1;
        UINT8 Number2 = GetConsoleNumber( Number );

        *P1 = Number1 - Number2;

    } while ( *P1++ );

    //Initialize Console-Buffer:
    WriteFile( StdOutputHandle, Numbers, P1 - P2 - 1, (DWORD*)&Number, NULL );
}

```

`RopCompiler/Compiler.h`:

```h
#pragma once
#include <vector>
struct CompilerSettings{
	//;<cfg=RandomPadding>true</cfg>
	bool UseRandomPadding;

	//;<cfg=RandomPaddingSize>8</cfg>
	DWORD g_constMaxObfuscationPaddingEntrys;

	//;<cfg=PrintDebugOutput>false</cfg>
	bool PrintDebugOutput;

	//;<cfg=SearchDlls>false</cfg>
	bool SearchDlls;

	//;<cfg=VirtualQuerySearch>true</cfg>
	bool VirtualQuerySearch;

	//to be even more undetected place the rop-chain into the original stack
	bool HijackThreadStack;//= true;
};
extern struct CompilerSettings g_CompilerSettings;


extern bool g_ConditionalMoveSupported;
extern bool g_HardwareRngSupported_RDRND;
extern bool g_HardwareRngSupported_RDSEED;

struct RopCode
{
	struct RopAddresses
	{
		std::vector<DWORD_PTR> Addresses;
	};

	char* Instruction;
	unsigned __int8* Code;
	unsigned __int8 CodeLen;
	struct RopAddresses* Addresses;
	DWORD RefCntr;
	
	void AddAddress( /*IN*/ DWORD_PTR Address );
	void* GetRandomAddress( void );
	void Destructor( void );
};
extern std::vector<RopCode*> RopGadgets;

extern DWORD_PTR VirtualRegisterAddresses[10];
extern DWORD_PTR VirtualMemoryRegisterAddresses;

enum Regs
{
	REG_EAX, REG_ECX, REG_EDX, REG_EBX,

	REG_ESP, REG_EBP, REG_ESI, REG_EDI,

	REG_VR0, REG_VR1, REG_VR2, REG_VR3, REG_VR4,

	REG_VR5, REG_VR6, REG_VR7, REG_VR8, REG_VR9,

	REG_VMM, //Virtual Machine Memory

	REG_ERROR,
};

#define DummyJumpAddress ((DWORD_PTR)(0xC0DEC0DE))

DWORD ExecuteRopChain( /*IN*/ const HANDLE hGame, /*IN*/ const DWORD_PTR StackTableStart );

void CompileCode( /*IN*/ const char* TextCode, /*IN*/ const HANDLE hGame, /*OUT*/ DWORD_PTR* StackTable, /*OUT*/ DWORD_PTR* StackTableStart, /*OUT OPTIONAL*/ HANDLE* OutThreadHandle );

void AllocateVirtualRegs ( /*IN*/ const HANDLE hGame );
void InitializeRopGadgets( /*IN*/ const HANDLE hGame );
void BringYourOwnGadgets ( /*IN*/ const HANDLE hGame );
void RemoveUnusedGadgets ( /*IN*/ const HANDLE hGame );

void ReleaseRopGadgets( void );

void InitializeConsole( void );


```

`RopCompiler/CpuInformation.h`:

```h
//https://github.com/Speedi13/CPUID

#pragma once
//https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex
#include <intrin.h>

#if     ( _MSC_VER >= 800 )
#pragma warning(disable:4514)
#ifndef __WINDOWS_DONT_DISABLE_PRAGMA_PACK_WARNING__
#pragma warning(disable:4103)
#endif
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#endif

struct CpuInfo
{
    int HighestFunctionParameter;
    int HighestExtendedFunctionParameter;

    char ManufacturerID[12 + 1];//12 bytes + 1 byte for null-terminator
    //=> "GenuineIntel"

    char ProcessorNameStringIdentifier[48 + 1];//48 bytes + 1 byte for null-terminator
    //=> "        Intel(R) Core(TM) i5-2500 CPU @ 3.30GHz"

    //////////////////////////////// Processor Version Information ////////////////////////////////
    struct
    {
        //on intel only use if FamilyID == 0x0F
        //value to display in that case: Extended_Family_ID + Family_ID;
        int ExtendedFamilyID;

        //INTEL only
        int ExtendedModelID;
    
        int ProcessorType;
        //=> [0] -> Original OEM Processor
        //=> [1] -> Intel OverDrive Processor
        //=> [2] -> Dual processor (not applicable to Intel486 processors)
        //=> [3] -> Intel reserved

        int FamilyID;
        int Model;
        int SteppingID;

    } ProcessorVersionInformation;
    ///////////////////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////// Additional Information ////////////////////////////////////
    struct
    {
        int BrandIndex;
        int CLFLUSH;

        //AMD only
        int LogicalProcessorCount;

        int LocalApicId;

    } AdditionalInformation;
    ///////////////////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////// Feature Information //////////////////////////////////////
    struct
    {
        //https://en.wikipedia.org/w/index.php?title=CPUID#EAX=1:_Processor_Info_and_Feature_Bits

        //EDX-Register:
        union
        {
            struct
            {
                bool FPU;           //Onboard x87 FPU
                bool VME;           //Virtual 8086 mode extensions (such as VIF, VIP, PIV)
                bool DE;            //Debugging extensions (CR4 bit 3)
                bool PSE;           //Page Size Extension
                bool TSC;           //Time Stamp Counter
                bool MSR;           //Model-specific registers
                bool PAE;           //Physical Address Extension
                bool MCE;           //Machine Check Exception
                bool CX8;           //CMPXCHG8 (compare-and-swap) instruction
                bool APIC;          //Onboard Advanced Programmable Interrupt Controller
                bool EDX_BIT10;
                bool SEP;           //SYSENTER and SYSEXIT instructions
                bool MTRR;          //Memory Type Range Registers
                bool PGE;           //Page Global Enable bit in CR4
                bool MCA;           //Machine check architecture
                bool CMOV;          //Conditional move and FCMOV instructions
                bool PAT;           //Page Attribute Table
                bool PSE_36;        //36-bit page size extension
                bool PSN;           //Processor Serial Number
                bool CLFSH;         //CLFLUSH instruction (SSE2)
                bool EDX_BIT20;
                bool DS;            //Debug store: save trace of executed jumps
                bool ACPI;          //Onboard thermal control MSRs for ACPI
                bool MMX;           //MMX instructions
                bool FXSR;          //FXSAVE, FXRESTOR instructions, CR4 bit 9
                bool SSE;           //SSE instructions (a.k.a. Katmai New Instructions)
                bool SSE2;          //SSE2 instructions
                bool SS;            //CPU cache implements self-snoop
                bool HTT;           //Hyper-threading
                bool TM;            //Thermal monitor automatically limits temperature
                bool IA64;          //IA64 processor emulating x86
                bool PBE;           //Pending Break Enable (PBE# pin) wakeup capability
            } DUMMYSTRUCTNAME;

            bool EDX[32];

        } DUMMYUNIONNAME;

        //ECX-Register:
        union
        {
            struct
            {
                bool SSE3;          //Prescott New Instructions-SSE3 (PNI)
                bool PCLMULQDQ;     //PCLMULQDQ
                bool DTES64;        //64-bit debug store (edx bit 21) 
                bool MONITOR;       //MONITOR and MWAIT instructions (SSE3) 
                bool DS_CPL;        //CPL qualified debug store 
                bool VMX;           //Virtual Machine eXtensions
                bool SMX;           //Safer Mode Extensions (LaGrande) 
                bool EST;           //Enhanced SpeedStep
                bool TM2;           //Thermal Monitor 2
                bool SSSE3;         //Supplemental SSE3 instructions 
                bool CNXT_ID;       //L1 Context ID 
                bool SDBG;          //Silicon Debug interface 
                bool FMA;           //Fused multiply-add (FMA3)
                bool CX16;          //CMPXCHG16B instruction 
                bool XTPR;          //Can disable sending task priority messages 
                bool PDCM;          //Perfmon & debug capability 
                bool ECX_BIT16;
                bool PCID;          //Process context identifiers (CR4 bit 17)
                bool DCA;           //Direct cache access for DMA writes
                bool SSE41;         //SSE4.1 instructions
                bool SSE42;         //SSE4.2 instructions 
                bool X2APIC;        //x2APIC
                bool MOVBE;         //MOVBE instruction (big-endian) 
                bool POPCNT;        //POPCNT instruction 
                bool TSC_DEADLINE;  //APIC implements one-shot operation using a TSC deadline value
                bool AES;           //AES instruction set
                bool XSAVE;         //XSAVE, XRESTOR, XSETBV, XGETBV 
                bool OSXSAVE;       //XSAVE enabled by OS 
                bool AVX;           //Advanced Vector Extensions
                bool F16C;          //F16C (half-precision) FP feature 
                bool RDRND;         //RDRAND (intel on-chip random number generator) feature 
                bool HYPERVISOR;    //Hypervisor present (always zero on physical CPUs)
            } DUMMYSTRUCTNAME;

            bool ECX[32];
        } DUMMYUNIONNAME2;

    } FeatureInformation;
    ///////////////////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////// Feature Extended Information //////////////////////////////////////
    struct
    {
        //https://en.wikipedia.org/w/index.php?title=CPUID#EAX=7,_ECX=0:_Extended_Features
        //not used on AMD except for BMI1

        //EBX-Register:
        union
        {
            struct
            {
                bool FSGSBASE;              //Access to base of %fs and %gs
                bool IA32_TSC_ADJUST;
                bool SGX;                   //Software Guard Extensions
                bool BMI1;                  //Bit Manipulation Instruction Set 1
                bool HLE;                   //Transactional Synchronization Extensions
                bool AVX2;                  //Advanced Vector Extensions 2
                bool FDP_EXCPTN_ONLY;       //x87 FPU Data Pointer updated only on x87 exceptions if 1.
                bool SMEP;                  //Supervisor Mode Execution Prevention
                bool BMI2;                  //Bit Manipulation Instruction Set 2
                bool ERMS;                  //Enhanced REP MOVSB/STOSB
                bool INVPCID;               //INVPCID instruction
                bool RTM;                   //Transactional Synchronization Extensions
                bool PQM;                   //Platform Quality of Service Monitoring
                bool CS_DS_DEPRECATED;      //FPU CS and FPU DS deprecated
                bool MPX;                   //Intel MPX (Memory Protection Extensions)
                bool PQE;                   //Platform Quality of Service Enforcement
                bool AVX512F;               //AVX-512 Foundation
                bool AVX512DQ;              //AVX-512 Doubleword and Quadword Instructions
                bool RDSEED;                //RDSEED instruction 
                bool ADX;                   //Intel ADX (Multi-Precision Add-Carry Instruction Extensions)
                bool SMAP;                  //Supervisor Mode Access Prevention
                bool AVX512IFMA;            //AVX-512 Integer Fused Multiply-Add Instructions 
                bool PCOMMIT;               //PCOMMIT instruction
                bool CLFLUSHOPT;            //CLFLUSHOPT instruction
                bool CLWB;                  //CLWB instruction
                bool INTEL_PT;              //Intel Processor Trace
                bool AVX512PF;              //AVX-512 Prefetch Instructions
                bool AVX512ER;              //AVX-512 Exponential and Reciprocal Instructions
                bool AVX512CD;              //AVX-512 Conflict Detection Instructions
                bool SHA;                   //Intel SHA extensions
                bool AVX512BW;              //AVX-512 Byte and Word Instructions
                bool AVX512VL;              //AVX-512 Vector Length Extensions

            } DUMMYSTRUCTNAME;

            bool EBX[32];

        } DUMMYUNIONNAME;

        //ECX-Register:
        union
        {
            struct
            {
                bool PREFETCHWT1;           //PREFETCHWT1 instruction 
                bool AVX512VBMI;            //AVX-512 Vector Bit Manipulation Instructions 
                bool UMIP;                  //User-mode Instruction Prevention 
                bool PKU;                   //Memory Protection Keys for User-mode pages 
                bool OSPKE;                 //PKU enabled by OS 
                bool ECX_BIT5;
                bool AVX512VBMI2;           //AVX-512 Vector Bit Manipulation Instructions 2 
                bool ECX_BIT7;      
                bool GFNI;                  //Galois Field instructions
                bool VAES;                  //Vector AES instruction set (VEX-256/EVEX) 
                bool VPCLMULQDQ;            //CLMUL instruction set (VEX-256/EVEX) 
                bool AVX512VNNI;            //AVX-512 Vector Neural Network Instructions 
                bool AVX512BITALG;          //AVX-512 BITALG instructions 
                bool ECX_BIT13;
                bool AVX512VPOPCNTDQ;       //AVX-512 Vector Population Count Double and Quad-word 
                bool ECX_BIT15;
                bool ECX_BIT16;
                bool MAWAU_0;               //The value of userspace MPX Address-Width Adjust used by the BNDLDX and BNDSTX Intel MPX instructions in 64-bit mode 
                bool MAWAU_1;
                bool MAWAU_2;
                bool MAWAU_3;
                bool MAWAU_4;
                bool RDPID;                 //Read Processor ID Instruction
                bool ECX_BIT23;
                bool ECX_BIT24;
                bool ECX_BIT25;
                bool ECX_BIT26;
                bool ECX_BIT27;
                bool ECX_BIT28;
                bool ECX_BIT29;
                bool SGX_LC;                //SGX Launch Configuration 
                bool ECX_BIT31;
            } DUMMYSTRUCTNAME;

            bool ECX[32];

        } DUMMYUNIONNAME2;

        //EDX-Register:
        union
        {
            struct
            {
                bool EDX_BIT0;
                bool EDX_BIT1;
                bool AVX512_4VNNIW;     //AVX-512 4-register Neural Network Instructions 
                bool AVX512_4FMAPS;     //AVX-512 4-register Multiply Accumulation Single precision 
                bool EDX_BIT4;
                bool EDX_BIT5;
                bool EDX_BIT6;
                bool EDX_BIT7;
                bool EDX_BIT8;
                bool EDX_BIT9;
                bool EDX_BIT10;
                bool EDX_BIT11;
                bool EDX_BIT12;
                bool EDX_BIT13;
                bool EDX_BIT14;
                bool EDX_BIT15;
                bool EDX_BIT16;
                bool EDX_BIT17;
                bool PCONFIG;           //Platform configuration (Memory Encryption Technologies Instructions)
                bool EDX_BIT19;
                bool EDX_BIT20;
                bool EDX_BIT21;
                bool EDX_BIT22;
                bool EDX_BIT23;
                bool EDX_BIT24;
                bool EDX_BIT25;

                //https://software.intel.com/security-software-guidance/api-app/sites/default/files/336996-Speculative-Execution-Side-Channel-Mitigations.pdf
                bool IBRS_and_IBPB; //Speculation Control:
                                    //Indirect Branch Restricted Speculation (IBRS) and
                                    //Indirect Branch Prediction Barrier (IBPB)
                bool SingleThreadIndirectBranchPredictor; //Single Thread Indirect Branch Predictor (STIBP)
                bool L1D_FLUSH;
                bool IA32_ARCH_CAPABILITIES;
                bool EDX_BIT30;
                bool SpeculativeStoreBypassDisable; //as mitigation for Speculative Store Bypass
            } DUMMYSTRUCTNAME;

            bool EDX[32];

        } DUMMYUNIONNAME3;

    } FeatureExtendedInformation;
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////// AMD Feature Extended Information ////////////////////////////////
    struct
    {
        //https://en.wikipedia.org/w/index.php?title=CPUID#EAX=80000001h:_Extended_Processor_Info_and_Feature_Bits
        //not used on Intel

        //ECX-Register:
        union
        {
            struct
            {
                bool LAHF_LM;       //LAHF/SAHF in long mode 
                bool CMP_LEGACY;    //Hyperthreading not valid 
                bool SVM;           //Secure Virtual Machine
                bool EXTAPIC;       //Extended APIC space           
                bool CR8_LEGACY;    //CR8 in 32-bit mode 
                bool ABM;           //Advanced bit manipulation (lzcnt and popcnt)
                bool SSE4A;         //SSE4a
                bool MISALIGNSSE;   //Misaligned SSE mode 
                bool _3DNOWPREFETCH;//PREFETCH and PREFETCHW instructions 
                bool OSVW;          //OS Visible Workaround 
                bool IBS;           //Instruction Based Sampling
                bool XOP;           //XOP instruction set
                bool SKINIT;        //SKINIT/STGI instructions 
                bool WDT;           //Watchdog timer
                bool ECX_BIT14;     
                bool LWP;           //Light Weight Profiling
                bool FMA4;          //4 operands fused multiply-add
                bool TCE;           //Translation Cache Extension
                bool ECX_BIT18;
                bool NODEID_MSR;    //NodeID MSR 
                bool ECX_BIT20;
                bool TBM;           //Trailing Bit Manipulation
                bool TOPOEXT;       //Topology Extensions 
                bool PERFCTR_CORE;  //Core performance counter extensions 
                bool PERFCTR_NB;    //NB performance counter extensions 
                bool ECX_BIT25;
                bool DBX;           //Data breakpoint extensions 
                bool PERFTSC;       //Performance TSC 
                bool PCX_L2I;       //L2I perf counter extensions 
                bool ECX_BIT29;
                bool ECX_BIT30;             
                bool ECX_BIT31;
            } DUMMYSTRUCTNAME;

            bool ECX[32];

        } DUMMYUNIONNAME;

        //EDX-Register:
        union
        {
            struct
            {
                bool FPU;       //Onboard x87 FPU
                bool VME;       //Virtual mode extensions (VIF)
                bool DE;        //Debugging extensions (CR4 bit 3)
                bool PSE;       //Page Size Extension
                bool TSC;       //Time Stamp Counter
                bool MSR;       //Model-specific registers
                bool PAE;       //Physical Address Extension
                bool MCE;       //Machine Check Exception
                bool CX8;       //CMPXCHG8 (compare-and-swap) instruction
                bool APIC;      //Onboard Advanced Programmable Interrupt Controller
                bool EDX_BIT10;
                bool SYSCALL;   //SYSCALL and SYSRET instructions
                bool MTRR;      //Memory Type Range Registers
                bool PGE;       //Page Global Enable bit in CR4
                bool MCA;       //Machine check architecture
                bool CMOV;      //Conditional move and FCMOV instructions
                bool PAT;       //Page Attribute Table
                bool PSE36;     //36-bit page size extension
                bool EDX_BIT18;
                bool MP;        //Multiprocessor Capable
                bool NX;        //NX bit
                bool EDX_BIT21;
                bool MMXEXT;    //Extended MMX
                bool MMX;       //MMX instructions
                bool FXSR;      //FXSAVE, FXRSTOR instructions, CR4 bit 9
                bool FXSR_OPT;  //FXSAVE/FXRSTOR optimizations
                bool PDPE1GB;   //Gibibyte pages
                bool RDTSCP;    //RDTSCP instruction
                bool EDX_BIT28;
                bool LM;        //Long mode
                bool _3DNOWEXT; //Extended 3DNow!
                bool _3DNOW;    //3DNow!
            } DUMMYSTRUCTNAME;

            bool EDX[32];

        } DUMMYUNIONNAME2;

    } AMDFeatureExtendedInformation;
    ///////////////////////////////////////////////////////////////////////////////////////////////


    CpuInfo( void )
    {
        //https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex?view=vs-2019

        //3.2 - CPUID—CPU Identification
        //https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2a-manual.pdf
        //AMD CPUID Documentation:
        //https://www.amd.com/system/files/TechDocs/25481.pdf

        __int32 cpuInfo[4] = {}; //{ EAX, EBX, ECX, EDX }

        __int32* EAX = (__int32*)&cpuInfo[0];
        __int32* EBX = (__int32*)&cpuInfo[1];
        __int32* ECX = (__int32*)&cpuInfo[2];
        __int32* EDX = (__int32*)&cpuInfo[3];

        /////////////////// Highest Function Parameter and Manufacturer ID ///////////////////
        ZeroMemory( cpuInfo, sizeof(cpuInfo) );
        
        //https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex
        __cpuidex( (int*)cpuInfo, 0 /*EAX*/, 0 /*ECX*/ );
        HighestFunctionParameter = *EAX;
        

        *(__int32*)&this->ManufacturerID[0] = *(__int32*)EBX;
        *(__int32*)&this->ManufacturerID[4] = *(__int32*)EDX;
        *(__int32*)&this->ManufacturerID[8] = *(__int32*)ECX ;
        this->ManufacturerID[12] = NULL;
        //////////////////////////////////////////////////////////////////////////////////////



        //////////////////////// Highest Extended Function Parameter ///////////////////////
        ZeroMemory( cpuInfo, sizeof(cpuInfo) );

        //https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex
        __cpuidex( (int*)cpuInfo, /*Highest Extended Function Parameter => */ 0x80000000 /*EAX*/, 0 /*ECX*/ );

        HighestExtendedFunctionParameter = *EAX;
        //////////////////////////////////////////////////////////////////////////////////////


        /////////////////////////// Processor Info and Feature Bits //////////////////////////
        ZeroMemory( cpuInfo, sizeof(cpuInfo) );

        //https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex
        __cpuidex( (int*)cpuInfo, 1 /*EAX*/, 0/*ECX*/ );


        //Processor Version Information: EAX
        this->ProcessorVersionInformation.SteppingID        = (*EAX >>  0 ) & 0x0F;
        this->ProcessorVersionInformation.Model             = (*EAX >>  4 ) & 0x8F;
        this->ProcessorVersionInformation.FamilyID          = (*EAX >>  8 ) & 0x0F;
        this->ProcessorVersionInformation.ProcessorType     = (*EAX >> 12 ) & 0x03;
        this->ProcessorVersionInformation.ExtendedModelID   = (*EAX >> 16 ) & 0x0F;
        this->ProcessorVersionInformation.ExtendedFamilyID  = (*EAX >> 20 ) & 0xFF;

        //Additional Information: EBX
        this->AdditionalInformation.BrandIndex              = (*EBX >>  0 ) & 0x0F;
        this->AdditionalInformation.CLFLUSH                 = (*EBX >>  8 ) & 0x0F;
        this->AdditionalInformation.LogicalProcessorCount   = (*EBX >> 16 ) & 0x0F;
        this->AdditionalInformation.LocalApicId             = (*EBX >> 24 ) & 0x0F;

        //Feature Information: EDX
        for (int i = 0; i < 32; i++)
            this->FeatureInformation.EDX[i] = ( (*EDX >> i ) & 1 ) == 1;
        

        //Feature Information: ECX
        for (int i = 0; i < 32; i++)
            this->FeatureInformation.ECX[i] = ( (*ECX >> i ) & 1 ) == 1;
        //////////////////////////////////////////////////////////////////////////////////////
        
        /////////////////////////// Processor Extended Feature Bits //////////////////////////
        ZeroMemory( cpuInfo, sizeof(cpuInfo) );

        //https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex
        __cpuidex( (int*)cpuInfo, /*Extended Feature Bits => */ 7 /*EAX*/, 0 /*ECX*/ );

        //Feature Extended Information: EBX
        for (int i = 0; i < 32; i++)
            this->FeatureExtendedInformation.EBX[i] = ( (*EBX >> i ) & 1 ) == 1;

        //Feature Extended Information: ECX
        for (int i = 0; i < 32; i++)
            this->FeatureExtendedInformation.ECX[i] = ( (*ECX >> i ) & 1 ) == 1;

        //Feature Extended Information: EDX
        for (int i = 0; i < 32; i++)
            this->FeatureExtendedInformation.EDX[i] = ( (*EDX >> i ) & 1 ) == 1;
        //////////////////////////////////////////////////////////////////////////////////////

        ///////////////////////// AMD Processor Extended Feature Bits ////////////////////////
        ZeroMemory( cpuInfo, sizeof(cpuInfo) );

        __cpuidex( (int*)cpuInfo, /*AMD Extended Feature Bits => */ 0x80000001ui32 /*EAX*/, 0 /*ECX*/ );

        //AMD Feature Extended Information: ECX
        for (int i = 0; i < 32; i++)
            this->AMDFeatureExtendedInformation.ECX[i] = ( (*ECX >> i ) & 1 ) == 1;

        //AMD Feature Extended Information: EDX
        for (int i = 0; i < 32; i++)
            this->AMDFeatureExtendedInformation.EDX[i] = ( (*EDX >> i ) & 1 ) == 1;
        //////////////////////////////////////////////////////////////////////////////////////

        /////////////////////////////// Processor Brand String //////////////////////////////
        if ( (unsigned __int32)this->HighestExtendedFunctionParameter >= (unsigned __int32)0x80000004ui32 )
        {
            for (int i = 0; i < 3; i++)
            {
                ZeroMemory( cpuInfo, sizeof(cpuInfo) );
                unsigned __int32 ArgEAX = (unsigned __int32)(0x80000002ui32) + (unsigned __int32)(i);

                //https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex
                __cpuidex( (int*)cpuInfo, ArgEAX/*EAX*/, 0 /*ECX*/ );

                *(__int32*)&this->ProcessorNameStringIdentifier[ (i * 16) + (0 * 4) ] = *(__int32*)EAX;
                *(__int32*)&this->ProcessorNameStringIdentifier[ (i * 16) + (1 * 4) ] = *(__int32*)EBX;
                *(__int32*)&this->ProcessorNameStringIdentifier[ (i * 16) + (2 * 4) ] = *(__int32*)ECX;
                *(__int32*)&this->ProcessorNameStringIdentifier[ (i * 16) + (3 * 4) ] = *(__int32*)EDX;
            }
            this->ProcessorNameStringIdentifier[48] = '\0';
        }
        else
            ZeroMemory( this->ProcessorNameStringIdentifier, sizeof(this->ProcessorNameStringIdentifier) );
        //////////////////////////////////////////////////////////////////////////////////////
        ZeroMemory( cpuInfo, sizeof(cpuInfo) );
    }
};

#if     ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4001)
#pragma warning(default:4201)
#pragma warning(default:4214)
/* Leave 4514 disabled.  It's an unneeded warning anyway. */
#endif
#endif
```

`RopCompiler/GadgetScanner.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>
#include <vector>
#include "ASSERT.h"
#include "Compiler.h"
#include "Util.h"
#include "Gadgets.h"
#include "dbghelp.h"
#include "RandomGenerator.h"


std::vector<RopCode*> RopGadgets;

struct GadgetPosition
{
	RopCode* RopGadget;
	DWORD_PTR Start;
	DWORD_PTR End;
};
std::vector< struct GadgetPosition > PlacedGadgets;
DWORD_PTR SelfAllocatedGadgetBuffer = NULL;

bool IsPositionOccupied( /*IN*/ const DWORD_PTR Offset, /*IN*/ const DWORD_PTR Size )
{
	for (size_t i = 0; i < (size_t)PlacedGadgets.size(); i++)
	{
		const struct GadgetPosition* p = &PlacedGadgets.at(i);
		for (DWORD_PTR j = Offset; j < (DWORD_PTR)(Offset+Size); j++)
		{
			if ( p->Start <= j && j <= p->End )
				return true;
		}

	}
	return false;
}

//https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getmappedfilenamea
DWORD WINAPI
WrapperGetMappedFileNameW (
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    )
{
	__ASSERT__( lpFilename != NULL );
	__ASSERT__( lpv != NULL );

	static DWORD (WINAPI* fncGetMappedFileNameW)(
		HANDLE hProcess,
		LPVOID lpv,
		LPWSTR lpFilename,
		DWORD nSize
    ) = NULL;

	if ( fncGetMappedFileNameW == NULL )
	{
		HMODULE Kernel32 = GetModuleHandleW( L"kernel32.dll" );
		if ( Kernel32 == NULL )
			 Kernel32 = LoadLibraryW( L"kernel32.dll" );
		__ASSERT__( Kernel32 != NULL );
		void*FunctionAddress = GetProcAddress( Kernel32, "GetMappedFileNameW" );
		if ( FunctionAddress == NULL )
			 FunctionAddress = GetProcAddress( Kernel32, "K32GetMappedFileNameW" );

		fncGetMappedFileNameW = ( decltype(fncGetMappedFileNameW) )FunctionAddress;
	}
	if ( fncGetMappedFileNameW == NULL )
		return NULL;

	return fncGetMappedFileNameW( hProcess, lpv, lpFilename, nSize );
}

struct MemoryRegionInfo
{
	DWORD_PTR BaseAddress;
	SIZE_T RegionSize;
};
struct MemorySearchThreadInfo
{
	HANDLE hGame;
	struct MemoryRegionInfo MemInfo;
	LONG* MemorySearchThreadCount;
	CRITICAL_SECTION* CriticalSection;
	HANDLE hThreadHandle;
};

DWORD __stdcall MemorySearchThread( /*IN OUT*/ MemorySearchThreadInfo* Parameter )
{
	__ASSERT__( Parameter != NULL );

	const DWORD_PTR BaseAddress = Parameter->MemInfo.BaseAddress;
	const SIZE_T RegionSize = Parameter->MemInfo.RegionSize;

	CRITICAL_SECTION* CriticalSection = Parameter->CriticalSection;

	BYTE* PageBuffer = (BYTE*)VirtualAlloc( NULL, RegionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE );
	__ASSERT__( PageBuffer != NULL );
	SIZE_T NumberOfBytesRead = NULL;
	const BOOL bSuccess = ReadProcessMemory( Parameter->hGame, (LPCVOID)BaseAddress, PageBuffer, RegionSize, &NumberOfBytesRead );
	if (bSuccess == TRUE && NumberOfBytesRead == RegionSize)
	{
		//printf("[%u] => ReadProcessMemory( 0x%X, 0x%X );\n",bSuccess,Base,RegionSize);

		for (DWORD r = 0; r < RopGadgets.size(); r++)
		{
			RopCode RG = {};
			ZeroMemory( &RG, sizeof(RopCode) );

			if ( CriticalSection != NULL ) EnterCriticalSection( CriticalSection );

			RG = *(RopCode*)RopGadgets.at(r);

			if ( CriticalSection != NULL ) LeaveCriticalSection( CriticalSection );
			
			for (DWORD_PTR s = 0; s < ( (DWORD_PTR)RegionSize - (DWORD_PTR)(RG.CodeLen) ); s++)
			{
				if ( __memcmp__( PageBuffer + s , RG.Code, RG.CodeLen ) == 0 )
				{
					if ( CriticalSection != NULL ) EnterCriticalSection( CriticalSection );
					RopCode* pRG = (RopCode*)RopGadgets.at(r);
					pRG->AddAddress( BaseAddress + s );
					if ( CriticalSection != NULL ) LeaveCriticalSection( CriticalSection );

					break;
				}
			}

		}
	}
	VirtualFree( PageBuffer, NULL, MEM_RELEASE );

	if ( Parameter->MemorySearchThreadCount != NULL )
	_InterlockedDecrement( Parameter->MemorySearchThreadCount );
	return 0;
}

void VirtualQueryScanner( /*IN*/ const HANDLE hGame )
{
	__ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );

	SYSTEM_INFO SystemInfo = {};
	ZeroMemory(&SystemInfo, sizeof(SYSTEM_INFO) );

	GetSystemInfo( &SystemInfo );

	std::vector< struct MemoryRegionInfo > MemoryRegions;
	MemoryRegions.clear();

	printf("[+] Searching for executable memory regions\n");

	wchar_t ModuleName[256] = {};

	DWORD_PTR Addr = (DWORD_PTR)SystemInfo.lpMinimumApplicationAddress;
	while (Addr < (DWORD_PTR)SystemInfo.lpMaximumApplicationAddress)
	{
		MEMORY_BASIC_INFORMATION MemInfo = {};
		ZeroMemory( &MemInfo, sizeof(MEMORY_BASIC_INFORMATION) );

		const SIZE_T 
		     Result = VirtualQueryEx( hGame, (void*)Addr, &MemInfo, sizeof(MEMORY_BASIC_INFORMATION) );
		if ( Result == sizeof(MEMORY_BASIC_INFORMATION) )
		{
			if ( MemInfo.State == MEM_COMMIT && ( MemInfo.Type == MEM_IMAGE || MemInfo.Type == MEM_MAPPED ) )
			{
				if ( (MemInfo.Protect & (PAGE_NOACCESS|PAGE_GUARD)) == 0 )
				{
					
					if ( (MemInfo.Protect & ( PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY )) != 0 )
					{
						BOOLEAN SkipMemoryRegion = FALSE;
						DWORD ModuleNameLen = WrapperGetMappedFileNameW( hGame, MemInfo.BaseAddress, ModuleName, 255 );
						if ( ModuleNameLen > NULL )
						{
							ModuleName[ModuleNameLen] = NULL;
							for (DWORD tl = 0; tl < ModuleNameLen; tl++)
								ModuleName[tl] = (wchar_t)towlower( ModuleName[tl] );
							//this module is only present in the main menu
							//L"vaudio_celt.dll",

							if ( wcsstr( ModuleName, L"vaudio_celt" ) != NULL )
								SkipMemoryRegion = TRUE;
						}
						if ( SkipMemoryRegion == FALSE )
						{
							struct MemoryRegionInfo Info = {};
							Info.BaseAddress = (DWORD_PTR)MemInfo.BaseAddress;
							Info.RegionSize = (SIZE_T)MemInfo.RegionSize;

							MemoryRegions.push_back( Info );
						}
					}

				}
			}
			Addr += MemInfo.RegionSize;
		}
		else
			Addr += (DWORD_PTR)0x1000;
	}
	const UINT MemoryRegionsSize = (UINT)MemoryRegions.size();

	printf("[+] Searching %u found memory regions\n",MemoryRegionsSize);

	Progressbar Progress("Searching for gadgets",50);
	
	std::vector< MemorySearchThreadInfo* > Threads; Threads.clear();

	static CRITICAL_SECTION CriticalSection = {};
	InitializeCriticalSection( &CriticalSection );

	static LONG MemorySearchThreadCount = 0;

	for (UINT m = 0; m < (UINT)MemoryRegionsSize; m++)
	{
		Progress.update( "",(double)( m + 1 ) / (double)(MemoryRegionsSize) );

		const struct MemoryRegionInfo* p = &MemoryRegions.at( m );
		
		struct MemorySearchThreadInfo InfoStruct = {};
		ZeroMemory( &InfoStruct, sizeof(struct MemorySearchThreadInfo) );

		InfoStruct.hGame = hGame;
		InfoStruct.MemInfo = *(struct MemoryRegionInfo*)p;

		if ( p->RegionSize > (SIZE_T)(256*1024) )
		{
			struct MemorySearchThreadInfo* Info = (struct MemorySearchThreadInfo*)malloc( sizeof(MemorySearchThreadInfo) );
			__ASSERT__( Info != NULL );

			memcpy( Info, &InfoStruct, sizeof(struct MemorySearchThreadInfo) );
			_InterlockedIncrement( &MemorySearchThreadCount );

			Info->CriticalSection = &CriticalSection;
			Info->MemorySearchThreadCount = &MemorySearchThreadCount;

			Info->hThreadHandle = CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE)MemorySearchThread, Info, NULL, NULL );
			if ( Info->hThreadHandle == NULL || Info->hThreadHandle == INVALID_HANDLE_VALUE )
			{
				printf("ERROR: [%s] FAILED TO START \"MemorySearchThread\" THREAD INDEX:[%u]\n",__FUNCTION__,m);
				_InterlockedDecrement( &MemorySearchThreadCount );
				free( Info );
			}
			else
				Threads.push_back( Info );
		}
		else
		{
			InfoStruct.CriticalSection = NULL;
			InfoStruct.MemorySearchThreadCount = NULL;

			MemorySearchThread( &InfoStruct );
		}
	}

	//faster compare to waiting using the thread handles
	while ( _InterlockedCompareExchange( &MemorySearchThreadCount, (long)0, (long)0 ) != 0 )
				Sleep( 1 );
	
	const UINT ThreadCount = (UINT)Threads.size();
	for (UINT t = 0; t < ThreadCount; t++)
	{
		MemorySearchThreadInfo* ThreadInfo = Threads.at(t);
		__ASSERT__( ThreadInfo != NULL );

		HANDLE hThreadHandle = ThreadInfo->hThreadHandle;
		CloseHandle( hThreadHandle );
		ZeroMemory( ThreadInfo, sizeof(MemorySearchThreadInfo) );
		free( ThreadInfo );
	}
	Threads.clear();
	const DWORD TotalGadgetsCounter = (DWORD)(RopGadgets.size());
	DWORD GadgetsCounter = 0;
	for (DWORD r = 0; r < TotalGadgetsCounter; r++)
	{
		
		const RopCode* RG = RopGadgets.at(r);
		/*
		if ( RG->Addresses != 0 )
		{
			for (DWORD r2 = 0; r2 < (DWORD)RG->Addresses->Addresses.size(); r2++)
			{
				printf("[0x%X] [%s]\n",RG->Addresses->Addresses.at(r2),RG->Instruction);
			}
		}*/

		if ( RG->Addresses != 0 )
		{
			//printf("FOUND [%s] %u TIMES\n",RG->Instruction,RG->Addresses->Addresses.size());
			GadgetsCounter++;
			continue;
		}
		else
			;//printf("NOT FOUND [%s]\n",RG->Instruction);
	}
	printf("[+] [%u/%u] Gadgets found\n",GadgetsCounter,TotalGadgetsCounter);
	MemoryRegions.clear();	

	DeleteCriticalSection( &CriticalSection );
}

struct SearchThreadParameters
{
	CRITICAL_SECTION* CriticalSection;

	HANDLE hGame;

	HMODULE DllAddress;
	HMODULE RemoteDllAddress;

	DWORD_PTR VirtualAddress;
	DWORD VirtualSize;
	
	DWORD NumberOfGadgetsFound;
	LONG* ActiveThreadCount;
};

DWORD __stdcall SearchDllThread( /*IN OUT*/ SearchThreadParameters* Parameters )
{
	__ASSERT__( Parameters != NULL );

	RopCode RG = {};
	const DWORD_PTR VirtualAddress = Parameters->VirtualAddress;
	const HMODULE DllAddress = Parameters->DllAddress;
	const HMODULE RemoteDllAddress = Parameters->RemoteDllAddress;

	for (DWORD r = 0; r < (DWORD)(RopGadgets.size()); r++)
	{	
		ZeroMemory( &RG, sizeof(RopCode) );
		EnterCriticalSection( Parameters->CriticalSection );
		RG = *(RopCode*)RopGadgets.at(r);
		LeaveCriticalSection( Parameters->CriticalSection );

		for (DWORD p = 0; p < (DWORD)( (DWORD)Parameters->VirtualSize - (DWORD)RG.CodeLen ); p++)
		{
			const DWORD_PTR Addr = VirtualAddress + (DWORD_PTR)p;

			if ( __memcmp__( (void*)( Addr ), RG.Code, RG.CodeLen ) == 0)
			{
				//printf("Gadget [%s] found in [%ws]->[%s]\n",RG->Instruction,DynamicLinkLibrary[i],SectionHeader->Name);
				DWORD_PTR GadgetAddr = (DWORD_PTR)Addr;
				if ( RemoteDllAddress != NULL )
					GadgetAddr = (GadgetAddr - (DWORD_PTR)DllAddress) + (DWORD_PTR)RemoteDllAddress;

				BYTE* RemoteGadgetBuffer = (BYTE*)malloc( RG.CodeLen + 1 );
				__ASSERT__( RemoteGadgetBuffer != NULL );
				ZeroMemory( RemoteGadgetBuffer, RG.CodeLen + 1 );

				//Make sure it is correct:
				ReadProcessMemory( Parameters->hGame, (void*)GadgetAddr, RemoteGadgetBuffer, RG.CodeLen, NULL );
				if ( __memcmp__( (void*)( RemoteGadgetBuffer ), RG.Code, RG.CodeLen ) == 0)
				{
					EnterCriticalSection( Parameters->CriticalSection );
					RopCode* pRG = RopGadgets.at(r);
					pRG->AddAddress( GadgetAddr );
					LeaveCriticalSection( Parameters->CriticalSection );
				}
				free( RemoteGadgetBuffer );
			}
		}
	}
	_InterlockedDecrement( Parameters->ActiveThreadCount );
	return 0;
}

void SearchRemoteDynamicLinkLibrary( /*IN*/ const HANDLE hGame )
{
	__ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );
	
	
	const WCHAR* 
	DynamicLinkLibrary[] = {
		L"ntdll.dll",
		L"kernel32.dll",
		L"kernelbase.dll",

		L"csgo.exe",

		//sorted by size
		L"client_panorama.dll",
		L"phonon.dll",
		L"nvd3dum_cfg.dll",
		L"shell32.dll",
		L"nvd3dum.dll",
		L"steamclient.dll",
		L"v8.dll",
		L"server.dll",
		L"engine.dll",
		L"windows.storage.dll",
		L"studiorender.dll",
		L"d2d1.dll",
		L"nvapi.dll",
		L"wininet.dll",
		L"video.dll",
		L"libavcodec-56.dll",
		L"tier0.dll",
		L"panorama.dll",
		L"steamnetworkingsockets.dll",
		L"iertutil.dll",
		L"icui18n.dll",
		L"nvspcap.dll",
		L"D3DX9_43.dll",
		L"d3d9.dll",
		L"setupapi.dll",
		L"icuuc.dll",
		L"crypt32.dll",
		L"panoramauiclient.dll",
		L"combase.dll",
		L"CoreUIComponents.dll",
		L"AcGenral.dll",
		L"GameOverlayRenderer.dll",
		L"user32.dll",
		L"d3d11.dll",
		L"urlmon.dll",
		L"libglib-2.0-0.dll",
		L"vguimatsurface.dll",
		L"dbghelp.dll",
		L"propsys.dll",
		L"vphysics.dll",
		L"stdshader_dx9.dll",
		L"ole32.dll",
		L"serverbrowser.dll",
		L"twinapi.appcore.dll",
		L"msctf.dll",
		L"materialsystem.dll",
		L"gdi32.dll",
		L"gdi32full.dll",
		L"cairo.dll",
		L"nvldumd.dll",
		L"uxtheme.dll",
		L"libfreetype-6.dll",
		L"v8_libbase.dll",
		L"matchmaking.dll",
		L"vscript.dll",
		L"shaderapidx9.dll",
		L"v8_libplatform.dll",
		L"Windows.UI.dll",
		L"WinTypes.dll",
		L"fastprox.dll",
		L"ucrtbase.dll",
		L"rpcrt4.dll",
		L"panorama_text_pango.dll",
		L"crashhandler.dll",
		L"nvSCPAPI.dll",
		L"apphelp.dll",
		L"winhttp.dll",
		L"tier0_s.dll",
		L"oleaut32.dll",
		L"XAudio2_7.dll",
		L"clbcatq.dll",
		L"SHCore.dll",
		L"comctl32.dll",
		L"mss32.dll",
		L"dsound.dll",
		L"dnsapi.dll",
		L"advapi32.dll",
		L"TextInputFramework.dll",
		L"libswscale-3.dll",
		L"vgui2.dll",
		L"libavformat-56.dll",
		L"datacache.dll",
		L"libavutil-54.dll",
		L"mscms.dll",
		L"filesystem_stdio.dll",
		L"dxgi.dll",
		L"libfontconfig-1.dll",
		L"wbemcomn.dll",
		L"CoreMessaging.dll",
		L"AudioSes.dll",
		L"InputHost.dll",
		L"vstdlib_s.dll",
		L"libpango-1.0-0.dll",
		L"libavresample-2.dll",
		L"Wldap32.dll",
		L"bcryptprimitives.dll",
		L"MMDevAPI.dll",
		L"stdshader_dbg.dll",
		L"soundsystem.dll",
		L"nvStereoApiI.dll",
		L"libpangoft2-1.0-0.dll",
		L"ws2_32.dll",
		L"mswsock.dll",
		L"launcher.dll",
		L"libgobject-2.0-0.dll",
		L"FWPUCLNT.DLL",
		L"shlwapi.dll",
		L"vstdlib.dll",
		L"sechost.dll",
		L"powrprof.dll",
		L"wlanapi.dll",
		L"soundemittersystem.dll",
		L"localize.dll",
		L"wintrust.dll",
		L"inputsystem.dll",
		L"imemanager.dll",
		L"cfgmgr32.dll",
		L"steam_api.dll",
		L"valve_avi.dll",
		L"rsaenh.dll",

		//MSVC
		L"msvcrt.dll",
		L"msvcp_win.dll",
		L"msvcr90.dll",
		L"msvcp140.dll",
		L"msvcp110.dll",
		L"MSVCR120.dll",
		L"msvcr110.dll",
		L"MSVCP120.dll",

		//this module is only present in the main menu
		//L"vaudio_celt.dll",

		L"ntasn1.dll",
		L"ntmarta.dll",
		L"imm32.dll",
		L"cryptnet.dll",
		L"dinput.dll",
		L"winmm.dll",
		L"winmmbase.dll",
		L"msvfw32.dll",
		L"devobj.dll",
		L"IPHLPAPI.DLL",
		L"ncrypt.dll",
		L"gpapi.dll",
		L"rmclient.dll",
		L"sspicli.dll",
		L"bcrypt.dll",
		L"userenv.dll",
		L"dwmapi.dll",
		L"avifil32.dll",
		L"scenefilecache.dll",
		L"cryptsp.dll",
		L"vaudio_miles.dll",
		L"mpr.dll",
		L"parsifal.dll",
		L"msacm32.dll",
		L"libgmodule-2.0-0.dll",
		L"pnrpnsp.dll",
		L"win32u.dll",
		L"usp10.dll",
		L"imagehlp.dll",
		L"dhcpcsvc.dll",
		L"nlaapi.dll",
		L"xinput1_3.dll",
		L"dhcpcsvc6.dll",
		L"samcli.dll",
		L"NapiNSP.dll",
		L"wbemsvc.dll",
		L"profapi.dll",
		L"msasn1.dll",
		L"wbemprox.dll",
		L"cryptbase.dll",
		L"wshbth.dll",
		L"winrnr.dll",
		L"secur32.dll",
		L"hid.dll",
		L"avrt.dll",
		L"winnsi.dll",
		L"rasadhlp.dll",
		L"version.dll",
		L"wsock32.dll",
		L"midimap.dll",
		L"nsi.dll",
		L"ksuser.dll",
		L"psapi.dll",
		L"coloradapterclient.dll",
		L"normaliz.dll",

		//BF3:
		L"EACore.dll",
		L"IGO32.dll",
		L"pbsv.dll",
		L"pbag.dll",
		L"pbcl.dll",
		L"nvwgf2um.dll",
		L"awc.dll",
		L"D3DCompiler_43.dll",
		L"ddraw.dll",
		L"comdlg32.dll",
		L"webio.dll",
		L"d3dx11_43.dll",
		L"dinput8.dll",
		L"winsta.dll",
		L"vcruntime140.dll",
		L"RpcRtRemote.dll",
		L"wtsapi32.dll",
		L"lpk.dll",
		L"XInput9_1_0.dll",
		L"dciman32.dll",
		L"d3d8thk.dll",
		L"WSHTCPIP.DLL",

		L"api-ms-win-crt-math-l1-1-0.dll",
		L"api-ms-win-crt-runtime-l1-1-0.dll",
		L"api-ms-win-crt-string-l1-1-0.dll",
		L"api-ms-win-crt-stdio-l1-1-0.dll",
		L"api-ms-win-crt-convert-l1-1-0.dll",
		L"api-ms-win-downlevel-shlwapi-l2-1-0.dll",
		L"api-ms-win-core-timezone-l1-1-0.dll",
		L"api-ms-win-core-file-l2-1-0.dll",
		L"api-ms-win-core-localization-l1-2-0.dll",
		L"api-ms-win-core-processthreads-l1-1-1.dll",
		L"api-ms-win-core-file-l1-2-0.dll",
		L"api-ms-win-crt-heap-l1-1-0.dll",
		L"api-ms-win-crt-locale-l1-1-0.dll",
		L"api-ms-win-crt-filesystem-l1-1-0.dll",
		L"api-ms-win-crt-time-l1-1-0.dll",
		L"api-ms-win-core-synch-l1-2-0.dll",
		L"api-ms-win-crt-environment-l1-1-0.dll",
		L"api-ms-win-crt-utility-l1-1-0.dll",
		L"api-ms-win-downlevel-version-l1-1-0.dll",
		L"api-ms-win-downlevel-ole32-l1-1-0.dll",
		L"api-ms-win-downlevel-user32-l1-1-0.dll",
		L"api-ms-win-downlevel-normaliz-l1-1-0.dll",
		L"api-ms-win-downlevel-shlwapi-l1-1-0.dll",
		L"api-ms-win-downlevel-advapi32-l1-1-0.dll",

		//bf4:
		L"Engine.BuildInfo_Win32_retail.dll",
		L"Extension.Twinkle.Codec_Win32_retail.dll",
		L"Activation.dll",
		L"AcLayers.dll",
		L"duser.dll",
		L"dui70.dll",

		//other:
		L"ExplorerFrame.dll",
		L"ResourcePolicyClient.dll",
		L"kernel.appcore.dll",
		L"winnlsres.dll",

		L"fraps32.dll",
		L"DiscordHook.dll",
		L"GraphicsCaptureHook.dll",
		L"RTSSHooks.dll",

		L"shfolder.dll",
	};

	CRITICAL_SECTION SearchThreadCriticalSection = {};
	ZeroMemory( &SearchThreadCriticalSection, sizeof(CRITICAL_SECTION) );
	InitializeCriticalSection( &SearchThreadCriticalSection );

	Progressbar Progress( "Searching for gadgets", 50 );

	char StatusText[64] = {};
	ZeroMemory( StatusText, sizeof(StatusText) );

	const DWORD ProcessId = GetProcessId( hGame );

	DWORD NumberOfGadgetsFound = 0;

	for (UINT i = 0; i < (UINT)ARRAYSIZE(DynamicLinkLibrary); i++)
	{
		HMODULE DllAddress = (HMODULE)NULL;
		HMODULE RemoteDllAddress = (HMODULE)NULL;
		
		const wchar_t* DllName = (const wchar_t*)DynamicLinkLibrary[i];

		sprintf_s( StatusText, "File: [%ws]%*s", DllName, 45 - wcslen(DllName), "" );
		Progress.update( StatusText,(double)( i + 1) / (double)(ARRAYSIZE(DynamicLinkLibrary)) );

		if ( i < 3 )
			DllAddress = GetModuleHandleW( DllName );
			//the first three system dlls are always mapped to the same address in every process
		else
		{
			struct RemoteProcessModuleInfo RemoteDllInfo = {};
			ZeroMemory(&RemoteDllInfo, sizeof(struct RemoteProcessModuleInfo) );

			if ( GetRemoteProcessModuleInfo( ProcessId, DllName, &RemoteDllInfo ) == true )
			{
				BYTE* DiskDllImage = (BYTE*)NULL;
				DWORD DiskDllImageSize = (DWORD)NULL;
				LoadFileToMemory( RemoteDllInfo.szExePath, &DiskDllImage, &DiskDllImageSize );

				if ( DiskDllImage != NULL && DiskDllImageSize != NULL )
				{
					RemoteDllAddress = (HMODULE)RemoteDllInfo.modBaseAddr;
					DllAddress = (HMODULE)ManualMapDynamicLinkLibrary( DiskDllImage, (DWORD_PTR)RemoteDllInfo.modBaseAddr );
					free( DiskDllImage );
				}
			}
		}
		if ( DllAddress == NULL ) continue;
		
		IMAGE_DOS_HEADER* DosHeader = (IMAGE_DOS_HEADER*)DllAddress;
		const IMAGE_NT_HEADERS* NtHeaders = (IMAGE_NT_HEADERS*)ImageNtHeader( DosHeader );
		if ( NtHeaders == NULL ) continue;

		const WORD NumberOfSections = NtHeaders->FileHeader.NumberOfSections;
		if ( NumberOfSections < 1 ) continue;
		
		IMAGE_SECTION_HEADER* SectionHeaders = (IMAGE_SECTION_HEADER*)( (DWORD_PTR)NtHeaders + sizeof(IMAGE_NT_HEADERS) );
		for (WORD j = 0; j < (WORD)NumberOfSections; j++)
		{
			const IMAGE_SECTION_HEADER* SectionHeader = &SectionHeaders[j];
			if ( (SectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) != IMAGE_SCN_MEM_EXECUTE ) continue;

			//Ignore discardable sections:
			if ( (SectionHeader->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) == IMAGE_SCN_MEM_DISCARDABLE ) continue;

			const DWORD_PTR VirtualAddress = (DWORD_PTR)SectionHeader->VirtualAddress + (DWORD_PTR)DosHeader;
			const DWORD VirtualSize = SectionHeader->Misc.VirtualSize;

			DWORD SearchOffset = 0;

			//for each ~100KB of data create a thread
			const DWORD PerThreadDataSize = 1024 * 100;
			const DWORD ThreadCount = ( VirtualSize / PerThreadDataSize ) + 1;

			HANDLE* ThreadHandles = (HANDLE*)malloc( sizeof(HANDLE) * ThreadCount );
			__ASSERT__( ThreadHandles != NULL );

			HANDLE* ThreadParametersList = (HANDLE*)malloc( sizeof(SearchThreadParameters) * (ThreadCount+1) );
			__ASSERT__( ThreadParametersList != NULL );

			static LONG ActiveThreadCount = 0;
			InterlockedExchange( &ActiveThreadCount, ThreadCount );
			
			for (DWORD t = 0; t < ThreadCount; t++)
			{
				SearchThreadParameters* ThreadParameters = (SearchThreadParameters*)( (DWORD_PTR)ThreadParametersList + ( sizeof(SearchThreadParameters) * t ) );
				ZeroMemory( ThreadParameters, sizeof(SearchThreadParameters) );

				ThreadParameters->CriticalSection = (CRITICAL_SECTION*)&SearchThreadCriticalSection;

				ThreadParameters->hGame = hGame;

				ThreadParameters->DllAddress = DllAddress;
				ThreadParameters->RemoteDllAddress = RemoteDllAddress;

				ThreadParameters->VirtualAddress = VirtualAddress + (DWORD_PTR)SearchOffset;

				ThreadParameters->ActiveThreadCount = &ActiveThreadCount;

				ThreadParameters->NumberOfGadgetsFound = (DWORD)NULL;

				DWORD VS = PerThreadDataSize + SearchOffset;

				if ( VS > VirtualSize )
					 VS = VirtualSize - SearchOffset;
				else
					VS = PerThreadDataSize;
				ThreadParameters->VirtualSize = VS;

				if ( ThreadCount == 1 )
				{
					//Don't create a thread use the current one:
					ThreadHandles[t] = INVALID_HANDLE_VALUE;
					SearchDllThread( ThreadParameters );
					break;
				}
				else
				{
					HANDLE hThreadHandle = CreateThread( NULL, NULL, (LPTHREAD_START_ROUTINE)SearchDllThread, (void*)ThreadParameters, NULL, NULL );
					if ( hThreadHandle == NULL || hThreadHandle == INVALID_HANDLE_VALUE )
					{
						printf("ERROR: [%s] FAILED TO START \"SearchDllThread\" THREAD INDEX:[%u]\n",__FUNCTION__,t);
						_InterlockedDecrement( &ActiveThreadCount );
					}
					ThreadHandles[t] = hThreadHandle;
				}
			

				SearchOffset += PerThreadDataSize;
			}

			while ( ThreadCount > 1 && _InterlockedCompareExchange( &ActiveThreadCount, (long)0, (long)0 ) != (long)0 )
				Sleep( 1 );
		
			for (DWORD w = 0; w < ThreadCount; w++)
			{
				SearchThreadParameters* ThreadParameters = (SearchThreadParameters*)( (DWORD_PTR)ThreadParametersList + ( sizeof(SearchThreadParameters) * w ) );

				NumberOfGadgetsFound += ThreadParameters->NumberOfGadgetsFound;
				
				HANDLE hThreadHandle = ThreadHandles[w];
				if ( hThreadHandle != NULL && hThreadHandle != INVALID_HANDLE_VALUE )
					CloseHandle( hThreadHandle );
			}
			free( ThreadParametersList );
			free( ThreadHandles );
			//printf("Searching [%ws]->[%s] at [0x%X] Size:[0x%X]\n",DynamicLinkLibrary[i],SectionHeader->Name,VirtualAddress,VirtualSize);
		}
		if ( RemoteDllAddress != NULL )
		{
			const DWORD SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
			      DWORD MappedPageSize = (SizeOfImage / (DWORD)0x1000ui32) * (DWORD)0x1000ui32;
			if ( (SizeOfImage % (DWORD)0x1000ui32) != 0 )
				MappedPageSize += (DWORD)0x1000ui32;

			VirtualFree( (void*)DllAddress, NULL, MEM_RELEASE );
		}
	}

	DeleteCriticalSection( &SearchThreadCriticalSection );
	DWORD GadgetsCounter = 0;
	const DWORD TotalGadgetsCounter = (DWORD)(RopGadgets.size());
	for (DWORD r = 0; r < TotalGadgetsCounter; r++)
	{
		
		const RopCode* RG = RopGadgets.at(r);
		/*
		if ( RG->Addresses != 0 )
		{
			for (DWORD r2 = 0; r2 < (DWORD)RG->Addresses->Addresses.size(); r2++)
			{
				printf("[0x%X] [%s]\n",RG->Addresses->Addresses.at(r2),RG->Instruction);
			}
		}*/
		if ( RG->Addresses != 0 )
		{
			//printf("FOUND [%s] %u TIMES\n",RG->Instruction,RG->Addresses->Addresses.size());
			GadgetsCounter++;
			continue;
		}
		else
			;//printf("NOT FOUND [%s]\n",RG->Instruction);
	}
	printf("[+] [%u/%u] Gadgets found\n",GadgetsCounter,TotalGadgetsCounter);
}

void InitializeRopGadgets( /*IN*/ const HANDLE hGame )
{
	__ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );

	RopGadgets.clear();
	for (DWORD i = 0; i < (DWORD)ARRAYSIZE(g_RopGadgets); i++)
	{
		struct RopCode* RopGadget = &g_RopGadgets[i];
		RopGadget->Addresses = NULL;
		RopGadget->RefCntr = NULL;
		RopGadgets.push_back( RopGadget );
	}

	if ( g_CompilerSettings.SearchDlls == true )
		SearchRemoteDynamicLinkLibrary( hGame );

	if ( g_CompilerSettings.VirtualQuerySearch == true )
		VirtualQueryScanner( hGame );
}

void ReleaseRopGadgets( void )
{
	const DWORD GadgetCount = (DWORD)RopGadgets.size();
	for (DWORD i = 0; i < GadgetCount; i++)
	{
		struct RopCode* RopGadget = RopGadgets.at(i);
		if ( RopGadget != NULL )
		{
			RopCode::RopAddresses* RopAddresses = RopGadget->Addresses;
			if ( RopAddresses != NULL )
			{
				RopGadget->Destructor();
				RopGadget->Addresses = NULL; 

				//To prevent free after free ;)
				for (DWORD j = 0; j < GadgetCount; j++)
				{
					struct RopCode* RopGadget2 = RopGadgets.at(j);
					if ( RopGadget2 != NULL && RopGadget2->Addresses == RopAddresses )
						RopGadget2->Addresses = NULL;
				}
			}
		}
	}
	RopGadgets.clear();
}

void BringYourOwnGadgets( /*IN*/ const HANDLE hGame )
{
	__ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );

	PlacedGadgets.clear();

	DWORD NumberOfNotFoundGadgets = NULL;
	for (DWORD r = NULL; r < (DWORD)RopGadgets.size(); r++)
	{
		const RopCode* RG = RopGadgets.at(r);
		if ( RG->Addresses != NULL ) continue;
		NumberOfNotFoundGadgets++;
	}
	if ( NumberOfNotFoundGadgets == NULL ) return;

	DWORD RandomFlags[] = { PAGE_READWRITE, PAGE_EXECUTE_READWRITE };
	const DWORD ProtectionFlags = *(DWORD*)SelectRandomElement( RandomFlags, getArraySize( RandomFlags, DWORD ), sizeof(DWORD) );
	
	DWORD RandomSize = (DWORD)0x4000ui32;

	if ( (NumberOfNotFoundGadgets / (DWORD)10ui32) > 0 )
		RandomSize += (DWORD)0x1000ui32 * (NumberOfNotFoundGadgets / (DWORD)10ui32);

	RandomSize += (DWORD)( g_RandomGenerator.GetDword() % (DWORD)0x4001ui32 );

	DWORD GadgetBufferSize = (DWORD)( (DWORD)(RandomSize / 0x1000ui32) * 0x1000ui32 );
	if ( (DWORD)(RandomSize % 0x1000ui32) != (DWORD)NULL )
		GadgetBufferSize += (DWORD)0x1000ui32;

	BYTE* AllocatedMem = (BYTE*)VirtualAllocEx( hGame, NULL, GadgetBufferSize, MEM_COMMIT | MEM_RESERVE, ProtectionFlags );
	if ( AllocatedMem == NULL )
	{
		printf("[%s] ERROR FAILED TO ALLOCATE GADGET BUFFER [0x%X]\n",__FUNCTION__, GetLastError() );
		system("pause");
		 return;
	}
	SelfAllocatedGadgetBuffer = (DWORD_PTR)AllocatedMem;
	printf("[+] Allocating Gadget buffer [0x%p][0x%X]\n", AllocatedMem, GadgetBufferSize );
	

	BYTE* LocalBuffer = (BYTE*)malloc( GadgetBufferSize );
	__ASSERT__( LocalBuffer != NULL );

	g_RandomGenerator.GetBuffer( LocalBuffer, GadgetBufferSize );

	for (DWORD r = 0; r < (DWORD)RopGadgets.size(); r++)
	{
		RopCode* RG = RopGadgets.at(r);
		if ( RG->Addresses != NULL ) continue;
		
		DWORD RandomOffset = NULL;
		do
		{
			RandomOffset = g_RandomGenerator.GetDword() % ( GadgetBufferSize - RG->CodeLen - 1 );
		}
		while ( IsPositionOccupied( RandomOffset, RG->CodeLen + 1 ) != false );

		memcpy( (void*)( (DWORD_PTR)LocalBuffer + (DWORD_PTR)RandomOffset ), RG->Code, RG->CodeLen );

		RG->AddAddress( (DWORD_PTR)( (DWORD_PTR)AllocatedMem + (DWORD_PTR)RandomOffset) );

		struct GadgetPosition Info = {};
		ZeroMemory(&Info, sizeof(GadgetPosition) );

		Info.Start = RandomOffset;
		Info.End = RandomOffset + RG->CodeLen + 1;
		Info.RopGadget = RG;
		PlacedGadgets.push_back( Info );
		
		if ( (DWORD)(r+1) < (DWORD)(RopGadgets.size()) )
		{
			for (DWORD r2 = (DWORD)(r+1); r2 < (DWORD)(RopGadgets.size()); r2++)
			{
				struct RopCode* RG2 = RopGadgets.at(r2);
				if ( RG2->Addresses != NULL ) continue;
				if ( RG2->CodeLen != RG->CodeLen ) continue;
				if ( memcmp( RG2->Code, RG->Code, RG->CodeLen) != 0 ) continue;
				//same instruction:
				RG2->Addresses = RG->Addresses;
			}
		}
		
	}
	WriteProcessMemory( hGame, AllocatedMem, LocalBuffer, (SIZE_T)GadgetBufferSize, nullptr );
	free( LocalBuffer );

	DWORD NewRandomFlags[] = { PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE, PAGE_EXECUTE_WRITECOPY };

	DWORD NewProtectionFlags = *(DWORD*)SelectRandomElement( NewRandomFlags, getArraySize( NewRandomFlags, DWORD ), sizeof(DWORD) );
	DWORD dwOldProtection = NULL;
	VirtualProtectEx( hGame, AllocatedMem, (SIZE_T)GadgetBufferSize, NewProtectionFlags, &dwOldProtection );

	for (DWORD Counter = 0; Counter < (DWORD)( GadgetBufferSize / 0x1000ui32 ); Counter++)
	{
		NewProtectionFlags = *(DWORD*)SelectRandomElement( NewRandomFlags, getArraySize( NewRandomFlags, DWORD ), sizeof(DWORD) );
		dwOldProtection = NULL;
		VirtualProtectEx( hGame, AllocatedMem + (DWORD)(Counter * 0x1000ui32), (SIZE_T)0x1000, NewProtectionFlags, &dwOldProtection );
	}
	
}

void RemoveUnusedGadgets( /*IN*/ const HANDLE hGame )
{
	__ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );

	DWORD RemovedGadgetCounter = NULL;
	const UINT PlacedGadgetsCount = (UINT)PlacedGadgets.size();
	if ( PlacedGadgetsCount == NULL )
		return;
	
	__ASSERT__( SelfAllocatedGadgetBuffer != NULL );

	for (UINT i = 0; i < (UINT)PlacedGadgetsCount; i++)
	{
		const struct GadgetPosition* GP = &PlacedGadgets.at(i);

		DWORD Ref = NULL;

		const RopCode* RG = GP->RopGadget;
		for (DWORD r2 = 0; r2 < (DWORD)(RopGadgets.size()); r2++)
		{
			const struct RopCode* RG2 = RopGadgets.at(r2);
			if ( RG2->Addresses == NULL ) continue;

			if ( RG2->CodeLen != RG->CodeLen ) continue;
			if ( __memcmp__( RG2->Code, RG->Code, RG->CodeLen) != 0 ) continue;
			//same instruction:
			Ref += RG2->RefCntr;
		}

		if ( Ref == 0 )
		{
			//printf("REMOVING: [%s] at [0x%X]\n",RG->Instruction,GP->Start);
			RemovedGadgetCounter++;
			BYTE* RandomBuffer = (BYTE*)malloc( RG->CodeLen + 1 );
			__ASSERT__( RandomBuffer != NULL );

			g_RandomGenerator.GetBuffer( RandomBuffer, RG->CodeLen + 1 );
			DWORD dwOldProtection = NULL;
			VirtualProtectEx( hGame, (void*)GP->Start, RG->CodeLen, PAGE_EXECUTE_READWRITE, &dwOldProtection );
			WriteProcessMemory( hGame, (void*)GP->Start, RandomBuffer, RG->CodeLen, NULL );
			VirtualProtectEx( hGame, (void*)GP->Start, RG->CodeLen, dwOldProtection, &dwOldProtection );
			free( RandomBuffer ); RandomBuffer = NULL;
		}
		else
		{
			//printf("RopGadget: [%s]\n",RG->Instruction);
		}

	}
	PlacedGadgets.clear();

	if ( RemovedGadgetCounter == PlacedGadgetsCount )
	{
		//delete page because its not used!
		VirtualFreeEx( hGame, (PVOID)SelfAllocatedGadgetBuffer, NULL, MEM_RELEASE );
		SelfAllocatedGadgetBuffer = NULL;
	}

	
	printf("[+] Removed %u unused Gadgets\n", RemovedGadgetCounter);
}

void AllocateVirtualRegs( /*IN*/ const HANDLE hGame )
{
	__ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );

	DWORD RandomFlags[] = { PAGE_READWRITE, PAGE_EXECUTE_READWRITE };

	for (DWORD i = 0; i < (DWORD)ARRAYSIZE(VirtualRegisterAddresses); i++)
	{
		const DWORD ProtectionFlags = *(DWORD*)SelectRandomElement( RandomFlags, getArraySize( RandomFlags, DWORD ), sizeof(DWORD) );

		BYTE* RemoteMemory = (BYTE*)VirtualAllocEx( hGame, 0, 0x1000, MEM_COMMIT | MEM_RESERVE, ProtectionFlags );
		if ( RemoteMemory == NULL )
		{
			printf("ERROR: Failed to allocate Virtual Register %u with error:[0x%X]\n",i,GetLastError());
			continue;
		}

		BYTE* localPtr = (BYTE*)malloc( 0x1000 );
		__ASSERT__( localPtr != NULL );

		g_RandomGenerator.GetBuffer( localPtr, 0x1000 );

		WriteProcessMemory( hGame, RemoteMemory, localPtr, (SIZE_T)0x1000, 0 );

		RemoteMemory += ( g_RandomGenerator.GetDword() % ( 0x1000 - sizeof(DWORD_PTR) ) );
		VirtualRegisterAddresses[i] = (DWORD_PTR)RemoteMemory;
		printf("[+] Allocated Virtual Register %u -> 0x%p\n", i, (PVOID)RemoteMemory );
		
		free( localPtr );
	}
	const DWORD ProtectionFlags = *(DWORD*)SelectRandomElement( RandomFlags, getArraySize( RandomFlags, DWORD ), sizeof(DWORD) );

	VirtualMemoryRegisterAddresses = (DWORD_PTR)VirtualAllocEx( hGame, 0, (SIZE_T)0x2000, MEM_COMMIT | MEM_RESERVE, ProtectionFlags );
	printf("[+] Allocated Virtual Memory Register -> 0x%p\n", (PVOID)VirtualMemoryRegisterAddresses);
}

```

`RopCompiler/Gadgets.h`:

```h
#pragma once
//https://defuse.ca/online-x86-assembler.htm

RopCode g_RopGadgets[] = {
    {"mov eax, ecx",                (unsigned __int8*)"\x8B\xC1\xC3", 3,        (0), 0},
    {"mov eax, edx",                (unsigned __int8*)"\x89\xD0\xC3", 3,        (0), 0},
    {"mov eax, ebx",                (unsigned __int8*)"\x89\xD8\xC3", 3,        (0), 0},
    
    //The following instructions are implemented by using other instructions [via the AdvancedInstructionHandler callbacks] so they can be used:
    //{"mov ecx, eax",              (unsigned __int8*)"\x89\xC1\xC3", 3,        (0), 0},//
    //{"mov ebx, ecx",              (unsigned __int8*)"\x89\xCB\xC3", 3,        (0), 0},//
    //{"mov ebx, eax",              (unsigned __int8*)"\x8B\xD8\xC3", 3,        (0), 0},//
    //{"mov edx, eax",              (unsigned __int8*)"\x89\xC2\xC3", 3,        (0), 0},//
    //{"mov DWORD PTR[eax], ebx",   (unsigned __int8*)"\x89\x18\xC3", 3,        (0), 0},//
    //{"mov BYTE PTR [eax],bl",     (unsigned __int8*)"\x88\x18\xC3", 3,        (0), 0},//
    //{"mov BYTE PTR [eax],ebx",    (unsigned __int8*)"\x88\x18\xC3", 3,        (0), 0},//

    {"sub eax, ecx",                (unsigned __int8*)"\x29\xC8\xC3", 3,        (0), 0},
    //{"sub ebx, edx",              (unsigned __int8*)"\x29\xD3\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND

    {"lea eax,[ecx+4]",             (unsigned __int8*)"\x8D\x41\x04\xC3", 4,    (0), 0},

    {"lea eax,[eax+4]",             (unsigned __int8*)"\x83\xC0\x04\xC3", 4,    (0), 0},
    {"add eax, 4",                  (unsigned __int8*)"\x83\xC0\x04\xC3", 4,    (0), 0},
    {"add eax, 0x4",                (unsigned __int8*)"\x83\xC0\x04\xC3", 4,    (0), 0},

    {"inc eax",                     (unsigned __int8*)"\x40\xC3", 2,            (0), 0},
    {"dec eax",                     (unsigned __int8*)"\x48\xC3", 2,            (0), 0},


    {"inc edx",                     (unsigned __int8*)"\x42\xC3", 2,            (0), 0},
    {"dec edx",                     (unsigned __int8*)"\x4A\xC3", 2,            (0), 0},

    
    {"add eax, ebx",                (unsigned __int8*)"\x01\xD8\xC3", 3,        (0), 0},

    {"mov DWORD PTR[ebx], eax",     (unsigned __int8*)"\x89\x03\xC3", 3,        (0), 0},
    
    
    {"mov BYTE PTR [ebx],eax",      (unsigned __int8*)"\x88\x03\xC3", 3,        (0), 0},
    {"mov BYTE PTR [ebx],al",       (unsigned __int8*)"\x88\x03\xC3", 3,        (0), 0},

    {"pop eax",                     (unsigned __int8*)"\x58\xC3", 2,            (0), 0},
    {"pop ecx",                     (unsigned __int8*)"\x59\xC3", 2,            (0), 0},
    {"pop edx",                     (unsigned __int8*)"\x5A\xC3", 2,            (0), 0},
    {"pop ebx",                     (unsigned __int8*)"\x5B\xC3", 2,            (0), 0},
    {"pop esp",                     (unsigned __int8*)"\x5C\xC3", 2,            (0), 0},
    {"pop ebp",                     (unsigned __int8*)"\x5D\xC3", 2,            (0), 0},
    {"pop esi",                     (unsigned __int8*)"\x5E\xC3", 2,            (0), 0},
    {"pop edi",                     (unsigned __int8*)"\x5F\xC3", 2,            (0), 0},
    {"pusha",                       (unsigned __int8*)"\x60\xC3", 2,            (0), 0},
    {"popa",                        (unsigned __int8*)"\x61\xC3", 2,            (0), 0},

    //USED BY VM TO READ FROM Virtual Registers
    {"mov eax, DWORD PTR[eax]",     (unsigned __int8*)"\x8B\x00\xC3", 3,        (0), 0},
    /*
    {"mov ecx, DWORD PTR[ecx]",     (unsigned __int8*)"\x8B\x09\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND
    {"mov edx, DWORD PTR[edx]",     (unsigned __int8*)"\x8B\x12\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND
    {"mov ebx, DWORD PTR[ebx]",     (unsigned __int8*)"\x8B\x1B\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND
    {"mov esp, DWORD PTR[esp]",     (unsigned __int8*)"\x8B\x24\x24\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"mov ebp, DWORD PTR[ebp]",     (unsigned __int8*)"\x8B\x6D\x00\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"mov esi, DWORD PTR[esi]",     (unsigned __int8*)"\x8B\x36\xC3", 3,        (0), 0},
    {"mov edi, DWORD PTR[edi]",     (unsigned __int8*)"\x8B\x3F\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND
    */
    {"cmovs eax,ecx",               (unsigned __int8*)"\x0F\x48\xC1\xC3", 4,    (0), 0},

    {"cmovc eax,ecx",               (unsigned __int8*)"\x0F\x42\xC1\xC3", 4,    (0), 0},

    /*
    {"cmovs esp,eax",               (unsigned __int8*)"\x0F\x48\xE0\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovs esp,eax",               (unsigned __int8*)"\x0F\x48\xE0\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovs esp,ecx",               (unsigned __int8*)"\x0F\x48\xE1\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovs esp,edx",               (unsigned __int8*)"\x0F\x48\xE2\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovs esp,ebx",               (unsigned __int8*)"\x0F\x48\xE3\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovs esp,ebp",               (unsigned __int8*)"\x0F\x48\xE5\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    */
    //{"cmovns eax,ecx",                (unsigned __int8*)"\x0F\x49\xC1\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    /*
    {"cmovns esp,eax",              (unsigned __int8*)"\x0F\x49\xE0\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovns esp,ecx",              (unsigned __int8*)"\x0F\x49\xE1\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovns esp,edx",              (unsigned __int8*)"\x0F\x49\xE2\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovns esp,ebx",              (unsigned __int8*)"\x0F\x49\xE3\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovns esp,ebp",              (unsigned __int8*)"\x0F\x49\xE5\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovne esp,ebx",              (unsigned __int8*)"\x0F\x45\xE3\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmove esp,ebx",               (unsigned __int8*)"\x0F\x44\xE3\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    */

    {"cmove eax,ecx",               (unsigned __int8*)"\x0F\x44\xC1\xC3", 4,    (0), 0},

    {"cmovne eax,ecx",              (unsigned __int8*)"\x0F\x45\xC1\xC3", 4,    (0), 0},

    
    /*
    {"cmovs ebp,ebx",               (unsigned __int8*)"\x0F\x48\xEB\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovs esi,ebx",               (unsigned __int8*)"\x0F\x48\xF3\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    {"cmovs edi,ebx",               (unsigned __int8*)"\x0F\x48\xFB\xC3", 4,    (0), 0},//REMOVED: NO GADGET FOUND
    */

    

    {"xchg eax,ecx",                (unsigned __int8*)"\x91\xC3", 2,            (0), 0},
    {"xchg ecx,eax",                (unsigned __int8*)"\x91\xC3", 2,            (0), 0},

    //{"xchg ebx,ecx",              (unsigned __int8*)"\x87\xCB\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND
    //{"xchg ecx,ebx",              (unsigned __int8*)"\x87\xCB\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND

    {"xchg edx,eax",                (unsigned __int8*)"\x92\xC3", 2,            (0), 0},
    {"xchg eax,edx",                (unsigned __int8*)"\x92\xC3", 2,            (0), 0},

    {"xchg ebx,eax",                (unsigned __int8*)"\x93\xC3", 2,            (0), 0},
    {"xchg eax,ebx",                (unsigned __int8*)"\x93\xC3", 2,            (0), 0},

    {"xchg esp,eax",                (unsigned __int8*)"\x94\xC3", 2,            (0), 0},
    {"xchg eax,esp",                (unsigned __int8*)"\x94\xC3", 2,            (0), 0},

    {"xchg ebp,eax",                (unsigned __int8*)"\x95\xC3", 2,            (0), 0},
    {"xchg eax,ebp",                (unsigned __int8*)"\x95\xC3", 2,            (0), 0},

    {"xchg esi,eax",                (unsigned __int8*)"\x96\xC3", 2,            (0), 0},
    {"xchg eax,esi",                (unsigned __int8*)"\x96\xC3", 2,            (0), 0},

    {"xchg edi,eax",                (unsigned __int8*)"\x97\xC3", 2,            (0), 0},
    {"xchg eax,edi",                (unsigned __int8*)"\x97\xC3", 2,            (0), 0},

    {"xchg esp,ebp",                (unsigned __int8*)"\x87\xEC\xC3", 3,        (0), 0},
    {"xchg ebp,esp",                (unsigned __int8*)"\x87\xEC\xC3", 3,        (0), 0},

    {"xchg esp,ebx",                (unsigned __int8*)"\x87\xDC\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND
    //{"xchg ebx,esp",              (unsigned __int8*)"\x87\xDC\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND
    
    //{"xchg esp,edx",              (unsigned __int8*)"\x87\xD4\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND
    //{"xchg edx,esp",              (unsigned __int8*)"\x87\xD4\xC3", 3,        (0), 0},//REMOVED: NO GADGET FOUND
    
    //Breakpoint:
    {"int3",                        (unsigned __int8*)"\xCC\xC3", 2,            (0), 0},

    //No-Operation:
    {"nop",                         (unsigned __int8*)"\x90\xC3", 2,            (0), 0},
};

```

`RopCompiler/GameOffsets.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>
#include "Util.h"
#include "dbghelp.h"
#include "GameOffsets.h"
#include "ASSERT.h"

DWORD_PTR OFFSET_GlowObjectManager = NULL;	// -> VR9
DWORD_PTR OFFSET_LocalPlayer = NULL;		// -> VR8
DWORD_PTR OFFSET_EntityList = NULL;			// -> VR7
DWORD_PTR OFFSET_FORCE_ATTACK = NULL;		// -> VR6

DWORD_PTR OFFSET_CrosshairId = NULL;		// -> VR5
DWORD_PTR OFFSET_TeamNum = NULL;			// -> VR4
DWORD_PTR OFFSET_bSpotted = NULL;			// -> VR3

DWORD_PTR GLOBAL_MinimumAddress = (DWORD_PTR)(0x10000);// -> VR0

bool IsValidCodeRegion( /*IN*/ const IMAGE_DOS_HEADER* DosHeader, /*IN*/ const DWORD_PTR Address )
{
	__ASSERT__( DosHeader != NULL );
	__ASSERT__( (DWORD_PTR)Address >= (DWORD_PTR)DosHeader );

	const DWORD_PTR RVA = (DWORD_PTR)Address - (DWORD_PTR)DosHeader;

	const IMAGE_NT_HEADERS* ImageNtHeader = (IMAGE_NT_HEADERS*)( (DWORD_PTR)DosHeader + (DWORD_PTR)DosHeader->e_lfanew );
	const IMAGE_SECTION_HEADER* SectionHeader = ImageRvaToSection( ImageNtHeader, (const PVOID)DosHeader, (ULONG)(RVA & 0xFFFFFFFF) );
	if ( SectionHeader == nullptr ) return false;
	const DWORD Flags = IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE;
	return (SectionHeader->Characteristics & Flags) == Flags;
}

DWORD ResolveToOffset( /*IN*/ const IMAGE_DOS_HEADER* DosHeader, /*IN*/ const DWORD_PTR Address )
{
	__ASSERT__( DosHeader != NULL );
	__ASSERT__( (DWORD_PTR)Address >= (DWORD_PTR)DosHeader );

	const DWORD_PTR RVA = (DWORD_PTR)Address - (DWORD_PTR)DosHeader;

	const IMAGE_NT_HEADERS* ImageNtHeader = (IMAGE_NT_HEADERS*)( (DWORD_PTR)DosHeader + (DWORD_PTR)DosHeader->e_lfanew );
	
	const DWORD_PTR VA = (DWORD_PTR)ImageRvaToVa( ImageNtHeader, DosHeader, (DWORD)(RVA & 0xFFFFFFFF) );
	return ( VA & 0xFFFFFFFF );
}

bool ClientDllSearchForOffsets( /*IN*/ const struct RemoteProcessModuleInfo* ClientDllInfo )
{
	__ASSERT__( ClientDllInfo != NULL );

	BYTE* ClientImage = (BYTE*)NULL;
	DWORD ClientImageSize = (DWORD)NULL;

	LoadFileToMemory( ClientDllInfo->szExePath, &ClientImage, &ClientImageSize );
	if ( ClientImage == NULL || ClientImageSize == NULL )
	{
		printf("ERROR: Failed to load [%ws] into memory!\n",ClientDllInfo->szModule);
		system("pause");
		return false;
	}
	printf("[+] Loaded [%ws] into memory [0x%p]!\n", ClientDllInfo->szModule, ClientImage );
	const IMAGE_DOS_HEADER* DosHeader = (IMAGE_DOS_HEADER*)ClientImage;
	const IMAGE_NT_HEADERS* NtHeader  = (IMAGE_NT_HEADERS*)ImageNtHeader( ClientImage );
	if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE || NtHeader == NULL )
	{
		printf("ERROR file [%ws] is not a valid PE-Image!\n", ClientDllInfo->szModule );
		system("pause");
		free( ClientImage );
		return false;
	}

	const DWORD VirtualImageBase = (DWORD)NtHeader->OptionalHeader.ImageBase;
	printf("[+] Search for offsets in [%ws]\n",ClientDllInfo->szModule);
	printf("-------------------------------------------------------------\n");

	OFFSET_GlowObjectManager = (DWORD_PTR)FindPattern( (HMODULE)ClientImage, ClientImageSize, "75 ?? 0F 57 C0 C7 05 ?? ?? ?? ?? 00 00 00 00 0F 11 05");
	if ( OFFSET_GlowObjectManager == NULL || IsValidCodeRegion( DosHeader, OFFSET_GlowObjectManager ) == false )
		printf("[!] ERROR OFFSET_GlowObjectManager NOT FOUND!\n");
	else
	{
		OFFSET_GlowObjectManager += (DWORD_PTR)18;
		OFFSET_GlowObjectManager = *(__int32*)OFFSET_GlowObjectManager - VirtualImageBase;
		printf("[+] OFFSET_GlowObjectManager: 0x%X\n",OFFSET_GlowObjectManager);
		OFFSET_GlowObjectManager += (DWORD_PTR)ClientDllInfo->modBaseAddr;
	}
	OFFSET_LocalPlayer = (DWORD_PTR)FindPattern( (HMODULE)ClientImage, ClientImageSize, "8D 34 85 ?? ?? ?? ?? 89 15 ?? ?? ?? ?? 8B 41 08 8B 48 04 83 F9 FF");
	if ( OFFSET_LocalPlayer == NULL || IsValidCodeRegion( DosHeader, OFFSET_LocalPlayer ) == false )
		printf("[!] ERROR OFFSET_LocalPlayer NOT FOUND!\n");
	else
	{
		OFFSET_LocalPlayer += (DWORD_PTR)3;
		OFFSET_LocalPlayer = *(__int32*)OFFSET_LocalPlayer + 4 - VirtualImageBase;
		printf("[+] OFFSET_LocalPlayer: 0x%X\n",OFFSET_LocalPlayer);
		OFFSET_LocalPlayer += (DWORD_PTR)ClientDllInfo->modBaseAddr;
	}
	
	
	OFFSET_FORCE_ATTACK = (DWORD_PTR)FindPattern( (HMODULE)ClientImage, ClientImageSize, "89 0D ?? ?? ?? ?? 8B 0D ?? ?? ?? ?? 8B F2 8B C1 83 CE 04");
	if ( OFFSET_FORCE_ATTACK == NULL || IsValidCodeRegion( DosHeader, OFFSET_FORCE_ATTACK ) == false )
		printf("[!] ERROR OFFSET_FORCE_ATTACK NOT FOUND!\n");
	else
	{
		OFFSET_FORCE_ATTACK += (DWORD_PTR)2;
		OFFSET_FORCE_ATTACK = *(__int32*)OFFSET_FORCE_ATTACK - VirtualImageBase;
		printf("[+] OFFSET_FORCE_ATTACK: 0x%X\n",OFFSET_FORCE_ATTACK);
		OFFSET_FORCE_ATTACK += (DWORD_PTR)ClientDllInfo->modBaseAddr;
	}

	OFFSET_EntityList = (DWORD_PTR)FindPattern( (HMODULE)ClientImage, ClientImageSize, "8B 89 ?? ?? ?? ?? 85 C9 74 52");
	if ( OFFSET_EntityList == NULL || IsValidCodeRegion( DosHeader, OFFSET_EntityList ) == false )
		printf("[!] ERROR OFFSET_EntityList NOT FOUND!\n");
	else
	{
		OFFSET_EntityList += (DWORD_PTR)2;
		OFFSET_EntityList = *(__int32*)OFFSET_EntityList - VirtualImageBase;
		printf("[+] OFFSET_EntityList: 0x%X\n",OFFSET_EntityList);
		OFFSET_EntityList += (DWORD_PTR)ClientDllInfo->modBaseAddr;
	}
	

	OFFSET_CrosshairId = (DWORD_PTR)FindPattern( (HMODULE)ClientImage, ClientImageSize, "73 ?? 8B 81 ?? ?? 00 00 85 C0 75 ?? 8B 81 ?? ?? 00 00 85 C0 74");
	if ( OFFSET_CrosshairId == NULL || IsValidCodeRegion( DosHeader, OFFSET_CrosshairId ) == false )
		printf("[!] ERROR OFFSET_CrosshairId NOT FOUND!\n");
	else
	{
		OFFSET_CrosshairId += (DWORD_PTR)4;
		OFFSET_CrosshairId = *(__int32*)OFFSET_CrosshairId;
		printf("[+] OFFSET_CrosshairId: 0x%X\n",OFFSET_CrosshairId);
	}
	
	
	OFFSET_bSpotted = (DWORD_PTR)FindPattern( (HMODULE)ClientImage, ClientImageSize, "80 B9 ?? ?? ?? 00 00 74 ?? 8B 41 08");
	if ( OFFSET_bSpotted == NULL || IsValidCodeRegion( DosHeader, OFFSET_bSpotted ) == false )
		printf("[!] ERROR OFFSET_bSpotted NOT FOUND!\n");
	else
	{
		OFFSET_bSpotted += 2;
		OFFSET_bSpotted = *(__int32*)OFFSET_bSpotted;
		printf("[+] OFFSET_bSpotted: 0x%X\n",OFFSET_bSpotted);
	}


	OFFSET_TeamNum = (DWORD_PTR)0xF4;
	printf("[+] OFFSET_TeamNum: 0x%X\n",OFFSET_TeamNum);

	printf("-------------------------------------------------------------\n");

	ZeroMemory( ClientImage, ClientImageSize );
	free( ClientImage ); ClientImage = NULL;

	return true;
}
```

`RopCompiler/GameOffsets.h`:

```h
#pragma once
extern DWORD_PTR OFFSET_GlowObjectManager;// -> VR9
extern DWORD_PTR OFFSET_LocalPlayer;// -> VR8
extern DWORD_PTR OFFSET_EntityList;// -> VR7
extern DWORD_PTR OFFSET_FORCE_ATTACK;// -> VR6

extern DWORD_PTR OFFSET_CrosshairId;// -> VR5
extern DWORD_PTR OFFSET_TeamNum;// -> VR4
extern DWORD_PTR OFFSET_bSpotted;// -> VR3

extern DWORD_PTR GLOBAL_MinimumAddress;// -> VR0

bool ClientDllSearchForOffsets( /*IN*/ const struct RemoteProcessModuleInfo* ClientDllInfo );
```

`RopCompiler/Main.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>
#include "Compiler.h"
#include "Util.h"
#include "GameOffsets.h"
#include "RandomGenerator.h"
#include "ASSERT.h"


//https://github.com/Speedi13/CPUID
#include "CpuInformation.h"

int __cdecl main( /*IN*/ const int argc, /*IN*/ const CHAR* argv[])
{
	UNREFERENCED_PARAMETER( argc );
	UNREFERENCED_PARAMETER( argv );

	InitializeConsole();	

	EnableAllPrivileges();

	//Retrieve cpu-information using the CPUID instruction
	//https://github.com/Speedi13/CPUID
	//=> https://en.wikipedia.org/wiki/CPUID
	const struct CpuInfo CpuInformation = CpuInfo();

	//Check cpu-feature information:
	g_ConditionalMoveSupported = CpuInformation.AMDFeatureExtendedInformation.CMOV || CpuInformation.FeatureInformation.CMOV;
	
	//https://en.wikipedia.org/wiki/RdRand
	g_HardwareRngSupported_RDRND  = CpuInformation.FeatureInformation.RDRND;
	g_HardwareRngSupported_RDSEED = CpuInformation.FeatureExtendedInformation.RDSEED;
	
	if ( g_ConditionalMoveSupported != true )
		printf("WARNING: WTF Seems like your CPU doesn't support conditional moves\n");

	if ( g_HardwareRngSupported_RDRND == true )
		printf("[+] Hardware RDRND supported\n");
	if ( g_HardwareRngSupported_RDSEED == true )
		printf("[+] Hardware RDSEED supported\n");

	if ( g_HardwareRngSupported_RDRND == true || g_HardwareRngSupported_RDSEED == true )
	{
		//check if hardware random number generator is bugged.
		//Some CPUs always return the same for some reason.
		if ( g_RandomGenerator.checkHardwareRNG() == false )
		{
			g_HardwareRngSupported_RDRND = false;
			g_HardwareRngSupported_RDSEED = false;
		}
	}
	
	g_RandomGenerator.Initialize();

	char RandomAsciiText[64] = {};
	g_RandomGenerator.GetString( RandomAsciiText, 64 );

	SetConsoleTitleA( RandomAsciiText );

	//Turn Ascii string in to Wide-Char:
	RandomAsciiText[ 62 ] = NULL;
	for (DWORD i = 0; i < 64; i+=2)
		RandomAsciiText[ i + 1 ] = NULL;

	const WCHAR* FileDialogTitle = L"[ROP-Assembly code file]";
	memcpy( (PVOID)&RandomAsciiText[6], (PVOID)FileDialogTitle, wcslen(FileDialogTitle)*2);

	const wchar_t* SourceCodeFilePath = OpenFileDialog( (LPCWSTR)RandomAsciiText );
	if ( SourceCodeFilePath == NULL || SourceCodeFilePath[0] == NULL )
		return ERROR_SUCCESS;

	const
	//acquire highest priority possible to reduce the time this program is running:
	DWORD PriorityClasses[] = { (DWORD)REALTIME_PRIORITY_CLASS, (DWORD)HIGH_PRIORITY_CLASS, (DWORD)ABOVE_NORMAL_PRIORITY_CLASS };
	for (DWORD i = 0; i < 3; i++)
		if ( SetPriorityClass( GetCurrentProcess(), PriorityClasses[i] ) == TRUE ) 
			break;

	printf("[+] Searching for game...\n");

	HANDLE hGame = INVALID_HANDLE_VALUE;

	enum GameIndexEnum
	{
		Game_CSGO,
		Game_BF3,
		Game_BF4,
		Game_Invalid,
	};
	const char*
	GameExecutables[] = {
		"csgo.exe",		// => Game_CSGO
		"bf3.exe",		// => Game_BF3
		"bf4_x86.exe",	// => Game_BF4
	};
	DWORD GameIndex = Game_Invalid;

	unsigned long ProcessId = (unsigned long)NULL;
	while ( hGame == INVALID_HANDLE_VALUE )
	{
		Sleep( 100 );
		
		for ( GameIndex = Game_CSGO ; GameIndex < ARRAYSIZE(GameExecutables) && ProcessId < 8; GameIndex++)
			ProcessId = GetProcessIdByName( GameExecutables[GameIndex] );
		
		GameIndex -= 1;

		if ( ProcessId < 8 )
			continue;

		hGame = OpenProcess( PROCESS_ALL_ACCESS, FALSE, ProcessId );
		if ( hGame == NULL || hGame == INVALID_HANDLE_VALUE )
		{
			hGame = INVALID_HANDLE_VALUE;
			ProcessId = 0;
			printf("[!] ERROR: failed to access process id:[0x%X] error:[0x%X]!\n",ProcessId,GetLastError());
		}
	}
	if ( GameIndex == Game_CSGO )
	{
		printf( "[+] CSGO ProcessId: %u\n", ProcessId );
	
		struct RemoteProcessModuleInfo ClientDllInfo = {};
		ZeroMemory(&ClientDllInfo, sizeof(struct RemoteProcessModuleInfo) );

		while ( GetRemoteProcessModuleInfo( ProcessId, L"client_panorama.dll", &ClientDllInfo ) == false &&
			GetRemoteProcessModuleInfo( ProcessId, L"client.dll",          &ClientDllInfo ) == false    )
			Sleep( 3000 );
	
		if ( (DWORD_PTR)ClientDllInfo.modBaseAddr != (DWORD_PTR)ClientDllInfo.hModule )
		{
			printf("ERROR: ClientDllInfo seems to be corrupted!\n");
			system("pause");
		}
		const DWORD_PTR ClientDllAddress = (DWORD_PTR)ClientDllInfo.hModule;

		printf("[+] CSGO Client dll: 0x%X\n",ClientDllAddress);

		ClientDllSearchForOffsets( &ClientDllInfo );
	}
	else
	if ( GameIndex == Game_BF3 )
		printf( "[+] BF3 ProcessId: %u\n", ProcessId );
	else
	if ( GameIndex == Game_BF4 )
		printf( "[+] BF4 ProcessId: %u\n", ProcessId );

	BYTE* AsmSourceCode = (BYTE*)NULL;
	DWORD AsmSourceCodeSize = (DWORD)NULL;

	if ( LoadFileToMemory( SourceCodeFilePath, &AsmSourceCode, &AsmSourceCodeSize ) != true 
		|| AsmSourceCode == NULL || AsmSourceCodeSize < (DWORD)(2) )
	{
		printf("ERROR while loading source-code file [%ws]\n",SourceCodeFilePath);
		system("pause");
	}
	AsmSourceCode[AsmSourceCodeSize] = 0;

	/////////////////////////// Default settings ///////////////////////////
	g_CompilerSettings.UseRandomPadding = false;
	g_CompilerSettings.g_constMaxObfuscationPaddingEntrys = 8;
	g_CompilerSettings.PrintDebugOutput = false;
	g_CompilerSettings.SearchDlls = true;
	g_CompilerSettings.VirtualQuerySearch = true;

	//to be even more undetected place the rop-chain into the original stack
	g_CompilerSettings.HijackThreadStack = true;
	////////////////////////////////////////////////////////////////////////

	//Read settings from source-code file
	GetCompilerSettings( (char*)AsmSourceCode, strlen((char*)AsmSourceCode), &g_CompilerSettings );

	//Search for Rop-Gadgets:
	InitializeRopGadgets( hGame );

	//Allocate the Gadgets that weren't found:
	BringYourOwnGadgets( hGame );

	DWORD_PTR StackTable = (DWORD_PTR)NULL;
	DWORD_PTR StackTableStart = (DWORD_PTR)NULL;
	HANDLE hThreadHandle = INVALID_HANDLE_VALUE;
	HANDLE* pThreadHandle = &hThreadHandle;
	if ( g_CompilerSettings.HijackThreadStack != true )
		pThreadHandle = NULL;

	CompileCode( (char*)AsmSourceCode, hGame, &StackTable, &StackTableStart, pThreadHandle );

	ZeroMemory( AsmSourceCode, AsmSourceCodeSize );
	free( AsmSourceCode );

	RemoveUnusedGadgets( hGame );

	SYSTEM_INFO SystemInfo = {};
	ZeroMemory(&SystemInfo, sizeof(SYSTEM_INFO) );

	GetSystemInfo( &SystemInfo );

	GLOBAL_MinimumAddress = (DWORD_PTR)SystemInfo.lpMinimumApplicationAddress;
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	printf("-------------------------------------------------------------\n");
	if ( GameIndex == Game_CSGO )
	{
		
		printf("[+] Initializing VR9 -> OFFSET_GlowObjectManager\n");
		WriteProcessMemory( hGame, (LPVOID)VirtualRegisterAddresses[9], (LPCVOID)&OFFSET_GlowObjectManager, sizeof(DWORD_PTR), NULL );

		printf("[+] Initializing VR8 -> OFFSET_LocalPlayer\n");
		WriteProcessMemory( hGame, (LPVOID)VirtualRegisterAddresses[8], (LPCVOID)&OFFSET_LocalPlayer,       sizeof(DWORD_PTR), NULL );

		printf("[+] Initializing VR7 -> OFFSET_EntityList\n");
		WriteProcessMemory( hGame, (LPVOID)VirtualRegisterAddresses[7], (LPCVOID)&OFFSET_EntityList,        sizeof(DWORD_PTR), NULL );

		printf("[+] Initializing VR6 -> OFFSET_FORCE_ATTACK\n");
		WriteProcessMemory( hGame, (LPVOID)VirtualRegisterAddresses[6], (LPCVOID)&OFFSET_FORCE_ATTACK,      sizeof(DWORD_PTR), NULL );

		printf("[+] Initializing VR5 -> OFFSET_CrosshairId\n");
		WriteProcessMemory( hGame, (LPVOID)VirtualRegisterAddresses[5], (LPCVOID)&OFFSET_CrosshairId,       sizeof(DWORD_PTR), NULL );

		printf("[+] Initializing VR4 -> OFFSET_TeamNum\n");
		WriteProcessMemory( hGame, (LPVOID)VirtualRegisterAddresses[4], (LPCVOID)&OFFSET_TeamNum,           sizeof(DWORD_PTR), NULL );

		printf("[+] Initializing VR3 -> OFFSET_bSpotted\n");
		WriteProcessMemory( hGame, (LPVOID)VirtualRegisterAddresses[3], (LPCVOID)&OFFSET_bSpotted,          sizeof(DWORD_PTR), NULL );
	}
	printf("[+] Initializing VR0 -> GLOBAL_MinimumAddress\n");
	WriteProcessMemory	  ( hGame, (LPVOID)VirtualRegisterAddresses[0], (LPCVOID)&GLOBAL_MinimumAddress,    sizeof(DWORD_PTR), NULL );
	printf("-------------------------------------------------------------\n");
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	printf("[+] Rop-Chain start: 0x%p\n",(PVOID)StackTableStart);
	DWORD ThreadId = (DWORD)0;

	if ( g_CompilerSettings.HijackThreadStack == true && pThreadHandle != NULL )
	{
		ThreadId = GetThreadId( hThreadHandle );
		const
		DWORD ThreadSuspendCount = ResumeThread( hThreadHandle );
		if ( ThreadSuspendCount == (DWORD)(0xFFFFFFFFui32) )
		{
			printf("ERROR ResumeThread failed: 0x%X\n",GetLastError());
			system("pause");
		}
		CloseHandle( hThreadHandle );
	}
	else
		ThreadId = ExecuteRopChain( hGame, StackTableStart );

	CloseHandle( hGame );

	free( (void*)SourceCodeFilePath );

	g_RandomGenerator.release();

	ReleaseRopGadgets();

	SetPriorityClass( GetCurrentProcess(), NORMAL_PRIORITY_CLASS );

	if ( ThreadId > (DWORD)NULL )
	{
		char MessageBoxMsg[64] = {};
		sprintf_s( MessageBoxMsg, "ROP-Chain started in thread %u!", ThreadId );

		MessageBoxA( NULL, MessageBoxMsg, "ROP-Compiler", MB_OK | MB_ICONINFORMATION );
	}
	else
		system("pause");

	ClearConsole();

	return ERROR_SUCCESS;
}

```

`RopCompiler/RandomGenerator.cpp`:

```cpp
#include <Windows.h>
#include "ASSERT.h"

#include <bcrypt.h>

#include "Compiler.h"
#include "Util.h"
#include "RandomGenerator.h"

#include <Psapi.h>

#include <immintrin.h> //RDRAND and RDSEED instructions

RandomGenerator g_RandomGenerator = {};

struct WinApiCryptGenRandom
{
    HMODULE ADVAPI32;
    HCRYPTPROV hCryptProv;

    ///////////////////////////// API Functions /////////////////////////////
    BOOL (WINAPI* _CryptAcquireContextA)(
    _Out_       HCRYPTPROV  *phProv,
    _In_opt_    LPCSTR    szContainer,
    _In_opt_    LPCSTR    szProvider,
    _In_        DWORD       dwProvType,
    _In_        DWORD       dwFlags
    );

    BOOL (WINAPI* _CryptReleaseContext)(
    _In_    HCRYPTPROV  hProv,
    _In_    DWORD       dwFlags
    );

    BOOL (WINAPI* _CryptGenRandom)(
    _In_                            HCRYPTPROV  hProv,
    _In_                            DWORD   dwLen,
    _Inout_updates_bytes_(dwLen)    BYTE    *pbBuffer
    );
    /////////////////////////////////////////////////////////////////////////

    BOOL WinApiCryptGenRandom::Initialize( void )
    {
        this->hCryptProv = NULL;

        this->ADVAPI32 = LoadLibraryW( L"ADVAPI32.dll" );
        if ( this->ADVAPI32 == NULL )
            return FALSE;

        this->_CryptAcquireContextA = ( decltype(this->_CryptAcquireContextA) ) GetProcAddress( ADVAPI32, "CryptAcquireContextA" );
        this->_CryptReleaseContext  = ( decltype(this->_CryptReleaseContext) )  GetProcAddress( ADVAPI32, "CryptReleaseContext" );
        this->_CryptGenRandom       = ( decltype(this->_CryptGenRandom) )       GetProcAddress( ADVAPI32, "CryptGenRandom" );

        if (    this->_CryptAcquireContextA == NULL
            ||  this->_CryptReleaseContext == NULL 
            ||  this->_CryptGenRandom == NULL)
        {
            this->ADVAPI32 = NULL;
            return FALSE;
        }

        return this->_CryptAcquireContextA( &this->hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT ); 
    }
    BOOL WinApiCryptGenRandom::release( void )
    {
        if ( this->ADVAPI32 == NULL || this->hCryptProv == NULL )
            return TRUE;
        return this->_CryptReleaseContext( this->hCryptProv, 0 ); 
    }

    //https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom
    bool WinApiCryptGenRandom::Random( /*OUT*/ BYTE *pbBuffer, /*IN*/ DWORD dwLen)
    {
        if (this->hCryptProv == NULL || this->ADVAPI32 == NULL)
            return false;

        __ASSERT__( pbBuffer != NULL );
        __ASSERT__( dwLen > 0 );

        return this->_CryptGenRandom( this->hCryptProv, dwLen, (BYTE*)pbBuffer ) == TRUE;
    }
};


//https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom
struct WinApiCryptGenRandomV2
{
    BCRYPT_ALG_HANDLE hAlgorithm;
    HMODULE BCRYPT;

    ///////////////////////////// API Functions /////////////////////////////
    NTSTATUS (WINAPI* _BCryptOpenAlgorithmProvider)(
    _Out_       BCRYPT_ALG_HANDLE   *phAlgorithm,
    _In_        LPCWSTR pszAlgId,
    _In_opt_    LPCWSTR pszImplementation,
    _In_        ULONG   dwFlags
    );

    NTSTATUS (WINAPI* _BCryptCloseAlgorithmProvider)(
    _Inout_ BCRYPT_ALG_HANDLE   hAlgorithm,
    _In_    ULONG   dwFlags
    );

    NTSTATUS (WINAPI* _BCryptGenRandom)(
    _In_opt_                        BCRYPT_ALG_HANDLE   hAlgorithm,
    _Inout_updates_bytes_all_(cbBuffer)   PUCHAR  pbBuffer,
    _In_                            ULONG   cbBuffer,
    _In_                            ULONG   dwFlags
    );
    /////////////////////////////////////////////////////////////////////////

    BOOL WinApiCryptGenRandomV2::Initialize( /*IN*/ bool UseDualEllipticCurve /*NSA backdoored RNG*/ )
    {
        this->hAlgorithm = NULL;

        this->BCRYPT = LoadLibraryW( L"bcrypt.dll" );
        if ( this->BCRYPT == NULL )
            return FALSE;

        this->_BCryptOpenAlgorithmProvider  = ( decltype(this->_BCryptOpenAlgorithmProvider) )  GetProcAddress( BCRYPT, "BCryptOpenAlgorithmProvider" );
        this->_BCryptCloseAlgorithmProvider = ( decltype(this->_BCryptCloseAlgorithmProvider) ) GetProcAddress( BCRYPT, "BCryptCloseAlgorithmProvider" );
        this->_BCryptGenRandom              = ( decltype(this->_BCryptGenRandom) )              GetProcAddress( BCRYPT, "BCryptGenRandom" );


        LPCWSTR AlogName = UseDualEllipticCurve ? BCRYPT_RNG_DUAL_EC_ALGORITHM : BCRYPT_RNG_FIPS186_DSA_ALGORITHM;

        return this->_BCryptOpenAlgorithmProvider( &this->hAlgorithm, AlogName ,0 ,0 ) == 0;
    }

    BOOL WinApiCryptGenRandomV2::release( void )
    {
        if ( this->BCRYPT == NULL )
            return TRUE;

        BOOL Result = FALSE;

        if ( this->hAlgorithm != NULL )
            Result = this->_BCryptCloseAlgorithmProvider( &this->hAlgorithm, 0 ) == 0;

        FreeLibrary( this->BCRYPT ); this->BCRYPT = NULL;
        return Result == TRUE;
    }

    //https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom
    bool WinApiCryptGenRandomV2::Random( /*OUT*/ BYTE *pbBuffer, /*IN*/ DWORD dwLen)
    {
        if ( this->BCRYPT == NULL )
            return false;

        DWORD Flags;
        if ( this->hAlgorithm == NULL )
            Flags = BCRYPT_USE_SYSTEM_PREFERRED_RNG;
        else
            Flags = 0;

        __ASSERT__( pbBuffer != NULL );
        __ASSERT__( dwLen > 0 );

        return this->_BCryptGenRandom( this->hAlgorithm, pbBuffer, dwLen, 0) == (NTSTATUS)(0x00000000l);
    }
};

WinApiCryptGenRandom   g_OldCryptApi;
WinApiCryptGenRandomV2 g_DualEllipticCurveRNG; //don't use it, its way to slow anyway
WinApiCryptGenRandomV2 g_FIPS186DSARNG;

void RandomGenerator::Initialize( void )
{
    g_OldCryptApi.Initialize();

    //don't use it, its way to slow on non-win10 systems anyway
    //g_DualEllipticCurveRNG.Initialize( true );
    /*===>*/g_DualEllipticCurveRNG.BCRYPT = NULL;
    /*===>*/g_DualEllipticCurveRNG.hAlgorithm = NULL;

    g_FIPS186DSARNG.Initialize( false );

    unsigned __int64 Seed = GenerateRandomSeed();

    unsigned __int64 PrimeNumber = 836663ui64;

    for (int i = 0; i < 10; i++)
    {
        this->LCGState[i] = (unsigned __int32)( Seed & 0xFFFFFFFFui64 );

        //https://prime-numbers.info/list/safe-primes
        Seed *= PrimeNumber;
        Seed += 1ui64;
        PrimeNumber = (2ui64 * PrimeNumber) + 1ui64;
    }
    this->LCG_ThreadId = GetCurrentThreadId();
}

void RandomGenerator::release( void )
{
    g_OldCryptApi.release( );
    g_DualEllipticCurveRNG.release( );
    g_FIPS186DSARNG.release( );
    for (int i = 0; i < 10; i++)
        this->LCGState[i] = NULL;
}

template< typename T >
T RandomOperator( /*IN*/ T Input1, /*IN*/ T Input2, /*IN*/ BYTE OperatorId )
{
    switch (OperatorId)
    {
    case 0: //XOR
        return (T)( (T)Input1 ^ (T)Input2 );
    case 1: //SUB1
        return (T)( (T)Input1 - (T)Input2 );
    case 2: //SUB2
        return (T)( (T)Input2 - (T)Input1 );
    case 3://ADD
        return (T)( (T)Input1 + (T)Input2 );
    }
    return (T)NULL;
}

template< typename T >
T RandomCombineData( /*IN*/ BYTE* RandomArray, /*IN*/ DWORD ArraySize, /*IN*/ BYTE ActionId )
{
    switch (ActionId)
    {
    case 0:
        {
        T Value = (T)0;
        T Mask = (T)1;
        for (DWORD i = 0; i < ArraySize; i+= 2 * sizeof( T ) )
        {
            Value |= (RandomArray[i] & Mask);
            Mask = Mask << sizeof( T );
        }
        return Value;
        }
    case 1: //XOR
        {
        T Value = 0;
        for (DWORD i = 0; i < ArraySize; i += 1 * sizeof( T ) )
            Value ^= RandomArray[i];
        return Value;
        }
    case 2: //SUB
        {
        T Value = 0;
        for (DWORD i = 0; i < ArraySize; i += 1 * sizeof( T ) )
            Value -= RandomArray[i];
        return Value;
        }
    case 3://ADD
        {
        T Value = 0;
        for (DWORD i = 0; i < ArraySize; i += 1 * sizeof( T ) )
            Value += RandomArray[i];
        return Value;
        }
    }
    return (T)NULL;
}


BYTE RandomGenerator::GetByte( void )
{
    //https://en.wikipedia.org/wiki/RdRand  
    if ( g_HardwareRngSupported_RDRND == true )
    {
        //https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-rdrand16-step-rdrand32-step-rdrand64-step
        unsigned short HardwareGeneratedRandomNumber = NULL;
        const int Success = _rdrand16_step( &HardwareGeneratedRandomNumber );
        HardwareGeneratedRandomNumber = HardwareGeneratedRandomNumber % 256;
        if ( Success == TRUE ) 
            return (BYTE)( HardwareGeneratedRandomNumber & 0xFF );
		else
			 printf("[%s] _rdrand16_step failed!\n", __FUNCTION__);
    }

    BYTE RandomValue = (BYTE)( (int)( this->LCG_rand() % 256 ) & 0xFF );

    const BYTE ArraySize = 16 * sizeof( BYTE ); 
    BYTE RandomArray[ ArraySize ] = {};
    ZeroMemory( RandomArray, sizeof(RandomArray) );

    for (int r = 0; r < 3; r++)
    {
        if ( r == 0 && g_OldCryptApi.Random( RandomArray, ArraySize )           != true ) 
            continue;
        if ( r == 1 && g_DualEllipticCurveRNG.Random( RandomArray, ArraySize )  != true  ) 
            continue;
        if ( r == 2 && g_FIPS186DSARNG.Random( RandomArray, ArraySize )         != true  ) 
            continue;

        BYTE Value  = RandomCombineData<BYTE>(  RandomArray,    ArraySize,  RandomArray[ ArraySize - 2 ] % 4 );
        RandomValue = RandomOperator<BYTE>(     RandomValue,    Value,      RandomArray[ ArraySize - 1 ] % 4 );
        continue;
    }
    return RandomValue;
}

WORD RandomGenerator::GetWord( void )
{
    //https://en.wikipedia.org/wiki/RdRand
    if ( g_HardwareRngSupported_RDRND == true )
    {
        //https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-rdrand16-step-rdrand32-step-rdrand64-step
        unsigned short HardwareGeneratedRandomNumber = NULL;
        const int Success = _rdrand16_step( &HardwareGeneratedRandomNumber );
        if ( Success == TRUE ) 
            return HardwareGeneratedRandomNumber;
		else
			printf("[%s] _rdrand16_step failed!\n", __FUNCTION__);
    }

    WORD RandomValue = NULL;
    for (WORD i = 0; i < sizeof(WORD); i++)
        RandomValue |= (WORD)( (WORD)( this->LCG_rand() % 256 ) << (8 * i) );

    const BYTE ArraySize = 16 * sizeof( WORD ); 
    BYTE RandomArray[ ArraySize ] = {};
    ZeroMemory( RandomArray, sizeof(RandomArray) );

    for (int r = 0; r < 3; r++)
    {
        if ( r == 0 && g_OldCryptApi.Random( RandomArray, ArraySize )           != true ) 
            continue;
        if ( r == 1 && g_DualEllipticCurveRNG.Random( RandomArray, ArraySize )  != true  ) 
            continue;
        if ( r == 2 && g_FIPS186DSARNG.Random( RandomArray, ArraySize )         != true  ) 
            continue;

        WORD Value  = RandomCombineData<WORD>(  RandomArray,    ArraySize,  RandomArray[ ArraySize - 2 ] % 4 );
        RandomValue = RandomOperator<WORD>(     RandomValue,    Value,      RandomArray[ ArraySize - 1 ] % 4 );
        continue;
    }
    return RandomValue;
}

DWORD RandomGenerator::GetDword( void )
{
    //https://en.wikipedia.org/wiki/RdRand  
    if ( g_HardwareRngSupported_RDRND == true )
    {
        //https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-rdrand16-step-rdrand32-step-rdrand64-step
        unsigned int HardwareGeneratedRandomNumber = NULL;
        const int Success = _rdrand32_step( &HardwareGeneratedRandomNumber );
        if ( Success == TRUE ) 
            return HardwareGeneratedRandomNumber;
		else
			printf("[%s] _rdrand32_step failed!\n", __FUNCTION__);
    }

    
    DWORD RandomValue = 0;

    for (DWORD i = 0; i < sizeof(DWORD); i++)
        RandomValue |= (DWORD)( (DWORD)( this->LCG_rand() % 256 ) << (8 * i) );

    const BYTE ArraySize = 16 * sizeof( DWORD ); 
    BYTE RandomArray[ ArraySize ] = {};
    ZeroMemory( RandomArray, sizeof(RandomArray) );

    for (int r = 0; r < 3; r++)
    {
        if ( r == 0 && g_OldCryptApi.Random( RandomArray, ArraySize )           != true ) 
            continue;

        if ( r == 1 && g_DualEllipticCurveRNG.Random( RandomArray, ArraySize )  != true  ) 
            continue;

        if ( r == 2 && g_FIPS186DSARNG.Random( RandomArray, ArraySize )         != true  ) 
            continue;

        DWORD Value = RandomCombineData<DWORD>( RandomArray,    ArraySize,  RandomArray[ ArraySize - 2 ] % 4 );
        RandomValue = RandomOperator<DWORD>(    RandomValue,    Value,      RandomArray[ ArraySize - 1 ] % 4 );
        continue;
    }
    return RandomValue;
}

DWORD64 RandomGenerator::GetQword( void )
{
#if defined(_M_X64)
    //https://en.wikipedia.org/wiki/RdRand
    if ( g_HardwareRngSupported_RDRND == true )
    {
        //https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-rdrand16-step-rdrand32-step-rdrand64-step
        unsigned __int64 HardwareGeneratedRandomNumber = 0;
        const int Success = _rdrand64_step( &HardwareGeneratedRandomNumber );
        if ( Success == TRUE ) 
            return HardwareGeneratedRandomNumber;
		else
			printf("[%s] _rdrand64_step failed!\n", __FUNCTION__);
    }
#else
    if ( g_HardwareRngSupported_RDRND == true )
    {
        unsigned int Dwords[2] = { (unsigned int)(0), (unsigned int)(0) };
        int Success = FALSE;
        for (DWORD j = 0; j < 2; j++)
            Success += _rdrand32_step( &Dwords[j] );

        if ( Success == (int)( (int)TRUE + (int)TRUE ) )
            return (DWORD64)( Dwords[0] ) | (DWORD64)( (DWORD64)( Dwords[1] ) << 32 );
		else
			printf("[%s] _rdrand32_step failed!\n", __FUNCTION__);
    }
#endif

    DWORD64 RandomValue = NULL;
    for (DWORD64 i = 0; i < sizeof(DWORD64); i++)
        RandomValue |= (DWORD64)( (DWORD64)( this->LCG_rand() % 256 ) << (DWORD64)(8ui64 * i) );

    const BYTE ArraySize = 16 * sizeof( DWORD64 ); 
    BYTE RandomArray[ ArraySize ] = {};
    ZeroMemory( RandomArray, sizeof(RandomArray) );

    for (int r = 0; r < 3; r++)
    {
        if ( r == 0 && g_OldCryptApi.Random( RandomArray, ArraySize )           != true ) 
            continue;
        if ( r == 1 && g_DualEllipticCurveRNG.Random( RandomArray, ArraySize )  != true  ) 
            continue;
        if ( r == 2 && g_FIPS186DSARNG.Random( RandomArray, ArraySize )         != true  ) 
            continue;

        DWORD64 Value = RandomCombineData<DWORD64>( RandomArray,    ArraySize,  RandomArray[ ArraySize - 2 ] % 4 );
        RandomValue =   RandomOperator<DWORD64>(    RandomValue,    Value,      RandomArray[ ArraySize - 1 ] % 4 );
        continue;
    }
    return RandomValue;
}

CHAR* RandomGenerator::GetString( /*IN OUT*/CHAR* Buffer, /*IN*/DWORD Size )
{
    __ASSERT__( Buffer != NULL );
    __ASSERT__( Size > 0 );

    this->GetBuffer( Buffer, Size );

    const UINT8 PrintableFirst = (UINT8)' ';
    const UINT8 PrintableLast  = (UINT8)'~';

    const UINT8 PrintableChars = ( PrintableLast + 1 ) - PrintableFirst;

    for (DWORD i = 0; i < Size; i++)
    {
        const UINT8 NewChar = (UINT8)Buffer[ i ] % ( PrintableChars );
        Buffer[ i ] = (CHAR)( (UINT8)NewChar + (UINT8)PrintableFirst );
    }

    Buffer[ Size - 1 ] = (CHAR)NULL;
    return Buffer;
}

void RandomGenerator::GetBuffer( /*IN OUT*/ void* Address, /*IN*/ DWORD Size )
{
    __ASSERT__( Address != NULL );
    __ASSERT__( Size > 0 );

    //https://en.wikipedia.org/wiki/RdRand  
    if ( g_HardwareRngSupported_RDRND == true )
    {
        bool HWRNGSuccess = true;

        const DWORD NotAlignedSize = (DWORD)( (DWORD)Size % (DWORD)4ui32 );
        const DWORD Aligned_4Byte  = (DWORD)( (DWORD)Size / (DWORD)4ui32 );
        
        unsigned __int32 RandomNbr32 = 0ui32;

        for (DWORD i = 0ui32; i < Aligned_4Byte; i++)
        {
            if ( _rdrand32_step( &RandomNbr32 ) != TRUE )
            {
				printf("[%s] _rdrand32_step [1] failed!\n", __FUNCTION__);
                HWRNGSuccess = false;
                break;
            }
            *(DWORD*)( (DWORD_PTR)Address + (i * 4ui32) ) = (DWORD)(RandomNbr32);
        }

        if ( HWRNGSuccess == true && NotAlignedSize > 0ui32 )
        {
            for (DWORD i = 0ui32; i < NotAlignedSize; i++)
            {
                if ( _rdrand32_step( &RandomNbr32 ) != TRUE )
                {
					printf("[%s] _rdrand32_step [2] failed!\n", __FUNCTION__);
                    HWRNGSuccess = false;
                    break;
                }
                RandomNbr32 %= 256ui32;
                *(BYTE*)( (DWORD_PTR)Address + (Aligned_4Byte * 4ui32) + i ) = (BYTE)(RandomNbr32);
            }
        }
        if ( HWRNGSuccess == true ) 
                return;
    }
    
    bool MallocUsed = false;

    BYTE* Buffer = (BYTE*)0;
    if ( Size > 0x1000ui32 )
    {
        Buffer = (BYTE*)malloc( Size );
        MallocUsed = true;
    }
    else
    {
        Buffer = (BYTE*)alloca( Size );
        if ( Buffer == NULL )
        {
            Buffer = (BYTE*)malloc( Size );
            MallocUsed = true;
        }
    }
    __ASSERT__( Buffer != NULL );

    BYTE* p = (BYTE*)Address;
    BYTE RandomOp = NULL;

    this->LCG_randBuffer( p, Size );

    for (int r = 0; r < 3; r++)
    {
        p = (BYTE*)Address;
        RandomOp = *(BYTE*)p % 4;

        if ( r == 0 && g_OldCryptApi.Random( (BYTE*)Buffer, Size )      != true ) 
            continue;
        if ( r == 1 && g_DualEllipticCurveRNG.Random( Buffer, Size )    != true  ) 
            continue;
        if ( r == 2 && g_FIPS186DSARNG.Random( Buffer, Size )           != true  ) 
            continue;

        for (DWORD i = NULL; i < Size; i++, p++)
            { *(BYTE*)p = RandomOperator( *(BYTE*)p, Buffer[i], RandomOp); };

        continue;
    }
    

    if ( MallocUsed == true )
        free( Buffer );
}

unsigned int RandomGenerator::GenerateRandomSeed( void )
{
    UINT cookie = 0;
    FILETIME SystemTimeAsFileTime = {};
    LARGE_INTEGER PerformanceCounter = {};
    LARGE_INTEGER InterruptCounter = {};
    LARGE_INTEGER TickCount64 = {};
    LARGE_INTEGER AuxiliaryCounterValue = {};
    LARGE_INTEGER ConversionErrorValue = {};
    LARGE_INTEGER ProcessorIdleCycleTime = {};
    
    __int32 cpuInfo[ 4 ] = {}; //{ EAX, EBX, ECX, EDX }

    ZeroMemory( &SystemTimeAsFileTime, sizeof(FILETIME) );
    ZeroMemory( &PerformanceCounter, sizeof(LARGE_INTEGER) );
    ZeroMemory( &InterruptCounter, sizeof(LARGE_INTEGER) );
    ZeroMemory( &TickCount64, sizeof(LARGE_INTEGER) );
    ZeroMemory( &AuxiliaryCounterValue, sizeof(LARGE_INTEGER) );
    ZeroMemory( &ConversionErrorValue, sizeof(LARGE_INTEGER) );

    const HMODULE Kernel32  = GetModuleHandleW(L"kernel32.dll");
    const HMODULE KernelBase= GetModuleHandleW(L"kernelbase.dll");

    __ASSERT__( Kernel32 != NULL );
    __ASSERT__( KernelBase != NULL );

    ////////////////////////////////////// CPUID Based Start Value //////////////////////////////////////
    ZeroMemory( cpuInfo, sizeof(cpuInfo) );
    __cpuidex( (int*)cpuInfo, 0 /*EAX*/, 0 /*ECX*/ );

    QueryPerformanceCounter( (LARGE_INTEGER*)&PerformanceCounter );
    BYTE RandomOperatorId = (BYTE)( (DWORD)( (DWORD)( PerformanceCounter.LowPart >> 3 ) % 4) );

    const UINT HighestFunctionParameter = cpuInfo[/*EAX*/0];
    __ASSERT__( HighestFunctionParameter > 0 );

    for (UINT i = 0; i < HighestFunctionParameter; i++)
    {
        ZeroMemory( cpuInfo, sizeof(cpuInfo) );
        __cpuidex( (int*)cpuInfo, HighestFunctionParameter /*EAX*/, 0 /*ECX*/ );

        for (int j = 0; j < 4; j++)
            cookie = (UINT)RandomOperator<UINT>( (UINT)(cookie), (UINT)(cpuInfo[j]), RandomOperatorId );
    }

    ZeroMemory( cpuInfo, sizeof(cpuInfo) );
    __cpuidex( (int*)cpuInfo, /*Highest Extended Function Parameter => */ 0x80000000 /*EAX*/, 0 /*ECX*/ );

    QueryPerformanceCounter( (LARGE_INTEGER*)&PerformanceCounter );
    RandomOperatorId = (BYTE)( (DWORD)( (DWORD)( PerformanceCounter.LowPart >> 7 ) % 4 ) );

    const UINT HighestExtendedFunctionParameter = cpuInfo[/*EAX*/0];
    __ASSERT__( HighestExtendedFunctionParameter > 0x80000000 );

    for (UINT i = 0x80000000; i < HighestExtendedFunctionParameter; i++)
    {
        ZeroMemory( cpuInfo, sizeof(cpuInfo) );
        __cpuidex( (int*)cpuInfo, i /*EAX*/, 0 /*ECX*/ );

        for (UINT j = 0; j < 4; j++)
            cookie = (UINT)RandomOperator<UINT>( (UINT)(cookie), (UINT)(cpuInfo[j]), RandomOperatorId );
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////

    BOOL (__stdcall* FncGetPerformanceInfo)(PERFORMANCE_INFORMATION* pPerformanceInformation, DWORD cb) = NULL;
    FncGetPerformanceInfo = ( decltype(FncGetPerformanceInfo) )GetProcAddress( Kernel32, "GetPerformanceInfo" );
    if ( FncGetPerformanceInfo != NULL )
    {
        PERFORMANCE_INFORMATION PerformanceInformation = {};
        ZeroMemory( &PerformanceInformation, sizeof(PERFORMANCE_INFORMATION) );
        if ( FncGetPerformanceInfo( &PerformanceInformation, sizeof(PERFORMANCE_INFORMATION) ) == TRUE )
        {
            cookie ^= PerformanceInformation.ThreadCount;
            cookie ^= PerformanceInformation.HandleCount;
            cookie ^= PerformanceInformation.ProcessCount;
        }
    }

    BOOL (__stdcall* fncGlobalMemoryStatusEx)(LPMEMORYSTATUSEX lpBuffer) = NULL;
    fncGlobalMemoryStatusEx = ( decltype(fncGlobalMemoryStatusEx) )GetProcAddress( Kernel32, "GlobalMemoryStatusEx" );
    if ( fncGlobalMemoryStatusEx != NULL )
    {
        MEMORYSTATUSEX MemoryStatusEx = {};
        ZeroMemory( &MemoryStatusEx, sizeof(MEMORYSTATUSEX) );
        if ( fncGlobalMemoryStatusEx( &MemoryStatusEx ) == TRUE )
        {
            const UINT64 XorValue = (UINT64)( (UINT64)( (UINT64)(MemoryStatusEx.dwMemoryLoad) * (UINT64)(cookie) ) * (UINT64)2096687ui64 ) >> 7;
            cookie ^= (UINT)( XorValue & 0xFFFFFFFF );
        }
    }

    //https://docs.microsoft.com/en-us/windows/win32/api/realtimeapiset/nf-realtimeapiset-queryidleprocessorcycletime
    BOOL (WINAPI* fncQueryIdleProcessorCycleTime)( PULONG BufferLength, PULONG64 ProcessorIdleCycleTime ) = NULL;
    fncQueryIdleProcessorCycleTime = ( decltype(fncQueryIdleProcessorCycleTime) )GetProcAddress( Kernel32, "QueryIdleProcessorCycleTime" );
    if ( fncQueryIdleProcessorCycleTime != NULL )
    {
        ULONG BufferLength = sizeof(LARGE_INTEGER);
        if ( fncQueryIdleProcessorCycleTime( &BufferLength, (ULONG64*)&ProcessorIdleCycleTime.QuadPart ) == TRUE )
        {
            cookie ^= ProcessorIdleCycleTime.LowPart;
            cookie ^= ProcessorIdleCycleTime.HighPart;
        }
    }

    GetSystemTimeAsFileTime( (LPFILETIME)&SystemTimeAsFileTime );

    cookie ^= SystemTimeAsFileTime.dwLowDateTime;
    cookie ^= SystemTimeAsFileTime.dwHighDateTime;
    cookie ^= GetCurrentProcessId( );
    cookie ^= GetCurrentThreadId( );

    TickCount64.QuadPart = GetTickCount64( );

    cookie ^= TickCount64.LowPart;
    cookie ^= TickCount64.HighPart;

    //https://docs.microsoft.com/en-us/windows/win32/api/realtimeapiset/nf-realtimeapiset-queryunbiasedinterrupttime
    BOOL (WINAPI*fncQueryUnbiasedInterruptTime)( PULONGLONG UnbiasedTime ) = NULL;
    fncQueryUnbiasedInterruptTime = ( decltype(fncQueryUnbiasedInterruptTime) )GetProcAddress( Kernel32, "QueryUnbiasedInterruptTime" );

    //https://docs.microsoft.com/en-us/windows/win32/api/realtimeapiset/nf-realtimeapiset-queryinterrupttime
    void (WINAPI*fncQueryInterruptTime)( PULONGLONG Time ) = NULL;
    fncQueryInterruptTime = ( decltype(fncQueryInterruptTime) )GetProcAddress( KernelBase, "QueryInterruptTime" );

    if ( fncQueryInterruptTime != NULL )
    {
        fncQueryInterruptTime( (PULONGLONG)&InterruptCounter.QuadPart );
        cookie ^= InterruptCounter.LowPart;
        cookie ^= InterruptCounter.HighPart;
    }
    else
    if ( fncQueryUnbiasedInterruptTime != NULL && 
         fncQueryUnbiasedInterruptTime( (PULONGLONG)&InterruptCounter.QuadPart ) == TRUE )
    {
        cookie ^= InterruptCounter.LowPart;
        cookie ^= InterruptCounter.HighPart;
    }

    this->LCGGeneratorIndex = cookie % 10;
    printf("[+] LCG start index: %u\n",this->LCGGeneratorIndex);

    //https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter
    if ( QueryPerformanceCounter( (LARGE_INTEGER*)&PerformanceCounter ) == TRUE )
    {
        cookie ^= PerformanceCounter.LowPart;
        cookie ^= PerformanceCounter.HighPart;
    }

    //https://docs.microsoft.com/en-us/windows/win32/api/realtimeapiset/nf-realtimeapiset-convertperformancecountertoauxiliarycounter
    HRESULT (WINAPI* fncConvertPerformanceCounterToAuxiliaryCounter)(   ULONGLONG ullPerformanceCounterValue, 
                                                                        PULONGLONG lpAuxiliaryCounterValue, 
                                                                        PULONGLONG lpConversionError 
                                                                    ) = NULL;
    fncConvertPerformanceCounterToAuxiliaryCounter = ( decltype(fncConvertPerformanceCounterToAuxiliaryCounter) )GetProcAddress( KernelBase, "ConvertPerformanceCounterToAuxiliaryCounter");
    if ( fncConvertPerformanceCounterToAuxiliaryCounter != NULL &&
         QueryPerformanceCounter( (LARGE_INTEGER*)&PerformanceCounter ) == TRUE)
    {
        const HRESULT 
                hResult = fncConvertPerformanceCounterToAuxiliaryCounter(   (ULONGLONG)PerformanceCounter.QuadPart, 
                                                                            (PULONGLONG)&AuxiliaryCounterValue.QuadPart, 
                                                                            (PULONGLONG)&ConversionErrorValue.QuadPart );
        if ( hResult == S_OK )
        {
            if ( AuxiliaryCounterValue.LowPart  != PerformanceCounter.LowPart &&
                 AuxiliaryCounterValue.HighPart != PerformanceCounter.HighPart)
            {       
                cookie ^= AuxiliaryCounterValue.LowPart;
                cookie ^= AuxiliaryCounterValue.HighPart;
            }
        }
    }
    
    //https://en.wikipedia.org/wiki/RdRand
    if ( g_HardwareRngSupported_RDSEED == true )
    {
#if _MSC_VER >= 1910
        //https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-rdseed16-step-rdseed32-step-rdseed64-step
        unsigned __int32 HardwareGeneratedSeed = NULL;
        const int Success = _rdseed32_step( &HardwareGeneratedSeed );
        if ( Success == TRUE ) 
            cookie ^= HardwareGeneratedSeed;
		else
			printf("[%s] _rdseed32_step failed!\n", __FUNCTION__);
#endif
    }
    else
    if ( g_HardwareRngSupported_RDRND == true )
    {
        //https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-rdrand16-step-rdrand32-step-rdrand64-step
        unsigned int HardwareGeneratedRandomNumber = NULL;
        const int Success = _rdrand32_step( &HardwareGeneratedRandomNumber );
        if ( Success == TRUE ) 
            cookie ^= HardwareGeneratedRandomNumber;
		else
			printf("[%s] _rdrand32_step failed!\n", __FUNCTION__);
    }

    return cookie;
};

//Linear congruential generator
int RandomGenerator::LCG_rand( void )
{
    const DWORD CurrentThreadId = GetCurrentThreadId();
    if ( CurrentThreadId != this->LCG_ThreadId )
        printf("FATAL ERROR: %s can not be used multithreaded!\n", __FUNCTION__);

    LCGGeneratorIndex = ( LCGGeneratorIndex + 1 ) % 10;

    
    const LinearCongruentialGenerator Generator = GeneratorValues[ LCGGeneratorIndex ];

    unsigned int Number = Generator.multiplier * this->LCGState[ LCGGeneratorIndex ] + Generator.increment;

    const __int32 modulus = (__int32)(Generator.modulus);
    if ( modulus != (__int32)(-1i32) )
        Number = (unsigned int)( Number % ((unsigned int)(modulus)) );

    this->LCGState[ LCGGeneratorIndex ] = Number;

    Number = (unsigned int)( Number >> Generator.Shift ) & Generator.Mask;
    return Number;
}

void RandomGenerator::LCG_randBuffer( /*IN OUT*/ void* Address, /*IN*/ DWORD Size)
{
    __ASSERT__( Address != NULL );
    __ASSERT__( Size > 0 );

    BYTE* Pointer = (BYTE*)( (DWORD_PTR)Address + (DWORD_PTR)0 );

    LinearCongruentialGenerator LocalGeneratorValues[10] = {};
    unsigned int Local_LCGState[10] = {};

    for (int c1 = 0; c1 < 10; c1++)
    {
        Local_LCGState[c1] = this->LCGState[c1];
        LocalGeneratorValues[c1] = GeneratorValues[c1];
    }

    unsigned int Index = this->LCGGeneratorIndex;
    
    for (DWORD i = 0; i < Size; i++, Pointer++)
    {
        Index = ( Index + 1 ) % 10;
        
        unsigned int Number = Local_LCGState[ Index ];

        Number *= LocalGeneratorValues[Index].multiplier;
        Number += LocalGeneratorValues[Index].increment;

        const signed __int32 modulus = (signed __int32)( LocalGeneratorValues[Index].modulus );
        if ( modulus != (signed __int32)(-1i32) )
            Number %= (unsigned int)( modulus );

        Local_LCGState[ Index ] = Number;

        Number >>= LocalGeneratorValues[Index].Shift;
        *(BYTE*)Pointer = (BYTE)( Number );
    }

    for (int c1 = 0; c1 < 10; c1++)
        this->LCGState[c1] = Local_LCGState[c1];
    this->LCGGeneratorIndex = Index;
}

bool RandomGenerator::checkHardwareRNG( void )
{
	unsigned __int32 RdSeed32Cntr = 0;
	unsigned __int32 RdSeed32Value = 0;

	unsigned __int32 RdRand32Cntr = 0;
	unsigned __int32 RdRand32Value = 0;
	
	//check if hardware random number generator is bugged.
	//Some CPUs always return the same for some reason.

	for (unsigned int i = 0; i < 32; i++)
	{
		if ( g_HardwareRngSupported_RDSEED == true )
		{
	#if _MSC_VER >= 1910
			//https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-rdseed16-step-rdseed32-step-rdseed64-step
			unsigned int HardwareGeneratedRandomNumber = NULL;
			const int Success = _rdseed32_step( &HardwareGeneratedRandomNumber );
			if ( Success == TRUE )
			{
				if ( i == 0 )
					RdSeed32Value = HardwareGeneratedRandomNumber;
				else
				{
					if ( RdSeed32Value == HardwareGeneratedRandomNumber )
						RdSeed32Cntr += 1;
				}
			}
	#endif
		}

		if ( g_HardwareRngSupported_RDRND == true )
		{
			//https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-rdrand16-step-rdrand32-step-rdrand64-step
			unsigned int HardwareGeneratedRandomNumber = NULL;
			const int Success = _rdrand32_step( &HardwareGeneratedRandomNumber );
			if ( Success == TRUE )
			{
				if ( i == 0 )
					RdRand32Value = HardwareGeneratedRandomNumber;
				else
				{
					if ( RdRand32Value == HardwareGeneratedRandomNumber )
						RdRand32Cntr += 1;
				}
			}

		}
	}
	//if more than half of the values are the same, its bugged.
	if ( RdRand32Cntr > 16 || RdSeed32Cntr > 16 )
		return false;

	return true;
}

```

`RopCompiler/RandomGenerator.h`:

```h
#pragma once

struct RandomGenerator
{
	void Initialize( void );
	void release( void );
	unsigned int GenerateRandomSeed( void );

	BYTE    GetByte ( void );
	WORD    GetWord ( void );
	DWORD   GetDword( void );
	DWORD64 GetQword( void );
	CHAR*   GetString( /*IN OUT*/CHAR*  Buffer, /*IN*/DWORD Size );

	void GetBuffer( /*IN OUT*/ void* Address, /*IN*/ DWORD Size );

	///////////////////// Linear congruential generator /////////////////////
	unsigned int LCGGeneratorIndex;
	unsigned int LCGState[10];

	unsigned int LCG_ThreadId;
	
	int LCG_rand( void );
	void LCG_randBuffer( /*IN OUT*/ void* Address, /*IN*/ DWORD Size );
	/////////////////////////////////////////////////////////////////////////

	bool checkHardwareRNG( void );
};
extern RandomGenerator g_RandomGenerator;


/////////////////////////////////////////// Linear congruential generator ///////////////////////////////////////////
struct LinearCongruentialGenerator
{
	__int32 modulus; //m

	unsigned __int32 multiplier; //a
	unsigned __int32 increment; //c
	
	unsigned __int32 Shift;
	unsigned __int32 Mask; 
};
	
const LinearCongruentialGenerator GeneratorValues[10] = {
	//https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
	
	//Numerical Recipes
	{ -1i32, 1664525ui32, 1013904223ui32, 16, 0x7FFF },

	//Borland C/C++
	{ -1i32, 22695477ui32, 1ui32, 16, 0x7FFF },

	//glibc (used by GCC)
	{ -1i32, 1103515245ui32, 12345ui32, 0, 0x7FFFFFFF },

	//ANSI C: Watcom, Digital Mars, CodeWarrior, IBM VisualAge C/C++
	{ -1i32, 1103515245ui32, 12345ui32, 16, 0x7FFF },

	//Borland Delphi, Virtual Pascal and Turbo Pascal
	//but using on 32bit
	{ -1i32, 134775813ui32, 1ui32, 0, 0xFFFFFFFF },
	
	//Microsoft Visual/Quick C/C++
	{ -1i32, 214013ui32, 2531011ui32, 16, 0x7FFF },

	//Microsoft Visual Basic (6 and earlier)
	{ 16777216i32, 214013ui32, 2531011ui32, 16, 0x7FFF },

	//RtlUniform from Native API
	{ 2147483647i32, 0x7FFFFFEDui32, 0x7FFFFFC3ui32, 0, 0x7FFFFFFF },

	//cc65 [0]
	{ 8388608i32, 0x10101ui32, 0x415927ui32, 8, 0x7FFF },

	//cc65 [1]
	{ -1i32, 0x10101ui32, 826366247ui32, 16, 0x7FFF },
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

```

`RopCompiler/RopCompiler.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{06DE52BE-0E09-4819-B6DD-77E9BB14DFE0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>RopCompiler</RootNamespace>
    <ProjectName>RopCompiler</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v110</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v110</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
      <CallingConvention>FastCall</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CallingConvention>FastCall</CallingConvention>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <EnablePREfast>false</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateMapFile>true</GenerateMapFile>
      <LargeAddressAware>true</LargeAddressAware>
      <SetChecksum>true</SetChecksum>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Compiler.cpp" />
    <ClCompile Include="dbghelp.cpp" />
    <ClCompile Include="GameOffsets.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="GadgetScanner.cpp" />
    <ClCompile Include="RandomGenerator.cpp" />
    <ClCompile Include="Util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Compiler.h" />
    <ClInclude Include="CpuInformation.h" />
    <ClInclude Include="dbghelp.h" />
    <ClInclude Include="GameOffsets.h" />
    <ClInclude Include="Gadgets.h" />
    <ClInclude Include="ASSERT.h" />
    <ClInclude Include="RandomGenerator.h" />
    <ClInclude Include="Util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`RopCompiler/RopCompiler.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Compiler">
      <UniqueIdentifier>{db9c0b6e-7c9e-4a78-bb3b-420e58a4b3d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="GameOffsets">
      <UniqueIdentifier>{324d40f7-7790-4a96-8bb0-ff9a8135f5b5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Util">
      <UniqueIdentifier>{6bab0d73-534d-4201-a7cd-eb59554dd9f2}</UniqueIdentifier>
    </Filter>
    <Filter Include="dbghelp">
      <UniqueIdentifier>{b0c6e968-12e5-4a6a-84ad-183c383413a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Main">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Main</Filter>
    </ClCompile>
    <ClCompile Include="Compiler.cpp">
      <Filter>Compiler</Filter>
    </ClCompile>
    <ClCompile Include="GameOffsets.cpp">
      <Filter>GameOffsets</Filter>
    </ClCompile>
    <ClCompile Include="Util.cpp">
      <Filter>Util</Filter>
    </ClCompile>
    <ClCompile Include="dbghelp.cpp">
      <Filter>dbghelp</Filter>
    </ClCompile>
    <ClCompile Include="GadgetScanner.cpp">
      <Filter>Compiler</Filter>
    </ClCompile>
    <ClCompile Include="RandomGenerator.cpp">
      <Filter>Util</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Compiler.h">
      <Filter>Compiler</Filter>
    </ClInclude>
    <ClInclude Include="GameOffsets.h">
      <Filter>GameOffsets</Filter>
    </ClInclude>
    <ClInclude Include="Util.h">
      <Filter>Util</Filter>
    </ClInclude>
    <ClInclude Include="dbghelp.h">
      <Filter>dbghelp</Filter>
    </ClInclude>
    <ClInclude Include="Gadgets.h">
      <Filter>Compiler</Filter>
    </ClInclude>
    <ClInclude Include="CpuInformation.h">
      <Filter>Util</Filter>
    </ClInclude>
    <ClInclude Include="RandomGenerator.h">
      <Filter>Util</Filter>
    </ClInclude>
    <ClInclude Include="ASSERT.h">
      <Filter>dbghelp</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`RopCompiler/RopCompiler.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`RopCompiler/Util.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>
#include <TlHelp32.h>

#include "ASSERT.h"
#include "Util.h"
#include "Compiler.h"
#include "dbghelp.h"
#include "RandomGenerator.h"

void GetDecimalNumber( /*IN*/ const char* inString, /*OUT*/ DWORD64* outNumber, /*OUT*/ size_t* outI )
{
	__ASSERT__( inString != NULL );
	__ASSERT__( outNumber != NULL );
	__ASSERT__( outI != NULL );

    DWORD64 Number = (DWORD64)NULL;
	size_t i = (size_t)NULL;
    for ( ; inString[i] >= (const char)'0' && inString[i] <= (const char)'9' ; i++)
	{
        Number = ((DWORD64)(10ui64) * Number) + (DWORD64)( (unsigned __int8)inString[i] - (unsigned __int8)'0');
	}
	*(size_t*)outI = (size_t)i;
	*(DWORD64*)outNumber = (DWORD64)Number;
    return ;
}

bool GetHeximalNumber( /*IN*/ const char *inString, /*OUT*/ DWORD64* outNumber, /*OUT*/ size_t* outI )
{
	__ASSERT__( inString != NULL );
	__ASSERT__( outNumber != NULL );
	__ASSERT__( outI != NULL );

	*outNumber = (DWORD64)NULL;
	*outI = (size_t)NULL;

	if ( inString[0] != (const char)'0' || tolower( (int)inString[1] ) != (int)'x' )
		return false;

	DWORD64 Number = (DWORD64)NULL;
	size_t i = (size_t)NULL;
	for ( bool InvalidChar = false; InvalidChar == false; i++)
	{
		unsigned __int8 c = (unsigned __int8)inString[2+i];
		if ( c >= (unsigned __int8)'A' && c <= (unsigned __int8)'F' )
			c += (unsigned __int8)' ';

		if ( c >= (unsigned __int8)'a' && c <= (unsigned __int8)'f' )
		{
			const DWORD64 temp = (DWORD64)( (unsigned __int8)c - (unsigned __int8)'a' ) + (DWORD64)10ui64;
			Number <<= (DWORD64)4ui64;
			Number |= temp;
			
			continue;
		}
		if ( c >= (unsigned __int8)'0' && c <= (unsigned __int8)'9' )
		{
			const DWORD64 temp = (DWORD64)( (unsigned __int8)c - (unsigned __int8)'0' );
			Number <<= (DWORD64)4ui64;
			Number |= temp;
			
			continue;
		}
		i--;
		InvalidChar = true;
	}
	*(size_t*)outI = (size_t)i;
	*(DWORD64*)outNumber = (DWORD64)Number;
	return true;

}

char* RegToString( /*IN*/ const enum Regs Reg )
{
	switch (Reg)
	{
	case REG_EAX:
		return "EAX";
		break;
	case REG_ECX:
		return "ECX";
		break;
	case REG_EDX:
		return "EDX";
		break;
	case REG_EBX:
		return "EBX";
		break;
	case REG_ESP:
		return "ESP";
		break;
	case REG_EBP:
		return "EBP";
		break;
	case REG_ESI:
		return "ESI";
		break;
	case REG_EDI:
		return "EDI";
		break;
	case REG_VR0:
		return "VR0";
		break;
	case REG_VR1:
		return "VR1";
		break;
	case REG_VR2:
		return "VR2";
		break;
	case REG_VR3:
		return "VR3";
		break;
	case REG_VR4:
		return "VR4";
		break;
	case REG_VR5:
		return "VR5";
		break;
	case REG_VR6:
		return "VR6";
		break;
	case REG_VR7:
		return "VR7";
		break;
	case REG_VR8:
		return "VR8";
		break;
	case REG_VR9:
		return "VR9";
		break;
	case REG_VMM:
		return "VMM";
		break;
	default:
		break;
	}
	return nullptr;
}

enum Regs GetReg( /*IN*/ const char* p)
{
	if ( (int)tolower(p[0]) == (int)'e' &&
		 (int)tolower(p[2]) == (int)'x')
	{
		if ( (int)tolower(p[1]) == (int)'a' )
			 return REG_EAX;
		if ( (int)tolower(p[1]) == (int)'b' )
			 return REG_EBX;
		if ( (int)tolower(p[1]) == (int)'c' )
			 return REG_ECX;
		if ( (int)tolower(p[1]) == (int)'d' )
			 return REG_EDX;
	}
	if ( (int)tolower(p[0]) == (int)'e' &&
		 (int)tolower(p[2]) == (int)'p')
	{
		if ( (int)tolower(p[1]) == (int)'s' )
			 return REG_ESP;
		if ( (int)tolower(p[1]) == (int)'b' )
			 return REG_EBP;
	}

	if ( (int)tolower(p[0]) == (int)'e' &&
		 (int)tolower(p[2]) == (int)'i')
	{
		if ( (int)tolower(p[1]) == (int)'s' )
			 return REG_ESI;
		if ( (int)tolower(p[1]) == (int)'d' )
			 return REG_EDI;
	}

	if ( (int)tolower(p[0]) == (int)'v' &&
		 (int)tolower(p[1]) == (int)'r')
	{
		if ( (int)tolower(p[2]) == (int)'0' )
			 return REG_VR0;
		if ( (int)tolower(p[2]) == (int)'1' )
			 return REG_VR1;
		if ( (int)tolower(p[2]) == (int)'2' )
			 return REG_VR2;
		if ( (int)tolower(p[2]) == (int)'3' )
			 return REG_VR3;
		if ( (int)tolower(p[2]) == (int)'4' )
			 return REG_VR4;
		if ( (int)tolower(p[2]) == (int)'5' )
			 return REG_VR5;
		if ( (int)tolower(p[2]) == (int)'6' )
			 return REG_VR6;
		if ( (int)tolower(p[2]) == (int)'7' )
			 return REG_VR7;
		if ( (int)tolower(p[2]) == (int)'8' )
			 return REG_VR8;
		if ( (int)tolower(p[2]) == (int)'9' )
			 return REG_VR9;
	}
	if ( (int)tolower(p[0]) == (int)'v' &&
		 (int)tolower(p[1]) == (int)'m' &&
		 (int)tolower(p[2]) == (int)'m' )
		 return REG_VMM;

	return REG_ERROR;
}

unsigned long GetProcessIdByName( /*IN*/ const char *ProcessName )
{
	__ASSERT__( ProcessName != NULL );

	HANDLE SnapshotHandle = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );
	if (SnapshotHandle == NULL || SnapshotHandle == INVALID_HANDLE_VALUE) return 0;

	WCHAR ProcName[MAX_PATH+1] = {};
	ZeroMemory( ProcName, sizeof(ProcName) );

	for (UINT i = 0; i < ((UINT)(MAX_PATH)); i++)
	{
		unsigned char c = (unsigned char)(ProcessName[i]);
		if ( (UINT8)c < 31ui8 || (UINT8)c > 128ui8 )
			c = (UINT8)NULL;
		ProcName[i] = (UINT8)c;
		if (c == NULL) break;
	}
	ProcName[MAX_PATH] = (WCHAR)NULL;

	unsigned long pid = (unsigned long)NULL;

	PROCESSENTRY32W ProcessEntry;	
	ZeroMemory( &ProcessEntry, sizeof(PROCESSENTRY32W) );
	
	ProcessEntry.dwSize = sizeof(PROCESSENTRY32W);
	BOOL Loop = Process32FirstW(SnapshotHandle, &ProcessEntry);
	while (Loop == TRUE)
	{
		if (_wcsicmp(ProcessEntry.szExeFile, ProcName) == 0) 
		{
			pid = ProcessEntry.th32ProcessID;
			break;
		}
		ZeroMemory( &ProcessEntry, sizeof(PROCESSENTRY32W) );
		ProcessEntry.dwSize = sizeof(PROCESSENTRY32W);
		Loop = Process32NextW(SnapshotHandle, &ProcessEntry);
	}
	CloseHandle( SnapshotHandle );
	return pid;
}

bool GetRemoteProcessModuleInfo( /*IN*/ const DWORD ProcessId, /*IN*/ const wchar_t* wcModuleName, /*OUT*/ struct RemoteProcessModuleInfo* outInfo )
{
	__ASSERT__( ProcessId > 4 );
	__ASSERT__( wcModuleName != NULL  );
	__ASSERT__( outInfo != NULL  );

	bool SuccessStatus = false;

	ZeroMemory( outInfo, sizeof(RemoteProcessModuleInfo) );

	HANDLE SnapshotHandle = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, ProcessId );
	if (SnapshotHandle == NULL || SnapshotHandle == INVALID_HANDLE_VALUE) return SuccessStatus;	

	MODULEENTRY32W ModuleEntry = {};
	ZeroMemory( &ModuleEntry, sizeof(MODULEENTRY32W) );
	
	ModuleEntry.dwSize = sizeof(MODULEENTRY32W);
	BOOL Loop = Module32FirstW(SnapshotHandle, &ModuleEntry);
	while (Loop == TRUE)
	{
		if (_wcsicmp(ModuleEntry.szModule, wcModuleName) == 0) 
		{
			outInfo->modBaseAddr = ModuleEntry.modBaseAddr;
			outInfo->modBaseSize = ModuleEntry.modBaseSize;
			outInfo->hModule = ModuleEntry.hModule;
			memcpy( outInfo->szModule, ModuleEntry.szModule, MAX_MODULE_NAME32 + 1 );
			memcpy( outInfo->szExePath, ModuleEntry.szExePath, MAX_PATH );
			SuccessStatus = true;
			break;
		}
		ZeroMemory( &ModuleEntry, sizeof(MODULEENTRY32W) );
		ModuleEntry.dwSize = sizeof(MODULEENTRY32W);
		Loop = Module32NextW(SnapshotHandle, &ModuleEntry);
	}
	CloseHandle( SnapshotHandle );

	return SuccessStatus;
}

bool GetRemoteProcessModuleExportAddress( /*IN*/ const DWORD ProcessId, /*IN*/ const char* ModuleName, /*IN*/ const char* ExportName, /*OUT*/ DWORD_PTR* outAddress )
{
	__ASSERT__( ProcessId > 4 );
	__ASSERT__( ModuleName != NULL  );
	__ASSERT__( ExportName != NULL  );
	__ASSERT__( outAddress != NULL  );

	bool SuccessStatus = false;
	HANDLE SnapshotHandle = NULL;

	*outAddress = 0;
	
	SnapshotHandle = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, ProcessId );
	if (SnapshotHandle == NULL || SnapshotHandle == INVALID_HANDLE_VALUE) return SuccessStatus;
	
	WCHAR wcModuleName[MAX_PATH+1] = {};
	ZeroMemory( wcModuleName, sizeof(wcModuleName) );

	for (UINT i = 0; i < (UINT)MAX_PATH; i++)
	{
		unsigned char c = (unsigned char)(ModuleName[i]);
		if ( (UINT8)c < (UINT8)31ui8 || (UINT8)c > (UINT8)128ui8 )
			c = (UINT8)NULL;
		wcModuleName[i] = (UINT8)c;
		if (c == NULL) break;
	}
	wcModuleName[MAX_PATH] = (WCHAR)NULL;
	

	MODULEENTRY32W ModuleEntry = {};
	ZeroMemory( &ModuleEntry, sizeof(MODULEENTRY32W) );
	
	ModuleEntry.dwSize = sizeof(MODULEENTRY32W);
	BOOL Loop = Module32FirstW(SnapshotHandle, &ModuleEntry);
	while (Loop == TRUE)
	{
		if (_wcsicmp(ModuleEntry.szModule, wcModuleName) == 0) 
		{
			HMODULE hDllModule = LoadLibraryW( ModuleEntry.szExePath );
			if ( hDllModule != 0 )
			{
				DWORD_PTR ExportAddr = (DWORD_PTR)GetProcAddressToLower( hDllModule, ExportName, TRUE );
				if ( ExportAddr != 0 )
				{
					ExportAddr -= (DWORD_PTR)hDllModule;

					ExportAddr += (DWORD_PTR)ModuleEntry.modBaseAddr;

					*outAddress = ExportAddr;

					SuccessStatus = true;
				}
			}
			break;
		}
		ZeroMemory( &ModuleEntry, sizeof(MODULEENTRY32W) );
		ModuleEntry.dwSize = sizeof(MODULEENTRY32W);
		Loop = Module32NextW(SnapshotHandle, &ModuleEntry);
	}
	CloseHandle( SnapshotHandle );

	return SuccessStatus;
}

bool RemoteSuspendProcessThreads( /*IN*/ const DWORD ProcessId, /*IN*/ bool Resume )
{
	__ASSERT__( ProcessId > 4 );

	bool SuccessStatus = false;

	HANDLE SnapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, ProcessId);
	if (SnapshotHandle == NULL || SnapshotHandle == INVALID_HANDLE_VALUE) return SuccessStatus;

	THREADENTRY32 ThreadEntry = {};
	ZeroMemory( &ThreadEntry, sizeof(THREADENTRY32) ); 
	ThreadEntry.dwSize = sizeof(THREADENTRY32);

	BOOL Loop = Thread32First(SnapshotHandle, &ThreadEntry);
	while (Loop == TRUE)
	{
		if (ThreadEntry.dwSize >= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(ThreadEntry.th32OwnerProcessID)) 
		{
			if(ThreadEntry.th32OwnerProcessID == ProcessId)
			{
				HANDLE ThreadHandle = OpenThread(THREAD_SUSPEND_RESUME, FALSE, ThreadEntry.th32ThreadID);
				if(ThreadHandle != NULL && ThreadHandle != INVALID_HANDLE_VALUE)
				{
					DWORD SuspendCount = (DWORD)0xFFFFFFFFui32;
					if ( Resume == true )
						SuspendCount = ResumeThread(ThreadHandle);
					else
						SuspendCount = SuspendThread(ThreadHandle);

					if ( SuspendCount != (DWORD)(0xFFFFFFFFui32) )
						SuccessStatus = true;

					CloseHandle(ThreadHandle);
				}
			}
		}
		ZeroMemory( &ThreadEntry, sizeof(THREADENTRY32) ); 
		ThreadEntry.dwSize = sizeof(THREADENTRY32);
		Loop = Thread32Next(SnapshotHandle, &ThreadEntry);
	}
	CloseHandle(SnapshotHandle);

	return SuccessStatus;
}

bool NtSuspendProcess( /*IN*/ const HANDLE hProcess )
{
	__ASSERT__( hProcess != INVALID_HANDLE_VALUE && hProcess != NULL );

	static NTSTATUS(__stdcall* fncNtSuspendProcess)(HANDLE ProcessHandle) = NULL;

	if ( fncNtSuspendProcess == NULL )
	{
		HMODULE hNtDll = GetModuleHandleW( L"ntdll.dll" );
		if ( hNtDll == NULL )
			 hNtDll = LoadLibraryW( L"ntdll.dll" );
		__ASSERT__( hNtDll != NULL );

		void* Function = GetProcAddress( hNtDll, "NtSuspendProcess" );
		if ( Function == NULL )
			 Function = GetProcAddress( hNtDll, "ZwSuspendProcess" );

		fncNtSuspendProcess = ( decltype(fncNtSuspendProcess) )Function;
	}

	return fncNtSuspendProcess( hProcess ) == (NTSTATUS)(0x00000000l);
}

bool NtResumeProcess( /*IN*/ const HANDLE hProcess )
{
	__ASSERT__( hProcess != INVALID_HANDLE_VALUE && hProcess != NULL );

	static NTSTATUS(__stdcall* fncNtResumeProcess)(HANDLE ProcessHandle) = NULL;

	if ( fncNtResumeProcess == NULL )
	{
		HMODULE hNtDll = GetModuleHandleW( L"ntdll.dll" );
		if ( hNtDll == NULL )
			 hNtDll = LoadLibraryW( L"ntdll.dll" );
		__ASSERT__( hNtDll != NULL );
		void* Function = GetProcAddress( hNtDll, "NtResumeProcess" );
		if ( Function == NULL )
			 Function = GetProcAddress( hNtDll, "ZwResumeProcess" );

		fncNtResumeProcess = ( decltype(fncNtResumeProcess) )Function;
	}

	return fncNtResumeProcess( hProcess ) == (NTSTATUS)(0x00000000l);
}

bool LoadFileToMemory( /*IN*/ const wchar_t* FilePath, /*OUT*/ BYTE** Image, /*OUT*/ DWORD* ImageSize )
{
	__ASSERT__( FilePath != NULL );
	__ASSERT__( Image != NULL );
	__ASSERT__( ImageSize != NULL );

	*(void**)Image = (void*)NULL;
	*(DWORD*)ImageSize = (DWORD)NULL;
	bool ReturnState = false;

	const HANDLE FileHandle = CreateFileW( FilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL );
	if ( FileHandle == NULL || FileHandle == INVALID_HANDLE_VALUE ) return ReturnState;

	const ULONG FileSize = GetFileSize(FileHandle, NULL);
	if ( FileSize != NULL && FileSize != (ULONG)(0xFFFFFFFFui32) )
	{
		BYTE* ImageInMemory = (BYTE*)malloc( FileSize + 0x100 );
		if ( ImageInMemory != NULL )
		{
			DWORD NumberOfBytesRead = (DWORD)NULL;
			if ( ReadFile(FileHandle, ImageInMemory, FileSize, &NumberOfBytesRead, NULL) == TRUE )
			{
				*(void**)Image = (void*)ImageInMemory;
				*(DWORD*)ImageSize = (DWORD)FileSize;
				ReturnState =  true;
			}
			else
				free( ImageInMemory );
		}
	}
	CloseHandle(FileHandle);
	return ReturnState;
};

BYTE HexNmbrToByte( /*IN*/ const char* a ){
	BYTE b[2] = {};

	__ASSERT__( a != NULL );

	for (int i1 = 0; i1 < ((int)2i32); i1++)
	{
		if ( a[i1] >= '0' && a[i1] <= '9' )
			b[i1] = a[i1] - '0';
		else
		if ( a[i1] >= 'A' && a[i1] <= 'F' )
			b[i1] = a[i1] - 'A' + 10;
		else
		if ( a[i1] >= 'a' && a[i1] <= 'f' )
			b[i1] = a[i1] - 'a' + 10;
	}

	BYTE outValue = 0;
	
	if ( a[1] == NULL || a[1] == ' ' )
		outValue = (b[0]&0xF);
	else
		outValue = ((b[0]&0xF) << 4) | (b[1]&0xF);

	*(WORD*)&b[0] = 0;
	return outValue;
}

BYTE* FindPattern( /*IN*/ const HMODULE hModule, /*IN*/ const DWORD dwSize, /*IN*/ const char* szSig)
{
	__ASSERT__( hModule != NULL );
	__ASSERT__( dwSize > 0 );
	__ASSERT__( szSig != NULL );

	const size_t SigLen = (size_t)strlen(szSig) + (size_t)1;
	__ASSERT__( SigLen > 0 );

	BYTE* byteSig = (BYTE*)malloc( SigLen + 2 );
	__ASSERT__( byteSig != NULL );
	ZeroMemory( byteSig, SigLen );
	
	size_t byteSigPos = (size_t)NULL;

	char* Mask = (char*)malloc( SigLen + 2 );
	__ASSERT__( Mask != NULL );
	ZeroMemory( Mask, SigLen );

	size_t MaskPos = (size_t)NULL;

	for (size_t i = 0; i < SigLen; )
	{
		const char* p = &szSig[i];
		if (p[0] == NULL)
			break;
		else
		if ( p[0] == ' ' )
		{
			i++;
			continue;
		}
		else
		if ( p[0] == (char)'?' && p[1] == (char)'?' )
		{
			Mask[ MaskPos++ ] = (char)'?';
			byteSig[ byteSigPos++ ] = (BYTE)0x00ui8;
			i += 2;
			continue;
		}
		else
		if ( p[0] == (char)'?' )
		{
			Mask[ MaskPos++ ] = (char)'?';
			byteSig[ byteSigPos++ ] = (BYTE)0x00ui8;
			i += 1;
			continue;
		}
		else
		{
			Mask[ MaskPos++ ] = (char)'x';
			byteSig[ byteSigPos++ ] = HexNmbrToByte( p );
			i += 2;
			continue;
		}
		continue;
	}
	if ( MaskPos == NULL || byteSigPos == NULL )
		return (BYTE*)NULL;

	Mask[ MaskPos++ ] = (char)NULL;
	byteSig[ byteSigPos++ ] = (BYTE)NULL;

	BYTE* Result = FindPattern( (BYTE*)hModule, dwSize, byteSig, Mask );
	
	ZeroMemory( byteSig, SigLen );
	free( byteSig ); byteSig = 0;

	ZeroMemory( Mask, SigLen );
	free( Mask ); Mask = 0;

	return Result;
}

DWORD GetValue( /*IN*/ const char* String )
{
	__ASSERT__( String != NULL );

	if ( (int)tolower(String[0]) == (int)'t' && 
		 (int)tolower(String[1]) == (int)'r' && 
		 (int)tolower(String[2]) == (int)'u' && 
		 (int)tolower(String[3]) == (int)'e' )
		 return TRUE;

	if ( (int)tolower(String[0]) == (int)'f' && 
		 (int)tolower(String[1]) == (int)'a' && 
		 (int)tolower(String[2]) == (int)'l' && 
		 (int)tolower(String[3]) == (int)'s' && 
		 (int)tolower(String[4]) == (int)'e' )
		 return FALSE;

	return (DWORD)atoi( String );
}

void GetCompilerSettings( /*IN*/ const char* FileContent, /*IN*/ const DWORD FileSize, /*OUT*/ struct CompilerSettings* Setting )
{
	__ASSERT__( FileContent != NULL );
	__ASSERT__( FileSize > 1 );
	__ASSERT__( Setting != NULL );

	//<cfg=Name>???</cfg>

	char CfgName[64] = {};
	ZeroMemory(CfgName, sizeof(CfgName) );

	for (DWORD i = 0; i < FileSize; i++)
	{
		if ( (int)tolower(FileContent[i+0]) == (int)'<' &&
			 (int)tolower(FileContent[i+1]) == (int)'c' &&
			 (int)tolower(FileContent[i+2]) == (int)'f' &&
			 (int)tolower(FileContent[i+3]) == (int)'g' &&
			 (int)tolower(FileContent[i+4]) == (int)'=' )
		{
			if ( FileContent[i+5] == '"' ) i+=1;

			
			DWORD j = 0;
			for ( ; (j+i+5) < FileSize; j++)
			{
				const char c = FileContent[j+i+5];
				CfgName[ j ] = c;
				if ( c == '>' || c == '"' || c == 0 ||c == '"' ||  c == '\n' || c == '\r' ) break;
			}
			CfgName[ j++ ] = 0;
			

			if ( _stricmp( CfgName, "RandomPadding" ) == 0 )
			{
				DWORD k = 0;
				for (; ; k++)
				{
					const char c = FileContent[k+j+i+5];
					CfgName[ k ] = c;
					if ( c == '<' || c == 0 || c == '"' || c == '\n' || c == '\r' )
						break;
				}
				CfgName[ k ] = 0;
				Setting->UseRandomPadding = GetValue( CfgName ) == TRUE;
			}
			else
			if ( _stricmp( CfgName, "RandomPaddingSize" ) == 0 )
			{
				DWORD k = 0;
				for (; ; k++)
				{
					const char c = FileContent[k+j+i+5];
					CfgName[k] = c;
					if ( c == '<' || c == 0 || c == '"' || c == '\n' || c == '\r' )
						break;
				}
				CfgName[k] = 0;
				Setting->g_constMaxObfuscationPaddingEntrys = GetValue( CfgName );
			}
			else
			if ( _stricmp( CfgName, "PrintDebugOutput" ) == 0 )
			{
				DWORD k = 0;
				for (; ; k++)
				{
					const char c = FileContent[k+j+i+5];
					CfgName[k] = c;
					if ( c == '<' || c == 0 || c == '"' || c == '\n' || c == '\r' )
						break;
				}
				CfgName[k] = 0;
				Setting->PrintDebugOutput = GetValue( CfgName ) == TRUE;
			}
			else
			if ( _stricmp( CfgName, "SearchDlls" ) == 0 )
			{
				DWORD k = 0;
				for (; ; k++)
				{
					const char c = FileContent[k+j+i+5];
					CfgName[k] = c;
					if ( c == '<' || c == 0 || c == '"' || c == '\n' || c == '\r' )
						break;
				}
				CfgName[k] = 0;
				Setting->SearchDlls = GetValue( CfgName ) == TRUE;
			}
			else
			if ( _stricmp( CfgName, "VirtualQuerySearch" ) == 0 )
			{
				DWORD k = 0;
				for (; ; k++)
				{
					const char c = FileContent[k+j+i+5];
					CfgName[k] = c;
					if ( c == '<' || c == 0 || c == '"' || c == '\n' || c == '\r' )
						break;
				}
				CfgName[k] = 0;
				Setting->VirtualQuerySearch = GetValue( CfgName ) == TRUE;
			}
			else
			{
				printf("[!] UNKNOWN COMPILER SETTING [%s]\n",CfgName);
				system("pause");
			}
		}

	}
	return;
}



wchar_t* OpenFileDialog( LPCWSTR DialogTitle )
{
	__ASSERT__( DialogTitle != NULL );

	static BOOL (APIENTRY* l_GetOpenFileNameW)(LPOPENFILENAMEW) = NULL;

	if ( l_GetOpenFileNameW == NULL )
	{
		HMODULE hCOMDLG32 = LoadLibraryW( L"COMDLG32.dll" );
		if ( hCOMDLG32 != NULL )
			l_GetOpenFileNameW = ( decltype(l_GetOpenFileNameW) )GetProcAddress( hCOMDLG32, "GetOpenFileNameW" );
		else
		{
			printf("[!]ERROR: failed to load COMDLG32\n");
			system("pause");
			return nullptr;
		}
	}
	if ( l_GetOpenFileNameW == NULL )
	{
		printf("[!]ERROR: failed to find GetOpenFileNameW\n");
		system("pause");
		return nullptr;
	}
	wchar_t* FilePath = (wchar_t*)malloc( 1025*2 );
	__ASSERT__( FilePath != NULL );

	OPENFILENAMEW OpenFileNameStruct = {};
	do
	{
		ZeroMemory( &OpenFileNameStruct, sizeof(OPENFILENAMEW) );
		ZeroMemory( FilePath, 1025 * 2 );

		OpenFileNameStruct.lStructSize = sizeof(OPENFILENAMEW);
		OpenFileNameStruct.lpstrFilter = L"ROP-Assembly code file ( .asm )\0*.asm;*.txt\0All\0*.*\0\0\0\0";
		OpenFileNameStruct.nFileOffset = 1;
		OpenFileNameStruct.lpstrFile = FilePath;
		OpenFileNameStruct.nMaxFile = 1024;
		OpenFileNameStruct.lpstrTitle = DialogTitle;
		OpenFileNameStruct.Flags = OFN_FILEMUSTEXIST;

		if ( l_GetOpenFileNameW( &OpenFileNameStruct ) != TRUE )
		{
			free( FilePath );
			FilePath = NULL;
		}
		else
		{
			HANDLE hFileHandle = CreateFileW( FilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL );
			if (	CloseHandle( hFileHandle ) != TRUE 
				||	hFileHandle == NULL 
				||	hFileHandle == INVALID_HANDLE_VALUE )
				FilePath[0] = NULL;
		}
	}
	while ( FilePath != NULL && FilePath[0] == NULL );

	return FilePath;
}

//-------------------------------------------------------------------------------
//https://github.com/learn-more/findpattern-bench/blob/master/patterns/kokole.h
bool DataCompare( /*IN*/ const BYTE* pData, /*IN*/ const BYTE* bSig, /*IN*/ const char* szMask)
{
	__ASSERT__( pData != NULL );
	__ASSERT__( bSig != NULL );
	__ASSERT__( szMask != NULL );

	for (; *szMask; ++szMask, ++pData, ++bSig)
	{
		if (*szMask == 'x' && *pData != *bSig)
			return false;
	}
	return (*szMask) == NULL;
}
BYTE* FindPattern( /*IN*/ const BYTE* dwAddress, /*IN*/ const DWORD dwSize, /*IN*/ const BYTE* pbSig, /*IN*/ const char* szMask)
{
	__ASSERT__( dwAddress != NULL );
	__ASSERT__( dwSize > 0 );
	__ASSERT__( pbSig != NULL );
	__ASSERT__( szMask != NULL );

	const DWORD length = (DWORD)strlen(szMask);
	__ASSERT__( length > 0 );

	for (DWORD i = NULL; i < dwSize - length; i++)
	{
		if (DataCompare(dwAddress + i, pbSig, szMask))
			return (BYTE*)(dwAddress + i);
	}
	return 0;
}
//-------------------------------------------------------------------------------


void RemoteLoadLibraryW( /*IN*/ const HANDLE hProcess, /*IN*/ const wchar_t* DllPath )
{
	__ASSERT__( hProcess != INVALID_HANDLE_VALUE && hProcess != NULL );
	__ASSERT__( DllPath != NULL );

	const SIZE_T DllPathLen = ( (SIZE_T)wcslen(DllPath) + (SIZE_T)1 ) * 2;

	__ASSERT__( DllPathLen > 2 );

	// The System Dlls get mapped to the same virtual address in every process :D
	HMODULE hKernel32 = GetModuleHandleW( L"kernel32.dll" );
	__ASSERT__( hKernel32 != NULL );

	PVOID FncLoadLibraryAddr = (PVOID)GetProcAddress( hKernel32, "LoadLibraryW" );
	__ASSERT__( FncLoadLibraryAddr != NULL );

	//Allocate space in the targets process for our string
	DWORD_PTR RemoteDllPath = (DWORD_PTR)VirtualAllocEx(hProcess, 0, (SIZE_T)( DllPathLen + (SIZE_T)8 ), MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
	__ASSERT__( RemoteDllPath != NULL );

	//write the string into the fresh allocated space:
	WriteProcessMemory(hProcess, (LPVOID)RemoteDllPath, (LPVOID)DllPath, DllPathLen, NULL);

	//Remote starting LoadLibrary:
	HANDLE hThread = CreateRemoteThread(	hProcess, 
											NULL, 
											NULL, 
											(LPTHREAD_START_ROUTINE)FncLoadLibraryAddr,
											(LPVOID)RemoteDllPath, //<= The parameter
											NULL, 
											NULL
										);
	__ASSERT__( hThread != NULL && hThread != INVALID_HANDLE_VALUE );
	//Lets wait till LoadLibrary is finished:
	WaitForSingleObject( hThread, INFINITE );DWORD ExitCode = 0;
	GetExitCodeThread( hThread, &ExitCode );

	//the dll path is not longer needed lets free that:
	VirtualFreeEx( hProcess, (LPVOID)RemoteDllPath, NULL, MEM_RELEASE );
}

void LoadAllDlls( /*IN*/ const HANDLE hGame )
{
	__ASSERT__( hGame != INVALID_HANDLE_VALUE && hGame != NULL );

	wchar_t Path[1024] = {};
	wcscpy_s( Path, L"c:\\windows\\syswow64\\" );

	UINT PathLen = (UINT)wcslen(Path);

	WIN32_FIND_DATAW FindData = {};
	ZeroMemory( &FindData, sizeof(WIN32_FIND_DATAW) );
	

	HANDLE hFind = FindFirstFileW( L"c:\\windows\\syswow64\\*.dll", &FindData );
	if ( hFind != NULL && hFind != INVALID_HANDLE_VALUE )
	{
		do
		{
			printf("FileName: [%ws]\n",FindData.cFileName);
			wcscpy_s( &Path[PathLen], (UINT)(1024ui32)-PathLen-(UINT)(1ui32), FindData.cFileName);
			RemoteLoadLibraryW( hGame, Path );

			ZeroMemory( &FindData, sizeof(WIN32_FIND_DATAW) );
		}
		while(FindNextFileW(hFind,&FindData) == TRUE);

		FindClose(hFind);
	}
}

void* ManualMapDynamicLinkLibrary( /*IN*/ void* DiskImage, /*IN OPTIONAL*/ DWORD_PTR RelocationPositionOverwrite )
{
	__ASSERT__( DiskImage != NULL );

	IMAGE_DOS_HEADER* DosHeader = (IMAGE_DOS_HEADER*)DiskImage;
	if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) 
		return (void*)NULL;

	const IMAGE_NT_HEADERS* NtHeaders = (IMAGE_NT_HEADERS*)ImageNtHeader( DosHeader );
	if ( NtHeaders == NULL || NtHeaders->Signature != IMAGE_NT_SIGNATURE ) 
		return (void*)NULL;

	const IMAGE_FILE_HEADER* FileHeader = (IMAGE_FILE_HEADER*)&NtHeaders->FileHeader;
	if ( (FileHeader->Characteristics & IMAGE_FILE_DLL ) != IMAGE_FILE_DLL && 
		 (FileHeader->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE ) != IMAGE_FILE_EXECUTABLE_IMAGE ) 
		return (void*)NULL;

	const IMAGE_OPTIONAL_HEADER* OptionalHeader = (IMAGE_OPTIONAL_HEADER*)&NtHeaders->OptionalHeader;
	if (   (OptionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC && (sizeof(IMAGE_OPTIONAL_HEADER) == sizeof(IMAGE_OPTIONAL_HEADER32)) )
		|| (OptionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC && (sizeof(IMAGE_OPTIONAL_HEADER) == sizeof(IMAGE_OPTIONAL_HEADER64)) ) )
		return (void*)NULL;

	const DWORD SizeOfImage = OptionalHeader->SizeOfImage;
	const DWORD SizeOfHeaders = OptionalHeader->SizeOfHeaders;
	const WORD  NumberOfSections = FileHeader->NumberOfSections;
	const WORD  SizeOfOptionalHeader = FileHeader->SizeOfOptionalHeader;

	if (   SizeOfImage <= (DWORD)0x1000 
		|| SizeOfHeaders < (DWORD)( sizeof(IMAGE_DOS_HEADER) )
		|| NumberOfSections < 1 
		|| SizeOfOptionalHeader < 1 )
		return (void*)NULL;

	DWORD MappedPageSize = (SizeOfImage / (DWORD)0x1000ui32) * (DWORD)0x1000ui32;
		if ( (SizeOfImage % (DWORD)0x1000ui32) != 0 )
			MappedPageSize += (DWORD)0x1000ui32;

	IMAGE_DOS_HEADER* MappedDosHeader = (IMAGE_DOS_HEADER*)VirtualAlloc( NULL, MappedPageSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE );
	if ( MappedDosHeader == NULL )
	{
		printf("[%s] failed to allocate buffer for image! [0x%X]\n",__FUNCTION__,GetLastError());
		return (void*)NULL;
	}
	
	/////////////////////////////////////////////////////////////// Image Sections //////////////////////////////////////////////////////////////
	//Copy Headers
	memcpy( MappedDosHeader, DosHeader, SizeOfHeaders );
	ZeroMemory( (void*)( (DWORD_PTR)MappedDosHeader + (DWORD_PTR)SizeOfHeaders ), (DWORD)0x1000 - SizeOfHeaders );

	//Copy Sections
	IMAGE_SECTION_HEADER* SectionHeaders = (IMAGE_SECTION_HEADER*)( (DWORD_PTR)OptionalHeader + SizeOfOptionalHeader );
	for( WORD i = 0; i< NumberOfSections; i++ )
	{
		const IMAGE_SECTION_HEADER* SectionHeader = (IMAGE_SECTION_HEADER*)&SectionHeaders[i];

		const DWORD VirtualAddress = SectionHeader->VirtualAddress;
		if ( VirtualAddress < (DWORD)0x1000ui32 || VirtualAddress > SizeOfImage ) continue;

		const PVOID Destination = (PVOID)( (DWORD_PTR)MappedDosHeader + (DWORD_PTR)VirtualAddress );

		const DWORD VirtualSize = SectionHeader->Misc.VirtualSize;
		if ( VirtualSize < (DWORD)1 ) continue;

		const DWORD SizeOfRawData = SectionHeader->SizeOfRawData;
		if ( SizeOfRawData < 1 || (SectionHeader->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) == IMAGE_SCN_CNT_UNINITIALIZED_DATA )
			ZeroMemory( Destination, VirtualSize );
		else
		{
			const DWORD PointerToRawData = SectionHeader->PointerToRawData;
			if ( PointerToRawData < SizeOfHeaders || SizeOfRawData < 1 ) continue;

			PVOID Source = (PVOID)( (DWORD_PTR)DiskImage + PointerToRawData );
			memcpy( Destination, Source, SizeOfRawData );

			if ( SizeOfRawData > VirtualSize )
				ZeroMemory( (void*)( (DWORD_PTR)Destination + VirtualSize ), (SizeOfRawData - VirtualSize) );
		}
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	
	///////////////////////////////////////////////////////////// Image Relocations /////////////////////////////////////////////////////////////
	const DWORD_PTR ImageBase = OptionalHeader->ImageBase;

	DWORD_PTR ImageDelta = NULL;
	if ( RelocationPositionOverwrite != NULL )
		ImageDelta = (DWORD_PTR)( (DWORD_PTR)RelocationPositionOverwrite - (DWORD_PTR)ImageBase );
	else
		ImageDelta = (DWORD_PTR)( (DWORD_PTR)MappedDosHeader - (DWORD_PTR)ImageBase );

	if ( ImageDelta != NULL )
	{
		const IMAGE_DATA_DIRECTORY* BaseRelocationDirectory = &OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		if ( BaseRelocationDirectory->Size > (DWORD)1ui32 && 
			 BaseRelocationDirectory->VirtualAddress > (DWORD)0x1000ui32 &&
			 BaseRelocationDirectory->VirtualAddress < SizeOfImage)
		{
			const DWORD_PTR BaseRelocationVA = BaseRelocationDirectory->VirtualAddress;
			IMAGE_BASE_RELOCATION* BaseRelocation = (IMAGE_BASE_RELOCATION*)( (DWORD_PTR)MappedDosHeader + (DWORD_PTR)BaseRelocationVA );
		
			while( BaseRelocation->VirtualAddress != NULL )
			{
				const DWORD dwSizeOfBlock = BaseRelocation->SizeOfBlock;
				DWORD_PTR RelocationBaseAddress = BaseRelocation->VirtualAddress;
				
				if( dwSizeOfBlock > sizeof(IMAGE_BASE_RELOCATION) && RelocationBaseAddress > (DWORD_PTR)(0x1000) )
				{
					RelocationBaseAddress += (DWORD_PTR)MappedDosHeader;
					const WORD* Relocations = (WORD*)( (DWORD_PTR)BaseRelocation + sizeof(IMAGE_BASE_RELOCATION) );
					const DWORD RelocationCount = ( dwSizeOfBlock - sizeof(IMAGE_BASE_RELOCATION) ) / sizeof(WORD);
					for( DWORD i = 0; i < RelocationCount; i++ )
					{
						const WORD Entry = Relocations[i];

						const WORD RelocationType = (Entry >> 12);
						const WORD RelocationOffset = Entry & 0xfff;

						const DWORD_PTR VirtualAddress = RelocationBaseAddress + (DWORD_PTR)RelocationOffset;
						
						//https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a79a460be03d9da50f71d427b26238496

						//https://github.com/DarthTon/Blackbone/blob/43bc59f68dc1e86347a76192ef3eadc0bf21af67/src/BlackBoneDrv/ldrreloc.c#L229

						if ( RelocationType == IMAGE_REL_BASED_ABSOLUTE )
						{
							//
							// Absolute - no fixup required.
							//
						}
						else
						if ( RelocationType == IMAGE_REL_BASED_HIGH )
						{
							//
							// High - (16-bits) relocate the high half of an address.
							//
							
							LONG Temp = *(WORD*)(VirtualAddress) << 16;
							Temp += (ULONG)(ImageDelta & 0xFFFFFFFF);
							*(WORD*)VirtualAddress = (WORD)(Temp >> 16);
							
							//*(WORD*)VirtualAddress = HIWORD(MAKELONG(0, *(WORD*)VirtualAddress) + (ImageDelta & 0xFFFFFFFF));
						}
						else
						if ( RelocationType == IMAGE_REL_BASED_LOW )
						{
							//
							// Low - (16-bit) relocate the low half of an address.
							//
							*(WORD*)VirtualAddress += (WORD)(ImageDelta & 0xFFFF);
						}
						else
						if ( RelocationType == IMAGE_REL_BASED_HIGHLOW )
						{
							//
							// HighLow - (32-bits) relocate the high and low half
							//      of an address.
							//
							*(DWORD*)VirtualAddress = (DWORD)(ImageDelta & 0xFFFFFFFF);
						}
						else
						if ( RelocationType == IMAGE_REL_BASED_HIGHADJ )
						{
							//
							// Adjust high - (16-bits) relocate the high half of an
							//      address and adjust for sign extension of low half.
							//

							//
							// If the address has already been relocated then don't
							// process it again now or information will be lost.
							//
							if (RelocationOffset & 2/*LDRP_RELOCATION_FINAL*/ ) {
								;
							}
							else
							{
								LONG
								Temp = *(WORD*)(VirtualAddress) << 16;
								Temp += (LONG)( Relocations[i+1] );
								Temp += (ULONG)(ImageDelta & 0xFFFFFFFF);
								Temp += 0x8000;
								*(WORD*)VirtualAddress = (WORD)(Temp >> 16);
							}
							i++;
						}
						else
						if (   RelocationType == IMAGE_REL_BASED_MACHINE_SPECIFIC_5
							|| RelocationType == IMAGE_REL_BASED_RESERVED
							|| RelocationType == IMAGE_REL_BASED_MACHINE_SPECIFIC_7
							|| RelocationType == IMAGE_REL_BASED_MACHINE_SPECIFIC_8
							|| RelocationType == IMAGE_REL_BASED_MACHINE_SPECIFIC_9)
						{
							;
						}
						else
						if ( RelocationType == IMAGE_REL_BASED_DIR64 )
							*(unsigned __int64*)VirtualAddress += ImageDelta;
						
						
					}
				}
				BaseRelocation = (IMAGE_BASE_RELOCATION*)( (DWORD_PTR)BaseRelocation + (DWORD_PTR)dwSizeOfBlock );
			}
		}
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	
	/////////////////////////////////////////////////////////////// Image Imports ///////////////////////////////////////////////////////////////
	const IMAGE_DATA_DIRECTORY* DirectoryEntryImport = &OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	const DWORD DirectoryEntryImportVA = DirectoryEntryImport->VirtualAddress;
	if ( DirectoryEntryImportVA > (DWORD)0x1000ui32 && DirectoryEntryImportVA < SizeOfImage )
	{
		IMAGE_IMPORT_DESCRIPTOR* ImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)( (DWORD_PTR)MappedDosHeader + DirectoryEntryImportVA );

		IMAGE_THUNK_DATA* OrigFirstThunk	= (IMAGE_THUNK_DATA*)NULL;
		IMAGE_THUNK_DATA* FirstThunk		= (IMAGE_THUNK_DATA*)NULL;
	
		while( ImportDescriptor->Characteristics != (DWORD)NULL )
		{
			OrigFirstThunk	= (PIMAGE_THUNK_DATA)( (DWORD_PTR)MappedDosHeader + (DWORD_PTR)ImportDescriptor->OriginalFirstThunk );
			FirstThunk		= (PIMAGE_THUNK_DATA)( (DWORD_PTR)MappedDosHeader + (DWORD_PTR)ImportDescriptor->FirstThunk );

			const char* ModuleName = (const char*)( (DWORD_PTR)MappedDosHeader + (DWORD_PTR)ImportDescriptor->Name );
		
			const HMODULE LibraryAddr = (HMODULE)LoadLibraryA( ModuleName );
			if ( LibraryAddr != NULL ) 
			{
				while( OrigFirstThunk->u1.AddressOfData )
				{
					if(OrigFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
						FirstThunk->u1.Function = (DWORD_PTR)GetProcAddress( LibraryAddr, (char*)( IMAGE_ORDINAL(OrigFirstThunk->u1.Ordinal) ) );
					else
					{
						const DWORD AddressOfData = OrigFirstThunk->u1.AddressOfData;
						if ( AddressOfData > (DWORD)0x1000ui32 && AddressOfData < SizeOfImage )
						{
							const IMAGE_IMPORT_BY_NAME* ImportByName = (IMAGE_IMPORT_BY_NAME*)( (DWORD_PTR)MappedDosHeader + (DWORD_PTR)AddressOfData );
							FirstThunk->u1.Function = (DWORD_PTR)GetProcAddress( LibraryAddr, (LPCSTR)ImportByName->Name );
						}
					}
					OrigFirstThunk = (IMAGE_THUNK_DATA*)( (DWORD_PTR)OrigFirstThunk + (DWORD_PTR)sizeof(IMAGE_THUNK_DATA) );
					FirstThunk     = (IMAGE_THUNK_DATA*)( (DWORD_PTR)FirstThunk     + (DWORD_PTR)sizeof(IMAGE_THUNK_DATA) );
				}
			}
			ImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)( (DWORD_PTR)ImportDescriptor + (DWORD_PTR)sizeof(IMAGE_IMPORT_DESCRIPTOR) );
		}
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	return MappedDosHeader;
}

//Code from ReactOS:
int __cdecl __memcmp__( /*IN*/ const void *s1, /*IN*/ const void *s2, /*IN*/ size_t n)
{
	if ( n != (size_t)NULL ) 
	{
		__ASSERT__( s1 != NULL && s2 != NULL );

		//https://doxygen.reactos.org/d5/d21/memcmp_8c.html

		const unsigned char *p1 = (const unsigned char *)s1, *p2 = (const unsigned char *)s2;
		do 
		{
			if (*p1++ != *p2++)
				return (*--p1 - *--p2);
		} while (--n != 0);
	}
	return 0;
}

Progressbar::Progressbar( /*IN*/ char* Text, /*IN*/ int Size )
{
	__ASSERT__( Text != NULL );

	CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo = {};
	ZeroMemory( &ConsoleScreenBufferInfo, sizeof(CONSOLE_SCREEN_BUFFER_INFO) );

	this->hStdOutHandle = GetStdHandle(STD_OUTPUT_HANDLE);

	GetConsoleScreenBufferInfo( hStdOutHandle, (CONSOLE_SCREEN_BUFFER_INFO*)&ConsoleScreenBufferInfo );

	this->dwCursorPosition = ConsoleScreenBufferInfo.dwCursorPosition;

	this->ProgressText = Text;
	this->Size = Size;
}

void Progressbar::update( /*IN*/ char* Status, /*IN*/ double percentage )
{
	__ASSERT__( Status != NULL );

	const BOOL ConsoleCursorPositionUpdated =
	SetConsoleCursorPosition( this->hStdOutHandle, this->dwCursorPosition );

	if ( ConsoleCursorPositionUpdated == TRUE )
	{
		const int ProgressPercentage= (int)( (double)percentage * (double)(100.f)		);
		const int ProgressSize		= (int)( (double)percentage * (double)this->Size	);
		const int ProgressLeft		= (int)( (int)this->Size	- (int)ProgressSize		);

		char* ProgressBuffer = (char*)malloc( ProgressSize + 1 );
		__ASSERT__( ProgressBuffer != NULL );

		memset( ProgressBuffer, '=', ProgressSize );
		ProgressBuffer[ProgressSize] = NULL;

		printf ("%s\n%s [%.*s%*s] %3d%%\n", Status, this->ProgressText, ProgressSize, ProgressBuffer,ProgressLeft, "",ProgressPercentage);

		free( ProgressBuffer );
	}
}

template< typename T >
T* SelectRandomElement( /*IN*/ T* Array, /*IN*/ DWORD ArraySize )
{
	__ASSERT__( Array != NULL );
	__ASSERT__( ArraySize > 0 );

	DWORD RandomSelection = NULL;
	if ( ArraySize < (DWORD)1000000000ui32 )
	{
		DWORD MaxNumber = (DWORD)100ui32;
		for ( ; (DWORD)( ArraySize / MaxNumber ) != (DWORD)NULL ; MaxNumber *= 10ui32 )
			;

		const DWORD Steps = (DWORD)MaxNumber / ArraySize;

		RandomSelection = (DWORD)(GetRandomDword() % (DWORD)(Steps * ArraySize)) + (DWORD)1ui32;

		for (DWORD i = 0, j = ( (DWORD)ArraySize - (DWORD)1ui32 ); i < ArraySize; i++, j--)
		{
			const DWORD CompareValue =  j * Steps;
			if ( RandomSelection > CompareValue )
				return (T*)( (DWORD_PTR)Array + (sizeof(T) * (DWORD_PTR)(i)) );
		}
	}
	printf("FATAL ERROR in SelectRandomElement => { RandomSelection:[%u] }\n",RandomSelection);
	system("pause");
	return NULL;
}

void* SelectRandomElement( /*IN*/ void* Array, /*IN*/ DWORD ArraySize, /*IN*/ DWORD ArrayDataTypeSize )
{
	__ASSERT__( Array != NULL );
	__ASSERT__( ArraySize > 0 );
	__ASSERT__( ArrayDataTypeSize > 0 );

	DWORD RandomSelection = NULL;
	if ( ArraySize < (DWORD)1000000000ui32 )
	{
		DWORD MaxNumber = (DWORD)100ui32;
		for ( ; (DWORD)( ArraySize / MaxNumber ) != (DWORD)NULL ; MaxNumber *= 10ui32 )
			;

		const DWORD Steps = (DWORD)MaxNumber / ArraySize;

		RandomSelection = (DWORD)(g_RandomGenerator.GetDword() % (DWORD)(Steps * ArraySize)) + 1;

		for (DWORD i = 0, j = ( (DWORD)ArraySize - (DWORD)1ui32 ); i < ArraySize; i++, j--)
		{
			const DWORD CompareValue = j * Steps;
			if ( RandomSelection > CompareValue )
				return (void*)( (DWORD_PTR)Array + (ArrayDataTypeSize * (DWORD_PTR)(i)) );
		}
	}
	__ASSERT__( ArraySize < (DWORD)1000000000ui32 );

	printf("FATAL ERROR in SelectRandomElement => { RandomSelection:[%u] }\n",RandomSelection);
	system("pause");
	return NULL;
}

bool EnablePrivilege( /*IN*/ LPCWSTR PrivilegeName )
{
	__ASSERT__( PrivilegeName != NULL );

	BOOL bResult = FALSE;
	
	HANDLE TokenHandle = NULL;
	bResult = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &TokenHandle);
	if ( bResult != TRUE || TokenHandle == NULL || TokenHandle == INVALID_HANDLE_VALUE )
		return false;

	LUID Luid = {};
	ZeroMemory( &Luid, sizeof(LUID) );

	bResult = LookupPrivilegeValueW( NULL, PrivilegeName, &Luid );
	if ( bResult == TRUE )
	{
		TOKEN_PRIVILEGES TokenPrivileges = {};
		ZeroMemory( &TokenPrivileges, sizeof(TOKEN_PRIVILEGES) );

		TokenPrivileges.PrivilegeCount = (DWORD)1ui32;
		TokenPrivileges.Privileges[0].Luid = Luid;
		TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		bResult = AdjustTokenPrivileges( TokenHandle, FALSE, &TokenPrivileges, NULL, NULL, NULL );
	}
	CloseHandle(TokenHandle);

	return bResult == TRUE; 
}

void EnableAllPrivileges( void )
{
	const LPCWSTR PrivilegeNames[] = 
	{
		SE_CREATE_TOKEN_NAME              ,
		SE_ASSIGNPRIMARYTOKEN_NAME        ,
		SE_LOCK_MEMORY_NAME               ,
		SE_INCREASE_QUOTA_NAME            ,
		SE_UNSOLICITED_INPUT_NAME         ,
		SE_MACHINE_ACCOUNT_NAME           ,
		SE_TCB_NAME                       ,
		SE_SECURITY_NAME                  ,
		SE_TAKE_OWNERSHIP_NAME            ,
		SE_LOAD_DRIVER_NAME               ,
		SE_SYSTEM_PROFILE_NAME            ,
		SE_SYSTEMTIME_NAME                ,
		SE_PROF_SINGLE_PROCESS_NAME       ,
		SE_INC_BASE_PRIORITY_NAME         ,
		SE_CREATE_PAGEFILE_NAME           ,
		SE_CREATE_PERMANENT_NAME          ,
		SE_BACKUP_NAME                    ,
		SE_RESTORE_NAME                   ,
		SE_SHUTDOWN_NAME                  ,
		SE_DEBUG_NAME                     ,
		SE_AUDIT_NAME                     ,
		SE_SYSTEM_ENVIRONMENT_NAME        ,
		SE_CHANGE_NOTIFY_NAME             ,
		SE_REMOTE_SHUTDOWN_NAME           ,
		SE_UNDOCK_NAME                    ,
		SE_SYNC_AGENT_NAME                ,
		SE_ENABLE_DELEGATION_NAME         ,
		SE_MANAGE_VOLUME_NAME             ,
		SE_IMPERSONATE_NAME               ,
		SE_CREATE_GLOBAL_NAME             ,
		SE_TRUSTED_CREDMAN_ACCESS_NAME    ,
		SE_RELABEL_NAME                   ,
		SE_INC_WORKING_SET_NAME           ,
		SE_TIME_ZONE_NAME                 ,
		SE_CREATE_SYMBOLIC_LINK_NAME      ,
	};

	for (DWORD i = 0; i < (DWORD)35ui32; i++)
		EnablePrivilege( (LPCWSTR)PrivilegeNames[i] );
}

void ClearConsole()
{
	HANDLE StdOutHandle = GetStdHandle(STD_OUTPUT_HANDLE);
	__ASSERT__( StdOutHandle != INVALID_HANDLE_VALUE && StdOutHandle != NULL );

	COORD ConsoleStartCoord  = {};
	ZeroMemory( &ConsoleStartCoord, sizeof(COORD) );

	CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo = {};
	ZeroMemory( &ConsoleScreenBufferInfo, sizeof(CONSOLE_SCREEN_BUFFER_INFO) );
	if ( GetConsoleScreenBufferInfo( StdOutHandle, &ConsoleScreenBufferInfo ) != TRUE )
		return;

	ConsoleStartCoord.X = (SHORT)NULL;
	ConsoleStartCoord.Y = (SHORT)NULL;
	if ( SetConsoleCursorPosition( StdOutHandle, ConsoleStartCoord ) != TRUE )
		return;

	const SHORT ConsoleBufferSizeX = ConsoleScreenBufferInfo.dwSize.X;
	const SHORT ConsoleBufferSizeY = ConsoleScreenBufferInfo.dwSize.Y;

	const DWORD ConsoleBufferSize = (DWORD)ConsoleBufferSizeX * (DWORD)ConsoleBufferSizeY;

	DWORD NumberOfCharsWritten = 0;
	FillConsoleOutputCharacterA( StdOutHandle, ' ', ConsoleBufferSize, ConsoleStartCoord, &NumberOfCharsWritten );

	DWORD NumberOfAttrsWritten = 0;
	FillConsoleOutputAttribute( StdOutHandle, 
								ConsoleScreenBufferInfo.wAttributes,
								ConsoleBufferSize, 
								ConsoleStartCoord, 
								&NumberOfAttrsWritten
							 );
}
```

`RopCompiler/Util.h`:

```h
#pragma once

#define getArraySize( Array, ElementDataType ) (sizeof(Array) / sizeof(ElementDataType))

void GetDecimalNumber( /*IN*/ const char* inString, /*OUT*/ DWORD64* outNumber, /*OUT*/ size_t* outI );
bool GetHeximalNumber( /*IN*/ const char *inString, /*OUT*/ DWORD64* outNumber, /*OUT*/ size_t* outI );

char* RegToString( /*IN*/ const enum Regs Reg );
enum Regs GetReg(  /*IN*/ const char* p);

unsigned long GetProcessIdByName( /*IN*/ const char *ProcessName);

struct RemoteProcessModuleInfo
{
	BYTE  * modBaseAddr;        // Base address of module in th32ProcessID's context
    DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
    HMODULE hModule;            // The hModule of this module in th32ProcessID's context
    WCHAR   szModule[255 + 1];
    WCHAR   szExePath[MAX_PATH];
};
bool GetRemoteProcessModuleInfo( /*IN*/ const DWORD ProcessId, /*IN*/ const wchar_t* ModuleName, /*OUT*/ struct RemoteProcessModuleInfo* outInfo );

bool GetRemoteProcessModuleExportAddress( /*IN*/ const DWORD ProcessId, /*IN*/ const char* ModuleName, /*IN*/ const char* ExportName, /*OUT*/ DWORD_PTR* outAddress );

bool RemoteSuspendProcessThreads( /*IN*/ const DWORD ProcessId, /*IN*/ bool Resume );

bool NtSuspendProcess( /*IN*/ const HANDLE hProcess );
bool NtResumeProcess ( /*IN*/ const HANDLE hProcess );

bool EnablePrivilege( /*IN*/ LPCWSTR PrivilegeName );
void EnableAllPrivileges( void );

bool LoadFileToMemory( /*IN*/ const wchar_t* FilePath, /*OUT*/ BYTE** Image, /*OUT*/ DWORD* ImageSize );

BYTE* FindPattern(/*IN*/ const BYTE* dwAddress, /*IN*/ const DWORD dwSize, /*IN*/ const BYTE* pbSig, /*IN*/ const char* szMask);
BYTE* FindPattern(/*IN*/ const HMODULE hModule , /*IN*/const DWORD dwSize, /*IN*/ const char* szSig);

void GetCompilerSettings( const char* FileContent, const DWORD FileSize, struct CompilerSettings* Setting );

wchar_t* OpenFileDialog( LPCWSTR DialogTitle );

void RemoteLoadLibraryW( const HANDLE hProcess, const wchar_t* DllPath );
void LoadAllDlls( const HANDLE hProcess );

void* ManualMapDynamicLinkLibrary( /*IN*/ void* DiskImage, /*IN OPTIONAL*/ DWORD_PTR RelocationPositionOverwrite = NULL );

int __cdecl __memcmp__( /*IN*/ const void *s1, /*IN*/ const void *s2, /*IN*/ size_t n );

struct Progressbar
{
	HANDLE hStdOutHandle;
	COORD dwCursorPosition;
	char* ProgressText;
	int Size;

	Progressbar( /*IN*/ char* Text, /*IN*/ int Size );
	void update( /*IN*/ char* Status, /*IN*/ double percentage );
};

void* SelectRandomElement( /*IN*/ void* Array, /*IN*/ DWORD ArraySize, /*IN*/ DWORD ArrayDataTypeSize );

void ClearConsole();


```

`RopCompiler/dbghelp.cpp`:

```cpp
#include <Windows.h>
#include "ASSERT.h"
#include <stdio.h>



#include "dbghelp.h"
//code from: https://github.com/Speedi13/Custom-GetProcAddress-and-GetModuleHandle-and-more

//////////////////////////////////////////////////////////////////////////////////////////////////
//			Equivalent to the windows api function ImageNtHeader
//////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Locates the IMAGE_NT_HEADERS structure in a PE image and returns a pointer to the data
/// </summary>
/// <param name="Base">The base address of an image that is mapped into memory by a call to the MapViewOfFile function</param>
/// <returns>If the function succeeds, the return value is a pointer to an IMAGE_NT_HEADERS structure</returns>
IMAGE_NT_HEADERS* WINAPI ImageNtHeader( _In_ const PVOID Base )
{
	IMAGE_DOS_HEADER *DosHeader = (IMAGE_DOS_HEADER*)Base;
	if ( DosHeader
		&& DosHeader->e_magic == IMAGE_DOS_SIGNATURE
		&& DosHeader->e_lfanew >= 0u
		&& DosHeader->e_lfanew < 0x10000000u )
	{
		IMAGE_NT_HEADERS* ImageNtHeader = (IMAGE_NT_HEADERS *)((BYTE *)DosHeader + DosHeader->e_lfanew);
		if ( ImageNtHeader->Signature == IMAGE_NT_SIGNATURE )
			return ImageNtHeader;
	}
	return nullptr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//			Equivalent to the windows api function ImageRvaToSection and ImageRvaToVa
//////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Locates a relative virtual address (RVA) within the image header of a file that is mapped as a file and returns a pointer to the section table entry for that RVA
/// </summary>
/// <param name="NtHeaders">A pointer to an IMAGE_NT_HEADERS structure. This structure can be obtained by calling the ImageNtHeader function.</param>
/// <param name="Base">This parameter is reserved</param>
/// <param name="Rva">The relative virtual address to be located</param>
/// <returns>If the function succeeds, the return value is a pointer to an IMAGE_SECTION_HEADER structure</returns>
IMAGE_SECTION_HEADER* WINAPI ImageRvaToSection( const IMAGE_NT_HEADERS* NtHeaders, const PVOID Base, const ULONG Rva)
{
	UNREFERENCED_PARAMETER( Base );

	if (!NtHeaders)
		return nullptr;

	DWORD dwNumberOfSections = NtHeaders->FileHeader.NumberOfSections;
	if (!dwNumberOfSections)
		return nullptr;

	WORD SizeOfOptionalHeader = NtHeaders->FileHeader.SizeOfOptionalHeader;
	IMAGE_SECTION_HEADER* pSectionHeaders = (IMAGE_SECTION_HEADER*)( (BYTE*)&NtHeaders->OptionalHeader + SizeOfOptionalHeader );
	for (DWORD i = 0; i < dwNumberOfSections; i++)
	{
		DWORD VirtualAddress = pSectionHeaders[i].VirtualAddress;
		DWORD SizeOfRawData = pSectionHeaders[i].SizeOfRawData;
		if ( (Rva >= VirtualAddress) && (Rva < (SizeOfRawData + VirtualAddress)) )
			return &pSectionHeaders[i];
	}
	return nullptr;
}

/// <summary>
/// Locates a relative virtual address (RVA) within the image header of a file that is mapped as a file and returns the virtual address of the corresponding byte in the file.
/// </summary>
/// <param name="NtHeaders">A pointer to an IMAGE_NT_HEADERS structure. This structure can be obtained by calling the ImageNtHeader function</param>
/// <param name="Base">The base address of an image that is mapped into memory through a call to the MapViewOfFile / ReadFile function</param>
/// <param name="Rva">The relative virtual address to be located</param>
/// <returns>If the function succeeds, the return value is the virtual address in the mapped file</returns>
PVOID WINAPI ImageRvaToVa( const IMAGE_NT_HEADERS* NtHeaders, const void* Base, const DWORD Rva)
{
	IMAGE_SECTION_HEADER* ResultSection = nullptr;

	ResultSection = ImageRvaToSection(NtHeaders, (PVOID)Base, Rva);
	if ( !ResultSection )
		return nullptr;

	return (char *)Base + (Rva - ResultSection->VirtualAddress) + ResultSection->PointerToRawData;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//			Equivalent to the windows api function ImageDirectoryEntryToDataEx
//////////////////////////////////////////////////////////////////////////////////////////////////
PVOID WINAPI ImageDirectoryEntryToDataInternal( PVOID Base, BOOLEAN MappedAsImage, ULONG* Size, DWORD SizeOfHeaders, IMAGE_DATA_DIRECTORY* DataDirectory, IMAGE_FILE_HEADER *ImageFileHeader, void* ImageOptionalHeader )
{
	*(ULONG*)Size = NULL;

	if ( !DataDirectory->VirtualAddress || !DataDirectory->Size || !SizeOfHeaders )
		return nullptr;

	*(ULONG*)Size = DataDirectory->Size;
	if ( MappedAsImage || DataDirectory->VirtualAddress < SizeOfHeaders )
		return (char *)Base + DataDirectory->VirtualAddress;

	WORD SizeOfOptionalHeader = ImageFileHeader->SizeOfOptionalHeader;
	WORD NumberOfSections = ImageFileHeader->NumberOfSections;
	if ( !NumberOfSections || !SizeOfOptionalHeader )
		return nullptr;

	IMAGE_SECTION_HEADER* pSectionHeaders = (IMAGE_SECTION_HEADER*)( (BYTE*)ImageOptionalHeader + SizeOfOptionalHeader );
	for (DWORD i = 0; i < NumberOfSections; i++)
	{
		IMAGE_SECTION_HEADER* pSectionHeader = &pSectionHeaders[i];
		if ( (DataDirectory->VirtualAddress >= pSectionHeader->VirtualAddress) && 
			 (DataDirectory->VirtualAddress < (pSectionHeader->SizeOfRawData + pSectionHeader->VirtualAddress)) )
		{
			return (char *)Base + (DataDirectory->VirtualAddress - pSectionHeader->VirtualAddress) + pSectionHeader->PointerToRawData;
		}
	}
	return nullptr;
}
PVOID WINAPI ImageDirectoryEntryToData32(PVOID Base, BOOLEAN MappedAsImage, USHORT DirectoryEntry, ULONG* Size, IMAGE_FILE_HEADER *ImageFileHeader, IMAGE_OPTIONAL_HEADER32 *ImageOptionalHeader)
{
	*(ULONG*)Size = NULL;

	if ( DirectoryEntry >= ImageOptionalHeader->NumberOfRvaAndSizes )
		return nullptr;

	IMAGE_DATA_DIRECTORY* DataDirectory = &ImageOptionalHeader->DataDirectory[DirectoryEntry];
	if ( !DataDirectory->VirtualAddress || !DataDirectory->Size )
		return nullptr;

	return ImageDirectoryEntryToDataInternal(	Base, 
												MappedAsImage, 
												Size, 
												ImageOptionalHeader->SizeOfHeaders, 
												DataDirectory, 
												ImageFileHeader, 
												ImageOptionalHeader );
}
PVOID WINAPI ImageDirectoryEntryToData64(PVOID Base, BOOLEAN MappedAsImage, USHORT DirectoryEntry, ULONG* Size, IMAGE_FILE_HEADER *ImageFileHeader, IMAGE_OPTIONAL_HEADER64 *ImageOptionalHeader)
{
	*(ULONG*)Size = NULL;

	if ( DirectoryEntry >= ImageOptionalHeader->NumberOfRvaAndSizes )
		return nullptr;

	IMAGE_DATA_DIRECTORY* DataDirectory = &ImageOptionalHeader->DataDirectory[DirectoryEntry];
	if ( !DataDirectory->VirtualAddress || !DataDirectory->Size )
		return nullptr;

	return ImageDirectoryEntryToDataInternal(	Base, 
												MappedAsImage, 
												Size, 
												ImageOptionalHeader->SizeOfHeaders, 
												DataDirectory, 
												ImageFileHeader, 
												ImageOptionalHeader );
}
PVOID WINAPI ImageDirectoryEntryToDataRom(PVOID Base, WORD HeaderMagic, USHORT DirectoryEntry, ULONG* Size, IMAGE_FILE_HEADER *ImageFileHeader, IMAGE_ROM_OPTIONAL_HEADER *ImageRomHeaders)
{
	UNREFERENCED_PARAMETER(HeaderMagic);

	*(ULONG*)Size = NULL;

	if ( ImageFileHeader->NumberOfSections <= 0u || !ImageFileHeader->SizeOfOptionalHeader )
		return nullptr;

	IMAGE_SECTION_HEADER* pSectionHeader = (IMAGE_SECTION_HEADER*)( (BYTE*)ImageRomHeaders + ImageFileHeader->SizeOfOptionalHeader );

	WORD j = 0;
	for ( ; j < ImageFileHeader->NumberOfSections; j++, pSectionHeader++)
	{
		if ( DirectoryEntry == 3 && _stricmp((char *)pSectionHeader->Name, ".pdata") == NULL )
			break;
		if ( DirectoryEntry == 6 && _stricmp((char *)pSectionHeader->Name, ".rdata") == NULL )
		{
			*(ULONG*)Size = NULL;
			for ( BYTE* i = (BYTE *)Base + pSectionHeader->PointerToRawData + 0xC; *(DWORD *)i; i += 0x1C )
				*Size += 0x1C;
			break;
		}
	}
	if ( j >= ImageFileHeader->NumberOfSections )
		return nullptr;	

	return (char *)Base + pSectionHeader->PointerToRawData;
}

/// <summary>
/// Locates a directory entry within the image header and returns the address of the data for the directory entry
/// </summary>
/// <param name="Base">The base address of the image or data file</param>
/// <param name="MappedAsImage">If the flag is TRUE, the file is mapped by the system as an image. If this flag is FALSE, the file is mapped as a data file by the MapViewOfFile / ReadFile function</param>
/// <param name="DirectoryEntry">The directory entry to be located</param>
/// <param name="Size">A pointer to a variable that receives the size of the data for the directory entry that is located</param>
/// <returns>If the function succeeds, the return value is a pointer to the data for the directory entry</returns>
LPCVOID WINAPI ImageDirectoryEntryToDataEx( const PVOID Base, const BOOLEAN MappedAsImage, const USHORT DirectoryEntry, ULONG* Size)
{
	*(ULONG*)Size = NULL;

	IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)Base;
	if (!pDosHeader)
		return nullptr;

	IMAGE_FILE_HEADER* ImageFileHeader = nullptr;
	IMAGE_OPTIONAL_HEADER* ImageOptionalHeader = nullptr;

	LONG NtHeaderFileOffset = pDosHeader->e_lfanew;
	IMAGE_NT_HEADERS* ImageNtHeader = (PIMAGE_NT_HEADERS)( (LPBYTE)pDosHeader + NtHeaderFileOffset );

	if (	pDosHeader->e_magic == IMAGE_DOS_SIGNATURE 
		&&	NtHeaderFileOffset > 0 
		&&	NtHeaderFileOffset < 0x10000000u 
		&&	ImageNtHeader->Signature == IMAGE_NT_SIGNATURE )
	{
		ImageFileHeader = &ImageNtHeader->FileHeader;	
		ImageOptionalHeader = &ImageNtHeader->OptionalHeader;
	}
	else
	{
		ImageFileHeader = (IMAGE_FILE_HEADER *)Base;
		ImageOptionalHeader = (IMAGE_OPTIONAL_HEADER *)( (BYTE*)Base + 0x14 );
	}
	switch ( ImageOptionalHeader->Magic )
	{
	case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
		return ImageDirectoryEntryToData32(
			Base,
			MappedAsImage,
			DirectoryEntry,
			Size,
			ImageFileHeader,
			(IMAGE_OPTIONAL_HEADER32 *)ImageOptionalHeader);
	case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
		return ImageDirectoryEntryToData64(
			Base,
			MappedAsImage,
			DirectoryEntry,
			Size,
			ImageFileHeader,
			(IMAGE_OPTIONAL_HEADER64 *)ImageOptionalHeader);
	case IMAGE_ROM_OPTIONAL_HDR_MAGIC:
		return ImageDirectoryEntryToDataRom(
			Base,
			IMAGE_ROM_OPTIONAL_HDR_MAGIC,
			DirectoryEntry,
			Size,
			ImageFileHeader,
			(IMAGE_ROM_OPTIONAL_HEADER *)ImageOptionalHeader);
	}
	return nullptr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//					Equivalent to the windows api function GetProcAddress
//////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Retrieves the address of an exported function inside the specified module
/// </summary>
/// <param name="hModule">Address of the module</param>
/// <param name="lpProcName">Name of the exported procedure</param>
/// <param name="MappedAsImage">Is the module mapped or a raw file? (TRUE / FALSE)</param>
/// <returns>returns the exported procedure address inside the specified module</returns>
FARPROC WINAPI GetProcAddressToLower( _In_ const HMODULE hModule, _In_ LPCSTR lpProcName, _In_ const BOOLEAN MappedAsImage )
{
	if (lpProcName == NULL)
		return nullptr;

	unsigned short ProcOrdinal = 0xFFFF;
	if ( (ULONG_PTR)lpProcName < 0xFFFF )
		ProcOrdinal = (ULONG_PTR)lpProcName & 0xFFFF;
	else
	{
		//in case of "#123" resolve the ordinal to 123
		if ( lpProcName[0] == '#' )
		{
			DWORD OrdinalFromString = atoi( lpProcName + 1 );
			if ( OrdinalFromString < 0xFFFF &&
				 OrdinalFromString != 0 )
			{
				ProcOrdinal = OrdinalFromString & 0xFFFF;
				lpProcName = (LPCSTR)( ProcOrdinal );
			}
		}
	}
	const IMAGE_DOS_HEADER* DosHeader = (IMAGE_DOS_HEADER*)hModule;
	if ( !DosHeader || DosHeader->e_magic != IMAGE_DOS_SIGNATURE)
		return nullptr;

	//only OptionalHeader is different between 64bit and 32bit so try not to touch it!
	const IMAGE_NT_HEADERS* NtHeader = (IMAGE_NT_HEADERS*)( (DWORD_PTR)DosHeader + DosHeader->e_lfanew );
	if ( NtHeader->Signature != IMAGE_NT_SIGNATURE )
		return nullptr;

	ULONG ExportDirectorySize = NULL;
	IMAGE_EXPORT_DIRECTORY* ExportDirectory = (IMAGE_EXPORT_DIRECTORY*)ImageDirectoryEntryToDataEx( (const PVOID)DosHeader, MappedAsImage, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportDirectorySize );
	if ( !ExportDirectory || !ExportDirectorySize )
		return nullptr;

	//check if any export functions are present
	if ( !ExportDirectory->NumberOfFunctions )
		return nullptr;

	//from BlackBone
	//https://github.com/DarthTon/Blackbone/blob/3dc33d815011b83855af607013d34c836b9d0877/src/BlackBone/Process/ProcessModules.cpp#L266
	// Fix invalid directory size
	if (ExportDirectorySize <= sizeof( IMAGE_EXPORT_DIRECTORY ))
	{
		// New size should take care of max number of present names (max name length is assumed to be 255 chars)
		ExportDirectorySize = static_cast<DWORD>( ExportDirectory->AddressOfNameOrdinals - (DWORD)( (BYTE*)(ExportDirectory) - (BYTE*)(DosHeader) )
												  + max( ExportDirectory->NumberOfFunctions, ExportDirectory->NumberOfNames ) * 255 );
	}

	DWORD AddressOfNamesRVA			= ExportDirectory->AddressOfNames;
	DWORD AddressOfFunctionsRVA		= ExportDirectory->AddressOfFunctions;
	DWORD AddressOfNameOrdinalsRVA	= ExportDirectory->AddressOfNameOrdinals;

	DWORD* ExportNames	= (DWORD*)( MappedAsImage ? ((BYTE*)DosHeader + AddressOfNamesRVA			) : ImageRvaToVa( NtHeader, DosHeader, AddressOfNamesRVA		) );
	DWORD* Functions	= (DWORD*)( MappedAsImage ? ((BYTE*)DosHeader + AddressOfFunctionsRVA		) : ImageRvaToVa( NtHeader, DosHeader, AddressOfFunctionsRVA	) );
	WORD*  Ordinals		= (WORD *)( MappedAsImage ? ((BYTE*)DosHeader + AddressOfNameOrdinalsRVA	) : ImageRvaToVa( NtHeader, DosHeader, AddressOfNameOrdinalsRVA	) );
	
	for (DWORD i = 0; i < ExportDirectory->NumberOfFunctions; i++)
	{
		unsigned short OrdinalIndex = Ordinals[i];

		DWORD ExportFncOffset = Functions[OrdinalIndex];
		if ( !ExportFncOffset )
			continue;

		char* ProcNamePtr = (char*)( MappedAsImage ? ((char*)DosHeader + ExportNames[i])  : ImageRvaToVa( NtHeader, DosHeader, ExportNames[i]  ) );
		BYTE* ExportFnc	  = (BYTE*)( MappedAsImage ? ((BYTE*)DosHeader + ExportFncOffset) : ImageRvaToVa( NtHeader, DosHeader, ExportFncOffset ) );

		//Forwarded exports:
		if ( MappedAsImage &&	//Not supported on images that are not mapped
								//Not supported with ordinals for forwarded export by name
			//Check for forwarded export:
			ExportFnc > ((BYTE*)ExportDirectory) && 
			ExportFnc < ((BYTE*)ExportDirectory + ExportDirectorySize))
		{
			//for example inside the Kernelbase.dll's export table
			//NTDLL.RtlDecodePointer
			//It could also forward an ordinal
			//NTDLL.#123
			char* ForwardedString = (char*)ExportFnc;
			DWORD ForwardedStringLen = (DWORD)strlen( ForwardedString )+1;
			if ( ForwardedStringLen >= 256 )
				continue;
			 char szForwardedLibraryName[256];
			memcpy( szForwardedLibraryName, ForwardedString, ForwardedStringLen );
			char* ForwardedFunctionName = NULL;
			char* ForwardedFunctionOrdinal = NULL;
			for (DWORD s = 0; s < ForwardedStringLen; s++)
			{
				if (szForwardedLibraryName[s] == '.')
				{
					szForwardedLibraryName[s] = NULL;
					ForwardedFunctionName = &ForwardedString[s+1];
					break;
				}
			}

			//forwarded by ordinal
			if ( ForwardedFunctionName != nullptr && ForwardedFunctionName[0] == '#' )
			{
				ForwardedFunctionOrdinal = ForwardedFunctionName + 1;
				ForwardedFunctionName = NULL;
			}
			if ( ForwardedFunctionName )
			{
				if ( strcmp( lpProcName, ForwardedFunctionName) != NULL )
					continue;

				HMODULE hForwardedDll = LoadLibraryA( szForwardedLibraryName );
				__ASSERT__( hForwardedDll != NULL );
				FARPROC ForwardedFunction = (FARPROC)GetProcAddressToLower( hForwardedDll, ForwardedFunctionName, MappedAsImage );
				return (FARPROC)ForwardedFunction;
			}
			else
			if ( ForwardedFunctionOrdinal && ProcOrdinal < 0xFFFF )
			{
				DWORD ForwardedOrdinal = atoi( ForwardedFunctionOrdinal );
				if ( ForwardedOrdinal > 0xFFFF || 
					 ForwardedOrdinal == 0 ||
					 ForwardedOrdinal != ProcOrdinal ) 
					continue;
				
				HMODULE hForwardedDll = LoadLibraryA( szForwardedLibraryName );
				FARPROC ForwardedFunction = (FARPROC)GetProcAddressToLower( hForwardedDll, (char*)(ForwardedOrdinal&0xFFFF), MappedAsImage );
				return (FARPROC)ForwardedFunction;
			}
			else
				continue;
		}
		
		if ( (ULONG_PTR)lpProcName > 0xFFFF && _stricmp( lpProcName, ProcNamePtr) == NULL )
			return (FARPROC)ExportFnc;
		else
		{
			if ( (OrdinalIndex+1) == ProcOrdinal )
				return (FARPROC)ExportFnc;
		}
	}
	return nullptr;
}

```

`RopCompiler/dbghelp.h`:

```h
#pragma once
//code from: https://github.com/Speedi13/Custom-GetProcAddress-and-GetModuleHandle-and-more

//////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Locates the IMAGE_NT_HEADERS structure in a PE image and returns a pointer to the data
/// </summary>
/// <param name="Base">The base address of an image that is mapped into memory by a call to the MapViewOfFile function</param>
/// <returns>If the function succeeds, the return value is a pointer to an IMAGE_NT_HEADERS structure</returns>
IMAGE_NT_HEADERS* WINAPI ImageNtHeader( _In_ const PVOID Base );

//////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Locates a relative virtual address (RVA) within the image header of a file that is mapped as a file and returns the virtual address of the corresponding byte in the file.
/// </summary>
/// <param name="NtHeaders">A pointer to an IMAGE_NT_HEADERS structure. This structure can be obtained by calling the ImageNtHeader function</param>
/// <param name="Base">The base address of an image that is mapped into memory through a call to the MapViewOfFile / ReadFile function</param>
/// <param name="Rva">The relative virtual address to be located</param>
/// <returns>If the function succeeds, the return value is the virtual address in the mapped file</returns>
PVOID WINAPI ImageRvaToVa( const IMAGE_NT_HEADERS* NtHeaders, const void* Base, const DWORD Rva);

/// <summary>
/// Locates a relative virtual address (RVA) within the image header of a file that is mapped as a file and returns a pointer to the section table entry for that RVA
/// </summary>
/// <param name="NtHeaders">A pointer to an IMAGE_NT_HEADERS structure. This structure can be obtained by calling the ImageNtHeader function.</param>
/// <param name="Base">This parameter is reserved</param>
/// <param name="Rva">The relative virtual address to be located</param>
/// <returns>If the function succeeds, the return value is a pointer to an IMAGE_SECTION_HEADER structure</returns>
IMAGE_SECTION_HEADER* WINAPI ImageRvaToSection( const IMAGE_NT_HEADERS* NtHeaders, const PVOID Base, const ULONG Rva);

//////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>
/// Retrieves the address of an exported function inside the specified module
/// </summary>
/// <param name="hModule">Address of the module</param>
/// <param name="lpProcName">Name of the exported procedure</param>
/// <param name="MappedAsImage">Is the module mapped or a raw file? (TRUE / FALSE)</param>
/// <returns>returns the exported procedure address inside the specified module</returns>
FARPROC WINAPI GetProcAddressToLower( _In_ const HMODULE hModule, _In_ LPCSTR lpProcName, _In_ const BOOLEAN MappedAsImage );
```