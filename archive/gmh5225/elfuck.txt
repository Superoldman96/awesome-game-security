Project Path: arc_gmh5225_elfuck_1c3as2sg

Source Tree:

```txt
arc_gmh5225_elfuck_1c3as2sg
├── LICENSE
├── Makefile
├── README.md
├── doc
│   ├── LICENSE
│   ├── README
│   └── TODO
├── include
│   ├── decompress.h
│   ├── elfuck.h
│   ├── execelf.h
│   ├── getpw.h
│   ├── lock.h
│   ├── nrv2e.h
│   ├── poly.h
│   └── stubify.h
└── src
    ├── Makefile
    ├── antidump.S
    ├── decompress.S
    ├── elfuck.c
    ├── execelf.S
    ├── getpw.c
    ├── lock.S
    ├── nrv2e.c
    ├── poly.c
    └── stubify.c

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {description}
    Copyright (C) {year}  {fullname}

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  {signature of Ty Coon}, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.


```

`Makefile`:

```
ef:	src/elfuck
src/elfuck:src/elfuck.c src/getpw.c src/nrv2e.c src/poly.c src/stubify.c src/decompress.S src/execelf.S src/lock.S include/decompress.h include/elfuck.h include/execelf.h include/getpw.h include/lock.h include/nrv2e.h include/poly.h include/stubify.h
	(cd src; make elfuck)
clean:
	rm -f ef core
	(cd src; make clean)

```

`README.md`:

```md
# elfuck
ELF packer for i386
origial version from sk2 by sd

```

`doc/LICENSE`:

```
ELFuck - ELF ultimate compression kit (c) 2002 by sd <http://sd.g-art.nl>
+-----------------------------------------------------------------------+
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

```

`doc/README`:

```
  ELFuck - ELF ultimate compression kit
  +-----------------------------------+
  ELFuck is basicaly compression utility, now extended by ELF password
  locking and string-burning, including polymorphics features to make
  pattern detection of protected binaries a bit harder.

  Compression (1-9 level)
  +---------------------+
  ELFuck uses excellent Markus F.X.J. Oberhumer's compression algorithm,
  NRV2E which carries very good compression with tiny decompressor
  (about 128 bytes!). This algorithm family is stolen from UPX, with
  difference in that decompression is done in real time; ELFuck will
  decompress ELF directly to .text/.data segment and executes authentic
  ELF image from there, on other hand, UPX creates original ELF in /tmp
  and execve() it, so that we don't need any writeable filesystem at all.
  Well, I should place note there that it is braindead to pack binaries
  smaller than 1kb, because ELFuck have to add 128 bytes of decompressor
  code and about 400 bytes of ELF loader and ELF header. For reference,
  table with ratios compared to gzip:

	File			Original size	NRV2E	%	gzip
	--------------------------------------------------------------
	/bin/bash		512540		245592 (47%)	243346
	/etc/termcap		700857		224779 (32%!)	225821
	/bin/rpm (static)	1328424		622559 (46%!)	628622
	/bin/ls			43740		21537  (49%!)	21569
	/boot/vmlinux		1296935		562507 (43%)	558392

  you see, in some cases it's better than gzip (well, compression
  takes more time, however) ...

  Locking (-l option)
  +-----------------+
  Because ELFuck is 100%-ly based on stolen ideas, I also implemented
  this one of BurnEye. Someone may like to disallow other users to
  use/analyse your binary (public shells, root browsing user's homes).
  The algorithm is kinda simple, but seems to be pretty effective:
  We'll select some password; expand it using sha1 to 160 bit key.
  by this key we'll encrypt, using RC4 algorithm, whole binary
  (except the decrypting stub, of course). We'll also keep
  last 32bits of sha1 against original binary, in order to check password.
  When someone will execute such protected binary; the stub will ask for
  password, make hash of it and try to decrypt the binary back using
  this key. Then we'll make a hash of potentially decrypted binary,
  check it against the value we've saved while creating, and if matches,
  the binary is decrypted correctly (=right password) and we'll let it
  run.

  Note, that the locked binary will look for 'EPW' shell variable, in case
  is there, password will be taken from it instead. This is useful
  when you've a lot of binaries locked with same password, so you'll just
  do `export EPW=password`, you'll not be asked for password anymore.

  This kind of protection of binaries is very strong, as someone without
  password will need to crack RC4 ... Good luck!

  Polymorphism / string burning (-s option)
  +---------------------------------------+
  Well, we're also using virus technology for good purposes ;)
  Using this option (-s) you'll get mutated binary each time,
  sucessfuly defeating pattern-scanners. However, the polymorphic
  decryptor will take about 500 bytes ;( For further details
  on polymorphic engine, look at poly.c

  However, to propagate itself, elfuck always put it's banner into
  generated ELF's header. To disable this behavior, use -b option.

  ATTENTION!
  +--------+
  Backup your target binary before using this utility! The name is not
  random, the way we're loading ELF binary into memory is not so clean,
  so things are just getting fucked up sometimes ;)

  Have fun!
   -sd

```

`doc/TODO`:

```
+ polymorphic ELF header

```

`include/decompress.h`:

```h
#ifndef DECOMPRESS_H
#define DECOMPRESS_H
extern	void decompress(void);
extern	void decompress_end(void);
extern	ulong decompress_src;
extern	ulong decompress_dest;
#define DECOMPRESS_SIZE ((unsigned) decompress_end - (unsigned) decompress)
#endif

```

`include/elfuck.h`:

```h
#ifndef ELFUCK_H
#define ELFUCK_H

#define ELF_BANNER "\nELFuck 0.1 compressed (c) 2002 by sd <http://sd.g-art.nl>\n"
#define BANNER	"ELFuck 0.1, real-time ELF executables compression/encryption\n" \
		"(c) Copyright 2002 by sd <http://sd.g-art.nl>\n"

#ifndef ulong
#define ulong unsigned long
#endif
#ifndef uchar
#define uchar unsigned char
#endif
#ifndef uint
#define uint unsigned int
#endif

#define eprintf(fmt...) fprintf(stderr, fmt)
#define ALIGNDOWN(x) ((x)&(~4095))
#define ALIGNUP(x) ALIGNDOWN((x)+4095)

#define FLAG_NOBANNER	1
#define FLAG_SCRAMBLE	2
#define FLAG_LOCK	4

#endif

```

`include/execelf.h`:

```h
#ifndef EXECELF_H
#define EXECELF_H
extern void execelf(void);
extern void execelf_end(void);
extern void e_skip_interp(void);
extern void e_no_interp(void);
extern char execelf_interp[256];
#define EXECELF_SIZE ((unsigned) execelf_end - (unsigned) execelf)
#endif

```

`include/getpw.h`:

```h
#ifndef GETPW_H
#define GETPW_H

#ifndef __ASSEMBLY__
void	getpassw(uchar *hash);
#endif
#define MAXPASS 56

#endif

```

`include/lock.h`:

```h
#ifndef LOCK_H
#define LOCK_H

extern	void elf_lock();
extern	ulong lock_start;
extern	ulong lock_testkey;
extern	ulong locked_len;
extern	void elf_lock_end();
extern	void sha1_asm(uchar *, char *, int);
extern	void rc4_asm(uchar *, char *, int);

#define LOCK_SIZE ((ulong) elf_lock_end - (ulong) elf_lock)

#endif

```

`include/nrv2e.h`:

```h
/* implementation of the NRV2E-99 compression algorithm */
#ifndef NRV2E_H
#define NRV2E_H
#include "elfuck.h"
extern int ucl_nrv2e_99_compress(uchar *, uint, uchar *, uint *, void *, int, void *, uint *);
#endif

```

`include/poly.h`:

```h
#ifndef POLY_H
#define POLY_H

typedef struct {
	unsigned long a,b;
	unsigned paddr, plen;
	unsigned len;
	unsigned start;
} poly_key;

#define MAXGAPLEN	16
#define MINGAPLEN	8
#define MAXJUNK		3

//#define NOPGAP

char	*poly_gen(poly_key *key);
void	poly_encrypt(unsigned char *data, int len, poly_key *key);

#endif

```

`include/stubify.h`:

```h
#ifndef STUBIFY_H
#define STUBIFY_H
#include <linux/elf.h>
extern int	pack_elf(char *, char *, int, int);

typedef struct {
	void    (*callback) (int, uint, int, void * user);
	void	*user;
} ucl_callback;

struct stub {
	struct elf32_hdr	elf;
	struct elf32_phdr	phdr;
	uchar  data[1];
} __attribute__ ((packed));

struct elf_aux {
	ulong	phdr;
	ulong	phnum;
	ulong	entry;
	ulong	freestart;
	ulong	freelen;
}  __attribute__ ((packed));

#endif

```

`src/Makefile`:

```
#CC=dietlibc/diet gcc
CC=gcc
CFLAGS=-Wall -O2 -fno-stack-protector -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0 -z execstack -I../include
LDFLAGS=-s
.c.o:
	$(CC) $(CFLAGS) -c $<
.S.o:
	$(CC) $(CFLAGS) -c $<
elfuck:elfuck.o getpw.o nrv2e.o poly.o stubify.o decompress.o execelf.o lock.o
	$(CC) $(CFLAGS) -o elfuck elfuck.o getpw.o nrv2e.o poly.o stubify.o decompress.o execelf.o lock.o
clean:
	rm -f *.o elfuck core
elfuck.o: ../include/elfuck.h ../include/stubify.h
getpw.o: ../include/elfuck.h ../include/lock.h ../include/getpw.h
nrv2e.o:
poly.o: ../include/elfuck.h ../include/poly.h
stubify.o: ../include/nrv2e.h ../include/elfuck.h ../include/decompress.h ../include/execelf.h ../include/stubify.h ../include/poly.h ../include/getpw.h ../include/lock.h
../include/decompress.h:
../include/elfuck.h:
../include/execelf.h:
../include/getpw.h:
../include/lock.h:
../include/nrv2e.h: ../include/elfuck.h
../include/poly.h:
../include/stubify.h:

```

`src/antidump.S`:

```S
/*
 * $Id: antidup.S, this makes tracing of binary a bit harder. We're
 *	achieving this by simple technique -- we're tracing it first,
 *	linux won't allow ptrace() at one pid twice.
 */

.globl	antidump
.globl	antidump_end

antidump:
	xor	%eax, %eax
	mov	$190, %al
	int	$0x80
	test	%eax, %eax
	jz	traced_child
wait_loop:
	xor	%edx, %edx
	push	%ecx
	or	$-1, %ebx
	mov	%esp, %ecx
	push	$7
	pop	%eax
	int	$0x80
	pop	%ebx
	cmp	$0x7f, %bl
	mov	%bh, %bl
	jne	go_exit
/* child got signal, deliver it */
	and	$63, %ebx
	mov	%ebx, %esi
	xchg	%ecx, %eax
	push	$7
	pop	%ebx
	push	$26
	pop	%eax
	int	$0x80
	jmp	wait_loop
go_exit:
	push	$1
	pop	%eax
	int	$0x80
traced_child:
	xor	%ebx, %ebx
	push	$26
	pop	%eax
	int	$0x80
	test	%eax, %eax
	js	go_exit
entidump_end:

```

`src/decompress.S`:

```S
/*
 * $Id: decompress.S, NRV2E decompressor,
 *	111 bytes - optimized for size, not speed ;)
 */

.data
.align 0
.p2align 0
.globl	decompress
.globl	decompress_end
.globl	decompress_src
.globl	decompress_dest
decompress:
	cld
	.byte	0xbe	/* mov decompress_src, %esi */
decompress_src:	.long	0
	lodsl
	xchg	%eax, %edi
	push	%edi
decompr_start:
	or	$-1, %ebp
	xor	%ecx, %ecx
	xor	%ebx, %ebx
	call	ggetbit
getbit:
	add	%bl, %bl
	jne	gotbit
	mov	(%esi), %bl
	inc	%esi
	stc
	adc	%bl, %bl
gotbit:	ret
decompr_literal:
	movsb
	.byte	0xb0	/* jmp decompr_loop ;) */
ggetbit:
	pop	%edx
decompr_loop:
	call	*%edx
	jc	decompr_literal
decompr_match:
	xor	%eax, %eax
	inc	%eax
loop:
	call	*%edx
	adc	%eax, %eax
	call	*%edx
	jc	break
	dec	%eax
	call	*%edx
	adc	%eax, %eax
	jmp	loop
break:	sub	$3, %eax
	jc	decompr_same_off
	shl	$8, %eax
	lodsb
	xor	$0xffffffff, %eax
	jz	decompr_end
	sar	%eax
	xchg	%eax, %ebp
	jae	decompr_got_off
decompr_mlen1:
	call	*%edx
	adc	%ecx, %ecx
	jmp	decompr_got_len
	# not reached ?!
decompr_same_off:
	call	*%edx
	jc	decompr_mlen1
decompr_got_off:
	inc	%ecx
	call	*%edx
	jc	decompr_mlen1
loop1:
	call	*%edx
	adc	%ecx, %ecx
	call	*%edx
	jae	loop1
	inc	%ecx
	inc	%ecx
decompr_got_len:
	cmp	$-0x500, %ebp
	adc	$2, %ecx
	xchg	%esi, %eax
	lea	(%edi, %ebp, 1), %esi
	repz;	movsb
	xchg	%esi, %eax
	jmp	decompr_loop
decompr_end:
/* just execute decompressed code */
	ret
decompress_dest:
	.long	0
decompress_end:

```

`src/elfuck.c`:

```c
/*
 * $Id: elfuck.c, the main program, args parsing etc
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "elfuck.h"
#include "stubify.h"

void __stack_chk_fail(void) {}


int	usage(char *s)
{
	eprintf("%s [-bsl0123456789] input <output>\n"
		"\tb\tdon't include banner in header\n"
		"\ts\tscramble the file with polymorphic decryptor\n"
		"\tl\tlock the file by password\n"
		"\t1-9\tcompression level\n", s);
	return 1;
}

int	main(int argc, char *argv[])
{
	int	level = 9;
	char	*input;
	char	output[1024] = "output";
	int	i = 1;
	int	flags = 0;

	printf("%s\n", BANNER);

	/* parse args */
	if (argc < 2)
		return usage(argv[0]);

	/* arguments ? */
	if (argv[1][0] == '-') {
		int q;
		char *s = argv[1];

		i++;
		for (q = 1; q < strlen(s); q++) {
			if ((s[q] >= '1') && (s[q] <= '9')) {
				level = s[q] - '0';
				continue;
			}
			switch (s[q] & 0xdf) {
				case 'B':
					flags |= FLAG_NOBANNER;
					break;
				case 'S':
					flags |= FLAG_SCRAMBLE;
					break;
				case 'L':
					flags |= FLAG_LOCK;
					break;
				default:
					return usage(argv[0]);
			}
		}
	}

	if (argc <= i)
		return usage(argv[0]);
	input = argv[i];
	i++;
	if (i < argc) {
		strncpy(output, argv[i], sizeof(output)-1);
		output[sizeof(output)-1] = 0;
	}
	return pack_elf(input, output, abs(level), flags);
}

```

`src/execelf.S`:

```S
/*
 * $Id: execelf.S, executing any ELF file from memory - ~400 bytes ;)
 */

.data
.align 0
.p2align 0
.globl	execelf
.globl	execelf_end
.globl	execelf_interp
.globl	e_skip_interp
.globl	e_no_interp

#define DEBUG 0
GRANT=512

#if DEBUG
#define PAUSE \
	pushal; \
	pushl	$3; \
	pop	%eax; \
	push	$1; \
	pop	%edx; \
	push	%eax; \
	mov	%esp, %ecx; \
	xor	%ebx, %ebx; \
	int	$0x80; \
	pop	%eax; \
	popal;
#else
#define PAUSE
#endif

execelf:
//#include "antidump.S"
	call	e_getdelta
elf_error:
	call	e_getstrings
e_err1:
	.ascii	"ELF execution failed\n"
e_err2:
e_getstrings:
	movl	$4, %eax
	movl	$2, %ebx
	popl	%ecx
	movl	$(e_err2-e_err1), %edx
	int	$0x80
	mov	$1, %eax
	mov	$127, %ebx
	int	$0x80
e_getdelta:
	pop	%edi
	add	$(execelf_end-elf_error), %edi
	mov	%edi, %ebx
	xor	%ebp, %ebp	/* interpreter base, none at this time */
	xor	%eax, %eax
	scasb
	jz	e_no_interp
e_skip_interp:
	scasb
	jnz	e_skip_interp
e_load_interp:
	/* well, try open interpreter file */
	push	%esi
	mov	$5, %eax
	xor	%ecx, %ecx
	int	$0x80
	test	%eax, %eax
	js	elf_error
	mov	$4096, %edx
	sub	%edx, %esp	/* one page for headers */
	xchg	%eax, %ebx	/* handle to %ebx */
	mov	$3, %eax	/* read() */
	mov	%esp, %ecx
	int	$0x80
	
	mov	28(%esp), %edx	/* phdrs offset */
	push	$0		/* last_bss */
	push	$0		/* elf_bss */
e_load_findseg:
	cmpl	$1, 8(%esp, %edx)
	jne	e_load_nextseg
	/* this will mmap one segment */
e_load_mapseg:
	mov	8+8(%esp, %edx), %eax /* vaddr offset */
	mov	%eax, %edi
	and	$~4095, %edi
	and	$4095, %eax

	mov	8+4(%esp, %edx), %ecx /* offset in file */
	sub	%eax, %ecx

	mov	8+16(%esp, %edx), %esi /* filesz */
	add	%eax, %esi

	push	%ecx		/* offset */
	push	%ebx		/* fd */
	push	$0x12		/* MAP_FIXED | MAP_PRIVATE */
	push	$0x7		/* rwx */
	push	%esi		/* filesize */

	cmpw	$3, 8+5*4+16(%esp) /* ET_DYN ?! */
	jne	e_load_fixed
	add	%ebp, %edi	/* relocate */
	test	%ebp, %ebp	/* huh, base not known yet ? */
	jne	e_load_fixed
	andb	$~0x10, 8(%esp)	/* remove MAP_FIXED */
	push	$0
	.byte	0xb0		/* addr = 0, i.e. get random */
e_load_fixed:
	push	%edi		/* addr */
	mov	%esp, %ebx
	mov	$90, %eax
	int	$0x80		/* try mmap */
	cmp	$0xfffff000, %eax
1:	jae	elf_error	/* failed ? */

	testb	$0x10, 12(%esp)	/* was fixed ? */
	jnz	e_load_wasfixed
	sub	%edi, %eax	/* it's first dynamic - set base */
	xchg	%eax, %ebp	/* to the ebp */
e_load_wasfixed:
	add	$16, %esp
	pop	%ebx		/* restore fd */
	pop	%eax		/* offset - blah */

	mov	8+8(%esp, %edx), %ecx /* vaddr unaligned */
	add	%ebp, %ecx
	
	mov	8+16(%esp, %edx), %edi
	add	%ecx, %edi	/* k = load_addr + p_vaddr + p_filesz */
	pop	%eax		/* elf_bss */
	cmp	%edi, %eax	/* if (k > elf_bss) */
	jae	elf_bss_g
	xchg	%edi, %eax	/* elf_bss = k */
elf_bss_g:

	mov	4+20(%esp, %edx), %edi
	add	%ecx, %edi	/* k = load_addr + p_vaddr + p_memsz */
	pop	%esi		/* last_bss */
	cmp	%edi, %esi
	jae	last_bss_g
	mov	%edi, %esi
last_bss_g:
	pushl	%esi
	pushl	%eax

e_load_nextseg:
	add	$32, %edx
	decw	8+44(%esp)
	jnz	e_load_findseg

	mov	$6, %eax	/* close that sucker */
	int	$0x80

/* well, ladies and gantlemans, now pad zero the bss and mmap the rest of it */
	pop	%edi		/* elf_bss */
	pop	%ecx		/* last_bss */
	lea	4095(%edi), %eax /* where we'll start mmaping to */
	and	$~4095, %eax
	sub	%eax, %ecx	/* size */
	add	$4095, %ecx	/* pagealigned */
	and	$~4095, %ecx
	jecxz	no_bss

	push	$0
	push	$0
	push	$0x32
	push	$0x7
	push	%ecx
	push	%eax
	mov	%esp, %ebx
	mov	$90, %eax
	int	$0x80
	cmp	$0xfffff000, %eax
	jae	1b		/* failed ? */
	add	$24, %esp

	/* and also zero it */
	xor	%eax, %eax
	repz;	stosb
no_bss:

	mov	24(%esp), %eax	/* yep, we need new entrypoint */
	add	%ebp, %eax
	add	$4096, %esp
	pop	%esi
e_no_interp:
	mov	%esi, %edi
	test	%eax, %eax
	jnz	have_ep
	mov	8(%edi), %eax
have_ep:
	xchg	%eax, %ebx	/* entrypoint in ebx */
	mov	%edi, %edx	/* saved-aux in edx */

/* now go count stuff */
	mov	%esp, %esi
	lea	(%esp), %esi
	lodsl
	lea	4(%esi,%eax,4), %esi
skip_env:
	lodsl
	test	%eax, %eax
	jnz	skip_env

	push	%esi		/* save start of aux table */
skip_aux:
	lodsl
	test	%eax, %eax
	lodsl
	jnz	skip_aux

	pop	%eax

	sub	%esp, %esi	/* in esi is now size of block to be moved */
	mov	%esi, %ecx
	mov	%esp, %esi
	sub	$GRANT, %esp
	mov	%esp, %edi
	repz;	movsb

	push	%ebx		/* save entrypoint */
	lea	-512(%eax), %esi

	PAUSE

/*	push	$4
	pop	%ecx
	push	$22
	pop	%ebx
	call	set_aux_ent
	
	push	$6
	pop	%ecx
	push	$4096
	pop	%ebx
	call	set_aux_ent
	
	push	$8
	pop	%ecx
	push	$0
	pop	%ebx
	call	set_aux_ent

	push	$11
	pop	%ecx
	push	$0
	pop	%ebx
	call	set_aux_ent

	push	$12
	pop	%ecx
	push	$0
	pop	%ebx
	call	set_aux_ent

	push	$13
	pop	%ecx
	push	$0
	pop	%ebx
	call	set_aux_ent

	push	$14
	pop	%ecx
	push	$0
	pop	%ebx
	call	set_aux_ent */


	push	$3
	pop	%ecx		/* AT_PHDR */
	mov	(%edx), %ebx
	call	set_aux_ent
	mov	$5, %cl		/* AT_PHNUM */
	mov	4(%edx), %ebx
	call	set_aux_ent
	mov	$7, %cl		/* AT_BASE */
	mov	%ebp, %ebx
	call	set_aux_ent
	mov	$9, %cl		/* AT_ENTRY */
	mov	8(%edx), %ebx
	call	set_aux_ent

	/* now, free our unused pages and fire that sucker up */
	push	$91
	pop	%eax
	movl	12(%edx), %ebx
	movl	16(%edx), %ecx
	int	$0x80
	xor	%eax, %eax
	xor	%ebx, %ebx
	xor	%ecx, %ecx
	xor	%edx, %edx
	xor	%esi, %esi
	xor	%edi, %edi
	xor	%ebp, %ebp
	ret	/* voila! */

/* this will setup new/modify existing aux entry, well on buggy
   < 2.2.17 kernels we're going to overwrite envp, but heck, it
   seem to work fine -sd */
set_aux_ent:
	push	%esi
set_aux_find:
	lodsl
	test	%eax, %eax
	jz	set_aux_new
	cmp	%ecx, %eax
	lodsl
	jne	set_aux_find
	mov	%ebx, -4(%esi)
set_aux_done:
	pop	%esi
	ret
set_aux_new:
	mov	%ecx, -4(%esi)
	mov	%ebx, (%esi)
	and	$0, 4(%esi)
	jmp	set_aux_done

execelf_end:
execelf_interp:	.zero	256




```

`src/getpw.c`:

```c
/*
 * $Id: getpw.c, password input
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <termios.h>
#include <string.h>
#include <time.h>

#include "elfuck.h"
#include "lock.h"
#include "getpw.h"

/* this will return a 20byte hash of entered password */
void	getpassw(uchar *hash)
{
        struct  termios old, new;
	char	p1[MAXPASS], p2[MAXPASS];
	int	len1, len2;

	/* get old term settings */
        tcgetattr(0, &old);
        new = old;
        new.c_lflag &= ~(ECHO);
        tcsetattr(0, TCSAFLUSH, &new);
	while (1) {
		printf("Password: "); fflush(stdout);
		len1 = read(0, p1, sizeof(p1)-1);
		if (--len1 < 0) goto bad;
		p1[len1] = 0;
		putchar('\n');
		printf("Retype password:"); fflush(stdout);
		len2 = read(0, p2, sizeof(p2)-1);
		if (--len2 < 0) goto bad;
		p2[len2] = 0;
		putchar('\n');
		if ((len1 != len2) || (strcmp(p1, p2))) {
		bad:
			printf("Sorry, passwords do not match\n");
			continue;
		}
		break;
	}
        tcsetattr(0, TCSAFLUSH, &old);
	sha1_asm(hash, p1, len1);
}

```

`src/lock.S`:

```S
/*
 * $Id: lock.S, file locking, sha1 & rc4 (~400 & ~80 bytes)
 */

#define __ASSEMBLY__
#include "getpw.h"

.globl	elf_lock
.globl	lock_start
.globl	lock_testkey
.globl	elf_lock_end
.globl	rc4_asm
.globl	sha1_asm
.globl	locked_len

	.data
	.align	0
	.p2align 0

elf_lock:
	.byte	0xbd			/* mov lock_start, %ebp */
lock_start:	.long 0			/* ptr to encrypted data */
	mov	%esp, %esi
	sub	$(64+MAXPASS), %esp	/* 60 bytes - password, 64 bytes - terminfo */
	cld
	lodsl
	lea	4(%esi, %eax, 4), %esi
/* walk thru env and look for 'EPW=' */
find_env:
	lodsl
	test	%eax, %eax
	jz	find_env_end

	cmpl	$0x3d575045, (%eax)	/* cmp 'EPW=', (%eax) */
	jne	find_env
	lea	4(%eax), %esi
	jmp	have_pass
find_env_end:
get_pass:
	push	$4
	pop	%eax
	xor	%ebx, %ebx
	inc	%ebx
	mov	-4(%ebp), %edx		/* size of banner (negative!) */
	lea	-4(%ebp, %edx), %ecx
	neg	%edx
	int	$0x80
	/* we'must explicitly read password from stdin
	 * ioctl(TCGETS ... */
	pushl	$54
	popl	%eax		/* ioctl */
	xor	%ebx, %ebx	/* stdin */
	mov	$0x5401, %ecx	/* TCGETS */
	mov	%esp, %edx
	int	$0x80
	test	%eax, %eax
	jnz	err_out
ioctl_ok:
	pushl	12(%edx)
	andb	$0xf7, 12(%edx)	/* &= ~(ECHO) */
	inc	%ecx		/* 0x5402 - TCSETS */
	mov	$54, %al
	push	%eax
	int	$0x80

	push	%ecx
	push	%edx
	mov	$3, %al
	lea	64(%esp), %ecx
	mov	%ecx, %esi
	push	$MAXPASS
	pop	%edx		/* maximal password - 60 chrs */
	int	$0x80
	dec	%eax
	jns	1f
err_out:
	xchg	%eax, %ebx
	xor	%eax, %eax
	inc	%eax
	int	$0x80
1:
	movb	%ah, (%ecx, %eax) /* terminate string (yah, including \n) */

	pop	%edx		/* restore original terminfo */
	pop	%ecx
	pop	%eax
	popl	12(%edx)
	int	$0x80

	/* write newline */
	mov	$4, %al
	inc	%ebx
	push	$0xa
	mov	%esp, %ecx
	push	$1
	pop	%edx
	int	$0x80
	pop	%eax
have_pass:
	xor	%ecx, %ecx
	push	%esi
	.byte	0xb0
1:	inc	%ecx
	lodsb
	test	%al, %al
	jnz	1b
	pop	%esi
	mov	%esp, %edi
	call	sha1		/* and compute hash of password! */
	/* well, now use the password hash value as decryption key */
	.byte	0xb9		/* mov locked_len, %ecx */
locked_len:	.long	0
	mov	%ebp, %esi
/*
 * edi - key (hashed)
 * esi - input data
 * ecx - length
 */
	call	rc4		/* decrypt */
	push	%edi
	add	$20, %edi
	call	sha1		/* compute sha1 of result */
	.byte	0x81, 0x3f	/* cmp $lock_testkey, (%edi) */
lock_testkey:.long	0
	pop	%edi
	je	decrypt_ok
	call	rc4		/* repair back ;) */
	call	1f
	.ascii	"bad password\n"
1:	pop	%ecx
	push	$4
	pop	%eax
	push	$2
	pop	%ebx
	pushl	$13
	pop	%edx
	int	$0x80
	jmp	get_pass	/* try again ;) */
decrypt_ok:
	add	$(64+MAXPASS), %esp
	jmp	*%ebp		/* jump to decrypted proggie */

/*
 * RC4 implementation, 20 byte key assumed
 * edi - key
 * esi - data
 * ecx - datalen
 */
rc4:
	pushal
	mov	%esp, %ebp
	xor	%eax, %eax
1:	dec	%esp
	inc	%al
	jnz	1b
1:	movb	%al, (%esp, %eax)
	inc	%al
	jnz	1b		/* eax = 0 index2 */
	cdq			/* edx = 0, counter */
	xor	%ebx, %ebx	/* ebx = 0 index1 */
2:	addb	(%edi, %ebx), %al
	addb	(%esp, %edx), %al
	movb	(%esp, %edx), %bh
	xchgb	%bh, (%esp, %eax)
	movb	%bh, (%esp, %edx)
	xor	%bh, %bh
	inc	%ebx
	cmp	$20, %bl	/* <-- put key len there! */
	jc	1f
	and	%bh, %bl
1:	inc	%dl
	jnz	2b
	cdq			/* edx = 0, x */
	xor	%ebx, %ebx	/* ebx = 0, y */
1:	inc	%dl
	addb	(%esp, %edx), %bl
	movb	(%esp, %edx), %al
	xchgb	%al, (%esp, %ebx)
	movb	%al, (%esp, %edx)
	addb	(%esp, %ebx), %al
	mov	(%esp, %eax), %al
	xor	%al, (%esi)
	inc	%esi
	loop	1b
	mov	%ebp, %esp
	popa
	ret
rc4_end:

/*
 * minimalistic implementation of sha1 in x86 asm, ~400 bytes
 * esi - input bytes
 * ecx - number of input bytes
 * edi - 20 bytes of digest
 */
sha1:
	pusha
	push	%edi
	pushl	$0x67452301	/* state[0] */
	pushl	$0xEFCDAB89	/* state[1] */
	pushl	$0x98BADCFE	/* state[2] */
	pushl	$0x10325476	/* state[3] */
	pushl	$0xC3D2E1F0	/* state[4] */
	mov	%ecx, %eax
	mov	%ecx, %ebp
	shl	$3, %eax
	bswap	%eax		/* sha1 works with big endian only ;( */
	push	%eax		/* count[0] */
	sub	$128, %esp	/* for padding stuff */
trans_loop:
	cmp	$64, %ecx
	jc	gopad1
	call	transform
	add	$64, %esi
	sub	$64, %ecx
	jmp	trans_loop
gopad1:
	mov	%esp, %edi
	push	%ecx
	repz;	movsb
	movb	$0x80, %al	/* padding mark */
	stosb
	pop	%ebx
	mov	$127, %cl
	sub	%ebx, %ecx
	xor	%eax, %eax
	repz;	stosb
	mov	%esp, %esi	/* start to esi */
	inc	%ecx
	mov	127(%esi,%ecx), %eax	/* size to eax */
	cmp	$56, %ebx
	jc	single_align
double_align:
	mov	%eax, 124(%esi)
	call	transform
	add	$64, %esi
	.byte	0xba
single_align:
	mov	%eax, 60(%esp)
	call	transform
	add	$128+4, %esp
	
	mov	$5, %cl
	mov	20(%esp), %edi
1:	mov	-4(%esp, %ecx, 4), %eax
	bswap	%eax
	stosl
	loop	1b
	add	$24, %esp
	popa
ret

/*
 * well, this is the main SHA1 function
 * it must preserve all registers
 * 0(%esp) - count - unused
 * 4(%esp) - state[4]
 * 8(%esp) - state[3]
 * 12(%esp) - state[2]
 * 16(%esp) - state[1]
 * 20(%esp) - state[0]
 */
transform:
	pusha
	/* create private copy of processed data */
	pushl	$64
	popl	%ecx
	sub	%ecx, %esp
	mov	%esp, %edi
	repz;	movsb
	mov	%esp, %esi

	add	$128+36+4, %edi

	mov	16(%edi), %ebp
	mov	12(%edi), %eax
	mov	8(%edi), %ebx
	mov	4(%edi), %edx
	mov	(%edi), %edi

	/*
	 * e = a
	 * a = b
	 * b = c
	 * c = d
	 * d = e
	 */
	xor	%ecx, %ecx
aloop:
	# rotate a,b,c,d,e
	push	%eax
	push	%ebx
	push	%edx
	push	%edi
	push	%ebp
	pop	%eax
	pop	%ebp
	pop	%edi
	pop	%edx
	pop	%ebx

#!#
	push	%edx
	call	rop
	push	%eax
	rol	$5, %eax
	add	%eax, %edx
	pop	%eax
	add	%edx, %ebp
	rol	$30, %ebx
	pop	%edx

	inc	%ecx
	cmp	$80, %cl
	jc	aloop
	add	$64, %esp

	lea	128+36+4(%esp), %ecx

	add	%ebp, 16(%ecx)
	add	%eax, 12(%ecx)
	add	%ebx, 8(%ecx)
	add	%edx, 4(%ecx)
	add	%edi, (%ecx)

	popa
ret

rop:
	cmp	$20, %cl
	jae	r2
/*
 * R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
 * R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
 */
r0:
	xor	%edi, %edx	/* x = x^y */
	and	%ebx, %edx	/* x = x&w */
	xor	%edi, %edx	/* x = x^y */

	cmp	$20, %cl
	jae	r2
	cmp	$16, %cl
	jae	r1
r0_:
	push	%eax
	mov	(%esi, %ecx, 4), %eax /* x += blk0(i) */
	bswap	%eax
	mov	%eax, (%esi, %ecx, 4)
	add	%eax, %edx
	pop	%eax
	jmp	rx
r1:
	call	blk
rx:	add	$0x5A827999, %edx
rall:	ret

/*
 * R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
 * R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
 */

r2:
	cmp	$40, %cl
	jae	mayber3
r2r4:
	xor	%ebx, %edx	/* x^w */
	xor	%edi, %edx	/* ^y */
	call	blk
	add	$0x6ED9EBA1, %edx
	cmp	$60, %cl
	jc	rall
	/* alternatively R4 */
	add	$(0xCA62C1D6-0x6ED9EBA1), %edx
	ret
mayber3:
	cmp	$60, %cl
	jae	r2r4
r3:
/* R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30); */
	push	%edx
	or	%ebx, %edx	/* x|w */
	and	%edi, %edx	/* &y */
	and	%ebx, (%esp)
	or	(%esp), %edx
	add	$4, %esp
	call	blk
	add	$0x8F1BBCDC, %edx
	ret

/*
 * this performs block expand function
 * blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
 *         ^block->l[(i+2)&15]^block->l[i&15],1))
 * i => ecx
 * result will be added to X (%edx), block itself is in esi
 */
blk:
	pusha
	lea	13(%ecx), %eax
	and	$15, %al	/* block->l[(i+13)&15] = ebx */
	lea	8(%ecx), %ebx
	and	$15, %bl	/* block->l[(i+8)&15] = ebx */
	lea	2(%ecx), %edx
	and	$15, %dl	/* block->l[(i+2)&15] = edx */
	and	$15, %cl	/* block->l[i&15] = ecx */

	mov	(%esi, %eax, 4), %edi /* block->l[i&15] */
	xor	(%esi, %ebx, 4), %edi /* ^block->l[(i+8)&15] */
	xor	(%esi, %edx, 4), %edi /* ^block->l[(i+2)&15] */
	xor	(%esi, %ecx, 4), %edi /* ^block->l[i&15] */
	rol	$1, %edi	/* rol 1 */
	mov	%edi, (%esi, %ecx, 4) /* result to block->l[i&15] */
	add	%edi, 20(%esp)	/* add to pushed %edx */
	popa
ret
sha1_end:
elf_lock_end:

/* just a C interfaces */

/* sha1_asm(char *digest, char *input, int len) */
sha1_asm:
	pushal
	mov	32+4(%esp), %edi
	mov	32+8(%esp), %esi
	mov	32+12(%esp), %ecx
	call	sha1
	popal
ret

/* rc4_asm(char *key, char *input, int len) */
rc4_asm:
	pushal
	mov	32+4(%esp), %edi
	mov	32+8(%esp), %esi
	mov	32+12(%esp), %ecx
	call	rc4
	popal
ret

```

`src/nrv2e.c`:

```c
/* nrv2e -- implementation of the NRV2E-99 compression algorithm

   This file was part of the UCL data compression library.

   Copyright (C) 1996-2002 Markus Franz Xaver Johannes Oberhumer
   All Rights Reserved.

   The UCL library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The UCL library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the UCL library; see the file COPYING.
   If not, write to the Free Software Foundation, Inc.,
   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Markus F.X.J. Oberhumer
   <markus@oberhumer.com>
   http://www.oberhumer.com/opensource/ucl/
 */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <linux/elf.h>
#include <string.h>
#include <sys/mman.h>

#include <limits.h>

//#include <assert.h>
#define assert(x)


#define ucl_memcpy memcpy
#define ucl_malloc malloc
#define ucl_alloc(x,y) malloc(x*y)
#define ucl_free free
#define ucl_memcmp memcmp
#define ucl_memset memset
#define ucl_sizeof(x) (sizeof(x))
#define UCL_PUBLIC(x) x

#define NRV2E
//#define __UCL_CHECKER

#define UCL_BYTE(x)       ((unsigned char) (x))
#define UCL_USHORT(x)     ((unsigned short) ((x) & 0xffff))
#define UCL_MAX(a,b)        ((a) >= (b) ? (a) : (b))
#define UCL_MIN(a,b)        ((a) <= (b) ? (a) : (b))
#define UCL_MAX3(a,b,c)     ((a) >= (b) ? UCL_MAX(a,c) : UCL_MAX(b,c))
#define UCL_MIN3(a,b,c)     ((a) <= (b) ? UCL_MIN(a,c) : UCL_MIN(b,c))


#define UCL_E_OK                    0
#define UCL_E_ERROR                 (-1)
#define UCL_E_INVALID_ARGUMENT      (-2)
#define UCL_E_OUT_OF_MEMORY         (-3)
/* compression errors */
#define UCL_E_NOT_COMPRESSIBLE      (-101)
/* decompression errors */
#define UCL_E_INPUT_OVERRUN         (-201)
#define UCL_E_OUTPUT_OVERRUN        (-202)
#define UCL_E_LOOKBEHIND_OVERRUN    (-203)
#define UCL_E_EOF_NOT_FOUND         (-204)
#define UCL_E_INPUT_NOT_CONSUMED    (-205)
#define UCL_E_OVERLAP_OVERRUN       (-206)

typedef unsigned int ucl_uint32;
typedef int ucl_int32;
#define UCL_UINT32_MAX      0xffffffffUL
#define UCL_INT32_MAX       INT_MAX
#define UCL_INT32_MIN       INT_MIN
typedef unsigned int ucl_uint;
typedef int ucl_int;
#define UCL_UINT_MAX        UINT_MAX
#define UCL_INT_MAX         INT_MAX
#define UCL_INT_MIN         INT_MIN
#define UCL_UINT32_C(c)     c ## UL
#define UCL_UNUSED(x)	    x = x


struct ucl_compress_config_t {
	int     bb_endian;
	int     bb_size;
	ucl_uint max_offset;
	ucl_uint max_match;
	int     s_level;
	int     h_level;
	int     p_level;
	int     c_flags;
	ucl_uint m_size;
};
#define ucl_compress_config_p   ucl_compress_config_t *

#define ucl_byte                unsigned char
#define ucl_bytep               unsigned char *
#define ucl_charp               char *
#define ucl_voidp               void *
#define ucl_shortp              short *
#define ucl_ushortp             unsigned short *
#define ucl_uint32p             ucl_uint32 *
#define ucl_int32p              ucl_int32 *
#define ucl_uintp               ucl_uint *
#define ucl_intp                ucl_int *
#define ucl_voidpp              ucl_voidp *
#define ucl_bytepp              ucl_bytep *
#define ucl_bool		int

/* a progress indicator callback function */
typedef struct {
	void    (*callback) (ucl_uint, ucl_uint, int, ucl_voidp user);
	ucl_voidp user;
} ucl_progress_callback_t;
#define ucl_progress_callback_p ucl_progress_callback_t *


#define N       (1024*1024ul)	/* size of ring buffer */
//#define SWD_USE_MALLOC
#define SWD_HSIZE   65536ul

#if 1
#define THRESHOLD       1	/* lower limit for match length */
#define F            16384	/* upper limit for match length */
#else
#define THRESHOLD       1	/* lower limit for match length */
#define F            2048	/* upper limit for match length */
#endif

#define UCL_COMPRESS_T          ucl_nrv2e_t
#define ucl_swd_t               ucl_nrv2e_swd_t
#define ucl_nrv_99_compress     ucl_nrv2e_99_compress
#define M2_MAX_OFFSET           0x500
#define ucl_swd_p		ucl_swd_t *

typedef struct {
	int     init;

	ucl_uint look;		/* bytes in lookahead buffer */

	ucl_uint m_len;
	ucl_uint m_off;

	ucl_uint last_m_len;
	ucl_uint last_m_off;

	const ucl_byte *bp;
	const ucl_byte *ip;
	const ucl_byte *in;
	const ucl_byte *in_end;
	ucl_byte *out;

	ucl_uint32 bb_b;
	unsigned bb_k;
	unsigned bb_c_endian;
	unsigned bb_c_s;
	unsigned bb_c_s8;
	ucl_byte *bb_p;
	ucl_byte *bb_op;

	struct ucl_compress_config_t conf;
	ucl_uintp result;

	ucl_progress_callback_p cb;

	ucl_uint textsize;	/* text size counter */
	ucl_uint codesize;	/* code size counter */
	ucl_uint printcount;	/* counter for reporting progress every 1K bytes */

	/* some stats */
	unsigned long lit_bytes;
	unsigned long match_bytes;
	unsigned long rep_bytes;
	unsigned long lazy;
} UCL_COMPRESS_T;

#define getbyte(c)  ((c).ip < (c).in_end ? *((c).ip)++ : (-1))

#ifndef SWD_N
#  define SWD_N             N
#endif
#ifndef SWD_F
#  define SWD_F             F
#endif
#ifndef SWD_THRESHOLD
#  define SWD_THRESHOLD     THRESHOLD
#endif

/* unsigned type for dictionary access - don't waste memory here */
#if (SWD_N + SWD_F + SWD_F < USHRT_MAX)
typedef unsigned short swd_uint;
#  define SWD_UINT_MAX      USHRT_MAX
#else
typedef ucl_uint swd_uint;
#  define SWD_UINT_MAX      UCL_UINT_MAX
#endif
#define SWD_UINT(x)         ((swd_uint)(x))


#ifndef SWD_HSIZE
#  define SWD_HSIZE         16384
#endif
#ifndef SWD_MAX_CHAIN
#  define SWD_MAX_CHAIN     2048
#endif

#if !defined(HEAD3)
#if 1
#  define HEAD3(b,p) \
    (((0x9f5f*(((((ucl_uint32)b[p]<<5)^b[p+1])<<5)^b[p+2]))>>5) & (SWD_HSIZE-1))
#else
#  define HEAD3(b,p) \
    (((0x9f5f*(((((ucl_uint32)b[p+2]<<5)^b[p+1])<<5)^b[p]))>>5) & (SWD_HSIZE-1))
#endif
#endif

#if (SWD_THRESHOLD == 1) && !defined(HEAD2)
#  if 1 && defined(UCL_UNALIGNED_OK_2)
#    define HEAD2(b,p)      (* (const ucl_ushortp) &(b[p]))
#  else
#    define HEAD2(b,p)      (b[p] ^ ((unsigned)b[p+1]<<8))
#  endif
#  define NIL2              SWD_UINT_MAX
#endif


#if defined(__UCL_CHECKER)
   /* malloc arrays of the exact size to detect any overrun */
#  ifndef SWD_USE_MALLOC
#    define SWD_USE_MALLOC
#  endif
#endif


typedef struct {
/* public - "built-in" */
	ucl_uint n;
	ucl_uint f;
	ucl_uint threshold;

/* public - configuration */
	ucl_uint max_chain;
	ucl_uint nice_length;
	ucl_bool use_best_off;
	ucl_uint lazy_insert;

/* public - output */
	ucl_uint m_len;
	ucl_uint m_off;
	ucl_uint look;
	int     b_char;
#if defined(SWD_BEST_OFF)
	ucl_uint best_off[SWD_BEST_OFF];
#endif

/* semi public */
	UCL_COMPRESS_T *c;
	ucl_uint m_pos;
#if defined(SWD_BEST_OFF)
	ucl_uint best_pos[SWD_BEST_OFF];
#endif

/* private */
	const ucl_byte *dict;
	const ucl_byte *dict_end;
	ucl_uint dict_len;

/* private */
	ucl_uint ip;		/* input pointer (lookahead) */
	ucl_uint bp;		/* buffer pointer */
	ucl_uint rp;		/* remove pointer */
	ucl_uint b_size;

	unsigned char *b_wrap;

	ucl_uint node_count;
	ucl_uint first_rp;

#if defined(SWD_USE_MALLOC)
	unsigned char *b;
	swd_uint *head3;
	swd_uint *succ3;
	swd_uint *best3;
	swd_uint *llen3;
#ifdef HEAD2
	swd_uint *head2;
#endif
#else
	unsigned char b[SWD_N + SWD_F + SWD_F];
	swd_uint head3[SWD_HSIZE];
	swd_uint succ3[SWD_N + SWD_F];
	swd_uint best3[SWD_N + SWD_F];
	swd_uint llen3[SWD_HSIZE];
#ifdef HEAD2
	swd_uint head2[UCL_UINT32_C(65536)];
#endif
#endif
} ucl_swd_t;


/* Access macro for head3.
 * head3[key] may be uninitialized if the list is emtpy,
 * but then its value will never be used.
 */
#if defined(__UCL_CHECKER)
#  define s_head3(s,key) \
        ((s->llen3[key] == 0) ? SWD_UINT_MAX : s->head3[key])
#else
#  define s_head3(s,key)        s->head3[key]
#endif


/***********************************************************************
//
************************************************************************/

static
void    swd_initdict(ucl_swd_t * s, const ucl_byte * dict,
		     ucl_uint dict_len)
{
	s->dict = s->dict_end = NULL;
	s->dict_len = 0;

	if (!dict || dict_len <= 0)
		return;
	if (dict_len > s->n) {
		dict += dict_len - s->n;
		dict_len = s->n;
	}

	s->dict = dict;
	s->dict_len = dict_len;
	s->dict_end = dict + dict_len;
	ucl_memcpy(s->b, dict, dict_len);
	s->ip = dict_len;
}


static
void    swd_insertdict(ucl_swd_t * s, ucl_uint node, ucl_uint len)
{
	ucl_uint key;

	s->node_count = s->n - len;
	s->first_rp = node;

	while (len-- > 0) {
		key = HEAD3(s->b, node);
		s->succ3[node] = s_head3(s, key);
		s->head3[key] = SWD_UINT(node);
		s->best3[node] = SWD_UINT(s->f + 1);
		s->llen3[key]++;
		assert(s->llen3[key] <= s->n);

#ifdef HEAD2
		key = HEAD2(s->b, node);
		s->head2[key] = SWD_UINT(node);
#endif

		node++;
	}
}


/***********************************************************************
//
************************************************************************/

static
int     swd_init(ucl_swd_t * s, const ucl_byte * dict, ucl_uint dict_len)
{
	ucl_uint i = 0;
	int     c = 0;

	if (s->n == 0)
		s->n = SWD_N;
	if (s->f == 0)
		s->f = SWD_F;
	s->threshold = SWD_THRESHOLD;
	if (s->n > SWD_N || s->f > SWD_F)
		return UCL_E_INVALID_ARGUMENT;

#if defined(SWD_USE_MALLOC)
	s->b = (unsigned char *) ucl_alloc(s->n + s->f + s->f, 1);
	s->head3 = (swd_uint *) ucl_alloc(SWD_HSIZE, sizeof(*s->head3));
	s->succ3 = (swd_uint *) ucl_alloc(s->n + s->f, sizeof(*s->succ3));
	s->best3 = (swd_uint *) ucl_alloc(s->n + s->f, sizeof(*s->best3));
	s->llen3 = (swd_uint *) ucl_alloc(SWD_HSIZE, sizeof(*s->llen3));
	if (!s->b || !s->head3 || !s->succ3 || !s->best3 || !s->llen3)
		return UCL_E_OUT_OF_MEMORY;
#ifdef HEAD2
	s->head2 =
	    (swd_uint *) ucl_alloc(UCL_UINT32_C(65536), sizeof(*s->head2));
	if (!s->head2)
		return UCL_E_OUT_OF_MEMORY;
#endif
#endif

	/* defaults */
	s->max_chain = SWD_MAX_CHAIN;
	s->nice_length = s->f;
	s->use_best_off = 0;
	s->lazy_insert = 0;

	s->b_size = s->n + s->f;
	if (s->b_size + s->f >= SWD_UINT_MAX)
		return UCL_E_ERROR;
	s->b_wrap = s->b + s->b_size;
	s->node_count = s->n;

	ucl_memset(s->llen3, 0, sizeof(s->llen3[0]) * SWD_HSIZE);
#ifdef HEAD2
#if 1
	ucl_memset(s->head2, 0xff,
		   sizeof(s->head2[0]) * UCL_UINT32_C(65536));
	assert(s->head2[0] == NIL2);
#else
	for (i = 0; i < UCL_UINT32_C(65536); i++)
		s->head2[i] = NIL2;
#endif
#endif

	s->ip = 0;
	swd_initdict(s, dict, dict_len);
	s->bp = s->ip;
	s->first_rp = s->ip;

	assert(s->ip + s->f <= s->b_size);
#if 1
	s->look = (ucl_uint) (s->c->in_end - s->c->ip);
	if (s->look > 0) {
		if (s->look > s->f)
			s->look = s->f;
		ucl_memcpy(&s->b[s->ip], s->c->ip, s->look);
		s->c->ip += s->look;
		s->ip += s->look;
	}
#else
	s->look = 0;
	while (s->look < s->f) {
		if ((c = getbyte(*(s->c))) < 0)
			break;
		s->b[s->ip] = UCL_BYTE(c);
		s->ip++;
		s->look++;
	}
#endif
	if (s->ip == s->b_size)
		s->ip = 0;

	if (s->look >= 2 && s->dict_len > 0)
		swd_insertdict(s, 0, s->dict_len);

	s->rp = s->first_rp;
	if (s->rp >= s->node_count)
		s->rp -= s->node_count;
	else
		s->rp += s->b_size - s->node_count;

#if defined(__UCL_CHECKER)
	/* initialize memory for the first few HEAD3 (if s->ip is not far
	 * enough ahead to do this job for us). The value doesn't matter. */
	if (s->look < 3)
		ucl_memset(&s->b[s->bp + s->look], 0, 3);
#endif

	UCL_UNUSED(i);
	UCL_UNUSED(c);
	return UCL_E_OK;
}


static
void    swd_exit(ucl_swd_t * s)
{
#if defined(SWD_USE_MALLOC)
	/* free in reverse order of allocations */
#ifdef HEAD2
	ucl_free(s->head2);
	s->head2 = NULL;
#endif
	ucl_free(s->llen3);
	s->llen3 = NULL;
	ucl_free(s->best3);
	s->best3 = NULL;
	ucl_free(s->succ3);
	s->succ3 = NULL;
	ucl_free(s->head3);
	s->head3 = NULL;
	ucl_free(s->b);
	s->b = NULL;
#else
	UCL_UNUSED(s);
#endif
}


#define swd_pos2off(s,pos) \
    (s->bp > (pos) ? s->bp - (pos) : s->b_size - ((pos) - s->bp))


/***********************************************************************
//
************************************************************************/

static __inline__ void swd_getbyte(ucl_swd_t * s)
{
	int     c;

	if ((c = getbyte(*(s->c))) < 0) {
		if (s->look > 0)
			--s->look;
#if defined(__UCL_CHECKER)
		/* initialize memory - value doesn't matter */
		s->b[s->ip] = 0;
		if (s->ip < s->f)
			s->b_wrap[s->ip] = 0;
#endif
	} else {
		s->b[s->ip] = UCL_BYTE(c);
		if (s->ip < s->f)
			s->b_wrap[s->ip] = UCL_BYTE(c);
	}
	if (++s->ip == s->b_size)
		s->ip = 0;
	if (++s->bp == s->b_size)
		s->bp = 0;
	if (++s->rp == s->b_size)
		s->rp = 0;
}


/***********************************************************************
// remove node from lists
************************************************************************/

static __inline__ void swd_remove_node(ucl_swd_t * s, ucl_uint node)
{
	if (s->node_count == 0) {
		ucl_uint key;

#ifdef UCL_DEBUG
		if (s->first_rp != UCL_UINT_MAX) {
			if (node != s->first_rp)
				printf
				    ("Remove %5d: %5d %5d %5d %5d  %6d %6d\n",
				     node, s->rp, s->ip, s->bp,
				     s->first_rp, s->ip - node,
				     s->ip - s->bp);
			assert(node == s->first_rp);
			s->first_rp = UCL_UINT_MAX;
		}
#endif

		key = HEAD3(s->b, node);
		assert(s->llen3[key] > 0);
		--s->llen3[key];

#ifdef HEAD2
		key = HEAD2(s->b, node);
		assert(s->head2[key] != NIL2);
		if ((ucl_uint) s->head2[key] == node)
			s->head2[key] = NIL2;
#endif
	} else
		--s->node_count;
}


/***********************************************************************
//
************************************************************************/

static
void    swd_accept(ucl_swd_t * s, ucl_uint n)
{
	assert(n <= s->look);

	if (n > 0)
		do {
			ucl_uint key;

			swd_remove_node(s, s->rp);

			/* add bp into HEAD3 */
			key = HEAD3(s->b, s->bp);
			s->succ3[s->bp] = s_head3(s, key);
			s->head3[key] = SWD_UINT(s->bp);
			s->best3[s->bp] = SWD_UINT(s->f + 1);
			s->llen3[key]++;
			assert(s->llen3[key] <= s->n);

#ifdef HEAD2
			/* add bp into HEAD2 */
			key = HEAD2(s->b, s->bp);
			s->head2[key] = SWD_UINT(s->bp);
#endif

			swd_getbyte(s);
		} while (--n > 0);
}


/***********************************************************************
//
************************************************************************/

static
void    swd_search(ucl_swd_t * s, ucl_uint node, ucl_uint cnt)
{
#if 0 && defined(__GNUC__) && defined(__i386__)
	register const unsigned char *p1 __asm__("%edi");
	register const unsigned char *p2 __asm__("%esi");
	register const unsigned char *px __asm__("%edx");
#else
	const unsigned char *p1;
	const unsigned char *p2;
	const unsigned char *px;
#endif
	ucl_uint m_len = s->m_len;
	const unsigned char *b = s->b;
	const unsigned char *bp = s->b + s->bp;
	const unsigned char *bx = s->b + s->bp + s->look;
	unsigned char scan_end1;

	assert(s->m_len > 0);

	scan_end1 = bp[m_len - 1];
	for (; cnt-- > 0; node = s->succ3[node]) {
		p1 = bp;
		p2 = b + node;
		px = bx;

		assert(m_len < s->look);

		if (
#if 1
			   p2[m_len - 1] == scan_end1 &&
			   p2[m_len] == p1[m_len] &&
#endif
			   p2[0] == p1[0] && p2[1] == p1[1]) {
			ucl_uint i;
			assert(ucl_memcmp(bp, &b[node], 3) == 0);

#if 0 && defined(UCL_UNALIGNED_OK_4)
			p1 += 3;
			p2 += 3;
			while (p1 < px
			       && *(const ucl_uint32p) p1 ==
			       *(const ucl_uint32p) p2)
				p1 += 4, p2 += 4;
			while (p1 < px && *p1 == *p2)
				p1 += 1, p2 += 1;
#else
			p1 += 2;
			p2 += 2;
			do {
			} while (++p1 < px && *p1 == *++p2);
#endif
			i = p1 - bp;

#ifdef UCL_DEBUG
			if (ucl_memcmp(bp, &b[node], i) != 0)
				printf("%5ld %5ld %02x%02x %02x%02x\n",
				       (long) s->bp, (long) node,
				       bp[0], bp[1], b[node], b[node + 1]);
#endif
			assert(ucl_memcmp(bp, &b[node], i) == 0);

#if defined(SWD_BEST_OFF)
			if (i < SWD_BEST_OFF) {
				if (s->best_pos[i] == 0)
					s->best_pos[i] = node + 1;
			}
#endif
			if (i > m_len) {
				s->m_len = m_len = i;
				s->m_pos = node;
				if (m_len == s->look)
					return;
				if (m_len >= s->nice_length)
					return;
				if (m_len > (ucl_uint) s->best3[node])
					return;
				scan_end1 = bp[m_len - 1];
			}
		}
	}
}


/***********************************************************************
//
************************************************************************/

#ifdef HEAD2

static
ucl_bool swd_search2(ucl_swd_t * s)
{
	ucl_uint key;

	assert(s->look >= 2);
	assert(s->m_len > 0);

	key = s->head2[HEAD2(s->b, s->bp)];
	if (key == NIL2)
		return 0;
#ifdef UCL_DEBUG
	if (ucl_memcmp(&s->b[s->bp], &s->b[key], 2) != 0)
		printf("%5ld %5ld %02x%02x %02x%02x\n", (long) s->bp,
		       (long) key, s->b[s->bp], s->b[s->bp + 1], s->b[key],
		       s->b[key + 1]);
#endif
	assert(ucl_memcmp(&s->b[s->bp], &s->b[key], 2) == 0);
#if defined(SWD_BEST_OFF)
	if (s->best_pos[2] == 0)
		s->best_pos[2] = key + 1;
#endif

	if (s->m_len < 2) {
		s->m_len = 2;
		s->m_pos = key;
	}
	return 1;
}

#endif


/***********************************************************************
//
************************************************************************/

static
void    swd_findbest(ucl_swd_t * s)
{
	ucl_uint key;
	ucl_uint cnt, node;
	ucl_uint len;

	assert(s->m_len > 0);

	/* get current head, add bp into HEAD3 */
	key = HEAD3(s->b, s->bp);
	node = s->succ3[s->bp] = s_head3(s, key);
	cnt = s->llen3[key]++;
	assert(s->llen3[key] <= s->n + s->f);
	if (cnt > s->max_chain && s->max_chain > 0)
		cnt = s->max_chain;
	s->head3[key] = SWD_UINT(s->bp);

	s->b_char = s->b[s->bp];
	len = s->m_len;
	if (s->m_len >= s->look) {
		if (s->look == 0)
			s->b_char = -1;
		s->m_off = 0;
		s->best3[s->bp] = SWD_UINT(s->f + 1);
	} else {
#ifdef HEAD2
		if (swd_search2(s))
#endif
			if (s->look >= 3)
				swd_search(s, node, cnt);
		if (s->m_len > len)
			s->m_off = swd_pos2off(s, s->m_pos);
		s->best3[s->bp] = SWD_UINT(s->m_len);

#if defined(SWD_BEST_OFF)
		if (s->use_best_off) {
			int     i;
			for (i = 2; i < SWD_BEST_OFF; i++)
				if (s->best_pos[i] > 0)
					s->best_off[i] =
					    swd_pos2off(s,
							s->best_pos[i] -
							1);
				else
					s->best_off[i] = 0;
		}
#endif
	}

	swd_remove_node(s, s->rp);

#ifdef HEAD2
	/* add bp into HEAD2 */
	key = HEAD2(s->b, s->bp);
	s->head2[key] = SWD_UINT(s->bp);
#endif
}


#undef HEAD3
#undef HEAD2
#undef s_head3


/***********************************************************************
//
************************************************************************/

static int
init_match(UCL_COMPRESS_T * c, ucl_swd_t * s,
	   const ucl_byte * dict, ucl_uint dict_len, ucl_uint32 flags)
{
	int     r;

	assert(!c->init);
	c->init = 1;

	s->c = c;

	c->last_m_len = c->last_m_off = 0;

	c->textsize = c->codesize = c->printcount = 0;
	c->lit_bytes = c->match_bytes = c->rep_bytes = 0;
	c->lazy = 0;

	r = swd_init(s, dict, dict_len);
	if (r != UCL_E_OK) {
		swd_exit(s);
		return r;
	}

	s->use_best_off = (flags & 1) ? 1 : 0;
	return UCL_E_OK;
}


/***********************************************************************
//
************************************************************************/

static int
find_match(UCL_COMPRESS_T * c, ucl_swd_t * s,
	   ucl_uint this_len, ucl_uint skip)
{
	assert(c->init);

	if (skip > 0) {
		assert(this_len >= skip);
		swd_accept(s, this_len - skip);
		c->textsize += this_len - skip + 1;
	} else {
		assert(this_len <= 1);
		c->textsize += this_len - skip;
	}

	s->m_len = THRESHOLD;
#ifdef SWD_BEST_OFF
	if (s->use_best_off)
		memset(s->best_pos, 0, sizeof(s->best_pos));
#endif
	swd_findbest(s);
	c->m_len = s->m_len;
#if defined(__UCL_CHECKER)
	/* s->m_off may be uninitialized if we didn't find a match,
	 * but then its value will never be used.
	 */
	c->m_off = (s->m_len == THRESHOLD) ? 0 : s->m_off;
#else
	c->m_off = s->m_off;
#endif

	swd_getbyte(s);

	if (s->b_char < 0) {
		c->look = 0;
		c->m_len = 0;
		swd_exit(s);
	} else {
		c->look = s->look + 1;
	}
	c->bp = c->ip - c->look;

#if 0
	/* brute force match search */
	if (c->m_len > THRESHOLD && c->m_len + 1 <= c->look) {
		const ucl_byte *ip = c->bp;
		const ucl_byte *m = c->bp - c->m_off;
		const ucl_byte *in = c->in;

		if (ip - in > N)
			in = ip - N;
		for (;;) {
			while (*in != *ip)
				in++;
			if (in == ip)
				break;
			if (in != m)
				if (memcmp(in, ip, c->m_len + 1) == 0)
					printf("%p %p %p %5d\n", in, ip, m,
					       c->m_len);
			in++;
		}
	}
#endif

	if (c->cb && c->textsize > c->printcount) {
		(*c->cb->callback) (c->textsize, c->codesize, 3, c->cb->user);
		c->printcount += 1024;
	}

	return UCL_E_OK;
}


/***********************************************************************
// bit buffer
************************************************************************/

static int bbConfig(UCL_COMPRESS_T * c, int endian, int bitsize)
{
	if (endian != -1) {
		if (endian != 0)
			return UCL_E_ERROR;
		c->bb_c_endian = endian;
	}
	if (bitsize != -1) {
		if (bitsize != 8 && bitsize != 16 && bitsize != 32)
			return UCL_E_ERROR;
		c->bb_c_s = bitsize;
		c->bb_c_s8 = bitsize / 8;
	}
	c->bb_b = 0;
	c->bb_k = 0;
	c->bb_p = NULL;
	c->bb_op = NULL;
	return UCL_E_OK;
}


static void bbWriteBits(UCL_COMPRESS_T * c)
{
	ucl_byte *p = c->bb_p;
	ucl_uint32 b = c->bb_b;

	p[0] = UCL_BYTE(b >> 0);
	if (c->bb_c_s >= 16) {
		p[1] = UCL_BYTE(b >> 8);
		if (c->bb_c_s == 32) {
			p[2] = UCL_BYTE(b >> 16);
			p[3] = UCL_BYTE(b >> 24);
		}
	}
}


static void bbPutBit(UCL_COMPRESS_T * c, unsigned bit)
{
	assert(bit == 0 || bit == 1);
	assert(c->bb_k <= c->bb_c_s);

	if (c->bb_k < c->bb_c_s) {
		if (c->bb_k == 0) {
			assert(c->bb_p == NULL);
			c->bb_p = c->bb_op;
			c->bb_op += c->bb_c_s8;
		}
		assert(c->bb_p != NULL);
		assert(c->bb_p + c->bb_c_s8 <= c->bb_op);

		c->bb_b = (c->bb_b << 1) + bit;
		c->bb_k++;
	} else {
		assert(c->bb_p != NULL);
		assert(c->bb_p + c->bb_c_s8 <= c->bb_op);

		bbWriteBits(c);
		c->bb_p = c->bb_op;
		c->bb_op += c->bb_c_s8;
		c->bb_b = bit;
		c->bb_k = 1;
	}
}


static void bbPutByte(UCL_COMPRESS_T * c, unsigned b)
{
    /**printf("putbyte %p %p %x  (%d)\n", op, bb_p, x, bb_k);*/
	assert(c->bb_p == NULL || c->bb_p + c->bb_c_s8 <= c->bb_op);
	*c->bb_op++ = UCL_BYTE(b);
}


static void bbFlushBits(UCL_COMPRESS_T * c, unsigned filler_bit)
{
	if (c->bb_k > 0) {
		assert(c->bb_k <= c->bb_c_s);
		while (c->bb_k != c->bb_c_s)
			bbPutBit(c, filler_bit);
		bbWriteBits(c);
		c->bb_k = 0;
	}
	c->bb_p = NULL;
}



/***********************************************************************
//
************************************************************************/

static void code_prefix_ss11(UCL_COMPRESS_T * c, ucl_uint32 i)
{
	if (i >= 2) {
		ucl_uint32 t = 4;
		i += 2;
		do {
			t <<= 1;
		} while (i >= t);
		t >>= 1;
		do {
			t >>= 1;
			bbPutBit(c, (i & t) ? 1 : 0);
			bbPutBit(c, 0);
		} while (t > 2);
	}
	bbPutBit(c, (unsigned) i & 1);
	bbPutBit(c, 1);
}


#if defined(NRV2D) || defined(NRV2E)
static void code_prefix_ss12(UCL_COMPRESS_T * c, ucl_uint32 i)
{
	if (i >= 2) {
		ucl_uint32 t = 2;
		do {
			i -= t;
			t <<= 2;
		} while (i >= t);
		do {
			t >>= 1;
			bbPutBit(c, (i & t) ? 1 : 0);
			bbPutBit(c, 0);
			t >>= 1;
			bbPutBit(c, (i & t) ? 1 : 0);
		} while (t > 2);
	}
	bbPutBit(c, (unsigned) i & 1);
	bbPutBit(c, 1);
}
#endif


static void
code_match(UCL_COMPRESS_T * c, ucl_uint m_len, const ucl_uint m_off)
{
	unsigned m_low = 0;

	while (m_len > c->conf.max_match) {
		code_match(c, c->conf.max_match - 3, m_off);
		m_len -= c->conf.max_match - 3;
	}

	c->match_bytes += m_len;
	if (m_len > c->result[3])
		c->result[3] = m_len;
	if (m_off > c->result[1])
		c->result[1] = m_off;

	bbPutBit(c, 0);

#if defined(NRV2B)
	if (m_off == c->last_m_off) {
		bbPutBit(c, 0);
		bbPutBit(c, 1);
	} else {
		code_prefix_ss11(c, 1 + ((m_off - 1) >> 8));
		bbPutByte(c, (unsigned) m_off - 1);
	}
	m_len = m_len - 1 - (m_off > M2_MAX_OFFSET);
	if (m_len >= 4) {
		bbPutBit(c, 0);
		bbPutBit(c, 0);
		code_prefix_ss11(c, m_len - 4);
	} else {
		bbPutBit(c, m_len > 1);
		bbPutBit(c, (unsigned) m_len & 1);
	}
#elif defined(NRV2D)
	m_len = m_len - 1 - (m_off > M2_MAX_OFFSET);
	assert(m_len > 0);
	m_low = (m_len >= 4) ? 0u : (unsigned) m_len;
	if (m_off == c->last_m_off) {
		bbPutBit(c, 0);
		bbPutBit(c, 1);
		bbPutBit(c, m_low > 1);
		bbPutBit(c, m_low & 1);
	} else {
		code_prefix_ss12(c, 1 + ((m_off - 1) >> 7));
		bbPutByte(c,
			  ((((unsigned) m_off - 1) & 0x7f) << 1) |
			  ((m_low > 1) ? 0 : 1));
		bbPutBit(c, m_low & 1);
	}
	if (m_len >= 4)
		code_prefix_ss11(c, m_len - 4);
#elif defined(NRV2E)
	m_len = m_len - 1 - (m_off > M2_MAX_OFFSET);
	assert(m_len > 0);
	m_low = (m_len <= 2);
	if (m_off == c->last_m_off) {
		bbPutBit(c, 0);
		bbPutBit(c, 1);
		bbPutBit(c, m_low);
	} else {
		code_prefix_ss12(c, 1 + ((m_off - 1) >> 7));
		bbPutByte(c,
			  ((((unsigned) m_off - 1) & 0x7f) << 1) | (m_low ^
								    1));
	}
	if (m_low)
		bbPutBit(c, (unsigned) m_len - 1);
	else if (m_len <= 4) {
		bbPutBit(c, 1);
		bbPutBit(c, (unsigned) m_len - 3);
	} else {
		bbPutBit(c, 0);
		code_prefix_ss11(c, m_len - 5);
	}
#else
#  error
#endif

	c->last_m_off = m_off;
	UCL_UNUSED(m_low);
}


static void code_run(UCL_COMPRESS_T * c, const ucl_byte * ii, ucl_uint lit)
{
	if (lit == 0)
		return;
	c->lit_bytes += lit;
	if (lit > c->result[5])
		c->result[5] = lit;
	do {
		bbPutBit(c, 1);
		bbPutByte(c, *ii++);
	} while (--lit > 0);
}


/***********************************************************************
//
************************************************************************/

static int
len_of_coded_match(UCL_COMPRESS_T * c, ucl_uint m_len, ucl_uint m_off)
{
	int     b;
	if (m_len < 2 || (m_len == 2 && (m_off > M2_MAX_OFFSET))
	    || m_off > c->conf.max_offset)
		return -1;
	assert(m_off > 0);

	m_len = m_len - 2 - (m_off > M2_MAX_OFFSET);

	if (m_off == c->last_m_off)
		b = 1 + 2;
	else {
#if defined(NRV2B)
		b = 1 + 10;
		m_off = (m_off - 1) >> 8;
		while (m_off > 0) {
			b += 2;
			m_off >>= 1;
		}
#elif defined(NRV2D) || defined(NRV2E)
		b = 1 + 9;
		m_off = (m_off - 1) >> 7;
		while (m_off > 0) {
			b += 3;
			m_off >>= 2;
		}
#else
#  error
#endif
	}

#if defined(NRV2B) || defined(NRV2D)
	b += 2;
	if (m_len < 3)
		return b;
	m_len -= 3;
#elif defined(NRV2E)
	b += 2;
	if (m_len < 2)
		return b;
	if (m_len < 4)
		return b + 1;
	m_len -= 4;
#else
#  error
#endif
	do {
		b += 2;
		m_len >>= 1;
	} while (m_len > 0);

	return b;
}


/***********************************************************************
//
************************************************************************/

#if !defined(NDEBUG)
static
void    assert_match(const ucl_swd_p swd, ucl_uint m_len, ucl_uint m_off)
{
	const UCL_COMPRESS_T *c = swd->c;
	ucl_uint d_off;

	assert(m_len >= 2);
	if (m_off <= (ucl_uint) (c->bp - c->in)) {
		assert(c->bp - m_off + m_len < c->ip);
		assert(ucl_memcmp(c->bp, c->bp - m_off, m_len) == 0);
	} else {
		assert(swd->dict != NULL);
		d_off = m_off - (ucl_uint) (c->bp - c->in);
		assert(d_off <= swd->dict_len);
		if (m_len > d_off) {
			assert(ucl_memcmp
			       (c->bp, swd->dict_end - d_off, d_off) == 0);
			assert(c->in + m_len - d_off < c->ip);
			assert(ucl_memcmp
			       (c->bp + d_off, c->in, m_len - d_off) == 0);
		} else {
			assert(ucl_memcmp
			       (c->bp, swd->dict_end - d_off, m_len) == 0);
		}
	}
}
#else
#  define assert_match(a,b,c)   ((void)0)
#endif


#if defined(SWD_BEST_OFF)

static void
better_match(const ucl_swd_p swd, ucl_uint * m_len, ucl_uint * m_off)
{
}

#endif


/***********************************************************************
//
************************************************************************/

UCL_PUBLIC(int)
ucl_nrv_99_compress(const ucl_bytep in, ucl_uint in_len,
		    ucl_bytep out, ucl_uintp out_len,
		    ucl_progress_callback_p cb,
		    int level,
		    const struct ucl_compress_config_p conf,
		    ucl_uintp result)
{
	const ucl_byte *ii;
	ucl_uint lit;
	ucl_uint m_len, m_off;
	UCL_COMPRESS_T c_buffer;
	UCL_COMPRESS_T *const c = &c_buffer;
#undef swd
#if 1 && defined(SWD_USE_MALLOC)
	ucl_swd_t the_swd;
#   define swd (&the_swd)
#else
	ucl_swd_p swd;
#endif
	ucl_uint result_buffer[16];
	int     r;

	struct swd_config_t {
		unsigned try_lazy;
		ucl_uint good_length;
		ucl_uint max_lazy;
		ucl_uint nice_length;
		ucl_uint max_chain;
		ucl_uint32 flags;
		ucl_uint32 max_offset;
	};
	const struct swd_config_t *sc;
	static const struct swd_config_t swd_config[10] = {
		/* faster compression */
		{0, 0, 0, 8, 4, 0, 48 * 1024L},
		{0, 0, 0, 16, 8, 0, 48 * 1024L},
		{0, 0, 0, 32, 16, 0, 48 * 1024L},
		{1, 4, 4, 16, 16, 0, 48 * 1024L},
		{1, 8, 16, 32, 32, 0, 48 * 1024L},
		{1, 8, 16, 128, 128, 0, 48 * 1024L},
		{2, 8, 32, 128, 256, 0, 128 * 1024L},
		{2, 32, 128, F, 2048, 1, 128 * 1024L},
		{2, 32, 128, F, 2048, 1, 256 * 1024L},
		{2, F, F, F, 4096, 1, N}
		/* max. compression */
	};

	if (level < 1 || level > 10)
		return UCL_E_INVALID_ARGUMENT;
	sc = &swd_config[level - 1];

	memset(c, 0, sizeof(*c));
	c->ip = c->in = in;
	c->in_end = in + in_len;
	c->out = out;
	if (cb && cb->callback)
		c->cb = cb;
	cb = NULL;
	c->result = result ? result : (ucl_uintp) result_buffer;
	memset(c->result, 0, 16 * sizeof(*c->result));
	c->result[0] = c->result[2] = c->result[4] = UCL_UINT_MAX;
	result = NULL;
	memset(&c->conf, 0xff, sizeof(c->conf));
	if (conf)
		memcpy(&c->conf, conf, sizeof(c->conf));
	conf = NULL;
	r = bbConfig(c, 0, 8);
	if (r == 0)
		r = bbConfig(c, c->conf.bb_endian, c->conf.bb_size);
	if (r != 0)
		return UCL_E_INVALID_ARGUMENT;
	c->bb_op = out;

	ii = c->ip;	/* point to start of literal run */
	lit = 0;

#if !defined(swd)
	swd = (ucl_swd_p) ucl_alloc(1, ucl_sizeof(*swd));
	if (!swd)
		return UCL_E_OUT_OF_MEMORY;
#endif
	swd->f = UCL_MIN(F, c->conf.max_match);
	swd->n = UCL_MIN(N, sc->max_offset);
	if (c->conf.max_offset != UCL_UINT_MAX)
		swd->n = UCL_MIN(N, c->conf.max_offset);
	if (in_len >= 256 && in_len < swd->n)
		swd->n = in_len;
	if (swd->f < 8 || swd->n < 256)
		return UCL_E_INVALID_ARGUMENT;
	r = init_match(c, swd, NULL, 0, sc->flags);
	if (r != UCL_E_OK) {
#if !defined(swd)
		ucl_free(swd);
#endif
		return r;
	}
	if (sc->max_chain > 0)
		swd->max_chain = sc->max_chain;
	if (sc->nice_length > 0)
		swd->nice_length = sc->nice_length;
	if (c->conf.max_match < swd->nice_length)
		swd->nice_length = c->conf.max_match;

	if (c->cb)
		(*c->cb->callback) (0, 0, -1, c->cb->user);

	c->last_m_off = 1;
	r = find_match(c, swd, 0, 0);
	if (r != UCL_E_OK)
		return r;
	while (c->look > 0) {
		ucl_uint ahead;
		ucl_uint max_ahead;
		int     l1, l2;

		c->codesize = c->bb_op - out;

		m_len = c->m_len;
		m_off = c->m_off;

		assert(c->bp == c->ip - c->look);
		assert(c->bp >= in);
		if (lit == 0)
			ii = c->bp;
		assert(ii + lit == c->bp);
		assert(swd->b_char == *(c->bp));

		if (m_len < 2 || (m_len == 2 && (m_off > M2_MAX_OFFSET))
		    || m_off > c->conf.max_offset) {
			/* a literal */
			lit++;
			swd->max_chain = sc->max_chain;
			r = find_match(c, swd, 1, 0);
			assert(r == 0);
			continue;
		}

		/* a match */
#if defined(SWD_BEST_OFF)
		if (swd->use_best_off)
			better_match(swd, &m_len, &m_off);
#endif
		assert_match(swd, m_len, m_off);

		/* shall we try a lazy match ? */
		ahead = 0;
		if (sc->try_lazy <= 0 || m_len >= sc->max_lazy
		    || m_off == c->last_m_off) {
			/* no */
			l1 = 0;
			max_ahead = 0;
		} else {
			/* yes, try a lazy match */
			l1 = len_of_coded_match(c, m_len, m_off);
			assert(l1 > 0);
			max_ahead = UCL_MIN(sc->try_lazy, m_len - 1);
		}

		while (ahead < max_ahead && c->look > m_len) {
			if (m_len >= sc->good_length)
				swd->max_chain = sc->max_chain >> 2;
			else
				swd->max_chain = sc->max_chain;
			r = find_match(c, swd, 1, 0);
			ahead++;

			assert(r == 0);
			assert(c->look > 0);
			assert(ii + lit + ahead == c->bp);

			if (c->m_len < 2)
				continue;
#if defined(SWD_BEST_OFF)
			if (swd->use_best_off)
				better_match(swd, &c->m_len, &c->m_off);
#endif
			l2 = len_of_coded_match(c, c->m_len, c->m_off);
			if (l2 < 0)
				continue;
#if 1
			if (l1 + (int) (ahead + c->m_len - m_len) * 5 >
			    l2 + (int) (ahead) * 9)
#else
			if (l1 > l2)
#endif
			{
				c->lazy++;
				assert_match(swd, c->m_len, c->m_off);

#if 0
				if (l3 > 0) {
					/* code previous run */
					code_run(c, ii, lit);
					lit = 0;
					/* code shortened match */
					code_match(c, ahead, m_off);
				} else
#endif
				{
					lit += ahead;
					assert(ii + lit == c->bp);
				}
				goto lazy_match_done;
			}
		}

		assert(ii + lit + ahead == c->bp);

		/* 1 - code run */
		code_run(c, ii, lit);
		lit = 0;

		/* 2 - code match */
		code_match(c, m_len, m_off);
		swd->max_chain = sc->max_chain;
		r = find_match(c, swd, m_len, 1 + ahead);
		assert(r == 0);

	      lazy_match_done:;
	}

	/* store final run */
	code_run(c, ii, lit);

	/* EOF */
	bbPutBit(c, 0);
#if defined(NRV2B)
	code_prefix_ss11(c, UCL_UINT32_C(0x1000000));
	bbPutByte(c, 0xff);
#elif defined(NRV2D) || defined(NRV2E)
	code_prefix_ss12(c, UCL_UINT32_C(0x1000000));
	bbPutByte(c, 0xff);
#else
#  error
#endif
	bbFlushBits(c, 0);

	assert(c->textsize == in_len);
	c->codesize = c->bb_op - out;
	*out_len = c->bb_op - out;
	if (c->cb)
		(*c->cb->callback) (c->textsize, c->codesize, 4, c->cb->user);

#if 0
	printf("%7ld %7ld -> %7ld   %7ld %7ld   %ld  (max: %d %d %d)\n",
	       (long) c->textsize, (long) in_len, (long) c->codesize,
	       c->match_bytes, c->lit_bytes, c->lazy,
	       c->result[1], c->result[3], c->result[5]);
#endif
	assert(c->lit_bytes + c->match_bytes == in_len);

	swd_exit(swd);
#if !defined(swd)
	ucl_free(swd);
#endif
	return UCL_E_OK;
#undef swd
}


/*
vi:ts=4:et
*/

```

`src/poly.c`:

```c
/*
 * $Id: poly.c, kinda lame polymorphic engine
 *
 * The decryptor will look like
 *
 * 0: mov $key1, %reg1   \
 * 1: mov $key2, %reg2    \ these may be randomly exchanged
 * 2: mov $length, %reg3  /
 * 3: mov $addr, %reg4   /
 *
 * 4: xor %reg1, (%reg4)
 * 5: sub %reg2, (%reg4) \ exchangable
 * 6: add %reg2, %reg1   /
 * 7: lea x(%reg4), %reg4 / add x, %reg4 \ exchangable
 * 8: lea x(%reg4), %reg4 / add x, %reg4 /
 * 9: dec %reg3
 *    jz loopout
 *
 *
 * each instruction statement has before and after some one-byte junk
 * (cli, nop ..), following a jump to randomly placed next statement,
 * a`la Onehalf.
 *
 * virii folks will know -- kinda lame ;p
 */


#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#include "elfuck.h"
#include "poly.h"

typedef struct {
	int	pos;
	int	len;
} poly_state;

static void	blewgap(unsigned char **p)
{
	int gaplen = (rand() % (MAXGAPLEN-MINGAPLEN)) + MINGAPLEN;
	unsigned char *buf = *p;
	(*p) += gaplen;
	while (gaplen--)
#ifdef NOPGAP
		*buf++ = 0x90;
#else
		*buf++ = rand() & 0xff;
#endif
}

static int freeregs[3];

static void	blewnop(unsigned char **p)
{
	unsigned char *b = *p;
	static char tab[] = "\xf8\xfc\xf5\xf9\xfd\x90";
	(*p)++;
	switch (rand() % 3) {
		case 0: /* dec */
			*b = 0x48 + freeregs[rand() % 3];
			break;
		case 1: /* inc */
			*b = 0x40 + freeregs[rand() % 3];
			break;
		case 2: /* some one-byte */
			*b = tab[rand() % (sizeof(tab)-1)];
			break;
	}
}

static void	blewnops(unsigned char **p) {
	int i = (rand() % MAXJUNK)+1;
	while (i--) {
		blewnop(p);
	}
}

static void	blewadd(unsigned char **p, unsigned num, int reg)
{
	unsigned char *buf = *p;
	switch (rand() % 3) {
		/* classic add */
		case 0:
			buf[0] = 0x81;
			buf[1] = 0xc0 + reg;
			*((unsigned *)(&buf[2])) = num;
			break;
		/* sub -number */
		case 1:
			buf[0] = 0x81;
			buf[1] = 0xe8 + reg;
			*((unsigned *)(&buf[2])) = 0-num;
			break;
		/* lea num(%reg), reg */
		case 2:
			buf[0] = 0x8d;
			buf[1] = 0x80 + reg + reg*8;
			*((unsigned *)(&buf[2])) = num;
			break;
	}
	(*p) += 6;
}

void	mix_jump(int *tab, int count)
{
	int i, j, k, s;
	for (i = 0; i < count*count; i++) {
		j = rand() % count;
		k = (j+1) % count;
		s = tab[j];
		tab[j] = tab[k];
		tab[k] = s;
	}
}

char	*poly_gen(poly_key *key)
{
	poly_state st[10];
	unsigned char *ret, *before, *outjump = NULL;
	unsigned char *p = ret = malloc((MAXGAPLEN+64)*10);
	int	regs[4];
	int	ii, i, j, k;
	unsigned koef1, koef2;
	int	jtab[10];

	memset(st, 0, sizeof(st));
	memset(regs, 0, sizeof(regs));

	/* generate keys */
	srand(time(NULL));
	key->a = rand() ^ (rand() << 16);
	key->b = rand() ^ (rand() << 16);
	koef1 = rand() ^ (rand() << 16);
	koef2 = (0-koef1) + 4;

	/* generate registers */
	for (i = 0; i < 4; i++) {
		int a;
		a = (rand() % 8)-1;
	again:
		a = (a+1) % 8;
		if (a == 4) goto again;
		for (j = 0; j < i; j++) {
			if (regs[j] == a)
				goto again;
		}
		regs[i] = a;
	}

	/* pick the rest */
	for (i = 0, k = 0; i < 8; i++) {
		if (i == 4) continue;
		for (j = 0; j < 4; j++) {
			if (i == regs[j])
				goto next;
		}
		for (j = 0; j < k; j++) {
			if (i == freeregs[j])
				goto next;
		}
		freeregs[k++] = i;
	next:
		;	
	}

	for (ii = 0; ii < 10; ii++) {
		int state;
		
		/* introduce us by real shit ;p */
		blewgap(&p);

		/* find free state */
		for (state = rand() % 10; st[state].len; state = (state+1) % 10);


		/* put few nops */
		before = p;
		blewnops(&p);
		switch (state) {
			case 0:
				*p++ = 0xb8 + regs[0];
				*((ulong *) p) = key->a;
				p += 4;
				break;
			case 1:
				*p++ = 0xb8 + regs[1];
				*((ulong *) p) = key->b;
				p += 4;
				break;
			case 2:
				*p++ = 0xb8 + regs[2];
				key->plen = p-ret;
				p += 4;
				break;
			case 3:
				*p++ = 0xb8 + regs[3];
				key->paddr = p-ret;
				p += 4;
				break;
			case 4:
				*p++ = 0x31;
				*p++ = 0x40 + regs[3] + regs[0] * 8;
				*p++ = 0;
				break;
			case 5:
				*p++ = 0x29;
				*p++ = 0x40 + regs[3] + regs[1] * 8;
				*p++ = 0;
				break;
			case 6:
				*p++ = 1;
				*p++ = 0xc0 + regs[0] + regs[1] * 8;
				break;
			case 7:
				blewadd(&p, koef1, regs[3]);
				break;
			case 8:
				blewadd(&p, koef2, regs[3]);
				break;
			case 9:
				*p++ = 0x48 + regs[2];
				outjump = p;
				/* space for jump code */
				for (i = 0; i < 6; i++)
					blewnop(&p);
				break;
		}
		blewnops(&p);
		st[state].pos = before - ret;
		st[state].len = p - before;
	}
	/* ok, we have our states */
	blewgap(&p);

	/* now compute jumps */
	for (i = 0; i < 9; i++) {
		jtab[i] = i+1;
	}
	jtab[9] = 4;

/*	XXX-TODO: Not implemented yet
	mix_jump(&jtab[0], 4);
	mix_jump(&jtab[5], 2);
	mix_jump(&jtab[7], 2); */

	key->start = st[0].pos;

	/* place jump instruction after each label */
	for (i = 0; i < 10; i++) {
		long from = st[i].pos + st[i].len;
		long to = st[jtab[i]].pos;
		long rel = to-from-2;
		if ((rel > 127) || (rel < -127)) {
			/* near jump */
			ret[from] = 0xe9;
			*((long *)(&ret[from+1])) = rel-3;
		} else {
			/* short jump */
			ret[from] = 0xeb;
			ret[from+1] = ((unsigned long) rel) & 0xff;
		}
	}

	/* and finally, setup the jump-out instruction */
	i = p-outjump-2;
	if (i > 127) {
		/* near 'jz' */
		outjump[0] = 0x0f;
		outjump[1] = 0x84;
		*((long *)(&outjump[2])) = i-4;
	} else {
		/* short 'jz' */
		outjump[0] = 0x74;
		outjump[1] = i;
	}
	key->len = p-ret;
	return ret;
}

void	poly_encrypt(unsigned char *data, int len, poly_key *key)
{
	unsigned *p = (void *) data;
	unsigned a,b;

	len = (len+3) >> 2;
	a = key->a;
	b = key->b;

	while (len--) {
		*p += b;
		*p ^= a;
		a += b;
		p++;
	}
}

```

`src/stubify.c`:

```c
/*
 * $Id: stubify.c, well, this is what actually screws up any ELF file.
 *
 * Produced SFX executable looks like:
 *
 * <segment>
 *	<optional polymorphic descrambler>
 *	<optional locking code>
 * 	120	decompressor [entrypoint]
 *	4	ptr to dest (needed by decompressor)
 *	x1	packed elf body
 *	4096-x2 <padding>
 *	x2	ELF loader <-- from this point decompressor stores output
 *	---- there begins original ELF base
 *	two segments of original elf, merged to one
 */

/* you can put anything there */
#define PWDPROMPT "password:"

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <linux/elf.h>
#include <string.h>
#include <sys/mman.h>
#include "nrv2e.h"
#include "elfuck.h"
#include "decompress.h"
#include "execelf.h"
#include "stubify.h"
#include "poly.h"
#include "getpw.h"
#include "lock.h"

static	int olen;
void	pack_callback(int ts, int cs, void *d)
{
	static int c = 0;
	register int k = ts * 100 / olen;

	if (c != k) {
		fprintf(stderr, "\r%d %%", k);
		c = k;
	}
}

#define OFFSET(x) ((x) & 4095)
int	stubify_elf(uchar *src, uchar *dest, int size, int level, int flags)
{
	struct	elf32_hdr *e = (void *) src;
	struct	stub *o = (void *) dest;
	struct	elf32_phdr *p;
	ulong	lo = -1, hi = 0, memhi = 0, start = 0;
	uchar	*pa, *ka;
	int	i, d = 0;
	ucl_callback cb;
	struct	elf_aux *aux;
	int	bsize = sizeof(ELF_BANNER)-1, esize = EXECELF_SIZE + 1;
	int	have_interp = 0;
	poly_key	pk;
	uchar	*poly = NULL;
	uchar	phash[20];
	ulong	testhash[5];
	int	lsize = 0;
	uchar	*lock = NULL;

	if (strncmp(e->e_ident, "\177ELF", 4)) {
		eprintf("ERROR: Input file not in ELF format\n");
		return -1;
	}

	memset(&pk, 0, sizeof(pk));

	if (flags & FLAG_NOBANNER)
		bsize = 0;

	if (flags & FLAG_SCRAMBLE) {
		poly = poly_gen(&pk);
	}

	if (flags & FLAG_LOCK) {
		int lp = sizeof(PWDPROMPT)-1;
		int lpn = -lp;
		getpassw(phash);
		lock = malloc(LOCK_SIZE + lp + sizeof(lpn));
		memcpy(lock + LOCK_SIZE, PWDPROMPT, lp);
		memcpy(lock + LOCK_SIZE + lp, &lpn, sizeof(lpn));
		lsize = LOCK_SIZE + lp + sizeof(lpn);
	}

	/* find code and data segments */
	for (i = 0, p = (void *) (src + e->e_phoff); i < e->e_phnum; i++, p++) {
		if (p->p_type == PT_LOAD) {
			if (p->p_vaddr < lo) lo = p->p_vaddr;
			if ((p->p_vaddr+p->p_filesz) > hi)
				hi = p->p_vaddr + p->p_filesz;
			if ((p->p_vaddr+p->p_memsz) > memhi)
				memhi = p->p_vaddr + p->p_memsz;
		}
		if (p->p_type == PT_INTERP) {
			strcpy(execelf_interp, src + p->p_offset);
			esize += strlen(execelf_interp);
			have_interp = 1;
		}
	}

	if (!have_interp) {
		/* huh. this is really hackish, ELF haven't interpreter,
		   so zero interpreter loader code for better compression,
		   as it will be never used anyway */
		memset(e_skip_interp, 0, e_no_interp-e_skip_interp);
	}

	lo = ALIGNDOWN(lo);
	hi = ALIGNUP(hi);
	memhi = ALIGNUP(memhi);
	printf("size in file: %ld, size in memory: %ld\n", hi-lo, memhi-lo);

	/* allocate source buffer we'll be compressing */
	ka = pa = malloc((hi-lo) + esize);
	if (!pa) {
		perror("ERROR: malloc failed");
		return -1;
	}
	memcpy(ka, execelf, esize); pa += esize;
	memset(pa, 0, (hi-lo));

	/* copy file data to it */
	for (i = 0, p = (void *) (src + e->e_phoff); i < e->e_phnum; i++, p++) {
		if (p->p_type == PT_LOAD) {
			memcpy(	pa + ALIGNDOWN(p->p_vaddr - lo),
				src + p->p_offset - OFFSET(p->p_vaddr),
				p->p_filesz + OFFSET(p->p_vaddr));
			memcpy(	pa + p->p_vaddr - lo,
				src + p->p_offset,
				p->p_filesz);
		}
	}

	/* ok, now compress that sucker */
	printf("Compressing ...\n");
	cb.callback = (void *) pack_callback;
	olen = (hi-lo) + esize;
	d = bsize + DECOMPRESS_SIZE + pk.len + lsize;
	ucl_nrv2e_99_compress(ka, olen, o->data + d, &i, &cb, level, NULL, NULL);
	aux = (void *) (o->data + d + i);
	i += sizeof(*aux);

	start = ALIGNDOWN(lo - (sizeof(struct stub) + d + i + 4096));
	if (start > 0x7fffffff) {
		printf("FATAL: There is not enough space for us!\n");
		free(ka);
		return -1;
	}

	/* ok, it's time to setup headers */
	memcpy(o->elf.e_ident, "\177ELF", 4);
	o->elf.e_type = ET_EXEC;
	o->elf.e_machine = EM_386;
	o->elf.e_version = 1;
	o->elf.e_entry = start + bsize + sizeof(o->elf) + sizeof(o->phdr);
	o->elf.e_phoff = sizeof(o->elf);
	o->elf.e_shoff = o->elf.e_flags = 0;
	o->elf.e_ehsize = sizeof(o->elf);
	o->elf.e_phentsize = sizeof(o->phdr);
	o->elf.e_phnum = 1;
	o->elf.e_shentsize = o->elf.e_shnum = o->elf.e_shstrndx = 0;

	/* we'have only one segment */
	o->phdr.p_type = PT_LOAD;
	o->phdr.p_offset = 0;
	o->phdr.p_vaddr = o->phdr.p_paddr = start;
	o->phdr.p_filesz = sizeof(o->elf) + sizeof(o->phdr) + d + i;
	o->phdr.p_memsz = memhi - start;
	o->phdr.p_flags = PF_R | PF_W | PF_X;
	o->phdr.p_align = 4096;

	/* copy the decompressor */
	memcpy(o->data, ELF_BANNER, bsize);
	decompress_src = o->elf.e_entry + pk.len + lsize + DECOMPRESS_SIZE - 4;
	decompress_dest = lo - esize;
	memcpy(o->data + bsize + pk.len + lsize, decompress, DECOMPRESS_SIZE);

	/* setup aux variables for execelf */
	aux->phdr = e->e_phoff + lo;
	aux->phnum = e->e_phnum;
	aux->entry = e->e_entry;
	aux->freestart = start;
	aux->freelen = lo - start - 4096;

	/* lock the result if requiered */
	if (lock) {
		uchar *data = o->data + bsize + pk.len + lsize;
		int llen = (DECOMPRESS_SIZE + i);
		sha1_asm((char *) testhash, data, llen);
		lock_testkey = testhash[0];
		lock_start = o->elf.e_entry + pk.len + lsize;
		locked_len = llen;
		memcpy(lock, elf_lock, LOCK_SIZE);
		memcpy(o->data + bsize + pk.len, lock, lsize);
		rc4_asm(phash, data, llen);
	}

	/* scramble the result if requiered */
	if (pk.len) {
		ulong slen = (DECOMPRESS_SIZE + i + lsize);
		poly_encrypt(o->data + bsize + pk.len,
			slen, &pk);

		/* setup the descrambler */
		*((ulong *)(&poly[pk.plen])) = (slen+3) >> 2;
		*((ulong *)(&poly[pk.paddr])) = o->elf.e_entry + pk.len;
		o->elf.e_entry += pk.start;

		/* and copy the polymorphic descrambler */
		memcpy(o->data + bsize, poly, pk.len);
	}

	free(ka);
	free(poly);
	free(lock);
	return o->phdr.p_filesz;
}

/* this will pack arbitrary ELF in 'src' to 'dest' with 'evel' */
int	pack_elf(char *src, char *dest, int level, int flags)
{
	int	in, out, size, t;
	uchar	*i, *o;

	printf("Packing%s%s%s '%s' to '%s'\n", 
		flags & FLAG_SCRAMBLE ? ", scrambling" : "",
		flags & FLAG_LOCK ? ", locking" : "",
		flags & FLAG_NOBANNER ? " without banner" : "",
		src, dest);

	/* open input/output streams */
	in = open(src, O_RDONLY);
	if (in < 0) {
		perror(src);
		return 1;
	}

	out = open(dest, O_CREAT | O_RDWR | O_TRUNC, 0744);
	if (out < 0) {
		perror(dest);
		return 1;
	}

	size = lseek(in, 0, SEEK_END);
	ftruncate(out, ALIGNDOWN(size*2) + 4096);

	/* mmap them */
	i = mmap(NULL, ALIGNUP(size), PROT_READ, MAP_SHARED, in, 0);
	if (i == MAP_FAILED) {
		perror("mmap");
		close(in); close(out);
		return 1;
	}

	o = mmap(NULL, ALIGNDOWN(size*2) + 4096, PROT_READ | PROT_WRITE, MAP_SHARED,
		out, 0);
	if (o == MAP_FAILED) {
		perror("mmap");
		close(in); close(out); munmap(i, ALIGNUP(size));
		return 1;
	}
	t = stubify_elf(i, o, size, level, flags);
	munmap(i, ALIGNUP(size));
	munmap(o, ALIGNDOWN(size*2) + 4096);
	if (t >= 0) {
		printf("\rOk, compressed to %.2f%% (%d => %d)\n", t * 100.0 / size, size, t);
		ftruncate(out, t);
		close(out);
	} else {
		printf("\rCompression failed!\n");
		close(out);
		unlink(dest);
	}
	close(in);
	return t<0?-1:0;
}

```