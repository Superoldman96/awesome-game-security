Project Path: arc_gmh5225_obfstr_ceyohz3d

Source Tree:

```txt
arc_gmh5225_obfstr_ceyohz3d
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ examples
‚îÇ   ‚îú‚îÄ‚îÄ obfuscation.rs
‚îÇ   ‚îî‚îÄ‚îÄ stringify.rs
‚îú‚îÄ‚îÄ license.txt
‚îú‚îÄ‚îÄ readme.md
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ bytes.rs
    ‚îú‚îÄ‚îÄ cfo.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ murmur3.rs
    ‚îú‚îÄ‚îÄ pos.rs
    ‚îú‚îÄ‚îÄ wide.rs
    ‚îú‚îÄ‚îÄ words.rs
    ‚îî‚îÄ‚îÄ xref.rs

```

`Cargo.toml`:

```toml
[package]
name = "obfstr"
version = "0.4.1"
edition = "2021"
license = "MIT"

authors = ["Casper <CasualX@users.noreply.github.com>"]
description = "Compiletime string constant obfuscation for Rust"
documentation = "https://docs.rs/obfstr"
repository = "https://github.com/CasualX/obfstr"
readme = "readme.md"
keywords = ["obfuscation", "hash", "random", "wide"]
categories = ["no-std"]

```

`examples/obfuscation.rs`:

```rs
/*!
Try out the obfuscation live!

```
cargo rustc --release --example obfuscation -- --emit asm -C "llvm-args=-x86-asm-syntax=intel"
```

Inspect `target/release/examples/obfuscation.s` to see the compiled code.

These examples are #[inline(never)] to aid inspection of the generated code.
In practice the generated code is inlined and mixed with their surrounding code.
*/

#[inline(never)]
fn obfstmt() -> i32 {
	let mut i = 0;
	// trace_macros!(true);
	obfstr::obfstmt! {
		i = 5;
		i *= 24;
		i -= 10;
		i += 8;
		i *= 28;
		i -= 18;
		i += 1;
		i *= 21;
		i -= 11;
	}
	// trace_macros!(false);
	assert_eq!(i, 69016);
	i
}

#[inline(never)]
fn obfstr() {
	print(obfstr::obfstr!("Hello world!"));
	print(obfstr::obfstr!("AB"));
	print(obfstr::obfstr!("This literal is very very very long to see if it correctly handles long strings"));
}

#[inline(never)]
fn xref() -> &'static i32 {
	static FOO: i32 = 42;
	obfstr::xref!(&FOO)
}

fn main() {
	println!("obfstmt: {}", obfstmt());
	obfstr();
	println!("xref: {}", xref());
}

#[inline(never)]
fn print(s: &str) {
	println!("obfstr: {}", s);
}

```

`examples/stringify.rs`:

```rs
/*!
This example demonstrates various ways to obfuscate the string literals in more complex scenarios.
The example presented here uses an enum because it can be challenging to return a string representation of it.
 */

use std::fmt;
use obfstr::{obfstr, position};

// Let's try to obfuscate the string representation of this enum.
pub enum Example {
	Foo,
	Bar,
	Baz,
}

impl Example {
	// Returns an owned String but this allocates memory.
	pub fn to_str1(&self) -> String {
		match self {
			Example::Foo => String::from(obfstr!("Foo")),
			Example::Bar => String::from(obfstr!("Bar")),
			Example::Baz => String::from(obfstr!("Baz")),
		}
	}

	// Use a callback to keep the string slice allocated on the stack but this gets annoying in more complex scenarios.
	pub fn to_str2<R, F: FnMut(&str) -> R>(&self, mut f: F) -> R {
		match self {
			Example::Foo => f(obfstr!("Foo")),
			Example::Bar => f(obfstr!("Bar")),
			Example::Baz => f(obfstr!("Baz"))
		}
	}

	// Use a buffer to hold the deobfuscated string. Panics if the buffer is too small.
	pub fn to_str3<'a>(&self, buf: &'a mut [u8; 4]) -> &'a str {
		match self {
			Example::Foo => obfstr!(buf <- "Foo"),
			Example::Bar => obfstr!(buf <- "Bar"),
			Example::Baz => obfstr!(buf <- "Baz"),
		}
	}

	// Allocate the string literals via concatenation.
	pub const POOL: &'static str = concat!("Foo", "Bar", "Baz");

	// Deobfuscate the POOL constant and pass it here as the pool argument.
	// This to string implementation will slice the right substring.
	pub fn to_str4<'a>(&self, pool: &'a str) -> &'a str {
		match self {
			Example::Foo => &pool[position!(Example::POOL, "Foo")],
			Example::Bar => &pool[position!(Example::POOL, "Bar")],
			Example::Baz => &pool[position!(Example::POOL, "Baz")],
		}
	}
}
impl fmt::Display for Example {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		self.to_str2(|s| f.write_str(s))
	}
}

fn main() {}

```

`license.txt`:

```txt
Copyright (c) 2019-2020 Casper <CasualX@users.noreply.github.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`readme.md`:

```md
String Obfuscation
==================

[![MIT License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![crates.io](https://img.shields.io/crates/v/obfstr.svg)](https://crates.io/crates/obfstr)
[![docs.rs](https://docs.rs/obfstr/badge.svg)](https://docs.rs/obfstr)
[![Build status](https://github.com/CasualX/obfstr/workflows/CI/badge.svg)](https://github.com/CasualX/obfstr/actions)

Compiletime string constant obfuscation for Rust.

The string constant itself is embedded in obfuscated form and deobfuscated locally.
This reference to a temporary value must be used in the same statement it was generated.
See the documentation for more advanced use cases.

Examples
--------

The `obfstr!` macro returns the deobfuscated string as a temporary value:

```rust
assert_eq!(obfstr::obfstr!("Hello üåç"), "Hello üåç");
```

The `wide!` macro provides compiletime utf16 string constants:

```rust
let expected = &['W' as u16, 'i' as u16, 'd' as u16, 'e' as u16, 0];
assert_eq!(obfstr::wide!("Wide\0"), expected);
```

The `random!` macro provides compiletime random values:

```rust
const RND: i32 = obfstr::random!(u8) as i32;
assert!(RND >= 0 && RND <= 255);
```

Compiletime random values are based on `file!()`, `line!()`, `column!()` and a fixed seed to ensure reproducibility.
This fixed seed is stored as text in the environment variable `OBFSTR_SEED` and can be changed as desired.

License
-------

Licensed under [MIT License](https://opensource.org/licenses/MIT), see [license.txt](license.txt).

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, shall be licensed as above, without any additional terms or conditions.

```

`src/bytes.rs`:

```rs
/*!
Byte string obfuscation
=======================
*/

use core::ptr::{read_volatile, write};

/// Compiletime string constant obfuscation.
///
/// The purpose of the obfuscation is to make it difficult to discover the original strings with automated analysis.
/// String obfuscation is not intended to hinder a dedicated reverse engineer from discovering the original string.
/// This should not be used to hide secrets in client binaries and the author disclaims any responsibility for any damages resulting from ignoring this warning.
///
/// The `obfstr!` macro returns the deobfuscated string as a temporary `&str` value and must be consumed in the same statement it was used:
///
/// ```
/// use obfstr::obfstr;
///
/// const HELLO_WORLD: &str = "Hello üåç";
/// assert_eq!(obfstr!(HELLO_WORLD), HELLO_WORLD);
/// ```
///
/// Different syntax forms are supported to reuse the obfuscated strings in outer scopes:
///
/// ```
/// use obfstr::obfstr;
///
/// // Obfuscate a bunch of strings
/// obfstr! {
/// 	let s = "Hello world";
/// 	let another = "another";
/// }
/// assert_eq!(s, "Hello world");
/// assert_eq!(another, "another");
///
/// // Assign to an uninit variable in outer scope
/// let (true_string, false_string);
/// let string = if true {
/// 	obfstr!(true_string = "true")
/// }
/// else {
/// 	obfstr!(false_string = "false")
/// };
/// assert_eq!(string, "true");
///
/// // Return an obfuscated string from a function
/// fn helper(buf: &mut [u8]) -> &str {
/// 	obfstr!(buf <- "hello")
/// }
/// let mut buf = [0u8; 16];
/// assert_eq!(helper(&mut buf), "hello");
/// ```
#[macro_export]
macro_rules! obfstr {
	($(let $name:ident = $s:expr;)*) => {$(
		$crate::obfbytes! { let $name = $s.as_bytes(); }
		let $name = $crate::unsafe_as_str($name);
	)*};
	($name:ident = $s:expr) => {
		$crate::unsafe_as_str($crate::obfbytes!($name = $s.as_bytes()))
	};
	($buf:ident <- $s:expr) => {
		$crate::unsafe_as_str($crate::obfbytes!($buf <- $s.as_bytes()))
	};
	($s:expr) => {
		$crate::unsafe_as_str($crate::obfbytes!($s.as_bytes()))
	};
}

/// Compiletime byte string obfuscation.
#[macro_export]
macro_rules! obfbytes {
	($(let $name:ident = $s:expr;)*) => {
		$(let ref $name = $crate::__obfbytes!($s);)*
	};
	($name:ident = $s:expr) => {{
		$name = $crate::__obfbytes!($s);
		&$name
	}};
	($buf:ident <- $s:expr) => {{
		let buf = &mut $buf[..$s.len()];
		buf.copy_from_slice(&$crate::__obfbytes!($s));
		buf
	}};
	($s:expr) => {
		&$crate::__obfbytes!($s)
	};
}

#[doc(hidden)]
#[macro_export]
macro_rules! __obfbytes {
	($s:expr) => {{
		const _OBFBYTES_STRING: &[u8] = $s;
		const _OBFBYTES_LEN: usize = _OBFBYTES_STRING.len();
		const _OBFBYTES_KEYSTREAM: [u8; _OBFBYTES_LEN] = $crate::bytes::keystream::<_OBFBYTES_LEN>($crate::__entropy!("key", stringify!($s)) as u32);
		static _OBFBYTES_SDATA: [u8; _OBFBYTES_LEN] = $crate::bytes::obfuscate::<_OBFBYTES_LEN>(_OBFBYTES_STRING, &_OBFBYTES_KEYSTREAM);
		$crate::bytes::deobfuscate::<_OBFBYTES_LEN>(
			$crate::__xref!(
				$crate::__entropy!("offset", stringify!($s)) as usize,
				$crate::__entropy!("xref", stringify!($s)),
				&_OBFBYTES_SDATA),
			&_OBFBYTES_KEYSTREAM)
	}};
}

// Simple XorShift to generate the key stream.
// Security doesn't matter, we just want a number of random-looking bytes.
#[inline(always)]
const fn next_round(mut x: u32) -> u32 {
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	x
}

/// Generate the key stream for array of given length.
#[inline(always)]
pub const fn keystream<const LEN: usize>(key: u32) -> [u8; LEN] {
	let mut keys = [0u8; LEN];
	let mut round_key = key;
	let mut i = 0;
	// Calculate the key stream in chunks of 4 bytes
	while i < LEN & !3 {
		round_key = next_round(round_key);
		let kb = round_key.to_ne_bytes();
		keys[i + 0] = kb[0];
		keys[i + 1] = kb[1];
		keys[i + 2] = kb[2];
		keys[i + 3] = kb[3];
		i += 4;
	}
	// Calculate the remaining bytes of the key stream
	round_key = next_round(round_key);
	let kb = round_key.to_ne_bytes();
	match LEN % 4 {
		1 => {
			keys[i + 0] = kb[0];
		},
		2 => {
			keys[i + 0] = kb[0];
			keys[i + 1] = kb[1];
		},
		3 => {
			keys[i + 0] = kb[0];
			keys[i + 1] = kb[1];
			keys[i + 2] = kb[2];
		},
		_ => (),
	}
	keys
}

/// Obfuscates the input string and given key stream.
#[inline(always)]
pub const fn obfuscate<const LEN: usize>(s: &[u8], k: &[u8; LEN]) -> [u8; LEN] {
	if s.len() != LEN {
		panic!("input string len not equal to key stream len");
	}
	let mut data = [0u8; LEN];
	let mut i = 0usize;
	while i < LEN {
		data[i] = s[i] ^ k[i];
		i += 1;
	}
	data
}

/// Deobfuscates the obfuscated input string and given key stream.
#[inline(always)]
pub fn deobfuscate<const LEN: usize>(s: &[u8; LEN], k: &[u8; LEN]) -> [u8; LEN] {
	let mut buffer = [0u8; LEN];
	let mut i = 0;
	// Try to tickle the LLVM optimizer in _just_ the right way
	// Use `read_volatile` to avoid constant folding a specific read and optimize the rest
	// Volatile reads of any size larger than 8 bytes appears to cause a bunch of one byte reads
	// Hand optimize in chunks of 8 and 4 bytes to avoid this
	unsafe {
		let src = s.as_ptr();
		let dest = buffer.as_mut_ptr();
		// Process in chunks of 8 bytes on 64-bit targets
		#[cfg(target_pointer_width = "64")]
		while i < LEN & !7 {
			let ct = read_volatile(src.offset(i as isize) as *const [u8; 8]);
			let tmp = u64::from_ne_bytes([ct[0], ct[1], ct[2], ct[3], ct[4], ct[5], ct[6], ct[7]]) ^
				u64::from_ne_bytes([k[i + 0], k[i + 1], k[i + 2], k[i + 3], k[i + 4], k[i + 5], k[i + 6], k[i + 7]]);
			write(dest.offset(i as isize) as *mut [u8; 8], tmp.to_ne_bytes());
			i += 8;
		}
		// Process in chunks of 4 bytes
		while i < LEN & !3 {
			let ct = read_volatile(src.offset(i as isize) as *const [u8; 4]);
			let tmp = u32::from_ne_bytes([ct[0], ct[1], ct[2], ct[3]]) ^
				u32::from_ne_bytes([k[i + 0], k[i + 1], k[i + 2], k[i + 3]]);
			write(dest.offset(i as isize) as *mut [u8; 4], tmp.to_ne_bytes());
			i += 4;
		}
		// Process the remaining bytes
		match LEN % 4 {
			1 => {
				let ct = read_volatile(src.offset(i as isize));
				write(dest.offset(i as isize), ct ^ k[i]);
			},
			2 => {
				let ct = read_volatile(src.offset(i as isize) as *const [u8; 2]);
				write(dest.offset(i as isize) as *mut [u8; 2], [
					ct[0] ^ k[i + 0],
					ct[1] ^ k[i + 1],
				]);
			},
			3 => {
				let ct = read_volatile(src.offset(i as isize) as *const [u8; 3]);
				write(dest.offset(i as isize) as *mut [u8; 2], [
					ct[0] ^ k[i + 0],
					ct[1] ^ k[i + 1],
				]);
				write(dest.offset(i as isize + 2), ct[2] ^ k[i + 2]);
			},
			_ => (),
		}
	}
	buffer
}

#[inline(always)]
pub fn equals<const LEN: usize>(s: &[u8; LEN], k: &[u8; LEN], other: &[u8]) -> bool {
	if other.len() != LEN {
		return false;
	}
	let mut i = 0;
	// Try to tickle the LLVM optimizer in _just_ the right way
	// Use `read_volatile` to avoid constant folding a specific read and optimize the rest
	// Volatile reads of any size larger than 8 bytes appears to cause a bunch of one byte reads
	// Hand optimize in chunks of 8 and 4 bytes to avoid this
	unsafe {
		let src = s.as_ptr();
		// Process in chunks of 8 bytes on 64-bit targets
		#[cfg(target_pointer_width = "64")]
		while i < LEN & !7 {
			let ct = read_volatile(src.offset(i as isize) as *const [u8; 8]);
			let tmp = u64::from_ne_bytes([ct[0], ct[1], ct[2], ct[3], ct[4], ct[5], ct[6], ct[7]]) ^
				u64::from_ne_bytes([k[i + 0], k[i + 1], k[i + 2], k[i + 3], k[i + 4], k[i + 5], k[i + 6], k[i + 7]]);
			let other = u64::from_ne_bytes([other[i + 0], other[i + 1], other[i + 2], other[i + 3], other[i + 4], other[i + 5], other[i + 6], other[i + 7]]);
			if tmp != other {
				return false;
			}
			i += 8;
		}
		// Process in chunks of 4 bytes
		while i < LEN & !3 {
			let ct = read_volatile(src.offset(i as isize) as *const [u8; 4]);
			let tmp = u32::from_ne_bytes([ct[0], ct[1], ct[2], ct[3]]) ^
				u32::from_ne_bytes([k[i + 0], k[i + 1], k[i + 2], k[i + 3]]);
			let other = u32::from_ne_bytes([other[i + 0], other[i + 1], other[i + 2], other[i + 3]]);
			if tmp != other {
				return false;
			}
			i += 4;
		}
		// Process the remaining bytes
		match LEN % 4 {
			1 => {
				let ct = read_volatile(src.offset(i as isize));
				ct ^ k[i] == other[i]
			},
			2 => {
				let ct = read_volatile(src.offset(i as isize) as *const [u8; 2]);
				u16::from_ne_bytes([ct[0], ct[1]]) ^ u16::from_ne_bytes([k[i + 0], k[i + 1]]) == u16::from_ne_bytes([other[i + 0], other[i + 1]])
			},
			3 => {
				let ct = read_volatile(src.offset(i as isize) as *const [u8; 3]);
				u32::from_ne_bytes([ct[0], ct[1], ct[2], 0]) ^ u32::from_ne_bytes([k[i + 0], k[i + 1], k[i + 2], 0]) == u32::from_ne_bytes([other[i + 0], other[i + 1], other[i + 2], 0])
			},
			_ => true,
		}
	}
}

// Test correct processing of less than multiple of 8 lengths
#[test]
fn test_remaining_bytes() {
	const STRING: &[u8] = b"01234567ABCDEFGHI";
	fn test<const LEN: usize>(key: u32) {
		let keys = keystream::<LEN>(key);
		let data = obfuscate::<LEN>(&STRING[..LEN], &keys);
		let buffer = deobfuscate::<LEN>(&data, &keys);
		// Ciphertext should not equal input string
		assert_ne!(&data[..], &STRING[..LEN]);
		// Deobfuscated result should equal input string
		assert_eq!(&buffer[..], &STRING[..LEN]);
		// Specialized equals check should succeed
		assert!(equals::<LEN>(&data, &keys, &STRING[..LEN]));
	}
	test::<8>(0x1111);
	test::<9>(0x2222);
	test::<10>(0x3333);
	test::<11>(0x4444);
	test::<12>(0x5555);
	test::<13>(0x6666);
	test::<14>(0x7777);
	test::<15>(0x8888);
	test::<16>(0x9999);
}

#[test]
fn test_equals() {
	const STRING: &str = "Hello √∞≈∏≈í¬ç";
	const LEN: usize = STRING.len();
	const KEYSTREAM: [u8; LEN] = keystream::<LEN>(0x10203040);
	const OBFSTRING: [u8; LEN] = obfuscate::<LEN>(STRING.as_bytes(), &KEYSTREAM);
	assert!(equals::<LEN>(&OBFSTRING, &KEYSTREAM, STRING.as_bytes()));
}

#[test]
fn test_obfstr_let() {
	obfstr! {
		let abc = "abc";
		let def = "defdef";
	}
	assert_eq!(abc, "abc");
	assert_eq!(def, "defdef");
}

#[test]
fn test_obfstr_const() {
	assert_eq!(obfstr!("\u{20}\0"), " \0");
	assert_eq!(obfstr!("\"\n\t\\\'\""), "\"\n\t\\\'\"");

	const LONG_STRING: &str = "This literal is very very very long to see if it correctly handles long strings";
	assert_eq!(obfstr!(LONG_STRING), LONG_STRING);

	const ABC: &str = "ABC";
	const WORLD: &str = "üåç";

	assert_eq!(obfbytes!(ABC.as_bytes()), "ABC".as_bytes());
	assert_eq!(obfbytes!(WORLD.as_bytes()), "üåç".as_bytes());
}

```

`src/cfo.rs`:

```rs
/*!
Control Flow Obfuscation
========================
*/

/// Generates the keys and xor values for a sequence of statements.
pub const fn generate<const LEN: usize>(mut key: u32, mut xor: u32, stmts: &[&'static str; LEN]) -> [(&'static str, u32, u32); LEN] {
	let mut result = [("", 0, 0); LEN];
	let mut i = 0;
	while i < stmts.len() {
		key ^= xor;
		xor = crate::murmur3(stmts[i].as_bytes(), key);
		// FIXME! This should check for collisions...
		result[i] = (stmts[i], key, xor);
		i += 1;
	}
	result
}

/// Statement control flow obfuscation.
///
/// Given a sequence of statements obfuscates the relationship between each statement.
///
/// # Limitations
///
/// Variables cannot be declared inside the obfuscated statements, declare and initialize any variables needed beforehand.
/// Control flow analysis will fail. The declared variables will need to be mutable and have an initial value.
///
/// There's a risk that the obfuscated code fails to work due to two statements generating the same random key accidentally.
/// This is presented at runtime with an infinite loop pending extra validation checks.
///
/// # Examples
///
/// ```
/// let mut tmp = 0;
/// obfstr::obfstmt! {
/// 	tmp = 2;
/// 	tmp *= 22;
/// 	tmp -= 12;
/// 	tmp /= 3;
/// }
///# obfstr::obfstmt! {}
/// assert_eq!(tmp, 10);
/// ```
#[macro_export]
macro_rules! obfstmt {
	($($stmt:stmt;)*) => {{
		// Initial KEY and XOR values
		const _OBFSTMT_KEY: u32 = $crate::__entropy!(stringify!($($stmt;)*)) as u32;
		const _OBFSTMT_XOR: u32 = $crate::murmur3(b"XOR", _OBFSTMT_KEY);
		// Count the number of statements
		const _OBFSTMT_LEN: usize = <[&'static str]>::len(&[$(stringify!($stmt)),*]);
		// Generate key and xor values of every statement and the final exit code
		const _OBFSTMT_STMTS: [(&'static str, u32, u32); _OBFSTMT_LEN] =
			$crate::cfo::generate::<{_OBFSTMT_LEN}>(_OBFSTMT_KEY, _OBFSTMT_XOR, &[$(stringify!($stmt)),*]);
		const _OBFSTMT_EXIT: u32 = if _OBFSTMT_LEN == 0 { _OBFSTMT_KEY ^ _OBFSTMT_XOR }
			else { _OBFSTMT_STMTS[_OBFSTMT_LEN - 1].1 ^ _OBFSTMT_STMTS[_OBFSTMT_LEN - 1].2 };
		// Initialize the key and xor values
		let mut key = _OBFSTMT_KEY;
		#[allow(unused_mut)]
		let mut xor = _OBFSTMT_XOR;
		loop {
			$crate::__obfstmt_match!(key, xor, 0usize, [$($stmt;)*], []);
			key ^= xor;
		}
	}};
}

/// Generates the match statement for [`obfstmt!`].
#[doc(hidden)]
#[macro_export]
macro_rules! __obfstmt_match {
	// Terminating case, generate the code
	($key:expr, $xor:expr, $x:expr, [], [$($i:expr, $stmt:stmt;)*]) => {
		match $key {
			// Have to use match guard here because an expression isn't allowed in pattern position
			// The result is still optimized to a binary search for the right key per block
			$(
				key if key == { _OBFSTMT_STMTS[$i].1 } => {
					$stmt
					$xor = _OBFSTMT_STMTS[$i].2;
				},
			)*
			_OBFSTMT_EXIT => break,
			_ => (),
		}
	};
	// Generate increasing indices for every stmt
	($key:expr, $xor:expr, $x:expr, [$stmt1:stmt; $($tail:stmt;)*], [$($i:expr, $stmt2:stmt;)*]) => {
		$crate::__obfstmt_match!($key, $xor, $x + 1usize, [$($tail;)*], [$($i, $stmt2;)* $x, $stmt1; ])
	};
}

#[test]
fn test_identical_stmt() {
	let mut i: u8 = 0;
	obfstmt! {
		i += 1;
		i += 1;
		i += 1;
		i += 1;
	}
	obfstmt! {}
	assert_eq!(i, 4);
}

```

`src/lib.rs`:

```rs
/*!
Compiletime string constant obfuscation.
*/

#![cfg_attr(not(test), no_std)]

use core::str;

#[doc(hidden)]
pub mod wide;

#[doc(hidden)]
pub mod cfo;

mod murmur3;
pub use self::murmur3::murmur3;

mod pos;
pub use self::pos::position;

#[doc(hidden)]
pub mod xref;

//----------------------------------------------------------------

/// Compiletime random number generator.
///
/// Supported types are `u8`, `u16`, `u32`, `u64`, `usize`, `i8`, `i16`, `i32`, `i64`, `isize`, `bool`, `f32` and `f64`.
///
/// The integer types generate a random value in their respective range.  
/// The float types generate a random value in range of `[1.0, 2.0)`.
///
/// While the result is generated at compiletime only the integer types are available in const contexts.
///
/// ```
/// const RND: i32 = obfstr::random!(u8) as i32;
/// assert!(RND >= 0 && RND <= 255);
/// ```
///
/// The behavior of the macro inside other macros can be surprising:
///
/// ```
/// // When used as top-level input to macros, random works as expected
/// assert_ne!(obfstr::random!(u64), obfstr::random!(u64));
///
/// // When used inside the definition of a macro, random does not work as expected
/// macro_rules! inside {
/// 	() => {
/// 		assert_eq!(obfstr::random!(u64), obfstr::random!(u64));
/// 	};
/// }
/// inside!();
///
/// // When provided a unique seed, random works as expected
/// // Note that the seeds must evaluate to a literal!
/// macro_rules! seeded {
/// 	() => {
/// 		assert_ne!(obfstr::random!(u64, "lhs"), obfstr::random!(u64, "rhs"));
/// 	};
/// }
/// seeded!();
///
/// // Repeated usage in macros, random does not work as expected
/// macro_rules! repeated {
/// 	($($name:ident),*) => {
/// 		$(let $name = obfstr::random!(u64, "seed");)*
/// 	};
/// }
/// repeated!(a, b);
/// assert_eq!(a, b);
///
/// // Provide additional unique seeds, random works as expected
/// macro_rules! repeated_seeded {
/// 	($($name:ident),*) => {
/// 		$(let $name = obfstr::random!(u64, "seed", stringify!($name));)*
/// 	};
/// }
/// repeated_seeded!(c, d);
/// assert_ne!(c, d);
/// ```
#[macro_export]
macro_rules! random {
	($ty:ident $(, $seeds:expr)* $(,)?) => {{
		const _RANDOM_ENTROPY: u64 = $crate::entropy(concat!(file!(), ":", line!(), ":", column!() $(, ":", $seeds)*));
		$crate::__random_cast!($ty, _RANDOM_ENTROPY)
	}};
}

#[doc(hidden)]
#[macro_export]
macro_rules! __random_cast {
	(u8, $seed:expr) => { $seed as u8 };
	(u16, $seed:expr) => { $seed as u16 };
	(u32, $seed:expr) => { $seed as u32 };
	(u64, $seed:expr) => { $seed as u64 };
	(usize, $seed:expr) => { $seed as usize };
	(i8, $seed:expr) => { $seed as i8 };
	(i16, $seed:expr) => { $seed as i16 };
	(i32, $seed:expr) => { $seed as i32 };
	(i64, $seed:expr) => { $seed as i64 };
	(isize, $seed:expr) => { $seed as isize };
	(bool, $seed:expr) => { $seed as i64 >= 0 };
	(f32, $seed:expr) => { f32::from_bits(0b0_01111111 << (f32::MANTISSA_DIGITS - 1) | ($seed as u32 >> 9)) };
	(f64, $seed:expr) => { f64::from_bits(0b0_01111111111 << (f64::MANTISSA_DIGITS - 1) | ($seed >> 12)) };

	($ty:ident, $seed:expr) => { compile_error!(concat!("unsupported type: ", stringify!($ty))) };
}

/// Compiletime bitmixing.
///
/// Takes an intermediate hash that may not be thoroughly mixed and increase its entropy to obtain both better distribution.
/// See [Better Bit Mixing](https://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html) for reference.
#[inline(always)]
pub const fn splitmix(seed: u64) -> u64 {
	let next = seed.wrapping_add(0x9e3779b97f4a7c15);
	let mut z = next;
	z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);
	z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb);
	return z ^ (z >> 31);
}

/// Compiletime string constant hash.
///
/// Implemented using the [DJB2 hash function](http://www.cse.yorku.ca/~oz/hash.html#djb2) xor variation.
#[inline(always)]
pub const fn hash(s: &str) -> u32 {
	let s = s.as_bytes();
	let mut result = 3581u32;
	let mut i = 0usize;
	while i < s.len() {
		result = result.wrapping_mul(33) ^ s[i] as u32;
		i += 1;
	}
	return result;
}

/// Compiletime string constant hash.
///
/// Helper macro guarantees compiletime evaluation of the string constant hash.
///
/// ```
/// const STRING: &str = "Hello World";
/// assert_eq!(obfstr::hash!(STRING), 0x6E4A573D);
/// ```
#[macro_export]
macro_rules! hash {
	($s:expr) => {{ const _DJB2_HASH: u32 = $crate::hash($s); _DJB2_HASH }};
}

/// Produces pseudorandom entropy from the given string.
#[doc(hidden)]
#[inline(always)]
pub const fn entropy(string: &str) -> u64 {
	splitmix(SEED ^ splitmix(hash(string) as u64))
}

/// Produces pseudorandom entropy from the argument literals.
#[doc(hidden)]
#[macro_export]
macro_rules! __entropy {
	($($seeds:expr),* $(,)?) => {
		$crate::entropy(concat!(file!(), ":", line!(), ":", column!() $(, ":", $seeds)*))
	};
}

/// Compiletime RNG seed.
///
/// This value is derived from the environment variable `OBFSTR_SEED` and has a fixed value if absent.
/// If it changes all downstream dependents are recompiled automatically.
pub const SEED: u64 = splitmix(hash(match option_env!("OBFSTR_SEED") { Some(seed) => seed, None => "FIXED" }) as u64);

//----------------------------------------------------------------

#[doc(hidden)]
pub mod bytes;

#[doc(hidden)]
pub mod words;

#[doc(hidden)]
#[inline(always)]
pub fn unsafe_as_str(bytes: &[u8]) -> &str {
	// When used correctly by this crate's macros this should be safe
	#[cfg(debug_assertions)]
	return str::from_utf8(bytes).unwrap();
	#[cfg(not(debug_assertions))]
	return unsafe { str::from_utf8_unchecked(bytes) };
}

```

`src/murmur3.rs`:

```rs
/*!
Expose MurmurHash3, a keyed hash function. Not ready for public API.
*/

/// MurmurHash3 (32-bit variant) keyed hash function.
#[doc(hidden)]
#[macro_export]
macro_rules! murmur3 {
	($s:expr, $seed:expr) => {{ const _MURMUR3_HASH: u32 = $crate::murmur3($s, $seed); _MURMUR3_HASH }};
	($s:expr) => {{ const _MURMUR3_HASH: u32 = $crate::murmur3($s, 0); _MURMUR3_HASH }};
}

/// MurmurHash3 (32-bit variant) keyed hash function.
#[doc(hidden)]
#[inline]
pub const fn murmur3(s: &[u8], seed: u32) -> u32 {
	let mut h = seed;
	const C1: u32 = 0xcc9e2d51;
	const C2: u32 = 0x1b873593;

	let mut i = 0;
	while i < s.len() & !3 {
		let mut k = u32::from_le_bytes([s[i + 0], s[i + 1], s[i + 2], s[i + 3]]);
		k = k.wrapping_mul(C1);
		k = k.rotate_left(15);
		k = k.wrapping_mul(C2);

		h ^= k;
		h = h.rotate_left(13);
		h = h.wrapping_mul(5).wrapping_add(0xe6546b64);

		i += 4;
	}

	if s.len() % 4 != 0 {
		let k = match s.len() % 4 {
			3 => u32::from_le_bytes([s[i + 0], s[i + 1], s[i + 2], 0]),
			2 => u32::from_le_bytes([s[i + 0], s[i + 1], 0, 0]),
			1 => u32::from_le_bytes([s[i + 0], 0, 0, 0]),
			_ => 0/*unreachable!()*/,
		};
		h ^= k.wrapping_mul(C1).rotate_left(15).wrapping_mul(C2);
	}

	fmix32(h ^ s.len() as u32)
}

#[inline]
const fn fmix32(mut h: u32) -> u32 {
	h ^= h >> 16;
	h = h.wrapping_mul(0x85ebca6b);
	h ^= h >> 13;
	h = h.wrapping_mul(0xc2b2ae35);
	h ^= h >> 16;
	return h;
}

#[test]
fn test_vectors() {
	static TEST_VECTORS: [(u32, u32, &[u8]); 13] = [
		(0,          0,          b""), // with zero data and zero seed, everything becomes zero
		(0x514E28B7, 1,          b""), // ignores nearly all the math
		(0x81F16F39, 0xffffffff, b""), // make sure your seed uses unsigned 32-bit math
		(0x76293B50, 0,          &[0xff, 0xff, 0xff, 0xff]), // make sure 4-byte chunks use unsigned math
		(0xF55B516B, 0,          &[0x21, 0x43, 0x65, 0x87]), // Endian order. UInt32 should end up as 0x87654321
		(0x2362F9DE, 0x5082EDEE, &[0x21, 0x43, 0x65, 0x87]), // Special seed value eliminates initial key with xor
		(0x7E4A8634, 0,          &[0x21, 0x43, 0x65]), // Only three bytes. Should end up as 0x654321
		(0xA0F7B07A, 0,          &[0x21, 0x43]), // Only two bytes. Should end up as 0x4321
		(0x72661CF4, 0,          &[0x21]), // Only one byte. Should end up as 0x21
		(0x2362F9DE, 0,          &[0, 0, 0, 0]),
		(0x85F0B427, 0,          &[0, 0, 0]),
		(0x30F4C306, 0,          &[0, 0]),
		(0x514E28B7, 0,          &[0]),
	];

	for &(expected, seed, input) in TEST_VECTORS.iter() {
		assert_eq!(expected, murmur3(input, seed));
	}
}

```

`src/pos.rs`:

```rs
use core::{ops, str};

/// Finds the position of the needle in the haystack at compiletime.
///
/// Produces a const-eval error if the needle is not a substring of the haystack.
///
/// # Examples
///
/// ```
/// assert_eq!(obfstr::position!("haystack", "st"), 3..5);
///# assert_eq!(obfstr::position!("haystack", "haystack"), 0..8);
///# assert_eq!(obfstr::position!("haystack", "ck"), 6..8);
/// ```
///
/// Use this API when pooling strings in a single obfstr:
///
/// ```
/// const POOL: &str = concat!("Foo", "Bar", "Baz");
///
/// obfstr::obfstr! { let pool = POOL; }
///
/// // Later, read strings from the pool
/// let foo = &pool[obfstr::position!(POOL, "Foo")];
/// let bar = &pool[obfstr::position!(POOL, "Bar")];
/// let baz = &pool[obfstr::position!(POOL, "Baz")];
/// ```
#[macro_export]
macro_rules! position {
	($haystack:expr, $needle:expr) => {{ const _POSITION_RANGE: ::core::ops::Range<usize> = $crate::position($haystack, $needle); _POSITION_RANGE }};
}

/// Finds the position of the needle in the haystack at compiletime.
///
/// Produces a const-eval error if the needle is not a substring of the haystack.
///
/// ```
/// const POSITION: std::ops::Range<usize> = obfstr::position("haystack", "st");
/// assert_eq!(POSITION, 3..5);
/// ```
#[doc(hidden)]
#[inline(always)]
pub const fn position(haystack: &str, needle: &str) -> ops::Range<usize> {
	let start = search(haystack, needle);
	// Panic if substring not found
	if start < 0 {
		panic!("Needle not found in the haystack");
	}
	let start = start as usize;
	start..start + needle.len()
}

const fn search(haystack: &str, needle: &str) -> isize {
	// Short-circuit empty needles
	if needle.len() == 0 {
		return 0;
	}

	let haystack = haystack.as_bytes();
	let needle = needle.as_bytes();

	// Avoid overflow checks later
	if needle.len() <= haystack.len() {
		// Special case for needle length of 1
		if needle.len() == 1 {
			let needle = needle[0];
			let mut offset = 0;
			while offset <= haystack.len() {
				if haystack[offset] == needle {
					return offset as isize;
				}
				offset += 1;
			}
		}
		// Full blown quicksearch
		else {
			// assumed:
			// needle.len() >= 2
			// needle.len() <= haystack.len()

			// Initialize the jump table
			let mut jumps = [max(needle.len()); 256];
			let tail = needle.len() - 1;
			let mut i = 0;
			while i < tail {
				jumps[needle[i] as usize] = max(tail - i);
				i += 1;
			}
			// Find the needle
			let sentinel = needle[tail];
			let mut offset = 0;
			while offset < haystack.len() - tail {
				let chr = haystack[offset + tail];
				if chr == sentinel && check(haystack, needle, offset) {
					return offset as isize;
				}
				offset += jumps[chr as usize] as usize;
			}
		}
	}
	return -1;
}


#[inline(always)]
const fn check(haystack: &[u8], needle: &[u8], offset: usize) -> bool {
	let mut i = 0;
	while i < needle.len() {
		if haystack[offset + i] != needle[i] {
			return false;
		}
		i += 1;
	}
	return true;
}
#[inline(always)]
const fn max(a: usize) -> u8 {
	if a > 255 { 255 } else { a as u8 }
}

#[test]
fn test_position() {
	assert_eq!(position("ABCBC", "CBC"), 2..5);
	assert_eq!(position("ABCBC", "ABCBC"), 0..5);
}

#[test]
#[should_panic]
fn test_position_needle_longer_than_haystack() {
	let _ = position("haystack", "needleneedleneedle");
}

```

`src/wide.rs`:

```rs

/// Encodes the input string as a wide string (utf-16) constant.
///
/// The type of the returned constant is `&'static [u16; LEN]`.
///
/// # Examples
///
/// ```
/// let expected = &['W' as u16, 'i' as u16, 'd' as u16, 'e' as u16, 0];
/// assert_eq!(expected, obfstr::wide!("Wide\0"));
/// ```
#[macro_export]
macro_rules! wide {
	($s:expr) => {{
		const _WIDE_STRING: &str = $s;
		const _WIDE_LEN: usize = $crate::wide::len(_WIDE_STRING);
		const _WIDE_WORDS: [u16; _WIDE_LEN] = $crate::wide::encode::<_WIDE_LEN>(_WIDE_STRING);
		&_WIDE_WORDS
	}};
}

const fn next(bytes: &[u8]) -> Option<(u32, &[u8])> {
	match bytes {
		&[a, ref tail @ ..] if a & 0x80 == 0x00 =>
			Some((a as u32, tail)),
		&[a, b, ref tail @ ..] if a & 0xe0 == 0xc0 =>
			Some(((a as u32 & 0x1f) << 6 | (b as u32 & 0x3f), tail)),
		&[a, b, c, ref tail @ ..] if a & 0xf0 == 0xe0 =>
			Some(((a as u32 & 0x0f) << 12 | (b as u32 & 0x3f) << 6 | (c as u32 & 0x3f), tail)),
		&[a, b, c, d, ref tail @ ..] if a & 0xf8 == 0xf0 =>
			Some(((a as u32 & 0x07) << 18 | (b as u32 & 0x3f) << 12 | (c as u32 & 0x3f) << 6 | (d as u32 & 0x3f), tail)),
		&[..] => None,
	}
}

#[doc(hidden)]
pub const fn len(s: &str) -> usize {
	let mut bytes = s.as_bytes();
	let mut len = 0;
	while let Some((chr, tail)) = next(bytes) {
		bytes = tail;
		len += if chr >= 0x10000 { 2 } else { 1 };
	}
	return len;
}

#[doc(hidden)]
pub const fn encode<const LEN: usize>(s: &str) -> [u16; LEN] {
	let mut bytes = s.as_bytes();
	let mut data = [0u16; LEN];
	let mut i = 0usize;
	while let Some((chr, tail)) = next(bytes) {
		bytes = tail;
		if chr >= 0x10000 {
			data[i + 0] = (0xD800 + (chr - 0x10000) / 0x400) as u16;
			data[i + 1] = (0xDC00 + (chr - 0x10000) % 0x400) as u16;
			i += 2;
		}
		else {
			data[i] = chr as u16;
			i += 1;
		}
	}
	return data;
}

#[test]
fn test_example() {
	let text = &['e' as u16, 'x' as u16, 'a' as u16, 'm' as u16, 'p' as u16, 'l' as u16, 'e' as u16];
	assert_eq!(text, wide!("example"));
}

#[test]
fn test_escapes() {
	let text = &['\t' as u16, '\n' as u16, '\r' as u16, '\\' as u16, '\0' as u16, '\'' as u16, '\"' as u16, '\x52' as u16, '\u{00B6}' as u16];
	assert_eq!(text, wide!("\t\n\r\\\0\'\"\x52\u{00B6}"));
}

#[test]
fn test_raw() {
	let text = &[b'\\' as u16];
	assert_eq!(text, wide!(r"\"));
	assert_eq!(text, wide!(r#"\"#));
	assert_eq!(text, wide!(r##"\"##));
}

#[test]
fn test_const() {
	const STRING: &str = "Wide\0";
	let text = &['W' as u16, 'i' as u16, 'd' as u16, 'e' as u16, 0];
	assert_eq!(text, wide!(STRING));
}

```

`src/words.rs`:

```rs
/*!
Wide string obfuscation
=======================
*/

/// Compiletime wide string constant obfuscation.
#[macro_export]
macro_rules! obfwide {
	($(let $name:ident = $s:expr;)*) => {
		$(let ref $name = $crate::__obfwide!($s);)*
	};
	($name:ident = $s:expr) => {{
		$name = $crate::__obfwide!($s);
		&$name
	}};
	($buf:ident <- $s:expr) => {{
		let buf = &mut $buf[..$s.len()];
		buf.copy_from_slice(&$crate::__obfwide!($s));
		buf
	}};
	($s:expr) => {
		&$crate::__obfwide!($s)
	};
}

#[doc(hidden)]
#[macro_export]
macro_rules! __obfwide {
	($s:expr) => {{
		const _OBFWIDE_STRING: &[u16] = $crate::wide!($s);
		const _OBFWIDE_LEN: usize = _OBFWIDE_STRING.len();
		const _OBFWIDE_KEYSTREAM: [u16; _OBFWIDE_LEN] = $crate::words::keystream::<_OBFWIDE_LEN>($crate::__entropy!("key", stringify!($s)) as u32);
		static _OBFWIDE_SDATA: [u16; _OBFWIDE_LEN] = $crate::words::obfuscate::<_OBFWIDE_LEN>(_OBFWIDE_STRING, &_OBFWIDE_KEYSTREAM);
		$crate::words::deobfuscate::<_OBFWIDE_LEN>(
			$crate::__xref!(
				$crate::__entropy!("offset", stringify!($s)) as usize,
				$crate::__entropy!("xref", stringify!($s)),
				&_OBFWIDE_SDATA),
			&_OBFWIDE_KEYSTREAM)
	}};
}

// Simple XorShift to generate the key stream.
// Security doesn't matter, we just want a number of random-looking bytes.
#[inline(always)]
const fn next_round(mut x: u32) -> u32 {
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	x
}

/// Generate the key stream for array of given length.
#[inline(always)]
pub const fn keystream<const LEN: usize>(key: u32) -> [u16; LEN] {
	let mut keys = [0u16; LEN];
	let mut round_key = key;
	let mut i = 0;
	// Calculate the key stream in chunks of 4 bytes
	while i < LEN & !1 {
		round_key = next_round(round_key);
		let kb = round_key.to_ne_bytes();
		keys[i + 0] = u16::from_ne_bytes([kb[0], kb[1]]);
		keys[i + 1] = u16::from_ne_bytes([kb[2], kb[3]]);
		i += 2;
	}
	// Calculate the remaining words of the key stream
	if LEN % 2 != 0 {
		round_key = next_round(round_key);
		keys[i] = round_key as u16;
	}
	keys
}

/// Obfuscates the input string and given key stream.
pub const fn obfuscate<const LEN: usize>(s: &[u16], k: &[u16; LEN]) -> [u16; LEN] {
	if s.len() != LEN {
		panic!("input string len not equal to key stream len");
	}
	let mut data = [0u16; LEN];
	let mut i = 0usize;
	while i < LEN {
		data[i] = s[i] ^ k[i];
		i += 1;
	}
	data
}

/// Deobfuscates the obfuscated input string and given key stream.
#[inline(always)]
pub fn deobfuscate<const LEN: usize>(s: &[u16; LEN], k: &[u16; LEN]) -> [u16; LEN] {
	let mut buffer = [0u16; LEN];
	let mut i = 0;
	// Try to tickle the LLVM optimizer in _just_ the right way
	// Use `read_volatile` to avoid constant folding a specific read and optimize the rest
	// Volatile reads of any size larger than 8 bytes appears to cause a bunch of one byte reads
	// Hand optimize in chunks of 8 and 4 bytes to avoid this
	unsafe {
		use ::core::ptr::{read_volatile, write};
		let src = s.as_ptr();
		let dest = buffer.as_mut_ptr();
		// Process in chunks of 8 bytes on 64-bit targets
		#[cfg(target_pointer_width = "64")]
		while i < LEN & !3 {
			let ct = read_volatile(src.offset(i as isize) as *const [u16; 4]);
			let tmp = [
				ct[0] ^ k[i + 0],
				ct[1] ^ k[i + 1],
				ct[2] ^ k[i + 2],
				ct[3] ^ k[i + 3],
			];
			write(dest.offset(i as isize) as *mut [u16; 4], tmp);
			i += 4;
		}
		// Process in chunks of 4 bytes
		while i < LEN & !1 {
			let ct = read_volatile(src.offset(i as isize) as *const [u16; 2]);
			let tmp = [
				ct[0] ^ k[i + 0],
				ct[1] ^ k[i + 1],
			];
			write(dest.offset(i as isize) as *mut [u16; 2], tmp);
			i += 2;
		}
		// Process the remaining bytes
		if LEN % 2 != 0 {
			let ct = read_volatile(src.offset(i as isize));
			write(dest.offset(i as isize), ct ^ k[i]);
		}
	}
	buffer
}

// Test correct processing of less than multiple of 8 lengths
#[test]
fn test_remaining_bytes() {
	const STRING: &[u16] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
	fn test<const LEN: usize>(key: u32) {
		let keys = keystream::<LEN>(key);
		let data = obfuscate::<LEN>(&STRING[..LEN], &keys);
		let buffer = deobfuscate::<LEN>(&data, &keys);
		// Ciphertext should not equal input string
		assert_ne!(&data[..], &STRING[..LEN]);
		// Deobfuscated result should equal input string
		assert_eq!(&buffer[..], &STRING[..LEN]);
	}
	test::<8>(0x1111);
	test::<9>(0x2222);
	test::<10>(0x3333);
	test::<11>(0x4444);
	test::<12>(0x5555);
	test::<13>(0x6666);
	test::<14>(0x7777);
	test::<15>(0x8888);
	test::<16>(0x9999);
}

#[test]
fn test_obfstr_let() {
	obfwide! {
		let hello = "hello";
		let world = "world";
	}
	assert_eq!(hello, crate::wide!("hello"));
	assert_eq!(world, crate::wide!("world"));
}

#[test]
fn test_obfstr_const() {
	const LONG_STRING: &str = "This literal is very very very long to see if it correctly handles long strings";
	assert_eq!(obfwide!(LONG_STRING), crate::wide!(LONG_STRING));

	const ABC: &str = "ABC";
	const WORLD: &str = "üåç";

	assert_eq!(obfwide!(ABC), &[b'A' as u16, b'B' as u16, b'C' as u16]);
	assert_eq!(obfwide!(WORLD), &[0xd83c, 0xdf0d]);
}

```

`src/xref.rs`:

```rs
use core::{hint, ptr};

/// Obfuscates the xref to static data.
///
/// ```
/// static FOO: i32 = 42;
/// let foo = obfstr::xref!(&FOO);
///
/// // When looking at the disassembly the reference to `FOO` has been obfuscated.
/// assert_eq!(foo as *const _, &FOO as *const _);
/// ```
#[macro_export]
macro_rules! xref {
	($e:expr) => {
		$crate::__xref!($crate::__entropy!(stringify!($e), 1) as usize, $crate::__entropy!(stringify!($e), 2), $e)
	};
}
#[doc(hidden)]
#[macro_export]
macro_rules! __xref {
	($offset:expr, $seed:expr, $e:expr) => {{
		const _XREF_OFFSET: usize = $offset;
		static mut _XREF_STATIC_MUT_OFFSET: usize = _XREF_OFFSET;
		$crate::xref::xref::<_, _XREF_OFFSET, {$seed}>($e, unsafe { &mut _XREF_STATIC_MUT_OFFSET })
	}};
}

#[inline(always)]
const fn non_zero(rand: usize) -> usize {
	if rand == 0 { 1 } else { rand }
}

#[inline(always)]
const fn obfchoice(v: usize, seed: u64) -> usize {
	let rand = (seed >> 32) as i32 as usize;
	match seed & 7 {
		0 => v.wrapping_add(rand),
		1 => rand.wrapping_sub(v),
		2 => v ^ rand,
		3 => v.rotate_left(non_zero(rand & 7) as u32),
		4 => !v,
		5 => v ^ (v >> non_zero(rand & 31)),
		6 => v.wrapping_mul(non_zero(rand)),
		7 => v.wrapping_neg(),
		_ => unsafe { hint::unreachable_unchecked() }
	}
}
#[inline(always)]
const fn obfuscate(mut v: usize, mut seed: u64) -> usize {
	use crate::splitmix;
	seed = splitmix(seed);
	v = obfchoice(v, seed);
	seed = splitmix(seed);
	v = obfchoice(v, seed);
	seed = splitmix(seed);
	v = obfchoice(v, seed);
	seed = splitmix(seed);
	v = obfchoice(v, seed);
	seed = splitmix(seed);
	return obfchoice(v, seed & 0xffffffff00000000 | 3) & 0xffff
}

/// Obfuscates the xref to static data.
#[inline(always)]
pub fn xref<T: ?Sized, const OFFSET: usize, const SEED: u64>(p: &'static T, offset: &'static usize) -> &'static T {
	unsafe {
		let mut p: *const T = p;
		// To avoid LLMV optimizing away the obfuscation, launder it through read_volatile
		let val = ptr::read_volatile(&(p as *const u8).wrapping_sub(obfuscate(OFFSET, SEED))).wrapping_add(obfuscate(ptr::read_volatile(offset), SEED));
		// set_ptr_value
		*(&mut p as *mut *const T as *mut *const u8) = val;
		&*p
	}
}

/// Obfuscates the xref to static data.
///
/// ```
/// static mut FOO: i32 = 42;
/// let foo = obfstr::xref_mut!(unsafe { &mut FOO });
///
/// // When looking at the disassembly the reference to `FOO` has been obfuscated.
/// assert_eq!(foo as *mut _, unsafe { &mut FOO } as *mut _);
/// ```
#[macro_export]
macro_rules! xref_mut {
	($e:expr) => { $crate::__xref_mut!($crate::__entropy!(stringify!($e), 1) as usize, $crate::__entropy!(stringify!($e), 2), $e) };
}
#[doc(hidden)]
#[macro_export]
macro_rules! __xref_mut {
	($offset:expr, $seed:expr, $e:expr) => {{
		const _XREF_OFFSET: usize = $offset;
		static mut _XREF_STATIC_MUT_OFFSET: usize = _XREF_OFFSET;
		$crate::xref::xref_mut::<_, _XREF_OFFSET, {$seed}>($e, unsafe { &mut _XREF_STATIC_MUT_OFFSET })
	}};
}

/// Obfuscates the xref to static data.
#[inline(always)]
pub fn xref_mut<T: ?Sized, const OFFSET: usize, const SEED: u64>(p: &'static mut T, offset: &'static usize) -> &'static mut T {
	unsafe {
		let mut p: *mut T = p;
		// To avoid LLMV optimizing away the obfuscation, launder it through read_volatile
		let val = ptr::read_volatile(&(p as *mut u8).wrapping_sub(obfuscate(OFFSET, SEED))).wrapping_add(obfuscate(ptr::read_volatile(offset), SEED));
		// set_ptr_value
		*(&mut p as *mut *mut T as *mut *mut u8) = val;
		&mut *p
	}
}

#[test]
fn test_xref_slice() {
	static FOO: [i32; 42] = [13; 42];
	let foo = xref!(&FOO[..]);
	assert_eq!(foo as *const _, &FOO as *const _);
}

#[test]
fn regression1() {
	// Caused by `v = v ^ (v >> RNG)` when RNG is zero to always be zero
	let v = obfuscate(4898264233338431333usize, (-4272872662024917058i64) as u64);
	assert_ne!(v, 0);
}

```