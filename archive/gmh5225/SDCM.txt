Project Path: arc_gmh5225_SDCM_rm6phn1v

Source Tree:

```txt
arc_gmh5225_SDCM_rm6phn1v
├── LICENSE
├── README.md
├── SECURITY.md
├── Scripts
│   ├── Attestation.ps1
│   ├── HLKx.ps1
│   └── ShippingLabel.ps1
├── SurfaceDevCenterManager
│   ├── App.config
│   ├── ErrorCodes.cs
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── SurfaceDevCenterManager.csproj
│   ├── SurfaceDevCenterManager.ruleset
│   ├── Utility
│   │   └── DevCenterCredentialsHandler.cs
│   └── authconfig.json
├── SurfaceDevCenterManager.sln
├── azure-pipelines-ci.yml
├── azure-pipelines.yml
└── build
    └── Set-AssemblyInfo.ps1

```

`LICENSE`:

```
    MIT License

    Copyright (c) Microsoft Corporation. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE

```

`README.md`:

```md
# __Surface Dev Center Manager (SDCM)__

Surface Dev Center Manager (SDCM) is a tool that utilizes the REST APIs made available by Microsoft Partner Center (a.k.a. Hardware Dev Center) to automate many common tasks for hardware development and maintenance around driver and firmware management.

**SDCM** enables you to create `Attestation` and `WHQL` products, submissions, download the resulting signed packages, and manage shipping labels to release software on Windows Update.

> This tool is based on the
[Hardware Dashboard API](https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/dashboard-api). Detailed options are available with the `-?`, `-h` or `-help` option at the command line.

<br/>

# Getting Started
1. Clone the repo
1. Follow the steps here to [setup your app](https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/dashboard-api#associate-an-azure-ad-application-with-your-windows-dev-center-account) to get credentials
1. Edit authconfig.json to the appropriate values after your app was set up
    - Change clientId, tenantId and key to match the values from your app registration
    - You should not have to change the url or urlPrefix
1. Build the project

<br/>

# Input Json Formats
> Please refer to the [Hardware Dashboard API](https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/dashboard-api) documentation for detailed information on each of the settings below.  This sample is targeted for a RS4 HLK submission and shipping label.

## Creating a Product
```json
{
    "createType": "product",
    "createProduct": {
        "productName": "ProductName_HLK",
        "testHarness": "HLK",
        "announcementDate": "2023-01-01T00:00:00",
        "deviceMetadataIds": null,
        "firmwareVersion": "0",
        "deviceType": "external",
        "isTestSign": false,
        "isFlightSign": false,
        "marketingNames": null,
        "selectedProductTypes": {
            "windows_v100_RS4": "Unclassified"
        },
        "requestedSignatures": [
            "WINDOWS_v100_X64_RS4_FULL"
        ],
        "additionalAttributes": null
    }
}
```

> For an Attestation submission, change testHarness to Attestation.

<br/>

## Creating a Submission
```json
{
    "createType": "submission",
    "createSubmission": {
        "name": "ProductName_HLK_Submission",
        "type":  "initial"
     }
 }
```

<br/>

## Creating a Shipping Label
```json
{
    "createType": "shippingLabel",
    "createShippingLabel": {
        "publishingSpecifications": {
            "goLiveDate": "2023-01-01T00:00:00.000Z",
            "visibleToAccounts": [],
            "isAutoInstallDuringOSUpgrade": true,
            "isAutoInstallOnApplicableSystems": true,
            "manualAcquisition": false,
            "isDisclosureRestricted": true,
            "publishToWindows10s": false,
            "additionalInfoForMsApproval": {
                "microsoftContact": "contact@microsoft.com",
                "validationsPerformed": "TBD",
                "affectedOems": [
                    "Your Company"
                ],
                "isRebootRequired": true,
                "isCoEngineered": true,
                "isForUnreleasedHardware": true,
                "hasUiSoftware": false,
                "businessJustification": "Driver Update"
            }
        },
        "targeting": {
            "hardwareIds": [
                {
                    "bundleId": "0",
                    "infId": "empty.inf",
                    "operatingSystemCode": "WINDOWS_v100_RS4_FULL",
                    "pnpString": "empty pnp"
                }
            ],
            "chids": [
                {
                    "chid": "guid",
                    "distributionState": "pendingAdd"
                }
            ],
            "restrictedToAudiences": [],
            "inServicePublishInfo": {
                "flooring": "",
                "ceiling": ""
            }
        },
        "name": "ProductName_HLK_ShippingLabel",
        "destination": "windowsUpdate"
    }
}
```

> Note that SDCM will auto-populate and publish all hardware IDs found in a Submission when creating a Shipping Label.

---
<br/>

# Basic Operations
## Create a Product
Create a json file '`Create_ProductName_HLK.json`' using the Product json example above.
```bash
sdcm.exe -create Create_ProductName_HLK.json
```

> This will output a Product ID (PID) if successful

---
<br/>

## List the Product
Verify the product was created by listing the details.
```bash
sdcm.exe -list product -productid PID
```

---
<br/>

## Create a Submission
Create a json file '`Create_ProductName_Submission_HLK.json`' using the Submission json example above.
```bash
sdcm.exe -create Create_ProductName_Submission_HLK.json -productid PID
```

> This will output a Submission ID (SID) if successful

---
<br/>

## List the Submission
List all the submissions for the product
```bash
sdcm.exe -list submission -productid PID
```

List a specific submission for the product
```bash
sdcm.exe -list submission -productid PID -submissionid SID
```

---
<br/>

## Upload a package to a Submission
Make sure the package (`.cab` or `.hlkx`) is signed by the [Extended Validation Certificate (EV Cert)](https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/get-a-code-signing-certificate) registered with your Partner Center *Hardware* Account
```bash
sdcm.exe -upload test.hlkx -productid PID -submissionid SID
```

---
<br/>

## Commit a Submission
When everything is ready to start processing the submission, commit it
```bash
sdcm.exe -commit -productid PID -submissionid SID
```

---
<br/>

## Wait for a Submission to be Ready
```bash
sdcm.exe -wait -productid PID -submissionid SID
```

---
<br/>

## Download files from a Submission
```bash
sdcm.exe -download hlksigned.zip -productid PID -submissionid SID
```

---
<br/>

# WHQL signing a Driver
> See `HLKx.ps1` in the Scripts folder.

---
<br/>

# Attestation signing a Driver
> See `Attestation.ps1` in the Scripts folder.

---
<br/>

# Creating a Shipping Label
> See `ShippingLabel.ps1` in the Scripts folder.

---
<br/>

# Contributing
This project welcomes contributions and suggestions.  Most contributions require you to agree to a
Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us
the rights to use your contribution. For details, visit https://cla.microsoft.com.

When you submit a pull request, a CLA-bot will automatically determine whether you need to provide
a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions
provided by the bot. You will only need to do this once across all repos using our CLA.

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).
For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or
contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.

```

`SECURITY.md`:

```md
<!-- BEGIN MICROSOFT SECURITY.MD V0.0.7 BLOCK -->

## __Security__

Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet), [Xamarin](https://github.com/xamarin), and [our GitHub organizations](https://opensource.microsoft.com/).

If you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/opensource/security/definition), please report it to us as described below.

---
<br/>

## __Reporting Security Issues__

**Please do not report security vulnerabilities through public GitHub issues.**

Instead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/opensource/security/create-report).

If you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/opensource/security/pgpkey).

You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://aka.ms/opensource/security/msrc).

Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:

  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)
  * Full paths of source file(s) related to the manifestation of the issue
  * The location of the affected source code (tag/branch/commit or direct URL)
  * Any special configuration required to reproduce the issue
  * Step-by-step instructions to reproduce the issue
  * Proof-of-concept or exploit code (if possible)
  * Impact of the issue, including how an attacker might exploit the issue

This information will help us triage your report more quickly.

If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/opensource/security/bounty) page for more details about our active programs.

---
<br/>

## __Preferred Languages__

We prefer all communications to be in English.

---
<br/>

## __Policy__

Microsoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/opensource/security/cvd).

<!-- END MICROSOFT SECURITY.MD BLOCK -->

```

`Scripts/Attestation.ps1`:

```ps1
#-------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation.  All rights reserved.
# Licensed under the MIT license.  See LICENSE file in the project root for full license information.
#-------------------------------------------------------------------------------
<#
.SYNOPSIS
    Script to use Surface Dev Center Manager to Attestation sign a driver package

.PARAMETER ProductName
    Product Name to use for the driver, visible in Hardware Dev Center

.PARAMETER Signatures
    OS Version and Architecture to submit the driver for

.PARAMETER InputPath
    Path to the EV-signed cab file needed for an Attestation-signed driver
    See steps here:
    https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/attestation-signing-a-kernel-driver-for-public-release
#>
#Requires -Version 5.0

param(
  [Parameter(Mandatory = $true, Position = 0)]
  [string] $ProductName,

  [Parameter(Mandatory = $true, Position = 1)]
  [ValidateSet("WINDOWS_v100_X64_RS3_FULL", "WINDOWS_v100_X64_RS4_FULL")]
  [string[]] $Signatures,

  [Parameter(Mandatory = $true, Position = 2)]
  [ValidateScript( { Test-Path -Path $_ -PathType Leaf })]
  [string] $InputPath
)

###################################################################################################
# Global Error Handler
###################################################################################################
trap {
  Write-Output "----- TRAP ----"
  Write-Output "Unhandled Exception: $($_.Exception.GetType().Name)"
  Write-Output $_.Exception
  $_ | Format-List -Force
}

###################################################################################################
# Globals
###################################################################################################
$global:ErrorActionPreference = "stop"
Set-StrictMode -Version Latest
$SCDM = ".\sdcm.exe"

###################################################################################################
# Functions
###################################################################################################
$CreateSubmissionForAttestationJson = @"
{
  "createType": "submission",
  "createSubmission": {
    "name": "$ProductName`_Attestation_Submission",
    "type": "initial"
  }
}
"@

$CreateProductForAttestationJson = @"
{
  "createType": "product",
  "createProduct": {
    "productName": "$ProductName`_Attestation",
    "testHarness": "Attestation",
    "announcementDate": "2018-04-01T00:00:00",
    "deviceMetadataIds": null,
    "firmwareVersion": "0",
    "deviceType": "external",
    "isTestSign": false,
    "isFlightSign": false,
    "marketingNames": null,
    "selectedProductTypes": { "windows_v100_RS4": "Unclassified" },
    "requestedSignatures": [ "WINDOWS_v100_X64_RS4_FULL" ],
    "additionalAttributes": null
  }
}
"@

###################################################################################################
# Main
###################################################################################################

Write-Output "Attestation Submission"
Write-Output ""

Write-Output "> Create Product"
$SDCM_PID = ""
Write-Output "    * Create JSON"
$json = $CreateProductForAttestationJson | ConvertFrom-Json
$json.createProduct.productName = "$ProductName`_Attestation"
$json.createProduct.announcementDate = (Get-Date).AddDays(7).ToString("s")
$json.createProduct.requestedSignatures = $Signatures
$json | ConvertTo-Json | Out-File -Encoding ASCII -FilePath "CreateAttest.json"
Write-Output "    * Submit"
$output = & $SCDM -create CreateAttest.json

if (-not ([string]$output -match "--- Product: (\d+)")) {
  Write-Output "Did not find product ID"
  Write-Output $output
  return -1
}
$SDCM_PID = $Matches[1]
Write-Output "    * PID: $SDCM_PID"

Write-Output "> Create Submission"
Write-Output "    * Create JSON"
$json = $CreateSubmissionForAttestationJson | ConvertFrom-Json
$json.createSubmission.name = "$ProductName`_Attestation_Submission"
$json | ConvertTo-Json | Out-File -Encoding ASCII -FilePath "CreateSubmissionAttest.json"
Write-Output "    * Submit"
$output = & $SCDM -create CreateSubmissionAttest.json -productid $SDCM_PID

if (-not ([string]$output -match "---- Submission: (\d+)")) {
  Write-Output "Did not find submission ID"
  Write-Output $output
  return -1
}
$SDCM_SID = $Matches[1]
Write-Output "    * SID: $SDCM_SID"

Write-Output "> Upload File"
& $SCDM -upload $InputPath -productid $SDCM_PID -submissionid $SDCM_SID

Write-Output "> Commit Submission"
& $SCDM -commit -productid $SDCM_PID -submissionid $SDCM_SID

Write-Output "> Wait for Submission to complete"
Write-Output "    * Dev Center URL: https://developer.microsoft.com/en-us/dashboard/hardware/driver/$SDCM_PID"
Write-Output "    * PID: $SDCM_PID"
Write-Output "    * SID: $SDCM_SID"
& $SCDM -wait -productid $SDCM_PID -submissionid $SDCM_SID

Write-Output "> Download File"
& $SCDM -productid $SDCM_PID -submissionid $SDCM_SID -download $InputPath`.signed`.zip

Write-Output "> Done"
Write-Output "    * Output: $InputPath`.signed`.zip"


```

`Scripts/HLKx.ps1`:

```ps1
#-------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation.  All rights reserved.
# Licensed under the MIT license.  See LICENSE file in the project root for full license information.
#-------------------------------------------------------------------------------
<#
.SYNOPSIS
    Script to use Surface Dev Center Manager to get a WHQL signed driver from a HLKx package

.PARAMETER ProductName
    Product Name to use for the driver, visible in Hardware Dev Center

.PARAMETER Signatures
    OS Version and Architecture to submit the driver for

.PARAMETER InputPath
    Path to the EV-signed HLKx file needed for an WHQL-signed driver
    See steps here:
    https://docs.microsoft.com/en-us/windows-hardware/test/hlk/user/digitally-sign-an-hlkx-package
#>
#Requires -Version 5.0

param(
  [Parameter(Mandatory = $true, Position = 0)]
  [string] $ProductName,

  [Parameter(Mandatory = $true, Position = 1)]
  [ValidateSet("WINDOWS_v100_X64_RS3_FULL", "WINDOWS_v100_X64_RS4_FULL")]
  [string[]] $Signatures,

  [Parameter(Mandatory = $true, Position = 2)]
  [ValidateScript( { Test-Path -Path $_ -PathType Leaf })]
  [string] $InputFile
)

###################################################################################################
# Global Error Handler
###################################################################################################
trap {
  Write-Output "----- TRAP ----"
  Write-Output "Unhandled Exception: $($_.Exception.GetType().Name)"
  Write-Output $_.Exception
  $_ | Format-List -Force
}

###################################################################################################
# Globals
###################################################################################################
$global:ErrorActionPreference = "stop"
Set-StrictMode -Version Latest
$SCDM = ".\sdcm.exe"

###################################################################################################
# Functions
###################################################################################################
$CreateSubmissionForHLKxJson = @"
{
  "createType": "submission",
  "createSubmission": {
    "name": "$ProductName`_HLK_Submission",
    "type": "initial"
  }
}
"@

$CreateProductForHLKxJson = @"
{
  "createType": "product",
  "createProduct": {
    "productName": "$ProductName`_HLK",
    "testHarness": "HLK",
    "announcementDate": "2018-04-01T00:00:00",
    "deviceMetadataIds": null,
    "firmwareVersion": "0",
    "deviceType": "external",
    "isTestSign": false,
    "isFlightSign": false,
    "marketingNames": null,
    "selectedProductTypes": { "windows_v100_RS4": "Unclassified" },
    "requestedSignatures": [ "WINDOWS_v100_X64_RS4_FULL" ],
    "additionalAttributes": null
  }
}
"@

###################################################################################################
# Main
###################################################################################################

Write-Output "HLK Submission"
Write-Output ""

Write-Output "> Create Product"
$SDCM_PID = ""
Write-Output "    * Create JSON"
$json = $CreateProductForHLKxJson | ConvertFrom-Json
$json.createProduct.productName = "$ProductName`_HLK"
$json.createProduct.announcementDate = (Get-Date).AddDays(7).ToString("s")
$json.createProduct.requestedSignatures = $Signatures
$json | ConvertTo-Json | Out-File -Encoding ASCII -FilePath "CreateHLK.json"
Write-Output "    * Submit"
$output = & $SCDM -create CreateHLK.json

if (-not ([string]$output -match "--- Product: (\d+)")) {
  Write-Output "Did not find product ID"
  Write-Output $output
  return -1
}
$SDCM_PID = $Matches[1]
Write-Output "    * PID: $SDCM_PID"

Write-Output "> Create Submission"
Write-Output "    * Create JSON"
$json = $CreateSubmissionForHLKxJson | ConvertFrom-Json
$json.createSubmission.name = "$ProductName`_HLK_Submission"
$json | ConvertTo-Json | Out-File -Encoding ASCII -FilePath "CreateSubmissionHLK.json"
Write-Output "    * Submit"
$output = & $SCDM -create CreateSubmissionHLK.json -productid $SDCM_PID

if (-not ([string]$output -match "---- Submission: (\d+)")) {
  Write-Output "Did not find submission ID"
  Write-Output $output
  return -1
}
$SDCM_SID = $Matches[1]
Write-Output "    * SID: $SDCM_SID"

Write-Output "> Upload File"
& $SCDM -upload $InputFile -productid $SDCM_PID -submissionid $SDCM_SID

Write-Output "> Commit Submission"
& $SCDM -commit -productid $SDCM_PID -submissionid $SDCM_SID

Write-Output "> Wait for Submission to complete"
Write-Output "    * Dev Center URL: https://developer.microsoft.com/en-us/dashboard/hardware/driver/$SDCM_PID"
Write-Output "    * PID: $SDCM_PID"
Write-Output "    * SID: $SDCM_SID"
& $SCDM -wait -productid $SDCM_PID -submissionid $SDCM_SID

Write-Output "> Download File"
& $SCDM -productid $SDCM_PID -submissionid $SDCM_SID -download $InputFile`.signed`.zip

Write-Output "> Done"
Write-Output "    * Output: $InputFile`.signed`.zip"


```

`Scripts/ShippingLabel.ps1`:

```ps1
#-------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation.  All rights reserved.
# Licensed under the MIT license.  See LICENSE file in the project root for full license information.
#-------------------------------------------------------------------------------
<#
.SYNOPSIS
    Script to use Surface Dev Center Manager to create a Shipping Label from a Submission

.PARAMETER ProductId
    Product ID of the Submission to make a Shipping Label for

.PARAMETER SubmissionId
    Submission ID of the Submission to make a Shipping Label for

.PARAMETER CHIDs
    Array of Computer Hardware IDs (CHIDs) to target the driver at a specific set of devices

.PARAMETER IsManualAcquistion
    In PublishingSpecifications if isAutoInstallDuringOSUpgrade or isAutoInstallOnApplicableSystems is true, then ManualAcquistion must be false
    In PublishingSpecifications if isAutoInstallDuringOSUpgrade and isAutoInstallOnApplicableSystems are false, then ManualAcquistion must be true

.PARAMETER Audiences
    Array of Audience IDs the publication should be restricted to

.PARAMETER Floor
    Lowest OS the driver is available for

.PARAMETER Ceiling
    Highest OS the driver is available for
#>
#Requires -Version 5.0

param(
  [Parameter(Mandatory = $true, Position = 0)]
  [string] $ProductId,

  [Parameter(Mandatory = $true, Position = 1)]
  [string] $SubmissionId,

  [Parameter(Mandatory = $true, Position = 2)]
  [string[]] $CHIDs,

  [Parameter(Mandatory = $false, Position = 3)]
  [bool] $ManualAcquistion = $false,

  [Parameter(Mandatory = $false, Position = 4)]
  [string[]] $Audiences,

  [Parameter(Mandatory = $false, Position = 5)]
  [string] $Floor = "19H1",

  [Parameter(Mandatory = $false, Position = 6)]
  [string] $Ceiling = "19H1"
)

###################################################################################################
# Global Error Handler
###################################################################################################
trap {
  Write-Output "----- TRAP ----"
  Write-Output "Unhandled Exception: $($_.Exception.GetType().Name)"
  Write-Output $_.Exception
  $_ | Format-List -Force
}

###################################################################################################
# Globals
###################################################################################################
$global:ErrorActionPreference = "stop"
Set-StrictMode -Version Latest
$SDCM = ".\sdcm.exe"

###################################################################################################
# Functions
###################################################################################################

###################################################################################################
# Main
###################################################################################################

Write-Output "Shipping Label"
Write-Output ""

Write-Output "> Wait for Driver Metadata to be ready"
& $SDCM -wait -waitmetadata -productid $ProductId -submissionid $SubmissionId

Write-Output "> Generate Shipping Label json"
$CreateShippingLabelJson = @"
{
  "createType": "shippingLabel",
  "createShippingLabel": {
      "publishingSpecifications": {
        "goLiveDate": "2018-10-02T00:00:00.000Z",
        "visibleToAccounts": [],
        "isAutoInstallDuringOSUpgrade": true,
        "isAutoInstallOnApplicableSystems": true,
        "manualAcquistion": $ManualAcquistion,
        "isDisclosureRestricted": true,
        "publishToWindows10s": false,
        "additionalInfoForMsApproval": {
          "microsoftContact": "contact@microsoft.com",
          "validationsPerformed": "TBD",
          "affectedOems": [
            "Your Company"
          ],
          "isRebootRequired": true,
          "isCoEngineered": true,
          "isForUnreleasedHardware": true,
          "hasUiSoftware": false,
          "businessJustification": "Driver Update"
        }
      },
    "targeting": {
      "hardwareIds": [
        {
          "bundleId": "0",
          "infId": "empty.inf",
          "operatingSystemCode": "WINDOWS_v100_RS4_FULL",
          "pnpString": "empty pnp"
        }
      ],
      "chids": [
        {
          "chid": "guid",
          "distributionState": "pendingAdd"
        }
      ],
      "restrictedToAudiences": $Audiences,
      "inServicePublishInfo": {
        "flooring": $Floor,
        "ceiling": $Ceiling
      }
    },
    "name": "$ProductName`_ShippingLabel",
    "destination": "windowsUpdate"
  }
}
"@
$CreateShippingLabelJson | Write-Host
$CreateShippingLabelJson | Out-File -encoding ASCII CreateShippingLabel.json

Write-Output "> Create Shipping Label"
$output = & $SDCM -create CreateShippingLabel.json -productid $ProductId -submissionid $SubmissionId
if (-not ([string]$output -match "---- Shipping Label: (\d+)")) {
  Write-Output "Did not find shipping label ID"
  Write-Output $output
  return -1
}
$ShippingLabelId = $Matches[1]
Write-Output "    * ShippingLabelId: $ShippingLabelId"

Write-Output "> Wait for Shipping Label"
& $SDCM -wait -productid $ProductId -submissionid $SubmissionId -shippinglabelid $ShippingLabelId

Write-Output "> Done"


```

`SurfaceDevCenterManager.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30517.126
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SurfaceDevCenterManager", "SurfaceDevCenterManager\SurfaceDevCenterManager.csproj", "{6D5FB1F6-29EB-49E4-9B10-CB60B30265F2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|AnyCPU = Debug|AnyCPU
		Release|AnyCPU = Release|AnyCPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6D5FB1F6-29EB-49E4-9B10-CB60B30265F2}.Debug|AnyCPU.ActiveCfg = Debug|Any CPU
		{6D5FB1F6-29EB-49E4-9B10-CB60B30265F2}.Debug|AnyCPU.Build.0 = Debug|Any CPU
		{6D5FB1F6-29EB-49E4-9B10-CB60B30265F2}.Release|AnyCPU.ActiveCfg = Release|Any CPU
		{6D5FB1F6-29EB-49E4-9B10-CB60B30265F2}.Release|AnyCPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E256CD1B-4950-40D3-9303-F6F68AD44EAC}
	EndGlobalSection
EndGlobal

```

`SurfaceDevCenterManager/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.1" />
    </startup>
  <runtime>
  </runtime>
</configuration>

```

`SurfaceDevCenterManager/ErrorCodes.cs`:

```cs
/*++
    Copyright (c) Microsoft Corporation. All rights reserved.

    Licensed under the MIT license.  See LICENSE file in the project root for full license information.
--*/

namespace SurfaceDevCenterManager
{
    internal enum ErrorCodes
    {
        SUCCESS = 0,
        UNSPECIFIED = -1,
        UNHANDLED_EXCEPTION = -2,
        COMMAND_LINE_OPTION_PARSING_FAILED = -3,
        NO_DEV_CENTER_CREDENTIALS_FOUND = -4,
        OVERRIDE_SERVER_INVALID = -5,
        CREATE_INPUT_FILE_DOES_NOT_EXIST = -6,
        NEW_PRODUCT_API_FAILED = -7,
        NEW_SUBMISSION_PRODUCT_ID_MISSING = -8,
        NEW_SUBMISSION_API_FAILED = -9,
        NEW_SHIPPING_LABEL_PRODUCT_ID_MISSING = -10,
        NEW_SHIPPING_LABEL_SUBMISSION_ID_MISSING = -11,
        NEW_SHIPPING_LABEL_CREATE_API_FAILED = -12,
        NEW_SHIPPING_LABEL_GET_SUBMISSION_API_FAILED = -13,
        COMMIT_PRODUCT_ID_MISSING = -14,
        COMMIT_SUBMISSION_ID_MISSING = -15,
        COMMIT_API_FAILED = -16,
        LIST_GET_PRODUCTS_API_FAILED = -17,
        LIST_GET_SUBMISSION_API_FAILED = -18,
        LIST_GET_SHIPPING_LABEL_API_FAILED = -19,
        DOWNLOAD_OUTPUT_PATH_NOT_EXIST = -20,
        DOWNLOAD_OUTPUT_FILE_ALREADY_EXISTS = -21,
        DOWNLOAD_PRODUCT_ID_MISSING = -22,
        DOWNLOAD_SUBMISSION_ID_MISSING = -23,
        DOWNLOAD_GET_SUBMISSION_API_FAILED = -24,
        METADATA_SUBMISSION_ID_MISSING = -25,
        METADATA_PRODUCT_ID_MISSING = -26,
        METADATA_GET_SUBMISSION_API_FAILED = -27,
        UPLOAD_PRODUCT_ID_MISSING = -28,
        UPLOAD_GET_SUBMISSION_API_FAILED = -29,
        UPLOAD_SUBMISSION_ID_MISSING = -30,
        WAIT_PRODUCT_ID_MISSING = -31,
        WAIT_SUBMISSION_ID_MISSING = -32,
        WAIT_GET_SUBMISSION_API_FAILED = -33,
        WAIT_SUBMISSION_FAILED_IN_HWDC = -34,
        WAIT_GET_SHIPPING_LABEL_API_FAILED = -35,
        WAIT_SHIPPING_LABEL_FAILED_IN_HWDC = -36,
        AUIDENCE_GET_AUDIENCE_API_FAILED = -37,
        LIST_GET_PARTNER_SUBMISSION_API_FAILED = -38,
        LIST_INVALID_OPTION = -39,
        CREATEMETADATA_PRODUCT_ID_MISSING = -40,
        CREATEMETADATA_SUBMISSION_ID_MISSING = -41,
        CREATEMETADATA_API_FAILED = -42,
        TRANSLATE_PRODUCT_ID_MISSING = -43,
        TRANSLATE_SUBMISSION_ID_MISSING = -44,
        TRANSLATE_PUBLISHER_ID_MISSING = -45,
        TRANSLATE_API_FAILED = -46,
        SUBMISSION_ENTITY_NOT_FOUND = -47,
        COMMIT_REQUEST_INVALID_FOR_CURRENT_STATE = -48,
        HTTP_429_RATE_LIMIT_EXCEEDED = -429,
        PARTNER_CENTER_HTTP_EXCEPTION = -1000
    }

    // https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/get-product-data#error-codes
    internal static class ErrorCodeConstants
    {
        public const string EntityNotFound = "entityNotFound";
        public const string RequestInvalidForCurrentState = "requestInvalidForCurrentState";
    }

    //
    internal static class ErrorMessageConstants
    {
        public const string OnlyPendingSubmissionsCanBeCommitted = "Only pending submissions can be committed.";
        public const string InitialSubmissionAlreadyExists = "Initial submission already exists";
    }
}

```

`SurfaceDevCenterManager/Program.cs`:

```cs
/*++
    Copyright (c) Microsoft Corporation. All rights reserved.

    Licensed under the MIT license.  See LICENSE file in the project root for full license information.
--*/
using Microsoft.Devices.HardwareDevCenterManager;
using Microsoft.Devices.HardwareDevCenterManager.DevCenterApi;
using Microsoft.Devices.HardwareDevCenterManager.Utility;
using Mono.Options;
using Newtonsoft.Json;
using SurfaceDevCenterManager.Utility;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;

namespace SurfaceDevCenterManager
{
    public enum DevCenterHWSubmissionType
    {
        ShippingLabel = 0,
        Product = 1,
        Submission = 2,
        PartnerSubmission = 3,
        Invalid
    };

    public class CreateInput
    {
        [JsonProperty("createType")]
        public DevCenterHWSubmissionType CreateType { get; set; }

        [JsonProperty("createProduct")]
        public NewProduct CreateProduct { get; set; }

        [JsonProperty("createSubmission")]
        public NewSubmission CreateSubmission { get; set; }

        [JsonProperty("createShippingLabel")]
        public NewShippingLabel CreateShippingLabel { get; set; }
    }

    internal class Program
    {
        private static int verbosity;
        private const uint DEFAULT_TIMEOUT = 5 * 60;
        private static Guid CorrelationId;
        private static DevCenterErrorDetails LastCommand;

        private static int Main(string[] args)
        {
            ErrorCodes result = ErrorCodes.UNSPECIFIED;

            CorrelationId = Guid.NewGuid();

            try
            {
                result = MainAsync(args).GetAwaiter().GetResult();
            }
            catch (Exception e)
            {
                Console.WriteLine("Unhandled Exception:");
                Console.WriteLine(e.ToString());
                Console.WriteLine("Last Command:");
                DevCenterErrorDetailsDump(LastCommand);
                result = ErrorCodes.UNHANDLED_EXCEPTION;
            }

            Console.WriteLine("Correlation Id: {0}", CorrelationId.ToString());
            Console.WriteLine("Return: {0} ({1})", (int)result, result.ToString());
            if (System.Diagnostics.Debugger.IsAttached)
            {
                //Break debugger to look at command line output before the window disappears
                System.Diagnostics.Debugger.Break();
            }
            return (int)result;
        }

        public static void LastCommandSet(DevCenterErrorDetails error)
        {
            LastCommand = error;
        }

        /// <summary>
        /// Processes command line args and calls into HWDC
        /// </summary>
        /// <returns>Returns 0 success, non-zero on error</returns>
        private static async Task<ErrorCodes> MainAsync(string[] args)
        {
            ErrorCodes retval = ErrorCodes.SUCCESS;
            bool show_help = false;
            string CreateOption = null;
            bool CommitOption = false;
            string ListOption = null;
            string ProductId = null;
            string SubmissionId = null;
            string ShippingLabelId = null;
            string PublisherId = null;
            string DownloadOption = null;
            string MetadataOption = null;
            string SubmissionPackagePath = null;
            bool WaitOption = false;
            bool WaitForMetaData = false;
            bool CreateMetaData = false;
            bool AudienceOption = false;
            int OverrideServer = 0;
            bool OverrideServerPresent = false;
            string CredentialsOption = null;
            string AADAuthenticationOption = null;
            string TimeoutOption = null;
            uint HttpTimeout = DEFAULT_TIMEOUT;
            bool TranslateOption = false;
            string AnotherPartnerId = null;

            OptionSet p = new OptionSet() {
                { "c|create=",         "Path to json file with configuration to create", v => CreateOption = v },
                { "commit",            "Commit submission with given ID", v => CommitOption = true },
                { "l|list=",           "List a shippinglabel, product, submission or partnersubmission", v => ListOption = v },
                { "u|upload=",         "Upload a package to a specific product and submission", v => SubmissionPackagePath = v },
                { "productid=",        "Specify a specific ProductId", v => ProductId = v },
                { "submissionid=",     "Specify a specific SubmissionId", v => SubmissionId = v },
                { "shippinglabelid=",  "Specify a specific ShippingLabelId", v => ShippingLabelId = v },
                { "publisherid=",      "Specify a specific PublisherId", v => PublisherId = v },
                { "partnerid=",        "Specify PublisherId of the Partner to share the submission to via shipping label instead of Windows Update", v => AnotherPartnerId = v },
                { "v",                 "Increase debug message verbosity", v => { if (v != null) {++verbosity; }} },
                { "d|download=",       "Download a submission to current directory or folder specified", v => DownloadOption = v ?? Environment.CurrentDirectory },
                { "m|metadata=",       "Download a submission metadata to current directory or folder specified", v => MetadataOption = v ?? Environment.CurrentDirectory },
                { "h|help",            "Show this message and exit", v => show_help = v != null },
                { "w|wait",            "Wait for submission id to be done", v => WaitOption = true },
                { "waitmetadata",      "Wait for metadata to be done as well in a submission", v => WaitForMetaData = true },
                { "createmetadata",    "Request metadata creation for older submissions", v => CreateMetaData = true },
                { "a|audience",        "List Audiences", v => AudienceOption = true },
                { "server=",           "Specify target DevCenter server from CredSelect enum", v => { OverrideServer = int.Parse(v); OverrideServerPresent = true; }    },
                { "creds=",            "Option to specify app credentials.  Options: ENVOnly, ClientCredentials, ManagedIdentity, MiThenFile, FileOnly, AADOnly, AADThenFile (Default)", v => CredentialsOption = v },
                { "aad=",              "Option to specify AAD auth behavior.  Options: Never (Default), Prompt, Always, RefreshSession, SelectAccount", v => AADAuthenticationOption = v },
                { "t|timeout=",        $"Adjust the timeout for HTTP requests to specified seconds.  Default:{DEFAULT_TIMEOUT} seconds", v => TimeoutOption = v  },
                { "translate",         "Translate the given publisherid, productid and submissionid from a partner to the values visible in your HDC account", v => TranslateOption = true},
                { "?",                 "Show this message and exit", v => show_help = v != null },
            };

            Console.WriteLine("SurfaceDevCenterManager v" + Assembly.GetExecutingAssembly().GetName().Version);

            List<string> extra;
            try
            {
                extra = p.Parse(args);
            }
            catch (OptionException e)
            {
                ErrorParsingOptions(e.Message);
                Console.WriteLine("Try running with just '--help' for more information.");
                return ErrorCodes.COMMAND_LINE_OPTION_PARSING_FAILED;
            }

            if (show_help)
            {
                ShowHelp(p);
                return ErrorCodes.SUCCESS;
            }

            List<AuthorizationHandlerCredentials> myCreds = await DevCenterCredentialsHandler.GetApiCreds(CredentialsOption, AADAuthenticationOption);

            if (myCreds == null)
            {
                ErrorParsingOptions("Unable to get Dev Center Credentials");
                return ErrorCodes.NO_DEV_CENTER_CREDENTIALS_FOUND;
            }

            if (OverrideServer < 0 || OverrideServer >= myCreds.Count)
            {
                ErrorParsingOptions("OverrideServer invalid - " + OverrideServer);
                return ErrorCodes.OVERRIDE_SERVER_INVALID;
            }
            else
            {
                if (!OverrideServerPresent)
                {
                    string loopServersString = ConfigurationManager.AppSettings["loopservers"];
                    if (loopServersString != null)
                    {
                        string[] serversList = loopServersString.Split(',');
                        int x = (new Random()).Next(0, serversList.Length);
                        OverrideServer = int.Parse(serversList[x]);
                    }
                }
            }

            if (CreateOption != null && (!File.Exists(CreateOption)))
            {
                ErrorParsingOptions("CreateOption invalid - " + CreateOption);
                return ErrorCodes.CREATE_INPUT_FILE_DOES_NOT_EXIST;
            }

            DevCenterHWSubmissionType ListOptionEnum = DevCenterHWSubmissionTypeCheck(ListOption);
            if (ListOption != null && ListOptionEnum == DevCenterHWSubmissionType.Invalid)
            {
                ErrorParsingOptions("ListOption invalid - " + ListOption);
                return ErrorCodes.LIST_INVALID_OPTION;
            }

            if (TimeoutOption != null)
            {
                if (uint.TryParse(TimeoutOption, out uint inputParse))
                {
                    HttpTimeout = inputParse;
                    Console.WriteLine($"> HttpTimeout: {HttpTimeout} seconds");
                }
                else
                {
                    Console.WriteLine($"> HttpTimeout: Invalid value {TimeoutOption}, using default timeout");
                }
            }

            DevCenterOptions options = new DevCenterOptions() { CorrelationId = CorrelationId, HttpTimeoutSeconds = HttpTimeout, RequestDelayMs = 250, LastCommand = LastCommandSet };
            DevCenterHandler api = new DevCenterHandler(myCreds[OverrideServer], options);

            if (CreateOption != null)
            {
                Console.WriteLine("> Create Option");

                CreateInput createInput = JsonConvert.DeserializeObject<CreateInput>(File.ReadAllText(CreateOption));

                if (DevCenterHWSubmissionType.Product == createInput.CreateType)
                {
                    try
                    {
                        DevCenterResponse<Product> ret = await api.NewProduct(createInput.CreateProduct);
                        if (ret.Error != null)
                        {
                            if (ret.Error.HttpErrorCode == 429)
                            {
                                Console.WriteLine($"{nameof(CreateOption)} {nameof(api.NewProduct)} experienced a HTTP 429 Too Many Requests response.");
                                return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                            }
                            else
                            {
                                DevCenterErrorDetailsDump(ret.Error);
                                return ErrorCodes.NEW_PRODUCT_API_FAILED;
                            }
                        }
                        else
                        {
                            ret.ReturnValue[0].Dump();
                        }
                    }
                    catch (Exception ex)
                    {
                        LogExceptionToConsole(ex, nameof(CreateOption), nameof(api.NewProduct));
                        return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                    }
                }
                else if (DevCenterHWSubmissionType.Submission == createInput.CreateType)
                {
                    if (ProductId == null)
                    {
                        Console.WriteLine("> ERROR: productid not specified");
                        retval = ErrorCodes.NEW_SUBMISSION_PRODUCT_ID_MISSING;
                    }

                    if (retval == 0)
                    {
                        Console.WriteLine("> Creating Submission");

                        try
                        {
                            DevCenterResponse<Submission> ret = await api.NewSubmission(ProductId, createInput.CreateSubmission);
                            if (ret.Error != null)
                            {
                                if (ret.Error.HttpErrorCode == 429)
                                {
                                    Console.WriteLine($"{nameof(CreateOption)} {nameof(api.NewSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                    return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                                }
                                else
                                {
                                    DevCenterErrorDetailsDump(ret.Error);
                                    return ErrorCodes.NEW_SUBMISSION_API_FAILED;
                                }
                            }
                            else
                            {
                                ret.ReturnValue[0].Dump();
                            }
                        }
                        catch (Exception ex)
                        {
                            LogExceptionToConsole(ex, nameof(CreateOption), nameof(api.NewSubmission));
                            return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                        }
                    }
                }
                else if (DevCenterHWSubmissionType.ShippingLabel == createInput.CreateType)
                {
                    if (ProductId == null)
                    {
                        Console.WriteLine("> ERROR: productid not specified");
                        retval = ErrorCodes.NEW_SHIPPING_LABEL_PRODUCT_ID_MISSING;
                    }

                    if (SubmissionId == null)
                    {
                        Console.WriteLine("> ERROR: submissionid not specified");
                        retval = ErrorCodes.NEW_SHIPPING_LABEL_SUBMISSION_ID_MISSING;
                    }

                    if (retval == 0)
                    {
                        Console.WriteLine("> Get Driver Metadata");
                        string tmpfile = System.IO.Path.GetTempFileName();

                        var section = string.Empty;
                        try
                        {
                            section = nameof(api.GetSubmission);
                            DevCenterResponse<Submission> retSubmission = await api.GetSubmission(ProductId, SubmissionId);
                            if (retSubmission.Error != null)
                            {
                                if (retSubmission.Error.HttpErrorCode == 429)
                                {
                                    Console.WriteLine($"{nameof(CreateOption)} {nameof(api.GetSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                    return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                                }
                                else
                                {
                                    DevCenterErrorDetailsDump(retSubmission.Error);
                                    return ErrorCodes.NEW_SHIPPING_LABEL_GET_SUBMISSION_API_FAILED;
                                }
                            }

                            List<Submission> submissions = retSubmission.ReturnValue;
                            List<Download.Item> dls = submissions[0].Downloads.Items;
                            foreach (Download.Item dl in dls)
                            {
                                if (dl.Type.ToLower() == Download.Type.driverMetadata.ToString().ToLower())
                                {
                                    Console.WriteLine("> driverMetadata Url: " + dl.Url);
                                    BlobStorageHandler bsh = new BlobStorageHandler(dl.Url.AbsoluteUri);
                                    await bsh.Download(tmpfile);
                                }
                            }

                            string jsonContent = System.IO.File.ReadAllText(tmpfile);
                            DriverMetadata metadata = JsonConvert.DeserializeObject<DriverMetadata>(jsonContent);
                            System.IO.File.Delete(tmpfile);

                            List<HardwareId> labelHwids = new List<HardwareId>();

                            foreach (KeyValuePair<string, DriverMetadataDetails> bundleInfo in metadata.BundleInfoMap)
                            {
                                foreach (KeyValuePair<string, DriverMetadataInfDetails> infInfo in bundleInfo.Value.InfInfoMap)
                                {
                                    foreach (KeyValuePair<string, Dictionary<string, DriverMetadataHWID>> osPnpInfo in infInfo.Value.OSPnPInfoMap)
                                    {
                                        foreach (KeyValuePair<string, DriverMetadataHWID> pnpInfo in osPnpInfo.Value)
                                        {
                                            HardwareId labelHwid = new HardwareId
                                            {
                                                BundleId = bundleInfo.Key,
                                                InfId = infInfo.Key,
                                                OperatingSystemCode = osPnpInfo.Key,
                                                PnpString = pnpInfo.Key.ToLower()   // Recommendation from HDC team
                                            };
                                            labelHwids.Add(labelHwid);
                                        }
                                    }
                                }
                            }

                            createInput.CreateShippingLabel.Targeting.HardwareIds = labelHwids;
                            createInput.CreateShippingLabel.PublishingSpecifications.GoLiveDate = DateTime.Now.AddDays(7);

                            if (AnotherPartnerId != null)
                            {
                                Console.WriteLine("> Shipping to Partner (not Windows Update): " + AnotherPartnerId);
                                createInput.CreateShippingLabel.Destination = "anotherPartner";
                                createInput.CreateShippingLabel.RecipientSpecifications = new RecipientSpecifications()
                                {
                                    EnforceChidTargeting = false,
                                    ReceiverPublisherId = AnotherPartnerId
                                };
                            }

                            Console.WriteLine("> Creating Shipping Label");
                            section = nameof(api.NewShippingLabel);
                            DevCenterResponse<ShippingLabel> ret = await api.NewShippingLabel(ProductId, SubmissionId, createInput.CreateShippingLabel);
                            if (ret.Error != null)
                            {
                                if (ret.Error.HttpErrorCode == 429)
                                {
                                    Console.WriteLine($"{nameof(CreateOption)} {nameof(api.NewShippingLabel)} experienced a HTTP 429 Too Many Requests response.");
                                    return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                                }
                                else
                                {
                                    DevCenterErrorDetailsDump(ret.Error);
                                    return ErrorCodes.NEW_SHIPPING_LABEL_CREATE_API_FAILED;
                                }
                            }
                            else
                            {
                                ret.ReturnValue[0].Dump();
                            }
                        }
                        catch (Exception ex)
                        {
                            LogExceptionToConsole(ex, nameof(CreateOption), section);
                            return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                        }
                    }
                }
                else
                {
                    Console.WriteLine(">  Invalid Create Option selected");
                }
            }
            else if (CommitOption)
            {
                Console.WriteLine("> Commit Option");

                if (ProductId == null)
                {
                    Console.WriteLine("> ERROR: productid not specified");
                    retval = ErrorCodes.COMMIT_PRODUCT_ID_MISSING;
                }

                if (SubmissionId == null)
                {
                    Console.WriteLine("> ERROR: submissionid not specified");
                    retval = ErrorCodes.COMMIT_SUBMISSION_ID_MISSING;
                }

                if (retval == 0)
                {
                    Console.WriteLine("> Sending Commit");

                    try
                    {
                        DevCenterResponse<bool> ret = await api.CommitSubmission(ProductId, SubmissionId);
                        if (ret.Error != null)
                        {
                            if (ret.Error.HttpErrorCode == 429)
                            {
                                Console.WriteLine($"{nameof(CommitOption)} {nameof(api.CommitSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                            }
                            if (ret.Error.Code == ErrorCodeConstants.RequestInvalidForCurrentState && ret.Error.Message == ErrorMessageConstants.OnlyPendingSubmissionsCanBeCommitted)
                            {
                                Console.WriteLine($"{nameof(CommitOption)} {nameof(api.CommitSubmission)} request invalid for currentState, {ErrorMessageConstants.OnlyPendingSubmissionsCanBeCommitted}");
                                DevCenterErrorDetailsDump(ret.Error);
                                return ErrorCodes.COMMIT_REQUEST_INVALID_FOR_CURRENT_STATE;
                            }
                            else
                            {
                                DevCenterErrorDetailsDump(ret.Error);
                                return ErrorCodes.COMMIT_API_FAILED;
                            }
                        }
                        else
                        {
                            if (!ret.ReturnValue[0])
                            {
                                Console.WriteLine("> Commit Failed");
                                retval = ErrorCodes.COMMIT_API_FAILED;
                            }
                            else
                            {
                                Console.WriteLine("> Commit OK");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        LogExceptionToConsole(ex, nameof(CommitOption), nameof(api.CommitSubmission));
                        return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                    }
                }
            }
            else if (ListOption != null)
            {
                Console.WriteLine("> List Option {0}", ListOption);

                var section = string.Empty;
                try
                {
                    switch (ListOptionEnum)
                    {
                        case DevCenterHWSubmissionType.Product:
                            {
                                section = nameof(api.GetProducts);
                                DevCenterResponse<Product> ret = await api.GetProducts(ProductId);
                                if (ret.Error != null)
                                {
                                    if (ret.Error.HttpErrorCode == 429)
                                    {
                                        Console.WriteLine($"{nameof(ListOption)} {nameof(api.GetProducts)} experienced a HTTP 429 Too Many Requests response.");
                                        return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                                    }
                                    else
                                    {
                                        DevCenterErrorDetailsDump(ret.Error);
                                        return ErrorCodes.LIST_GET_PRODUCTS_API_FAILED;
                                    }
                                }
                                else
                                {
                                    List<Product> products = ret.ReturnValue;
                                    foreach (Product product in products)
                                    {
                                        product.Dump();
                                    }
                                }
                            }
                            break;
                        case DevCenterHWSubmissionType.Submission:
                            {
                                section = nameof(api.GetSubmission);
                                DevCenterResponse<Submission> ret = await api.GetSubmission(ProductId, SubmissionId);
                                if (ret.Error != null)
                                {
                                    if (ret.Error.HttpErrorCode == 429)
                                    {
                                        Console.WriteLine($"{nameof(ListOption)} {nameof(api.GetSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                        return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                                    }
                                    if (ret.Error.Code == ErrorCodeConstants.EntityNotFound)
                                    {
                                        Console.WriteLine($"{nameof(ListOption)} {nameof(api.GetSubmission)} entity not found, try translate option.");
                                        DevCenterErrorDetailsDump(ret.Error);
                                        return ErrorCodes.SUBMISSION_ENTITY_NOT_FOUND;
                                    }
                                    else
                                    {
                                        DevCenterErrorDetailsDump(ret.Error);
                                        return ErrorCodes.LIST_GET_SUBMISSION_API_FAILED;
                                    }
                                }
                                else
                                {
                                    List<Submission> submissions = ret.ReturnValue;
                                    foreach (Submission submission in submissions)
                                    {
                                        submission.Dump();
                                    }
                                }
                            }
                            break;
                        case DevCenterHWSubmissionType.ShippingLabel:
                            {
                                section = nameof(api.GetShippingLabels);
                                DevCenterResponse<ShippingLabel> ret = await api.GetShippingLabels(ProductId, SubmissionId, ShippingLabelId);
                                if (ret.Error != null)
                                {
                                    if (ret.Error.HttpErrorCode == 429)
                                    {
                                        Console.WriteLine($"{nameof(ListOption)} {nameof(api.GetShippingLabels)} experienced a HTTP 429 Too Many Requests response.");
                                        return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                                    }
                                    else
                                    {
                                        DevCenterErrorDetailsDump(ret.Error);
                                        return ErrorCodes.LIST_GET_SHIPPING_LABEL_API_FAILED;
                                    }
                                }
                                else
                                {
                                    List<ShippingLabel> shippingLabels = ret.ReturnValue;
                                    foreach (ShippingLabel shippingLabel in shippingLabels)
                                    {
                                        shippingLabel.Dump();
                                    }
                                }
                            }
                            break;
                        case DevCenterHWSubmissionType.PartnerSubmission:
                            {
                                section = nameof(api.GetPartnerSubmission);
                                DevCenterResponse<Submission> ret = await api.GetPartnerSubmission(PublisherId, ProductId, SubmissionId);
                                if (ret.Error != null)
                                {
                                    if (ret.Error.HttpErrorCode == 429)
                                    {
                                        Console.WriteLine($"{nameof(ListOption)} {nameof(api.GetPartnerSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                        return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                                    }
                                    else
                                    {
                                        DevCenterErrorDetailsDump(ret.Error);
                                        return ErrorCodes.LIST_GET_PARTNER_SUBMISSION_API_FAILED;
                                    }
                                }
                                else
                                {
                                    List<Submission> submissions = ret.ReturnValue;
                                    foreach (Submission submission in submissions)
                                    {
                                        submission.Dump();
                                    }
                                }
                            }
                            break;
                        default:
                            Console.WriteLine(">  Invalid List Option selected");
                            break;
                    }
                }
                catch (Exception ex)
                {
                    LogExceptionToConsole(ex, nameof(ListOption), section);
                    return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                }
            }
            else if (DownloadOption != null)
            {
                Console.WriteLine("> Download Option {0}", DownloadOption);

                string pathNameFull = System.IO.Path.GetFullPath(DownloadOption);
                string FileNamePart = System.IO.Path.GetFileName(DownloadOption);
                string PathNamePart = System.IO.Path.GetDirectoryName(DownloadOption);

                if (!System.IO.Directory.Exists(PathNamePart))
                {
                    Console.WriteLine("> ERROR: Output path does not exist: " + PathNamePart);
                    retval = ErrorCodes.DOWNLOAD_OUTPUT_PATH_NOT_EXIST;
                }

                if (System.IO.File.Exists(DownloadOption))
                {
                    Console.WriteLine("> ERROR: Output file exists already: " + DownloadOption);
                    retval = ErrorCodes.DOWNLOAD_OUTPUT_FILE_ALREADY_EXISTS;
                }

                if (ProductId == null)
                {
                    Console.WriteLine("> ERROR: productid not specified");
                    retval = ErrorCodes.DOWNLOAD_PRODUCT_ID_MISSING;
                }

                if (SubmissionId == null)
                {
                    Console.WriteLine("> ERROR: submissionid not specified");
                    retval = ErrorCodes.DOWNLOAD_SUBMISSION_ID_MISSING;
                }

                if (retval == 0)
                {
                    Console.WriteLine("> Fetch Submission Info");
                    try
                    {
                        DevCenterResponse<Submission> ret = await api.GetSubmission(ProductId, SubmissionId);
                        if (ret.Error != null)
                        {
                            if (ret.Error.HttpErrorCode == 429)
                            {
                                Console.WriteLine($"{nameof(DownloadOption)} {nameof(api.GetSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                            }
                            else
                            {
                                DevCenterErrorDetailsDump(ret.Error);
                                return ErrorCodes.DOWNLOAD_GET_SUBMISSION_API_FAILED;
                            }
                        }
                        List<Submission> submissions = ret.ReturnValue;
                        List<Download.Item> dls = submissions[0].Downloads.Items;
                        foreach (Download.Item dl in dls)
                        {
                            if (dl.Type.ToLower() == Download.Type.signedPackage.ToString().ToLower())
                            {
                                Console.WriteLine("> signedPackage Url: " + dl.Url);
                                BlobStorageHandler bsh = new BlobStorageHandler(dl.Url.AbsoluteUri);
                                await bsh.Download(DownloadOption);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        LogExceptionToConsole(ex, nameof(DownloadOption), nameof(api.GetSubmission));
                        return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                    }
                }
            }
            else if (MetadataOption != null)
            {
                Console.WriteLine("> Metadata Download Option {0}", MetadataOption);

                if (ProductId == null)
                {
                    Console.WriteLine("> ERROR: productid not specified");
                    retval = ErrorCodes.METADATA_PRODUCT_ID_MISSING;
                }

                if (SubmissionId == null)
                {
                    Console.WriteLine("> ERROR: submissionid not specified");
                    retval = ErrorCodes.METADATA_SUBMISSION_ID_MISSING;
                }

                if (retval == 0)
                {
                    Console.WriteLine("> Fetch Submission Info");
                    try
                    {
                        DevCenterResponse<Submission> ret = await api.GetSubmission(ProductId, SubmissionId);
                        if (ret.Error != null)
                        {
                            if (ret.Error.HttpErrorCode == 429)
                            {
                                Console.WriteLine($"{nameof(MetadataOption)} {nameof(api.GetSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                            }
                            else
                            {
                                DevCenterErrorDetailsDump(ret.Error);
                                return ErrorCodes.METADATA_GET_SUBMISSION_API_FAILED;
                            }
                        }
                        List<Submission> submissions = ret.ReturnValue;
                        List<Download.Item> dls = submissions[0].Downloads.Items;
                        bool foundMetaData = false;
                        foreach (Download.Item dl in dls)
                        {
                            if (dl.Type.ToLower() == Download.Type.driverMetadata.ToString().ToLower())
                            {
                                Console.WriteLine("> driverMetadata Url: " + dl.Url);
                                BlobStorageHandler bsh = new BlobStorageHandler(dl.Url.AbsoluteUri);
                                await bsh.Download(MetadataOption);
                                foundMetaData = true;
                            }
                        }

                        if (!foundMetaData)
                        {
                            Console.WriteLine("> ERROR: No Metadata available for this submission");
                        }
                    }
                    catch (Exception ex)
                    {
                        LogExceptionToConsole(ex, nameof(MetadataOption), nameof(api.GetSubmission));
                        return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                    }
                }
            }
            else if (SubmissionPackagePath != null)
            {
                Console.WriteLine("> Upload Option");

                if (ProductId == null)
                {
                    Console.WriteLine("> ERROR: productid not specified");
                    retval = ErrorCodes.UPLOAD_PRODUCT_ID_MISSING;
                }

                if (SubmissionId == null)
                {
                    Console.WriteLine("> ERROR: submissionid not specified");
                    retval = ErrorCodes.UPLOAD_SUBMISSION_ID_MISSING;
                }

                if (retval == 0)
                {
                    Console.WriteLine("> Fetch Submission Info");
                    try
                    {
                        DevCenterResponse<Submission> ret = await api.GetSubmission(ProductId, SubmissionId);
                        if (ret.Error != null)
                        {
                            if (ret.Error.HttpErrorCode == 429)
                            {
                                Console.WriteLine($"{nameof(SubmissionPackagePath)} {nameof(api.GetSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                            }
                            else
                            {
                                DevCenterErrorDetailsDump(ret.Error);
                                return ErrorCodes.UPLOAD_GET_SUBMISSION_API_FAILED;
                            }
                        }
                        List<Submission> submissions = ret.ReturnValue;
                        List<Download.Item> dls = submissions[0].Downloads.Items;
                        foreach (Download.Item dl in dls)
                        {
                            if (dl.Type.ToLower() == Download.Type.initialPackage.ToString().ToLower())
                            {
                                Console.WriteLine("> initialPackage Url: " + dl.Url);
                                Console.WriteLine("> Uploading Submission Package");
                                BlobStorageHandler bsh = new BlobStorageHandler(dl.Url.AbsoluteUri);
                                await bsh.Upload(SubmissionPackagePath);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        LogExceptionToConsole(ex, nameof(SubmissionPackagePath), nameof(api.GetSubmission));
                        return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                    }
                }
            }
            else if (WaitOption)
            {
                Console.WriteLine("> Wait Option");

                if (ProductId == null)
                {
                    Console.WriteLine("> ERROR: productid not specified");
                    retval = ErrorCodes.WAIT_PRODUCT_ID_MISSING;
                }

                if (SubmissionId == null)
                {
                    Console.WriteLine("> ERROR: submissionid not specified");
                    retval = ErrorCodes.WAIT_SUBMISSION_ID_MISSING;
                }

                if (retval == 0)
                {
                    bool done = false;
                    string lastCurrentStep = "";
                    string lastState = "";

                    while (!done)
                    {
                        if (ShippingLabelId == null)
                        {
                            try
                            {
                                DevCenterResponse<Submission> ret = await api.GetSubmission(ProductId, SubmissionId);
                                if (ret.Error != null)
                                {
                                    if (ret.Error.HttpErrorCode == 429)
                                    {
                                        Console.WriteLine($"{nameof(WaitOption)} {nameof(api.GetSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                        await Task.Delay(5000);
                                        continue;
                                    }
                                    else
                                    {
                                        DevCenterErrorDetailsDump(ret.Error);
                                        done = true;
                                        retval = ErrorCodes.WAIT_GET_SUBMISSION_API_FAILED;
                                        break;
                                    }
                                }
                                List<Submission> submissions = ret.ReturnValue;
                                Submission sub = submissions[0];

                                if (!done)
                                {
                                    if (sub.WorkflowStatus == null)
                                    {
                                        Console.WriteLine($"{nameof(WaitOption)} {sub.Name} {nameof(WorkflowStatus)} was NULL. Will continue to wait...");
                                        continue;
                                    }

                                    if (sub.WorkflowStatus.CurrentStep != lastCurrentStep ||
                                    sub.WorkflowStatus.State != lastState)
                                    {
                                        lastCurrentStep = sub.WorkflowStatus.CurrentStep;
                                        lastState = sub.WorkflowStatus.State;
                                        await sub.WorkflowStatus.Dump();
                                    }

                                    bool haveMetadata = false;
                                    bool haveSignedPackage = false;
                                    if (sub.Downloads != null)
                                    {
                                        List<Download.Item> dls = sub.Downloads.Items;
                                        foreach (Download.Item dl in dls)
                                        {
                                            if (dl.Type.ToLower() == Download.Type.driverMetadata.ToString().ToLower())
                                            {
                                                Console.WriteLine("> driverMetadata Url: " + dl.Url);
                                                haveMetadata = true;
                                            }
                                            if (dl.Type.ToLower() == Download.Type.signedPackage.ToString().ToLower())
                                            {
                                                Console.WriteLine("> signedPackage Url: " + dl.Url);
                                                haveSignedPackage = true;
                                            }
                                        }
                                    }

                                    if (lastState == "failed")
                                    {
                                        done = true;
                                        retval = ErrorCodes.WAIT_SUBMISSION_FAILED_IN_HWDC;
                                    }
                                    else if (haveSignedPackage)
                                    {
                                        if (WaitForMetaData)
                                        {
                                            if (haveMetadata)
                                            {
                                                done = true;
                                                Console.WriteLine("> Submission Ready with Metadata");
                                            }
                                        }
                                        else
                                        {
                                            done = true;
                                            Console.WriteLine("> Submission Ready");
                                        }
                                    }

                                    if (!done)
                                    {
                                        await Task.Delay(5000);
                                    }
                                }
                                else
                                {
                                    Console.WriteLine("> Signed Package Ready");
                                }
                            }
                            catch (Exception ex)
                            {
                                LogExceptionToConsole(ex, nameof(WaitOption), nameof(api.GetSubmission));
                                return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                            }
                        }
                        else
                        {
                            try
                            {
                                DevCenterResponse<ShippingLabel> ret = await api.GetShippingLabels(ProductId, SubmissionId, ShippingLabelId);
                                if (ret.Error != null)
                                {
                                    if (ret.Error.HttpErrorCode == 429)
                                    {
                                        Console.WriteLine($"{nameof(WaitOption)} {nameof(api.GetShippingLabels)} experienced a HTTP 429 Too Many Requests response.");
                                        await Task.Delay(5000);
                                        continue;
                                    }
                                    else
                                    {

                                        DevCenterErrorDetailsDump(ret.Error);
                                        done = true;
                                        retval = ErrorCodes.WAIT_GET_SHIPPING_LABEL_API_FAILED;
                                        break;
                                    }
                                }
                                List<ShippingLabel> shippingLabels = ret.ReturnValue;
                                ShippingLabel label = shippingLabels[0];

                                if (label.WorkflowStatus.CurrentStep != lastCurrentStep ||
                                    label.WorkflowStatus.State != lastState)
                                {
                                    lastCurrentStep = label.WorkflowStatus.CurrentStep;
                                    lastState = label.WorkflowStatus.State;
                                    await label.WorkflowStatus.Dump();
                                }

                                if (lastState == "failed")
                                {
                                    done = true;
                                    retval = ErrorCodes.WAIT_SHIPPING_LABEL_FAILED_IN_HWDC;
                                }
                                else if (lastCurrentStep == "microsoftApproval")
                                {
                                    done = true;
                                    Console.WriteLine("> Shipping Label Ready");
                                }
                                else if (lastCurrentStep == "finalizeSharing" && lastState == "completed")
                                {
                                    done = true;
                                    Console.WriteLine("> Shipping Label for Sharing Ready");
                                }
                                else
                                {
                                    await Task.Delay(5000);
                                }
                            }
                            catch (Exception ex)
                            {
                                LogExceptionToConsole(ex, nameof(WaitOption), nameof(api.GetShippingLabels));
                                return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                            }
                        }
                    }
                    Console.WriteLine("> Done");
                }
            }
            else if (AudienceOption)
            {
                Console.WriteLine("> Audience Option");

                try
                {
                    DevCenterResponse<Audience> ret = await api.GetAudiences();
                    if (ret.Error != null)
                    {
                        if (ret.Error.HttpErrorCode == 429)
                        {
                            Console.WriteLine($"{nameof(AudienceOption)} {nameof(api.GetAudiences)} experienced a HTTP 429 Too Many Requests response.");
                            return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                        }
                        else
                        {
                            DevCenterErrorDetailsDump(ret.Error);
                            return ErrorCodes.AUIDENCE_GET_AUDIENCE_API_FAILED;
                        }
                    }
                    else
                    {
                        List<Audience> audiences = ret.ReturnValue;
                        foreach (Audience audience in audiences)
                        {
                            audience.Dump();
                        }
                    }
                }
                catch (Exception ex)
                {
                    LogExceptionToConsole(ex, nameof(AudienceOption), nameof(api.GetAudiences));
                    return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                }
            }
            else if (CreateMetaData)
            {
                Console.WriteLine("> Create MetaData Option");

                if (ProductId == null)
                {
                    Console.WriteLine("> ERROR: productid not specified");
                    retval = ErrorCodes.CREATEMETADATA_PRODUCT_ID_MISSING;
                }

                if (SubmissionId == null)
                {
                    Console.WriteLine("> ERROR: submissionid not specified");
                    retval = ErrorCodes.CREATEMETADATA_SUBMISSION_ID_MISSING;
                }

                if (retval == 0)
                {
                    Console.WriteLine("> Sending Create MetaData");
                    try
                    {
                        DevCenterResponse<bool> ret = await api.CreateMetaData(ProductId, SubmissionId);
                        if (ret.Error != null)
                        {
                            if (ret.Error.HttpErrorCode == 429)
                            {
                                Console.WriteLine($"{nameof(CreateMetaData)} {nameof(api.CreateMetaData)} experienced a HTTP 429 Too Many Requests response.");
                                return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                            }
                            else
                            {
                                DevCenterErrorDetailsDump(ret.Error);
                                return ErrorCodes.CREATEMETADATA_API_FAILED;
                            }
                        }
                        else
                        {
                            if (!ret.ReturnValue[0])
                            {
                                Console.WriteLine("> Create MetaData Failed");
                                retval = ErrorCodes.CREATEMETADATA_API_FAILED;
                            }
                            else
                            {
                                Console.WriteLine("> Create MetaData OK");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        LogExceptionToConsole(ex, nameof(CreateMetaData), nameof(api.CreateMetaData));
                        return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                    }
                }
            }
            else if (TranslateOption)
            {
                Console.WriteLine("> Translate Option");

                if (PublisherId == null)
                {
                    Console.WriteLine("> ERROR: publisherid not specified");
                    retval = ErrorCodes.TRANSLATE_PUBLISHER_ID_MISSING;
                }

                if (ProductId == null)
                {
                    Console.WriteLine("> ERROR: productid not specified");
                    retval = ErrorCodes.TRANSLATE_PRODUCT_ID_MISSING;
                }

                if (SubmissionId == null)
                {
                    Console.WriteLine("> ERROR: submissionid not specified");
                    retval = ErrorCodes.TRANSLATE_SUBMISSION_ID_MISSING;
                }

                if (retval == 0)
                {
                    Console.WriteLine("> Requesting Translation");
                    try
                    {
                        DevCenterResponse<Submission> ret = await api.GetPartnerSubmission(PublisherId, ProductId, SubmissionId);
                        if (ret.Error != null)
                        {
                            if (ret.Error.HttpErrorCode == 429)
                            {
                                Console.WriteLine($"{nameof(TranslateOption)} {nameof(api.GetPartnerSubmission)} experienced a HTTP 429 Too Many Requests response.");
                                return ErrorCodes.HTTP_429_RATE_LIMIT_EXCEEDED;
                            }
                            else
                            {
                                DevCenterErrorDetailsDump(ret.Error);
                                return ErrorCodes.TRANSLATE_API_FAILED;
                            }
                        }
                        else
                        {
                            if (ret.ReturnValue.Count == 0)
                            {
                                Console.WriteLine("> Translate Failed");
                                retval = ErrorCodes.TRANSLATE_API_FAILED;
                            }
                            else
                            {
                                Console.WriteLine("> Translate OK");
                                ret.ReturnValue[0].Dump();
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        LogExceptionToConsole(ex, nameof(TranslateOption), nameof(api.GetPartnerSubmission));
                        return ErrorCodes.PARTNER_CENTER_HTTP_EXCEPTION;
                    }
                }
            }
            return retval;
        }

        private static void ShowHelp(OptionSet p)
        {
            Console.WriteLine("Usage: sdcm [OPTIONS]+");
            Console.WriteLine("Surface Dev Center Manager - Manage Microsoft Hardware Dev Center content");
            Console.WriteLine();
            Console.WriteLine("Options:");
            p.WriteOptionDescriptions(Console.Out);
        }

        private static void ErrorParsingOptions(string message)
        {
            Console.Write("Error Parsing Options: ");
            Console.WriteLine(message);
        }

        private static DevCenterHWSubmissionType DevCenterHWSubmissionTypeCheck(string input)
        {
            DevCenterHWSubmissionType retval = DevCenterHWSubmissionType.Invalid;
            if (input == null)
            {
                return retval;
            }

            foreach (DevCenterHWSubmissionType opt in Enum.GetValues(typeof(DevCenterHWSubmissionType)))
            {
                if (string.Compare(input, opt.ToString(), StringComparison.OrdinalIgnoreCase) == 0)
                {
                    retval = opt;
                    break;
                }
            }
            return retval;
        }

        private static void DevCenterErrorDetailsDump(DevCenterErrorDetails error)
        {
            Console.WriteLine("ERROR (DevCenterErrorDetails)");
            if (error == null) return;
            Console.WriteLine("Code:    " + (error.Code ?? ""));
            Console.WriteLine("HttpCode:" + error.HttpErrorCode);
            Console.WriteLine("Message: " + (error.Message ?? ""));
            if (error.ValidationErrors != null)
            {
                Console.WriteLine("ValidationErrors:");
                foreach (DevCenterErrorValidationErrorEntry entry in error.ValidationErrors)
                {
                    Console.WriteLine("  Target: " + entry.Target);
                    Console.WriteLine("  Message:" + entry.Message);
                }
            }

            if (error.Trace != null)
            {
                Console.WriteLine("Request Id:     {0}", error.Trace.RequestId ?? "");
                Console.WriteLine("Method:         {0}", error.Trace.Method ?? "");
                Console.WriteLine("Url:            {0}", error.Trace.Url ?? "");
                Console.WriteLine("Content:        {0}", error.Trace.Content ?? "");
            }
        }

        /// <summary>
        /// Log messages to the console for debugging
        /// </summary>
        /// <param name="ex"></param>
        /// <param name="option"></param>
        /// <param name="section"></param>
        private static void LogExceptionToConsole(Exception ex, string option, string section)
        {
            if (ex == null) return;
            Console.WriteLine("");
            Console.WriteLine("============================================================");
            Console.WriteLine("\tSurfaceDevCenterManager Exception Log");
            Console.WriteLine($"Option:          {option ?? ""}");
            Console.WriteLine($"Section:         {section ?? ""}");
            Console.WriteLine($"Type:            {ex.GetType() ?? null}");
            Console.WriteLine($"Message:         {ex.Message ?? ""}");
            Console.WriteLine($"Inner Exception: {ex.InnerException?.Message ?? ""}");
            Console.WriteLine($"Correlation Id:  {CorrelationId}");
            Console.WriteLine("============================================================");
            Console.WriteLine("");
        }
    }
}

```

`SurfaceDevCenterManager/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SurfaceDevCenterManager")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Surface")]
[assembly: AssemblyCopyright("(C) 2018 Microsoft. All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6d5fb1f6-29eb-49e4-9b10-cb60b30265f2")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.1")]
[assembly: AssemblyFileVersion("1.0.0.1")]

```

`SurfaceDevCenterManager/SurfaceDevCenterManager.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{6D5FB1F6-29EB-49E4-9B10-CB60B30265F2}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>SurfaceDevCenterManager</RootNamespace>
    <AssemblyName>sdcm</AssemblyName>
    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <TargetFrameworkProfile />
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.1.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <CodeAnalysisRuleSet>SurfaceDevCenterManager.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <CodeAnalysisRuleSet>SurfaceDevCenterManager.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Configuration" />
    <Reference Include="System.Core" />
    <Reference Include="System.Security" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="ErrorCodes.cs" />
    <Compile Include="Utility\DevCenterCredentialsHandler.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
    <None Include="authconfig.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Include="SurfaceDevCenterManager.ruleset" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.7.1">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.7.1 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Azure.Security.KeyVault.Keys">
      <Version>4.7.0</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.Data.Edm">
      <Version>5.8.5</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.Data.Services.Client">
      <Version>5.8.5</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.Devices.HardwareDevCenterManager">
      <Version>3.0.17</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.IdentityModel.Clients.ActiveDirectory">
      <Version>5.3.0</Version>
    </PackageReference>
    <PackageReference Include="Mono.Options">
      <Version>6.12.0.148</Version>
    </PackageReference>
    <PackageReference Include="Newtonsoft.Json">
      <Version>13.0.3</Version>
    </PackageReference>
    <PackageReference Include="System.ComponentModel.EventBasedAsync">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.Dynamic.Runtime">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.Linq.Queryable">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.Net.Requests">
      <Version>4.3.0</Version>
    </PackageReference>
    <PackageReference Include="System.Spatial">
      <Version>5.8.5</Version>
    </PackageReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`SurfaceDevCenterManager/SurfaceDevCenterManager.ruleset`:

```ruleset
<?xml version="1.0" encoding="utf-8"?>
<RuleSet Name="Rules for SurfaceDevCenterManager" Description="Code analysis rules for SurfaceDevCenterManager.csproj." ToolsVersion="15.0">
  <IncludeAll Action="Warning" />
  <Rules AnalyzerId="Microsoft.Analyzers.ManagedCodeAnalysis" RuleNamespace="Microsoft.Rules.Managed">
    <Rule Id="CA1002" Action="None" />
    <Rule Id="CA1303" Action="None" />
    <Rule Id="CA1709" Action="Warning" />
    <Rule Id="CA2204" Action="None" />
    <Rule Id="CA2227" Action="None" />
  </Rules>
</RuleSet>
```

`SurfaceDevCenterManager/Utility/DevCenterCredentialsHandler.cs`:

```cs
/*++
    Copyright (c) Microsoft Corporation. All rights reserved.

    Licensed under the MIT license.  See LICENSE file in the project root for full license information.
--*/
using Microsoft.Devices.HardwareDevCenterManager.Utility;
using Microsoft.IdentityModel.Clients.ActiveDirectory;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace SurfaceDevCenterManager.Utility
{
    internal class DevCenterCredentialsHandler
    {
        private static readonly byte[] s_additionalEntropy = { 254, 122, 123, 135, 23, 79, 6 };

        private static string GetCredential()
        {
            byte[] data = null;
            byte[] encryptData = null;
            string retval = null;

            if (System.IO.File.Exists(GetSdcmBinPath()))
            {

                encryptData = System.IO.File.ReadAllBytes(GetSdcmBinPath());

                if (encryptData != null)
                {
                    try
                    {
                        data = ProtectedData.Unprotect(encryptData, s_additionalEntropy, DataProtectionScope.CurrentUser);
                        retval = Encoding.Unicode.GetString(data);
                    }
                    catch (CryptographicException)
                    {
                        data = null;
                    }
                }
            }

            return retval;
        }

        private static bool SetCredential(string token)
        {
            byte[] data = Encoding.Unicode.GetBytes(token);
            byte[] encryptData = null;
            bool retval = false;
            try
            {
                encryptData = ProtectedData.Protect(data, s_additionalEntropy, DataProtectionScope.CurrentUser);
            }
            catch (CryptographicException)
            {
                encryptData = null;
            }

            if (encryptData != null)
            {

                System.IO.File.WriteAllBytes(GetSdcmBinPath(), encryptData);
                retval = true;
            }

            return retval;
        }

        private static string GetSdcmBinPath()
        {
            string tmpPath = System.IO.Path.GetTempPath();
            return tmpPath + "sdcm.bin";
        }

        private static bool DeleteCredential()
        {
            System.IO.File.Delete(GetSdcmBinPath());
            return true;
        }

        public static async Task<List<AuthorizationHandlerCredentials>> GetApiCreds(string CredentialsOption, string AADAuthenticationOption)
        {
            List<AuthorizationHandlerCredentials> myCreds = null;
            if (CredentialsOption == null)
            {
                CredentialsOption = "AADThenFile";
            }
            CredentialsOption = CredentialsOption.ToLowerInvariant();

            // Check environment variable option
            if (CredentialsOption.CompareTo("clientcredentials") == 0 || CredentialsOption.CompareTo("envonly") == 0)
            {
                try
                {
                    myCreds = new List<AuthorizationHandlerCredentials>
                    {
                        new AuthorizationHandlerCredentials()
                        {
                            TenantId = Environment.GetEnvironmentVariable("SDCM_CREDS_TENANTID"),
                            ClientId = Environment.GetEnvironmentVariable("SDCM_CREDS_CLIENTID"),
                            Key = Environment.GetEnvironmentVariable("SDCM_CREDS_KEY"),
                            Url = new Uri(Environment.GetEnvironmentVariable("SDCM_CREDS_URL"), UriKind.Absolute),
                            UrlPrefix = new Uri(Environment.GetEnvironmentVariable("SDCM_CREDS_URLPREFIX"), UriKind.Relative)
                        }
                    };

                    myCreds = IsValidCredentials(myCreds[0], managedIdentity: false) == true ? myCreds : null;
                    return myCreds;
                }
                catch (Exception)
                {
                    Console.WriteLine("Missing or invalid environment variables: SDCM_CREDS_TENANTID, SDCM_CREDS_CLIENTID, SDCM_CREDS_KEY, SDCM_CREDS_URL, SDCM_CREDS_URLPREFIX");
                    return null;
                }
            }

            if (CredentialsOption.CompareTo("managedidentity") == 0)
            {
                try
                {
                    myCreds = new List<AuthorizationHandlerCredentials>
                    {
                        new AuthorizationHandlerCredentials()
                        {
                            TenantId = Environment.GetEnvironmentVariable("SDCM_CREDS_TENANTID"),
                            ClientId = Environment.GetEnvironmentVariable("SDCM_CREDS_CLIENTID"),
                            Url = new Uri(Environment.GetEnvironmentVariable("SDCM_CREDS_URL"), UriKind.Absolute),
                            UrlPrefix = new Uri(Environment.GetEnvironmentVariable("SDCM_CREDS_URLPREFIX"), UriKind.Relative),
                            ManagedIdentityClientId = Environment.GetEnvironmentVariable("SDCM_CREDS_MI_CLIENTID"),
                            Scope = Environment.GetEnvironmentVariable("SDCM_CREDS_MI_SCOPE")
                        }
                    };

                    myCreds = IsValidCredentials(myCreds[0], managedIdentity: true) == true ? myCreds : null;
                    return myCreds;
                }
                catch (Exception)
                {
                    Console.WriteLine("Missing or invalid environment variables: SDCM_CREDS_TENANTID, SDCM_CREDS_CLIENTID, SDCM_CREDS_MI_CLIENTID, SDCM_CREDS_MI_SCOPE, SDCM_CREDS_URL, SDCM_CREDS_URLPREFIX");
                    return null;
                }
            }

            if (CredentialsOption.CompareTo("mithenfile") == 0)
            {
                try
                {
                    string authconfig = System.IO.File.ReadAllText(AppDomain.CurrentDomain.BaseDirectory + "\\authconfig.json");
                    myCreds = JsonConvert.DeserializeObject<List<AuthorizationHandlerCredentials>>(authconfig);
                    if (myCreds.Count == 0)
                    {
                        myCreds = null;
                    }

                    myCreds = IsValidCredentials(myCreds[0], managedIdentity: true) == true ? myCreds : null;
                    return myCreds;
                }
                catch (Exception)
                {
                    myCreds = null;
                }
            }

            if ((CredentialsOption.CompareTo("aadonly") == 0) || (CredentialsOption.CompareTo("aadthenfile") == 0))
            {
                myCreds = await GetWebApiCreds(AADAuthenticationOption);
            }

            if (myCreds == null)
            {
                if ((CredentialsOption.CompareTo("fileonly") == 0) || (CredentialsOption.CompareTo("aadthenfile") == 0))
                {
                    try
                    {
                        string authconfig = System.IO.File.ReadAllText(AppDomain.CurrentDomain.BaseDirectory + "\\authconfig.json");
                        myCreds = JsonConvert.DeserializeObject<List<AuthorizationHandlerCredentials>>(authconfig);
                        if (myCreds.Count == 0)
                        {
                            myCreds = null;
                        }
                        else
                        {
                            if (myCreds[0].ClientId.CompareTo("guid") == 0)
                            {
                                myCreds = null;
                            }
                        }
                    }
                    catch (Exception)
                    {
                        myCreds = null;
                    }
                }
            }

            return myCreds;
        }

        private static async Task<List<AuthorizationHandlerCredentials>> GetWebApiCreds(string AADAuthenticationOption)
        {
            List<AuthorizationHandlerCredentials> ReturnList = null;

            string url = ConfigurationManager.AppSettings["url"];

            if (url == null)
            {
                return null;
            }

            Uri WebAPIUri = new Uri(url);

            string clientID = ConfigurationManager.AppSettings["clientID"];
            Uri redirectUri = new Uri(ConfigurationManager.AppSettings["redirectUri"]);
            string resource = ConfigurationManager.AppSettings["resource"];
            string authority = ConfigurationManager.AppSettings["authority"];
            AuthenticationContext authContext = new AuthenticationContext(authority);

            if (AADAuthenticationOption == null)
            {
                AADAuthenticationOption = "never";
            }
            AADAuthenticationOption = AADAuthenticationOption.ToLowerInvariant();
            PlatformParameters platformParams = new PlatformParameters(PromptBehavior.Never);

            if (AADAuthenticationOption.CompareTo("prompt") == 0)
            {
                platformParams = new PlatformParameters(PromptBehavior.Auto);
            }
            else if (AADAuthenticationOption.CompareTo("always") == 0)
            {
                platformParams = new PlatformParameters(PromptBehavior.Always);
            }
            else if (AADAuthenticationOption.CompareTo("refreshsession") == 0)
            {
                platformParams = new PlatformParameters(PromptBehavior.RefreshSession);
            }
            else if (AADAuthenticationOption.CompareTo("selectaccount") == 0)
            {
                platformParams = new PlatformParameters(PromptBehavior.SelectAccount);
            }

            AuthenticationResult authResult = null;
            bool retryAuth = false;

            string AccessTokenType = null, AccessToken = null;
            Uri restApi = new Uri(WebAPIUri, "/api/credentials");

            AccessToken = GetCredential();
            if (AccessToken != null)
            {
                ReturnList = await FetchList(restApi, AccessToken);
            }

            if (ReturnList == null)
            {
                DeleteCredential();
                try
                {
                    authResult = await authContext.AcquireTokenAsync(resource, clientID, redirectUri, platformParams);
                    AccessTokenType = authResult.AccessTokenType;
                    AccessToken = authResult.AccessToken;
                }
                catch (AdalException)
                {
                    retryAuth = true;
                    authResult = null;
                    AccessTokenType = null;
                    AccessToken = null;
                }

                if (retryAuth)
                {
                    try
                    {
                        authResult = await authContext.AcquireTokenAsync(resource, clientID, redirectUri, new PlatformParameters(PromptBehavior.Auto));
                        AccessTokenType = authResult.AccessTokenType;
                        AccessToken = authResult.AccessToken;
                    }
                    catch (AdalException)
                    {
                        authResult = null;
                        AccessTokenType = null;
                        AccessToken = null;
                    }
                }

                if (AccessToken != null)
                {
                    SetCredential(AccessToken);
                    ReturnList = await FetchList(restApi, AccessToken);
                }
            }

            return ReturnList;
        }

        private static async Task<List<AuthorizationHandlerCredentials>> FetchList(Uri restApi, string AccessToken)
        {
            List<AuthorizationHandlerCredentials> ReturnList = null;

            using (HttpClient client = new HttpClient())
            {
                client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", AccessToken);

                HttpResponseMessage infoResult = await client.GetAsync(restApi);

                string content = await infoResult.Content.ReadAsStringAsync();

                if (infoResult.IsSuccessStatusCode)
                {
                    ReturnList = JsonConvert.DeserializeObject<List<AuthorizationHandlerCredentials>>(content);
                }
            }

            return ReturnList;
        }

        private static bool IsValidCredentials(AuthorizationHandlerCredentials creds, bool managedIdentity)
        {
            bool isValidCredentials = true;

            if (string.IsNullOrWhiteSpace(creds.TenantId) || creds.TenantId.CompareTo("guid") == 0)
            {
                return false;
            }

            if (string.IsNullOrWhiteSpace(creds.ClientId) || creds.ClientId.CompareTo("guid") == 0)
            {
                return false;
            }

            if (managedIdentity)
            {
                if (string.IsNullOrWhiteSpace(creds.ManagedIdentityClientId) || creds.ManagedIdentityClientId.CompareTo("guid") == 0)
                {
                    return false;
                }

                if (string.IsNullOrWhiteSpace(creds.Scope) || creds.Scope.CompareTo("string") == 0)
                {
                    return false;
                }
            }
            else
            {
                if (string.IsNullOrWhiteSpace(creds.Key) || creds.Key.CompareTo("string") == 0)
                {
                    return false;
                }
            }

            return isValidCredentials;
        }
    }
}

```

`SurfaceDevCenterManager/authconfig.json`:

```json
[
  {
    "tenantId": "guid",
    "clientId": "guid",
    "managedIdentityClientId": "guid",
    "scope":  "string",
    "key": "string",
    "url": "https://manage.devcenter.microsoft.com",
    "urlPrefix": "v2.0/my"
  }
]

```

`azure-pipelines-ci.yml`:

```yml
# .NET Desktop
# Build and run tests for .NET Desktop or Windows classic desktop solutions.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/apps/windows/dot-net

pool:
  vmImage: 'VS2017-Win2016'

variables:
  solution: '**/*.sln'
  buildPlatform: 'AnyCPU'
  buildConfiguration: 'Release'

name: 1.$(Date:yyyy).$(Date:MMdd).$(Rev:r)

steps:
- task: NuGetToolInstaller@0

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(solution)'

- task: Powershell@2
  displayName: Update Assembly Version
  inputs:
    targetType: filePath
    filePath: 'build\Set-AssemblyInfo.ps1'
    arguments: '-BuildVersion $(Build.BuildNumber) -AssemblyInfoFile SurfaceDevCenterManager\Properties\AssemblyInfo.cs'
    workingDirectory: '.'

- task: VSBuild@1
  inputs:
    solution: '$(solution)'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: PublishBuildArtifacts@1
  inputs:
    PathToPublish: '$(System.DefaultWorkingDirectory)'
    name: 'drop'


```

`azure-pipelines.yml`:

```yml
# .NET Desktop
# Build and run tests for .NET Desktop or Windows classic desktop solutions.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/apps/windows/dot-net

pool:
  vmImage: 'VS2017-Win2016'

variables:
  solution: '**/*.sln'
  buildPlatform: 'AnyCPU'
  buildConfiguration: 'Release'

steps:
- task: NuGetToolInstaller@0

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(solution)'

- task: VSBuild@1
  inputs:
    solution: '$(solution)'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'


```

`build/Set-AssemblyInfo.ps1`:

```ps1
#-------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation.  All rights reserved.
# Licensed under the MIT license.  See LICENSE file in the project root for full license information.
#-------------------------------------------------------------------------------
<#
.SYNOPSIS
    Script to set the AssemblyInfo.cs version information

.PARAMETER BuildVersion
    New version to use
#>
#Requires -Version 5.0

param(
 [Parameter(Mandatory=$true,Position=0)]
 [string] $BuildVersion,

 [Parameter(Mandatory=$true,Position=1)]
 [string] $AssemblyInfoFile
)

###################################################################################################
# Global Error Handler
###################################################################################################
trap {
    Write-Output "----- TRAP ----"
    Write-Output "Unhandled Exception: $($_.Exception.GetType().Name)"
    Write-Output $_.Exception
    $_ | Format-List -Force 
}

###################################################################################################
# Globals
###################################################################################################
$global:ErrorActionPreference = "stop"
Set-StrictMode -Version Latest

###################################################################################################
# Functions
###################################################################################################

###################################################################################################
# Main
###################################################################################################
#$AssemblyInfoFile = "$PSScriptRoot\..\SurfaceDevCenterManager\Properties\AssemblyInfo.cs"

"Open: $AssemblyInfoFile" | Write-Output
$AssemblyInfo = gc $AssemblyInfoFile


"Set Version: $BuildVersion" | Write-Output
$BuildVersion = "`"$BuildVersion`""
$NewAssemblyInfo = $AssemblyInfo -replace '\"1.0.0.0\"',$BuildVersion

"Replace: $AssemblyInfoFile" | Write-Output
$NewAssemblyInfo | Out-File -Encoding ASCII -FilePath $AssemblyInfoFile


```