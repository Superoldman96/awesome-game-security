Project Path: arc_gmh5225_ClearDriverTraces_nlmf2l88

Source Tree:

```txt
arc_gmh5225_ClearDriverTraces_nlmf2l88
├── ClearDriverTraces
│   ├── Cleaning.h
│   ├── Main.cpp
│   ├── Mapper.inf
│   ├── Mapper.sln
│   ├── Mapper.vcxproj
│   ├── Mapper.vcxproj.filters
│   └── Misc.h
└── README.md

```

`ClearDriverTraces/Cleaning.h`:

```h
#pragma once
#include "Misc.h"

//21h1, you can get these from ida
ULONG PiDDBCacheTableOffset = 0xD2F000;
ULONG PiDDBLockOffset = 0xC44940;

ULONG g_KernelHashBucketListOffset = 0xBC080;
ULONG g_HashCacheLockOffset = 0x37F20;

ULONG g_CiEaCacheLookasideListOffset = 0x38400;

#pragma region MmUnloadedDrivers

typedef struct _KLDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	PVOID GpValue;
	PVOID NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused;
	PVOID SectionPointer;
	ULONG CheckSum;
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

void RemoveMmUnloadedDrivers(PDRIVER_OBJECT driverObject)
{
	reinterpret_cast<PKLDR_DATA_TABLE_ENTRY>(driverObject->DriverSection)->BaseDllName.Length = 0; // mm unloaded drivers entry is not created if base dll name is 0
}

#pragma endregion

#pragma region PiDDBCacheTable

typedef struct PiDDBCacheEntry
{
	LIST_ENTRY		list;
	UNICODE_STRING	driverName;
	ULONG			driverStamp;
	NTSTATUS		loadStatus;
};

NTSTATUS RemovePiDDBCacheTableEntry(PDRIVER_OBJECT driverObject)
{
	//get table and lock addresses
	ULONG64 kernelBase = (ULONG64)GetKernelBase(NULL);
	PRTL_AVL_TABLE PiDDBCacheTable = PRTL_AVL_TABLE(kernelBase + PiDDBCacheTableOffset);
	PERESOURCE PiDDBLock = PERESOURCE(kernelBase + PiDDBLockOffset);

	//create lookup entry
	PiDDBCacheEntry lookupEntry;
	RtlInitUnicodeString(&lookupEntry.driverName, PKLDR_DATA_TABLE_ENTRY(driverObject->DriverSection)->BaseDllName.Buffer);

	//get spinlock
	if (!ExAcquireResourceExclusiveLite(PiDDBLock, true))
	{
		Print("could not aquire PiDDB spinlock\n");
		return STATUS_UNSUCCESSFUL;
	}

	//look for entry
	PiDDBCacheEntry* foundEntry = (PiDDBCacheEntry*)(RtlLookupElementGenericTableAvl(PiDDBCacheTable, &lookupEntry));


	if (!foundEntry)
	{
		Print("could not find PiDDB entry\n");
		ExReleaseResourceLite(PiDDBLock);
		return STATUS_UNSUCCESSFUL;
	}

	//get prev and next list entries to remove our entry from list
	PLIST_ENTRY nextEntry = foundEntry->list.Flink;
	PLIST_ENTRY prevEntry = foundEntry->list.Blink;

	if (!nextEntry || !prevEntry)
	{
		Print("could not find PiDDB list links\n");
		ExReleaseResourceLite(PiDDBLock);
		return STATUS_UNSUCCESSFUL;
	}

	//replace links
	prevEntry->Flink = foundEntry->list.Flink;
	nextEntry->Blink = foundEntry->list.Blink;

	foundEntry->list.Blink = prevEntry;
	foundEntry->list.Flink = nextEntry;


	//clean entry
	WriteRandom((ULONG64)foundEntry->driverName.Buffer, foundEntry->driverName.Length);
	foundEntry->driverStamp = RandomNumber() % sizeof(ULONG);
	WriteRandom((ULONG64)&foundEntry->list, sizeof(LIST_ENTRY));
	foundEntry->loadStatus = RandomNumber() % sizeof(NTSTATUS);
	RtlDeleteElementGenericTableAvl(PiDDBCacheTable, foundEntry);

	//check if entry can still be found
	foundEntry = (PiDDBCacheEntry*)(RtlLookupElementGenericTableAvl(PiDDBCacheTable, &lookupEntry));

	if (foundEntry)
	{
		Print("could not delete PiDDB entry\n");
		ExReleaseResourceLite(PiDDBLock);
		return STATUS_UNSUCCESSFUL;
	}

	Print("cleaned PiDDB entry\n");
	ExReleaseResourceLite(PiDDBLock);
	return STATUS_SUCCESS;
}
#pragma endregion

#pragma region HashBucketList

typedef struct _HashBucketEntry
{
	struct _HashBucketEntry* Next;
	UNICODE_STRING DriverName;
	ULONG CertHash[5];
} HashBucketEntry;

NTSTATUS RemoveKernelHashBucketListEntry(PDRIVER_OBJECT driverObject)
{
	UINT64 cidllBase = GetKernelModuleBase("CI.dll");
	if (!cidllBase)
	{
		Print("failed to get ci base\n");
		return STATUS_UNSUCCESSFUL;
	}

	PSINGLE_LIST_ENTRY g_KernelHashBucketList = PSINGLE_LIST_ENTRY(cidllBase + g_KernelHashBucketListOffset);
	PERESOURCE g_HashCacheLock = PERESOURCE(cidllBase + g_HashCacheLockOffset);

	UNICODE_STRING driverName;
	RtlInitUnicodeString(&driverName, PKLDR_DATA_TABLE_ENTRY(driverObject->DriverSection)->FullDllName.Buffer + 6); //remove \??\C:

	if (!ExAcquireResourceExclusiveLite(g_HashCacheLock, true))
	{
		Print("could not get hash bucket list spinlock\n");
		return STATUS_UNSUCCESSFUL;
	}

	HashBucketEntry* currEntry = (HashBucketEntry*)g_KernelHashBucketList->Next;
	HashBucketEntry* prevEntry = (HashBucketEntry*)g_KernelHashBucketList;

	while (currEntry)
	{
		if (!RtlCompareUnicodeString(&driverName, &currEntry->DriverName, true))
		{
			//unlink
			prevEntry->Next = currEntry->Next;

			//overwrite
			currEntry->Next = (HashBucketEntry*)(RandomNumber() % sizeof(PVOID));
			WriteRandom((UINT64)&currEntry->CertHash, sizeof(currEntry->CertHash));
			WriteRandom((ULONG64)currEntry->DriverName.Buffer, currEntry->DriverName.Length);

			//free 
			ExFreePoolWithTag(currEntry, 0);
			break;
		}

		prevEntry = currEntry;
		currEntry = currEntry->Next;
	}

	currEntry = (HashBucketEntry*)g_KernelHashBucketList->Next;
	while (currEntry)
	{
		if (!RtlCompareUnicodeString(&driverName, &currEntry->DriverName, true))
		{
			Print("failed to clear hasbucketList\n");
			ExReleaseResourceLite(g_HashCacheLock);
			return STATUS_UNSUCCESSFUL;
		}
		currEntry = currEntry->Next;
	}

	Print("cleared hashbucketList\n");
	ExReleaseResourceLite(g_HashCacheLock);
	return STATUS_SUCCESS;
}

#pragma endregion

#pragma region LookasideList

NTSTATUS DeleteCiEaCacheLookasideList()
{
	UINT64 cidllBase = GetKernelModuleBase("CI.dll");
	if (!cidllBase)
	{
		Print("failed to get ci base\n");
		return STATUS_UNSUCCESSFUL;
	}


	PLOOKASIDE_LIST_EX g_CiEaCacheLookasideList = (PLOOKASIDE_LIST_EX)(cidllBase + g_CiEaCacheLookasideListOffset);
	ULONG size = g_CiEaCacheLookasideList->L.Size;
	ExDeleteLookasideListEx(g_CiEaCacheLookasideList);
	ExInitializeLookasideListEx(g_CiEaCacheLookasideList, NULL, NULL, PagedPool, 0, size, 'csIC', 0);
}

#pragma endregion

```

`ClearDriverTraces/Main.cpp`:

```cpp
#include "Cleaning.h"

void MyUnload(PDRIVER_OBJECT driverObject)
{
	Print("[s11] unloading mapper\n");
}


NTSTATUS DriverEntry(PDRIVER_OBJECT  driverObject, PUNICODE_STRING  RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);
	driverObject->DriverUnload = MyUnload;

	NTSTATUS status = STATUS_SUCCESS;
	RemoveMmUnloadedDrivers(driverObject);

	status = RemovePiDDBCacheTableEntry(driverObject);
	if (!NT_SUCCESS(status))
	{
		Print("failed to clear piddb cache %x\n", status);
		return status;
	}

	status = RemoveKernelHashBucketListEntry(driverObject);
	if (!NT_SUCCESS(status))
	{
		Print("failed to clear hashbucket list cache %x\n", status);
		return status;
	}

	status = DeleteCiEaCacheLookasideList();
	if (!NT_SUCCESS(status))
	{
		Print("failed to delete lookaside list %x\n", status);
		return status;
	}

	return status;
}


```

`ClearDriverTraces/Mapper.inf`:

```inf
;
; Mapper.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=Mapper.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
Mapper_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
Mapper.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%Mapper.DeviceDesc%=Mapper_Device, Root\Mapper ; TODO: edit hw-id

[Mapper_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
Mapper.sys

;-------------- Service installation
[Mapper_Device.NT.Services]
AddService = Mapper,%SPSVCINST_ASSOCSERVICE%, Mapper_Service_Inst

; -------------- Mapper driver install sections
[Mapper_Service_Inst]
DisplayName    = %Mapper.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\Mapper.sys

;
;--- Mapper_Device Coinstaller installation ------
;

[Mapper_Device.NT.CoInstallers]
AddReg=Mapper_Device_CoInstaller_AddReg
CopyFiles=Mapper_Device_CoInstaller_CopyFiles

[Mapper_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[Mapper_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[Mapper_Device.NT.Wdf]
KmdfService =  Mapper, Mapper_wdfsect
[Mapper_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "Mapper Installation Disk"
Mapper.DeviceDesc = "Mapper Device"
Mapper.SVCDESC = "Mapper Service"

```

`ClearDriverTraces/Mapper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Mapper", "Mapper.vcxproj", "{EB6C9087-A8AA-4160-9E90-8A8864CC8806}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|ARM.ActiveCfg = Debug|ARM
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|ARM.Build.0 = Debug|ARM
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|ARM.Deploy.0 = Debug|ARM
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|ARM64.Build.0 = Debug|ARM64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|x64.ActiveCfg = Debug|x64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|x64.Build.0 = Debug|x64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|x64.Deploy.0 = Debug|x64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|x86.ActiveCfg = Debug|Win32
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|x86.Build.0 = Debug|Win32
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Debug|x86.Deploy.0 = Debug|Win32
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|ARM.ActiveCfg = Release|ARM
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|ARM.Build.0 = Release|ARM
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|ARM.Deploy.0 = Release|ARM
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|ARM64.ActiveCfg = Release|ARM64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|ARM64.Build.0 = Release|ARM64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|ARM64.Deploy.0 = Release|ARM64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|x64.ActiveCfg = Release|x64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|x64.Build.0 = Release|x64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|x64.Deploy.0 = Release|x64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|x86.ActiveCfg = Release|x64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|x86.Build.0 = Release|x64
		{EB6C9087-A8AA-4160-9E90-8A8864CC8806}.Release|x86.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F7A011C2-B9ED-4AD4-8D29-BFF8831D6A76}
	EndGlobalSection
EndGlobal

```

`ClearDriverTraces/Mapper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{EB6C9087-A8AA-4160-9E90-8A8864CC8806}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Mapper</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Mapper.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Cleaning.h" />
    <ClInclude Include="Misc.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ClearDriverTraces/Mapper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Mapper.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Misc.h">
      <Filter>Driver Files</Filter>
    </ClInclude>
    <ClInclude Include="Cleaning.h">
      <Filter>Driver Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ClearDriverTraces/Misc.h`:

```h
#pragma once
#include <Ntifs.h>
#include <ntimage.h> 

#define Print(fmt, ...) DbgPrint("[s11]: " fmt, ##__VA_ARGS__)

PVOID GetKernelBase(ULONG* Size)
{
	typedef unsigned char uint8_t;
	auto Idt_base = reinterpret_cast<uintptr_t>(KeGetPcr()->IdtBase);
	auto align_page = *reinterpret_cast<uintptr_t*>(Idt_base + 4) >> 0xc << 0xc;

	for (; align_page; align_page -= PAGE_SIZE)
	{
		for (int index = 0; index < PAGE_SIZE - 0x7; index++)
		{
			auto current_address = static_cast<intptr_t>(align_page) + index;

			if (*reinterpret_cast<uint8_t*>(current_address) == 0x48
				&& *reinterpret_cast<uint8_t*>(current_address + 1) == 0x8D
				&& *reinterpret_cast<uint8_t*>(current_address + 2) == 0x1D
				&& *reinterpret_cast<uint8_t*>(current_address + 6) == 0xFF) //48 8d 1D ?? ?? ?? FF
			{
				auto nto_base_offset = *reinterpret_cast<int*>(current_address + 3);
				auto nto_base_ = (current_address + nto_base_offset + 7);
				if (!(nto_base_ & 0xfff))
				{
					if (Size)
						*Size = reinterpret_cast<IMAGE_NT_HEADERS64*>(nto_base_ + reinterpret_cast<IMAGE_DOS_HEADER*>(nto_base_)->e_lfanew)->OptionalHeader.SizeOfImage;

					return (PVOID)nto_base_;
				}
			}
		}
	}

	return NULL;
}


inline ULONG RandomNumber()
{
	ULONG64 tickCount;
	KeQueryTickCount(&tickCount);
	return RtlRandomEx((PULONG)&tickCount);
}

void WriteRandom(ULONG64 addr, ULONG size)
{
	for (size_t i = 0; i < size; i++)
	{
		*(char*)(addr + i) = RandomNumber() % 255;
	}
}

//zwquerysysteminformation
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;


extern "C" NTSTATUS NTAPI ZwQuerySystemInformation(ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);

PVOID QuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInfoClass, ULONG* size)
{

	int currAttempt = 0;
	int maxAttempt = 20;


QueryTry:
	if (currAttempt >= maxAttempt)
		return 0;

	currAttempt++;
	ULONG neededSize = 0;
	ZwQuerySystemInformation(SystemInfoClass, NULL, neededSize, &neededSize);
	if (!neededSize)
		goto QueryTry;

	ULONG allocationSize = neededSize;
	PVOID informationBuffer = ExAllocatePool(NonPagedPool, allocationSize);
	if (!informationBuffer)
		goto QueryTry;

	NTSTATUS status = ZwQuerySystemInformation(SystemInfoClass, informationBuffer, neededSize, &neededSize);
	if (!NT_SUCCESS(status))
	{
		ExFreePoolWithTag(informationBuffer, 0);
		goto QueryTry;
	}

	*size = allocationSize;
	return informationBuffer;
}


typedef struct _SYSTEM_MODULE_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

UINT64 GetKernelModuleBase(const char* name)
{

	ULONG size = 0;
	PSYSTEM_MODULE_INFORMATION moduleInformation = (PSYSTEM_MODULE_INFORMATION)QuerySystemInformation(SystemModuleInformation, &size);

	if (!moduleInformation || !size)
		return 0;

	for (size_t i = 0; i < moduleInformation->Count; i++)
	{
		char* fileName = (char*)moduleInformation->Module[i].FullPathName + moduleInformation->Module[i].OffsetToFileName;
		if (!strcmp(fileName, name))
		{
			UINT64 imageBase = (UINT64)moduleInformation->Module[i].ImageBase;
			ExFreePoolWithTag(moduleInformation, 0);
			return imageBase;
		}
	}

	ExFreePoolWithTag(moduleInformation, 0);
}
```

`README.md`:

```md
# ClearDriverTraces
clearing traces of a loaded driver

## DESCRIPTION  
This project gets rid of some entries left behind by loading a signed kernel driver which can lead to the certificate getting blacklisted.

## NOTES
I have only provided the right offsets for my windows version (21h1). You can get the correct offsets from ida. Open the module they are loaded in, search for them in the name search window, rebase the program to 0, and then copy their location.

## USAGE 
Compile in x64 release and sign it. Load it like any other signed driver.

```