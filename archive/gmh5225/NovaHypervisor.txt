Project Path: arc_gmh5225_NovaHypervisor_pitsm9ek

Source Tree:

```txt
arc_gmh5225_NovaHypervisor_pitsm9ek
├── Images
│   ├── logo.png
│   └── logo_transparent.png
├── LICENSE.txt
├── NovaClient
│   ├── NovaClient.cpp
│   ├── NovaClient.vcxproj
│   ├── NovaClient.vcxproj.filters
│   ├── NovaHypervisor.cpp
│   ├── NovaHypervisor.h
│   ├── Utils.cpp
│   ├── Utils.h
│   ├── pch.cpp
│   └── pch.h
├── NovaHypervisor
│   ├── AsmDescriptorTable.asm
│   ├── AsmEpt.asm
│   ├── AsmSegmentRegs.asm
│   ├── AsmVmexitHandler.asm
│   ├── AsmVmxContextState.asm
│   ├── Autolock.hpp
│   ├── DeviceControl.cpp
│   ├── DeviceControl.h
│   ├── Ept.cpp
│   ├── Ept.h
│   ├── EventInjection.cpp
│   ├── EventInjection.h
│   ├── GlobalVariables.h
│   ├── HypervisorDefinitions.h
│   ├── InlineAsm.h
│   ├── MemoryHelper.hpp
│   ├── NovaHypervisor.cpp
│   ├── NovaHypervisor.h
│   ├── NovaHypervisor.vcxproj
│   ├── NovaHypervisor.vcxproj.filters
│   ├── PoolManager.cpp
│   ├── PoolManager.h
│   ├── RegistersHandler.cpp
│   ├── RegistersHandler.h
│   ├── RequestList.hpp
│   ├── Spinlock.cpp
│   ├── Spinlock.h
│   ├── VmState.h
│   ├── VmcallHandler.cpp
│   ├── VmcallHandler.h
│   ├── VmexitHandler.cpp
│   ├── VmexitHandler.h
│   ├── Vmx.cpp
│   ├── Vmx.h
│   ├── VmxHelper.cpp
│   ├── VmxHelper.h
│   ├── WindowsDefinitions.h
│   ├── WppDefinitions.h
│   ├── pch.cpp
│   └── pch.h
├── NovaHypervisor.sln
└── README.md

```

`LICENSE.txt`:

```txt
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2025  Ido Veltzman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) 2023  Ido Veltzman
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
```

`NovaClient/NovaClient.cpp`:

```cpp
#include "pch.h"
#include "Utils.h"
#include "NovaHypervisor.h"

int main(int argc, char* argv[]) {
	if (argc < 3 || argc > 5) {
		std::cerr << "Usage: NovaClient.exe <protect | unprotect> <address> <permissions [r|w|x]>" << std::endl;
		return EXIT_FAILURE;
	}
	std::string operation = argv[1];
	std::string rawAddress(argv[2]);

	if (operation.compare("protect") != 0 && operation.compare("unprotect") != 0) {
		std::cerr << "Invalid operation" << std::endl;
		return EXIT_FAILURE;
	}

	try {
		NovaHypervisor novaHypervisor = NovaHypervisor();
		UINT64 address = GetAddress(rawAddress);

		if (operation.compare("protect") == 0) {
			ProtectedMemory protectedMemory = { 0 };

			if (argc < 4) {
				std::cerr << "Missing permissions argument" << std::endl;
				return EXIT_FAILURE;
			}
			protectedMemory.Address = address;
			protectedMemory.Permissions = novaHypervisor.TranslatePermissions(argv[3]);
			
			if (protectedMemory.Permissions & EPT_PAGE_WRITE && !(protectedMemory.Permissions & EPT_PAGE_READ)) {
				std::cerr << "Cannot set write bit and not read bit" << std::endl;
				return EXIT_FAILURE;
			}

			if (novaHypervisor.ProtectAddressRange(protectedMemory)) {
				std::cout << "Protected address: 0x" << std::hex << protectedMemory.Address << " with permissions: " 
					<< argv[3] << std::endl;
				return EXIT_SUCCESS;
			}
			std::cerr << "Failed to protect address" << std::endl;
			return EXIT_FAILURE;
		}
		else if (operation.compare("unprotect") == 0) {
			if (novaHypervisor.UnprotectAddressRange(address)) {
				std::cout << "Unprotected address: 0x" << std::hex << address << std::endl;
				return EXIT_SUCCESS;
			}
			std::cerr << "Failed to protect address" << std::endl;
			return EXIT_FAILURE;
		}
	}
	catch (const std::runtime_error& e) {
		std::cerr << e.what() << std::endl;
		return EXIT_FAILURE;
	}

	return EXIT_SUCCESS;
}
```

`NovaClient/NovaClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{903e47b4-0017-4749-b094-1363ab0a3632}</ProjectGuid>
    <RootNamespace>NovaClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="NovaClient.cpp" />
    <ClCompile Include="NovaHypervisor.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NovaHypervisor.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NovaClient/NovaClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NovaClient.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NovaHypervisor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NovaHypervisor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NovaClient/NovaHypervisor.cpp`:

```cpp
#include "pch.h"
#include "NovaHypervisor.h"

NovaHypervisor::NovaHypervisor() {
	hNova = NULL;

	if (!IsVmxSupported())
		throw std::runtime_error("VMX is not supported on this system");

	hNova = CreateFile(DRIVER_NAME, GENERIC_WRITE | GENERIC_READ, 0, nullptr, OPEN_EXISTING, 0, nullptr);

	if (!ValidHandle(hNova))
		throw std::runtime_error("Failed to open Nova driver");
}

NovaHypervisor::~NovaHypervisor() {
	if (hNova && hNova != INVALID_HANDLE_VALUE)
		CloseHandle(hNova);
}

/*
 * Description:
 * IsVmxSupported checks if VMX is supported on the current system.
 *
 * Parameters:
 * There are no parameters.
 *
 * Returns:
 * @supported [bool] -- True if VMX is supported, false otherwise.
 */
bool NovaHypervisor::IsVmxSupported() {
	std::array<int, 4> cpuInfo{};
	__cpuid(cpuInfo.data(), 1);
	return (cpuInfo[2] & (1 << 5)) != 0;
}

/*
 * Description:
 * ProtectAddressRange protects a range of memory.
 *
 * Parameters:
 * @protectedMemory [_In_ ProtectedMemory] -- The protected memory structure.
 *
 * Returns:
 * @protected	   [bool]				   -- True if the address was protected successfully, false otherwise.
 */
bool NovaHypervisor::ProtectAddressRange(_In_ ProtectedMemory protectedMemory) const {
	if (!ValidHandle(hNova))
		return false;
	DWORD bytesReturned = 0;
	BOOL result = DeviceIoControl(hNova, IOCTL_PROTECT_ADDRESS_RANGE, &protectedMemory, sizeof(protectedMemory),
		nullptr, 0, &bytesReturned, nullptr);
	return result == TRUE;
}

/*
 * Description:
 * UnprotectAddressRange unprotects a range of memory.
 *
 * Parameters:
 * @address	  [_In_ UINT64] -- The address to unprotect.
 *
 * Returns:
 * @protected [bool]		-- True if the address was unprotected successfully, false otherwise.
 */
bool NovaHypervisor::UnprotectAddressRange(_In_ UINT64 address) const {
	if (!ValidHandle(hNova))
		return false;
	DWORD bytesReturned = 0;
	BOOL result = DeviceIoControl(hNova, IOCTL_UNPROTECT_ADDRESS_RANGE, &address, sizeof(address),
		nullptr, 0, &bytesReturned, nullptr);
	return result == TRUE;
}

/*
 * Description:
 * TranslatePermissions translates the permissions string to a UINT8 value.
 *
 * Parameters:
 * @permissions [_In_ const std::string&] -- The permissions string.
 *
 * Returns:
 * @result	    [UINT8]				      -- The translated permissions.
 */
UINT8 NovaHypervisor::TranslatePermissions(_In_ const std::string& permissions) const {
	UINT8 result = 0;

	if (permissions.size() > 3)
		throw std::runtime_error("Invalid permissions string");

	if (permissions.find('r') != std::string::npos)
		result |= EPT_PAGE_READ;
	if (permissions.find('w') != std::string::npos)
		result |= EPT_PAGE_WRITE;
	if (permissions.find('x') != std::string::npos)
		result |= EPT_PAGE_EXECUTE;
	return result;
}
```

`NovaClient/NovaHypervisor.h`:

```h
#pragma once
#include "pch.h"

constexpr const wchar_t* DRIVER_NAME = LR"(\\.\NovaHypervisor)";
constexpr ULONG IOCTL_PROTECT_ADDRESS_RANGE = CTL_CODE(0x8000, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS);
constexpr ULONG IOCTL_UNPROTECT_ADDRESS_RANGE = CTL_CODE(0x8000, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS);

typedef struct {
	UINT8 Permissions;
	UINT64 Address;
} ProtectedMemory;

enum EptPagePermissions {
	EPT_PAGE_READ = 1,
	EPT_PAGE_WRITE = 2,
	EPT_PAGE_EXECUTE = 4,
	EPT_ALL_PERMISSIONS = EPT_PAGE_READ | EPT_PAGE_WRITE | EPT_PAGE_EXECUTE,
	EPT_MAX_PAGE_PERMISSIONS = EPT_ALL_PERMISSIONS
};

class NovaHypervisor
{
private:
	HANDLE hNova;

	static constexpr auto ValidHandle = [](HANDLE h) -> bool {
		return h && h != INVALID_HANDLE_VALUE;
	};
	bool IsVmxSupported();

public:
	NovaHypervisor();
	~NovaHypervisor();
	bool ProtectAddressRange(_In_ ProtectedMemory protectedMemory) const;
	bool UnprotectAddressRange(_In_ UINT64 address) const;
	UINT8 TranslatePermissions(_In_ const std::string& permissions) const;
};

```

`NovaClient/Utils.cpp`:

```cpp
#include "pch.h"
#include "Utils.h"

UINT64 GetAddress(_In_ std::string address) {
	UINT64 result = atoi(address.c_str());

	if (result != 0)
		return result;

	if (!address.starts_with("0x") && !address.starts_with("0X"))
		throw std::runtime_error("Invalid address format");

	std::stringstream addressStream;
	addressStream << std::hex << address;
	addressStream >> result;
	return result;
}
```

`NovaClient/Utils.h`:

```h
#pragma once
#include "pch.h"

UINT64 GetAddress(_In_ std::string address);
```

`NovaClient/pch.cpp`:

```cpp
#include "pch.h"

```

`NovaClient/pch.h`:

```h
#pragma once
#include <iostream>
#include <array>
#include <intrin.h>
#include <sstream>
#include <Windows.h>
```

`NovaHypervisor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35327.3
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NovaHypervisor", "NovaHypervisor\NovaHypervisor.vcxproj", "{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NovaClient", "NovaClient\NovaClient.vcxproj", "{903E47B4-0017-4749-B094-1363AB0A3632}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Debug|ARM64.Build.0 = Debug|ARM64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Debug|x64.ActiveCfg = Debug|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Debug|x64.Build.0 = Debug|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Debug|x64.Deploy.0 = Debug|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Debug|x86.ActiveCfg = Debug|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Debug|x86.Build.0 = Debug|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Debug|x86.Deploy.0 = Debug|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Release|ARM64.ActiveCfg = Release|ARM64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Release|ARM64.Build.0 = Release|ARM64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Release|ARM64.Deploy.0 = Release|ARM64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Release|x64.ActiveCfg = Release|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Release|x64.Build.0 = Release|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Release|x64.Deploy.0 = Release|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Release|x86.ActiveCfg = Release|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Release|x86.Build.0 = Release|x64
		{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}.Release|x86.Deploy.0 = Release|x64
		{903E47B4-0017-4749-B094-1363AB0A3632}.Debug|ARM64.ActiveCfg = Debug|x64
		{903E47B4-0017-4749-B094-1363AB0A3632}.Debug|ARM64.Build.0 = Debug|x64
		{903E47B4-0017-4749-B094-1363AB0A3632}.Debug|x64.ActiveCfg = Debug|x64
		{903E47B4-0017-4749-B094-1363AB0A3632}.Debug|x64.Build.0 = Debug|x64
		{903E47B4-0017-4749-B094-1363AB0A3632}.Debug|x86.ActiveCfg = Debug|Win32
		{903E47B4-0017-4749-B094-1363AB0A3632}.Debug|x86.Build.0 = Debug|Win32
		{903E47B4-0017-4749-B094-1363AB0A3632}.Release|ARM64.ActiveCfg = Release|x64
		{903E47B4-0017-4749-B094-1363AB0A3632}.Release|ARM64.Build.0 = Release|x64
		{903E47B4-0017-4749-B094-1363AB0A3632}.Release|x64.ActiveCfg = Release|x64
		{903E47B4-0017-4749-B094-1363AB0A3632}.Release|x64.Build.0 = Release|x64
		{903E47B4-0017-4749-B094-1363AB0A3632}.Release|x86.ActiveCfg = Release|Win32
		{903E47B4-0017-4749-B094-1363AB0A3632}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F6F14612-203A-4F7F-A819-33DAE39E8E9E}
	EndGlobalSection
EndGlobal

```

`NovaHypervisor/AsmDescriptorTable.asm`:

```asm
PUBLIC AsmGetLdtr
PUBLIC AsmGetGdtBase
PUBLIC AsmGetIdtBase
PUBLIC AsmGetGdtLimit
PUBLIC AsmGetIdtLimit
PUBLIC AsmReloadGdtr
PUBLIC AsmReloadIdtr

.code _text

AsmGetLdtr PROC
	sldt	rax
	ret
AsmGetLdtr ENDP

AsmGetGdtBase PROC

	LOCAL	gdtr[10]:BYTE
	sgdt	gdtr
	mov		rax, QWORD PTR gdtr[2]
	ret
AsmGetGdtBase ENDP

AsmGetIdtBase PROC
	LOCAL	idtr[10]:BYTE
	
	sidt	idtr
	mov		rax, QWORD PTR idtr[2]
	ret
AsmGetIdtBase ENDP

AsmGetGdtLimit PROC
	LOCAL	gdtr[10]:BYTE

	sgdt	gdtr
	mov		ax, WORD PTR gdtr[0]
	ret
AsmGetGdtLimit ENDP

AsmGetIdtLimit PROC
	LOCAL	idtr[10]:BYTE
	
	sidt	idtr
	mov		ax, WORD PTR idtr[0]
	ret
AsmGetIdtLimit ENDP

;
; Description:
; AsmReloadGdtr is responsible for reloading gdt.
;
; Parameters:
; @GdtBase	  [PVOID]  -- Gdt base.
; @GdtLimit	  [UINT32] -- Gdt limit.
;
; Returns:
; @gdt		  [PVOID]  -- New gdt.
;
AsmReloadGdtr PROC

    push	rcx
    shl		rdx, 48
    push	rdx
    lgdt	fword ptr [rsp+6]
    pop		rax
    pop		rax
    ret
    
AsmReloadGdtr ENDP

;
; Description:
; AsmReloadIdtr is responsible for reloading idt.
;
; Parameters:
; @IdtBase	  [PVOID]  -- Idt base.
; @IdtLimit	  [UINT32] -- Idt limit.
;
; Returns:
; @idt		  [PVOID]  -- New idt.
;

AsmReloadIdtr PROC
    
    push	rcx
    shl		rdx, 48
    push	rdx
    lidt	fword ptr [rsp+6]
    pop		rax
    pop		rax
    ret
    
AsmReloadIdtr ENDP

END
```

`NovaHypervisor/AsmEpt.asm`:

```asm
PUBLIC AsmInvept
PUBLIC AsmInvvpid

.code _text

VMX_ERROR_CODE_FAILED_WITH_STATUS   = 1
VMX_ERROR_CODE_FAILED               = 2

;
; Description:
; AsmInvept is responsible for invalidating the EPT cache.
;
; Parameters:
; @rcx		   [RegionType]   -- The region type to allocate.
; @rdx		   [INVEPT_DESC*] -- The address of the EPTP to invalidate.
;
; Returns:
; @invalidated [UCHAR]		  -- 0 if invalidated successfully, 1 if failed with status, 2 failed without status.
;
AsmInvept PROC PUBLIC
    invept  rcx, oword ptr [rdx]
    jz @ErrorWithStatus
    jc @ErrorNoStatus
    xor     rax, rax
    ret

    @ErrorWithStatus: 
    mov     rax, VMX_ERROR_CODE_FAILED_WITH_STATUS
    ret

    @ErrorNoStatus:
    mov     rax, VMX_ERROR_CODE_FAILED
    ret
AsmInvept ENDP

;
; Description:
; AsmInvvpid is responsible for invalidating virtual translation for a processor.
;
; Parameters:
; @rcx		   [RegionType]   -- The region type to allocate.
; @rdx		   [INVEPT_DESC*] -- The address of the EPTP to invalidate.
;
; Returns:
; @invalidated [UCHAR]		  -- 0 if invalidated successfully, 1 if failed with status, 2 failed without status.
;
AsmInvvpid PROC PUBLIC
    invvpid  rcx, oword ptr [rdx]
    jz @ErrorWithStatus
    jc @ErrorNoStatus
    xor     rax, rax
    ret

    @ErrorWithStatus: 
    mov     rax, VMX_ERROR_CODE_FAILED_WITH_STATUS
    ret

    @ErrorNoStatus:
    mov     rax, VMX_ERROR_CODE_FAILED
    ret
AsmInvvpid ENDP

END
```

`NovaHypervisor/AsmSegmentRegs.asm`:

```asm
PUBLIC AsmGetCs
PUBLIC AsmGetDs
PUBLIC AsmGetEs
PUBLIC AsmGetSs
PUBLIC AsmGetFs
PUBLIC AsmGetGs
PUBLIC AsmGetTr
PUBLIC AsmGetRflags

.code _text

AsmGetRflags PROC
	pushfq
	pop		rax
	ret
AsmGetRflags ENDP

AsmGetCs PROC
	mov		rax, cs
	ret
AsmGetCs ENDP

AsmGetDs PROC
	mov		rax, ds
	ret
AsmGetDs ENDP

AsmGetEs PROC
	mov		rax, es
	ret
AsmGetEs ENDP

AsmGetSs PROC
	mov		rax, ss
	ret
AsmGetSs ENDP

AsmGetFs PROC
	mov		rax, fs
	ret
AsmGetFs ENDP

AsmGetGs PROC
	mov		rax, gs
	ret
AsmGetGs ENDP

AsmGetTr PROC
	str	rax
	ret
AsmGetTr ENDP

END
```

`NovaHypervisor/AsmVmexitHandler.asm`:

```asm
PUBLIC AsmVmexitHandler

EXTERN VmexitHandler:PROC
EXTERN VmResumeInstruction:PROC
EXTERN GetCurrentGuestRsp:PROC
EXTERN GetCurrentGuestRip:PROC

.code _text

;
; Description:
; AsmVmexitHandler is responsible for handling vmexit
;
; Parameters:
; There are no parameters.
;
; Returns:
; There is no return value.
;
AsmVmexitHandler PROC
    ; Stack alignment
    push 0

    pushfq
    push r15
    push r14
    push r13
    push r12
    push r11
    push r10
    push r9
    push r8        
    push rdi
    push rsi
    push rbp
    push rbp ; rsp
    push rbx
    push rdx
    push rcx
    push rax	

    ; Calling the VmexitHandler
    ; Subbing 0x28 from rsp for shadow space for the guest registers
	mov rcx, rsp
	sub	rsp, 28h
	call	VmexitHandler
	add	rsp, 28h

    ; Check if we need to perform vmxoff
	cmp	al, 1
	je		AsmVmxoffHandler

    ; Restore the guest state
	pop rax
    pop rcx
    pop rdx
    pop rbx
    pop rbp		; rsp
    pop rbp
    pop rsi
    pop rdi 
    pop r8
    pop r9
    pop r10
    pop r11
    pop r12
    pop r13
    pop r14
    pop r15
    popfq

	sub rsp, 0100h
	jmp VmResumeInstruction
AsmVmexitHandler ENDP

;
; Description:
; AsmVmxoffHandler is responsible for handling vmxoff and return to the guest
;
; Parameters:
; There are no parameters.
;
; Returns:
; There is no return value.
;
AsmVmxoffHandler PROC
    ; Getting the guest's rsp
    sub rsp, 020h
    call GetCurrentGuestRsp
    add rsp, 020h

    ; Getting the guest rip
    mov [rsp+088h], rax
    sub rsp, 020h
    call GetCurrentGuestRip
    add rsp, 020h

    ; Loading the guest rsp and pushing the return address to the stack
    mov rdx, rsp
    mov rbx, [rsp+088h]
    mov rsp, rbx
    push rax
    mov rsp, rdx

    ; Because there was a push, need to add 8 to the stack
    sub rbx,08h
    mov [rsp+088h], rbx

	pop rax
    pop rcx
    pop rdx
    pop rbx
    pop rbp ; rsp
    pop rbp
    pop rsi
    pop rdi 
    pop r8
    pop r9
    pop r10
    pop r11
    pop r12
    pop r13
    pop r14
    pop r15
    popfq

	pop rsp
	ret
AsmVmxoffHandler ENDP

END

```

`NovaHypervisor/AsmVmxContextState.asm`:

```asm
PUBLIC AsmVmxVmcall
PUBLIC AsmHypervVmcall
PUBLIC AsmVmxSaveState
PUBLIC AsmVmxRestoreState

EXTERN VirtualizeProcessor:PROC

.code _text

NO_HYPERV_MAGIC  = 4e4f485950455256H ; "NOHYPERV"
VMCALL_MAGIC	 = 564d43414c4cH	 ; "VMCALL"
HYPERVISOR_MAGIC = 4856544d50H		 ; "HVTMP"

;
; Description:
; AsmVmxVmcall is responsible for issueing a vmcall instruction.
;
; Parameters:
; @VmcallNumber	  [UINT64]	 -- Vmcall number
; @OptionalParam1 [UINT64]	 -- Parameter 1
; @OptionalParam2 [UINT64]	 -- Parameter 2
; @OptionalParam3 [UINT64]	 -- Parameter 3
;
; Returns:
; @status		  [NTSTATUS] -- STATUS_SUCCESS if the vmcall was successful, otherwise an error code.
;
AsmVmxVmcall PROC
	pushfq
    push    r10
    push    r11
    push    r12
    mov     r10, HYPERVISOR_MAGIC
    mov     r11, VMCALL_MAGIC
    mov     r12, NO_HYPERV_MAGIC
    vmcall
    pop     r12
    pop     r11
    pop     r10
    popfq
    ret    
AsmVmxVmcall ENDP

;
; Description:
; AsmHypervVmcall is responsible for issueing a vmcall to hyperv.
;
; Parameters:
; @HypercallNumber [UINT64]	 -- Hypercall number
; @InputParam      [UINT64]	 -- The guest physical address of the input parameter.
; @OutputParam     [UINT64]	 -- The guest physical address of the output parameter.
;
; Returns:
; @status		  [NTSTATUS] -- STATUS_SUCCESS if the vmcall was successful, otherwise an error code.
;
AsmHypervVmcall PROC
    ; Saving the registers
    pushfq

    push r15
    push r14
    push r13
    push r12
    push r11
    push r10
    push r9
    push r8        
    push rdi
    push rsi
    push rbp
    push rbp	; rsp
    push rbx
    push rdx
    push rcx
    push rax

    ; Unpacking the registers from rcx
    mov rax, qword ptr [rcx+0h]
    mov rdx, qword ptr [rcx+10h]
    mov rbx, qword ptr [rcx+18h]
    mov rbp, qword ptr [rcx+28h]
    mov rsi, qword ptr [rcx+30h]
    mov rdi, qword ptr [rcx+38h]
    mov r8, qword ptr [rcx+40h]
    mov r9, qword ptr [rcx+48h]
    mov r10, qword ptr [rcx+50h]
    mov r11, qword ptr [rcx+58h]
    mov r12, qword ptr [rcx+60h]
    mov r13, qword ptr [rcx+68h]
    mov r14, qword ptr [rcx+70h]
    mov r15, qword ptr [rcx+78h]

    ; Saving the packed rcx
    push rcx
    mov rcx, qword ptr [rcx+08h]

    vmcall

    ; Restoring the state
    pop rcx

    mov qword ptr [rcx+0h], rax
    mov qword ptr [rcx+10h], rdx
    mov qword ptr [rcx+18h], rbx
    mov qword ptr [rcx+28h], rbp
    mov qword ptr [rcx+30h], rsi
    mov qword ptr [rcx+38h], rdi
    mov qword ptr [rcx+40h], r8
    mov qword ptr [rcx+48h], r9
    mov qword ptr [rcx+50h], r10
    mov qword ptr [rcx+58h], r11
    mov qword ptr [rcx+60h], r12
    mov qword ptr [rcx+68h], r13
    mov qword ptr [rcx+70h], r14
    mov qword ptr [rcx+78h], r15
    mov qword ptr [rcx+08h], rcx

    pop rax
    pop rcx
    pop rdx
    pop rbx
    pop rbp		; rsp
    pop rbp
    pop rsi
    pop rdi 
    pop r8
    pop r9
    pop r10
    pop r11
    pop r12
    pop r13
    pop r14
    pop r15
    popfq
    ret
AsmHypervVmcall ENDP

;
; Description:
; AsmVmxSaveState is responsible for saving the current state and launching the vm.
;
; Parameters:
; There are no parameters.
;
; Returns:
; There is no return value.
;
AsmVmxSaveState PROC
	pushfq	; save r/eflag

	push rax
	push rcx
	push rdx
	push rbx
	push rbp
	push rsi
	push rdi
	push r8
	push r9
	push r10
	push r11
	push r12
	push r13
	push r14
	push r15

	sub rsp, 0100h
	mov rcx, rsp

	call VirtualizeProcessor

	; Shouldn't be reached, added for fail safe.
	int 3
	jmp AsmVmxRestoreState
AsmVmxSaveState ENDP

;
; Description:
; AsmVmxRestoreState is responsible for restoring the state.
;
; Parameters:
; There are no parameters.
;
; Returns:
; There is no return value.
;
AsmVmxRestoreState PROC
	add rsp, 0100h

	pop r15
	pop r14
	pop r13
	pop r12
	pop r11
	pop r10
	pop r9
	pop r8
	pop rdi
	pop rsi
	pop rbp
	pop rbx
	pop rdx
	pop rcx
	pop rax
	popfq

	ret	
AsmVmxRestoreState ENDP

END

```

`NovaHypervisor/Autolock.hpp`:

```hpp
#pragma once
#include "pch.h"

template<typename TLock>
struct AutoLock {
	AutoLock(TLock& lock) : _lock(lock) {
		_lock.Lock();
	}

	~AutoLock() {
		_lock.Unlock();
	}

private:
	TLock& _lock;
};
```

`NovaHypervisor/DeviceControl.cpp`:

```cpp
#include "pch.h"
#include "DeviceControl.h"

/*
* Description:
* NovaDeviceControl is responsible for handling IOCTLs.
*
* Parameters:
* @DeviceObject [PDEVICE_OBJECT] -- Not used.
* @Irp			[PIRP]			 -- The IRP that contains the user data such as SystemBuffer, Irp stack, etc.
*
* Returns:
* @status		[NTSTATUS]		 -- Always will be STATUS_SUCCESS.
*/
NTSTATUS NovaDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);
	NTSTATUS status = STATUS_SUCCESS;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG size = stack->Parameters.DeviceIoControl.InputBufferLength;

	switch (stack->Parameters.DeviceIoControl.IoControlCode) {
		case IOCTL_PROTECT_ADDRESS_RANGE: {
			if (size != sizeof(HookedPage)) {
				status = STATUS_INVALID_PARAMETER;
				break;
			}
			HookedPage* hookedPage = static_cast<HookedPage*>(Irp->AssociatedIrp.SystemBuffer);

			if (!VALID_KERNELMODE_MEMORY(hookedPage->Address) ||
				hookedPage->Permissions > EPT_MAX_PAGE_PERMISSIONS ||
				hookedPage->Permissions & EPT_PAGE_WRITE && !(hookedPage->Permissions & EPT_PAGE_READ)) {
				status = STATUS_INVALID_PARAMETER;
				break;
			}

			status = static_cast<NTSTATUS>(KeIpiGenericCall(reinterpret_cast<PKIPI_BROADCAST_WORKER>(VmxHelper::HookPageByVmcall), 
				reinterpret_cast<UINT64>(hookedPage)));

			if (!NT_SUCCESS(status)) {
				NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to hook page 0x%llx with permissions 0x%llx (0x%08X)",
					hookedPage->Address, hookedPage->Permissions, status);
				break;
			}
			NovaHypervisorLog(TRACE_FLAG_INFO, "Hooked page 0x%llx with permissions 0x%llx",
				hookedPage->Address, hookedPage->Permissions);
			break;
		}
		case IOCTL_UNPROTECT_ADDRESS_RANGE: {
			if (size != sizeof(UINT64)) {
				status = STATUS_INVALID_PARAMETER;
				break;
			}
			UINT64* protectedMemory = static_cast<UINT64*>(Irp->AssociatedIrp.SystemBuffer);

			if (!VALID_KERNELMODE_MEMORY(*protectedMemory)) {
				status = STATUS_INVALID_PARAMETER;
				break;
			}

			status = static_cast<NTSTATUS>(KeIpiGenericCall(reinterpret_cast<PKIPI_BROADCAST_WORKER>(VmxHelper::UnhookPageByVmcall),
				*protectedMemory));

			if (!NT_SUCCESS(status))
				NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to unhook page 0x%llx (0x%08X)", *protectedMemory, status);
			break;
		}
		default: {
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}
	}

	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
```

`NovaHypervisor/DeviceControl.h`:

```h
#pragma once
#include "pch.h"
#include "GlobalVariables.h"
#include "HypervisorDefinitions.h"
#include "Ept.h"
#include "WppDefinitions.h"
#include "DeviceControl.tmh"

constexpr int IOCTL_PROTECT_ADDRESS_RANGE = CTL_CODE(0x8000, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS);
constexpr int IOCTL_UNPROTECT_ADDRESS_RANGE = CTL_CODE(0x8000, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS);

constexpr auto IsValidSize = [](_In_ size_t dataSize, _In_ size_t structSize) -> bool {
	return dataSize != 0 && dataSize % structSize == 0;
};

constexpr auto VALID_KERNELMODE_MEMORY = [](_In_ size_t address) -> bool {
	return address > 0x8000000000000000 && address < 0xFFFFFFFFFFFFFFFF;
};

DRIVER_DISPATCH NovaDeviceControl;
```

`NovaHypervisor/Ept.cpp`:

```cpp
#include "pch.h"
#include "Ept.h"

Ept::Ept() {
	eptPointer = { 0 };
	numberOfEnabledMemoryRanges = 0;
	eptPageTable = NULL;
	defaultMemoryType = 0xFF;
	executeOnlySupport = true;
	memset(memoryRanges, 0, sizeof(memoryRanges));
	hookedPages = AllocateVirtualMemory<PLIST_ENTRY>(sizeof(LIST_ENTRY), false);

	if (!hookedPages) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to allocate memory for hooked pages list");
		ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
	}
	InitializeListHead(hookedPages);
	hookedPagesLock = Spinlock();

	if (!CheckFeatures()) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "EPT features are not supported by the processor");
		FreeVirtualMemory(hookedPages);
		ExRaiseStatus(STATUS_NOT_SUPPORTED);
	}
	BuildMtrrMap();
	NovaHypervisorLog(TRACE_FLAG_INFO, "MTRR memory map built successfully");

	if (!LogicalProcessorInitialize()) {
		FreeVirtualMemory(hookedPages);
		ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
	}
}

Ept::~Ept() {
	UnhookAllPages();
	FreeVirtualMemory(hookedPages);

	if (this->eptPageTable) {
		MmFreeContiguousMemory(this->eptPageTable);
		this->eptPageTable = NULL;
	}
}

/*
* Description:
* GetEptPointerFlags is responsible for returning the flags member from the EPT pointer.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @flags [ULONG64] -- EPT pointer flags.
*/
ULONG64 Ept::GetEptPointerFlags() const {
	return eptPointer.Flags;
}

/*
* Description:
* CheckFeatures is responsible for checking that all the critical EPT features are supported by the processor.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @supported [bool] -- True if all the critical EPT features are supported, otherwise false.
*/
bool Ept::CheckFeatures() {
	IA32_VMX_EPT_VPID_CAP_REGISTER vpidRegister = { 0 };
	IA32_MTRR_DEF_TYPE_REGISTER mtrrDefType = { 0 };

	vpidRegister.Flags = __readmsr(MSR_IA32_VMX_EPT_VPID_CAP);
	mtrrDefType.Flags = __readmsr(MSR_IA32_MTRR_DEF_TYPE);

	if (!vpidRegister.PageWalkLength4 || !vpidRegister.MemoryTypeWriteBack || !vpidRegister.Pde2MbPages || 
		!mtrrDefType.MtrrEnable) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "EPT is not supported by the processor.");
		return false;
	}

	if (!vpidRegister.AdvancedVmexitEptViolationsInformation)
		NovaHypervisorLog(TRACE_FLAG_WARNING, "The processor doesn't report advanced vmexit information for EPT violations.");

	if (!vpidRegister.ExecuteOnlyPages) {
		executeOnlySupport = false;
		NovaHypervisorLog(TRACE_FLAG_WARNING, "The processor doesn't support execute-only pages.");
	}

	NovaHypervisorLog(TRACE_FLAG_INFO, "All important EPT features are present.");
	return true;
}

/*
* Description:
* BuildMtrrMap is responsible for building the MTRR map.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void Ept::BuildMtrrMap() {
	IA32_MTRR_CAPABILITIES_REGISTER mtrrCapabilities = { 0 };
	IA32_MTRR_PHYSBASE_REGISTER currentPhyiscalBase = { 0 };
	IA32_MTRR_PHYSMASK_REGISTER currentPhysicalMask = { 0 };
	IA32_MTRR_FIXED_RANGE_TYPE k64Types = { 0 };
	IA32_MTRR_FIXED_RANGE_TYPE k16Types = { 0 };
	IA32_MTRR_FIXED_RANGE_TYPE k4Types = { 0 };
	PMTRR_RANGE_DESCRIPTOR descriptor = nullptr;
	ULONG numberOfBitsInMask = 0;
	IA32_MTRR_DEF_TYPE_REGISTER mtrrDefType = { 0 };
	mtrrDefType.Flags = __readmsr(MSR_IA32_MTRR_DEF_TYPE);

	if (!mtrrDefType.MtrrEnable) {
		this->defaultMemoryType = MEMORY_TYPE_UNCACHEABLE;
		return;
	}
	this->defaultMemoryType = static_cast<UCHAR>(mtrrDefType.DefaultMemoryType);
	mtrrCapabilities.Flags = __readmsr(MSR_IA32_MTRR_CAPABILITIES);

	if (mtrrCapabilities.FixedRangeSupported && mtrrDefType.FixedRangeMtrrEnable) {
		k64Types.All = __readmsr(IA32_MTRR_FIX64K_00000);

		for (unsigned int i = 0; i < 8; i++) {
			descriptor = &this->memoryRanges[this->numberOfEnabledMemoryRanges++];
			descriptor->MemoryType = k64Types.s.Types[i];
			descriptor->PhysicalBaseAddress = IA32_MTRR_FIX64K_BASE + (IA32_MTRR_FIX64K_SIZE * i);
			descriptor->PhysicalEndAddress = IA32_MTRR_FIX64K_BASE + (IA32_MTRR_FIX64K_SIZE * i) + (IA32_MTRR_FIX64K_SIZE - 1);
			descriptor->FixedRange = true;
		}

		for (unsigned int i = 0; i < 2; i++) {
			k16Types.All = __readmsr(IA32_MTRR_FIX16K_80000 + i);

			for (unsigned int j = 0; j < 8; j++) {
				descriptor = &this->memoryRanges[this->numberOfEnabledMemoryRanges++];
				descriptor->MemoryType = k16Types.s.Types[j];
				descriptor->PhysicalBaseAddress = (IA32_MTRR_FIX16K_BASE + (i * IA32_MTRR_FIX16K_SIZE * 8)) + (IA32_MTRR_FIX16K_SIZE * j);
				descriptor->PhysicalEndAddress = (IA32_MTRR_FIX16K_BASE + (i * IA32_MTRR_FIX16K_SIZE * 8)) + (IA32_MTRR_FIX16K_SIZE * j) +
					(IA32_MTRR_FIX16K_SIZE - 1);
				descriptor->FixedRange = true;
			}
		}

		for (unsigned int i = 0; i < 8; i++) {
			k4Types.All = __readmsr(IA32_MTRR_FIX4K_C0000 + i);

			for (unsigned int j = 0; j < 8; j++) {
				descriptor = &this->memoryRanges[this->numberOfEnabledMemoryRanges++];
				descriptor->MemoryType = k4Types.s.Types[j];
				descriptor->PhysicalBaseAddress = (IA32_MTRR_FIX4K_BASE + (i * IA32_MTRR_FIX4K_SIZE * 8)) + (IA32_MTRR_FIX4K_SIZE * j);
				descriptor->PhysicalEndAddress = (IA32_MTRR_FIX4K_BASE + (i * IA32_MTRR_FIX4K_SIZE * 8)) + (IA32_MTRR_FIX4K_SIZE * j) +
					(IA32_MTRR_FIX4K_SIZE - 1);
				descriptor->FixedRange = true;
			}
		}
	}

	for (UINT64 currentRegister = 0; currentRegister < mtrrCapabilities.VariableRangeCount; currentRegister++) {
		currentPhyiscalBase.Flags = __readmsr(MSR_IA32_MTRR_PHYSBASE0 + (currentRegister * 2));
		currentPhysicalMask.Flags = __readmsr(MSR_IA32_MTRR_PHYSMASK0 + (currentRegister * 2));

		if (currentPhysicalMask.Valid) {
			descriptor = &this->memoryRanges[this->numberOfEnabledMemoryRanges++];
			descriptor->PhysicalBaseAddress = currentPhyiscalBase.PageFrameNumber * PAGE_SIZE;
			_BitScanForward64(&numberOfBitsInMask, currentPhysicalMask.PageFrameNumber * PAGE_SIZE);
			descriptor->PhysicalEndAddress = descriptor->PhysicalBaseAddress + (1ULL << numberOfBitsInMask) - 1;
			descriptor->MemoryType = (UCHAR)currentPhyiscalBase.Type;
			descriptor->FixedRange = false;

			if (descriptor->MemoryType == MEMORY_TYPE_WRITE_BACK)
				this->numberOfEnabledMemoryRanges--;
			NovaHypervisorLog(TRACE_FLAG_DEBUG, "MTRR Range: Base=0x%llx End=0x%llx Type=0x%x", descriptor->PhysicalBaseAddress, descriptor->PhysicalEndAddress,
				descriptor->MemoryType);
		}
	}
	NovaHypervisorLog(TRACE_FLAG_INFO, "Default memory type: 0x%x", this->defaultMemoryType);
}

/*
* Description:
* GetPml1Entry is responsible for getting a PML1 entry.
*
* Parameters:
* @physicalAddress [_In_ SIZE_T]				 -- The physical address to search.
*
* Returns:
* @pml1			   [PEPT_PML1_ENTRY]			 -- The PML1 entry.
*/
PEPT_PML1_ENTRY Ept::GetPml1Entry(_In_ SIZE_T physicalAddress) {
	SIZE_T directory = ADDRMASK_EPT_PML2_INDEX(physicalAddress);
	SIZE_T directoryPointer = ADDRMASK_EPT_PML3_INDEX(physicalAddress);
	SIZE_T pml4Entry = ADDRMASK_EPT_PML4_INDEX(physicalAddress);

	if (pml4Entry > 0)
		return NULL;
	PEPT_PML2_ENTRY pml2 = &eptPageTable->PML2[directoryPointer][directory];

	if (pml2->LargePage)
		return NULL;
	PEPT_PML1_ENTRY pml1 = reinterpret_cast<PEPT_PML1_ENTRY>(GetVirtualAddress(reinterpret_cast<PEPT_PML2_POINTER>(pml2)->PageFrameNumber * PAGE_SIZE));

	if (!pml1)
		return NULL;
	pml1 = &pml1[ADDRMASK_EPT_PML1_INDEX(physicalAddress)];
	return pml1;
}

/*
* Description:
* GetPml2Entry is responsible for getting a PML2 entry.
*
* Parameters:
* @physicalAddress [_In_ SIZE_T]				 -- The physical address to search.
*
* Returns:
* @pml2			   [PEPT_PML2_ENTRY]			 -- The PML2 entry.
*/
PEPT_PML2_ENTRY Ept::GetPml2Entry(_In_ SIZE_T physicalAddress) {
	SIZE_T directory = ADDRMASK_EPT_PML2_INDEX(physicalAddress);
	SIZE_T directoryPointer = ADDRMASK_EPT_PML3_INDEX(physicalAddress);
	SIZE_T pml4Entry = ADDRMASK_EPT_PML4_INDEX(physicalAddress);

	// Addresses above 512GB are invalid because it is greater than physical address bus width 
	if (pml4Entry > 0)
		return NULL;
	return &eptPageTable->PML2[directoryPointer][directory];
}

/*
* Description:
* SplitLargePage is responsible for splitting a large page into smaller pages.
*
* Parameters:
* @buffer		   [_Inout_ PVOID]				 -- The buffer to store the split.
* @physicalAddress [_In_ SIZE_T]				 -- The physical address to split.
*
* Returns:
* @status		   [bool]						 -- True if splitted else false.
*/
bool Ept::SplitLargePage(_Inout_ PVOID buffer, _In_ SIZE_T physicalAddress) {

	EPT_PML1_ENTRY pml1Template = { 0 };
	EPT_PML2_POINTER newSplitPtr = { 0 };

	if (!buffer) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Buffer is not allocated");
		return false;
	}

	PEPT_PML2_ENTRY pml2Entry = GetPml2Entry(physicalAddress);

	if (!pml2Entry) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "An invalid physical address passed 0x%llx", physicalAddress);
		return false;
	}

	// If this large page is not marked a large page, that means it's already splitted.
	if (!pml2Entry->LargePage) {
		poolManager->Free(buffer, SPLIT_2MB_PAGING_TO_4KB_PAGE);
		return true;
	}
	PVMM_EPT_DYNAMIC_SPLIT newSplit = static_cast<PVMM_EPT_DYNAMIC_SPLIT>(buffer);

	if (!newSplit) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to allocate dynamic split memory");
		return false;
	}
	RtlSecureZeroMemory(newSplit, sizeof(VMM_EPT_DYNAMIC_SPLIT));
	newSplit->Entry = pml2Entry;

	// Make a template for RWX and copy it to all PML1 entries.
	pml1Template.Flags = 0;
	pml1Template.ReadAccess = 1;
	pml1Template.WriteAccess = 1;
	pml1Template.ExecuteAccess = 1;
	pml1Template.MemoryType = pml2Entry->MemoryType;
	pml1Template.IgnorePat = pml2Entry->IgnorePat;
	pml1Template.SuppressVe = pml2Entry->SuppressVe;

	__stosq(reinterpret_cast<SIZE_T*>(&newSplit->PML1[0]), pml1Template.Flags, VMM_EPT_PML1E_COUNT);

	// Set the PFNs for identity mapping by converting the 2MB PFN to 4KB + offset to the frame.
	for (SIZE_T entryIndex = 0; entryIndex < VMM_EPT_PML1E_COUNT; entryIndex++) {
		newSplit->PML1[entryIndex].PageFrameNumber = ((pml2Entry->PageFrameNumber * SIZE_2_MB) / PAGE_SIZE) + entryIndex;
		newSplit->PML1[entryIndex].MemoryType = GetMemoryType(newSplit->PML1[entryIndex].PageFrameNumber, false);
	}

	// Set a new pointer that points to the new split instead of the 2MB page.
	newSplitPtr.Flags = 0;
	newSplitPtr.WriteAccess = 1;
	newSplitPtr.ReadAccess = 1;
	newSplitPtr.ExecuteAccess = 1;
	newSplitPtr.PageFrameNumber = GetPhysicalAddress(reinterpret_cast<UINT64>(&newSplit->PML1[0])) / PAGE_SIZE;
	RtlCopyMemory(pml2Entry, &newSplitPtr, sizeof(newSplitPtr));

	return true;
}

/*
* Description:
* SetupPML2Entry is responsible for setting the correct memory type for a PML2 entry.
*
* Parameters:
* @newEntry		   [_Inout_ PEPT_PML2_ENTRY] -- The new PML2 entry.
* @pageFrameNumber [_In_ SIZE_T]			 -- The page frame number.
*
* Returns:
* @status		   [bool]					-- True if the entry is set up successfully, otherwise false.
*/
bool Ept::SetupPML2Entry(_Inout_ PEPT_PML2_ENTRY newEntry, _In_ SIZE_T pageFrameNumber) {
	newEntry->PageFrameNumber = pageFrameNumber;
	SIZE_T addressOfPage = pageFrameNumber * SIZE_2_MB;

	if (IsValidForLargePage(pageFrameNumber)) {
		newEntry->MemoryType = GetMemoryType(pageFrameNumber, true);
		return true;
	}
	// First entry MUST be uncacheable, otherwise it will cause a page fault.
	if (pageFrameNumber == 0) {
		newEntry->MemoryType = MEMORY_TYPE_UNCACHEABLE;
		return true;
	}
	PVOID buffer = poolManager->Allocate(SPLIT_2MB_PAGING_TO_4KB_PAGE);

	if (buffer)
		return SplitLargePage(buffer, pageFrameNumber * SIZE_2_MB);
	return false;
}

/*
* Description:
* AllocateAndCreateIdentityPageTable is responsible for creating a new EPT page table.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @pageTable [PVMM_EPT_PAGE_TABLE] -- The allocated page table.
*/
PVMM_EPT_PAGE_TABLE Ept::AllocateAndCreateIdentityPageTable() {
	PHYSICAL_ADDRESS maxPhysicalAddress = { 0 };
	EPT_PML3_POINTER pml3Template = { 0 };
	EPT_PML2_ENTRY pml2Template = { 0 };
	maxPhysicalAddress.QuadPart = MAXULONG64;

	PVMM_EPT_PAGE_TABLE pageTable = static_cast<PVMM_EPT_PAGE_TABLE>(MmAllocateContiguousMemory(sizeof(VMM_EPT_PAGE_TABLE), maxPhysicalAddress));

	if (!pageTable) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to allocate memory for EPT page table");
		return NULL;
	}
	RtlSecureZeroMemory(pageTable, sizeof(VMM_EPT_PAGE_TABLE));

	// Mark the first 512GB PML4 entry as present to manage up to 512GB of discrete paging structures. 
	pageTable->PML4[0].PageFrameNumber = GetPhysicalAddress(reinterpret_cast<UINT64>(&pageTable->PML3[0])) / PAGE_SIZE;
	pageTable->PML4[0].ReadAccess = 1;
	pageTable->PML4[0].WriteAccess = 1;
	pageTable->PML4[0].ExecuteAccess = 1;

	// Copy RWX template to all PML3 entries.
	pml3Template.Flags = 0;
	pml3Template.ReadAccess = 1;
	pml3Template.WriteAccess = 1;
	pml3Template.ExecuteAccess = 1;
	__stosq(reinterpret_cast<SIZE_T*>(&pageTable->PML3[0]), pml3Template.Flags, VMM_EPT_PML3E_COUNT);

	// For each of the 512 PML3 entries 
	for (SIZE_T entryIndex = 0; entryIndex < VMM_EPT_PML3E_COUNT; entryIndex++)
		pageTable->PML3[entryIndex].PageFrameNumber = GetPhysicalAddress(reinterpret_cast<UINT64>(&pageTable->PML2[entryIndex][0])) / PAGE_SIZE;

	// Copy RWX template to all PML2 entries and mark them as present.
	pml2Template.Flags = 0;
	pml2Template.WriteAccess = 1;
	pml2Template.ReadAccess = 1;
	pml2Template.ExecuteAccess = 1;
	pml2Template.LargePage = 1;
	__stosq(reinterpret_cast<SIZE_T*>(&pageTable->PML2[0]), pml2Template.Flags, VMM_EPT_PML3E_COUNT * VMM_EPT_PML2E_COUNT);

	for (SIZE_T entryGroupIndex = 0; entryGroupIndex < VMM_EPT_PML3E_COUNT; entryGroupIndex++) {
		for (SIZE_T entryIndex = 0; entryIndex < VMM_EPT_PML2E_COUNT; entryIndex++) {
			if (!SetupPML2Entry(&pageTable->PML2[entryGroupIndex][entryIndex], (entryGroupIndex * VMM_EPT_PML2E_COUNT) + entryIndex)) {
				NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to setup PML2 entry for page table");
				MmFreeContiguousMemory(pageTable);
				pageTable = NULL;
				return NULL;
			}
		}
	}
	return pageTable;
}

/*
* Description:
* LogicalProcessorInitialize is responsible for initializing the EPT.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @status [bool] -- True if the EPT is initialized, otherwise false.
*/
bool Ept::LogicalProcessorInitialize() {
	EPTP eptp = { 0 };
	PVMM_EPT_PAGE_TABLE pageTable = AllocateAndCreateIdentityPageTable();

	if (!pageTable) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Unable to allocate memory for EPT");
		return false;
	}
	this->eptPageTable = pageTable;

	eptp.Flags = 0;
	eptp.MemoryType = MEMORY_TYPE_WRITE_BACK;
	eptp.EnableAccessAndDirtyFlags = FALSE;

	// Must be 3, indicating an EPT page-walk length of 4.
	eptp.PageWalkLength = 3;
	eptp.PageFrameNumber = GetPhysicalAddress(reinterpret_cast<UINT64>(&pageTable->PML4)) / PAGE_SIZE;
	this->eptPointer = eptp;
	return true;
}

/*
* Description:
* HandlePageHookExit is responsible for handling a page hook vmexit.
*
* Parameters:
* @violationQualification [_In_ VMX_EXIT_QUALIFICATION_EPT_VIOLATION] -- The EPT violation qualification.
* @guestPhysicalAddr	  [_In_ UINT64]								  -- The guest physical address.
*
* Returns:
* @status				  [bool]									  -- True if the page hook exit is handled, otherwise false.
*/
_Use_decl_annotations_
bool Ept::HandlePageHookExit(_In_ VMX_EXIT_QUALIFICATION_EPT_VIOLATION violationQualification, _In_ UINT64 guestPhysicalAddr) {
	PEPT_HOOKED_PAGE_DETAIL hookedEntry = NULL;
	bool handled = false;
	UINT64 alignedPhysicalAddress = reinterpret_cast<UINT64>(PAGE_ALIGN(guestPhysicalAddr));

	if (!alignedPhysicalAddress) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Target address could not be mapped to physical memory");
		return handled;
	}
	UINT64 virtualAddress = GetVirtualAddress(guestPhysicalAddr);
	this->hookedPagesLock.Lock();
	PLIST_ENTRY currentEntry = this->hookedPages;

	while (currentEntry->Flink != this->hookedPages) {
		currentEntry = currentEntry->Flink;
		hookedEntry = CONTAINING_RECORD(currentEntry, EPT_HOOKED_PAGE_DETAIL, Entry);

		if (hookedEntry->PhysicalBaseAddress == alignedPhysicalAddress) {
			ULONG currentProcessor = KeGetCurrentProcessorNumber();
			handled = HandleHookedPage(hookedEntry, violationQualification, virtualAddress);

			if (handled && !GuestState[currentProcessor].IncrementRip) {
				GuestState[currentProcessor].HookedPage = hookedEntry;
				VmxHelper::SetMonitorTrapFlag(true);
			}
			break;
		}
	}
	
	this->hookedPagesLock.Unlock();
	return handled;
}

/*
* Description:
* HandleHookedPage is responsible to handle a hooked page.
*
* Parameters:
* @hookedEntryDetails	  [_Inout_ EPT_HOOKED_PAGE_DETAIL]			  -- The hooked page details.
* @violationQualification [_In_ VMX_EXIT_QUALIFICATION_EPT_VIOLATION] -- The violation qualification.
* @guestVirtualAddress    [_In_ ULONG64]							  -- The guest virtual address that caused the hook.
*
* Returns:
* @status				  [bool]									  -- True if the page is handled, otherwise false.
*/
bool Ept::HandleHookedPage(_Inout_ EPT_HOOKED_PAGE_DETAIL* hookedEntryDetails,
	_In_ VMX_EXIT_QUALIFICATION_EPT_VIOLATION violationQualification, _In_ ULONG64 guestVirtualAddress) {
	bool operationAllowed = false;
	bool handled = false;
	PEPT_PML1_ENTRY pml1Entry = hookedEntryDetails->EntryAddress;

	if (!violationQualification.EptExecutable && violationQualification.ExecuteAccess) {
		if (guestVirtualAddress >= KernelBaseInfo.KernelBaseAddress &&
			guestVirtualAddress < (KernelBaseInfo.KernelBaseAddress + KernelBaseInfo.KernelSize)) {
			pml1Entry->ExecuteAccess = 1;
			operationAllowed = true;
			NovaHypervisorLog(TRACE_FLAG_INFO, "Allowed execute access to protected address from: 0x%llx", guestVirtualAddress);
		}
		else
			NovaHypervisorLog(TRACE_FLAG_INFO, "Blocked execute access to protected address from: 0x%llx", guestVirtualAddress);
		handled = true;
	}
	else if (!violationQualification.EptWriteable && violationQualification.WriteAccess) {
		if (guestVirtualAddress >= KernelBaseInfo.KernelBaseAddress &&
			guestVirtualAddress < (KernelBaseInfo.KernelBaseAddress + KernelBaseInfo.KernelSize)) {
			pml1Entry->WriteAccess = 1;
			operationAllowed = true;
			NovaHypervisorLog(TRACE_FLAG_INFO, "Allowed write access to protected address from: 0x%llx", guestVirtualAddress);
		}
		else
			NovaHypervisorLog(TRACE_FLAG_INFO, "Blocked write access to protected address from: 0x%llx", guestVirtualAddress);
		handled = true;
	}
	else if (!violationQualification.EptReadable && violationQualification.ReadAccess) {
		if (guestVirtualAddress >= KernelBaseInfo.KernelBaseAddress &&
			guestVirtualAddress < (KernelBaseInfo.KernelBaseAddress + KernelBaseInfo.KernelSize)) {
			pml1Entry->ReadAccess = 1;
			operationAllowed = true;
			NovaHypervisorLog(TRACE_FLAG_INFO, "Allowed read access to protected address from: 0x%llx", guestVirtualAddress);
		}
		else
			NovaHypervisorLog(TRACE_FLAG_INFO, "Blocked read access to protected address from: 0x%llx", guestVirtualAddress);
		handled = true;
	}

	if (operationAllowed) {
		SetPML1AndInvalidateTLB(hookedEntryDetails->EntryAddress, hookedEntryDetails->OriginalEntry, SINGLE_CONTEXT);
		GuestState[KeGetCurrentProcessorNumber()].IncrementRip = false;
	}
	return handled;
}

/*
* Description:
* HandleEptViolation is responsible for handling ept violations.
*
* Parameters:
* @exitQualification [_In_ ULONG64] -- The exit qualification.
* @guestPhysicalAddr [_In_ ULONG64] -- The guest physical address.
*
* Returns:
* There is no return value.
*/
void Ept::HandleEptViolation(_In_ ULONG64 exitQualification, _In_ ULONG64 guestPhysicalAddr) {
	VMX_EXIT_QUALIFICATION_EPT_VIOLATION violationQualification = { 0 };
	violationQualification.Flags = exitQualification;

	if (HandlePageHookExit(violationQualification, guestPhysicalAddr))
		return;

	NovaHypervisorLog(TRACE_FLAG_ERROR, "Unexpected EPT violation at 0x%llx", guestPhysicalAddr);
	DbgBreakPoint();
}

/*
* Description:
* HandleMisconfiguration is responsible for handling EPT misconfigurations.
*
* Parameters:
* @guestAddress [_In_ UINT64] -- The guest address.
*
* Returns:
* There is no return value.
*/
void Ept::HandleMisconfiguration(_In_ UINT64 guestAddress) {
	NovaHypervisorLog(TRACE_FLAG_ERROR, "EPT Misconfiguration!");
	NovaHypervisorLog(TRACE_FLAG_ERROR, "A field in the EPT paging structure was invalid, faulting guest address: 0x%llx", guestAddress);
	DbgBreakPoint();
}

/*
* Description:
* HandleMonitorTrapFlag is responsible for handling MTF event.
*
* Parameters:
* @hookedEntry [_Inout_ PEPT_HOOKED_PAGE_DETAIL] -- The hooked page detail.
*
* Returns:
* There is no return value.
*/
void Ept::HandleMonitorTrapFlag(_Inout_ PEPT_HOOKED_PAGE_DETAIL hookedEntry) {
	SetPML1AndInvalidateTLB(hookedEntry->EntryAddress, hookedEntry->ChangedEntry, SINGLE_CONTEXT);
	NovaHypervisorLog(TRACE_FLAG_INFO, "Restored hooked page 0x%llx", hookedEntry->VirtualAddress);
}

/*
* Description:
* RootModePageHook is responsible for hooking a page in VMX root mode.
*
* Parameters:
* @targetFunc	[_In_ PVOID] -- The target function to hook.
* @permissions [_In_ UINT8]  -- The permissions for the page.
*
* Returns:
* @status		[bool]	     -- True if the page is hooked, otherwise false.
*/
bool Ept::RootModePageHook(_In_ PVOID targetFunc, _In_ UINT8 permissions) {
	EPT_PML1_ENTRY changedEntry = { 0 };
	ULONG currentProcessorIndex = KeGetCurrentProcessorIndex();

	if (GuestState[currentProcessorIndex].IsOnVmxRoot && !GuestState[currentProcessorIndex].IsLaunched)
		return false;

	if (permissions & EPT_PAGE_WRITE && !(permissions & EPT_PAGE_READ)) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Invalid permissions to perform a hook");
		return false;
	}

	if (IsHookExists(reinterpret_cast<UINT64>(targetFunc))) {
		NovaHypervisorLog(TRACE_FLAG_INFO, "Hook already exists for the target function: 0x%llx", reinterpret_cast<UINT64>(targetFunc));
		return true;
	}

	PVOID virtualFuncAddress = PAGE_ALIGN(targetFunc);
	SIZE_T physicalFuncAddress = GetPhysicalAddress(reinterpret_cast<UINT64>(virtualFuncAddress));

	if (!physicalFuncAddress) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Target address could not be mapped to physical memory");
		return false;
	}
	PVOID targetBuffer = poolManager->Allocate(SPLIT_2MB_PAGING_TO_4KB_PAGE);

	if (!targetBuffer) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to allocate memory for the target buffer");
		return false;
	}

	if (!SplitLargePage(targetBuffer, physicalFuncAddress)) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Could not split page for the address: 0x%llx", physicalFuncAddress);
		poolManager->Free(targetBuffer, SPLIT_2MB_PAGING_TO_4KB_PAGE);
		return false;
	}
	PEPT_PML1_ENTRY pml1Entry = GetPml1Entry(physicalFuncAddress);

	if (!pml1Entry) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to get PML1 entry of the target address: 0x%llx", physicalFuncAddress);
		poolManager->Free(targetBuffer, SPLIT_2MB_PAGING_TO_4KB_PAGE);
		return false;
	}
	changedEntry.Flags = pml1Entry->Flags;
	changedEntry.ReadAccess = permissions & EPT_PAGE_READ;
	changedEntry.WriteAccess = permissions & EPT_PAGE_WRITE;
	changedEntry.ExecuteAccess = permissions & EPT_PAGE_EXECUTE;

	PEPT_HOOKED_PAGE_DETAIL hookedEntry = static_cast<PEPT_HOOKED_PAGE_DETAIL>(poolManager->Allocate(EPT_HOOK_PAGE));

	if (!hookedEntry) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to allocate memory for the hooked entry");
		poolManager->Free(targetBuffer, SPLIT_2MB_PAGING_TO_4KB_PAGE);
		return false;
	}
	hookedEntry->IsExecutionHook = false;
	hookedEntry->VirtualAddress = reinterpret_cast<UINT64>(targetFunc);
	hookedEntry->PhysicalAddress = physicalFuncAddress;
	hookedEntry->PhysicalBaseAddress = reinterpret_cast<UINT64>(PAGE_ALIGN(physicalFuncAddress));
	hookedEntry->EntryAddress = pml1Entry;
	hookedEntry->OriginalEntry = *pml1Entry;
	hookedEntry->ChangedEntry = changedEntry;
	this->hookedPagesLock.Lock();
	InsertHeadList(this->hookedPages, &(hookedEntry->Entry));
	this->hookedPagesLock.Unlock();

	// Invalidate the entry in the TLB caches so it will not conflict with the actual paging structure.
	if (GuestState[currentProcessorIndex].IsLaunched)
		SetPML1AndInvalidateTLB(pml1Entry, changedEntry, SINGLE_CONTEXT);
	else
		pml1Entry->Flags = changedEntry.Flags;
	return true;
}

/*
* Description:
* PageHook is responsible for hooking a page.
*
* Parameters:
* @targetFunc	[_In_ PVOID] -- The target function to hook.
* @permissions  [_In_ UINT8] -- The permissions for the page.
*
* Returns:
* @status		[bool]	     -- True if the page is hooked, otherwise false.
*/
bool Ept::PageHook(_In_ PVOID targetFunc, _In_ UINT8 permissions) {
	ULONG currentProcessor = KeGetCurrentProcessorIndex();

	if (GuestState[currentProcessor].IsLaunched) {
		if (NT_SUCCESS(AsmVmxVmcall(VMCALL_EXEC_HOOK_PAGE, reinterpret_cast<UINT64>(targetFunc), permissions, NULL))) {
			NovaHypervisorLog(TRACE_FLAG_INFO, "Hook applied from vmx root mode");
			KeIpiGenericCall(reinterpret_cast<PKIPI_BROADCAST_WORKER>(VmxHelper::InvalidateEptByVmcall), this->eptPointer.Flags);
			return true;
		}
	}
	else {
		if (RootModePageHook(targetFunc, permissions)) {
			NovaHypervisorLog(TRACE_FLAG_INFO, "Hook applied (vm not launched yet)");
			return true;
		}
	}

	NovaHypervisorLog(TRACE_FLAG_WARNING, "Hook not applied");
	return false;
}

/*
* Description:
* GetMemoryType is responsible for getting a memory type for PFN.
*
* Parameters:
* @pfn				[_In_ ULONG64] -- The PFN.
* @isLargePage		[_In_ bool]	   -- True if the page is a large page, otherwise false.
*
* Returns:
* @targetMemoryType [UCHAR]		   -- The memory type.
*/
UCHAR Ept::GetMemoryType(_In_ ULONG64 pfn, _In_ bool isLargePage) {
	UCHAR targetMemoryType = 0xFF;
	MTRR_RANGE_DESCRIPTOR* currentMemoryRange;
	ULONG64 addressOfPage = isLargePage ? pfn * SIZE_2_MB : pfn * PAGE_SIZE;

	for (UINT32 currentMtrrRange = 0; currentMtrrRange < this->numberOfEnabledMemoryRanges; currentMtrrRange++) {
		currentMemoryRange = &this->memoryRanges[currentMtrrRange];

		if (addressOfPage >= currentMemoryRange->PhysicalBaseAddress &&
			addressOfPage < currentMemoryRange->PhysicalEndAddress) {
			if (currentMemoryRange->FixedRange) {
				targetMemoryType = currentMemoryRange->MemoryType;
				break;
			}

			if (targetMemoryType == MEMORY_TYPE_UNCACHEABLE) {
				targetMemoryType = currentMemoryRange->MemoryType;
				break;
			}

			if (targetMemoryType == MEMORY_TYPE_WRITE_THROUGH || currentMemoryRange->MemoryType == MEMORY_TYPE_WRITE_THROUGH) {
				if (targetMemoryType == MEMORY_TYPE_WRITE_BACK) {
					targetMemoryType = MEMORY_TYPE_WRITE_THROUGH;
					continue;
				}
			}
			targetMemoryType = currentMemoryRange->MemoryType;
		}
	}

	if (targetMemoryType == 0xFF)
		targetMemoryType = this->defaultMemoryType;

	return targetMemoryType;
}

/*
* Description:
* GetPml1OrPml2Entry is responsible for getting PML1 or PML2 entry.
*
* Parameters:
* @physicalAddress [_In_ SIZE_T]			  -- The physical address to search.
* @isLargePage	   [_Inout_ bool]			  -- True if the page is a large page, otherwise false.
*
* Returns:
* @entry		   [PVOID]					  -- The PML1 or PML2 entry.
*/
PVOID Ept::GetPml1OrPml2Entry(_In_ SIZE_T physicalAddress, _Inout_ bool* isLargePage) {
	SIZE_T directory = ADDRMASK_EPT_PML2_INDEX(physicalAddress);
	SIZE_T directoryPointer = ADDRMASK_EPT_PML3_INDEX(physicalAddress);
	SIZE_T pml4Entry = ADDRMASK_EPT_PML4_INDEX(physicalAddress);

	if (pml4Entry > 0)
		return NULL;
	PEPT_PML2_ENTRY pml2 = &eptPageTable->PML2[directoryPointer][directory];

	if (pml2->LargePage) {
		*isLargePage = true;
		return pml2;
	}
	PEPT_PML2_POINTER pml2Pointer = reinterpret_cast<PEPT_PML2_POINTER>(pml2);
	PEPT_PML1_ENTRY pml1 = reinterpret_cast<PEPT_PML1_ENTRY>(GetVirtualAddress(pml2Pointer->PageFrameNumber * PAGE_SIZE));

	if (!pml1)
		return NULL;
	pml1 = &pml1[ADDRMASK_EPT_PML1_INDEX(physicalAddress)];

	*isLargePage = false;
	return pml1;
}

/*
* Description:
* IsValidForLargePage checks if the page is valid for a large page.
*
* Parameters:
* @pfn	  [_In_ ULONG64] -- The page frame number.
*
* Returns:
* @status [bool]		 -- True if the page is valid for a large page, otherwise false.
*/
bool Ept::IsValidForLargePage(_In_ ULONG64 pfn) {
	ULONG64 startPageAddress = pfn * SIZE_2_MB;
	ULONG64 endPageAddress = startPageAddress + SIZE_2_MB - 1;
	MTRR_RANGE_DESCRIPTOR* currentMemoryRange = nullptr;

	for (UINT32 memoryPageIndex = 0; memoryPageIndex < this->numberOfEnabledMemoryRanges; memoryPageIndex++) {
		currentMemoryRange = &this->memoryRanges[memoryPageIndex];

		if ((startPageAddress <= currentMemoryRange->PhysicalEndAddress && endPageAddress > currentMemoryRange->PhysicalEndAddress) ||
			(startPageAddress < currentMemoryRange->PhysicalBaseAddress && endPageAddress >= currentMemoryRange->PhysicalBaseAddress))
			return false;
	}
	return true;
}

/*
* Description:
* SetPML1AndInvalidateTLB is responsible for setting the PML1 entry and invalidating the TLB.
*
* Parameters:
* @pml1Entry	    [_Inout_ PEPT_PML1_ENTRY] -- The PML1 entry to set.
* @pml1Value	    [_In_ EPT_PML1_ENTRY]	  -- The PML1 value to set.
* @invalidationType [_In_ INVEPT_TYPE]		  -- The invalidation type.
*
* Returns:
* There is no return value.
*/
_Use_decl_annotations_
void Ept::SetPML1AndInvalidateTLB(_Inout_ PEPT_PML1_ENTRY pml1Entry, _In_ EPT_PML1_ENTRY pml1Value, _In_ INVEPT_TYPE invalidationType) {
	pml1Entry->Flags = pml1Value.Flags;

	switch (invalidationType) {
	case SINGLE_CONTEXT:
		VmxHelper::InvalidateEpt(this->eptPointer.Flags);
		break;
	case ALL_CONTEXTS:
		VmxHelper::InvalidateEpt();
		break;
	default:
		break;
	}
}

/*
* Description:
* PageUnhook is responsible to dispatch a vmcall to remove a hooked page.
*
* Parameters:
* @guestVirtualAddress [_In_ UINT64] -- The guest virtual address.
*
* Returns:
* @status			   [bool]		 -- True if the page is unhooked, otherwise false.
*/
bool Ept::PageUnhook(_In_ UINT64 guestVirtualAddress) {
	if (GuestState[KeGetCurrentProcessorNumber()].IsOnVmxRoot)
		return false;
	PEPT_HOOKED_PAGE_DETAIL hookedEntry = GetHookedPage(guestVirtualAddress);

	if (hookedEntry) {
		KeGenericCallDpc(UnhookSinglePage, reinterpret_cast<PVOID>(hookedEntry->VirtualAddress));
		RemoveEntryList(hookedEntry->Entry.Flink);
		return true;
	}
	return false;
}

/*
* Description:
* PageUnhookVmcall is responsible to invalidate the TLB for a specific page.
*
* Parameters:
* @guestPhysicalAddress [_In_ UINT64] -- The guest virtual address.
*
* Returns:
* @status			    [bool]		  -- True if the page is unhooked, otherwise false.
*/
bool Ept::PageUnhookVmcall(_In_ UINT64 guestVirtualAddress) {
	if (!GuestState[KeGetCurrentProcessorNumber()].IsOnVmxRoot)
		return false;
	PEPT_HOOKED_PAGE_DETAIL hookedEntry = GetHookedPage(guestVirtualAddress);

	if (hookedEntry) {
		SetPML1AndInvalidateTLB(hookedEntry->EntryAddress, hookedEntry->OriginalEntry, SINGLE_CONTEXT);
		return true;
	}
	return false;
}

/*
* Description:
* PageUnhook is responsible to unhook all pages.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @status [bool] -- True if unhooked all pages, else false.
*/
bool Ept::UnhookAllPagesVmcall() {
	PEPT_HOOKED_PAGE_DETAIL hookedEntry = nullptr;

	if (!GuestState[KeGetCurrentProcessorNumber()].IsOnVmxRoot)
		return false;
	PLIST_ENTRY entry = this->hookedPages;

	while (this->hookedPages != entry->Flink) {
		entry = entry->Flink;
		hookedEntry = CONTAINING_RECORD(entry, EPT_HOOKED_PAGE_DETAIL, Entry);
		SetPML1AndInvalidateTLB(hookedEntry->EntryAddress, hookedEntry->OriginalEntry, SINGLE_CONTEXT);
	}
	return true;
}

/*
* Description:
* PageUnhook is responsible to dispatch a vmcall to unhook all pages.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void Ept::UnhookAllPages() {
	if (GuestState[KeGetCurrentProcessorNumber()].IsOnVmxRoot)
		return;
	KeGenericCallDpc(UnhookAllPagesDpc, NULL);

	// Clean up the protected addresses
	hookedPagesLock.Lock();
	this->hookedPages->Blink = NULL;
	this->hookedPages->Flink = NULL;
	hookedPagesLock.Unlock();
}

/*
* Description:
*
* IsHookExists checks if a hook exists for the given guest virtual address.
*
* Parameters:
* @guestVirtualAddress [_In_ UINT64] -- The guest virtual address to check.
*
* Returns:
* @status [bool] -- True if a hook exists, otherwise false.
*/
bool Ept::IsHookExists(_In_ UINT64 guestVirtualAddress) {
	return GetHookedPage(guestVirtualAddress) != NULL;
}

/*
* Description:
* GetHookedPage retrieves the hooked page details for a given guest virtual address.
*
* Parameters:
* @guestVirtualAddress [_In_ UINT64] -- The guest virtual address to retrieve the hooked page for.
*
* Returns:
* @hookedPage [PEPT_HOOKED_PAGE_DETAIL] -- The details of the hooked page, or NULL if not found.
*/
PEPT_HOOKED_PAGE_DETAIL Ept::GetHookedPage(_In_ UINT64 guestVirtualAddress) {
	PEPT_HOOKED_PAGE_DETAIL hookedEntry = nullptr;

	this->hookedPagesLock.Lock();
	PLIST_ENTRY entry = this->hookedPages;

	if (IsListEmpty(this->hookedPages)) {
		this->hookedPagesLock.Unlock();
		return NULL;
	}

	while (this->hookedPages != entry->Flink) {
		entry = entry->Flink;
		hookedEntry = CONTAINING_RECORD(entry, EPT_HOOKED_PAGE_DETAIL, Entry);

		if (hookedEntry->VirtualAddress == guestVirtualAddress) {
			this->hookedPagesLock.Unlock();
			return hookedEntry;
		}
	}
	this->hookedPagesLock.Unlock();
	return NULL;
}
```

`NovaHypervisor/Ept.h`:

```h
#pragma once
#include "pch.h"
#include "HypervisorDefinitions.h"
#include "InlineAsm.h"
#include "GlobalVariables.h"
#include "MemoryHelper.hpp"
#include "Vmx.h"
#include "WppDefinitions.h"
#include "Ept.tmh"

enum EptPagePermissions {
	EPT_PAGE_READ = 1,
	EPT_PAGE_WRITE = 2,
	EPT_PAGE_EXECUTE = 4,
	EPT_ALL_PERMISSIONS = EPT_PAGE_READ | EPT_PAGE_WRITE | EPT_PAGE_EXECUTE,
	EPT_MAX_PAGE_PERMISSIONS = EPT_ALL_PERMISSIONS
};

class Ept {
private:
	MTRR_RANGE_DESCRIPTOR memoryRanges[MTRR_ENTRIES_SIZE];
	ULONG numberOfEnabledMemoryRanges;
	EPTP eptPointer;
	PVMM_EPT_PAGE_TABLE eptPageTable;
	UCHAR defaultMemoryType;
	LIST_ENTRY* hookedPages;
	Spinlock hookedPagesLock;
	bool executeOnlySupport;

	bool CheckFeatures();
	void BuildMtrrMap();
	PEPT_PML1_ENTRY GetPml1Entry(_In_ SIZE_T physicalAddress);
	PEPT_PML2_ENTRY GetPml2Entry(_In_ SIZE_T physicalAddress);
	PVOID GetPml1OrPml2Entry(_In_ SIZE_T physicalAddress, _Inout_ bool* isLargePage);
	UCHAR GetMemoryType(_In_ ULONG64 pfn, _In_ bool isLargePage);
	bool SplitLargePage(_Inout_ PVOID buffer, _In_ SIZE_T physicalAddress);
	bool IsValidForLargePage(_In_ ULONG64 pfn);
	bool SetupPML2Entry(_Inout_ PEPT_PML2_ENTRY newEntry, _In_ SIZE_T pageFrameNumber);
	PVMM_EPT_PAGE_TABLE AllocateAndCreateIdentityPageTable();
	bool LogicalProcessorInitialize();
	void SetPML1AndInvalidateTLB(_Inout_ PEPT_PML1_ENTRY pml1Entry, _In_ EPT_PML1_ENTRY pml1Value, INVEPT_TYPE _In_ invalidationType);
	bool HandleHookedPage(_Inout_ EPT_HOOKED_PAGE_DETAIL* hookedEntryDetails, 
		_In_ VMX_EXIT_QUALIFICATION_EPT_VIOLATION violationQualification, _In_ ULONG64 guestVirtualAddress);
	bool HandlePageHookExit(_In_ VMX_EXIT_QUALIFICATION_EPT_VIOLATION violationQualification, _In_ UINT64 guestPhysicalAddr);
	bool PageHook(_In_ PVOID targetFunc, _In_ UINT8 permissions);
	bool PageUnhook(_In_ UINT64 guestVirtualAddress);
	void UnhookAllPages();
	PEPT_HOOKED_PAGE_DETAIL GetHookedPage(_In_ UINT64 guestVirtualAddress);
	bool IsHookExists(_In_ UINT64 guestVirtualAddress);

public:
	Ept();
	~Ept();

	void* operator new(size_t size) {
		return AllocateVirtualMemory<PVOID>(size, false);
	}

	void operator delete(void* p) {
		FreeVirtualMemory(p);
	}

	bool RootModePageHook(_In_ PVOID TargetFunc, _In_ UINT8 permissions);
	void HandleEptViolation(_In_ ULONG64 exitQualification, _In_ ULONG64 guestPhysicalAddr);
	void HandleMisconfiguration(_In_ UINT64 guestPhysicalAddress);
	bool PageUnhookVmcall(_In_ UINT64 guestVirtualAddress);
	bool UnhookAllPagesVmcall();
	void HandleMonitorTrapFlag(_Inout_ PEPT_HOOKED_PAGE_DETAIL hookedEntry);
	ULONG64 GetEptPointerFlags() const;
};
```

`NovaHypervisor/EventInjection.cpp`:

```cpp
#include "pch.h"
#include "EventInjection.h"

namespace EventHandler {
	void SetupInstructionLength() {
		SIZE_T exitInstractionLength = 0;
		__vmx_vmread(VM_EXIT_INSTRUCTION_LEN, &exitInstractionLength);
		__vmx_vmwrite(VM_ENTRY_INSTRUCTION_LEN, exitInstractionLength);
	}

	void InjectInterruption(_In_ INTERRUPT_TYPE interruptionType, _In_ EXCEPTION_VECTORS vector, _In_ bool deliverErrorCode,
		_In_ ULONG32 errorCode) {

		INTERRUPT_INFO info = { 0 };
		info.Valid = TRUE;
		info.InterruptType = interruptionType;
		info.Vector = vector;
		info.DeliverCode = deliverErrorCode;
		__vmx_vmwrite(VM_ENTRY_INTR_INFO_FIELD, info.Flags);

		if (deliverErrorCode)
			__vmx_vmwrite(VM_ENTRY_EXCEPTION_ERROR_CODE, errorCode);
	}

	void InjectBreakpoint() {
		InjectInterruption(INTERRUPT_TYPE_SOFTWARE_INTERRUPT, EXCEPTION_VECTOR_BREAKPOINT, false, 0);
		SetupInstructionLength();
	}

	void InjectGeneralProtection() {
		InjectInterruption(INTERRUPT_TYPE_HARDWARE_EXCEPTION, EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, true, 0);
		SetupInstructionLength();
	}

	void InjectUndefinedOpcode() {
		InjectInterruption(INTERRUPT_TYPE_HARDWARE_EXCEPTION, EXCEPTION_VECTOR_UNDEFINED_OPCODE, false, 0);
	}
};
```

`NovaHypervisor/EventInjection.h`:

```h
#pragma once
#include "pch.h"
#include "HypervisorDefinitions.h"

typedef enum _EXCEPTION_VECTORS
{
	EXCEPTION_VECTOR_DIVIDE_ERROR,
	EXCEPTION_VECTOR_DEBUG_BREAKPOINT,
	EXCEPTION_VECTOR_NMI,
	EXCEPTION_VECTOR_BREAKPOINT,
	EXCEPTION_VECTOR_OVERFLOW,
	EXCEPTION_VECTOR_BOUND_RANGE_EXCEEDED,
	EXCEPTION_VECTOR_UNDEFINED_OPCODE,
	EXCEPTION_VECTOR_NO_MATH_COPROCESSOR,
	EXCEPTION_VECTOR_DOUBLE_FAULT,
	EXCEPTION_VECTOR_RESERVED0,
	EXCEPTION_VECTOR_INVALID_TASK_SEGMENT_SELECTOR,
	EXCEPTION_VECTOR_SEGMENT_NOT_PRESENT,
	EXCEPTION_VECTOR_STACK_SEGMENT_FAULT,
	EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT,
	EXCEPTION_VECTOR_PAGE_FAULT,
	EXCEPTION_VECTOR_RESERVED1,
	EXCEPTION_VECTOR_MATH_FAULT,
	EXCEPTION_VECTOR_ALIGNMENT_CHECK,
	EXCEPTION_VECTOR_MACHINE_CHECK,
	EXCEPTION_VECTOR_SIMD_FLOATING_POINT_NUMERIC_ERROR,
	EXCEPTION_VECTOR_VIRTUAL_EXCEPTION,
	EXCEPTION_VECTOR_RESERVED2,
	EXCEPTION_VECTOR_RESERVED3,
	EXCEPTION_VECTOR_RESERVED4,
	EXCEPTION_VECTOR_RESERVED5,
	EXCEPTION_VECTOR_RESERVED6,
	EXCEPTION_VECTOR_RESERVED7,
	EXCEPTION_VECTOR_RESERVED8,
	EXCEPTION_VECTOR_RESERVED9,
	EXCEPTION_VECTOR_RESERVED10,
	EXCEPTION_VECTOR_RESERVED11,
	EXCEPTION_VECTOR_RESERVED12
} EXCEPTION_VECTORS;

typedef enum _INTERRUPT_TYPE
{
	INTERRUPT_TYPE_EXTERNAL_INTERRUPT = 0,
	INTERRUPT_TYPE_RESERVED = 1,
	INTERRUPT_TYPE_NMI = 2,
	INTERRUPT_TYPE_HARDWARE_EXCEPTION = 3,
	INTERRUPT_TYPE_SOFTWARE_INTERRUPT = 4,
	INTERRUPT_TYPE_PRIVILEGED_SOFTWARE_INTERRUPT = 5,
	INTERRUPT_TYPE_SOFTWARE_EXCEPTION = 6,
	INTERRUPT_TYPE_OTHER_EVENT = 7
} INTERRUPT_TYPE;

typedef union _INTERRUPT_INFO {
	struct {
		UINT32 Vector : 8;
		UINT32 InterruptType : 3;
		UINT32 DeliverCode : 1;
		UINT32 Reserved : 19;
		UINT32 Valid : 1;
	};
	UINT32 Flags;
} INTERRUPT_INFO, * PINTERRUPT_INFO;

typedef union _VMEXIT_INTERRUPT_INFO {
	struct {
		UINT32 Vector : 8;
		UINT32 InterruptionType : 3;
		UINT32 ErrorCodeValid : 1;
		UINT32 NmiUnblocking : 1;
		UINT32 Reserved : 18;
		UINT32 Valid : 1;
	};
	UINT32 Flags;
}VMEXIT_INTERRUPT_INFO, * PVMEXIT_INTERRUPT_INFO;

typedef struct _EVENT_INFORMATION
{
	INTERRUPT_INFO InterruptInfo;
	UINT32 InstructionLength;
	UINT64 ErrorCode;
}EVENT_INFORMATION, * PEVENT_INFORMATION;

namespace EventHandler {
	void SetupInstructionLength();
	void InjectInterruption(_In_ INTERRUPT_TYPE interruptionType, _In_ EXCEPTION_VECTORS vector, _In_ bool deliverErrorCode, _In_ ULONG32 errorCode);
	void InjectBreakpoint();
	void InjectGeneralProtection();
	void InjectUndefinedOpcode();
};
```

`NovaHypervisor/GlobalVariables.h`:

```h
#pragma once
#include "pch.h"
#include "HypervisorDefinitions.h"
#include "Ept.h"
#include "VmState.h"
#include "PoolManager.h"

inline VmState* GuestState;
inline PoolManager* poolManager;
inline KERNEL_BASE_INFO KernelBaseInfo;
```

`NovaHypervisor/HypervisorDefinitions.h`:

```h
#pragma once

#include "pch.h"
#include "Spinlock.h"

#pragma warning(push)
#pragma warning(disable: 4201)

// Constants
constexpr ULONG64 MAX_PROTECTED_ADDRESSES = 512;

constexpr SIZE_T VMM_STACK_SIZE = 0x8000;
constexpr SIZE_T VMCS_SIZE = 4096;
constexpr SIZE_T VMXON_SIZE = 4096;
constexpr ULONG MSR_APIC_BASE = 0x01B;
constexpr ULONG MSR_IA32_FEATURE_CONTROL = 0x03A;
constexpr ULONG RPL_MASK = 3;

constexpr ULONG MSR_IA32_VMX_BASIC = 0x480;
constexpr ULONG MSR_IA32_VMX_PINBASED_CTLS = 0x481;
constexpr ULONG MSR_IA32_VMX_PROCBASED_CTLS = 0x482;
constexpr ULONG MSR_IA32_VMX_EXIT_CTLS = 0x483;
constexpr ULONG MSR_IA32_VMX_ENTRY_CTLS = 0x484;
constexpr ULONG MSR_IA32_VMX_MISC = 0x485;
constexpr ULONG MSR_IA32_VMX_CR0_FIXED0 = 0x486;
constexpr ULONG MSR_IA32_VMX_CR0_FIXED1 = 0x487;
constexpr ULONG MSR_IA32_VMX_CR4_FIXED0 = 0x488;
constexpr ULONG MSR_IA32_VMX_CR4_FIXED1 = 0x489;
constexpr ULONG MSR_IA32_VMX_VMCS_ENUM = 0x48A;
constexpr ULONG MSR_IA32_VMX_PROCBASED_CTLS2 = 0x48B;
constexpr ULONG MSR_IA32_VMX_EPT_VPID_CAP = 0x48C;
constexpr ULONG MSR_IA32_VMX_TRUE_PINBASED_CTLS = 0x48D;
constexpr ULONG MSR_IA32_VMX_TRUE_PROCBASED_CTLS = 0x48E;
constexpr ULONG MSR_IA32_VMX_TRUE_EXIT_CTLS = 0x48F;
constexpr ULONG MSR_IA32_VMX_TRUE_ENTRY_CTLS = 0x490;
constexpr ULONG MSR_IA32_VMX_VMFUNC = 0x491;

constexpr ULONG MSR_IA32_SYSENTER_CS = 0x174;
constexpr ULONG MSR_IA32_SYSENTER_ESP = 0x175;
constexpr ULONG MSR_IA32_SYSENTER_EIP = 0x176;
constexpr ULONG MSR_IA32_DEBUGCTL = 0x1D9;

constexpr ULONG MSR_LSTAR = 0xC0000082;

constexpr ULONG MSR_FS_BASE = 0xC0000100;
constexpr ULONG MSR_GS_BASE = 0xC0000101;
constexpr ULONG MSR_SHADOW_GS_BASE = 0xC0000102;

constexpr ULONG MSR_IA32_MTRR_DEF_TYPE = 0x2FF;
constexpr ULONG MSR_IA32_MTRR_CAPABILITIES = 0x000000FE;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE0 = 0x00000200;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE1 = 0x00000202;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE2 = 0x00000204;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE3 = 0x00000206;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE4 = 0x00000208;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE5 = 0x0000020A;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE6 = 0x0000020C;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE7 = 0x0000020E;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE8 = 0x00000210;
constexpr ULONG MSR_IA32_MTRR_PHYSBASE9 = 0x00000212;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK0 = 0x00000201;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK1 = 0x00000203;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK2 = 0x00000205;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK3 = 0x00000207;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK4 = 0x00000209;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK5 = 0x0000020B;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK6 = 0x0000020D;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK7 = 0x0000020F;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK8 = 0x00000211;
constexpr ULONG MSR_IA32_MTRR_PHYSMASK9 = 0x00000213;
constexpr SIZE_T IA32_MTRR_FIX64K_BASE = 0x00000000;
constexpr SIZE_T IA32_MTRR_FIX64K_SIZE = 0x00010000;
constexpr SIZE_T IA32_MTRR_FIX64K_00000 = 0x00000250;

constexpr SIZE_T IA32_MTRR_FIX16K_BASE = 0x00080000;
constexpr SIZE_T IA32_MTRR_FIX16K_SIZE = 0x00004000;
constexpr SIZE_T IA32_MTRR_FIX16K_80000 = 0x00000258;
constexpr SIZE_T IA32_MTRR_FIX16K_A0000 = 0x00000259;

constexpr SIZE_T IA32_MTRR_FIX4K_BASE = 0x000C0000;
constexpr SIZE_T IA32_MTRR_FIX4K_SIZE = 0x00001000;
constexpr SIZE_T IA32_MTRR_FIX4K_C0000 = 0x00000268;
constexpr SIZE_T IA32_MTRR_FIX4K_C8000 = 0x00000269;
constexpr SIZE_T IA32_MTRR_FIX4K_D0000 = 0x0000026A;
constexpr SIZE_T IA32_MTRR_FIX4K_D8000 = 0x0000026B;
constexpr SIZE_T IA32_MTRR_FIX4K_E0000 = 0x0000026C;
constexpr SIZE_T IA32_MTRR_FIX4K_E8000 = 0x0000026D;
constexpr SIZE_T IA32_MTRR_FIX4K_F0000 = 0x0000026E;
constexpr SIZE_T IA32_MTRR_FIX4K_F8000 = 0x0000026F;

constexpr ULONG64 RESERVED_MSR_RANGE_LOW = 0x40000000;
constexpr ULONG64 RESERVED_MSR_RANGE_HIGH = 0x400000F0;

constexpr USHORT VMEXIT_STATE_BITS = 0xF8;
constexpr ULONGLONG NO_ADDITIONAL_VMCS = ~0ULL;

constexpr ULONG PIN_BASED_VM_EXECUTION_CONTROLS_EXTERNAL_INTERRUPT = 0x00000001;
constexpr ULONG PIN_BASED_VM_EXECUTION_CONTROLS_NMI_EXITING = 0x00000008;
constexpr ULONG PIN_BASED_VM_EXECUTION_CONTROLS_VIRTUAL_NMI = 0x00000020;
constexpr ULONG PIN_BASED_VM_EXECUTION_CONTROLS_ACTIVE_VMX_TIMER = 0x00000040;
constexpr ULONG PIN_BASED_VM_EXECUTION_CONTROLS_PROCESS_POSTED_INTERRUPTS = 0x00000080;

constexpr ULONG CPU_BASED_VIRTUAL_INTR_PENDING = 0x00000004;
constexpr ULONG CPU_BASED_USE_TSC_OFFSETING = 0x00000008;
constexpr ULONG CPU_BASED_HLT_EXITING = 0x00000080;
constexpr ULONG CPU_BASED_INVLPG_EXITING = 0x00000200;
constexpr ULONG CPU_BASED_MWAIT_EXITING = 0x00000400;
constexpr ULONG CPU_BASED_RDPMC_EXITING = 0x00000800;
constexpr ULONG CPU_BASED_RDTSC_EXITING = 0x00001000;
constexpr ULONG CPU_BASED_CR3_LOAD_EXITING = 0x00008000;
constexpr ULONG CPU_BASED_CR3_STORE_EXITING = 0x00010000;
constexpr ULONG CPU_BASED_CR8_LOAD_EXITING = 0x00080000;
constexpr ULONG CPU_BASED_CR8_STORE_EXITING = 0x00100000;
constexpr ULONG CPU_BASED_TPR_SHADOW = 0x00200000;
constexpr ULONG CPU_BASED_VIRTUAL_NMI_PENDING = 0x00400000;
constexpr ULONG CPU_BASED_MOV_DR_EXITING = 0x00800000;
constexpr ULONG CPU_BASED_UNCOND_IO_EXITING = 0x01000000;
constexpr ULONG CPU_BASED_ACTIVATE_IO_BITMAP = 0x02000000;
constexpr ULONG CPU_BASED_MONITOR_TRAP_FLAG = 0x08000000;
constexpr ULONG CPU_BASED_ACTIVATE_MSR_BITMAP = 0x10000000;
constexpr ULONG CPU_BASED_MONITOR_EXITING = 0x20000000;
constexpr ULONG CPU_BASED_PAUSE_EXITING = 0x40000000;
constexpr ULONG CPU_BASED_ACTIVATE_SECONDARY_CONTROLS = 0x80000000;

constexpr ULONG CPU_BASED_CTL2_ENABLE_EPT = 0x2;
constexpr ULONG CPU_BASED_CTL2_RDTSCP = 0x8;
constexpr ULONG CPU_BASED_CTL2_ENABLE_VPID = 0x20;
constexpr ULONG CPU_BASED_CTL2_UNRESTRICTED_GUEST = 0x80;
constexpr ULONG CPU_BASED_CTL2_VIRTUAL_INTERRUPT_DELIVERY = 0x200;
constexpr ULONG CPU_BASED_CTL2_ENABLE_INVPCID = 0x1000;
constexpr ULONG CPU_BASED_CTL2_ENABLE_VMFUNC = 0x2000;
constexpr ULONG CPU_BASED_CTL2_ENABLE_XSAVE_XRSTORS = 0x100000;

// VMCalls
constexpr ULONG VMCALL_TEST = 1;
constexpr ULONG VMCALL_VMXOFF = 2;
constexpr ULONG VMCALL_EXEC_HOOK_PAGE = 3;
constexpr ULONG VMCALL_INVEPT_ALL_CONTEXT = 4;
constexpr ULONG VMCALL_INVEPT_SINGLE_CONTEXT = 5;
constexpr ULONG VMCALL_UNHOOK_SINGLE_PAGE = 6;
constexpr ULONG VMCALL_UNHOOK_ALL_PAGES = 7;

// VM-exit Control Bits
constexpr ULONG VM_EXIT_IA32E_MODE = 0x00000200;
constexpr ULONG VM_EXIT_ACK_INTR_ON_EXIT = 0x00008000;
constexpr ULONG VM_EXIT_SAVE_GUEST_PAT = 0x00040000;
constexpr ULONG VM_EXIT_LOAD_HOST_PAT = 0x00080000;

// VM-entry Control Bits
constexpr ULONG VM_ENTRY_IA32E_MODE = 0x00000200;
constexpr ULONG VM_ENTRY_SMM = 0x00000400;
constexpr ULONG VM_ENTRY_DEACT_DUAL_MONITOR = 0x00000800;
constexpr ULONG VM_ENTRY_LOAD_GUEST_PAT = 0x00004000;

// Exit Reasons
constexpr ULONG EXIT_REASON_EXCEPTION_NMI = 0;
constexpr ULONG EXIT_REASON_EXTERNAL_INTERRUPT = 1;
constexpr ULONG EXIT_REASON_TRIPLE_FAULT = 2;
constexpr ULONG EXIT_REASON_INIT = 3;
constexpr ULONG EXIT_REASON_SIPI = 4;
constexpr ULONG EXIT_REASON_IO_SMI = 5;
constexpr ULONG EXIT_REASON_OTHER_SMI = 6;
constexpr ULONG EXIT_REASON_PENDING_VIRT_INTR = 7;
constexpr ULONG EXIT_REASON_PENDING_VIRT_NMI = 8;
constexpr ULONG EXIT_REASON_TASK_SWITCH = 9;
constexpr ULONG EXIT_REASON_CPUID = 10;
constexpr ULONG EXIT_REASON_GETSEC = 11;
constexpr ULONG EXIT_REASON_HLT = 12;
constexpr ULONG EXIT_REASON_INVD = 13;
constexpr ULONG EXIT_REASON_INVLPG = 14;
constexpr ULONG EXIT_REASON_RDPMC = 15;
constexpr ULONG EXIT_REASON_RDTSC = 16;
constexpr ULONG EXIT_REASON_RSM = 17;
constexpr ULONG EXIT_REASON_VMCALL = 18;
constexpr ULONG EXIT_REASON_VMCLEAR = 19;
constexpr ULONG EXIT_REASON_VMLAUNCH = 20;
constexpr ULONG EXIT_REASON_VMPTRLD = 21;
constexpr ULONG EXIT_REASON_VMPTRST = 22;
constexpr ULONG EXIT_REASON_VMREAD = 23;
constexpr ULONG EXIT_REASON_VMRESUME = 24;
constexpr ULONG EXIT_REASON_VMWRITE = 25;
constexpr ULONG EXIT_REASON_VMXOFF = 26;
constexpr ULONG EXIT_REASON_VMXON = 27;
constexpr ULONG EXIT_REASON_CR_ACCESS = 28;
constexpr ULONG EXIT_REASON_DR_ACCESS = 29;
constexpr ULONG EXIT_REASON_IO_INSTRUCTION = 30;
constexpr ULONG EXIT_REASON_MSR_READ = 31;
constexpr ULONG EXIT_REASON_MSR_WRITE = 32;
constexpr ULONG EXIT_REASON_INVALID_GUEST_STATE = 33;
constexpr ULONG EXIT_REASON_MSR_LOADING = 34;
constexpr ULONG EXIT_REASON_MWAIT_INSTRUCTION = 36;
constexpr ULONG EXIT_REASON_MONITOR_TRAP_FLAG = 37;
constexpr ULONG EXIT_REASON_MONITOR_INSTRUCTION = 39;
constexpr ULONG EXIT_REASON_PAUSE_INSTRUCTION = 40;
constexpr ULONG EXIT_REASON_MCE_DURING_VMENTRY = 41;
constexpr ULONG EXIT_REASON_TPR_BELOW_THRESHOLD = 43;
constexpr ULONG EXIT_REASON_APIC_ACCESS = 44;
constexpr ULONG EXIT_REASON_ACCESS_GDTR_OR_IDTR = 46;
constexpr ULONG EXIT_REASON_ACCESS_LDTR_OR_TR = 47;
constexpr ULONG EXIT_REASON_EPT_VIOLATION = 48;
constexpr ULONG EXIT_REASON_EPT_MISCONFIG = 49;
constexpr ULONG EXIT_REASON_INVEPT = 50;
constexpr ULONG EXIT_REASON_RDTSCP = 51;
constexpr ULONG EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED = 52;
constexpr ULONG EXIT_REASON_INVVPID = 53;
constexpr ULONG EXIT_REASON_WBINVD = 54;
constexpr ULONG EXIT_REASON_XSETBV = 55;
constexpr ULONG EXIT_REASON_APIC_WRITE = 56;
constexpr ULONG EXIT_REASON_RDRAND = 57;
constexpr ULONG EXIT_REASON_INVPCID = 58;
constexpr ULONG EXIT_REASON_RDSEED = 61;
constexpr ULONG EXIT_REASON_PML_FULL = 62;
constexpr ULONG EXIT_REASON_XSAVES = 63;
constexpr ULONG EXIT_REASON_XRSTORS = 64;
constexpr ULONG EXIT_REASON_PCOMMIT = 65;

// Hyperv cpuid
constexpr ULONG HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS = 0x40000000;
constexpr ULONG HYPERV_CPUID_INTERFACE = 0x40000001;
constexpr ULONG HYPERV_CPUID_VERSION = 0x40000002;
constexpr ULONG HYPERV_CPUID_FEATURES = 0x40000003;
constexpr ULONG HYPERV_CPUID_ENLIGHTMENT_INFO = 0x40000004;
constexpr ULONG HYPERV_CPUID_IMPLEMENT_LIMITS = 0x40000005;
constexpr ULONG HYPERV_HYPERVISOR_PRESENT_BIT = 0x80000000;
constexpr ULONG HYPERV_CPUID_MIN = 0x40000005;
constexpr ULONG HYPERV_CPUID_MAX = 0x4000ffff;

// Exit qualification for CR accesses
constexpr ULONG TYPE_MOV_TO_CR = 0;
constexpr ULONG TYPE_MOV_FROM_CR = 1;
constexpr ULONG TYPE_CLTS = 2;
constexpr ULONG TYPE_LMSW = 3;

// DPL modes
constexpr SIZE_T DPL_USER = 3;
constexpr SIZE_T DPL_SYSTEM = 0;

// Ept definitions
constexpr SIZE_T VMM_EPT_PML4E_COUNT = 512;
constexpr SIZE_T VMM_EPT_PML3E_COUNT = 512;
constexpr SIZE_T VMM_EPT_PML2E_COUNT = 512;
constexpr SIZE_T VMM_EPT_PML1E_COUNT = 512;

constexpr UCHAR MEMORY_TYPE_UNCACHEABLE = 0x00000000;
constexpr UCHAR MEMORY_TYPE_WRITE_COMBINING = 0x00000001;
constexpr UCHAR MEMORY_TYPE_WRITE_THROUGH = 0x00000004;
constexpr UCHAR MEMORY_TYPE_WRITE_PROTECTED = 0x00000005;
constexpr UCHAR MEMORY_TYPE_WRITE_BACK = 0x00000006;
constexpr UCHAR MEMORY_TYPE_INVALID = 0x000000FF;

constexpr SIZE_T VPID_TAG = 1;

// Integer 2MB
constexpr SIZE_T SIZE_2_MB = ((SIZE_T)(512 * PAGE_SIZE));

// Offset into the 1st paging structure (4096 byte)
#define ADDRMASK_EPT_PML1_OFFSET(_VAR_) (_VAR_ & 0xFFFULL)

// Index of the 1st paging structure (4096 byte)
#define ADDRMASK_EPT_PML1_INDEX(_VAR_) ((_VAR_ & 0x1FF000ULL) >> 12)

// Index of the 2nd paging structure (2MB)
#define ADDRMASK_EPT_PML2_INDEX(_VAR_) ((_VAR_ & 0x3FE00000ULL) >> 21)

// Index of the 3rd paging structure (1GB)
#define ADDRMASK_EPT_PML3_INDEX(_VAR_) ((_VAR_ & 0x7FC0000000ULL) >> 30)

// Index of the 4th paging structure (512GB)
#define ADDRMASK_EPT_PML4_INDEX(_VAR_) ((_VAR_ & 0xFF8000000000ULL) >> 39)

constexpr ULONG64 CPUID_PROCESSOR_AND_PROCESSOR_FEATURE_IDENTIFIERS = 1;

// Type definitions
enum RegionType {
	VMXON_REGION,
	VMCS_REGION,
	MSR_BITMAP_REGION
};

typedef union _PEPT_PML4
{
	struct
	{
		/**
		 * [Bit 0] Read access; indicates whether reads are allowed from the 512-GByte region controlled by this entry.
		 */
		UINT64 ReadAccess : 1;

		/**
		 * [Bit 1] Write access; indicates whether writes are allowed from the 512-GByte region controlled by this entry.
		 */
		UINT64 WriteAccess : 1;

		/**
		 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
		 * instruction fetches are allowed from the 512-GByte region controlled by this entry.
		 * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
		 * allowed from supervisor-mode linear addresses in the 512-GByte region controlled by this entry.
		 */
		UINT64 ExecuteAccess : 1;
		UINT64 Reserved1 : 5;

		/**
		 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 512-GByte region
		 * controlled by this entry. Ignored if bit 6 of EPTP is 0.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 Accessed : 1;
		UINT64 Reserved2 : 1;

		/**
		 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
		 * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 512-GByte region
		 * controlled by this entry. If that control is 0, this bit is ignored.
		 */
		UINT64 UserModeExecute : 1;
		UINT64 Reserved3 : 1;

		/**
		 * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
		 */
		UINT64 PageFrameNumber : 36;
		UINT64 Reserved4 : 16;
	};

	UINT64 Flags;
} EPT_PML4, * PEPT_PML4;



typedef union _EPDPTE_1GB
{
	struct
	{
		/**
		 * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte page referenced by this entry.
		 */
		UINT64 ReadAccess : 1;

		/**
		 * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte page referenced by this entry.
		 */
		UINT64 WriteAccess : 1;

		/**
		 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
		 * instruction fetches are allowed from the 1-GByte page controlled by this entry.
		 * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
		 * allowed from supervisor-mode linear addresses in the 1-GByte page controlled by this entry.
		 */
		UINT64 ExecuteAccess : 1;

		/**
		 * [Bits 5:3] EPT memory type for this 1-GByte page.
		 *
		 * @see Vol3C[28.2.6(EPT and memory Typing)]
		 */
		UINT64 MemoryType : 3;

		/**
		 * [Bit 6] Ignore PAT memory type for this 1-GByte page.
		 *
		 * @see Vol3C[28.2.6(EPT and memory Typing)]
		 */
		UINT64 IgnorePat : 1;

		/**
		 * [Bit 7] Must be 1 (otherwise, this entry references an EPT page directory).
		 */
		UINT64 LargePage : 1;

		/**
		 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte page
		 * referenced by this entry. Ignored if bit 6 of EPTP is 0.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 Accessed : 1;

		/**
		 * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 1-GByte page referenced
		 * by this entry. Ignored if bit 6 of EPTP is 0.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 Dirty : 1;

		/**
		 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
		 * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte page controlled
		 * by this entry. If that control is 0, this bit is ignored.
		 */
		UINT64 UserModeExecute : 1;
		UINT64 Reserved1 : 19;

		/**
		 * [Bits 47:30] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
		 */
		UINT64 PageFrameNumber : 18;
		UINT64 Reserved2 : 15;

		/**
		 * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
		 * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
		 * 0, this bit is ignored.
		 *
		 * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
		 */
		UINT64 SuppressVe : 1;
	};

	UINT64 Flags;
} EPDPTE_1GB, * PEPDPTE_1GB;



typedef union _EPDPTE
{
	struct
	{
		/**
		 * [Bit 0] Read access; indicates whether reads are allowed from the 1-GByte region controlled by this entry.
		 */
		UINT64 ReadAccess : 1;

		/**
		 * [Bit 1] Write access; indicates whether writes are allowed from the 1-GByte region controlled by this entry.
		 */
		UINT64 WriteAccess : 1;

		/**
		 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
		 * instruction fetches are allowed from the 1-GByte region controlled by this entry.
		 * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
		 * allowed from supervisor-mode linear addresses in the 1-GByte region controlled by this entry.
		 */
		UINT64 ExecuteAccess : 1;
		UINT64 Reserved1 : 5;

		/**
		 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 1-GByte region
		 * controlled by this entry. Ignored if bit 6 of EPTP is 0.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 Accessed : 1;
		UINT64 Reserved2 : 1;

		/**
		 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
		 * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 1-GByte region controlled
		 * by this entry. If that control is 0, this bit is ignored.
		 */
		UINT64 UserModeExecute : 1;
		UINT64 Reserved3 : 1;

		/**
		 * [Bits 47:12] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
		 */
		UINT64 PageFrameNumber : 36;
		UINT64 Reserved4 : 16;
	};

	UINT64 Flags;
} EPDPTE, * PEPDPTE;


typedef union _EPDE_2MB
{
	struct
	{
		/**
		 * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte page referenced by this entry.
		 */
		UINT64 ReadAccess : 1;

		/**
		 * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte page referenced by this entry.
		 */
		UINT64 WriteAccess : 1;

		/**
		 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
		 * instruction fetches are allowed from the 2-MByte page controlled by this entry.
		 * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
		 * allowed from supervisor-mode linear addresses in the 2-MByte page controlled by this entry.
		 */
		UINT64 ExecuteAccess : 1;

		/**
		 * [Bits 5:3] EPT memory type for this 2-MByte page.
		 *
		 * @see Vol3C[28.2.6(EPT and memory Typing)]
		 */
		UINT64 MemoryType : 3;

		/**
		 * [Bit 6] Ignore PAT memory type for this 2-MByte page.
		 *
		 * @see Vol3C[28.2.6(EPT and memory Typing)]
		 */
		UINT64 IgnorePat : 1;

		/**
		 * [Bit 7] Must be 1 (otherwise, this entry references an EPT page table).
		 */
		UINT64 LargePage : 1;

		/**
		 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte page
		 * referenced by this entry. Ignored if bit 6 of EPTP is 0.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 Accessed : 1;

		/**
		 * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 2-MByte page referenced
		 * by this entry. Ignored if bit 6 of EPTP is 0.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 Dirty : 1;

		/**
		 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
		 * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte page controlled
		 * by this entry. If that control is 0, this bit is ignored.
		 */
		UINT64 UserModeExecute : 1;
		UINT64 Reserved1 : 10;

		/**
		 * [Bits 47:21] Physical address of 4-KByte aligned EPT page-directory-pointer table referenced by this entry.
		 */
		UINT64 PageFrameNumber : 27;
		UINT64 Reserved2 : 15;

		/**
		 * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
		 * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
		 * 0, this bit is ignored.
		 *
		 * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
		 */
		UINT64 SuppressVe : 1;
	};

	UINT64 Flags;
} EPDE_2MB, * PEPDE_2MB;



typedef union _EPDE
{
	struct
	{
		/**
		 * [Bit 0] Read access; indicates whether reads are allowed from the 2-MByte region controlled by this entry.
		 */
		UINT64 ReadAccess : 1;

		/**
		 * [Bit 1] Write access; indicates whether writes are allowed from the 2-MByte region controlled by this entry.
		 */
		UINT64 WriteAccess : 1;

		/**
		 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
		 * instruction fetches are allowed from the 2-MByte region controlled by this entry.
		 * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
		 * allowed from supervisor-mode linear addresses in the 2-MByte region controlled by this entry.
		 */
		UINT64 ExecuteAccess : 1;
		UINT64 Reserved1 : 5;

		/**
		 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 2-MByte region
		 * controlled by this entry. Ignored if bit 6 of EPTP is 0.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 Accessed : 1;
		UINT64 Reserved2 : 1;

		/**
		 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
		 * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 2-MByte region controlled
		 * by this entry. If that control is 0, this bit is ignored.
		 */
		UINT64 UserModeExecute : 1;
		UINT64 Reserved3 : 1;

		/**
		 * [Bits 47:12] Physical address of 4-KByte aligned EPT page table referenced by this entry.
		 */
		UINT64 PageFrameNumber : 36;
		UINT64 Reserved4 : 16;
	};

	UINT64 Flags;
} EPDE, * PEPDE;


typedef union _EPTE
{
	struct
	{
		/**
		 * [Bit 0] Read access; indicates whether reads are allowed from the 4-KByte page referenced by this entry.
		 */
		UINT64 ReadAccess : 1;

		/**
		 * [Bit 1] Write access; indicates whether writes are allowed from the 4-KByte page referenced by this entry.
		 */
		UINT64 WriteAccess : 1;

		/**
		 * [Bit 2] If the "mode-based execute control for EPT" VM-execution control is 0, execute access; indicates whether
		 * instruction fetches are allowed from the 4-KByte page controlled by this entry.
		 * If that control is 1, execute access for supervisor-mode linear addresses; indicates whether instruction fetches are
		 * allowed from supervisor-mode linear addresses in the 4-KByte page controlled by this entry.
		 */
		UINT64 ExecuteAccess : 1;

		/**
		 * [Bits 5:3] EPT memory type for this 4-KByte page.
		 *
		 * @see Vol3C[28.2.6(EPT and memory Typing)]
		 */
		UINT64 MemoryType : 3;

		/**
		 * [Bit 6] Ignore PAT memory type for this 4-KByte page.
		 *
		 * @see Vol3C[28.2.6(EPT and memory Typing)]
		 */
		UINT64 IgnorePat : 1;
		UINT64 Reserved1 : 1;

		/**
		 * [Bit 8] If bit 6 of EPTP is 1, accessed flag for EPT; indicates whether software has accessed the 4-KByte page
		 * referenced by this entry. Ignored if bit 6 of EPTP is 0.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 Accessed : 1;

		/**
		 * [Bit 9] If bit 6 of EPTP is 1, dirty flag for EPT; indicates whether software has written to the 4-KByte page referenced
		 * by this entry. Ignored if bit 6 of EPTP is 0.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 Dirty : 1;

		/**
		 * [Bit 10] Execute access for user-mode linear addresses. If the "mode-based execute control for EPT" VM-execution control
		 * is 1, indicates whether instruction fetches are allowed from user-mode linear addresses in the 4-KByte page controlled
		 * by this entry. If that control is 0, this bit is ignored.
		 */
		UINT64 UserModeExecute : 1;
		UINT64 Reserved2 : 1;

		/**
		 * [Bits 47:12] Physical address of the 4-KByte page referenced by this entry.
		 */
		UINT64 PageFrameNumber : 36;
		UINT64 Reserved3 : 15;

		/**
		 * [Bit 63] Suppress \#VE. If the "EPT-violation \#VE" VM-execution control is 1, EPT violations caused by accesses to this
		 * page are convertible to virtualization exceptions only if this bit is 0. If "EPT-violation \#VE" VMexecution control is
		 * 0, this bit is ignored.
		 *
		 * @see Vol3C[25.5.6.1(Convertible EPT Violations)]
		 */
		UINT64 SuppressVe : 1;
	};

	UINT64 Flags;
} EPTE, * PEPTE;

typedef EPT_PML4 EPT_PML4_POINTER, * PEPT_PML4_POINTER;
typedef EPDPTE EPT_PML3_POINTER, * PEPT_PML3_POINTER;
typedef EPDE_2MB EPT_PML2_ENTRY, * PEPT_PML2_ENTRY;
typedef EPDE EPT_PML2_POINTER, * PEPT_PML2_POINTER;
typedef EPTE EPT_PML1_ENTRY, * PEPT_PML1_ENTRY;

typedef struct _VMM_EPT_PAGE_TABLE
{
	DECLSPEC_ALIGN(PAGE_SIZE) EPT_PML4_POINTER PML4[VMM_EPT_PML4E_COUNT];
	DECLSPEC_ALIGN(PAGE_SIZE) EPT_PML3_POINTER PML3[VMM_EPT_PML3E_COUNT];
	DECLSPEC_ALIGN(PAGE_SIZE) EPT_PML2_ENTRY PML2[VMM_EPT_PML3E_COUNT][VMM_EPT_PML2E_COUNT];
} VMM_EPT_PAGE_TABLE, * PVMM_EPT_PAGE_TABLE;

typedef struct _VMM_EPT_DYNAMIC_SPLIT
{
	DECLSPEC_ALIGN(PAGE_SIZE) EPT_PML1_ENTRY PML1[VMM_EPT_PML1E_COUNT];
	union
	{
		PEPT_PML2_ENTRY Entry;
		PEPT_PML2_POINTER Pointer;
	};

} VMM_EPT_DYNAMIC_SPLIT, * PVMM_EPT_DYNAMIC_SPLIT;

typedef struct _MTRR_RANGE_DESCRIPTOR
{
	SIZE_T PhysicalBaseAddress;
	SIZE_T PhysicalEndAddress;
	UCHAR MemoryType;
	bool FixedRange;
} MTRR_RANGE_DESCRIPTOR, * PMTRR_RANGE_DESCRIPTOR;

typedef union _IA32_VMX_EPT_VPID_CAP_REGISTER
{
	struct
	{
		/**
		 * [Bit 0] When set to 1, the processor supports execute-only translations by EPT. This support allows software to
		 * configure EPT paging-structure entries in which bits 1:0 are clear (indicating that data accesses are not allowed) and
		 * bit 2 is set (indicating that instruction fetches are allowed).
		 */
		UINT64 ExecuteOnlyPages : 1;
		UINT64 Reserved1 : 5;

		/**
		 * [Bit 6] Indicates support for a page-walk length of 4.
		 */
		UINT64 PageWalkLength4 : 1;
		UINT64 Reserved2 : 1;

		/**
		 * [Bit 8] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
		 * uncacheable (UC).
		 *
		 * @see Vol3C[24.6.11(Extended-Page-Table Pointer (EPTP))]
		 */
		UINT64 MemoryTypeUncacheable : 1;
		UINT64 Reserved3 : 5;

		/**
		 * [Bit 14] When set to 1, the logical processor allows software to configure the EPT paging-structure memory type to be
		 * write-back (WB).
		 */
		UINT64 MemoryTypeWriteBack : 1;
		UINT64 Reserved4 : 1;

		/**
		 * [Bit 16] When set to 1, the logical processor allows software to configure a EPT PDE to map a 2-Mbyte page (by setting
		 * bit 7 in the EPT PDE).
		 */
		UINT64 Pde2MbPages : 1;

		/**
		 * [Bit 17] When set to 1, the logical processor allows software to configure a EPT PDPTE to map a 1-Gbyte page (by setting
		 * bit 7 in the EPT PDPTE).
		 */
		UINT64 Pdpte1GbPages : 1;
		UINT64 Reserved5 : 2;

		/**
		 * [Bit 20] If bit 20 is read as 1, the INVEPT instruction is supported.
		 *
		 * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
		 * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
		 */
		UINT64 Invept : 1;

		/**
		 * [Bit 21] When set to 1, accessed and dirty flags for EPT are supported.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 EptAccessedAndDirtyFlags : 1;

		/**
		 * [Bit 22] When set to 1, the processor reports advanced VM-exit information for EPT violations. This reporting is done
		 * only if this bit is read as 1.
		 *
		 * @see Vol3C[27.2.1(Basic VM-Exit Information)]
		 */
		UINT64 AdvancedVmexitEptViolationsInformation : 1;
		UINT64 Reserved6 : 2;

		/**
		 * [Bit 25] When set to 1, the single-context INVEPT type is supported.
		 *
		 * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
		 * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
		 */
		UINT64 InveptSingleContext : 1;

		/**
		 * [Bit 26] When set to 1, the all-context INVEPT type is supported.
		 *
		 * @see Vol3C[30(VMX INSTRUCTION REFERENCE)]
		 * @see Vol3C[28.3.3.1(Operations that Invalidate Cached Mappings)]
		 */
		UINT64 InveptAllContexts : 1;
		UINT64 Reserved7 : 5;

		/**
		 * [Bit 32] When set to 1, the INVVPID instruction is supported.
		 */
		UINT64 Invvpid : 1;
		UINT64 Reserved8 : 7;

		/**
		 * [Bit 40] When set to 1, the individual-address INVVPID type is supported.
		 */
		UINT64 InvvpidIndividualAddress : 1;

		/**
		 * [Bit 41] When set to 1, the single-context INVVPID type is supported.
		 */
		UINT64 InvvpidSingleContext : 1;

		/**
		 * [Bit 42] When set to 1, the all-context INVVPID type is supported.
		 */
		UINT64 InvvpidAllContexts : 1;

		/**
		 * [Bit 43] When set to 1, the single-context-retaining-globals INVVPID type is supported.
		 */
		UINT64 InvvpidSingleContextRetainGlobals : 1;
		UINT64 Reserved9 : 20;
	};

	UINT64 Flags;
} IA32_VMX_EPT_VPID_CAP_REGISTER, * PIA32_VMX_EPT_VPID_CAP_REGISTER;

// MSR_IA32_MTRR_DEF_TYPE 
typedef union
{
	struct
	{
		/**
		 * [Bits 2:0] Default Memory Type.
		 */
		UINT64 DefaultMemoryType : 3;
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_BIT                   0
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_FLAG                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE_MASK                  0x07
#define IA32_MTRR_DEF_TYPE_DEFAULT_MEMORY_TYPE(_)                    (((_) >> 0) & 0x07)
		UINT64 Reserved1 : 7;

		/**
		 * [Bit 10] Fixed Range MTRR Enable.
		 */
		UINT64 FixedRangeMtrrEnable : 1;
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_BIT               10
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_FLAG              0x400
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE_MASK              0x01
#define IA32_MTRR_DEF_TYPE_FIXED_RANGE_MTRR_ENABLE(_)                (((_) >> 10) & 0x01)

		/**
		 * [Bit 11] MTRR Enable.
		 */
		UINT64 MtrrEnable : 1;
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_BIT                           11
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_FLAG                          0x800
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE_MASK                          0x01
#define IA32_MTRR_DEF_TYPE_MTRR_ENABLE(_)                            (((_) >> 11) & 0x01)
		UINT64 Reserved2 : 52;
	};

	UINT64 Flags;
} IA32_MTRR_DEF_TYPE_REGISTER;

typedef union _IA32_FEATURE_CONTROL_MSR
{
	ULONG64 All;
	struct
	{
		ULONG64 Lock : 1;
		ULONG64 EnableSMX : 1;
		ULONG64 EnableVmxon : 1;
		ULONG64 Reserved2 : 5;
		ULONG64 EnableLocalSENTER : 7;
		ULONG64 EnableGlobalSENTER : 1;
		ULONG64 Reserved3a : 16;
		ULONG64 Reserved3b : 32;
	} Fields;
} IA32_FEATURE_CONTROL_MSR, * PIA32_FEATURE_CONTROL_MSR;

typedef struct _CPUID {
	int eax;
	int ebx;
	int ecx;
	int edx;
} CPUID, * PCPUID;

typedef union _IA32_VMX_BASIC_MSR
{
	ULONG64 All;
	struct
	{
		ULONG32 RevisionIdentifier : 31;  // [0-30]
		ULONG32 Reserved1 : 1;            // [31]
		ULONG32 RegionSize : 12;          // [32-43]
		ULONG32 RegionClear : 1;          // [44]
		ULONG32 Reserved2 : 3;            // [45-47]
		ULONG32 SupportedIA64 : 1;        // [48]
		ULONG32 SupportedDualMoniter : 1; // [49]
		ULONG32 MemoryType : 4;           // [50-53]
		ULONG32 VmExitReport : 1;         // [54]
		ULONG32 VmxCapabilityHint : 1;    // [55]
		ULONG32 Reserved3 : 8;            // [56-63]
	} Fields;
} IA32_VMX_BASIC_MSR, * PIA32_VMX_BASIC_MSR;

typedef union _EPTP
{
	struct
	{
		/**
		 * [Bits 2:0] EPT paging-structure memory type:
		 * - 0 = Uncacheable (UC)
		 * - 6 = Write-back (WB)
		 * Other values are reserved.
		 *
		 * @see Vol3C[28.2.6(EPT and memory Typing)]
		 */
		UINT64 MemoryType : 3;

		/**
		 * [Bits 5:3] This value is 1 less than the EPT page-walk length.
		 *
		 * @see Vol3C[28.2.6(EPT and memory Typing)]
		 */
		UINT64 PageWalkLength : 3;

		/**
		 * [Bit 6] Setting this control to 1 enables accessed and dirty flags for EPT.
		 *
		 * @see Vol3C[28.2.4(Accessed and Dirty Flags for EPT)]
		 */
		UINT64 EnableAccessAndDirtyFlags : 1;
		UINT64 Reserved1 : 5;

		/**
		 * [Bits 47:12] Bits N-1:12 of the physical address of the 4-KByte aligned EPT PML4 table.
		 */
		UINT64 PageFrameNumber : 36;
		UINT64 Reserved2 : 16;
	};

	UINT64 Flags;
} EPTP, * PEPTP;

typedef union _VMX_EXIT_QUALIFICATION_EPT_VIOLATION
{
	struct
	{
		UINT64 ReadAccess : 1;
		UINT64 WriteAccess : 1;
		UINT64 ExecuteAccess : 1;
		UINT64 EptReadable : 1;
		UINT64 EptWriteable : 1;
		UINT64 EptExecutable : 1;
		UINT64 EptExecutableForUserMode : 1;
		UINT64 ValidGuestLinearAddress : 1;
		UINT64 CausedByTranslation : 1;
		UINT64 UserModeLinearAddress : 1;
		UINT64 ReadableWritablePage : 1;
		UINT64 ExecuteDisablePage : 1;
		UINT64 NmiUnblocking : 1;
		UINT64 Reserved1 : 51;
	};

	UINT64 Flags;
} VMX_EXIT_QUALIFICATION_EPT_VIOLATION, * PVMX_EXIT_QUALIFICATION_EPT_VIOLATION;

//
// See Table 28-1.
//
typedef union _EPT_PML4E
{
	ULONG64 All;
	struct
	{
		UINT64 Read : 1;               // bit 0
		UINT64 Write : 1;              // bit 1
		UINT64 Execute : 1;            // bit 2
		UINT64 Reserved1 : 5;          // bit 7:3 (Must be Zero)
		UINT64 Accessed : 1;           // bit 8
		UINT64 Ignored1 : 1;           // bit 9
		UINT64 ExecuteForUserMode : 1; // bit 10
		UINT64 Ignored2 : 1;           // bit 11
		UINT64 PhysicalAddress : 36;   // bit (N-1):12 or Page-Frame-Number
		UINT64 Reserved2 : 4;          // bit 51:N
		UINT64 Ignored3 : 12;          // bit 63:52
	} Fields;
} EPT_PML4E, * PEPT_PML4E;

//
// See Table 28-3
//
typedef union _EPT_PDPTE
{
	ULONG64 All;
	struct
	{
		UINT64 Read : 1;               // bit 0
		UINT64 Write : 1;              // bit 1
		UINT64 Execute : 1;            // bit 2
		UINT64 Reserved1 : 5;          // bit 7:3 (Must be Zero)
		UINT64 Accessed : 1;           // bit 8
		UINT64 Ignored1 : 1;           // bit 9
		UINT64 ExecuteForUserMode : 1; // bit 10
		UINT64 Ignored2 : 1;           // bit 11
		UINT64 PhysicalAddress : 36;   // bit (N-1):12 or Page-Frame-Number
		UINT64 Reserved2 : 4;          // bit 51:N
		UINT64 Ignored3 : 12;          // bit 63:52
	} Fields;
} EPT_PDPTE, * PEPT_PDPTE;

//
// See Table 28-5
//
typedef union _EPT_PDE
{
	ULONG64 All;
	struct
	{
		UINT64 Read : 1;               // bit 0
		UINT64 Write : 1;              // bit 1
		UINT64 Execute : 1;            // bit 2
		UINT64 Reserved1 : 5;          // bit 7:3 (Must be Zero)
		UINT64 Accessed : 1;           // bit 8
		UINT64 Ignored1 : 1;           // bit 9
		UINT64 ExecuteForUserMode : 1; // bit 10
		UINT64 Ignored2 : 1;           // bit 11
		UINT64 PhysicalAddress : 36;   // bit (N-1):12 or Page-Frame-Number
		UINT64 Reserved2 : 4;          // bit 51:N
		UINT64 Ignored3 : 12;          // bit 63:52
	} Fields;
} EPT_PDE, * PEPT_PDE;

//
// See Table 28-6
//
typedef union _EPT_PTE
{
	ULONG64 All;
	struct
	{
		UINT64 Read : 1;               // bit 0
		UINT64 Write : 1;              // bit 1
		UINT64 Execute : 1;            // bit 2
		UINT64 EPTMemoryType : 3;      // bit 5:3 (EPT Memory type)
		UINT64 IgnorePAT : 1;          // bit 6
		UINT64 Ignored1 : 1;           // bit 7
		UINT64 AccessedFlag : 1;       // bit 8
		UINT64 DirtyFlag : 1;          // bit 9
		UINT64 ExecuteForUserMode : 1; // bit 10
		UINT64 Ignored2 : 1;           // bit 11
		UINT64 PhysicalAddress : 36;   // bit (N-1):12 or Page-Frame-Number
		UINT64 Reserved : 4;           // bit 51:N
		UINT64 Ignored3 : 11;          // bit 62:52
		UINT64 SuppressVE : 1;         // bit 63
	} Fields;
} EPT_PTE, * PEPT_PTE;

typedef union _IA32_MTRR_CAPABILITIES_REGISTER
{
	struct
	{
		UINT64 VariableRangeCount : 8;
		UINT64 FixedRangeSupported : 1;
		UINT64 Reserved1 : 1;
		UINT64 WcSupported : 1;
		UINT64 SmrrSupported : 1;
		UINT64 Reserved2 : 52;
	};

	UINT64 Flags;
} IA32_MTRR_CAPABILITIES_REGISTER, * PIA32_MTRR_CAPABILITIES_REGISTER;


// MSR_IA32_MTRR_PHYSBASE(0-9)
typedef union _IA32_MTRR_PHYSBASE_REGISTER
{
	struct
	{
		UINT64 Type : 8;
		UINT64 Reserved1 : 4;
		UINT64 PageFrameNumber : 36;
		UINT64 Reserved2 : 16;
	};

	UINT64 Flags;
} IA32_MTRR_PHYSBASE_REGISTER, * PIA32_MTRR_PHYSBASE_REGISTER;


typedef union _IA32_MTRR_PHYSMASK_REGISTER
{
	struct
	{
		UINT64 Type : 8;
		UINT64 Reserved1 : 3;
		UINT64 Valid : 1;
		UINT64 PageFrameNumber : 36;
		UINT64 Reserved2 : 16;
	};

	UINT64 Flags;
} IA32_MTRR_PHYSMASK_REGISTER, * PIA32_MTRR_PHYSMASK_REGISTER;

enum INVEPT_TYPE
{
	SINGLE_CONTEXT = 0x00000001,
	ALL_CONTEXTS = 0x00000002,
};

enum VMCS_FIELDS
{
	VIRTUAL_PROCESSOR_ID = 0x00000000,
	GUEST_ES_SELECTOR = 0x00000800,
	GUEST_CS_SELECTOR = 0x00000802,
	GUEST_SS_SELECTOR = 0x00000804,
	GUEST_DS_SELECTOR = 0x00000806,
	GUEST_FS_SELECTOR = 0x00000808,
	GUEST_GS_SELECTOR = 0x0000080a,
	GUEST_LDTR_SELECTOR = 0x0000080c,
	GUEST_TR_SELECTOR = 0x0000080e,
	HOST_ES_SELECTOR = 0x00000c00,
	HOST_CS_SELECTOR = 0x00000c02,
	HOST_SS_SELECTOR = 0x00000c04,
	HOST_DS_SELECTOR = 0x00000c06,
	HOST_FS_SELECTOR = 0x00000c08,
	HOST_GS_SELECTOR = 0x00000c0a,
	HOST_TR_SELECTOR = 0x00000c0c,
	IO_BITMAP_A = 0x00002000,
	IO_BITMAP_A_HIGH = 0x00002001,
	IO_BITMAP_B = 0x00002002,
	IO_BITMAP_B_HIGH = 0x00002003,
	MSR_BITMAP = 0x00002004,
	MSR_BITMAP_HIGH = 0x00002005,
	VM_EXIT_MSR_STORE_ADDR = 0x00002006,
	VM_EXIT_MSR_STORE_ADDR_HIGH = 0x00002007,
	VM_EXIT_MSR_LOAD_ADDR = 0x00002008,
	VM_EXIT_MSR_LOAD_ADDR_HIGH = 0x00002009,
	VM_ENTRY_MSR_LOAD_ADDR = 0x0000200a,
	VM_ENTRY_MSR_LOAD_ADDR_HIGH = 0x0000200b,
	TSC_OFFSET = 0x00002010,
	TSC_OFFSET_HIGH = 0x00002011,
	VIRTUAL_APIC_PAGE_ADDR = 0x00002012,
	VIRTUAL_APIC_PAGE_ADDR_HIGH = 0x00002013,
	VMFUNC_CONTROLS = 0x00002018,
	VMFUNC_CONTROLS_HIGH = 0x00002019,
	EPT_POINTER = 0x0000201A,
	EPT_POINTER_HIGH = 0x0000201B,
	EPTP_LIST = 0x00002024,
	EPTP_LIST_HIGH = 0x00002025,
	GUEST_PHYSICAL_ADDRESS = 0x2400,
	GUEST_PHYSICAL_ADDRESS_HIGH = 0x2401,
	VMCS_LINK_POINTER = 0x00002800,
	VMCS_LINK_POINTER_HIGH = 0x00002801,
	GUEST_IA32_DEBUGCTL = 0x00002802,
	GUEST_IA32_DEBUGCTL_HIGH = 0x00002803,
	PIN_BASED_VM_EXEC_CONTROL = 0x00004000,
	CPU_BASED_VM_EXEC_CONTROL = 0x00004002,
	EXCEPTION_BITMAP = 0x00004004,
	PAGE_FAULT_ERROR_CODE_MASK = 0x00004006,
	PAGE_FAULT_ERROR_CODE_MATCH = 0x00004008,
	CR3_TARGET_COUNT = 0x0000400a,
	VM_EXIT_CONTROLS = 0x0000400c,
	VM_EXIT_MSR_STORE_COUNT = 0x0000400e,
	VM_EXIT_MSR_LOAD_COUNT = 0x00004010,
	VM_ENTRY_CONTROLS = 0x00004012,
	VM_ENTRY_MSR_LOAD_COUNT = 0x00004014,
	VM_ENTRY_INTR_INFO_FIELD = 0x00004016,
	VM_ENTRY_EXCEPTION_ERROR_CODE = 0x00004018,
	VM_ENTRY_INSTRUCTION_LEN = 0x0000401a,
	TPR_THRESHOLD = 0x0000401c,
	SECONDARY_VM_EXEC_CONTROL = 0x0000401e,
	VM_INSTRUCTION_ERROR = 0x00004400,
	VM_EXIT_REASON = 0x00004402,
	VM_EXIT_INTR_INFO = 0x00004404,
	VM_EXIT_INTR_ERROR_CODE = 0x00004406,
	IDT_VECTORING_INFO_FIELD = 0x00004408,
	IDT_VECTORING_ERROR_CODE = 0x0000440a,
	VM_EXIT_INSTRUCTION_LEN = 0x0000440c,
	VMX_INSTRUCTION_INFO = 0x0000440e,
	GUEST_ES_LIMIT = 0x00004800,
	GUEST_CS_LIMIT = 0x00004802,
	GUEST_SS_LIMIT = 0x00004804,
	GUEST_DS_LIMIT = 0x00004806,
	GUEST_FS_LIMIT = 0x00004808,
	GUEST_GS_LIMIT = 0x0000480a,
	GUEST_LDTR_LIMIT = 0x0000480c,
	GUEST_TR_LIMIT = 0x0000480e,
	GUEST_GDTR_LIMIT = 0x00004810,
	GUEST_IDTR_LIMIT = 0x00004812,
	GUEST_ES_AR_BYTES = 0x00004814,
	GUEST_CS_AR_BYTES = 0x00004816,
	GUEST_SS_AR_BYTES = 0x00004818,
	GUEST_DS_AR_BYTES = 0x0000481a,
	GUEST_FS_AR_BYTES = 0x0000481c,
	GUEST_GS_AR_BYTES = 0x0000481e,
	GUEST_LDTR_AR_BYTES = 0x00004820,
	GUEST_TR_AR_BYTES = 0x00004822,
	GUEST_INTERRUPTIBILITY_INFO = 0x00004824,
	GUEST_ACTIVITY_STATE = 0x00004826,
	GUEST_SM_BASE = 0x00004828,
	GUEST_SYSENTER_CS = 0x0000482A,
	HOST_IA32_SYSENTER_CS = 0x00004c00,
	CR0_GUEST_HOST_MASK = 0x00006000,
	CR4_GUEST_HOST_MASK = 0x00006002,
	CR0_READ_SHADOW = 0x00006004,
	CR4_READ_SHADOW = 0x00006006,
	CR3_TARGET_VALUE0 = 0x00006008,
	CR3_TARGET_VALUE1 = 0x0000600a,
	CR3_TARGET_VALUE2 = 0x0000600c,
	CR3_TARGET_VALUE3 = 0x0000600e,
	EXIT_QUALIFICATION = 0x00006400,
	GUEST_LINEAR_ADDRESS = 0x0000640a,
	GUEST_CR0 = 0x00006800,
	GUEST_CR3 = 0x00006802,
	GUEST_CR4 = 0x00006804,
	GUEST_ES_BASE = 0x00006806,
	GUEST_CS_BASE = 0x00006808,
	GUEST_SS_BASE = 0x0000680a,
	GUEST_DS_BASE = 0x0000680c,
	GUEST_FS_BASE = 0x0000680e,
	GUEST_GS_BASE = 0x00006810,
	GUEST_LDTR_BASE = 0x00006812,
	GUEST_TR_BASE = 0x00006814,
	GUEST_GDTR_BASE = 0x00006816,
	GUEST_IDTR_BASE = 0x00006818,
	GUEST_DR7 = 0x0000681a,
	GUEST_RSP = 0x0000681c,
	GUEST_RIP = 0x0000681e,
	GUEST_RFLAGS = 0x00006820,
	GUEST_PENDING_DBG_EXCEPTIONS = 0x00006822,
	GUEST_SYSENTER_ESP = 0x00006824,
	GUEST_SYSENTER_EIP = 0x00006826,
	HOST_CR0 = 0x00006c00,
	HOST_CR3 = 0x00006c02,
	HOST_CR4 = 0x00006c04,
	HOST_FS_BASE = 0x00006c06,
	HOST_GS_BASE = 0x00006c08,
	HOST_TR_BASE = 0x00006c0a,
	HOST_GDTR_BASE = 0x00006c0c,
	HOST_IDTR_BASE = 0x00006c0e,
	HOST_IA32_SYSENTER_ESP = 0x00006c10,
	HOST_IA32_SYSENTER_EIP = 0x00006c12,
	HOST_RSP = 0x00006c14,
	HOST_RIP = 0x00006c16,
};

typedef struct _INVEPT_DESCRIPTOR
{
	UINT64 EptPointer;
	UINT64 Reserved; // Must be zero.
} INVEPT_DESCRIPTOR, * PINVEPT_DESCRIPTOR;

typedef struct _INVEPT_DESC
{
	EPTP EptPointer;
	UINT64  Reserveds;
}INVEPT_DESC, * PINVEPT_DESC;

typedef enum _InvvpidType
{
	InvvpidIndividualAddress = 0x00000000,
	InvvpidSingleContext = 0x00000001,
	InvvpidAllContext = 0x00000002,
	InvvpidSingleContextRetainingGlobals = 0x00000003
} InvvpidType;

typedef struct _INVVPID_DESCRIPTOR {
	UINT64 Vpid : 16;
	UINT64 Reserved : 48;
	UINT64 LinearAddress;
} INVVPID_DESCRIPTOR, * PINVVPID_DESCRIPTOR;

typedef struct _GUEST_REGS
{
	ULONG64 rax;                  // 0x00         
	ULONG64 rcx;
	ULONG64 rdx;                  // 0x10
	ULONG64 rbx;
	ULONG64 rsp;                  // 0x20         // rsp is not stored here
	ULONG64 rbp;
	ULONG64 rsi;                  // 0x30
	ULONG64 rdi;
	ULONG64 r8;                   // 0x40
	ULONG64 r9;
	ULONG64 r10;                  // 0x50
	ULONG64 r11;
	ULONG64 r12;                  // 0x60
	ULONG64 r13;
	ULONG64 r14;                  // 0x70
	ULONG64 r15;
} GUEST_REGS, * PGUEST_REGS;

typedef union SEGMENT_ATTRIBUTES
{
	USHORT UCHARs;
	struct
	{
		USHORT TYPE : 4; /* 0;  Bit 40-43 */
		USHORT S : 1;    /* 4;  Bit 44 */
		USHORT DPL : 2;  /* 5;  Bit 45-46 */
		USHORT P : 1;    /* 7;  Bit 47 */

		USHORT AVL : 1; /* 8;  Bit 52 */
		USHORT L : 1;   /* 9;  Bit 53 */
		USHORT DB : 1;  /* 10; Bit 54 */
		USHORT G : 1;   /* 11; Bit 55 */
		USHORT GAP : 4;

	} Fields;
} SEGMENT_ATTRIBUTES;

typedef struct SEGMENT_SELECTOR
{
	USHORT             SEL;
	SEGMENT_ATTRIBUTES ATTRIBUTES;
	ULONG32            LIMIT;
	ULONG64            BASE;
} SEGMENT_SELECTOR, * PSEGMENT_SELECTOR;


typedef struct _SEGMENT_DESCRIPTOR {
	USHORT LIMIT0;
	USHORT BASE0;
	UCHAR  BASE1;
	UCHAR  ATTR0;
	UCHAR  LIMIT1ATTR1;
	UCHAR  BASE2;
} SEGMENT_DESCRIPTOR, * PSEGMENT_DESCRIPTOR;

enum SEGREGS
{
	ES = 0,
	CS,
	SS,
	DS,
	FS,
	GS,
	LDTR,
	TR
};

typedef union _MSR
{
	struct
	{
		ULONG Low;
		ULONG High;
	};

	ULONG64 Content;
} MSR, * PMSR;

typedef union _IA32_MTRR_FIXED_RANGE_TYPE
{
	UINT64 All;
	struct
	{
		UINT8 Types[8];
	} s;
} IA32_MTRR_FIXED_RANGE_TYPE;

constexpr SIZE_T MAX_VARIABLE_RANGE_MTRRS = 255;
constexpr SIZE_T FIXED_RANGE_MTRRS_SIZE = ((1 + 2 + 8) * RTL_NUMBER_OF_FIELD(IA32_MTRR_FIXED_RANGE_TYPE, s.Types));
constexpr SIZE_T MTRR_ENTRIES_SIZE = MAX_VARIABLE_RANGE_MTRRS + FIXED_RANGE_MTRRS_SIZE;

typedef union _MOV_CR_QUALIFICATION
{
	ULONG_PTR All;
	struct
	{
		ULONG ControlRegister : 4;
		ULONG AccessType : 2;
		ULONG LMSWOperandType : 1;
		ULONG Reserved1 : 1;
		ULONG Register : 4;
		ULONG Reserved2 : 4;
		ULONG LMSWSourceData : 16;
		ULONG Reserved3;
	} Fields;
} MOV_CR_QUALIFICATION, * PMOV_CR_QUALIFICATION;

typedef struct _EPT_HOOKED_PAGE_DETAIL {
	LIST_ENTRY Entry;
	UINT64 VirtualAddress;
	UINT64 PhysicalAddress;
	UINT64 PhysicalBaseAddress;
	PEPT_PML1_ENTRY EntryAddress;
	EPT_PML1_ENTRY OriginalEntry;
	EPT_PML1_ENTRY ChangedEntry;
	PCHAR InlineHook;
	bool IsExecutionHook;
} EPT_HOOKED_PAGE_DETAIL, * PEPT_HOOKED_PAGE_DETAIL;

typedef struct {
	UINT8 Permissions;
	UINT64 Address;
} HookedPage;

#pragma warning(pop)
```

`NovaHypervisor/InlineAsm.h`:

```h
#pragma once
#include "pch.h"

extern "C" {
	void inline AsmRestoreToVmxOffState();
	NTSTATUS inline AsmVmxVmcall(unsigned long long VmcallNumber, unsigned long long OptionalParam1, unsigned long long OptionalParam2, unsigned long long OptionalParam3);
	UINT64 inline  AsmHypervVmcall(unsigned long long HypercallInputValue, unsigned long long InputParamGPA, unsigned long long OutputParamGPA);
	void AsmVmxSaveState();
	void AsmVmxRestoreState();

	void AsmVmexitHandler();
	void inline  AsmSaveVmxOffState();

	unsigned char inline AsmInvept(unsigned long Type, void* Descriptors);
	unsigned char inline AsmInvvpid(unsigned long Type, void* Descriptors);

	unsigned short AsmGetCs();
	unsigned short AsmGetDs();
	unsigned short AsmGetEs();
	unsigned short AsmGetSs();
	unsigned short AsmGetFs();
	unsigned short AsmGetGs();
	unsigned short AsmGetLdtr();
	unsigned short AsmGetTr();
	unsigned short AsmGetRflags();

	unsigned long long inline AsmGetGdtBase();
	unsigned short AsmGetGdtLimit();

	unsigned long long inline AsmGetIdtBase();
	unsigned short AsmGetIdtLimit();
	extern void AsmReloadGdtr(void* GdtBase, unsigned long GdtLimit);
	extern void AsmReloadIdtr(void* GdtBase, unsigned long GdtLimit);
}

```

`NovaHypervisor/MemoryHelper.hpp`:

```hpp
#pragma once

#include "pch.h"
#include "WindowsDefinitions.h"

#define DRIVER_TAG 'avoN'
#define VALID_USERMODE_MEMORY(MemAddress)(MemAddress > 0 && MemAddress < 0x7FFFFFFFFFFFFFFF)

/*
* Description:
* GetPhysicalAddress is responsible for getting the physical address of a virtual address.
*
* Parameters:
* @virtualAddress  [_In_ UINT64] -- Virtual address to get the physical address of.
*
* Returns:
* @physicalAddress [UINT64]		 -- Physical address.
*/
inline UINT64 GetPhysicalAddress(_In_ UINT64 virtualAddress) {
	PHYSICAL_ADDRESS physicalAddress = MmGetPhysicalAddress(reinterpret_cast<PVOID>(virtualAddress));
	return static_cast<UINT64>(physicalAddress.QuadPart);
}

/*
* Description:
* GetVirtualAddress is responsible for getting the virtual address of a physical address.
*
* Parameters:
* @physicalAddress  [_In_ UINT64] -- Physical address to get the virtual address of.
*
* Returns:
* @virtualAddress	[UINT64]	  -- Virtual address.
*/
inline UINT64 GetVirtualAddress(_In_ UINT64 physicalAddress) {
	PHYSICAL_ADDRESS physicalAddr = { 0 };
	physicalAddr.QuadPart = physicalAddress;

	return reinterpret_cast<UINT64>(MmGetVirtualForPhysical(physicalAddr));
}

/*
* Description:
* FreeVirtualMemory is responsible for freeing virtual memory and null it.
*
* Parameters:
* @address [PVOID] -- Address to free.
*
* Returns:
* There is no return value.
*/
inline void FreeVirtualMemory(_In_ PVOID address) {
	if (!address)
		return;
	ExFreePoolWithTag(address, DRIVER_TAG);
	address = NULL;
}

/*
* Description:
* AllocateVirtualMemory is responsible for allocating virtual memory with the right function depends on the windows version.
*
* Parameters:
* @size				    [size_t]	  -- Size to allocate.
* @paged				[bool]		  -- Paged or non-paged.
* @forceDeprecatedAlloc [bool]		  -- Force allocation with ExAllocatePoolWithTag.
*
* Returns:
* @ptr					[PointerType] -- Allocated pointer on success else NULL.
*/
template <typename PointerType>
inline PointerType AllocateVirtualMemory(size_t size, bool paged = true, bool forceDeprecatedAlloc = false) {
	PVOID allocatedMem = NULL;

	if (AllocatePool2 && WindowsBuildNumber >= WIN_2004 && !forceDeprecatedAlloc) {
		allocatedMem = paged ? ((tExAllocatePool2)AllocatePool2)(POOL_FLAG_PAGED, size, DRIVER_TAG) :
			((tExAllocatePool2)AllocatePool2)(POOL_FLAG_NON_PAGED, size, DRIVER_TAG);
	}
	else {
#pragma warning( push )
#pragma warning( disable : 4996)
		allocatedMem = paged ? ExAllocatePoolWithTag(PagedPool, size, DRIVER_TAG) :
			ExAllocatePoolWithTag(NonPagedPool, size, DRIVER_TAG);
#pragma warning( pop )
	}

	if (allocatedMem)
		RtlSecureZeroMemory(allocatedMem, size);
	return reinterpret_cast<PointerType>(allocatedMem);
}

/*
* Description:
* ProbeAddress is responsible for probing an address and returning specific status code on failure.
*
* Parameters:
* @address	   [PVOID]	  -- Address to probe.
* @len		   [SIZE_T]   -- Structure size.
* @alignment   [ULONG]    -- Address' required alignment.
* @failureCode [NTSTATUS] -- Failure code.
*
* Returns:
* @status	   [NTSTATUS] -- NTSUCCESS if succeeded else failure code.
*/
inline NTSTATUS ProbeAddress(PVOID address, SIZE_T len, ULONG alignment, NTSTATUS failureCode) {
	NTSTATUS status = STATUS_SUCCESS;

	if (!VALID_USERMODE_MEMORY((ULONGLONG)address))
		return STATUS_ABANDONED;

	__try {
		ProbeForRead(address, len, alignment);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		status = failureCode;
	}

	return status;
}
```

`NovaHypervisor/NovaHypervisor.cpp`:

```cpp
#include "pch.h"
#include "NovaHypervisor.h"

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {
	UNREFERENCED_PARAMETER(RegistryPath);
	UNICODE_STRING deviceName = { 0 };
	UNICODE_STRING symLinkName = { 0 };
	PDEVICE_OBJECT deviceObject = nullptr;
	NTSTATUS status = STATUS_SUCCESS;
	KernelBaseInfo = { 0 };

	// Getting the OS version.
	RTL_OSVERSIONINFOW osVersion = { sizeof(osVersion) };
	NTSTATUS result = RtlGetVersion(&osVersion);

	if (!NT_SUCCESS(result))
		return STATUS_ABANDONED;

	WPP_INIT_TRACING(DriverObject, RegistryPath);
	WindowsBuildNumber = osVersion.dwBuildNumber;

	// Loading ExAllocatePool2 if available.
	UNICODE_STRING routineName = RTL_CONSTANT_STRING(L"ExAllocatePool2");
	AllocatePool2 = MmGetSystemRoutineAddress(&routineName);
	status = VmxHelper::FindKernelBaseAddress();

	if (!NT_SUCCESS(status)) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to find kernel base address");
		WPP_CLEANUP(DriverObject);
		return status;
	}

	__try {
		poolManager = new PoolManager();
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		status = GetExceptionCode();
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Exception occurred while initializing the pool manager: (0x%08X)", status);
		WPP_CLEANUP(DriverObject);
		return status;
	}

	// Initializing the driver.
	RtlInitUnicodeString(&deviceName, DEVICE_NAME);
	RtlInitUnicodeString(&symLinkName, SYMBOLIC_LINK);

	status = IoCreateDevice(DriverObject, 0, &deviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);

	if (!NT_SUCCESS(status)) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to create device object (0x%08X)", status);
		WPP_CLEANUP(DriverObject);
		return status;
	}
	status = IoCreateSymbolicLink(&symLinkName, &deviceName);

	if (!NT_SUCCESS(status)) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to create symbolic link (0x%08X)", status);
		IoDeleteDevice(deviceObject);
		WPP_CLEANUP(DriverObject);
		return status;
	}

	DriverObject->DriverUnload = NovaUnload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = NovaCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = NovaCreateClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = NovaDeviceControl;

	status = VmxInitialize() ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

	if (!NT_SUCCESS(status)) {
		TerminateVmx();

		if (poolManager) {
			delete poolManager;
			poolManager = nullptr;
		}
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to initialize the hypervisor (0x%08X)", status);
		IoDeleteSymbolicLink(&symLinkName);
		IoDeleteDevice(deviceObject);
		WPP_CLEANUP(DriverObject);
		return status;
	}

	NovaHypervisorLog(TRACE_FLAG_INFO, "Driver loaded successfully");
	return status;
}

void NovaUnload(_In_ PDRIVER_OBJECT DriverObject) {
	UNICODE_STRING symLinkName = { 0 };
	TerminateVmx();

	if (poolManager) {
		delete poolManager;
		poolManager = nullptr;
	}
	RtlInitUnicodeString(&symLinkName, SYMBOLIC_LINK);
	IoDeleteSymbolicLink(&symLinkName);
	IoDeleteDevice(DriverObject->DeviceObject);

	NovaHypervisorLog(TRACE_FLAG_INFO, "Driver unloaded");
	WPP_CLEANUP(DriverObject);
}

/*
* Description:
* NovaCreateClose is responsible for creating a success response for given IRP.
*
* Parameters:
* @DeviceObject [PDEVICE_OBJECT] -- Not used.
* @Irp			[PIRP]			 -- The IRP that contains the user data such as SystemBuffer, Irp stack, etc.
*
* Returns:
* @status		[NTSTATUS]		 -- Always will be STATUS_SUCCESS.
*/
NTSTATUS NovaCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
```

`NovaHypervisor/NovaHypervisor.h`:

```h
#pragma once
#include "pch.h"
#include "Vmx.h"
#include "DeviceControl.h"
#include "Ept.h"
#include "VmxHelper.h"
#include "WppDefinitions.h"
#include "NovaHypervisor.tmh"

constexpr wchar_t DEVICE_NAME[] = L"\\Device\\NovaHypervisor";
constexpr wchar_t SYMBOLIC_LINK[] = L"\\??\\NovaHypervisor";

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);
DRIVER_UNLOAD NovaUnload;
DRIVER_DISPATCH NovaCreateClose;

```

`NovaHypervisor/NovaHypervisor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{38FD1E0B-A6E5-43C3-B1B0-82E1E85C3102}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>NovaHypervisor</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <WppEnabled>true</WppEnabled>
      <WppTraceFunction>NovaHypervisorLog(LEVEL,MSG,...)</WppTraceFunction>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <WppEnabled>true</WppEnabled>
      <WppTraceFunction>NovaHypervisorLog(LEVEL,MSG,...)</WppTraceFunction>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AsmDescriptorTable.asm" />
    <MASM Include="AsmEpt.asm" />
    <MASM Include="AsmSegmentRegs.asm">
      <FileType>Document</FileType>
    </MASM>
    <MASM Include="AsmVmexitHandler.asm">
      <FileType>Document</FileType>
    </MASM>
    <MASM Include="AsmVmxContextState.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DeviceControl.cpp" />
    <ClCompile Include="EventInjection.cpp" />
    <ClCompile Include="NovaHypervisor.cpp" />
    <ClCompile Include="Ept.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="PoolManager.cpp" />
    <ClCompile Include="RegistersHandler.cpp" />
    <ClCompile Include="Spinlock.cpp" />
    <ClCompile Include="VmcallHandler.cpp" />
    <ClCompile Include="VmexitHandler.cpp" />
    <ClCompile Include="Vmx.cpp" />
    <ClCompile Include="VmxHelper.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AutoLock.hpp" />
    <ClInclude Include="DeviceControl.h" />
    <ClInclude Include="EventInjection.h" />
    <ClInclude Include="Ept.h" />
    <ClInclude Include="GlobalVariables.h" />
    <ClInclude Include="HypervisorDefinitions.h" />
    <ClInclude Include="InlineAsm.h" />
    <ClInclude Include="MemoryHelper.hpp" />
    <ClInclude Include="NovaHypervisor.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="PoolManager.h" />
    <ClInclude Include="RegistersHandler.h" />
    <ClInclude Include="RequestList.hpp" />
    <ClInclude Include="VmcallHandler.h" />
    <ClInclude Include="VmexitHandler.h" />
    <ClInclude Include="VmState.h" />
    <ClInclude Include="Vmx.h" />
    <ClInclude Include="VmxHelper.h" />
    <ClInclude Include="WindowsDefinitions.h" />
    <ClInclude Include="WppDefinitions.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Spinlock.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`NovaHypervisor/NovaHypervisor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Assembly">
      <UniqueIdentifier>{da163b29-f0dd-48dc-a755-55974b9e8f45}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NovaHypervisor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Ept.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="VmcallHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Vmx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="VmexitHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Spinlock.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PoolManager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EventInjection.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DeviceControl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RegistersHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="VmxHelper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Ept.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GlobalVariables.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="InlineAsm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VmcallHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Vmx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NovaHypervisor.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HypervisorDefinitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WindowsDefinitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemoryHelper.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VmxHelper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VmexitHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Autolock.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PoolManager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RequestList.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EventInjection.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DeviceControl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WppDefinitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RegistersHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AsmSegmentRegs.asm">
      <Filter>Assembly</Filter>
    </MASM>
    <MASM Include="AsmVmexitHandler.asm">
      <Filter>Assembly</Filter>
    </MASM>
    <MASM Include="AsmVmxContextState.asm">
      <Filter>Assembly</Filter>
    </MASM>
    <MASM Include="AsmEpt.asm">
      <Filter>Assembly</Filter>
    </MASM>
    <MASM Include="AsmDescriptorTable.asm">
      <Filter>Assembly</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <None Include="Spinlock.h">
      <Filter>Header Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`NovaHypervisor/PoolManager.cpp`:

```cpp
#include "pch.h"
#include "PoolManager.h"

_IRQL_requires_max_(APC_LEVEL)
PoolManager::PoolManager() {
	OBJECT_ATTRIBUTES objectAttributes{};
	running = false;
	this->allocationThread = NULL;
	this->freeThread = NULL;
	runningLock = Spinlock();
	pagingAllocations.Lock = Spinlock();
	eptHookAllocations.Lock = Spinlock();
	allocationRequests = RequestList<ALLOCATION_TYPE>();
	freeRequests = RequestList<POOL_ALLOCATION>();

	InitializeObjectAttributes(&objectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
	InitializeListHead(&pagingAllocations.Head);
	InitializeListHead(&eptHookAllocations.Head);
	NovaHypervisorLog(TRACE_FLAG_DEBUG, "Initialized allocation lists.");

	for (USHORT i = 0; i < MAX_INITIAL_ALLOCATIONS; i++) {
		AllocateInternal(SPLIT_2MB_PAGING_TO_4KB_PAGE, true);
		AllocateInternal(EPT_HOOK_PAGE, true);
	}
	NovaHypervisorLog(TRACE_FLAG_DEBUG, "Allocated initial blocks.");

	NTSTATUS status = PsCreateSystemThread(&this->allocationThread, GENERIC_ALL, &objectAttributes, NULL, NULL, 
		(PKSTART_ROUTINE)&ProcessAllocationThread, this);

	if (!NT_SUCCESS(status))
		ExRaiseStatus(status);
	NovaHypervisorLog(TRACE_FLAG_DEBUG, "Started allocation thread.");

	running = true;
	status = PsCreateSystemThread(&this->freeThread, GENERIC_ALL, &objectAttributes, NULL, NULL,
		(PKSTART_ROUTINE)&ProcessFreeThread, this);

	if (!NT_SUCCESS(status))
		ExRaiseStatus(status);
	NovaHypervisorLog(TRACE_FLAG_DEBUG, "Started free thread.");
}

_IRQL_requires_max_(APC_LEVEL)
PoolManager::~PoolManager() {
	StopThreads();
	
	auto FreeAllocations = [](_Inout_ PLIST_ENTRY head, _In_ Spinlock& lock) -> void {
		PPOOL_ALLOCATION allocation = nullptr;
		AutoLock<Spinlock> listLock(lock);
		PLIST_ENTRY entry = head->Flink;

		while (entry != head) {
			PLIST_ENTRY nextEntry = entry->Flink;
			allocation = CONTAINING_RECORD(entry, POOL_ALLOCATION, Entry);
			RemoveEntryList(entry);

			// Since allocation->Address is already freed at TerminateVmx we don't need to free it again.
			FreeVirtualMemory(allocation);
			entry = nextEntry;
		}
	};

	FreeAllocations(&pagingAllocations.Head, pagingAllocations.Lock);
	FreeAllocations(&eptHookAllocations.Head, eptHookAllocations.Lock);
}

_IRQL_requires_max_(APC_LEVEL)
bool PoolManager::AllocateInternal(_In_ ALLOCATION_TYPE type, _In_ bool isInit) {
	SIZE_T allocationSize = 0;
	PPOOL_ALLOCATION allocation = nullptr;
	PLIST_ENTRY head = nullptr;

	switch (type) {
		case SPLIT_2MB_PAGING_TO_4KB_PAGE:
			head = &pagingAllocations.Head;
			allocationSize = sizeof(VMM_EPT_DYNAMIC_SPLIT);
			break;
		case EPT_HOOK_PAGE:
			head = &eptHookAllocations.Head;
			allocationSize = sizeof(EPT_HOOKED_PAGE_DETAIL);
			break;
		default:
			return false;
	}
	Spinlock& lock = (type == SPLIT_2MB_PAGING_TO_4KB_PAGE) ?
		pagingAllocations.Lock : eptHookAllocations.Lock;
	AutoLock<Spinlock> autoLock(lock);
	allocation = AllocateVirtualMemory<PPOOL_ALLOCATION>(sizeof(POOL_ALLOCATION), false);

	if (!allocation)
		return false;

	// For some reason, when allocating with ExAllocatePool2 it doesn't work so need to use "legacy" allocation.
	allocation->Address = AllocateVirtualMemory<PVOID>(allocationSize, false, true);

	if (!allocation->Address) {
		FreeVirtualMemory(allocation);
		return false;
	}
	allocation->Type = type;
	allocation->IsUsed = !isInit;

	InitializeListHead(&allocation->Entry);
	InsertTailList(head, &allocation->Entry);
	return true;
}

_IRQL_requires_max_(APC_LEVEL)
void PoolManager::FreeInternal(_In_ PVOID address, _In_ ALLOCATION_TYPE type) {
	PPOOL_ALLOCATION allocation = nullptr;
	PLIST_ENTRY head = nullptr;

	switch (type) {
	case SPLIT_2MB_PAGING_TO_4KB_PAGE:
		head = &pagingAllocations.Head;
		break;
	case EPT_HOOK_PAGE:
		head = &eptHookAllocations.Head;
		break;
	default:
		return;
	}
	Spinlock& lock = (type == SPLIT_2MB_PAGING_TO_4KB_PAGE) ?
		pagingAllocations.Lock : eptHookAllocations.Lock;
	AutoLock<Spinlock> autoLock(lock);

	for (PLIST_ENTRY entry = head->Flink; entry != head; entry = entry->Flink) {
		allocation = CONTAINING_RECORD(entry, POOL_ALLOCATION, Entry);

		if (allocation->Address == address) {
			FreeVirtualMemory(allocation->Address);
			allocation->IsUsed = false;
			break;
		}
	}
}

/*
* Description:
* FindFreeSlot is responsible for asking to free memory allocation by pushing it to the free requests queue.
*
* Parameters:
* @address [_In_ PVOID]			  -- The address to free.
* @type	   [_In_ ALLOCATION_TYPE] -- The type of the allocation.
*
* Returns:
* There is no return value.
*/
PVOID PoolManager::FindFreeSlot(_In_ ALLOCATION_TYPE type) {
	PPOOL_ALLOCATION allocation = nullptr;
	PLIST_ENTRY head = nullptr;
	Spinlock lock;

	switch (type) {
	case SPLIT_2MB_PAGING_TO_4KB_PAGE:
		head = &pagingAllocations.Head;
		lock = pagingAllocations.Lock;
		break;
	case EPT_HOOK_PAGE:
		head = &eptHookAllocations.Head;
		lock = eptHookAllocations.Lock;
		break;
	default:
		return nullptr;
	}
	AutoLock<Spinlock> autoLock(lock);

	for (PLIST_ENTRY entry = head->Flink; entry != head; entry = entry->Flink) {
		allocation = CONTAINING_RECORD(entry, POOL_ALLOCATION, Entry);

		if (!allocation->IsUsed) {
			allocation->IsUsed = true;
			return allocation->Address;
		}
	}
	return allocation;
}

/*
* Description:
* Allocate is responsible for asking for an allocation by pushing it to the free requests queue.
*
* Parameters:
* @type		  [_In_ ALLOCATION_TYPE] -- The type of the allocation.
*
* Returns:
* @allocation [PVOID]				 -- The allocated memory if allocated else nullptr.
*/
PVOID PoolManager::Allocate(_In_ ALLOCATION_TYPE type) {
	bool queued = false;
	UINT64 waitCount = 0;
	UINT32 wait = 1;

	if (!IsValidAllocationType(type))
		return nullptr;
	PVOID allocation = FindFreeSlot(type);

	if (allocation)
		return allocation;

	// Queuing the allocation request.
	queued = allocationRequests.Insert(type);

	if (!queued) {
		do {
			for (UINT32 i = 0; i < wait; i++)
				_mm_pause();
			queued = allocationRequests.Insert(type);

			wait = wait * 2 > MAX_WAIT ? MAX_WAIT : wait * 2;

			if (wait == MAX_WAIT)
				waitCount++;
		} while (!queued && waitCount < MAX_WAIT_ITERATIONS);

		if (waitCount == MAX_WAIT_ITERATIONS)
			return nullptr;
		waitCount = 0;
		wait = 1;
	}

	// Waiting it to be processed.
	do {
		for (UINT32 i = 0; i < wait; i++)
			_mm_pause();
		allocation = FindFreeSlot(type);

		wait = wait * 2 > MAX_WAIT ? MAX_WAIT : wait * 2;

		if (wait == MAX_WAIT)
			waitCount++;
	} while (!allocation && waitCount < MAX_WAIT_ITERATIONS);
	return allocation;
}

/*
* Description:
* Free is responsible for asking to free memory allocation by pushing it to the free requests queue.
*
* Parameters:
* @address [_In_ PVOID]			  -- The address to free.
* @type	   [_In_ ALLOCATION_TYPE] -- The type of the allocation.
*
* Returns:
* There is no return value.
*/
void PoolManager::Free(_In_ PVOID address, _In_ ALLOCATION_TYPE type) {
	bool queued = false;
	UINT64 waitCount = 0;
	UINT32 wait = 1;
	POOL_ALLOCATION allocation = { 0 };

	if (!address || !IsValidAllocationType(type))
		return;

	allocation.Address = address;
	allocation.Type = type;

	queued = freeRequests.Insert(allocation);

	if (!queued) {
		do {
			for (UINT32 i = 0; i < wait; i++)
				_mm_pause();
			queued = freeRequests.Insert(allocation);

			wait = wait * 2 > MAX_WAIT ? MAX_WAIT : wait * 2;

			if (wait == MAX_WAIT)
				waitCount++;
		} while (!queued && waitCount < MAX_WAIT_ITERATIONS);
	}
}

/*
* Description:
* ProcessAllocation is responsible for periodically allocate memory.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
_IRQL_requires_(PASSIVE_LEVEL)
void PoolManager::ProcessAllocation() {
	ALLOCATION_TYPE type;
	bool isRunning = true;

	auto UpdateRunningState = [&]() -> void {
		runningLock.Lock();
		isRunning = running;
		runningLock.Unlock();
	};
	
	while (isRunning) {
		if (allocationRequests.GetListSize() == 0) {
			Sleep(DEFAULT_SLEEP_MS);
			UpdateRunningState();
			continue;
		}
		type = allocationRequests.Pop();
		AllocateInternal(type);
		UpdateRunningState();
	}
}

/*
* Description:
* ProcessFree is responsible for periodically freeing memory.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
_IRQL_requires_(PASSIVE_LEVEL)
void PoolManager::ProcessFree() {
	bool isRunning = true;
	POOL_ALLOCATION allocation = { 0 };

	auto UpdateRunningState = [&]() -> void {
		runningLock.Lock();
		isRunning = running;
		runningLock.Unlock();
	};

	while (isRunning) {
		if (freeRequests.GetListSize() == 0) {
			Sleep(DEFAULT_SLEEP_MS);
			UpdateRunningState();
			continue;
		}
		allocation = freeRequests.Pop();

		if (allocation.Address)
			FreeInternal(allocation.Address, allocation.Type);
		UpdateRunningState();
	}

	// Free all the remaining allocations.
	if (freeRequests.GetListSize() > 0) {
		while (freeRequests.GetListSize() > 0) {
			allocation = freeRequests.Pop();

			if (allocation.Address)
				FreeInternal(allocation.Address, allocation.Type);
		}
	}
}

/*
* Description:
* StopThreads is responsible for stopping the allocation and free threads.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void PoolManager::StopThreads() {
	auto StopThread = [](HANDLE thread) -> void {
		NTSTATUS status = STATUS_SUCCESS;

		if (thread) {
			do {
				status = ZwWaitForSingleObject(thread, FALSE, NULL);
			} while (status == STATUS_TIMEOUT);
			ZwClose(thread);
		}
	};
	runningLock.Lock();

	if (running) {
		running = false;

		// Need to explicitly unlock here to prevent deadlock.
		runningLock.Unlock();
		StopThread(allocationThread);
		allocationThread = NULL;
		StopThread(freeThread);
		freeThread = NULL;
	}
}

/*
* Description:
* ProcessAllocationThread is responsible for periodically allocate memory.
*
* Parameters:
* @StartContext [_In_ PVOID] -- The context that holds the lock, if suppose to continue to run and interval.
*
* Returns:
* There is no return value.
*/
_IRQL_requires_(PASSIVE_LEVEL)
void ProcessAllocationThread(_In_ PVOID StartContext) {
	PoolManager* poolManager = reinterpret_cast<PoolManager*>(StartContext);
	poolManager->ProcessAllocation();
}

/*
* Description:
* ProcessFreeThread is responsible for periodically free memory.
*
* Parameters:
* @StartContext [_In_ PVOID] -- The context that holds the lock, if suppose to continue to run and interval.
*
* Returns:
* There is no return value.
*/
_IRQL_requires_(PASSIVE_LEVEL)
void ProcessFreeThread(_In_ PVOID StartContext) {
	PoolManager* poolManager = reinterpret_cast<PoolManager*>(StartContext);
	poolManager->ProcessFree();
}

```

`NovaHypervisor/PoolManager.h`:

```h
#pragma once
#include "pch.h"
#include "AutoLock.hpp"
#include "Spinlock.h"
#include "MemoryHelper.hpp"
#include "HypervisorDefinitions.h"
#include "RequestList.hpp"
#include "WppDefinitions.h"
#include "PoolManager.tmh"

constexpr SIZE_T MAX_INITIAL_ALLOCATIONS = 10;
constexpr SIZE_T MAX_WAIT_ITERATIONS = 10;
constexpr UINT64 DEFAULT_SLEEP_MS = 100;

enum ALLOCATION_TYPE {
	SPLIT_2MB_PAGING_TO_4KB_PAGE,
	EPT_HOOK_PAGE
};

typedef struct _FREE_REQUEST {
	PVOID Address;
	ALLOCATION_TYPE Type;
} FREE_REQUEST, * PFREE_REQUEST;

typedef struct _ALLOCATION_REQUEST {
	ALLOCATION_TYPE type;
} ALLOCATION_REQUEST, * PALLOCATION_REQUEST;

typedef struct _POOL_ALLOCATION {
	PVOID Address;
	bool IsUsed;
	ALLOCATION_TYPE Type;
	LIST_ENTRY Entry;
} POOL_ALLOCATION, * PPOOL_ALLOCATION;

typedef struct _ALLOCATION_LIST {
	LIST_ENTRY Head;
	Spinlock Lock;
} ALLOCATION_LIST, * PALLOCATION_LIST;

_IRQL_requires_(PASSIVE_LEVEL)
void ProcessAllocationThread(_In_ PVOID StartContext);
_IRQL_requires_(PASSIVE_LEVEL)
void ProcessFreeThread(_In_ PVOID StartContext);

class PoolManager {
private:
	bool running;
	Spinlock runningLock;
	HANDLE allocationThread;
	HANDLE freeThread;
	ALLOCATION_LIST pagingAllocations;
	ALLOCATION_LIST eptHookAllocations;
	RequestList<ALLOCATION_TYPE> allocationRequests;
	RequestList<POOL_ALLOCATION> freeRequests;

	_IRQL_requires_max_(APC_LEVEL)
	bool AllocateInternal(_In_ ALLOCATION_TYPE type, _In_ bool isInit = false);
	_IRQL_requires_max_(APC_LEVEL)
	void FreeInternal(_In_ PVOID address, _In_ ALLOCATION_TYPE type);
	PVOID FindFreeSlot(_In_ ALLOCATION_TYPE type);
	void StopThreads();

	bool IsValidAllocationType(_In_ ALLOCATION_TYPE type) const {
		return type == SPLIT_2MB_PAGING_TO_4KB_PAGE || type == EPT_HOOK_PAGE;
	}

	void Sleep(_In_ UINT64 milliseconds) const {
		LARGE_INTEGER interval = { 0 };
		interval.QuadPart = -10000 * milliseconds;
		KeDelayExecutionThread(KernelMode, FALSE, &interval);
	}
public:
	void* operator new(size_t size) {
		return AllocateVirtualMemory<PVOID>(size, false);
	}

	void operator delete(void* p) {
		FreeVirtualMemory(p);
	}

	_IRQL_requires_max_(APC_LEVEL)
	PoolManager();
	_IRQL_requires_max_(APC_LEVEL)
	~PoolManager();
	PVOID Allocate(_In_ ALLOCATION_TYPE type);
	void Free(_In_ PVOID address, _In_ ALLOCATION_TYPE type);
	_IRQL_requires_(PASSIVE_LEVEL)
	void ProcessAllocation();
	_IRQL_requires_(PASSIVE_LEVEL)
	void ProcessFree();
};

```

`NovaHypervisor/RegistersHandler.cpp`:

```cpp
#include "pch.h"
#include "RegistersHandler.h"

/*
* Description:
* IsValidMsr is responsible for checking if an MSR is valid.
*
* Parameters:
* @rcx [_In_ ULONG64] -- RCX.
*
* Returns:
* Returns true if the MSR is valid, otherwise false.
*/
bool RegistersHandler::IsValidMsr(_In_ ULONG64 rcx) {
	return (rcx <= 0x00001FFF || (rcx >= 0xC0000000 && rcx <= 0xC0001FFF)) ||
		(rcx >= RESERVED_MSR_RANGE_LOW && rcx <= RESERVED_MSR_RANGE_HIGH);
}

/*
* Description:
* HandleCRAccess is responsible for handling a control register access.
*
* Parameters:
* @guestRegisters [_In_ PGUEST_REGS] -- The guest registers.
*
* Returns:
* There is no return value
*/
void RegistersHandler::HandleCRAccess(_In_ PGUEST_REGS guestRegisters) {
	SIZE_T exitQualification = 0;
	__vmx_vmread(EXIT_QUALIFICATION, &exitQualification);

	PMOV_CR_QUALIFICATION data = (PMOV_CR_QUALIFICATION)&exitQualification;
	PULONG64 registerPointer = &guestRegisters->rax + data->Fields.Register;

	// Point it to guest RSP
	if (data->Fields.Register == 4) {
		SIZE_T rsp = 0;
		__vmx_vmread(GUEST_RSP, &rsp);
		*registerPointer = rsp;
	}

	if (data->Fields.AccessType > TYPE_MOV_FROM_CR) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Unsupported CR access type: %d", data->Fields.AccessType);
		return;
	}

	if (data->Fields.AccessType == TYPE_MOV_TO_CR) {
		switch (data->Fields.ControlRegister) {
		case 0: {
			__vmx_vmwrite(GUEST_CR0, *registerPointer);
			__vmx_vmwrite(CR0_READ_SHADOW, *registerPointer);
			break;
		}
		case 3: {
			__vmx_vmwrite(GUEST_CR3, (*registerPointer & ~(1ULL << 63)));
			VmxHelper::InvalidateVpid(1);
			break;
		}
		case 4: {
			__vmx_vmwrite(GUEST_CR4, *registerPointer);
			__vmx_vmwrite(CR4_READ_SHADOW, *registerPointer);
			break;
		}
		default: {
			NovaHypervisorLog(TRACE_FLAG_ERROR, "Unsupported write operation for control register: %d", data->Fields.ControlRegister);
			break;
		}
		}
	}
	else {
		switch (data->Fields.ControlRegister) {
		case 0: {
			__vmx_vmread(GUEST_CR0, registerPointer);
			break;
		}
		case 3: {
			__vmx_vmread(GUEST_CR3, registerPointer);
			break;
		}
		case 4: {
			__vmx_vmread(GUEST_CR4, registerPointer);
			break;
		}
		default: {
			NovaHypervisorLog(TRACE_FLAG_ERROR, "Unsupported read operation for control register: %d", data->Fields.ControlRegister);
			break;
		}
		}
	}
}

/*
* Description:
* HandleMSRRead is responsible for handling MSR reading.
*
* Parameters:
* @guestRegisters [_Inout_ PGUEST_REGS] -- The guest registers.
*
* Returns:
* There is no return value
*/
void RegistersHandler::HandleMSRRead(_Inout_ PGUEST_REGS guestRegisters) {
	MSR msr = { 0 };

	if (IsValidMsr(guestRegisters->rcx))
		msr.Content = __readmsr((ULONG)guestRegisters->rcx);

	guestRegisters->rax = (ULONG64)msr.Low;
	guestRegisters->rdx = (ULONG64)msr.High;
}

/*
* Description:
* HandleMSRWrite is responsible for handling MSR writing.
*
* Parameters:
* @guestRegisters [_In_ PGUEST_REGS] -- The guest registers.
*
* Returns:
* There is no return value
*/
void RegistersHandler::HandleMSRWrite(_In_ PGUEST_REGS guestRegisters) {
	if (IsValidMsr(guestRegisters->rcx)) {
		MSR msr = { 0 };
		msr.Low = (ULONG)guestRegisters->rax;
		msr.High = (ULONG)guestRegisters->rdx;
		__writemsr((ULONG)guestRegisters->rcx, msr.Content);
	}
}

/*
* Description:
* HandleCpuid is responsible for handling cpuid instruction.
*
* Parameters:
* @guestRegisters [_Inout_ PGUEST_REGS] -- The guest registers.
*
* Returns:
* There is no return value.
*/
void RegistersHandler::HandleCpuid(_Inout_ PGUEST_REGS guestRegisters) {
	int cpuInfo[4] = { 0 };

	__cpuidex(cpuInfo, (int)guestRegisters->rax, (int)guestRegisters->rcx);

	// If rax is 1, then need to set the hypervisor present bit. 
	// If it is cpuid_interface then need to return the interface identifier.
	if (guestRegisters->rax == CPUID_PROCESSOR_AND_PROCESSOR_FEATURE_IDENTIFIERS)
		cpuInfo[2] |= HYPERV_HYPERVISOR_PRESENT_BIT;
	else if (guestRegisters->rax == HYPERV_CPUID_INTERFACE)
		cpuInfo[0] = '0#vH'; // For hyperv support.
	else if (guestRegisters->rax == HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS) {
		cpuInfo[0] = HYPERV_CPUID_INTERFACE;
		cpuInfo[1] = HYPERVISOR_INTERFACE;
	}

	guestRegisters->rax = cpuInfo[0];
	guestRegisters->rbx = cpuInfo[1];
	guestRegisters->rcx = cpuInfo[2];
	guestRegisters->rdx = cpuInfo[3];
}
```

`NovaHypervisor/RegistersHandler.h`:

```h
#pragma once

#include "pch.h"
#include "HypervisorDefinitions.h"
#include "VmxHelper.h"
#include "WppDefinitions.h"
#include "RegistersHandler.tmh"

constexpr int HYPERVISOR_INTERFACE = 'AVON';

namespace RegistersHandler {
	bool IsValidMsr(_In_ ULONG64 rcx);
	void HandleCRAccess(_In_ PGUEST_REGS guestRegisters);
	void HandleMSRRead(_Inout_ PGUEST_REGS guestRegisters);
	void HandleMSRWrite(_In_ PGUEST_REGS guestRegisters);
	void HandleCpuid(_Inout_ PGUEST_REGS guestRegisters);
};
```

`NovaHypervisor/RequestList.hpp`:

```hpp
#pragma once

#include "pch.h"
#include "AutoLock.hpp"
#include "Spinlock.h"

constexpr SIZE_T MAX_ALLOCATION_REQUESTS = 100;

template <typename Request>
class RequestList {
private:
	typedef struct _RequestItem {
		Request Data;
		bool IsUsed;
	} RequestItem;
	Spinlock lock;
	RequestItem requests[MAX_ALLOCATION_REQUESTS];
	UINT64 itemsCount = 0;

public:
	RequestList() {
		memset(requests, 0, sizeof(requests));
		lock = Spinlock();
	}

	~RequestList() {
		memset(requests, 0, sizeof(requests));
	}

	bool Insert(Request item) {
		AutoLock<Spinlock> autoLock(lock);

		if (itemsCount == MAX_ALLOCATION_REQUESTS)
			return false;

		for (SIZE_T i = 0; i < MAX_ALLOCATION_REQUESTS; i++) {
			if (!requests[i].IsUsed) {
				requests[i].Data = item;
				requests[i].IsUsed = true;
				itemsCount++;
				return true;
			}
		}
		return false;
	}

	Request Pop() {
		AutoLock<Spinlock> autoLock(lock);

		if (itemsCount == 0)
			return Request();

		for (SIZE_T i = 0; i < MAX_ALLOCATION_REQUESTS; i++) {
			if (requests[i].IsUsed) {
				requests[i].IsUsed = false;
				itemsCount--;
				return requests[i].Data;
			}
		}
		return Request();
	}

	UINT64 GetListSize() {
		AutoLock<Spinlock> autoLock(lock);
		return itemsCount;
	}
};
```

`NovaHypervisor/Spinlock.cpp`:

```cpp
#include "pch.h"
#include "Spinlock.h"

Spinlock::Spinlock() {
	Unlock();
}

Spinlock::~Spinlock() {
	Unlock();
}

bool Spinlock::DoLock() {
	return !InterlockedExchange16(&lock, 1) && lock != 0;
}

void Spinlock::Lock() {
	UINT32 wait = 1;

	while (!DoLock()) {
		for (UINT32 i = 0; i < wait; i++)
			_mm_pause();
		wait = wait * 2 > MAX_WAIT ? MAX_WAIT : wait * 2;
	}
}

void Spinlock::Unlock() {
	lock = 0;
}
```

`NovaHypervisor/Spinlock.h`:

```h
#pragma once
#include "pch.h"

constexpr UINT32 MAX_WAIT = 65536;

class Spinlock {
public:
	Spinlock();
	~Spinlock();
	void Lock();
	void Unlock();
private:
	bool DoLock();
	volatile SHORT lock;
};
```

`NovaHypervisor/VmState.h`:

```h
#pragma once
#include "pch.h"
#include "HypervisorDefinitions.h"
#include "MemoryHelper.hpp"

// Forward declarations to avoid circular include dependencies
struct _EPT_HOOKED_PAGE_DETAIL;
typedef struct _EPT_HOOKED_PAGE_DETAIL EPT_HOOKED_PAGE_DETAIL, * PEPT_HOOKED_PAGE_DETAIL;
class Ept;

typedef struct _VMX_VMXOFF_STATE
{
	bool IsVmxoffExecuted;
	UINT64  GuestRip;
	UINT64  GuestRsp;
} VMX_VMXOFF_STATE, * PVMX_VMXOFF_STATE;

class VmState {
public:
	bool IsOnVmxRoot;
	bool IncrementRip;
	bool IsLaunched;
	UINT64 VmxonRegion;
	UINT64 VmxonRegionPhysical;
	UINT64 VmcsRegion;
	UINT64 VmcsRegionPhysical;
	UINT64 VmmStack;
	UINT64 MsrBitmap;
	UINT64 MsrBitmapPhysical;
	VMX_VMXOFF_STATE VmxoffState;
	PEPT_HOOKED_PAGE_DETAIL HookedPages;
	PEPT_HOOKED_PAGE_DETAIL HookedPage;
	Ept* EptInstance;

	VmState() = default;
	~VmState() = default;

	void* operator new(size_t size) {
		return AllocateVirtualMemory<PVOID>(size, false);
	}
	void operator delete(void* p) {
		FreeVirtualMemory(p);
	}
};


```

`NovaHypervisor/VmcallHandler.cpp`:

```cpp
#include "pch.h"
#include "VmcallHandler.h"

/*
* Description:
* VmcallHandler is responsible for handling the vmcalls.
*
* Parameters:
* @vmcallNumber	  [_In_ UINT64]		-- The vmcall number.
* @optionalParam1 [_In_opt_ UINT64] -- The first optional parameter.
* @optionalParam2 [_In_opt_ UINT64] -- The second optional parameter.
* @optionalParam3 [_In_opt_ UINT64] -- The third optional parameter.
*
* Returns:
* @status		  [NTSTATUS]		-- The function returns the status of the operation.
*/
NTSTATUS VmcallHandler(_In_ UINT64 vmcallNumber, _In_opt_ UINT64 optionalParam1, _In_opt_ UINT64 optionalParam2, _In_opt_ UINT64 optionalParam3) {
	NTSTATUS status = STATUS_SUCCESS;
	ULONG currentProcessorIndex = KeGetCurrentProcessorNumber();
	Ept* currentEptInstance = GuestState[currentProcessorIndex].EptInstance;

	switch (vmcallNumber) {
		case VMCALL_TEST: {
			NovaHypervisorLog(TRACE_FLAG_INFO, "VmcallTest called with @Param1 = 0x%llx , @Param2 = 0x%llx , @Param3 = 0x%llx", optionalParam1, optionalParam2, optionalParam3);
			break;
		}
		case VMCALL_VMXOFF: {
			VmxVmxoff();
			break;
		}
		case VMCALL_EXEC_HOOK_PAGE: {
			if (optionalParam1 == 0) {
				NovaHypervisorLog(TRACE_FLAG_ERROR, "Invalid parameters for VMCALL_EXEC_HOOK_PAGE");
				status = STATUS_INVALID_PARAMETER;
				break;
			}
			status = currentEptInstance->RootModePageHook(reinterpret_cast<PVOID>(optionalParam1), static_cast<UINT8>(optionalParam2)) ?
				STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
			break;
		}
		case VMCALL_INVEPT_SINGLE_CONTEXT: {
			VmxHelper::InvalidateEpt(optionalParam1);
			break;
		}
		case VMCALL_INVEPT_ALL_CONTEXT: {
			VmxHelper::InvalidateEpt();
			break;
		}
		case VMCALL_UNHOOK_SINGLE_PAGE: {
			if (optionalParam1 == 0) {
				NovaHypervisorLog(TRACE_FLAG_ERROR, "Invalid parameters for VMCALL_UNHOOK_SINGLE_PAGE");
				status = STATUS_INVALID_PARAMETER;
				break;
			}
			status = currentEptInstance->PageUnhookVmcall(optionalParam1) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
			break;
		}
		case VMCALL_UNHOOK_ALL_PAGES: {
			status = currentEptInstance->UnhookAllPagesVmcall() ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
			break;
		}
		default: {
			NovaHypervisorLog(TRACE_FLAG_WARNING, "Unsupported vmcall: 0x%llx\n", vmcallNumber);
			status = STATUS_INVALID_PARAMETER;
			break;
		}
	}
	return status;
}

```

`NovaHypervisor/VmcallHandler.h`:

```h
#pragma once
#include "pch.h"
#include "HypervisorDefinitions.h"
#include "GlobalVariables.h"
#include "Vmx.h"
#include "Ept.h"
#include "VmxHelper.h"
#include "WppDefinitions.h"
#include "VmcallHandler.tmh"

NTSTATUS VmcallHandler(_In_ UINT64 vmcallNumber, _In_opt_ UINT64 optionalParam1, _In_opt_ UINT64 optionalParam2, _In_opt_ UINT64 optionalParam3);
```

`NovaHypervisor/VmexitHandler.cpp`:

```cpp
#include "pch.h"
#include "VmexitHandler.h"

/*
* Description:
* VmexitHandler is responsible for handling the VMEXIT events.
*
* Parameters:
* @guestRegisters [_Inout_ PGUEST_REGISTERS] -- The guest registers.
*
* Returns:
* @bool										 -- The function returns true if vmxoff was executed, otherwise false.
*/
bool VmexitHandler(_Inout_ PGUEST_REGS guestRegisters) {
	SIZE_T exitReason = 0;
	SIZE_T exitQualification = 0;
	ULONG currentProcessorIndex = KeGetCurrentProcessorNumber();

	// Indicates we are in Vmx root mode in this logical core
	GuestState[currentProcessorIndex].IsOnVmxRoot = true;
	GuestState[currentProcessorIndex].IncrementRip = true;
	Ept* currentEptInstance = GuestState[currentProcessorIndex].EptInstance;

	__vmx_vmread(VM_EXIT_REASON, &exitReason);
	__vmx_vmread(EXIT_QUALIFICATION, &exitQualification);
	exitReason &= 0xffff;

	switch (exitReason) {
		case EXIT_REASON_EXCEPTION_NMI: {
			VMEXIT_INTERRUPT_INFO interruptExit = { 0 };
			__vmx_vmread(VM_EXIT_INTR_INFO, reinterpret_cast<SIZE_T*>(&interruptExit));

			if (interruptExit.InterruptionType == INTERRUPT_TYPE_SOFTWARE_EXCEPTION && interruptExit.Vector == EXCEPTION_VECTOR_BREAKPOINT) {
				GuestState[currentProcessorIndex].IncrementRip = false;
				EventHandler::InjectBreakpoint();
			}
			else if (interruptExit.InterruptionType == INTERRUPT_TYPE_HARDWARE_EXCEPTION && interruptExit.Vector == EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT) {
				GuestState[currentProcessorIndex].IncrementRip = false;
				EventHandler::InjectGeneralProtection();
			}
			else if (interruptExit.InterruptionType == INTERRUPT_TYPE_HARDWARE_EXCEPTION && interruptExit.Vector == EXCEPTION_VECTOR_UNDEFINED_OPCODE) {
				GuestState[currentProcessorIndex].IncrementRip = false;
				EventHandler::InjectUndefinedOpcode();
			}
			break;
		}
		case EXIT_REASON_TRIPLE_FAULT: {
			DbgBreakPoint();
			break;
		}

		case EXIT_REASON_VMCLEAR:
		case EXIT_REASON_VMPTRLD:
		case EXIT_REASON_VMPTRST:
		case EXIT_REASON_VMREAD:
		case EXIT_REASON_VMRESUME:
		case EXIT_REASON_VMWRITE:
		case EXIT_REASON_VMXOFF:
		case EXIT_REASON_VMXON:
		case EXIT_REASON_VMLAUNCH: {
			SIZE_T rflags = 0;
			__vmx_vmread(GUEST_RFLAGS, &rflags);
			__vmx_vmwrite(GUEST_RFLAGS, rflags | 0x1);
			break;
		}

		case EXIT_REASON_CR_ACCESS: {
			RegistersHandler::HandleCRAccess(guestRegisters);
			break;
		}
		case EXIT_REASON_MSR_READ:{
			RegistersHandler::HandleMSRRead(guestRegisters);
			break;
		}
		case EXIT_REASON_MSR_WRITE: {
			RegistersHandler::HandleMSRWrite(guestRegisters);
			break;
		}
		case EXIT_REASON_CPUID: {
			RegistersHandler::HandleCpuid(guestRegisters);
			break;
		}
		case EXIT_REASON_MONITOR_TRAP_FLAG: {
			if (GuestState[currentProcessorIndex].HookedPage) {
				currentEptInstance->HandleMonitorTrapFlag(GuestState[currentProcessorIndex].HookedPage);
				GuestState[currentProcessorIndex].HookedPage = NULL;
			}
			GuestState[currentProcessorIndex].IncrementRip = false;
			VmxHelper::SetMonitorTrapFlag(false);
			break;
		}
		case EXIT_REASON_EPT_VIOLATION: {
			SIZE_T physicalAddress = 0;
			__vmx_vmread(GUEST_PHYSICAL_ADDRESS, &physicalAddress);
			currentEptInstance->HandleEptViolation(exitQualification, physicalAddress);
			break;
		}
		case EXIT_REASON_EPT_MISCONFIG: {
			SIZE_T physicalAddress = 0;
			__vmx_vmread(GUEST_PHYSICAL_ADDRESS, &physicalAddress);
			currentEptInstance->HandleMisconfiguration(physicalAddress);
			break;
		}
		case EXIT_REASON_VMCALL: {
			if (IsSelfVmcall(guestRegisters->r10, guestRegisters->r11, guestRegisters->r12))
				guestRegisters->rax = VmcallHandler(guestRegisters->rcx, guestRegisters->rdx, guestRegisters->r8, guestRegisters->r9);
			else
				guestRegisters->rax = AsmHypervVmcall(guestRegisters->rcx, guestRegisters->rdx, guestRegisters->r8);
			break;
		}
		default: {
			NovaHypervisorLog(TRACE_FLAG_WARNING, "Unkown Vmexit, reason : 0x%llx", exitReason);
			break;
		}
	}

	if (!GuestState[currentProcessorIndex].VmxoffState.IsVmxoffExecuted && GuestState[currentProcessorIndex].IncrementRip)
		VmxHelper::ResumeToNextInstruction();

	// Set indicator of Vmx noon root mode to false
	GuestState[currentProcessorIndex].IsOnVmxRoot = false;
	return GuestState[currentProcessorIndex].VmxoffState.IsVmxoffExecuted;
}

/*
* Description:
* VmResumeInstruction is responsible for calling the VMRESUME instruction.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void VmResumeInstruction() {
	__vmx_vmresume();

	SIZE_T errorCode = 0;
	__vmx_vmread(VM_INSTRUCTION_ERROR, &errorCode);
	__vmx_off();
	NovaHypervisorLog(TRACE_FLAG_ERROR, "VM resume failed with error code: 0x%llx", errorCode);
}
```

`NovaHypervisor/VmexitHandler.h`:

```h
#pragma once
#include "pch.h"
#include "HypervisorDefinitions.h"
#include "GlobalVariables.h"
#include "RegistersHandler.h"
#include "EventInjection.h"
#include "VmcallHandler.h"
#include "WppDefinitions.h"
#include "VmexitHandler.tmh"

constexpr ULONG64 NO_HYPERV_MAGIC = 0x4e4f485950455256;
constexpr ULONG64 VMCALL_MAGIC = 0x564d43414c4c;
constexpr ULONG64 HYPERVISOR_MAGIC = 0x4856544d50;

constexpr auto IsSelfVmcall = [](ULONG64 r10, ULONG64 r11, ULONG64 r12) -> bool {
	return r10 == HYPERVISOR_MAGIC && r11 == VMCALL_MAGIC && r12 == NO_HYPERV_MAGIC;
};

extern "C" {
	void VmResumeInstruction();
	bool VmexitHandler(_Inout_ PGUEST_REGS guestRegisters);
}

```

`NovaHypervisor/Vmx.cpp`:

```cpp
#include "pch.h"
#include "Vmx.h"

/*
* Description:
* VmxInitialize is responsible for initializing the VMX.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @status [bool] -- True if VMX was initialized, else false.
*/
bool VmxInitialize() {
	if (!VmxInitializer())
		return false;
	KeGenericCallDpc(InitializeGuest, 0x0);

	if (!NT_SUCCESS(AsmVmxVmcall(VMCALL_TEST, 0x22, 0x333, 0x4444)))
		return false;
	return true;
}

/*
* Description:
* InitializeGuest is responsible for initializing the guest by saving the state and launching the VM.
*
* Parameters:
* @dpc			   [_In_ KDPC*]		-- The DPC.
* @deferredContext [_In_opt_ PVOID] -- Additional context.
* @systemArgument1 [_In_opt_ PVOID] -- The system argument 1, used to signal when the DPC is done.
* @systemArgument2 [_In_opt_ PVOID] -- The system argument 2, used to synchronize.
* 
* Returns:
* There is no return value.
*/
void InitializeGuest(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2) {
	UNREFERENCED_PARAMETER(dpc);
	UNREFERENCED_PARAMETER(deferredContext);

	AsmVmxSaveState();
	KeSignalCallDpcSynchronize(systemArgument2);
	KeSignalCallDpcDone(systemArgument1);
}

/*
* Description:
* TerminateVmx is responsible for freeing all the memory and devirtualize the processors.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void TerminateVmx() {
	KeGenericCallDpc(TerminateGuest, 0x0);
	ULONG processorCount = KeQueryActiveProcessorCount(0);

	for (ULONG i = 0; i < processorCount; i++) {
		if (GuestState[i].EptInstance) {
			delete GuestState[i].EptInstance;
			GuestState[i].EptInstance = nullptr;
		}
	}
	FreeVirtualMemory(GuestState);
}

/*
* Description:
* TerminateGuest is responsible for devirtualize the processor.
*
* Parameters:
* @dpc			   [_In_ KDPC*]		-- The DPC.
* @deferredContext [_In_opt_ PVOID] -- Additional context.
* @systemArgument1 [_In_opt_ PVOID] -- The system argument 1, used to signal when the DPC is done.
* @systemArgument2 [_In_opt_ PVOID] -- The system argument 2, used to synchronize.
*
* Returns:
* There is no return value.
*/
void TerminateGuest(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2) {
	UNREFERENCED_PARAMETER(dpc);
	UNREFERENCED_PARAMETER(deferredContext);

	if (!VmxTerminate())
		NovaHypervisorLog(TRACE_FLAG_ERROR, "There was an error terminating vmx");

	KeSignalCallDpcSynchronize(systemArgument2);
	KeSignalCallDpcDone(systemArgument1);
}

/*
* Description:
* VmxInitializer is responsible for allocating the guests and creating the EPT and allocate the needed structures for
* each logical core.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @status [bool] -- True if the VMX was initialized, else false.
*/
_IRQL_requires_max_(APC_LEVEL)
bool VmxInitializer() {
	ULONG processorIndex = 0;
	bool initialized = true;

	if (!VmxHelper::IsVmxSupported()) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "VMX is not supported in this machine");
		return false;
	}
	ULONG processorCount = KeQueryActiveProcessorCount(0);
	GuestState = AllocateVirtualMemory<VmState*>(sizeof(VmState) * processorCount, false);

	if (!GuestState) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Insufficient memory for GuestState allocation");
		return false;
	}

	for (; processorIndex < processorCount; processorIndex++) {
		__try {
			GuestState[processorIndex].EptInstance = new Ept();
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to create EPT instance for processor 0x%lx: 0x%llx", processorIndex, GetExceptionCode());
			initialized = false;
			break;
		}
	}

	if (!initialized) {
		for (ULONG i = 0; i < processorIndex; i++) {
			if (GuestState[i].EptInstance) {
				delete GuestState[i].EptInstance;
				GuestState[i].EptInstance = nullptr;
			}
		}
		FreeVirtualMemory(GuestState);
		return false;
	}

	// Allocating vmxon, vmcs, vmm stack and msr bitmap for each logical core.
	KeGenericCallDpc(reinterpret_cast<PKDEFERRED_ROUTINE>(AllocateVmStructures), 0x0);
	return true;
}

/*
* Description:
* VirtualizeProcessor is responsible for loading the VMCS and launching the VM for a logical core.
*
* Parameters:
* @guestStack [_In_ PVOID] -- The guest stack.
*
* Returns:
* @status	  [bool]	   -- Returns only false if the VM didn't launch.
*/
bool VirtualizeProcessor(_In_ PVOID guestStack) {
	bool success = true;
	ULONG64 errorCode = 0;
	ULONG processorId = KeGetCurrentProcessorNumber();

	do {
		if (GuestState[processorId].VmxonRegion == 0) {
			NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to get guest state for processor %d", processorId);
			success = false;
			break;
		}

		if (!VmxHelper::ClearVmcsState(&GuestState[processorId])) {
			NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to clear VMCS state for processor %d", processorId);
			success = false;
			break;
		}

		if (!VmxHelper::LoadVmcs(&GuestState[processorId])) {
			NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to load VMCS for processor %d", processorId);
			success = false;
			break;
		}

		success = SetupVmcs(&GuestState[processorId], guestStack);
	} while (false);

	if (success) {
		NovaHypervisorLog(TRACE_FLAG_INFO, "Launching VM on processor %d", processorId);
		GuestState[processorId].IsLaunched = true;
		__vmx_vmlaunch();
	}

	__vmx_off();
	__vmx_vmread(VM_INSTRUCTION_ERROR, &errorCode);
	NovaHypervisorLog(TRACE_FLAG_ERROR, "VM launch failed with error code 0x%llx", errorCode);
	GuestState[processorId].IsLaunched = false;
	return false;
}

/*
* Description:
* VmxTerminate is responsible for freeing the allocated memory for each logical core.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @status [bool] -- True if the VMX was terminated, else false.
*/
bool VmxTerminate() {
	NTSTATUS status = STATUS_SUCCESS;
	ULONG currentProcessorIndex = KeGetCurrentProcessorNumber();

	NovaHypervisorLog(TRACE_FLAG_INFO, "Terminating VMX for logical core %d", currentProcessorIndex);
	status = AsmVmxVmcall(VMCALL_VMXOFF, NULL, NULL, NULL);

	if (!NT_SUCCESS(status))
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to execute vmcall to turn off vmx");

	if (GuestState[currentProcessorIndex].VmxonRegion != 0) {
		MmFreeContiguousMemory(reinterpret_cast<PVOID>(GuestState[currentProcessorIndex].VmxonRegion));
		GuestState[currentProcessorIndex].VmxonRegion = 0;
	}

	if (GuestState[currentProcessorIndex].VmcsRegion != 0) {
		MmFreeContiguousMemory(reinterpret_cast<PVOID>(GuestState[currentProcessorIndex].VmcsRegion));
		GuestState[currentProcessorIndex].VmcsRegion = 0;
	}
	FreeVirtualMemory(reinterpret_cast<PVOID>(GuestState[currentProcessorIndex].VmmStack));
	FreeVirtualMemory(reinterpret_cast<PVOID>(GuestState[currentProcessorIndex].MsrBitmap));
	return NT_SUCCESS(status);
}

/*
* Description:
* SetupVmcs is responsible for setting up vmcs and launching the VM.
*
* Parameters:
* @state	  [_In_ VmState*] -- The VM state.
* @guestStack [_In_ PVOID]	  -- The guest stack.
*
* Returns:
* @status	  [bool]						-- True if the VM was launched, else false.
*/
bool SetupVmcs(_Inout_ VmState* state, _In_ PVOID guestStack) {
	SEGMENT_SELECTOR segmentSelector = { 0 };
	IA32_VMX_BASIC_MSR vmxBasicMsr = { 0 };
	vmxBasicMsr.All = __readmsr(MSR_IA32_VMX_BASIC);

	__vmx_vmwrite(HOST_ES_SELECTOR, AsmGetEs() & 0xF8);
	__vmx_vmwrite(HOST_CS_SELECTOR, AsmGetCs() & 0xF8);
	__vmx_vmwrite(HOST_SS_SELECTOR, AsmGetSs() & 0xF8);
	__vmx_vmwrite(HOST_DS_SELECTOR, AsmGetDs() & 0xF8);
	__vmx_vmwrite(HOST_FS_SELECTOR, AsmGetFs() & 0xF8);
	__vmx_vmwrite(HOST_GS_SELECTOR, AsmGetGs() & 0xF8);
	__vmx_vmwrite(HOST_TR_SELECTOR, AsmGetTr() & 0xF8);

	// Setting the link pointer to the required value for 4KB VMCS. 
	__vmx_vmwrite(VMCS_LINK_POINTER, ~0ULL);

	__vmx_vmwrite(GUEST_IA32_DEBUGCTL, __readmsr(MSR_IA32_DEBUGCTL) & 0xFFFFFFFF);
	__vmx_vmwrite(GUEST_IA32_DEBUGCTL_HIGH, __readmsr(MSR_IA32_DEBUGCTL) >> 32);

	/* Time-stamp counter offset */
	__vmx_vmwrite(TSC_OFFSET, 0);

	__vmx_vmwrite(PAGE_FAULT_ERROR_CODE_MASK, 0);
	__vmx_vmwrite(PAGE_FAULT_ERROR_CODE_MATCH, 0);

	__vmx_vmwrite(VM_EXIT_MSR_STORE_COUNT, 0);
	__vmx_vmwrite(VM_EXIT_MSR_LOAD_COUNT, 0);

	__vmx_vmwrite(VM_ENTRY_MSR_LOAD_COUNT, 0);
	__vmx_vmwrite(VM_ENTRY_INTR_INFO_FIELD, 0);

	PVOID gdtBase = reinterpret_cast<PVOID>(AsmGetGdtBase());

	VmxHelper::FillGuestSelectorData(gdtBase, ES, AsmGetEs());
	VmxHelper::FillGuestSelectorData(gdtBase, CS, AsmGetCs());
	VmxHelper::FillGuestSelectorData(gdtBase, SS, AsmGetSs());
	VmxHelper::FillGuestSelectorData(gdtBase, DS, AsmGetDs());
	VmxHelper::FillGuestSelectorData(gdtBase, FS, AsmGetFs());
	VmxHelper::FillGuestSelectorData(gdtBase, GS, AsmGetGs());
	VmxHelper::FillGuestSelectorData(gdtBase, LDTR, AsmGetLdtr());
	VmxHelper::FillGuestSelectorData(gdtBase, TR, AsmGetTr());

	__vmx_vmwrite(GUEST_FS_BASE, __readmsr(MSR_FS_BASE));
	__vmx_vmwrite(GUEST_GS_BASE, __readmsr(MSR_GS_BASE));

	
	ULONG cpuBasedVmExecControls = VmxHelper::AdjustControls(CPU_BASED_ACTIVATE_MSR_BITMAP | CPU_BASED_ACTIVATE_SECONDARY_CONTROLS, 
		vmxBasicMsr.Fields.VmxCapabilityHint ? MSR_IA32_VMX_TRUE_PROCBASED_CTLS : MSR_IA32_VMX_PROCBASED_CTLS);
	__vmx_vmwrite(CPU_BASED_VM_EXEC_CONTROL, cpuBasedVmExecControls);
	NovaHypervisorLog(TRACE_FLAG_DEBUG, "CPU Based VM Exec Controls (Based on MSR_IA32_VMX_PROCBASED_CTLS) : 0x%x", cpuBasedVmExecControls);

	ULONG secondaryProcBasedVmExecControls = VmxHelper::AdjustControls(CPU_BASED_CTL2_RDTSCP | CPU_BASED_CTL2_ENABLE_EPT | 
		CPU_BASED_CTL2_ENABLE_INVPCID | CPU_BASED_CTL2_ENABLE_XSAVE_XRSTORS | CPU_BASED_CTL2_ENABLE_VPID,
		MSR_IA32_VMX_PROCBASED_CTLS2);

	__vmx_vmwrite(SECONDARY_VM_EXEC_CONTROL, secondaryProcBasedVmExecControls);
	NovaHypervisorLog(TRACE_FLAG_DEBUG, "Secondary CPU Based VM Exec Controls (Based on MSR_IA32_VMX_PROCBASED_CTLS2) : 0x%x", secondaryProcBasedVmExecControls);

	__vmx_vmwrite(PIN_BASED_VM_EXEC_CONTROL, VmxHelper::AdjustControls(0,
		vmxBasicMsr.Fields.VmxCapabilityHint ? MSR_IA32_VMX_TRUE_PINBASED_CTLS : MSR_IA32_VMX_PINBASED_CTLS));

	__vmx_vmwrite(VM_EXIT_CONTROLS, VmxHelper::AdjustControls(VM_EXIT_IA32E_MODE,
		vmxBasicMsr.Fields.VmxCapabilityHint ? MSR_IA32_VMX_TRUE_EXIT_CTLS : MSR_IA32_VMX_EXIT_CTLS));

	__vmx_vmwrite(VM_ENTRY_CONTROLS, VmxHelper::AdjustControls(VM_ENTRY_IA32E_MODE,
		vmxBasicMsr.Fields.VmxCapabilityHint ? MSR_IA32_VMX_TRUE_ENTRY_CTLS : MSR_IA32_VMX_ENTRY_CTLS));

	__vmx_vmwrite(CR0_GUEST_HOST_MASK, 0);
	__vmx_vmwrite(CR4_GUEST_HOST_MASK, 0);

	__vmx_vmwrite(CR0_READ_SHADOW, 0);
	__vmx_vmwrite(CR4_READ_SHADOW, 0);

	__vmx_vmwrite(GUEST_CR0, __readcr0());
	__vmx_vmwrite(GUEST_CR3, __readcr3());
	__vmx_vmwrite(GUEST_CR4, __readcr4());

	__vmx_vmwrite(GUEST_DR7, 0x400);

	__vmx_vmwrite(HOST_CR0, __readcr0());
	__vmx_vmwrite(HOST_CR4, __readcr4());
	__vmx_vmwrite(HOST_CR3, VmxHelper::FindSystemDirectoryTableBase());

	__vmx_vmwrite(GUEST_GDTR_BASE, AsmGetGdtBase());
	__vmx_vmwrite(GUEST_IDTR_BASE, AsmGetIdtBase());
	__vmx_vmwrite(GUEST_GDTR_LIMIT, AsmGetGdtLimit());
	__vmx_vmwrite(GUEST_IDTR_LIMIT, AsmGetIdtLimit());

	__vmx_vmwrite(GUEST_RFLAGS, AsmGetRflags());

	__vmx_vmwrite(GUEST_SYSENTER_CS, __readmsr(MSR_IA32_SYSENTER_CS));
	__vmx_vmwrite(GUEST_SYSENTER_EIP, __readmsr(MSR_IA32_SYSENTER_EIP));
	__vmx_vmwrite(GUEST_SYSENTER_ESP, __readmsr(MSR_IA32_SYSENTER_ESP));
	
	VmxHelper::GetSegmentDescriptor(&segmentSelector, AsmGetTr(), reinterpret_cast<PVOID>(AsmGetGdtBase()));
	__vmx_vmwrite(HOST_TR_BASE, segmentSelector.BASE);

	__vmx_vmwrite(HOST_FS_BASE, __readmsr(MSR_FS_BASE));
	__vmx_vmwrite(HOST_GS_BASE, __readmsr(MSR_GS_BASE));

	__vmx_vmwrite(HOST_GDTR_BASE, AsmGetGdtBase());
	__vmx_vmwrite(HOST_IDTR_BASE, AsmGetIdtBase());

	__vmx_vmwrite(HOST_IA32_SYSENTER_CS, __readmsr(MSR_IA32_SYSENTER_CS));
	__vmx_vmwrite(HOST_IA32_SYSENTER_EIP, __readmsr(MSR_IA32_SYSENTER_EIP));
	__vmx_vmwrite(HOST_IA32_SYSENTER_ESP, __readmsr(MSR_IA32_SYSENTER_ESP));

	__vmx_vmwrite(MSR_BITMAP, state->MsrBitmapPhysical);

	__vmx_vmwrite(EPT_POINTER, state->EptInstance->GetEptPointerFlags());
	__vmx_vmwrite(VIRTUAL_PROCESSOR_ID, VPID_TAG);

	__vmx_vmwrite(GUEST_RSP, reinterpret_cast<SIZE_T>(guestStack));
	__vmx_vmwrite(GUEST_RIP, reinterpret_cast<SIZE_T>(AsmVmxRestoreState));

	UINT64 hostRsp = (state->VmmStack + VMM_STACK_SIZE - 1);
	hostRsp &= ~0xF;
	__vmx_vmwrite(HOST_RSP, hostRsp);
	__vmx_vmwrite(HOST_RIP, reinterpret_cast<SIZE_T>(AsmVmexitHandler));
	return true;
}

/*
* Description:
* VmxVmxoff is responsible for turning off the VMX.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void VmxVmxoff() {
	ULONG currentProcessorIndex = KeGetCurrentProcessorNumber();

	// Making sure that we are running with the correct guest CR3 and not the host CR3.
	SIZE_T GuestCr3 = 0;
	__vmx_vmread(GUEST_CR3, &GuestCr3);
	__writecr3(GuestCr3);

	SIZE_T guestRip = 0;
	SIZE_T guestRsp = 0;
	__vmx_vmread(GUEST_RIP, &guestRip);
	__vmx_vmread(GUEST_RSP, &guestRsp);

	SIZE_T exitInstructionLength = 0;
	__vmx_vmread(VM_EXIT_INSTRUCTION_LEN, &exitInstructionLength);
	guestRip += exitInstructionLength;

	// Set the previous registers states
	GuestState[currentProcessorIndex].VmxoffState.GuestRip = guestRip;
	GuestState[currentProcessorIndex].VmxoffState.GuestRsp = guestRsp;
	GuestState[currentProcessorIndex].VmxoffState.IsVmxoffExecuted = true;

	VmxHelper::RestoreRegisters();

	// Clearing VMCS state.
	VmxHelper::ClearVmcsState(&GuestState[currentProcessorIndex]);
	__vmx_off();

	GuestState[currentProcessorIndex].IsLaunched = false;
	VmxHelper::DisableVmxOperation();
}

/*
* Description:
* AllocateVmStructures is responsible for enabling VMX and allocating vmxon, vmcs, vmm stack and msr bitmap for each logical core.
*
* Parameters:
* @dpc			   [_In_ KDPC*]		-- The DPC.
* @deferredContext [_In_opt_ PVOID] -- Additional context.
* @systemArgument1 [_In_opt_ PVOID] -- The system argument 1, used to signal when the DPC is done.
* @systemArgument2 [_In_opt_ PVOID] -- The system argument 2, used to synchronize.
*
* Returns:
* @status		   [bool]		    -- True if the VMX was enabled and the memory was allocated, else false.
*/
bool AllocateVmStructures(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2) {
	UNREFERENCED_PARAMETER(dpc);
	UNREFERENCED_PARAMETER(deferredContext);

	ULONG currentProcessorId = KeGetCurrentProcessorNumber();
	NovaHypervisorLog(TRACE_FLAG_INFO, "Allocating VMX regions for logical core %d", currentProcessorId);
	VmxHelper::EnableVmxOperation();
	NovaHypervisorLog(TRACE_FLAG_INFO, "VMX operation enabled for logical core %d", currentProcessorId);

	if (!AllocateRegion(VMXON_REGION, &GuestState[currentProcessorId])) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Error in allocating memory for Vmxon region for logical core %d", currentProcessorId);
		return false;
	}
	if (!AllocateRegion(VMCS_REGION, &GuestState[currentProcessorId])) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Error in allocating memory for Vmcs region for logical core %d", currentProcessorId);
		return false;
	}

	GuestState[currentProcessorId].VmmStack = AllocateVirtualMemory<UINT64>(VMM_STACK_SIZE, false);

	if (!GuestState[currentProcessorId].VmmStack) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to allocate VMM stack for processor %d", currentProcessorId);
		return false;
	}
	GuestState[currentProcessorId].MsrBitmap = AllocateVirtualMemory<UINT64>(PAGE_SIZE, false);

	if (!GuestState[currentProcessorId].MsrBitmap) {
		NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to allocate MSR bitmap for processor %d", currentProcessorId);
		return false;
	}
	GuestState[currentProcessorId].MsrBitmapPhysical = GetPhysicalAddress(GuestState[currentProcessorId].MsrBitmap);

	KeSignalCallDpcSynchronize(systemArgument2);
	KeSignalCallDpcDone(systemArgument1);
	return true;
}

/*
* Description:
* AllocateRegion is responsible for allocating a VMX region.
*
* Parameters:
* @state	  [_Inout_ VmState*] -- The VM state to allocate the region for.
* @regionType [RegionType]		 -- The region type to allocate.
*
* Returns:
* @allocated  [bool]			 -- Returns true if allocated, else false.
*/
bool AllocateRegion(_In_ RegionType regionType, _Inout_ VmState* state) {
	int status = 0;
	bool success = true;
	PVOID region = NULL;
	UINT64 alignedRegionVirtual = 0;
	UINT64 alignedRegionPhysical = 0;
	UINT64 physicalAddress = 0;
	IA32_VMX_BASIC_MSR basic = { 0 };
	PHYSICAL_ADDRESS maxPhysicalAddress = { 0 };
	maxPhysicalAddress.QuadPart = MAXULONG64;
	KIRQL originalIrql = KeGetCurrentIrql();
	size_t regionSize = 0;

	switch (regionType) {
	case VMXON_REGION:
		regionSize = VMXON_SIZE * 2;
		break;
	case VMCS_REGION:
		regionSize = VMCS_SIZE * 2;
		break;
	default:
		return false;
	}

	if (originalIrql > DISPATCH_LEVEL)
		KeLowerIrql(DISPATCH_LEVEL);

	do {
		region = MmAllocateContiguousMemory(regionSize + PAGE_SIZE, maxPhysicalAddress);

		if (!region) {
			success = false;
			break;
		}
		alignedRegionVirtual = (UINT64)PAGE_ALIGN(region);

		RtlSecureZeroMemory(region, regionSize + PAGE_SIZE);
		physicalAddress = MmGetPhysicalAddress(region).QuadPart;
		alignedRegionPhysical = (UINT64)PAGE_ALIGN(physicalAddress);

		// Changing Revision Identifier
		basic.All = __readmsr(MSR_IA32_VMX_BASIC);

		if (alignedRegionVirtual)
			*(UINT64*)alignedRegionVirtual = basic.Fields.RevisionIdentifier;

		if (basic.Fields.MemoryType != 6) {
			NovaHypervisorLog(TRACE_FLAG_ERROR, "Memory type is not write-back");
			success = false;
			break;
		}

		if (regionType == VMXON_REGION)
			status = __vmx_on(&alignedRegionPhysical);

		if (status) {
			NovaHypervisorLog(TRACE_FLAG_ERROR, "Failed to do vmxon with status %d", status);
			success = false;
			break;
		}
	} while (false);

	// Making sure to free the allocated memory if failed with the right IRQL.
	if (!success) {
		if (region != 0)
			MmFreeContiguousMemory(region);
		region = NULL;
	}

	// Restoring the original IRQL.
	if (originalIrql > DISPATCH_LEVEL)
		KeRaiseIrql(originalIrql, &originalIrql);

	if (!success)
		return false;

	if (regionType == VMCS_REGION) {
		state->VmcsRegion = (UINT64)region;
		state->VmcsRegionPhysical = alignedRegionPhysical;
		return true;
	}
	else {
		state->VmxonRegion = (UINT64)region;
		state->VmxonRegionPhysical = alignedRegionPhysical;
	}
	return true;
}

/*
* Description:
* GetCurrentGuestRsp is responsible for getting the RSP for the current guest.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @rsp [UINT64] -- The RSP for the current guest.
*/
UINT64 GetCurrentGuestRsp() {
	return GuestState[KeGetCurrentProcessorNumber()].VmxoffState.GuestRsp;
}

/*
* Description:
* GetCurrentGuestRip is responsible for getting the RIP for the current guest.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @rip [UINT64] -- The RIP for the current guest.
*/
UINT64 GetCurrentGuestRip() {
	return GuestState[KeGetCurrentProcessorNumber()].VmxoffState.GuestRip;
}

/*
* Description:
* UnhookAllPagesDpc is responsible for removing all the EPT hooks and invalidating the TLB.
*
* Parameters:
* @dpc			   [_In_ KDPC*]		-- The DPC.
* @deferredContext [_In_opt_ PVOID] -- Additional context.
* @systemArgument1 [_In_opt_ PVOID] -- The system argument 1, used to signal when the DPC is done.
* @systemArgument2 [_In_opt_ PVOID] -- The system argument 2, used to synchronize.
*
* Returns:
* There is no return value.
*/
void UnhookAllPagesDpc(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2) {
	UNREFERENCED_PARAMETER(dpc);
	UNREFERENCED_PARAMETER(deferredContext);

	AsmVmxVmcall(VMCALL_UNHOOK_ALL_PAGES, NULL, NULL, NULL);
	KeSignalCallDpcSynchronize(systemArgument2);
	KeSignalCallDpcDone(systemArgument1);
}

/*
* Description:
* UnhookAllPages is responsible for removing single EPT hook and invalidating the TLB.
*
* Parameters:
* @dpc			   [_In_ KDPC*]		-- The DPC.
* @deferredContext [_In_opt_ PVOID] -- Additional context (page to unhook).
* @systemArgument1 [_In_opt_ PVOID] -- The system argument 1, used to signal when the DPC is done.
* @systemArgument2 [_In_opt_ PVOID] -- The system argument 2, used to synchronize.
*
* Returns:
* There is no return value.
*/
void UnhookSinglePage(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2) {
	UNREFERENCED_PARAMETER(dpc);

	if (deferredContext)
		AsmVmxVmcall(VMCALL_UNHOOK_SINGLE_PAGE, reinterpret_cast<UINT64>(deferredContext), NULL, NULL);
	KeSignalCallDpcSynchronize(systemArgument2);
	KeSignalCallDpcDone(systemArgument1);
}
```

`NovaHypervisor/Vmx.h`:

```h
#pragma once
#include "pch.h"
#include "Ept.h"
#include "HypervisorDefinitions.h"
#include "WindowsDefinitions.h"
#include "InlineAsm.h"
#include "GlobalVariables.h"
#include "VmxHelper.h"
#include "MemoryHelper.hpp"
#include "VmState.h"
#include "WppDefinitions.h"
#include "Vmx.tmh"

bool VmxInitialize();
_IRQL_requires_max_(APC_LEVEL)
bool VmxInitializer();

void TerminateVmx();
bool VmxTerminate();

void InitializeGuest(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2);
void TerminateGuest(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2);
void UnhookSinglePage(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2);
void UnhookAllPagesDpc(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2);
bool AllocateVmStructures(_In_ KDPC* dpc, _In_opt_ PVOID deferredContext, _In_opt_ PVOID systemArgument1, _In_opt_ PVOID systemArgument2);
bool AllocateRegion(_In_ RegionType regionType, _Inout_ VmState* state);

void VmxVmxoff();

extern "C" { 
	bool VirtualizeProcessor(_In_ PVOID guestStack); 
	UINT64 GetCurrentGuestRip();
	UINT64 GetCurrentGuestRsp();
}
bool SetupVmcs(_Inout_ VmState* state, _In_ PVOID guestStack);

```

`NovaHypervisor/VmxHelper.cpp`:

```cpp
#include "pch.h"
#include "VmxHelper.h"
#include "GlobalVariables.h"

/*
* Description:
* EnableVmxOperation is responsible for enabling VMX operation.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void VmxHelper::EnableVmxOperation() {
	ULONGLONG cr4 = __readcr4();
	cr4 |= 0x2000;
	__writecr4(cr4);
};

/*
* Description:
* DisableVmxOperation is responsible for disabling VMX operation.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void VmxHelper::DisableVmxOperation() {
	ULONGLONG cr4 = __readcr4();
	cr4 &= ~0x2000;
	__writecr4(cr4);
};

/*
* Description:
* IsVmxSupported is responsible for getting whether VMX is supported.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @supported [bool] -- True if VMX is supported, else false.
*/
 bool VmxHelper::IsVmxSupported() {
	IA32_FEATURE_CONTROL_MSR control = { 0 };
	CPUID cpuidResult = { 0 };

	__cpuid((int*)&cpuidResult, 1);

	if ((cpuidResult.ecx & (1 << 5)) == 0)
		return false;
	control.All = __readmsr(MSR_IA32_FEATURE_CONTROL);

	if (control.Fields.Lock == 0) {
		control.Fields.Lock = TRUE;
		control.Fields.EnableVmxon = TRUE;
		__writemsr(MSR_IA32_FEATURE_CONTROL, control.All);
		return true;
	}
	return control.Fields.EnableVmxon;
}

/*
* Description:
* ClearVmcsState is responsible for setting VMCS launch state to clear.
*
* Parameters:
* @state  [_Inout_ VmState*] -- The VM state to clear.
*
* Returns:
* @status [bool]			 -- True if the VMCS was cleared, else false.
*/
 bool VmxHelper::ClearVmcsState(_Inout_ VmState* state) {
	int status = __vmx_vmclear(&state->VmcsRegionPhysical);

	if (status) {
		__vmx_off();
		return false;
	}
	return true;
}

/*
* Description:
* LoadVmcs is responsible for loading the VMCS.
*
* Parameters:
* @state  [_Inout_ VmState*] -- The VM state that contains the VMCS to load.
*
* Returns:
* @status [bool]			 -- True if the VMCS loaded, else false.
*/
 bool VmxHelper::LoadVmcs(_Inout_ VmState* state) {
	return !__vmx_vmptrld(&state->VmcsRegionPhysical);
}

/*
* Description:
* ResumeToNextInstruction is responsible for resuming to the next instruction after VMEXIT.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void VmxHelper::ResumeToNextInstruction() {
	SIZE_T resumeRip = NULL;
	SIZE_T currentRip = NULL;
	SIZE_T exitInstructionLength = 0;

	__vmx_vmread(GUEST_RIP, &currentRip);
	__vmx_vmread(VM_EXIT_INSTRUCTION_LEN, &exitInstructionLength);

	resumeRip = currentRip + exitInstructionLength;
	__vmx_vmwrite(GUEST_RIP, resumeRip);
}

/*
* Description:
* GetSegmentDescriptor is responsible for filling the segment selector with the base, limit, and attributes of the segment.
*
* Parameters:
* @segmentSelector [_Inout_ PSEGMENT_SELECTOR] -- The segment selector to fill.
* @selector		   [_In_ USHORT]			   -- The selector to get the descriptor for.
* @gdtBase		   [_In_ PVOID]				   -- The base of the GDT.
*
* Returns:
* @status		   [bool]					   -- True if the segment descriptor was filled, else false.
*/
 bool VmxHelper::GetSegmentDescriptor(_Inout_ PSEGMENT_SELECTOR segmentSelector, _In_ USHORT selector, _In_ PVOID gdtBase) {
	if (!segmentSelector || selector & 4)
		return false;
	PSEGMENT_DESCRIPTOR segDesc = reinterpret_cast<PSEGMENT_DESCRIPTOR>(reinterpret_cast<PUCHAR>(gdtBase) + (selector & ~0x7));

	segmentSelector->SEL = selector;
	segmentSelector->BASE = segDesc->BASE0 | segDesc->BASE1 << 16 | segDesc->BASE2 << 24;
	segmentSelector->LIMIT = segDesc->LIMIT0 | (segDesc->LIMIT1ATTR1 & 0xf) << 16;
	segmentSelector->ATTRIBUTES.UCHARs = segDesc->ATTR0 | (segDesc->LIMIT1ATTR1 & 0xf0) << 4;

	// TSS or callgate, save the base high part.
	if (!(segDesc->ATTR0 & 0x10)) {
		ULONG64 tmp = *reinterpret_cast<PULONG64>((reinterpret_cast<PUCHAR>(segDesc) + 8));
		segmentSelector->BASE = (segmentSelector->BASE & 0xffffffff) | (tmp << 32);
	}

	// 4096-bit granularity is enabled for this segment, scale the limit
	if (segmentSelector->ATTRIBUTES.Fields.G)
		segmentSelector->LIMIT = (segmentSelector->LIMIT << 12) + 0xfff;
	return true;
}

/*
* Description:
* FillGuestSelectorData is responsible for setting the guest selector, attributes, limit, and base
*
* Parameters:
* @gdtBase		   [_In_ PVOID]	 -- The base of the GDT.
* @segmentRegister [_In_ ULONG]	 -- The segment register to set.
* @selector		   [_In_ USHORT] -- The selector to get the descriptor for.
*
* Returns:
* There is no return value.
*/
 bool VmxHelper::FillGuestSelectorData(_In_ PVOID gdtBase, _In_ ULONG segmentRegister, _In_ USHORT selector) {
	SEGMENT_SELECTOR segmentSelector = { 0 };
	ULONG accessRights = 0;

	if (!GetSegmentDescriptor(&segmentSelector, selector, gdtBase))
		return false;
	accessRights = reinterpret_cast<PUCHAR>(&segmentSelector.ATTRIBUTES)[0];
	accessRights += (reinterpret_cast<PUCHAR>(&segmentSelector.ATTRIBUTES)[1] << 12);

	if (selector == 0)
		accessRights |= 0x10000;
	__vmx_vmwrite(GUEST_ES_SELECTOR + segmentRegister * 2, selector);
	__vmx_vmwrite(GUEST_ES_LIMIT + segmentRegister * 2, segmentSelector.LIMIT);
	__vmx_vmwrite(GUEST_ES_AR_BYTES + segmentRegister * 2, accessRights);
	__vmx_vmwrite(GUEST_ES_BASE + segmentRegister * 2, segmentSelector.BASE);
	return true;
}

/*
* Description:
* AdjustControls is responsible for adjusting MSR controls.
*
* Parameters:
* @ctl	[_In_ ULONG] -- Control to adjust.
* @msr	[_In_ ULONG] -- The MSR to adjust.
*
* Returns:
* @ctl	[ULONG]		 -- The adjusted control.
*/
 ULONG VmxHelper::AdjustControls(_In_ ULONG ctl, _In_ ULONG msr) {
	MSR msrValue = { 0 };
	msrValue.Content = __readmsr(msr);
	ctl &= msrValue.High;
	ctl |= msrValue.Low;
	return ctl;
}

/*
* Description:
* InvalidateVpid is responsible for invalidating single vpid, single address or all VPIDs.
*
* Parameters:
* @vpid	   [_In_opt_ UINT64] -- The vpid to invalidate.
* @address [_In_opt_ UINT64] -- The address to invalidate.
*
* Returns:
* There is no return value.
*/
void VmxHelper::InvalidateVpid(_In_opt_ UINT64 vpid, _In_opt_ UINT64 address) {
	INVVPID_DESCRIPTOR descriptor = { 0 };
	InvvpidType type = InvvpidAllContext;

	if (vpid) {
		descriptor.Vpid = vpid;
		type = InvvpidSingleContext;

		if (address) {
			descriptor.LinearAddress = address;
			type = InvvpidIndividualAddress;
		}
	}
	AsmInvvpid(type, &descriptor);
}

/*
* Description:
* InvalidateEpt is responsible for invalidating single or all EPT contexts.
*
* Parameters:
* @context [_In_opt_ UINT64] -- The context to invalidate.
*
* Returns:
* There is no return value.
*/
void VmxHelper::InvalidateEpt(_In_opt_ UINT64 context) {
	INVEPT_DESC descriptor = { 0 };
	ULONG inveptType = ALL_CONTEXTS;

	if (context) {
		descriptor.EptPointer.Flags = context;
		inveptType = SINGLE_CONTEXT;
	}
	AsmInvept(inveptType, &descriptor);
}

/*
* Description:
* InvalidateEptByVmcall is responsible for invalidating single or all EPT contexts via vmcall.
*
* Parameters:
* @context [_In_opt_ UINT64] -- The context to invalidate.
*
* Returns:
* @status  [NTSTATUS]		 -- STATUS_SUCCESS if the operation was successful, else an error code.
*/
_Use_decl_annotations_
NTSTATUS VmxHelper::InvalidateEptByVmcall(_In_opt_ UINT64 context) {
	return context ? AsmVmxVmcall(VMCALL_INVEPT_SINGLE_CONTEXT, context, NULL, NULL) :
		AsmVmxVmcall(VMCALL_INVEPT_ALL_CONTEXT, NULL, NULL, NULL);
}

/*
* Description:
* HookPageByVmcall is responsible for hooking a page in VMX root mode via vmcall.
*
* Parameters:
* @context [_In_opt_ UINT64] -- The hooked page details.
*
* Returns:
* @status  [NTSTATUS]		 -- STATUS_SUCCESS if the operation was successful, else an error code.
*/
_Use_decl_annotations_
NTSTATUS VmxHelper::HookPageByVmcall(_In_opt_ UINT64 context) {
	if (!context)
		return STATUS_INVALID_PARAMETER;
	HookedPage* hookedPage = reinterpret_cast<HookedPage*>(context);
	return AsmVmxVmcall(VMCALL_EXEC_HOOK_PAGE, hookedPage->Address, hookedPage->Permissions, NULL);
}

/*
* Description:
* UnhookPageByVmcall is responsible for unhooking a page in VMX root mode via vmcall.
*
* Parameters:
* @context [_In_opt_ UINT64] -- The address to unhook.
*
* Returns:
* @status  [NTSTATUS]		 -- STATUS_SUCCESS if the operation was successful, else an error code.
*/
_Use_decl_annotations_
NTSTATUS VmxHelper::UnhookPageByVmcall(_In_opt_ UINT64 context) {
	if (!context)
		return STATUS_INVALID_PARAMETER;

	return AsmVmxVmcall(VMCALL_UNHOOK_SINGLE_PAGE, context, NULL, NULL);
}

/*
* Description:
* RestoreRegisters is responsible for restoring the fs, gs, gdtr, gdtr limit, idtr and idtr limit when vmxoff is performed.
*
* Parameters:
* There are no parameters.
*
* Returns:
* There is no return value.
*/
void VmxHelper::RestoreRegisters() {
	ULONG64 fsBase = 0;
	ULONG64 gsBase = 0;
	ULONG64 gdtrBase = 0;
	ULONG64 gdtrLimit = 0;
	ULONG64 idtrBase = 0;
	ULONG64 idtrLimit = 0;

	__vmx_vmread(GUEST_FS_BASE, &fsBase);
	__writemsr(MSR_FS_BASE, fsBase);

	__vmx_vmread(GUEST_GS_BASE, &gsBase);
	__writemsr(MSR_GS_BASE, gsBase);

	__vmx_vmread(GUEST_GDTR_BASE, &gdtrBase);
	__vmx_vmread(GUEST_GDTR_LIMIT, &gdtrLimit);

	AsmReloadGdtr(reinterpret_cast<PVOID>(gdtrBase), gdtrLimit);

	__vmx_vmread(GUEST_IDTR_BASE, &idtrBase);
	__vmx_vmread(GUEST_IDTR_LIMIT, &idtrLimit);

	AsmReloadIdtr(reinterpret_cast<PVOID>(idtrBase), idtrLimit);
}

/*
* Description:
* FindSystemDirectoryTableBase is responsible for getting the system process' directory table base.
*
* Parameters:
* There are no parameters.
*
* Returns:
* @directoryTableBase [UINT64] -- The system process' directory table base.
*/
 UINT64 VmxHelper::FindSystemDirectoryTableBase() {
	KPROCESS* SystemProcess = static_cast<PKPROCESS>(PsInitialSystemProcess);
	return SystemProcess->DirectoryTableBase;
}

 /*
 * Description:
 * FindKernelBaseAddress is responsible for finding the kernel base address.
 * 
 * Parameters:
 * There are no parameters.
 * 
 * Returns:
 * @status [NTSTATUS] -- STATUS_SUCCESS if the kernel base address was found, else error.
 */
 NTSTATUS VmxHelper::FindKernelBaseAddress() {
	 PKLDR_DATA_TABLE_ENTRY loadedModulesEntry = NULL;
	 NTSTATUS status = STATUS_NOT_FOUND;

	 if (!ExAcquireResourceExclusiveLite(PsLoadedModuleResource, 1))
		 return STATUS_ABANDONED;

	 for (PLIST_ENTRY pListEntry = PsLoadedModuleList->InLoadOrderLinks.Flink;
		 pListEntry != &PsLoadedModuleList->InLoadOrderLinks;
		 pListEntry = pListEntry->Flink) {
		 loadedModulesEntry = CONTAINING_RECORD(pListEntry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

		 if (_wcsnicmp(loadedModulesEntry->BaseDllName.Buffer, KERNEL_NAME, KERNEL_NAME_LEN) == 0) {
			 KernelBaseInfo.KernelBaseAddress = reinterpret_cast<UINT64>(loadedModulesEntry->DllBase);
			 KernelBaseInfo.KernelSize = loadedModulesEntry->SizeOfImageNotRounded;
			 status = STATUS_SUCCESS;
			 break;
		 }
	 }

	 ExReleaseResourceLite(PsLoadedModuleResource);
	 return status;
 }

 void VmxHelper::SetMonitorTrapFlag(_In_ bool set) {
	 ULONG64 cpuBasedVmExecControls = 0;
	 __vmx_vmread(CPU_BASED_VM_EXEC_CONTROL, &cpuBasedVmExecControls);
	 cpuBasedVmExecControls = set ? cpuBasedVmExecControls | CPU_BASED_MONITOR_TRAP_FLAG :
		 cpuBasedVmExecControls & ~CPU_BASED_MONITOR_TRAP_FLAG;
	 __vmx_vmwrite(CPU_BASED_VM_EXEC_CONTROL, cpuBasedVmExecControls);
 }
```

`NovaHypervisor/VmxHelper.h`:

```h
#pragma once
#include "pch.h"
#include "HypervisorDefinitions.h"
#include "InlineAsm.h"
#include "WindowsDefinitions.h"
#include "VmState.h"
#include "WppDefinitions.h"
#include "VmxHelper.tmh"

constexpr wchar_t KERNEL_NAME[] = L"ntoskrnl.exe";
constexpr size_t KERNEL_NAME_LEN = 12;

namespace VmxHelper {
	void EnableVmxOperation();
	void DisableVmxOperation();
	bool IsVmxSupported();
	bool ClearVmcsState(_Inout_ VmState* state);
	bool LoadVmcs(_Inout_ VmState* state);
	void ResumeToNextInstruction();
	bool GetSegmentDescriptor(_Inout_ PSEGMENT_SELECTOR segmentSelector, _In_ USHORT selector, _In_ PVOID gdtBase);
	bool FillGuestSelectorData(_In_ PVOID gdtBase, _In_ ULONG segmentRegister, _In_ USHORT selector);
	ULONG AdjustControls(_In_ ULONG ctl, _In_ ULONG msr);
	void InvalidateVpid(_In_opt_ UINT64 vpid = 0, _In_opt_ UINT64 address = 0);
	void InvalidateEpt(_In_opt_ UINT64 context = 0);
	NTSTATUS InvalidateEptByVmcall(_In_opt_ UINT64 context = 0);
	NTSTATUS HookPageByVmcall(_In_opt_ UINT64 context = 0);
	NTSTATUS UnhookPageByVmcall(_In_opt_ UINT64 context = 0);
	void RestoreRegisters();
	UINT64 FindSystemDirectoryTableBase();
	NTSTATUS FindKernelBaseAddress();
	void SetMonitorTrapFlag(_In_ bool set);
};

```

`NovaHypervisor/WindowsDefinitions.h`:

```h
#pragma once

#include "pch.h"

// Globals
inline ULONG WindowsBuildNumber = 0;
inline PVOID AllocatePool2 = NULL;

// Constants
constexpr ULONG WIN_1507 = 10240;
constexpr ULONG WIN_1511 = 10586;
constexpr ULONG WIN_1607 = 14393;
constexpr ULONG WIN_1703 = 15063;
constexpr ULONG WIN_1709 = 16299;
constexpr ULONG WIN_1803 = 17134;
constexpr ULONG WIN_1809 = 17763;
constexpr ULONG WIN_1903 = 18362;
constexpr ULONG WIN_1909 = 18363;
constexpr ULONG WIN_2004 = 19041;
constexpr ULONG WIN_20H2 = 19042;
constexpr ULONG WIN_21H1 = 19043;
constexpr ULONG WIN_21H2 = 19044;
constexpr ULONG WIN_22H2 = 19045;
constexpr ULONG WIN_1121H2 = 22000;
constexpr ULONG WIN_1122H2 = 22621;
constexpr ULONG WIN_1123H2 = 22631;
constexpr ULONG WIN_1124H2 = 26100;

// Structs
typedef struct _KPROCESS
{
	DISPATCHER_HEADER Header;
	LIST_ENTRY ProfileListHead;
	ULONG_PTR DirectoryTableBase;
	UCHAR Data[1];
} KPROCESS, * PKPROCESS;

typedef struct _KERNEL_BASE_INFO {
	ULONG64 KernelBaseAddress;
	ULONG KernelSize;
} KERNEL_BASE_INFO, * PKERNEL_BASE_INFO;

typedef struct _KLDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	VOID* ExceptionTable;
	ULONG ExceptionTableSize;
	VOID* GpValue;
	PVOID* NonPagedDebugInfo;
	VOID* DllBase;
	VOID* EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	union
	{
		USHORT SignatureLevel : 4;
		USHORT SignatureType : 3;
		USHORT Frozen : 2;
		USHORT HotPatch : 1;
		USHORT Unused : 6;
		USHORT EntireField;
	} u1;
	VOID* SectionPointer;
	ULONG CheckSum;
	ULONG CoverageSectionSize;
	VOID* CoverageSection;
	VOID* LoadedImports;
	union
	{
		VOID* Spare;
		PVOID* NtDataTableEntry;
	};
	ULONG SizeOfImageNotRounded;
	ULONG TimeDateStamp;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

#pragma warning (disable: 4201)
struct _EX_PUSH_LOCK
{
	union
	{
		struct
		{
			ULONGLONG Locked : 1;
			ULONGLONG Waiting : 1;
			ULONGLONG Waking : 1;
			ULONGLONG MultipleShared : 1;
			ULONGLONG Shared : 60;
		};
		ULONGLONG Value;
		VOID* Ptr;
	};
};

typedef struct _FULL_OBJECT_TYPE {
	LIST_ENTRY TypeList;
	UNICODE_STRING Name;
	VOID* DefaultObject;
	UCHAR Index;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	UCHAR TypeInfo[0x78];
	_EX_PUSH_LOCK TypeLock;
	ULONG Key;
	LIST_ENTRY CallbackList;
} FULL_OBJECT_TYPE, * PFULL_OBJECT_TYPE;

// Function prototypes
typedef PVOID(NTAPI* tExAllocatePool2)(
	POOL_FLAGS Flags,
	SIZE_T     NumberOfBytes,
	ULONG      Tag
	);

// Externs
extern "C" PKLDR_DATA_TABLE_ENTRY PsLoadedModuleList;
extern "C" PERESOURCE PsLoadedModuleResource;

extern "C" {
	_IRQL_requires_max_(APC_LEVEL)
		_IRQL_requires_min_(PASSIVE_LEVEL)
		_IRQL_requires_same_
		VOID
		NTAPI
		KeGenericCallDpc(
			_In_ PKDEFERRED_ROUTINE Routine,
			_In_opt_ PVOID Context
		);

	_IRQL_requires_(DISPATCH_LEVEL)
		_IRQL_requires_same_
		VOID
		NTAPI
		KeSignalCallDpcDone(
			_In_ PVOID SystemArgument1
		);

	_IRQL_requires_(DISPATCH_LEVEL)
		_IRQL_requires_same_
		ULONG
		NTAPI
		KeSignalCallDpcSynchronize(
			_In_ PVOID SystemArgument2
		);
}

```

`NovaHypervisor/WppDefinitions.h`:

```h
#ifndef WPP_DEFINITIONS_H
#define WPP_DEFINITIONS_H

// {e74c1035-77d4-4c5b-9088-77056fae3aa3}

#define WPP_CONTROL_GUIDS                                              \
    WPP_DEFINE_CONTROL_GUID(                                           \
        NovaHypervisorLogger, (e74c1035,77d4,4c5b,9088,77056fae3aa3), \
			WPP_DEFINE_BIT(TRACE_FLAG_DEBUG) \
			WPP_DEFINE_BIT(TRACE_FLAG_INFO) \
			WPP_DEFINE_BIT(TRACE_FLAG_WARNING) \
			WPP_DEFINE_BIT(TRACE_FLAG_ERROR) \
   ) 

//#define WPP_Flags_LEVEL_LOGGER(Flags, level)                                  \
//    WPP_LEVEL_LOGGER(Flags)
//
//#define WPP_Flags_LEVEL_ENABLED(Flags, level)                                 \
//    (WPP_LEVEL_ENABLED(Flags) && \
//    WPP_CONTROL(WPP_BIT_ ## Flags).Level >= level)

//
// DoTraceLevelMessage is a custom macro that adds support for levels to the 
// default DoTraceMessage, which supports only flags. In this version, both
// flags and level are conditions for generating the trace message. 
// The preprocessor is told to recognize the function by using the -func argument
// in the RUN_WPP line on the source file. In the source file you will find
// -func:DoTraceLevelMessage(LEVEL,FLAGS,MSG,...). The conditions for triggering 
// this event in the macro are the Levels defined in evntrace.h and the flags 
// defined above and are evaluated by the macro WPP_LEVEL_FLAGS_ENABLED below. 
// 
#define WPP_LEVEL_FLAGS_LOGGER(level,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(level, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= level)

typedef enum _LoggerLevel {
	Debug = 0,
	Info,
	Warning,
	Error
} LoggerLevel;
//
// Configuration block to scan the enumeration definition LoggerLevel. Used when  
// viewing the trace to display names instead of the integer values that users must decode
//
// begin_wpp config
// CUSTOM_TYPE(state, ItemEnum(_LoggerLevel));
// end_wpp


// MACRO: TRACE_RETURN
// Configuration block that defines trace macro. It uses the PRE/POST macros to include
// code as part of the trace macro expansion. TRACE_MACRO is equivalent to the code below:
//
// {if (Status != STATUS_SUCCESS){  // This is the code in the PRE macro
//     DoTraceMessage(FLAG_ONE, "Function Return = %!STATUS!", Status)
// ;}}                              // This is the code in the POST macro
//                                 
// 
// USEPREFIX statement: Defines a format string prefix to be used when logging the event, 
// below the STDPREFIX is used. The first value is the trace function name with out parenthesis
// and the second value is the format string to be used.
// 
// USESUFFIX statement: Defines a suffix format string that gets logged with the event. 
// 
// FUNC statement: Defines the name and signature of the trace function. The function defined 
// below takes one argument, no format string, and predefines the flag equal to FLAG_ONE.
//
//
//begin_wpp config
//USEPREFIX (TRACE_RETURN, "%!STDPREFIX!");
//FUNC TRACE_RETURN{FLAG=FLAG_ONE}(EXP);
//USESUFFIX (TRACE_RETURN, "Function Return=%!STATUS!",EXP);
//end_wpp

//
// PRE macro: The name of the macro includes the condition arguments FLAGS and EXP
//            define in FUNC above
//
#define WPP_FLAG_EXP_PRE(FLAGS, HR) {if (HR != STATUS_SUCCESS) {

//
// POST macro
// The name of the macro includes the condition arguments FLAGS and EXP
//            define in FUNC above
#define WPP_FLAG_EXP_POST(FLAGS, HR) ;}}

// 
// The two macros below are for checking if the event should be logged and for 
// choosing the logger handle to use when calling the ETW trace API
//
#define WPP_FLAG_EXP_ENABLED(FLAGS, HR) WPP_FLAG_ENABLED(FLAGS)
#define WPP_FLAG_EXP_LOGGER(FLAGS, HR) WPP_FLAG_LOGGER(FLAGS)

#endif
```

`NovaHypervisor/pch.cpp`:

```cpp
#include "pch.h"

```

`NovaHypervisor/pch.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include <intrin.h>
#include <cstdarg>
#include <ntstrsafe.h>
```

`README.md`:

```md
# NovaHypervisor

<p align="center">
  <img alt="Logo" src="./Images/logo_transparent.png" width="400" height="400">
</p>

![image](https://img.shields.io/badge/C%2B%2B-00599C?style=for-the-badge&logo=c%2B%2B&logoColor=white) ![assembly](https://img.shields.io/badge/ASSEMBLY-ED8B00?style=for-the-badge&logo=Assembly&logoColor=white) ![image](https://img.shields.io/badge/Windows-0078D6?style=for-the-badge&logo=windows&logoColor=white)

## Description

NovaHypervisor is a defensive x64 Intel host based hypervisor. The goal of this project is to protect against kernel based attacks (either via Bring Your Own Vulnerable Driver (BYOVD) or other means) by safeguarding defense products (AntiVirus / Endpoint Protection) and kernel memory structures and preventing unauthorized access to kernel memory.

NovaHypervisor is written in C++ and Assembly, and is designed to be compatible with Hyper-V and run on Windows 10 and later versions. Please see the [setup](#setup) section for more information on how to use it.

> [!WARNING]  
> This project is in a very early stage of development and is not yet ready for production use. It is intended for educational purposes and to demonstrate the concepts of a defensive hypervisor.
> The project has been tested on the latest Windows 10, and while it should work on Windows 11, it has not been tested on that version yet.

## Usage

To use the NovaHypervisor, you will need to create a kernel service and start it:

```cmd
sc create NovaHypervisor type= kernel binPath= "C:\Path\To\NovaHypervisor.sys"

sc start NovaHypervisor
```

Then, you can add and remove the addresses that you want to protect using the [NovaClient](./NovaClient/) application:

```cmd
REM Add an address to protect
NovaClient.exe protect 0x12345678 <r|w|x> <execution hook>

REM Remove an address from protection
NovaClient.exe unprotect 0x12345678
```

- protect: Protect a memory address from being accessed, you can specify the type of protection:
  - `r`: Read protection
  - `w`: Write protection
  - `x`: Execute protection
The protection that you give is the protection that the address will **have**. For example, if you want to remove execute privileges, do "rw".

- unprotect: Remove protection from a memory address.

> [!NOTE]
> Execution hook via inline hook + EPT hooks are not supported and will not be supported for this project to prevent abuse.

## Setup

### Compiling the Project

The setup to compile the project requires you to have:

- Visual Studio 2022 or later.
- Windows Driver Kit (WDK) installed.

### Target setup

To run the hypervisor, you will need to have a Windows 10 or later version installed on your machine. You will also need to have:

- Intel VT-x enabled.
- Virtualized IOMMU.

## Logging and Debugging

### Logging

NovaHypervisor uses [WPP](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/wpp-software-tracing) logging as it provides easy to use interface that works also in VMX root. To be able to see the logs, make sure to create a trace session once:

```cmd
logman create trace "NovaHypervisorLogs" -p {e74c1035-77d4-4c5b-9088-77056fae3aa3} 0xffffffff 0xff -o C:\Path\To\NovaHypervisor.etl
```

Later on, whenever you want to start or end the logging session you can use:

```cmd
logman start "NovaHypervisorLogs"
logman stop "NovaHypervisorLogs"
```

To view the logs you can use tools such as [TraceView](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/traceview).

### Debugging

To test and debug it in your testing environment run those commands with elevated cmd and then restart your machine:

```cmd
bcdedit /set testsigning on
bcdedit /debug on
bcdedit /dbgsettings net hostip:<HOSTIP> port:55000 key:1.2.3.4
```

Where `<HOSTIP>` is the IP address of your host machine.

## Resources

[Hypervisor From Scratch](https://rayanfam.com/topics/hypervisor-from-scratch-part-1/)

[HyperDbg](https://github.com/HyperDbg/HyperDbg)

## Personal Thanks & Contributors

- [Sinaei](https://x.com/Intel80x86): For his help with answering questions I had and for his amazing work on HyperDbg and Hypervisor From Scratch.

- [memN0ps](https://github.com/memN0ps/): For his help with answering questions I had and pointing me to the right resources.

```