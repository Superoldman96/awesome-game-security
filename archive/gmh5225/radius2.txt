Project Path: arc_gmh5225_radius2_x098et3x

Source Tree:

```txt
arc_gmh5225_radius2_x098et3x
├── Cargo.toml
├── LICENSE
├── README.md
├── dist
│   └── debian
│       ├── CONFIG
│       ├── DESCR
│       ├── Makefile
│       └── deb.mk
├── examples
│   ├── ais3
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── babyre
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── dex
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── frida
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── ollvm
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── r100
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── r200
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── statically-linked
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── tracer
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   └── unbreakable
│       ├── Cargo.toml
│       └── src
│           └── main.rs
├── radius
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── README.md
│   └── src
│       ├── lib.rs
│       ├── main.rs
│       ├── memory.rs
│       ├── operations.rs
│       ├── processor.rs
│       ├── r2_api.rs
│       ├── radius.rs
│       ├── registers.rs
│       ├── sims
│       │   ├── cpp.rs
│       │   ├── format.rs
│       │   ├── fs.rs
│       │   ├── libc.rs
│       │   ├── mod.rs
│       │   ├── net.rs
│       │   ├── objc.rs
│       │   ├── syscall.rs
│       │   └── win.rs
│       ├── solver.rs
│       ├── state.rs
│       ├── test.rs
│       └── value.rs
├── radius2.md
└── tests
    ├── ais3
    ├── baby-re
    ├── escrackme.apk
    ├── fairlight
    ├── fileread
    ├── hello
    ├── hello.c
    ├── ioscrackme.ipa
    ├── looper
    ├── looper.c
    ├── multi
    ├── multi32
    ├── ollvm
    ├── r100
    ├── r200
    ├── simple
    ├── statically-linked
    ├── strstuff
    ├── strstuff.c
    ├── symmem
    ├── sys
    ├── sys.c
    └── unbreakable

```

`Cargo.toml`:

```toml
[workspace]
resolver = "2"

members = [
    "radius",
    "examples/ais3",
    "examples/r100",
    "examples/r200",
    "examples/unbreakable",
    "examples/dex",
    "examples/babyre",
    "examples/frida",
    "examples/tracer",
    "examples/ollvm",
    "examples/statically-linked"
]

[profile.release]
lto = true
opt-level=3

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Austin Emmitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
## radius2 - fas
```

`dist/debian/CONFIG`:

```
PACKAGE=radius
ARCH=amd64
DEPENDS=radare2
SECTION=user/shell
PRIORITY=optional
MAINTAINER=Austin Aemmitt <aemmitt@nowsecure.com>

VERSION=$(shell cat ../../radius/Cargo.toml| grep ^version | cut -d '"' -f2)

#include ../../config.mk

```

`dist/debian/DESCR`:

```
symbolic execution plugin for radare2
radius is a fast binary emulation and symbolic execution framework using radare2

```

`dist/debian/Makefile`:

```
include ./CONFIG

UNAME=$(shell uname)
SUDO?=sudo
DEPENDS=
CROSSARCH=x64
PWD=$(shell pwd)
PACKAGE_DIR?=${PWD}

R2_VERSION=$(shell r2 -qv)

DOCKCROSS=$(PWD)/../dockcross

#R2PLUGDIR=$(shell r2 -H R2_LIBR_PLUGINS)
#R2PLUGDIR=/usr/lib/radare2/$(R2_VERSION)

R2_LIBEXT=$(shell r2 -H R2_LIBEXT)

ifeq ($(R2_LIBEXT),)
error:
	@echo "Cannot find r2"
endif

all: root
	$(SUDO) rm -rf control data
	$(MAKE) clean
	mkdir -p data
	cp -rf root/* data
	$(MAKE) control
	$(MAKE) deb

root:
	cd ../../ && cargo build --release
	mkdir -p root/usr/bin
	cp -f ../../target/release/radius2 root/usr/bin/radius2

purge: clean
	rm -rf root

summary:
	echo $(VERSION)

include deb.mk

```

`dist/debian/deb.mk`:

```mk
# Create .deb without using dpkg tools.
#
# Author: Tim Wegener <twegener@madabar.com>
#
# Use 'include deb_hand.mak' after defining the user variables in a local
# makefile.
#
# The 'data' rule must be customised in the local make file.
# This rule should make a 'data' directory containing the full file
# layout of the installed package.
#
# This makefile will create a debian-binary file a control directory and a
# a build directory in the current directory.
# Do 'make clobber' to remove these generated files.
#
# Destination:
# PACKAGE_DIR - directory where package (and support files) will be built
#               defaults to the current directory
#
# Sources:
# SOURCE_DIR - directory containing files to be packaged
# ICON_SOURCE - 26x26 icon file for maemo
# DESCR - description with summary on first line
# preinst, postinst, prerm, postrm - optional control shell scripts

# These fields are used to build the control file:
# PACKAGE = 
# VERSION = 
# ARCH = 
# SECTION = 
# PRIORITY = 
# MAINTAINER = 
# DEPENDS = 
#
# SOURCE_DIR =
# ICON_SOURCE = 
# (ICON_SOURCE is optional)

# *** NO USER CHANGES REQUIRED BEYOND THIS POINT ***
ifeq ($(shell uname),Darwin)
MD5SUM=md5
else
MD5SUM=md5sum
endif

GAWK=awk
PACKAGE_DIR=$(shell pwd)
CONTROL_EXTRAS ?= ${wildcard preinst postinst prerm postrm}

${PACKAGE_DIR}/control: ${PACKAGE_DIR}/data ${CONTROL_EXTRAS} DESCR \
			${ICON_SOURCE}
	#rm -rf $@
	mkdir -p $@
ifneq (${CONTROL_EXTRAS},)
	cp ${CONTROL_EXTRAS} $@
endif
#       Make control file.
	echo "Package: ${PACKAGE}" > $@/control
	echo "Version: ${VERSION}" >> $@/control
	echo "Section: ${SECTION}" >> $@/control
	echo "Priority: ${PRIORITY}" >> $@/control
	echo "Architecture: ${ARCH}" >> $@/control
ifneq (${DEPENDS},)
	echo "Depends: ${DEPENDS}" >> $@/control
endif
	echo "Installed-Size: ${shell du -s ${PACKAGE_DIR}/data|cut -f1}" \
		>> $@/control
	echo "Maintainer: ${MAINTAINER}" >> $@/control
	printf "Description:" >> $@/control
	cat DESCR | ${GAWK} '{print " "$$0;}' >> $@/control
#ifneq (${ICON_SOURCE},)
#	echo "Maemo-Icon-26:" >> $@/control
#	base64 ${ICON_SOURCE} | ${GAWK} '{print " "$$0;}' >> $@/control
#endif
#       Make md5sums.
	cd ${PACKAGE_DIR}/data && find . -type f -exec ${MD5SUM} {} \; \
		| sed -e 's| \./||' \
		> $@/md5sums

${PACKAGE_DIR}/debian-binary:
	echo "2.0" > $@

${PACKAGE_DIR}/clean:
	rm -rf ${PACKAGE_DIR}/data ${PACKAGE_DIR}/control ${PACKAGE_DIR}/build *.deb

${PACKAGE_DIR}/build: ${PACKAGE_DIR}/debian-binary ${PACKAGE_DIR}/control \
			${PACKAGE_DIR}/data
	rm -rf $@
	mkdir $@
	cp ${PACKAGE_DIR}/debian-binary $@/
	cd ${PACKAGE_DIR}/control && tar czvf $@/control.tar.gz *
	cd ${PACKAGE_DIR}/data && \
		COPY_EXTENDED_ATTRIBUTES_DISABLE=true \
		COPYFILE_DISABLE=true \
		tar cpzvf $@/data.tar.gz *

# Convert GNU ar to BSD ar that debian requires.
# Note: Order of files within ar archive is important!
${PACKAGE_DIR}/${PACKAGE}_${VERSION}_${ARCH}.deb: ${PACKAGE_DIR}/build
	ar -rc $@ $</debian-binary $</control.tar.gz $</data.tar.gz
	#sed -e 's|^\([^/]\+\)/ \(.*\)|\1  \2|g' $@tmp > $@fail
	#rm -f $@tmp
	#mv $@fail $@

.PHONY: data
data: ${PACKAGE_DIR}/data

.PHONY: control
control: ${PACKAGE_DIR}/control

.PHONY: build
build: ${PACKAGE_DIR}/build

.PHONY: clean
clean: ${PACKAGE_DIR}/clean $(EXTRA_CLEAN)
	rm -f debian-binary

.PHONY: deb
deb: ${PACKAGE_DIR}/${PACKAGE}_${VERSION}_${ARCH}.deb


clobber::
	rm -rf ${PACKAGE_DIR}/debian_binary ${PACKAGE_DIR}/control \
		${PACKAGE_DIR}/data ${PACKAGE_DIR}/build

push:
	scp *.deb radare.org:/srv/http/radareorg/cydia/debs

mrproper: clean
	rm -rf root

```

`examples/ais3/Cargo.toml`:

```toml
[package]
name = "ais3"
version = "0.1.0"
authors = ["aemmitt <aemmitt@nowsecure.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
radius2 = { path = "../../radius" }
```

`examples/ais3/src/main.rs`:

```rs
use radius2::{Radius, RadiusOption};

fn main() {
    let options = vec![RadiusOption::Permissions(true)];
    let mut radius = Radius::new_with_options(Some("tests/ais3"), &options);
    //let verify = radius.get_address("sym.verify").unwrap();
    let mut state = radius.call_state(0x004005f6);
    let addr: u64 = 0xfff00000;
    let flag_val = state.symbolic_value("flag", 24 * 8);
    state.memory.write_value(addr, &flag_val, 24);
    state.registers.set("rax", state.concrete_value(addr, 64));

    radius.breakpoint(0x00400602);
    radius.avoid(&[0x0040060e]);
    let new_state = radius.run(state, 1);
    //println!("{:?}", radius.processor.crashes[0].status);
    let flag = new_state.unwrap().evaluate_string(&flag_val).unwrap();
    println!("FLAG: {}", flag);
}

```

`examples/babyre/Cargo.toml`:

```toml
[package]
name = "babyre"
version = "0.1.0"
authors = ["aemmitt <aemmitt@nowsecure.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
radius2 = { path = "../../radius" }
```

`examples/babyre/src/main.rs`:

```rs
use radius2::state::State;
use radius2::value::Value;
use radius2::sims::Sim;
use radius2::{Radius, RadiusOption};

// simulates the scanf("%d", dst) calls with sym inputs
fn scanf_sim(state: &mut State, args: &[Value]) -> Value {
    let input_len = state
        .context
        .entry("ints".to_owned())
        .or_insert_with(Vec::new)
        .len();

    let new_int = state.symbolic_value(&format!("int{}", input_len), 32);
    state.memory_write_value(&args[1], &new_int, 4);
    state.context.get_mut("ints").unwrap().push(new_int);
    state.concrete_value(1, 64)
}

fn main() {
    // runs better without opt and default sims
    let options = [RadiusOption::Optimize(false), RadiusOption::Sims(false)];
    let mut radius = Radius::new_with_options(Some("tests/baby-re"), &options);
    let main = radius.get_address("main").unwrap();
    let scanf = radius.get_address("sym.imp.__isoc99_scanf").unwrap();

    // register the custom sim
    radius.simulate(scanf, Sim{
        symbol: "scanf".to_owned(),
        function: scanf_sim,
        arguments: 2 
    });

    let state = radius.call_state(main); // start at main
    let new_state = radius.run_until(state, 0x004028e9, &[0x00402941]).unwrap();

    // solving takes the majority of the ~5 sec runtime
    let mut flag_bytes = vec![]; // the hook writes the flag bytes, collect them
    for input in new_state.context.get("ints").unwrap() {
        flag_bytes.push(new_state.solver.eval_to_u64(&input).unwrap() as u8);
    }
    let flag = String::from_utf8(flag_bytes).unwrap();

    println!("FLAG: {}", flag);
    assert_eq!(flag, "Math is hard!");
}

```

`examples/dex/Cargo.toml`:

```toml
[package]
name = "dex"
version = "0.1.0"
authors = ["aemmitt <aemmitt@nowsecure.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

radius2 = { path = "../../radius" }
```

`examples/dex/src/main.rs`:

```rs
use radius2::{Radius, RadiusOption};

fn main() {
    let options = [RadiusOption::Debug(true), RadiusOption::Sims(false)];
    let mut radius = Radius::new_with_options(Some("apk://tests/escrackme.apk"), &options);
    let mut state = radius.call_state(0x001bd1cc);
    let bv = state.symbolic_value("flag", 32);

    state.registers.set("v7", bv.clone());
    let mut new_state = radius.run_until(state, 0x001bd21e, &[]).unwrap();
    let flag = new_state.eval(&bv).unwrap().as_u64().unwrap();

    println!("FLAG: {:x}", flag);
    assert_eq!(flag, 0xcafebabe);
}

```

`examples/frida/Cargo.toml`:

```toml
[package]
name = "frida"
version = "0.1.0"
authors = ["aemmitt <aemmitt@nowsecure.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
radius2 = { path = "../../radius" }
```

`examples/frida/src/main.rs`:

```rs
use radius2::value::Value;
use radius2::{Radius, RadiusOption};

fn main() {
    let options = [
        RadiusOption::Debug(true),
        RadiusOption::Sims(false),
        RadiusOption::LoadPlugins(true),
    ];

    let mut radius = Radius::new_with_options(Some("frida://attach/usb//iOSCrackMe"), &options);

    // turn off cache to write value back to real mem
    radius.set_option("io.cache", "false");
    let validate = radius.get_address("validate").unwrap();
    let mut state = radius.frida_state(validate); // hook addr and suspend when hit

    let len: usize = 16;
    let bv = state.bv("flag", 8 * len as u32);

    // add "[a-zA-Z]" constraint
    state.constrain_bytes_bv(&bv, "[a-zA-Z]");
    let buf_addr = state.registers.get("x0");
    state.memory_write_value(&buf_addr, &Value::Symbolic(bv.clone(), 0), len);

    let mut new_state = radius
        .run_until(state, validate + 0x210, &[validate + 0x218])
        .unwrap();

    let flag = new_state.evaluate_string_bv(&bv).unwrap();
    println!("FLAG: {}", flag);

    // write solution back to app memory
    radius.write_string(buf_addr.as_u64().unwrap(), &flag);
    radius.close(); // closing lets app continue
}

```

`examples/ollvm/Cargo.toml`:

```toml
[package]
name = "ollvm"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
radius2 = { path = "../../radius" }
```

`examples/ollvm/src/main.rs`:

```rs
use radius2::{Radius, State, vc};
use std::io::{self, Write};

// output: 
// FLAG: mirror_mirror_on_the_wall_whos_the_ugliest_handler_of_them_all?!
// target/release/ollvm  0.80s user 0.06s system 99% cpu 0.869 total

const HASHES:[u64; 8] = [
    0x875cd4f2e18f8fc4, 0xbb093e17e5d3fa42, 
    0xada5dd034aae16b4, 0x97322728fea51225,
    0x4124799d72188d0d, 0x2b3e3fbbb4d44981, 
    0xdfcac668321e4daa, 0xeac2137a35c8923a
];

fn main() {
    let mut radius = Radius::new("tests/ollvm");
    fn flag_hook(state: &mut State) -> bool {
        state.registers.set("rax", state.context["flag"][0].clone()); 
        true
    }
    radius.hook(0x00400899, flag_hook);

    let main = radius.get_address("main").unwrap();
    let mut state = radius.call_state(main);
    radius.set_argv_env(&mut state, &[vc(0x58), vc(0x31)], &[]);
    let flag = state.symbolic_value("flag", 64);
    state.context.insert("flag".to_owned(), vec!(flag.clone()));

    let mut end_state = radius.run(state, 1).unwrap();
    let rcx = end_state.registers.get("rcx");

    print!("FLAG: ");
    io::stdout().flush().unwrap();

    for hash in HASHES {
        end_state.solver.push();
        end_state.assert(&rcx.eq(&vc(hash)));
        let reved = end_state.evaluate_string(&flag).unwrap();
        print!("{}", &reved.chars().rev().collect::<String>());
        end_state.solver.pop();
        io::stdout().flush().unwrap();
    }
    println!();
}

```

`examples/r100/Cargo.toml`:

```toml
[package]
name = "r100"
version = "0.1.0"
authors = ["aemmitt <aemmitt@nowsecure.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
radius2 = { path = "../../radius" }
```

`examples/r100/src/main.rs`:

```rs
use radius2::Radius;

fn main() {
    let mut radius = Radius::new("tests/r100");
    let mut state = radius.call_state(0x004006fd);
    let addr: u64 = 0x100000;
    let flag_val = state.symbolic_value("flag", 12 * 8);
    state.memory.write_value(addr, &flag_val, 12);
    state.registers.set("rdi", state.concrete_value(addr, 64));

    radius.breakpoint(0x004007a1);
    radius.avoid(&[0x00400790]);
    let mut new_state = radius.run(state, 1).unwrap();
    let flag = new_state.evaluate_string(&flag_val).unwrap();
    println!("FLAG: {}", flag);
    assert_eq!(flag, "Code_Talkers");
}

```

`examples/r200/Cargo.toml`:

```toml
[package]
name = "r200"
version = "0.1.0"
authors = ["aemmitt <aemmitt@nowsecure.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
radius2 = { path = "../../radius" }
```

`examples/r200/src/main.rs`:

```rs
use radius2::Radius;

fn main() {
    let mut radius = Radius::new("tests/r200");
    let mut state = radius.call_state(0x00400886);
    let bv = state.symbolic_value("flag", 6 * 8);

    let addr = state.registers.get("rsp").as_u64().unwrap();
    state.memory.write_value(addr - 0x18, &bv, 6);

    radius.breakpoint(0x00400843);
    radius.mergepoint(0x004007fd);
    radius.avoid(&[0x00400832]);

    let mut new_state = radius.run(state, 1).unwrap();
    let flag = new_state.evaluate_string(&bv).unwrap();
    println!("FLAG: {}", flag);
    assert_eq!(flag, "rotors");
}

```

`examples/statically-linked/Cargo.toml`:

```toml
[package]
name = "statically-linked"
version = "0.1.0"
authors = ["Lennard Hofmann <lennard.hofmann@web.de>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
radius2 = { path = "../../radius" }

```

`examples/statically-linked/src/main.rs`:

```rs
use radius2::{vc, Radius, RadiusOption};

fn main() {
    let mut radius = Radius::new_with_options(
        Some("tests/statically-linked"),
        &[RadiusOption::Debug(true)],
    );

    // Hooking library functions can save a lot of time
    radius.assign_sim(0x40145e, "strcmp");

    let mut state = radius.call_state(0x40102b); // start at main
    let flag = state.symbolic_value("flag", 15 * 8); // flag is 15 bytes long
    radius.set_argv_env(&mut state, &[vc(0), flag.clone()], &[]); // argv[1] = flag
    radius.avoid(&[0x401047]);

    let mut desired_state = radius.run(state, 1).unwrap();
    println!("flag: {}", desired_state.evaluate_string(&flag).unwrap());
}

```

`examples/tracer/Cargo.toml`:

```toml
[package]
name = "tracer"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
radius2 = { path = "../../radius" }
```

`examples/tracer/src/main.rs`:

```rs
use radius2::{Radius, RadiusOption};
use radius2::state::StateStatus;
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    let options = [RadiusOption::Debug(true), RadiusOption::Sims(false)];
    let mut radius = Radius::new_with_options(Some(args[1].to_owned()), &options);
    let addr = radius.get_address(&args[2]).unwrap_or_default();
    let mut state = radius.debug_state(addr, &args[3..]);
    let mut prev = radius.r2api.cmd("dr").unwrap();
    let mut cont = true;
    
    while state.status == StateStatus::Active && cont {
        for register in &state.registers.indexes {
            let reg = &register.reg_info;
            if reg.type_str == "gpr" || reg.type_str == "flg" {
                let name = reg.name.to_owned();
                let dbg_value = radius.r2api.get_register_value(&name).unwrap();
                let rad_value = state.registers.get(&name).as_u64().unwrap();
                if dbg_value != rad_value {
                    println!("{} {:x} {:x}", name, dbg_value, rad_value);
                    cont = reg.type_str == "flg"; // continue for flags
                } 
            }
        }
        if cont {
            prev = radius.r2api.cmd("dr;ds").unwrap();
            radius.processor.step(&mut state);
        } else {
            println!("\nprevious:\n{}", prev);
            println!("\ncurrent:\n{}", radius.r2api.cmd("dr").unwrap());
        }
    }
}

```

`examples/unbreakable/Cargo.toml`:

```toml
[package]
name = "unbreakable"
version = "0.1.0"
authors = ["aemmitt <aemmitt@nowsecure.com>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
radius2 = { path = "../../radius" }
```

`examples/unbreakable/src/main.rs`:

```rs
use radius2::Radius;

fn main() {
    let mut radius = Radius::new("tests/unbreakable");
    let mut state = radius.call_state(0x004005bd);
    let len: usize = 0x33;
    let bv = state.symbolic_value("flag", 8 * len as u32);

    // add "CTF{" constraint
    state.constrain_bytes(&bv, "CTF{");

    let addr: u64 = 0x6042c0;
    state.memory.write_value(addr, &bv, len);
    let new_state = radius.run_until(state, 0x00400830, &[0x00400850]);
    let flag = new_state.unwrap().evaluate_string(&bv).unwrap();

    println!("FLAG: {}", flag);
    assert_eq!(flag, "CTF{0The1Quick2Brown3Fox4Jumped5Over6The7Lazy8Fox9}");
}

```

`radius/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
[[package]]
name = "addr2line"
version = "0.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03345e98af8f3d786b6d9f656ccfa6ac316d954e92bc4841f0bba20789d5fb5a"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "autocfg"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2"

[[package]]
name = "autocfg"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a"

[[package]]
name = "backtrace"
version = "0.3.59"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4717cfcbfaa661a0fd48f8453951837ae7e8f81e481fbb136e3202d72805a744"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if 1.0.0",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "base64"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b25d992356d2eb0ed82172f5248873db5560c4721f564b13cb5193bda5e668e"
dependencies = [
 "byteorder",
]

[[package]]
name = "bitflags"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693"

[[package]]
name = "boolector"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dc3b440a0cd770e8cd01c982f22d3d7f087eec4558c47e2cb37c440f1fe04aa"
dependencies = [
 "boolector-sys",
 "libc",
]

[[package]]
name = "boolector-sys"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b087a617403133ccedd30ae4bc03fa6dde621ae30a5285a0335f0ac1ca927c7"
dependencies = [
 "cc",
 "cmake",
 "copy_dir",
 "libc",
]

[[package]]
name = "byteorder"
version = "1.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"

[[package]]
name = "bytes"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "206fdffcfa2df7cbe15601ef46c813fce0965eb3286db6b56c583b814b51c81c"
dependencies = [
 "byteorder",
 "either",
 "iovec",
]

[[package]]
name = "cc"
version = "1.0.68"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a72c244c1ff497a746a7e1fb3d14bd08420ecda70c8f25c7112f2781652d787"

[[package]]
name = "cfg-if"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cloudabi"
version = "0.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f"
dependencies = [
 "bitflags",
]

[[package]]
name = "cmake"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb6210b637171dfba4cda12e579ac6dc73f5165ad56133e5d72ef3131f320855"
dependencies = [
 "cc",
]

[[package]]
name = "cookie"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "888604f00b3db336d2af898ec3c1d5d0ddf5e6d462220f2ededc33a87ac4bbd5"
dependencies = [
 "time",
 "url 1.7.2",
]

[[package]]
name = "cookie_store"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46750b3f362965f197996c4448e4a0935e791bf7d6631bfce9ee0af3d24c919c"
dependencies = [
 "cookie",
 "failure",
 "idna 0.1.5",
 "log",
 "publicsuffix",
 "serde",
 "serde_json",
 "time",
 "try_from",
 "url 1.7.2",
]

[[package]]
name = "copy_dir"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e4281031634644843bd2f5aa9c48cf98fc48d6b083bd90bb11becf10deaf8b0"
dependencies = [
 "walkdir",
]

[[package]]
name = "core-foundation"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a89e2ae426ea83155dccf10c0fa6b1463ef6d5fcb44cee0b224a408fa640a62"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea221b5284a47e40033bf9b66f35f984ec0ea2931eb03505246cd27a963f981b"

[[package]]
name = "crc32fast"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81156fece84ab6a9f2afdb109ce3ae577e42b1228441eded99bd77f627953b1a"
dependencies = [
 "cfg-if 1.0.0",
]

[[package]]
name = "crossbeam-deque"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9f02af974daeee82218205558e51ec8768b48cf524bd01d550abe5573a608285"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
 "maybe-uninit",
]

[[package]]
name = "crossbeam-epoch"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "058ed274caafc1f60c4997b5fc07bf7dc7cca454af7c6e81edffe5f33f70dace"
dependencies = [
 "autocfg 1.0.1",
 "cfg-if 0.1.10",
 "crossbeam-utils",
 "lazy_static",
 "maybe-uninit",
 "memoffset",
 "scopeguard",
]

[[package]]
name = "crossbeam-queue"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "774ba60a54c213d409d5353bda12d49cd68d14e45036a285234c8d6f91f92570"
dependencies = [
 "cfg-if 0.1.10",
 "crossbeam-utils",
 "maybe-uninit",
]

[[package]]
name = "crossbeam-utils"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3c7c73a2d1e9fc0886a08b93e98eb643461230d5f1925e4036204d5f2e261a8"
dependencies = [
 "autocfg 1.0.1",
 "cfg-if 0.1.10",
 "lazy_static",
]

[[package]]
name = "dtoa"
version = "0.4.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56899898ce76aaf4a0f24d914c97ea6ed976d42fec6ad33fcbb0a1103e07b2b0"

[[package]]
name = "either"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e78d4f1cc4ae33bbfc157ed5d5a5ef3bc29227303d595861deb238fcec4e9457"

[[package]]
name = "encoding_rs"
version = "0.8.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80df024fbc5ac80f87dfef0d9f5209a252f2a497f7f42944cff24d8253cac065"
dependencies = [
 "cfg-if 1.0.0",
]

[[package]]
name = "failure"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d32e9bd16cc02eae7db7ef620b392808b89f6a5e16bb3497d159c6b92a0f4f86"
dependencies = [
 "backtrace",
 "failure_derive",
]

[[package]]
name = "failure_derive"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa4da3c766cd7a0db8242e326e9e4e081edd567072893ed320008189715366a4"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "flate2"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd3aec53de10fe96d7d8c565eb17f2c687bb5518a2ec453b5b1252964526abe0"
dependencies = [
 "cfg-if 1.0.0",
 "crc32fast",
 "libc",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5fc25a87fa4fd2094bffb06925852034d90a17f0d1e05197d4956d3555752191"
dependencies = [
 "matches",
 "percent-encoding 2.1.0",
]

[[package]]
name = "fuchsia-cprng"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba"

[[package]]
name = "fuchsia-zircon"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82"
dependencies = [
 "bitflags",
 "fuchsia-zircon-sys",
]

[[package]]
name = "fuchsia-zircon-sys"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7"

[[package]]
name = "futures"
version = "0.1.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a471a38ef8ed83cd6e40aa59c1ffe17db6855c18e3604d9c4ed8c08ebc28678"

[[package]]
name = "futures-cpupool"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab90cde24b3319636588d0c35fe03b1333857621051837ed769faefb4c2162e4"
dependencies = [
 "futures",
 "num_cpus",
]

[[package]]
name = "getrandom"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753"
dependencies = [
 "cfg-if 1.0.0",
 "libc",
 "wasi",
]

[[package]]
name = "gimli"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e4075386626662786ddb0ec9081e7c7eeb1ba31951f447ca780ef9f5d568189"

[[package]]
name = "h2"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5b34c246847f938a410a03c5458c7fee2274436675e76d8b903c08efc29c462"
dependencies = [
 "byteorder",
 "bytes",
 "fnv",
 "futures",
 "http",
 "indexmap",
 "log",
 "slab",
 "string",
 "tokio-io",
]

[[package]]
name = "hashbrown"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04"

[[package]]
name = "hermit-abi"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "322f4de77956e22ed0e5032c359a0f1273f1f7f0d79bfa3b8ffbc730d7fbcc5c"
dependencies = [
 "libc",
]

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "http"
version = "0.1.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6ccf5ede3a895d8856620237b2f02972c1bbc78d2965ad7fe8838d4a0ed41f0"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6741c859c1b2463a423a1dbce98d418e6c3c3fc720fb0d45528657320920292d"
dependencies = [
 "bytes",
 "futures",
 "http",
 "tokio-buf",
]

[[package]]
name = "httparse"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3a87b616e37e93c22fb19bcd386f02f3af5ea98a25670ad0fce773de23c5e68"

[[package]]
name = "hyper"
version = "0.12.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c843caf6296fc1f93444735205af9ed4e109a539005abb2564ae1d6fad34c52"
dependencies = [
 "bytes",
 "futures",
 "futures-cpupool",
 "h2",
 "http",
 "http-body",
 "httparse",
 "iovec",
 "itoa",
 "log",
 "net2",
 "rustc_version",
 "time",
 "tokio",
 "tokio-buf",
 "tokio-executor",
 "tokio-io",
 "tokio-reactor",
 "tokio-tcp",
 "tokio-threadpool",
 "tokio-timer",
 "want",
]

[[package]]
name = "hyper-tls"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a800d6aa50af4b5850b2b0f659625ce9504df908e9733b635720483be26174f"
dependencies = [
 "bytes",
 "futures",
 "hyper",
 "native-tls",
 "tokio-io",
]

[[package]]
name = "idna"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e"
dependencies = [
 "matches",
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "idna"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "418a0a6fab821475f634efe3ccc45c013f742efe03d853e8d3355d5cb850ecf8"
dependencies = [
 "matches",
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "indexmap"
version = "1.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "824845a0bf897a9042383849b02c1bc219c2383772efcd5c6f9766fa4b81aef3"
dependencies = [
 "autocfg 1.0.1",
 "hashbrown",
]

[[package]]
name = "iovec"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2b3ea6ff95e175473f8ffe6a7eb7c00d054240321b84c57051175fe3c1e075e"
dependencies = [
 "libc",
]

[[package]]
name = "itoa"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd25036021b0de88a0aff6b850051563c6516d0bf53f8638938edbb9de732736"

[[package]]
name = "kernel32-sys"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d"
dependencies = [
 "winapi 0.2.8",
 "winapi-build",
]

[[package]]
name = "lazy_static"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"

[[package]]
name = "libc"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "789da6d93f1b866ffe175afc5322a4d76c038605a1c3319bb57b06967ca98a36"

[[package]]
name = "lock_api"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4da24a77a3d8a6d4862d95f72e6fdb9c09a643ecdb402d754004a557f2bec75"
dependencies = [
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710"
dependencies = [
 "cfg-if 1.0.0",
]

[[package]]
name = "matches"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08"

[[package]]
name = "maybe-uninit"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60302e4db3a61da70c0cb7991976248362f30319e88850c487b9b95bbf059e00"

[[package]]
name = "memoffset"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "043175f069eda7b85febe4a74abbaeff828d9f8b448515d3151a14a3542811aa"
dependencies = [
 "autocfg 1.0.1",
]

[[package]]
name = "mime"
version = "0.3.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a60c7ce501c71e03a9c9c0d35b861413ae925bd979cc7a4e30d060069aaac8d"

[[package]]
name = "mime_guess"
version = "2.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2684d4c2e97d99848d30b324b00c8fcc7e5c897b7cbb5819b09e7c90e8baf212"
dependencies = [
 "mime",
 "unicase",
]

[[package]]
name = "miniz_oxide"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a92518e98c078586bc6c934028adcca4c92a53d6a958196de835170a01d84e4b"
dependencies = [
 "adler",
 "autocfg 1.0.1",
]

[[package]]
name = "mio"
version = "0.6.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4afd66f5b91bf2a3bc13fad0e21caedac168ca4c707504e75585648ae80e4cc4"
dependencies = [
 "cfg-if 0.1.10",
 "fuchsia-zircon",
 "fuchsia-zircon-sys",
 "iovec",
 "kernel32-sys",
 "libc",
 "log",
 "miow",
 "net2",
 "slab",
 "winapi 0.2.8",
]

[[package]]
name = "miow"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebd808424166322d4a38da87083bfddd3ac4c131334ed55856112eb06d46944d"
dependencies = [
 "kernel32-sys",
 "net2",
 "winapi 0.2.8",
 "ws2_32-sys",
]

[[package]]
name = "native-tls"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8d96b2e1c8da3957d58100b09f102c6d9cfdfced01b7ec5a8974044bb09dbd4"
dependencies = [
 "lazy_static",
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "net2"
version = "0.2.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "391630d12b68002ae1e25e8f974306474966550ad82dac6886fb8910c19568ae"
dependencies = [
 "cfg-if 0.1.10",
 "libc",
 "winapi 0.3.9",
]

[[package]]
name = "num_cpus"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3"
dependencies = [
 "hermit-abi",
 "libc",
]

[[package]]
name = "object"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a5b3dd1c072ee7963717671d1ca129f1048fda25edea6b752bfc71ac8854170"

[[package]]
name = "once_cell"
version = "1.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af8b08b04175473088b46763e51ee54da5f9a164bc162f615b91bc179dbf15a3"

[[package]]
name = "openssl"
version = "0.10.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d7830286ad6a3973c0f1d9b73738f69c76b739301d0229c4b96501695cbe4c8"
dependencies = [
 "bitflags",
 "cfg-if 1.0.0",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-sys",
]

[[package]]
name = "openssl-probe"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28988d872ab76095a6e6ac88d99b54fd267702734fd7ffe610ca27f533ddb95a"

[[package]]
name = "openssl-sys"
version = "0.9.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6b0d6fb7d80f877617dfcb014e605e2b5ab2fb0afdf27935219bb6bd984cb98"
dependencies = [
 "autocfg 1.0.1",
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "parking_lot"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f842b1982eb6c2fe34036a4fbfb06dd185a3f5c8edfaacdf7d1ea10b07de6252"
dependencies = [
 "lock_api",
 "parking_lot_core",
 "rustc_version",
]

[[package]]
name = "parking_lot_core"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b876b1b9e7ac6e1a74a6da34d25c42e17e8862aa409cbbbdcfc8d86c6f3bc62b"
dependencies = [
 "cfg-if 0.1.10",
 "cloudabi",
 "libc",
 "redox_syscall 0.1.57",
 "rustc_version",
 "smallvec",
 "winapi 0.3.9",
]

[[package]]
name = "percent-encoding"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831"

[[package]]
name = "percent-encoding"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e"

[[package]]
name = "pkg-config"
version = "0.3.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3831453b3449ceb48b6d9c7ad7c96d5ea673e9b470a1dc578c2ce6521230884c"

[[package]]
name = "ppv-lite86"
version = "0.2.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac74c624d6b2d21f425f752262f42188365d7b8ff1aff74c82e45136510a4857"

[[package]]
name = "proc-macro2"
version = "1.0.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0d8caf72986c1a598726adc988bb5984792ef84f5ee5aa50209145ee8077038"
dependencies = [
 "unicode-xid",
]

[[package]]
name = "publicsuffix"
version = "1.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95b4ce31ff0a27d93c8de1849cf58162283752f065a90d508f1105fa6c9a213f"
dependencies = [
 "idna 0.2.3",
 "url 2.2.2",
]

[[package]]
name = "quote"
version = "1.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3d0b9745dc2debf507c8422de05d7226cc1f0644216dfdfead988f9b1ab32a7"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r2pipe"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73dc7feef74ee5fd1e0173baba115fe71182447b1a5e76e72589caf84a6a3dea"
dependencies = [
 "libc",
 "reqwest",
 "serde",
 "serde_derive",
 "serde_json",
]

[[package]]
name = "radius"
version = "0.1.0"
dependencies = [
 "backtrace",
 "boolector",
 "hex",
 "r2pipe",
 "serde",
 "serde_json",
]

[[package]]
name = "rand"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca"
dependencies = [
 "autocfg 0.1.7",
 "libc",
 "rand_chacha 0.1.1",
 "rand_core 0.4.2",
 "rand_hc 0.1.0",
 "rand_isaac",
 "rand_jitter",
 "rand_os",
 "rand_pcg",
 "rand_xorshift",
 "winapi 0.3.9",
]

[[package]]
name = "rand"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ef9e7e66b4468674bfcb0c81af8b7fa0bb154fa9f28eb840da5c447baeb8d7e"
dependencies = [
 "libc",
 "rand_chacha 0.3.0",
 "rand_core 0.6.2",
 "rand_hc 0.3.0",
]

[[package]]
name = "rand_chacha"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef"
dependencies = [
 "autocfg 0.1.7",
 "rand_core 0.3.1",
]

[[package]]
name = "rand_chacha"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e12735cf05c9e10bf21534da50a147b924d555dc7a547c42e6bb2d5b6017ae0d"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.2",
]

[[package]]
name = "rand_core"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b"
dependencies = [
 "rand_core 0.4.2",
]

[[package]]
name = "rand_core"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c33a3c44ca05fa6f1807d8e6743f3824e8509beca625669633be0acbdf509dc"

[[package]]
name = "rand_core"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34cf66eb183df1c5876e2dcf6b13d57340741e8dc255b48e40a26de954d06ae7"
dependencies = [
 "getrandom",
]

[[package]]
name = "rand_hc"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4"
dependencies = [
 "rand_core 0.3.1",
]

[[package]]
name = "rand_hc"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3190ef7066a446f2e7f42e239d161e905420ccab01eb967c9eb27d21b2322a73"
dependencies = [
 "rand_core 0.6.2",
]

[[package]]
name = "rand_isaac"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08"
dependencies = [
 "rand_core 0.3.1",
]

[[package]]
name = "rand_jitter"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1166d5c91dc97b88d1decc3285bb0a99ed84b05cfd0bc2341bdf2d43fc41e39b"
dependencies = [
 "libc",
 "rand_core 0.4.2",
 "winapi 0.3.9",
]

[[package]]
name = "rand_os"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b75f676a1e053fc562eafbb47838d67c84801e38fc1ba459e8f180deabd5071"
dependencies = [
 "cloudabi",
 "fuchsia-cprng",
 "libc",
 "rand_core 0.4.2",
 "rdrand",
 "winapi 0.3.9",
]

[[package]]
name = "rand_pcg"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "abf9b09b01790cfe0364f52bf32995ea3c39f4d2dd011eac241d2914146d0b44"
dependencies = [
 "autocfg 0.1.7",
 "rand_core 0.4.2",
]

[[package]]
name = "rand_xorshift"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbf7e9e623549b0e21f6e97cf8ecf247c1a8fd2e8a992ae265314300b2455d5c"
dependencies = [
 "rand_core 0.3.1",
]

[[package]]
name = "rdrand"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2"
dependencies = [
 "rand_core 0.3.1",
]

[[package]]
name = "redox_syscall"
version = "0.1.57"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41cc0f7e4d5d4544e8861606a285bb08d3e70712ccc7d2b84d7c0ccfaf4b05ce"

[[package]]
name = "redox_syscall"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "742739e41cd49414de871ea5e549afb7e2a3ac77b589bcbebe8c82fab37147fc"
dependencies = [
 "bitflags",
]

[[package]]
name = "remove_dir_all"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acd125665422973a33ac9d3dd2df85edad0f4ae9b00dafb1a05e43a9f5ef8e7"
dependencies = [
 "winapi 0.3.9",
]

[[package]]
name = "reqwest"
version = "0.9.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f88643aea3c1343c804950d7bf983bd2067f5ab59db6d613a08e05572f2714ab"
dependencies = [
 "base64",
 "bytes",
 "cookie",
 "cookie_store",
 "encoding_rs",
 "flate2",
 "futures",
 "http",
 "hyper",
 "hyper-tls",
 "log",
 "mime",
 "mime_guess",
 "native-tls",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "time",
 "tokio",
 "tokio-executor",
 "tokio-io",
 "tokio-threadpool",
 "tokio-timer",
 "url 1.7.2",
 "uuid",
 "winreg",
]

[[package]]
name = "rustc-demangle"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "410f7acf3cb3a44527c5d9546bad4bf4e6c460915d5f9f2fc524498bfe8f70ce"

[[package]]
name = "rustc_version"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"
dependencies = [
 "semver",
]

[[package]]
name = "ryu"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71d301d4193d031abdd79ff7e3dd721168a9572ef3fe51a1517aba235bd8f86e"

[[package]]
name = "schannel"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f05ba609c234e60bee0d547fe94a4c7e9da733d1c962cf6e59efa4cd9c8bc75"
dependencies = [
 "lazy_static",
 "winapi 0.3.9",
]

[[package]]
name = "scopeguard"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"

[[package]]
name = "security-framework"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3670b1d2fdf6084d192bc71ead7aabe6c06aa2ea3fbd9cc3ac111fa5c2b1bd84"
dependencies = [
 "bitflags",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3676258fd3cfe2c9a0ec99ce3038798d847ce3e4bb17746373eb9f0f1ac16339"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "semver"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403"
dependencies = [
 "semver-parser",
]

[[package]]
name = "semver-parser"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3"

[[package]]
name = "serde"
version = "1.0.126"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec7505abeacaec74ae4778d9d9328fe5a5d04253220a85c4ee022239fc996d03"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.126"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "963a7dbc9895aeac7ac90e74f34a5d5261828f79df35cbed41e10189d3804d43"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "799e97dc9fdae36a5c8b8f2cae9ce2ee9fdce2058c57a93e6099d919fd982f79"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "642dd69105886af2efd227f75a520ec9b44a820d65bc133a9131f7d229fd165a"
dependencies = [
 "dtoa",
 "itoa",
 "serde",
 "url 1.7.2",
]

[[package]]
name = "slab"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f173ac3d1a7e3b28003f40de0b5ce7fe2710f9b9dc3fc38664cebee46b3b6527"

[[package]]
name = "smallvec"
version = "0.6.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b97fcaeba89edba30f044a10c6a3cc39df9c3f17d7cd829dd1446cab35f890e0"
dependencies = [
 "maybe-uninit",
]

[[package]]
name = "string"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d24114bfcceb867ca7f71a0d3fe45d45619ec47a6fbfa98cb14e14250bfa5d6d"
dependencies = [
 "bytes",
]

[[package]]
name = "syn"
version = "1.0.72"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1e8cdbefb79a9a5a65e0db8b47b723ee907b7c7f8496c76a1770b5c310bab82"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-xid",
]

[[package]]
name = "synstructure"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b834f2d66f734cb897113e34aaff2f1ab4719ca946f9a7358dba8f8064148701"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "unicode-xid",
]

[[package]]
name = "tempfile"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22"
dependencies = [
 "cfg-if 1.0.0",
 "libc",
 "rand 0.8.3",
 "redox_syscall 0.2.8",
 "remove_dir_all",
 "winapi 0.3.9",
]

[[package]]
name = "time"
version = "0.1.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6db9e6914ab8b1ae1c260a4ae7a49b6c5611b40328a735b21862567685e73255"
dependencies = [
 "libc",
 "wasi",
 "winapi 0.3.9",
]

[[package]]
name = "tinyvec"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b5220f05bb7de7f3f53c7c065e1199b3172696fe2db9f9c4d8ad9b4ee74c342"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cda74da7e1a664f795bb1f8a87ec406fb89a02522cf6e50620d016add6dbbf5c"

[[package]]
name = "tokio"
version = "0.1.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a09c0b5bb588872ab2f09afa13ee6e9dac11e10a0ec9e8e3ba39a5a5d530af6"
dependencies = [
 "bytes",
 "futures",
 "mio",
 "num_cpus",
 "tokio-current-thread",
 "tokio-executor",
 "tokio-io",
 "tokio-reactor",
 "tokio-tcp",
 "tokio-threadpool",
 "tokio-timer",
]

[[package]]
name = "tokio-buf"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fb220f46c53859a4b7ec083e41dec9778ff0b1851c0942b211edb89e0ccdc46"
dependencies = [
 "bytes",
 "either",
 "futures",
]

[[package]]
name = "tokio-current-thread"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1de0e32a83f131e002238d7ccde18211c0a5397f60cbfffcb112868c2e0e20e"
dependencies = [
 "futures",
 "tokio-executor",
]

[[package]]
name = "tokio-executor"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb2d1b8f4548dbf5e1f7818512e9c406860678f29c300cdf0ebac72d1a3a1671"
dependencies = [
 "crossbeam-utils",
 "futures",
]

[[package]]
name = "tokio-io"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57fc868aae093479e3131e3d165c93b1c7474109d13c90ec0dda2a1bbfff0674"
dependencies = [
 "bytes",
 "futures",
 "log",
]

[[package]]
name = "tokio-reactor"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09bc590ec4ba8ba87652da2068d150dcada2cfa2e07faae270a5e0409aa51351"
dependencies = [
 "crossbeam-utils",
 "futures",
 "lazy_static",
 "log",
 "mio",
 "num_cpus",
 "parking_lot",
 "slab",
 "tokio-executor",
 "tokio-io",
 "tokio-sync",
]

[[package]]
name = "tokio-sync"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edfe50152bc8164fcc456dab7891fa9bf8beaf01c5ee7e1dd43a397c3cf87dee"
dependencies = [
 "fnv",
 "futures",
]

[[package]]
name = "tokio-tcp"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "98df18ed66e3b72e742f185882a9e201892407957e45fbff8da17ae7a7c51f72"
dependencies = [
 "bytes",
 "futures",
 "iovec",
 "mio",
 "tokio-io",
 "tokio-reactor",
]

[[package]]
name = "tokio-threadpool"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df720b6581784c118f0eb4310796b12b1d242a7eb95f716a8367855325c25f89"
dependencies = [
 "crossbeam-deque",
 "crossbeam-queue",
 "crossbeam-utils",
 "futures",
 "lazy_static",
 "log",
 "num_cpus",
 "slab",
 "tokio-executor",
]

[[package]]
name = "tokio-timer"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93044f2d313c95ff1cb7809ce9a7a05735b012288a888b62d4434fd58c94f296"
dependencies = [
 "crossbeam-utils",
 "futures",
 "slab",
 "tokio-executor",
]

[[package]]
name = "try-lock"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59547bce71d9c38b83d9c0e92b6066c4253371f15005def0c30d9657f50c7642"

[[package]]
name = "try_from"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "283d3b89e1368717881a9d51dad843cc435380d8109c9e47d38780a324698d8b"
dependencies = [
 "cfg-if 0.1.10",
]

[[package]]
name = "unicase"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6"
dependencies = [
 "version_check",
]

[[package]]
name = "unicode-bidi"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eeb8be209bb1c96b7c177c7420d26e04eccacb0eeae6b980e35fcb74678107e0"
dependencies = [
 "matches",
]

[[package]]
name = "unicode-normalization"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33717dca7ac877f497014e10d73f3acf948c342bee31b5ca7892faf94ccc6b49"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-xid"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ccb82d61f80a663efe1f787a51b16b5a51e3314d6ac365b08639f52387b33f3"

[[package]]
name = "url"
version = "1.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd4e7c0d531266369519a4aa4f399d748bd37043b00bde1e4ff1f60a120b355a"
dependencies = [
 "idna 0.1.5",
 "matches",
 "percent-encoding 1.0.1",
]

[[package]]
name = "url"
version = "2.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a507c383b2d33b5fc35d1861e77e6b383d158b2da5e14fe51b83dfedf6fd578c"
dependencies = [
 "form_urlencoded",
 "idna 0.2.3",
 "matches",
 "percent-encoding 2.1.0",
]

[[package]]
name = "uuid"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90dbc611eb48397705a6b0f6e917da23ae517e4d127123d2cf7674206627d32a"
dependencies = [
 "rand 0.6.5",
]

[[package]]
name = "vcpkg"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "025ce40a007e1907e58d5bc1a594def78e5573bb0b1160bc389634e8f12e4faa"

[[package]]
name = "version_check"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5fecdca9a5291cc2b8dcf7dc02453fee791a280f3743cb0905f8822ae463b3fe"

[[package]]
name = "walkdir"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c66c0b9792f0a765345452775f3adbd28dde9d33f30d13e5dcc5ae17cf6f3780"
dependencies = [
 "kernel32-sys",
 "winapi 0.2.8",
]

[[package]]
name = "want"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6395efa4784b027708f7451087e647ec73cc74f5d9bc2e418404248d679a230"
dependencies = [
 "futures",
 "log",
 "try-lock",
]

[[package]]
name = "wasi"
version = "0.10.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a143597ca7c7793eff794def352d41792a93c481eb1042423ff7ff72ba2c31f"

[[package]]
name = "winapi"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-build"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc"

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "winreg"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2986deb581c4fe11b621998a5e53361efe6b48a151178d0cd9eeffa4dc6acc9"
dependencies = [
 "winapi 0.3.9",
]

[[package]]
name = "ws2_32-sys"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d59cefebd0c892fa2dd6de581e937301d8552cb44489cdff035c6187cb63fa5e"
dependencies = [
 "winapi 0.2.8",
 "winapi-build",
]

```

`radius/Cargo.toml`:

```toml
[package]
name = "radius2"
description = "a fast symbolic execution framework using r2"
version = "1.0.28"
authors = ["aemmitt-ns <aemmitt@nowsecure.com>"]
license = "MIT"
edition = "2018"
keywords = ["symbolic", "execution"]
repository = "https://github.com/aemmitt-ns/radius"
readme = "README.md"

[dependencies]
r2pipe = "0.7.0"
serde_json = "1.0.59"
serde = { version = "1.0.117", features = ["derive"] }
boolector = "0.4.3"
clap = "2.33.3"
rand = "0.8.4"
colored = "2.0.0"

[features]
default = ["boolector/vendor-lgl"]

[package.metadata.docs.rs]
no-default-features = true
```

`radius/README.md`:

```md
## radius2 - fast symbolic execution with r2

[![Rust](https://github.com/radareorg/radius2/actions/workflows/rust.yml/badge.svg)](https://github.com/radareorg/radius2/actions/workflows/rust.yml)

This repository is a continuation of the work from [@aemmitt-ns](https://github.com/aemmitt-ns/radius2) maintained by the [radareorg](https://github.com/radareorg) community.

`radius2` is a fast symbolic execution and taint analysis framework using `radare2` that is focused on covering many different architectures and executable formats. It also strives to be easy to use and has a CLI tool that makes some reversing tasks as easy as adding a symbolic value and setting a string to reach or avoid. Reversing challenges can be solved as easily as the example below. 
```
$ radius2 -p ais3 -s flag 184 -X sorry

  flag : "ais3{I_tak3_g00d_n0t3s}"

```

### Building

Install radare2 with 
```
git clone https://github.com/radareorg/radare2.git
radare2/sys/install.sh 
```

Install radius2 with `cargo install radius2` or include radius2 as a dependency using `radius2 = "1.0.27"`

### Supported Architectures

- **x86**
- **amd64**
- **ARM**
- **AArch64**

### "Supported" Architectures

radius2 also "supports" **MIPS**, **PowerPC**, and **Gameboy** but they are almost entirely untested. Additionally radius2 supports execution of **cBPF** and **eBPF** programs.

radius2 can execute **Dalvik** bytecode only involving static methods and variables. 

Finally there is also a varying amount of support for **6502**, **8051**, **AVR**, **h8300**, **PIC**, **RISCV**, **SH-4**, **V810**, **V850**, **Xtensa**.

Also PCode can be translated to ESIL with r2ghidra with `pdgp` (currently broken, actually maybe fixed now) so potentially more archs could be supported that way.

### Example

```rust
use radius2::{Radius, Value};

fn main() {
    let mut radius = Radius::new("tests/r100");
    let mut state = radius.call_state(0x004006fd);
    let addr: u64 = 0x100000;
    let flag_val = state.symbolic_value("flag", 12 * 8);
    state.memory_write_value(&Value::Concrete(addr, 0), &flag_val, 12);
    state.registers.set("rdi", state.concrete_value(addr, 64));

    radius.breakpoint(0x004007a1);
    radius.avoid(&[0x00400790]);
    let mut new_state = radius.run(state, 1).unwrap();
    let flag = new_state.evaluate_string(&flag_val).unwrap();
    println!("FLAG: {}", flag);
    assert_eq!(flag, "Code_Talkers");
}
```

### radius2 CLI tool

radius2 can also be installed from crates.io and easily included in packages. radius2 also has a CLI tool that can be installed with `cargo install radius2`

```
radius2 1.0.28
Austin Emmitt (@alkalinesec) <alkali@alkalinesecurity.com>
A symbolic execution tool using r2 and boolector

USAGE:
    radius2 [FLAGS] [OPTIONS] --path <path>

FLAGS:
    -M, --automerge    Automatically merge states
    -V, --color        Use color output
        --crash        Execution stops on invalid memory access
    -h, --help         Prints help information
    -j, --json         Output JSON
    -z, --lazy         Evaluate symbolic PC values lazily
    -K, --merge-all    Merge all finished states
        --no-sims      Do not simulate imports
    -N, --no-modify    Disallow self-modifying code (faster sometimes)
        --no-strict    Don't avoid invalid instructions and ESIL
        --plugins      Load r2 plugins
    -P, --profile      Get performance and runtime information
    -2, --stderr       Show stderr output
    -0, --stdin        Use stdin for target program
    -1, --stdout       Show stdout output
        --version      Prints version information
    -v, --verbose      Show verbose / debugging output

OPTIONS:
    -a, --address <address>                   Address to begin execution at
    -A, --arg <arg>...                        Argument for the target program
    -x, --avoid <avoid>...                    Avoid addresses
    -X, --avoid-strings <avoid_strings>...    Avoid code xrefs to strings
    -B, --break-strings <break_strings>...    Breakpoint code xrefs to strings
    -b, --break <breakpoint>...               Breakpoint at some target address
    -c, --constrain <SYMBOL> <EXPR>           Constrain symbol values with string or pattern
    -C, --constrain-after <SYMBOL> <EXPR>     Constrain symbol or file values after execution
        --env <env>...                        Environment variable for the target program
    -e, --eval <ESIL>...                      Evaluate ESIL expression
    -E, --eval-after <ESIL>...                Evaluate ESIL expression after execution
    -f, --file <PATH> <SYMBOL>                Add a symbolic file
    -F, --fuzz <fuzz>                         Generate testcases and write to supplied dir
    -H, --hook <ADDR> <EXPR>                  Hook the provided address with an ESIL expression
    -i, --include <SYMBOL> <EXPR>             Assert symbol contains a string
    -L, --libs <libs>...                      Load libraries from path
        --max <max>                           Maximum number of states to keep at a time
    -m, --merge <merge>...                    Set address as a mergepoint
    -I, --not-include <SYMBOL> <EXPR>         Assert symbol does not contain a string
    -p, --path <path>                         Path to the target binary
    -r, --r2-cmd <CMD>...                     Run r2 command on launch
    -S, --set <REG/ADDR> <VALUE> <BITS>       Set memory or register values
    -s, --symbol <NAME> <BITS>                Create a symbolic value
```

This tool can be used to solve the same `r100` crackme as above like 

```
$ radius2 -p tests/r100 -a 0x4006fd -x 0x400790 -s flag 96 -S A0 0x100000 64 -S 0x100000 flag 96
  flag : "Code_Talkers"
```
Or even more quickly with strings using 

```
$ radius2 -p tests/r100 -s stdin 96 -X Incorrect
  stdin : "Code_Talkers"
```

```

`radius/src/lib.rs`:

```rs
extern crate boolector;
extern crate r2pipe;
extern crate serde_json;

/// Memory used in a program state
pub mod memory;
mod operations;
/// Process the IL to execute instructions
pub mod processor;
/// Interact with the radare2 instance
pub mod r2_api;
/// Start symbolic execution for a given binary
pub mod radius;
/// Registers and their values for a given state
pub mod registers;
/// Simulated libc functions and syscalls
pub mod sims;
/// Utilities for using the SMT solver to evaluate symbolic values
pub mod solver;
/// A program state, containing the registers, memory, and solver context
pub mod state;
mod test;
/// Asbstraction for concrete and symbolic values used during execution
pub mod value;

pub use crate::radius::{Radius, RadiusOption};
pub use crate::registers::Registers;
pub use crate::sims::{Sim, SimMethod};
pub use crate::state::State;
pub use crate::value::{vc, Value};
```

`radius/src/main.rs`:

```rs
use crate::processor::Word;
use crate::r2_api::hex_encode;
use crate::radius::{Radius, RadiusOption, RunMode};
use boolector::BV;
use clap::{App, Arg};
use colored::*;
use std::path::Path;
use std::time::Instant;
use std::{fs, process};

use crate::state::StateStatus;
use crate::value::{Value, vc};

use std::collections::{HashSet, HashMap};
use std::ascii::escape_default;
use std::str;

//use ahash::AHashMap;
//type HashMap<P, Q> = AHashMap<P, Q>;
use serde::{Deserialize, Serialize};
use std::collections::VecDeque;

pub mod memory;
pub mod operations;
pub mod processor;
pub mod r2_api;
pub mod radius;
pub mod registers;
pub mod sims;
pub mod solver;
pub mod state;
pub mod value;

macro_rules! occurs {
    ($m:expr, $s:expr) => {
        $m.occurrences_of($s) > 0
    };
}

macro_rules! collect {
    ($m:expr, $s:expr) => {
        $m.values_of($s).unwrap_or_default().collect::<Vec<_>>()
    };
}

fn show(bs: &[u8]) -> String {
    if let Ok(s) = String::from_utf8(bs.to_owned()) {
        s
    } else {
    let mut visible = String::new();
        for &b in bs {
            let part: Vec<u8> = escape_default(b).collect();
            visible.push_str(str::from_utf8(&part).unwrap());
        }
        visible
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonOutput {
    pub symbols: HashMap<String, String>,
    pub stdout: String,
    pub stderr: String,
}

fn main() {
    let matches = App::new("radius2")
        .global_settings(&[clap::AppSettings::ColoredHelp])
        .version(env!("CARGO_PKG_VERSION"))
        .author("Austin Emmitt (@alkalinesec) <alkali@alkalinesecurity.com>")
        .about("A symbolic execution tool using r2 and boolector")
        .arg(
            Arg::with_name("path")
                .short("p")
                .long("path")
                .takes_value(true)
                .required(true)
                .help("Path to the target binary"),
        )
        .arg(
            Arg::with_name("libs")
                .short("L")
                .long("libs")
                .takes_value(true)
                .multiple(true)
                .help("Load libraries from path"),
        )
        .arg(
            Arg::with_name("file")
                .short("f")
                .long("file")
                .value_names(&["PATH", "SYMBOL"])
                .multiple(true)
                .help("Add a symbolic file"),
        )
        .arg(
            Arg::with_name("json")
                .short("j")
                .long("json")
                .help("Output JSON"),
        )
        .arg(
            Arg::with_name("verbose")
                .short("v")
                .long("verbose")
                .help("Show verbose / debugging output"),
        )
        .arg(
            Arg::with_name("plugins")
                .long("plugins")
                .help("Load r2 plugins"),
        )
        .arg(
            Arg::with_name("lazy")
                .short("z")
                .long("lazy")
                .help("Evaluate symbolic PC values lazily"),
        )
        .arg(
            Arg::with_name("crash")
                .long("crash")
                .help("Execution stops on invalid memory access"),
        )
        .arg(
            Arg::with_name("noselfmodify")
                .short("N")
                .long("no-modify")
                .help("Disallow self-modifying code (faster sometimes)"),
        )
        .arg(
            Arg::with_name("nostrict")
                .long("no-strict")
                .help("Don't avoid invalid instructions and ESIL"),
        )
        .arg(
            Arg::with_name("no_sims")
                .long("no-sims")
                .help("Do not simulate imports"),
        )
        .arg(
            Arg::with_name("fuzz")
                .short("F")
                .long("fuzz")
                .takes_value(true)
                .help("Generate testcases and write to supplied dir"),
        )
        .arg(
            Arg::with_name("max")
                .long("max")
                .takes_value(true)
                .help("Maximum number of states to keep at a time"),
        )
        .arg(
            Arg::with_name("profile")
                .short("P")
                .long("profile")
                .help("Get performance and runtime information"),
        )
        .arg(
            Arg::with_name("color")
                .short("V")
                .long("color")
                .help("Use color output"),
        )
        .arg(
            Arg::with_name("stdin")
                .short("0")
                .long("stdin")
                .help("Use stdin for target program"),
        )
        .arg(
            Arg::with_name("stdout")
                .short("1")
                .long("stdout")
                .help("Show stdout output"),
        )
        .arg(
            Arg::with_name("stderr")
                .short("2")
                .long("stderr")
                .help("Show stderr output"),
        )
        .arg(
            Arg::with_name("ghidra")
                .short("G")
                .long("ghidra")
                .help("Use r2ghidra to translate pcode to ESIL"),
        )
        .arg(
            Arg::with_name("address")
                .short("a")
                .long("address")
                .takes_value(true)
                .help("Address to begin execution at"),
        )
        .arg(
            Arg::with_name("breakpoint")
                .short("b")
                .long("break")
                .takes_value(true)
                .multiple(true)
                .help("Breakpoint at some target address"),
        )
        .arg(
            Arg::with_name("break_strings")
                .short("B")
                .long("break-strings")
                .takes_value(true)
                .multiple(true)
                .help("Breakpoint code xrefs to strings"),
        )
        .arg(
            Arg::with_name("avoid")
                .short("x")
                .long("avoid")
                .takes_value(true)
                .multiple(true)
                .help("Avoid addresses"),
        )
        .arg(
            Arg::with_name("avoid_strings")
                .short("X")
                .long("avoid-strings")
                .takes_value(true)
                .multiple(true)
                .help("Avoid code xrefs to strings"),
        )
        .arg(
            Arg::with_name("merge")
                .short("m")
                .long("merge")
                .takes_value(true)
                .multiple(true)
                .help("Set address as a mergepoint"),
        )
        .arg(
            Arg::with_name("automerge")
                .short("M")
                .long("automerge")
                .help("Automatically merge states"),
        )
        .arg(
            Arg::with_name("merge_all")
                .short("K")
                .long("merge-all")
                .help("Merge all finished states"),
        )
        .arg(
            Arg::with_name("arg")
                .short("A")
                .long("arg")
                .takes_value(true)
                .multiple(true)
                .help("Argument for the target program"),
        )
        .arg(
            Arg::with_name("env")
                .long("env")
                .takes_value(true)
                .multiple(true)
                .help("Environment variable for the target program"),
        )
        .arg(
            Arg::with_name("symbol")
                .short("s")
                .long("symbol")
                .value_names(&["NAME", "BITS"])
                .multiple(true)
                .help("Create a symbolic value"),
        )
        .arg(
            Arg::with_name("set")
                .short("S")
                .long("set")
                .value_names(&["REG/ADDR", "VALUE", "BITS"])
                .multiple(true)
                .help("Set memory or register values"),
        )
        .arg(
            Arg::with_name("constrain")
                .short("c")
                .long("constrain")
                .value_names(&["SYMBOL", "EXPR"])
                .multiple(true)
                .help("Constrain symbol values with string or pattern"),
        )
        .arg(
            Arg::with_name("constrain_after")
                .short("C")
                .long("constrain-after") // post-constrain
                .value_names(&["SYMBOL", "EXPR"])
                .multiple(true)
                .help("Constrain symbol or file values after execution"),
        )
        .arg(
            Arg::with_name("include")
                .short("i")
                .long("include")
                .value_names(&["SYMBOL", "EXPR"])
                .multiple(true)
                .help("Assert symbol contains a string"),
        )
        .arg(
            Arg::with_name("not_include")
                .short("I")
                .long("not-include")
                .value_names(&["SYMBOL", "EXPR"])
                .multiple(true)
                .help("Assert symbol does not contain a string"),
        )
        .arg(
            Arg::with_name("hook")
                .short("H")
                .long("hook")
                .value_names(&["ADDR", "EXPR"])
                .multiple(true)
                .help("Hook the provided address with an ESIL expression"),
        )
        .arg(
            Arg::with_name("r2_command")
                .short("r")
                .long("r2-cmd")
                .value_names(&["CMD"])
                .multiple(true)
                .help("Run r2 command on launch"),
        )
        .arg(
            Arg::with_name("evaluate")
                .short("e")
                .long("eval")
                .value_names(&["ESIL"])
                .multiple(true)
                .help("Evaluate ESIL expression"),
        )
        .arg(
            Arg::with_name("evaluate_after")
                .short("E")
                .long("eval-after")
                .value_names(&["ESIL"])
                .multiple(true)
                .help("Evaluate ESIL expression after execution"),
        )
        .get_matches();

    let libpaths: Vec<&str> = collect!(matches, "libs");

    let debug = occurs!(matches, "verbose") || occurs!(matches, "color");
    let no_sims = occurs!(matches, "no_sims");
    let profile = occurs!(matches, "profile");
    let fuzz = occurs!(matches, "fuzz");
    let all_sims = !no_sims && libpaths.is_empty();
    let mut json_out = JsonOutput {
        symbols: HashMap::new(),
        stdout: String::from(""),
        stderr: String::from(""),
    };

    let do_json = occurs!(matches, "json");

    let plugins = occurs!(matches, "plugins") || occurs!(matches, "ghidra")
        || matches
            .value_of("path")
            .unwrap_or_default()
            .starts_with("frida:"); // load plugins for r2frida

    let mut options = vec![
        RadiusOption::Debug(debug),
        RadiusOption::Lazy(occurs!(matches, "lazy")),
        RadiusOption::Strict(!occurs!(matches, "nostrict")),
        RadiusOption::SelfModify(!occurs!(matches, "noselfmodify")),
        RadiusOption::ColorOutput(occurs!(matches, "color")),
        RadiusOption::Permissions(occurs!(matches, "crash")),
        RadiusOption::AutoMerge(occurs!(matches, "automerge")),
        RadiusOption::Sims(!no_sims),
        RadiusOption::SimAll(all_sims),
        RadiusOption::LoadLibs(!libpaths.is_empty()),
        RadiusOption::LoadPlugins(plugins),
    ];

    for lib in libpaths {
        options.push(RadiusOption::LibPath(lib.to_owned()));
    }

    let threads: usize = 1;
    let start = Instant::now();

    let path = matches.value_of("path").unwrap_or("-");
    let dir = Path::new(matches.value_of("fuzz").unwrap_or("."));

    // just a guardrail cuz the error otherwise is vv unclear
    if path != "-" && !path.contains(':') && fs::metadata(path).is_err() {
        println!("'{}' not found", path);
        process::exit(1);
    }

    let mut radius = Radius::new_with_options(matches.value_of("path"), &options);

    if !dir.exists() {
        fs::create_dir(&dir).unwrap();
    }

    let max_states = matches
        .value_of("max")
        .unwrap_or("256")
        .parse()
        .unwrap_or(256);

    // translate pcode to ESIL
    if occurs!(matches, "ghidra") {
        radius.cmd("pdgp").unwrap_or_default();
    }

    // execute provided r2 commands
    let cmds: Vec<&str> = collect!(matches, "r2_command");
    for cmd in cmds {
        let r = radius.cmd(cmd);
        if occurs!(matches, "verbose") && r.is_ok() {
            println!("{}", r.unwrap());
        }
    }

    // set breakpoints, avoids, and merges
    let mut bps: Vec<u64> = collect!(matches, "breakpoint")
        .iter()
        .map(|x| radius.get_address(x).unwrap())
        .collect();
    let mut avoid: Vec<u64> = collect!(matches, "avoid")
        .iter()
        .map(|x| radius.get_address(x).unwrap())
        .collect();
    let merges: Vec<u64> = collect!(matches, "merge")
        .iter()
        .map(|x| radius.get_address(x).unwrap())
        .collect();

    let mut analyzed = false;
    // get code references to strings and add them to the avoid list
    if occurs!(matches, "avoid_strings") {
        // need to analyze to get string refs
        radius.analyze(3);
        analyzed = true;
        for string in collect!(matches, "avoid_strings") {
            for location in radius.r2api.search_strings(string).unwrap() {
                avoid.extend(
                    radius
                        .r2api
                        .get_references(location)
                        .unwrap_or_default()
                        .iter()
                        .map(|x| x.from),
                );
            }
        }
    }

    // get code references to strings and add them to the breakpoints
    if occurs!(matches, "break_strings") {
        // need to analyze to get string refs
        if !analyzed {
            radius.analyze(3);
        }
        for string in collect!(matches, "break_strings") {
            for location in radius.r2api.search_strings(string).unwrap() {
                bps.extend(
                    radius
                        .r2api
                        .get_references(location)
                        .unwrap_or_default()
                        .iter()
                        .map(|x| x.from),
                );
            }
        }
    }

    for bp in bps {
        radius.breakpoint(bp);
    }

    radius.avoid(&avoid);

    for merge in merges {
        radius.mergepoint(merge);
    }

    let mut state = if let Some(address) = matches.value_of("address") {
        let addr = radius.get_address(address).unwrap_or(0);
        if path.starts_with("frida:") {
            radius.frida_state(addr)
        } else if path.starts_with("gdb:") || path.starts_with("dbg:") {
            radius.debug_state(addr, &[])
        } else {
            radius.call_state(addr)
        }
    } else {
        radius.entry_state()
    };

    // collect the symbol declarations
    let mut files: Vec<&str> = collect!(matches, "file");
    let mut symbol_names = vec![];
    let mut symbol_map = HashMap::new();
    let mut symbol_types = HashMap::new();
    let mut has_stdin = false;

    let symbols: Vec<&str> = collect!(matches, "symbol");
    for i in 0..matches.occurrences_of("symbol") as usize {
        // use get_address so hex / simple ops can be used
        let sym_name = symbols[2 * i];
        symbol_names.push(sym_name);
        let mut len = symbols[2 * i + 1];

        if len.ends_with('n') {
            len = &len[..len.len() - 1];
            symbol_types.insert(sym_name, "num");
        } else {
            symbol_types.insert(sym_name, "str");
        }

        let length = radius.get_address(len).unwrap_or(8) as u32;
        let sym_value = state.symbolic_value(sym_name, length);
        //symbol_types.insert(sym_name, symbols[3 * i + 2]);
        symbol_map.insert(sym_name, sym_value.as_bv().unwrap());
        state.context.insert(sym_name.to_owned(), vec![sym_value]);

        if sym_name.to_lowercase() == "stdin" {
            files.extend(vec!["0", sym_name]);
            has_stdin = true;
        }
    }

    let mut argvs: Vec<&str> = collect!(matches, "arg");
    let envs: Vec<&str> = collect!(matches, "env");
    let has_argv_env = !argvs.is_empty() || !envs.is_empty();

    // if theres no input, default argv[0] to first symbol
    let default_args = !has_argv_env && files.is_empty() && !has_stdin && !symbols.is_empty();

    if default_args || has_argv_env {
        if default_args {
            argvs = vec![path];
            argvs.extend(symbol_names.clone())
        }

        let mut argv = vec![];
        let mut envv = vec![];

        for (t, args) in [argvs, envs].iter().enumerate() {
            for arg in args {
                let value = if let Some(sym) = symbol_map.get(arg) {
                    Value::Symbolic(sym.clone(), 0)
                } else {
                    // @ signs to prevent parsing as radius args
                    let narg = if arg.starts_with("@") {
                        &arg[1..]
                    } else {
                        &arg[..]
                    };

                    let bytes: Vec<Value> = narg
                        .as_bytes()
                        .iter()
                        .map(|b| Value::Concrete(*b as u64, 0))
                        .collect();

                    state.memory.pack(&bytes)
                };

                if t == 0 {
                    argv.push(value);
                } else {
                    envv.push(value);
                }
            }
        }

        radius.set_argv_env(&mut state, &argv, &envv);
    }

    // collect the symbol constraints
    let cons: Vec<&str> = collect!(matches, "constrain");
    for i in 0..matches.occurrences_of("constrain") as usize {
        let bv = &symbol_map[cons[2 * i]];
        let cons = if cons[2 * i + 1].starts_with('@') {
            &cons[2 * i + 1][1..]
        } else {
            &cons[2 * i + 1]
        };
        state.constrain_bytes_bv(bv, cons);
    }

    // collect the ESIL hooks
    let hooks: Vec<&str> = collect!(matches, "hook");
    for i in 0..matches.occurrences_of("hook") as usize {
        if let Ok(addr) = radius.get_address(hooks[2 * i]) {
            radius.esil_hook(addr, hooks[2 * i + 1]);
        }
    }

    // collect the added files
    for i in 0..files.len() / 2usize {
        let file = files[2 * i];
        let name = files[2 * i + 1];
        if let Some(sym) = symbol_map.get(name) {
            let length = symbol_map[name].get_width() as usize;
            let value = Value::Symbolic(sym.clone(), 0);
            let bytes = state.unpack(&value, length / 8);
            if let Ok(fd) = files[2 * i].parse() {
                state.filesystem.fill(fd, &bytes);
            } else {
                state.filesystem.add_file(files[2 * i], &bytes);
            }
        } else {
            let content = files[2 * i + 1];
            if let Ok(fd) = file.parse() {
                state.fill_file_string(fd, content)
            } else {
                let bytes: Vec<Value> = content
                    .as_bytes()
                    .iter()
                    .map(|b| Value::Concrete(*b as u64, 0))
                    .collect();

                state.filesystem.add_file(file, &bytes);
            }
        }
    }

    // set provided address and register values
    let sets: Vec<&str> = collect!(matches, "set");
    for i in 0..matches.occurrences_of("set") as usize {
        // easiest way to interpret the stuff is just to use
        let ind = 3 * i;
        let mut length: u32 = sets[ind + 2].parse().unwrap();

        let mut is_ref = false;
        let valstr = if sets[ind + 1][0..1].to_owned() == "&" {
            is_ref = true;
            &sets[ind + 1][1..]
        } else {
            &sets[ind + 1][0..]
        };

        let lit = radius.processor.get_literal(valstr);
        let mut value = if let Some(Word::Literal(val)) = lit {
            val
        } else if let Some(bv) = symbol_map.get(valstr) {
            Value::Symbolic(bv.slice(length - 1, 0), 0)
        } else {
            // this is a real workaround of the system
            // i need a better place for these kinds of utils
            let bytes = valstr.as_bytes();
            let bv = BV::from_hex_str(
                state.solver.btor.clone(),
                hex_encode(bytes).as_str(),
                length,
            );

            Value::Symbolic(bv, 0)
        };

        if is_ref {
            let addr = state.memory_alloc(&Value::Concrete(length as u64 / 8, 0));
            state.memory_write_value(&addr, &value, length as usize / 8);
            value = addr;
            length = state.memory.bits as u32;
        }

        let lit = radius.processor.get_literal(sets[ind]);
        if let Some(Word::Literal(address)) = lit {
            state.memory_write_value(&address, &value, (length / 8) as usize);
        } else if let Some(Word::Register(index)) =
            radius.processor.get_register(&mut state, sets[ind])
        {
            state.registers.set_value(index, value);
        }
    }

    // collect the ESIL strings to evaluate
    let evals: Vec<&str> = collect!(matches, "evaluate");
    for eval in evals {
        radius.processor.parse_expression(&mut state, eval);
    }

    if profile {
        println!("init time:\t{}", start.elapsed().as_micros());
    }
    // run the thing
    let run_start = Instant::now();

    if !fuzz {
        let result = if !occurs!(matches, "merge_all") {
            radius.run(state, threads)
        } else {
            let mut states = radius.run_all(state);
            let count = states.len();

            if !states.is_empty() {
                let mut end = states.remove(0);
                for _ in 1..count {
                    end.merge(&mut states.remove(0));
                }
                Some(end)
            } else {
                None
            }
        };

        if profile {
            let usecs = run_start.elapsed().as_micros();
            let steps = radius.get_steps();
            println!(
                "run time:\t{}\ninstructions:\t{}\ninstr/usec:\t{:0.6}",
                usecs,
                steps,
                (steps as f64 / usecs as f64)
            );
        }

        if let Some(mut end_state) = result {
            // collect the ESIL strings to evaluate after running
            let constraints: Vec<&str> = collect!(matches, "constrain_after");
            for i in 0..matches.occurrences_of("constrain_after") as usize {
                let name = constraints[2 * i];
                let con = constraints[2 * i + 1];

                let cons = if con.starts_with('@') { &con[1..] } else { con };

                if symbol_map.contains_key(name) {
                    let bv = &symbol_map[name];
                    end_state.constrain_bytes_bv(bv, cons);
                } else if files.contains(&name) {
                    end_state.constrain_file(name, cons);
                } else if let Ok(fd) = name.parse::<usize>() {
                    end_state.constrain_fd(fd, cons);
                } else if let Some(_reg) = end_state.registers.get_register(name) {
                    let val = radius.r2api.get_address(cons).unwrap();
                    end_state.assert(&end_state.registers.get_with_alias(name).eq(&vc(val)));
                } else if let Ok(addr) = radius.r2api.get_address(name) {
                    let mem = end_state.memory.read_value(addr, 4);
                    let val = radius.r2api.get_address(cons).unwrap();
                    end_state.assert(&mem.eq(&vc(val)));
                }
            }

            for inc in &["include", "not_include"] {
                let constraints: Vec<&str> = collect!(matches, inc);

                for i in 0..matches.occurrences_of(inc) as usize {
                    let name = constraints[2 * i];
                    let con = constraints[2 * i + 1];

                    let index = if files.contains(&name) {
                        end_state.search_file(name, con)
                    } else if let Ok(fd) = name.parse::<usize>() {
                        end_state.search_fd(fd, con)
                    } else {
                        vc(-1i64 as u64)
                    };

                    if inc.to_owned() == "include" {
                        end_state.assert(&!index.eq(&vc(-1i64 as u64)));
                    } else {
                        end_state.assert(&index.eq(&vc(-1i64 as u64)));
                    }
                }
            }

            // collect the ESIL strings to evaluate after running
            let evals: Vec<&str> = collect!(matches, "evaluate_after");
            for eval in evals {
                radius.processor.parse_expression(&mut end_state, eval);
            }
            let solve_start = Instant::now();

            if !do_json {
                println!()
            };
            for symbol in symbol_names {
                let val = Value::Symbolic(end_state.translate(&symbol_map[symbol]).unwrap(), 0);

                if let Some(bv) = end_state.solver.eval_to_bv(&val) {
                    let str_opt = end_state.evaluate_string_bv(&bv);
                    let sym_type = symbol_types[symbol];
                    let hex = end_state.solver.hex_solution(&bv).unwrap_or_default();
                    if !do_json {
                        if sym_type == "str" && str_opt.is_some() {
                            println!("  {} : {:?}", symbol.green(), str_opt.unwrap());
                        } else if sym_type == "str" {
                            let bytes = end_state.evaluate_bytes_bv(&bv).unwrap();
                            println!("  {} : \"{}\"", symbol.green(), show(&bytes));
                        } else {
                            println!("  {} : 0x{}", symbol.green(), hex);
                        }
                    } else {
                        json_out
                            .symbols
                            .insert(symbol.to_owned().to_owned(), hex.to_owned());
                    }
                } else if !do_json {
                    println!("  {} : no satisfiable value", symbol.red());
                } else {
                    json_out
                        .symbols
                        .insert(symbol.to_owned().to_owned(), "unsat".to_owned());
                }
            }
            if !do_json {
                println!()
            };

            if profile {
                println!("solve time:\t{}", solve_start.elapsed().as_micros());
            }

            // dump program output
            let head = "=".repeat(37);
            let foot = "=".repeat(80);
            if occurs!(matches, "stdout") {
                let out = show(&end_state.dump_file_bytes(1));
                if !do_json {
                    println!(
                        "{}stdout{}\n{}\n{}",
                        head.blue(),
                        head.blue(),
                        out,
                        foot.blue()
                    );
                } else {
                    json_out.stdout = out;
                }
            }
            if occurs!(matches, "stderr") {
                let out = show(&end_state.dump_file_bytes(2));
                if !do_json {
                    println!(
                        "{}stderr{}\n{}\n{}",
                        head.red(),
                        head.red(),
                        out,
                        foot.red()
                    );
                } else {
                    json_out.stderr = out;
                }
            }
        }

        if do_json {
            println!("{}", serde_json::to_string(&json_out).unwrap_or_default());
        }
    } else {
        // TODO this is temporary until I integrate a real testcase gen mode in processor
        let mut pcs: HashMap<u64, usize> = HashMap::new();
        let mut states = VecDeque::new();
        let mut solutions: HashSet<Vec<u8>> = HashSet::new();
        states.push_back(state);

        let mut file_counts: HashMap<&str, usize> = HashMap::new();

        for symbol in symbol_map.keys() {
            file_counts.insert(symbol, 0);
        }

        while !states.is_empty() {
            let num_states = states.len();
            let mut s = states.pop_front().unwrap();
            let cpc = s.registers.get_pc().as_u64().unwrap();

            radius.processor.fetch_instruction(&mut s, cpc);
            let tn = radius.processor.instructions[&cpc].instruction.type_num;

            let new_states = radius.processor.run(s, RunMode::Step);
            //new_states.push(s);

            for mut new_state in new_states {
                let pc = new_state.registers.get_pc().as_u64().unwrap();
                let active = new_state.status == StateStatus::Active;
                if pcs.entry(pc).and_modify(|c| *c += 1).or_insert(1) > &mut 1 {
                    if active && num_states <= max_states {
                        states.push_back(new_state);
                    }
                    continue;
                }
                // after (conditional) calls and jumps
                if tn & 0xf == 1 || tn & 0xf == 4 {
                    for symbol in symbol_map.keys() {
                        let val = new_state.translate(&symbol_map[symbol]).unwrap();

                        if let Some(bytes) = new_state.evaluate_bytes_bv(&val) {
                            if !solutions.contains(&bytes) {
                                let c = file_counts[symbol];
                                let filename = &format!("{}{:04}", symbol, c);
                                fs::write(dir.join(filename), &bytes).unwrap();
                                file_counts.insert(symbol, c + 1);
                                solutions.insert(bytes);
                            }
                        }
                    }
                }
                if active {
                    states.push_front(new_state);
                }
            }
        }

        if profile {
            let usecs = run_start.elapsed().as_micros();
            let steps = radius.get_steps();
            println!(
                "run time:\t{}\ninstructions:\t{}\ninstr/usec:\t{:0.6}\ngenerated:\t{}",
                usecs,
                steps,
                (steps as f64 / usecs as f64),
                file_counts.values().sum::<usize>()
            );
        }
    }

    if profile {
        println!("total time:\t{}", start.elapsed().as_micros());
    }

    radius.close();
}

```

`radius/src/memory.rs`:

```rs
use std::collections::BTreeMap;
//use ahash::AHashMap;
//type HashMap<P, Q> = AHashMap<P, Q>;

use crate::r2_api::{Endian, R2Api, STACK_SIZE, STACK_START};
use crate::solver::Solver;
use crate::value::Value;
use std::mem;

pub const READ_CACHE: usize = 256;
// const LEN_MAX: u64 = 65536;

// one day I will make a reasonable heap impl
// today is not that day
const HEAP_START: u64 = 0x40000000;
const HEAP_SIZE: u64 = 0x040000;
// const HEAP_CANARY_SIZE: u64 = 0x10;
// const HEAP_CHUNK: u64 = 0x100;
const ALIGN: u64 = 16;

// i think these are different on darwin
const PROT_NONE:  u64 = 0x0;
const PROT_READ:  u64 = 0x1;
const PROT_WRITE: u64 = 0x2;
const PROT_EXEC:  u64 = 0x4;

/// The virtual memory of the program state
///
/// Values in Memory can be either Concrete or Symbolic
#[derive(Clone)]
pub struct Memory {
    pub solver: Solver,
    pub r2api: R2Api,

    // TODO refactor merge to make this private
    pub mem: BTreeMap<u64, Vec<Value>>,
    heap: Heap,
    //heap_canary: Value,
    pub bits: u64,
    pub endian: Endian,
    pub segs: Vec<MemorySegment>,
    pub blank: bool,
}

pub enum Permission {
    Read,
    Write,
    Execute,
}

#[derive(Debug, Clone)]
pub struct MemorySegment {
    pub name: String,
    pub addr: u64,
    pub size: u64,
    pub read: bool,
    pub write: bool,
    pub exec: bool,
    pub init: bool,
}

impl Memory {
    /// Create a new Memory struct to hold memory values for symbolic execution
    pub fn new(r2api: &mut R2Api, btor: Solver, blank: bool) -> Memory {
        let segments = r2api.get_segments().unwrap();
        let mut segs = Vec::with_capacity(64);

        for seg in segments {
            segs.push(MemorySegment {
                name: seg.name,
                addr: seg.vaddr,
                size: seg.size,
                read: seg.perm.contains('r'),
                write: seg.perm.contains('w'),
                exec: seg.perm.contains('x'),
                init: true,
            });
        }

        let endian = r2api.info.bin.endian.as_str();

        let bin = &r2api.info.bin;
        let bits = if bin.arch == "arm" && bin.bits == 16 {
            32 // says "16" for 32 bit arm cuz thumb
        } else {
            bin.bits
        };

        //let heap_canary = Value::Symbolic(
        //    btor.bv("heap_canary", HEAP_CANARY_SIZE as u32), 0);

        Memory {
            solver: btor,
            r2api: r2api.clone(),
            mem: BTreeMap::new(),
            heap: Heap::new(HEAP_START, HEAP_SIZE),
            //heap_canary,
            bits,
            endian: Endian::from_string(endian),
            segs,
            blank,
        }
    }

    /// Allocate memory `length` bytes long. Returns the address of the allocation.
    pub fn alloc(&mut self, length: &Value) -> u64 {
        let len = length.as_u64().unwrap();
        // aligning makes some runs take much longer wtaf
        let len = len + if len % ALIGN != 0 { ALIGN - len % ALIGN } else { 0 };

        let addr = self.heap.alloc(len);
        //let canary = self.heap_canary.clone();
        //self.write_value(addr, &canary, HEAP_CANARY_SIZE as usize);
        addr
    }

    #[inline]
    pub fn alloc_sym(&mut self, length: &Value, solver: &mut Solver) -> Value {
        let len = solver.max_value(length);
        Value::Concrete(self.heap.alloc(len), 0)
    }

    /// Free allocated memory
    pub fn free(&mut self, addr: &Value) -> Value {
        let address = addr.as_u64().unwrap();
        if let Some(ret) = self.heap.free(address) {
            Value::Concrete(ret, addr.get_taint())
        } else {
            Value::Concrete(0, 0) // idk none of this is right
        }
    }

    #[inline]
    pub fn free_sym(&mut self, addr: &Value, solver: &mut Solver) -> Value {
        let address = solver.evalcon_to_u64(addr).unwrap();
        self.free(&Value::Concrete(address, 0))
    }

    /// Check the permissions `perm` (r/w/x) of the memory at `addr`
    #[inline]
    pub fn check_permission(&self, addr: u64, length: u64, perm: char) -> bool {
        for seg in &self.segs {
            if addr >= seg.addr && addr + length <= seg.addr + seg.size {
                match perm {
                    'r' => return seg.read,
                    'w' => return seg.write,
                    'x' => return seg.exec,
                    'i' => return seg.init,
                    _ => return false, // uhhh shouldnt happen
                }
            }
        }

        false
    }

    pub fn add_segment(&mut self, name: &str, addr: u64, size: u64, perms: &str) {
        self.segs.push(MemorySegment {
            name: name.to_owned(),
            addr,
            size,
            read: perms.contains('r'),
            write: perms.contains('w'),
            exec: perms.contains('x'),
            init: perms.contains('i'),
        });
        // zero mem for new segment
        self.r2api.cmd(&format!("w0 {} @ {}", size, addr)).unwrap();
    }

    pub fn add_heap(&mut self) {
        self.mem
            .insert(HEAP_START, vec![Value::Concrete(0, 0); READ_CACHE]);
        self.add_segment("heap", HEAP_START, HEAP_SIZE, "rw--");
    }

    pub fn add_stack(&mut self) {
        //self.mem.insert(STACK_START+STACK_SIZE/2, vec![Value::Concrete(0, 0); READ_CACHE]);
        self.add_segment("stack", STACK_START, STACK_SIZE, "rw--");
    }

    // its hard to overstate how much all of this sucks
    pub fn add_std_streams(&mut self) {
        let mut fd = 0;
        let stds = ["stdin", "stdout", "stderr"];
        for std in &stds {
            let mut addr = self.r2api.get_address(&("obj.".to_owned() + std)).unwrap();
            let mut offset = 112; // linux
            if addr == 0 {
                addr = self
                    .r2api
                    .get_address(&("reloc.__".to_owned() + std + "p"))
                    .unwrap();
                offset = 18; // macos, this is jank af
            }

            if addr != 0 {
                // from libc.rs should be in a common place
                let file_struct = self.alloc(&Value::Concrete(216, 0));
                self.write_value(file_struct + offset, &Value::Concrete(fd, 0), 4);
                self.write_value(
                    addr,
                    &Value::Concrete(file_struct, 0),
                    (self.bits / 8) as usize,
                );
                fd += 1;
            }
        }

        // Also put the macos canary here idk. this 100% sucks
        let stk_chk = self.r2api.get_address("reloc.__stack_chk_guard").unwrap();
        if stk_chk != 0 {
            let chk_value_addr = self.heap.alloc(8);
            self.write_value(
                chk_value_addr,
                &(Value::Symbolic(self.solver.bv("stack_canary", 64), 0)),
                (self.bits / 8) as usize,
            );
        }
    }

    pub fn brk(&mut self, address: u64) -> u64 {
        // check if this address is already mapped
        let avail = !self.check_permission(address, 1, 'i');

        for seg in &mut self.segs {
            if seg.name == ".data" {
                if avail {
                    // set size and return new break
                    seg.size = address - seg.addr;
                    return address;
                } else {
                    // return previous break
                    return seg.addr + seg.size;
                }
            }
        }
        0
    }

    pub fn sbrk(&mut self, inc: u64) -> u64 {
        for seg in &mut self.segs {
            if seg.name == ".data" {
                seg.size += inc;
                return seg.addr + seg.size - inc; // returns previous
            }
        }
        -1i64 as u64
    }

    #[inline]
    pub fn read_sym(&mut self, address: &Value, len: usize, solver: &mut Solver) -> Value {
        match address {
            Value::Concrete(addr, _t) => self.read_value(*addr, len),
            Value::Symbolic(addr, t) => {
                let addrs = solver.evaluate_many(addr);
                let mut value = Value::Symbolic(solver.bvv(0, 64), 0);
                for a in addrs {
                    let read_val = self.read_value(a, len);
                    let bv = solver.bvv(a, 64);
                    let cond = Value::Symbolic(addr._eq(&bv), *t);
                    value = solver.conditional(&cond, &read_val, &value);
                }
                //println!("value: {:?}", value);
                value
            }
        }
    }

    #[inline]
    pub fn write_sym(&mut self, address: &Value, value: &Value, len: usize, solver: &mut Solver) {
        match address {
            Value::Concrete(addr, _t) => self.write_value(*addr, value, len),
            Value::Symbolic(addr, t) => {
                let addrs = solver.evaluate_many(addr);
                for a in addrs {
                    let read_val = self.read_value(a, len);
                    let bv = solver.bvv(a, addr.get_width());
                    let cond = Value::Symbolic(addr._eq(&bv), *t);
                    let new_val = solver.conditional(&cond, value, &read_val);
                    self.write_value(a, &new_val, len);
                }
            }
        }
    }

    pub fn read_sym_len(
        &mut self,
        address: &Value,
        length: &Value,
        solver: &mut Solver,
    ) -> Vec<Value> {
        let len = solver.max_value(length) as usize;

        match address {
            Value::Concrete(addr, _t) => {
                let mut data = vec![Value::Concrete(0, 0); len];
                self.read(*addr, len, &mut data);
                data
            }
            Value::Symbolic(addr, t) => {
                let addrs = solver.evaluate_many(addr);
                let mut values = Vec::with_capacity(256);
                for a in addrs {
                    let mut read_vals = vec![Value::Concrete(0, 0); len];
                    self.read(a, len, &mut read_vals);

                    let mut new_vals = vec![];
                    if values.is_empty() {
                        new_vals = read_vals;
                    } else {
                        for count in 0..len {
                            let bv = solver.bvv(a, 64);
                            let cond = Value::Symbolic(addr._eq(&bv), *t);
                            let value =
                                solver.conditional(&cond, &read_vals[count], &values[count]);

                            new_vals.push(value);
                        }
                    }
                    values = new_vals;
                }
                values
            }
        }
    }

    pub fn write_sym_len(
        &mut self,
        address: &Value,
        values: &[Value],
        length: &Value,
        solver: &mut Solver,
    ) {
        let mut len = solver.max_value(length) as usize;
        // hopefully this doesn't occur
        if len > values.len() {
            len = values.len();
        }

        let mut addrs = Vec::with_capacity(256);
        let t = address.get_taint();
        match address {
            Value::Concrete(addr, _t) => addrs.push(*addr),
            Value::Symbolic(addr, _t) => addrs.extend(solver.evaluate_many(addr)),
        };

        for addr in addrs {
            let mut read_vals = vec![Value::Concrete(0, 0); len];
            self.read(addr, len, &mut read_vals);

            for count in 0..len {
                let addr_val = Value::Concrete(addr, t);
                let count_val = Value::Concrete(count as u64, 0);
                let cond = address.eq(&addr_val) & count_val.ult(length);
                let value = solver.conditional(&cond, &values[count], &read_vals[count]);
                self.write(addr + count as u64, &mut [value]);
            }
        }
    }

    pub fn memmove(&mut self, dst: &Value, src: &Value, length: &Value, solver: &mut Solver) {
        let data = self.read_sym_len(src, length, solver);
        self.write_sym_len(dst, &data, length, solver);
    }

    pub fn search(
        &mut self,
        addr: &Value,
        needle: &Value,
        length: &Value,
        reverse: bool,
        solver: &mut Solver,
    ) -> Value {
        //let mut search_data = self.read_sym_len(addr, length);
        let len = solver.max_value(length) as usize;

        // concrete needle ends at null
        // symbolic is given by width
        let needlen = match needle {
            Value::Concrete(val, _t) => {
                let mut mask = 0xff;
                let mut l = 1;
                for i in 1..9 {
                    if mask & val != 0 {
                        l = i;
                    }
                    mask <<= 8;
                }
                l
            }
            Value::Symbolic(val, _t) => val.get_width() / 8,
        } as usize;

        let mut result = Value::Concrete(0, 0);
        let mut found = Value::Concrete(0, 0);

        if needlen > len {
            return result;
        }

        for pos in 0..(len - needlen) {
            // get value to test
            let pos_val = if reverse {
                addr.clone() + length.clone() - Value::Concrete(pos as u64, 0)
            } else {
                addr.clone() + Value::Concrete(pos as u64, 0)
            };
            let value = self.read_sym(&pos_val, needlen, solver);

            let pos_cond = pos_val.ult(&(addr.clone() + length.clone())) & !pos_val.ult(addr);
            let new_cond = value.eq(needle) & pos_cond & !found.clone();
            result = solver.conditional(&new_cond, &pos_val, &result);
            found = value.eq(needle) | found;

            // println!("result {:?} {:?} {:?}", result, value, needle);
            if let Value::Concrete(res, _t) = &result {
                if *res != 0 {
                    break;
                }
            } 
            if value.id(needle).as_u64().unwrap() == 1 {
                // this is weird but cuts searches on identical values
                break;
            }
        }

        result
    }

    pub fn strlen(&mut self, addr: &Value, length: &Value, solver: &mut Solver) -> Value {
        let end = self.search(addr, &Value::Concrete(0, 0), length, false, solver);
        solver.conditional(&(end.eq(&Value::Concrete(0, 0))), length, &end.sub(addr))
    }

    pub fn compare(
        &mut self,
        addr1: &Value,
        addr2: &Value,
        length: &Value,
        solver: &mut Solver,
    ) -> Value {
        let len = solver.max_value(length);
        let data1 = self.read_sym_len(addr1, &Value::Concrete(len, length.get_taint()), solver);
        let data2 = self.read_sym_len(addr2, &Value::Concrete(len, length.get_taint()), solver);

        let mut result = Value::Concrete(0, 0);

        for ind in 0..len as usize {
            let d1 = &data1[ind].uext(&Value::Concrete(8, 0));
            let d2 = &data2[ind].uext(&Value::Concrete(8, 0));

            let ind_val = Value::Concrete(ind as u64, 0);
            let len_cond = ind_val.ult(length);

            result = solver.conditional(
                &(result.eq(&Value::Concrete(0, 0)) & len_cond),
                &d1.sub(d2),
                &result,
            );

            if let Value::Concrete(res, _t) = &result {
                if *res != 0 {
                    break;
                }
            }
        }

        result
    }

    /// read a Value of `length` bytes from memory at `addr`
    pub fn read_value(&mut self, addr: u64, length: usize) -> Value {
        if length <= 32 {
            let mut data: [Value; 32] = Default::default();
            self.read(addr, length, &mut data[..length]);
            self.pack(&data[..length])
        } else {
            let mut data = vec![Value::Concrete(0, 0); length];
            self.read(addr, length, &mut data);
            self.pack(&data)
        }
    }

    /// write a Value of `length` bytes to memory at `addr`
    pub fn write_value(&mut self, addr: u64, value: &Value, length: usize) {
        if length <= 32 {
            let mut data: [Value; 32] = Default::default();
            self.unpack(value, length, &mut data[..length]);
            self.write(addr, &mut data[..length])
        } else {
            let mut data = vec![Value::Concrete(0, 0); length];
            self.unpack(value, length, &mut data);
            self.write(addr, &mut data)
        }
    }

    /// read `length` bytes from memory at `addr` into `data`
    pub fn read(&mut self, addr: u64, length: usize, data: &mut [Value]) {
        if length == 0 || data.len() == 0 {
            return;
        }
        let make_sym = self.blank && !self.check_permission(addr, length as u64, 'i');

        let size = READ_CACHE as u64;
        let mask = -1i64 as u64 ^ (size - 1);
        let not_mask = size - 1;
        let chunks = (((addr & not_mask) + length as u64) / size) + 1;

        let mut index = 0;
        for count in 0..chunks {
            let caddr = (addr & mask) + size * count;
            let mut offset = (addr & not_mask) * (count == 0) as u64;

            let mem = if let Some(m) = self.mem.get(&caddr) {
                m
            } else if make_sym {
                let mut vals = Vec::with_capacity(READ_CACHE);
                for i in 0..size {
                    let sym_name = format!("mem_{:08x}", caddr + i);
                    vals.push(Value::Symbolic(self.solver.bv(&sym_name, 8), 0));
                }
                self.mem.entry(caddr).or_insert(vals)
            } else {
                let bytes = self.r2api.read(caddr, READ_CACHE).unwrap();
                // println!("{:x} {:?}", caddr, bytes);
                let vals = bytes
                    .iter()
                    .map(|b| Value::Concrete(*b as u64, 0))
                    .collect();
                self.mem.entry(caddr).or_insert(vals)
            };

            while index < length && offset < size && data.len() > index {
                data[index] = mem[offset as usize].to_owned();
                index += 1;
                offset += 1;
            }
        }
    }

    pub fn prot_to_str(&self, prot: u64) -> String {
        let mut prot_str = String::from("");

        if prot == PROT_NONE {
            return String::from("---");
        }

        if prot & PROT_READ != 0 {
            prot_str += "r";
        } else {
            prot_str += "-";
        }
        if prot & PROT_WRITE != 0 {
            prot_str += "w";
        } else {
            prot_str += "-";
        }
        if prot & PROT_EXEC != 0 {
            prot_str += "x";
        } else {
            prot_str += "-";
        }

        prot_str
    }

    pub fn read_bytes(&mut self, addr: u64, length: usize, solver: &mut Solver) -> Vec<u8> {
        let mut data = vec![Value::Concrete(0, 0); length];
        self.read(addr, length, &mut data);
        solver.push();
        let data_u8 = data
            .iter()
            .map(|d| solver.evalcon_to_u64(d).unwrap() as u8)
            .collect();
        solver.pop();
        data_u8
    }

    //read utf8 string
    pub fn read_string(&mut self, addr: u64, length: usize, solver: &mut Solver) -> String {
        String::from_utf8(self.read_bytes(addr, length, solver)).unwrap_or_default()
    }

    pub fn write_string(&mut self, addr: u64, string: &str) {
        let data = string.as_bytes();
        let mut data_value = Vec::with_capacity(string.len());
        for d in data {
            data_value.push(Value::Concrete(*d as u64, 0));
        }
        data_value.push(Value::Concrete(0, 0));
        self.write(addr, &mut data_value);
    }

    /// write `length` bytes to memory at `addr` from `data`
    pub fn write(&mut self, addr: u64, data: &mut [Value]) {
        let length = data.len();
        let size = READ_CACHE as u64;
        let mask = -1i64 as u64 ^ (size - 1);
        let not_mask = size - 1;
        let chunks = (((addr & not_mask) + length as u64) / size) + 1;

        let mut index = 0;
        for count in 0..chunks {
            let caddr = (addr & mask) + size * count;
            let mut offset = (addr & not_mask) * (count == 0) as u64;

            let mem = if let Some(m) = self.mem.get_mut(&caddr) {
                m
            } else {
                let mut newmem = vec![Value::Concrete(0, 0); READ_CACHE];
                // dont read if we are writing all
                if addr % size != 0 || length % READ_CACHE != 0 {
                    self.read(caddr, READ_CACHE, &mut newmem);
                }
                self.mem.entry(caddr).or_insert(newmem)
            };

            while index < length && offset < size {
                mem[offset as usize] = mem::take(&mut data[index]);
                index += 1;
                offset += 1;
            }
        }
    }

    // this sucks, we need to properly do error handling to do this right
    // TODO make everything not suck
    pub fn handle_segfault(&self, addr: u64, length: u64, perm: char) {
        panic!(
            "addr {} length {} does not have perm \"{}\"",
            addr, length, perm
        );
    }

    // jesus this got huge
    /// Pack the bytes in `data` into a Value according to the endianness of the target
    pub fn pack(&self, data: &[Value]) -> Value {
        let new_data = data;
        let length = new_data.len();
        let mut taint = 0;

        if self.endian == Endian::Big {
            let mut new_data = data.to_owned();
            new_data.reverse();
        }

        // if length > 64 bits use sym to cheat
        if length > 8 || new_data.iter().any(|x| x.is_symbolic()) {
            // this value isn't used, idk
            let mut sym_val = self.solver.bvv(0, 1);

            for count in 0..length {
                let datum = new_data.get(count).unwrap();
                match &datum {
                    Value::Symbolic(val, t) => {
                        //let trans_val = self.solver.translate(val).unwrap();

                        if sym_val.get_width() == 1 {
                            sym_val = val.slice(7, 0);
                        } else {
                            sym_val = val.slice(7, 0).concat(&sym_val);
                        }

                        taint |= t;
                    }
                    Value::Concrete(val, t) => {
                        let new_val = self.solver.bvv(*val, 8);

                        if sym_val.get_width() == 1 {
                            sym_val = new_val;
                        } else {
                            sym_val = new_val.concat(&sym_val);
                        }

                        taint |= t;
                    }
                }
            }
            Value::Symbolic(sym_val, taint)
        } else {
            let mut con_val: u64 = 0;
            for (count, datum) in new_data.iter().enumerate() {
                if let Value::Concrete(val, t) = datum {
                    con_val += val << (8 * count);
                    taint |= t;
                }
            }
            Value::Concrete(con_val, taint)
        }
    }

    /// Unpack the Value into `length` bytes and store them in the `data` ref
    pub fn unpack(&self, value: &Value, length: usize, data: &mut [Value]) {
        //let mut data: Vec<Value> = Vec::with_capacity(length);
        if length == 0 {
            return;
        }

        match value {
            Value::Concrete(val, t) => {
                for count in 0..length {
                    // TODO fix this for >64 bit length
                    data[count] = Value::Concrete((val.wrapping_shr(8 * count as u32)) & 0xff, *t);
                }
            }
            Value::Symbolic(val, t) => {
                for count in 0..length {
                    //let trans_val = self.solver.translate(&val).unwrap();
                    let bv = val.slice(((count as u32) + 1) * 8 - 1, (count as u32) * 8);
                    data[count] = Value::Symbolic(bv, *t);
                }
            }
        }
        if self.endian == Endian::Big {
            data.reverse();
        }
        //data
    }

    pub fn addresses(&self) -> Vec<u64> {
        self.mem.keys().cloned().collect::<Vec<u64>>()
    }

    pub fn in_memory(&self, addr: u64) -> bool {
        self.mem.contains_key(&(addr & -(READ_CACHE as i64) as u64))
    }
}

/// An extremely simple heap
#[derive(Clone)]
pub struct Heap {
    pub start: u64,
    pub size: u64,
    pub chunks: Vec<Chunk>,
}

/// A chunk within the Heap
#[derive(Clone, PartialEq)]
pub struct Chunk {
    pub addr: u64,
    pub size: u64,
}

// still a dumb af heap implementation
impl Heap {
    pub fn new(start: u64, size: u64) -> Self {
        Heap {
            start,
            size,
            chunks: vec![Chunk {
                addr: start,
                size: 0,
            }],
        }
    }

    pub fn alloc(&mut self, size: u64) -> u64 {
        let last = &self.chunks[self.chunks.len() - 1];
        let addr = last.addr + last.size;
        self.chunks.push(Chunk {
            addr,
            size //: size + HEAP_CANARY_SIZE,
        });
        addr
    }

    pub fn free(&mut self, addr: u64) -> Option<u64> {
        let last = &self.chunks[self.chunks.len() - 1];
        if addr == last.addr {
            self.chunks.pop();
            Some(addr)
        } else if let Some(rem) = self.chunks.iter().position(|x| x.addr == addr) {
            self.chunks.remove(rem);
            Some(addr)
        } else {
            None
        }
    }
}

```

`radius/src/operations.rs`:

```rs
use crate::state::{StackItem, State};
use crate::value::{vc, Value};
use std::f64;

pub const OPS: [&str; 16] = [
    "+", "-", "++", "--", "*", "/", "<<", ">>", "|", "&", "^", "%", "!", ">>>>", ">>>", "<<<",
];

pub const SIZE: u64 = 64;

#[derive(Debug, Clone, PartialEq)]
pub enum Operations {
    Trap,
    Interrupt,
    Syscall,
    PcAddress,
    If,
    Else,
    EndIf,
    Compare,
    LessThan,
    LessThanEq,
    GreaterThan,
    GreaterThanEq,
    LeftShift,
    LogicalRightShift,
    RightShift,
    LeftRotation,
    RightRotation,
    SignExtend,
    And,
    Or,
    Xor,
    Add,
    Subtract,
    Multiply,
    LongMultiply,
    Divide,
    LongDivide,
    Modulo,
    LongModulo,
    SignedDivide,
    SignedModulo,
    Not,
    Increment,
    Decrement,
    Equal,
    WeakEqual,
    Peek(usize),
    Poke(usize),
    PeekBits,
    PokeBits,
    PeekSize,
    PokeSize,
    PeekMany,
    PokeMany,
    PopCount,
    Ceiling,
    Floor,
    Round,
    SquareRoot,
    DoubleToInt,
    SignedToDouble,
    UnsignedToDouble,
    DoubleToFloat,
    FloatToDouble,
    FloatCompare,
    FloatLessThan,
    FloatAdd,
    FloatSubtract,
    FloatMultiply,
    FloatDivide,
    NaN,
    FloatNegate,
    AddressStore,
    AddressRestore,
    Swap,
    Pick,
    ReversePick,
    Pop,
    Duplicate,
    Number,
    Clear,
    Break,
    Repeat,
    GoTo,
    PrintStack,
    ToDo,
    NoOperation,

    Print,      // Tool for cli hooks
    PrintDebug, // Tool for cli hooks
    Backtrace,  // Tool for cli hooks
    Constrain,
    ConstrainEqual,
    ConstraintPush,
    ConstraintPop,
    Terminate,
    Discard,

    // flag ops
    Zero,
    Carry,
    Borrow,
    Parity,
    Overflow,
    // SubOverflow,
    // i forget these
    S,
    Ds,
    JumpTarget,
    Js,
    R,

    Unknown,
}

impl Operations {
    pub fn from_string(s: &str) -> Self {
        match s {
            "TRAP" => Operations::Trap,
            "$" => Operations::Interrupt,
            "()" => Operations::Syscall,
            "$$" => Operations::PcAddress, // this is whack
            "?{" => Operations::If,
            "}{" => Operations::Else,
            "}" => Operations::EndIf,
            "==" => Operations::Compare,
            "<" => Operations::LessThan,
            "<=" => Operations::LessThanEq,
            ">" => Operations::GreaterThan,
            ">=" => Operations::GreaterThanEq,
            "<<" => Operations::LeftShift,
            "LSL" => Operations::LeftShift,
            "ASL" => Operations::LeftShift,
            ">>" => Operations::LogicalRightShift,
            "LSR" => Operations::LogicalRightShift,
            ">>>>" => Operations::RightShift,
            "ASR" => Operations::RightShift,
            "<<<" => Operations::LeftRotation,
            "ROL" => Operations::LeftRotation,
            ">>>" => Operations::RightRotation,
            "ROR" => Operations::RightRotation,
            "~" => Operations::SignExtend,
            "SIGN" => Operations::SignExtend,
            "&" => Operations::And,
            "|" => Operations::Or,
            "^" => Operations::Xor,
            "+" => Operations::Add,
            "-" => Operations::Subtract,
            "*" => Operations::Multiply,
            "L*" => Operations::LongMultiply,
            "/" => Operations::Divide,
            "L/" => Operations::LongDivide,
            "%" => Operations::Modulo,
            "L%" => Operations::LongModulo,
            "~/" => Operations::SignedDivide,
            "~%" => Operations::SignedModulo,
            "!" => Operations::Not,
            "++" => Operations::Increment,
            "--" => Operations::Decrement,
            "=" => Operations::Equal,
            ":=" => Operations::WeakEqual,
            "[1]" => Operations::Peek(1),
            "[2]" => Operations::Peek(2),
            "[4]" => Operations::Peek(4),
            "[8]" => Operations::Peek(8),
            "[16]" => Operations::Peek(16),
            "=[1]" => Operations::Poke(1),
            "=[2]" => Operations::Poke(2),
            "=[4]" => Operations::Poke(4),
            "=[8]" => Operations::Poke(8),
            "=[16]" => Operations::Poke(16),
            "=[]" => Operations::PokeBits,
            "[]" => Operations::PeekBits,
            "=[n]" => Operations::PokeSize,
            "[n]" => Operations::PeekSize,
            "=[*]" => Operations::PokeMany,
            "[*]" => Operations::PeekMany,
            "POPCOUNT" => Operations::PopCount,
            "CEIL" => Operations::Ceiling,
            "FLOOR" => Operations::Floor,
            "ROUND" => Operations::Round,
            "SQRT" => Operations::SquareRoot,
            "D2I" => Operations::DoubleToInt,
            "I2D" => Operations::SignedToDouble,
            "S2D" => Operations::SignedToDouble,
            "U2D" => Operations::UnsignedToDouble,
            "F2D" => Operations::FloatToDouble,
            "D2F" => Operations::DoubleToFloat,
            "F+" => Operations::FloatAdd,
            "F-" => Operations::FloatSubtract,
            "F*" => Operations::FloatMultiply,
            "F/" => Operations::FloatDivide,
            "F==" => Operations::FloatCompare,
            "F<" => Operations::FloatLessThan,
            "NAN" => Operations::NaN,
            "-F" => Operations::FloatNegate,
            "SWAP" => Operations::Swap,
            "PICK" => Operations::Pick,
            "RPICK" => Operations::ReversePick,
            "POP" => Operations::Pop,
            "DUP" => Operations::Duplicate,
            "NUM" => Operations::Number,
            "CLEAR" => Operations::Clear,
            "BREAK" => Operations::Break,
            "REPEAT" => Operations::Repeat,
            "GOTO" => Operations::GoTo,
            "STACK" => Operations::PrintStack,
            "TODO" => Operations::ToDo,
            "" => Operations::NoOperation,

            // hax for use in the cli / plugin
            "." => Operations::Print,
            ".." => Operations::PrintDebug,
            "BT" => Operations::Backtrace,
            "_" => Operations::Constrain,
            "_=" => Operations::ConstrainEqual,
            "_+" => Operations::ConstraintPush,
            "_-" => Operations::ConstraintPop,
            "!!" => Operations::Terminate, // state.set_break()
            "!_" => Operations::Discard,   // state.set_inactive()

            "$z" => Operations::Zero,
            "$c" => Operations::Carry,
            "$b" => Operations::Borrow,
            "$p" => Operations::Parity,
            "$o" => Operations::Overflow,
            //"$so" => Operations::SubOverflow,
            "$s" => Operations::S,
            "$ds" => Operations::Ds,
            "$jt" => Operations::JumpTarget,
            "$js" => Operations::Js,
            "$r" => Operations::R,
            _ => Operations::Unknown,
        }
    }
}

#[inline]
pub fn get_size(state: &mut State) -> u32 {
    let item = state.stack.pop().unwrap_or_default();

    let sz = match &item {
        StackItem::StackValue(_val) => 64,
        StackItem::StackRegister(index) => {
            let reg = &state.registers.indexes[*index];
            reg.reg_info.size as u32
        }
    };

    state.stack.push(item);
    sz
}

#[inline]
pub fn pop_bv(state: &mut State, n: u32) -> Value {
    let value = pop_value(state, false, false);
    Value::Symbolic(state.solver.to_bv(&value, n), value.get_taint())
}

//#[inline]
pub fn pop_value(state: &mut State, set_size: bool, sign_ext: bool) -> Value {
    let item = state.stack.pop().unwrap_or_default();

    let value = match item {
        StackItem::StackValue(val) => val,
        StackItem::StackRegister(index) => {
            if set_size {
                let reg = &state.registers.indexes[index];
                state.esil.last_sz = reg.reg_info.size as usize;
            }
            state.registers.get_value(index)
        }
    };

    match &value {
        Value::Concrete(_v, _t) => value,
        Value::Symbolic(ov, t) => {
            // check const and fits in u64
            if ov.is_const() && ov.get_width() <= 64 {
                Value::Concrete(ov.as_u64().unwrap(), *t)
            } else {
                let v = ov; //state.translate(&ov).unwrap();
                let szdiff = SIZE as i32 - v.get_width() as i32;
                if szdiff > 0 {
                    if sign_ext {
                        Value::Symbolic(v.sext(szdiff as u32), *t)
                    } else {
                        Value::Symbolic(v.uext(szdiff as u32), *t)
                    }
                } else {
                    value
                }
            }
        }
    }
}

#[inline]
pub fn pop_stack_value(
    state: &mut State,
    stack: &mut Vec<StackItem>,
    set_size: bool,
    sign_ext: bool,
) -> Value {
    let item = stack.pop().unwrap_or_default();

    let value = match item {
        StackItem::StackValue(val) => val,
        StackItem::StackRegister(index) => {
            if set_size {
                let reg = state.registers.indexes.get(index).unwrap();
                state.esil.last_sz = reg.reg_info.size as usize;
            }
            state.registers.get_value(index)
        }
    };

    match &value {
        Value::Concrete(_v, _t) => value,
        Value::Symbolic(ov, t) => {
            if ov.is_const() && ov.get_width() <= 64 {
                Value::Concrete(ov.as_u64().unwrap(), *t)
            } else {
                let v = ov; //state.translate(&ov).unwrap();
                let szdiff = SIZE as u32 - v.get_width();
                if szdiff > 0 {
                    if sign_ext {
                        Value::Symbolic(v.sext(szdiff), *t)
                    } else {
                        Value::Symbolic(v.uext(szdiff), *t)
                    }
                } else {
                    value
                }
            }
        }
    }
}

#[inline]
pub fn push_value(state: &mut State, value: Value) {
    state.stack.push(StackItem::StackValue(value));
}

#[inline]
pub fn pop_concrete(state: &mut State, set_size: bool, sign_ext: bool) -> u64 {
    let value = pop_value(state, set_size, sign_ext);

    match &value {
        Value::Concrete(val, _t) => *val,
        Value::Symbolic(_val, _t) => state.solver.evalcon_to_u64(&value).unwrap(),
    }
}

#[inline]
pub fn get_stack_taint(state: &mut State, n: usize) -> u64 {
    let mut taint = 0;
    for _ in 0..n {
        let arg = pop_value(state, false, false);
        taint |= arg.get_taint();
        push_value(state, arg);
    }
    taint
}

#[inline]
pub fn pop_double(state: &mut State) -> f64 {
    let value = pop_concrete(state, false, false);
    f64::from_bits(value)
}

#[inline]
pub fn pop_float(state: &mut State) -> f32 {
    let value = pop_concrete(state, false, false);
    f32::from_bits(value as u32)
}

#[inline]
pub fn do_equal(state: &mut State, reg: StackItem, value: Value, set_esil: bool) {
    if let StackItem::StackRegister(index) = reg {
        let register = state.registers.indexes.get(index).unwrap();
        let size = register.reg_info.size as usize;
        let prev = state.registers.get_value(index);

        if let Some(cond) = &state.condition {
            state.registers.set_value(
                index,
                state
                    .solver
                    .conditional(&Value::Symbolic(cond.to_owned(), 0), &value, &prev),
            );
        } else {
            state.registers.set_value(index, value.to_owned());
        }

        if set_esil {
            state.esil.last_sz = size;
            state.esil.current = value;
            state.esil.previous = prev;
        }
    }
}

macro_rules! binary_operation {
    ($state:expr, $op:tt) => {
        let arg1 = pop_value($state, false, false);
        let arg2 = pop_value($state, false, false);
        push_value($state, arg1 $op arg2);
    };
}

macro_rules! binary_float_operation {
    ($state:expr, $op:tt) => {
        let t = get_stack_taint($state, 1);
        let arg1 = pop_double($state);
        let arg2 = pop_double($state);
        let value = Value::Concrete(f64::to_bits(arg1 $op arg2), t);
        push_value($state, value);
    };
}

macro_rules! binary_method {
    ($state:expr, $op:ident) => {
        let arg1 = pop_value($state, false, false);
        let arg2 = pop_value($state, false, false);
        push_value($state, arg1.$op(arg2));
    };
}

#[inline]
pub fn genmask(bits: u64) -> u64 {
    if bits > 0 && bits < 63 {
        (2u64 << bits) - 1
    } else {
        0xffffffffffffffff
    }
}

pub fn do_operation(state: &mut State, operation: &Operations) {
    match operation {
        Operations::Trap => {}
        Operations::Interrupt => {}
        Operations::Syscall => {}
        Operations::PcAddress => {
            push_value(state, state.esil.prev_pc.clone());
        }
        Operations::If => {} // these are handled in processor
        Operations::Else => {}
        Operations::EndIf => {}
        Operations::Compare => {
            let arg1 = pop_value(state, true, false);
            let arg2 = pop_value(state, false, false);
            state.esil.current = arg1.to_owned() - arg2;
            state.esil.previous = arg1;
        }
        Operations::LessThan => {
            let arg1 = pop_value(state, true, true);
            let arg2 = pop_value(state, false, true);
            push_value(state, arg1.slt(&arg2));
        }
        Operations::LessThanEq => {
            let arg1 = pop_value(state, true, true);
            let arg2 = pop_value(state, false, true);
            push_value(state, arg1.slte(&arg2));
        }
        Operations::GreaterThan => {
            let arg1 = pop_value(state, true, true);
            let arg2 = pop_value(state, false, true);
            push_value(state, arg1.sgt(&arg2));
        }
        Operations::GreaterThanEq => {
            let arg1 = pop_value(state, true, true);
            let arg2 = pop_value(state, false, true);
            push_value(state, arg1.sgte(&arg2));
        }
        Operations::LeftShift => {
            binary_operation!(state, <<);
        }
        Operations::LogicalRightShift => {
            binary_operation!(state, >>);
        }
        Operations::RightShift => {
            let sz = get_size(state);
            let arg1 = pop_value(state, false, true);
            let arg2 = pop_value(state, false, true);
            push_value(state, arg1.asr(arg2, sz));
        }
        Operations::LeftRotation => {
            let sz = get_size(state);
            let arg1 = pop_value(state, false, false);
            let arg2 = pop_value(state, false, false);
            push_value(state, arg1.rol(arg2, sz));
        }
        Operations::RightRotation => {
            let sz = get_size(state);
            let arg1 = pop_value(state, false, false);
            let arg2 = pop_value(state, false, false);
            push_value(state, arg1.ror(arg2, sz));
        }
        Operations::SignExtend => {
            let arg1 = pop_value(state, false, false);
            let arg2 = pop_concrete(state, false, false);

            match arg1 {
                Value::Concrete(val1, t) => {
                    let shift = (64 - arg2) as i64;
                    let val = Value::Concrete(((val1 << shift) as i64 >> shift) as u64, t);
                    push_value(state, val);
                }
                Value::Symbolic(val1, t) => {
                    let val =
                        Value::Symbolic(val1.slice((arg2 - 1) as u32, 0).sext(64 - arg2 as u32), t);
                    push_value(state, val);
                }
            }
        }
        Operations::And => {
            binary_operation!(state, &);
        }
        Operations::Or => {
            binary_operation!(state, |);
        }
        Operations::Xor => {
            binary_operation!(state, ^);
        }
        Operations::Add => {
            binary_operation!(state, +);
        }
        Operations::Subtract => {
            binary_operation!(state, -);
        }
        Operations::Multiply => {
            binary_operation!(state, *);
        }
        // here, unlike anywhere else, long means 128 bit
        // it should be long long long long multiply
        Operations::LongMultiply => {
            let arg1 = pop_value(state, false, false);
            let arg2 = pop_value(state, false, false);

            match (arg1, arg2) {
                (Value::Concrete(val1, t1), Value::Concrete(val2, t2)) => {
                    let val = (val1 as u128) * (val2 as u128);
                    push_value(state, Value::Concrete((val >> 64) as u64, t1 | t2));
                    push_value(state, Value::Concrete(val as u64, t1 | t2));
                }
                (Value::Symbolic(val1, t1), Value::Concrete(val2, t2)) => {
                    let sval1 = val1.uext(64);
                    let sval2 = state.bvv(val2, 128);
                    let prod = sval1.mul(&sval2);
                    push_value(state, Value::Symbolic(prod.slice(127, 64), t1 | t2));
                    push_value(state, Value::Symbolic(prod.slice(63, 0), t1 | t2));
                }
                (Value::Concrete(val1, t1), Value::Symbolic(val2, t2)) => {
                    let sval2 = val2.uext(64);
                    let sval1 = state.bvv(val1, 128);
                    let prod = sval1.mul(&sval2);
                    push_value(state, Value::Symbolic(prod.slice(127, 64), t1 | t2));
                    push_value(state, Value::Symbolic(prod.slice(63, 0), t1 | t2));
                }
                (Value::Symbolic(val1, t1), Value::Symbolic(val2, t2)) => {
                    let sval1 = val1.uext(64);
                    let sval2 = val2.uext(64);
                    let prod = sval1.mul(&sval2);
                    push_value(state, Value::Symbolic(prod.slice(127, 64), t1 | t2));
                    push_value(state, Value::Symbolic(prod.slice(63, 0), t1 | t2));
                }
            }
        }
        Operations::LongDivide => {
            let arg1 = pop_bv(state, 128);
            let arg2 = pop_bv(state, 128);
            let arg3 = pop_bv(state, 128);

            push_value(state, ((arg2 << vc(64)) + arg1) / arg3);
        }
        Operations::LongModulo => {
            let arg1 = pop_bv(state, 128);
            let arg2 = pop_bv(state, 128);
            let arg3 = pop_bv(state, 128);

            //println!("{:?} {:?} {:?}", arg1, arg2, arg3);
            push_value(state, ((arg2 << vc(64)) + arg1) % arg3);
        }
        Operations::Divide => {
            binary_operation!(state, /);
        }
        Operations::Modulo => {
            binary_operation!(state, %);
        }
        Operations::SignedDivide => {
            binary_method!(state, sdiv);
        }
        Operations::SignedModulo => {
            binary_method!(state, srem);
        }
        Operations::Not => {
            let arg1 = pop_value(state, false, false);
            push_value(state, !arg1);
        }
        Operations::Increment => {
            let arg1 = pop_value(state, false, false);
            push_value(state, arg1 + Value::Concrete(1, 0));
        }
        Operations::Decrement => {
            let arg1 = pop_value(state, false, false);
            push_value(state, arg1 - Value::Concrete(1, 0));
        }
        Operations::Equal => {
            let reg_arg = state.stack.pop().unwrap();
            let value = pop_value(state, false, false);
            do_equal(state, reg_arg, value, true);
        }
        Operations::WeakEqual => {
            let reg_arg = state.stack.pop().unwrap();
            let value = pop_value(state, false, false);
            do_equal(state, reg_arg, value, false);
        }
        Operations::Peek(n) => {
            let addr = pop_value(state, false, false);

            let val = state.memory_read_value(&addr, *n);
            state.esil.current = val.to_owned();
            push_value(state, val);

            state.esil.previous = addr;
            state.esil.last_sz = 8 * (*n);
        }
        Operations::Poke(n) => {
            let addr = pop_value(state, false, false);
            let value = pop_value(state, false, false);

            if let Some(cond) = &state.condition.to_owned() {
                let prev = state.memory_read_value(&addr, *n);
                state.memory_write_value(
                    &addr,
                    &state
                        .solver
                        .conditional(&Value::Symbolic(cond.to_owned(), 0), &value, &prev),
                    *n,
                );
            } else {
                state.memory_write_value(&addr, &value, *n);
            }

            //state.memory.write_value(addr, value, n);
            state.esil.previous = addr;
            state.esil.last_sz = 8 * (*n);
        }
        Operations::PeekBits => {
            let n = (state.memory.bits / 8) as usize;
            let addr = pop_value(state, false, false);

            let val = state.memory_read_value(&addr, n);
            state.esil.current = val.to_owned();
            push_value(state, val);

            state.esil.previous = addr;
            state.esil.last_sz = 8 * n;
        }
        Operations::PokeBits => {
            let n = (state.memory.bits / 8) as usize;
            let addr = pop_value(state, false, false);
            let value = pop_value(state, false, false);

            if let Some(cond) = &state.condition.to_owned() {
                let prev = state.memory_read_value(&addr, n);
                state.memory_write_value(
                    &addr,
                    &state
                        .solver
                        .conditional(&Value::Symbolic(cond.to_owned(), 0), &value, &prev),
                    n,
                );
            } else {
                state.memory_write_value(&addr, &value, n);
            }

            //state.memory.write_value(addr, value, n);
            state.esil.previous = addr;
            state.esil.last_sz = 8 * n;
        }
        Operations::PeekSize => {
            let n = pop_concrete(state, false, false) as usize;
            let addr = pop_value(state, false, false);

            let val = state.memory_read_value(&addr, n);
            state.esil.current = val.to_owned();
            push_value(state, val);

            state.esil.previous = addr;
            state.esil.last_sz = 8 * n;
        }
        Operations::PokeSize => {
            let n = pop_concrete(state, false, false) as usize;
            let addr = pop_value(state, false, false);
            let value = pop_value(state, false, false);

            if let Some(cond) = &state.condition.to_owned() {
                let prev = state.memory_read_value(&addr, n);
                state.memory_write_value(
                    &addr,
                    &state
                        .solver
                        .conditional(&Value::Symbolic(cond.to_owned(), 0), &value, &prev),
                    n,
                );
            } else {
                state.memory_write_value(&addr, &value, n);
            }

            //state.memory.write_value(addr, value, n);
            state.esil.previous = addr;
            state.esil.last_sz = 8 * n;
        }
        Operations::PeekMany => {
            let mut addr = pop_value(state, false, false);
            let num = pop_concrete(state, false, false);

            for _ in 0..num {
                if let Some(StackItem::StackRegister(ind)) = state.stack.pop() {
                    let reg = state.registers.indexes[ind].clone();
                    let val = state.memory_read_value(&addr, reg.reg_info.size as usize / 8);
                    do_equal(state, StackItem::StackRegister(ind), val, false);
                    addr = addr + vc(reg.reg_info.size);
                }
            }
        }
        Operations::PokeMany => {
            let mut addr = pop_value(state, false, false);
            let num = pop_concrete(state, false, false);

            for _ in 0..num {
                if let Some(StackItem::StackRegister(ind)) = state.stack.pop() {
                    let reg = state.registers.indexes[ind].clone();
                    let val = state.registers.get_value(ind);
                    state.memory_write_value(&addr, &val, reg.reg_info.size as usize / 8);
                    addr = addr + vc(reg.reg_info.size);
                }
            }
        }
        // this is a hack to do op pokes ~efficiently
        Operations::AddressStore => {
            let addr = pop_value(state, false, false);
            state.esil.stored_address = Some(addr.to_owned());
            push_value(state, addr);
        }
        Operations::AddressRestore => {
            let addr = state.esil.stored_address.as_ref().unwrap().to_owned();
            push_value(state, addr);
            state.esil.stored_address = None;
        }
        Operations::PopCount => {
            let arg1 = pop_value(state, false, false);
            match arg1 {
                Value::Concrete(val, t) => {
                    let value = Value::Concrete(val.count_ones() as u64, t);
                    push_value(state, value);
                }
                Value::Symbolic(val, t) => {
                    let mut sym_val = state.bvv(0, 64);
                    for i in 0..val.get_width() {
                        sym_val = sym_val.add(&val.slice(i + 1, i).uext(63));
                    }
                    push_value(state, Value::Symbolic(sym_val, t));
                }
            }
        }
        Operations::Ceiling => {
            let t = get_stack_taint(state, 1);
            let arg1 = pop_double(state);
            push_value(state, Value::Concrete(f64::to_bits(arg1.ceil()), t));
        }
        Operations::Floor => {
            let t = get_stack_taint(state, 1);
            let arg1 = pop_double(state);
            push_value(state, Value::Concrete(f64::to_bits(arg1.floor()), t));
        }
        Operations::Round => {
            let t = get_stack_taint(state, 1);
            let arg1 = pop_double(state);
            push_value(state, Value::Concrete(f64::to_bits(arg1.round()), t));
        }
        Operations::SquareRoot => {
            let t = get_stack_taint(state, 1);
            let arg1 = pop_double(state);
            push_value(state, Value::Concrete(f64::to_bits(arg1.sqrt()), t));
        }
        Operations::DoubleToInt => {
            let t = get_stack_taint(state, 1);
            let arg1 = pop_double(state);
            push_value(state, Value::Concrete(arg1 as u64, t));
        }
        Operations::SignedToDouble => {
            let t = get_stack_taint(state, 1);
            let arg1 = pop_concrete(state, false, true);
            let value = Value::Concrete(f64::to_bits(arg1 as i64 as f64), t);
            push_value(state, value);
        }
        Operations::UnsignedToDouble => {
            let t = get_stack_taint(state, 1);
            let arg1 = pop_concrete(state, false, false);
            push_value(state, Value::Concrete(f64::to_bits(arg1 as f64), t));
        }
        Operations::FloatToDouble => {
            let val = pop_value(state, false, false);
            push_value(state, val.to_owned());

            let arg1 = pop_float(state);
            let size = pop_concrete(state, false, false);

            // i hate this but this is how I wrote r2
            // so i have only myself to blame
            let value = if size != 64 {
                Value::Concrete(f64::to_bits(arg1 as f64), val.get_taint())
            } else {
                val
            };
            push_value(state, value);
        }
        Operations::DoubleToFloat => {
            let t = get_stack_taint(state, 1);

            let arg1 = pop_double(state);
            let size = pop_concrete(state, false, false);

            // these casts will need casts when i'm done with em
            let value = if size != 64 {
                Value::Concrete(f32::to_bits(arg1 as f32) as u64, t)
            } else {
                Value::Concrete(f64::to_bits(arg1), t)
            };
            push_value(state, value);
        }
        Operations::FloatAdd => {
            binary_float_operation!(state, +);
        }
        Operations::FloatSubtract => {
            binary_float_operation!(state, -);
        }
        Operations::FloatMultiply => {
            binary_float_operation!(state, *);
        }
        Operations::FloatDivide => {
            binary_float_operation!(state, /);
        }
        Operations::FloatCompare => {
            let t = get_stack_taint(state, 2);
            let arg1 = pop_double(state);
            let arg2 = pop_double(state);
            push_value(state, Value::Concrete((arg1 - arg2 == 0.0) as u64, t));
        }
        Operations::FloatLessThan => {
            let t = get_stack_taint(state, 2);
            let arg1 = pop_double(state);
            let arg2 = pop_double(state);
            push_value(state, Value::Concrete((arg1 < arg2) as u64, t));
        }
        Operations::NaN => {
            let t = get_stack_taint(state, 1);
            let arg1 = pop_double(state);
            push_value(state, Value::Concrete(arg1.is_nan() as u64, t));
        }
        Operations::FloatNegate => {
            let t = get_stack_taint(state, 1);
            let arg1 = pop_double(state);
            push_value(state, Value::Concrete(f64::to_bits(-arg1), t));
        }
        Operations::Swap => {
            let arg1 = state.stack.pop().unwrap();
            let arg2 = state.stack.pop().unwrap();
            state.stack.push(arg1);
            state.stack.push(arg2);
        }
        Operations::Pick => {
            let n = pop_concrete(state, false, false);
            let item = state.stack[state.stack.len() - n as usize].to_owned();
            state.stack.push(item);
        }
        Operations::ReversePick => {
            let n = pop_concrete(state, false, false);
            let item = state.stack[n as usize].to_owned();
            state.stack.push(item);
        }
        Operations::Pop => {
            state.stack.pop();
        }
        Operations::Duplicate => {
            let item = state.stack.pop().unwrap();
            state.stack.push(item.clone());
            state.stack.push(item);
        }
        Operations::Number => {
            let value = pop_value(state, false, false);
            push_value(state, value);
        }
        Operations::Clear => {
            state.stack.clear();
        }
        Operations::PrintStack => {
            for value in state.stack.iter().rev() {
                println!("{:?}", value);
            }
        }
        Operations::Break => {}
        Operations::Repeat => {}
        Operations::GoTo => {}
        Operations::NoOperation => {}

        Operations::Print => {
            let value = pop_value(state, false, false);
            if let Some(cond) = &state.condition {
                state.solver.push();
                let condition = cond.clone();
                state.assert_bv(&condition);
            }
            let ip = state.registers.get_pc().as_u64().unwrap_or_default();
            if let Some(bv) = state.solver.eval_to_bv(&value) {
                let hex = state.solver.hex_solution(&bv).unwrap();
                if let Some(string) = state.evaluate_string_bv(&bv) {
                    println!("\n0x{:08x}    0x{} {:?}\n", ip, hex, string);
                } else {
                    println!("\n0x{:08x}    0x{}\n", ip, hex);
                }
            } else {
                println!("\n0x{:08x}    unsat\n", ip);
            }
            if state.condition.is_some() {
                state.solver.pop();
            }
        }
        Operations::PrintDebug => {
            let value = pop_value(state, false, false);
            let ip = state.registers.get_pc().as_u64().unwrap_or_default();
            println!("\n0x{:08x}    {:?}\n", ip, value);
        }
        Operations::Backtrace => {
            state.print_backtrace();
        }
        Operations::Constrain => {
            let value = pop_value(state, false, false);
            state.assert(&value);
        }
        // im gettin tired of writing x,y,-,!,_
        Operations::ConstrainEqual => {
            let val1 = pop_value(state, false, false);
            let val2 = pop_value(state, false, false);
            state.assert(&val1.eq(&val2));
        }
        Operations::ConstraintPush => {
            state.solver.push();
        }
        Operations::ConstraintPop => {
            state.solver.pop();
        }
        Operations::Terminate => {
            if let Some(cond) = &state.condition {
                let cond_value = Value::Symbolic(cond.to_owned(), 0);
                if state.solver.check_sat(&cond_value) {
                    state.solver.assert(&cond_value);
                    state.set_break();
                }
            } else {
                state.set_break();
            }
        }
        Operations::Discard => {
            state.set_inactive();
        }
        Operations::ToDo => {
            if state.strict {
                //unimplemented!();
                state.set_inactive();
            }
        }

        Operations::Zero => {
            let cur = &state.esil.current;
            let mask = Value::Concrete(genmask((state.esil.last_sz - 1) as u64), 0);
            let zf = !(cur.and(&mask));
            push_value(state, zf);
        }
        Operations::Carry => {
            let bits = pop_concrete(state, false, false);
            let mask = Value::Concrete(genmask(bits & 0x3f), 0);
            let cur = &state.esil.current;
            let old = &state.esil.previous;

            let cf = cur.and(&mask).ult(&old.and(&mask));
            push_value(state, cf);
        }
        Operations::Borrow => {
            let bits = pop_concrete(state, false, false);
            let mask = Value::Concrete(genmask(bits & 0x3f), 0);
            let cur = &state.esil.current;
            let old = &state.esil.previous;

            let cf = old.and(&mask).ult(&cur.and(&mask));
            push_value(state, cf);
        }
        Operations::Parity => match &state.esil.current {
            Value::Concrete(val, t) => {
                let pf = Value::Concrete(!((val & 0xff).count_ones() % 2) as u64, *t);
                push_value(state, pf);
            }
            Value::Symbolic(_val, _t) => {
                let c1 = Value::Concrete(0x0101010101010101, 0);
                let c2 = Value::Concrete(0x8040201008040201, 0);
                let c3 = Value::Concrete(0x1ff, 0);

                let cur = state.esil.current.to_owned();
                let lsb = cur & Value::Concrete(0xff, 0);
                let pf = !((((lsb * c1) & c2) % c3) & Value::Concrete(1, 0));
                //let pf = Value::Symbolic(val.redxor(), *t); this is 2x slower wtf
                push_value(state, pf);
            }
        },
        Operations::Overflow => {
            let bits = pop_concrete(state, false, false);
            let mask1 = Value::Concrete(genmask(bits & 0x3f), 0);
            let mask2 = Value::Concrete(genmask((bits + 0x3f) & 0x3f), 0);

            let cur = &state.esil.current;
            let old = &state.esil.previous;

            let c_in = cur.and(&mask1).ult(&old.and(&mask1));
            let c_out = cur.and(&mask2).ult(&old.and(&mask2));
            let of = c_in ^ c_out;
            push_value(state, of);
        }
        Operations::S => {
            let size = pop_value(state, false, false);
            let cur = state.esil.current.to_owned();
            let value = (cur >> size) & Value::Concrete(1, 0);
            push_value(state, value);
        }
        Operations::Ds => {
            let cur = state.esil.current.to_owned();
            let sz = Value::Concrete(state.esil.last_sz as u64, 0);
            let ds = (cur >> sz) & Value::Concrete(1, 0);
            push_value(state, ds);
        }
        Operations::JumpTarget => {}
        Operations::Js => {}
        Operations::R => {
            push_value(state, Value::Concrete(64 >> 3, 0));
        }
        Operations::Unknown => {
            if state.strict {
                // still panic here, we should support all ESIL
                panic!("Encountered an unknown word!");
            }
        }
    }
}

```

`radius/src/processor.rs`:

```rs
use crate::operations::{
    do_operation, pop_concrete, pop_stack_value, pop_value, push_value, Operations, OPS,
};
use crate::r2_api::{hex_decode, CallingConvention, Instruction, Syscall};
use crate::value::{vc, Value};

use crate::state::{
    Event, EventContext, EventTrigger, ExecMode, StackItem, State, StateStatus, DO_EVENT_HOOKS,
};

use crate::sims::syscall::syscall;
use crate::sims::{Sim, SimMethod};

use std::collections::BinaryHeap;
use std::mem;
use std::rc::Rc;
use colored::*;

use std::collections::BTreeMap;
use std::collections::{HashMap, HashSet};

const INSTR_NUM: usize = 64;
// const COLOR: bool = true;
const CALL_TYPE: u64 = 3;
const RETN_TYPE: u64 = 5;
// const NOP_TYPE: i64 = 8;

#[derive(Debug, Clone, PartialEq)]
pub enum Word {
    Literal(Value),
    Register(usize),
    Operator(Operations),
    Unknown(String),
}

#[derive(Debug, Clone, PartialEq)]
pub enum RunMode {
    Single,
    Step,
    Parallel,
    Multiple,
}

pub type HookMethod = fn(&mut State) -> bool;

#[derive(Clone)]
pub struct Processor {
    pub instructions: BTreeMap<u64, InstructionEntry>,
    pub hooks: HashMap<u64, Vec<HookMethod>>,
    pub esil_hooks: HashMap<u64, Vec<String>>,
    pub sims: HashMap<u64, Sim>,
    pub traps: HashMap<u64, SimMethod>,
    pub interrupts: HashMap<u64, SimMethod>,
    pub syscalls: HashMap<u64, Syscall>,
    pub breakpoints: HashSet<u64>,
    pub mergepoints: HashSet<u64>,
    pub avoidpoints: HashSet<u64>,
    pub visited: HashSet<u64>,
    pub merges: BTreeMap<u64, State>,
    pub crashes: Vec<State>,
    pub selfmodify: bool,
    pub optimized: bool,
    pub debug: bool,
    pub lazy: bool,
    pub force: bool,
    pub automerge: bool,
    pub color: bool,
    pub topological: bool, // execute blocks in topological sort order
    pub steps: u64,        // number of state steps
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum InstructionFlag {
    //None,
    Hook,
    ESILHook,
    Sim,
    Merge,
    Avoid,
    Break,
}

#[derive(Debug, Clone)]
pub struct InstructionEntry {
    pub instruction: Instruction,
    pub tokens: Vec<Word>,
    pub flags: HashSet<InstructionFlag>,
}

impl Processor {
    pub fn new(
        selfmodify: bool,
        optimized: bool,
        debug: bool,
        lazy: bool,
        force: bool,
        topological: bool,
        automerge: bool,
        color: bool,
    ) -> Self {
        Processor {
            instructions: BTreeMap::new(),
            hooks: HashMap::new(),
            esil_hooks: HashMap::new(),
            sims: HashMap::new(),
            traps: HashMap::new(),
            interrupts: HashMap::new(),
            syscalls: HashMap::new(),
            breakpoints: HashSet::new(),
            mergepoints: HashSet::new(),
            avoidpoints: HashSet::new(),
            visited: HashSet::new(),
            merges: BTreeMap::new(),
            crashes: vec![],
            selfmodify,
            optimized,
            debug,
            lazy,
            force,
            topological,
            automerge,
            color,
            steps: 0, //states: vec!()
        }
    }

    pub fn tokenize(&self, state: &mut State, esil: &str) -> Vec<Word> {
        let mut tokens: Vec<Word> = Vec::with_capacity(128);
        let split_esil = esil.split(',');

        for s in split_esil {
            let l = s.len();

            // nice, pretty, simple
            if let Some(register) = self.get_register(state, s) {
                tokens.push(register);
            } else if let Some(literal) = self.get_literal(s) {
                tokens.push(literal);
            } else if let Some(operator) = self.get_operator(s) {
                tokens.push(operator);

            // all this garbage is for the combo ones like ++=[8] ...
            } else if l > 1 && &s[l - 1..] == "=" && OPS.contains(&&s[..l - 1]) {
                let reg_word = tokens.pop().unwrap();
                tokens.push(reg_word.to_owned());
                let operator = self.get_operator(&s[..l - 1]).unwrap();
                tokens.push(operator);
                tokens.push(reg_word);
                tokens.push(Word::Operator(Operations::Equal));
            } else if l > 4 && &s[l - 1..] == "]" && OPS.contains(&&s[..l - 4]) {
                tokens.push(Word::Operator(Operations::AddressStore));
                let peek = self.get_operator(&s[l - 3..]).unwrap();
                tokens.push(peek);
                let operator = self.get_operator(&s[..l - 4]).unwrap();
                tokens.push(operator);
                let poke = self.get_operator(&s[l - 4..]).unwrap();
                tokens.push(Word::Operator(Operations::AddressRestore));
                tokens.push(poke);
            } else if let Some(values) = state.context.get(s) {
                tokens.extend(
                    values
                        .iter()
                        .map(|x| Word::Literal(state.translate_value(x))),
                );
            } else {
                tokens.push(Word::Unknown(String::from(s)));
            }
        }

        tokens
    }

    /// attempt to tokenize word as number literal (eg. 0x8)
    #[inline]
    pub fn get_literal(&self, word: &str) -> Option<Word> {
        if let Ok(i) = word.parse::<u64>() {
            Some(Word::Literal(Value::Concrete(i, 0)))
        } else if word.len() > 2 && &word[0..2] == "0x" {
            let val = u64::from_str_radix(&word[2..word.len()], 16).unwrap();
            Some(Word::Literal(Value::Concrete(val, 0)))
        } else if let Ok(i) = word.parse::<i64>() {
            Some(Word::Literal(Value::Concrete(i as u64, 0)))
        } else {
            None
        }
    }

    /// attempt to tokenize word as register (eg. rbx)
    #[inline]
    pub fn get_register(&self, state: &mut State, word: &str) -> Option<Word> {
        let name = if let Some(alias) = state.registers.aliases.get(word) {
            alias.reg.as_str()
        } else {
            word
        };
        state
            .registers
            .get_register(name)
            .map(|reg| Word::Register(reg.index))
    }

    /// attempt to tokenize word as operation (eg. +)
    #[inline]
    pub fn get_operator(&self, word: &str) -> Option<Word> {
        match Operations::from_string(word) {
            Operations::Unknown => None,
            op => Some(Word::Operator(op)),
        }
    }

    /// print instruction if debug output is enabled
    pub fn print_instr(&self, state: &mut State, instr: &Instruction) {
        if let Some(sim) = self.sims.get(&instr.offset) {
            println!(
                "\n0x{:08x}      ( {} {} )\n",
                instr.offset,
                "simulated", sim.symbol.blue()
            );
        } else if !self.color {
            println!(
                "0x{:08x}      {:<40} |  {}",
                instr.offset, instr.disasm, instr.esil
            );
        } else {
            print!(
                "{}",
                state
                    .r2api
                    .cmd(&format!("pd 1 @ {}", instr.offset))
                    .unwrap()
            );
        }
    }

    // perform an emulated syscall using the definitions in syscall.rs
    pub fn do_syscall(&self, state: &mut State) {
        let sys_val = state.registers.get_with_alias("SN");
        let sys_num = state.solver.evalcon_to_u64(&sys_val).unwrap();
        //let pc = state.registers.get_pc().as_u64().unwrap();

        if let Some(sys) = self.syscalls.get(&sys_num) {
            let cc = state.r2api.get_syscall_cc().unwrap();
            let mut args = Vec::with_capacity(8);
            for arg in cc.args {
                args.push(state.registers.get(arg.as_str()));
            }
            let ret = syscall(sys.name.as_str(), state, &args);
            state.registers.set(cc.ret.as_str(), ret);
        }
    }

    // for one-off parsing of strings
    pub fn parse_expression(&self, state: &mut State, esil: &str) {
        let words = self.tokenize(state, esil);
        self.parse(state, &words);
    }

    /**
     * Parse and execute the vector of tokenized ESIL words.
     * The difficult parts here are the temporary stacks for IF/ELSE
     * When a conditional is symbolic the stack needs to be copied
     * into separate stacks for the if and else portions
     * after ENDIF (}) these stacks are unwound into a single vec of
     * conditional bitvectors IF(cond, IF_VAL, ELSE_VAL)
     */
    pub fn parse(&self, state: &mut State, words: &[Word]) {
        state.stack.clear();

        let mut word_index = 0;
        let words_len = words.len();

        while word_index < words_len {
            let word = &words[word_index];
            word_index += 1;

            // this is weird...
            if state.esil.mode == ExecMode::NoExec {
                match &word {
                    Word::Operator(Operations::Else) | Word::Operator(Operations::EndIf) => {}
                    _ => continue,
                }
            }

            match word {
                Word::Literal(val) => {
                    state.stack.push(StackItem::StackValue(val.to_owned()));
                }
                Word::Register(index) => {
                    state.stack.push(StackItem::StackRegister(*index));
                }
                Word::Operator(op) => {
                    match op {
                        Operations::If => {
                            let arg1 = pop_value(state, false, false);

                            match (arg1, &state.esil.mode) {
                                (Value::Concrete(val1, _t), ExecMode::Uncon) => {
                                    state.esil.mode = if val1 == 0 {
                                        ExecMode::NoExec
                                    } else {
                                        ExecMode::Exec
                                    };
                                }
                                (Value::Symbolic(val1, _t), ExecMode::Uncon) => {
                                    //println!("if {:?}", val1);
                                    state.esil.mode = ExecMode::If;
                                    state.esil.temp1 = state.stack.to_owned();
                                    let cond_bv = val1._eq(&state.bvv(0, val1.get_width())).not();

                                    state.condition = Some(cond_bv);
                                }
                                _ => {
                                    println!("Bad ESIL?");
                                }
                            }
                        }
                        Operations::Else => match &state.esil.mode {
                            ExecMode::Exec => state.esil.mode = ExecMode::NoExec,
                            ExecMode::NoExec => state.esil.mode = ExecMode::Exec,
                            ExecMode::If => {
                                state.esil.mode = ExecMode::Else;
                                state.condition = Some(state.condition.as_ref().unwrap().not());
                                state.esil.temp2 = mem::take(&mut state.stack);
                                state.stack = mem::take(&mut state.esil.temp1);
                            }
                            _ => {}
                        },
                        Operations::EndIf => {
                            match &state.esil.mode {
                                ExecMode::If | ExecMode::Else => {}
                                _ => {
                                    state.esil.mode = ExecMode::Uncon;
                                    continue;
                                }
                            };

                            let mut new_temp = match &state.esil.mode {
                                ExecMode::If => mem::take(&mut state.esil.temp1),
                                ExecMode::Else => mem::take(&mut state.esil.temp2),
                                _ => vec![], // won't happen
                            };

                            // this is weird but just a trick to not have to alloc a new vec
                            let mut new_stack = mem::take(&mut state.esil.temp1);
                            let mut old_stack = mem::take(&mut state.stack);
                            while !old_stack.is_empty() && !new_temp.is_empty() {
                                let if_val = pop_stack_value(state, &mut old_stack, false, false);
                                let else_val = pop_stack_value(state, &mut new_temp, false, false);
                                let cond_val = state.solver.conditional(
                                    &Value::Symbolic(
                                        state.condition.as_ref().unwrap().to_owned(),
                                        0,
                                    ),
                                    &if_val,
                                    &else_val,
                                );

                                new_stack.push(StackItem::StackValue(cond_val));
                            }

                            new_stack.reverse();
                            state.stack = new_stack;
                            state.condition = None;

                            state.esil.mode = ExecMode::Uncon;
                        }
                        Operations::GoTo => {
                            let n = pop_concrete(state, false, false);
                            if let Some(cond) = &state.condition.clone() {
                                if !state.check(&Value::Symbolic(cond.not(), 0)) {
                                    state.esil.mode = ExecMode::Uncon;
                                    word_index = n as usize;
                                } else {
                                    state.assert_bv(&cond.not());
                                }
                            } else {
                                state.esil.mode = ExecMode::Uncon;
                                word_index = n as usize;
                            }
                        }
                        Operations::Break => {
                            if let Some(cond) = &state.condition.clone() {
                                if !state.check(&Value::Symbolic(cond.not(), 0)) {
                                    state.esil.mode = ExecMode::Uncon;
                                    break;
                                } else {
                                    state.assert_bv(&cond.not());
                                }
                            } else {
                                state.esil.mode = ExecMode::Uncon;
                                break;
                            }
                        }
                        Operations::Interrupt => {
                            let _value = pop_value(state, false, false);
                        }
                        Operations::Trap => {
                            let trap = pop_concrete(state, false, false);
                            let sys_val = state.registers.get_with_alias("SN");
                            if let Some(trap_sim) = self.traps.get(&trap) {
                                // provide syscall args
                                let cc = state.r2api.get_syscall_cc().unwrap_or_default();
                                let mut args = vec![sys_val];
                                for arg in cc.args {
                                    args.push(state.registers.get(arg.as_str()));
                                }
                                let ret = trap_sim(state, &args);
                                state.registers.set(cc.ret.as_str(), ret);
                            }
                        }
                        Operations::Syscall => self.do_syscall(state),
                        _ => do_operation(state, op),
                    }
                }
                Word::Unknown(s) => {
                    push_value(state, Value::Concrete(0, 0));
                    println!("Unknown word: {}", s);
                }
            }
        }
    }

    /// removes words that weak set flag values that are never read, and words that are NOPs
    /// really need to refactor this mess but every time i try it gets slower
    pub fn optimize(&mut self, state: &mut State, prev_pc: u64, curr_instr: &InstructionEntry) {
        let prev_instr = &self.instructions[&prev_pc];
        if !prev_instr
            .tokens
            .contains(&Word::Operator(Operations::WeakEqual))
            || !curr_instr
                .tokens
                .contains(&Word::Operator(Operations::WeakEqual))
        {
            return;
        }

        let mut regs_read: Vec<usize> = Vec::with_capacity(16);
        let mut regs_written: Vec<usize> = Vec::with_capacity(16);

        let len = curr_instr.tokens.len();
        for (i, word) in curr_instr.tokens.iter().enumerate() {
            if let Word::Register(index) = word {
                if i + 1 < len {
                    let next = &curr_instr.tokens[i + 1];
                    if let Word::Operator(op) = next {
                        match op {
                            Operations::WeakEqual | Operations::Equal => {
                                regs_written.push(*index);
                            }
                            _ => regs_read.push(*index),
                        }
                    } else {
                        regs_read.push(*index);
                    }
                }
            }
        }

        let mut remove: Vec<usize> = Vec::with_capacity(32);
        for (i, word) in prev_instr.tokens.iter().enumerate() {
            if let Word::Operator(op) = word {
                if let Operations::NoOperation = op {
                    remove.push(i); // remove nops
                } else if let Operations::WeakEqual = op {
                    let reg = &prev_instr.tokens[i - 1];
                    if let Word::Register(index) = reg {
                        if !regs_read.iter().any(|r| state.registers.is_sub(*r, *index))
                            && regs_written
                                .iter()
                                .any(|r| state.registers.is_sub(*r, *index))
                        {
                            let val = &prev_instr.tokens[i - 2];
                            if let Word::Operator(op) = val {
                                match op {
                                    Operations::Zero => remove.extend(vec![i - 2, i - 1, i]),
                                    Operations::Carry => {
                                        remove.extend(vec![i - 3, i - 2, i - 1, i])
                                    }
                                    Operations::Borrow => {
                                        remove.extend(vec![i - 3, i - 2, i - 1, i])
                                    }
                                    Operations::Parity => remove.extend(vec![i - 2, i - 1, i]),
                                    Operations::Overflow => {
                                        remove.extend(vec![i - 3, i - 2, i - 1, i])
                                    }
                                    Operations::S => remove.extend(vec![i - 3, i - 2, i - 1, i]),
                                    _ => {}
                                }
                            }
                        }
                    }
                }
            }
        }

        if !remove.is_empty() {
            let mut mut_prev_instr = prev_instr.to_owned();
            let mut new_tokens: Vec<Word> = Vec::with_capacity(128);

            for (i, word) in prev_instr.tokens.iter().enumerate() {
                if !remove.contains(&i) {
                    new_tokens.push(word.to_owned());
                }
            }
            mut_prev_instr.tokens = new_tokens;
            self.instructions.insert(prev_pc, mut_prev_instr);
        }
    }

    pub fn get_args(&self, state: &mut State, cc: &CallingConvention) -> Vec<Value> {
        let mut args = Vec::with_capacity(16);

        if !cc.args.is_empty() {
            for arg in &cc.args {
                args.push(state.registers.get_with_alias(arg));
            }
        } else {
            // read args from stack?
            let mut sp = state.registers.get_with_alias("SP");
            let length = state.memory.bits as usize / 8;

            for _ in 0..8 {
                // do 8 idk?
                sp = sp + Value::Concrete(length as u64, 0);
                let value = state.memory_read_value(&sp, length);
                args.push(value);
            }
        }

        args
    }

    /**
     * Update the status of the state and execute the instruction at PC
     * If the instruction is hooked or the method is simulated perform the
     * respective callback. Hooks returning false will skip the instruction
     */
    pub fn execute(
        &self,
        state: &mut State,
        instr: &Instruction,
        flags: &HashSet<InstructionFlag>,
        words: &[Word],
    ) {
        if state.check && state.check_crash(&vc(instr.offset), &vc(instr.size), 'x') {
            return;
        }

        let pc = instr.offset;
        state.esil.prev_pc = vc(pc);
        let new_pc = instr.offset.wrapping_add(instr.size);

        state.esil.pcs.clear();
        if instr.jump != 0 {
            state.esil.pcs.push(instr.jump);

            if instr.fail != 0 {
                state.esil.pcs.push(instr.fail);
            }
        }

        //let mut new_status = status;
        let mut new_flags = flags.clone();
        if state.status == StateStatus::PostMerge && flags.contains(&InstructionFlag::Merge) {
            state.status = StateStatus::Active;
            new_flags.remove(&InstructionFlag::Merge);
        }

        if instr.type_num == CALL_TYPE {
            state.backtrace.push((instr.jump, new_pc));
        }

        // skip executing this instruction
        let mut skip = false;
        let mut update = true;
        if !new_flags.is_empty() {
            if new_flags.contains(&InstructionFlag::Hook) {
                let hooks = &self.hooks[&pc];
                for hook in hooks {
                    skip = !hook(state) || skip;
                }
            }
            if new_flags.contains(&InstructionFlag::ESILHook) {
                let esils = &self.esil_hooks[&pc];
                for esil in esils {
                    self.parse_expression(state, esil);
                    let val = pop_concrete(state, false, false);
                    skip = (val != 0) || skip;
                }
            }
            if state.registers.get_pc() != vc(pc) {
                update = false; // hook changed pc dont update
            }
            if new_flags.contains(&InstructionFlag::Sim) {
                let sim = &self.sims[&pc];
                let cc = state.r2api.get_cc(pc).unwrap_or_default();
                let args = self.get_args(state, &cc);

                let ret = (sim.function)(state, &args);
                state.registers.set_with_alias(cc.ret.as_str(), ret);

                // don't ret if sim changes the PC value
                // this is bad hax because thats all i do
                if state.registers.get_pc() == vc(pc) {
                    self.ret(state);
                }
                skip = true;
                update = false;
            }
            if new_flags.contains(&InstructionFlag::Break) {
                state.status = StateStatus::Break;
                skip = true;
                update = false;
            }
            if new_flags.contains(&InstructionFlag::Merge) {
                state.status = StateStatus::Merge;
                skip = true;
                update = false;
            }
            if new_flags.contains(&InstructionFlag::Avoid) {
                state.status = StateStatus::Inactive;
                skip = true;
                update = false;
            }
        }

        if update {
            let pc_val = Value::Concrete(new_pc, 0);
            state.registers.set_pc(pc_val);
        }

        if !skip {
            if state.strict && instr.disasm == "invalid" {
                //panic!("Executed invalid instruction");
                state.set_inactive();
            } else {
                self.parse(state, words);
            }
        }

        if instr.type_num == RETN_TYPE {
            if state.backtrace.is_empty() && new_flags.is_empty() {
                // try to avoid returning outside valid context
                if let Value::Concrete(v, _) = state.registers.get_pc() {
                    if v == 0 || !state.memory.check_permission(v, 1, 'x') {
                        // if it looks invalid
                        let avoid = !self.breakpoints.is_empty() || (!self.automerge && !self.esil_hooks.is_empty());
                        if  avoid {
                            state.status = StateStatus::Inactive;
                        } else {
                            // break if there are no other breakpoints/hooks
                            state.status = StateStatus::Break;
                        }
                    }
                }
            } else {
                state.backtrace.pop();
            }
        } else if self.automerge && instr.type_num < 2 { 
            state.status = StateStatus::Merge;
        }
    }

    // weird method that just performs a return
    pub fn ret(&self, state: &mut State) {
        let ret_esil = state.r2api.get_ret().unwrap_or_default();
        if ret_esil != "" {
            self.parse_expression(state, ret_esil.as_str());
            state.backtrace.pop();
        } else if let Some(bt) = state.backtrace.pop() {
            state.registers.set_pc(vc(bt.1));
        }
    }

    // get the instruction, set its status, tokenize if necessary
    // and optimize if enabled. TODO this has become so convoluted, fix it
    pub fn fetch_instruction(&mut self, state: &mut State, pc_val: u64) {
        let has_instr = self.instructions.contains_key(&pc_val);
        if self.selfmodify || !has_instr {
            let mut pc_tmp = pc_val;
            let instrs = if self.selfmodify {
                let data = state.memory_read_bytes(pc_val, 32);
                // 1 at a time for selfmodify
                // check to see if bytes changed
                if has_instr {
                    let instr = &self.instructions[&pc_val];
                    let bytes = hex_decode(&instr.instruction.bytes);
                    if bytes == data[..bytes.len()].to_vec() {
                        // nothing needs to be done but this is
                        // such a weird construction. i hate this code
                        return;
                    }
                }
                state
                    .r2api
                    .disassemble_bytes(pc_val, &data, 1)
                    .unwrap_or_default()
            } else {
                state
                    .r2api
                    .disassemble(pc_val, INSTR_NUM)
                    .unwrap_or_default()
            };

            let mut prev: Option<u64> = None;
            for instr in instrs {
                let size = instr.size;
                let words = self.tokenize(state, &instr.esil);

                let mut flags = HashSet::new();
                let mut opt = self.optimized && !self.selfmodify;
                if self.hooks.contains_key(&pc_tmp) {
                    flags.insert(InstructionFlag::Hook);
                }
                if self.esil_hooks.contains_key(&pc_tmp) {
                    flags.insert(InstructionFlag::ESILHook);
                }
                if self.breakpoints.contains(&pc_tmp) {
                    flags.insert(InstructionFlag::Break);
                }
                if self.mergepoints.contains(&pc_tmp) {
                    flags.insert(InstructionFlag::Merge);
                }
                if self.avoidpoints.contains(&pc_tmp) {
                    flags.insert(InstructionFlag::Avoid);
                }
                if self.sims.contains_key(&pc_tmp) {
                    flags.insert(InstructionFlag::Sim);
                }

                // don't optimize if hooked / bp for accuracy
                if !flags.is_empty() {
                    opt = false;
                }

                let instr_entry = InstructionEntry {
                    instruction: instr,
                    tokens: words,
                    flags,
                };

                if opt {
                    if let Some(prev_pc) = prev {
                        self.optimize(state, prev_pc, &instr_entry);
                    }
                    prev = Some(pc_tmp);
                }
                self.instructions.insert(pc_tmp, instr_entry);
                pc_tmp = pc_tmp.wrapping_add(size);
            }
        }
    }

    pub fn execute_instruction(&mut self, state: &mut State, pc_val: u64) {
        self.fetch_instruction(state, pc_val);

        // the hash lookup is done twice, needs fixing
        let instr = self.instructions.get(&pc_val).unwrap();

        if self.debug {
            self.print_instr(state, &instr.instruction);
        }
        self.execute(state, &instr.instruction, &instr.flags, &instr.tokens);
    }

    /// Take single step with the state provided
    pub fn step(&mut self, state: &mut State) -> Vec<State> {
        self.steps += 1;
        state.visit();

        let pc_allocs = 32;
        let pc_value = state.registers.get_pc();

        if let Some(pc_val) = pc_value.as_u64() {
            self.execute_instruction(state, pc_val);
        } else {
            panic!("got an unexpected sym PC: {:?}", pc_value);
        }

        let new_pc = state.registers.get_pc();

        if self.force && !state.esil.pcs.is_empty() {
            // we just use the pcs in state.esil.pcs
        } else if let Some(pc) = new_pc.as_u64() {
            state.esil.pcs.clear();
            state.esil.pcs.push(pc);
        } else {
            let pc_val = new_pc.as_bv().unwrap();
            if self.debug {
                println!("\n{} : {:?}\n", "symbolic PC".red(), pc_val);
            }

            if DO_EVENT_HOOKS && state.has_event_hooks {
                state.do_hooked(
                    &Event::SymbolicExec(EventTrigger::Before),
                    &EventContext::ExecContext(new_pc.clone(), vec![]),
                );
            }

            if !self.lazy && !state.esil.pcs.is_empty() {
                // testing sat without modelgen is a bit faster than evaluating
                state.esil.pcs = state
                    .esil
                    .pcs
                    .clone()
                    .into_iter()
                    .filter(|x| state.check(&new_pc.eq(&vc(*x))))
                    .collect();
            } else if state.esil.pcs.is_empty() {
                let bps = self.breakpoints.clone();
                state.esil.pcs = bps.into_iter()
                    .filter(|bp| state.check(&new_pc.eq(&vc(*bp))))
                    .collect();

                if state.esil.pcs.is_empty() {
                    state.esil.pcs = state.evaluate_many(&pc_val);
                }
            }

            if DO_EVENT_HOOKS && state.has_event_hooks {
                state.do_hooked(
                    &Event::SymbolicExec(EventTrigger::After),
                    &EventContext::ExecContext(new_pc.clone(), state.esil.pcs.clone()),
                );
            }
        }

        if state.esil.pcs.len() > 1 || new_pc.as_u64().is_none() {
            let mut states: Vec<State> = Vec::with_capacity(pc_allocs);

            // this function is kind of a mess this should be refactored
            if state.esil.pcs.is_empty() && new_pc.as_u64().is_none() {
                state.set_inactive();
                return states;
            }

            let last = state.esil.pcs.len() - 1;
            for new_pc_val in &state.esil.pcs[..last] {
                let mut new_state = state.clone();
                if let Some(pc_val) = new_pc.as_bv() {
                    let a = pc_val._eq(&new_state.bvv(*new_pc_val, pc_val.get_width()));
                    new_state.solver.assert_bv(&a);
                }
                new_state.registers.set_pc(Value::Concrete(*new_pc_val, 0));
                states.push(new_state);
            }

            let new_pc_val = state.esil.pcs[last];
            if let Some(pc_val) = new_pc.as_bv() {
                let pc_bv = pc_val;
                let a = pc_bv._eq(&state.bvv(new_pc_val, pc_bv.get_width()));
                state.solver.assert_bv(&a);
            }
            state.registers.set_pc(Value::Concrete(new_pc_val, 0));
            states
        } else if self.selfmodify {
            let mut states: Vec<State> = Vec::with_capacity(pc_allocs);

            // this is bad, 8 bytes is not enough, but this is what it is for now
            let mem = state.memory_read_value(&new_pc, 8);
            if let Value::Symbolic(bv, _t) = &mem {
                let possible = state.evaluate_many(bv);
                if !possible.is_empty() {
                    let last = possible.len() - 1;
                    for pos in &possible[..last] {
                        let mut new_state = state.clone();
                        new_state.assert(&mem.eq(&vc(*pos)));
                        states.push(new_state);
                    }
                    state.assert(&mem.eq(&vc(possible[last])));
                }
            }
            states
        } else {
            vec![]
        }
    }

    /// run the state until completion based on mode
    pub fn run(&mut self, state: State, mode: RunMode) -> Vec<State> {
        // use binary heap as priority queue to prioritize states
        // that have the lowest number of visits for the current PC
        let mut states = BinaryHeap::new();
        let mut results = vec![];
        states.push(Rc::new(state));

        // run until empty for single, until split for parallel
        // or until every state is at the breakpoint for multiple
        let split = mode == RunMode::Parallel;
        let step = mode == RunMode::Step;

        loop {
            //println!("{} states", states.len());
            if states.is_empty() {
                if self.merges.is_empty() {
                    return results;
                } else {
                    // pop one out of mergers
                    // let key = *self.merges.keys().next().unwrap();
                    // let mut merge = self.merges.remove(&key).unwrap();
                    let (_k, mut merge) = self.merges.pop_first().unwrap();
                    merge.status = StateStatus::PostMerge;
                    states.push(Rc::new(merge));
                }
            }

            let mut current_rc = states.pop().unwrap();
            let current_state = Rc::make_mut(&mut current_rc);

            match current_state.status {
                StateStatus::Active | StateStatus::PostMerge => {
                    let new_states = self.step(current_state);
                    // ugly but prevents lots of wasted effort, needs serious refactor
                    if current_state.status == StateStatus::Break && current_state.is_sat() {
                        if mode != RunMode::Multiple {
                            results.push(current_state.to_owned());
                            return results;
                        }
                    }
                    for mut state in new_states {
                        if state.status == StateStatus::Break && state.is_sat() {
                            if mode != RunMode::Multiple {
                                results.push(state.to_owned());
                                return results;
                            }
                        }
                        states.push(Rc::new(state));
                    }
                    states.push(current_rc);
                }
                StateStatus::Merge => {
                    self.merge(current_state.to_owned());
                }
                StateStatus::Break => {
                    if current_state.is_sat() {
                        results.push(current_state.to_owned());
                        if mode != RunMode::Multiple {
                            return results;
                        }
                    }
                }
                StateStatus::Crash(_addr, _len) => {
                    self.crashes.push(current_state.to_owned());
                }
                _ => {}
            }

            // single step mode always returns states
            if step || (split && states.len() > 1) {
                while let Some(mut state) = states.pop() {
                    results.push(Rc::make_mut(&mut state).to_owned());
                }
                return results;
            }
        }
    }

    pub fn merge(&mut self, mut state: State) {
        let pc = state.registers.get_pc().as_u64().unwrap();
        if let Some(merge_state) = self.merges.get_mut(&pc) {
            merge_state.merge(&mut state);
        } else {
            self.merges.insert(pc, state);
        }
    }
}

```

`radius/src/r2_api.rs`:

```rs
use r2pipe::{R2Pipe, R2PipeSpawnOptions};
use serde::{Deserialize, Deserializer, Serialize};
use std::sync::{Arc, Mutex};
use std::u64;
use std::u8;
//use ahash::AHashMap;
//type HashMap<P, Q> = AHashMap<P, Q>;

use std::collections::HashMap;
use std::path::Path;
use std::{thread, time};

pub const STACK_START: u64 = 0xfff00000;
pub const STACK_SIZE: u64 = 0x78000 * 2;

#[derive(Debug, Clone, PartialEq)]
pub enum Endian {
    Little,
    Big,
    Mixed,
    Unknown,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Mode {
    Default,
    Debugger,
    Frida,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallingConvention {
    pub ret: String,
    pub args: Vec<String>,
}

impl Default for CallingConvention {
    fn default() -> Self {
        CallingConvention {
            ret: String::from("A0"),
            args: vec![
                String::from("A0"),
                String::from("A1"),
                String::from("A2"),
                // String::from("A3"),
            ],
        }
    }
}

impl Endian {
    pub fn from_string(end: &str) -> Endian {
        match end {
            "little" => Endian::Little,
            "big" => Endian::Big,
            "mixed" => Endian::Mixed,
            _ => Endian::Unknown,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Instruction {
    #[serde(alias = "addr")]
    pub offset: u64,
    pub size: u64,

    #[serde(default = "invalid")]
    pub opcode: String,

    #[serde(default = "invalid")]
    pub disasm: String,

    #[serde(default)]
    pub esil: String,

    #[serde(default = "blank")]
    pub bytes: String,

    #[serde(default = "invalid")]
    pub r#type: String,

    #[serde(default)]
    pub type_num: u64,

    #[serde(default)]
    pub jump: u64,

    #[serde(default)]
    pub fail: u64,
}

fn invalid() -> String {
    "invalid".to_string()
}

fn blank() -> String {
    "".to_string()
}

fn zero() -> i64 {
    0
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Segment {
    pub name: String,
    pub size: u64,
    pub vsize: u64,
    pub perm: String,
    pub paddr: u64,
    pub vaddr: u64,
}

#[derive(Debug)]
pub struct Permission {
    pub initialized: bool,
    pub read: bool,
    pub write: bool,
    pub execute: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AliasInfo {
    pub reg: String,
    pub role: u64,
    pub role_str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegisterInfo {
    pub name: String,
    pub r#type: u64,
    pub type_str: String,
    pub size: u64,
    pub offset: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegisterInformation {
    pub alias_info: Vec<AliasInfo>,
    pub reg_info: Vec<RegisterInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CoreInfo {
    pub file: String,

    #[serde(default)]
    pub size: i64,
    pub mode: String,
    pub format: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BinInfo {
    pub arch: String,
    pub bintype: String,
    pub bits: u64,
    pub canary: bool,
    pub endian: String,
    pub os: String,
    pub nx: bool,
}

impl Default for BinInfo {
    fn default() -> Self {
        BinInfo {
            arch: "".to_string(),
            bintype: "".to_string(),
            bits: 64,
            canary: false,
            endian: "little".to_string(),
            os: "".to_string(),
            nx: false,
        }
    }
}

impl Default for CoreInfo {
    fn default() -> Self {
        CoreInfo {
            file: "".to_string(),
            size: 0,
            mode: "".to_string(),
            format: "".to_string(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Default, Deserialize)]
pub struct Information {
    #[serde(default)]
    pub core: CoreInfo,

    #[serde(default)]
    pub bin: BinInfo,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Syscall {
    pub name: String,
    pub swi: u64,
    pub num: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchResult {
    pub r#type: String,
    pub offset: u64,
    pub data: String,
}


#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisasmSearchResult {
    pub addr: u64,
    pub size: u64,
    pub opstr: String,
    pub r#type: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisasmSearchResults {
    pub cmd: String,
    pub arg: String,
    pub result: Vec<DisasmSearchResult>
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrossRef {
    pub addr: u64,
    pub r#type: String,
    pub at: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VarRef {
    pub base: String,
    pub offset: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Variable {
    pub name: String,
    pub kind: String,
    pub r#type: String,
    pub r#ref: VarRef,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionInfo {
    pub offset: u64,
    pub name: String,
    pub size: u64,
    pub realsz: u64,
    pub noreturn: bool,
    pub stackframe: u64,
    pub calltype: String,
    pub cost: u64,
    pub cc: u64,
    pub bits: u64,
    pub r#type: String,
    pub nbbs: u64, // number of basic blocks
    pub edges: u64,
    pub ebbs: u64,
    pub signature: String,
    pub minbound: u64,
    pub maxbound: u64,
    pub callrefs: Vec<CrossRef>,
    pub datarefs: Vec<u64>,
    pub codexrefs: Vec<CrossRef>,
    pub dataxrefs: Vec<CrossRef>,
    pub indegree: u64,
    pub outdegree: u64,
    pub nlocals: u64,
    pub nargs: u64,
    pub bpvars: Vec<Variable>,
    pub spvars: Vec<Variable>,
    pub regvars: Vec<Variable>,
    pub difftype: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BasicBlock {
    pub opaddr: u64,
    pub addr: u64,
    pub size: u64,
    pub inputs: u64,
    pub outputs: u64,
    pub ninstr: u64,
    pub traced: bool,

    #[serde(default)]
    pub jump: u64,

    #[serde(default)]
    pub fail: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Symbol {
    pub name: String,
    pub flagname: String,
    pub realname: String,
    pub ordinal: usize,
    pub bind: String,
    pub size: usize,
    pub r#type: String,
    pub vaddr: u64,
    pub paddr: u64,
    pub is_imported: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Import {
    #[serde(default)]
    pub ordinal: usize,

    #[serde(default)]
    pub bind: String,

    #[serde(default)]
    pub r#type: String,

    #[serde(default)]
    pub name: String,

    #[serde(default)]
    pub plt: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FridaImport {
    pub index: usize,
    pub module: String,
    pub r#type: String,
    pub name: String,

    #[serde(deserialize_with = "from_hex")]
    pub address: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Export {
    name: String,
    flagname: String,
    realname: String,
    ordinal: usize,
    bind: String,
    size: usize,
    r#type: String,
    vaddr: u64,
    paddr: u64,
    is_imported: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObjCClassMethod {
    pub name: String,
    pub addr: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObjCClassField {
    pub name: String,
    pub addr: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JavaClassMethod {
    pub name: String,
    pub vaddr: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JavaClassField {
    pub name: String,
    pub vaddr: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObjCClassInfo {
    pub classname: String,

    #[serde(default)]
    pub methods: Vec<ObjCClassMethod>,

    #[serde(default)]
    pub fields: Vec<ObjCClassField>,

    pub addr: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JavaClassInfo {
    pub classname: String,
    pub vaddr: u64,

    #[serde(default)]
    pub index: i64,
    //pub r#super: String,
    #[serde(default)]
    pub methods: Vec<JavaClassMethod>,

    #[serde(default)]
    pub fields: Vec<JavaClassField>,

    #[serde(rename = "super", default)]
    pub superclass: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Relocation {
    #[serde(default = "blank")]
    pub name: String,
    pub vaddr: u64,
    pub paddr: u64,
    pub r#type: String,
    pub demname: String,
    pub is_ifunc: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct File {
    pub raised: bool,
    pub fd: usize,
    pub uri: String,
    pub from: u64,
    pub writable: bool,
    pub size: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FridaInfo {
    pub arch: String,
    pub bits: u64,
    pub os: String,
    pub pid: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Entrypoint {
    pub vaddr: u64,
    pub paddr: u64,
    pub baddr: u64,
    pub laddr: u64,
    pub haddr: u64,
    pub r#type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Reference {
    pub from: u64,
    pub r#type: String,
    pub opcode: String,

    #[serde(default)]
    pub fcn_addr: u64,

    #[serde(default)]
    pub fcn_name: String,

    #[serde(default)]
    pub refname: String,
}

fn from_hex<'de, D>(deserializer: D) -> Result<u64, D::Error>
where
    D: Deserializer<'de>,
{
    let s: &str = Deserialize::deserialize(deserializer)?;
    if s.len() > 2 {
        Ok(u64::from_str_radix(&s[2..], 16).unwrap_or(0))
    } else {
        Ok(0)
    }
}

pub type R2Result<T> = Result<T, String>;
pub fn r2_result<T, E>(result: Result<T, E>) -> R2Result<T> {
    if let Ok(res) = result {
        Ok(res)
    } else {
        Err("Deserialization error".to_owned())
    }
}

pub fn hex_encode(data: &[u8]) -> String {
    data.iter()
        .map(|d| format!("{:02x}", *d))
        .collect::<Vec<_>>()
        .join("")
}

pub fn hex_decode(data: &str) -> Vec<u8> {
    let mut result = Vec::with_capacity(data.len());
    for i in 0..data.len() / 2 {
        result.push(u8::from_str_radix(&data[2 * i..2 * i + 2], 16).unwrap());
    }
    result
}

// #[derive(DerefMut)]
#[derive(Clone)]
pub struct R2Api {
    pub r2p: Arc<Mutex<R2Pipe>>,
    //pub instructions: HashMap<u64, Instruction>,
    //pub permissions: HashMap<u64, Permission>,
    pub info: Information,
    pub mode: Mode,
    do_cache: bool,
    cache: HashMap<String, String>,
}

impl R2Api {
    pub fn new<T: AsRef<str>>(filename: Option<T>, opts: Option<Vec<&'static str>>) -> R2Api {
        let options = &opts.as_ref().map(|o| R2PipeSpawnOptions {
            exepath: "r2".to_owned(),
            args: o.to_owned(),
        });

        let r2pipe = match (&filename, &opts) {
            (None, _) => R2Pipe::open(),
            (Some(name), _) => R2Pipe::spawn(name, options.to_owned()),
            // _ => Err(Error::NoSession),
        };

        let mut r2api = R2Api {
            r2p: Arc::new(Mutex::new(r2pipe.unwrap())),
            info: Information::default(),
            mode: Mode::Default,
            do_cache: true,
            cache: HashMap::new(),
        };

        r2api.info = r2api.get_info().unwrap();
        r2api.mode = if r2api.info.core.file.starts_with("frida:") {
            let _ = r2api.cmd("s `:il~[0]`"); // seek to first module
            Mode::Frida
        } else if r2api.info.core.file.starts_with("dbg:") {
            Mode::Debugger
        } else {
            Mode::Default
        };

        if r2api.mode == Mode::Frida {
            let info = r2api.get_frida_info().unwrap();
            r2api.info.bin.arch = info.arch;
            r2api.info.bin.bits = info.bits;
        }

        // if we are on arm64 default to v35 plugin
        // nevermind its very broken due to changes to post/pre indexes?
        // if r2api.info.bin.arch == "arm" && r2api.info.bin.bits == 64 {
        //     r2api.set_option("asm.arch", "arm.v35").unwrap_or_default();
        // }

        r2api
    }

    pub fn cmd(&mut self, cmd: &str) -> R2Result<String> {
        Ok(self.r2p.lock().unwrap().cmd(cmd).unwrap_or_default())
    }

    // cached command
    pub fn ccmd(&mut self, cmd: &str) -> R2Result<String> {
        if self.do_cache {
            if let Some(result) = self.cache.get(cmd) {
                Ok(result.to_owned())
            } else {
                let result = self.cmd(cmd)?;
                self.cache.insert(cmd.to_owned(), result.clone());
                Ok(result)
            }
        } else {
            self.cmd(cmd)
        }
    }

    pub fn get_info(&mut self) -> R2Result<Information> {
        let json = self.cmd("ij")?;
        Ok(serde_json::from_str(json.as_str()).unwrap())
    }

    pub fn get_frida_info(&mut self) -> R2Result<FridaInfo> {
        let json = self.cmd(":ij")?;
        Ok(serde_json::from_str(json.as_str()).unwrap())
    }

    pub fn get_registers(&mut self) -> R2Result<RegisterInformation> {
        let json = self.cmd("aerpj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_cc(&mut self, pc: u64) -> R2Result<CallingConvention> {
        let json = self.ccmd(format!("af @ {}; afcrj @ {}", pc, pc).as_str())?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_shellcode(&mut self, cmd: &str) -> R2Result<Vec<u8>> {
        let result = self.ccmd(&format!("gr;gi exec;gc cmd={};g", cmd))?;
        Ok(hex_decode(&result))
    }

    /*
        arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes
    ──────────────────────────────────────────────────────────────
    alpha         a0    a1    a2    a3    a4    a5    -
    arc           r0    r1    r2    r3    r4    r5    -
    arm/OABI      a1    a2    a3    a4    v1    v2    v3
    arm/EABI      r0    r1    r2    r3    r4    r5    r6
    arm64         x0    x1    x2    x3    x4    x5    -
    blackfin      R0    R1    R2    R3    R4    R5    -
    i386          ebx   ecx   edx   esi   edi   ebp   -
    ia64          out0  out1  out2  out3  out4  out5  -
    m68k          d1    d2    d3    d4    d5    a0    -
    microblaze    r5    r6    r7    r8    r9    r10   -
    mips/o32      a0    a1    a2    a3    -     -     -     [1]
    mips/n32,64   a0    a1    a2    a3    a4    a5    -
    nios2         r4    r5    r6    r7    r8    r9    -
    parisc        r26   r25   r24   r23   r22   r21   -
    powerpc       r3    r4    r5    r6    r7    r8    r9
    riscv         a0    a1    a2    a3    a4    a5    -
    s390          r2    r3    r4    r5    r6    r7    -
    s390x         r2    r3    r4    r5    r6    r7    -
    superh        r4    r5    r6    r7    r0    r1    r2
    sparc/32      o0    o1    o2    o3    o4    o5    -
    sparc/64      o0    o1    o2    o3    o4    o5    -
    tile          R00   R01   R02   R03   R04   R05   -
    x86-64        rdi   rsi   rdx   r10   r8    r9    -
    x32           rdi   rsi   rdx   r10   r8    r9    -
    xtensa        a6    a3    a4    a5    a8    a9    -
    */

    pub fn get_syscall_cc(&mut self) -> R2Result<CallingConvention> {
        // this sucks, need a central place for arch stuff
        match (self.info.bin.arch.as_str(), self.info.bin.bits) {
            ("x86", 32) => Ok(CallingConvention {
                args: vec![
                    "ebx".to_string(),
                    "ecx".to_string(),
                    "edx".to_string(),
                    "esi".to_string(),
                    "edi".to_string(),
                    "ebp".to_string(),
                ],
                ret: "eax".to_string(),
            }),
            ("x86", 64) => Ok(CallingConvention {
                args: vec![
                    "rdi".to_string(),
                    "rsi".to_string(),
                    "rdx".to_string(),
                    "r10".to_string(),
                    "r8".to_string(),
                    "r9".to_string(),
                ],
                ret: "rax".to_string(),
            }),
            // 16 is thumb mode, need to handle better
            ("arm", 16) | ("arm", 32) => Ok(CallingConvention {
                args: vec![
                    "r0".to_string(),
                    "r1".to_string(),
                    "r2".to_string(),
                    "r3".to_string(),
                    "r4".to_string(),
                    "r5".to_string(),
                    "r6".to_string(),
                ],
                ret: "r0".to_string(),
            }),
            ("arm", 64) => Ok(CallingConvention {
                args: vec![
                    "x0".to_string(),
                    "x1".to_string(),
                    "x2".to_string(),
                    "x3".to_string(),
                    "x4".to_string(),
                    "x5".to_string(),
                    "x6".to_string(),
                    "x7".to_string(),
                    "x8".to_string(), // supposedly xnu/ios can have up 9 args
                ],
                ret: "x0".to_string(),
            }),
            ("riscv", _) | ("mips", _) => Ok(CallingConvention {
                args: vec![
                    "a0".to_string(),
                    "a1".to_string(),
                    "a2".to_string(),
                    "a3".to_string(),
                    "a4".to_string(),
                    "a5".to_string(),
                ],
                ret: "a0".to_string(),
            }),
            ("sparc", _) => Ok(CallingConvention {
                args: vec![
                    "o0".to_string(),
                    "o1".to_string(),
                    "o2".to_string(),
                    "o3".to_string(),
                    "o4".to_string(),
                    "o5".to_string(),
                ],
                ret: "o0".to_string(),
            }),
            ("ppc", _) => Ok(CallingConvention {
                args: vec![
                    "r3".to_string(),
                    "r4".to_string(),
                    "r5".to_string(),
                    "r6".to_string(),
                    "r7".to_string(),
                    "r8".to_string(),
                    "r9".to_string(),
                ],
                ret: "r3".to_string(), // TODO errors are in r0
            }),
            ("xtensa", _) => Ok(CallingConvention {
                args: vec![
                    "a6".to_string(),
                    "a3".to_string(),
                    "a4".to_string(),
                    "a5".to_string(),
                    "a8".to_string(),
                    "a9".to_string(),
                ],
                ret: "a2".to_string(),
            }),
            _ => Err("calling convention not found".to_owned()),
        }
    }

    /*pub fn get_classes(&mut self) -> R2Result<Vec<ClassInfo>> {
        let json = self.cmd("icj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }*/

    pub fn get_objc_class(&mut self, class: &str) -> R2Result<ObjCClassInfo> {
        let json = self.ccmd(&format!("icj {}", class))?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_java_class(&mut self, class: &str) -> R2Result<JavaClassInfo> {
        let json = self.ccmd(&format!("icj {}", class))?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    /*pub fn get_class_map(&mut self) -> R2Result<HashMap<String, ClassInfo>> {
        let classes = self.get_classes()?;
        let mut class_map = HashMap::new();
        for c in &classes {
            class_map.insert(c.classname.clone(), c.to_owned());
        }
        Ok(class_map)
    }*/

    pub fn get_segments(&mut self) -> R2Result<Vec<Segment>> {
        let json = self.ccmd("iSj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn analyze(&mut self, n: usize) -> R2Result<String> {
        // n = 14 automatically wins flareon
        self.cmd("a".repeat(n).as_str())
    }

    pub fn get_function_info(&mut self, addr: u64) -> R2Result<FunctionInfo> {
        let json = self.cmd(format!("afij @ {}", addr).as_str())?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_functions(&mut self) -> R2Result<Vec<FunctionInfo>> {
        let json = self.cmd("aflj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_references(&mut self, addr: u64) -> R2Result<Vec<Reference>> {
        let json = self.cmd(&format!("axtj {}", addr))?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    /*pub fn get_strings(&mut self) -> R2Result<Vec<Reference>> {
        let json = self.cmd("izzj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }*/

    pub fn search(&mut self, string: &str) -> R2Result<Vec<SearchResult>> {
        let json = self.cmd(&format!("/j {}", string))?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn search_bytes(&mut self, data: &[u8]) -> R2Result<Vec<SearchResult>> {
        let json = self.cmd(&format!("/xj {}", hex_encode(data)))?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    /// Gets all strings then filters, slower than search
    pub fn search_strings(&mut self, string: &str) -> R2Result<Vec<u64>> {
        let result = self.ccmd(&format!("izz~[2]~{}", string))?;
        Ok(result
            .trim()
            .split('\n')
            .map(|x| u64::from_str_radix(&x[2..], 16).unwrap_or_default())
            .filter(|x| *x != 0)
            .collect())
    }

    pub fn get_blocks(&mut self, addr: u64) -> R2Result<Vec<BasicBlock>> {
        let cmd = format!("af @ {}; afbj @ {}", addr, addr);
        let json = self.cmd(cmd.as_str())?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_ret(&mut self) -> R2Result<String> {
        // simple as that?
        let ret = self.ccmd("pae ret")?;
        if ret.is_empty() {
            if self.info.bin.arch == "bpf" {
                Ok("8,sp,+=,sp,[8],pc,=".to_owned())
            } else {
                Err("no ret instruction".to_owned())
            }
        } else {
            Ok(ret[0..ret.len() - 1].to_owned())
        }
    }

    pub fn get_register_value(&mut self, reg: &str) -> R2Result<u64> {
        let val = self.cmd(&format!("aer {}", reg))?;
        if val.len() > 2 {
            Ok(u64::from_str_radix(&val[2..val.len() - 1], 16).unwrap_or_default())
        } else {
            Ok(0) // return 0 if the reg doesnt exist (pdgp hax)
        }
    }

    pub fn set_register_value(&mut self, reg: &str, value: u64) {
        let cmd = format!("aer {}={}", reg, value);
        let _r = self.cmd(cmd.as_str());
    }

    pub fn get_syscall_str(&mut self, sys_num: u64) -> R2Result<String> {
        let cmd = format!("asl {}", sys_num);
        let ret = self.ccmd(cmd.as_str())?;
        Ok(ret[0..ret.len() - 1].to_owned())
    }

    pub fn get_syscall_num(&mut self, sys_str: &str) -> R2Result<u64> {
        let cmd = format!("asl {}", sys_str);
        let ret = self.ccmd(cmd.as_str())?;
        Ok((&ret[0..ret.len() - 1]).parse::<u64>().unwrap())
    }

    pub fn get_syscalls(&mut self) -> R2Result<Vec<Syscall>> {
        let json = self.cmd("asj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn seek(&mut self, addr: u64) {
        let _r = self.cmd(format!("s {}", addr).as_str());
    }

    pub fn breakpoint(&mut self, addr: u64) -> R2Result<String> {
        match self.mode {
            Mode::Debugger => self.cmd(format!("db {}", addr).as_str()),
            Mode::Frida => self.cmd(format!(":db {}", addr).as_str()),
            _ => Ok("idk".to_string()),
        }
    }

    /// continue concrete execution
    pub fn cont(&mut self) -> R2Result<String> {
        match self.mode {
            Mode::Debugger => self.cmd("dc"),
            Mode::Frida => self.cmd(":dc"),
            _ => self.cmd("aec"),
        }
    }

    pub fn init_debug(&mut self, addr: u64, args: &[String]) {
        (match self.mode {
            Mode::Debugger => self.cmd(&format!("db {};dc", addr)),
            Mode::Frida => panic!("can't enter debug from frida mode, also why would you?"),
            _ => {
                self.mode = Mode::Debugger;
                self.cmd(&format!("doo {};db {};dc", args.join(" "), addr))
            }
        })
        .unwrap_or_default();
    }

    pub fn init_vm(&mut self) {
        let _r = self.cmd(&format!("aei; aeim {} {}", STACK_START, STACK_SIZE));
    }

    pub fn init_entry(&mut self, args: &[String], vars: &[String]) {
        let argc = args.len();
        let argv = args.join(" ");
        let env = vars.join(" ");
        self.init_vm();
        // this is very weird but this is how it works
        let _r = self.cmd(&format!(".aeis {} {} {} @ SP", argc, argv, env));
    }

    pub fn init_frida(&mut self, addr: u64) -> R2Result<HashMap<String, u64>> {
        // we are reaching levels of jankiness previously thought to be impossible
        let _alloc = self.cmd(": global.mem = Memory.alloc(0x2000)")?;
        let func = format!(
            // experimenting with increasingly shitty ways to suspend.
            "{{global.mem.writeUtf8String(JSON.stringify(this.context,{}))}}",
            // need this to convert everything to strings oof
            "function(k,v){return v && typeof v === 'object' && Object.keys(v).length ? v:''+v}",
            // need this to wait for continue, nvmd doesnt work
            // "(function(){while(global.mem.readU8()){Thread.sleep(1)}})()"
        );

        let script_data = format!(
            ": Interceptor.attach(ptr('0x{:x}'),function(){});",
            addr, func
        );

        self.cmd(&script_data).unwrap();
        loop {
            thread::sleep(time::Duration::from_millis(100));
            let out = self.cmd(": global.mem.readUtf8String()")?;
            if out.starts_with("{") {
                let context: Result<HashMap<String, String>, _> = serde_json::from_str(&out);
                break Ok(self.parse_context(context.unwrap_or_default()));
            }
        }
    }

    fn parse_context(&self, context: HashMap<String, String>) -> HashMap<String, u64> {
        let mut newcon = HashMap::new();
        for reg in context.keys() {
            if context[reg].starts_with("0x") {
                newcon.insert(
                    reg.to_owned(),
                    u64::from_str_radix(&context[reg][2..], 16).unwrap_or(0),
                );
            } else if context[reg].contains(".") {
                // cant know if these are f32 or f64 so this will be wrong half the time. this sucks
                newcon.insert(
                    reg.to_owned(),
                    f64::to_bits(context[reg].parse::<f64>().unwrap_or(0.0)),
                );
            } else if !context[reg].starts_with("[") {
                newcon.insert(
                    reg.to_owned(),
                    u64::from_str_radix(&context[reg], 10).unwrap_or(0),
                );
            }
        }
        newcon
    }

    pub fn set_option(&mut self, key: &str, value: &str) -> R2Result<String> {
        self.cmd(format!("e {}={}", key, value).as_str())
    }

    // is.j returns a weird format
    pub fn get_symbol(&mut self, addr: u64) -> R2Result<Symbol> {
        let json = self.ccmd(&format!("is.j @ {}", addr))?;
        let result: Option<HashMap<String, Symbol>> = serde_json::from_str(json.as_str()).ok();
        if let Some(mut symmap) = result {
            Ok(symmap.remove("symbols").unwrap())
        } else {
            Err("symbol not found".to_owned())
        }
    }

    pub fn get_symbols(&mut self) -> R2Result<Vec<Symbol>> {
        let json = self.ccmd("isj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_imports(&mut self) -> R2Result<Vec<Import>> {
        if self.mode != Mode::Frida {
            let json = self.ccmd("iij")?;
            r2_result(serde_json::from_str(json.as_str()))
        } else {
            // so jank i dont even know
            let json = self.cmd(":iij")?;
            let f_imps: Vec<FridaImport> = serde_json::from_str(json.as_str()).unwrap();

            Ok(f_imps
                .iter()
                .map(|f| Import {
                    name: f.name.to_owned(),
                    r#type: f.r#type.to_owned(),
                    ordinal: f.index,
                    plt: f.address,
                    bind: f.name.to_owned(),
                })
                .collect())
        }
    }

    pub fn get_exports(&mut self) -> R2Result<Vec<Export>> {
        let json = self.ccmd("iEj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn disassemble(&mut self, addr: u64, num: usize) -> R2Result<Vec<Instruction>> {
        let cmd = format!("pdj {} @ {}", num, addr);
        let json = self.cmd(cmd.as_str())?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn disassemble_function(&mut self, addr: u64) -> R2Result<Vec<Instruction>> {
        let cmd = format!("af @ {};pdfj @ {}", addr, addr);
        let json = self.cmd(cmd.as_str())?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn disassemble_bytes(
        &mut self,
        addr: u64,
        data: &[u8],
        num: usize,
    ) -> R2Result<Vec<Instruction>> {
        // this is unfortunately necessary as there is no padj @, i need to make one
        let cmd = format!("wx {} @ {}; pij {} @ {}", hex_encode(data), addr, num, addr);

        let json = self.ccmd(cmd.as_str())?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn search_disasm(&mut self, opcode: &str) -> R2Result<DisasmSearchResults> {
        let cmd = format!("/amj {}", opcode);
        let json = self.ccmd(cmd.as_str())?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn assemble(&mut self, instruction: &str) -> R2Result<Vec<u8>> {
        let cmd = format!("pa {}", instruction);
        let hexpairs = self.ccmd(cmd.as_str())?;
        Ok(hex_decode(&hexpairs))
    }

    pub fn read(&mut self, addr: u64, length: usize) -> R2Result<Vec<u8>> {
        let cmd = format!("p8 {} @ {}", length, addr);
        let out = self.cmd(cmd.as_str())?;
        // println!("{}", out);
        Ok(hex_decode(&out))
    }

    pub fn write(&mut self, addr: u64, data: Vec<u8>) {
        let cmd = format!("wx {} @ {}", hex_encode(&data), addr);
        let _r = self.cmd(cmd.as_str());
    }

    // get_address tries to be a bit smart, maybe a bad idea
    pub fn get_address(&mut self, symbol: &str) -> R2Result<u64> {
        let mut val = "".to_owned();
        if self.mode == Mode::Frida {
            let cmd = format!(":isa {}", symbol);
            val = self.cmd(cmd.as_str()).unwrap_or_default();
        }
        if val == "" || val == "0x0\n" {
            for prefix in &["", "sym.", "sym.imp.", "sym.unk."] {
                let cmd = format!("?v {}{}", prefix, symbol);
                val = self.cmd(cmd.as_str()).unwrap_or_default();
                if val != "" && val != "0x0\n" {
                    break;
                }
            }
        }
        if val.len() > 3 {
            r2_result(u64::from_str_radix(&val[2..val.len() - 1], 16))
        } else {
            Ok(0) // to be consistent with r2?
        }
    }

    pub fn get_files(&mut self) -> R2Result<Vec<File>> {
        let json = self.cmd("oj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn set_file(&mut self, path: &str) {
        if let Some(file) = self.get_files().unwrap().iter().find(|f| f.uri == path) {
            self.cmd(format!("op {}", file.fd).as_str()).unwrap();
        }
    }

    pub fn set_file_fd(&mut self, fd: usize) {
        self.cmd(format!("op {}", fd).as_str()).unwrap();
    }

    pub fn get_libraries(&mut self) -> R2Result<Vec<String>> {
        let json = self.ccmd("ilj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_relocations(&mut self) -> R2Result<Vec<Relocation>> {
        let json = self.ccmd("irj")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_entrypoints(&mut self) -> R2Result<Vec<Entrypoint>> {
        let json = self.ccmd("iej")?;
        r2_result(serde_json::from_str(json.as_str()))
    }

    pub fn get_flag(&mut self, addr: u64) -> R2Result<String> {
        self.cmd(&format!("fd @ 0x{:x}", addr))
    }

    // load libraries, return list of full loaded paths
    pub fn load_libraries(&mut self, lib_paths: &[String]) -> R2Result<Vec<String>> {
        let paths = self.load_library_helper(lib_paths, &[])?;
        self.cmd("op 3").unwrap_or_default(); // usually the main module is 3 idk
        Ok(paths)
    }

    // this got a little nuts
    pub fn load_library_helper(
        &mut self,
        lib_paths: &[String],
        loaded_paths: &[String],
    ) -> R2Result<Vec<String>> {
        let bits = self.info.bin.bits;
        let mut sections = self.get_segments().unwrap();
        let relocations = self.get_relocations().unwrap();

        let mut relocation_map = HashMap::new();
        for reloc in &relocations {
            relocation_map.insert(reloc.name.clone(), reloc);
        }

        let mut high_addr = sections.iter().map(|s| s.vaddr).max().unwrap();

        let libs = self.get_libraries()?;

        let mut paths = lib_paths.to_owned();
        paths.push("".to_owned()); // add cur dir ?

        let mut full_paths = loaded_paths.to_owned();

        for lib in &libs {
            for path in &paths {
                let lib_path = Path::new(path)
                    .join(lib)
                    .to_str()
                    .unwrap_or_default()
                    .to_owned();

                let loaded = full_paths.iter().any(|x| x == &lib_path);
                if !loaded && Path::new(&lib_path).exists() {
                    let load_addr = (high_addr & 0xfffffffffffff000) + 0x3000; // idk
                    self.cmd(format!("o {} {}", &lib_path, load_addr).as_str())?;
                    full_paths.push(lib_path);

                    sections = self.get_segments().unwrap();
                    high_addr = sections.iter().map(|s| s.vaddr).max().unwrap();

                    for export in &self.get_exports().unwrap() {
                        if let Some(reloc) = relocation_map.get(&export.name) {
                            // write the export address into the reloc
                            self.cmd(
                                format!("wv{} {} @ {}", bits / 8, export.vaddr, reloc.vaddr)
                                    .as_str(),
                            )?;
                        }
                    }
                    if let Ok(librs) = self.load_library_helper(lib_paths, &full_paths) {
                        full_paths = librs;
                    }
                    break;
                } else if loaded {
                    // if its already loaded we still have to select it and get the exports
                    self.set_file(&lib_path);
                    for export in &self.get_exports().unwrap() {
                        if let Some(reloc) = relocation_map.get(&export.name) {
                            self.cmd(
                                format!("wv{} {} @ {}", bits / 8, export.vaddr, reloc.vaddr)
                                    .as_str(),
                            )?;
                        }
                    }
                    break;
                }
            }
        }

        Ok(full_paths)
    }

    pub fn clear(&mut self) {}

    pub fn close(&mut self) {
        self.r2p.lock().unwrap().close();
    }
}

```

`radius/src/radius.rs`:

```rs
pub use crate::processor::{HookMethod, Processor, RunMode};
use crate::r2_api::{BasicBlock, FunctionInfo, Information, Instruction, R2Api, R2Result};
use crate::state::State;
//use crate::value::Value;
use crate::sims::syscall::indirect;
use crate::sims::{get_sims, zero, Sim, SimMethod};
use crate::value::{vc, Value};

// use std::collections::VecDeque;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// use std::thread;

#[derive(Debug, Clone, PartialEq)]
pub enum RadiusOption {
    /// Use simulated syscalls
    Syscalls(bool),
    /// Use simulated imports     
    Sims(bool),
    /// Sim all imports, with stub if missing
    SimAll(bool),
    /// Optimize executed ESIL expressions
    Optimize(bool),
    /// Enable debug output
    Debug(bool),
    /// panic! on unimplemented
    Strict(bool),
    /// Don't check sat on symbolic pcs
    Lazy(bool),
    /// Check memory permissions
    Permissions(bool),
    /// Force execution of all branches
    Force(bool),
    /// Execute blocks in topological order
    Topological(bool),
    /// Enable merge-maxxing, automatic state merging
    AutoMerge(bool),
    /// Maximum values to evaluate for sym PCs
    EvalMax(usize),
    /// Radare2 argument, must be static
    R2Argument(&'static str),
    /// Handle self-modifying code (poorly)
    SelfModify(bool),
    /// Load plugins
    LoadPlugins(bool),
    /// Load libraries
    LoadLibs(bool),
    /// use color output from r2
    ColorOutput(bool),
    /// Path to load library from
    LibPath(String),
}

/// Main Radius struct that coordinates and configures
/// the symbolic execution of a binary.
///
/// Radius can be instantiated using either `Radius::new(filename: &str)`
/// or `Radius::new_with_options(...)`
///
///  ## Example
///
/// ```
/// use radius2::radius::Radius;
/// let mut radius = Radius::new("/bin/sh");
/// ```
pub struct Radius {
    /// Handle to interact with radare2
    pub r2api: R2Api,
    /// Evaluates ESIL to execute instructions
    pub processor: Processor,
    processors: Arc<Mutex<Vec<Processor>>>,
    /// Max number of symbolic PC evaluations
    pub eval_max: usize,
    /// Check memory permissions
    pub check: bool,
    /// Print out disassembly of executed instructions
    pub debug: bool,
    /// Panic on invalid instructions
    pub strict: bool,
}

impl Radius {
    /// Create a new Radius instance for the provided binary
    ///
    /// ## Arguments
    /// * `filename` - path to the target binary
    ///
    /// ## Example
    /// ```
    /// use radius2::radius::Radius;
    /// let mut radius = Radius::new("/bin/sh");
    /// ```
    pub fn new<T: AsRef<str>>(filename: T) -> Self {
        // no radius options and no r2 errors by default
        Radius::new_with_options(Some(filename), &[])
    }

    /// Create a new Radius instance for the provided binary with a vec of `RadiusOption`
    ///
    /// ## Arguments
    /// * `filename` - path to the target binary
    /// * `options` - array of options to configure radius2
    ///
    /// ## Example
    /// ```
    ///   use radius2::radius::{Radius, RadiusOption};
    ///   let options = [RadiusOption::Optimize(false), RadiusOption::Sims(false)];
    ///   let mut radius = Radius::new_with_options(Some("/bin/sh"), &options);
    /// ```
    pub fn new_with_options<T: AsRef<str>>(filename: Option<T>, options: &[RadiusOption]) -> Self {
        let mut argv = vec!["-2"];
        let mut eval_max = 256;
        let mut paths = vec![];
        for o in options {
            if let RadiusOption::R2Argument(arg) = o {
                argv.push(*arg);
            } else if let RadiusOption::EvalMax(m) = o {
                eval_max = *m;
            } else if let RadiusOption::LibPath(p) = o {
                paths.push(p.to_owned());
            }
        }

        let debug = options.contains(&RadiusOption::Debug(true));
        let color = options.contains(&RadiusOption::ColorOutput(true));
        let use_sims = !options.contains(&RadiusOption::Sims(false));

        if !options.contains(&RadiusOption::LoadPlugins(true)) {
            argv.push("-NN");
        }

        if debug && color {
            // pretty print disasm + esil
            argv.push("-e scr.color=3");
            //argv.push("-e asm.cmt.esil=true");
            argv.push("-e asm.lines=false");
            argv.push("-e asm.emu=false");
            argv.push("-e asm.xrefs=false");
            argv.push("-e asm.functions=false");
        }

        let args = if !argv.is_empty() || filename.is_none() {
            Some(argv)
        } else {
            None
        };

        let mut r2api = R2Api::new(filename, args);
        r2api.set_option("io.cache", "true").unwrap();
        // r2api.cmd("eco darkda").unwrap(); // i like darkda

        let arch = &r2api.info.bin.arch;

        // don't optimize dalvik & arm
        let opt = !options.contains(&RadiusOption::Optimize(false))
            && arch.as_str() != "arm"
            && arch.as_str() != "dalvik";

        let lazy = !options.contains(&RadiusOption::Lazy(false));
        let force = options.contains(&RadiusOption::Force(true));
        let topo = options.contains(&RadiusOption::Topological(true));
        let check = options.contains(&RadiusOption::Permissions(true));
        let sim_all = options.contains(&RadiusOption::SimAll(true));
        let selfmod = options.contains(&RadiusOption::SelfModify(true));
        let strict = options.contains(&RadiusOption::Strict(true));
        let automerge = options.contains(&RadiusOption::AutoMerge(true));

        let mut processor = Processor::new(selfmod, opt, debug, lazy, force, topo, automerge, color);
        let processors = Arc::new(Mutex::new(vec![]));

        if !options.contains(&RadiusOption::Syscalls(false)) {
            let syscalls = r2api.get_syscalls().unwrap();
            if let Some(sys) = syscalls.get(0) {
                processor.traps.insert(sys.swi, indirect);
            }
            for sys in &syscalls {
                processor.syscalls.insert(sys.num, sys.to_owned());
            }
        }

        let _libs = if options.contains(&RadiusOption::LoadLibs(true)) {
            r2api.load_libraries(&paths).unwrap()
        } else {
            vec![]
        };

        // this is weird, idk
        if use_sims {
            Radius::register_sims(&mut r2api, &mut processor, sim_all);
        }

        Radius {
            r2api,
            processor,
            processors,
            eval_max,
            check,
            debug,
            strict,
        }
    }

    /// Initialized state at the provided function address with an initialized stack
    /// (if applicable)
    ///
    /// ## Arguments
    /// * `addr` - the address of the function
    ///
    /// ## Example
    /// ```
    /// use radius2::radius::Radius;
    /// let mut radius = Radius::new("/bin/sh");
    /// let mut state = radius.call_state(0x004006fd);
    /// ```
    pub fn call_state(&mut self, addr: u64) -> State {
        self.r2api.seek(addr);
        self.r2api.init_vm();
        let mut state = self.init_state();
        state.memory.add_stack();
        state.memory.add_heap();
        state.memory.add_std_streams();
        state
    }

    /// Initialized state at the provided function name with an initialized stack
    /// equivalent to `call_state(get_address(sym))`
    ///
    /// ## Arguments
    /// * `sym` - the name of the function
    ///
    /// ## Example
    ///  ```
    ///  use radius2::Radius;
    ///  let mut radius = Radius::new("/bin/sh");
    ///  let mut state = radius.callsym_state("printf");
    ///  ```
    pub fn callsym_state<T: AsRef<str>>(&mut self, sym: T) -> State {
        let addr = self.get_address(sym).unwrap_or_default();
        self.call_state(addr)
    }

    /// Initialize state from a debugger breakpoint
    /// the program will block until bp is hit
    pub fn debug_state(&mut self, addr: u64, args: &[String]) -> State {
        // set cache to false to set breakpoint
        self.r2api.set_option("io.cache", "false").unwrap();
        self.r2api.init_debug(addr, args);
        self.init_state()
    }

    /// Initialize state from a frida hook
    /// the program will block until the hook is hit
    pub fn frida_state(&mut self, addr: u64) -> State {
        self.r2api.seek(addr);
        let mut state = self.init_state();
        self.processor.fetch_instruction(&mut state, addr); // cache real instrs
        let context = self.r2api.init_frida(addr).unwrap();

        for reg in context.keys() {
            if state.registers.regs.contains_key(reg) {
                state.registers.set(reg, vc(context[reg]));
            }
        }
        state
    }

    /// Initialized state at the program entry point (the first if multiple).
    ///
    /// ## Example
    ///
    /// ```
    /// use radius2::Radius;
    /// let mut radius = Radius::new("/bin/sh");
    /// let mut state = radius.entry_state();
    /// ```
    pub fn entry_state(&mut self) -> State {
        // get the entrypoint
        let entrypoints = self.r2api.get_entrypoints().unwrap_or_default();
        if !entrypoints.is_empty() {
            self.r2api.seek(entrypoints[0].vaddr);
        }
        self.r2api.init_vm();
        let mut state = self.init_state();
        state.memory.add_stack();
        state.memory.add_heap();
        state.memory.add_std_streams();

        let start_main_reloc = self.r2api.get_address("reloc.__libc_start_main").unwrap_or(0);
        if start_main_reloc != 0 {
            self.r2api.cmd("af").unwrap(); // analyze entrypoint
            let callers = self.r2api.get_references(start_main_reloc).unwrap_or_default();
            if !callers.is_empty() {
                self.hook(callers[0].from, __libc_start_main);
            }
        }
        state
    }

    /// Set argv and env with arrays of values
    pub fn set_argv_env(&mut self, state: &mut State, args: &[Value], env: &[Value]) {
        // we write args to both regs and stack
        // i think this is ok
        let sp = state.registers.get_with_alias("SP");
        let ptrlen = (state.memory.bits / 8) as usize;
        let argc = Value::Concrete(args.len() as u64, 0);
        state.memory_write_value(&sp, &argc, ptrlen);
        state.registers.set_with_alias("A0", argc);

        let types = ["argv", "env"];
        let mut current = sp + Value::Concrete(ptrlen as u64, 0);
        for (i, strings) in [args, env].iter().enumerate() {
            state
                .context
                .insert(types[i].to_owned(), vec![current.clone()]);
            let alias = format!("A{}", i + 1);
            state.registers.set_with_alias(&alias, current.clone());
            for string in strings.iter() {
                let addr = state
                    .memory
                    .alloc(&Value::Concrete((string.size() / 8) as u64 + 1, 0));

                state.memory_write_value(
                    &Value::Concrete(addr, 0),
                    string,
                    string.size() as usize / 8,
                );

                state.memory.write_value(
                    addr + (string.size() / 8) as u64,
                    &Value::Concrete(0, 0),
                    1,
                );

                state.memory_write_value(&current, &Value::Concrete(addr, 0), ptrlen);
                current = current + Value::Concrete(ptrlen as u64, 0);
            }
            state.memory_write_value(&current, &Value::Concrete(0, 0), ptrlen);
            current = current + Value::Concrete(ptrlen as u64, 0);
        }
    }

    /// A default initial state
    pub fn init_state(&mut self) -> State {
        State::new(
            &mut self.r2api,
            self.eval_max,
            self.debug,
            false,
            self.check,
            self.strict,
        )
    }

    /// A "blank" state with uninitialized values set to be symbolic
    pub fn blank_state(&mut self) -> State {
        State::new(
            &mut self.r2api,
            self.eval_max,
            self.debug,
            true,
            self.check,
            self.strict,
        )
    }

    /// A blank state except for PC and SP
    pub fn blank_call_state(&mut self, addr: u64) -> State {
        self.r2api.seek(addr);
        self.r2api.init_vm();
        let mut state = self.blank_state();
        let sp = self.r2api.get_register_value("SP").unwrap();
        state
            .registers
            .set_with_alias("PC", Value::Concrete(addr, 0));
        state.registers.set_with_alias("SP", Value::Concrete(sp, 0));
        state.memory.add_stack();
        state.memory.add_heap();
        state.memory.add_std_streams();
        state
    }

    /// Hook an address with a callback that is passed the `State`.
    ///
    /// The return value of the callback specifies whether the hooked instruction should be executed or skipped
    ///
    /// ## Arguments
    /// * `addr` - the address to hook
    /// * `hook_callback` - the function to call once the address is reached
    ///
    /// ## Example
    /// ```
    /// use radius2::{Radius, State, vc};
    /// let mut radius = Radius::new("/bin/sh");
    ///
    /// fn callback(state: &mut State) -> bool {
    ///     state.registers.set("rax", vc(0x1337));
    ///     true // do not skip instruction
    /// }
    /// radius.hook(0x400cb0, callback);
    /// ```
    pub fn hook(&mut self, addr: u64, hook_callback: HookMethod) {
        self.processor
            .hooks
            .entry(addr)
            .or_insert(vec![])
            .push(hook_callback);
    }

    /// Hook an address with an esil expression. The instruction
    /// at the address is skipped if the last value on the stack is nonzero
    ///
    /// ## Arguments
    /// * `addr` - the address to hook
    /// * `esil` - the ESIL expression to evaluate
    pub fn esil_hook(&mut self, addr: u64, esil: &str) {
        self.processor
            .esil_hooks
            .entry(addr)
            .or_insert(vec![])
            .push(esil.to_owned());
    }

    /// Hook a symbol with a callback that is passed each state that reaches it
    pub fn hook_symbol(&mut self, sym: &str, hook_callback: HookMethod) {
        let addr = self.get_address(sym).unwrap();
        self.hook(addr, hook_callback);
    }

    // internal method to register import sims
    fn register_sims(r2api: &mut R2Api, processor: &mut Processor, sim_all: bool) {
        let sims = get_sims();
        let files = r2api.get_files().unwrap();

        for file in files {
            if file.uri.starts_with("null://") {
                continue;
            }

            r2api.set_file_fd(file.fd);
            let symbols = r2api.get_imports().unwrap();
            let mut symmap: HashMap<String, u64> = HashMap::new();

            for symbol in symbols {
                symmap.insert(symbol.name, symbol.plt);
            }

            // TODO expand this to handle other symbols
            for sim in &sims {
                let addropt = symmap.remove(&sim.symbol);
                if let Some(addr) = addropt {
                    processor.sims.insert(addr, sim.to_owned());
                }
            }

            if sim_all {
                for name in symmap.keys() {
                    // we are gonna go with zero by default
                    processor.sims.insert(
                        symmap[name],
                        Sim {
                            symbol: name.to_owned(),
                            function: zero,
                            arguments: 0,
                        },
                    );
                }
            }
        }

        // back to main file
        r2api.set_file_fd(3);
    }

    /// Register a trap to call the provided `SimMethod`
    pub fn trap(&mut self, trap_num: u64, sim: SimMethod) {
        self.processor.traps.insert(trap_num, sim);
    }

    /// Register a `SimMethod` for the provided function address
    ///
    /// ## Arguments
    /// * `addr` - address of the function to simulate (usually the PLT address)
    /// * `sim` - Sim struct containing the function name, implementation, and arg count
    ///
    /// ## Example
    /// ```
    /// use radius2::{Radius, State, Sim, Value, vc};
    /// let mut radius = Radius::new("/bin/sh");
    /// let scanf = radius.get_address("__isoc99_scanf").unwrap();
    ///
    /// fn scanf_sim(state: &mut State, args: &[Value]) -> Value {
    ///     state.memory_write_value(&args[1], &vc(42), 8);
    ///     vc(1)
    /// }
    ///
    /// radius.simulate(scanf, Sim{
    ///     symbol: "scanf".to_owned(),
    ///     function: scanf_sim,
    ///     arguments: 2
    /// });
    /// ```
    pub fn simulate(&mut self, addr: u64, sim: Sim) {
        self.processor.sims.insert(addr, sim);
    }

    /// assign an existing sim to an address (for static binaries)
    pub fn assign_sim(&mut self, addr: u64, name: &str) {
        // TODO: get_sims should return a HashMap idk why it doesnt
        get_sims()
            .into_iter()
            .find(|s| s.symbol == name)
            .map(|s| self.simulate(addr, s));
    }

    /// Add a breakpoint at the provided address.
    /// This is where execution will stop after `run` is called
    pub fn breakpoint(&mut self, addr: u64) {
        self.processor.breakpoints.insert(addr);
    }

    /// Add a mergepoint, an address where many states will be combined
    /// into a single state with the proper constraints
    pub fn mergepoint(&mut self, addr: u64) {
        self.processor.mergepoints.insert(addr);
    }

    /// Add addresses that will be avoided during execution. Any
    /// `State` that reaches these addresses will be marked inactive
    ///
    /// ## Arguments
    /// * `addrs` - slice of addresses to avoid during execution
    pub fn avoid(&mut self, addrs: &[u64]) {
        for addr in addrs {
            self.processor.avoidpoints.insert(*addr);
        }
    }

    /// Get total number of steps from all processors
    pub fn get_steps(&self) -> u64 {
        self.processor.steps
            + self
                .processors
                .lock()
                .unwrap()
                .iter()
                .map(|p| p.steps)
                .sum::<u64>()
    }

    /// Execute function and return the resulting state
    pub fn call_function(&mut self, sym: &str, state: State, args: Vec<Value>) -> Option<State> {
        let addr = self.r2api.get_address(sym).unwrap_or_default();
        self.call_address(addr, state, args)
    }

    /// Execute function at address and return the resulting state
    /// if there are multiple result states, merge them all
    pub fn call_address(&mut self, addr: u64, mut state: State, args: Vec<Value>) -> Option<State> {
        state.set_args(args);
        state.registers.set_pc(vc(addr));

        let mut states = self.run_all(state);
        let count = states.len();

        if !states.is_empty() {
            let mut end = states.remove(0);
            for _ in 1..count {
                end.merge(&mut states.remove(0));
            }
            Some(end)
        } else {
            None
        }
    }

    /// Simple way to execute until a given target address while avoiding a vec of other addrs
    ///
    /// ## Arguments
    /// * `state` - the program state to begin running from
    /// * `target` - the goal address where execution should stop and return the result state
    /// * `avoid` - slice of addresses to avoid, states that reach them will be marked inactive
    pub fn run_until(&mut self, state: State, target: u64, avoid: &[u64]) -> Option<State> {
        self.breakpoint(target);
        self.avoid(avoid);
        self.processor.run(state, RunMode::Single).pop()
    }

    /// Execute until every state has reached an end and return active states
    pub fn run_all(&mut self, state: State) -> Vec<State> {
        self.processor.run(state, RunMode::Multiple)
    }

    /// Main run method, start or continue a symbolic execution
    ///
    /// ## Arguments
    /// * `state` - the program state to begin executing from
    /// * `threads` - number of threads (currently unused)
    ///
    ///  ## Example
    /// ```
    /// use radius2::Radius;
    /// let mut radius = Radius::new("/bin/ls");
    /// let state = radius.entry_state();
    /// let new_state = radius.run(state, 1);
    /// ```
    pub fn run(&mut self, state: State, _threads: usize) -> Option<State> {
        // we are gonna scrap threads for now cuz theyre currently useless.
        self.processor.run(state, RunMode::Single).pop()
    }

    /// Run radare2 analysis
    pub fn analyze(&mut self, n: usize) {
        let _r = self.r2api.analyze(n);
    }

    /// Get information about the binary and radare2 session
    pub fn get_info(&mut self) -> R2Result<Information> {
        self.r2api.get_info()
    }

    /// Get address of symbol
    pub fn get_address<T: AsRef<str>>(&mut self, symbol: T) -> R2Result<u64> {
        self.r2api.get_address(symbol.as_ref())
    }

    /// Get all functions
    pub fn get_functions(&mut self) -> R2Result<Vec<FunctionInfo>> {
        self.r2api.get_functions()
    }

    /// Get function information at this address
    pub fn get_function(&mut self, address: u64) -> R2Result<FunctionInfo> {
        self.r2api.get_function_info(address)
    }

    /// Get basic blocks of a function
    pub fn get_blocks(&mut self, address: u64) -> R2Result<Vec<BasicBlock>> {
        self.r2api.get_blocks(address)
    }

    /// Disassemble at the provided address
    pub fn disassemble(&mut self, address: u64, num: usize) -> R2Result<Vec<Instruction>> {
        self.r2api.disassemble(address, num)
    }

    /// Disassemble function at the provided address
    pub fn disassemble_function(&mut self, address: u64) -> R2Result<Vec<Instruction>> {
        self.r2api.disassemble_function(address)
    }

    /// Assemble the given instruction
    pub fn assemble(&mut self, instruction: &str) -> R2Result<Vec<u8>> {
        self.r2api.assemble(instruction)
    }

    /// Read directly from binary
    pub fn read(&mut self, address: u64, length: usize) -> R2Result<Vec<u8>> {
        self.r2api.read(address, length)
    }

    /// Patch binary
    pub fn write(&mut self, address: u64, data: Vec<u8>) {
        self.r2api.write(address, data)
    }

    /// Write string to binary / real memory
    pub fn write_string(&mut self, address: u64, string: &str) {
        self.r2api
            .write(address, string.chars().map(|c| c as u8).collect::<Vec<_>>())
    }

    /// Set radare2 option, equivalent to "e `key`=`value`"
    pub fn set_option(&mut self, key: &str, value: &str) {
        self.r2api.set_option(key, value).unwrap();
    }

    /// Run any r2 command
    pub fn cmd(&mut self, cmd: &str) -> R2Result<String> {
        self.r2api.cmd(cmd)
    }

    /// continue real execution
    pub fn cont(&mut self) {
        self.r2api.cont().unwrap();
    }

    /// close r2
    pub fn close(&mut self) {
        self.r2api.close()
    }

    // clear cached data from r2api and processors
    pub fn clear(&mut self) {
        self.r2api.clear();
        self.processors.lock().unwrap().clear();
    }
}

pub fn __libc_start_main(state: &mut State) -> bool {
    let mut args = state.get_args();
    let main = args.remove(0);

    // TODO go to init then main
    // but we need a nice arch neutral way to push ret
    // so until then

    // go to main
    state.registers.set_with_alias("PC", main);
    state.set_args(args);

    false
}

```

`radius/src/registers.rs`:

```rs
use crate::r2_api::{AliasInfo, R2Api, RegisterInfo};
use crate::solver::Solver;
use crate::value::{vc, Value};
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Bounds {
    tstr: String,
    start: u64,
    end: u64,
    size: u64,
}

#[derive(Debug, Clone)]
pub struct Register {
    pub reg_info: RegisterInfo,
    pub bounds: Bounds,
    pub index: usize,
    pub value_index: usize,
}

#[derive(Clone)]
pub struct Registers {
    pub solver: Solver,
    pub r2api: R2Api,
    pub aliases: HashMap<String, AliasInfo>,
    pub regs: HashMap<String, Register>,
    pub indexes: Vec<Register>,
    pub values: Vec<Value>,
    pub pc: Option<Register>,
    // clear_upper: bool
}

impl Registers {
    pub fn new(r2api: &mut R2Api, btor: Solver, blank: bool) -> Self {
        let mut reg_info = r2api.get_registers().unwrap();
        reg_info
            .reg_info
            .sort_by(|a, b| b.size.partial_cmp(&a.size).unwrap());

        //let clear_upper = r2api.clear_upper_bits();

        let mut registers = Registers {
            solver: btor.clone(),
            r2api: r2api.clone(),
            aliases: HashMap::new(),
            regs: HashMap::new(),
            indexes: vec![],
            values: vec![],
            pc: None,
            // clear_upper
        };

        let mut bounds_map: HashMap<Bounds, usize> = HashMap::new();
        for reg in reg_info.reg_info {
            let mut bounds = Bounds {
                tstr: reg.type_str.to_owned(),
                start: reg.offset,
                end: reg.offset.wrapping_add(reg.size),
                size: reg.size,
            };

            let old_bounds = bounds_map.keys();
            let mut in_bounds = false;
            for bound in old_bounds {
                let inside = bounds.start >= bound.start && bounds.end <= bound.end;
                if bound.tstr == bounds.tstr && inside {
                    in_bounds = true;
                    bounds = bound.clone();
                }
            }

            if !in_bounds {
                let val = if !blank {
                    let v = r2api.get_register_value(&reg.name).unwrap_or_default();
                    if reg.size <= 64 {
                        vc(v)
                    } else {
                        Value::Symbolic(btor.bvv(v, reg.size as u32), 0)
                    }
                } else {
                    let sym_name = format!("reg_{}", reg.name);
                    Value::Symbolic(btor.bv(sym_name.as_str(), reg.size as u32), 0)
                };

                bounds_map.insert(bounds.clone(), registers.values.len());
                registers.values.push(val);
            }

            let reg_obj = Register {
                reg_info: reg,
                bounds: bounds.clone(),
                value_index: bounds_map[&bounds],
                index: registers.indexes.len(),
            };

            registers.indexes.push(reg_obj.clone());
            registers
                .regs
                .insert(reg_obj.reg_info.name.clone(), reg_obj);
        }

        for alias in &reg_info.alias_info {
            registers
                .aliases
                .insert(alias.role_str.to_owned(), alias.clone());

            if alias.role_str == "PC" {
                registers.pc = Some(registers.get_register(&alias.reg).unwrap().clone());
            }
        }

        registers
    }

    /// Get the value of the register `reg`
    #[inline]
    pub fn get(&self, reg: &str) -> Value {
        self.get_value(self.regs[reg].index)
    }

    /// Set the value of the register `reg`
    #[inline]
    pub fn set(&mut self, reg: &str, value: Value) {
        self.set_value(self.regs[reg].index, value)
    }

    #[inline]
    pub fn get_register(&self, reg: &str) -> Option<&Register> {
        self.regs.get(reg)
    }

    /// Get register with name OR alias, eg. `PC`, `SP`
    #[inline]
    pub fn get_with_alias(&self, alias: &str) -> Value {
        let mut reg = alias;
        if let Some(r) = self.aliases.get(alias) {
            reg = &r.reg;
        }
        self.get_value(self.regs[reg].index)
    }

    /// Set register with name OR alias, eg. `PC`, `SP`
    #[inline]
    pub fn set_with_alias(&mut self, alias: &str, value: Value) {
        if let Some(r) = self.aliases.get(alias) {
            let t = r.reg.to_owned();
            return self.set_value(self.regs[&t].index, value);
        }
        // make set_with_alias more forgiving
        if let Some(reg) = self.regs.get(alias) {
            let creg = reg.clone();
            self.set_value(creg.index, value);
        }
    }

    /// Get the value of `PC`
    #[inline]
    pub fn get_pc(&self) -> Value {
        self.get_value(self.pc.as_ref().unwrap().index)
    }

    /// Set the value of `PC`
    #[inline]
    pub fn set_pc(&mut self, value: Value) {
        self.set_value(self.pc.as_ref().unwrap().index, value)
    }

    #[inline]
    pub fn is_sub(&mut self, r1: usize, r2: usize) -> bool {
        let reg1 = &self.indexes[r1];
        let reg2 = &self.indexes[r2];

        let start1 = reg1.reg_info.offset;
        let start2 = reg2.reg_info.offset;
        let end1 = reg1.reg_info.offset + reg1.reg_info.size;
        let end2 = reg2.reg_info.offset + reg2.reg_info.size;

        start2 >= start1 && end2 <= end1
    }

    pub fn get_value(&self, index: usize) -> Value {
        let register = &self.indexes[index];
        if register.reg_info.offset == -1i64 as u64 {
            return Value::Concrete(0, 0); // this is a zero register
        }
        let value = &self.values[register.value_index];
        if register.reg_info.size == register.bounds.size {
            value.to_owned()
        } else {
            let offset = register.reg_info.offset - register.bounds.start;
            value.slice(register.reg_info.size + offset - 1, offset)
        }
    }

    pub fn set_value(&mut self, index: usize, value: Value) {
        let register = &self.indexes[index];

        if register.reg_info.offset == -1i64 as u64 {
            return; // this is a zero register
        }

        let size = register.reg_info.size;
        if size == register.bounds.size {
            if size <= 64 {
                self.values[register.value_index] = value.slice(size - 1, 0);
            } else {
                // need to prevent size > 64 from becoming a u64
                let bv = self.solver.to_bv(&value, size as u32);
                let v = Value::Symbolic(bv, value.get_taint());
                self.values[register.value_index] = v;
            }
        } else if size == 32 {
            // this sux
            self.values[register.value_index] = value.slice(size - 1, 0).uext(&vc(32));
        } else {
            let bound_size = register.bounds.size as u32;
            let offset = register.reg_info.offset - register.bounds.start;
            let old_value = &self.values[register.value_index];

            let mut new_sym;
            let mut old_sym;
            let taint;

            // TODO this may cause huge amounts of overtainting, maybe just use new
            // im pulling trig and just using new, the downside of not is too high
            match (value, old_value.to_owned()) {
                (Value::Concrete(new, t1), Value::Concrete(old, _t2)) => {
                    let new_mask = (1 << size) - 1;
                    let mask = !(new_mask << offset);
                    let new_value = (old & mask) + ((new & new_mask) << offset);
                    self.values[register.value_index] = Value::Concrete(new_value, t1);
                    return;
                }
                (Value::Concrete(new, t1), Value::Symbolic(old, _t2)) => {
                    new_sym = self.solver.bvv(new, size as u32);
                    old_sym = old;
                    taint = t1; // | t2;
                }
                (Value::Symbolic(new, t1), Value::Concrete(old, _t2)) => {
                    old_sym = self.solver.bvv(old, bound_size);
                    new_sym = new;
                    taint = t1; // | t2;
                }
                (Value::Symbolic(new, t1), Value::Symbolic(old, _t2)) => {
                    old_sym = old;
                    new_sym = new;
                    taint = t1; // | t2;
                }
            }

            new_sym = new_sym.slice(size as u32 - 1, 0);
            old_sym = old_sym.slice(bound_size - 1, 0);

            let mut new_value;

            if offset > 0 {
                new_value = new_sym.concat(&old_sym.slice((offset - 1) as u32, 0));
                let new_off = offset as u32 + size as u32;
                if bound_size - new_off > 0 {
                    new_value = old_sym.slice(bound_size - 1, new_off).concat(&new_value);
                }
            } else {
                new_value = old_sym.slice(bound_size - 1, size as u32).concat(&new_sym);
            }

            self.values[register.value_index] = Value::Symbolic(new_value, taint);
        }
    }
}

```

`radius/src/sims/cpp.rs`:

```rs
use crate::sims::format;
use crate::sims::libc;
use crate::sims::syscall;
use crate::state::State;
use crate::value::{vc, Value};

```

`radius/src/sims/format.rs`:

```rs
use crate::state::State;
use crate::value::{vc, Value};

const MAXLEN: usize = 8192;
const FORMATS: [char; 19] = [
    'd', 'i', 'u', 'o', 'x', 'X', 'f', 'F', 'e', 'E', 'g', 'G', 'a', 'A', 'c', 's', 'p', 'n', '%',
];

const UINTS: [char; 4] = ['u', 'o', 'x', 'X'];
const NONUINTS: [char; 15] = [
    'd', 'i', 'f', 'F', 'e', 'E', 'g', 'G', 'a', 'A', 'c', 's', 'n', '%', 'p',
];

// the value returned is the formatted string
pub fn format(state: &mut State, vargs: &[Value]) -> Vec<Value> {
    let args = get_fmt_args(state, vargs);
    let length = state.memory_strlen(&args[0], &vc(MAXLEN as u64));
    let mut formatstr = state.memory_read(&args[0], &length);
    let mut result = Vec::with_capacity(MAXLEN);

    let mut count = 0;
    let mut ind = 0; // argument index
    while !formatstr.is_empty() {
        let c = formatstr.remove(0);
        if !formatstr.is_empty() && state.check(&c.eq(&vc('%' as u64))) {
            if formatstr[0].as_u64() != Some('%' as u64) {
                ind += 1; // jank fix cuz %% shouldnt increment
            }
            // if it can be % it *must* be %
            state.assert(&c.eq(&vc('%' as u64)));
            let formatted = format_one(state, &mut formatstr, &args[ind], count);
            count += formatted.len();
            result.extend(formatted);
        } else {
            result.push(c);
            count += 1
        }
    }
    result
}

// get list of possible formats, we will let uints stay symbolic
pub fn may_be_formats(state: &mut State, c: &Value) -> Vec<char> {
    let mut formats = Vec::with_capacity(8);
    for f in FORMATS.iter() {
        if state.check(&c.eq(&vc(*f as u64))) {
            formats.push(*f);
        }
    }
    formats
}

// c must be in the resulting formats
pub fn must_be_formats(state: &mut State, c: &Value, formats: &[char]) {
    if !c.is_concrete() {
        let mut asserts = vec![];
        for f in formats.iter() {
            asserts.push(state.solver.to_bv(&c.eq(&vc(*f as u64)), 1));
        }
        state.assert_bv(&state.solver.or_all(&asserts));
    }
}

// get format args (from x9 on *OS)
pub fn get_fmt_args(state: &mut State, args: &[Value]) -> Vec<Value> {
    // this is dumb, we need to fix the calling convention stuff in r2
    if state.info.bin.bintype == "mach0" && state.info.bin.arch == "arm" {
        let mut newargs = args[..1].to_owned();
        // read args from stack?
        let mut argp = state.registers.get("x9");
        let length = state.memory.bits as usize / 8;

        for _ in 0..8 { // do 8 idk
            let value = state.memory_read_value(&argp, length);
            argp = argp + vc(length as u64);
            newargs.push(value);
        }
        newargs
    } else {
        args.to_owned()
    }
}

// do one format string, "%10s", "%03x", etc
// count is just for %n
pub fn format_one(
    state: &mut State,
    formatstr: &mut Vec<Value>,
    arg: &Value,
    count: usize,
) -> Vec<Value> {
    let mut preformat = Vec::with_capacity(64); // eg the 08 in %08x, ignore for now
    let mut result = Vec::with_capacity(MAXLEN);

    while !formatstr.is_empty() {
        let c = formatstr.remove(0);
        let formats = may_be_formats(state, &c);

        if !formats.is_empty() {
            let preformat_str = if preformat.is_empty() {
                "".to_owned()
            } else {
                let preformat_val = state.memory.pack(&preformat);
                let preformat_bv = state
                    .solver
                    .to_bv(&preformat_val, 8 * preformat.len() as u32);
                state.evaluate_string_bv(&preformat_bv).unwrap_or_default()
            };

            let maybe_uint = formats.iter().any(|f| UINTS.contains(f));

            if maybe_uint {
                // ensure that it *is* a uint format
                must_be_formats(state, &c, &UINTS);
                result.extend(format_uint(state, &c, arg, &preformat_str));
            } else {
                must_be_formats(state, &c, &NONUINTS);
                let cl = tolower(state, &[c.clone()]);
                let cc = state.solver.evalcon_to_u64(&cl).unwrap_or(0) as u8;

                match cc as char {
                    'c' => result.push(arg.and(&vc(0xff))),
                    'p' => result.extend(format_uint(state, &c, arg, &preformat_str)),
                    'd' | 'i' => result.extend(format_int(state, &c, arg, &preformat_str)),
                    'f' | 'e' | 'g' | 'a' => result.extend(format_float(state, &c, arg)),
                    's' => result.extend(format_string(state, &c, arg, &preformat_str)),
                    'n' => state.memory_write_value(arg, &vc(count as u64), 32),
                    '%' => result.push(vc('%' as u64)),
                    _ => {}
                }
            }

            // capitalize letters if format is uppercase (X, F, G etc)
            let up = isupper(state, &[c]);
            if up.as_u64() != Some(0) {
                for i in 0..result.len() {
                    let upper = toupper(state, &[result[i].clone()]);
                    result[i] = state.cond(&up, &upper, &result[i]);
                }
            }

            break;
        } else {
            preformat.push(c);
        }
    }
    result
}

fn format_to_base(state: &mut State, c: &Value) -> Value {
    let f = tolower(state, &[c.to_owned()]); // X -> x
    let mut base = vc(10); // default to 10
    base = state.cond(&f.eq(&vc('x' as u64)), &vc(16), &base);
    base = state.cond(&f.eq(&vc('p' as u64)), &vc(16), &base);
    state.cond(&f.eq(&vc('o' as u64)), &vc(8), &base)
}

fn format_uint(state: &mut State, c: &Value, arg: &Value, pre: &str) -> Vec<Value> {
    let base = format_to_base(state, c);
    let temp = vc(state.memory.alloc(&vc(MAXLEN as u64)));
    itoa_helper(state, arg, &temp, &base, false, 32);
    let length = state.memory_strlen(&temp, &vc(MAXLEN as u64));
    let mut result = state.memory_read(&temp, &length);
    state.memory.free(&temp); // like it never happened

    let padding = pre.parse::<usize>().unwrap_or(0);
    if result.len() < padding {
        let extra = padding - result.len();
        let pad = if pre.starts_with("0") {
            vec![vc('0' as u64); extra]
        } else {
            vec![vc(' ' as u64); extra]
        };
        result = [pad, result].concat();
    }

    result
}

fn format_int(state: &mut State, _c: &Value, arg: &Value, pre: &str) -> Vec<Value> {
    // this is a bit jank, i should redo how itoa_helper works
    let temp = vc(state.memory.alloc(&vc(MAXLEN as u64)));
    itoa_helper(state, arg, &temp, &vc(10), true, 64);
    let length = state.memory_strlen(&temp, &vc(MAXLEN as u64));
    let mut result = state.memory_read(&temp, &length);
    state.memory.free(&temp); // like it never happened

    let padding = pre.parse::<usize>().unwrap_or(0);
    if result.len() < padding {
        let extra = padding - result.len();
        let pad = if pre.starts_with("0") {
            vec![vc('0' as u64); extra]
        } else {
            vec![vc(' ' as u64); extra]
        };
        result = [pad, result].concat();
    }

    result
}

fn format_float(state: &mut State, _c: &Value, arg: &Value) -> Vec<Value> {
    let f = f32::from_bits(state.solver.evalcon_to_u64(arg).unwrap_or_default() as u32);
    format!("{:e}", f).chars().map(|c| vc(c as u64)).collect() // jank
}

fn format_string(state: &mut State, _c: &Value, arg: &Value, pre: &str) -> Vec<Value> {
    let length = state.memory_strlen(arg, &vc(MAXLEN as u64));
    let mut result = state.memory_read(arg, &length);

    let padding = pre.parse::<usize>().unwrap_or(0);
    if result.len() < padding {
        let extra = padding - result.len();
        let pad = vec![vc(' ' as u64); extra];
        result = [pad, result].concat();
    }
    result
}

pub fn scan(state: &mut State, vargs: &[Value]) -> Value {
    let args = get_fmt_args(state, vargs);
    let flength = state.memory_strlen(&args[1], &vc(MAXLEN as u64));
    let mut formatstr = state.memory_read(&args[1], &(flength + vc(1)));
    let mut data = args[0].to_owned();

    let mut count = 0;
    let mut ind = 1; // argument index
    while !formatstr.is_empty() {
        let c = formatstr.remove(0);
        if !formatstr.is_empty() && state.check(&c.eq(&vc('%' as u64))) {
            if formatstr[0].as_u64() != Some('%' as u64) {
                ind += 1; // jank fix cuz %% shouldnt increment
            }
            // if it can be % it *must* be %
            state.assert(&c.eq(&vc('%' as u64)));
            scan_one(state, &mut formatstr, &args[ind], &mut data);
            count += 1;
        } else {
            data = data + vc(1);
        }
    }

    vc(count as u64)
}

pub fn scan_one(state: &mut State, formatstr: &mut Vec<Value>, arg: &Value, data: &mut Value) {
    let mut preformat = Vec::with_capacity(64); // eg the 08 in %08x, ignore for no

    while !formatstr.is_empty() {
        let c = formatstr.remove(0);
        let formats = may_be_formats(state, &c);

        if !formats.is_empty() {
            let preformat_str = if preformat.is_empty() {
                "".to_owned()
            } else {
                let preformat_val = state.memory.pack(&preformat);
                let preformat_bv = state
                    .solver
                    .to_bv(&preformat_val, 8 * preformat.len() as u32);
                state.evaluate_string_bv(&preformat_bv).unwrap_or_default()
            };
            let maybe_uint = formats.iter().any(|f| UINTS.contains(f));
            let next = formatstr.remove(0); // get delimiter maybe?
            let delim = state.memory_search(data, &next, &vc(MAXLEN as u64), false);
            state.memory_write_value(&delim, &vc(0), 1); // write a null there

            if maybe_uint {
                // ensure that it *is* a uint format
                must_be_formats(state, &c, &UINTS);
                scan_uint(state, &c, arg, data);
            } else {
                must_be_formats(state, &c, &NONUINTS);
                let cl = tolower(state, &[c]);
                let cc = state.solver.evalcon_to_u64(&cl).unwrap_or(0) as u8;

                match cc as char {
                    'c' => state.memory_write_value(arg, data, 1),
                    'p' => scan_uint(state, &vc(cc as u64), arg, data),
                    'd' | 'i' => scan_int(state, arg, data),
                    'f' | 'e' | 'g' | 'a' => scan_float(state, arg, data),
                    's' => scan_string(state, arg, data, &preformat_str),
                    _ => {}
                }
            }
            break;
        } else {
            preformat.push(c);
        }
    }
}

pub fn scan_uint(state: &mut State, c: &Value, arg: &Value, data: &mut Value) {
    let base = format_to_base(state, c);
    let value = atoi_helper(state, data, &base, 32); // TODO need to fix size for p, llx etc
    state.memory_write_value(arg, &value, 4);
    *data = data.add(&state.memory_strlen(data, &vc(MAXLEN as u64))) + vc(1);
}

pub fn scan_int(state: &mut State, arg: &Value, data: &mut Value) {
    let value = atoi_helper(state, data, &vc(10), 32); // TODO need to fix size for p, llx etc
    state.memory_write_value(arg, &value, 4);
    *data = data.add(&state.memory_strlen(data, &vc(MAXLEN as u64))) + vc(1);
}

pub fn scan_float(state: &mut State, arg: &Value, data: &mut Value) {
    let addr = state.solver.evalcon_to_u64(data).unwrap_or_default();
    let fs = state.memory_read_cstring(addr);
    let f = fs.parse::<f32>().unwrap_or_default();
    state.memory_write_value(arg, &vc(f32::to_bits(f) as u64), 4);
    *data = data.add(&state.memory_strlen(data, &vc(MAXLEN as u64))) + vc(1);
}

pub fn scan_string(state: &mut State, arg: &Value, data: &mut Value, pre: &str) {
    let limit = pre.parse::<u64>().unwrap_or(MAXLEN as u64);
    let length = state.memory_strlen(data, &vc(limit)) + vc(1);
    state.memory_move(arg, data, &length);
    *data = data.add(&length);
}

fn bv_pow(bv: &Value, exp: u32) -> Value {
    let mut result = vc(1);
    for _ in 0..exp {
        result = result * bv.clone();
    }
    result
}

// is digit
#[inline]
fn isdig(c: &Value) -> Value {
    c.ult(&vc(0x3a)) & !c.ult(&vc(0x30))
}

// is valid digit of base
fn isbasedigit(state: &State, c: &Value, base: &Value) -> Value {
    state.cond(
        &base.ult(&vc(11)),
        &(c.ult(&(vc('0' as u64) + base.clone())) & !c.ult(&vc('0' as u64))),
        &(isdig(c)
            | (c.ult(&(vc('a' as u64) + base.sub(&vc(10)))) & !c.ult(&vc('a' as u64)))
            | (c.ult(&(vc('A' as u64) + base.sub(&vc(10)))) & !c.ult(&vc('A' as u64)))),
    )
}

fn tonum(state: &State, c: &Value) -> Value {
    let alpha = state.cond(
        &c.ulte(&vc('Z' as u64)),
        &c.sub(&vc('A' as u64 - 10)),
        &c.sub(&vc('a' as u64 - 10)),
    );

    state
        .solver
        .conditional(&c.ulte(&vc('9' as u64)), &c.sub(&vc('0' as u64)), &alpha)
}

fn atoi_concrete(state: &mut State, addr: &Value, base: &Value, len: usize) -> Value {
    // TODO fix this to not use string because 123\xff will be 0 right now
    let numstr = state.memory_read_string(addr.as_u64().unwrap(), len);
    let numstr = numstr.trim_start(); // trim whitespace

    if numstr.len() == 0 {
        return vc(0);
    }

    let start = if numstr.len() > 1 && &numstr[0..2] == "0x" {
        2
    } else {
        0
    }; // offset
    let end = if let Some(n) = numstr[start + 1..]
        .chars()
        .position(|c| isbasedigit(state, &vc(c as u64), base).as_u64().unwrap() != 1)
    {
        start + n + 1
    } else {
        len
    }; // oof

    let numopt = u64::from_str_radix(&numstr[start..end], base.as_u64().unwrap() as u32);
    numopt.map(vc).unwrap_or_default()
}

/*
 * From SO
 * atoi reads digits from the buffer until it can't any more. It stops when it
 * encounters any character that isn't a digit, except whitespace (which it skips)
 * or a '+' or a '-' before it has seen any digits (which it uses to select the
 * appropriate sign for the result). It returns 0 if it saw no digits.
 */

// for now and maybe forever this only works for strings that
// don't have garbage in them. so only strings with digits or +/-
pub fn atoi_helper(state: &mut State, addr: &Value, base: &Value, size: u64) -> Value {
    let length = state.memory_strlen(&addr, &Value::Concrete(64, 0));
    let data = state.memory_read(addr, &length);
    let len = data.len();

    state.assert(&length.eq(&vc(len as u64)));
    if len == 0 {
        return Value::Concrete(0, 0);
    }

    // gonna take the easy way out and special case out all concrete
    if addr.is_concrete() && base.is_concrete() && data.iter().all(|x| x.is_concrete()) {
        return atoi_concrete(state, addr, base, len);
    }

    let mut result = Value::Concrete(0, 0);

    // multiplier for negative nums
    let neg_mul = state.cond(
        &data[0].eq(&vc('-' as u64)),
        &Value::Concrete(-1i64 as u64, 0),
        &Value::Concrete(1, 0),
    );

    for (i, d) in data.iter().enumerate() {
        let dx = d.uext(&vc(8));
        let exp = (len - i - 1) as u32;

        // digit or + / -
        let cond = if i == 0 {
            isbasedigit(state, &dx, base) | dx.eq(&vc('-' as u64)) | dx.eq(&vc('+' as u64))
        } else {
            isbasedigit(state, &dx, base)
        };
        state.assert(&cond);

        // add d*10**n to result
        result = result
            + state.cond(
                &!isbasedigit(state, &dx, base),
                &vc(0),
                &(bv_pow(base, exp) * tonum(state, &dx)),
            );
    }
    // this assertion is much faster than slicing dx
    if size < 64 {
        let mask = (1i64.wrapping_shl(size as u32) - 1) as u64;
        state.assert(&result.ulte(&Value::Concrete(mask, 0)));
    }

    result * neg_mul
}

pub fn itoa_concrete(
    state: &mut State,
    value: &Value,
    string: &Value,
    base: &Value,
    sign: bool,
    size: usize,
) -> Value {
    let sz = size as u64;
    if let Value::Concrete(v, t) = value {
        let mut masked = v & ((1 << sz) - 1);
        if sign && sz < 64 {
            masked = (((masked as i64) << (64 - sz)) >> sz) as u64;
        }
        let vstr = match (base.as_u64().unwrap(), sign) {
            (2, _) => format!("{:b}", masked),
            (8, _) => format!("{:o}", masked),
            (16, _) => format!("{:x}", masked),
            (_, false) => format!("{}", masked),
            (_, true) => format!("{}", masked as i64),
        };
        let mut data: Vec<Value> = vstr
            .chars()
            .map(|c| Value::Concrete(c as u64, *t))
            .collect();

        data.push(vc(0));
        state.memory_write(string, &data, &vc(data.len() as u64));
    }
    string.to_owned()
}

pub fn itoa_helper(
    state: &mut State,
    value: &Value,
    string: &Value,
    base: &Value,
    sign: bool,
    size: usize,
) -> Value {
    if value.is_concrete() && base.is_concrete() {
        return itoa_concrete(state, value, string, base, sign, size);
    }

    let mut data = Vec::with_capacity(size);

    // condition to add a minus sign -
    let neg_cond = &(value.slt(&vc(0)) & base.eq(&vc(10)) & vc(sign as u64));

    let uval = state
        .solver
        .conditional(neg_cond, &value.mul(&vc(-1i64 as u64)), value);

    let uval = Value::Symbolic(state.solver.to_bv(&uval, 128), 0);
    let ubase = Value::Symbolic(state.solver.to_bv(base, 128), 0);
    let mut shift = Value::Symbolic(state.solver.bvv(0, 64), 0);

    for i in 0..size as u32 {
        let dx = uval.rem(&bv_pow(&ubase, i + 1)).div(&bv_pow(&ubase, i));

        // shift that will be applied to remove 00000...
        shift = state
            .solver
            .conditional(&!dx.clone(), &shift.add(&vc(8)), &vc(0));

        data.push(state.cond(
            &dx.ult(&vc(10)),
            &dx.add(&vc('0' as u64)),
            &dx.sub(&vc(10)).add(&vc('a' as u64)),
        ));
    }

    data.reverse();

    let bv = state.memory.pack(&data).as_bv().unwrap();
    let shift_bits = 31 - bv.get_width().leading_zeros(); // log2(n)
    let bv = bv.srl(&shift.as_bv().unwrap().slice(shift_bits - 1, 0));
    let mut new_addr = string.clone();

    if sign {
        let b = state
            .solver
            .conditional(neg_cond, &vc('-' as u64), &vc('+' as u64));

        state.memory_write_value(string, &b, 1);

        // if we add a minus, write number to addr+1
        new_addr = state
            .solver
            .conditional(neg_cond, &(new_addr.clone() + vc(1)), &new_addr);
    }
    state.memory_write_value(&new_addr, &Value::Symbolic(bv, 0), data.len());
    state.memory_write_value(&new_addr.add(&vc(data.len() as u64)), &vc(0), 8);

    string.to_owned()
}

pub fn islower(_state: &mut State, args: &[Value]) -> Value {
    let c = args[0].slice(7, 0);
    c.ult(&Value::Concrete(0x7b, 0)) & !c.ult(&Value::Concrete(0x61, 0))
}

pub fn isupper(_state: &mut State, args: &[Value]) -> Value {
    let c = args[0].slice(7, 0);
    c.ult(&Value::Concrete(0x5b, 0)) & !c.ult(&Value::Concrete(0x41, 0))
}

pub fn toupper(state: &mut State, args: &[Value]) -> Value {
    let islo = islower(state, args);
    state
        .solver
        .conditional(&islo, &args[0].sub(&vc(0x20)), &args[0])
}

pub fn tolower(state: &mut State, args: &[Value]) -> Value {
    let isup = isupper(state, args);
    state
        .solver
        .conditional(&isup, &args[0].add(&vc(0x20)), &args[0])
}

```

`radius/src/sims/fs.rs`:

```rs
use crate::value::Value;
use std::fs;
// use std::io;
use std::time::SystemTime;

#[derive(Debug, Clone)]
pub enum FileMode {
    Read,
    Write,
    Append,
}

/// Stat structure from kernel_stat64
#[derive(Default, Debug, Clone)]
pub struct Stat {
    pub st_dev: u64,
    pub st_ino: u64,
    pub st_mode: u32,
    pub st_nlink: u32,
    pub st_uid: u32,
    pub st_gid: u32,

    pub __pad0: u32,
    pub st_rdev: u64,
    pub st_size: i64,
    pub st_blksize: i32,
    pub st_blocks: i64,

    pub st_atime: u64,
    pub st_atimensec: u64,
    pub st_mtime: u64,
    pub st_mtimensec: u64,
    pub st_ctime: u64,
    pub st_ctimensec: u64,

    pub __glibc_reserved: [i32; 2],
}

#[derive(Debug, Clone)]
pub struct SimFile {
    pub path: String,
    pub fd: usize,
    pub position: usize,
    pub mode: FileMode,
    pub content: Vec<Value>,
    pub metadata: Option<fs::Metadata>,
}

#[derive(Debug, Clone)]
pub struct SimFilesytem {
    pub files: Vec<SimFile>,
}

impl Default for SimFilesytem {
    fn default() -> Self {
        Self::new()
    }
}

impl SimFilesytem {
    pub fn new() -> Self {
        let files = SimFilesytem::get_stdio();
        SimFilesytem { files }
    }

    pub fn open(&mut self, path: &str, mode: FileMode) -> Option<usize> {
        for file in &self.files {
            if file.path == path {
                return Some(file.fd);
            }
        }

        let fd = self.files.len();
        let data = fs::read(path);

        if data.is_ok() {
            let metadata = fs::metadata(path).unwrap();

            let mut content = Vec::with_capacity(512);
            for d in data.unwrap() {
                content.push(Value::Concrete(d as u64, 0));
            }

            let file = SimFile {
                path: path.to_owned(),
                fd,
                position: 0,
                mode,
                content,
                metadata: Some(metadata),
            };

            self.files.push(file);
            Some(fd)
        } else {
            None
        }
    }

    pub fn read(&mut self, fd: usize, length: usize) -> Vec<Value> {
        if let Some(file) = &mut self.files.get_mut(fd) {
            let start = file.position;
            let end = if file.content.len() - start < length {
                file.content.len()
            } else {
                start + length
            };

            file.position = end;
            file.content[start..end].to_vec()
        } else {
            vec![]
        }
    }

    pub fn fill(&mut self, fd: usize, data: &[Value]) {
        self.files[fd].content.extend(data.to_owned());
    }

    pub fn dump(&mut self, fd: usize) -> Vec<Value> {
        self.files[fd].content.clone()
    }

    pub fn write(&mut self, fd: usize, data: Vec<Value>) -> Option<Value> {
        if let Some(file) = &mut self.files.get_mut(fd) {
            let length = data.len();
            file.position += length;
            file.content.extend(data);
            Some(Value::Concrete(length as u64, 0))
        } else {
            None
        }
    }

    pub fn seek(&mut self, fd: usize, pos: usize, whence: usize) -> Option<Value> {
        if let Some(file) = &mut self.files.get_mut(fd) {
            if whence == 0 {
                file.position = pos;
            } else if whence == 1 {
                file.position += pos;
            } else if whence == 2 {
                file.position = file.content.len() + pos;
            }
            Some(Value::Concrete(file.position as u64, 0))
        } else {
            None
        }
    }

    pub fn getfd(&mut self, path: &str) -> Option<usize> {
        self.files.iter().find(|f| f.path == path).map(|f| f.fd)
    }

    pub fn getpath(&mut self, fd: usize) -> Option<String> {
        self.files
            .iter()
            .find(|f| f.fd == fd)
            .map(|f| f.path.clone())
    }

    pub fn access(&mut self, path: &str) -> Value {
        if self.files.iter().any(|f| f.path == path) {
            return Value::Concrete(0, 0);
        }

        let metadata = fs::metadata(path);
        if metadata.is_ok() {
            Value::Concrete(0, 0)
        } else {
            Value::Concrete(-1i64 as u64, 0)
        }
    }

    pub fn stat(&mut self, path: &str) -> Option<Stat> {
        let metadata = fs::metadata(path);
        if let Ok(meta) = metadata {
            Some(Stat {
                st_dev: 16777234,
                st_ino: 3334575,
                st_mode: 33188,
                st_nlink: 0,
                st_uid: 0,
                st_gid: 0,
                st_rdev: 0,
                __pad0: 0,

                st_size: meta.len() as i64,
                st_blksize: 0x1000,
                st_blocks: 8,

                st_atime: meta
                    .accessed()
                    .unwrap()
                    .duration_since(SystemTime::UNIX_EPOCH)
                    .unwrap()
                    .as_secs(),
                st_atimensec: 0,
                st_mtime: meta
                    .modified()
                    .unwrap()
                    .duration_since(SystemTime::UNIX_EPOCH)
                    .unwrap()
                    .as_secs(),
                st_mtimensec: 0,
                st_ctime: meta
                    .created()
                    .unwrap()
                    .duration_since(SystemTime::UNIX_EPOCH)
                    .unwrap()
                    .as_secs(),
                st_ctimensec: 0,

                __glibc_reserved: [0, 0],
            })
        } else {
            None
        }
    }

    pub fn touch(&mut self, path: &str, mode: FileMode) {
        let fd = self.files.len();

        let file = SimFile {
            path: path.to_owned(),
            fd,
            position: 0,
            mode,
            content: vec![],
            metadata: None,
        };

        self.files.push(file);
    }

    pub fn close(&mut self, fd: usize) {
        self.seek(fd, 0, 0); // uhh just go to 0 for now
    }

    pub fn add_file(&mut self, path: &str, data: &[Value]) {
        self.files.push(SimFile {
            path: path.to_owned(),
            fd: self.files.len(),
            position: 0,
            mode: FileMode::Read,
            content: data.to_owned(),
            metadata: None,
        });
    }

    pub fn remove_file(&mut self, path: &str) {
        let f = self.files.iter().find(|f| f.path == path).map(|f| f.fd);
        if let Some(fd) = f {
            self.files.remove(fd);
        }
    }

    pub fn get_stdio() -> Vec<SimFile> {
        vec![
            SimFile {
                path: "STDIN".to_owned(), // idk
                fd: 0,
                position: 0,
                mode: FileMode::Read,
                content: Vec::with_capacity(256),
                metadata: None,
            },
            SimFile {
                path: "STDOUT".to_owned(),
                fd: 1,
                position: 0,
                mode: FileMode::Write,
                content: Vec::with_capacity(256),
                metadata: None,
            },
            SimFile {
                path: "STDERR".to_owned(),
                fd: 2,
                position: 0,
                mode: FileMode::Write,
                content: Vec::with_capacity(256),
                metadata: None,
            },
        ]
    }
}

```

`radius/src/sims/libc.rs`:

```rs
use crate::sims::format;
use crate::sims::syscall;
use crate::state::State;
use crate::value::{vc, Value};
use rand::Rng;

const MAX_LEN: u64 = 8192;

// TODO everything that interacts with errno in any way

// now using sim fs
pub fn puts(state: &mut State, args: &[Value]) -> Value {
    put_helper(state, args, true)
}

fn put_helper(state: &mut State, args: &[Value], nl: bool) -> Value {
    let addr = &args[0];
    let length = strlen(state, &args[0..1]);
    let mut data = state.memory_read(addr, &length);
    if nl {
        data.push(vc('\n' as u64))
    } // add newline
    state.filesystem.write(1, data);
    length
}

pub fn putchar(state: &mut State, args: &[Value]) -> Value {
    let c = args[0].slice(7, 0);
    state.filesystem.write(1, vec![c.clone()]);
    c
}

fn readline(state: &mut State, args: &[Value]) -> Value {
    let fd = state.solver.evalcon_to_u64(&args[0]).unwrap_or(0) as usize;
    let mut p = args[1].to_owned();

    loop {
        let c = state
            .filesystem
            .read(fd, 1)
            .get(0)
            .unwrap_or(&vc(-1i64 as u64))
            .to_owned();

        if c.as_u64() != Some(-1i64 as u64) {
            // uhhh idk we cant do symbolic file pos yet so
            // this is where we are at
            if c.as_u64() == Some('\n' as u64) {
                break;
            } else if c.is_symbolic() {
                state.assert(&!c.eq(&vc('\n' as u64)));
            }
            state.memory_write_value(&p, &c, 1);
            p = p + vc(1);
        } else {
            break;
        }
    }
    state.memory_write_value(&p, &vc(0), 1);
    args[1].to_owned()
}

pub fn getchar(state: &mut State, _args: &[Value]) -> Value {
    state
        .filesystem
        .read(0, 1)
        .get(0)
        .unwrap_or(&vc(-1i64 as u64))
        .to_owned()
}

pub fn fprintf(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &args[0..1]);
    let fdn = state.solver.evalcon_to_u64(&fd).unwrap_or(1);
    let formatted = format::format(state, &args[1..]);
    let ret = vc(formatted.len() as u64);
    state.filesystem.write(fdn as usize, formatted);
    ret
}

pub fn sprintf(state: &mut State, args: &[Value]) -> Value {
    let mut formatted = format::format(state, &args[1..]);
    formatted.push(vc(0));
    let ret = vc(formatted.len() as u64);
    state.memory_write(&args[0], &formatted, &vc(formatted.len() as u64));
    ret
}

pub fn snprintf(state: &mut State, args: &[Value]) -> Value {
    let mut formatted = format::format(state, &args[2..]);
    formatted.push(vc(0));
    let ret = vc(formatted.len() as u64);
    let length = state.cond(&args[1].ult(&ret), &args[1], &ret);
    state.memory_write(&args[0], &formatted, &length);
    ret
}

pub fn printf(state: &mut State, args: &[Value]) -> Value {
    let formatted = format::format(state, args);
    let ret = vc(formatted.len() as u64);
    state.filesystem.write(1, formatted);
    ret
}

pub fn scanf(state: &mut State, args: &[Value]) -> Value {
    let addr = state.solver.evalcon_to_u64(&args[0]).unwrap_or(0);
    let fmt = state.memory_read_cstring(addr);
    let length = if fmt.starts_with("%") && fmt.ends_with("s") && fmt.len() > 2 {
        vc(fmt[1..fmt.len()-1].parse::<u64>().unwrap_or(MAX_LEN))
    } else {
        vc(MAX_LEN)
    };

    if length.as_u64().unwrap() == MAX_LEN {
        let buf = state.memory_alloc(&length.add(&vc(1)));
        read(state, &[vc(0), buf.clone(), length]);
        let result = format::scan(state, &[&[buf.clone()], args].concat());
        state.memory_free(&buf);
        result
    } else {
        read(state, &[vc(0), args[1].clone(), length.clone()])
    }
}

pub fn sscanf(state: &mut State, args: &[Value]) -> Value {
    format::scan(state, args)
}

pub fn memmove(state: &mut State, args: &[Value]) -> Value {
    state.memory_move(&args[0], &args[1], &args[2].slice(31, 0));
    args[0].to_owned()
}

pub fn memmove_chk(state: &mut State, args: &[Value]) -> Value {
    state.assert(&args[2].ulte(&args[3])); // assert length < size
    memmove(state, args)
}

pub fn memcpy(state: &mut State, args: &[Value]) -> Value {
    // TODO make actual memcpy that does overlaps right
    // how often do memcpys actually do that? next to never probably
    state.memory_move(&args[0], &args[1], &args[2].slice(31, 0));
    args[0].to_owned()
}

pub fn memcpy_chk(state: &mut State, args: &[Value]) -> Value {
    state.assert(&args[2].ulte(&args[3])); // assert length < size
    memcpy(state, args)
}

pub fn bcopy(state: &mut State, args: &[Value]) -> Value {
    state.memory_move(&args[0], &args[1], &args[2].slice(31, 0));
    vc(0)
}

pub fn bzero(state: &mut State, args: &[Value]) -> Value {
    memset(state, &[args[0].to_owned(), vc(0), args[1].to_owned()]);
    vc(0)
}

pub fn mempcpy(state: &mut State, args: &[Value]) -> Value {
    memcpy(state, args).add(&args[2])
}

pub fn mempcpy_chk(state: &mut State, args: &[Value]) -> Value {
    memcpy_chk(state, args).add(&args[2])
}

pub fn memccpy(state: &mut State, args: &[Value]) -> Value {
    memcpy(state, args)
}

pub fn memfrob(state: &mut State, args: &[Value]) -> Value {
    let addr = &args[0];
    let num = &args[1];

    let x = vc(0x2a);
    let data = state.memory_read(addr, num);
    let mut new_data = vec![];
    for d in data {
        new_data.push(d.to_owned() ^ x.to_owned());
    }
    state.memory_write(addr, &new_data, num);
    vc(0)
}

pub fn strlen(state: &mut State, args: &[Value]) -> Value {
    state.memory_strlen(&args[0], &vc(MAX_LEN))
}

pub fn strnlen(state: &mut State, args: &[Value]) -> Value {
    state.memory_strlen(&args[0], &args[1].slice(31, 0))
}

pub fn gets(state: &mut State, args: &[Value]) -> Value {
    readline(state, &[&[vc(0)], args].concat())
}

pub fn fgets(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &args[2..3]);
    let buf = args[0].to_owned();
    let len = args[1].to_owned() - vc(1);
    syscall::read(state, &[fd, buf, len]);
    args[0].to_owned()
}

pub fn fputs(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &args[1..2]);
    let length = strlen(state, &args[0..1]);
    syscall::write(state, &[fd, args[0].to_owned(), length]);
    vc(0)
}

pub fn perror(state: &mut State, args: &[Value]) -> Value {
    let length = strlen(state, &args[0..1]);
    syscall::write(state, &[vc(2), args[0].to_owned(), length]);
    vc(0)
}

pub fn fputc(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &args[1..2]);
    let fdn = state.solver.evalcon_to_u64(&fd).unwrap_or(1) as usize;
    state.filesystem.write(fdn, vec![args[0].to_owned()]);
    vc(0)
}

pub fn feof(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &args[1..2]);
    let fdn = state.solver.evalcon_to_u64(&fd).unwrap_or(1) as usize;
    let f = &state.filesystem.files[fdn];
    vc((f.position != f.content.len() - 1) as u64)
}

pub fn strcpy(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[1], &vc(MAX_LEN)) + vc(1);
    state.memory_move(&args[0], &args[1], &length);
    args[0].to_owned()
}

pub fn strcpy_chk(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[1], &vc(MAX_LEN)) + vc(1);
    state.assert(&length.ulte(&args[2])); // assert length < size
    state.memory_move(&args[0], &args[1], &length);
    args[0].to_owned()
}

pub fn stpcpy(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[1], &vc(MAX_LEN));
    strcpy(state, args) + length
}

pub fn stpcpy_chk(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[1], &vc(MAX_LEN));
    strcpy_chk(state, args) + length
}

pub fn strdup(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[0], &vc(MAX_LEN)) + vc(1);
    let new_addr = vc(state.memory.alloc(&length));
    state.memory_move(&new_addr, &args[0], &length);
    new_addr
}

// what a weird function
pub fn strdupa(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[0], &vc(MAX_LEN)) + vc(1);
    strdup(state, args) + length
}

// TODO for strn stuff I may need to add a null?
pub fn strndup(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[0], &args[1].slice(31, 0));
    let new_addr = vc(state.memory.alloc(&length));
    state.memory_move(&new_addr, &args[0], &length);
    new_addr
}

pub fn strndupa(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[0], &args[1]);
    strndup(state, args) + length
}

pub fn strfry(_state: &mut State, args: &[Value]) -> Value {
    args[0].to_owned() // don't shuffle anything
}

pub fn strncpy(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[1], &args[2].slice(31, 0));
    state.assert(&length.ulte(&args[3])); // assert length < size
    state.memory_move(&args[0], &args[1], &length);
    args[0].to_owned()
}

pub fn strncpy_chk(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[1], &args[2].slice(31, 0));
    state.memory_move(&args[0], &args[1], &length);
    args[0].to_owned()
}

pub fn strcat(state: &mut State, args: &[Value]) -> Value {
    let length1 = state.memory_strlen(&args[0], &vc(MAX_LEN));
    let length2 = state.memory_strlen(&args[1], &vc(MAX_LEN)) + vc(1);
    state.memory_move(&args[0].add(&length1), &args[1], &length2);
    args[0].to_owned()
}

pub fn strcat_chk(state: &mut State, args: &[Value]) -> Value {
    let length1 = state.memory_strlen(&args[0], &vc(MAX_LEN));
    let length2 = state.memory_strlen(&args[1], &vc(MAX_LEN)) + vc(1);
    state.assert(&length1.add(&length2).ulte(&args[3])); // assert length < size
    state.memory_move(&args[0].add(&length1), &args[1], &length2);
    args[0].to_owned()
}

pub fn strncat(state: &mut State, args: &[Value]) -> Value {
    let length1 = state.memory_strlen(&args[0], &args[2].slice(31, 0));
    let length2 = state.memory_strlen(&args[1], &args[2].slice(31, 0)) + vc(1);
    state.memory_move(&args[0].add(&length1), &args[1], &length2);
    args[0].to_owned()
}

pub fn memset(state: &mut State, args: &[Value]) -> Value {
    let mut data = vec![];
    let length = state.solver.max_value(&args[2]) & 0xffffffff;
    for _ in 0..length {
        data.push(args[1].to_owned());
    }

    state.memory_write(&args[0], &data, &args[2]);
    args[0].to_owned()
}

pub fn memset_chk(state: &mut State, args: &[Value]) -> Value {
    state.assert(&args[2].ulte(&args[3])); // assert length < size
    memset(state, args)
}

fn memchr_helper(state: &mut State, args: &[Value], reverse: bool) -> Value {
    state.memory_search(&args[0], &args[1], &args[2], reverse)
}

pub fn memchr(state: &mut State, args: &[Value]) -> Value {
    memchr_helper(state, args, false)
}

pub fn memrchr(state: &mut State, args: &[Value]) -> Value {
    memchr_helper(state, args, true)
}

fn strchr_helper(state: &mut State, args: &[Value], reverse: bool) -> Value {
    let length = state.memory_strlen(&args[0], &vc(MAX_LEN));
    let string = args[0].to_owned();
    let c = args[1].and(&vc(0xff));

    memchr_helper(state, &[string, c, length], reverse)
}

pub fn strchr(state: &mut State, args: &[Value]) -> Value {
    strchr_helper(state, args, false)
}

pub fn strrchr(state: &mut State, args: &[Value]) -> Value {
    strchr_helper(state, args, true)
}

pub fn memcmp(state: &mut State, args: &[Value]) -> Value {
    state.memory_compare(&args[0], &args[1], &args[2])
}

pub fn strcmp(state: &mut State, args: &[Value]) -> Value {
    let len1 = state.memory_strlen(&args[0], &vc(MAX_LEN));
    let len2 = state.memory_strlen(&args[1], &vc(MAX_LEN));
    let length = state.cond(&(len1.ult(&len2)), &len1, &len2) + vc(1);

    state.memory_compare(&args[0], &args[1], &length)
}

pub fn strncmp(state: &mut State, args: &[Value]) -> Value {
    let len1 = state.memory_strlen(&args[0], &args[2]);
    let len2 = state.memory_strlen(&args[1], &args[2]);
    let mut length = state.cond(&(len1.ult(&len2)), &len1, &len2);
    length = state.cond(&(length.ult(&args[2])), &length.add(&vc(1)), &args[2]);

    state.memory_compare(&args[0], &args[1], &length)
}

// TODO properly handle sym slens
// idk if I will ever do this ^. it is super complicated
// and the performance would likely be bad anyway
pub fn memmem(state: &mut State, args: &[Value]) -> Value {
    let len = state.solver.evalcon_to_u64(&args[3]).unwrap() as usize;
    let mut needle_val = state.memory_read_value(&args[2], len);

    // necessary as concrete values will not search for end nulls
    needle_val = Value::Symbolic(
        state.solver.to_bv(&needle_val, 8 * len as u32),
        needle_val.get_taint(),
    );

    let mem = args[0].to_owned();
    let length = args[1].to_owned();
    memchr_helper(state, &[mem, needle_val, length], false)
}

pub fn strstr(state: &mut State, args: &[Value]) -> Value {
    let dlen = state.memory_strlen(&args[0], &vc(MAX_LEN));
    let slen = state.memory_strlen(&args[1], &vc(MAX_LEN));
    let len = state.solver.evalcon_to_u64(&slen).unwrap() as usize;
    let needle_val = state.memory_read_value(&args[0], len);
    memchr_helper(state, &[args[0].to_owned(), needle_val, dlen], false)
}

pub fn malloc(state: &mut State, args: &[Value]) -> Value {
    state.memory_alloc(&args[0])
}

pub fn realloc(state: &mut State, args: &[Value]) -> Value {
    malloc(state, &args[1..])
}

pub fn calloc(state: &mut State, args: &[Value]) -> Value {
    state.memory_alloc(&args[0].mul(&args[1]))
}

pub fn free(state: &mut State, args: &[Value]) -> Value {
    state.memory_free(&args[0]);
    vc(0)
}

pub fn mmap(state: &mut State, args: &[Value]) -> Value {
    syscall::mmap(state, args)
}

pub fn munmap(state: &mut State, args: &[Value]) -> Value {
    syscall::munmap(state, args)
}

pub fn c_syscall(state: &mut State, args: &[Value]) -> Value {
    syscall::syscall("indirect_syscall", state, args)
}

// This is not going to be a real version of this func
// because otherwise all execution would have to take place
// within this sim which would be weird and bad
pub fn __libc_start_main(state: &mut State, args: &[Value]) -> Value {
    let main = args[0].to_owned();
    let argc = args[1].to_owned();
    let argv = args[2].to_owned();

    // TODO go to init then main
    // but we need a nice arch neutral way to push ret
    // so until then

    // go to main
    state.registers.set_with_alias("PC", main);
    state.registers.set_with_alias("A0", argc);
    state.registers.set_with_alias("A1", argv);

    // TODO set env
    state.registers.set_with_alias("A2", vc(0));

    // uh in case we are overwriting A0
    args[1].to_owned()
}

/*
type = struct _IO_FILE {
/*    0      |     4 */    int _flags;
/* XXX  4-byte hole  */
/*    8      |     8 */    char *_IO_read_ptr;
/*   16      |     8 */    char *_IO_read_end;
/*   24      |     8 */    char *_IO_read_base;
/*   32      |     8 */    char *_IO_write_base;
/*   40      |     8 */    char *_IO_write_ptr;
/*   48      |     8 */    char *_IO_write_end;
/*   56      |     8 */    char *_IO_buf_base;
/*   64      |     8 */    char *_IO_buf_end;
/*   72      |     8 */    char *_IO_save_base;
/*   80      |     8 */    char *_IO_backup_base;
/*   88      |     8 */    char *_IO_save_end;
/*   96      |     8 */    struct _IO_marker *_markers;
/*  104      |     8 */    struct _IO_FILE *_chain;
/*  112      |     4 */    int _fileno;
/*  116      |     4 */    int _flags2;
/*  120      |     8 */    __off_t _old_offset;
/*  128      |     2 */    unsigned short _cur_column;
/*  130      |     1 */    signed char _vtable_offset;
/*  131      |     1 */    char _shortbuf[1];
/* XXX  4-byte hole  */
/*  136      |     8 */    _IO_lock_t *_lock;
/*  144      |     8 */    __off64_t _offset;
/*  152      |     8 */    struct _IO_codecvt *_codecvt;
/*  160      |     8 */    struct _IO_wide_data *_wide_data;
/*  168      |     8 */    struct _IO_FILE *_freeres_list;
/*  176      |     8 */    void *_freeres_buf;
/*  184      |     8 */    size_t __pad5;
/*  192      |     4 */    int _mode;
/*  196      |    20 */    char _unused2[20];

                           /* total size (bytes):  216 */
                         }
*/

// beginning of bad FILE function support

// _fileno offset from above linux x86_64
pub const LINUX_FILENO_OFFSET: u64 = 112;

// _file offset from macos aarch64
pub const MACOS_FILENO_OFFSET: u64 = 18;

pub fn fileno(state: &mut State, args: &[Value]) -> Value {
    let fd_addr = if state.info.bin.os == "darwin" {
        args[0].add(&vc(MACOS_FILENO_OFFSET))
    } else {
        args[0].add(&vc(LINUX_FILENO_OFFSET))
    };
    state.memory_read_value(&(fd_addr), 4)
}

pub fn fopen(state: &mut State, args: &[Value]) -> Value {
    // we are reaching levels of jank code previously undreamt
    let fd = syscall::open(state, args);
    let file_struct = state.memory.alloc(&vc(216));

    let fd_addr = if state.info.bin.os == "darwin" {
        vc(file_struct).add(&vc(MACOS_FILENO_OFFSET))
    } else {
        vc(file_struct).add(&vc(LINUX_FILENO_OFFSET))
    };
    state.memory_write_value(&fd_addr, &fd, 4);
    vc(file_struct)
}

pub fn fclose(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &[args[0].to_owned()]);
    syscall::close(state, &[fd])
}

pub fn fread(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &[args[3].to_owned()]);
    syscall::read(
        state,
        &[fd, args[0].to_owned(), args[1].mul(&args[2]).to_owned()],
    )
}

pub fn fwrite(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &[args[3].to_owned()]);
    syscall::write(
        state,
        &[fd, args[0].to_owned(), args[1].mul(&args[2]).to_owned()],
    )
}

pub fn fseek(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &[args[0].to_owned()]);
    syscall::lseek(state, &[fd, args[1].to_owned(), args[2].to_owned()])
}

pub fn ftell(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &[args[0].to_owned()]);
    let fdn = state.solver.evalcon_to_u64(&fd).unwrap_or_default() as usize;
    vc(state.filesystem.files[fdn].position as u64)
}

pub fn rewind(state: &mut State, args: &[Value]) -> Value {
    let fd = fileno(state, &[args[0].to_owned()]);
    syscall::lseek(state, &[fd, vc(0), vc(0)])
}

// is whitespace
fn _isws(c: &Value) -> Value {
    c.eq(&vc(0x09)) | c.eq(&vc(0x20)) | c.eq(&vc(0x0d)) | c.eq(&vc(0x0a))
}

pub fn atoi(state: &mut State, args: &[Value]) -> Value {
    format::atoi_helper(state, &args[0], &vc(10), 32)
}

pub fn atol(state: &mut State, args: &[Value]) -> Value {
    let bits = state.memory.bits;
    format::atoi_helper(state, &args[0], &vc(10), bits)
}

pub fn atoll(state: &mut State, args: &[Value]) -> Value {
    format::atoi_helper(state, &args[0], &vc(10), 64)
}

fn strto_helper(state: &mut State, args: &[Value], bits: u64) -> Value {
    // not perfect but idk
    if let Value::Concrete(addr, _) = args[1] {
        if addr != 0 {
            let length = state.memory_strlen(&args[0], &vc(64));
            state.memory_write_value(
                &args[1],
                &args[0].add(&length),
                state.memory.bits as usize / 8,
            );
        }
    }

    format::atoi_helper(state, &args[0], &args[2], bits)
}

pub fn strtoll(state: &mut State, args: &[Value]) -> Value {
    strto_helper(state, args, 64)
}

// this is string to double not int... do something horrific for now
pub fn strtod(state: &mut State, args: &[Value]) -> Value {
    let addr = state.solver.evalcon_to_u64(&args[0]).unwrap_or_default();
    vc(state
        .memory_read_cstring(addr)
        .parse::<f64>()
        .unwrap_or_default()
        .to_bits())
}

pub fn strtof(state: &mut State, args: &[Value]) -> Value {
    let addr = state.solver.evalcon_to_u64(&args[0]).unwrap_or_default();
    vc(state
        .memory_read_cstring(addr)
        .parse::<f32>()
        .unwrap_or_default()
        .to_bits() as u64)
}

pub fn strtol(state: &mut State, args: &[Value]) -> Value {
    let bits = state.memory.bits;
    strto_helper(state, args, bits)
}

pub fn strtoul(state: &mut State, args: &[Value]) -> Value {
    let bits = state.memory.bits;
    strto_helper(state, args, bits)
}

pub fn itoa(state: &mut State, args: &[Value]) -> Value {
    format::itoa_helper(state, &args[0], &args[1], &args[2], true, 32)
}

pub fn islower(_state: &mut State, args: &[Value]) -> Value {
    let c = args[0].slice(7, 0);
    c.ult(&vc(0x7b)) & !c.ult(&vc(0x61))
}

pub fn isupper(_state: &mut State, args: &[Value]) -> Value {
    let c = args[0].slice(7, 0);
    c.ult(&vc(0x5b)) & !c.ult(&vc(0x41))
}

pub fn isalpha(state: &mut State, args: &[Value]) -> Value {
    isupper(state, args) | islower(state, args)
}

pub fn isdigit(_state: &mut State, args: &[Value]) -> Value {
    let c = args[0].slice(7, 0);
    c.ult(&vc(0x3a)) & !c.ult(&vc(0x30))
}

pub fn isalnum(state: &mut State, args: &[Value]) -> Value {
    isalpha(state, args) | isdigit(state, args)
}

pub fn isblank(_state: &mut State, args: &[Value]) -> Value {
    let c = args[0].slice(7, 0);
    c.eq(&vc(0x20)) | c.eq(&vc(0x09))
}

pub fn iscntrl(_state: &mut State, args: &[Value]) -> Value {
    let c = args[0].slice(7, 0);
    (c.ugte(&vc(0)) & c.ulte(&vc(0x1f))) | c.eq(&vc(0x7f))
}

pub fn toupper(state: &mut State, args: &[Value]) -> Value {
    let islo = islower(state, args);
    state.cond(&islo, &args[0].sub(&vc(0x20)), &args[0])
}

pub fn tolower(state: &mut State, args: &[Value]) -> Value {
    let isup = isupper(state, args);
    state.cond(&isup, &args[0].add(&vc(0x20)), &args[0])
}

pub fn zero(_state: &mut State, _args: &[Value]) -> Value {
    vc(0)
}

pub fn rand(state: &mut State, _args: &[Value]) -> Value {
    // let r = rand::thread_rng().gen::<u64>();
    // let rand = state.symbolic_value(&format!("rand_{}", r), 64);

    // let rand_vec = &mut state
    //     .context
    //     .entry("rand".to_string())
    //     .or_insert_with(Vec::new);

    // rand_vec.push(rand.clone());
    // rand
    vc(4) // https://xkcd.com/221
}

pub fn srand(_state: &mut State, _args: &[Value]) -> Value {
    vc(0)
}

pub fn fflush(_state: &mut State, _args: &[Value]) -> Value {
    vc(0)
}

pub fn getpid(state: &mut State, args: &[Value]) -> Value {
    syscall::getpid(state, args)
}

pub fn getuid(state: &mut State, args: &[Value]) -> Value {
    syscall::getuid(state, args)
}

pub fn getgid(state: &mut State, args: &[Value]) -> Value {
    syscall::getuid(state, args)
}

pub fn geteuid(state: &mut State, args: &[Value]) -> Value {
    syscall::getuid(state, args)
}

pub fn getegid(state: &mut State, args: &[Value]) -> Value {
    syscall::getuid(state, args)
}

pub fn fork(state: &mut State, args: &[Value]) -> Value {
    syscall::fork(state, args)
}

pub fn brk(state: &mut State, args: &[Value]) -> Value {
    let addr = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let current = syscall::sbrk(state, &[vc(0)]).as_u64();
    let new = syscall::brk(state, args).as_u64();
    if current.unwrap() == addr || new.unwrap() != addr {
        vc(0)
    } else {
        vc(-1i64 as u64)
    }
}

pub fn sbrk(state: &mut State, args: &[Value]) -> Value {
    syscall::sbrk(state, args)
}

pub fn getpagesize(_state: &mut State, _args: &[Value]) -> Value {
    vc(0x1000)
}

pub fn gethostname(state: &mut State, args: &[Value]) -> Value {
    let addr = state.solver.evalcon_to_u64(&args[0]).unwrap_or(0);
    state.memory_write_string(addr, "radius");
    vc(0)
}

// hardcode these for now idk
const OPTIND: u64 = 0xfffd0000;
const OPTARG: u64 = 0xfffd0004;

fn getopt_setup(state: &mut State) {
    let relocs = state.r2api.get_relocations().unwrap_or_default();

    let optind_addr = relocs
        .iter()
        .find(|r| r.name == "optind")
        .map(|r| r.vaddr)
        .unwrap_or(0);

    let optarg_addr = relocs
        .iter()
        .find(|r| r.name == "optarg")
        .map(|r| r.vaddr)
        .unwrap_or(0);

    let optind_ptr = state.memory_read_value(&vc(optind_addr), 4);

    if let Some(ind) = optind_ptr.as_u64() {
        if ind != OPTIND {
            state.memory_write_ptr(&vc(optind_addr), &vc(OPTIND));
            state.memory_write_ptr(&vc(optarg_addr), &vc(OPTARG));
            state.memory_write_value(&vc(OPTIND), &vc(1), 4);
            state.memory_write_ptr(&vc(OPTARG), &vc(0));
        }
    }
}

/*
from the man pages

"By default, getopt() permutes the contents of argv as it scans,
so that eventually all the nonoptions are at the end."

uhhhh i am not gonna do that for right now? also wat
*/

// this is not even close to being a faithful representation
// of the actual (insane) semantics of getopt
pub fn getopt(state: &mut State, args: &[Value]) -> Value {
    getopt_setup(state);

    let ptr = state.memory.bits / 8;
    let optind_val = state.memory_read_value(&vc(OPTIND), 4);
    let optind = state.solver.evalcon_to_u64(&optind_val).unwrap_or(1);
    let argc = state.solver.evalcon_to_u64(&args[0]).unwrap_or(1);

    if optind >= argc {
        vc(-1i64 as u64)
    } else {
        let optstr_addr = state.solver.evalcon_to_u64(&args[2]).unwrap_or(0);
        let optstr = state.memory_read_cstring(optstr_addr);

        let argv_addr = state.memory_read_ptr(&args[1].add(&vc(optind * ptr)));
        let argv_len = strlen(state, &[argv_addr.clone()]);

        let arg = state.memory_read(&argv_addr, &argv_len);
        let mut result = vc(-1i64 as u64);
        if arg.len() < 2 {
            return result;
        }

        let is_opt = arg[0].eq(&vc('-' as u64));
        result = state.cond(&is_opt, &vc('?' as u64), &result);
        let mut optarg = state.memory_read_ptr(&vc(OPTARG));

        for index in 0..optstr.len() {
            let c = vc(optstr.as_bytes()[index] as u64);
            let is_c = arg[1].eq(&c);
            result = state.cond(&is_opt.and(&is_c), &c, &result);

            if arg.len() > 2 && index + 1 < optstr.len() && &optstr[index + 1..index + 2] == ":" {
                // argument may be next argv, nvmd disallow
                //let newarg_addr = args[1].add(&vc((optind+1)*ptr));

                // if opt is c which has arg, arg must be in same argv (eg -xfoo)
                let arg_cond = (!is_c.clone()).or(&is_c.and(&!arg[2].eq(&vc(0))));
                state.assert(&arg_cond);

                optarg = state.cond(&is_c, &argv_addr.add(&vc(2)), &optarg);
                state.memory_write_ptr(&vc(OPTARG), &optarg);
            }
        }

        state.memory_write_value(&vc(OPTIND), &vc(optind + 1), 4);
        result
    }
}

// fully symbolic getenv
pub fn getenv(state: &mut State, args: &[Value]) -> Value {
    if state.context.get("env").is_none() {
        return vc(0);
    }

    let arg_ptr = args[0].to_owned();
    let arg_length = state.memory_strlen(&arg_ptr, &vc(MAX_LEN));

    let bits = state.memory.bits as usize;
    let mut env_ptr = state.context["env"][0].clone();
    let mut result = vc(0);
    let eqs = vc('=' as u64);
    loop {
        let var_ptr = state.memory_read_value(&env_ptr, bits / 8);

        if state.solver.check_sat(&var_ptr.eq(&vc(0))) {
            state.assert(&var_ptr.eq(&vc(0)));
            break;
        }

        let full_length = state.memory_strlen(&var_ptr, &vc(MAX_LEN));
        let name_end = state.memory_search(&var_ptr, &eqs, &full_length, false);

        let name_length = state.cond(&name_end.eq(&vc(0)), &full_length, &name_end.sub(&var_ptr));

        let value_ptr = var_ptr.add(&name_length).add(&vc(1));
        let long_len = state.cond(&arg_length.ugte(&name_length), &arg_length, &name_length);

        let cmp = state.memory_compare(&arg_ptr, &var_ptr, &long_len);
        result = state.cond(&cmp.eq(&vc(0)), &value_ptr, &result);

        env_ptr = env_ptr + vc(bits as u64 / 8);
    }
    result
}

// the first arg is always the real path idk
pub fn realpath(state: &mut State, args: &[Value]) -> Value {
    let length = state.memory_strlen(&args[0], &vc(MAX_LEN));
    state.memory_move(&args[1], &args[0], &length);
    args[1].to_owned()
}

pub fn sleep(_state: &mut State, _args: &[Value]) -> Value {
    vc(0)
}

pub fn __errno_location(state: &mut State, _args: &[Value]) -> Value {
    let addr = state.memory_alloc(&vc(8));
    state.memory_write_value(&addr, &vc(0), 8);
    addr
}

pub fn open(state: &mut State, args: &[Value]) -> Value {
    syscall::open(state, args)
}

pub fn close(state: &mut State, args: &[Value]) -> Value {
    syscall::close(state, args)
}

pub fn read(state: &mut State, args: &[Value]) -> Value {
    syscall::read(state, args)
}

pub fn write(state: &mut State, args: &[Value]) -> Value {
    syscall::write(state, args)
}

pub fn lseek(state: &mut State, args: &[Value]) -> Value {
    syscall::lseek(state, args)
}

pub fn access(state: &mut State, args: &[Value]) -> Value {
    syscall::access(state, args)
}

pub fn stat(state: &mut State, args: &[Value]) -> Value {
    syscall::stat(state, args)
}

pub fn fstat(state: &mut State, args: &[Value]) -> Value {
    syscall::fstat(state, args)
}

pub fn lstat(state: &mut State, args: &[Value]) -> Value {
    syscall::lstat(state, args)
}

pub fn ptrace(state: &mut State, args: &[Value]) -> Value {
    syscall::ptrace(state, args)
}

pub fn exit(state: &mut State, args: &[Value]) -> Value {
    syscall::exit(state, args)
}

```

`radius/src/sims/mod.rs`:

```rs
use crate::state::State;
use crate::value::Value;

pub mod format;
pub mod fs;
pub mod libc;
pub mod syscall;

pub type SimMethod = fn(&mut State, &[Value]) -> Value;

#[derive(Clone)]
pub struct Sim {
    pub symbol: String,
    pub function: SimMethod,
    pub arguments: usize,
}

pub fn make_sim(symbol: &str, function: SimMethod, arguments: usize) -> Sim {
    Sim {
        symbol: String::from(symbol),
        function,
        arguments,
    }
}

pub fn error(_state: &mut State, _args: &[Value]) -> Value {
    Value::Concrete(-1i64 as u64, 0)
}

pub fn zero(_state: &mut State, _args: &[Value]) -> Value {
    Value::Concrete(0, 0)
}

pub fn ret(state: &mut State, _args: &[Value]) -> Value {
    state.registers.get_with_alias("R0")
}

// this isn't great
/*pub fn unconstrained(state: &mut State, _args: &[Value]) -> Value {
    let mut uncon_vec = state.context.entry("uncon".to_owned()).or_insert(vec!()).clone();
    let uncon = state.symbolic_value(&format!("uncon_{}", uncon_vec.len()), 64);
    uncon_vec.push(uncon.clone());
    state.context.insert("uncon".to_owned(), uncon_vec);
    uncon
}*/

/*
add fortify versions
memcpy, mempcpy, memmove, memset, strcpy, stpcpy, stncpy, 
strcat, strncat, sprintf, vsprintf, snprintf, vsnprintf, gets.
*/

// get a vec of all available Sims
pub fn get_sims() -> Vec<Sim> {
    vec![
        make_sim("puts", libc::puts, 1),
        make_sim("gets", libc::gets, 1),
        make_sim("__gets_chk", libc::gets, 1),
        make_sim("putchar", libc::putchar, 1),
        make_sim("putwchar", libc::putchar, 1),
        make_sim("getchar", libc::getchar, 0),
        make_sim("fgets", libc::fgets, 1),
        make_sim("__fgets_chk", libc::fgets, 1),
        make_sim("fgetc", libc::fgets, 1),
        make_sim("fputs", libc::fputs, 2),
        make_sim("fputc", libc::fputc, 2),
        make_sim("feof", libc::feof, 1),
        make_sim("fprintf", libc::fprintf, 2),
        make_sim("printf", libc::printf, 1),
        make_sim("sprintf", libc::sprintf, 2),
        make_sim("__sprintf_chk", libc::sprintf, 2),
        make_sim("snprintf", libc::snprintf, 3),
        make_sim("__snprintf_chk", libc::snprintf, 3),
        make_sim("vprintf", libc::printf, 1),   // fix
        make_sim("vsprintf", libc::sprintf, 2), // fix
        make_sim("__vsprintf_chk", libc::sprintf, 2),
        make_sim("perror", libc::perror, 1),
        make_sim("fflush", libc::fflush, 0),
        make_sim("scanf", libc::scanf, 1),
        make_sim("sscanf", libc::sscanf, 1),
        make_sim("__isoc99_scanf", libc::scanf, 1),
        make_sim("__isoc99_sscanf", libc::sscanf, 1),
        make_sim("fopen", libc::fopen, 2),
        make_sim("freopen", libc::fopen, 3),
        make_sim("fread", libc::fread, 4),
        make_sim("fwrite", libc::fwrite, 4),
        make_sim("ferror", libc::zero, 1),
        make_sim("fseek", libc::fseek, 2),
        make_sim("ftell", libc::ftell, 1),
        make_sim("fclose", libc::fgets, 1),
        make_sim("rewind", libc::rewind, 2),
        make_sim("strlen", libc::strlen, 1),
        make_sim("strnlen", libc::strnlen, 2),
        make_sim("strstr", libc::strstr, 2),
        make_sim("strcpy", libc::strcpy, 2),
        make_sim("__strcpy_chk", libc::strcpy_chk, 2),
        make_sim("stpcpy", libc::stpcpy, 2),
        make_sim("__stpcpy_chk", libc::stpcpy_chk, 2),
        make_sim("strncpy", libc::strncpy, 3),
        make_sim("__strncpy_chk", libc::strncpy_chk, 3),
        make_sim("strxfrm", libc::strncpy, 3),
        make_sim("strcat", libc::strcat, 2),
        make_sim("__strcat_chk", libc::strcat_chk, 2),
        make_sim("strncat", libc::strncat, 3),
        make_sim("strdup", libc::strdup, 1),
        make_sim("strndup", libc::strndup, 2),
        make_sim("strdupa", libc::strdupa, 1),
        make_sim("strndupa", libc::strndupa, 2),
        make_sim("strfry", libc::strfry, 1),
        make_sim("strchr", libc::strchr, 2),
        make_sim("__strchr_chk", libc::strchr, 2),
        make_sim("strrchr", libc::strrchr, 2),
        make_sim("strstr", libc::strstr, 2),
        make_sim("strcmp", libc::strcmp, 2),
        make_sim("strcoll", libc::strcmp, 2),
        make_sim("strncmp", libc::strncmp, 3),
        make_sim("memmove", libc::memmove, 3),
        make_sim("__memmove_chk", libc::memmove_chk, 3),
        make_sim("memcpy", libc::memcpy, 3),
        make_sim("__memcpy_chk", libc::memcpy_chk, 3),
        make_sim("memccpy", libc::memccpy, 3),
        make_sim("mempcpy", libc::mempcpy, 3),
        make_sim("__mempcpy_chk", libc::mempcpy_chk, 3),
        make_sim("memfrob", libc::memfrob, 2),
        make_sim("memset", libc::memset, 3),
        make_sim("__memset_chk", libc::memset_chk, 3),
        make_sim("memchr", libc::memchr, 3),
        make_sim("__memchr_chk", libc::memchr, 3),
        make_sim("memrchr", libc::memrchr, 3),
        make_sim("memcmp", libc::memcmp, 3),
        make_sim("bcmp", libc::memcmp, 3),
        make_sim("memmem", libc::memmem, 3),
        make_sim("bcopy", libc::bcopy, 3),
        make_sim("bzero", libc::bzero, 2),
        make_sim("malloc", libc::malloc, 1),
        make_sim("realloc", libc::realloc, 1),
        make_sim("calloc", libc::calloc, 2),
        make_sim("free", libc::strnlen, 1),
        make_sim("mmap", libc::mmap, 4),
        make_sim("munmap", libc::munmap, 2),
        make_sim("brk", libc::brk, 1),
        make_sim("sbrk", libc::sbrk, 1),
        make_sim("atoi", libc::atoi, 1),
        make_sim("atol", libc::atol, 1),
        make_sim("itoa", libc::itoa, 3),
        make_sim("strtol", libc::strtol, 3),
        make_sim("strtoul", libc::strtoul, 3),
        make_sim("strtoll", libc::strtoll, 3),
        make_sim("strtod", libc::strtod, 3),
        make_sim("islower", libc::islower, 1),
        make_sim("isupper", libc::isupper, 1),
        make_sim("isalpha", libc::isalpha, 1),
        make_sim("isdigit", libc::isdigit, 1),
        make_sim("isalnum", libc::isalnum, 1),
        make_sim("iscntrl", libc::iscntrl, 1),
        make_sim("isblank", libc::isblank, 1),
        make_sim("tolower", libc::tolower, 1),
        make_sim("toupper", libc::toupper, 1),
        make_sim("open", libc::open, 3),
        make_sim("close", libc::close, 1),
        make_sim("read", libc::read, 3),
        make_sim("write", libc::write, 3),
        make_sim("lseek", libc::lseek, 2),
        make_sim("access", libc::access, 1),
        make_sim("stat", libc::stat, 2),
        make_sim("fstat", libc::fstat, 2),
        make_sim("lstat", libc::lstat, 2),
        make_sim("getopt", libc::getopt, 3),
        make_sim("getopt_long", libc::getopt, 4),
        make_sim("getuid", libc::getuid, 0),
        make_sim("getgid", libc::getgid, 0),
        make_sim("geteuid", libc::geteuid, 0),
        make_sim("getegid", libc::getegid, 0),
        make_sim("sleep", libc::sleep, 1),
        make_sim("getpid", libc::getpid, 0),
        make_sim("fork", libc::fork, 0),
        make_sim("ptrace", libc::ptrace, 0),
        make_sim("syscall", libc::c_syscall, 0),
        make_sim("getenv", libc::getenv, 1),
        make_sim("abort", libc::exit, 1),
        make_sim("exit", libc::exit, 1),
        make_sim("xexit", libc::exit, 1),
        make_sim("ioctl", error, 1),
        make_sim("sysctl", zero, 1),
        make_sim("setbuf", zero, 2),
        make_sim("rand", libc::rand, 0),
        make_sim("arc4random", libc::rand, 0),
        make_sim("srand", libc::srand, 1),
        make_sim("gethostname", libc::gethostname, 0),
        make_sim("getpagesize", libc::getpagesize, 0),
        make_sim("__stack_chk_fail", ret, 0),
        // this is covered by the hook in radius.rs
        // make_sim("__libc_start_main", libc::__libc_start_main, 5),
        make_sim("__cfi_slowpath", zero, 0),
        make_sim("__errno_location", libc::__errno_location, 0),
    ]
}

```

`radius/src/sims/objc.rs`:

```rs
use crate::value::Value;
use crate::state::State;
use crate::sims::syscall;

pub fn objc_msgSend(state: &mut State, args: Vec<Value>) -> Value {
    Value::Concrete(0, 0)
}

pub fn objc_msgSend_stret(state: &mut State, args: Vec<Value>) -> Value {
    Value::Concrete(0, 0)
}

pub fn objc_msgSendSuper(state: &mut State, args: Vec<Value>) -> Value {
    Value::Concrete(0, 0)
}

pub fn objc_msgSendSuper_stret(state: &mut State, args: Vec<Value>) -> Value {
    Value::Concrete(0, 0)
}
```

`radius/src/sims/syscall.rs`:

```rs
use crate::sims::fs::FileMode;
use crate::state::{State, StateStatus};
use crate::value::Value;

const MAX_LEN: u64 = 8192;

pub fn syscall(syscall_name: &str, state: &mut State, args: &[Value]) -> Value {
    match syscall_name {
        "indirect_syscall" => indirect(state, args), // fuq

        "open" => open(state, args),
        "openat" => openat(state, args),
        "close" => close(state, args),
        "read" => read(state, args),
        "write" => write(state, args),
        "access" => access(state, args),
        "stat" => stat(state, args),
        "fstat" => fstat(state, args),
        "lstat" => lstat(state, args),
        "lseek" => lseek(state, args),
        "mprotect" => mmap(state, args),
        "mmap" => mmap(state, args),
        "munmap" => munmap(state, args),
        "brk" => brk(state, args),
        "sbrk" => sbrk(state, args),
        "getpid" => getpid(state, args),
        "getuid" => getuid(state, args),
        "geteuid" => getuid(state, args),
        "getgid" => getuid(state, args),
        "getegid" => getuid(state, args),
        "fork" => fork(state, args),
        "exit" => exit(state, args),
        "ptrace" => ptrace(state, args),
        _ => error(state, args), // this is literally every syscall
                                 // the rest arent real
                                 // you have been played for a fool
    }
}

// get actual syscall and recall ..
pub fn indirect(state: &mut State, args: &[Value]) -> Value {
    let sn = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let sys_str = state.r2api.get_syscall_str(sn).unwrap();
    syscall(sys_str.as_str(), state, &args[1..])
}

pub fn open(state: &mut State, args: &[Value]) -> Value {
    let addr = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let len = state.memory_strlen(&args[0], &Value::Concrete(MAX_LEN, 0));
    let length = state.solver.evalcon_to_u64(&len).unwrap();
    let path = state.memory_read_string(addr, length as usize);
    if let Some(fd) = state.filesystem.open(path.as_str(), FileMode::Read) {
        Value::Concrete(fd as u64, 0)
    } else {
        Value::Concrete(-1i64 as u64, 0)
    }
}

// ignore dir for now idk
pub fn openat(state: &mut State, args: &[Value]) -> Value {
    open(state, &args[1..])
}

pub fn close(state: &mut State, args: &[Value]) -> Value {
    let fd = state.solver.evalcon_to_u64(&args[0]);
    state.filesystem.close(fd.unwrap() as usize);
    Value::Concrete(0, 0)
}

pub fn read(state: &mut State, args: &[Value]) -> Value {
    let fd = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let length = state.solver.max_value(&args[2]) & 0xffffffff;
    let data = state.filesystem.read(fd as usize, length as usize);
    let len = data.len();
    state.memory_write(&args[1], &data, &args[2]);
    Value::Concrete(len as u64, args[2].get_taint())
}

pub fn write(state: &mut State, args: &[Value]) -> Value {
    let fd = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let data = state.memory_read(&args[1], &args[2]);
    let len = data.len();
    state.filesystem.write(fd as usize, data);
    Value::Concrete(len as u64, 0)
}

pub fn access(state: &mut State, args: &[Value]) -> Value {
    let addr = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let len = state.memory_strlen(&args[0], &Value::Concrete(MAX_LEN, 0));
    let length = state.solver.evalcon_to_u64(&len).unwrap();
    let path = state.memory_read_string(addr, length as usize);
    state.filesystem.access(path.as_str())
}

/*

/* offset    |  size */  type = struct stat {
/*    0      |     8 */    __dev_t st_dev;
/*    8      |     8 */    __ino_t st_ino;
/*   16      |     8 */    __nlink_t st_nlink;
/*   24      |     4 */    __mode_t st_mode;
/*   28      |     4 */    __uid_t st_uid;
/*   32      |     4 */    __gid_t st_gid;
/*   36      |     4 */    int __pad0;
/*   40      |     8 */    __dev_t st_rdev;
/*   48      |     8 */    __off_t st_size;
/*   56      |     8 */    __blksize_t st_blksize;
/*   64      |     8 */    __blkcnt_t st_blocks;
/*   72      |    16 */    struct timespec {
/*   72      |     8 */        __time_t tv_sec;
/*   80      |     8 */        __syscall_slong_t tv_nsec;

                               /* total size (bytes):   16 */
                           } st_atim;
/*   88      |    16 */    struct timespec {
/*   88      |     8 */        __time_t tv_sec;
/*   96      |     8 */        __syscall_slong_t tv_nsec;

                               /* total size (bytes):   16 */
                           } st_mtim;
/*  104      |    16 */    struct timespec {
/*  104      |     8 */        __time_t tv_sec;
/*  112      |     8 */        __syscall_slong_t tv_nsec;

                               /* total size (bytes):   16 */
                           } st_ctim;
/*  120      |    24 */    __syscall_slong_t __glibc_reserved[3];

                           /* total size (bytes):  144 */
                         }

*/

pub fn stat(state: &mut State, args: &[Value]) -> Value {
    let path_addr = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let path_len = state.memory_strlen(&args[0], &Value::Concrete(4096, 0)); // idk
    let path = state.memory_read_string(path_addr, path_len.as_u64().unwrap() as usize);
    let statopt = state.filesystem.stat(&path);
    let statbuf = state.solver.evalcon_to_u64(&args[1]).unwrap();

    if let Some(statdata) = statopt {
        // oof this is just one case, any different bits, arch, or os could be different
        // this definitely sucks.
        state
            .memory
            .write_value(statbuf, &Value::Concrete(statdata.st_dev, 0), 8);
        state
            .memory
            .write_value(statbuf + 8, &Value::Concrete(statdata.st_ino, 0), 8);
        state.memory.write_value(
            statbuf + 16,
            &Value::Concrete(statdata.st_mode as u64, 0),
            8,
        );
        state.memory.write_value(
            statbuf + 24,
            &Value::Concrete(statdata.st_nlink as u64, 0),
            4,
        );
        state
            .memory
            .write_value(statbuf + 28, &Value::Concrete(statdata.st_uid as u64, 0), 4);
        state
            .memory
            .write_value(statbuf + 32, &Value::Concrete(statdata.st_gid as u64, 0), 4);
        state
            .memory
            .write_value(statbuf + 36, &Value::Concrete(statdata.__pad0 as u64, 0), 4);
        state
            .memory
            .write_value(statbuf + 40, &Value::Concrete(statdata.st_rdev, 0), 8);
        state.memory.write_value(
            statbuf + 48,
            &Value::Concrete(statdata.st_size as u64, 0),
            8,
        );
        state.memory.write_value(
            statbuf + 56,
            &Value::Concrete(statdata.st_blksize as u64, 0),
            8,
        );
        //state.memory.write_value(statbuf, &Value::Concrete(statdata.__pad2 as u64, 0), 4);
        state.memory.write_value(
            statbuf + 64,
            &Value::Concrete(statdata.st_blocks as u64, 0),
            8,
        );
        state
            .memory
            .write_value(statbuf + 72, &Value::Concrete(statdata.st_atime, 0), 8);
        state
            .memory
            .write_value(statbuf + 80, &Value::Concrete(statdata.st_atimensec, 0), 8);
        state
            .memory
            .write_value(statbuf + 88, &Value::Concrete(statdata.st_mtime, 0), 8);
        state
            .memory
            .write_value(statbuf + 96, &Value::Concrete(statdata.st_mtimensec, 0), 8);
        state
            .memory
            .write_value(statbuf + 104, &Value::Concrete(statdata.st_ctime, 0), 8);
        state
            .memory
            .write_value(statbuf + 112, &Value::Concrete(statdata.st_ctimensec, 0), 8);
        state.memory.write_value(
            statbuf + 120,
            &Value::Concrete(statdata.__glibc_reserved[0] as u64, 0),
            4,
        );
        state.memory.write_value(
            statbuf + 124,
            &Value::Concrete(statdata.__glibc_reserved[1] as u64, 0),
            4,
        );
        Value::Concrete(0, 0)
    } else {
        Value::Concrete(-1i64 as u64, 0)
    }
}

pub fn fstat(state: &mut State, args: &[Value]) -> Value {
    let fd = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let path = state.filesystem.getpath(fd as usize).unwrap_or_default();
    let path_addr = state.memory.alloc(&Value::Concrete(path.len() as u64, 0));
    state.memory_write_string(path_addr, &path);
    stat(state, &[Value::Concrete(path_addr, 0), args[1].clone()])
}

// TODO handle symbolic links
pub fn lstat(state: &mut State, args: &[Value]) -> Value {
    stat(state, args)
}

pub fn lseek(state: &mut State, args: &[Value]) -> Value {
    let fd = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let pos = state.solver.evalcon_to_u64(&args[1]).unwrap();
    let whence = state.solver.evalcon_to_u64(&args[2]).unwrap();
    let result = state.filesystem.seek(fd as usize, pos as usize, whence as usize);
    result.unwrap_or(Value::Concrete(-1i64 as u64, 0))
}

pub fn error(_state: &mut State, _args: &[Value]) -> Value {
    Value::Concrete(-1i64 as u64, 0)
}

// TODO success dummy
pub fn success(_state: &mut State, _args: &[Value]) -> Value {
    Value::Concrete(0, 0)
}

// TODO fd backed mem
pub fn mmap(state: &mut State, args: &[Value]) -> Value {
    // we can't do symbolic mmaps
    // this is beyond science
    let mut addr = state.solver.evalcon_to_u64(&args[0]).unwrap();
    let size = state.solver.evalcon_to_u64(&args[1]).unwrap();
    let prot = state.solver.evalcon_to_u64(&args[2]).unwrap();

    if addr == 0 {
        addr = state.memory_alloc(&args[1]).as_u64().unwrap();
    }

    let perms = state.memory.prot_to_str(prot);
    state
        .memory
        .add_segment("mmapped", addr, size, perms.as_str());
    Value::Concrete(addr, 0)
}

pub fn munmap(state: &mut State, args: &[Value]) -> Value {
    let addr = state.solver.evalcon_to_u64(&args[0]).unwrap();

    let mut ind = -1i32 as usize;
    for (i, seg) in state.memory.segs.iter().enumerate() {
        if seg.addr == addr {
            ind = i;
            break;
        }
    }

    if ind as i32 != -1 {
        state.memory.segs.remove(ind);
        Value::Concrete(0, 0)
    } else {
        Value::Concrete(-1i64 as u64, 0)
    }
}

pub fn brk(state: &mut State, args: &[Value]) -> Value {
    let addr = state.solver.evalcon_to_u64(&args[0]).unwrap();
    Value::Concrete(state.memory.brk(addr), 0)
}

pub fn sbrk(state: &mut State, args: &[Value]) -> Value {
    let inc = state.solver.evalcon_to_u64(&args[0]).unwrap();
    Value::Concrete(state.memory.sbrk(inc), 0)
}

// returning a symbolic pid+1 | 0 | -1
// will result in a split state when used to branch
// essentially recreating a fork. pretty cool!
pub fn fork(state: &mut State, _args: &[Value]) -> Value {
    let cpid = state.pid + 1;
    state.pid = cpid;
    let pid = state.bv(format!("pid_{}", cpid).as_str(), 64);
    let a = pid
        ._eq(&state.bvv(cpid, 64))
        .or(&pid._eq(&state.bvv(0, 64)))
        .or(&pid._eq(&state.bvv(-1i64 as u64, 64)));

    state.solver.assert_bv(&a);
    Value::Symbolic(pid, 0)
}

pub fn getpid(state: &mut State, _args: &[Value]) -> Value {
    Value::Concrete(state.pid, 0)
}

pub fn getuid(_state: &mut State, _args: &[Value]) -> Value {
    Value::Concrete(0, 0)
}

pub fn ptrace(_state: &mut State, _args: &[Value]) -> Value {
    Value::Concrete(0, 0) // antidebug checks for -1
}

pub fn exit(state: &mut State, args: &[Value]) -> Value {
    state.status = StateStatus::Inactive;
    args[0].to_owned()
}

```

`radius/src/solver.rs`:

```rs
use crate::value::Value;
use boolector::option::{BtorOption, ModelGen, NumberFormat};
use boolector::{Btor, SolverResult, BV};
use std::cmp::Ordering;
use std::sync::Arc;

const EVAL_MAX: usize = 256;

pub type BitVec = BV<Arc<Btor>>;

#[derive(Debug, Clone)]
pub struct Solver {
    pub btor: Arc<Btor>,
    pub assertions: Vec<BitVec>,
    pub indexes: Vec<usize>,
    pub eval_max: usize,
}

impl Default for Solver {
    fn default() -> Self {
        Self::new(EVAL_MAX)
    }
}

impl Solver {
    pub fn new(eval_max: usize) -> Self {
        let btor = Arc::new(Btor::new());
        //btor.set_opt(BtorOption::SatEngine(SatEngine::CaDiCaL));
        btor.set_opt(BtorOption::ModelGen(ModelGen::Disabled));
        btor.set_opt(BtorOption::Incremental(true));
        btor.set_opt(BtorOption::OutputNumberFormat(NumberFormat::Hexadecimal));
        //btor.set_opt(BtorOption::PrettyPrint(false));

        Solver {
            btor,
            assertions: Vec::with_capacity(256),
            indexes: Vec::with_capacity(256),
            eval_max,
        }
    }

    pub fn duplicate(&self) -> Self {
        let btor = Arc::new(self.btor.duplicate());

        let mut solver = Solver {
            btor,
            assertions: Vec::with_capacity(256),
            indexes: self.indexes.clone(),
            eval_max: self.eval_max,
        };

        solver.assertions = self
            .assertions
            .iter()
            .map(|a| solver.translate(a).unwrap())
            .collect();

        solver
    }

    pub fn apply_assertions(&self) {
        for assertion in &self.assertions {
            assertion.assert();
        }
    }

    #[inline]
    pub fn bv(&self, s: &str, n: u32) -> BitVec {
        // check if it already exists
        BV::new(self.btor.clone(), n, Some(s))
    }

    #[inline]
    pub fn bvv(&self, v: u64, n: u32) -> BitVec {
        if n <= 64 {
            // boolector sign extends. even though its u64...
            // what the fuck
            BV::from_u64(self.btor.clone(), v, n)
        } else {
            BV::from_u64(self.btor.clone(), v, 64).uext(n - 64)
        }
    }

    pub fn translate(&self, bv: &BitVec) -> Option<BitVec> {
        Btor::get_matching_bv(self.btor.clone(), bv)
    }

    pub fn translate_value(&self, value: &Value) -> Value {
        match value {
            Value::Concrete(val, t) => Value::Concrete(*val, *t),
            Value::Symbolic(val, t) => Value::Symbolic(self.translate(val).unwrap(), *t),
        }
    }

    pub fn to_bv(&self, value: &Value, length: u32) -> BitVec {
        match value {
            Value::Concrete(val, _t) => self.bvv(*val, length),
            Value::Symbolic(val, _t) => {
                //let new_val = self.translate(val).unwrap();
                let szdiff = val.get_width() as i32 - length as i32;
                match szdiff.cmp(&0) {
                    Ordering::Equal => val.to_owned(),
                    Ordering::Greater => val.slice(length - 1, 0),
                    Ordering::Less => val.uext((-szdiff) as u32),
                }
            }
        }
    }

    pub fn to_sym(&self, value: &Value, length: u32) -> Value {
        Value::Symbolic(self.to_bv(value, length), value.get_taint())
    }

    pub fn conditional(&self, cond: &Value, if_val: &Value, else_val: &Value) -> Value {
        let mut max_bit = 1;
        if if_val.is_symbolic() || else_val.is_symbolic() {
            if let Value::Symbolic(ifv, _) = if_val {
                max_bit = ifv.get_width();
            }

            if let Value::Symbolic(elv, _) = else_val {
                if elv.get_width() > max_bit {
                    max_bit = elv.get_width()
                }
            }
        } else {
            // add exception for if(c, y, y) for concrete y
            if let Some(x) = if_val.as_u64() {
                if let Some(y) = else_val.as_u64() {
                    if x == y {
                        return Value::Concrete(
                            if_val.as_u64().unwrap(),
                            if_val.get_taint() | else_val.get_taint(),
                        );
                    }
                }
            }
            max_bit = 64;
        }

        match cond {
            Value::Concrete(val, t) => {
                if *val != 0 {
                    if_val.with_taint(*t)
                } else {
                    else_val.with_taint(*t)
                }
            }
            Value::Symbolic(val, t) => {
                let taint = if_val.get_taint() | else_val.get_taint();
                Value::Symbolic(
                    val.slice(0, 0)
                        .cond_bv(&self.to_bv(if_val, max_bit), &self.to_bv(else_val, max_bit)),
                    taint | t,
                )
            }
        }
    }

    pub fn enable_model(&self, b: bool) {
        if b {
            self.btor.set_opt(BtorOption::ModelGen(ModelGen::All));
        } else {
            self.btor.set_opt(BtorOption::ModelGen(ModelGen::Disabled));
        }
    }

    pub fn evaluate(&self, bv: &BitVec) -> Option<Value> {
        self.enable_model(true);

        self.btor.push(1);
        self.apply_assertions();
        //let new_bv = self.translate(bv).unwrap();
        let sol = if self.btor.sat() == SolverResult::Sat {
            Some(Value::Concrete(bv.get_a_solution().as_u64().unwrap(), 0))
        } else {
            None
        };
        self.btor.pop(1);

        self.enable_model(false);

        sol
    }

    pub fn eval(&self, value: &Value) -> Option<Value> {
        match value {
            Value::Concrete(val, t) => Some(Value::Concrete(*val, *t)),
            Value::Symbolic(bv, t) => {
                self.enable_model(true);

                self.btor.push(1);
                self.apply_assertions();
                //let new_bv = self.translate(bv).unwrap();
                let sol = if self.btor.sat() == SolverResult::Sat {
                    Some(Value::Concrete(bv.get_a_solution().as_u64().unwrap(), *t))
                } else {
                    None
                };
                self.btor.pop(1);

                self.enable_model(false);

                sol
            }
        }
    }

    pub fn eval_to_u64(&self, value: &Value) -> Option<u64> {
        if let Some(Value::Concrete(val, _t)) = self.eval(value) {
            Some(val)
        } else {
            None
        }
    }

    pub fn eval_to_bv(&mut self, value: &Value) -> Option<BitVec> {
        match value {
            Value::Concrete(val, _t) => Some(self.bvv(*val, 64)),
            Value::Symbolic(bv, _t) => {
                self.enable_model(true);

                self.btor.push(1);
                self.apply_assertions();
                //let new_bv = self.translate(bv).unwrap();
                let sol_bv = if self.btor.sat() == SolverResult::Sat {
                    let sol = bv.get_a_solution().disambiguate();
                    let bv_str = sol.as_01x_str();
                    Some(BV::from_binary_str(self.btor.clone(), bv_str))
                } else {
                    None
                };
                self.btor.pop(1);
                self.enable_model(false);

                sol_bv
            }
        }
    }

    pub fn evalcon_to_u64(&mut self, value: &Value) -> Option<u64> {
        match value {
            Value::Concrete(val, _t) => Some(*val),
            Value::Symbolic(bv, _t) => self.evalcon(bv),
        }
    }

    #[inline]
    pub fn push(&mut self) {
        self.indexes.push(self.assertions.len());
        self.btor.push(1)
    }

    #[inline]
    pub fn pop(&mut self) {
        self.btor.pop(1);
        let index = self.indexes.pop().unwrap();
        self.assertions = self.assertions[..index].to_owned();
    }

    #[inline]
    pub fn reset(&mut self) {
        // uhhh this might work?
        self.assertions.clear();
        self.indexes.clear();
    }

    // evaluate and constrain the symbol to the value
    pub fn evalcon(&mut self, lbv: &BitVec) -> Option<u64> {
        // TODO this is a stupid fix to 128 bit float reg evalcon-ing
        // all of this code needs to be reorganized around Values instead of
        // returning u64s, except for circumstances explicitly involving addresses
        let bv = if lbv.get_width() <= 64 {
            lbv.to_owned()
        } else {
            lbv.slice(63, 0)
        };

        self.enable_model(true);
        self.btor.push(1);
        self.apply_assertions();
        //let new_bv = self.translate(bv).unwrap();
        let sol = if self.btor.sat() == SolverResult::Sat {
            let conval = bv.get_a_solution().as_u64().unwrap();
            let assertion = bv._eq(&self.bvv(conval, bv.get_width()));
            self.assert_bv(&assertion);
            Some(conval)
        } else {
            None
        };
        self.btor.pop(1);
        self.enable_model(false);
        sol
    }

    pub fn assert_in(&mut self, bv: &BitVec, values: &[u64]) {
        let mut cond = self.bvv(1, 1);
        for val in values {
            let nbv = self.bvv(*val, 64);
            cond = cond.or(&bv._eq(&nbv));
        }
        self.assert_bv(&cond);
    }

    #[inline]
    pub fn assert_bv(&mut self, bv: &BitVec) {
        self.assertions.push(bv.to_owned());
    }

    #[inline]
    pub fn assert(&mut self, value: &Value) {
        self.assertions
            .push(self.to_bv(&!value.eq(&Value::Concrete(0, 0)), 1));
    }

    #[inline]
    pub fn is_sat(&self) -> bool {
        if self.assertions.is_empty() {
            true
        } else {
            self.btor.push(1);
            self.apply_assertions();
            let sat = self.btor.sat() == SolverResult::Sat;
            self.btor.pop(1);
            sat
        }
    }

    /// check the satisfiability of the assertion
    #[inline]
    pub fn check_sat(&mut self, assertion: &Value) -> bool {
        match assertion {
            Value::Concrete(v, _t) => *v != 0,
            Value::Symbolic(_v, _t) => {
                self.btor.push(1);
                self.assert(assertion);
                self.apply_assertions();
                let sat = self.btor.sat() == SolverResult::Sat;
                self.assertions.pop();
                self.btor.pop(1);
                sat
            }
        }
    }

    pub fn evaluate_many(&mut self, bv: &BitVec) -> Vec<u64> {
        self.enable_model(true);
        let mut solutions: Vec<u64> = Vec::with_capacity(self.eval_max);
        //let new_bv = self.translate(bv).unwrap();
        self.btor.push(1);
        self.apply_assertions();
        for _i in 0..self.eval_max {
            if self.btor.sat() == SolverResult::Sat {
                let solopt = bv.get_a_solution().as_u64();
                if let Some(sol) = solopt {
                    solutions.push(sol);
                    let sol_bv = BV::from_u64(self.btor.clone(), sol, bv.get_width());

                    bv._eq(&sol_bv).not().assert();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        self.btor.pop(1);

        if solutions.len() == self.eval_max {
            // if there are more possibilities than EVAL_MAX
            // constrain it to be in the eval subset
            self.assert_in(bv, &solutions);
        }
        self.enable_model(false);
        solutions
    }

    pub fn solution(&self, bv: &BitVec) -> Option<String> {
        self.enable_model(true);

        self.btor.push(1);
        self.apply_assertions();
        let sol = if self.btor.sat() == SolverResult::Sat {
            let solution = bv.get_a_solution().disambiguate();
            let sol_str = solution.as_01x_str();
            Some(sol_str.to_string())
        } else {
            None
        };
        self.btor.pop(1);
        self.enable_model(false);
        sol
    }

    // workaround for dumb temp file issue on termux
    pub fn hex_solution(&self, bv: &BitVec) -> Option<String> {
        if let Some(bin) = self.solution(bv) {
            let mut hex = "".to_owned();
            for i in 0..bin.len() / 8 {
                //
                let byte = u64::from_str_radix(&bin[8 * i..8 * (i + 1)], 2);
                hex += &format!("{:02x}", byte.unwrap_or_default());
            }
            Some(hex)
        } else {
            None
        }
    }

    pub fn and_all(&self, bvs: &[BitVec]) -> BitVec {
        let mut bv = BV::from_bool(self.btor.clone(), true);
        for next_bv in bvs {
            bv = bv.and(next_bv);
        }
        bv
    }

    // this should just be called "any"
    pub fn or_all(&self, bvs: &[BitVec]) -> BitVec {
        let mut bv = BV::from_bool(self.btor.clone(), false);
        for next_bv in bvs {
            bv = bv.or(next_bv);
        }
        bv
    }

    // surprisingly fast binary search to max
    pub fn max(&self, bv: &BitVec) -> u64 {
        self.btor.push(1);
        self.apply_assertions();

        let len = bv.get_width();
        let mut low = 0;
        let mut high = 1 << (len - 1);

        while high != low {
            bv.ugte(&self.bvv(high, len)).assume();
            while self.btor.sat() != SolverResult::Sat && high != low {
                high = low + (high - low) / 2;
                bv.ugte(&self.bvv(high, len)).assume();
            }

            let tmp = high;
            high = high + (high - low) / 2;
            low = tmp;
        }
        self.btor.pop(1);

        low
    }

    pub fn min(&self, bv: &BitVec) -> u64 {
        self.btor.push(1);
        self.apply_assertions();

        let len = bv.get_width();
        let mut low = 0;
        let mut high = 1 << (len - 1);

        while high != low {
            bv.ult(&self.bvv(high, len)).assume();
            while self.btor.sat() == SolverResult::Sat && high != low {
                high = low + (high - low) / 2;
                bv.ult(&self.bvv(high, len)).assume();
            }

            let tmp = high;
            high = high + (high - low) / 2;
            low = tmp;
        }
        self.btor.pop(1);
        low
    }

    pub fn max_value(&self, value: &Value) -> u64 {
        match value {
            Value::Concrete(val, _t) => *val,
            Value::Symbolic(val, _t) => self.max(val),
        }
    }

    pub fn min_value(&self, value: &Value) -> u64 {
        match value {
            Value::Concrete(val, _t) => *val,
            Value::Symbolic(val, _t) => self.min(val),
        }
    }
}

```

`radius/src/state.rs`:

```rs
use crate::memory::{Memory, READ_CACHE};
use crate::r2_api::{Endian, Information, R2Api};
use crate::registers::Registers;
use crate::sims::fs::SimFilesytem;
use crate::solver::{BitVec, Solver};
use crate::value::{byte_values, vc, Value};

use std::cmp::Ordering;
use std::collections::{HashMap, HashSet};
use std::rc::Rc;
use std::u8;

// event hooks could be a performance issue at some point
// prolly not now cuz there are 10000 slower things
// but also i hate the code for them and want to remove it
pub const DO_EVENT_HOOKS: bool = false;

#[derive(Debug, Clone, PartialEq, Hash, Eq)]
pub enum EventTrigger {
    Before, // call hook before event occurs
    After,  // call hook after
}

#[derive(Debug, Clone, PartialEq, Hash, Eq)]
pub enum Event {
    SymbolicRead(EventTrigger),    // read from symbolic address
    SymbolicWrite(EventTrigger),   // write to symbolic address
    SymbolicExec(EventTrigger),    // execute symbolic address
    Alloc(EventTrigger),           // allocate memory
    SymbolicAlloc(EventTrigger),   // allocate symbolic length
    Free(EventTrigger),            // free memory
    SymbolicFree(EventTrigger),    // free symbolic address
    Search(EventTrigger),          // mem search (strchr, memmem)
    SymbolicSearch(EventTrigger),  // search with symbolic addr, needle, or length
    Compare(EventTrigger),         // compare memory (memcmp, strcmp)
    SymbolicCompare(EventTrigger), // symbolic compare
    StringLength(EventTrigger),    // string length check (strlen)
    SymbolicStrlen(EventTrigger),  // strlen of symbolic address
    Move(EventTrigger),            // move bytes from src to dst (memcpy, memmove)
    SymbolicMove(EventTrigger),    // symbolic move (memcpy, memmove)
    All(EventTrigger),             // gotta hook em all, ra! - di! - us!
}

#[derive(Debug, Clone, PartialEq)]
pub enum EventContext {
    ReadContext(Value, Value),
    WriteContext(Value, Value),
    ExecContext(Value, Vec<u64>),
    AllocContext(Value),
    FreeContext(Value),
    SearchContext(Value, Value, Value),
    CompareContext(Value, Value, Value),
    StrlenContext(Value, Value),
    MoveContext(Value, Value, Value),
}

pub type EventHook = dyn Fn(&mut State, &EventContext);

#[derive(Debug, Clone, PartialEq)]
pub enum ExecMode {
    If,     // in a symbolic if clause ?{,...,}
    Else,   // in a symbolic else clause ?{,---,}{,...,}
    Exec,   // in a clause that is always executed 1,?{,...,}
    NoExec, // in a clause that is never executed 0,?{,...,}
    Uncon,  // not in an if or else, regular parsing
}

#[derive(Debug, Clone)]
pub struct EsilState {
    pub mode: ExecMode,
    pub prev_pc: Value,
    pub previous: Value,
    pub current: Value,
    pub last_sz: usize,
    pub stored_address: Option<Value>,
    pub temp1: Vec<StackItem>,
    pub temp2: Vec<StackItem>,
    pub pcs: Vec<u64>,
}

#[derive(Debug, Clone)]
pub enum StackItem {
    StackRegister(usize),
    StackValue(Value),
}

impl Default for StackItem {
    fn default() -> Self {
        StackItem::StackValue(Value::Concrete(0, 0))
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum StateStatus {
    Active,
    Break,
    Merge,
    PostMerge, // so we dont get caught in merge loop
    Unsat,
    Inactive,
    Crash(u64, char),
    Exit,
}

/// A program state, including memory, registers, and solver data
#[derive(Clone)]
pub struct State {
    pub solver: Solver,
    pub r2api: R2Api,
    pub info: Information,
    pub stack: Vec<StackItem>,
    pub esil: EsilState,
    pub condition: Option<BitVec>,
    pub registers: Registers,
    pub memory: Memory,
    pub filesystem: SimFilesytem,
    pub status: StateStatus,
    pub context: HashMap<String, Vec<Value>>,
    pub taints: HashMap<String, u64>,
    pub hooks: HashMap<Event, Rc<EventHook>>,
    pub visits: HashMap<u64, usize>,
    pub pid: u64,
    pub backtrace: Vec<(u64, u64)>,
    pub blank: bool,
    pub debug: bool,
    pub check: bool,
    pub strict: bool,
    pub has_event_hooks: bool,
}

// state equality is based on PC visit count
// in order to use a priority queue to manage states
impl PartialEq for State {
    fn eq(&self, other: &Self) -> bool {
        other.get_visit() == self.get_visit()
    }
}

impl Eq for State {}

impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        other.get_visit().cmp(&self.get_visit())
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl State {
    /// Create a new state, should generally not be called directly
    pub fn new(
        r2api: &mut R2Api,
        eval_max: usize,
        debug: bool,
        blank: bool,
        check: bool,
        strict: bool,
    ) -> Self {
        let esil_state = EsilState {
            mode: ExecMode::Uncon,
            prev_pc: Value::Concrete(0, 0),
            previous: Value::Concrete(0, 0),
            current: Value::Concrete(0, 0),
            last_sz: 64,
            stored_address: None,
            temp1: vec![], // these instances are actually not used
            temp2: vec![],
            pcs: Vec::with_capacity(64),
        };

        let solver = Solver::new(eval_max);
        let registers = Registers::new(r2api, solver.clone(), blank);
        let memory = Memory::new(r2api, solver.clone(), blank);

        State {
            solver,
            r2api: r2api.clone(),
            info: r2api.info.clone(),
            stack: Vec::with_capacity(128),
            esil: esil_state,
            condition: None,
            registers,
            memory,
            filesystem: SimFilesytem::new(),
            status: StateStatus::Active,
            context: HashMap::new(),
            taints: HashMap::new(),
            hooks: HashMap::new(),
            visits: HashMap::with_capacity(512),
            backtrace: Vec::with_capacity(128),
            pid: 1337, // sup3rh4x0r
            blank,
            debug,
            check,
            strict,
            has_event_hooks: false,
        }
    }

    /// duplicate state is different from clone as it creates
    /// a duplicate solver instead of another reference to the old one
    pub fn duplicate(&mut self) -> Self {
        let solver = self.solver.duplicate();

        let mut registers = self.registers.clone();
        registers.solver = solver.clone();
        registers.values = registers
            .values
            .iter()
            .map(|r| solver.translate_value(r))
            .collect();

        let mut memory = self.memory.clone();
        memory.solver = solver.clone();

        let addrs = memory.addresses();
        for addr in addrs {
            let values = memory.mem.remove(&addr).unwrap();
            memory.mem.insert(
                addr,
                values.iter().map(|v| solver.translate_value(&v)).collect(),
            );
        }

        let mut context = HashMap::new();
        for key in self.context.keys() {
            let values = self.context.get(key).unwrap();
            let new_values = values.iter().map(|v| solver.translate_value(v)).collect();

            context.insert(key.to_owned(), new_values);
        }

        let mut filesystem = self.filesystem.clone();
        for f in &mut filesystem.files {
            let content = f.content.clone();
            f.content = content.iter().map(|v| solver.translate_value(v)).collect();
        }

        let esil_state = EsilState {
            mode: ExecMode::Uncon,
            prev_pc: self.esil.prev_pc.clone(),
            previous: vc(0),
            current: vc(0),
            last_sz: 64,
            stored_address: None,
            temp1: Vec::with_capacity(128),
            temp2: Vec::with_capacity(128),
            pcs: Vec::with_capacity(64),
        };

        State {
            solver,
            r2api: self.r2api.clone(),
            info: self.info.clone(),
            stack: Vec::with_capacity(128),
            esil: esil_state,
            condition: None,
            registers,
            memory,
            filesystem,
            status: self.status.clone(),
            context,
            taints: self.taints.clone(),
            hooks: self.hooks.clone(),
            visits: self.visits.clone(),
            backtrace: self.backtrace.clone(),
            pid: self.pid,
            blank: self.blank,
            debug: self.debug,
            check: self.check,
            strict: self.strict,
            has_event_hooks: self.has_event_hooks,
        }
    }

    pub fn hook_event(&mut self, event: Event, hook: Rc<EventHook>) {
        self.has_event_hooks = true;
        self.hooks.insert(event, hook);
    }

    pub fn do_hooked(&mut self, event: &Event, event_context: &EventContext) {
        if !self.hooks.contains_key(event) {
            return;
        }
        let hook = self.hooks.get(event).unwrap().clone();
        hook(self, event_context)
    }

    /// Allocate a block of memory `length` bytes in size
    pub fn memory_alloc(&mut self, length: &Value) -> Value {
        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if length.is_symbolic() {
                Event::SymbolicAlloc(EventTrigger::Before)
            } else {
                Event::Alloc(EventTrigger::Before)
            };
            self.do_hooked(&event, &EventContext::AllocContext(length.to_owned()));
        }

        let ret = self.memory.alloc_sym(length, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if length.is_symbolic() {
                Event::SymbolicAlloc(EventTrigger::After)
            } else {
                Event::Alloc(EventTrigger::After)
            };
            self.do_hooked(&event, &EventContext::AllocContext(length.to_owned()));
        }

        ret
    }

    /// Free a block of memory at `addr`
    pub fn memory_free(&mut self, addr: &Value) -> Value {
        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if addr.is_symbolic() {
                Event::SymbolicFree(EventTrigger::Before)
            } else {
                Event::Free(EventTrigger::Before)
            };
            self.do_hooked(&event, &EventContext::FreeContext(addr.to_owned()));
        }

        if self.check && self.check_crash(addr, &vc(1), 'r') {
            return vc(-1i64 as u64);
        }

        let ret = self.memory.free_sym(addr, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if addr.is_symbolic() {
                Event::SymbolicFree(EventTrigger::After)
            } else {
                Event::Free(EventTrigger::After)
            };
            self.do_hooked(&event, &EventContext::FreeContext(addr.to_owned()));
        }

        ret
    }

    /// Read `length` bytes from `address`
    pub fn memory_read(&mut self, address: &Value, length: &Value) -> Vec<Value> {
        if DO_EVENT_HOOKS && self.has_event_hooks && (address.is_symbolic() || length.is_symbolic())
        {
            self.do_hooked(
                &Event::SymbolicRead(EventTrigger::Before),
                &EventContext::ReadContext(address.to_owned(), length.to_owned()),
            );
        }

        if self.check && self.check_crash(address, length, 'r') {
            return vec![];
        }

        let ret = self.memory.read_sym_len(address, length, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks && (address.is_symbolic() || length.is_symbolic())
        {
            self.do_hooked(
                &Event::SymbolicRead(EventTrigger::After),
                &EventContext::ReadContext(address.to_owned(), length.to_owned()),
            );
        }

        ret
    }

    /// Write `length` bytes to `address`
    pub fn memory_write(&mut self, address: &Value, values: &[Value], length: &Value) {
        if DO_EVENT_HOOKS && self.has_event_hooks && (address.is_symbolic() || length.is_symbolic())
        {
            self.do_hooked(
                &Event::SymbolicWrite(EventTrigger::Before),
                &EventContext::WriteContext(address.to_owned(), length.to_owned()),
            );
        }

        if self.check && self.check_crash(address, length, 'r') {
            return;
        }
        let ret = self
            .memory
            .write_sym_len(address, values, length, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks && (address.is_symbolic() || length.is_symbolic())
        {
            self.do_hooked(
                &Event::SymbolicWrite(EventTrigger::After),
                &EventContext::WriteContext(address.to_owned(), length.to_owned()),
            );
        }

        ret
    }

    /// Read `length` byte `value` from `address`
    #[inline]
    pub fn memory_read_value(&mut self, address: &Value, length: usize) -> Value {
        if DO_EVENT_HOOKS && self.has_event_hooks && address.is_symbolic() {
            self.do_hooked(
                &Event::SymbolicRead(EventTrigger::Before),
                &EventContext::ReadContext(address.to_owned(), Value::Concrete(length as u64, 0)),
            );
        }

        if self.check && self.check_crash(address, &vc(length as u64), 'r') {
            return vc(-1i64 as u64);
        }

        let ret = self.memory.read_sym(address, length, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks && address.is_symbolic() {
            self.do_hooked(
                &Event::SymbolicRead(EventTrigger::After),
                &EventContext::ReadContext(address.to_owned(), Value::Concrete(length as u64, 0)),
            );
        }

        ret
    }

    /// Write `length` byte `value` to `address`
    #[inline]
    pub fn memory_write_value(&mut self, address: &Value, value: &Value, length: usize) {
        if DO_EVENT_HOOKS && self.has_event_hooks && address.is_symbolic() {
            self.do_hooked(
                &Event::SymbolicRead(EventTrigger::Before),
                &EventContext::ReadContext(address.to_owned(), Value::Concrete(length as u64, 0)),
            );
        }

        if self.check && self.check_crash(address, &vc(length as u64), 'w') {
            return;
        }

        let ret = self
            .memory
            .write_sym(address, value, length, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks && address.is_symbolic() {
            self.do_hooked(
                &Event::SymbolicWrite(EventTrigger::After),
                &EventContext::WriteContext(address.to_owned(), Value::Concrete(length as u64, 0)),
            );
        }

        ret
    }

    /// Search for `needle` at the address `addr` for a maximum of `length` bytes
    /// Returns a `Value` containing the **address** of the needle, not index
    pub fn memory_search(
        &mut self,
        addr: &Value,
        needle: &Value,
        length: &Value,
        reverse: bool,
    ) -> Value {
        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if addr.is_symbolic() || length.is_symbolic() {
                Event::SymbolicSearch(EventTrigger::Before)
            } else {
                Event::Search(EventTrigger::Before)
            };
            self.do_hooked(
                &event,
                &EventContext::SearchContext(addr.to_owned(), needle.to_owned(), length.to_owned()),
            );
        }

        if self.check && self.check_crash(addr, &vc(1), 'r') {
            return vc(-1i64 as u64);
        }

        let ret = self
            .memory
            .search(addr, needle, length, reverse, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if addr.is_symbolic() || length.is_symbolic() {
                Event::SymbolicSearch(EventTrigger::After)
            } else {
                Event::Search(EventTrigger::After)
            };
            self.do_hooked(
                &event,
                &EventContext::SearchContext(addr.to_owned(), needle.to_owned(), length.to_owned()),
            );
        }

        ret
    }

    /// Compare memory at `dst` and `src` address up to `length` bytes.
    /// This is akin to memcmp but will handle symbolic addrs and length
    pub fn memory_compare(&mut self, dst: &Value, src: &Value, length: &Value) -> Value {
        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if dst.is_symbolic() || src.is_symbolic() || length.is_symbolic() {
                Event::SymbolicCompare(EventTrigger::Before)
            } else {
                Event::Compare(EventTrigger::Before)
            };
            self.do_hooked(
                &event,
                &EventContext::CompareContext(dst.to_owned(), src.to_owned(), length.to_owned()),
            );
        }

        if self.check && (self.check_crash(src, &vc(1), 'r') || self.check_crash(dst, &vc(1), 'r'))
        {
            return vc(-1i64 as u64);
        }

        let ret = self.memory.compare(dst, src, length, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if dst.is_symbolic() || src.is_symbolic() || length.is_symbolic() {
                Event::SymbolicCompare(EventTrigger::After)
            } else {
                Event::Compare(EventTrigger::After)
            };
            self.do_hooked(
                &event,
                &EventContext::CompareContext(dst.to_owned(), src.to_owned(), length.to_owned()),
            );
        }

        ret
    }

    /// Get the length of the null terminated string at `addr`
    pub fn memory_strlen(&mut self, addr: &Value, length: &Value) -> Value {
        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if addr.is_symbolic() || length.is_symbolic() {
                Event::SymbolicStrlen(EventTrigger::Before)
            } else {
                Event::StringLength(EventTrigger::Before)
            };
            self.do_hooked(
                &event,
                &EventContext::StrlenContext(addr.to_owned(), length.to_owned()),
            );
        }

        // eh don't use the length here
        if self.check && self.check_crash(addr, &vc(1), 'r') {
            return vc(-1i64 as u64);
        }

        let ret = self.memory.strlen(addr, length, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if addr.is_symbolic() || length.is_symbolic() {
                Event::SymbolicStrlen(EventTrigger::After)
            } else {
                Event::StringLength(EventTrigger::After)
            };
            self.do_hooked(
                &event,
                &EventContext::StrlenContext(addr.to_owned(), length.to_owned()),
            );
        }

        ret
    }

    /// Move `length` bytes from `src` to `dst`
    pub fn memory_move(&mut self, dst: &Value, src: &Value, length: &Value) {
        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if dst.is_symbolic() || src.is_symbolic() || length.is_symbolic() {
                Event::SymbolicMove(EventTrigger::Before)
            } else {
                Event::Move(EventTrigger::Before)
            };
            self.do_hooked(
                &event,
                &EventContext::MoveContext(dst.to_owned(), src.to_owned(), length.to_owned()),
            );
        }

        if self.check && (self.check_crash(src, length, 'r') || self.check_crash(dst, length, 'w'))
        {
            return;
        }

        self.memory.memmove(dst, src, length, &mut self.solver);

        if DO_EVENT_HOOKS && self.has_event_hooks {
            let event = if dst.is_symbolic() || src.is_symbolic() || length.is_symbolic() {
                Event::SymbolicMove(EventTrigger::After)
            } else {
                Event::Move(EventTrigger::After)
            };
            self.do_hooked(
                &event,
                &EventContext::MoveContext(dst.to_owned(), src.to_owned(), length.to_owned()),
            );
        }
    }

    /// Read pointer from `address`
    pub fn memory_read_ptr(&mut self, address: &Value) -> Value {
        let ptr_len = self.memory.bits as usize / 8;
        self.memory_read_value(address, ptr_len)
    }

    /// Write pointer `value` to `address`
    pub fn memory_write_ptr(&mut self, address: &Value, value: &Value) {
        let ptr_len = self.memory.bits as usize / 8;
        self.memory_write_value(address, value, ptr_len)
    }

    /// Read `length` bytes from `address`
    pub fn memory_read_bytes(&mut self, address: u64, length: usize) -> Vec<u8> {
        self.memory.read_bytes(address, length, &mut self.solver)
    }

    /// Read a string from `address` up to `length` bytes long
    pub fn memory_read_string(&mut self, address: u64, length: usize) -> String {
        self.memory.read_string(address, length, &mut self.solver)
    }

    /// Read a concrete c string from `address`
    pub fn memory_read_cstring(&mut self, address: u64) -> String {
        let length = self.memory_strlen(&vc(address), &vc(4096));
        let len = self.solver.evalcon_to_u64(&length).unwrap_or(0);
        self.memory
            .read_string(address, len as usize, &mut self.solver)
    }

    // this doesnt need to be here, just for consistency sake
    /// Write `string` to `address`
    pub fn memory_write_string(&mut self, address: u64, string: &str) {
        self.memory.write_string(address, string)
    }

    /// pack bytes into a single `Value`
    pub fn pack(&self, data: &[Value]) -> Value {
        self.memory.pack(data)
    }

    /// unpack `Value` into vector of bytes
    pub fn unpack(&self, data: &Value, length: usize) -> Vec<Value> {
        let mut values = vec![Value::Concrete(0, 0); length];
        self.memory.unpack(data, length, &mut values);
        values
    }

    pub fn fill_file(&mut self, fd: usize, data: &[Value]) {
        self.filesystem.fill(fd, data)
    }

    pub fn fill_file_string(&mut self, fd: usize, string: &str) {
        let data = byte_values(string);
        self.filesystem.fill(fd, &data)
    }

    pub fn dump_path(&mut self, path: &str) -> Vec<Value> {
        if let Some(fd) = self.filesystem.getfd(path) {
            self.filesystem.dump(fd)
        } else {
            vec![]
        }
    }

    pub fn dump_file(&mut self, fd: usize) -> Vec<Value> {
        self.filesystem.dump(fd)
    }

    pub fn dump_file_bytes(&mut self, fd: usize) -> Vec<u8> {
        let values = self.filesystem.dump(fd);
        let bytes = values
            .iter()
            .map(|v| self.solver.evalcon_to_u64(v).unwrap_or(0) as u8)
            .collect();

        bytes
    }

    pub fn dump_file_string(&mut self, fd: usize) -> Option<String> {
        String::from_utf8(self.dump_file_bytes(fd)).ok()
    }

    /// Apply this state to the radare2 instance. This writes all the values
    /// in the states memory back to the memory in r2 as well as the register
    /// values, evaluating any symbolic expressions.
    pub fn apply(&mut self) {
        let mut inds = Vec::with_capacity(256);
        for reg in &self.registers.indexes {
            if !inds.contains(&reg.value_index) {
                inds.push(reg.value_index);
                let rval = self.registers.values[reg.value_index].to_owned();
                let r = self.solver.evalcon_to_u64(&rval).unwrap();
                self.r2api.set_register_value(&reg.reg_info.name, r);
            }
        }

        let mut bvals = vec![Value::Concrete(0, 0); READ_CACHE];
        for addr in self.memory.addresses() {
            self.memory.read(addr, READ_CACHE, &mut bvals);
            let bytes: Vec<u8> = bvals
                .iter()
                .map(|bval| self.solver.evalcon_to_u64(&bval).unwrap() as u8)
                .collect();

            self.r2api.write(addr, bytes.clone());
        }

        // TODO: evaluate files and write to real FS? maybe a bad idea
    }

    /// Merges `state` into self
    pub fn merge(&mut self, state: &mut State) {
        let state_asserts = &state.solver.assertions;
        let assertion = state.solver.and_all(state_asserts);
        let asserted = Value::Symbolic(assertion, 0);

        // merge registers
        let reg_count = state.registers.values.len();
        for index in 0..reg_count {
            let reg = &self.registers.values[index];
            let curr_reg = &state.registers.values[index];
            //new_regs.push(state.solver.conditional(&asserted, curr_reg, reg));
            self.registers.values[index] = state.solver.conditional(&asserted, curr_reg, reg);
        }

        // merge memory
        //let mut new_mem = HashMap::with_capacity(1024);

        let merge_addrs = self.memory.addresses();
        let state_addrs = state.memory.addresses();

        let mut addrs = HashSet::with_capacity(READ_CACHE);
        addrs.extend(merge_addrs);
        addrs.extend(state_addrs);

        let mut tmp1 = Vec::with_capacity(READ_CACHE);
        let mut tmp2 = Vec::with_capacity(READ_CACHE);

        for addr in addrs {
            let newvec = if let Some(m) = self.memory.mem.get_mut(&addr) {
                m
            } else {
                self.memory.read(addr, READ_CACHE, &mut tmp1);
                &mut tmp1
            };
            let curvec = if let Some(m) = state.memory.mem.get(&addr) {
                m
            } else {
                state.memory.read(addr, READ_CACHE, &mut tmp2);
                &tmp2
            };

            for i in 0..READ_CACHE {
                if newvec.len() > i && curvec.len() > i {   
                    newvec[i] = state.cond(&asserted, &curvec[i], &newvec[i]);
                }
            }
        }

        // merge context
        for (k, v) in &state.context {
            for i in 0..v.len() {
                if let Some(nv) = self.context.get_mut(k) {
                    if i < nv.len() {
                        nv[i] = state.cond(&asserted, &v[i], &nv[i]);
                    } else {
                        nv.push(state.cond(&asserted, &v[i], &vc(0)))
                    }
                }
            }
        }

        // merge filesystem
        for file in &state.filesystem.files {
            for cfile in &mut self.filesystem.files {
                if file.path == cfile.path {
                    let mlen = if file.content.len() > cfile.content.len() { 
                        file.content.len()
                    } else {
                        cfile.content.len()
                    };
                    for i in 0..mlen {
                        let space = vc(0x20); // fill overflow with spaces, uhhh cuz
                        let v = file.content.get(i).unwrap_or(&space);
                        let cv = cfile.content.get(i).unwrap_or(&space);
                        if i < cfile.content.len() {
                            cfile.content[i] = state.cond(&asserted, &v, &cv);
                        } else {
                            cfile.content.push(state.cond(&asserted, &v, &cv));
                        }
                    }
                }
            }
        }

        // merge solvers
        let assertions = &self.solver.assertions;
        let current = state.solver.and_all(assertions);
        self.solver.reset();
        self.assert_bv(&current.or(&asserted.as_bv().unwrap()));
    }

    /// Use the constraints from the provided state. This is
    /// useful for constraining the data in some initial
    /// state with the assertions of some desired final state
    pub fn constrain_with_state(&mut self, state: &Self) {
        self.solver = state.solver.clone();
    }

    /// Create a bitvector from this states solver
    pub fn bv(&self, s: &str, n: u32) -> BitVec {
        self.solver.bv(s, n)
    }

    /// Create a bitvector value from this states solver
    pub fn bvv(&self, v: u64, n: u32) -> BitVec {
        self.solver.bvv(v, n)
    }

    /// Create a `Value::Concrete` from a value `v` and bit width `n`
    pub fn concrete_value(&self, v: u64, n: u32) -> Value {
        let mask = if n < 64 { (1 << n) - 1 } else { -1i64 as u64 };
        Value::Concrete(v & mask, 0)
    }

    /// Create a `Value::Symbolic` from a name `s` and bit width `n`
    pub fn symbolic_value(&self, s: &str, n: u32) -> Value {
        Value::Symbolic(self.bv(s, n), 0)
    }

    /// Create a tainted `Value::Concrete` from a value `v` and bit width `n`
    pub fn tainted_concrete_value(&mut self, t: &str, v: u64, n: u32) -> Value {
        let mask = if n < 64 { (1 << n) - 1 } else { -1i64 as u64 };
        let taint = self.get_tainted_identifier(t);
        Value::Concrete(v & mask, taint)
    }

    /// Create a tainted `Value::Symbolic` from a name `s` and bit width `n`
    pub fn tainted_symbolic_value(&mut self, t: &str, s: &str, n: u32) -> Value {
        let taint = self.get_tainted_identifier(t);
        Value::Symbolic(self.bv(s, n), taint)
    }

    /// Get the numeric identifier for the given taint name
    pub fn get_tainted_identifier(&mut self, t: &str) -> u64 {
        if let Some(taint) = self.taints.get(t) {
            *taint
        } else {
            let index = self.taints.len();
            if index < 64 {
                let new_taint = 1 << index as u64;
                self.taints.insert(t.to_owned(), new_taint);
                new_taint
            } else {
                // no need to panic
                println!("Max of 64 taints allowed!");
                0
            }
        }
    }

    /// Check if the `value` is tainted with the given `taint`  
    pub fn is_tainted_with(&mut self, value: &Value, taint: &str) -> bool {
        (value.get_taint() & self.get_tainted_identifier(taint)) != 0
    }

    /// BitVectors will need to be translated if run is multithreaded
    pub fn translate(&self, bv: &BitVec) -> Option<BitVec> {
        self.solver.translate(bv)
    }

    /// Translate `value` to this states solver
    pub fn translate_value(&self, value: &Value) -> Value {
        self.solver.translate_value(value)
    }

    /// Evaluate a `Value` `val`
    pub fn eval(&mut self, val: &Value) -> Option<Value> {
        self.solver.eval(val)
    }

    /// Evaluate a bitvector `bv`
    pub fn evaluate(&mut self, bv: &BitVec) -> Option<Value> {
        self.solver.evaluate(bv)
    }

    /// Evaluate and constrain the symbol to the u64
    pub fn evalcon(&mut self, bv: &BitVec) -> Option<u64> {
        self.solver.evalcon(bv)
    }

    /// Constrain bytes of bitvector to be an exact string eg. "ABC"
    /// or use "\[...\]" to match a simple pattern eg. "\[XYZa-z0-9\]"
    pub fn constrain_bytes_bv(&mut self, bv: &BitVec, pattern: &str) {
        if &pattern[..1] != "[" {
            for (i, c) in pattern.chars().enumerate() {
                self.assert_bv(
                    &bv.slice(8 * (i as u32 + 1) - 1, 8 * i as u32)
                        ._eq(&self.bvv(c as u64, 8)),
                );
            }
        } else {
            let patlen = pattern.len();
            let newpat = &pattern[1..patlen - 1];
            let mut assertions = Vec::with_capacity(256);

            for ind in 0..bv.get_width() / 8 {
                assertions.clear();
                let s = &bv.slice(8 * (ind + 1) - 1, 8 * ind);

                let mut i = 0;
                while i < patlen - 2 {
                    let c = newpat.as_bytes()[i] as u64;
                    if patlen > 4 && i < patlen - 4 && &newpat[i + 1..i + 2] == "-" {
                        let n = newpat.as_bytes()[i + 2] as u64;
                        i += 3;
                        assertions.push(s.ugte(&self.bvv(c, 8)).and(&s.ulte(&self.bvv(n, 8))));
                    } else {
                        i += 1;
                        assertions.push(s._eq(&self.bvv(c, 8)));
                    }
                }

                self.assert_bv(&self.solver.or_all(&assertions));
            }
        }
    }

    /// Constrain bytes of bitvector to be an exact string eg. "ABC"
    /// or use "\[...\]" to match a simple pattern eg. "\[XYZa-z0-9\]"
    pub fn constrain_bytes(&mut self, bv: &Value, pattern: &str) {
        if let Value::Symbolic(s, _) = bv {
            self.constrain_bytes_bv(s, pattern)
        }
    }

    /// Constrain bytes of file with file descriptor `fd` and pattern
    pub fn constrain_fd(&mut self, fd: usize, content: &str) {
        let fbytes = self.dump_file(fd);
        let fbv = self.pack(&fbytes);
        self.constrain_bytes(&fbv, content);
    }

    /// Constrain bytes of file at `path` with pattern
    pub fn constrain_file(&mut self, path: &str, content: &str) {
        if let Some(fd) = self.filesystem.getfd(path) {
            self.constrain_fd(fd, content);
        }
    }

    // search for string in file
    pub fn search_file(&mut self, path: &str, content: &str) -> Value {
        if let Some(fd) = self.filesystem.getfd(path) {
            self.search_fd(fd, content)
        } else {
            vc(-1i64 as u64)
        }
    }

    // TODO this is hacky as fuck, make it better
    pub fn search_fd(&mut self, fd: usize, content: &str) -> Value {
        let data = self.dump_file(fd);
        let length = vc(data.len() as u64);
        let addr = self.memory_alloc(&length);
        self.memory_write(&addr, &data, &length);
        let needle = self.pack(&byte_values(content));
        let result = self.memory_search(&addr, &needle, &length, false);
        self.memory_free(&addr);
        self.cond(&result.eq(&vc(0)), &vc(-1i64 as u64), &result)
    }

    /// Check if this state is satisfiable and mark the state `Unsat` if not
    pub fn is_sat(&mut self) -> bool {
        if self.solver.is_sat() {
            true
        } else {
            self.status = StateStatus::Unsat;
            false
        }
    }

    /// Increment visit counter
    pub fn visit(&mut self) {
        if let Some(pc) = self.registers.get_pc().as_u64() {
            self.visits.entry(pc).and_modify(|c| *c += 1).or_insert(1);
        }
    }

    /// Get visit counter
    pub fn get_visit(&self) -> usize {
        if let Some(pc) = self.registers.get_pc().as_u64() {
            *self.visits.get(&pc).unwrap_or(&0)
        } else {
            0
        }
    }

    /// Print backtrace
    pub fn print_backtrace(&mut self) {
        for (i, bt) in self.backtrace.iter().rev().enumerate() {
            let name = self.r2api.get_flag(bt.1).unwrap_or_default();
            println!("\n#{} 0x{:08x} ({})\n", i, bt.1, name.trim());
        }
    }

    /// Set status of state (active, inactive, merge, unsat...)
    pub fn set_status(&mut self, status: StateStatus) {
        self.status = status;
    }

    /// Get status of state (active, inactive, merge, unsat...)
    pub fn get_status(&mut self) -> StateStatus {
        self.status.clone()
    }

    /// Convenience method to mark state inactive
    pub fn set_inactive(&mut self) {
        self.set_status(StateStatus::Inactive);
    }

    /// Convenience method to mark state crashed
    pub fn set_crash(&mut self, addr: u64, perm: char) {
        self.set_status(StateStatus::Crash(addr, perm));
    }

    pub fn check_crash(&mut self, addr: &Value, len: &Value, perm: char) -> bool {
        let length = self.solver.max_value(len);
        match addr {
            Value::Concrete(address, _t) => {
                let crash = !self.memory.check_permission(*address, length, perm);
                if crash {
                    self.set_crash(*address, perm);
                }
                crash
            }
            Value::Symbolic(address, _t) => {
                let min = self.solver.min(address);
                let max = self.solver.max(address);
                let min_crash = !self.memory.check_permission(min, length, perm);
                let max_crash = !self.memory.check_permission(max, length, perm);
                if min_crash {
                    self.set_crash(min, perm);
                } else if max_crash {
                    self.set_crash(max, perm);
                }
                min_crash || max_crash
            }
        }
    }

    /// convenience method to break
    pub fn set_break(&mut self) {
        self.set_status(StateStatus::Break);
    }

    /// Get the argument values for the current function
    pub fn get_args(&mut self) -> Vec<Value> {
        let pc = self.registers.get_pc().as_u64().unwrap();
        let cc = self.r2api.get_cc(pc).unwrap_or_default();
        let mut args = Vec::with_capacity(16);

        if !cc.args.is_empty() {
            for arg in &cc.args {
                args.push(self.registers.get_with_alias(arg));
            }
        } else {
            // read args from stack?
            let mut sp = self.registers.get_with_alias("SP");
            let length = self.memory.bits as usize / 8;

            for _ in 0..8 {
                // do 8 idk?
                sp = sp + Value::Concrete(length as u64, 0);
                let value = self.memory_read_value(&sp, length);
                args.push(value);
            }
        }

        args
    }

    /// get the return value from the right register
    pub fn get_ret(&mut self) -> Value {
        let pc = self.registers.get_pc().as_u64().unwrap();
        let cc = self.r2api.get_cc(pc).unwrap_or_default();
        self.registers.get(&cc.ret)
    }

    /// Set the argument values for the current function
    pub fn set_args(&mut self, mut values: Vec<Value>) {
        let pc = self.registers.get_pc().as_u64().unwrap();
        let cc = self.r2api.get_cc(pc).unwrap_or_default();

        if !cc.args.is_empty() {
            for arg in &cc.args {
                if !values.is_empty() {
                    self.registers.set_with_alias(arg, values.remove(0));
                }
            }
        } else {
            // read args from stack?
            let mut sp = self.registers.get_with_alias("SP");
            let length = self.memory.bits as usize / 8;

            for _ in 0..8 {
                // do 8 idk?
                sp = sp + Value::Concrete(length as u64, 0);
                if !values.is_empty() {
                    self.memory_write_value(&sp, &values.remove(0), length);
                }
            }
        }
    }

    /// Assert the truth of the given bitvector (value != 0)
    pub fn assert_bv(&mut self, bv: &BitVec) {
        self.solver.assert_bv(bv)
    }

    /// Assert the truth of the given `Value` (value != 0)
    pub fn assert(&mut self, value: &Value) {
        self.solver.assert(value)
    }

    /// Check the satisfiability of the given value
    pub fn check(&mut self, val: &Value) -> bool {
        self.solver.check_sat(val)
    }

    /// Get a conditional value
    pub fn cond(&self, condition: &Value, if_val: &Value, else_val: &Value) -> Value {
        self.solver.conditional(condition, if_val, else_val)
    }

    /// Evaluate multiple solutions to bv
    pub fn evaluate_many(&mut self, bv: &BitVec) -> Vec<u64> {
        self.solver.evaluate_many(bv)
    }

    /// Evaluate bytes from bitvector `bv`
    pub fn evaluate_bytes_bv(&mut self, bv: &BitVec) -> Option<Vec<u8>> {
        let new_bv = bv; //self.translate(bv).unwrap();
        let mut data: Vec<u8> = vec![];
        if self.solver.is_sat() {
            //let one_sol = new_bv.get_a_solution().disambiguate();
            let solution_opt = self.solver.solution(new_bv);
            if let Some(solution) = solution_opt {
                for i in 0..(new_bv.get_width() / 8) as usize {
                    let sol = u8::from_str_radix(&solution[i * 8..(i + 1) * 8], 2);
                    data.push(sol.unwrap());
                }
                if self.memory.endian == Endian::Little {
                    data.reverse();
                }
                Some(data)
            } else {
                None
            }
        } else {
            None
        }
    }

    /// Evaluate bytes from bitvector `bv`
    pub fn evaluate_string_bv(&mut self, bv: &BitVec) -> Option<String> {
        if let Some(bytes) = self.evaluate_bytes_bv(bv) {
            String::from_utf8(bytes).ok()
        } else {
            None
        }
    }

    /// Evaluate bytes from value
    pub fn evaluate_bytes(&mut self, value: &Value) -> Option<Vec<u8>> {
        self.evaluate_bytes_bv(value.as_bv().as_ref().unwrap())
    }

    /// Evaluate string from value
    pub fn evaluate_string(&mut self, value: &Value) -> Option<String> {
        self.evaluate_string_bv(value.as_bv().as_ref().unwrap())
    }
}

```

`radius/src/test.rs`:

```rs
//use crate::state::State;

// #[test]
// looper is broken cuz of the weird disassembly crash
// fn looper() {
//     use crate::radius::{Radius, RadiusOption};

//     let options = [RadiusOption::Sims(false)]; // RadiusOption::Debug(true));
//     let mut radius = Radius::new_with_options(Some("../tests/looper"), &options);
//     let state = radius.call_state(0x100003f4c);
//     //let state = radius.entry_state(&vec!("looper".to_owned()), &vec!());
//     let new_state = radius.run_until(state, 0x100003fb4, &[]).unwrap();
//     let x0 = new_state.registers.get("x0");
//     println!("{:?}", x0);
//     assert_eq!(x0.as_u64(), Some(1837180037));
// }

#[test]
fn hello() {
    use crate::radius::{Radius, RadiusOption};
    let options = [RadiusOption::Debug(true)];
    let mut radius = Radius::new_with_options(Some("../tests/hello"), &options);
    let state = radius.call_state(0x00001149);
    let new_state = radius.run_until(state, 0x1163, &[]).unwrap();
    println!("{:?}", new_state.registers.get("eax"))
}

#[test]
fn strstuff() {
    use crate::radius::Radius;
    use crate::value::Value;

    let mut radius = Radius::new("../tests/strstuff");
    let main = radius.r2api.get_address("main").unwrap();
    let mut state = radius.call_state(main);

    let bv = state.bv("flag", 10 * 8);
    let addr: u64 = 0x100000;
    let len = 10;
    state
        .memory
        .write_value(addr + 8, &Value::Concrete(addr + 24, 0), 8);
    state
        .memory
        .write_value(addr + 24, &Value::Symbolic(bv.clone(), 0), len);
    state
        .memory
        .write_value(addr + 34, &Value::Concrete(0, 0), 8);
    state.registers.set("rsi", Value::Concrete(addr, 0));

    let mut new_state = radius.run_until(state, 0x1208, &[0x120f]).unwrap();
    println!("{:?}", new_state.evaluate_string_bv(&bv))
}

#[test]
fn simple() {
    use crate::radius::Radius;
    use crate::value::Value;

    let mut radius = Radius::new("../tests/simple");
    let mut state = radius.call_state(0x5fa);

    let bv = state.bv("num", 32);
    state.registers.set("edi", Value::Symbolic(bv.clone(), 0));
    let mut new_state = radius.run_until(state, 0x60b, &[0x612]).unwrap();

    if let Value::Concrete(val, _t) = new_state.evaluate(&bv).unwrap() {
        assert_eq!(val, 2);
    }
}

// this takes a really long time now (3s)
// cuz its doing the atoi also
#[test]
fn multi() {
    use crate::radius::{Radius, RadiusOption};

    let options = [RadiusOption::Debug(true)];
    let mut radius = Radius::new_with_options(Some("../tests/multi"), &options);
    let mut state = radius.entry_state();

    let arg1 = state.symbolic_value("arg1", 40);
    let name = state.concrete_value(0, 0);

    radius.set_argv_env(&mut state, &[name, arg1], &[]);
    let mut new_state = radius.run_until(state, 0x11c2, &[0x11c9]).unwrap();

    let arg = new_state.registers.get_with_alias("A0");
    println!("arg: {}", new_state.eval(&arg).unwrap().as_u64().unwrap());
}

#[test]
fn r100() {
    use crate::radius::{Radius, RadiusOption};
    use crate::value::Value;

    let options = vec![RadiusOption::Debug(false)];
    let mut radius = Radius::new_with_options(Some("../tests/r100"), &options);
    let mut state = radius.call_state(0x004006fd);
    let bv = state.bv("flag", 12 * 8);
    let addr: u64 = 0x100000;
    state
        .memory
        .write_value(addr, &Value::Symbolic(bv.clone(), 0), 12);
    state.registers.set("rdi", Value::Concrete(addr, 0));

    radius.breakpoint(0x004007a1);
    radius.avoid(&[0x00400790]);
    let mut new_state = radius.run(state, 1).unwrap();
    let flag = new_state.evaluate_string_bv(&bv).unwrap();
    println!("FLAG: {}", flag);
    assert_eq!(flag, "Code_Talkers");
}

#[test]
fn r200() {
    use crate::radius::{Radius, RadiusOption};
    use crate::value::Value;

    let options = vec![RadiusOption::Debug(false)];
    let mut radius = Radius::new_with_options(Some("../tests/r200"), &options);
    let mut state = radius.call_state(0x00400886);
    let bv = state.bv("flag", 6 * 8);

    let addr = state.registers.get("rsp").as_u64().unwrap();
    state
        .memory
        .write_value(addr - 0x18, &Value::Symbolic(bv.clone(), 0), 6);

    radius.breakpoint(0x00400843);
    radius.mergepoint(0x004007fd);
    radius.avoid(&[0x00400832]);

    let mut new_state = radius.run(state, 1).unwrap();
    let flag = new_state.evaluate_string_bv(&bv).unwrap();
    println!("FLAG: {}", flag);
    assert_eq!(flag, "rotors");
}

#[test]
fn unbreakable() {
    use crate::radius::Radius;
    use crate::value::Value;

    let mut radius = Radius::new("../tests/unbreakable");
    let mut state = radius.call_state(0x004005bd);
    let len: usize = 0x33;
    let bv = state.bv("flag", 8 * len as u32);

    // add "CTF{" constraint
    let assertion = bv.slice(31, 0)._eq(&state.bvv(0x7b465443, 32));
    state.assert_bv(&assertion);

    let addr: u64 = 0x6042c0;
    state
        .memory
        .write_value(addr, &Value::Symbolic(bv.clone(), 0), len);
    let mut new_state = radius.run_until(state, 0x00400830, &[0x00400850]).unwrap();

    let flag = new_state.evaluate_string_bv(&bv).unwrap();
    println!("FLAG: {}", flag);
    assert_eq!(flag, "CTF{0The1Quick2Brown3Fox4Jumped5Over6The7Lazy8Fox9}");
}

/*fn callback(state: &mut State) -> bool {
    //println!("state: {:?}", state);
    true
}*/

#[test]
fn fileread() {
    use crate::radius::{Radius, RadiusOption};
    use crate::value::byte_values;

    let options = vec![RadiusOption::Debug(true)];
    let mut radius = Radius::new_with_options(Some("../tests/fileread"), &options);
    radius.analyze(2); // necessary for sims for some reason
    let mut state = radius.call_state(0x100003e7c);
    let data = byte_values("hmmmmmm");
    state.filesystem.add_file("test.txt", &data);
    let mut new_state = radius.run_until(state, 0x100003f14, &[]).unwrap();

    // dump stdout
    let data = new_state.filesystem.dump(1);

    let mut str_bytes = vec![];
    for d in data {
        str_bytes.push(new_state.solver.eval_to_u64(&d).unwrap() as u8);
    }
    let string = String::from_utf8(str_bytes).unwrap();
    assert_eq!(string, "hmmm\n");
}

#[test]
fn format() {
    use crate::radius::Radius;
    use crate::sims::format;
    use crate::value::vc;

    let mut radius = Radius::new("../tests/hello");
    let main = radius.r2api.get_address("main").unwrap();
    let mut state = radius.call_state(main);

    //let buf_addr = state.memory_alloc(&vc(100));
    let fmt_addr = state.memory_alloc(&vc(100));

    let dx = state.symbolic_value("dx", 8);
    //state.assert_value(&dx.eq(&vc('x' as u64)));

    // symbolic format
    let fmt = [vc('%' as u64), dx, vc(0)];
    state.memory_write(&fmt_addr, &fmt, &vc(8));

    //state.memory_write_string(fmt_addr.as_u64().unwrap(), "%02x");
    //state.memory_write_string(buf_addr.as_u64().unwrap(), "cool");

    //state.memory_write_value(&buf_addr, &vc(17492), 4);
    let data = format::format(&mut state, &[fmt_addr, vc(17499)]);
    let value = state.pack(&data);
    state.assert(&value.slice(31, 0).eq(&vc(0x62353434)));
    let result = state.evaluate_string(&value).unwrap();
    println!("result: {}", result);
    assert_eq!(&result[0..4], "445b");
}

#[test]
fn symmem() {
    use crate::radius::{Radius, RadiusOption};
    use crate::sims::format::{atoi_helper, itoa_helper};
    use crate::state::{Event, EventTrigger};
    use crate::value::Value;
    use std::rc::Rc;

    let mut radius =
        Radius::new_with_options(Some("../tests/symmem"), &vec![RadiusOption::Debug(false)]);

    let main = radius.r2api.get_address("main").unwrap();
    let mut state = radius.call_state(main);
    state.hook_event(
        Event::SymbolicRead(EventTrigger::Before),
        Rc::new(|_s, _e| {
            println!("hit event hook");
        }),
    );

    let x = state.bv("x", 64);
    //x.ult(&state.bvv(-1 as i64 as u64, 64)).assert();
    //x.ugt(&state.bvv(40, 64)).assert();
    //println!("x: {:?}", state.solver.max(&x));

    let sentence = String::from("this is my string it is a good string I think");
    state.memory.write_string(0x100000, sentence.as_str());
    state
        .memory
        .write_value(0x100008, &Value::Symbolic(x.clone(), 0), 8);

    let index = state.memory_search(
        &Value::Concrete(0x100000, 0),
        &Value::Concrete(0x646f6f67, 0),
        &Value::Concrete(64, 0),
        false,
    );

    //println!("index is {:?}", index);

    if let Value::Symbolic(ind, _t) = index {
        state.solver.push();
        ind._eq(&state.bvv(0x10000a, 64)).assert();
        //println!("{:?}", state.memory.read_string(0x100000, 48));
        state.solver.pop();
    }

    //return;

    let sentence1 = "elephant";
    let _sentence2 = "alephant";

    state.memory.write_string(0x100000, sentence1);
    state
        .memory
        .write_value(0x100010, &Value::Symbolic(x.clone(), 0), 8);

    let cmp = state.memory_compare(
        &Value::Concrete(0x100000, 0),
        &Value::Concrete(0x100010, 0),
        &Value::Concrete(8, 0),
    );

    if let Value::Symbolic(c, _t) = cmp {
        c._eq(&state.bvv(0, 64)).assert();
        println!("{}", state.evaluate_string_bv(&x).unwrap());
    }

    let len = 8;
    state.memory.write_string(0x200000, "00000110");
    let atoi_addr = Value::Concrete(0x200000, 0);
    let numstr = state.symbolic_value("numstr", 8 * len);
    state.memory_write_value(&atoi_addr, &numstr, len as usize);
    let num = atoi_helper(&mut state, &atoi_addr, &Value::Concrete(2, 0), 32); //numstr);
    state.assert(&num.sgt(&Value::Concrete(110i64 as u64, 0)));
    //println!("num: {:?}", num);
    println!("atoi: {:?}", state.evaluate_string(&numstr));

    let itoa_addr = Value::Concrete(0x300000, 0);
    let citoa_val = Value::Concrete(0x003239343731, 0);
    //let itoa_val = Value::Concrete(0x4454, 0);
    let itoa_val = state.symbolic_value("itoa", 32);
    itoa_helper(
        &mut state,
        &itoa_val,
        &itoa_addr,
        &Value::Concrete(10, 0),
        true,
        32,
    );
    let ibv = state.memory_read_value(&itoa_addr, 7);
    state.assert(&ibv.eq(&citoa_val));
    println!("itoa: {:?}", state.eval(&itoa_val));

    //println!("cmp: {:?}", cmp);

    /*println!("good: {:?}", index);
    if let Value::Concrete(good) = index {
        println!("good: {:?}, {:?}", index, sentence.get(..good as usize));
    }*/

    let len: usize = 8;
    let bv = state.bv("flag", 8 * len as u32);
    //bv._eq(&state.bvv(3, 64)).not().assert();

    state.registers.set("rdi", Value::Symbolic(bv.clone(), 0));

    let mut new_state = radius.run_until(state, 0x119c, &[0x119e]).unwrap();

    let eax = new_state.registers.get("rax");

    //println!("eax: {:?}", eax);
    //eax.as_bv().unwrap()._eq(&new_state.bvv(7, 64)).assert();
    println!("val: {:?} {:?}", new_state.eval(&eax), eax);

    radius.r2api.close();
}

#[test]
fn ioscrackme() {
    use crate::radius::{Radius, RadiusOption};
    use crate::value::Value;

    let mut radius = Radius::new_with_options(
        Some("ipa://../tests/ioscrackme.ipa"),
        &[RadiusOption::Debug(true)],
    );

    //radius.set_option("asm.arch", "arm.v35");
    let len: usize = 16;

    let validate = radius.r2api.get_address("sym._validate").unwrap();
    let mut state = radius.call_state(validate);
    let bv = state.bv("flag", 8 * len as u32);

    // add "[a-zA-Z]" constraint
    state.constrain_bytes_bv(&bv, "[a-zA-Z]");

    let buf_addr: u64 = 0xfff00000;
    state.registers.set("x0", Value::Concrete(buf_addr, 0));
    state
        .memory
        .write_value(buf_addr, &Value::Symbolic(bv.clone(), 0), len);

    let mut new_state = radius
        .run_until(state, 0x10000600c, &[0x100006044])
        .unwrap();

    let flag = new_state.evaluate_string_bv(&bv);
    println!("FLAG: {}", flag.unwrap());
    radius.r2api.close();
}

```

`radius/src/value.rs`:

```rs
use crate::solver::BitVec;
use boolector::{Btor, BV};
use std::cmp::Ordering;
use std::ops;
use std::sync::Arc;

#[inline]
pub fn log2(x: u32) -> u32 {
    31 - x.leading_zeros()
}

#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    /// A concrete u64 value and an optional taint value
    Concrete(u64, u64),
    /// A symbolic bitvector value and an optional taint value
    Symbolic(BitVec, u64),
}

impl Default for Value {
    fn default() -> Self {
        Value::Concrete(0, 0)
    }
}

#[inline]
pub fn make_bv(bv: &BitVec, val: u64, n: u32) -> BitVec {
    BV::from_u64(bv.get_btor(), val, n)
}

#[inline]
pub fn value_to_bv(btor: Arc<Btor>, value: Value) -> BitVec {
    match value {
        Value::Concrete(val, _t) => BV::from_u64(btor, val, 64),
        Value::Symbolic(val, _t) => val,
    }
}

#[inline]
pub fn cond_value(cond: &BitVec, v1: Value, v2: Value) -> BitVec {
    cond.cond_bv(
        &value_to_bv(cond.get_btor(), v1),
        &value_to_bv(cond.get_btor(), v2),
    )
}

macro_rules! binary_ops {
    ($self:expr, $rhs:expr, $method:ident, $op:tt) => {
        match ($self, $rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                Value::Concrete(*a $op *b, *t1 | *t2)
            },
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(a, *b, a.get_width());
                Value::Symbolic(a.$method(&bv), *t1 | *t2)
            },
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(b, *a, b.get_width());
                Value::Symbolic(bv.$method(&b), *t1 | *t2)
            },
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a.$method(&b), *t1 | *t2),
                    Ordering::Greater => Value::Symbolic(a.$method(&b.uext(width_diff as u32)), *t1 | *t2),
                    Ordering::Less => Value::Symbolic(a.uext((-width_diff) as u32).$method(&b), *t1 | *t2)
                }
            }
        }
    };
}

macro_rules! wrapping_binary_ops {
    ($self:expr, $rhs:expr, $method:ident, $wrapping:ident) => {
        match ($self, $rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                Value::Concrete(a.$wrapping(*b), *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(a, *b, a.get_width());
                Value::Symbolic(a.$method(&bv), *t1 | *t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(b, *a, b.get_width());
                Value::Symbolic(bv.$method(&b), *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a.$method(&b), *t1 | *t2),
                    Ordering::Greater => {
                        Value::Symbolic(a.$method(&b.uext(width_diff as u32)), *t1 | *t2)
                    }
                    Ordering::Less => {
                        Value::Symbolic(a.uext((-width_diff) as u32).$method(&b), *t1 | *t2)
                    }
                }
            }
        }
    };
}

impl ops::Add<Value> for Value {
    type Output = Value;

    #[inline]
    fn add(self, rhs: Value) -> Value {
        wrapping_binary_ops!(&self, &rhs, add, wrapping_add)
    }
}

impl ops::Sub<Value> for Value {
    type Output = Value;

    #[inline]
    fn sub(self, rhs: Value) -> Value {
        wrapping_binary_ops!(&self, &rhs, sub, wrapping_sub)
    }
}

impl ops::Mul<Value> for Value {
    type Output = Value;

    #[inline]
    fn mul(self, rhs: Value) -> Value {
        wrapping_binary_ops!(&self, &rhs, mul, wrapping_mul)
    }
}

impl ops::Div<Value> for Value {
    type Output = Value;

    #[inline]
    fn div(self, rhs: Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                // boolector makes /0 always -1 so
                if b != 0 {
                    Value::Concrete(a.wrapping_div(b), t1 | t2)
                } else {
                    Value::Concrete(-1i64 as u64, t1 | t2)
                }
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, a.get_width());
                Value::Symbolic(a.udiv(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, b.get_width());
                Value::Symbolic(bv.udiv(&b), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a.udiv(&b), t1 | t2),
                    Ordering::Greater => {
                        Value::Symbolic(a.udiv(&b.uext(width_diff as u32)), t1 | t2)
                    }
                    Ordering::Less => Value::Symbolic(a.uext(-width_diff as u32).udiv(&b), t1 | t2),
                }
            }
        }
    }
}

impl ops::Rem<Value> for Value {
    type Output = Value;

    #[inline]
    fn rem(self, rhs: Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                if b != 0 {
                    Value::Concrete(a.wrapping_rem(b), t1 | t2)
                } else {
                    Value::Concrete(a, t1 | t2)
                }
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, a.get_width());
                Value::Symbolic(a.urem(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, b.get_width());
                Value::Symbolic(bv.urem(&b), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a.urem(&b), t1 | t2),
                    Ordering::Greater => {
                        Value::Symbolic(a.urem(&b.uext(width_diff as u32)), t1 | t2)
                    }
                    Ordering::Less => Value::Symbolic(a.uext(-width_diff as u32).urem(&b), t1 | t2),
                }
            }
        }
    }
}

impl ops::BitAnd<Value> for Value {
    type Output = Value;

    #[inline]
    fn bitand(self, rhs: Value) -> Value {
        binary_ops!(&self, &rhs, and, &)
    }
}

impl ops::BitOr<Value> for Value {
    type Output = Value;

    #[inline]
    fn bitor(self, rhs: Value) -> Value {
        binary_ops!(&self, &rhs, or, |)
    }
}

impl ops::BitXor<Value> for Value {
    type Output = Value;

    // ok here we could clear taint if a == b since this is used to zero regs
    // idk if this is actually a good idea or not. but something needs to be done
    // to stop wild overtainting
    #[inline]
    fn bitxor(self, rhs: Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                Value::Concrete(a ^ b, (t1 | t2) * ((a != b || t1 != t2) as u64))
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, a.get_width());
                Value::Symbolic(a.xor(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, b.get_width());
                Value::Symbolic(bv.xor(&b), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a.xor(&b), t1 | t2),
                    Ordering::Greater => {
                        Value::Symbolic(a.xor(&b.uext(width_diff as u32)), t1 | t2)
                    }
                    Ordering::Less => Value::Symbolic(a.uext(-width_diff as u32).xor(&b), t1 | t2),
                }
            }
        }
    }
}

impl ops::Not for Value {
    type Output = Value;

    #[inline]
    fn not(self) -> Value {
        match self {
            Value::Concrete(a, t) => Value::Concrete((a == 0) as u64, t),
            Value::Symbolic(a, t) => {
                let zero = BV::zero(a.get_btor(), a.get_width());
                Value::Symbolic(a._eq(&zero).uext(a.get_width() - 1), t)
            }
        }
    }
}

impl ops::Neg for Value {
    type Output = Value;

    #[inline]
    fn neg(self) -> Value {
        match self {
            Value::Concrete(a, t) => Value::Concrete(a.wrapping_neg(), t),
            Value::Symbolic(a, t) => Value::Symbolic(a.neg(), t),
        }
    }
}

impl ops::Shl<Value> for Value {
    type Output = Value;

    #[inline]
    fn shl(self, rhs: Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                if b > 63 {
                    Value::Concrete(0, t1 | t2)
                } else {
                    Value::Concrete(a.wrapping_shl(b as u32), t1 | t2)
                }
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, log2(a.get_width()));
                Value::Symbolic(a.sll(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, 64);
                Value::Symbolic(bv.sll(&b.slice(5, 0)), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                Value::Symbolic(a.sll(&b.slice(log2(a.get_width()) - 1, 0)), t1 | t2)
            }
        }
    }
}

impl ops::Shr<Value> for Value {
    type Output = Value;

    #[inline]
    fn shr(self, rhs: Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                if b > 63 {
                    Value::Concrete(0, t1 | t2)
                } else {
                    Value::Concrete(a.wrapping_shr(b as u32), t1 | t2)
                }
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, log2(a.get_width()));
                //println!("{:?} {:?}", a, b);
                Value::Symbolic(a.srl(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, 64);
                Value::Symbolic(bv.srl(&b.slice(5, 0)), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                Value::Symbolic(a.srl(&b.slice(log2(a.get_width()) - 1, 0)), t1 | t2)
            }
        }
    }
}

impl Value {
    #[inline]
    pub fn sdiv(self, rhs: Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                // boolector makes /0 always -1 so
                if b != 0 {
                    Value::Concrete(((a as i64).wrapping_div(b as i64)) as u64, t1 | t2)
                } else {
                    Value::Concrete(-1i64 as u64, t1 | t2)
                }
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, a.get_width());
                Value::Symbolic(a.sdiv(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, b.get_width());
                Value::Symbolic(bv.sdiv(&b), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a.sdiv(&b), t1 | t2),
                    Ordering::Greater => {
                        Value::Symbolic(a.sdiv(&b.sext(width_diff as u32)), t1 | t2)
                    }
                    Ordering::Less => Value::Symbolic(a.sext(-width_diff as u32).sdiv(&b), t1 | t2),
                }
            }
        }
    }

    #[inline]
    pub fn srem(self, rhs: Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                if b != 0 {
                    Value::Concrete(((a as i64).wrapping_rem(b as i64)) as u64, t1 | t2)
                } else {
                    Value::Concrete(a, t1 | t2)
                }
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, a.get_width());
                Value::Symbolic(a.srem(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, b.get_width());
                Value::Symbolic(bv.srem(&b), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a.srem(&b), t1 | t2),
                    Ordering::Greater => {
                        Value::Symbolic(a.srem(&b.sext(width_diff as u32)), t1 | t2)
                    }
                    Ordering::Less => Value::Symbolic(a.sext(-width_diff as u32).srem(&b), t1 | t2),
                }
            }
        }
    }

    #[inline]
    pub fn asr(self, rhs: Value, sz: u32) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                let shift = 64 - sz as i64;
                let sign_ext = ((a as i64) << shift) >> shift;
                Value::Concrete(((sign_ext as i64) >> (b as i64)) as u64, t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, log2(sz));
                Value::Symbolic(a.slice(sz - 1, 0).sra(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, sz);
                Value::Symbolic(bv.sra(&b.slice(log2(sz) - 1, 0)), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                Value::Symbolic(a.slice(sz - 1, 0).sra(&b.slice(log2(sz) - 1, 0)), t1 | t2)
            }
        }
    }

    #[inline]
    pub fn ror(self, rhs: Value, sz: u32) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                // uhhh
                let rot = (a & ((1 << sz) - 1)).rotate_right(b as u32);
                let mask = ((1 << b) - 1) << (64 - b);
                let val = rot - (rot & mask) + ((rot & mask) >> (64 - sz as u64));
                Value::Concrete(val, t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, log2(sz));
                Value::Symbolic(a.slice(sz - 1, 0).ror(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, sz);
                Value::Symbolic(bv.slice(sz - 1, 0).ror(&b.slice(log2(sz) - 1, 0)), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                Value::Symbolic(a.slice(sz - 1, 0).ror(&b.slice(log2(sz) - 1, 0)), t1 | t2)
            }
        }
    }

    #[inline]
    pub fn rol(self, rhs: Value, sz: u32) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                // uhhh
                let na = a << (64 - sz);
                let rot = na.rotate_left(b as u32);
                let mask = (1 << b) - 1;
                let val = ((rot - (rot & mask)) >> (64 - sz as u64)) + (rot & mask);
                Value::Concrete(val, t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, b, log2(sz));
                Value::Symbolic(a.slice(sz - 1, 0).rol(&bv), t1 | t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, a, sz);
                Value::Symbolic(bv.slice(sz - 1, 0).rol(&b.slice(log2(sz) - 1, 0)), t1 | t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                Value::Symbolic(a.slice(sz - 1, 0).rol(&b.slice(log2(sz) - 1, 0)), t1 | t2)
            }
        }
    }

    // get whether values are equivalent
    #[inline]
    pub fn eq(&self, rhs: &Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                Value::Concrete((*a == *b) as u64, *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(a, *b, a.get_width());
                Value::Symbolic(a._eq(&bv), *t1 | *t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(b, *a, b.get_width());
                Value::Symbolic(bv._eq(&b), *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a._eq(b), *t1 | *t2),
                    Ordering::Greater => {
                        Value::Symbolic(a._eq(&b.uext(width_diff as u32)), *t1 | *t2)
                    }
                    Ordering::Less => {
                        Value::Symbolic(b._eq(&a.uext(-width_diff as u32)), *t1 | *t2)
                    }
                }
            }
        }
    }

    // check if values are *identical*
    #[inline]
    pub fn id(&self, rhs: &Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                Value::Concrete((a == b) as u64, *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                if a.is_const() {
                    Value::Concrete((a.as_u64().unwrap() == *b) as u64, *t1 | *t2)
                } else {
                    Value::Concrete(0, *t1 | *t2)
                }
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                if b.is_const() {
                    Value::Concrete((b.as_u64().unwrap() == *a) as u64, *t1 | *t2)
                } else {
                    Value::Concrete(0, *t1 | *t2)
                }
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                Value::Concrete((a == b) as u64, *t1 | *t2)
            }
        }
    }

    #[inline]
    pub fn slt(&self, rhs: &Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                Value::Concrete(((*a as i64) < (*b as i64)) as u64, *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(a, *b, a.get_width());
                Value::Symbolic(a.slt(&bv), *t1 | *t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(b, *a, b.get_width());
                Value::Symbolic(bv.slt(&b), *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a.slt(b), *t1 | *t2),
                    Ordering::Greater => {
                        Value::Symbolic(a.slt(&b.sext(width_diff as u32)), *t1 | *t2)
                    }
                    Ordering::Less => {
                        Value::Symbolic(a.uext((-width_diff) as u32).slt(b), *t1 | *t2)
                    }
                }
            }
        }
    }

    #[inline]
    pub fn slte(&self, rhs: &Value) -> Value {
        self.slt(rhs) | self.eq(rhs)
    }

    #[inline]
    pub fn sgt(&self, rhs: &Value) -> Value {
        !self.slt(rhs) & !self.eq(rhs)
    }

    #[inline]
    pub fn sgte(self, rhs: &Value) -> Value {
        !self.slt(rhs)
    }

    #[inline]
    pub fn ult(&self, rhs: &Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                Value::Concrete((*a < *b) as u64, *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                let bv = make_bv(&a, *b, a.get_width());
                Value::Symbolic(a.ult(&bv), *t1 | *t2)
            }
            (Value::Concrete(a, t1), Value::Symbolic(b, t2)) => {
                let bv = make_bv(&b, *a, b.get_width());
                Value::Symbolic(bv.ult(&b), *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Symbolic(b, t2)) => {
                let width_diff = a.get_width() as i32 - b.get_width() as i32;
                match width_diff.cmp(&0) {
                    Ordering::Equal => Value::Symbolic(a.ult(&b), *t1 | *t2),
                    Ordering::Greater => {
                        Value::Symbolic(a.ult(&b.uext(width_diff as u32)), *t1 | *t2)
                    }
                    Ordering::Less => {
                        Value::Symbolic(a.uext((-width_diff) as u32).ult(&b), *t1 | *t2)
                    }
                }
            }
        }
    }

    #[inline]
    pub fn ulte(&self, rhs: &Value) -> Value {
        self.ult(rhs) | self.eq(rhs)
    }

    #[inline]
    pub fn ugt(&self, rhs: &Value) -> Value {
        !self.ult(rhs) & !self.eq(rhs)
    }

    #[inline]
    pub fn ugte(&self, rhs: &Value) -> Value {
        !self.ult(rhs)
    }

    #[inline]
    pub fn uext(&self, rhs: &Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                Value::Concrete(a & ((1 << b) - 1), *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                //let bv = make_bv(&a, b, a.get_width());
                let bits = if *b <= 64 { *b } else { 64 };
                Value::Symbolic(a.slice(*b as u32 - 1, 0).uext(64 - bits as u32), *t1 | *t2)
            }
            (Value::Concrete(a, t), Value::Symbolic(_b, _t)) => {
                // uh hopefully this doesnt happen
                Value::Concrete(*a, *t)
            }
            (Value::Symbolic(a, t), Value::Symbolic(_b, _t)) => {
                // uh hopefully this doesnt happen
                let szdiff = 64 - a.get_width();
                Value::Symbolic(a.uext(szdiff), *t)
            }
        }
    }

    #[inline]
    pub fn sext(&self, rhs: &Value) -> Value {
        match (self, rhs) {
            (Value::Concrete(a, t1), Value::Concrete(b, t2)) => {
                let szdiff = 64 - *b as i64;
                Value::Concrete((((*a as i64) << szdiff) >> szdiff) as u64, *t1 | *t2)
            }
            (Value::Symbolic(a, t1), Value::Concrete(b, t2)) => {
                //let bv = make_bv(&a, b, a.get_width());
                Value::Symbolic(
                    a.slice(*b as u32 - 1, 0).sext(64 - (*b % 64) as u32),
                    *t1 | *t2,
                )
            }
            (Value::Concrete(a, t), Value::Symbolic(_b, _t)) => {
                // uh hopefully this doesnt happen
                Value::Concrete(*a, *t)
            }
            (Value::Symbolic(a, t), Value::Symbolic(_b, _t)) => {
                // uh hopefully this doesnt happen
                let szdiff = 64 - a.get_width();
                Value::Symbolic(a.sext(szdiff), *t)
            }
        }
    }

    #[inline]
    pub fn slice(&self, high: u64, low: u64) -> Value {
        match self {
            Value::Concrete(a, t) => {
                let mask = if (high - low) < 63 {
                    (1 << (high - low + 1)) - 1
                } else {
                    -1i64 as u64
                };
                Value::Concrete((*a >> low) & mask, *t)
            }
            Value::Symbolic(a, t) => {
                let width = a.get_width() as u64;
                let h = if high < width {
                    high
                } else {
                    width - 1
                };
                let l = if low < width { 
                    low
                } else {
                    width - 1
                };
                Value::Symbolic(a.slice(h as u32, l as u32), *t)
            }
        }
    }

    #[inline]
    pub fn as_u64(&self) -> Option<u64> {
        match self {
            Value::Concrete(a, _t) => Some(*a),
            Value::Symbolic(a, _t) => a.as_u64(),
        }
    }

    /// tries to convert to Concrete
    #[inline]
    pub fn try_con(&self) -> Self {
        match self {
            Value::Concrete(_a, _t) => self.to_owned(),
            Value::Symbolic(a, t) => {
                if let Some(v) = a.as_u64() {
                    Value::Concrete(v, *t)
                } else {
                    self.to_owned()
                }
            }
        }
    }

    #[inline]
    pub fn as_bv(&self) -> Option<BitVec> {
        match self {
            Value::Concrete(_a, _t) => None,
            Value::Symbolic(a, _t) => Some(a.to_owned()),
        }
    }

    #[inline]
    pub fn get_taint(&self) -> u64 {
        match self {
            Value::Concrete(_a, t) => *t,
            Value::Symbolic(_a, t) => *t,
        }
    }

    #[inline]
    pub fn with_taint(&self, taint: u64) -> Value {
        match self {
            Value::Concrete(a, t) => Value::Concrete(*a, *t | taint),
            Value::Symbolic(a, t) => Value::Symbolic(a.to_owned(), *t | taint),
        }
    }

    pub fn depends(&self, rhs: &Value) -> bool {
        match rhs {
            Value::Concrete(_a, t1) => self.get_taint() & *t1 != 0,
            Value::Symbolic(abv, t1) => match self {
                Value::Concrete(_b, t2) => *t1 & *t2 != 0,
                Value::Symbolic(bbv, t2) => {
                    let mut tainted = false;
                    if let Some(sym) = abv.get_symbol() {
                        tainted = format!("{:?}", bbv).contains(sym);
                    }
                    tainted || (*t1 & *t2 != 0)
                }
            },
        }
    }

    #[inline]
    pub fn is_concrete(&self) -> bool {
        matches!(self, Value::Concrete(_, _))
    }

    #[inline]
    pub fn is_symbolic(&self) -> bool {
        matches!(self, Value::Symbolic(_, _))
    }

    #[inline]
    pub fn add(&self, rhs: &Value) -> Value {
        wrapping_binary_ops!(self, rhs, add, wrapping_add)
    }

    #[inline]
    pub fn sub(&self, rhs: &Value) -> Value {
        wrapping_binary_ops!(self, rhs, sub, wrapping_sub)
    }

    #[inline]
    pub fn mul(&self, rhs: &Value) -> Value {
        wrapping_binary_ops!(self, rhs, mul, wrapping_mul)
    }

    #[inline]
    pub fn div(&self, rhs: &Value) -> Value {
        wrapping_binary_ops!(self, rhs, udiv, wrapping_div)
    }

    #[inline]
    pub fn rem(&self, rhs: &Value) -> Value {
        wrapping_binary_ops!(self, rhs, urem, wrapping_rem)
    }

    #[inline]
    pub fn and(&self, rhs: &Value) -> Value {
        binary_ops!(self, rhs, and, &)
    }

    #[inline]
    pub fn or(&self, rhs: &Value) -> Value {
        binary_ops!(self, rhs, or, |)
    }

    #[inline]
    pub fn xor(&self, rhs: &Value) -> Value {
        binary_ops!(self, rhs, xor, ^)
    }

    #[inline]
    pub fn size(&self) -> u32 {
        match self {
            Value::Concrete(_a, _t) => 64,
            Value::Symbolic(a, _t) => a.get_width(),
        }
    }
}

/// convenience method for making an untainted `Value::Concrete`
#[inline]
pub fn vc(v: u64) -> Value {
    Value::Concrete(v, 0)
}

/// convert strings into vecs of values
#[inline]
pub fn byte_values<T: AsRef<str>>(string: T) -> Vec<Value> {
    string.as_ref().chars().map(|c| vc(c as u64)).collect()
}

```

`radius2.md`:

```md
# The `radius2` command line tool 

The `radius2` symbolic execution framework includes a command line utility that can be installed with `cargo install radius2`. It allows users to solve reversing problems quickly using symbolic execution and aims to be both user friendly and flexible enough to do nearly any task straight from the terminal. Many complex reversing CTF challenges can be solved with a short command like 

```bash
$ radius2 -p crackme -s flag 320 -X Wrong -B Correct

  flag : "grey{d1d_y0u_s0lv3_by_emul4t1ng?_1e4b8a}"

```

In this example from GreyCTF2023 `radius2` analyzes the binary with `r2`, executes 295293 instructions, and solves the final constraints, all in under 6 seconds. This binary also contains self-modifying code based on the input, which is handled seemlessly by the symbolic execution engine. 

This document will cover the many different ways `radius2` can be used to perform automated reverse engineering with symbolic execution. 

`radius2 -h` outputs the usage information:

```
radius2 1.0.27
Austin Emmitt (@alkalinesec) <alkali@alkalinesecurity.com>
A symbolic execution tool using r2 and boolector

USAGE:
    radius2 [FLAGS] [OPTIONS] --path <path>

FLAGS:
    -M, --automerge    Automatically merge states
    -V, --color        Use color output
        --crash        Execution stops on invalid memory access
    -h, --help         Prints help information
    -j, --json         Output JSON
    -z, --lazy         Evaluate symbolic PC values lazily
    -K, --merge-all    Merge all finished states
        --no-sims      Do not simulate imports
    -N, --no-modify    Disallow self-modifying code (faster sometimes)
        --no-strict    Don't avoid invalid instructions and ESIL
        --plugins      Load r2 plugins
    -P, --profile      Get performance and runtime information
    -2, --stderr       Show stderr output
    -0, --stdin        Use stdin for target program
    -1, --stdout       Show stdout output
        --version      Prints version information
    -v, --verbose      Show verbose / debugging output

OPTIONS:
    -a, --address <address>                   Address to begin execution at
    -A, --arg <arg>...                        Argument for the target program
    -x, --avoid <avoid>...                    Avoid addresses
    -X, --avoid-strings <avoid_strings>...    Avoid code xrefs to strings
    -B, --break-strings <break_strings>...    Breakpoint code xrefs to strings
    -b, --break <breakpoint>...               Breakpoint at some target address
    -c, --constrain <SYMBOL> <EXPR>           Constrain symbol values with string or pattern
    -C, --constrain-after <SYMBOL> <EXPR>     Constrain symbol or file values after execution
        --env <env>...                        Environment variable for the target program
    -e, --eval <ESIL>...                      Evaluate ESIL expression
    -E, --eval-after <ESIL>...                Evaluate ESIL expression after execution
    -f, --file <PATH> <SYMBOL>                Add a symbolic file
    -F, --fuzz <fuzz>                         Generate testcases and write to supplied dir
    -H, --hook <ADDR> <EXPR>                  Hook the provided address with an ESIL expression
    -i, --include <SYMBOL> <EXPR>             Assert symbol contains a string
    -L, --libs <libs>...                      Load libraries from path
        --max <max>                           Maximum number of states to keep at a time
    -m, --merge <merge>...                    Set address as a mergepoint
    -I, --not-include <SYMBOL> <EXPR>         Assert symbol does not contain a string
    -p, --path <path>                         Path to the target binary
    -r, --r2-cmd <CMD>...                     Run r2 command on launch
    -S, --set <REG/ADDR> <VALUE> <BITS>       Set memory or register values
    -s, --symbol <NAME> <BITS>                Create a symbolic value
```

The only required argument is `--path` (or `-p`) and the default behaviour of `radius2` is simply to begin execution from an `entry_state`, a state at the entrypoint of the program and run until the program exits, so `radius2 -p /bin/ls` will run, print nothing, and finish. To see what is "going on" the `-v` option can be used to view the instructions as they execute (`-V` will output with color)

```
$ radius2 -p /bin/ls -v
0000000100003f00:  pacibsp                                  |  
0000000100003f04:  stp x28, x27, [sp,  -0x60]!              |  96,sp,-=,x28,sp,=[8],x27,sp,8,+,=[8]
...
0000000100007154:  mov w0,  0x1                             |  0x1,w0,=
0000000100007158:  bl sym.imp.exit                          |  pc,lr,=,4294997208,pc,=
00000001000074d8:  adrp x17, 0x100008000                    |  4295000064,x17,=

```

The string on the right is ESIL, the intermediate language that is actually being executed by radius. It will be explained more below. By default no libraries are loaded and standard c functions are emulated (see the contents of `radius/sims/libc.rs`).

## Symbolic Values

Symbolic values can be defined with `-s <name> <length in bits>[n]` where n is appended to the bits in order to force printing the value as a number after evaluation. 

`stdin` is a special name that is automatically treated as the content of stdin, equivalent to `-s stdin 32 -f 0 stdin` (numeric file names are treated as file descriptors). See below for more information on input. A simple crackme can be solved as easily as 

```
$ radius2 -p r100 -s stdin 96 -X Incorrect

  stdin : "Code_Talkers"

```

## Guiding Execution

In order to reach a desired program state the user can set places to avoid or to complete execution. The user can also provide hooks to manipulate the state when it reaches an address. If no breakpoints or hooks are provided the symbolic execution will return the first state that finishes execution (eg. returns from `main`). 

The `-X` option tells radius2 to avoid any addresses that contain XREFs to a string containing the argument. States that reach avoided address are discarded and the first state to finish execution without being discarded is used to evaluate the symbolic values. Addresses to avoid can be manually set like `-x 0x400855`, the addresses can be in decimal or hex (or octal or binary if you wanna get real nuts), can include symbols and even be offsets from symbols like 

```
$ radius2 -p r100 -s stdin 96 -x main+109
```

Conversely breakpoints, target addresses where execution should stop and evaluate, can be set with `-b` and string xref breakpoints with `-B` so `radius2 -p r100 -s stdin 96 -B Nice` also works.  

## Program Input and Output

The user can set symbolic `argv` values using the symbol name, like `sym` in `-A progname sym`. Additionally symbolic file contents are created using `-s sym 4096 -f /path/to/file sym`. For both `-f` and `-A` any string which has not been defined as a symbol name will simply be that string. Files that are not supplied will be read from the real filesystem, but will never be written to. An example of these and other features is the solution to `unbreakable`

```bash
$ radius2 -p unbreakable -s flag 408 -c flag 'CTF{' -B 'Thank you' -z -A . flag

  flag : "CTF{0The1Quick2Brown3Fox4Jumped5Over6The7Lazy8Fox9}"

```

This example also constrains the first four bytes of `flag` to be "CTF{" with `-c` and passes `-z` to enable lazy solving, which will significantly speed up runtime (from 1 second down to 0.4 or so). In some cases string XREFs may not be found, in this case try passing `-r aae` which will tell r2 to emulate the program to find additional references. 

In this example the `-A . flag` arguments are actually not necessary as by default if a symbolic value hasn't been written into the program somehow it will be automatically set as `argv[1]`.

It is also possible to directly set register and memory values with `-S <reg or addr> <value> <length in bits>`.

The output of the program to `stdout` and `stderr` can also be dumped after the execution finishes using the `-1` and `-2` options respectively. This is helpful when checking whether the output of the program matches the expected result corresponding to the evaluated symbols. 

## State Merging

More complicated code may require state merging to finish in a reasonable time like in this example where `0x004007ba` is designated as a merge point

```
$ radius2 -p r200 -s stdin 48 -X Incorrect -m 0x004007ba

  stdin : "rotors"

```

State merging is the process of taking multiple program states that have reached the same point in code and combining them in order to prevent "state explosion". This occurs when eg. loops with symbolic conditions lead to exponential growth in the number of states being executed by the engine. In the example above this is prevented by setting a mergepoint at `0x004007ba` so that when a state reaches this address it is merged with the previous states at this address. The values of this state are combined based on the path constraints so if `eax` was `x` in state `s1` and `y` in state `s2` then the merged `eax` will now have the symbolic value `if(<s1 constraints>, x, if(<s2 constraints>, y, ...))`

In general state merging is often helpful in between loops where both loops have a symbolic condition that will result in `n` new states, for a total of `n**2` states after the second loop. When `n` is large this can result in huge numbers of states that will exhaust the memory of the host and take forever to execute one at a time. 

This is the case for the `r200` example above. Without state merging the execution will not complete in any reasonable time, but with a mergepoint between the two loops at `0x004007ba` it takes ~0.1 seconds!

```c
                  |    do {
    0x00400811    |        if (iStack_58 != 5 && SBORROW4(iStack_58, 5) == iStack_58 + -5 < 0) {
    0x00400813    |            iStack_58 = 0;
    0x00400830    |            while( true ) {
    0x00400841    |                if (iStack_58 != 5 && SBORROW4(iStack_58, 5) == iStack_58 + -5 < 0) {
    0x00400849    |                    return 0;
                  |                }
    0x00400830    |                if (*(aiStack_48 + iStack_58 * 4) != *(aiStack_28 + iStack_58 * 4)) break;
    0x00400839    |                iStack_58 = iStack_58 + 1;
                  |            }
    0x00400849    |            return 1;
                  |        }
    0x004007ba    |        uStack_54 = 0;
    0x004007fb    |        for (puStack_50 = *0x601080; puStack_50 != NULL; puStack_50 = *(puStack_50 + 2)) {
    0x004007dd    |            if (*(puStack_50 + 1) == *(iStack_60 + iStack_58)) {
    0x004007e3    |                uStack_54 = *puStack_50;
    0x004007e8    |                break;
                  |            }
                  |        }
    0x00400805    |        *(aiStack_48 + iStack_58 * 4) = uStack_54;
    0x00400809    |        iStack_58 = iStack_58 + 1;
    0x00400809    |    } while( true );
```

The above code is from `r2ghidra`, specifically the `pdgo` command which shows the offsets along with the decompiler output

Sometimes it will be clear when state merging can help, like this example. Other times its less clear and I generally just try random addresses that I think might work. 

## Test case generation 

`radius2` also has a basic testcase generation option, `-F <dir>` which will generate files containing values of the defined symbols for each different execution path. 

```
$ radius2 -p ais3 -s flag 256 -A . flag -F testcases -P
init time:      74039
run time:       194957
instructions:   2226
instr/usec:     0.011418
generated:      5
total time:     269024
$ ls testcases 
flag0000 flag0001 flag0002 flag0003 flag0004 flag0005
$ cat testcases/flag0005
ais3{I_tak3_g00d_n0t3s}
```

Here the `-P` option causes `radius2` to print out some profiling information. Times are measured in microseconds so it took 0.27 seconds to explore every path of the program and generate the 5 unique testcases that traverse each one. The flag value is contained in the last one (it usually is). 

## Adding Constraints

In the `unbreakable` example above we added an additional constraint onto the `flag` value with `-c flag 'CTF{'`. This argument constrains the first four characters of `flag` to be `CTF{`, however its also possible to use `-c` to constrain the bytes of a symbol to ranges, with eg. `-c flag '[a-zA-Z]'`. The syntax should look familiar as it is the same as the `[...]` regular expression. For example this IDA ctf challenge had the additional requirement that the bytes be printable, which can be quickly accomplished with the range `[ -~]`

```bash
$ radius2 -p chal -s flag 192 -c flag '[ -~]' -b 0x1610  

  flag : "Fr33_M4dam3-De/M4inten0n"

```

In addition to a symbolic value provided by the user, `-c` and `-C` can constrain register and file contents. This is particularly useful when a desired value should be found in a file or standard out after the symbolic execution finishes, as in the example of `ollvm`

```bash
$ radius2 -Np ollvm -s hex 128 -C1 'Output: 875cd4f2e18f8fc4'

  hex : "6d6972726F725f6d"

$ rax2 -s 6d6972726F725f6d # hex decode for flag bytes
mirror_m
```

The `-C` argument adds a constraint **after** execution. Here the first argument is a file descriptor `1` which denotes `stdout` and can be used to constrain the symbolic bytes of the output to the desired string. 

This example in particular shows the power of `radius2`. It has symbolic function summaries of many common functions, including `scanf` and `printf` which allows it to read the symbol as hex, transform it with 17k obfuscated instructions, and then print the reencoded bytes to `stdout`. Even with all of these operations the total time to execute and solve is less than 4 seconds. 

## Hooking with ESIL

Potentially the most powerful feature of `radius2` is the ability to quickly write arbitrary hooks with ESIL, the Evaluable String Intermediate Language of `radare2`. The `r200` example could also be solved using 

```bash
$ radius2 -p r200 -s stdin 48 -m 0x4007ba -H 0x400849 'eax,!,?{,stdin,.,}'
000000000040084a: 0x000073726f746f72 "rotors\u{0}\u{0}"
```

Instead of placing breakpoints or avoidpoints, this example hooks the address `0x400849` so that when reached by a state the expression `eax,!,?{,stdin,.,}` will be executed. This address is at the end of the validation function which is 0 when the input is correct. ESIL is a simple stack based VM that pushes values to a stack and has operators that pop them off and push the results. Here `eax` is pushed to the stack, then `!` pops it off and pushes its boolean negation (so pushing 1 if `eax` is 0, 0 otherwise). Next `?{` is a conditional that executes the expression between the brackets if the popped value is nonzero, and `stdin,.` simply evaluates and prints `stdin`. A table of ESIL operators can be viewed by running `ae??` in r2 and is reproduced below 


```
 =       assign updating internal flags
 :=      assign without updating internal flags
 +=      A+=B => B,A,+=
 +       A=A+B => B,A,+,A,=
 ++      increment, 2,A,++ == 3 (see rsi,--=[1], ... )
 --      decrement, 2,A,-- == 1
 *=      A*=B => B,A,*=
 /=      A/=B => B,A,/=
 %=      A%=B => B,A,%=
 &=      and ax, bx => bx,ax,&=
 |       or r0, r1, r2 => r2,r1,|,r0,=
 !=      negate all bits
 ^=      xor ax, bx => bx,ax,^=
 []      mov eax,[eax] => eax,[],eax,=
 =[]     mov [eax+3], 1 => 1,3,eax,+,=[]
 =[1]    mov byte[eax],1 => 1,eax,=[1]
 =[8]    mov [rax],1 => 1,rax,=[8]
 []      peek from random position
 [N]     peek word of N bytes from popped address
 [*]     peek some from random position
 =[*]    poke some at random position
 $       int 0x80 => 0x80,$
 $$      simulate a hardware trap
 ==      pops twice, compare and update esil flags
 <       compare for smaller
 <=      compare for smaller or equal
 >       compare for bigger
 >=      compare bigger for or equal
 >>=     shr ax, bx => bx,ax,>>=  # shift right
 <<=     shl ax, bx => bx,ax,<<=  # shift left
 >>>=    ror ax, bx => bx,ax,>>>=  # rotate right
 <<<=    rol ax, bx => bx,ax,<<<=  # rotate left
 ?{      if popped value != 0 run the block until }
 POP     drops last element in the esil stack
 DUP     duplicate last value in stack
 NUM     evaluate last item in stack to number
 SWAP    swap last two values in stack
 TRAP    stop execution
 BITS    16,BITS  # change bits, useful for arm/thumb
 TODO    the instruction is not yet esilized
 STACK   show contents of stack
 CLEAR   clears the esil stack
 REPEAT  repeat n times
 BREAK   terminates the string parsing
 SETJT   set jump target
 SETJTS  set jump target set
 SETD    set delay slot
 GOTO    jump to the Nth word popped from the stack
 $       esil interrupt
 $z      internal flag: zero
 $c      internal flag: carry
 $b      internal flag: borrow
 $p      internal flag: parity
 $s      internal flag: sign
 $o      internal flag: overflow
 $ds     internal flag: delay-slot
 $jt     internal flag: jump-target
 $js     internal flag: jump-target-set
 $$      internal flag: pc address
```

In addition to these operators `radius2` adds a few special ones

```
 .       print an evaluated value
 ..      print a debug value (unevaluated AST)
 _       constrain popped value to be nonzero
 _+      push solver constraints
 _-      pop solver contraints
 !!      set the state as if a breakpoint was hit
 !_      set the state as if an avoidpoint was hit
```

As noted above ESIL is also what all instructions are lifted into so it can be instructive to read the expressions in the verbose output. Since ESIL can define any instruction it is essentially possible to do nearly anything with an ESIL hook. 

## Faster Execution

The defaults of the `radius2` rust API are set so that the symbolic execution is as fast as possible. On the other hand the `radius2` CLI utility has defaults that are more reliable but may be a bit slower. 

In order to speed up execution the `-z` option will set the engine to check satisfiability as little as possible. This can often lead to significantly reduced run times but may also increase the chance of state explosion.

Additionally if the target does not include self-modifying code the `-N` argument can be used which will allow reading many instructions at a time and optimizing the instructions by performing some dead code elimination. 

Finally it is often useful to add more avoidpoints than is strictly necessary. By adding more and by placing them as early as possible in execution it can cut down on wasted execution of undesired states. 

## Other stuff 

Uhhhhhhh what else? `radius2` can initialize states from a process running in a local or remote debugger so `radius2 -p dbg://192.168.1.123:5555 -a addr -s sym 64 num -S x0 sym 64` will place a breakpoint and once hit will initiallize the state with the current context of the debuggee, set the register `x0` to a symbolic value, and then start symbolic execution. This can also be done with frida so `radius2 -p frida://usb/attach//wpa_supplicant -a free ...` will set a hook on `free` and when the hook is hit will initialize an exact state of the current process. You can even use `radius2` on a process running in `qemu` or attached via JTAG with `gdb://`.

## Conclusion

In a blog post Trail of Bits described its symbolic execution tool `manticore` with the expression "there's more than one way to skin a cat" and called `manticore` a "cat skinning machine". As `radius2` is orders of magnitude faster, works on more architectures and file formats, and is even more flexible than `manticore`, `radius2` should be thought of as a Cat-Skinning Optimus Prime. 



```

`tests/hello.c`:

```c
#include<stdio.h>

int main() {
	puts("hello\n");
	return 0;
}

```

`tests/looper.c`:

```c
#include<stdio.h>

int main() {
	int x = 1;
	for(int i=0; i < 0x10000; i++) {
		x += i;
		if (x > 0x1337) {
			x -= 0x1337;
		}
	}
	return x;
}

```

`tests/strstuff.c`:

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main(int argc, char** argv) {
	char str[64];
	strcpy(str, argv[1]);
	if (strcmp(str, "p4s5w0rd") == 0) {
		puts("nice one!");
		return 0;
	} else {
		puts("lame one!");
		return 1;
	}
}

```

`tests/sys.c`:

```c
#include <stdlib.h>
#include <unistd.h>

void main() {
	char input[16];
	syscall(3, 0, input, 16);
	syscall(0, 0);
}

```