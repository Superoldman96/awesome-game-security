Project Path: arc_gmh5225_pyda_aqg69icy

Source Tree:

```txt
arc_gmh5225_pyda_aqg69icy
├── CMakeLists.txt
├── Dockerfile
├── LICENSE
├── README.md
├── bin
│   ├── pyda
│   └── pyda-attach
├── examples
│   ├── cmplog.py
│   ├── heap.py
│   ├── ltrace.py
│   ├── ltrace_multithreaded.py
│   ├── resolve_indirect_calls.py
│   ├── simple.py
│   └── strace.py
├── lib
│   └── pyda
│       ├── __init__.py
│       ├── arch.py
│       ├── base.py
│       ├── hacks
│       │   ├── gdb.py
│       │   ├── pls_no_signal.py
│       │   ├── pwndbg_compat.py
│       │   └── signal.py
│       ├── process.py
│       └── tube.py
├── patches
│   ├── cpython-3.10.12.patch
│   ├── dynamorio-10.0.patch
│   └── make_patches.sh
├── pyda_core
│   ├── CMakeLists.txt
│   ├── privload.h
│   ├── pyda_core.c
│   ├── pyda_core.h
│   ├── pyda_core_py.c
│   ├── pyda_core_py.h
│   ├── pyda_patch_python.c
│   ├── pyda_threads.c
│   ├── pyda_threads.h
│   ├── pyda_unwind.c
│   ├── tool.c
│   └── util.h
└── tests
    ├── err_hook.py
    ├── err_invalidhook.py
    ├── err_norun.py
    ├── err_thread_entry.py
    ├── eval
    │   ├── malloc1.c
    │   ├── malloc1000.c
    │   ├── malloc100000.c
    │   ├── malloc1000000.c
    │   ├── malloccount_libdebug.py
    │   ├── malloccount_pyda.py
    │   └── run_eval.py
    ├── run_tests.py
    ├── simple.c
    ├── test_blocking1.py
    ├── test_blocking2.py
    ├── test_blocking3.py
    ├── test_blocking4.py
    ├── test_call.c
    ├── test_call.py
    ├── test_fork.c
    ├── test_hugeio.c
    ├── test_hugeio.py
    ├── test_io.c
    ├── test_io1.py
    ├── test_io2.py
    ├── test_longrunning.c
    ├── test_longrunning_multithread.c
    ├── test_pwntools.py
    ├── test_python_threading.py
    ├── test_regs_x86.py
    ├── test_segv.c
    ├── test_segv.py
    ├── test_syscall.py
    ├── test_thread_blocking.py
    ├── thread_10.c
    ├── thread_1000.c
    └── thread_nojoin.c

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

project(dynamorio_python VERSION 0.4.0)

add_subdirectory(pyda_core)

```

`Dockerfile`:

```
FROM ubuntu:22.04

RUN apt update && DEBIAN_FRONTEND=noninteractive apt install -y wget python3-pip python3-dev build-essential cmake gdbserver gdb tmux zsh git \
      cmake g++ doxygen git zlib1g-dev libunwind-dev libsnappy-dev liblz4-dev \
      build-essential gdb lcov pkg-config \
      libbz2-dev libffi-dev libgdbm-dev libgdbm-compat-dev liblzma-dev \
      libncurses5-dev libreadline6-dev libsqlite3-dev libssl-dev \
      lzma lzma-dev tk-dev uuid-dev zlib1g-dev && \
      rm -rf /var/lib/apt/lists/*

# install openssl to make python happy
RUN cd /usr/src/ && \
      wget https://www.openssl.org/source/openssl-1.1.1v.tar.gz && \
      tar xf openssl-1.1.1v.tar.gz && \
      rm openssl-1.1.1v.tar.gz && \
      cd openssl-1.1.1v/ && \
      ./config --prefix=/usr/local && \
      make -j && make install_sw && \
      rm -rf /usr/src/openssl-1.1.1v/

# install python
COPY patches/cpython-3.10.12.patch /tmp/cpython-3.10.12.patch
RUN mkdir /opt/custom-python/ && \
      mkdir /opt/custom-python-root/ && \
      cd /opt/custom-python/ && \
      wget https://github.com/python/cpython/archive/refs/tags/v3.10.12.tar.gz && \
      tar xf v3.10.12.tar.gz && rm v3.10.12.tar.gz && \
      mv /tmp/cpython-3.10.12.patch /opt/custom-python/cpython-3.10.12/ && \
      cd /opt/custom-python/cpython-3.10.12/ && git apply cpython-3.10.12.patch && \
      cd /opt/custom-python/cpython-3.10.12/ && \
      ./configure --prefix=/opt/custom-python-root/ --with-ensurepip=install --enable-shared --with-openssl=/usr/local/ --with-openssl-rpath=auto && \
      make install -j && \
      rm -rf /opt/custom-python/

ARG PYDA_DEBUG=0

# install dynamorio
COPY patches/dynamorio-10.0.patch /tmp
RUN git clone --recurse-submodules -j4 https://github.com/DynamoRIO/dynamorio.git /opt/dynamorio && cd /opt/dynamorio/ && git checkout release_10.0.0  && \
      cd /opt/dynamorio/ && \
      git apply /tmp/dynamorio-10.0.patch && \
      rm /tmp/dynamorio-10.0.patch && \
      mkdir /opt/dynamorio-install/ && \
      mkdir build && cd build && bash -c 'cmake -DDEBUG=$([ "$PYDA_DEBUG" == "1" ] && echo "ON" || echo "OFF") -DCMAKE_INSTALL_PREFIX=/opt/dynamorio-install/ ..' && \
      make -j && make install && \
      rm -rf /opt/dynamorio/ && \
      touch /opt/dynamorio-install/CMakeCache.txt

ENV DYNAMORIO_HOME=/opt/dynamorio-install/
ENV PYTHONHOME=/opt/custom-python-root/
ENV PYTHONPATH=/opt/custom-python-root/lib/python3.10/:/opt/pyda/lib

COPY ./ /opt/pyda/
WORKDIR /opt/pyda
RUN mkdir build && cd build && \
      bash -c 'CMAKE_PREFIX_PATH=/opt/dynamorio/build/cmake cmake -DCMAKE_BUILD_TYPE=$([ "$PYDA_DEBUG" == "1" ] && echo "Debug" || echo "Release") -DDynamoRIO_DIR=$DYNAMORIO_HOME/cmake -DPython3_EXECUTABLE=$PYTHONHOME/bin/python3 -DPython3_ROOT_DIR=/opt/custom-python-root/  ..' && \
      make -j

ENV PATH=$PATH:/opt/pyda/bin
WORKDIR /tmp

RUN git clone https://github.com/pwndbg/pwndbg.git && \
    cd pwndbg && git checkout cada600b0f2be0e2873465f59cc9c4c31425951a && \
    sed -i 's/signal.signal/__import__("pls_no_signal").signal/' pwndbg/__init__.py && \
    pip3 install -e .

WORKDIR /opt/pyda

ARG PYDA_GEF=0
RUN bash -c 'if [[ "$PYDA_GEF" = "1" ]]; then \
    apt update && apt install -y file; \
    PYTHONPATH= PYTHONHOME= bash -c "$(wget https://raw.githubusercontent.com/hugsy/gef/main/scripts/gef.sh -O -)"; \
    fi'

RUN pip3 install pwntools

ARG EVAL=0
RUN bash -c 'if [[ "$EVAL" = "1" ]]; then \
    apt update && apt install -y python3 python3-dev libdwarf-dev libelf-dev libiberty-dev linux-headers-generic libc6-dbg; \
    pip3 install libdebug; \
    fi'


```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Andrew Haberlandt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

CPython available under the PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2,
duplicated below. Dynamorio is available primarily under the BSD
license, duplicated below.

===========================================================================

PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2
--------------------------------------------

1. This LICENSE AGREEMENT is between the Python Software Foundation
("PSF"), and the Individual or Organization ("Licensee") accessing and
otherwise using this software ("Python") in source or binary form and
its associated documentation.

2. Subject to the terms and conditions of this License Agreement, PSF hereby
grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
analyze, test, perform and/or display publicly, prepare derivative works,
distribute, and otherwise use Python alone or in any derivative version,
provided, however, that PSF's License Agreement and PSF's notice of copyright,
i.e., "Copyright (c) 2001-2024 Python Software Foundation; All Rights Reserved"
are retained in Python alone or in any derivative version prepared by Licensee.

3. In the event Licensee prepares a derivative work that is based on
or incorporates Python or any part thereof, and wants to make
the derivative work available to others as provided herein, then
Licensee hereby agrees to include in any such work a brief summary of
the changes made to Python.

4. PSF is making Python available to Licensee on an "AS IS"
basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT
INFRINGE ANY THIRD PARTY RIGHTS.

5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS
A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,
OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

6. This License Agreement will automatically terminate upon a material
breach of its terms and conditions.

7. Nothing in this License Agreement shall be deemed to create any
relationship of agency, partnership, or joint venture between PSF and
Licensee.  This License Agreement does not grant permission to use PSF
trademarks or trade name in a trademark sense to endorse or promote
products or services of Licensee, or any third party.

8. By copying, installing or otherwise using Python, Licensee
agrees to be bound by the terms and conditions of this License
Agreement.

===========================================================================
Primary DynamoRIO License: BSD

All of DynamoRIO except certain portions called out in subsequent sections
on this page is licensed under the following BSD license:

Copyright (c) 2010-2024 Google, Inc. licensed under the terms of the BSD.  All other rights reserved.

Copyright (c) 2000-2009 VMware, Inc. licensed under the terms of the BSD.  All other rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of VMware, Inc. nor the names of its contributors may be
  used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

===========================================================================
libelftc License

The drsyms Extension contains libelftc code
(http://elftoolchain.sourceforge.net/) in binary form for obtaining file
and line information from DWARF2 debug information on Linux and
Cygwin/MinGW.  That libelftc code has the following copyright and license:

Copyright (c) 2006-2012 Kai Wang, Joseph Koshy, et al.
Copyright (c) 1990-2005 The Regents of the University of California, et al.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

===========================================================================
Certain Extensions are instead under the LGPL 2.1 License

The drwrap and drutil Extensions, along with Dr. Memory and all of its
libraries in the Dr. Memory Framework (if packaged with DynamoRIO), are
licensed under the LGPL 2.1 License and NOT the BSD license used for the
rest of DynamoRIO.  These Extensions are provided as libraries distinct
from the rest of DynamoRIO.  The details of this license are below:

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation;
version 2.1 of the License, and no later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

===========================================================================
The drsyms Extension is linked with elfutils libraries under the LGPL 3 License

The drsyms Extension on Linux is linked with static libraries from the
elfutils project.  The source code for elfutils is available at
git://sourceware.org/git/elfutils.git.  We choose the LGPL 3 license
(elfutils offers that as a choice) for our use of these libraries.  The
drsyms Extension and the elfutils static libraries are provided as
libraries distinct from the rest of DynamoRIO.  The details of the LGPL 3
license are below:

                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

===========================================================================
The valgrind.h and memcheck.h files in third_party/valgrind/ are also BSD
but with 4 clauses:

  Copyright (C) 2000-2013 Julian Seward.  All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. The origin of this software must not be misrepresented; you must
      not claim that you wrote the original software.  If you use this
      software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   3. Altered source versions must be plainly marked as such, and must
      not be misrepresented as being the original software.

   4. The name of the author may not be used to endorse or promote
      products derived from this software without specific prior written
      permission.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

===========================================================================

```

`README.md`:

```md
Pyda
====

Pyda lets you write dynamic binary analysis tools using Python.

Pyda combines [Dynamorio](https://dynamorio.org)-based instrumentation with a CPython interpreter, allowing you to
"inject" Python code into any x86/ARM64 Linux process, without
going through GDB or ptrace.

Features:
- **Hooks**: Inspect and modify registers
and memory at any instruction.
- **Redirect execution**: Hooks can directly modify the program
counter; for example, to cause a function to return early or to
skip over a tricky branch.
- **Syscall interception**: Syscall pre/post hooks can capture and modify syscall
arguments, and optionally skip the syscall altogether.
- **Package support**: Install and use your favorite packages like
normal using `pip` (e.g. pwntools).
- **Graceful multithreading**: Writing tools for multithreaded programs is easy:
program threads *share* a Python interpreter[*](#multithreading), so you can use globals to
track and aggregate state over several threads (see: [`p.tid`](#api)).


Pyda is a...
- **In-process, scriptable debugger**: Pyda hooks can be used as GDB-style breakpoints
to inspect/modify registers and memory. Several packages (e.g. pwntools) can be used
to look up symbols or parse DWARF info.
- **Reverse engineering tool**: Answer questions like "Where do all these indirect jumps go?" in just a few lines of Python.
- **CTF Tool**: We provide a pwntools-style API for I/O (a Pyda `Process` is actually a pwntools `tube`!), and
new "blocking" APIs like `p.run_until(pc)` which allow you to interleave execution and I/O.

#### Quickstart

```sh
docker run -it ghcr.io/ndrewh/pyda pyda examples/ltrace.py -- ls -al
```


## Example
> [!WARNING]
> This API is not stable and may change. Please provide
> feedback on the API by filing an issue.

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

# Get a handle to the current process
p = process()

# You can use pwnlib to get information about the target ELF
e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

# Define a hook/breakpoint -- this can be at any instruction
def main_hook(p):
    print(f"at main, rsp={hex(p.regs.rsp)}")
    return_addr = p.read(p.regs.rsp, 8)
    print(f"return address: {hex(u64(return_addr))}")

# Register the hook
p.hook(e.symbols["main"], main_hook)

# Tell Pyda we are ready to go!
p.run()
```

```
$ pyda examples/simple.py -- ./challenge 
at main, rsp=0x7fff1303f078
return address: 0x7f3c50420d90
```


### More examples
See [examples/](examples/) for additional examples.

- [`ltrace.py`](examples/ltrace.py): Hook all calls to library functions, and print out their arguments
- [`strace.py`](examples/strace.py): Hook all syscalls and print out their arguments
- [`cmplog.py`](examples/cmplog.py): Hook all `cmp` instructions and print out their arguments
- [`resolve_indirect_calls.py`](examples/resolve_indirect_calls.py): dump a list of indirect calls with `objdump`, and then
print out the targets during execution


## Limitations
- Currently Linux only (please contribute Windows and macOS support!)
- Currently X86_64/ARM64 only (please contribute support for other architectures)
- All of the limitations of Dynamorio apply. (The program must be reasonably well behaved. You should assume a sufficiently motivated program can detect whether it is running under Dynamorio.)
- Some state may be shared with the target process; while Dynamorio
attempts to isolate our libc (and other libraries) from the target, OS structures (e.g. fds)
are shared.

## Getting started

### Install

Suggested use is via Docker.

Pull the latest release:
```sh
docker pull ghcr.io/ndrewh/pyda
```

Or build it yourself:
```sh
docker build -t pyda .
```

(The Pyda image is currently based on `ubuntu:22.04` and we leave the default entrypoint as `/bin/bash`)

### Usage
```sh
pyda <script_path> [script_args] -- <bin_path> [bin_args]
```

"Hello World" example: `ltrace` over `/bin/ls`
```sh
pyda examples/ltrace.py -- ls
```
### API

You can view all of the available APIs in [process.py](https://github.com/ndrewh/pyda/blob/master/lib/pyda/process.py), but in summary:

Read/Modify Memory and Registers:

```py
# Read memory
p.read(0x100000, 8) # 8 bytes (bytes)
p.mem[0x100000] # 1 byte (int)
p.mem[0x100000:0x100008] # 8 bytes (bytes)

# Write memory
p.write(0x100000, b"\x00" * 8)
p.mem[0x100000:0x100008] = b"\x00" * 8

# Read registers
p.regs.rax # (int)

# Write registers
p.regs.rax = 0x1337133713371337
```

Hooks:

```py
# Hooks (functions called before executing the instruction at the specified PC)
p.hook(0x100000, lambda p: print(f"rsp={hex(p.regs.rsp)}"))

# New thread events: called when a new thread starts (just before entrypoint)
p.set_thread_entry(lambda p: print(f"tid {p.tid} started")) # Called when a new thread is spawned

# Syscall hooks: called for a specific syscall (specified by the first arg)
# as a pre (before syscall) or post (after syscall) hook.
#
# Pre-syscall hooks can optionally return False to skip the syscall.
# In this case, you are responsible for setting the return value
# (e.g. with p.regs.rax = 0). Returning any value other than False (or not
# returning anything at all) will still run the syscall.
p.syscall_pre(1, lambda p, syscall_num: print(f"write about to be called with {p.regs.rdx} bytes"))
p.syscall_post(1, lambda p, syscall_num: print(f"write called with {p.regs.rdx} bytes"))
```

Debugger-style "blocking" APIs:
```py
# Resumes the process until completion
p.run()

# Resumes the process until `pc` is reached
p.run_until(pc)

# pwntools tube APIs are overloaded:
# recvuntil(x) resumes the process until it reaches a "write" syscall
# that writes matching data
p.recvuntil(bstr)
```

Misc
```py
# Get process base
p.maps["libc.so.6"].base # (int)

# Get current thread id (valid in hooks and thread entrypoint)
p.tid # (int), starts from 1
```

### FAQ

**Why should I use this over GDB or other ptrace-based debuggers?** 

GDB breakpoints incur substantial overhead due to signal handling in the kernel and in
the tracer process.  This introduces an insurmountable
performance challenge for high-frequency breakpoints.
For multithreaded programs, this problem is compounded by
["group-stop"](https://man7.org/linux/man-pages/man2/ptrace.2.html), which will
stop *all* threads when *any* thread receives a stop signal.

Unlike GDB, Pyda hooks are executed directly in the target process itself (without the overhead of signals
or a kernel context switch). As a result, Pyda hooks typically run faster.

**Why should I use this over Frida or other dynamic instrumentation tools?**

These tools are quite similar to Pyda, with mostly ergonomic differences: Pyda tools
are written in Python using a relatively minimal set of [APIs](#api). Pyda relies on the existing Python ecosystem for many features (e.g. ELF parsing).
As a result, Pyda tools are typically shorter and easier to write than equivalent Frida scripts.

However, Pyda is **not** (currently) an adequate replacement for full-fledged dynamic instrumentation
frameworks. We do not provide a fine-grained instrumentation API (e.g.
you cannot insert specific instructions), relying instead on hooks
as the primary unit of instrumentation.

**Can I use `LD_LIBRARY_PATH` on the target?**

Generally, yes. Just
run `pyda` with `LD_LIBRARY_PATH` -- the target uses a normal loader.

**Can I run this tool on itself?**

Probably not. But you ***can*** run the Python interpreter under it.
```
$ pyda <script> -- python3
Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 
```

**Can my scripts parse arguments?**

Yes. Script arguments can be passed before
the `--` when running `pyda`. For example:
```sh
pyda script.py --option1 --option2 -- ls
```

Your script can parse these options like normal
with the `argparse` module.

## How it works

Pyda runs as a [Dynamorio](https://dynamorio.org) tool: `pyda` is just a `drrun` wrapper that runs the application under dynamorio with our tool loaded. Technically,
Pyda is "just" a shared object that links against `libPython`---both of which get loaded into the target process by Dynamorio. However, Dynamorio is designed to support
_targets_ which load the same libraries as required by _tools_ (i.e., by including it's own [private loader](https://dynamorio.org/using.html) for tools).
As you might imagine, it gets a bit messy to run CPython under a nonstandard loader,
and we had to include nontrivial patches for both Dynamorio and CPython to make it all work.
There were also issues with the ["Client Transparency"](https://dynamorio.org/transparency.html)
aspects of Dynamorio: in particular, our tool's threads reside in a different process group than the target itself
(despite residing in the same memory space). This causes problems
with certain concurrency primatives (e.g. `sem_init`/`sem_wait`) that rely on threads being in the same process group.

Dynamorio handles all the nasty low-level details: inserting instrumentation, machine state trasitions to/from hooks, etc. Pyda provides
a CPython extension for registering hooks and proxies machine state modifications to Dynamorio. Pyda itself ends up handling
a lot of edge cases (think: hooks which throw exceptions, hooks which remove themselves, redirect execution, etc.) and nasty error states, especially surrounding thread creation and cleanup.

### Multithreading

While in theory `ptrace` allows threads to be started and stopped independently, most interactive debuggers like GDB automatically suspend *all* threads
when *any* thread reaches a breakpoint (for more infomation, see GDB's `scheduler-locking` option and and the ptrace ["group-stop" documentation](https://man7.org/linux/man-pages/man2/ptrace.2.html)).

Like GDB breakpoints, Pyda hooks are global to all threads. But unlike GDB, hook execution does not interrupt other threads (except as described below).

Programs running under Pyda get a single CPython interpreter, so all threads share the same state (globals). When a hook
is called by a thread, the thread will first acquire the GIL. This effectively serves as a global lock over all hooks, but we may try to eliminate this in a future release.

We maintain a thread-specific
data structure using Dynamorio's TLS mechanism, which allows us to track thread creation/destruction
and report thread-specific information (e.g. `p.tid`) in hooks.

## Contributing

Issues and pull requests are welcome. If reporting an issue with a particular target, please attach the binary.


```

`bin/pyda`:

```
#!/bin/bash

ROOT=$(dirname "$0")/../
PYDA_NO_ATTACH=1 ASAN_OPTIONS=$ASAN_OPTIONS:detect_leaks=0 LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PYTHONHOME/lib/ PYDA_SCRIPT=$1 exec $DYNAMORIO_HOME/bin64/drrun -stack_size 1024K -c $ROOT/build/pyda_core/libtool.so ${@:2}

```

`bin/pyda-attach`:

```
#!/bin/bash

ROOT=$(dirname "$0")/../
PYDA_NO_CAPTURE=1 LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PYTHONHOME/lib/ exec $DYNAMORIO_HOME/bin64/drrun -attach $2 -stack_size 1024K -c $ROOT/build/pyda_core/libtool.so -script $1

```

`examples/cmplog.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64, u32
import string
import sys
import subprocess
from collections import defaultdict

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def get_cmp(proc):
    p = subprocess.run(f"objdump -M intel -d {proc.exe_path} | grep cmp", shell=True, capture_output=True)

    output = p.stdout.decode()
    cmp_locs = {}
    for l in output.split("\n"):
        if len(l) <= 1:
            continue

        # TODO: memory cmp
        if "QWORD PTR" in l:
            continue

        if ":\t" not in l:
            continue

        cmp_locs[int(l.split(":")[0].strip(), 16)] = l.split()[-1]

    return cmp_locs

cmp_locs_unfiltered = get_cmp(p)
cmp_locs = {}
for (a, v) in cmp_locs_unfiltered.items():
    info = v.split(",")
    if len(info) != 2:
        continue
    if "[" in info[0] or "[" in info[1]:
        continue

    if "0x" in info[0] or "0x" in info[1]:
        continue

    cmp_locs[a] = info

print(f"cmp_locs: {len(cmp_locs)}")

eq_count = 0
neq_count = 0
reg_map = {
    "eax": "rax",
    "ebx": "rbx",
    "ecx": "rcx",
    "edx": "rdx",
    "esi": "rsi",
    "edi": "rdi",
    "ebp": "rbp",
    "esp": "rsp",
    "r8d": "r8",
}

counts_by_pc = defaultdict(int)
good_cmps = defaultdict(int)
def cmp_hook(p):
    global eq_count, neq_count
    info = cmp_locs[p.regs.pc - e.address]

    counts_by_pc[p.regs.pc - e.address] += 1

    reg1 = reg_map.get(info[0], info[0])
    reg2 = reg_map.get(info[1], info[1])
    r1 = p.regs[reg1]
    r2 = p.regs[reg2]
    eq = r1 == r2

    if eq:
        eq_count += 1
    else:
        neq_count += 1

    print(f"cmp @ {hex(p.regs.rip - e.address)} {reg1}={hex(r1)} {reg2}={hex(r2)} {eq}")

for x in cmp_locs:
    p.hook(e.address + x, cmp_hook)

p.run()

```

`examples/heap.py`:

```py
from pwn import *
from pyda import *

import pwndbg # must come after pyda import, i think
from termcolor import colored, cprint

import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc.address = p.maps[libc.path].base

sym_map = {
    libc.symbols["malloc"]: "malloc",
    libc.symbols["free"]: "free",
    libc.symbols["realloc"]: "realloc",
}

# todo: use dwarf to figure out where tcache pointer is in tls?
# print(f"dwarf: {libc.dwarf}")

def heap_hook(p):
    name = sym_map[p.regs.rip]

    print(f"{name}(" + ", ".join([
        f"rdi={hex(p.regs.rdi)}",
    ]) + ")")

def after_heap_hook(p):
    heap = pwndbg.heap.current
    tcachebins = heap.tcachebins()
    if tcachebins is not None:
        for (s, b) in tcachebins.bins.items():
            if len(b.fd_chain) < 2:
                continue
            print(f"tcache {colored(hex(s), 'yellow')}: ", end="")
            print(colored(' -> ', 'yellow').join([hex(x) for x in b.fd_chain]))

        print()
    else:
        print("heap not initialized yet?")
    

for sym in sym_map:
    p.hook(sym, heap_hook)
    p.hook_after_call(sym, after_heap_hook)

p.run()
```

`examples/ltrace.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def guess_arg(x):
    printable_chars = bytes(string.printable, 'ascii')

    # Is pointer?
    if x > 0x100000000:
        try:
            data = p.read(x, 0x20)
            if all([c in printable_chars for c in data[:4]]):
                return str(data[:data.index(0)])
        except:
            pass
    
    return hex(x)

def lib_hook(p):
    name = plt_map[p.regs.pc]
    print(f"{name}(" + ", ".join([
        f"rdi={guess_arg(p.regs.arg1)}",
        f"rsi={guess_arg(p.regs.arg2)}",
        f"rdx={guess_arg(p.regs.arg3)}",
        f"rcx={guess_arg(p.regs.arg4)}",
    ]) + ")")

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

p.run()

```

`examples/ltrace_multithreaded.py`:

```py
# This is basically just ltrace.py but we also print the thread number
# and print a message when threads are created.

from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def guess_arg(x):
    printable_chars = bytes(string.printable, 'ascii')

    # Is pointer?
    if x > 0x100000000:
        try:
            data = p.read(x, 0x20)
            if all([c in printable_chars for c in data[:4]]):
                return str(data[:data.index(0)])
        except:
            pass
    
    return hex(x)

def lib_hook(p):
    name = plt_map[p.regs.rip]
    print(f"[thread {p.tid}] {name}(" + ", ".join([
        f"rdi={guess_arg(p.regs.rdi)}",
        f"rsi={guess_arg(p.regs.rsi)}",
        f"rdx={guess_arg(p.regs.rdx)}",
        f"rcx={guess_arg(p.regs.rcx)}",
    ]) + ")")

def thread_entry(p):
    print(f"thread_entry for {p.tid}")

p.set_thread_entry(thread_entry)

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

p.run()
```

`examples/resolve_indirect_calls.py`:

```py
from pyda import *
import sys
import subprocess

p = process()

BASE = p.maps[p.exe_path].base

def u64(data):
    return int.from_bytes(data, "little")

def get_calls(proc):
    p = subprocess.run(f"objdump -M intel -d {proc.exe_path} | grep call", shell=True, capture_output=True)

    output = p.stdout.decode()
    call_locs = {}
    ind_call_locs = {}
    for l in output.split("\n"):
        if len(l) <= 1:
            continue
        if "QWORD PTR" in l and l.endswith("]"):
            addr = int(l.split(":")[0].strip(), 16)
            lol = "".join(l.split(":")[1].split("[")[1].split("]")[0])
            if '+' in lol:
                reg, off = lol.split("+", 1)
            else:
                reg, off = lol, "0"

            try:
                off = int(off, 0)
            except:
                continue

            ind_call_locs[addr] = (reg, off)
        elif l.split()[-2] == "call":
            call_locs[int(l.split(":")[0].strip(), 16)] = l.split()[-1]
        
    return call_locs, ind_call_locs


call_locs, ind_call_locs = get_calls(p)

def call_reg(p):
    reg = call_locs[p.regs.rip - BASE]
    rax = p.regs[reg]
    print(f"call {hex(p.regs.rip - BASE)} -> {hex(rax - BASE)}")

def ind_call_print(p):
    addr = p.regs.rip - BASE
    reg, off = ind_call_locs[addr]
    reg_val = p.regs[reg]
    mem_target = reg_val + off
    try:
        mem = p.read(mem_target, 8)
        print(f"indcall {hex(addr)} -> {hex(u64(mem) - BASE)}")
    except Exception as e:
        print(e)
        pass

if BASE != 0:
    for c in call_locs:
        p.hook(BASE + c, call_reg)
    
    for c in ind_call_locs:
        p.hook(BASE + c, ind_call_print)

p.run()
```

`examples/simple.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def main_hook(p):
    print(f"at main, rsp={hex(p.regs.rsp)}")
    return_addr = p.read(p.regs.rsp, 8)
    print(f"return address: {hex(u64(return_addr))}")

p.hook(e.symbols["main"], main_hook)
p.run()
```

`examples/strace.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def guess_arg(x):
    printable_chars = bytes(string.printable, 'ascii')

    # Is pointer?
    if x > 0x100000000:
        try:
            data = p.read(x, 0x20)
            if all([c in printable_chars for c in data[:4]]):
                if 0 in data:
                    return str(data[:data.index(0)])
                else:
                    return str(data[:20]) + "..."

        except Exception as e:
            pass
    
    return hex(x)

def syscall_pre_hook(p, num):
    print(f"[syscall {num}] (" + ", ".join([
        f"rdi={guess_arg(p.regs.rdi)}",
        f"rsi={guess_arg(p.regs.rsi)}",
        f"rdx={guess_arg(p.regs.rdx)}",
        f"rcx={guess_arg(p.regs.rcx)}",
    ]) + ")")

for snum in range(500):
    p.syscall_pre(snum, syscall_pre_hook)

p.run()
```

`lib/pyda/__init__.py`:

```py
import sys, os
from .base import *

sys.path.append(os.path.join(os.path.dirname(__file__), 'hacks'))
```

`lib/pyda/arch.py`:

```py

from enum import Enum

ARCH = Enum("Arch", "X86 X64")


def arch():
    # todo: arch detection from dynamorio
    return ARCH.X64

def gdb_arch():
    return {
        ARCH.X86: "i386",
        ARCH.X64: "i386:x86-64",
    }[arch()]

def endianness():
    return "little"

def os():
    return "linux"

def ptrsize():
    return 8

```

`lib/pyda/base.py`:

```py
import pyda_core
from pyda_core import MemoryError, ThreadExitError, InvalidStateError, FatalSignalError
from .process import Process, Map, backtrace_to_str
from . import arch
import sys, os

INIT = False

def process(**kwargs):
    global INIT

    # todo: remove the bogus argument
    proc = Process(pyda_core.process(""), **kwargs)

    if not INIT:
        # by this point, hacks/ is in pythonpath
        import pwndbg_compat

        INIT = True
        if "pwndbg" in sys.modules:
            pwndbg_compat.patch_pwndbg(sys.modules["pwndbg"], proc)

    return proc

def xinfo(addr):
    # print(f"find page: {hex(int(addr))}")
    res = pyda_core.get_module_for_addr(addr)
    # print(f"res: {res}")
    if res is None:
        return None
    path, start, end, perms = res
    return Map(path=path, vaddr=start, size=end - start, perms=perms)

FatalSignalError.__str__ = lambda self: f"Signal {self.args[0]} on Thread {self.args[1]}\nBacktrace:\n{backtrace_to_str(self.args[2])}"

def exit(*args, **kwargs):
    raise RuntimeError("exit")

os._exit = exit
sys.exit = exit

```

`lib/pyda/hacks/gdb.py`:

```py
from types import SimpleNamespace
import pyda
import pyda_core

# This is a compatibility layer for pwndbg

PARAM_BOOLEAN = 133701
PARAM_ZINTEGER = 133702
PARAM_STRING = 133703
PARAM_ENUM = 133704
PARAM_AUTO_BOOLEAN = 133705
COMMAND_USER = 133706
COMPLETE_EXPRESSION = 133707
PARAM_OPTIONAL_FILENAME = 133708
COMMAND_SUPPORT = 133709
TYPE_CODE_STRUCT = 133710

class Parameter():
    def __init__(self, name, type, cls, seq=None):
        pass

events = SimpleNamespace()

class EventRegistry():
    def connect(self, _):
        pass

    pass

def execute(s, to_string=False, from_tty=False):
    if s == "show language":
        return 'The current source language is "auto; currently c".'
    elif s == "show debug-file-directory":
        return 'The directory where separate debug symbols are searched for is "/usr/lib/debug".'
    elif s == "show pagination":
        return 'State of pagination is off.'
    elif s == "help all":
        return 'there-are-no-command-why-are-you-asking-me -- Why?\n'
    elif s == "show endian":
        return f'The target endianness is set automatically (currently little {pyda.arch.endianness()}).'
    elif s == "show architecture":
        return f"The target architecture is set automatically (currently {pyda.arch.gdb_arch()})",
    elif s == "show osabi":
        return {
            "linux": """The current OS ABI is "auto" (currently "GNU/Linux").
The default OS ABI is "GNU/Linux".
"""
        }[pyda.arch.os()]
    elif s == "info win":
        return "No stack."
    elif s.startswith("set "):
        return "The TUI is not active."
    elif s.startswith("handle "):
        return "The TUI is not active."
    else:
        print(f"Failed command: {s}")
        raise NotImplementedError(f"s={s}")

class Type:
    def __init__(self, sz, signed, float=False):
        self.sz = sz
        self.signed = signed
        self.float = float

    def pointer(self):
        return Pointer(self)

    @property
    def sizeof(self):
        return self.sz

    @property
    def alignof(self):
        return self.sz

    def array(self, n):
        return Array(self, n)

    def __eq__(self, other):
        if not isinstance(other, Type):
            return False

        return (
            self.sz == other.sz
            and self.signed == other.signed
            and self.float == other.float
        )

class Pointer(Type):
    def __init__(self, t):
        super().__init__(8, False)
        self._points_to = t

    def __eq__(self, other):
        if not isinstance(other, Pointer):
            return False

        return self._points_to == other._points_to

class Array(Type):
    def __init__(self, t, n):
        super().__init__(t.sz * n, t.signed)
        self._points_to = t
        self._n = n

    def __eq__(self, other):
        if not isinstance(other, Array):
            return False

        return self._points_to == other._points_to and self._n == other._n

    def target(self):
        return self._points_to

class Value:
    def __init__(self, v):
        self.v = v
        self.type = Type(0, False)

    def cast(self, t):
        v = Value(self.v)
        v.type = t
        return v

    def __int__(self):
        assert not isinstance(self.type, Array)
        assert not self.type.float
        if type(self.v) is int:
            return self.v
        elif type(self.v) is bytes:
            return int.from_bytes(self.v, pyda.arch.endianness())
        else:
            raise NotImplementedError(f"Value: {self.v}")

    def __getitem__(self, idx):
        assert isinstance(self.type, Array), f"type: {self.type.__class__} {Array}"
        assert type(self.v) is bytes
        assert idx < self.type._n

        elementsz = self.type.target().sz
        return Value(self.v[idx * elementsz:(idx + 1) * elementsz]).cast(self.type.target())

class Command():
    def __init__(self, name, command_class, completer_class, prefix=None):
        self.name = name
        self.command_class = command_class
        self.prefix = prefix

class Function():
    def __init__(self, name):
        self.name = name

class Breakpoint():
    def __init__(self):
        pass

class error(BaseException):
    def __init__(self, s):
        self.s = s

    def __str__(self):
        return self.s

MemoryError = pyda.MemoryError

VERSION = "12.1"

def lookup_type(s):
    match s:
        case "char":
            return Type(1, True)
        case "short":
            return Type(2, True)
        case "int":
            return Type(4, True)
        case "long":
            return Type(8, True)
        case "long long":
            return Type(8, True)
        case "unsigned char":
            return Type(1, False)
        case "unsigned short":
            return Type(2, False)
        case "unsigned int":
            return Type(4, False)
        case "unsigned long":
            return Type(8, False)
        case "unsigned long long":
            return Type(8, False)
        case "long double":
            return Type(16, True, float=True)
        case "()" | "void":
            return Type(0, False)
        case _:
            print(f"lookup_type: {s}")
            return None
            # raise NotImplementedError(f"cmd: {s}")


events.exited = EventRegistry()
events.cont = EventRegistry()
events.new_objfile = EventRegistry()
events.stop = EventRegistry()
events.start = EventRegistry()
events.new_thread = EventRegistry()
events.before_prompt = EventRegistry()
events.memory_changed = EventRegistry()
events.register_changed = EventRegistry()

class Thread():
    def __init__(self, tid):
        self.tid = tid

    @property
    def global_num(self):
        return self.tid

class Frame():
    def architecture(self):
        return GdbArch(pyda.arch.gdb_arch())

class GdbArch():
    def __init__(self, s):
        self.s = s

    def name(self):
        return self.s

def newest_frame():
    return Frame()

def selected_thread():
    return Thread(pyda_core.get_current_thread_id())

class types():
    def has_field(t, name):
        return name in t.keys()

```

`lib/pyda/hacks/pls_no_signal.py`:

```py
def signal(x, y):
    pass
```

`lib/pyda/hacks/pwndbg_compat.py`:

```py
import pyda_core
from types import SimpleNamespace
from functools import partial

from pathlib import Path
from pwnlib.elf.elf import ELF
import sys
import importlib

# import our fake gdb module
from gdb import Value, Type
import pyda

class GDBLibInfo():
    def __init__(self):
        pass

    def sharedlibrary_paths(self):
        mods = pyda_core.list_modules()
        return mods

class GDBLibFile():
    def __init__(self):
        pass

    def get_file(self, path, **kwargs):
        p = Path(path)
        if p.is_file():
            return str(p)

        return None


class GDBLibSymbol():
    def __init__(self):
        pass

    def static_linkage_symbol_address(self, name):
        return None

    def address(self, name):
        return None

    def get(self, addr):
        res = pyda_core.get_module_for_addr(int(addr))
        if res[0] != 'unknown':
            print(f"WARN: Symbol lookup not implemented {hex(addr)} {res}")

        return None

def get_glibc_section_address(section):
    for l in pyda_core.list_modules():
        if "libc.so" in l:
            elf = ELF(l)
            off = elf.get_section_by_name(section).header.sh_addr
            addr = pyda_core.get_base(l) + off
            print(f"glibc addr: {hex(addr)}")
            return addr

    return None

class GDBLibMemory():
    def __init__(self, proc):
        self._p = proc

    def is_readable_address(self, addr):
        try:
            self._p.read(addr, 1)
            return True
        except:
            return False

    def poi(self, t, addr):
        v = self._p.read(addr, t.sizeof)
        # print(f"poi: {hex(addr)} => {v.hex()}")
        return Value(v).cast(t)

    def u32(self, addr):
        return int.from_bytes(self._p.read(addr, 4), pyda.arch.endianness())

    def i32(self, addr):
        return int.from_bytes(self._p.read(addr, 4), pyda.arch.endianness(), signed=True)

    def u64(self, addr):
        return int.from_bytes(self._p.read(addr, 8), pyda.arch.endianness())

    def s64(self, addr):
        return int.from_bytes(self._p.read(addr, 8), pyda.arch.endianness(), signed=True)

    def pvoid(self, addr):
        assert pyda.arch.ptrsize() == 8
        return self.u64(addr)

    def peek(self, addr):
        return chr(self._p.read(addr, 1)[0])

    def read(self, addr, size):
        return self._p.read(addr, size)



class Page():
    def __init__(self, map: pyda.Map) -> None:
        self._map = map

    @property
    def end(self):
        return self._map.end

    @property
    def start(self):
        return self._map.start

    def __contains__(self, addr):
        return self._map.start <= addr < self._map.end

    @property
    def objfile(self):
        return self._map.path

    @property
    def execute(self):
        return self._map.executable

    @property
    def rw(self):
        return self._map.readable and self._map.writable

    @property
    def rwx(self):
        return self.rw and self.execute

class GDBLibVMMap():
    def __init__(self, proc):
        pass

    def find(self, addr):
        info = pyda.xinfo(int(addr))
        return Page(info)

    def get(self):
        return []

class GDBLibArch():
    def __init__(self, proc):
        pass

    @property
    def endian(self):
        return pyda.arch.endianness()

    @property
    def ptrsize(self):
        return pyda.arch.ptrsize()

    def __getattr__(self, name):
        print(f"Arch: {name}")
        raise AttributeError(f"Arch: {name}")

def patch_pwndbg(pwndbg, proc):
    patch_gdblib(pwndbg.gdblib, proc)
    patch_glibc(pwndbg.glibc)

    pwndbg.heap.ptmalloc.HeuristicHeap.multithreaded = False

    pwndbg.heap.current = pwndbg.heap.ptmalloc.HeuristicHeap()
    pwndbg.heap.current.is_statically_linked = lambda: False

    pwndbg.heap.current.mp
    # pwndbg.heap.resolve_heap(is_first_run=True)

class GDBLibConfig():
    def __init__(self):
        self._d = {}

    def __getattr__(self, name):
        if name == "_d":
            return super().__getattr__(name)
        elif name in self._d:
            return self._d[name]
        else:
            return 0

    def __setattr__(self, name, value):
        if name == "_d":
            super().__setattr__(name, value)
        else:
            self._d[name] = value

class GDBRegs():
    def __init__(self, proc):
        self._p = proc

    def __getattr__(self, name):
        return self._p.regs[name]

def patch_gdblib(gdblib, proc):
    gdblib.info = GDBLibInfo()
    gdblib.file = GDBLibFile()
    gdblib.symbol = GDBLibSymbol()
    gdblib.config = GDBLibConfig()

    old_mem = gdblib.memory
    gdblib.memory = GDBLibMemory(proc)
    gdblib.memory.string = old_mem.string

    gdblib.vmmap = GDBLibVMMap(proc)
    gdblib.regs = GDBRegs(proc)
    # gdblib.arch = GDBLibArch(proc)

def patch_glibc(glibc):
    glibc.get_data_section_address = partial(get_glibc_section_address, ".data")
    glibc.get_got_section_address = partial(get_glibc_section_address, ".got")

```

`lib/pyda/process.py`:

```py
from collections import namedtuple, deque
from dataclasses import dataclass
import ctypes
import ctypes.util
from .tube import ProcessTube
import pyda_core
import sys

class Process(ProcessTube):
    def __init__(self, handle, io=False):
        self._p = handle

        if io:
            fds = self._p.capture_io()
            super().__init__(fds[0], fds[1])
        else:
            super().__init__(None, None)

        self._hooks = {}
        self._syscall_pre_hooks = {}
        self._syscall_post_hooks = {}
        self._registered_syscall_pre_hook = False
        self._registered_syscall_post_hook = False
        self._has_run = False

        self.regs = ProcessRegisters(handle)
        self.mem = ProcessMemory(handle)
        self.maps = ProcessMaps(handle)

        self.exe_path = self._p.get_main_module()

    def _hook_dispatch(self, addr):
        for h in self._hooks[addr]:
            h(self)

    def _syscall_pre_hook_dispatch(self, syscall_num):
        if syscall_num in self._syscall_pre_hooks:
            results = []
            for h in self._syscall_pre_hooks[syscall_num]:
                results.append(h(self, syscall_num))

            if False in results and True in results:
                raise RuntimeError("Cannot have mixed return values from syscall pre-hooks")
            elif False in results:
                return False
            elif True in results:
                return True

    def _syscall_post_hook_dispatch(self, syscall_num):
        if syscall_num in self._syscall_post_hooks:
            for h in self._syscall_post_hooks[syscall_num]:
                h(self, syscall_num)

    def hook(self, addr, callback, priority=False):
        if addr not in self._hooks:
            hook_wrapper = lambda p: self._hook_dispatch(addr)
            self._p.register_hook(addr, hook_wrapper)

            self._hooks[addr] = deque([callback])
        else:
            if priority:
                self._hooks[addr].appendleft(callback)
            else:
                self._hooks[addr].append(callback)

    def unhook(self, addr, callback=None, unregister=True):
        # TODO: Maybe replace this with some kind of hook disabling mechanism
        # (perhaps optimize for hook_after_call use)
        self._hooks[addr] = deque([c for c in self._hooks[addr] if c != callback])

        if (callback is None or len(self._hooks[addr]) == 0) and unregister:
            del self._hooks[addr]
            self._p.unregister_hook(addr)

    def hook_after_call(self, addr, callback):
        def call_hook(p):
            retaddr = int.from_bytes(p.read(p.regs.rsp, 8), "little")
            def after_call_hook(p):
                # print(f"after call to {hex(addr)}")
                callback(p)
                self.unhook(retaddr, after_call_hook, unregister=False)
            self.hook(retaddr, after_call_hook)

        self.hook(addr, call_hook, priority=True)

    def syscall_pre(self, syscall_num, callback):
        if self._has_run:
            raise RuntimeError("Cannot add syscall hooks after process has started")

        if not self._registered_syscall_pre_hook:
            self._p.set_syscall_pre_hook(lambda p, syscall_num: self._syscall_pre_hook_dispatch(syscall_num))
            self._registered_syscall_pre_hook = True

        if syscall_num not in self._syscall_pre_hooks:
            self._syscall_pre_hooks[syscall_num] = [callback]
        else:
            self._syscall_pre_hooks[syscall_num].append(callback)

    def syscall_post(self, syscall_num, callback):
        if self._has_run:
            raise RuntimeError("Cannot add syscall hooks after process has started")

        if not self._registered_syscall_post_hook:
            self._p.set_syscall_post_hook(lambda p, syscall_num: self._syscall_post_hook_dispatch(syscall_num))
            self._registered_syscall_post_hook = True

        if syscall_num not in self._syscall_post_hooks:
            self._syscall_post_hooks[syscall_num] = [callback]
        else:
            self._syscall_post_hooks[syscall_num].append(callback)

    def set_thread_entry(self, callback):
        self._p.set_thread_init_hook(lambda p: callback(self))

    def read(self, addr, size):
        return self._p.read(addr, size)

    def write(self, addr, data):
        return self._p.write(addr, data)

    def __getattr__(self, name):
        if self.regs.has_reg(name):
            raise AttributeError(f"Invalid attribute '{name}'. Did you mean 'regs.{name}'?")
        else:
            raise AttributeError(f"Invalid attribute '{name}'")

    def __setattr__(self, name, value):
        if not name.startswith("_") and name not in ["timeout", "buffer", "closed", "regs", "mem", "maps", "exe_path"]:
            raise AttributeError(f"Cannot set attribute '{name}'")

        super().__setattr__(name, value)

    def run(self):
        self._has_run = True
        self._p.run()

    def run_until(self, addr):
        self._has_run = True
        self._p.run_until_pc(addr)


    @property
    def tid(self):
        # This returns the thread id of the currently executing thread
        return pyda_core.get_current_thread_id()

    # Jumps to "start" and runs until "end" is reached
    # NOTE: This cannot be used from hooks
    def run_from_to(self, start, end):
        self.regs.rip = start
        self.run_until(end)

    # Returns a function that calls into (instrumented) target code
    # NOTE: This cannot be used from hooks
    def callable(self, addr):
        def call(*args):
            if not self._has_run:
                raise RuntimeError("Cannot use callable before first process break (no stack!). Try p.run_until(e.symbols['main']) first")

            self._p.push_state()

            ## BEGIN ARCH-SPECIFIC SETUP
            orig_rip = self.regs.rip

            # Push orig_rip as the return address
            self.regs.rsp &= ~0xf
            self.regs.rsp -= 8
            self.write(self.regs.rsp, orig_rip.to_bytes(8, "little"))

            set_regs_for_call_linux_x86(self, args)
            target_rsp = self.regs.rsp + 8

            self.regs.rip = addr

            # This is a bit hacky, but basically
            # we don't actually know that orig_rip is outside
            # of the function, we just know it's a reasonably
            # safe address. You'll get unexpectedly bad perf
            # if your original RIP is garbage

            count = 0
            try:
                while self.regs.rsp != target_rsp:
                    self.run_until(orig_rip)
                    count += 1
                ## END ARCH-SPECIFIC SETUP

            finally:
                if count > 1:
                    self.warning(f"WARN: Callable should be used from a safe RIP not within the callee.")

                self._p.pop_state()

        return call

    def backtrace(self):
        return backtrace_to_str(self._p.backtrace())

    def backtrace_cpp(self, short=False):
        return backtrace_to_str(self._p.backtrace(), demangle=True, short=short)

def find_any_library(*choices: str) -> str:
    for choice in choices:
        lib = ctypes.util.find_library(choice)
        if lib is not None:
            return lib
    raise LibraryNotFound('Cannot find any of libraries: {}'.format(choices))

try:
    libcxx = find_any_library("stdc++", "c++")
    libcxx = ctypes.CDLL(libcxx)  # On Linux
    cxa_demangle = getattr(libcxx, '__cxa_demangle')
    cxa_demangle.restype = ctypes.c_void_p
except LibraryNotFound:
    libcxx = None

def cxx_demangle(s):
    mangled_name_p = ctypes.c_char_p(s.encode('utf-8'))
    status = ctypes.c_int()
    retval = cxa_demangle(mangled_name_p, None, None, ctypes.pointer(status))

    res = None
    if status.value == 0:
        try:
            res = ctypes.c_char_p(retval).value.decode('utf-8')
        finally:
            pyda_core.free(retval)

    return res

def backtrace_to_str(bt, demangle=False, short=False):
    if demangle:
        if "cxxfilt" not in sys.modules:
            import cxxfilt

        cxxfilt = sys.modules["cxxfilt"]

    s = ""
    for f in bt:
        if demangle and f[3].startswith("_Z"):
            sym = cxx_demangle(f[3])
            if short and len(sym) > 100:
                sym = sym[:50] + "..." + sym[-50:]

            s += f"[{f[1]}+{hex(f[2])}] {sym}\n"
        elif f[2] != 0:
            s += f"[{f[1]}+{hex(f[2])}] {f[3]}\n"
        else:
            s += f"[ip={hex(f[0])}]\n"

    return s

def set_regs_for_call_linux_x86(p, args):
    if len(args) > 6:
        raise NotImplementedError(">6 args not supported yet")

    ARGS = [
        pyda_core.REG_RDI,
        pyda_core.REG_RSI,
        pyda_core.REG_RDX,
        pyda_core.REG_RCX,
        pyda_core.REG_R8,
        pyda_core.REG_R9
    ]
    for (reg_id, val) in zip(ARGS, args):
        if type(val) is int:
            p._p.set_register(reg_id, val)
        elif type(val) is bytes:
            ptr = ctypes.cast(ctypes.c_char_p(val), ctypes.c_void_p).value
            p._p.set_register(reg_id, ptr)
        else:
            raise ValueError(f"Invalid argument type {type(val)}")

class ProcessRegisters():
    def __init__(self, p):
        self._p = p

    def __getitem__(self, name):
        val = None
        reg_id = getattr(pyda_core, "REG_"+name.upper(), None)
        if reg_id:
            val = self._p.get_register(reg_id)

        if val is not None:
            return val

        raise AttributeError(f"Invalid register name '{name}'")

    def __setitem__(self, name, value):
        reg_id = getattr(pyda_core, "REG_"+name.upper(), None)
        if reg_id:
            self._p.set_register(reg_id, value)
        else:
            raise AttributeError(f"Invalid register name '{name}'")

    def __getattr__(self, name):
        return self[name]

    def __setattr__(self, name, value):
        if name != "_p":
            self[name] = value
        else:
            super().__setattr__(name, value)

    def has_reg(self, name):
        return hasattr(pyda_core, "REG_"+name.upper())

class ProcessMemory():
    def __init__(self, p):
        self._p = p

    def __getitem__(self, key):
        if type(key) is slice:
            start = key.start
            stop = key.stop
            step = key.step
            if step is not None and step != 1:
                raise ValueError("ProcessMemory: Step must be 1")

            if stop is not None:
                return self._p.read(start, stop - start)
            else:
                return self._p.read(start, 1)[0]

        return self._p.read(key, 1)[0]

class ProcessMaps():
    def __init__(self, p):
        self._p = p

    def __getitem__(self, key):
        return Map(vaddr=pyda_core.get_base(key), size=0, path=key, perms=None)


@dataclass
class Map:
    vaddr: int
    size: int
    path: str
    perms: int

    @property
    def base(self):
        return self.vaddr

    @property
    def start(self):
        return self.vaddr

    @property
    def end(self):
        return self.base + self.size

    @property
    def executable(self):
        return self.perms & 1

    @property
    def writable(self):
        return self.perms & 2

    @property
    def readable(self):
        return self.perms & 4



```

`lib/pyda/tube.py`:

```py
from pwnlib.tubes.tube import tube
from pwnlib.context import context
from pwnlib import term
import sys
import os
import pyda_core
import errno
import threading
import select

# todo
class ProcessTube(tube):
    def __init__(self, stdin_fd, stdout_fd, **kwargs):
        super(ProcessTube, self).__init__(**kwargs)

        self.closed = {"recv": False, "send": False}
        if stdin_fd is None or stdout_fd is None:
            self.closed["recv"] = True
            self.closed["send"] = True
            self._captured = False
        else:
            self._captured = True

        self._stdin_fd = stdin_fd
        self._stdout_fd = stdout_fd

        # real_stdin is what is connected to the user's terminal.
        # used for p.interactive() (note: sys.stdin may be buffered
        # even if PYTHONUNBUFFERED)
        self._real_stdin = os.fdopen(sys.stdin.fileno(), 'rb', 0)

    # Overwritten for better usability
    def recvall(self, timeout = None):
        """recvall() -> str

        Receives data until the socket is closed.
        """
        # todo
        raise NotImplementedError("recvall() not implemented")

    def recv_raw(self, numb, *a):
        if not self._captured:
            raise RuntimeError("I/O must be explicitly captured using process(io=True)")

        if self.closed["recv"]:
            raise EOFError

        if len(a) > 0:
            raise NotImplementedError("recv_raw() with flags not implemented")

        while True:
            try:
                data = os.read(self._stdout_fd, numb)
                break
            except IOError as e:
                if e.errno == errno.EAGAIN:
                    # If we're waiting for data, let the program continue
                    try:
                        self._p.run_until_io()
                        continue
                    except Exception as e:
                        raise EOFError

                if e.errno == errno.ETIMEDOUT or 'timed out' in e.strerror:
                    return None
                elif e.errno in (errno.ECONNREFUSED, errno.ECONNRESET):
                    self.shutdown("recv")
                    raise EOFError
                elif e.errno == errno.EINTR:
                    continue
                else:
                    raise

        if not data:
            self.shutdown("recv")
            raise EOFError

        return data

    # TODO: What happens when the pipe fills? This call
    # will indefinitely block?
    def send_raw(self, data):
        if not self._captured:
            raise RuntimeError("I/O must be explicitly captured using process(io=True)")

        if self.closed["send"]:
            raise EOFError

        ptr = 0
        while ptr < len(data):
            try:
                count = os.write(self._stdin_fd, data[ptr:])
                ptr += count
            except IOError as e:
                eof_numbers = (errno.EPIPE, errno.ECONNRESET, errno.ECONNREFUSED)
                if e.errno in eof_numbers or 'Socket is closed' in e.args:
                    self.shutdown("send")
                    raise EOFError
                elif e.errno == errno.EAGAIN:
                    # If we're waiting for data, let the program continue
                    try:
                        self._p.run_until_io()
                        continue
                    except Exception as e:
                        raise EOFError
                else:
                    raise

    def settimeout_raw(self, timeout):
        raise NotImplementedError("settimeout_raw() not implemented")

    def can_recv_raw(self, timeout):
        if not self._captured:
            raise RuntimeError("I/O must be explicitly captured using process(io=True)")

        if self.closed["recv"]:
            return False

        try:
            if timeout is None:
                return select.select([self._stdout_fd], [], []) == ([self._stdout_fd], [], [])

            return select.select([self._stdout_fd], [], [], timeout) == ([self._stdout_fd], [], [])
        except ValueError:
            # Not sure why this isn't caught when testing self.proc.stdout.closed,
            # but it's not.
            #
            #   File "/home/user/pwntools/pwnlib/tubes/process.py", line 112, in can_recv_raw
            #     return select.select([self.proc.stdout], [], [], timeout) == ([self.proc.stdout], [], [])
            # ValueError: I/O operation on closed file
            raise EOFError
        except select.error as v:
            if v.args[0] == errno.EINTR:
                return False

    def connected_raw(self, direction):
        return True

    def close(self):
        pass

    def _close_msg(self):
        self.info('Closed pyda socket')

    def fileno(self):
        self.error("fileno() not implemented")
        return None

    def shutdown_raw(self, direction):
        pass

    # This code is taken from pwnlib.tubes
    def interactive(self, prompt=term.text.bold_red('$') + ' '):
        if not self._captured:
            raise RuntimeError("I/O must be explicitly captured using process(io=True)")

        self.info('Switching to interactive mode')

        go = threading.Event()
        def send_thread():
            from pwnlib.args import term_mode
            os_linesep = os.linesep.encode()
            to_skip = b''
            while not go.is_set():
                if term.term_mode:
                    # note: this case is not tested
                    data = term.readline.readline(prompt = prompt, float = True)
                    if data.endswith(b'\n') and self.newline != b'\n':
                        data = data[:-1] + self.newline
                else:
                    stdin = self._real_stdin
                    while True:
                        can_read = select.select([stdin], [], [], 0.1) == ([stdin], [], [])
                        if can_read:
                            data = stdin.read(1)
                            break
                        elif go.is_set():
                            data = b''
                            break

                    # Keep OS's line separator if NOTERM is set and
                    # the user did not specify a custom newline
                    # even if stdin is a tty.
                    if sys.stdin.isatty() and (
                        term_mode
                        or context.newline != b"\n"
                        or self._newline is not None
                    ):
                        if to_skip:
                            if to_skip[:1] != data:
                                data = os_linesep[: -len(to_skip)] + data
                            else:
                                to_skip = to_skip[1:]
                                if to_skip:
                                    continue
                                data = self.newline
                        # If we observe a prefix of the line separator in a tty,
                        # assume we'll see the rest of it immediately after.
                        # This could stall until the next character is seen if
                        # the line separator is started but never finished, but
                        # that is unlikely to happen in a dynamic tty.
                        elif data and os_linesep.startswith(data):
                            if len(os_linesep) > 1:
                                to_skip = os_linesep[1:]
                                continue
                            data = self.newline
                    else:
                        raise RuntimeError("interactive() called not attached to TTY")

                if data:
                    try:
                        self.send(data)
                    except EOFError:
                        go.set()
                        self.info('Got EOF while sending in interactive')
                else:
                    go.set()

        t = context.Thread(target=send_thread)
        t.daemon = True
        t.start()

        # Recv thread -- must be main thread
        while not go.is_set():
            try:
                cur = self.recv(timeout = 0.05)
                cur = cur.replace(self.newline, b'\n')
                if cur:
                    stdout = sys.stdout
                    if not term.term_mode:
                        stdout = getattr(stdout, 'buffer', stdout)
                    stdout.write(cur)
                    stdout.flush()
            except EOFError:
                self.info('Got EOF while reading in interactive')
                go.set()
                break
            except KeyboardInterrupt:
                self.info('Interrupted')
                go.set()
                break

        while t.is_alive():
            t.join(timeout = 0.1)

```

`patches/cpython-3.10.12.patch`:

```patch
diff --git a/Modules/faulthandler.c b/Modules/faulthandler.c
index 8d2221cfd8..1372cbc291 100644
--- a/Modules/faulthandler.c
+++ b/Modules/faulthandler.c
@@ -20,7 +20,7 @@
 /* Using an alternative stack requires sigaltstack()
    and sigaction() SA_ONSTACK */
 #if defined(HAVE_SIGALTSTACK) && defined(HAVE_SIGACTION)
-#  define FAULTHANDLER_USE_ALT_STACK
+// #  define FAULTHANDLER_USE_ALT_STACK
 #endif
 
 #if defined(FAULTHANDLER_USE_ALT_STACK) && defined(HAVE_LINUX_AUXVEC_H) && defined(HAVE_SYS_AUXV_H)
diff --git a/Python/errors.c b/Python/errors.c
index bc1b55e440..78e704e332 100644
--- a/Python/errors.c
+++ b/Python/errors.c
@@ -698,10 +698,10 @@ PyErr_SetFromErrnoWithFilenameObject(PyObject *exc, PyObject *filenameObject)
 PyObject *
 PyErr_SetFromErrnoWithFilenameObjects(PyObject *exc, PyObject *filenameObject, PyObject *filenameObject2)
 {
+    int i = errno;
     PyThreadState *tstate = _PyThreadState_GET();
     PyObject *message;
     PyObject *v, *args;
-    int i = errno;
 #ifdef MS_WINDOWS
     WCHAR *s_buf = NULL;
 #endif /* Unix/Windows */
diff --git a/Python/thread_pthread.h b/Python/thread_pthread.h
index 35b9810aa3..130528aec3 100644
--- a/Python/thread_pthread.h
+++ b/Python/thread_pthread.h
@@ -100,7 +100,7 @@
 
 #if defined(HAVE_PTHREAD_CONDATTR_SETCLOCK) && defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
 // monotonic is supported statically.  It doesn't mean it works on runtime.
-#define CONDATTR_MONOTONIC
+// #define CONDATTR_MONOTONIC
 #endif
 
 
@@ -392,7 +392,7 @@ PyThread_allocate_lock(void)
     lock = (sem_t *)PyMem_RawMalloc(sizeof(sem_t));
 
     if (lock) {
-        status = sem_init(lock,0,1);
+        status = sem_init(lock,1,1);
         CHECK_STATUS("sem_init");
 
         if (error) {

```

`patches/dynamorio-10.0.patch`:

```patch
diff --git a/core/heap.c b/core/heap.c
index 8a0c440cf..f596108da 100644
--- a/core/heap.c
+++ b/core/heap.c
@@ -4548,7 +4548,7 @@ common_heap_free(thread_units_t *tu, void *p_void,
 #ifdef DEBUG_MEMORY
         /* ensure we are freeing memory in a proper unit */
         DOCHECK(CHKLVL_DEFAULT, { /* expensive check */
-                                  ASSERT(find_heap_unit(tu, p, size) != NULL);
+                                  ASSERT(find_heap_unit(tu, p, size) != NULL || *(bool*)0);
         });
 #endif
 
diff --git a/core/ir/opnd_shared.c b/core/ir/opnd_shared.c
index 982362e9f..b708d525a 100644
--- a/core/ir/opnd_shared.c
+++ b/core/ir/opnd_shared.c
@@ -2187,7 +2187,7 @@ DR_API
 bool
 reg_get_value_ex(reg_id_t reg, dr_mcontext_t *mc, OUT byte *val)
 {
-#ifdef X86
+#if defined(X86)
     if (reg >= DR_REG_START_MMX && reg <= DR_REG_STOP_MMX) {
         get_mmx_val((uint64 *)val, reg - DR_REG_START_MMX);
     } else if (reg >= DR_REG_START_XMM && reg <= DR_REG_STOP_XMM) {
@@ -2210,6 +2210,13 @@ reg_get_value_ex(reg_id_t reg, dr_mcontext_t *mc, OUT byte *val)
         reg_t regval = reg_get_value(reg, mc);
         *(reg_t *)val = regval;
     }
+#elif defined(AARCH64)
+    if (reg >= DR_REG_Q0 && reg <= DR_REG_Q31) {
+        memcpy(val, &mc->simd[reg - DR_REG_Q0], 16);
+    } else {
+        reg_t regval = reg_get_value(reg, mc);
+        *(reg_t *)val = regval;
+    }
 #else
     CLIENT_ASSERT(false, "NYI i#1551");
 #endif
diff --git a/core/lib/dr_tools.h b/core/lib/dr_tools.h
index efbb1c636..b7ab5d060 100644
--- a/core/lib/dr_tools.h
+++ b/core/lib/dr_tools.h
@@ -2107,6 +2107,11 @@ DR_API
 void
 dr_thread_yield(void);
 
+DR_API
+/** Current thread gives up its time quantum. */
+void
+dr_set_safe_for_sync(bool safe);
+
 /** Flags controlling the behavior of dr_suspend_all_other_threads_ex(). */
 typedef enum {
     /**
diff --git a/core/lib/instrument.c b/core/lib/instrument.c
index 00686214e..f4e7e0e63 100644
--- a/core/lib/instrument.c
+++ b/core/lib/instrument.c
@@ -147,6 +147,9 @@ typedef struct _callback_list_t {
  */
 /*
  */
+
+void print_xmm0(int);
+
 #define FAST_COPY_SIZE 5
 #define call_all_ret(ret, retop, postop, vec, type, ...)                         \
     do {                                                                         \
@@ -4731,6 +4734,18 @@ dr_insert_write_raw_tls(void *drcontext, instrlist_t *ilist, instr_t *where,
         });
 }
 
+DR_API
+void
+dr_set_safe_for_sync(bool safe)
+{
+    dcontext_t *dcontext = get_thread_private_dcontext();
+    CLIENT_ASSERT(!standalone_library, "API not supported in standalone mode");
+    if (IS_CLIENT_THREAD(dcontext))
+        dcontext->client_data->client_thread_safe_for_synch = safe;
+    else
+        dcontext->client_data->at_safe_to_terminate_syscall = safe;
+}
+
 DR_API
 /* Current thread gives up its time quantum. */
 void
diff --git a/core/loader_shared.c b/core/loader_shared.c
index 339805e41..3674912a8 100644
--- a/core/loader_shared.c
+++ b/core/loader_shared.c
@@ -452,6 +452,14 @@ privload_lookup_by_base(app_pc modbase)
     return NULL;
 }
 
+// HACK
+privmod_t* privload_lookup_by_pc_takelock(app_pc pc) {
+    acquire_recursive_lock(&privload_lock);
+    privmod_t *res = privload_lookup_by_pc(pc);
+    release_recursive_lock(&privload_lock);
+    return res;
+}
+
 /* Lookup the private loaded library by base */
 privmod_t *
 privload_lookup_by_pc(app_pc pc)
@@ -925,20 +933,16 @@ loader_allow_unsafe_static_behavior(void)
  */
 #define REDIRECT_HEADER_SHIFTED (1ULL << IF_X64_ELSE(63, 31))
 
-/* This routine allocates memory from DR's global memory pool.  Unlike
- * dr_global_alloc(), however, we store the size of the allocation in
- * the first few bytes so redirect_free() can retrieve it.  We also align
- * to the standard alignment used by most allocators.  This memory
- * is also not guaranteed-reachable.
- */
-void *
-redirect_malloc(size_t size)
-{
+static void *
+private_alloc(size_t alignment, size_t size) {
     void *mem;
+    if (alignment < STANDARD_HEAP_ALIGNMENT) {
+        alignment = STANDARD_HEAP_ALIGNMENT;
+    }
     /* We need extra space to store the size and alignment bit and ensure the returned
      * pointer is aligned.
      */
-    size_t alloc_size = size + sizeof(size_t) + STANDARD_HEAP_ALIGNMENT - HEAP_ALIGNMENT;
+    size_t alloc_size = size + sizeof(size_t) + alignment - HEAP_ALIGNMENT;
     /* Our header is the size itself, with the top bit stolen to indicate alignment. */
     if (TEST(REDIRECT_HEADER_SHIFTED, alloc_size)) {
         /* We do not support the top bit being set as that conflicts with the bit in
@@ -954,15 +958,15 @@ redirect_malloc(size_t size)
         return NULL;
     }
     ptr_uint_t res =
-        ALIGN_FORWARD((ptr_uint_t)mem + sizeof(size_t), STANDARD_HEAP_ALIGNMENT);
+        ALIGN_FORWARD((ptr_uint_t)mem + sizeof(size_t), alignment);
     size_t header = alloc_size;
     ASSERT(HEAP_ALIGNMENT * 2 == STANDARD_HEAP_ALIGNMENT);
     ASSERT(!TEST(REDIRECT_HEADER_SHIFTED, header));
     if (res == (ptr_uint_t)mem + sizeof(size_t)) {
         /* Already aligned. */
-    } else if (res == (ptr_uint_t)mem + sizeof(size_t) * 2) {
-        /* DR's alignment is "odd" for double-pointer so we're adding one pointer. */
+    } else if (res >= (ptr_uint_t)mem + sizeof(size_t) * 2) {
         header |= REDIRECT_HEADER_SHIFTED;
+        *(size_t*)(res - 2 * sizeof(size_t)) = res - 2 * sizeof(size_t) - (ptr_uint_t)mem;
     } else
         ASSERT_NOT_REACHED();
     *((size_t *)(res - sizeof(size_t))) = header;
@@ -970,6 +974,24 @@ redirect_malloc(size_t size)
     return (void *)res;
 }
 
+/* This routine allocates memory from DR's global memory pool.  Unlike
+ * dr_global_alloc(), however, we store the size of the allocation in
+ * the first few bytes so redirect_free() can retrieve it.  We also align
+ * to the standard alignment used by most allocators.  This memory
+ * is also not guaranteed-reachable.
+ */
+void *
+redirect_malloc(size_t size)
+{
+    return private_alloc(STANDARD_HEAP_ALIGNMENT, size);
+}
+
+int
+redirect_posix_memalign(void **memptr, size_t alignment, size_t size) {
+    *memptr = private_alloc(alignment, size);
+    return 0;
+}
+
 /* Returns the underlying DR allocation's size and starting point, given a
  * wrapped-malloc-layer pointer from a client/privlib.
  */
@@ -982,6 +1004,8 @@ redirect_malloc_size_and_start(void *mem, OUT void **start_out)
     if (TEST(REDIRECT_HEADER_SHIFTED, size)) {
         start = size_ptr - 1;
         size &= ~REDIRECT_HEADER_SHIFTED;
+
+        start -= *(size_ptr - 1);
     }
     if (start_out != NULL)
         *start_out = start;
@@ -995,12 +1019,7 @@ redirect_malloc_requested_size(void *mem)
         return 0;
     void *start;
     size_t size = redirect_malloc_size_and_start(mem, &start);
-    size -= sizeof(size_t);
-    if (start != mem) {
-        /* Subtract the extra size for alignment. */
-        size -= sizeof(size_t);
-    }
-    return size;
+    return (size_t)(start + size - mem);
 }
 
 /* This routine allocates memory from DR's global memory pool. Unlike
diff --git a/core/module_shared.h b/core/module_shared.h
index 5499f27e5..ad0c41247 100644
--- a/core/module_shared.h
+++ b/core/module_shared.h
@@ -492,6 +492,9 @@ privload_lookup_by_base(app_pc modbase);
 privmod_t *
 privload_lookup_by_pc(app_pc modbase);
 
+DR_API privmod_t *
+privload_lookup_by_pc_takelock(app_pc modbase);
+
 /* name is assumed to be in immutable persistent storage.
  * a copy of path is made.
  */
@@ -614,6 +617,9 @@ redirect_calloc(size_t nmemb, size_t size);
 void *
 redirect_malloc(size_t size);
 
+int
+redirect_posix_memalign(void **memptr, size_t alignment, size_t size);
+
 void
 redirect_free(void *mem);
 
diff --git a/core/os_shared.h b/core/os_shared.h
index 4e1150109..e5d06c655 100644
--- a/core/os_shared.h
+++ b/core/os_shared.h
@@ -455,7 +455,7 @@ os_page_size(void);
 /* This also tries to set other auxv values. */
 void
 os_page_size_init(const char **env, bool env_followed_by_auxv);
-size_t
+DR_API size_t
 os_minsigstksz(void);
 #endif
 bool
@@ -1200,7 +1200,7 @@ load_private_library(const char *filename, bool reachable);
 bool
 unload_private_library(app_pc modbase);
 /* searches in standard paths instead of requiring abs path */
-app_pc
+DR_API app_pc
 locate_and_load_private_library(const char *name, bool reachable);
 void
 loader_init_prologue(void);
diff --git a/core/synch.c b/core/synch.c
index f5eef1e5c..91f5a16bd 100644
--- a/core/synch.c
+++ b/core/synch.c
@@ -513,6 +513,9 @@ should_suspend_client_thread(dcontext_t *dcontext, thread_synch_state_t desired_
 {
     /* Marking un-suspendable does not apply to cleaning/terminating */
     ASSERT(IS_CLIENT_THREAD(dcontext));
+    if (THREAD_SYNCH_IS_CLEANED(desired_state)) {
+        SYSLOG_INTERNAL_INFO("cleaning client thread " TIDFMT, dcontext->owning_thread);
+    }
     return (THREAD_SYNCH_IS_CLEANED(desired_state) || dcontext->client_data->suspendable);
 }
 
@@ -765,7 +768,7 @@ check_wait_at_safe_spot(dcontext_t *dcontext, thread_synch_permission_t cur_stat
 }
 
 /* adjusts the pending synch count */
-void
+DR_API void
 adjust_wait_at_safe_spot(dcontext_t *dcontext, int amt)
 {
     thread_synch_data_t *tsd = (thread_synch_data_t *)dcontext->synch_field;
@@ -1249,8 +1252,8 @@ synch_with_all_threads(thread_synch_state_t desired_synch_state,
 
     LOG(THREAD, LOG_SYNCH, 1,
         "synch with all threads my id = " SZFMT
-        " Giving %d permission and seeking %d state\n",
-        my_id, cur_state, desired_synch_state);
+        " Giving %d permission and seeking %d state, flags %x\n",
+        my_id, cur_state, desired_synch_state, flags);
 
     /* grab all_threads_synch_lock */
     /* since all_threads synch doesn't give any permissions this is necessary
diff --git a/core/unix/loader.c b/core/unix/loader.c
index 10c4518b0..b27284a8e 100644
--- a/core/unix/loader.c
+++ b/core/unix/loader.c
@@ -158,7 +158,7 @@ privload_locate_and_load(const char *impname, privmod_t *dependent, bool reachab
 static void
 privload_call_lib_func(fp_t func);
 
-static void
+DR_API void
 privload_relocate_mod(privmod_t *mod);
 
 static void
@@ -690,16 +690,16 @@ privload_os_finalize(privmod_t *privmod)
     os_privmod_data_t *opd = (os_privmod_data_t *)privmod->os_privmod_data;
     /* Special handling for standard I/O file descriptors. */
     privmod_stdout = (FILE **)get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_STDOUT_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_STDOUT_NAME, NULL /* symver */, NULL);
     privmod_stdin = (FILE **)get_proc_address_from_os_data(&opd->os_data, opd->load_delta,
-                                                           LIBC_STDIN_NAME, NULL);
+                                                           LIBC_STDIN_NAME, NULL /* symver */, NULL);
     privmod_stderr = (FILE **)get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_STDERR_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_STDERR_NAME, NULL /* symver */, NULL);
     /* i#5133: glibc 2.32+ has ld.so call a hardcoded initializer before calling the
      * regular ELF constructors.
      */
     void (*libc_early_init)(bool) = (void (*)(bool))get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_EARLY_INIT_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_EARLY_INIT_NAME, NULL /* symver */, NULL);
     if (libc_early_init == NULL) {
         return;
     }
@@ -712,7 +712,7 @@ privload_os_finalize(privmod_t *privmod)
     /* Do not try to clobber vars unless we have to: get the libc version. */
 #    define LIBC_GET_VERSION_NAME "gnu_get_libc_version"
     const char *(*libc_ver)(void) = (const char *(*)(void))get_proc_address_from_os_data(
-        &opd->os_data, opd->load_delta, LIBC_GET_VERSION_NAME, NULL);
+        &opd->os_data, opd->load_delta, LIBC_GET_VERSION_NAME, NULL /* symver */, NULL);
     if (libc_ver == NULL)
         return;
     LOG(GLOBAL, LOG_LOADER, 2, "%s: calling %s\n", __FUNCTION__, LIBC_GET_VERSION_NAME);
@@ -727,7 +727,7 @@ privload_os_finalize(privmod_t *privmod)
     }
     os_privmod_data_t *ld_opd = (os_privmod_data_t *)privmod_ld_linux->os_privmod_data;
     byte *glro = get_proc_address_from_os_data(&ld_opd->os_data, ld_opd->load_delta,
-                                               "_rtld_global_ro", NULL);
+                                               "_rtld_global_ro", NULL /* symver */, NULL);
     if (glro == NULL) {
         SYSLOG_INTERNAL_WARNING("glibc 2.34+ i#5437 workaround failed: missed glro");
         return;
@@ -1030,7 +1030,7 @@ get_private_library_address(app_pc modbase, const char *name)
     if (dynamo_heap_initialized) {
         /* opd is initialized */
         os_privmod_data_t *opd = (os_privmod_data_t *)mod->os_privmod_data;
-        res = get_proc_address_from_os_data(&opd->os_data, opd->load_delta, name, NULL);
+        res = get_proc_address_from_os_data(&opd->os_data, opd->load_delta, name, NULL /* symver */, NULL);
         release_recursive_lock(&privload_lock);
         return res;
     } else {
@@ -1050,7 +1050,7 @@ get_private_library_address(app_pc modbase, const char *name)
             release_recursive_lock(&privload_lock);
             return NULL;
         }
-        res = get_proc_address_from_os_data(&os_data, delta, name, NULL);
+        res = get_proc_address_from_os_data(&os_data, delta, name, NULL /* symver */, NULL);
         release_recursive_lock(&privload_lock);
         return res;
     }
@@ -1276,7 +1276,13 @@ privload_relocate_os_privmod_data(os_privmod_data_t *opd, byte *mod_base)
 }
 #endif /* LINUX */
 
-static void
+DR_API void privload_relocate_mod_takelock(privmod_t *mod) {
+    acquire_recursive_lock(&privload_lock);
+    privload_relocate_mod(mod);
+    release_recursive_lock(&privload_lock);
+}
+
+void
 privload_relocate_mod(privmod_t *mod)
 {
 #ifdef LINUX
@@ -1517,6 +1523,7 @@ typedef struct _redirect_import_t {
 static const redirect_import_t redirect_imports[] = {
     { "calloc", (app_pc)redirect_calloc },
     { "malloc", (app_pc)redirect_malloc },
+    { "posix_memalign", (app_pc)redirect_posix_memalign },
     { "free", (app_pc)redirect_free },
     { "realloc", (app_pc)redirect_realloc },
     { "strdup", (app_pc)redirect_strdup },
@@ -1533,8 +1540,8 @@ static const redirect_import_t redirect_imports[] = {
     /* These libc routines can call pthread functions and cause hangs (i#4928) so
      * we use our syscall wrappers instead.
      */
-    { "read", (app_pc)os_read },
-    { "write", (app_pc)os_write },
+    /* { "read", (app_pc)os_read }, */
+    /* { "write", (app_pc)os_write }, */
 #if defined(LINUX) && !defined(ANDROID)
     { "__tls_get_addr", (app_pc)redirect___tls_get_addr },
     { "___tls_get_addr", (app_pc)redirect____tls_get_addr },
@@ -1548,6 +1555,7 @@ static const redirect_import_t redirect_imports[] = {
     { "__gnu_Unwind_Find_exidx", (app_pc)redirect___gnu_Unwind_Find_exidx },
 #    endif
 #endif
+    // { "dlsym", (app_pc)redirect_dlsym },
     { "dlsym", (app_pc)redirect_dlsym },
     /* We need these for clients that don't use libc (i#1747) */
     { "strlen", (app_pc)strlen },
@@ -1569,7 +1577,12 @@ static const redirect_import_t redirect_imports[] = {
     { "memset_chk", (app_pc)memset },
     { "memmove_chk", (app_pc)memmove },
     { "strncpy_chk", (app_pc)strncpy },
+    /* { "__errno_location", (app_pc)__errno_location } */
 };
+
+DR_API redirect_import_t *client_redirect_imports = NULL;
+DR_API int client_redirect_imports_count = 0;
+
 #define REDIRECT_IMPORTS_NUM (sizeof(redirect_imports) / sizeof(redirect_imports[0]))
 
 #ifdef DEBUG
@@ -1599,6 +1612,15 @@ privload_redirect_sym(os_privmod_data_t *opd, ptr_uint_t *r_addr, const char *na
         }
     }
 #endif
+    for (i = 0; i < client_redirect_imports_count; i++) {
+        if (strcmp(client_redirect_imports[i].name, name) == 0) {
+            if (opd->use_app_imports && client_redirect_imports[i].app_func != NULL)
+                *r_addr = (ptr_uint_t)client_redirect_imports[i].app_func;
+            else
+                *r_addr = (ptr_uint_t)client_redirect_imports[i].func;
+            return true;
+        }
+    }
     for (i = 0; i < REDIRECT_IMPORTS_NUM; i++) {
         if (strcmp(redirect_imports[i].name, name) == 0) {
             if (opd->use_app_imports && redirect_imports[i].app_func != NULL)
diff --git a/core/unix/loader_linux.c b/core/unix/loader_linux.c
index 9f5b85152..c63e58717 100644
--- a/core/unix/loader_linux.c
+++ b/core/unix/loader_linux.c
@@ -134,7 +134,7 @@ static size_t client_tls_size = 2 * 4096;
  * good way to guess how big this allocation was.  Instead we use this estimate.
  */
 /* On A32, the pthread is put before tcbhead instead tcbhead being part of pthread */
-static size_t tcb_size = IF_X86_ELSE(IF_X64_ELSE(0x900, 0x490), 0x40);
+static size_t tcb_size = IF_X86_ELSE(IF_X64_ELSE(0xc00, 0x490), 0x40);
 
 /* thread contol block header type from
  * - sysdeps/x86_64/nptl/tls.h
@@ -156,6 +156,8 @@ typedef struct _tcb_head_t {
 
     ptr_uint_t stack_guard;
     ptr_uint_t pointer_guard;
+    unsigned long int unused[2];
+    unsigned int feature_1;
 #elif defined(AARCH64)
     /* FIXME i#1569: This may be wrong! */
     void *dtv;
@@ -305,7 +307,8 @@ privload_copy_tls_block(app_pc priv_tls_base, uint mod_idx)
 void
 privload_mod_tls_primary_thread_init(privmod_t *mod)
 {
-    ASSERT(!dynamo_initialized);
+    // ASSERT(!dynamo_initialized);
+
     /* Copy ELF block for primary thread for use in init funcs (i#2751).
      * We do this after relocs and assume reloc ifuncs don't need this:
      * else we'd have to assume there are no relocs in the TLS blocks.
@@ -330,6 +333,7 @@ privload_tls_init(void *app_tp)
         app_tp);
     dr_tp = heap_mmap(client_tls_alloc_size, MEMPROT_READ | MEMPROT_WRITE,
                       VMM_SPECIAL_MMAP | VMM_PER_THREAD);
+    SYSLOG_INTERNAL_INFO("dr_tp: %p tcb_size: %lx\n", dr_tp, tcb_size);
     ASSERT(APP_LIBC_TLS_SIZE + TLS_PRE_TCB_SIZE + tcb_size <= client_tls_alloc_size);
 #ifdef AARCHXX
     /* GDB reads some pthread members (e.g., pid, tid), so we must make sure
@@ -373,6 +377,7 @@ privload_tls_init(void *app_tp)
     dr_tcb->self = dr_tcb;
     /* i#555: replace app's vsyscall with DR's int0x80 syscall */
     dr_tcb->sysinfo = (ptr_uint_t)client_int_syscall;
+    dr_tcb->feature_1 = 0; // this is currently used to say we don't have Intel CET
 #elif defined(AARCHXX)
     dr_tcb->dtv = NULL;
     dr_tcb->private = NULL;
diff --git a/core/unix/module.h b/core/unix/module.h
index 25616b24c..faa4be373 100644
--- a/core/unix/module.h
+++ b/core/unix/module.h
@@ -83,6 +83,10 @@ typedef struct _os_module_data_t {
     app_pc chain;           /* absolute addr of hash chain table */
     app_pc dynsym;          /* absolute addr of .dynsym */
     app_pc dynstr;          /* absolute addr of .dynstr */
+    app_pc versym;          /* absolute addr of .gnu.version */
+    app_pc verdef;          /* absolute addr of .gnu.version */
+    size_t verdefnum;          /* absolute addr of .gnu.version */
+    app_pc verdefstrtab;          /* absolute addr of .gnu.version */
     size_t dynstr_size;     /* size of .dynstr */
     size_t symentry_size;   /* size of a .dynsym entry */
     bool has_runpath;       /* is DT_RUNPATH present? */
@@ -167,7 +171,7 @@ extern stdfile_t **privmod_stderr;
 extern stdfile_t **privmod_stdin;
 
 /* loader.c */
-app_pc
+DR_API app_pc
 get_private_library_address(app_pc modbase, const char *name);
 
 bool
diff --git a/core/unix/module_elf.c b/core/unix/module_elf.c
index 9ba999c21..b46723900 100644
--- a/core/unix/module_elf.c
+++ b/core/unix/module_elf.c
@@ -283,6 +283,14 @@ module_fill_os_data(ELF_PROGRAM_HEADER_TYPE *prog_hdr, /* PT_DYNAMIC entry */
                         out_data->symentry_size = (size_t)dyn->d_un.d_val;
                     } else if (dyn->d_tag == DT_RUNPATH) {
                         out_data->has_runpath = true;
+                    } else if (dyn->d_tag == DT_VERSYM) {
+                        out_data->versym = elf_dt_abs_addr(dyn, base, sz, view_size,
+                                                          load_delta, at_map, dyn_reloc);
+                    } else if (dyn->d_tag == DT_VERDEF) {
+                        out_data->verdef = elf_dt_abs_addr(dyn, base, sz, view_size,
+                                                          load_delta, at_map, dyn_reloc);
+                    } else if (dyn->d_tag == DT_VERDEFNUM) {
+                        out_data->verdefnum = (size_t)dyn->d_un.d_val;
 #ifndef ANDROID
                     } else if (dyn->d_tag == DT_CHECKSUM) {
                         out_data->checksum = (size_t)dyn->d_un.d_val;
@@ -643,9 +651,17 @@ elf_sym_matches(ELF_SYM_TYPE *sym, char *strtab, const char *name,
 /* The new GNU hash scheme to improve lookup speed.
  * Can't find good doc to reference here.
  */
+
+#define VERSYM_VERSION 0x7fff
+#define VERSYM_HIDDEN 0x8000
+
+// TODO: Right now, this function does not actually deal with symbol versioning.
+// Most of the work is done, to parse symbol versions / definitions in the loaded library
+// but we don't actually return a specific symbol version (we
+// return the default version for now).
 static app_pc
-gnu_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
-                char *strtab, Elf_Symndx *buckets, Elf_Symndx *chain, ELF_ADDR *bitmask,
+gnu_hash_lookup(const char *name, Elf64_Word *symver_hash, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
+                char *strtab, Elf64_Half *symvertab, Elf64_Verdef *verdef, size_t verdefnum, Elf_Symndx *buckets, Elf_Symndx *chain, ELF_ADDR *bitmask,
                 ptr_uint_t bitidx, ptr_uint_t shift, size_t num_buckets,
                 size_t dynstr_size, bool *is_indirect_code)
 {
@@ -678,8 +694,32 @@ gnu_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
                     if (sym->st_value == 0 && ELF_ST_TYPE(sym->st_info) != STT_TLS)
                         continue; /* no value */
                     if (elf_sym_matches(sym, strtab, name, is_indirect_code)) {
-                        res = (app_pc)(symtab[sidx].st_value + load_delta);
-                        break;
+                        if (symvertab) {
+                            Elf64_Half ver = symvertab[sidx];
+                            Elf64_Word verhash = 0;
+                            for (size_t i=0; i<verdefnum; i++) {
+                                // Elf64_Verdaux *vdaux = (Elf64_Verdaux *)((char *)vd + vd->vd_aux);
+                                if (verdef->vd_ndx == (ver & VERSYM_VERSION)) {
+                                    verhash = verdef->vd_hash;
+                                    break;
+                                }
+                                verdef = (Elf64_Verdef *)((char *)verdef + verdef->vd_next);
+                            }
+
+                            if ((ver & VERSYM_HIDDEN) == 0 || ver == VER_NDX_GLOBAL) {
+                                // Default version
+                                res = (app_pc)(symtab[sidx].st_value + load_delta);
+                                LOG(GLOBAL, LOG_LOADER, 2, "%s: found %s default version %hd %d target %d\n", __func__, name, ver, verhash, symver_hash ? *symver_hash : -1);
+                                break;
+                            } else {
+                                // Non-default version
+                                LOG(GLOBAL, LOG_LOADER, 2, "%s: skip %s non-default version %hd %d target %d\n", __func__, name, ver, verhash, symver_hash ? *symver_hash : -1);
+                                if (!res) res = (app_pc)(symtab[sidx].st_value + load_delta);
+                            }
+                        } else {
+                            res = (app_pc)(symtab[sidx].st_value + load_delta);
+                            break;
+                        }
                     }
                 }
             } while (!TEST(1, *harray++));
@@ -693,12 +733,13 @@ gnu_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
  */
 static app_pc
 elf_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
-                char *strtab, Elf_Symndx *buckets, Elf_Symndx *chain, size_t num_buckets,
+                char *strtab, const Elf64_Half* symvertab, Elf_Symndx *buckets, Elf_Symndx *chain, size_t num_buckets,
                 size_t dynstr_size, bool *is_indirect_code)
 {
     Elf_Symndx sidx;
     Elf_Symndx hidx;
     ELF_SYM_TYPE *sym;
+
     app_pc res;
 
     hidx = elf_hash(name);
@@ -726,24 +767,28 @@ elf_hash_lookup(const char *name, ptr_int_t load_delta, ELF_SYM_TYPE *symtab,
 /* get the address by using the hashtable information in os_module_data_t */
 app_pc
 get_proc_address_from_os_data(os_module_data_t *os_data, ptr_int_t load_delta,
-                              const char *name, OUT bool *is_indirect_code)
+                              const char *name, void *symver, OUT bool *is_indirect_code)
 {
     if (os_data->hashtab != NULL) {
         Elf_Symndx *buckets = (Elf_Symndx *)os_data->buckets;
         Elf_Symndx *chain = (Elf_Symndx *)os_data->chain;
         ELF_SYM_TYPE *symtab = (ELF_SYM_TYPE *)os_data->dynsym;
+        Elf64_Half *vertab = (Elf64_Half *)os_data->versym;
+        Elf64_Verdef *verdef = (Elf64_Verdef *)os_data->verdef;
+        size_t verdefnum = os_data->verdefnum;
+
         char *strtab = (char *)os_data->dynstr;
         size_t num_buckets = os_data->num_buckets;
         if (os_data->hash_is_gnu) {
             /* The new GNU hash scheme */
-            return gnu_hash_lookup(name, load_delta, symtab, strtab, buckets, chain,
+            return gnu_hash_lookup(name, (Elf64_Word*)symver, load_delta, symtab, strtab, vertab, verdef, verdefnum, buckets, chain,
                                    (ELF_ADDR *)os_data->gnu_bitmask,
                                    (ptr_uint_t)os_data->gnu_bitidx,
                                    (ptr_uint_t)os_data->gnu_shift, num_buckets,
                                    os_data->dynstr_size, is_indirect_code);
         } else {
             /* ELF hash scheme */
-            return elf_hash_lookup(name, load_delta, symtab, strtab, buckets, chain,
+            return elf_hash_lookup(name, load_delta, symtab, strtab, vertab, buckets, chain,
                                    num_buckets, os_data->dynstr_size, is_indirect_code);
         }
     }
@@ -763,7 +808,7 @@ get_proc_address_ex(module_base_t lib, const char *name, bool *is_indirect_code
     ma = module_pc_lookup((app_pc)lib);
     if (ma != NULL) {
         res = get_proc_address_from_os_data(
-            &ma->os_data, ma->start - ma->os_data.base_address, name, &is_ifunc);
+            &ma->os_data, ma->start - ma->os_data.base_address, name, NULL /* symver */, &is_ifunc);
         /* XXX: for the case of is_indirect_code being true, should we call
          * the ifunc to get the real symbol location?
          * Current solution is:
@@ -972,6 +1017,8 @@ module_init_os_privmod_data_from_dyn(os_privmod_data_t *opd, ELF_DYNAMIC_ENTRY_T
         case DT_VERNEED: opd->verneed = (app_pc)(dyn->d_un.d_ptr + load_delta); break;
         case DT_VERNEEDNUM: opd->verneednum = dyn->d_un.d_val; break;
         case DT_VERSYM: opd->versym = (ELF_HALF *)(dyn->d_un.d_ptr + load_delta); break;
+        case DT_VERDEF: opd->verdef = (ELF_HALF *)(dyn->d_un.d_ptr + load_delta); break;
+        case DT_VERDEFNUM: opd->verdefnum = dyn->d_un.d_val;; break;
         case DT_RELCOUNT: opd->relcount = dyn->d_un.d_val; break;
         case DT_INIT: opd->init = (fp_t)(dyn->d_un.d_ptr + load_delta); break;
         case DT_FINI: opd->fini = (fp_t)(dyn->d_un.d_ptr + load_delta); break;
@@ -1054,7 +1101,7 @@ module_get_os_privmod_data(app_pc base, size_t size, bool dyn_reloc,
     module_init_os_privmod_data_from_dyn(pd, dyn, load_delta);
     DODEBUG({
         if (get_proc_address_from_os_data(&pd->os_data, pd->load_delta,
-                                          DR_DISALLOW_UNSAFE_STATIC_NAME, NULL) != NULL)
+                                          DR_DISALLOW_UNSAFE_STATIC_NAME, NULL /* symver */, NULL) != NULL)
             disallow_unsafe_static_calls = true;
     });
     pd->use_app_imports = false;
@@ -1099,7 +1146,7 @@ static app_pc
 module_lookup_symbol(ELF_SYM_TYPE *sym, os_privmod_data_t *pd)
 {
     app_pc res;
-    const char *name;
+    const char *name, *version;
     privmod_t *mod;
     bool is_ifunc;
     dcontext_t *dcontext = get_thread_private_dcontext();
@@ -1109,9 +1156,11 @@ module_lookup_symbol(ELF_SYM_TYPE *sym, os_privmod_data_t *pd)
         return NULL;
 
     name = (char *)pd->os_data.dynstr + sym->st_name;
+    version = NULL;
+    // version = pd->os_data.
     LOG(GLOBAL, LOG_LOADER, 3, "sym lookup for %s from %s\n", name, pd->soname);
     /* check my current module */
-    res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name, &is_ifunc);
+    res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name, NULL /* symver */, &is_ifunc);
     if (res != NULL) {
         if (is_ifunc) {
             TRY_EXCEPT_ALLOW_NO_DCONTEXT(
@@ -1154,7 +1203,7 @@ module_lookup_symbol(ELF_SYM_TYPE *sym, os_privmod_data_t *pd)
             LOG(GLOBAL, LOG_LOADER, 3, "NOT using libpthread's non-pthread symbol\n");
             res = NULL;
         } else {
-            res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name,
+            res = get_proc_address_from_os_data(&pd->os_data, pd->load_delta, name, NULL /* symver */,
                                                 &is_ifunc);
         }
         if (res != NULL) {
diff --git a/core/unix/module_macho.c b/core/unix/module_macho.c
index c3e9286aa..f2b697c42 100644
--- a/core/unix/module_macho.c
+++ b/core/unix/module_macho.c
@@ -357,7 +357,7 @@ read_uleb128(byte *start, byte *max, byte **next_entry OUT)
 
 app_pc
 get_proc_address_from_os_data(os_module_data_t *os_data, ptr_int_t load_delta,
-                              const char *name, OUT bool *is_indirect_code)
+                              const char *name, const char *symver, OUT bool *is_indirect_code)
 {
     /* Walk the Mach-O export trie.  We don't support < 10.6 which is when
      * they put this scheme in place.
@@ -477,7 +477,7 @@ get_proc_address_ex(module_base_t lib, const char *name, bool *is_indirect_code
                                                  */
                                                 (ptr_int_t)ma->start
                                                 : ma->start - ma->os_data.base_address,
-                                            name, is_indirect_code);
+                                            name, NULL /* symver */, is_indirect_code);
     }
     os_get_module_info_unlock();
     LOG(GLOBAL, LOG_SYMBOLS, 2, "%s: %s => " PFX "\n", __func__, name, res);
diff --git a/core/unix/module_private.h b/core/unix/module_private.h
index d98df70db..f106ce611 100644
--- a/core/unix/module_private.h
+++ b/core/unix/module_private.h
@@ -72,6 +72,8 @@ struct _os_privmod_data_t {
     int verneednum;
     int relcount;
     ELF_HALF *versym;
+    ELF_HALF *verdef;
+    int verdefnum;
 #else
     /* XXX i#1285: MacOS private loader NYI */
 #endif
@@ -123,7 +125,7 @@ module_get_text_section(app_pc file_map, size_t file_size);
 
 app_pc
 get_proc_address_from_os_data(os_module_data_t *os_data, ptr_int_t delta,
-                              const char *name, bool *is_indirect_code OUT);
+                              const char *name, void *symver, bool *is_indirect_code OUT);
 
 bool
 privload_redirect_sym(os_privmod_data_t *opd, ptr_uint_t *r_addr, const char *name);
diff --git a/core/unix/os.c b/core/unix/os.c
index d5133bf16..106d0672a 100644
--- a/core/unix/os.c
+++ b/core/unix/os.c
@@ -3761,8 +3761,13 @@ os_thread_sleep(uint64 milliseconds)
         /* not unusual for client threads to use itimers and have their run
          * routine sleep forever
          */
+
         if (count++ > 3 && !IS_CLIENT_THREAD(get_thread_private_dcontext())) {
-            ASSERT_NOT_REACHED();
+            // ATH: We are hitting this case in release builds, and it seems to be breaking
+            // some stuff. Removed the assert for now -- breaking should be ok because
+            // sleeps are always allowed to return early.
+            //
+            // ASSERT_NOT_REACHED();
             break; /* paranoid */
         }
         req = remain;
@@ -3848,6 +3853,7 @@ os_thread_suspend(thread_record_t *tr)
         if (ksynch_wait(&ostd->suspended, 0, SUSPEND_DEBUG_TIMEOUT_MS) == -ETIMEDOUT) {
             ASSERT_CURIOSITY(false && "failed to suspend thread in 5s");
         }
+        LOG(GLOBAL, LOG_SYNCH, 2, "os_thread_suspend: suspended = %d for thread %d\n", ksynch_get_value(&ostd->suspended), tr->id);
         if (ksynch_get_value(&ostd->suspended) == 0) {
             /* If it still has to wait, give up the cpu. */
             os_thread_yield();
diff --git a/core/unix/os_exports.h b/core/unix/os_exports.h
index c234c265c..304819704 100644
--- a/core/unix/os_exports.h
+++ b/core/unix/os_exports.h
@@ -299,6 +299,7 @@ dynamorio_set_envp(char **envp);
 /* drinjectlib wants the libc version while the core wants the private version */
 #    define getenv our_getenv
 #endif
+DR_API
 char *
 our_getenv(const char *name);
 
diff --git a/core/unix/rseq_linux.c b/core/unix/rseq_linux.c
index 4d3b9e60f..4ce713450 100644
--- a/core/unix/rseq_linux.c
+++ b/core/unix/rseq_linux.c
@@ -253,12 +253,14 @@ rseq_clear_tls_ptr(dcontext_t *dcontext)
 {
     ASSERT(rseq_tls_offset != 0);
     byte *base = get_app_segment_base(LIB_SEG_TLS);
-    struct rseq *app_rseq = (struct rseq *)(base + rseq_tls_offset);
-    /* We're directly writing this in the cache, so we do not bother with safe_read
-     * or safe_write here either.  We already cannot handle rseq adversarial cases.
-     */
-    if (is_dynamo_address((byte *)(ptr_uint_t)app_rseq->rseq_cs))
-        app_rseq->rseq_cs = 0;
+    if (base > 0) {
+        struct rseq *app_rseq = (struct rseq *)(base + rseq_tls_offset);
+        /* We're directly writing this in the cache, so we do not bother with safe_read
+         * or safe_write here either.  We already cannot handle rseq adversarial cases.
+         */
+        if (is_dynamo_address((byte *)(ptr_uint_t)app_rseq->rseq_cs))
+            app_rseq->rseq_cs = 0;
+    }
 }
 
 int
diff --git a/core/unix/signal.c b/core/unix/signal.c
index 0cbc94337..51ef52f80 100644
--- a/core/unix/signal.c
+++ b/core/unix/signal.c
@@ -3193,20 +3193,10 @@ thread_set_self_context(void *cxt)
     ASSERT_NOT_IMPLEMENTED(false); /* PR 405694: can't use regular sigreturn! */
 #endif
     memset(&frame, 0, sizeof(frame));
-#if defined(X86)
-    dcontext_t *dcontext = get_thread_private_dcontext();
-#endif
 #ifdef LINUX
-#    ifdef X86
-    byte *xstate = get_and_initialize_xstate_buffer(dcontext);
-    frame.uc.uc_mcontext.fpstate = &((kernel_xstate_t *)xstate)->fpstate;
-#    endif /* X86 */
     frame.uc.uc_mcontext = *sc;
 #endif
     IF_ARM(ASSERT_NOT_TESTED());
-#if defined(X86)
-    save_fpstate(dcontext, &frame);
-#endif
     /* The kernel calls do_sigaltstack on sys_rt_sigreturn primarily to ensure
      * the frame is ok, but the side effect is we can mess up our own altstack
      * settings if we're not careful.  Having invalid ss_size looks good for
@@ -3295,7 +3285,9 @@ thread_set_self_mcontext(priv_mcontext_t *mc)
     sig_full_cxt_t sc_full;
     sig_full_initialize(&sc_full, &ucxt);
 #if defined(LINUX) && defined(X86)
-    sc_full.sc->fpstate = NULL; /* for mcontext_to_sigcontext */
+    /* for mcontext_to_sigcontext to fill in with saved fp state */
+     sc_full.sc->fpstate = (kernel_fpstate_t *)get_and_initialize_xstate_buffer(
+         get_thread_private_dcontext());
 #endif
     mcontext_to_sigcontext(&sc_full, mc, DR_MC_ALL);
     thread_set_segment_registers(sc_full.sc);

```

`patches/make_patches.sh`:

```sh
#!/bin/bash

cd cpython/ && git diff > ../patches/cpython-3.10.12.patch && cd ..
cd dynamorio/ && git diff > ../patches/dynamorio-10.0.patch && cd ..

```

`pyda_core/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

add_compile_definitions(PYDA_VERSION="${CMAKE_PROJECT_VERSION}")

add_library(tool SHARED tool.c pyda_core_py.c pyda_core.c pyda_threads.c pyda_unwind.c pyda_patch_python.c)
find_package(DynamoRIO)
if (NOT DynamoRIO_FOUND)
  message(FATAL_ERROR "DynamoRIO package required to build")
endif(NOT DynamoRIO_FOUND)

find_package(Python3 3.10 EXACT COMPONENTS Interpreter Development)
if (NOT Python3_FOUND)
  message(FATAL_ERROR "Python required to build")
endif(NOT Python3_FOUND)

target_include_directories(tool PRIVATE ${Python3_INCLUDE_DIRS})
target_link_libraries(tool ${Python3_LIBRARIES} unwind)
target_compile_options(tool PUBLIC -DPYDA_DYNAMORIO_CLIENT -Werror)

configure_DynamoRIO_client(tool)
use_DynamoRIO_extension(tool drmgr)
use_DynamoRIO_extension(tool drcontainers)
#use_DynamoRIO_extension(tool drtools)

# the standalone python shared library (no dynamorio linked here)
# add_library(pyda_core SHARED pyda_core_py.c pyda_core.c)
# set_target_properties(pyda_core PROPERTIES PREFIX "")
# target_include_directories(pyda_core PRIVATE ${Python3_INCLUDE_DIRS})
# target_link_libraries(pyda_core ${Python3_LIBRARIES} unwind)

```

`pyda_core/privload.h`:

```h

app_pc locate_and_load_private_library(const char *name, bool reachable);
app_pc get_private_library_address(void *handle, const char *symbol);

// duplicated from dynamorio
typedef struct _privmod_t {
    app_pc base;
    size_t size;
    const char *name;
    char path[MAXIMUM_PATH];
    uint ref_count;
    bool externally_loaded;
    bool is_client; /* or Extension */
    bool called_proc_entry;
    bool called_proc_exit;
    struct _privmod_t *next;
    struct _privmod_t *prev;
    void *os_privmod_data;
} privmod_t;
privmod_t *privload_lookup_by_pc_takelock(app_pc pc);
void privload_relocate_mod_takelock(privmod_t *mod);

typedef struct _redirect_import_t {
    const char *name;
    app_pc func;
    app_pc app_func; /* Used only for dl_iterate_phdr over app libs, so far. */
} redirect_import_t;

extern redirect_import_t *client_redirect_imports;
extern int client_redirect_imports_count;

```

`pyda_core/pyda_core.c`:

```c

#include "pyda_core.h"
#include "pyda_threads.h"
#include "util.h"
#include <fcntl.h>
#include <pty.h>

#define CONTEXT_STACK_LIMIT 10

#ifndef PYDA_DYNAMORIO_CLIENT

pyda_process* pyda_mk_process() {
    // TODO: We might be able to use this to fork and launch the process
    // (in which the entire python file will be reparsed...)
    ABORT_IF_NODYNAMORIO;
}

#else
#include "dr_api.h"

static void free_hook(void *data) {
    // Must hold GIL
    pyda_hook *hook = (pyda_hook*)data;
    Py_DECREF(hook->py_func);
    hook->py_func = NULL;
    dr_global_free(hook, sizeof(pyda_hook));
}

static void thread_prepare_for_python_entry(PyGILState_STATE *gstate, pyda_thread *t, void* pc);
static void thread_prepare_for_python_return(PyGILState_STATE *gstate, pyda_thread *t, void* hook_addr);


pyda_process* pyda_mk_process() {
    ABORT_IF_NODYNAMORIO;

    pyda_process *proc = dr_global_alloc(sizeof(pyda_process));
    proc->refcount = 0; // xxx: will be incremented to 1 by first pyda_mk_thread
    proc->flush_count = 0;
    drvector_init(&proc->threads, 0, true, NULL);
    drvector_init(&proc->thread_run_untils, 0, true, NULL);

    proc->main_thread = pyda_mk_thread(proc);
    hashtable_init_ex(&proc->callbacks, 4, HASH_INTPTR, false, false, free_hook, NULL, NULL);

    proc->thread_init_hook = NULL;
    proc->syscall_pre_hook = NULL;
    proc->syscall_post_hook = NULL;
    proc->py_obj = NULL;

    // Setup locks, etc.
    pthread_condattr_t condattr;
    int ret;
    if (ret = pthread_condattr_setpshared(&condattr, PTHREAD_PROCESS_SHARED)) {
        dr_fprintf(STDERR, "pthread_condattr_setpshared failed: %d\n", ret);
        dr_abort();
    }
    if (ret = pthread_cond_init(&proc->thread_exit_cond, &condattr)) {
        dr_fprintf(STDERR, "pthread_cond_init failed %d\n", ret);
        dr_abort();
    }

    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    if (ret = pthread_mutex_init(&proc->refcount_mutex, &attr)) {
        dr_fprintf(STDERR, "pthread_mutex_init failed %d\n", ret);
        dr_abort();
    }

    // Setup I/O
    proc->stdin_fd = -1;
    proc->stdout_fd = -1;
    proc->stderr_fd = -1;

    // TODO: also need to modify dynamorio printing functions
    // as they use raw fd 0/1/2
    return proc;
}

extern file_t our_stderr;

void pyda_capture_io(pyda_process *proc, int use_pty, int pty_raw) {
    if (use_pty) {
        int master, slave;

        if (openpty(&master, &slave, NULL, NULL, NULL)) {
            // Failed to open TTY
            DEBUG_PRINTF("Failed to open TTY err %s\n", strerror(errno));
            use_pty = false;
        } else {
            dup2(slave, 0);
            dup2(slave, 1);
            dup2(slave, 2);
            proc->stdin_fd = dup(master);
            proc->stdout_fd = dup(master);
            proc->stderr_fd = dup(master);

            // Modify tty attributes
            struct termios tmios;
            if (tcgetattr(master, &tmios)) {
                DEBUG_PRINTF("Failed to get termios\n");
            } else {
                if (pty_raw)
                    cfmakeraw(&tmios);

                // Always: no echo
                tmios.c_lflag &= ~(ECHO);

                if (tcsetattr(master, TCSANOW, &tmios)) {
                    DEBUG_PRINTF("Failed to set termios\n");
                }
            }
        }
    }

    if (!use_pty) { // We were asked not to use a pty, or pty init failed
        int pipe1[2], pipe2[2], pipe3[2];
        if (pipe(pipe1) || pipe(pipe2) || pipe(pipe3)) {
            dr_fprintf(STDERR, "Failed to create pipes\n");
            dr_abort();
        }

        // Try to make a larger pipe (1M)
        if (fcntl(pipe1[0], F_SETPIPE_SZ, 1024*1024) || fcntl(pipe2[0], F_SETPIPE_SZ, 1024*1024) || fcntl(pipe3[0], F_SETPIPE_SZ, 1024*1024)) {
            DEBUG_PRINTF("Failed to set pipe size to 1M\n");
        }

        dup2(pipe1[0], 0);
        dup2(pipe2[1], 1);
        dup2(pipe3[1], 2);

        proc->stdin_fd = pipe1[1];
        proc->stdout_fd = pipe2[0];
        proc->stderr_fd = pipe3[0];
    }

    // nonblocking
    if (fcntl(proc->stdout_fd, F_SETFL, O_NONBLOCK) || fcntl(proc->stderr_fd, F_SETFL, O_NONBLOCK) || fcntl(proc->stdin_fd, F_SETFL, O_NONBLOCK)) {
        dr_fprintf(STDERR, "Failed to set stdio to nonblocking\n");
        dr_abort();
    }
}

// NOTE: This is called from thread_init_event on the main app thread
void pyda_prepare_io(pyda_process *proc) {
    // This sets up three new FDs for Pyda to
    // direct its output to. We set stdin/out/err to
    // the new FDs here, which occurs prior to Python startup
    //
    // Thus, Python will also use these new fds by default.

    int orig_in = dup(0);
    int orig_out = dup(1);
    int orig_err = dup(2);

    stdin = fdopen(orig_in, "r");
    stdout = fdopen(orig_out, "w");
    stderr = fdopen(orig_err, "w");

    our_stderr = orig_err;
}

static void free_context(void *ptr) {
    dr_global_free(ptr, sizeof(dr_mcontext_t));
}

pyda_thread* pyda_mk_thread(pyda_process *proc) {
    ABORT_IF_NODYNAMORIO;

    pyda_thread *thread = dr_global_alloc(sizeof(pyda_thread));
    pthread_condattr_t condattr;
    pthread_condattr_init(&condattr);
    int ret;
    if (ret = pthread_condattr_setpshared(&condattr, PTHREAD_PROCESS_SHARED)) {
        dr_fprintf(STDERR, "pthread_condattr_setpshared failed: %d\n", ret);
        dr_abort();
    }
    if (ret = pthread_cond_init(&thread->resume_cond, &condattr)) {
        dr_fprintf(STDERR, "pthread_cond_init failed %d\n", ret);
        dr_abort();
    }

    if (pthread_cond_init(&thread->break_cond, &condattr)) {
        dr_fprintf(STDERR, "pthread_cond_init failed\n");
        dr_abort();
    }

    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(&thread->mutex, &attr);

    // Start with it locked...
    pthread_mutex_lock(&thread->mutex);

    thread->python_yielded = 0;
    thread->app_yielded = 0;
    thread->proc = proc;

    dr_atomic_add32_return_sum(&thread->proc->refcount, 1);

    thread->yield_count = 0;

    static volatile unsigned int tid = 0;
    thread->tid = dr_atomic_add32_return_sum(&tid, 1);
    thread->rip_updated_in_python = 0;
    thread->skip_next_hook = 0;
    thread->python_exited = 0;
    thread->app_exited = 0;
    thread->errored = 0;
    thread->python_blocked_on_io = 0;
    thread->run_until = 0;
    thread->signal = 0;
    thread->dirty_run_until = 0;
    thread->flush_ts = proc->flush_count;

    drvector_init(&thread->context_stack, 0, true, free_context);
    drvector_init(&thread->hook_update_queue, 0, true, NULL);

    drvector_append(&proc->threads, thread);
    drvector_append(&proc->thread_run_untils, NULL);

    // PyErr_SetString(PyExc_RuntimeError, "OK");
    return thread;
}

void pyda_process_destroy(pyda_process *p) {
    // We must be holding the GIL lock so we can drop the refs
    if (PyGILState_Check()) {
        DEBUG_PRINTF("pyda_process_destroy already holds GIL.")
    }
    PyGILState_STATE gstate = PyGILState_Ensure();

    DEBUG_PRINTF("pyda_process_destroy\n");
    if (p->thread_init_hook)
        Py_DECREF(p->thread_init_hook);

    p->thread_init_hook = NULL;

    if (p->syscall_pre_hook)
        Py_DECREF(p->syscall_pre_hook);

    p->syscall_pre_hook = NULL;

    if (p->syscall_post_hook)
        Py_DECREF(p->syscall_post_hook);

    p->syscall_post_hook = NULL;

    hashtable_delete(&p->callbacks);
    drvector_delete(&p->threads);
    drvector_delete(&p->thread_run_untils);

    dr_global_free(p, sizeof(pyda_process));

    PyGILState_Release(gstate);
}

void pyda_thread_destroy(pyda_thread *t) {
    DEBUG_PRINTF("pyda_thread_destroy for idx %d\n", t->tid);
    pthread_mutex_lock(&t->proc->refcount_mutex);

    int new_refcount = dr_atomic_add32_return_sum(&t->proc->refcount, -1);
    if (new_refcount == 0) {
        pyda_process_destroy(t->proc);
    } else {
        pthread_cond_signal(&t->proc->thread_exit_cond);
        pthread_mutex_unlock(&t->proc->refcount_mutex);
    }

    drvector_delete(&t->context_stack);
    drvector_delete(&t->hook_update_queue);

    dr_global_free(t, sizeof(pyda_thread));
}

void pyda_thread_destroy_last(pyda_thread *t) {
    // wait for this thread to be the final thread
    pthread_mutex_lock(&t->proc->refcount_mutex);
    while (t->proc->refcount > 1)
        pthread_cond_wait(&t->proc->thread_exit_cond, &t->proc->refcount_mutex);

    DEBUG_PRINTF("pyda_thread_destroy_last unblock\n")
    pthread_mutex_unlock(&t->proc->refcount_mutex);
    pyda_thread_destroy(t);
}

void pyda_yield_noblock(pyda_thread *t) {
    t->python_yielded = 1;
    pthread_mutex_lock(&t->mutex);
    pthread_cond_broadcast(&t->resume_cond);
    pthread_mutex_unlock(&t->mutex);
}

// yield from python to the executable
void pyda_yield(pyda_thread *t) {
    t->python_yielded = 1;
    t->yield_count++;

    // here we wait for the executable to signal

    pthread_mutex_lock(&t->mutex);
    pthread_cond_broadcast(&t->resume_cond);

    while (!t->app_yielded)
        pthread_cond_wait(&t->break_cond, &t->mutex);

    t->app_yielded = 0;
    pthread_mutex_unlock(&t->mutex);

}

void pyda_break_noblock(pyda_thread *t) {
    t->app_yielded = 1;
    pthread_mutex_lock(&t->mutex);
    pthread_cond_broadcast(&t->break_cond);
    pthread_mutex_unlock(&t->mutex);
}

// yield from the executable back to python
void pyda_break(pyda_thread *t) {
    t->app_yielded = 1;

    // Hack to tell dynamorio that dr_flush_region on another thread is OK
    // here -- this is not REALLY safe per the docs but we use
    // dr_redirect_execution so we *should* always return to a valid fragment...
    // dr_mark_safe_to_suspend(dr_get_current_drcontext(), true);

    // here we wait for the python to signal
    pthread_mutex_lock(&t->mutex);
    pthread_cond_broadcast(&t->break_cond);

    while (!t->python_yielded)
        pthread_cond_wait(&t->resume_cond, &t->mutex);

    // dr_mark_safe_to_suspend(dr_get_current_drcontext(), false);

    t->python_yielded = 0;
    pthread_mutex_unlock(&t->mutex);
}

void pyda_initial_break(pyda_thread *t) {
    // lock is already held
    while (!t->python_yielded)
        pthread_cond_wait(&t->resume_cond, &t->mutex);

    t->python_yielded = 0;
    pthread_mutex_unlock(&t->mutex);
}

PyObject *pyda_run_until(pyda_thread *proc, uint64_t addr) {
    DEBUG_PRINTF("run_until: %llx\n", addr);
    return NULL;
}

void pyda_add_hook(pyda_process *p, uint64_t addr, PyObject *callback) {
    pyda_hook *cb = dr_global_alloc(sizeof(pyda_hook));
    cb->py_func = callback;

    Py_INCREF(callback);
    DEBUG_PRINTF("pyda_add_hook %p %p for %llx\n", cb, cb->py_func, addr);

    cb->callback_type = 0;
    cb->addr = (void*)addr;


    // void *drcontext = dr_get_current_drcontext();
    // dr_where_am_i_t whereami = dr_where_am_i(drcontext, (void*)addr, NULL);
    // DEBUG_PRINTF("Hook is in %lu\n", whereami);

    if (!hashtable_add(&p->callbacks, (void*)addr, cb)) {
        dr_global_free(cb, sizeof(pyda_hook));
        dr_fprintf(STDERR, "Failed to add hook at %p\n", (void*)addr);
        dr_abort();
    }

    
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    drvector_append(&t->hook_update_queue, (void*)addr);
}

void pyda_remove_hook(pyda_process *p, uint64_t addr) {
    hashtable_remove(&p->callbacks, (void*)addr);

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    drvector_append(&t->hook_update_queue, (void*)addr);
}

void pyda_set_thread_init_hook(pyda_process *p, PyObject *callback) {
    // NOTE: GIL is held

    if (p->thread_init_hook)
        Py_DECREF(p->thread_init_hook);

    p->thread_init_hook = callback;
    Py_INCREF(callback);
}

void pyda_set_syscall_pre_hook(pyda_process *p, PyObject *callback) {
    // NOTE: GIL is held

    if (p->syscall_pre_hook)
        Py_DECREF(p->syscall_pre_hook);

    p->syscall_pre_hook = callback;
    Py_INCREF(callback);
}

void pyda_set_syscall_post_hook(pyda_process *p, PyObject *callback) {
    // NOTE: GIL is held

    if (p->syscall_post_hook)
        Py_DECREF(p->syscall_post_hook);

    p->syscall_post_hook = callback;
    Py_INCREF(callback);
}

int pyda_flush_hooks() {
    void *drcontext = dr_get_current_drcontext();
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    pyda_process *p = t->proc;

    int flushed = 0;
    if (t->dirty_run_until) {
        void *run_until = pyda_get_run_until(t);
        if (run_until) dr_flush_region((void*)run_until, 1);
        t->dirty_run_until = 0;
        flushed = 1;
    }

    if (t->hook_update_queue.entries) {
        flushed = 1;

        // Copy to temporary, alternate storage so we don't hold the lock
        int entry_count = t->hook_update_queue.entries;
        void **tmp = dr_thread_alloc(drcontext, sizeof(void*) * entry_count);
        if (!tmp) {
            dr_fprintf(STDERR, "dr_thread_alloc failed");
            dr_abort();
        }
        memcpy(tmp, t->hook_update_queue.array, sizeof(void*) * entry_count);
        t->hook_update_queue.entries = 0;

        // Flush deleted hooks
        for (int i=0; i<entry_count; i++) {
            DEBUG_PRINTF("dr_flush_region: %llx\n", tmp[i]);
            dr_flush_region(tmp[i], 1);
            DEBUG_PRINTF("dr_flush_region end %llx\n", tmp[i]);

            // race lol
            p->flush_count++;
        }

        dr_thread_free(drcontext, tmp, sizeof(void*) * entry_count);
    }

    if (t->flush_ts != p->flush_count) {
        // Require that dr_redirect_execution is used, since another thread may have flushed
        // us during the dr_mark_safe_to_suspend section in thread_prepare_for_python_entry
        //
        // note: right now other threads cannot flush us
        flushed = 1;
        t->flush_ts = p->flush_count;
    }


    return flushed;
}
pyda_hook* pyda_get_callback(pyda_process *p, void* addr) {
    pyda_hook *cb = (void*)hashtable_lookup(&p->callbacks, addr);

    if (cb && cb->callback_type == 0) {
        return cb;
    }

    return NULL;
}

void *pyda_get_run_until(pyda_thread *t) {
    return (void*)t->run_until;
}

void pyda_set_run_until(pyda_thread *t, void *pc) {
    t->run_until = (uint64_t)pc;
    t->dirty_run_until = 1;
    drvector_set_entry(&t->proc->thread_run_untils, t->tid-1, pc);
    // NOTE: Will be flushed by pyda_break callers. Don't need to flush here.
}

void pyda_clear_run_until(pyda_thread *t) {
    uint64_t run_until = t->run_until;
    t->run_until = 0;
    t->dirty_run_until = 1;
    drvector_set_entry(&t->proc->thread_run_untils, t->tid-1, NULL);

    if (run_until)
        dr_flush_region((void*)run_until, 1);
}

int pyda_check_run_until(pyda_process *proc, void *test_pc) {
    // Unlocked for performance.
    for (int i=0; i<proc->thread_run_untils.entries; i++) {
        if (test_pc == proc->thread_run_untils.array[i]) return 1;
    }
    return 0;
}

static void thread_prepare_for_python_entry(PyGILState_STATE *gstate, pyda_thread *t, void* pc) {
    if (gstate) {
        // HACK: dr_mark_safe_to_suspend is not allowed in a cleancall, per the docs.
        // We sortof get away with this because we check later to see if any flushes
        // occurred during this period, and force a dr_redirect_execution if they did.
        t->flush_ts = t->proc->flush_count;

        // dr_mark_safe_to_suspend(dr_get_current_drcontext(), true);
        *gstate = PyGILState_Ensure();
        // dr_mark_safe_to_suspend(dr_get_current_drcontext(), false);
    }

    void *drcontext = dr_get_current_drcontext();
    t->cur_context.size = sizeof(dr_mcontext_t);
    t->cur_context.flags = DR_MC_ALL; // dr_redirect_execution requires it
    dr_get_mcontext(drcontext, &t->cur_context);

    if (pc)
        t->cur_context.pc = (app_pc)pc;

    t->rip_updated_in_python = 0;
}

static void thread_prepare_for_python_return(PyGILState_STATE *gstate, pyda_thread *t, void* hook_addr) {
    void *drcontext = dr_get_current_drcontext();

    // Syscall hooks are not allowed to modify PC
    if (!hook_addr) {
        if (t->rip_updated_in_python) {
            dr_fprintf(STDERR, "\n[Pyda] ERROR: Syscall hooks are not allowed to modify PC. Skipping future hooks.\n");
            dr_flush_file(STDERR);
            t->errored = 1;
        }
        dr_set_mcontext(drcontext, &t->cur_context);
        if (t->hook_update_queue.entries > 0) {
            dr_fprintf(STDERR, "\n[Pyda] WARN: Hooks should not be modified in a syscall. This is UB, continuing.\n");
        }
        if (gstate) PyGILState_Release(*gstate);
        return;
    }

    if (t->cur_context.pc == (app_pc)hook_addr && t->rip_updated_in_python) {
        dr_fprintf(STDERR, "\n[Pyda] ERROR: Hook updated RIP to the same address. This is UB. Skipping future hooks.\n");
        dr_flush_file(STDERR);
        t->errored = 1;
    }

    if (pyda_flush_hooks() || t->rip_updated_in_python) {
        // XXX: We might not be holding the GIL here (in run_until case) -- is hash-table locked?
        if (t->cur_context.pc == hook_addr && (pyda_get_callback(t->proc, hook_addr) || pyda_get_run_until(t) == hook_addr)) {
            t->skip_next_hook = 1;
        }
        // we need to call dr_redirect_execution
        if (gstate) PyGILState_Release(*gstate);
        dr_redirect_execution(&t->cur_context);
    } else {
        dr_set_mcontext(drcontext, &t->cur_context);
        if (gstate) PyGILState_Release(*gstate);
    }
}

void pyda_hook_cleancall(pyda_hook *cb) {
    PyGILState_STATE gstate;
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);

    if (t->skip_next_hook) {
        t->skip_next_hook = 0;
        return;
    }

    if (t->errored) return;

    DEBUG_PRINTF("cleancall %p %p %p tid=%d\n", cb->addr, cb->py_func, t, dr_get_thread_id(dr_get_current_drcontext()));
    thread_prepare_for_python_entry(&gstate, t, cb->addr);
    DEBUG_PRINTF("cleancall LOCKED %p %p %p\n", cb->addr, cb->py_func, t);

    PyObject *result = PyObject_CallFunctionObjArgs(cb->py_func, t->proc->py_obj, NULL);

    if (result == NULL) {
        dr_fprintf(STDERR, "\n[Pyda] ERROR: Hook call failed. Skipping future hooks on thread %d\n", t->tid);

        dr_flush_file(STDERR);
        t->errored = 1;
        PyErr_Print();
        dr_fprintf(STDERR, "\n");
        // dr_abort();
        if (getenv("PYDA_ABORT_ON_ERROR") && getenv("PYDA_ABORT_ON_ERROR")[0] == '1') {
            dr_fprintf(STDERR, "\n[Pyda] ABORTING (will crash now)\n");
            *(int*)(1) = 1;
        }
    } else {
        Py_DECREF(result);
    }

    DEBUG_PRINTF("cleancall ret %p %p %p\n", cb, cb->py_func, t);

    PyGILState_Release(gstate);

    // If this also happens to be the run_until target for this thread,
    // we deal with that here (instead of inserting two hooks)
    if (!t->python_exited && cb->addr == pyda_get_run_until(t)) {
        // It is UB to modify PC in a hook that is also the run_until target
        if (t->rip_updated_in_python) {
            dr_fprintf(STDERR, "\n[Pyda] ERROR: Hook updated RIP, but run_until target is hit. This is UB. Continuing.");
            dr_flush_file(STDERR);
            t->errored = 1;
        }

        // Clear the run_until flag and flush the block
        pyda_clear_run_until(t);

        // Wait for Python to yield back to us
        pyda_break(t);
    }

    thread_prepare_for_python_return(NULL, t, cb->addr); // MAY NOT RETURN
}

int pyda_hook_syscall(int syscall_num, int is_pre) {
    PyGILState_STATE gstate;
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (t->errored) return 1;

    if (is_pre == 0 && (syscall_num == 0 || syscall_num == 1) && t->python_blocked_on_io) { // read/write
        t->python_blocked_on_io = 0;
        thread_prepare_for_python_entry(NULL, t, NULL);
        pyda_break(t);
        thread_prepare_for_python_return(NULL, t, NULL);

        if (t->errored) return 1;
    }

    PyObject *hook = (is_pre ? t->proc->syscall_pre_hook : t->proc->syscall_post_hook);
    if (!hook) return 1;

    thread_prepare_for_python_entry(&gstate, t, NULL);

    DEBUG_PRINTF("syscall %d pre %d\n", syscall_num, is_pre);

    int should_run = 1;

    PyObject *syscall_num_obj = PyLong_FromLong(syscall_num);
    PyObject *result = PyObject_CallFunctionObjArgs(hook, t->proc->py_obj, syscall_num_obj, NULL);

    Py_DECREF(syscall_num_obj);

    if (result == NULL) {
        dr_fprintf(STDERR, "\n[Pyda] ERROR: Syscall hook call failed. Skipping future hooks on thread %d\n", t->tid);
        dr_flush_file(STDERR);
        t->errored = 1;
        PyErr_Print();
        dr_fprintf(STDERR, "\n");
    } else if (is_pre && PyBool_Check(result)) {
        // Should run
        should_run = PyObject_IsTrue(result);
        DEBUG_PRINTF("syscall pre_hook returned %d\n", should_run);
    } else {
        Py_DECREF(result);
        DEBUG_PRINTF("syscall hook returned non-bool\n");
    }

    DEBUG_PRINTF("syscall ret %d pre %d\n", syscall_num, is_pre);
    thread_prepare_for_python_return(&gstate, t, NULL);

    return should_run;
}

void pyda_hook_rununtil_reached(void *pc) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (t->errored || t->python_exited) return;
    if (t->skip_next_hook) {
        t->skip_next_hook = 0;
        return;
    }

    if (pyda_get_run_until(t) == pc) {
        thread_prepare_for_python_entry(NULL, t, pc);

        // Clear the run_until flag and flush the block
        pyda_clear_run_until(t);

        // Wait for Python to yield back to us
        pyda_break(t);
        thread_prepare_for_python_return(NULL, t, pc); // MAY NOT RETURN
    } else {
        // This can actually happen in two cases:
        // 1. The code cache entry was not flushed (BUG in Pyda!) after a run_until
        // 2. Another thread set this run_until hook (This is fine.)
        DEBUG_PRINTF("STALE run_until reached: %llx\n", pc);
    }
}

int pyda_push_context(pyda_thread *t) {
    if (t->context_stack.entries >= CONTEXT_STACK_LIMIT) return 0; // arbitrary limit

    dr_mcontext_t *new = dr_global_alloc(sizeof(dr_mcontext_t));
    memcpy(new, &t->cur_context, sizeof(dr_mcontext_t));
    drvector_append(&t->context_stack, new);
    return 1;
}

int pyda_pop_context(pyda_thread *t) {
    drvector_lock(&t->context_stack);
    if (t->context_stack.entries == 0) return 0;
    t->context_stack.entries--;
    memcpy(&t->cur_context, t->context_stack.array[t->context_stack.entries], sizeof(dr_mcontext_t));
    free_context(t->context_stack.array[t->context_stack.entries]);
    drvector_unlock(&t->context_stack);
    return 1;
}

#endif

```

`pyda_core/pyda_core.h`:

```h

#ifndef PYDA_CORE_H
#define PYDA_CORE_H

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#define Py_BUILD_CORE
#include <internal/pycore_condvar.h>
#undef Py_BUILD_CORE

#include <dr_api.h>
#include "hashtable.h"
#include "drvector.h"


extern int is_dynamorio_running;
typedef struct pyda_hook_s pyda_hook;
typedef struct pyda_thread_s pyda_thread;
typedef struct pyda_process_s pyda_process;

// Since we have multiple threads running, we need to keep track of
// which one is holding the GIL.

struct pyda_hook_s {
    PyObject *py_func;
    int callback_type;
    void *addr;
};

struct pyda_process_s {
    int refcount;

    pyda_thread *main_thread;
    PyObject *thread_init_hook;
    PyObject *syscall_pre_hook;
    PyObject *syscall_post_hook;

    PyObject *py_obj;

    pthread_cond_t thread_exit_cond;
    pthread_mutex_t refcount_mutex;

    int stdin_fd, stdout_fd, stderr_fd;

    void* entrypoint;

#ifdef PYDA_DYNAMORIO_CLIENT
    hashtable_t callbacks;
    drvector_t threads;
    drvector_t thread_run_untils; // vec of pcs
    int flush_count;
#endif

};

struct pyda_thread_s {
    unsigned long tid;

    pthread_cond_t resume_cond;
    pthread_cond_t break_cond;
    pthread_mutex_t mutex;

    int python_yielded, app_yielded;
    int python_blocked_on_io;

    pyda_process *proc;

    int rip_updated_in_python;
    int skip_next_hook; // Used when redirecting execution to same PC after a clean-call

    int python_exited; // Did this thread's python thread exit?
    int app_exited; // Did this thread's app thread exit?
    int errored; // Did some Pyda-misuse occur, or did the Python thread throw during a hook?

    int yield_count;
    uint64_t run_until;
    int dirty_run_until;

    int signal; // 0 if no signal, otherwise the signal number

#ifdef PYDA_DYNAMORIO_CLIENT
    dr_mcontext_t cur_context;
    drvector_t context_stack;

    // thread-local list of hooks to be flushed; guarantees that changes go into
    // effect when expected: e.g., when returning from a hook
    drvector_t hook_update_queue;

    // records the last seen proc->flush_count so that we don't return into a stale fragment
    int flush_ts; 
#endif
};

struct pyda_bt_entry {
    char modname[128];
    uint64_t offset;
    char sym_name[512];
    uint64_t ip;
    uint64_t sp;
};


pyda_process* pyda_mk_process();
pyda_thread* pyda_mk_thread(pyda_process*);

void pyda_capture_io(pyda_process *p, int use_pty, int pty_raw);
void pyda_prepare_io(pyda_process *p);

void pyda_process_destroy(pyda_process *p);
void pyda_thread_destroy(pyda_thread *t);
void pyda_thread_destroy_last(pyda_thread *t);

PyObject *pyda_run_until(pyda_thread *, uint64_t addr);

// yield from python to the executable
void pyda_yield(pyda_thread *t);
void pyda_yield_noblock(pyda_thread *t); // used when thread entry hook returns, we don't need to return to python.

// break from the executable to python
void pyda_break(pyda_thread *t);
void pyda_break_noblock(pyda_thread *t); // used when app exits, no need to return to it.

void pyda_initial_break(pyda_thread *t);
void pyda_add_hook(pyda_process *p, uint64_t addr, PyObject *callback);
void pyda_remove_hook(pyda_process *p, uint64_t addr);
void pyda_set_thread_init_hook(pyda_process *p, PyObject *callback);
void pyda_set_syscall_pre_hook(pyda_process *p, PyObject *callback);
void pyda_set_syscall_post_hook(pyda_process *p, PyObject *callback);
pyda_hook* pyda_get_callback(pyda_process *p, void* addr);

void* pyda_get_run_until(pyda_thread *t);
void pyda_set_run_until(pyda_thread *t, void *pc);
void pyda_clear_run_until(pyda_thread *t);
int pyda_check_run_until(pyda_process *proc, void *test_pc);

// These can only be called from application threads
int pyda_flush_hooks();
void pyda_hook_cleancall(pyda_hook *cb);
int pyda_hook_syscall(int syscall_num, int is_pre);
void pyda_hook_rununtil_reached(void *pc);

int pyda_push_context(pyda_thread *t);
int pyda_pop_context(pyda_thread *t);

int pyda_get_backtrace (pyda_thread *t, drvector_t *res);

#ifndef PYDA_DYNAMORIO_CLIENT

#define ABORT_IF_NODYNAMORIO {\
    PyErr_SetString(PyExc_RuntimeError, "This script must be run through the pyda CLI"); \
    return NULL;\
}

#else

#define ABORT_IF_NODYNAMORIO if (!is_dynamorio_running) {\
    PyErr_SetString(PyExc_RuntimeError, "This script must be run through the pyda CLI"); \
    return NULL;\
}

#endif


#endif // PYDA_CORE_H

```

`pyda_core/pyda_core_py.c`:

```c
#include "pyda_core_py.h"
#include "pyda_core.h"
#include "pyda_threads.h"
#include "util.h"

#ifdef PYDA_DYNAMORIO_CLIENT
#include "dr_api.h"
#endif

int is_dynamorio_running = 0;

typedef struct {
    PyObject_HEAD
    pyda_thread *main_thread; // main thread
} PydaProcess;

static PyObject* pyda_core_process(PyObject *self, PyObject *args, PyObject *kwargs);
static PyObject* pyda_core_free(PyObject *self, PyObject *args, PyObject *kwargs);
static PyObject *pyda_list_modules(PyObject *self, PyObject *noarg);
static PyObject *pyda_get_base(PyObject *self, PyObject *args);
static PyObject *pyda_get_module_for_addr(PyObject *self, PyObject *args);
static PyObject *pyda_get_current_thread_id(PyObject *self, PyObject *noarg);

static void PydaProcess_dealloc(PydaProcess *self);
static PyObject *PydaProcess_run(PyObject *self, PyObject *noarg);
static PyObject *PydaProcess_run_until_io(PyObject *self, PyObject *noarg);
static PyObject *PydaProcess_run_until_pc(PyObject *self, PyObject *arg);
static PyObject *PydaProcess_exited(PyObject *self, PyObject *noarg);
static PyObject *PydaProcess_capture_io(PyObject *self, PyObject *noarg);
static PyObject *PydaProcess_register_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_unregister_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_thread_init_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_get_register(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_register(PyObject *self, PyObject *args);
static PyObject *PydaProcess_read(PyObject *self, PyObject *args);
static PyObject *PydaProcess_write(PyObject *self, PyObject *args);
static PyObject *PydaProcess_get_main_module(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_syscall_filter(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_syscall_pre_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_set_syscall_post_hook(PyObject *self, PyObject *args);
static PyObject *PydaProcess_push_state(PyObject *self, PyObject *args);
static PyObject *PydaProcess_pop_state(PyObject *self, PyObject *args);
static PyObject *PydaProcess_backtrace(PyObject *self, PyObject *noarg);

static PyMethodDef PydaGlobalMethods[] = {
    {"process",  (PyCFunction)pyda_core_process, METH_KEYWORDS | METH_VARARGS,
     "Start a process."},
    {"list_modules",  (PyCFunction)pyda_list_modules, METH_NOARGS,
     "List all the modules."},
    {"get_base",  (PyCFunction)pyda_get_base, METH_VARARGS,
     "Get base address for module"},
    {"get_module_for_addr",  (PyCFunction)pyda_get_module_for_addr, METH_VARARGS,
     "Get module info for addr"},
    {"get_current_thread_id",  (PyCFunction)pyda_get_current_thread_id, METH_NOARGS,
     "Get current thread id, numbered from 1"},
    {"free",  (PyCFunction)pyda_core_free, METH_KEYWORDS | METH_VARARGS,
     "Call into the allocator used by the rest of the tool."},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static struct PyModuleDef pyda_module = {
    PyModuleDef_HEAD_INIT,
    "pyda_core",   /* name of module */
    NULL, /* module documentation, may be NULL */
    -1,       /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
    PydaGlobalMethods
};

static PyObject *MemoryError;
static PyObject *ThreadExitError;
static PyObject *InvalidStateError;
static PyObject *FatalSignalError;

static void register_exception(PyObject *mod, PyObject **target, const char *fullname, const char *name) {
    *target = PyErr_NewException(fullname, NULL, NULL);
    Py_XINCREF(*target);
    if (PyModule_AddObject(mod, name, *target) < 0) {
        Py_XDECREF(*target);
        Py_CLEAR(*target);
    }
}

PyMODINIT_FUNC
PyInit_pyda_core(void) {
    PyObject *m = PyModule_Create(&pyda_module);

    register_exception(m, &MemoryError, "pyda.MemoryError", "MemoryError");
    register_exception(m, &ThreadExitError, "pyda.ThreadExitError", "ThreadExitError");
    register_exception(m, &InvalidStateError, "pyda.InvalidStateError", "InvalidStateError");
    register_exception(m, &FatalSignalError, "pyda.FatalSignalError", "FatalSignalError");

#if defined(X86)
    PyModule_AddIntConstant(m, "REG_RAX", DR_REG_RAX);
    PyModule_AddIntConstant(m, "REG_RBX", DR_REG_RBX);
    PyModule_AddIntConstant(m, "REG_RCX", DR_REG_RCX);
    PyModule_AddIntConstant(m, "REG_RDX", DR_REG_RDX);
    PyModule_AddIntConstant(m, "REG_RSI", DR_REG_RSI);
    PyModule_AddIntConstant(m, "REG_RDI", DR_REG_RDI);
    PyModule_AddIntConstant(m, "REG_RBP", DR_REG_RBP);
    PyModule_AddIntConstant(m, "REG_RSP", DR_REG_RSP);
    PyModule_AddIntConstant(m, "REG_R8", DR_REG_R8);
    PyModule_AddIntConstant(m, "REG_R9", DR_REG_R9);
    PyModule_AddIntConstant(m, "REG_R10", DR_REG_R10);
    PyModule_AddIntConstant(m, "REG_R11", DR_REG_R11);
    PyModule_AddIntConstant(m, "REG_R12", DR_REG_R12);
    PyModule_AddIntConstant(m, "REG_R13", DR_REG_R13);
    PyModule_AddIntConstant(m, "REG_R14", DR_REG_R14);
    PyModule_AddIntConstant(m, "REG_R15", DR_REG_R15);
    PyModule_AddIntConstant(m, "REG_RIP", PYDA_REG_PC);
    PyModule_AddIntConstant(m, "REG_PC", PYDA_REG_PC);
    PyModule_AddIntConstant(m, "REG_FSBASE", PYDA_REG_FSBASE);
    PyModule_AddIntConstant(m, "REG_XMM0", DR_REG_XMM0);
    PyModule_AddIntConstant(m, "REG_XMM1", DR_REG_XMM1);
    PyModule_AddIntConstant(m, "REG_XMM2", DR_REG_XMM2);
    PyModule_AddIntConstant(m, "REG_XMM3", DR_REG_XMM3);
    PyModule_AddIntConstant(m, "REG_XMM4", DR_REG_XMM4);
    PyModule_AddIntConstant(m, "REG_XMM5", DR_REG_XMM5);
    PyModule_AddIntConstant(m, "REG_XMM6", DR_REG_XMM6);
    PyModule_AddIntConstant(m, "REG_XMM7", DR_REG_XMM7);
    PyModule_AddIntConstant(m, "REG_ARG1", DR_REG_RDI);
    PyModule_AddIntConstant(m, "REG_ARG2", DR_REG_RSI);
    PyModule_AddIntConstant(m, "REG_ARG3", DR_REG_RDX);
    PyModule_AddIntConstant(m, "REG_ARG4", DR_REG_RCX);
    PyModule_AddIntConstant(m, "REG_ARG5", DR_REG_R8);
    PyModule_AddIntConstant(m, "REG_ARG6", DR_REG_R9);
#elif defined(AARCH64)
    PyModule_AddIntConstant(m, "REG_X0", DR_REG_X0);
    PyModule_AddIntConstant(m, "REG_X1", DR_REG_X1);
    PyModule_AddIntConstant(m, "REG_X2", DR_REG_X2);
    PyModule_AddIntConstant(m, "REG_X3", DR_REG_X3);
    PyModule_AddIntConstant(m, "REG_X4", DR_REG_X4);
    PyModule_AddIntConstant(m, "REG_X5", DR_REG_X5);
    PyModule_AddIntConstant(m, "REG_X6", DR_REG_X6);
    PyModule_AddIntConstant(m, "REG_X7", DR_REG_X7);
    PyModule_AddIntConstant(m, "REG_X8", DR_REG_X8);
    PyModule_AddIntConstant(m, "REG_X9", DR_REG_X9);
    PyModule_AddIntConstant(m, "REG_X10", DR_REG_X10);
    PyModule_AddIntConstant(m, "REG_X11", DR_REG_X11);
    PyModule_AddIntConstant(m, "REG_X12", DR_REG_X12);
    PyModule_AddIntConstant(m, "REG_X13", DR_REG_X13);
    PyModule_AddIntConstant(m, "REG_X14", DR_REG_X14);
    PyModule_AddIntConstant(m, "REG_X15", DR_REG_X15);
    PyModule_AddIntConstant(m, "REG_X16", DR_REG_X16);
    PyModule_AddIntConstant(m, "REG_X17", DR_REG_X17);
    PyModule_AddIntConstant(m, "REG_X18", DR_REG_X18);
    PyModule_AddIntConstant(m, "REG_X19", DR_REG_X19);
    PyModule_AddIntConstant(m, "REG_X20", DR_REG_X20);
    PyModule_AddIntConstant(m, "REG_X21", DR_REG_X21);
    PyModule_AddIntConstant(m, "REG_X22", DR_REG_X22);
    PyModule_AddIntConstant(m, "REG_X23", DR_REG_X23);
    PyModule_AddIntConstant(m, "REG_X24", DR_REG_X24);
    PyModule_AddIntConstant(m, "REG_X25", DR_REG_X25);
    PyModule_AddIntConstant(m, "REG_X26", DR_REG_X26);
    PyModule_AddIntConstant(m, "REG_X27", DR_REG_X27);
    PyModule_AddIntConstant(m, "REG_X28", DR_REG_X28);
    PyModule_AddIntConstant(m, "REG_X29", DR_REG_X29);
    PyModule_AddIntConstant(m, "REG_X30", DR_REG_X30);
    PyModule_AddIntConstant(m, "REG_SP", DR_REG_SP);
    PyModule_AddIntConstant(m, "REG_PC", PYDA_REG_PC);
    PyModule_AddIntConstant(m, "REG_ARG1", DR_REG_R0);
    PyModule_AddIntConstant(m, "REG_ARG2", DR_REG_R1);
    PyModule_AddIntConstant(m, "REG_ARG3", DR_REG_R2);
    PyModule_AddIntConstant(m, "REG_ARG4", DR_REG_R3);
    PyModule_AddIntConstant(m, "REG_ARG5", DR_REG_R4);
    PyModule_AddIntConstant(m, "REG_ARG6", DR_REG_R5);
#endif

    return m;
}

/* Process class */

static PyMethodDef PydaProcessMethods[] = {
    {"run",  PydaProcess_run, METH_NOARGS, "Run"},
    {"run_until_pc",  PydaProcess_run_until_pc, METH_VARARGS, "Run until PC is reached"},
    {"run_until_io",  PydaProcess_run_until_io, METH_NOARGS, "Run until IO syscall"},
    {"capture_io", PydaProcess_capture_io, METH_NOARGS, "Capture IO -- returns IO fds"},
    {"register_hook",  PydaProcess_register_hook, METH_VARARGS, "Register a hook"},
    {"unregister_hook",  PydaProcess_unregister_hook, METH_VARARGS, "Un-register a hook"},
    {"set_thread_init_hook",  PydaProcess_set_thread_init_hook, METH_VARARGS, "Register thread init hook"},
    {"get_register",  PydaProcess_get_register, METH_VARARGS, "Get a specific register"},
    {"set_register",  PydaProcess_set_register, METH_VARARGS, "Set a specific register"},
    {"get_main_module",  PydaProcess_get_main_module, METH_VARARGS, "Get name of main module"},
    {"read",  PydaProcess_read, METH_VARARGS, "Read memory"},
    {"write",  PydaProcess_write, METH_VARARGS, "Write memory"},
    {"exited",  PydaProcess_exited, METH_NOARGS, "Check if thread has exited"},
    // {"set_syscall_filter",  PydaProcess_set_syscall_filter, METH_VARARGS, "Set list of syscalls to call hooks on"},
    {"set_syscall_pre_hook",  PydaProcess_set_syscall_pre_hook, METH_VARARGS, "Register syscall pre hook"},
    {"set_syscall_post_hook",  PydaProcess_set_syscall_post_hook, METH_VARARGS, "Register syscall post hook"},
    {"push_state",  PydaProcess_push_state, METH_VARARGS, "Push register state (thread-local)"},
    {"pop_state",  PydaProcess_pop_state, METH_VARARGS, "Pop register state (thread-local)"},
    {"backtrace", PydaProcess_backtrace, METH_NOARGS, "Returns backtrace (array of tuples)"},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

static PyTypeObject PydaProcess_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "custom.Custom",
    .tp_doc = PyDoc_STR("Custom objects"),
    .tp_basicsize = sizeof(PydaProcess),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_new = PyType_GenericNew,
    .tp_dealloc = (destructor)PydaProcess_dealloc,
    .tp_methods = PydaProcessMethods,
};


static PyObject *
pyda_core_process(PyObject *self, PyObject *args, PyObject *kwargs) {
    ABORT_IF_NODYNAMORIO;

    const char *name;
    PydaProcess *result = NULL;

    Py_buffer bin_path;

    static char *kwlist[] = {"name", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s*", kwlist, &bin_path))
        return NULL;

    *(char*)(bin_path.buf + bin_path.len) = '\0';

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (t != t->proc->main_thread) {
        PyErr_SetString(PyExc_RuntimeError, "Only the main thread is currently allowed to call process().");
        return NULL;
    }

    if (t->proc->py_obj) {
        PyErr_SetString(PyExc_RuntimeError, "You may only call process() once");
        return NULL;
    }

    PyType_Ready(&PydaProcess_Type);
    result = PyObject_NEW(PydaProcess, &PydaProcess_Type);
    if (result != NULL)
        result->main_thread = t;

    t->proc->py_obj = (PyObject*)result;

    PyBuffer_Release(&bin_path);
    return (PyObject*)result;
}

static PyObject *
pyda_core_free(PyObject *self, PyObject *args, PyObject *kwargs) {
    unsigned long addr;
    if (!PyArg_ParseTuple(args, "K", &addr))
        return NULL;

    free((void*)addr);

    Py_INCREF(Py_None);
    return Py_None;
}

static int check_valid_thread(pyda_thread *t) {
    if (!t) {
        PyErr_SetString(PyExc_RuntimeError, "Threads created with Python threading APIs cannot use Pyda APIs");
        return 1;
    }
    return 0;
}

static int check_python_thread(pyda_thread *t) {
    if (pyda_thread_getspecific(g_pyda_tls_is_python_thread_idx) != (void*)1) {
        PyErr_SetString(InvalidStateError, ".run()/.run_until() cannot be called from hooks.");
        return 1;
    }
    return 0;
}

static int check_exited(pyda_thread *t) {
    if (check_valid_thread(t)) return 1;
    if (t->app_exited) {
        PyErr_SetString(InvalidStateError, "Thread has already exited; cannot be resumed");
        return 1;
    }
    return 0;
}
static int check_signal(pyda_thread *t) {
    if (t->signal) {
        PyObject *tuple = PyTuple_New(3);
        PyTuple_SetItem(tuple, 0, PyLong_FromLong(t->signal));
        PyTuple_SetItem(tuple, 1, PyLong_FromLong(t->tid));
        PyTuple_SetItem(tuple, 2, PydaProcess_backtrace(NULL, NULL));
        PyErr_SetObject(FatalSignalError, tuple);
        return 1;
    }
    return 0;
}

static PyObject *
PydaProcess_run(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_python_thread(t)) return NULL;
    if (check_exited(t)) return NULL;

    Py_BEGIN_ALLOW_THREADS
    pyda_yield(t);
#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("yield returned\n");
#endif // PYDA_DYNAMORIO_CLIENT
    Py_END_ALLOW_THREADS

    if (check_signal(t)) return NULL;

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_run_until_io(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_python_thread(t)) return NULL;
    if (check_exited(t)) return NULL;

    t->python_blocked_on_io = 1;


    // todo: assert that this thread is like, actually blocked

    Py_BEGIN_ALLOW_THREADS
    pyda_yield(t);
#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("yield after io returned\n");
#endif // PYDA_DYNAMORIO_CLIENT
    Py_END_ALLOW_THREADS

    if (t->app_exited) {
        PyErr_SetString(ThreadExitError, "Thread exited while Pyda was waiting on I/O.");
        return NULL;
    }

    if (check_signal(t)) return NULL;

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_capture_io(PyObject* self, PyObject *noarg) {
    PydaProcess *p = (PydaProcess*)self;
    pyda_process *proc = p->main_thread->proc;

    if (!getenv("PYDA_NO_CAPTURE") || getenv("PYDA_NO_CAPTURE")[0] != '1') {
        int no_pty = (getenv("PYDA_NO_PTY") && getenv("PYDA_NO_PTY")[0] == '1');
        int no_raw = (getenv("PYDA_NO_RAW") && getenv("PYDA_NO_RAW")[0] == '1');
        pyda_capture_io(proc, !no_pty, !no_raw);
    }

    if (proc->stdin_fd == -1) {
        PyErr_SetString(PyExc_RuntimeError, "IO was not captured");
        return NULL;
    }

    PyObject *list = PyList_New(0);
    PyList_Append(list, PyLong_FromLong(proc->stdin_fd));
    PyList_Append(list, PyLong_FromLong(proc->stdout_fd));
    PyList_Append(list, PyLong_FromLong(proc->stderr_fd));

    return list;
}

static PyObject *
PydaProcess_backtrace(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    drvector_t backtrace;

    int ret = pyda_get_backtrace(t, &backtrace);

    PyObject *list = PyList_New(0);
    for (int i=0; i<backtrace.entries; i++) {
        struct pyda_bt_entry *e = backtrace.array[i];

        PyObject *tuple = PyTuple_New(4);
        PyTuple_SetItem(tuple, 0, PyLong_FromLong(e->ip));
        PyTuple_SetItem(tuple, 1, PyUnicode_FromString(e->modname));
        PyTuple_SetItem(tuple, 2, PyLong_FromLong(e->offset));
        PyTuple_SetItem(tuple, 3, PyUnicode_FromString(e->sym_name));
        PyList_Append(list, tuple);
    }

    drvector_delete(&backtrace);

    if (ret) {
        Py_DECREF(list);
        PyErr_SetString(PyExc_RuntimeError, "Could not generate backtrace");
        return NULL;
    }

    return list;
}

static PyObject *
PydaProcess_run_until_pc(PyObject* self, PyObject *args) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_python_thread(t)) return NULL;
    if (check_exited(t)) return NULL;

    unsigned long addr;
    if (!PyArg_ParseTuple(args, "K", &addr))
        return NULL;

    pyda_set_run_until(t, (void*)addr);

    Py_BEGIN_ALLOW_THREADS
    pyda_yield(t);
#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("yield returned\n");
#endif // PYDA_DYNAMORIO_CLIENT
    Py_END_ALLOW_THREADS

    if (t->app_exited) {
        PyErr_SetString(ThreadExitError, "Thread exited before reaching run_until target.");
        return NULL;
    }

    if (check_signal(t)) return NULL;

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_exited(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_valid_thread(t)) return NULL;
    if (t->app_exited) {
        Py_INCREF(Py_True);
        return Py_True;
    }
    Py_INCREF(Py_False);
    return Py_False;
}

static PyObject *
pyda_list_modules(PyObject* self, PyObject *noarg) {
#ifdef PYDA_DYNAMORIO_CLIENT
    PyObject *list = PyList_New(0);
    dr_module_iterator_t *iter = dr_module_iterator_start();
    while (dr_module_iterator_hasnext(iter)) {
        module_data_t *mod = dr_module_iterator_next(iter);
        PyList_Append(list, PyUnicode_FromString(mod->full_path));
    }
    dr_module_iterator_stop(iter);
    return list;
#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
pyda_get_current_thread_id(PyObject* self, PyObject *noarg) {
#ifdef PYDA_DYNAMORIO_CLIENT
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_valid_thread(t)) return NULL;
    int tid = t->tid;
    return PyLong_FromLong(tid);
#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static void
PydaProcess_dealloc(PydaProcess *self)
{
    Py_TYPE(self)->tp_free((PyObject *) self);
}

static PyObject *
PydaProcess_get_register(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    unsigned long long reg_id;

    if (!PyArg_ParseTuple(args, "K", &reg_id))
        return NULL;

#ifdef PYDA_DYNAMORIO_CLIENT
    // DEBUG_PRINTF("get_register: %s\n", regname);
    dr_mcontext_t *mc = &t->cur_context;

    // TODO: Fix... copilot wrote this. Surely we can write
    // a macro...

    if (reg_id == PYDA_REG_PC) {
        return PyLong_FromUnsignedLong((unsigned long)mc->pc);
    } else if (reg_id == PYDA_REG_FSBASE) {
        return PyLong_FromUnsignedLong((unsigned long)dr_get_tls_field(dr_get_current_drcontext()));
    }

    opnd_size_t sz = reg_get_size(reg_id);
    if (!(sz == OPSZ_4 || sz == OPSZ_8 || sz == OPSZ_16 || sz == OPSZ_32)) {
        PyErr_SetString(PyExc_RuntimeError, "Unsupported register size");
        return NULL;
    }

    uint64_t val[4] = {0};
    reg_get_value_ex(reg_id, mc, (uint8_t*)&val);

    if (sz == OPSZ_8) {
        // fast path
        return PyLong_FromUnsignedLong(val[0]);
    }

    // Convert to decimal string
    char buf[64];
    if (snprintf(buf, sizeof(buf), "0x%lx%lx", val[1], val[0]) >= sizeof(buf)) {
        PyErr_SetString(PyExc_RuntimeError, "Internal error: reg buffer too small");
        return NULL;
    }

    PyObject *ret = PyLong_FromString(buf, NULL, 16);
    if (!ret) {
        PyErr_SetString(PyExc_RuntimeError, "Internal error: failed to convert string to long");
        return NULL;
    }

    return ret;

#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_set_register(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    unsigned long long reg_id;
    PyObject *val;

    if (!PyArg_ParseTuple(args, "KO", &reg_id, &val))
        return NULL;

    if (!PyLong_Check(val)) {
        PyErr_SetString(PyExc_RuntimeError, "Value must be an integer");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    // DEBUG_PRINTF("get_register: %s\n", regname);
    dr_mcontext_t *mc = &t->cur_context;

    uint64_t raw[4] = {0};
    _PyLong_AsByteArray((PyLongObject *)val, (unsigned char*)&raw, sizeof(raw), 1, 0);

    DEBUG_PRINTF("set_register: %llx %llx\n", reg_id, raw[0]);

    if (reg_id == PYDA_REG_PC) {
        mc->pc = (void*)raw[0];
        t->rip_updated_in_python = 1;
    } else {
        if (!reg_set_value_ex(reg_id, mc, (uint8_t*)&raw)) {
            PyErr_SetString(PyExc_RuntimeError, "Failed to set register");
            return NULL;
        }
    }


#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_register_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    unsigned long long addr;
    PyObject *callback;

    if (!PyArg_ParseTuple(args, "KO!", &addr, &PyFunction_Type, &callback))
        return NULL;

    PyCodeObject *code = (PyCodeObject*)PyFunction_GetCode(callback);
    if (!code || code->co_argcount != 1) {
        PyErr_SetString(PyExc_RuntimeError, "Callback must take one argument");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("register_hook: %llx\n", addr);
    if (!dr_memory_is_readable((app_pc)addr, 1)) {
        char buf[100];
        snprintf(buf, sizeof(buf), "Hooked PC %" PRIxPTR " is invalid.", (uintptr_t)addr);
        PyErr_SetString(PyExc_RuntimeError, buf);
        return NULL;
    }

    pyda_add_hook(p->main_thread->proc, addr, callback);

#endif // PYDA_DYNAMORIO_CLIENT
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_set_thread_init_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    PyObject *callback;

    if (!PyArg_ParseTuple(args, "O!", &PyFunction_Type, &callback))
        return NULL;

    PyCodeObject *code = (PyCodeObject*)PyFunction_GetCode(callback);
    if (!code || code->co_argcount != 1) {
        PyErr_SetString(PyExc_RuntimeError, "Callback must take one argument");
        return NULL;
    }
#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("set_thread_init_hook\n");
#endif

    // note: pyda_set_thread_init_hook calls incref
    pyda_set_thread_init_hook(p->main_thread->proc, callback);

    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
PydaProcess_set_syscall_pre_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    PyObject *callback;

    if (!PyArg_ParseTuple(args, "O!", &PyFunction_Type, &callback))
        return NULL;

    PyCodeObject *code = (PyCodeObject*)PyFunction_GetCode(callback);
    if (!code || code->co_argcount != 2) {
        PyErr_SetString(PyExc_RuntimeError, "Callback must take two arguments");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("set_syscall_pre_hook\n");
#endif

    // note: pyda_set_syscall_pre_hook calls incref
    pyda_set_syscall_pre_hook(p->main_thread->proc, callback);

    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
PydaProcess_set_syscall_post_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    PyObject *callback;

    if (!PyArg_ParseTuple(args, "O!", &PyFunction_Type, &callback))
        return NULL;

    PyCodeObject *code = (PyCodeObject*)PyFunction_GetCode(callback);
    if (!code || code->co_argcount != 2) {
        PyErr_SetString(PyExc_RuntimeError, "Callback must take two arguments");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("set_syscall_post_hook\n");
#endif

    // note: pyda_set_syscall_pre_hook calls incref
    pyda_set_syscall_post_hook(p->main_thread->proc, callback);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_unregister_hook(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;

    unsigned long long addr;

    if (!PyArg_ParseTuple(args, "K", &addr)) {
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("unregister_hook: %llx\n", addr);
#endif // PYDA_DYNAMORIO_CLIENT
    pyda_remove_hook(p->main_thread->proc, addr);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_get_main_module(PyObject *self, PyObject *args) {
    const char *name;

    if (!PyArg_ParseTuple(args, ""))
        return NULL;

    PyObject *result = NULL;

#ifdef PYDA_DYNAMORIO_CLIENT
    module_data_t *mod = dr_get_main_module();

    if (!mod) {
        PyErr_SetString(PyExc_RuntimeError, "Module not found");
        return NULL;
    }

    // Return a string with the name of the main module
    result = PyUnicode_FromString(mod->full_path);
#else
    PyErr_SetString(PyExc_RuntimeError, "Not implemented outside of dynamorio");
    return NULL;
#endif

    return (PyObject*)result;
}


static PyObject *
pyda_get_base(PyObject *self, PyObject *args) {
    const char *name;

    Py_buffer bin_path;

    if (!PyArg_ParseTuple(args, "s*", &bin_path))
        return NULL;

    *(char*)(bin_path.buf + bin_path.len) = '\0';

    PyObject *result = NULL;

#ifdef PYDA_DYNAMORIO_CLIENT
    dr_module_iterator_t *iter = dr_module_iterator_start();
    while (dr_module_iterator_hasnext(iter)) {
        module_data_t *mod = dr_module_iterator_next(iter);
        if (strstr(mod->full_path, bin_path.buf)) {
            // Return the base address as python number
            result = PyLong_FromUnsignedLong((unsigned long)mod->start);
            break;
        }
    }

    if (!result) {
        PyErr_SetString(PyExc_RuntimeError, "Module not found");
        return NULL;
    }
#else
    PyErr_SetString(PyExc_RuntimeError, "Not implemented outside of dynamorio");
    return NULL;
#endif
    PyBuffer_Release(&bin_path);

    return (PyObject*)result;
}

static PyObject *
pyda_get_module_for_addr(PyObject *self, PyObject *args) {
    unsigned long addr;
    if (!PyArg_ParseTuple(args, "K", &addr))
        return NULL;

    PyObject *result = NULL;

#ifdef PYDA_DYNAMORIO_CLIENT
    unsigned char *base;
    size_t size;
    unsigned int prot;
    unsigned long perms = 0;
    if (dr_query_memory((void*)addr, &base, &size, &prot)) {
        if (prot & DR_MEMPROT_READ) {
            perms |= 4;
        }
        if (prot & DR_MEMPROT_WRITE) {
            perms |= 2;
        }
        if (prot & DR_MEMPROT_EXEC) {
            perms |= 1;
        }
    }

    result = PyList_New(0);
    module_data_t *mod = dr_lookup_module((void*)addr);
    if (mod) {
        PyList_Append(result, PyUnicode_FromString(mod->full_path));
        PyList_Append(result, PyLong_FromUnsignedLong((unsigned long)mod->start));
        PyList_Append(result, PyLong_FromUnsignedLong((unsigned long)mod->end));
        PyList_Append(result, PyLong_FromUnsignedLong(perms));

        dr_free_module_data(mod);
        return result;
    } else {
        PyList_Append(result, PyUnicode_FromString("unknown"));
        PyList_Append(result, PyLong_FromUnsignedLong((unsigned long)base));
        PyList_Append(result, PyLong_FromUnsignedLong((unsigned long)base + size));
        PyList_Append(result, PyLong_FromUnsignedLong(perms));
        return result;
    }

#else
    PyErr_SetString(PyExc_RuntimeError, "Not implemented outside of dynamorio");
    return NULL;
#endif

    Py_INCREF(Py_None);
    return Py_None;
}


static PyObject *
PydaProcess_read(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;


    unsigned long addr;
    unsigned long count;
    if (!PyArg_ParseTuple(args, "KK", &addr, &count))
        return NULL;

    if (count > 0x1000000) {
        PyErr_SetString(PyExc_RuntimeError, "Unreasonable read size");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    // DEBUG_PRINTF("read: %lx %lx\n", addr, count);
    void *buf = malloc(count);
    int success = dr_safe_read((void*)addr, count, buf, NULL);
    if (!success) {
        PyErr_SetString(MemoryError, "Failed to read memory");
        free(buf);
        return NULL;
    }
    PyObject *result = PyBytes_FromStringAndSize(buf, count);
    free(buf);
    return result;
#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}


static PyObject *
PydaProcess_write(PyObject *self, PyObject *args) {
    PydaProcess *p = (PydaProcess*)self;


    unsigned long addr;
    const char *data;
    Py_ssize_t len;
    if (!PyArg_ParseTuple(args, "Ks#", &addr, &data, &len))
        return NULL;

    if (len > 0x1000000) {
        PyErr_SetString(PyExc_RuntimeError, "Unreasonable write size");
        return NULL;
    }

#ifdef PYDA_DYNAMORIO_CLIENT
    DEBUG_PRINTF("write: %lx %lx\n", addr, len);
    int success = dr_safe_write((void*)addr, len, data, NULL);
    if (!success) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to write memory");
        return NULL;
    }
#endif // PYDA_DYNAMORIO_CLIENT

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_push_state(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    // NOTE: Before we entered python, we saved the state (see: calls to dr_get_mcontext)
    if (!pyda_push_context(t)) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to push state");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PydaProcess_pop_state(PyObject* self, PyObject *noarg) {
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    if (check_exited(t)) return NULL;

    if (!pyda_pop_context(t)) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to pop state");
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}

```

`pyda_core/pyda_core_py.h`:

```h
#define PY_SSIZE_T_CLEAN
#include <Python.h>
PyMODINIT_FUNC PyInit_pyda_core(void);

#define PYDA_REG_PC 0xb33f0001
#define PYDA_REG_FSBASE 0xb33f0002
```

`pyda_core/pyda_patch_python.c`:

```c

#include "pyda_core.h"
#include "pyda_threads.h"
#ifdef PYDA_DYNAMORIO_CLIENT

#include "dr_api.h"
#include "dr_tools.h"
#include "drmgr.h"
#include "privload.h"

static redirect_import_t python_redirect_imports[] = {
    { "pthread_key_create", (app_pc)pyda_thread_key_create },
    { "pthread_key_delete", (app_pc)pyda_thread_key_delete },
    { "pthread_getspecific", (app_pc)pyda_thread_getspecific },
    { "pthread_setspecific", (app_pc)pyda_thread_setspecific },
    { "pthread_cond_init", (app_pc)pyda_cond_init },
    { "pthread_cond_timedwait", (app_pc)pyda_cond_timedwait },
    { "pthread_cond_signal", (app_pc)pyda_cond_signal },
    { "pthread_mutex_init", (app_pc)pyda_mutex_init },
    { "pthread_self", (app_pc)pyda_thread_self },
    { "pthread_create", (app_pc)pyda_thread_create },
    { "pthread_detach", (app_pc)pyda_thread_detach },
    { "dlopen", (app_pc)pyda_dlopen },
    { "dlsym", (app_pc)pyda_dlsym },
    { "getauxval", (app_pc)pyda_getauxval },
    { "getenv", (app_pc)pyda_getenv }
};

#define NUM_NEW_IMPORTS (sizeof(python_redirect_imports) / sizeof(redirect_import_t))
void patch_python() {
    // // module_data_t *mod = dr_lookup_module_by_name("libpython3.10.so.1.0");
    // // iterate over modules

    // if (!mod) {
    //     dr_fprintf(STDERR, "Could not find libpython3.10.so.1.0\n");
    //     return;
    // }

    // // Find beginning of got
    // for (int i=0; i < mod->num_segments; i++) {
    //     module_segment_data_t *seg = &mod->segments[0];
    //     if ((seg->prot & DR_MEMPROT_READ | DR_MEMPROT_WRITE) == DR_MEMPROT_READ | DR_MEMPROT_WRITE) {
    //         dr_fprintf(STDERR, "Found writable segment at %p\n", seg->start);
    //     }
    // }

    client_redirect_imports = python_redirect_imports;
    client_redirect_imports_count = NUM_NEW_IMPORTS;
    privmod_t *mod = privload_lookup_by_pc_takelock((app_pc)&PyRun_SimpleString);
    privload_relocate_mod_takelock(mod);
}
#endif

```

`pyda_core/pyda_threads.c`:

```c
// We use this so that we have dr_set_tls_field
#define STATIC_DRMGR_ONLY
#include "pyda_threads.h"

#include "dr_api.h"
#include "dr_tools.h"
#include "drmgr.h"
#include "privload.h"
#include "Python.h"
#include "util.h"
#include <sys/auxv.h>

// These are used by python as shims to dynamorio-safe pthread functions

int pyda_thread_setspecific(pthread_key_t key, void *val);

int pyda_thread_key_create(pthread_key_t *p2newkey, void *unused) {
    int field = drmgr_register_tls_field();
    DR_ASSERT(field != -1);
    DEBUG_PRINTF("pthread_thread_key_create %d\n", field);
    *p2newkey = (pthread_key_t)field;
    pyda_thread_setspecific(field, 0);
    return 0;
}
int pyda_thread_key_delete(pthread_key_t key) {
    // nop
    return 0;
}
void* pyda_thread_getspecific(pthread_key_t key) {
    void *drcontext = dr_get_current_drcontext();
    void* result =  drmgr_get_tls_field(drcontext, (int)key);
    // DEBUG_PRINTF("pthread_thread_key_getspecific %d result %lx\n", key, (unsigned long)result);
    return result;
}
int pyda_thread_setspecific(pthread_key_t key, void *val) {
    void *drcontext = dr_get_current_drcontext();
    bool result = drmgr_set_tls_field(drcontext, (int)key, val);
    // DEBUG_PRINTF("pthread_thread_key_setspecific %d val %lx result %d\n", key, (unsigned long)val, result);
    return result != 1;
}

int pyda_cond_init(pthread_cond_t *condvar, const pthread_condattr_t *attr) {
    // DEBUG_PRINTF("pthread_cond_init %p\n", condvar);
    int res;
    if (attr) {
        pthread_condattr_setpshared((pthread_condattr_t*)attr, PTHREAD_PROCESS_SHARED);
        res = pthread_cond_init(condvar, attr);
    } else {
        pthread_condattr_t attr2;
        pthread_condattr_init(&attr2);
        pthread_condattr_setpshared(&attr2, PTHREAD_PROCESS_SHARED);
        res = pthread_cond_init(condvar, &attr2);
        pthread_condattr_destroy(&attr2);
    }

    return res;
}
int pyda_cond_timedwait(pthread_cond_t *condvar, pthread_mutex_t *mutex, const struct timespec *abstime) {
    // DEBUG_PRINTF("pthread_cond_timedwait %p %p ids %d\n", condvar, mutex, getpid());
    int result = pthread_cond_timedwait(condvar, mutex, abstime);
    return result;
}
int pyda_cond_signal(pthread_cond_t *condvar) {
    // DEBUG_PRINTF("pthread_cond_signal %p ids %d\n", condvar, getpid());
    return pthread_cond_signal(condvar);
}

void* pyda_dlopen(const char *filename, int flag) {
    void *drcontext = dr_get_current_drcontext();
    // DEBUG_PRINTF("pyda_dlopen %s\n", filename);
    // DR_ASSERT(IS_CLIENT_THREAD(drcontext));
    if (filename == NULL) {
        void *retaddr = __builtin_return_address(0);
        privmod_t *mod = privload_lookup_by_pc_takelock(retaddr);
        if (mod != NULL)
            return mod->base;
        else
            return NULL;
    } else {
        return locate_and_load_private_library(filename, true);
    }
}

void* pyda_dlsym(void *handle, const char *symbol) {
    void *drcontext = dr_get_current_drcontext();
    // DEBUG_PRINTF("pyda_dlsym %s\n", symbol);
    // DR_ASSERT(IS_CLIENT_THREAD(drcontext));
    return get_private_library_address(handle, symbol);
}

int pyda_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr) {
    // DEBUG_PRINTF("pthread_mutex_init %p\n", mutex);
    int res;
    if (attr) {
        pthread_mutexattr_setpshared((pthread_mutexattr_t*)attr, PTHREAD_PROCESS_SHARED);
        res = pthread_mutex_init(mutex, attr);
    } else {
        pthread_mutexattr_t attr2;
        pthread_mutexattr_init(&attr2);
        pthread_mutexattr_setpshared(&attr2, PTHREAD_PROCESS_SHARED);
        res = pthread_mutex_init(mutex, &attr2);
        pthread_mutexattr_destroy(&attr2);
    }

    return res;
}

void* pyda_thread_self() {
    // XXX: We *could* try to return our pyda-specific tid -- but there
    // are technically two threads with that tid!! (Python and App).
    // If we returned the same ID for two python threads,
    // it seems likely it would break things.
    //
    // Instead, we are just going to return the dynamorio thread id
    return (void*)(uintptr_t)dr_get_thread_id(dr_get_current_drcontext());
}

extern void __ctype_init();
void* python_thread_init(void *pyda_thread) {
    __ctype_init();

    void *drcontext = dr_get_current_drcontext();
    void *tls = dr_thread_alloc(drcontext, sizeof(void*) * 130);
    memset(tls, 0, sizeof(void*) * 130);
    dr_set_tls_field(drcontext, (void *)tls);

    dr_client_thread_set_suspendable(false);
    pyda_thread_setspecific(g_pyda_tls_idx, (void*)pyda_thread);
    pyda_thread_setspecific(g_pyda_tls_is_python_thread_idx, (void*)1);
    return tls;
}

struct thread_start {
    void *(*start_routine) (void *);
    void *arg;
    // void *pyda_thread;
};

static void client_thread_init(void *arg) {
    struct thread_start *ts = (struct thread_start*)arg;
    void *tls = python_thread_init(NULL);
    ts->start_routine(ts->arg);
    DEBUG_PRINTF("start_routine returned\n");
    dr_client_thread_set_suspendable(true);
    dr_thread_free(dr_get_current_drcontext(), tls, sizeof(void*) * 130);
    dr_global_free(ts, sizeof(struct thread_start));
}

int pyda_thread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg) {
    DEBUG_PRINTF("pthread_create %p %p %p %p\n", thread, attr, start_routine, arg);

    struct thread_start *ts = dr_global_alloc(sizeof(struct thread_start));
    ts->start_routine = start_routine;
    ts->arg = arg;
    // ts->pyda_thread = pyda_thread_getspecific(g_pyda_tls_idx);
    dr_create_client_thread(client_thread_init, ts);
    *thread = (pthread_t)0x13371337;
    return 0;
}

int pyda_thread_detach(pthread_t thread) {
    // nop
    DEBUG_PRINTF("pthread_detach %p\n", thread);
    return 0;
}


extern size_t os_minsigstksz(void);
unsigned long pyda_getauxval(unsigned long type) {
    DEBUG_PRINTF("getauxval %lx\n", type);
    if (type == AT_MINSIGSTKSZ) {
        return os_minsigstksz();
    }
    return getauxval(type);
}

int pyda_attach_mode;

extern const char *our_getenv(const char *name);
const char *pyda_getenv(const char *name) {
    if (pyda_attach_mode || true) {
        // Dynamorio does not have the correct ENV in attach mode.
        DEBUG_PRINTF("getenv2 %s=%s\n", name, getenv(name));
        return getenv(name);
    } else {
        DEBUG_PRINTF("getenv %s=%s\n", name, our_getenv(name));
        return our_getenv(name);
    }
}

void parse_proc_environ() {
    FILE *f = fopen("/proc/self/environ", "r");
    if (!f) {
        DEBUG_PRINTF("Failed to open /proc/self/environ\n");
        return;
    }

    // /proc/self/environ is a NULL-separated list of strings
    // each of the form KEY=VALUE

    // We store the new environment in attach_env
    // and we will use that in the attach mode.

    char buf[4096];
    size_t len = fread(buf, 1, sizeof(buf), f);
    fclose(f);

    if (len == sizeof(buf)) {
        DEBUG_PRINTF("Warning: /proc/self/environ too large\n");
    }

    char *key = buf;
    while (key < buf + len) {
        char *k = strtok(key, "=");
        char *v = key + strlen(k) + 1;
        DEBUG_PRINTF("setenv %s=%s\n", k, v);
        setenv(k, v, 0);
        key = v + strlen(v) + 1;
    }

}

```

`pyda_core/pyda_threads.h`:

```h
#include <pthread.h>
extern int g_pyda_tls_idx;
extern int g_pyda_tls_is_python_thread_idx;
int pyda_thread_setspecific(pthread_key_t key, void *val);
void* pyda_thread_getspecific(pthread_key_t key);

int pyda_thread_key_create(pthread_key_t *p2newkey, void *unused);
int pyda_thread_key_delete(pthread_key_t key);
void* pyda_thread_getspecific(pthread_key_t key);
int pyda_thread_setspecific(pthread_key_t key, void *val);
int pyda_cond_init(pthread_cond_t *condvar, const pthread_condattr_t *attr);
int pyda_cond_timedwait(pthread_cond_t *condvar, pthread_mutex_t *mutex, const struct timespec *abstime);
int pyda_cond_signal(pthread_cond_t *condvar);
int pyda_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

void* pyda_dlopen(const char *filename, int flag);
void* pyda_dlsym(void *handle, const char *symbol);
void* pyda_thread_self();
int pyda_thread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
int pyda_thread_detach(pthread_t thread);

void* python_thread_init(void *pyda_thread);
unsigned long pyda_getauxval(unsigned long type);
const char *pyda_getenv(const char *name);

void parse_proc_environ(void);
```

`pyda_core/pyda_unwind.c`:

```c
#include "pyda_core.h"
#define UNW_LOCAL_ONLY
#include <libunwind.h>
#include <sys/ucontext.h>

static void free_bt_entry(void *ptr) {
    dr_global_free(ptr, sizeof(struct pyda_bt_entry));
}

int pyda_get_backtrace (pyda_thread *t, drvector_t *res) {
  unw_cursor_t cursor; unw_context_t uc;
  unw_word_t ip, sp;

  unw_getcontext(&uc);
  ucontext_t *uc2 = (ucontext_t *) &uc;

#if defined(__x86_64__)
  uc2->uc_mcontext.gregs[REG_RIP] = (uintptr_t)t->cur_context.pc;
  uc2->uc_mcontext.gregs[REG_RSP] = t->cur_context.rsp;
  uc2->uc_mcontext.gregs[REG_RBP] = t->cur_context.rbp;
  uc2->uc_mcontext.gregs[REG_RDI] = t->cur_context.rdi;
  uc2->uc_mcontext.gregs[REG_RSI] = t->cur_context.rsi;
  uc2->uc_mcontext.gregs[REG_RDX] = t->cur_context.rdx;
  uc2->uc_mcontext.gregs[REG_RCX] = t->cur_context.rcx;
  uc2->uc_mcontext.gregs[REG_R8] = t->cur_context.r8;
  uc2->uc_mcontext.gregs[REG_R9] = t->cur_context.r8;
#elif defined(AARCH64)
  uc2->uc_mcontext.pc = (uintptr_t)t->cur_context.pc;
  uc2->uc_mcontext.regs[0] = t->cur_context.r0;
  uc2->uc_mcontext.regs[1] = t->cur_context.r1;
  uc2->uc_mcontext.regs[2] = t->cur_context.r2;
  uc2->uc_mcontext.regs[3] = t->cur_context.r3;
  uc2->uc_mcontext.regs[4] = t->cur_context.r4;
  uc2->uc_mcontext.regs[5] = t->cur_context.r5;
  uc2->uc_mcontext.regs[6] = t->cur_context.r6;
  uc2->uc_mcontext.regs[7] = t->cur_context.r7;
  uc2->uc_mcontext.sp = t->cur_context.sp;
  uc2->uc_mcontext.regs[30] = t->cur_context.lr;
#else
#error "Unsupported architecture"
#endif

  unw_init_local(&cursor, &uc);

  drvector_init(res, 0, true, free_bt_entry);

  do {
    struct pyda_bt_entry *e = dr_global_alloc(sizeof(struct pyda_bt_entry));

    char sym[512];
    unw_word_t offset;

    unw_get_reg(&cursor, UNW_REG_IP, &ip);
    unw_get_reg(&cursor, UNW_REG_SP, &sp);

    module_data_t *mod = dr_lookup_module((void*)ip);

    if (mod) {
        char *modname = strrchr(mod->full_path, '/');
        if (modname) {
            modname++;
        } else {
            modname = mod->full_path;
        }

        snprintf(e->modname, sizeof(e->modname), "%s", modname);
        e->offset = (uint64_t)ip - (uint64_t)mod->start;
    } else {
        e->modname[0] = 0;
        e->offset = 0;
    }

    if (unw_get_proc_name(&cursor, sym, sizeof(sym), &offset) == 0) {
        snprintf(e->sym_name, sizeof(e->sym_name), "%s", sym);
    } else {
        e->sym_name[0] = 0;
    }

    e->ip = ip;
    e->sp = sp;

    drvector_append(res, e);
  } while (unw_step(&cursor) > 0);

  return 0;
}


```

`pyda_core/tool.c`:

```c

// We use this so that we have dr_set_tls_field
#define STATIC_DRMGR_ONLY

#include "dr_api.h"
#include "dr_tools.h"
#include "drmgr.h"
#include "Python.h"
#include "util.h"

#include <signal.h>

#include "pyda_core_py.h"
#include "pyda_core.h"
#include "pyda_threads.h"

extern void __ctype_init();

void python_init();
void python_main_thread(void*);
void python_aux_thread(void*);
void module_load_event(void *drcontext, const module_data_t *mod, bool loaded);
void thread_init_event(void *drcontext);
void thread_exit_event(void *drcontext);
static void thread_entrypoint_break();

void patch_python();

static dr_emit_flags_t event_analysis(void *drcontext, void *tag, instrlist_t *bb, char for_trace,
                  char translating, void **user_data);
static dr_emit_flags_t
event_insert(void *drcontext, void *tag, instrlist_t *bb, instr_t *instr,
                 bool for_trace, bool translating, void *user_data);

static bool filter_syscall_event(void *drcontext, int sysnum);
static bool pre_syscall_event(void *drcontext, int sysnum);
static void post_syscall_event(void *drcontext, int sysnum);
static dr_signal_action_t signal_event(void *drcontext, dr_siginfo_t *siginfo);
static void fork_event(void *drcontext);
static void event_attach_post(void);


extern int is_dynamorio_running;
extern int pyda_attach_mode;

int is_python_init;

int g_pyda_tls_idx;
int g_pyda_tls_is_python_thread_idx;
client_id_t pyda_client_id;

DR_EXPORT void
dr_client_main(client_id_t id, int argc, const char *argv[])
{
    dr_set_client_name("Pyda",
                       "https://github.com/ndrewh/pyda");

    pyda_client_id = id;

    /* Options */
    drmgr_init();

    is_dynamorio_running = 1;

    /* make it easy to tell, by looking at log file, which client executed */
    DEBUG_PRINTF("Client 'pyda' initializing\n");

    // Dynamically patch python
    patch_python();

    // dr_set_process_exit_behavior(DR_EXIT_MULTI_THREAD | DR_EXIT_SKIP_THREAD_EXIT);

    // python_init();
    // dr_create_client_thread(python_thread, NULL);
    drmgr_register_thread_init_event(thread_init_event);
    drmgr_register_thread_exit_event(thread_exit_event);

    drmgr_register_module_load_event(module_load_event);
    drmgr_register_bb_instrumentation_event(event_analysis,
                                            event_insert,
                                            NULL);

    drmgr_register_pre_syscall_event(pre_syscall_event);
    drmgr_register_post_syscall_event(post_syscall_event);
    dr_register_filter_syscall_event(filter_syscall_event);
    dr_register_post_attach_event(event_attach_post);

    drmgr_register_signal_event(signal_event);
    dr_register_fork_init_event(fork_event);
    dr_request_synchronized_exit();

    g_pyda_tls_idx = drmgr_register_tls_field();
    g_pyda_tls_is_python_thread_idx = drmgr_register_tls_field();
}

void module_load_event(void *drcontext, const module_data_t *mod, bool loaded) {
    DEBUG_PRINTF("module_load_event: %s\n", mod->full_path);
}

void thread_init_event(void *drcontext) {
    DEBUG_PRINTF("thread_init_event\n");

    // Make a thread structure
    static pyda_process *global_proc = NULL;
    pyda_thread *t;
    if (!global_proc) {
        global_proc = pyda_mk_process();

        pyda_prepare_io(global_proc);
        t = global_proc->main_thread;
        if (!getenv("PYTHONPATH")) {
            parse_proc_environ();
        }
    } else {
        t = pyda_mk_thread(global_proc);
    }

    DEBUG_PRINTF("thread_init_event %p thread %d\n", (void*)t, dr_get_thread_id(drcontext));

    // WARN: This must use drcontext passed in.
    drmgr_set_tls_field(drcontext, g_pyda_tls_idx, (void*)t);
    drmgr_set_tls_field(drcontext, g_pyda_tls_is_python_thread_idx, (void*)0);

    // some init that python requires(?)
    __ctype_init();

    if (global_proc->main_thread->python_exited) {
        t->errored = 1;
    }

    // Every thread has its own corresponding python thread
    if (t == global_proc->main_thread) {
        dr_create_client_thread(python_main_thread, t);
    } else {
        dr_create_client_thread(python_aux_thread, t);
    }

    // Store the first pc, we will intrument it to call break
    if (t == global_proc->main_thread) {
        module_data_t *main_mod = dr_get_main_module();
        t->proc->entrypoint = (void*)main_mod->entry_point;

        if (!getenv("PYDA_NO_ATTACH")) {
            pyda_attach_mode = 1;
            // In attach mode, the entrypoint will never be reached,
            // so we release the lock now
            DEBUG_PRINTF("PYDA_NO_ATTACH is not set, assuming attach mode\n")
            pthread_mutex_unlock(&t->mutex);
        }
    } else {
        DEBUG_PRINTF("aux thread initial break\n");
        pyda_initial_break(t);
        DEBUG_PRINTF("aux thread initial break end\n");
    }
    DEBUG_PRINTF("thread_init_event end: %p\n", (void*)t);
}

void thread_exit_event(void *drcontext) {
    pyda_thread *t = drmgr_get_tls_field(drcontext, g_pyda_tls_idx);

    DEBUG_PRINTF("thread_exit_event: %p thread id %d\n", t, dr_get_thread_id(drcontext));
    t->app_exited = 1;

    pyda_break_noblock(t);
    /* dr_fprintf(STDERR, "pyda_break\n"); */
}

static const char *script_name;

static void get_python_args(int *o_argc, const char ***o_argv) {
    int argc;
    const char **argv;
    const char **new_argv;

    dr_get_option_array(pyda_client_id, &argc, &argv);

    if (argc >= 3 && strcmp(argv[1], "-script") == 0) {
        script_name = strdup(argv[2]);
        argc -= 2;

        // Copy to new memory
        new_argv = dr_global_alloc(sizeof(const char*) * (argc + 1));
        for (int i=0; i<argc; i++) {
            new_argv[i] = strdup(argv[i+2]);
        }

        new_argv[argc] = NULL;
        new_argv[0] = strdup(argv[0]);

        // Shift out the two "-script X" arguments
        DEBUG_PRINTF("Using script from command line: %s\n", script_name);
    } else {
        script_name = getenv("PYDA_SCRIPT");

        // Copy to new memory
        new_argv = dr_global_alloc(sizeof(const char*) * (argc + 1));
        for (int i=0; i<argc; i++) {
            new_argv[i] = strdup(argv[i]);
        }
        new_argv[argc] = NULL;
    }

    *o_argc = argc;
    *o_argv = new_argv;
}

void python_init() {
    static bool is_init = false;
    if (is_init) return;
    is_init = true;

    DEBUG_PRINTF("python_init\n");
    wchar_t *program = Py_DecodeLocale("program_name", NULL);
    if (program == NULL) {
        DEBUG_PRINTF("Fatal error: cannot decode argv[0]\n");
        exit(1);
    }

    /* Add the pyda_core module */
    if (PyImport_AppendInittab("pyda_core", PyInit_pyda_core) == -1) {
        fprintf(stderr, "Error: could not extend in-built modules table\n");
        exit(1);
    }

    Py_SetProgramName(program);  /* optional but recommended */
    PyConfig config;
    PyConfig_InitPythonConfig(&config);

    int argc;
    const char **argv;
    get_python_args(&argc, &argv);
    PyConfig_SetBytesArgv(&config, argc, (char * const *)argv);
    config.parse_argv = 0;

    // Output is much happier if we don't buffer.
    config.buffered_stdio = 0;

    Py_InitializeFromConfig(&config);

    DEBUG_PRINTF("python_init2\n");

#ifndef NDEBUG
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();

    // Check that the python interpreter is functional
    PyRun_SimpleString("from time import time,ctime\n"
                       "print('You are running Pyda v" PYDA_VERSION ".');\n"
    );
    DEBUG_PRINTF("python_init3\n");
    PyGILState_Release(gstate);
#endif
}

static dr_emit_flags_t
event_analysis(void *drcontext, void *tag, instrlist_t *bb, bool for_trace,
                  bool translating, void **user_data)
{
    return DR_EMIT_DEFAULT;
}
static dr_emit_flags_t
event_insert(void *drcontext, void *tag, instrlist_t *bb, instr_t *instr,
                 bool for_trace, bool translating, void *user_data)
{
    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    pyda_hook *callback;

    // XXX: I don't think this is safe, since the thread that updates
    // the code cache may not be the executing thread.
    //
#if defined(X86)
    bool save_fpstate = true;
#elif defined(AARCH64)
    bool save_fpstate = false;
#else
    #error "Unsupported arch"
#endif
    if (instr_get_app_pc(instr) == t->proc->entrypoint) {
        DEBUG_PRINTF("** Found Entrypoint\n");
        dr_insert_clean_call(drcontext, bb, instrlist_first_app(bb), (void *)thread_entrypoint_break,
                         false /* save fpstate */, 0);
    } else if ((callback = pyda_get_callback(t->proc, instr_get_app_pc(instr)))) {
        DEBUG_PRINTF("installing hook at %p\n", instr_get_app_pc(instr));
        dr_insert_clean_call(drcontext, bb, instr, (void *)pyda_hook_cleancall,
                         save_fpstate /* save fpstate */, 1, OPND_CREATE_INTPTR(callback));
    } else if (pyda_check_run_until(t->proc, instr_get_app_pc(instr))) {
        DEBUG_PRINTF("installing run_until hook at %p\n", instr_get_app_pc(instr));
        dr_insert_clean_call(drcontext, bb, instr, (void *)pyda_hook_rununtil_reached,
                         save_fpstate /* save fpstate */, 1, OPND_CREATE_INTPTR(instr_get_app_pc(instr)));
    }
    return DR_EMIT_DEFAULT;
}

static bool filter_syscall_event(void *drcontext, int sysnum) {
    // TODO: Check the list of desired syscalls
    return true;
}

static bool pre_syscall_event(void *drcontext, int sysnum) {
    if (drcontext != dr_get_current_drcontext()) {
        DEBUG_PRINTF("pre_syscall_event: drcontext mismatch\n");
        return true;
    }
    return pyda_hook_syscall(sysnum, 1);
}

static void post_syscall_event(void *drcontext, int sysnum) {
    if (drcontext != dr_get_current_drcontext()) {
        DEBUG_PRINTF("post_syscall_event: drcontext mismatch\n");
    }
    pyda_hook_syscall(sysnum, 0);
}

static dr_signal_action_t signal_event(void *drcontext, dr_siginfo_t *siginfo) {
    pyda_thread *t = drmgr_get_tls_field(drcontext, g_pyda_tls_idx);

    DEBUG_PRINTF("signal_event tid=%d: %d\n", t->tid, siginfo->sig);

    int sig = siginfo->sig;

    // We only care about signals that indicate crashes. We only care if the python thread
    // is still running (We need to have someone to raise the exception to!)
    // Perhaps unexpectedly, we also only care if the process has not blocked the signal.
    // This prevents us from handling signals before the application is ready for them (e.g.,
    // because it is holding the GIL. We will still handle them before the app gets them,
    // since dynamorio will call the handler a second time.)
    if ((sig == SIGSEGV || sig == SIGBUS || sig == SIGILL || sig == SIGABRT) && !siginfo->blocked) {
        if (!t->python_exited) {
            memcpy(&t->cur_context, siginfo->mcontext, sizeof(dr_mcontext_t));
            t->signal = sig;

            // Clear any previous run_until hooks: they are now invalid
            // since we are throwing.
            if (t->run_until)
                pyda_clear_run_until(t);

            // Raise an exception in Python +
            // Wait for Python to yield back to us
            pyda_break(t);

            if (!t->python_exited) {
                // Flushing is actually allowed in signal event handlers.
                // This updates run_until handlers, updated hooks, etc.
                pyda_flush_hooks();

                // Copy the state back to the siginfo
                memcpy(siginfo->mcontext, &t->cur_context, sizeof(dr_mcontext_t));

                t->signal = 0;

                return DR_SIGNAL_REDIRECT;
            }
            //
            // If Python exited (e.g. by not catching the FatalSignalError), we allow this
            // to fall through and deliver the signal anyway
            //
            dr_fprintf(STDERR, "[Pyda] Script did not handle FatalSignalError. Delivering signal %d.\n", sig);
        } else {
            dr_fprintf(STDERR, "[Pyda] ERROR: Signal %d received after Python exited/died. Add p.run() to receive the signal as an exception.\n", sig);
        }
    }

    return DR_SIGNAL_DELIVER;
}
static void fork_event(void *drcontext) {
    // This is called on the NEW fork, which doesn't have any parallel Python threads anymore.
    // TODO: How do we make sure that important locks aren't held at fork time when we have multiple threads?
    pyda_thread *t = drmgr_get_tls_field(drcontext, g_pyda_tls_idx);
    DEBUG_PRINTF("[Pyda] fork_init\n");

    pyda_process *p = t->proc;

    // Flush deleted hooks
    drvector_lock(&p->threads);
    for (int i=0; i<p->threads.entries; i++) {
        dr_flush_file(STDERR);
        if (p->threads.array[i] != t) pyda_thread_destroy(p->threads.array[i]);
    }
    p->threads.entries = 1;
    p->threads.array[0] = t;
    drvector_unlock(&p->threads);

    // For now, we just mark the current thread as exited, which just means we won't
    // try to yield to it in signal handlers or if we reach the last run_until hook.
    //
    // In the future, we could setup a new parallel Python thread that enters some
    // "fork handler" as the entrypoint or whatever

    t->python_exited = 1;
    p->main_thread = t;
}

static void event_attach_post() {
    if (!pyda_attach_mode) {
        dr_fprintf(STDERR, "Internal error: PYDA_NO_ATTACH is set but attach callback used\n");
        dr_abort();
        return;
    }

    DEBUG_PRINTF("event_attach_post on tid %d\n", dr_get_thread_id(dr_get_current_drcontext()));

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    DEBUG_PRINTF("[PYDA] Main thread (attached) is %ld\n", t->tid);

    if (t->proc->main_thread != t) {
        dr_fprintf(STDERR, "[Pyda] ERROR: Dynamorio is not running on the main thread. This is probably a bug.\n");
        dr_abort();
    }

    pthread_mutex_lock(&t->mutex); // we intentionally released the mutex based on `pyda_attach_mode`
    pyda_initial_break(t); // wait for the script to call p.run()

    // XXX: Not clear if this is legal to call here. If it is, we should note that we don't
    // have to redirect execution, because we aren't actually in translated code yet!
    /* pyda_flush_hooks(); */

    DEBUG_PRINTF("entrypoint end (attach)\n");
}

static void thread_entrypoint_break() {
    DEBUG_PRINTF("entrypoint (break)\n");

    pyda_thread *t = pyda_thread_getspecific(g_pyda_tls_idx);
    DEBUG_PRINTF("[PYDA] Main thread at entrypiont %ld\n", t->tid);

    pyda_initial_break(t);
    if (pyda_flush_hooks()) {
        DEBUG_PRINTF("entrypoint: flush hooks\n");

        // We may have flushed the current fragment, so we have to call
        // dr_redirect_execution instead of returning.
        dr_mcontext_t mc;
        mc.size = sizeof(mc);
        mc.flags = DR_MC_ALL;
        dr_get_mcontext(dr_get_current_drcontext(), &mc);
        mc.pc = t->proc->entrypoint;
        t->proc->entrypoint = 0; // avoid breaking a second time
        dr_flush_region((void*)mc.pc, 1);
        dr_redirect_execution(&mc);
    }
    DEBUG_PRINTF("entrypoint (break end)\n");
}

void drmgr_thread_init_event(void*);

void python_main_thread(void *arg) {
    pyda_thread *t = arg;
    void *drcontext = dr_get_current_drcontext();
    void *tls = python_thread_init(t);

    python_init();

    if (!PyGILState_Check()) {
        dr_fprintf(STDERR, "[Pyda] Error: GIL expected\n");
        dr_abort();
    }

    DEBUG_PRINTF("Running script...\n");

    if (!script_name) {
        dr_fprintf(STDERR, "[Pyda] Error: Script not specified\n");
        goto python_exit;
    }

    FILE *f = fopen(script_name, "r");
    if (!f) {
        dr_fprintf(STDERR, "[Pyda] Error: could not open %s\n", script_name);
        goto python_exit;
    }

    // The thread will be holding the lock until
    // it reaches the "initial" breakpoint
    pthread_mutex_lock(&t->mutex);
    pthread_mutex_unlock(&t->mutex);

    // This is a good place to put a sleep to attach GDB
    // if testing out the attach mode
    // sleep(15);

    if (PyRun_SimpleFile(f, script_name) == -1) {
        // python exception
        dr_fprintf(STDERR, "[Pyda] Script raised exception, see above.\n");
    }

    fclose(f);

python_exit:
    DEBUG_PRINTF("Script exited...\n");
    t->python_exited = 1;
    t->errored = 1;

    DEBUG_PRINTF("After script exit, GIL status %d\n", PyGILState_Check());

    Py_BEGIN_ALLOW_THREADS;

    if (!t->app_exited) {
        if (!t->signal)
            dr_fprintf(STDERR, "[Pyda] ERROR: Did you forget to call p.run()?\n");

        pyda_yield(t); // unblock (note: blocking)
        DEBUG_PRINTF("Implicit pyda_yield finished\n");
    }

    // This call will block until the main thread is the last.
    DEBUG_PRINTF("python_main_thread destroy\n");
    pyda_thread_destroy_last(t);
    DEBUG_PRINTF("python_main_thread destroy done\n");

    DEBUG_PRINTF("Py_FinalizeEx in thread %d\n", dr_get_thread_id(drcontext));

    Py_END_ALLOW_THREADS;

    if (Py_FinalizeEx() < 0) {
        DEBUG_PRINTF("WARN: Python finalization failed\n");
    }

    DEBUG_PRINTF("Py_FinalizeEx done\n");

    dr_thread_free(drcontext, tls, sizeof(void*) * 130);
    DEBUG_PRINTF("python_main_thread return\n");
}

void python_aux_thread(void *arg) {
    pyda_thread *t = arg;
    void *drcontext = dr_get_current_drcontext();
    void *tls = python_thread_init(t);

    DEBUG_PRINTF("python_aux_thread id %d\n", dr_get_thread_id(drcontext));

    // Wait for the main script to reach the first yield (so there is time to set thread_init_hook in the attach case)
    pthread_mutex_lock(&t->proc->main_thread->mutex);
    while (!t->proc->main_thread->yield_count)
        pthread_cond_wait(&t->proc->main_thread->resume_cond, &t->proc->main_thread->mutex);
    pthread_mutex_unlock(&t->proc->main_thread->mutex);

    DEBUG_PRINTF("python_aux_thread enter id %d\n", dr_get_thread_id(drcontext));

    // Acquire the GIL so this thread can call the thread entrypoint
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();

    // We just call the thread init hook, if one exists
    if (t->proc->thread_init_hook && !t->errored) {
        DEBUG_PRINTF("Calling thread_init_hook\n");
        PyObject *result = PyObject_CallFunctionObjArgs(t->proc->thread_init_hook, t->proc->py_obj, NULL);
        if (result == NULL) {
            PyErr_Print();
            dr_fprintf(STDERR, "[Pyda] ERROR: Thread entry hook failed. Continuing.\n");
            // dr_abort();
        }
    }

    PyGILState_Release(gstate);

    // dr_client_thread_set_suspendable(true);

    DEBUG_PRINTF("python_aux_thread 4\n");

    t->python_exited = 1;

    if (!t->app_exited) {
        pyda_yield(t);
        DEBUG_PRINTF("Implicit pyda_yield finished\n");
    }

    pyda_thread_destroy(t);

    DEBUG_PRINTF("python_aux_thread 5\n");
    dr_thread_free(drcontext, tls, sizeof(void*) * 130);
    DEBUG_PRINTF("python_aux_thread 6\n");
}

```

`pyda_core/util.h`:

```h

#ifndef NDEBUG
#define DEBUG_PRINTF(...) { \
    dr_fprintf(STDERR, __VA_ARGS__); \
    dr_flush_file(STDERR); \
}
#else
#define DEBUG_PRINTF(...)
#endif
```

`tests/err_hook.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def lib_hook(p):
    global counter
    name = plt_map[p.regs.rip]
    print(f"[thread {p.tid}] {name}")

    counter += 1
    if counter == 1000:
        jsdkfjdsaklfadska

def thread_entry(p):
    print(f"thread_entry for {p.tid}")

p.set_thread_entry(thread_entry)

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

p.run()
```

`tests/err_invalidhook.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

counter = 0
def lib_hook(p):
    global counter
    counter += 1

p.hook(0x1337133713371337, lib_hook)
p.run()
```

`tests/err_norun.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def lib_hook(p):
    global counter
    name = plt_map[p.regs.rip]
    print(f"[thread {p.tid}] {name}")

    counter += 1
    if counter == 1000:
        jsdkfjdsaklfadska

def thread_entry(p):
    print(f"thread_entry for {p.tid}")

p.set_thread_entry(thread_entry)

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

```

`tests/err_thread_entry.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def lib_hook(p):
    name = plt_map[p.regs.rip]
    print(f"[thread {p.tid}] {name}")

def thread_entry(p):
    global counter
    print(f"thread_entry for {p.tid}")

    counter += 1
    if counter == 27:
        jsdkfjdsaklfadska

p.set_thread_entry(thread_entry)

for x in e.plt:
    p.hook(e.plt[x], lib_hook)

p.run()
```

`tests/eval/malloc1.c`:

```c
#include <stdlib.h>
int main() {
    for (int i=0; i<1; i++) {
        void *m = malloc(0x100);
        free(m);
    }
}

```

`tests/eval/malloc1000.c`:

```c
#include <stdlib.h>
int main() {
    for (int i=0; i<1000; i++) {
        void *m = malloc(0x100);
        free(m);
    }
}

```

`tests/eval/malloc100000.c`:

```c
#include <stdlib.h>
int main() {
    for (int i=0; i<100000; i++) {
        void *m = malloc(0x100);
        free(m);
    }
}

```

`tests/eval/malloc1000000.c`:

```c
#include <stdlib.h>
int main() {
    for (int i=0; i<1000000; i++) {
        void *m = malloc(0x100);
        free(m);
    }
}

```

`tests/eval/malloccount_libdebug.py`:

```py
from libdebug import debugger
from pwnlib.elf.elf import ELF
from pathlib import Path
import sys

bin_path = Path(sys.argv[1])
d = debugger(str(bin_path.resolve()))
r = d.run()

e = ELF(bin_path)

counter = 0
def malloc_counter(t, bp):
    global counter
    counter += 1

d.breakpoint(e.plt["malloc"], callback=malloc_counter, file=bin_path.name)
d.cont()
d.wait()

print(f"malloc count: {counter}")
print("pass")

```

`tests/eval/malloccount_pyda.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

counter = 0
def malloc_counter(p):
    global counter
    counter += 1

p.hook(e.plt["malloc"], malloc_counter)
p.run()

print(f"malloc count: {counter}")
print("pass")

```

`tests/eval/run_eval.py`:

```py
import subprocess
from dataclasses import dataclass
from typing import Optional, Callable
from pathlib import Path
from tempfile import TemporaryDirectory
import os
import time

from argparse import ArgumentParser

@dataclass
class ExpectedResult:
    retcode: Optional[int] = None

    # checker(stdout, stderr) -> bool
    checkers: list[Callable[[bytes, bytes], bool]] = list

@dataclass
class RunOpts:
    no_pty: bool = False

def output_checker(stdout: bytes, stderr: bytes) -> bool:
    try:
        if stdout:
            stdout.decode()

        if stderr:
            stderr.decode()
    except:
        return False

    return True

def no_warnings_or_errors(stdout: bytes, stderr: bytes) -> bool:
    return b"[Pyda]" not in stderr and b"WARNING:" not in stderr

TESTS = [
    ("test_malloc_1", "malloc1.c", "malloccount_pyda.py", "malloccount_libdebug.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),
    ("test_malloc_1000", "malloc1000.c", "malloccount_pyda.py", "malloccount_libdebug.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),
    ("test_malloc_100000", "malloc100000.c", "malloccount_pyda.py", "malloccount_libdebug.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),
    ("test_malloc_1000000", "malloc1000000.c", "malloccount_pyda.py", "malloccount_libdebug.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),
]

def main():
    ap = ArgumentParser()
    ap.add_argument("--test", help="Run a specific test", default=None)
    ap.add_argument("--debug", help="Enable debug output", action="store_true")
    ap.add_argument("--ntrials", default=5, type=int)
    args = ap.parse_args()

    if args.test is None:
        res = True
        for (name, c_file, pyda_file, libdebug_file, run_opts, expected_result) in TESTS:
            res &= run_test(c_file, pyda_file, libdebug_file, run_opts, expected_result, name, args.debug, args.ntrials)
    else:
        test = next((t for t in TESTS if t[0] == args.test), None)
        if test is None:
            print(f"Test {args.test} not found")
            exit(1)

        name, c_file, pyda_file, libdebug_file, run_opts, expected_result = test
        res = run_test(c_file, pyda_file, libdebug_file, run_opts, expected_result, name, args.debug, args.ntrials)

    if not res:
        exit(1)

def run_pyda(c_exe_path, pyda_script_path, env, expected_result, test_name, debug):
    def run():
        cmd = f"pyda {pyda_script_path.resolve()} -- {c_exe_path.resolve()}"
        return subprocess.run(cmd, env=env, stdin=subprocess.DEVNULL, shell=True, timeout=60, capture_output=True)

    return run_tool(run, test_name, expected_result, debug)

def run_libdebug(c_exe_path, libdebug_script_path, env, expected_result, test_name, debug):
    def run():
        return subprocess.run(f"python3 {libdebug_script_path.resolve()} {c_exe_path.resolve()}", env=env, stdin=subprocess.DEVNULL, shell=True, timeout=60, capture_output=True)

    return run_tool(run, test_name, expected_result, debug)

def run_tool(run_cmd, test_name, expected_result, debug):
    result_str = ""

    t1, t2 = None, None
    try:
        t1 = time.time()
        result = run_cmd()
        t2 = time.time()

        stdout = result.stdout
        stderr = result.stderr
    except subprocess.TimeoutExpired as err:
        result_str += "  Timeout occurred. Did the test hang?\n"

        result = None
        stdout = err.stdout
        stderr = err.stderr


    if result:
        # Check the retcode
        if expected_result.retcode is not None:
            if result.returncode != expected_result.retcode:
                result_str += f"  Expected return code {expected_result.retcode}, got {result.returncode}\n"

    # Unconditionally check the output
    for (i, checker) in enumerate(expected_result.checkers):
        checker_res = False
        try:
            checker_res = checker(stdout, stderr)
        except:
            pass

        if not checker_res:
            result_str += f"  Checker {i} failed\n"

    res_time = None
    if t1 is not None and t2 is not None:
        res_time = t2 - t1

    if len(result_str) > 0:
        print(f"[FAIL] {test_name}")
        print(result_str)
    if debug:
        if stdout:
            print(stdout.decode())
        if stderr:
            print(stderr.decode())

    else:
        print(f"[OK] {test_name}")

    return result_str, res_time


def run_test(c_file, pyda_file, libdebug_file, run_opts, expected_result, test_name, debug, ntrials):
    # Compile to temporary directory
    with TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)
        c_path = Path(c_file)
        pyda_path = Path(pyda_file)
        libdebug_path = Path(libdebug_file)

        c_exe = tmpdir / c_path.stem
        compile_res = subprocess.run(['gcc', '-o', c_exe, c_path], capture_output=True)
        if compile_res.returncode != 0:
            print(f"Failed to compile {c_file}")
            print(compile_res.stderr)
            raise RuntimeError("Failed to compile test")

        env = os.environ.copy()
        if run_opts.no_pty:
            env["PYDA_NO_PTY"] = "1"

        for trial in range(ntrials):
            pyda_result, pyda_time = run_pyda(c_exe, pyda_path, env, expected_result, test_name, debug)
            libdebug_result, libdebug_time = run_libdebug(c_exe, libdebug_path, env, expected_result, test_name, debug)
            print(f"Pyda time: {pyda_time}")
            print(f"libdebug time: {libdebug_time}")

            if len(pyda_result) > 0 or len(libdebug_result) > 0:
                return False

        return True


if __name__ == '__main__':
    main()

```

`tests/run_tests.py`:

```py
import subprocess
from dataclasses import dataclass
from typing import Optional, Callable
from pathlib import Path
from tempfile import TemporaryDirectory
import os, time

from argparse import ArgumentParser

@dataclass
class ExpectedResult:
    retcode: Optional[int] = None

    # checker(stdout, stderr) -> bool
    checkers: list[Callable[[bytes, bytes], bool]] = list

    hang: bool = False

@dataclass
class RunOpts:
    no_pty: bool = False
    attach: bool = False

def output_checker(stdout: bytes, stderr: bytes) -> bool:
    try:
        if stdout:
            stdout.decode()

        if stderr:
            stderr.decode()
    except:
        return False
    
    return True

def no_warnings_or_errors(stdout: bytes, stderr: bytes) -> bool:
    return b"[Pyda]" not in stderr and b"WARNING:" not in stderr

TESTS = [
    # tests whether we can handle a large number of threads with concurrent hooks
    ("threads_concurrent_hooks", "thread_1000.c", "../examples/ltrace_multithreaded.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"malloc") == 20000,
            lambda o, e: o.count(b"free") == 20000,
            lambda o, e: all((o.count(f"[thread {i}]".encode('utf-8')) == 40 for i in range(2, 1002))),
        ]
    )),

    # tests whether we can handle a large number of threads that do not get waited on
    ("threads_nojoin", "thread_nojoin.c", "../examples/ltrace_multithreaded.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"malloc") > 15000,
            lambda o, e: o.count(b"free") > 15000,
            lambda o, e: all((o.count(f"[thread {i}]".encode('utf-8')) == 40 for i in range(2, 100))),
        ]
    )),

    # hook throws an exception
    ("err_hook_throw", "thread_1000.c", "err_hook.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
        ]
    )),

    # thread entry hook throws an exception
    ("err_thread_entry_throw", "thread_1000.c", "err_thread_entry.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
        ]
    )),

    # tests whether we can handle a simple syscall hook
    ("syscall_hooks", "simple.c", "test_syscall.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pre syscall") == o.count(b"post syscall") + 1, # (+1 for exit)
            lambda o, e: o.index(b"pre syscall") < o.index(b"post syscall"),
        ]
    )),

    # tests tid is correct in syscall hooks
    ("syscall_hooks_multithread", "thread_10.c", "test_syscall.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: all((o.count(f"[tid {i}]".encode('utf-8')) > 1 for i in range(1, 10))) or print(o),
        ]
    )),

    # user fails to call p.run()
    ("err_norun", "thread_1000.c", "err_norun.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
        ]
    )),

    # test register read/write
    ("test_regs_x86", "simple.c", "test_regs_x86.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"success") == 1,
        ]
    )),

    # test "blocking" I/O
    ("test_io1", "test_io.c", "test_io1.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"hello") == 0,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    # test "blocking" I/O
    ("test_io2", "test_io.c", "test_io2.py", RunOpts(), ExpectedResult(
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
            lambda o, e: e.count(b"RuntimeError: I/O must be explicitly captured using process(io=True)") == 1,
            lambda o, e: o.count(b"hello there") == 1,
            lambda o, e: o.count(b"goodbye") == 1,
        ]
    )),

    # test "blocking" run_until
    ("test_blocking1", "simple.c", "test_blocking1.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_blocking2", "simple.c", "test_blocking2.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_blocking3", "simple.c", "test_blocking3.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR: Did you forget to call p.run()?") == 1,
        ]
    )),

    ("test_blocking4", "simple.c", "test_blocking4.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"[Pyda] ERROR:") == 1,
            lambda o, e: e.count(b"Hook call failed") == 1,
            lambda o, e: e.count(b"InvalidStateError") == 1,
        ]
    )),

    # test "blocking" i/o with a giant write
    ("test_hugeio", "test_hugeio.c", "test_hugeio.py", RunOpts(no_pty=True), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_call", "test_call.c", "test_call.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_thread_blocking", "thread_10.c", "test_thread_blocking.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: all((o.count(f"[thread {i}]".encode('utf-8')) == 20 for i in range(2, 12))),
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_segv", "test_segv.c", "test_segv.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"test_segv") == 8,
            lambda o, e: o.count(b"] main") == 3,
            lambda o, e: o.count(b"] segfault") == 4,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_python_threading", "simple.c", "test_python_threading.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
            lambda o, e: o.count(b"thread start\n") == 1,
            lambda o, e: o.count(b"thread end\n") == 1,
        ]
    )),

    ("err_invalidhook", "simple.c", "err_invalidhook.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            lambda o, e: e.count(b"RuntimeError: Hooked PC 1337133713371337 is invalid.") == 1,
        ]
    )),

    ("test_pwntools", "simple.c", "test_pwntools.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pass\n") == 1,
        ]
    )),

    ("test_fork", "test_fork.c", "../examples/ltrace_multithreaded.py", RunOpts(), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"child status 0") == 1,
        ]
    )),

    ("test_attach", "test_longrunning.c", "../examples/ltrace_multithreaded.py", RunOpts(attach=True), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"[thread 1] sleep") in range(5, 12),
        ]
    )),

    ("test_attach_multithread", "test_longrunning_multithread.c", "../examples/ltrace_multithreaded.py", RunOpts(attach=True), ExpectedResult(
        retcode=0,
        checkers=[
            output_checker,
            no_warnings_or_errors,
            lambda o, e: o.count(b"pthread_join") in [9, 10], # first call may happen before attach
            lambda o, e: o.count(b"snprintf") == 10,
            lambda o, e: all((o.count(f"[thread {i}] gettimeofday".encode('utf-8')) in range(5, 12) for i in range(2, 12))),
            lambda o, e: all((o.count(f"thread_entry for {i}".encode('utf-8')) == 1 for i in range(2, 12))),
        ]
    )),
]

def main():
    ap = ArgumentParser()
    ap.add_argument("--test", help="Run a specific test", default=None)
    ap.add_argument("--debug", help="Enable debug output", action="store_true")
    ap.add_argument("--ntrials", default=5, type=int)
    args = ap.parse_args()

    if args.test is None:
        res = True
        for (name, c_file, python_file, run_opts, expected_result) in TESTS:
            res &= run_test(c_file, python_file, run_opts, expected_result, name, args.debug, args.ntrials)
    else:
        test = next((t for t in TESTS if t[0] == args.test), None)
        if test is None:
            print(f"Test {args.test} not found")
            exit(1)
        
        name, c_file, python_file, run_opts, expected_result = test
        res = run_test(c_file, python_file, run_opts, expected_result, name, args.debug, args.ntrials)

    if not res:
        exit(1)

TIMEOUT = 15
def run_test(c_file, python_file, run_opts, expected_result, test_name, debug, ntrials):
    # Compile to temporary directory
    with TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)
        c_path = Path(c_file)
        p_path = Path(python_file)

        c_exe = tmpdir / c_path.stem
        compile_res = subprocess.run(['gcc', '-o', c_exe, c_path, '-lpthread'], capture_output=True)
        if compile_res.returncode != 0:
            print(f"Failed to compile {c_file}")
            print(compile_res.stderr)
            raise RuntimeError("Failed to compile test")

        env = os.environ.copy()
        if run_opts.no_pty:
            env["PYDA_NO_PTY"] = "1"

        env["TERM"] = "linux"

        for trial in range(ntrials):
            result_str = ""
            try:
                if not run_opts.attach:
                    result = subprocess.run(f"pyda {p_path.resolve()} -- {c_exe.resolve()}", env=env, stdin=subprocess.DEVNULL, shell=True, timeout=TIMEOUT, capture_output=True)
                    stdout = result.stdout
                    stderr = result.stderr
                else:
                    # Attach mode: Launch the process and then attach to it
                    proc = subprocess.Popen([c_exe.resolve()], env=env, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    time.sleep(2)
                    result = subprocess.Popen(f"pyda-attach {p_path.resolve()} {proc.pid}", env=env, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL)

                    stdout, stderr = proc.communicate(timeout=TIMEOUT)
                    result.wait(timeout=TIMEOUT)

                if expected_result.hang:
                    result_str += "  Expected test to hang, but it did not\n"
            except subprocess.TimeoutExpired as err:
                if not expected_result.hang:
                    result_str += "  Timeout occurred. Did the test hang?\n"

                result = None
                stdout = err.stdout
                stderr = err.stderr

            
            if result:
                # Check the retcode
                if expected_result.retcode is not None:
                    if result.returncode != expected_result.retcode:
                        result_str += f"  Expected return code {expected_result.retcode}, got {result.returncode}\n"

            # Unconditionally check the output
            for (i, checker) in enumerate(expected_result.checkers):
                checker_res = False
                try:
                    checker_res = checker(stdout, stderr)
                except:
                    pass
                
                if not checker_res:
                    result_str += f"  Checker {i} failed\n"


            if len(result_str) > 0:
                print(f"[FAIL] {test_name} ({python_file} {c_file})")
                print(result_str)
                if debug:
                    if stdout:
                        print(stdout.decode())
                    if stderr:
                        print(stderr.decode())

                return False
            else:
                print(f"[OK] {test_name} ({python_file} {c_file})")

        return True


if __name__ == '__main__':
    main()

```

`tests/simple.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

int main(int argc, char** argv) {
    printf("start\n");
    void *allocs[10];
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    printf("end\n");
}
```

`tests/test_blocking1.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter2 = 0
try:
    while True:
        p.run_until(e.plt["malloc"])
        counter2 += 1
except ThreadExitError:
    pass

assert counter2 == 20, f"{counter2}"
print("pass")
```

`tests/test_blocking2.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def malloc_hook(p):
    global counter
    print(f"malloc({p.regs.rdi})")
    counter += 1

p.hook(e.plt["malloc"], malloc_hook)

counter2 = 0
try:
    while True:
        p.run_until(e.plt["malloc"])
        counter2 += 1
except ThreadExitError:
    pass

assert counter == counter2
print("pass")
```

`tests/test_blocking3.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter2 = 0
p.run_until(e.plt["malloc"])
p.run_until(e.plt["malloc"])
p.run_until(e.plt["malloc"])
p.run_until(e.plt["malloc"])

# NOTE: p.run() is not called -- process should finish and print an error
```

`tests/test_blocking4.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

counter = 0
def malloc_hook(p):
    global counter
    print(f"malloc({p.regs.rdi})")
    counter += 1
    p.run_until(0x1337133713371337)

p.hook(e.plt["malloc"], malloc_hook)

counter2 = 0
try:
    while True:
        p.run_until(e.plt["malloc"])
        counter2 += 1
except ThreadExitError:
    pass

assert counter == counter2
print("pass")
```

`tests/test_call.c`:

```c

int lol(char *arg1, int arg2) {
    printf("lol %s %d\n", arg1, arg2);
}

int main() {
    printf("here1\n");
    printf("here2\n");
}
```

`tests/test_call.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import time

p = process(io=True)

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

p.run_until(e.symbols["main"])

lol = p.callable(e.symbols["lol"])
st1 = b"abcd"
st2 = b"A" * 0x400

lol(st1, 1337)
p.recvuntil(b"lol abcd 1337")
lol(st2, 1338)
p.recvuntil(b"lol " + b"A" * 0x400 + b" 1338")
lol(st1, 1339)
p.recvuntil(b"lol abcd 1339")
lol(st1, 1340)
p.recvuntil(b"lol abcd 1340")
p.run()
print("pass")
```

`tests/test_fork.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void child_main() {
    printf("child\n");
}

void parent_main() {
    printf("parent\n");
}

int main(int argc, char** argv) {
    printf("start\n");
    int f = fork();
    if (f == 0) {
        // child
        child_main();
    } else if (f > 0) {
        // parent
        parent_main();

        int status;
        waitpid(f, &status, 0);
        printf("child status %d\n", status);
    } else {
        printf("error\n");
    }
    printf("end\n");
}

```

`tests/test_hugeio.c`:

```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    printf("hello there. please enter your name:\n");
    char *name = malloc(100000000); // 100M
    int res = fread(name, 1, 100000000, stdin);
    if (res != 100000000) {
        printf("error reading name\n");
        return 1;
    }
    printf("hello, %s\n", name);
    free(name);
    printf("goodbye\n");
}
```

`tests/test_hugeio.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import time

def fix_buffering(p):
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    libc.address = p.maps[libc.path].base

    stdin = u64(p.read(libc.symbols["stdin"], 8))
    stdout = u64(p.read(libc.symbols["stdout"], 8))
    stderr = u64(p.read(libc.symbols["stderr"], 8))
    p.callable(libc.symbols["setvbuf"])(stdin, 0, 2, 0)
    p.callable(libc.symbols["setvbuf"])(stdout, 0, 2, 0)
    p.callable(libc.symbols["setvbuf"])(stderr, 0, 2, 0)

p = process(io=True)

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

p.run_until(e.symbols["main"])
fix_buffering(p)

p.recvuntil(b"please enter your name:")
p.sendline(b"A" * 100000000)
p.recvline()
line = p.recvline()
expected = b"hello, " + b"A" * 100000000 + b"\n"
assert line == expected, f"bad {len(line)} {len(expected)}"

p.run()
print("pass")
```

`tests/test_io.c`:

```c
#include <stdio.h>
int main() {
    printf("hello there. please enter your name:\n");
    char name[100];
    scanf("%s", name);
    printf("hello, %s\n", name);

    int age;
    printf("please enter your age:\n");
    scanf("%d", &age);
    printf("hello %s, you are %d years old\n", name, age);
    printf("goodbye\n");
}
```

`tests/test_io1.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

p = process(io=True)

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def main_hook(p):
    print(f"at main, rsp={hex(p.regs.rsp)}")
    return_addr = p.read(p.regs.rsp, 8)
    print(f"return address: {hex(u64(return_addr))}")

p.hook(e.symbols["main"], main_hook)

p.recvuntil(b"please enter your name:")
p.sendline("andrew")
p.recvuntil("please enter your age:")
p.sendline("21")
p.recvline()
line = p.recvline()
assert line == b"hello andrew, you are 21 years old\n", line
p.run()
print("pass")
```

`tests/test_io2.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def main_hook(p):
    print(f"at main, rsp={hex(p.regs.rsp)}")
    return_addr = p.read(p.regs.rsp, 8)
    print(f"return address: {hex(u64(return_addr))}")

p.hook(e.symbols["main"], main_hook)

p.recvuntil(b"please enter your name:")
p.sendline("andrew")
p.recvuntil("please enter your age:")
p.sendline("21")
p.recvline()
line = p.recvline()
assert line == b"hello andrew, you are 21 years old\n", line
p.run()
print("pass")
```

`tests/test_longrunning.c`:

```c

#include <unistd.h>
#include <sys/time.h>

unsigned long timems() {
  struct timeval start;
  gettimeofday(&start, NULL);
  return (start.tv_sec * 1000000 + start.tv_usec) / 1000;
}
int main() {
    printf("Hello from long running test\n");

    unsigned long start = timems();
    while (timems() - start < 10000) {
        sleep(1);
    }

    char *buf = malloc(100);
    snprintf(buf, 100, "Finished longrunning test\n");
    printf("%s", buf);
}

```

`tests/test_longrunning_multithread.c`:

```c

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <stdint.h>
#include <pthread.h>

unsigned long timems() {
  struct timeval start;
  gettimeofday(&start, NULL);
  return (start.tv_sec * 1000000 + start.tv_usec) / 1000;
}

void* thread(void *tid) {
    unsigned int t = (unsigned int)(unsigned long)tid;
    printf("Hello from long running test %u\n", t);
    unsigned long start = timems();
    while (timems() - start < 10000) {
        sleep(1);
    }
    char *buf = malloc(100);
    snprintf(buf, 100, "Finished longrunning test %u\n", t);
    printf("%s", buf);
    return NULL;
}

int main() {
    pthread_t threads[10];
    for (int i=0; i<10; i++) {
        pthread_create(&threads[i], 0, thread, (void*)(uintptr_t)i);
    }

    for (int i=0; i<10; i++) {
        void *ret;
        pthread_join(threads[i], &ret);
    }


}

```

`tests/test_pwntools.py`:

```py
from pwn import *
from pyda import *

p = process(io=True)
p.run()
print("pass")
```

`tests/test_python_threading.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import time
from threading import Thread

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def thread():
    print("thread start")
    time.sleep(1)
    print("thread end")

t = Thread(target=thread)
t.start()

time.sleep(3)
p.run()
print("pass")

```

`tests/test_regs_x86.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def main_hook(p):
    # get all the registers
    print(f"reg rax: {hex(p.regs.rax)}")
    print(f"reg rbx: {hex(p.regs.rbx)}")
    print(f"reg rcx: {hex(p.regs.rcx)}")
    print(f"reg rdx: {hex(p.regs.rdx)}")
    print(f"reg rsi: {hex(p.regs.rsi)}")
    print(f"reg rdi: {hex(p.regs.rdi)}")
    print(f"reg rbp: {hex(p.regs.rbp)}")
    print(f"reg rsp: {hex(p.regs.rsp)}")
    print(f"reg rip: {hex(p.regs.rip)}")
    print(f"reg pc: {hex(p.regs.pc)}")
    print(f"reg r8: {hex(p.regs.r8)}")
    print(f"reg r9: {hex(p.regs.r9)}")
    print(f"reg r10: {hex(p.regs.r10)}")
    print(f"reg r11: {hex(p.regs.r11)}")
    print(f"reg r12: {hex(p.regs.r12)}")
    print(f"reg r13: {hex(p.regs.r13)}")
    print(f"reg r14: {hex(p.regs.r14)}")
    print(f"reg r15: {hex(p.regs.r15)}")
    print(f"reg xmm0: {hex(p.regs.xmm0)}")
    print(f"reg xmm1: {hex(p.regs.xmm1)}")
    print(f"reg xmm2: {hex(p.regs.xmm2)}")
    print(f"reg xmm3: {hex(p.regs.xmm3)}")
    print(f"reg xmm4: {hex(p.regs.xmm4)}")
    print(f"reg xmm5: {hex(p.regs.xmm5)}")
    print(f"reg xmm6: {hex(p.regs.xmm6)}")
    print(f"reg xmm7: {hex(p.regs.xmm7)}")
    print(f"reg fsbase: {hex(p.regs.fsbase)}")

    assert p.regs.pc == p.regs.rip
    assert p.regs.pc != 0

    # try round-trip
    p.regs.rax = 0xdeadbeef
    assert p.regs.rax == 0xdeadbeef

    p.regs.xmm0 = 0xdeadbeefdeadbeefdeadbeefdeadbeef
    assert p.regs.xmm0 == 0xdeadbeefdeadbeefdeadbeefdeadbeef

    print("success")



p.hook(e.symbols["main"], main_hook)
p.run()
```

`tests/test_segv.c`:

```c
#include <stdio.h>

void segfault() {
    *(volatile int*)0 = 0;
}

int main() {
    printf("Hello, World!\n");
    segfault();
    return 0;
}
```

`tests/test_segv.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

excepted = False
try:
    p.run()
except FatalSignalError as err:
    assert err.args[0] is not None
    excepted = True
    
    print(err)

assert excepted

print("Exception 1")

# Now, after the exception, redirect execution to main again
p.regs.rip = e.symbols["main"]
excepted = False
try:
    p.run()
except FatalSignalError as err:
    assert err.args[0] is not None
    excepted = True

    print(err)

assert excepted

print("Exception 2")

# Finally, let's try calling out to the function as a callable
excepted = False
try:
    p.callable(e.symbols["segfault"])()
except FatalSignalError as err:
    assert err.args[0] is not None
    excepted = True

    print(err)

assert excepted

print("Exception 3")

p.regs.rsp += 0x18
p.regs.rip = e.symbols["main"] + 0x26
p.run()
print("pass")
```

`tests/test_syscall.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
import string
import sys

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

plt_map = { e.plt[x]: x for x in e.plt }

def guess_arg(x):
    printable_chars = bytes(string.printable, 'ascii')

    # Is pointer?
    if x > 0x100000000:
        try:
            data = p.read(x, 0x20)
            if all([c in printable_chars for c in data[:4]]):
                if 0 in data:
                    return str(data[:data.index(0)])
                else:
                    return str(data[:20]) + "..."

        except Exception as e:
            pass
    
    return hex(x)

def syscall_pre_hook(p, num):
    print(f"[tid {p.tid}] [pre syscall {num}] (" + ", ".join([
        f"rdi={guess_arg(p.regs.rdi)}",
        f"rsi={guess_arg(p.regs.rsi)}",
        f"rdx={guess_arg(p.regs.rdx)}",
        f"rcx={guess_arg(p.regs.rcx)}",
    ]) + ")")

def syscall_post_hook(p, num):
    print(f"[tid {p.tid}] [post syscall {num}]")

for snum in range(500):
    p.syscall_pre(snum, syscall_pre_hook)

for snum in range(500):
    p.syscall_post(snum, syscall_post_hook)

p.run()
```

`tests/test_thread_blocking.py`:

```py
from pyda import *
from pwnlib.elf.elf import ELF
from pwnlib.util.packing import u64
from pwnlib.util.fiddling import hexdump
import string
import sys, time

p = process()

e = ELF(p.exe_path)
e.address = p.maps[p.exe_path].base

def thread_entry(p):
    print("Thread entry")
    try:
        while True:
            p.run_until(e.symbols["malloc"])
            print(f"[thread {p.tid}] malloc")
    except ThreadExitError:
        print("thread exit error")
        pass

p.set_thread_entry(thread_entry)
p.run()
print("pass")
```

`tests/thread_10.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NTHREAD 10

void* thread(void* arg) {
    void *allocs[10];
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
}
int main(int argc, char** argv) {
    pthread_t threads[NTHREAD];
    for (int i=0; i<NTHREAD; i++) {
        pthread_create(&threads[i], 0, thread, 0);
    }

    for (int i=0; i<NTHREAD; i++) {
        void *ret;
        pthread_join(threads[i], &ret);
    }

    // thread(NULL);
    return 0;
}
```

`tests/thread_1000.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NTHREAD 1000

void* thread(void* arg) {
    void *allocs[10];
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
}
int main(int argc, char** argv) {
    pthread_t threads[NTHREAD];
    for (int i=0; i<NTHREAD; i++) {
        pthread_create(&threads[i], 0, thread, 0);
    }

    for (int i=0; i<NTHREAD; i++) {
        void *ret;
        pthread_join(threads[i], &ret);
    }

    // thread(NULL);
    return 0;
}
```

`tests/thread_nojoin.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NTHREAD 1000

void* thread(void* arg) {
    void *allocs[10];
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
    for (int i=0; i<10; i++) {
        allocs[i] = malloc(0x100);
    }
    for (int i=0; i<10; i++) {
        free(allocs[i]);
    }
}
int main(int argc, char** argv) {
    pthread_t threads[NTHREAD];
    for (int i=0; i<NTHREAD; i++) {
        pthread_create(&threads[i], 0, thread, 0);
    }

    // thread(NULL);
    return 0;
}
```