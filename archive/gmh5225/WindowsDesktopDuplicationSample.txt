Project Path: arc_gmh5225_WindowsDesktopDuplicationSample_e82cths7

Source Tree:

```txt
arc_gmh5225_WindowsDesktopDuplicationSample_e82cths7
├── LICENSE
├── Resource.h
├── WinDesktopDup.cpp
├── WinDesktopDup.h
├── readme.md
├── small.ico
├── stdafx.cpp
├── stdafx.h
├── targetver.h
├── tsf.cpp
├── tsf.h
├── windup.cpp
├── windup.h
├── windup.ico
├── windup.rc
├── windup.sln
├── windup.vcxproj
└── windup.vcxproj.filters

```

`LICENSE`:

```
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>
```

`Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by windup.rc

#define IDS_APP_TITLE			103

#define IDR_MAINFRAME			128
#define IDD_WINDUP_DIALOG	102
#define IDD_ABOUTBOX			103
#define IDM_ABOUT				104
#define IDM_EXIT				105
#define IDI_WINDUP			107
#define IDI_SMALL				108
#define IDC_WINDUP			109
#define IDC_MYICON				2
#ifndef IDC_STATIC
#define IDC_STATIC				-1
#endif
// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NO_MFC					130
#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_COMMAND_VALUE		32771
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		110
#endif
#endif

```

`WinDesktopDup.cpp`:

```cpp
#include "stdafx.h"
#include "WinDesktopDup.h"

WinDesktopDup::~WinDesktopDup() {
	Close();
}

Error WinDesktopDup::Initialize() {
	// Get desktop
	HDESK hDesk = OpenInputDesktop(0, FALSE, GENERIC_ALL);
	if (!hDesk)
		return "Failed to open desktop";

	// Attach desktop to this thread (presumably for cases where this is not the main/UI thread)
	bool deskAttached = SetThreadDesktop(hDesk) != 0;
	CloseDesktop(hDesk);
	hDesk = nullptr;
	if (!deskAttached)
		return "Failed to attach recording thread to desktop";

	// Initialize DirectX
	HRESULT hr = S_OK;

	// Driver types supported
	D3D_DRIVER_TYPE driverTypes[] = {
	    D3D_DRIVER_TYPE_HARDWARE,
	    D3D_DRIVER_TYPE_WARP,
	    D3D_DRIVER_TYPE_REFERENCE,
	};
	auto numDriverTypes = ARRAYSIZE(driverTypes);

	// Feature levels supported
	D3D_FEATURE_LEVEL featureLevels[] = {
	    D3D_FEATURE_LEVEL_11_0,
	    D3D_FEATURE_LEVEL_10_1,
	    D3D_FEATURE_LEVEL_10_0,
	    D3D_FEATURE_LEVEL_9_1};
	auto numFeatureLevels = ARRAYSIZE(featureLevels);

	D3D_FEATURE_LEVEL featureLevel;

	// Create device
	for (size_t i = 0; i < numDriverTypes; i++) {
		hr = D3D11CreateDevice(nullptr, driverTypes[i], nullptr, 0, featureLevels, (UINT) numFeatureLevels,
		                       D3D11_SDK_VERSION, &D3DDevice, &featureLevel, &D3DDeviceContext);
		if (SUCCEEDED(hr))
			break;
	}
	if (FAILED(hr))
		return tsf::fmt("D3D11CreateDevice failed: %v", hr);

	// Initialize the Desktop Duplication system
	//m_OutputNumber = Output;

	// Get DXGI device
	IDXGIDevice* dxgiDevice = nullptr;
	hr                      = D3DDevice->QueryInterface(__uuidof(IDXGIDevice), (void**) &dxgiDevice);
	if (FAILED(hr))
		return tsf::fmt("D3DDevice->QueryInterface failed: %v", hr);

	// Get DXGI adapter
	IDXGIAdapter* dxgiAdapter = nullptr;
	hr                        = dxgiDevice->GetParent(__uuidof(IDXGIAdapter), (void**) &dxgiAdapter);
	dxgiDevice->Release();
	dxgiDevice = nullptr;
	if (FAILED(hr)) {
		return tsf::fmt("dxgiDevice->GetParent failed: %v", hr);
		//return ProcessFailure(m_Device, L"Failed to get parent DXGI Adapter", L"Error", hr, SystemTransitionsExpectedErrors);
	}

	// Get output
	IDXGIOutput* dxgiOutput = nullptr;
	hr                      = dxgiAdapter->EnumOutputs(OutputNumber, &dxgiOutput);
	dxgiAdapter->Release();
	dxgiAdapter = nullptr;
	if (FAILED(hr)) {
		return tsf::fmt("dxgiAdapter->EnumOutputs failed: %v", hr);
		//return ProcessFailure(m_Device, L"Failed to get specified output in DUPLICATIONMANAGER", L"Error", hr, EnumOutputsExpectedErrors);
	}

	dxgiOutput->GetDesc(&OutputDesc);

	// QI for Output 1
	IDXGIOutput1* dxgiOutput1 = nullptr;
	hr                        = dxgiOutput->QueryInterface(__uuidof(dxgiOutput1), (void**) &dxgiOutput1);
	dxgiOutput->Release();
	dxgiOutput = nullptr;
	if (FAILED(hr))
		return tsf::fmt("dxgiOutput->QueryInterface failed: %v", hr);

	// Create desktop duplication
	hr = dxgiOutput1->DuplicateOutput(D3DDevice, &DeskDupl);
	dxgiOutput1->Release();
	dxgiOutput1 = nullptr;
	if (FAILED(hr)) {
		if (hr == DXGI_ERROR_NOT_CURRENTLY_AVAILABLE) {
			//MessageBoxW(nullptr, L"There is already the maximum number of applications using the Desktop Duplication API running, please close one of those applications and then try again.", L"Error", MB_OK);
			return "Too many desktop recorders already active";
		}
		return tsf::fmt("DuplicateOutput failed: %v", hr);
		//return ProcessFailure(m_Device, L"Failed to get duplicate output in DUPLICATIONMANAGER", L"Error", hr, CreateDuplicationExpectedErrors);
	}

	return "";
}

void WinDesktopDup::Close() {
	if (DeskDupl)
		DeskDupl->Release();

	if (D3DDeviceContext)
		D3DDeviceContext->Release();

	if (D3DDevice)
		D3DDevice->Release();

	DeskDupl         = nullptr;
	D3DDeviceContext = nullptr;
	D3DDevice        = nullptr;
	HaveFrameLock    = false;
}

bool WinDesktopDup::CaptureNext() {
	if (!DeskDupl)
		return false;

	HRESULT hr;

	// according to the docs, it's best for performance if we hang onto the frame for as long as possible,
	// and only release the previous frame immediately before acquiring the next one. Something about
	// the OS coalescing updates, so that it doesn't have to store them as distinct things.
	if (HaveFrameLock) {
		HaveFrameLock = false;
		hr            = DeskDupl->ReleaseFrame();
		// ignore response
	}

	IDXGIResource*          deskRes = nullptr;
	DXGI_OUTDUPL_FRAME_INFO frameInfo;
	hr = DeskDupl->AcquireNextFrame(0, &frameInfo, &deskRes);
	if (hr == DXGI_ERROR_WAIT_TIMEOUT) {
		// nothing to see here
		return false;
	}
	if (FAILED(hr)) {
		// perhaps shutdown and reinitialize
		auto msg = tsf::fmt("Acquire failed: %x\n", hr);
		OutputDebugStringA(msg.c_str());
		return false;
	}

	HaveFrameLock = true;

	ID3D11Texture2D* gpuTex = nullptr;
	hr                      = deskRes->QueryInterface(__uuidof(ID3D11Texture2D), (void**) &gpuTex);
	deskRes->Release();
	deskRes = nullptr;
	if (FAILED(hr)) {
		// not expected
		return false;
	}

	bool ok = true;

	D3D11_TEXTURE2D_DESC desc;
	gpuTex->GetDesc(&desc);
	desc.CPUAccessFlags     = D3D11_CPU_ACCESS_WRITE | D3D11_CPU_ACCESS_READ;
	desc.Usage              = D3D11_USAGE_STAGING;
	desc.BindFlags          = 0;
	desc.MiscFlags          = 0; // D3D11_RESOURCE_MISC_GDI_COMPATIBLE ?
	ID3D11Texture2D* cpuTex = nullptr;
	hr                      = D3DDevice->CreateTexture2D(&desc, nullptr, &cpuTex);
	if (SUCCEEDED(hr)) {
		D3DDeviceContext->CopyResource(cpuTex, gpuTex);
	} else {
		// not expected
		ok = false;
	}

	//UINT                     subresource = D3D11CalcSubresource(0, 0, 0);
	D3D11_MAPPED_SUBRESOURCE sr;
	hr = D3DDeviceContext->Map(cpuTex, 0, D3D11_MAP_READ, 0, &sr);
	if (SUCCEEDED(hr)) {
		if (Latest.Width != desc.Width || Latest.Height != desc.Height) {
			Latest.Width  = desc.Width;
			Latest.Height = desc.Height;
			Latest.Buf.resize(desc.Width * desc.Height * 4);
		}
		for (int y = 0; y < (int) desc.Height; y++)
			memcpy(Latest.Buf.data() + y * desc.Width * 4, (uint8_t*) sr.pData + sr.RowPitch * y, desc.Width * 4);
		D3DDeviceContext->Unmap(cpuTex, 0);
	} else {
		ok = false;
	}

	cpuTex->Release();
	gpuTex->Release();

	return ok;
}

```

`WinDesktopDup.h`:

```h
#pragma once

typedef std::string Error;

// BGRA U8 Bitmap
struct Bitmap {
	int                  Width  = 0;
	int                  Height = 0;
	std::vector<uint8_t> Buf;
};

// WinDesktopDup hides the gory details of capturing the screen using the
// Windows Desktop Duplication API
class WinDesktopDup {
public:
	Bitmap Latest;
	int    OutputNumber = 0;

	~WinDesktopDup();

	Error Initialize();
	void  Close();
	bool  CaptureNext();

private:
	ID3D11Device*           D3DDevice        = nullptr;
	ID3D11DeviceContext*    D3DDeviceContext = nullptr;
	IDXGIOutputDuplication* DeskDupl         = nullptr;
	DXGI_OUTPUT_DESC        OutputDesc;
	bool                    HaveFrameLock = false;
};
```

`readme.md`:

```md
# Windows Desktop Duplication API
##### (without the agonizing pain)

This is a small demo that uses the Windows Desktop Duplication API that is available since Windows 8.

Microsoft has an official sample for the Windows Desktop Duplication API, but IMO it's more complex than necessary.


```

`stdafx.cpp`:

```cpp
#include "stdafx.h"

```

`stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

#include <stdint.h>

#include "tsf.h"

#include <string>
#include <functional>
#include <vector>

#include <d3d11.h>
#include <dxgi1_2.h>

```

`targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`tsf.cpp`:

```cpp
#include "stdafx.h"
// For license, see https://github.com/IMQS/tsf
#ifndef TSF_CPP_INCLUDED
#define TSF_CPP_INCLUDED

#include "tsf.h"
#include <assert.h>
#include <string.h>
#include <stdint.h>

namespace tsf {

static const size_t argbuf_arraysize = 16;

#ifdef _WIN32
static const char* i64Prefix   = "I64";
static const char* wcharPrefix = "";
static const char  wcharType   = 'S';
#else
static const char* i64Prefix   = "ll";
static const char* wcharPrefix = "l";
static const char  wcharType   = 's';
#endif

class StackBuffer {
public:
	char*  Buffer;    // The buffer
	size_t Pos;       // The number of bytes appended
	size_t Capacity;  // Capacity of 'Buffer'
	bool   OwnBuffer; // True if we have allocated the buffer

	StackBuffer(char* staticbuf, size_t staticbuf_size) {
		OwnBuffer = false;
		Pos       = 0;
		Buffer    = staticbuf;
		Capacity  = staticbuf_size;
	}

	void Reserve(size_t bytes) {
		if (Pos + bytes > Capacity) {
			size_t ncap = Capacity * 2;
			if (ncap < Pos + bytes)
				ncap = Pos + bytes;
			char* nbuf = new char[ncap];
			memcpy(nbuf, Buffer, Pos);
			Capacity = ncap;
			if (OwnBuffer)
				delete[] Buffer;
			OwnBuffer = true;
			Buffer    = nbuf;
		}
	}

	void MoveCurrentPos(size_t bytes) {
		Pos += bytes;
		assert(Pos <= Capacity);
	}

	char* AddUninitialized(size_t bytes) {
		Reserve(bytes);
		char* p = Buffer + Pos;
		Pos += bytes;
		return p;
	}

	void Add(char c) {
		char* p = AddUninitialized(1);
		*p      = c;
	}

	size_t RemainingSpace() const { return Capacity - Pos; }
};

static int format_string(char* destination, size_t count, const char* format_str, const char* s) {
	if (format_str[0] == '%' && format_str[1] == 's') {
		size_t i = 0;
		for (; i < count; i++) {
			if (!s[i])
				return (int) i;
			destination[i] = s[i];
		}
		return -1;
	}
	return fmt_snprintf(destination, count, format_str, s);
}

template <typename TInt, int tbase, bool upcase>
int format_integer(char* destination, TInt value) {
	// we could theoretically do a lower base than 10, but then our static buffer would need to be bigger.
	static_assert(tbase >= 10 && tbase <= 36, "base invalid");
	TInt base = (TInt) tbase;
	char buf[20];

	const char* lut = upcase ? "ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" : "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz";

	size_t i = 0;
	TInt   tmp_value;
	do {
		tmp_value = value;
		value /= base;
		buf[i++] = lut[35 + (tmp_value - value * base)];
	} while (value);

	if (tmp_value < 0)
		buf[i++] = '-';

	size_t n = i;
	i--;
	for (size_t j = 0; j < n; j++, i--)
		destination[j] = buf[i];
	return (int) n;
}

static int format_int32(char* destination, size_t count, const char* format_str, int32_t v) {
	switch (format_str[1]) {
	case 'd':
	case 'i':
		if (count >= 11)
			return format_integer<int32_t, 10, false>(destination, v);
		break;
	case 'u':
		if (count >= 11)
			return format_integer<uint32_t, 10, false>(destination, v);
		break;
	case 'x':
		if (count >= 8)
			return format_integer<uint32_t, 16, false>(destination, v);
		break;
	case 'X':
		if (count >= 8)
			return format_integer<uint32_t, 16, true>(destination, v);
		break;
	}
	return fmt_snprintf(destination, count, format_str, v);
}

static int format_int64(char* destination, size_t count, const char* format_str, int64_t v) {
#ifdef _WIN32
	bool isPlain = format_str[1] == i64Prefix[0] && format_str[2] == i64Prefix[1] && format_str[3] == i64Prefix[2];
#else
    bool isPlain = format_str[1] == i64Prefix[0] && format_str[2] == i64Prefix[1];
#endif
	if (isPlain) {
		switch (format_str[4]) {
		case 'd':
		case 'i':
			if (count >= 20)
				return format_integer<int64_t, 10, false>(destination, v);
			break;
		case 'u':
			if (count >= 20)
				return format_integer<uint64_t, 10, false>(destination, v);
			break;
		case 'x':
			if (count >= 16)
				return format_integer<uint64_t, 16, false>(destination, v);
			break;
		case 'X':
			if (count >= 16)
				return format_integer<uint64_t, 16, true>(destination, v);
			break;
		}
	}
	return fmt_snprintf(destination, count, format_str, v);
}

static inline void fmt_settype(char argbuf[argbuf_arraysize], size_t pos, const char* width, char type) {
	if (width != nullptr) {
		// set the type and the width specifier
		switch (argbuf[pos - 1]) {
		case 'l':
		case 'h':
		case 'w':
			pos--;
			break;
		}

		for (; *width; width++, pos++)
			argbuf[pos] = *width;

		argbuf[pos++] = type;
		argbuf[pos++] = 0;
	} else {
		// only set the type, not the width specifier
		argbuf[pos++] = type;
		argbuf[pos++] = 0;
	}
}

static inline int fmt_output_with_snprintf(char* outbuf, char fmt_type, char argbuf[argbuf_arraysize], size_t argbufsize, size_t outputSize, const fmtarg* arg) {
#define SETTYPE1(type) fmt_settype(argbuf, argbufsize, nullptr, type)
#define SETTYPE2(width, type) fmt_settype(argbuf, argbufsize, width, type)

	bool tokenint  = false;
	bool tokenreal = false;

	switch (fmt_type) {
	case 'd':
	case 'i':
	case 'o':
	case 'u':
	case 'x':
	case 'X':
		tokenint = true;
	}

	switch (fmt_type) {
	case 'e':
	case 'E':
	case 'f':
	case 'g':
	case 'G':
	case 'a':
	case 'A':
		tokenreal = true;
	}

	switch (arg->Type) {
	case fmtarg::TNull:
		return 0;
	case fmtarg::TPtr:
		SETTYPE1('p');
		return fmt_snprintf(outbuf, outputSize, argbuf, arg->Ptr);
	case fmtarg::TCStr:
		SETTYPE2("", 's');
		return format_string(outbuf, outputSize, argbuf, arg->CStr);
	case fmtarg::TWStr:
		SETTYPE2(wcharPrefix, wcharType);
		return fmt_snprintf(outbuf, outputSize, argbuf, arg->WStr);
	case fmtarg::TI32:
		if (fmt_type == 'c') {
			SETTYPE2("", 'c');
		} else if (tokenint) {
			SETTYPE2("", fmt_type);
		} else {
			SETTYPE2("", 'd');
		}
		return format_int32(outbuf, outputSize, argbuf, arg->I32);
	case fmtarg::TU32:
		if (tokenint) {
			SETTYPE2("", fmt_type);
		} else {
			SETTYPE2("", 'u');
		}
		return format_int32(outbuf, outputSize, argbuf, arg->UI32);
	case fmtarg::TI64:
		if (tokenint) {
			SETTYPE2(i64Prefix, fmt_type);
		} else {
			SETTYPE2(i64Prefix, 'd');
		}
		return format_int64(outbuf, outputSize, argbuf, arg->I64);
		//return fmt_snprintf(outbuf, outputSize, argbuf, arg->UI64);
	case fmtarg::TU64:
		if (tokenint) {
			SETTYPE2(i64Prefix, fmt_type);
		} else {
			SETTYPE2(i64Prefix, 'u');
		}
		return format_int64(outbuf, outputSize, argbuf, arg->UI64);
	case fmtarg::TDbl:
		if (tokenreal) {
			SETTYPE1(fmt_type);
		} else {
			SETTYPE1('g');
		}
		return fmt_snprintf(outbuf, outputSize, argbuf, arg->Dbl);
	}

#undef SETTYPE1
#undef SETTYPE2

	return 0;
}

TSF_FMT_API std::string fmt_core(const context& context, const char* fmt, ssize_t nargs, const fmtarg* args) {
	static const size_t bufsize = 256;
	char                staticbuf[bufsize];
	StrLenPair          res = fmt_core(context, fmt, nargs, args, staticbuf, bufsize);
	std::string         str(res.Str, res.Len);
	if (res.Str != staticbuf)
		delete[] res.Str;
	return str;
}

TSF_FMT_API StrLenPair fmt_core(const context& context, const char* fmt, ssize_t nargs, const fmtarg* args, char* staticbuf, size_t staticbuf_size) {
	if (nargs == 0) {
		// This is a common case worth optimizing. Unfortunately we cannot return 'fmt' directly, because it may be a temporary object.
		size_t len = strlen(fmt);
		if (staticbuf_size != 0 && len <= staticbuf_size + 1) {
			memcpy(staticbuf, fmt, len + 1);
			return StrLenPair{staticbuf, len};
		}
		StrLenPair r;
		r.Str = new char[len + 1];
		r.Len = len;
		memcpy(r.Str, fmt, len + 1);
		return r;
	}

	ssize_t       tokenstart = -1; // true if we have passed a %, and are looking for the end of the token
	ssize_t       iarg       = 0;
	bool          no_args_remaining;
	bool          spec_too_long;
	bool          disallowed;
	const ssize_t MaxOutputSize = 1 * 1024 * 1024;

	size_t      initial_sprintf_guessed_size = staticbuf_size >> 2; // must be less than staticbuf_size
	StackBuffer output(staticbuf, staticbuf_size);

	char argbuf[argbuf_arraysize];

	// we can always safely look one ahead, because 'fmt' is by definition zero terminated
	for (ssize_t i = 0; fmt[i]; i++) {
		if (tokenstart != -1) {
			bool tokenint  = false;
			bool tokenreal = false;
			bool is_q      = fmt[i] == 'q';
			bool is_Q      = fmt[i] == 'Q';

			switch (fmt[i]) {
			case 'a':
			case 'A':
			case 'c':
			case 'C':
			case 'd':
			case 'i':
			case 'e':
			case 'E':
			case 'f':
			case 'g':
			case 'G':
			case 'H':
			case 'o':
			case 's':
			case 'S':
			case 'u':
			case 'x':
			case 'X':
			case 'p':
			case 'n':
			case 'v':
			case 'q':
			case 'Q':
				no_args_remaining = iarg >= nargs;                          // more tokens than arguments
				spec_too_long     = i - tokenstart >= argbuf_arraysize - 1; // %_____too much data____v
				disallowed        = fmt[i] == 'n';

				if (is_q && context.Escape_q == nullptr)
					disallowed = true;

				if (is_Q && context.Escape_Q == nullptr)
					disallowed = true;

				if (no_args_remaining || spec_too_long || disallowed) {
					for (ssize_t j = tokenstart; j <= i; j++)
						output.Add(fmt[j]);
				} else {
					// prepare the single formatting token that we will send to snprintf
					ssize_t argbufsize = 0;
					for (ssize_t j = tokenstart; j < i; j++) {
						if (fmt[j] == '*')
							continue; // ignore
						argbuf[argbufsize++] = fmt[j];
					}

					// grow output buffer size until we don't overflow
					const fmtarg* arg = &args[iarg];
					iarg++;
					ssize_t outputSize = initial_sprintf_guessed_size;
					while (true) {
						char*   outbuf  = (char*) output.AddUninitialized(outputSize);
						bool    done    = false;
						ssize_t written = 0;
						if (is_q)
							written = context.Escape_q(outbuf, outputSize, *arg);
						else if (is_Q)
							written = context.Escape_Q(outbuf, outputSize, *arg);
						else
							written = fmt_output_with_snprintf(outbuf, fmt[i], argbuf, argbufsize, outputSize, arg);

						if (written >= 0 && written < outputSize) {
							output.MoveCurrentPos(written - outputSize);
							break;
						} else if (outputSize >= MaxOutputSize) {
							// give up. I first saw this on the Microsoft CRT when trying to write the "mu" symbol to an ascii string.
							break;
						}
						// discard and try again with a larger buffer
						output.MoveCurrentPos(-outputSize);
						outputSize = outputSize * 2;
					}
				}
				tokenstart = -1;
				break;
			case '%':
				output.Add('%');
				tokenstart = -1;
				break;
			default:
				break;
			}
		} else {
			// Look ahead to find the next % token. Most of our time is spend just
			// scanning through regular text, so it pays to make that fast.
			// In order to do that, we determine up front how much space is left in
			// our buffer, and then fill it up without checking at each character,
			// whether we have enough space. This turns out to be a big win.
			ssize_t stopAt = i + output.RemainingSpace();
			for (; i < stopAt && fmt[i] != '%' && fmt[i] != 0; i++)
				output.Buffer[output.Pos++] = fmt[i];

			if (fmt[i] == '%')
				tokenstart = i;
			else if (fmt[i] == 0)
				break;
			else {
				// need more buffer space; come around for another pass
				output.Reserve(1);
				i--;
			}
		}
	}
	output.Add('\0');
	return {output.Buffer, output.Pos - 1};
}

static inline int fmt_translate_snprintf_return_value(int r, size_t count) {
	if (r < 0 || (size_t) r >= count)
		return -1;
	else
		return r;
}

TSF_FMT_API int fmt_snprintf(char* destination, size_t count, const char* format_str, ...) {
	va_list va;
	va_start(va, format_str);
	int r = vsnprintf(destination, count, format_str, va);
	va_end(va);
	return fmt_translate_snprintf_return_value(r, count);
}

} // namespace tsf

#endif
```

`tsf.h`:

```h
// For license, see https://github.com/IMQS/tsf
#pragma once
#ifndef TSF_H_INCLUDED
#define TSF_H_INCLUDED

/*

tsf: A small, typesafe, cross-platform printf replacement (tested on Windows & linux).

We use snprintf as a backend, so all of the regular formatting
commands that you expect from the printf family of functions work.
This makes the code much smaller than other implementations.

We do however implement some of the common operations ourselves,
such as emitting integers or plain strings, because most snprintf
implementations are actually very slow, and we can gain a lot of
speed by doing these common operations ourselves.

Usage:

tsf::fmt("%v %v", "abc", 123)        -->  "abc 123"     <== Use %v as a generic value type
tsf::fmt("%s %d", "abc", 123)        -->  "abc 123"     <== Specific value types are fine too, unless they conflict with the provided type, in which case they are overridden
tsf::fmt("%v", std::string("abc"))   -->  "abc"         <== std::string
tsf::fmt("%v", std::wstring("abc"))  -->  "abc"         <== std::wstring
tsf::fmt("%.3f", 25.5)               -->  "25.500"      <== Use format strings as usual
tsf::print("%v", "Hello world")      -->  "Hello world" <== Print to stdout
tsf::print(stderr, "err %v", 5)      -->  "err 5"       <== Print to stderr (or any other FILE*)

Known unsupported features:
* Positional arguments
* %*s (integer width parameter)	-- wouldn't be hard to add. Presently ignored.

API:

fmt           returns std::string.
fmt_buf       is useful if you want to provide your own buffer to avoid memory allocations.
print         prints to stdout
print(FILE*)  prints to any FILE*

By providing a cast operator to fmtarg, you can get an arbitrary type
supported as an argument, provided it fits into one of the molds of the
printf family of arguments.

We also support two custom types: %Q and %q. In order to use these, you need to provide your own
implementation that wraps one of the lower level functions, and provides a 'context' object with
custom functions defined for Escape_Q and Escape_q. These were originally added in order to provide 
quoting and escaping for SQL identifiers and SQL string literals.

*/

#if defined(_MSC_VER)
#include <basetsd.h>
typedef SSIZE_T ssize_t;
#endif

#ifndef TSF_FMT_API
#define TSF_FMT_API
#endif

#include <stdarg.h>
#include <stdint.h>
#include <string>

namespace tsf {

class fmtarg
{
public:
	enum Types
	{
		TNull,	// Used as a sentinel to indicate that no parameter was passed
		TPtr,
		TCStr,
		TWStr,
		TI32,
		TU32,
		TI64,
		TU64,
		TDbl,
	};
	union
	{
		const void*		Ptr;
		const char*		CStr;
		const wchar_t*	WStr;
		int32_t			I32;
		uint32_t		UI32;
		int64_t			I64;
		uint64_t		UI64;
		double			Dbl;
	};
	Types Type;

	fmtarg()								: Type(TNull), CStr(NULL) {}
	fmtarg(const void* v)					: Type(TPtr), Ptr(v) {}
	fmtarg(const char* v)					: Type(TCStr), CStr(v) {}
	fmtarg(const wchar_t* v)				: Type(TWStr), WStr(v) {}
	fmtarg(const std::string& v)			: Type(TCStr), CStr(v.c_str()) {}
	fmtarg(const std::wstring& v)			: Type(TWStr), WStr(v.c_str()) {}
#ifdef _MSC_VER
	fmtarg(long v)							: Type(TI32), I32(v) {}
	fmtarg(unsigned long v)					: Type(TU32), UI32(v) {}
	fmtarg(__int32 v)						: Type(TI32), I32(v) {}
	fmtarg(unsigned __int32 v)				: Type(TU32), UI32(v) {}
	fmtarg(__int64 v)						: Type(TI64), I64(v) {}
	fmtarg(unsigned __int64 v)				: Type(TU64), UI64(v) {}
#else
	// clang/gcc
	fmtarg(int v)							: Type(TI32), I32(v) {}
	fmtarg(unsigned int v)					: Type(TU32), UI32(v) {}
#if LONG_MAX == 0x7fffffff
	// 32-bit arch
	fmtarg(long v)							: Type(TI32), I32(v) {}
	fmtarg(unsigned long v)					: Type(TU32), UI32(v) {}
#else
	// 64-bit arch
	fmtarg(long v)							: Type(TI64), I64(v) {}
	fmtarg(unsigned long v)					: Type(TU64), UI64(v) {}
#endif
	fmtarg(long long v)						: Type(TI64), I64(v) {}
	fmtarg(unsigned long long v)			: Type(TU64), UI64(v) {}
#endif
	fmtarg(double v)						: Type(TDbl), Dbl(v) {}
};

/* This can be used to add custom formatting tokens.
The only supported characters that you can use are "Q" and "q".
These were added for escaping SQL identifiers and SQL strings.
*/
struct context
{
	// Return the number of characters written, or -1 if outBufSize is not large enough to hold
	// the number of characters that you need to write. Do not write a null terminator.
	typedef size_t(*WriteSpecialFunc)(char* outBuf, size_t outBufSize, const fmtarg& val);

	WriteSpecialFunc Escape_Q = nullptr;
	WriteSpecialFunc Escape_q = nullptr;
};

struct StrLenPair
{
	char*  Str;
	size_t Len;
};

TSF_FMT_API std::string fmt_core(const context& context, const char* fmt, ssize_t nargs, const fmtarg* args);
TSF_FMT_API StrLenPair  fmt_core(const context& context, const char* fmt, ssize_t nargs, const fmtarg* args, char* staticbuf, size_t staticbuf_size);

namespace internal {

inline void fmt_pack(fmtarg* pack)
{
}

inline void fmt_pack(fmtarg* pack, const fmtarg& arg)
{
	*pack = arg;
}

template<typename... Args>
void fmt_pack(fmtarg* pack, const fmtarg& arg, const Args&... args)
{
	*pack = arg;
	fmt_pack(pack + 1, args...);
}

}

// Format and return std::string
template<typename... Args>
std::string fmt(const char* fs, const Args&... args)
{
	const auto num_args = sizeof...(Args);
	fmtarg pack_array[num_args + 1]; // +1 for zero args case
	internal::fmt_pack(pack_array, args...);
	context cx;
	return fmt_core(cx, fs, (ssize_t) num_args, pack_array);
}

// If the formatted string, with null terminator, fits inside staticbuf_len, then the returned pointer is staticbuf,
// and no memory allocation takes place.
// However, if the formatted string is too large to fit inside staticbuf_len, then the returned pointer must
// be deleted with "delete[] ptr".
template<typename... Args>
StrLenPair fmt_buf(const context& cx, char* buf, size_t buf_len, const char* fs, const Args&... args)
{
	const auto num_args = sizeof...(Args);
	fmtarg pack_array[num_args + 1]; // +1 for zero args case
	internal::fmt_pack(pack_array, args...);
	return fmt_core(cx, fs, (ssize_t) num_args, pack_array, buf, buf_len);
}

// If the formatted string, with null terminator, fits inside staticbuf_len, then the returned pointer is staticbuf,
// and no memory allocation takes place.
// However, if the formatted string is too large to fit inside staticbuf_len, then the returned pointer must
// be deleted with "delete[] ptr".
template<typename... Args>
StrLenPair fmt_buf(char* buf, size_t buf_len, const char* fs, const Args&... args)
{
	context cx;
	return fmt_buf(cx, buf, buf_len, fs, args...);
}

// Format and write to FILE*
template<typename... Args>
size_t print(FILE* file, const char* fs, const Args&... args)
{
	auto res = fmt(fs, args...);
	if (res.size() == 0)
		return 0;
	return fwrite(res.c_str(), 1, res.length(), file);
}

// Format and write to stdout
template<typename... Args>
size_t print(const char* fs, const Args&... args)
{
	return print(stdout, fs, args...);
}

/*  cross-platform "snprintf"

	destination			Destination buffer
	count				Number of characters available in 'destination'. This must include space for the null terminating character.
	format_str			The format string
	return
		-1				Not enough space
		0..count-1		Number of characters written, excluding the null terminator. The null terminator was written though.
*/
TSF_FMT_API int fmt_snprintf(char* destination, size_t count, const char* format_str, ...);

} // namespace tsf

#endif
```

`windup.cpp`:

```cpp
// windup.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "windup.h"
#include "WinDesktopDup.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;                         // current instance
WCHAR     szTitle[MAX_LOADSTRING];       // The title bar text
WCHAR     szWindowClass[MAX_LOADSTRING]; // the main window class name

// Forward declarations of functions included in this code module:
ATOM    MyRegisterClass(HINSTANCE hInstance);
HWND    InitInstance(HINSTANCE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);

WinDesktopDup dup;

void SetupDpiAwareness() {
	if (!SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2))
		tsf::print("SetProcessDpiAwarenessContext failed\n");
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                      _In_opt_ HINSTANCE hPrevInstance,
                      _In_ LPWSTR lpCmdLine,
                      _In_ int    nCmdShow) {
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

	SetupDpiAwareness();

	auto err = dup.Initialize();
	//err               = dup.Capture();

	// Initialize global strings
	LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadStringW(hInstance, IDC_WINDUP, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	HWND wnd = InitInstance(hInstance, nCmdShow);
	if (!wnd)
		return FALSE;

	HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDUP));

	SetTimer(wnd, 1, 15, nullptr);

	MSG msg;

	// Main message loop:
	while (GetMessage(&msg, nullptr, 0, 0)) {
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return (int) msg.wParam;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
ATOM MyRegisterClass(HINSTANCE hInstance) {
	WNDCLASSEXW wcex;

	wcex.cbSize = sizeof(WNDCLASSEX);

	wcex.style         = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc   = WndProc;
	wcex.cbClsExtra    = 0;
	wcex.cbWndExtra    = 0;
	wcex.hInstance     = hInstance;
	wcex.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDUP));
	wcex.hCursor       = LoadCursor(nullptr, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wcex.lpszMenuName  = MAKEINTRESOURCEW(IDC_WINDUP);
	wcex.lpszClassName = szWindowClass;
	wcex.hIconSm       = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

	return RegisterClassExW(&wcex);
}

//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
HWND InitInstance(HINSTANCE hInstance, int nCmdShow) {
	hInst = hInstance; // Store instance handle in our global variable

	HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
	                          CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

	if (!hWnd) {
		return nullptr;
	}

	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);

	return hWnd;
}

//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Processes messages for the main window.
//
//  WM_COMMAND  - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
	switch (message) {
	case WM_COMMAND: {
		int wmId = LOWORD(wParam);
		// Parse the menu selections:
		switch (wmId) {
		case IDM_ABOUT:
			DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
			break;
		case IDM_EXIT:
			DestroyWindow(hWnd);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
	} break;
	case WM_TIMER:
		if (dup.CaptureNext())
			InvalidateRect(hWnd, nullptr, false);
		break;
	case WM_PAINT: {
		PAINTSTRUCT ps;
		HDC         hdc = BeginPaint(hWnd, &ps);
		BITMAPINFO  inf;
		memset(&inf, 0, sizeof(inf));
		inf.bmiHeader.biSize        = sizeof(inf.bmiHeader);
		inf.bmiHeader.biWidth       = dup.Latest.Width;
		inf.bmiHeader.biHeight      = -dup.Latest.Height;
		inf.bmiHeader.biPlanes      = 1;
		inf.bmiHeader.biBitCount    = 32;
		inf.bmiHeader.biCompression = BI_RGB;
		void*   bits                = nullptr;
		HDC     srcDC               = CreateCompatibleDC(hdc);
		HBITMAP dib                 = CreateDIBSection(hdc, &inf, 0, &bits, nullptr, 0);
		memcpy(bits, dup.Latest.Buf.data(), dup.Latest.Width * dup.Latest.Height * 4);
		SelectObject(srcDC, dib);
		BitBlt(hdc, 0, 0, dup.Latest.Width, dup.Latest.Height, srcDC, 0, 0, SRCCOPY);
		DeleteObject(dib);
		DeleteObject(srcDC);
		EndPaint(hWnd, &ps);
	} break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}

// Message handler for about box.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	UNREFERENCED_PARAMETER(lParam);
	switch (message) {
	case WM_INITDIALOG:
		return (INT_PTR) TRUE;

	case WM_COMMAND:
		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
			EndDialog(hDlg, LOWORD(wParam));
			return (INT_PTR) TRUE;
		}
		break;
	}
	return (INT_PTR) FALSE;
}

```

`windup.h`:

```h
#pragma once

#include "resource.h"

```

`windup.rc`:

```rc
//Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#define APSTUDIO_HIDDEN_SYMBOLS
#include "windows.h"
#undef APSTUDIO_HIDDEN_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.

IDI_WINDUP       ICON         "windup.ico"
IDI_SMALL               ICON         "small.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDC_WINDUP MENU
BEGIN
    POPUP "&File"
    BEGIN
        MENUITEM "E&xit",                IDM_EXIT
    END
    POPUP "&Help"
    BEGIN
        MENUITEM "&About ...",           IDM_ABOUT
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDC_WINDUP ACCELERATORS
BEGIN
    "?",            IDM_ABOUT,              ASCII,  ALT
    "/",            IDM_ABOUT,              ASCII,  ALT
END


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "About windup"
FONT 8, "MS Shell Dlg"
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "windup, Version 1.0",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (c) 2019",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "OK",IDOK,113,41,50,14,WS_GROUP
END

/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END
END
#endif    // APSTUDIO_INVOKED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include ""windows.h""\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
   IDC_WINDUP   "WINDUP"
   IDS_APP_TITLE       "windup"
END

#endif
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE resource.
//

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`windup.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2041
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "windup", "windup.vcxproj", "{4415F877-AF7C-4959-94EC-703C30E3F612}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4415F877-AF7C-4959-94EC-703C30E3F612}.Debug|x64.ActiveCfg = Debug|x64
		{4415F877-AF7C-4959-94EC-703C30E3F612}.Debug|x64.Build.0 = Debug|x64
		{4415F877-AF7C-4959-94EC-703C30E3F612}.Debug|x86.ActiveCfg = Debug|Win32
		{4415F877-AF7C-4959-94EC-703C30E3F612}.Debug|x86.Build.0 = Debug|Win32
		{4415F877-AF7C-4959-94EC-703C30E3F612}.Release|x64.ActiveCfg = Release|x64
		{4415F877-AF7C-4959-94EC-703C30E3F612}.Release|x64.Build.0 = Release|x64
		{4415F877-AF7C-4959-94EC-703C30E3F612}.Release|x86.ActiveCfg = Release|Win32
		{4415F877-AF7C-4959-94EC-703C30E3F612}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {210C0573-3583-4609-8037-B888C6DA9E9A}
	EndGlobalSection
EndGlobal

```

`windup.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{4415F877-AF7C-4959-94EC-703C30E3F612}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>windup</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="tsf.h" />
    <ClInclude Include="WinDesktopDup.h" />
    <ClInclude Include="windup.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="tsf.cpp" />
    <ClCompile Include="WinDesktopDup.cpp" />
    <ClCompile Include="windup.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="windup.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="small.ico" />
    <Image Include="windup.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`windup.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="windup.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WinDesktopDup.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="tsf.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="windup.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WinDesktopDup.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="tsf.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="windup.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="small.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="windup.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```