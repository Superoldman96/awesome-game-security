Project Path: arc_gmh5225_return-address-spoofing_vj5fe0gi

Source Tree:

```txt
arc_gmh5225_return-address-spoofing_vj5fe0gi
├── README.md
├── ReturnSpoof.asm
└── ReturnSpoof.hpp

```

`README.md`:

```md
# GTA-return-address-spoofing
works with most public invokers, spoofs the return address to act as a bypass and allow checked natives to be called.

Implement in your invoker EndCall example:</br>
`spoof_call(g_GameVariables->GetNativeReturnAddress(), static_cast<void(*)(rage::scrNativeCallContext*)>(handler), static_cast<rage::scrNativeCallContext*>(&m_Context));`

```

`ReturnSpoof.asm`:

```asm
    	PUBLIC _spoofer_stub
     
    .code
     
    _spoofer_stub PROC
        pop r11
        pop r10
        mov rax, [rsp + 24]
        
        mov r10, [rax]
        mov [rsp], r10
        
        mov r10, [rax + 8]
        mov [rax + 8], r11
     
        mov [rax + 16], rbx
        lea rbx, fixup
        mov [rax], rbx
        mov rbx, rax
        
        jmp r10
     
    fixup:
        sub rsp, 16
        mov rcx, rbx
        mov rbx, [rcx + 16]
        jmp QWORD PTR [rcx + 8]
    _spoofer_stub ENDP
     
    END
```

`ReturnSpoof.hpp`:

```hpp
#include <type_traits>

namespace detail
{
	extern "C" void* _spoofer_stub();

	template <typename Ret, typename... Args>
	static inline auto shellcode_stub_helper(
		const void* shell,
		Args... args
	) -> Ret
	{
		auto fn = (Ret(*)(Args...))(shell);
		return fn(args...);
	}

	template <std::size_t Argc, typename>
	struct argument_remapper
	{
		// At least 5 params
		template<
			typename Ret,
			typename First,
			typename Second,
			typename Third,
			typename Fourth,
			typename... Pack
		>
			static auto do_call(
				const void* shell,
				void* shell_param,
				First first,
				Second second,
				Third third,
				Fourth fourth,
				Pack... pack
			) -> Ret
		{
			return shellcode_stub_helper<
				Ret,
				First,
				Second,
				Third,
				Fourth,
				void*,
				void*,
				Pack...
			>(
				shell,
				first,
				second,
				third,
				fourth,
				shell_param,
				nullptr,
				pack...
				);
		}
	};

	template <std::size_t Argc>
	struct argument_remapper<Argc, std::enable_if_t<Argc <= 4>>
	{
		// 4 or less params
		template<
			typename Ret,
			typename First = void*,
			typename Second = void*,
			typename Third = void*,
			typename Fourth = void*
		>
			static auto do_call(
				const void* shell,
				void* shell_param,
				First first = First{},
				Second second = Second{},
				Third third = Third{},
				Fourth fourth = Fourth{}
			) -> Ret
		{
			return shellcode_stub_helper<
				Ret,
				First,
				Second,
				Third,
				Fourth,
				void*,
				void*
			>(
				shell,
				first,
				second,
				third,
				fourth,
				shell_param,
				nullptr
				);
		}
	};
}


template <typename Ret, typename... Args>
static inline auto spoof_call(
	const void* trampoline,
	Ret(*fn)(Args...),
	Args... args
) -> Ret
{
	struct shell_params
	{
		const void* trampoline;
		void* function;
		void* rbx;
	};

	shell_params p{ trampoline, reinterpret_cast<void*>(fn) };
	using mapper = detail::argument_remapper<sizeof...(Args), void>;
	return mapper::template do_call<Ret, Args...>((const void*)&detail::_spoofer_stub, &p, args...);
}
```