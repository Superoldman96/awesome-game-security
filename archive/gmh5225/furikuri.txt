Project Path: arc_gmh5225_furikuri_pr6cd04u

Source Tree:

```txt
arc_gmh5225_furikuri_pr6cd04u
├── LICENSE
├── capstone
├── enma_pe
├── examples
│   ├── executable obfuscation
│   │   ├── executable obfuscation.cpp
│   │   ├── executable obfuscation.sln
│   │   ├── executable obfuscation.vcxproj
│   │   └── executable obfuscation.vcxproj.filters
│   └── shellcode obfuscation
│       ├── lzo1z.h
│       ├── lzo2_mdd32.lib
│       ├── lzo2_mdd64.lib
│       ├── lzo2_mt32.lib
│       ├── lzo2_mt64.lib
│       ├── lzoconf.h
│       ├── lzodefs.h
│       ├── shellcode obfuscation.cpp
│       ├── shellcode obfuscation.sln
│       ├── shellcode obfuscation.vcxproj
│       └── shellcode obfuscation.vcxproj.filters
├── fukutasm
├── furikuri
│   ├── fuku_mutation_imp.h
│   ├── fuku_mutation_x64.cpp
│   ├── fuku_mutation_x64.h
│   ├── fuku_mutation_x64_junk.cpp
│   ├── fuku_mutation_x64_junk.h
│   ├── fuku_mutation_x64_rules.cpp
│   ├── fuku_mutation_x64_rules.h
│   ├── fuku_mutation_x86.cpp
│   ├── fuku_mutation_x86.h
│   ├── fuku_mutation_x86_junk.cpp
│   ├── fuku_mutation_x86_junk.h
│   ├── fuku_mutation_x86_rules.cpp
│   ├── fuku_mutation_x86_rules.h
│   ├── fuku_obfuscator.cpp
│   ├── fuku_obfuscator.h
│   ├── fuku_protect_mgr.cpp
│   ├── fuku_protect_mgr.h
│   ├── fuku_protect_obfuscator_mgr.h
│   ├── fuku_protect_virtualizer_mgr.h
│   ├── fuku_settings_mgr.cpp
│   ├── fuku_settings_mgr.h
│   ├── fuku_settings_obfuscation.cpp
│   ├── fuku_settings_obfuscation.h
│   ├── fuku_settings_virtualization.cpp
│   ├── fuku_settings_virtualization.h
│   ├── fuku_virtualizer_imp.h
│   ├── furikuri.cpp
│   ├── furikuri.h
│   ├── furikuri.vcxproj
│   ├── furikuri.vcxproj.filters
│   ├── obf_templates
│   ├── psyche_block.cpp
│   ├── psyche_block.h
│   ├── psyche_cmd.cpp
│   ├── psyche_cmd.h
│   ├── psyche_handler.cpp
│   ├── psyche_handler.h
│   ├── psyche_pcode.cpp
│   ├── psyche_pcode.h
│   ├── psyche_storage.cpp
│   ├── psyche_storage.h
│   ├── stdafx.cpp
│   └── stdafx.h
├── furikuri.sln
├── furikuri_console
│   ├── furikuri_console.cpp
│   ├── furikuri_console.vcxproj
│   ├── furikuri_console.vcxproj.filters
│   ├── stdafx.cpp
│   └── stdafx.h
└── readme.md

```

`LICENSE`:

```
Copyright (c) 2018, JNA aka jnastarot
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 - Neither the name of JNA nor the names of its contributors may
   be used to endorse or promote products derived from this software without
   specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`examples/executable obfuscation/executable obfuscation.cpp`:

```cpp

#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <time.h>
#include <stdio.h>
#include <sstream>
#include <iostream>
#include <iostream>
#include <stdarg.h> 
#include <cstdint>

using namespace std;

#include <capstone/include/capstone/capstone.h>
#include <enma_pe/enma_pe/enma_pe.h>
#include <fukutasm/fukutasm/fukutasm.h>
#include <furikuri/furikuri.h>

int main() {

    pe_image _module(std::string("C:\\test_executable.exe"));

    if (_module.get_image_status() == pe_image_status_unknown) {

        cout << "Cant open file !" << endl;

        return 1;
    }
    else if (_module.get_image_status() == pe_image_status_bad_format) {

        cout << "Target file has invalid pe format !" << endl;

        return 1;
    }


    furikuri fuku;

    if (fuku.set_image_protect(_module)) {

        std::vector<uint8_t> out_image;

        fuku_settings_obfuscation ob_set(2, 2, 40.f, 30.f, 40.f,
            FUKU_ASM_SHORT_CFG_USE_EAX_SHORT | FUKU_ASM_SHORT_CFG_USE_DISP_SHORT | FUKU_ASM_SHORT_CFG_USE_IMM_SHORT, 
            false, false);

        //           { code segment rva, code segment size }
        fuku.add_ob_code_list({ 0x1000 , 0x6F0 }, ob_set);
  
        fuku_settings_mgr fuku_snapshot;

        if (fuku.fuku_protect(out_image)) {

            FILE* hTargetFile;
            fopen_s(&hTargetFile, "C:\\result_executable.exe", "wb");

            if (hTargetFile) {

                fwrite(out_image.data(), out_image.size(), 1, hTargetFile);
                fclose(hTargetFile);

                
                cout << "Protect was successful !" << endl;
            }
        }
        else {
            cout << "Protect was unsuccessful !" << endl;

            return 1;
        }
    }

    return 0;
}

```

`examples/executable obfuscation/executable obfuscation.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29209.62
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "executable obfuscation", "executable obfuscation.vcxproj", "{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Debug|x64.ActiveCfg = Debug|x64
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Debug|x64.Build.0 = Debug|x64
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Debug|x86.ActiveCfg = Debug|Win32
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Debug|x86.Build.0 = Debug|Win32
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Release|x64.ActiveCfg = Release|x64
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Release|x64.Build.0 = Release|x64
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Release|x86.ActiveCfg = Release|Win32
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FFDAA449-44D0-4701-9B88-06550CF5DCC9}
	EndGlobalSection
EndGlobal

```

`examples/executable obfuscation/executable obfuscation.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>executableobfuscation</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="executable obfuscation.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/executable obfuscation/executable obfuscation.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="executable obfuscation.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`examples/shellcode obfuscation/lzo1z.h`:

```h
/* lzo1z.h -- public interface of the LZO1Z compression algorithm

   This file is part of the LZO real-time data compression library.

   Copyright (C) 1996-2017 Markus Franz Xaver Johannes Oberhumer
   All Rights Reserved.

   The LZO library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The LZO library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the LZO library; see the file COPYING.
   If not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

   Markus F.X.J. Oberhumer
   <markus@oberhumer.com>
   http://www.oberhumer.com/opensource/lzo/
 */


#ifndef __LZO1Z_H_INCLUDED
#define __LZO1Z_H_INCLUDED 1

#ifndef __LZOCONF_H_INCLUDED
#include "lzoconf.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif


/***********************************************************************
//
************************************************************************/

/* Memory required for the wrkmem parameter.
 * When the required size is 0, you can also pass a NULL pointer.
 */

#define LZO1Z_MEM_DECOMPRESS    (0)


/* decompression */
LZO_EXTERN(int)
lzo1z_decompress        ( const lzo_bytep src, lzo_uint  src_len,
                                lzo_bytep dst, lzo_uintp dst_len,
                                lzo_voidp wrkmem /* NOT USED */ );

/* safe decompression with overrun testing */
LZO_EXTERN(int)
lzo1z_decompress_safe   ( const lzo_bytep src, lzo_uint  src_len,
                                lzo_bytep dst, lzo_uintp dst_len,
                                lzo_voidp wrkmem /* NOT USED */ );


/***********************************************************************
// better compression ratio at the cost of more memory and time
************************************************************************/

#define LZO1Z_999_MEM_COMPRESS  ((lzo_uint32_t) (14 * 16384L * sizeof(short)))

LZO_EXTERN(int)
lzo1z_999_compress      ( const lzo_bytep src, lzo_uint  src_len,
                                lzo_bytep dst, lzo_uintp dst_len,
                                lzo_voidp wrkmem );


/***********************************************************************
//
************************************************************************/

LZO_EXTERN(int)
lzo1z_999_compress_dict     ( const lzo_bytep src, lzo_uint  src_len,
                                    lzo_bytep dst, lzo_uintp dst_len,
                                    lzo_voidp wrkmem,
                              const lzo_bytep dict, lzo_uint dict_len );

LZO_EXTERN(int)
lzo1z_999_compress_level    ( const lzo_bytep src, lzo_uint  src_len,
                                    lzo_bytep dst, lzo_uintp dst_len,
                                    lzo_voidp wrkmem,
                              const lzo_bytep dict, lzo_uint dict_len,
                                    lzo_callback_p cb,
                                    int compression_level );

LZO_EXTERN(int)
lzo1z_decompress_dict_safe ( const lzo_bytep src, lzo_uint  src_len,
                                   lzo_bytep dst, lzo_uintp dst_len,
                                   lzo_voidp wrkmem /* NOT USED */,
                             const lzo_bytep dict, lzo_uint dict_len );


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* already included */


/* vim:set ts=4 sw=4 et: */

```

`examples/shellcode obfuscation/lzoconf.h`:

```h
/* lzoconf.h -- configuration of the LZO data compression library

   This file is part of the LZO real-time data compression library.

   Copyright (C) 1996-2017 Markus Franz Xaver Johannes Oberhumer
   All Rights Reserved.

   The LZO library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The LZO library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the LZO library; see the file COPYING.
   If not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

   Markus F.X.J. Oberhumer
   <markus@oberhumer.com>
   http://www.oberhumer.com/opensource/lzo/
 */


#ifndef __LZOCONF_H_INCLUDED
#define __LZOCONF_H_INCLUDED 1

#define LZO_VERSION             0x20a0  /* 2.10 */
#define LZO_VERSION_STRING      "2.10"
#define LZO_VERSION_DATE        "Mar 01 2017"

/* internal Autoconf configuration file - only used when building LZO */
#if defined(LZO_HAVE_CONFIG_H)
#  include <config.h>
#endif
#include <limits.h>
#include <stddef.h>


/***********************************************************************
// LZO requires a conforming <limits.h>
************************************************************************/

#if !defined(CHAR_BIT) || (CHAR_BIT != 8)
#  error "invalid CHAR_BIT"
#endif
#if !defined(UCHAR_MAX) || !defined(USHRT_MAX) || !defined(UINT_MAX) || !defined(ULONG_MAX)
#  error "check your compiler installation"
#endif
#if (USHRT_MAX < 1) || (UINT_MAX < 1) || (ULONG_MAX < 1)
#  error "your limits.h macros are broken"
#endif

/* get OS and architecture defines */
#ifndef __LZODEFS_H_INCLUDED
#include "lzodefs.h"
#endif


#ifdef __cplusplus
extern "C" {
#endif


/***********************************************************************
// some core defines
************************************************************************/

/* memory checkers */
#if !defined(__LZO_CHECKER)
#  if defined(__BOUNDS_CHECKING_ON)
#    define __LZO_CHECKER       1
#  elif defined(__CHECKER__)
#    define __LZO_CHECKER       1
#  elif defined(__INSURE__)
#    define __LZO_CHECKER       1
#  elif defined(__PURIFY__)
#    define __LZO_CHECKER       1
#  endif
#endif


/***********************************************************************
// integral and pointer types
************************************************************************/

/* lzo_uint must match size_t */
#if !defined(LZO_UINT_MAX)
#  if (LZO_ABI_LLP64)
#    if (LZO_OS_WIN64)
     typedef unsigned __int64   lzo_uint;
     typedef __int64            lzo_int;
#    define LZO_TYPEOF_LZO_INT  LZO_TYPEOF___INT64
#    else
     typedef lzo_ullong_t       lzo_uint;
     typedef lzo_llong_t        lzo_int;
#    define LZO_TYPEOF_LZO_INT  LZO_TYPEOF_LONG_LONG
#    endif
#    define LZO_SIZEOF_LZO_INT  8
#    define LZO_UINT_MAX        0xffffffffffffffffull
#    define LZO_INT_MAX         9223372036854775807LL
#    define LZO_INT_MIN         (-1LL - LZO_INT_MAX)
#  elif (LZO_ABI_IP32L64) /* MIPS R5900 */
     typedef unsigned int       lzo_uint;
     typedef int                lzo_int;
#    define LZO_SIZEOF_LZO_INT  LZO_SIZEOF_INT
#    define LZO_TYPEOF_LZO_INT  LZO_TYPEOF_INT
#    define LZO_UINT_MAX        UINT_MAX
#    define LZO_INT_MAX         INT_MAX
#    define LZO_INT_MIN         INT_MIN
#  elif (ULONG_MAX >= LZO_0xffffffffL)
     typedef unsigned long      lzo_uint;
     typedef long               lzo_int;
#    define LZO_SIZEOF_LZO_INT  LZO_SIZEOF_LONG
#    define LZO_TYPEOF_LZO_INT  LZO_TYPEOF_LONG
#    define LZO_UINT_MAX        ULONG_MAX
#    define LZO_INT_MAX         LONG_MAX
#    define LZO_INT_MIN         LONG_MIN
#  else
#    error "lzo_uint"
#  endif
#endif

/* The larger type of lzo_uint and lzo_uint32_t. */
#if (LZO_SIZEOF_LZO_INT >= 4)
#  define lzo_xint              lzo_uint
#else
#  define lzo_xint              lzo_uint32_t
#endif

typedef int lzo_bool;

/* sanity checks */
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int)  == LZO_SIZEOF_LZO_INT)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == LZO_SIZEOF_LZO_INT)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_xint) >= sizeof(lzo_uint))
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_xint) >= sizeof(lzo_uint32_t))

#ifndef __LZO_MMODEL
#define __LZO_MMODEL            /*empty*/
#endif

/* no typedef here because of const-pointer issues */
#define lzo_bytep               unsigned char __LZO_MMODEL *
#define lzo_charp               char __LZO_MMODEL *
#define lzo_voidp               void __LZO_MMODEL *
#define lzo_shortp              short __LZO_MMODEL *
#define lzo_ushortp             unsigned short __LZO_MMODEL *
#define lzo_intp                lzo_int __LZO_MMODEL *
#define lzo_uintp               lzo_uint __LZO_MMODEL *
#define lzo_xintp               lzo_xint __LZO_MMODEL *
#define lzo_voidpp              lzo_voidp __LZO_MMODEL *
#define lzo_bytepp              lzo_bytep __LZO_MMODEL *

#define lzo_int8_tp             lzo_int8_t __LZO_MMODEL *
#define lzo_uint8_tp            lzo_uint8_t __LZO_MMODEL *
#define lzo_int16_tp            lzo_int16_t __LZO_MMODEL *
#define lzo_uint16_tp           lzo_uint16_t __LZO_MMODEL *
#define lzo_int32_tp            lzo_int32_t __LZO_MMODEL *
#define lzo_uint32_tp           lzo_uint32_t __LZO_MMODEL *
#if defined(lzo_int64_t)
#define lzo_int64_tp            lzo_int64_t __LZO_MMODEL *
#define lzo_uint64_tp           lzo_uint64_t __LZO_MMODEL *
#endif

/* Older LZO versions used to support ancient systems and memory models
 * such as 16-bit MSDOS with __huge pointers or Cray PVP, but these
 * obsolete configurations are not supported any longer.
 */
#if defined(__LZO_MMODEL_HUGE)
#error "__LZO_MMODEL_HUGE memory model is unsupported"
#endif
#if (LZO_MM_PVP)
#error "LZO_MM_PVP memory model is unsupported"
#endif
#if (LZO_SIZEOF_INT < 4)
#error "LZO_SIZEOF_INT < 4 is unsupported"
#endif
#if (__LZO_UINTPTR_T_IS_POINTER)
#error "__LZO_UINTPTR_T_IS_POINTER is unsupported"
#endif
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int) >= 4)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) >= 4)
/* Strange configurations where sizeof(lzo_uint) != sizeof(size_t) should
 * work but have not received much testing lately, so be strict here.
 */
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == sizeof(size_t))
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == sizeof(ptrdiff_t))
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == sizeof(lzo_uintptr_t))
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(void *)   == sizeof(lzo_uintptr_t))
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(char *)   == sizeof(lzo_uintptr_t))
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long *)   == sizeof(lzo_uintptr_t))
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(void *)   == sizeof(lzo_voidp))
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(char *)   == sizeof(lzo_bytep))


/***********************************************************************
// function types
************************************************************************/

/* name mangling */
#if !defined(__LZO_EXTERN_C)
#  ifdef __cplusplus
#    define __LZO_EXTERN_C      extern "C"
#  else
#    define __LZO_EXTERN_C      extern
#  endif
#endif

/* calling convention */
#if !defined(__LZO_CDECL)
#  define __LZO_CDECL           __lzo_cdecl
#endif

/* DLL export information */
#if !defined(__LZO_EXPORT1)
#  define __LZO_EXPORT1         /*empty*/
#endif
#if !defined(__LZO_EXPORT2)
#  define __LZO_EXPORT2         /*empty*/
#endif

/* __cdecl calling convention for public C and assembly functions */
#if !defined(LZO_PUBLIC)
#  define LZO_PUBLIC(r)         __LZO_EXPORT1 r __LZO_EXPORT2 __LZO_CDECL
#endif
#if !defined(LZO_EXTERN)
#  define LZO_EXTERN(r)         __LZO_EXTERN_C LZO_PUBLIC(r)
#endif
#if !defined(LZO_PRIVATE)
#  define LZO_PRIVATE(r)        static r  __LZO_CDECL
#endif

/* function types */
typedef int
(__LZO_CDECL *lzo_compress_t)   ( const lzo_bytep src, lzo_uint  src_len,
                                        lzo_bytep dst, lzo_uintp dst_len,
                                        lzo_voidp wrkmem );

typedef int
(__LZO_CDECL *lzo_decompress_t) ( const lzo_bytep src, lzo_uint  src_len,
                                        lzo_bytep dst, lzo_uintp dst_len,
                                        lzo_voidp wrkmem );

typedef int
(__LZO_CDECL *lzo_optimize_t)   (       lzo_bytep src, lzo_uint  src_len,
                                        lzo_bytep dst, lzo_uintp dst_len,
                                        lzo_voidp wrkmem );

typedef int
(__LZO_CDECL *lzo_compress_dict_t)(const lzo_bytep src, lzo_uint  src_len,
                                         lzo_bytep dst, lzo_uintp dst_len,
                                         lzo_voidp wrkmem,
                                   const lzo_bytep dict, lzo_uint dict_len );

typedef int
(__LZO_CDECL *lzo_decompress_dict_t)(const lzo_bytep src, lzo_uint  src_len,
                                           lzo_bytep dst, lzo_uintp dst_len,
                                           lzo_voidp wrkmem,
                                     const lzo_bytep dict, lzo_uint dict_len );


/* Callback interface. Currently only the progress indicator ("nprogress")
 * is used, but this may change in a future release. */

struct lzo_callback_t;
typedef struct lzo_callback_t lzo_callback_t;
#define lzo_callback_p lzo_callback_t __LZO_MMODEL *

/* malloc & free function types */
typedef lzo_voidp (__LZO_CDECL *lzo_alloc_func_t)
    (lzo_callback_p self, lzo_uint items, lzo_uint size);
typedef void      (__LZO_CDECL *lzo_free_func_t)
    (lzo_callback_p self, lzo_voidp ptr);

/* a progress indicator callback function */
typedef void (__LZO_CDECL *lzo_progress_func_t)
    (lzo_callback_p, lzo_uint, lzo_uint, int);

struct lzo_callback_t
{
    /* custom allocators (set to 0 to disable) */
    lzo_alloc_func_t nalloc;                /* [not used right now] */
    lzo_free_func_t nfree;                  /* [not used right now] */

    /* a progress indicator callback function (set to 0 to disable) */
    lzo_progress_func_t nprogress;

    /* INFO: the first parameter "self" of the nalloc/nfree/nprogress
     * callbacks points back to this struct, so you are free to store
     * some extra info in the following variables. */
    lzo_voidp user1;
    lzo_xint user2;
    lzo_xint user3;
};


/***********************************************************************
// error codes and prototypes
************************************************************************/

/* Error codes for the compression/decompression functions. Negative
 * values are errors, positive values will be used for special but
 * normal events.
 */
#define LZO_E_OK                    0
#define LZO_E_ERROR                 (-1)
#define LZO_E_OUT_OF_MEMORY         (-2)    /* [lzo_alloc_func_t failure] */
#define LZO_E_NOT_COMPRESSIBLE      (-3)    /* [not used right now] */
#define LZO_E_INPUT_OVERRUN         (-4)
#define LZO_E_OUTPUT_OVERRUN        (-5)
#define LZO_E_LOOKBEHIND_OVERRUN    (-6)
#define LZO_E_EOF_NOT_FOUND         (-7)
#define LZO_E_INPUT_NOT_CONSUMED    (-8)
#define LZO_E_NOT_YET_IMPLEMENTED   (-9)    /* [not used right now] */
#define LZO_E_INVALID_ARGUMENT      (-10)
#define LZO_E_INVALID_ALIGNMENT     (-11)   /* pointer argument is not properly aligned */
#define LZO_E_OUTPUT_NOT_CONSUMED   (-12)
#define LZO_E_INTERNAL_ERROR        (-99)


#ifndef lzo_sizeof_dict_t
#  define lzo_sizeof_dict_t     ((unsigned)sizeof(lzo_bytep))
#endif

/* lzo_init() should be the first function you call.
 * Check the return code !
 *
 * lzo_init() is a macro to allow checking that the library and the
 * compiler's view of various types are consistent.
 */
#define lzo_init() __lzo_init_v2(LZO_VERSION,(int)sizeof(short),(int)sizeof(int),\
    (int)sizeof(long),(int)sizeof(lzo_uint32_t),(int)sizeof(lzo_uint),\
    (int)lzo_sizeof_dict_t,(int)sizeof(char *),(int)sizeof(lzo_voidp),\
    (int)sizeof(lzo_callback_t))
LZO_EXTERN(int) __lzo_init_v2(unsigned,int,int,int,int,int,int,int,int,int);

/* version functions (useful for shared libraries) */
LZO_EXTERN(unsigned) lzo_version(void);
LZO_EXTERN(const char *) lzo_version_string(void);
LZO_EXTERN(const char *) lzo_version_date(void);
LZO_EXTERN(const lzo_charp) _lzo_version_string(void);
LZO_EXTERN(const lzo_charp) _lzo_version_date(void);

/* string functions */
LZO_EXTERN(int)
    lzo_memcmp(const lzo_voidp a, const lzo_voidp b, lzo_uint len);
LZO_EXTERN(lzo_voidp)
    lzo_memcpy(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
LZO_EXTERN(lzo_voidp)
    lzo_memmove(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
LZO_EXTERN(lzo_voidp)
    lzo_memset(lzo_voidp buf, int c, lzo_uint len);

/* checksum functions */
LZO_EXTERN(lzo_uint32_t)
    lzo_adler32(lzo_uint32_t c, const lzo_bytep buf, lzo_uint len);
LZO_EXTERN(lzo_uint32_t)
    lzo_crc32(lzo_uint32_t c, const lzo_bytep buf, lzo_uint len);
LZO_EXTERN(const lzo_uint32_tp)
    lzo_get_crc32_table(void);

/* misc. */
LZO_EXTERN(int) _lzo_config_check(void);
typedef union {
    lzo_voidp a00; lzo_bytep a01; lzo_uint a02; lzo_xint a03; lzo_uintptr_t a04;
    void *a05; unsigned char *a06; unsigned long a07; size_t a08; ptrdiff_t a09;
#if defined(lzo_int64_t)
    lzo_uint64_t a10;
#endif
} lzo_align_t;

/* align a char pointer on a boundary that is a multiple of 'size' */
LZO_EXTERN(unsigned) __lzo_align_gap(const lzo_voidp p, lzo_uint size);
#define LZO_PTR_ALIGN_UP(p,size) \
    ((p) + (lzo_uint) __lzo_align_gap((const lzo_voidp)(p),(lzo_uint)(size)))


/***********************************************************************
// deprecated macros - only for backward compatibility
************************************************************************/

/* deprecated - use 'lzo_bytep' instead of 'lzo_byte *' */
#define lzo_byte                unsigned char
/* deprecated type names */
#define lzo_int32               lzo_int32_t
#define lzo_uint32              lzo_uint32_t
#define lzo_int32p              lzo_int32_t __LZO_MMODEL *
#define lzo_uint32p             lzo_uint32_t __LZO_MMODEL *
#define LZO_INT32_MAX           LZO_INT32_C(2147483647)
#define LZO_UINT32_MAX          LZO_UINT32_C(4294967295)
#if defined(lzo_int64_t)
#define lzo_int64               lzo_int64_t
#define lzo_uint64              lzo_uint64_t
#define lzo_int64p              lzo_int64_t __LZO_MMODEL *
#define lzo_uint64p             lzo_uint64_t __LZO_MMODEL *
#define LZO_INT64_MAX           LZO_INT64_C(9223372036854775807)
#define LZO_UINT64_MAX          LZO_UINT64_C(18446744073709551615)
#endif
/* deprecated types */
typedef union { lzo_bytep a; lzo_uint b; } __lzo_pu_u;
typedef union { lzo_bytep a; lzo_uint32_t b; } __lzo_pu32_u;
/* deprecated defines */
#if !defined(LZO_SIZEOF_LZO_UINT)
#  define LZO_SIZEOF_LZO_UINT   LZO_SIZEOF_LZO_INT
#endif

#if defined(LZO_CFG_COMPAT)

#define __LZOCONF_H 1

#if defined(LZO_ARCH_I086)
#  define __LZO_i386 1
#elif defined(LZO_ARCH_I386)
#  define __LZO_i386 1
#endif

#if defined(LZO_OS_DOS16)
#  define __LZO_DOS 1
#  define __LZO_DOS16 1
#elif defined(LZO_OS_DOS32)
#  define __LZO_DOS 1
#elif defined(LZO_OS_WIN16)
#  define __LZO_WIN 1
#  define __LZO_WIN16 1
#elif defined(LZO_OS_WIN32)
#  define __LZO_WIN 1
#endif

#define __LZO_CMODEL            /*empty*/
#define __LZO_DMODEL            /*empty*/
#define __LZO_ENTRY             __LZO_CDECL
#define LZO_EXTERN_CDECL        LZO_EXTERN
#define LZO_ALIGN               LZO_PTR_ALIGN_UP

#define lzo_compress_asm_t      lzo_compress_t
#define lzo_decompress_asm_t    lzo_decompress_t

#endif /* LZO_CFG_COMPAT */


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* already included */


/* vim:set ts=4 sw=4 et: */

```

`examples/shellcode obfuscation/lzodefs.h`:

```h
/* lzodefs.h -- architecture, OS and compiler specific defines

   This file is part of the LZO real-time data compression library.

   Copyright (C) 1996-2017 Markus Franz Xaver Johannes Oberhumer
   All Rights Reserved.

   The LZO library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   The LZO library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with the LZO library; see the file COPYING.
   If not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

   Markus F.X.J. Oberhumer
   <markus@oberhumer.com>
   http://www.oberhumer.com/opensource/lzo/
 */


#ifndef __LZODEFS_H_INCLUDED
#define __LZODEFS_H_INCLUDED 1

#if defined(__CYGWIN32__) && !defined(__CYGWIN__)
#  define __CYGWIN__ __CYGWIN32__
#endif
#if 1 && defined(__INTERIX) && defined(__GNUC__) && !defined(_ALL_SOURCE)
#  define _ALL_SOURCE 1
#endif
#if defined(__mips__) && defined(__R5900__)
#  if !defined(__LONG_MAX__)
#    define __LONG_MAX__ 9223372036854775807L
#  endif
#endif
#if 0
#elif !defined(__LZO_LANG_OVERRIDE)
#if (defined(__clang__) || defined(__GNUC__)) && defined(__ASSEMBLER__)
#  if (__ASSEMBLER__+0) <= 0
#    error "__ASSEMBLER__"
#  else
#    define LZO_LANG_ASSEMBLER  1
#  endif
#elif defined(__cplusplus)
#  if (__cplusplus+0) <= 0
#    error "__cplusplus"
#  elif (__cplusplus < 199711L)
#    define LZO_LANG_CXX        1
#  elif defined(_MSC_VER) && defined(_MSVC_LANG) && (_MSVC_LANG+0 >= 201402L) && 1
#    define LZO_LANG_CXX        _MSVC_LANG
#  else
#    define LZO_LANG_CXX        __cplusplus
#  endif
#  define LZO_LANG_CPLUSPLUS    LZO_LANG_CXX
#else
#  if defined(__STDC_VERSION__) && (__STDC_VERSION__+0 >= 199409L)
#    define LZO_LANG_C          __STDC_VERSION__
#  else
#    define LZO_LANG_C          1
#  endif
#endif
#endif
#if !defined(LZO_CFG_NO_DISABLE_WUNDEF)
#if defined(__ARMCC_VERSION)
#  pragma diag_suppress 193
#elif defined(__clang__) && defined(__clang_minor__)
#  pragma clang diagnostic ignored "-Wundef"
#elif defined(__INTEL_COMPILER)
#  pragma warning(disable: 193)
#elif defined(__KEIL__) && defined(__C166__)
#  pragma warning disable = 322
#elif defined(__GNUC__) && defined(__GNUC_MINOR__) && !defined(__PATHSCALE__)
#  if ((__GNUC__-0) >= 5 || ((__GNUC__-0) == 4 && (__GNUC_MINOR__-0) >= 2))
#    pragma GCC diagnostic ignored "-Wundef"
#  endif
#elif defined(_MSC_VER) && !defined(__clang__) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
#  if ((_MSC_VER-0) >= 1300)
#    pragma warning(disable: 4668)
#  endif
#endif
#endif
#if 0 && defined(__POCC__) && defined(_WIN32)
#  if (__POCC__ >= 400)
#    pragma warn(disable: 2216)
#  endif
#endif
#if 0 && defined(__WATCOMC__)
#  if (__WATCOMC__ >= 1050) && (__WATCOMC__ < 1060)
#    pragma warning 203 9
#  endif
#endif
#if defined(__BORLANDC__) && defined(__MSDOS__) && !defined(__FLAT__)
#  pragma option -h
#endif
#if !(LZO_CFG_NO_DISABLE_WCRTNONSTDC)
#ifndef _CRT_NONSTDC_NO_DEPRECATE
#define _CRT_NONSTDC_NO_DEPRECATE 1
#endif
#ifndef _CRT_NONSTDC_NO_WARNINGS
#define _CRT_NONSTDC_NO_WARNINGS 1
#endif
#ifndef _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_DEPRECATE 1
#endif
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS 1
#endif
#endif
#if 0
#define LZO_0xffffUL            0xfffful
#define LZO_0xffffffffUL        0xfffffffful
#else
#define LZO_0xffffUL            65535ul
#define LZO_0xffffffffUL        4294967295ul
#endif
#define LZO_0xffffL             LZO_0xffffUL
#define LZO_0xffffffffL         LZO_0xffffffffUL
#if (LZO_0xffffL == LZO_0xffffffffL)
#  error "your preprocessor is broken 1"
#endif
#if (16ul * 16384ul != 262144ul)
#  error "your preprocessor is broken 2"
#endif
#if 0
#if (32767 >= 4294967295ul)
#  error "your preprocessor is broken 3"
#endif
#if (65535u >= 4294967295ul)
#  error "your preprocessor is broken 4"
#endif
#endif
#if defined(__COUNTER__)
#  ifndef LZO_CFG_USE_COUNTER
#  define LZO_CFG_USE_COUNTER 1
#  endif
#else
#  undef LZO_CFG_USE_COUNTER
#endif
#if (UINT_MAX == LZO_0xffffL)
#if defined(__ZTC__) && defined(__I86__) && !defined(__OS2__)
#  if !defined(MSDOS)
#    define MSDOS 1
#  endif
#  if !defined(_MSDOS)
#    define _MSDOS 1
#  endif
#elif 0 && defined(__VERSION) && defined(MB_LEN_MAX)
#  if (__VERSION == 520) && (MB_LEN_MAX == 1)
#    if !defined(__AZTEC_C__)
#      define __AZTEC_C__ __VERSION
#    endif
#    if !defined(__DOS__)
#      define __DOS__ 1
#    endif
#  endif
#endif
#endif
#if (UINT_MAX == LZO_0xffffL)
#if defined(_MSC_VER) && defined(M_I86HM)
#  define ptrdiff_t long
#  define _PTRDIFF_T_DEFINED 1
#endif
#endif
#if (UINT_MAX == LZO_0xffffL)
#  undef __LZO_RENAME_A
#  undef __LZO_RENAME_B
#  if defined(__AZTEC_C__) && defined(__DOS__)
#    define __LZO_RENAME_A 1
#  elif defined(_MSC_VER) && defined(MSDOS)
#    if (_MSC_VER < 600)
#      define __LZO_RENAME_A 1
#    elif (_MSC_VER < 700)
#      define __LZO_RENAME_B 1
#    endif
#  elif defined(__TSC__) && defined(__OS2__)
#    define __LZO_RENAME_A 1
#  elif defined(__MSDOS__) && defined(__TURBOC__) && (__TURBOC__ < 0x0410)
#    define __LZO_RENAME_A 1
#  elif defined(__PACIFIC__) && defined(DOS)
#    if !defined(__far)
#      define __far far
#    endif
#    if !defined(__near)
#      define __near near
#    endif
#  endif
#  if defined(__LZO_RENAME_A)
#    if !defined(__cdecl)
#      define __cdecl cdecl
#    endif
#    if !defined(__far)
#      define __far far
#    endif
#    if !defined(__huge)
#      define __huge huge
#    endif
#    if !defined(__near)
#      define __near near
#    endif
#    if !defined(__pascal)
#      define __pascal pascal
#    endif
#    if !defined(__huge)
#      define __huge huge
#    endif
#  elif defined(__LZO_RENAME_B)
#    if !defined(__cdecl)
#      define __cdecl _cdecl
#    endif
#    if !defined(__far)
#      define __far _far
#    endif
#    if !defined(__huge)
#      define __huge _huge
#    endif
#    if !defined(__near)
#      define __near _near
#    endif
#    if !defined(__pascal)
#      define __pascal _pascal
#    endif
#  elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
#    if !defined(__cdecl)
#      define __cdecl cdecl
#    endif
#    if !defined(__pascal)
#      define __pascal pascal
#    endif
#  endif
#  undef __LZO_RENAME_A
#  undef __LZO_RENAME_B
#endif
#if (UINT_MAX == LZO_0xffffL)
#if defined(__AZTEC_C__) && defined(__DOS__)
#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
#elif defined(_MSC_VER) && defined(MSDOS)
#  if (_MSC_VER < 600)
#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
#  endif
#  if (_MSC_VER < 700)
#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
#    define LZO_BROKEN_SIZEOF 1
#  endif
#elif defined(__PACIFIC__) && defined(DOS)
#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
#elif defined(__TURBOC__) && defined(__MSDOS__)
#  if (__TURBOC__ < 0x0150)
#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
#  endif
#  if (__TURBOC__ < 0x0200)
#    define LZO_BROKEN_SIZEOF 1
#  endif
#  if (__TURBOC__ < 0x0400) && defined(__cplusplus)
#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
#  endif
#elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
#  define LZO_BROKEN_SIZEOF 1
#endif
#endif
#if defined(__WATCOMC__) && (__WATCOMC__ < 900)
#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
#endif
#if defined(_CRAY) && defined(_CRAY1)
#  define LZO_BROKEN_SIGNED_RIGHT_SHIFT 1
#endif
#define LZO_PP_STRINGIZE(x)             #x
#define LZO_PP_MACRO_EXPAND(x)          LZO_PP_STRINGIZE(x)
#define LZO_PP_CONCAT0()                /*empty*/
#define LZO_PP_CONCAT1(a)               a
#define LZO_PP_CONCAT2(a,b)             a ## b
#define LZO_PP_CONCAT3(a,b,c)           a ## b ## c
#define LZO_PP_CONCAT4(a,b,c,d)         a ## b ## c ## d
#define LZO_PP_CONCAT5(a,b,c,d,e)       a ## b ## c ## d ## e
#define LZO_PP_CONCAT6(a,b,c,d,e,f)     a ## b ## c ## d ## e ## f
#define LZO_PP_CONCAT7(a,b,c,d,e,f,g)   a ## b ## c ## d ## e ## f ## g
#define LZO_PP_ECONCAT0()               LZO_PP_CONCAT0()
#define LZO_PP_ECONCAT1(a)              LZO_PP_CONCAT1(a)
#define LZO_PP_ECONCAT2(a,b)            LZO_PP_CONCAT2(a,b)
#define LZO_PP_ECONCAT3(a,b,c)          LZO_PP_CONCAT3(a,b,c)
#define LZO_PP_ECONCAT4(a,b,c,d)        LZO_PP_CONCAT4(a,b,c,d)
#define LZO_PP_ECONCAT5(a,b,c,d,e)      LZO_PP_CONCAT5(a,b,c,d,e)
#define LZO_PP_ECONCAT6(a,b,c,d,e,f)    LZO_PP_CONCAT6(a,b,c,d,e,f)
#define LZO_PP_ECONCAT7(a,b,c,d,e,f,g)  LZO_PP_CONCAT7(a,b,c,d,e,f,g)
#define LZO_PP_EMPTY                    /*empty*/
#define LZO_PP_EMPTY0()                 /*empty*/
#define LZO_PP_EMPTY1(a)                /*empty*/
#define LZO_PP_EMPTY2(a,b)              /*empty*/
#define LZO_PP_EMPTY3(a,b,c)            /*empty*/
#define LZO_PP_EMPTY4(a,b,c,d)          /*empty*/
#define LZO_PP_EMPTY5(a,b,c,d,e)        /*empty*/
#define LZO_PP_EMPTY6(a,b,c,d,e,f)      /*empty*/
#define LZO_PP_EMPTY7(a,b,c,d,e,f,g)    /*empty*/
#if 1
#define LZO_CPP_STRINGIZE(x)            #x
#define LZO_CPP_MACRO_EXPAND(x)         LZO_CPP_STRINGIZE(x)
#define LZO_CPP_CONCAT2(a,b)            a ## b
#define LZO_CPP_CONCAT3(a,b,c)          a ## b ## c
#define LZO_CPP_CONCAT4(a,b,c,d)        a ## b ## c ## d
#define LZO_CPP_CONCAT5(a,b,c,d,e)      a ## b ## c ## d ## e
#define LZO_CPP_CONCAT6(a,b,c,d,e,f)    a ## b ## c ## d ## e ## f
#define LZO_CPP_CONCAT7(a,b,c,d,e,f,g)  a ## b ## c ## d ## e ## f ## g
#define LZO_CPP_ECONCAT2(a,b)           LZO_CPP_CONCAT2(a,b)
#define LZO_CPP_ECONCAT3(a,b,c)         LZO_CPP_CONCAT3(a,b,c)
#define LZO_CPP_ECONCAT4(a,b,c,d)       LZO_CPP_CONCAT4(a,b,c,d)
#define LZO_CPP_ECONCAT5(a,b,c,d,e)     LZO_CPP_CONCAT5(a,b,c,d,e)
#define LZO_CPP_ECONCAT6(a,b,c,d,e,f)   LZO_CPP_CONCAT6(a,b,c,d,e,f)
#define LZO_CPP_ECONCAT7(a,b,c,d,e,f,g) LZO_CPP_CONCAT7(a,b,c,d,e,f,g)
#endif
#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-((b)!=0))) - (o)) << 1) + (o)*((b)!=0))
#if 1 && defined(__cplusplus)
#  if !defined(__STDC_CONSTANT_MACROS)
#    define __STDC_CONSTANT_MACROS 1
#  endif
#  if !defined(__STDC_LIMIT_MACROS)
#    define __STDC_LIMIT_MACROS 1
#  endif
#endif
#if defined(__cplusplus)
#  define LZO_EXTERN_C          extern "C"
#  define LZO_EXTERN_C_BEGIN    extern "C" {
#  define LZO_EXTERN_C_END      }
#else
#  define LZO_EXTERN_C          extern
#  define LZO_EXTERN_C_BEGIN    /*empty*/
#  define LZO_EXTERN_C_END      /*empty*/
#endif
#if !defined(__LZO_OS_OVERRIDE)
#if (LZO_OS_FREESTANDING)
#  define LZO_INFO_OS           "freestanding"
#elif (LZO_OS_EMBEDDED)
#  define LZO_INFO_OS           "embedded"
#elif 1 && defined(__IAR_SYSTEMS_ICC__)
#  define LZO_OS_EMBEDDED       1
#  define LZO_INFO_OS           "embedded"
#elif defined(__CYGWIN__) && defined(__GNUC__)
#  define LZO_OS_CYGWIN         1
#  define LZO_INFO_OS           "cygwin"
#elif defined(__EMX__) && defined(__GNUC__)
#  define LZO_OS_EMX            1
#  define LZO_INFO_OS           "emx"
#elif defined(__BEOS__)
#  define LZO_OS_BEOS           1
#  define LZO_INFO_OS           "beos"
#elif defined(__Lynx__)
#  define LZO_OS_LYNXOS         1
#  define LZO_INFO_OS           "lynxos"
#elif defined(__OS400__)
#  define LZO_OS_OS400          1
#  define LZO_INFO_OS           "os400"
#elif defined(__QNX__)
#  define LZO_OS_QNX            1
#  define LZO_INFO_OS           "qnx"
#elif defined(__BORLANDC__) && defined(__DPMI32__) && (__BORLANDC__ >= 0x0460)
#  define LZO_OS_DOS32          1
#  define LZO_INFO_OS           "dos32"
#elif defined(__BORLANDC__) && defined(__DPMI16__)
#  define LZO_OS_DOS16          1
#  define LZO_INFO_OS           "dos16"
#elif defined(__ZTC__) && defined(DOS386)
#  define LZO_OS_DOS32          1
#  define LZO_INFO_OS           "dos32"
#elif defined(__OS2__) || defined(__OS2V2__)
#  if (UINT_MAX == LZO_0xffffL)
#    define LZO_OS_OS216        1
#    define LZO_INFO_OS         "os216"
#  elif (UINT_MAX == LZO_0xffffffffL)
#    define LZO_OS_OS2          1
#    define LZO_INFO_OS         "os2"
#  else
#    error "check your limits.h header"
#  endif
#elif defined(__WIN64__) || defined(_WIN64) || defined(WIN64)
#  define LZO_OS_WIN64          1
#  define LZO_INFO_OS           "win64"
#elif defined(__WIN32__) || defined(_WIN32) || defined(WIN32) || defined(__WINDOWS_386__)
#  define LZO_OS_WIN32          1
#  define LZO_INFO_OS           "win32"
#elif defined(__MWERKS__) && defined(__INTEL__)
#  define LZO_OS_WIN32          1
#  define LZO_INFO_OS           "win32"
#elif defined(__WINDOWS__) || defined(_WINDOWS) || defined(_Windows)
#  if (UINT_MAX == LZO_0xffffL)
#    define LZO_OS_WIN16        1
#    define LZO_INFO_OS         "win16"
#  elif (UINT_MAX == LZO_0xffffffffL)
#    define LZO_OS_WIN32        1
#    define LZO_INFO_OS         "win32"
#  else
#    error "check your limits.h header"
#  endif
#elif defined(__DOS__) || defined(__MSDOS__) || defined(_MSDOS) || defined(MSDOS) || (defined(__PACIFIC__) && defined(DOS))
#  if (UINT_MAX == LZO_0xffffL)
#    define LZO_OS_DOS16        1
#    define LZO_INFO_OS         "dos16"
#  elif (UINT_MAX == LZO_0xffffffffL)
#    define LZO_OS_DOS32        1
#    define LZO_INFO_OS         "dos32"
#  else
#    error "check your limits.h header"
#  endif
#elif defined(__WATCOMC__)
#  if defined(__NT__) && (UINT_MAX == LZO_0xffffL)
#    define LZO_OS_DOS16        1
#    define LZO_INFO_OS         "dos16"
#  elif defined(__NT__) && (__WATCOMC__ < 1100)
#    define LZO_OS_WIN32        1
#    define LZO_INFO_OS         "win32"
#  elif defined(__linux__) || defined(__LINUX__)
#    define LZO_OS_POSIX        1
#    define LZO_INFO_OS         "posix"
#  else
#    error "please specify a target using the -bt compiler option"
#  endif
#elif defined(__palmos__)
#  define LZO_OS_PALMOS         1
#  define LZO_INFO_OS           "palmos"
#elif defined(__TOS__) || defined(__atarist__)
#  define LZO_OS_TOS            1
#  define LZO_INFO_OS           "tos"
#elif defined(macintosh) && !defined(__arm__) && !defined(__i386__) && !defined(__ppc__) && !defined(__x64_64__)
#  define LZO_OS_MACCLASSIC     1
#  define LZO_INFO_OS           "macclassic"
#elif defined(__VMS)
#  define LZO_OS_VMS            1
#  define LZO_INFO_OS           "vms"
#elif (defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__)
#  define LZO_OS_CONSOLE        1
#  define LZO_OS_CONSOLE_PS2    1
#  define LZO_INFO_OS           "console"
#  define LZO_INFO_OS_CONSOLE   "ps2"
#elif defined(__mips__) && defined(__psp__)
#  define LZO_OS_CONSOLE        1
#  define LZO_OS_CONSOLE_PSP    1
#  define LZO_INFO_OS           "console"
#  define LZO_INFO_OS_CONSOLE   "psp"
#else
#  define LZO_OS_POSIX          1
#  define LZO_INFO_OS           "posix"
#endif
#if (LZO_OS_POSIX)
#  if defined(_AIX) || defined(__AIX__) || defined(__aix__)
#    define LZO_OS_POSIX_AIX        1
#    define LZO_INFO_OS_POSIX       "aix"
#  elif defined(__FreeBSD__)
#    define LZO_OS_POSIX_FREEBSD    1
#    define LZO_INFO_OS_POSIX       "freebsd"
#  elif defined(__hpux__) || defined(__hpux)
#    define LZO_OS_POSIX_HPUX       1
#    define LZO_INFO_OS_POSIX       "hpux"
#  elif defined(__INTERIX)
#    define LZO_OS_POSIX_INTERIX    1
#    define LZO_INFO_OS_POSIX       "interix"
#  elif defined(__IRIX__) || defined(__irix__)
#    define LZO_OS_POSIX_IRIX       1
#    define LZO_INFO_OS_POSIX       "irix"
#  elif defined(__linux__) || defined(__linux) || defined(__LINUX__)
#    define LZO_OS_POSIX_LINUX      1
#    define LZO_INFO_OS_POSIX       "linux"
#  elif defined(__APPLE__) && defined(__MACH__)
#    if ((__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__-0) >= 20000)
#      define LZO_OS_POSIX_DARWIN     1040
#      define LZO_INFO_OS_POSIX       "darwin_iphone"
#    elif ((__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0) >= 1040)
#      define LZO_OS_POSIX_DARWIN     __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
#      define LZO_INFO_OS_POSIX       "darwin"
#    else
#      define LZO_OS_POSIX_DARWIN     1
#      define LZO_INFO_OS_POSIX       "darwin"
#    endif
#    define LZO_OS_POSIX_MACOSX     LZO_OS_POSIX_DARWIN
#  elif defined(__minix__) || defined(__minix)
#    define LZO_OS_POSIX_MINIX      1
#    define LZO_INFO_OS_POSIX       "minix"
#  elif defined(__NetBSD__)
#    define LZO_OS_POSIX_NETBSD     1
#    define LZO_INFO_OS_POSIX       "netbsd"
#  elif defined(__OpenBSD__)
#    define LZO_OS_POSIX_OPENBSD    1
#    define LZO_INFO_OS_POSIX       "openbsd"
#  elif defined(__osf__)
#    define LZO_OS_POSIX_OSF        1
#    define LZO_INFO_OS_POSIX       "osf"
#  elif defined(__solaris__) || defined(__sun)
#    if defined(__SVR4) || defined(__svr4__)
#      define LZO_OS_POSIX_SOLARIS  1
#      define LZO_INFO_OS_POSIX     "solaris"
#    else
#      define LZO_OS_POSIX_SUNOS    1
#      define LZO_INFO_OS_POSIX     "sunos"
#    endif
#  elif defined(__ultrix__) || defined(__ultrix)
#    define LZO_OS_POSIX_ULTRIX     1
#    define LZO_INFO_OS_POSIX       "ultrix"
#  elif defined(_UNICOS)
#    define LZO_OS_POSIX_UNICOS     1
#    define LZO_INFO_OS_POSIX       "unicos"
#  else
#    define LZO_OS_POSIX_UNKNOWN    1
#    define LZO_INFO_OS_POSIX       "unknown"
#  endif
#endif
#endif
#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
#  if (UINT_MAX != LZO_0xffffL)
#    error "unexpected configuration - check your compiler defines"
#  endif
#  if (ULONG_MAX != LZO_0xffffffffL)
#    error "unexpected configuration - check your compiler defines"
#  endif
#endif
#if (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_WIN32 || LZO_OS_WIN64)
#  if (UINT_MAX != LZO_0xffffffffL)
#    error "unexpected configuration - check your compiler defines"
#  endif
#  if (ULONG_MAX != LZO_0xffffffffL)
#    error "unexpected configuration - check your compiler defines"
#  endif
#endif
#if defined(CIL) && defined(_GNUCC) && defined(__GNUC__)
#  define LZO_CC_CILLY          1
#  define LZO_INFO_CC           "Cilly"
#  if defined(__CILLY__)
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__CILLY__)
#  else
#    define LZO_INFO_CCVER      "unknown"
#  endif
#elif 0 && defined(SDCC) && defined(__VERSION__) && !defined(__GNUC__)
#  define LZO_CC_SDCC           1
#  define LZO_INFO_CC           "sdcc"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(SDCC)
#elif defined(__PATHSCALE__) && defined(__PATHCC_PATCHLEVEL__)
#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + (__PATHCC_MINOR__-0) * 0x100 + (__PATHCC_PATCHLEVEL__-0))
#  define LZO_INFO_CC           "Pathscale C"
#  define LZO_INFO_CCVER        __PATHSCALE__
#  if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
#    define LZO_CC_PATHSCALE_GNUC (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
#  endif
#elif defined(__INTEL_COMPILER) && ((__INTEL_COMPILER-0) > 0)
#  define LZO_CC_INTELC         __INTEL_COMPILER
#  define LZO_INFO_CC           "Intel C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__INTEL_COMPILER)
#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
#    define LZO_CC_INTELC_MSC   _MSC_VER
#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
#    define LZO_CC_INTELC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
#  endif
#elif defined(__POCC__) && defined(_WIN32)
#  define LZO_CC_PELLESC        1
#  define LZO_INFO_CC           "Pelles C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__POCC__)
#elif defined(__ARMCC_VERSION) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
#  if defined(__GNUC_PATCHLEVEL__)
#    define LZO_CC_ARMCC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
#  else
#    define LZO_CC_ARMCC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
#  endif
#  define LZO_CC_ARMCC          __ARMCC_VERSION
#  define LZO_INFO_CC           "ARM C Compiler"
#  define LZO_INFO_CCVER        __VERSION__
#elif defined(__clang__) && defined(__c2__) && defined(__c2_version__) && defined(_MSC_VER)
#  define LZO_CC_CLANG          (__clang_major__ * 0x10000L + (__clang_minor__-0) * 0x100 + (__clang_patchlevel__-0))
#  define LZO_CC_CLANG_C2       _MSC_VER
#  define LZO_CC_CLANG_VENDOR_MICROSOFT 1
#  define LZO_INFO_CC           "clang/c2"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__c2_version__)
#elif defined(__clang__) && defined(__llvm__) && defined(__VERSION__)
#  if defined(__clang_major__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
#    define LZO_CC_CLANG        (__clang_major__ * 0x10000L + (__clang_minor__-0) * 0x100 + (__clang_patchlevel__-0))
#  else
#    define LZO_CC_CLANG        0x010000L
#  endif
#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
#    define LZO_CC_CLANG_MSC    _MSC_VER
#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
#  endif
#  if defined(__APPLE_CC__)
#    define LZO_CC_CLANG_VENDOR_APPLE 1
#    define LZO_INFO_CC         "clang/apple"
#  else
#    define LZO_CC_CLANG_VENDOR_LLVM 1
#    define LZO_INFO_CC         "clang"
#  endif
#  if defined(__clang_version__)
#    define LZO_INFO_CCVER      __clang_version__
#  else
#    define LZO_INFO_CCVER      __VERSION__
#  endif
#elif defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
#  if defined(__GNUC_PATCHLEVEL__)
#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
#  else
#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
#  endif
#  define LZO_CC_LLVM           LZO_CC_LLVM_GNUC
#  define LZO_INFO_CC           "llvm-gcc"
#  define LZO_INFO_CCVER        __VERSION__
#elif defined(__ACK__) && defined(_ACK)
#  define LZO_CC_ACK            1
#  define LZO_INFO_CC           "Amsterdam Compiler Kit C"
#  define LZO_INFO_CCVER        "unknown"
#elif defined(__ARMCC_VERSION) && !defined(__GNUC__)
#  define LZO_CC_ARMCC          __ARMCC_VERSION
#  define LZO_CC_ARMCC_ARMCC    __ARMCC_VERSION
#  define LZO_INFO_CC           "ARM C Compiler"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__ARMCC_VERSION)
#elif defined(__AZTEC_C__)
#  define LZO_CC_AZTECC         1
#  define LZO_INFO_CC           "Aztec C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__AZTEC_C__)
#elif defined(__CODEGEARC__)
#  define LZO_CC_CODEGEARC      1
#  define LZO_INFO_CC           "CodeGear C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__CODEGEARC__)
#elif defined(__BORLANDC__)
#  define LZO_CC_BORLANDC       1
#  define LZO_INFO_CC           "Borland C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__BORLANDC__)
#elif defined(_CRAYC) && defined(_RELEASE)
#  define LZO_CC_CRAYC          1
#  define LZO_INFO_CC           "Cray C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(_RELEASE)
#elif defined(__DMC__) && defined(__SC__)
#  define LZO_CC_DMC            1
#  define LZO_INFO_CC           "Digital Mars C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DMC__)
#elif defined(__DECC)
#  define LZO_CC_DECC           1
#  define LZO_INFO_CC           "DEC C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DECC)
#elif (defined(__ghs) || defined(__ghs__)) && defined(__GHS_VERSION_NUMBER) && ((__GHS_VERSION_NUMBER-0) > 0)
#  define LZO_CC_GHS            1
#  define LZO_INFO_CC           "Green Hills C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__GHS_VERSION_NUMBER)
#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
#    define LZO_CC_GHS_MSC      _MSC_VER
#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
#    define LZO_CC_GHS_GNUC     (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
#  endif
#elif defined(__HIGHC__)
#  define LZO_CC_HIGHC          1
#  define LZO_INFO_CC           "MetaWare High C"
#  define LZO_INFO_CCVER        "unknown"
#elif defined(__HP_aCC) && ((__HP_aCC-0) > 0)
#  define LZO_CC_HPACC          __HP_aCC
#  define LZO_INFO_CC           "HP aCC"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__HP_aCC)
#elif defined(__IAR_SYSTEMS_ICC__)
#  define LZO_CC_IARC           1
#  define LZO_INFO_CC           "IAR C"
#  if defined(__VER__)
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__VER__)
#  else
#    define LZO_INFO_CCVER      "unknown"
#  endif
#elif defined(__IBMC__) && ((__IBMC__-0) > 0)
#  define LZO_CC_IBMC           __IBMC__
#  define LZO_INFO_CC           "IBM C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMC__)
#elif defined(__IBMCPP__) && ((__IBMCPP__-0) > 0)
#  define LZO_CC_IBMC           __IBMCPP__
#  define LZO_INFO_CC           "IBM C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMCPP__)
#elif defined(__KEIL__) && defined(__C166__)
#  define LZO_CC_KEILC          1
#  define LZO_INFO_CC           "Keil C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__C166__)
#elif defined(__LCC__) && defined(_WIN32) && defined(__LCCOPTIMLEVEL)
#  define LZO_CC_LCCWIN32       1
#  define LZO_INFO_CC           "lcc-win32"
#  define LZO_INFO_CCVER        "unknown"
#elif defined(__LCC__)
#  define LZO_CC_LCC            1
#  define LZO_INFO_CC           "lcc"
#  if defined(__LCC_VERSION__)
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__LCC_VERSION__)
#  else
#    define LZO_INFO_CCVER      "unknown"
#  endif
#elif defined(__MWERKS__) && ((__MWERKS__-0) > 0)
#  define LZO_CC_MWERKS         __MWERKS__
#  define LZO_INFO_CC           "Metrowerks C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__MWERKS__)
#elif (defined(__NDPC__) || defined(__NDPX__)) && defined(__i386)
#  define LZO_CC_NDPC           1
#  define LZO_INFO_CC           "Microway NDP C"
#  define LZO_INFO_CCVER        "unknown"
#elif defined(__PACIFIC__)
#  define LZO_CC_PACIFICC       1
#  define LZO_INFO_CC           "Pacific C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PACIFIC__)
#elif defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__)
#  if defined(__PGIC_PATCHLEVEL__)
#    define LZO_CC_PGI          (__PGIC__ * 0x10000L + (__PGIC_MINOR__-0) * 0x100 + (__PGIC_PATCHLEVEL__-0))
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__PGIC__) "." LZO_PP_MACRO_EXPAND(__PGIC_MINOR__) "." LZO_PP_MACRO_EXPAND(__PGIC_PATCHLEVEL__)
#  else
#    define LZO_CC_PGI          (__PGIC__ * 0x10000L + (__PGIC_MINOR__-0) * 0x100)
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__PGIC__) "." LZO_PP_MACRO_EXPAND(__PGIC_MINOR__) ".0"
#  endif
#  define LZO_INFO_CC           "Portland Group PGI C"
#elif defined(__PGI) && (defined(__linux__) || defined(__WIN32__))
#  define LZO_CC_PGI            1
#  define LZO_INFO_CC           "Portland Group PGI C"
#  define LZO_INFO_CCVER        "unknown"
#elif defined(__PUREC__) && defined(__TOS__)
#  define LZO_CC_PUREC          1
#  define LZO_INFO_CC           "Pure C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PUREC__)
#elif defined(__SC__) && defined(__ZTC__)
#  define LZO_CC_SYMANTECC      1
#  define LZO_INFO_CC           "Symantec C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__SC__)
#elif defined(__SUNPRO_C)
#  define LZO_INFO_CC           "SunPro C"
#  if ((__SUNPRO_C-0) > 0)
#    define LZO_CC_SUNPROC      __SUNPRO_C
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_C)
#  else
#    define LZO_CC_SUNPROC      1
#    define LZO_INFO_CCVER      "unknown"
#  endif
#elif defined(__SUNPRO_CC)
#  define LZO_INFO_CC           "SunPro C"
#  if ((__SUNPRO_CC-0) > 0)
#    define LZO_CC_SUNPROC      __SUNPRO_CC
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_CC)
#  else
#    define LZO_CC_SUNPROC      1
#    define LZO_INFO_CCVER      "unknown"
#  endif
#elif defined(__TINYC__)
#  define LZO_CC_TINYC          1
#  define LZO_INFO_CC           "Tiny C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TINYC__)
#elif defined(__TSC__)
#  define LZO_CC_TOPSPEEDC      1
#  define LZO_INFO_CC           "TopSpeed C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TSC__)
#elif defined(__WATCOMC__)
#  define LZO_CC_WATCOMC        1
#  define LZO_INFO_CC           "Watcom C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__WATCOMC__)
#elif defined(__TURBOC__)
#  define LZO_CC_TURBOC         1
#  define LZO_INFO_CC           "Turbo C"
#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TURBOC__)
#elif defined(__ZTC__)
#  define LZO_CC_ZORTECHC       1
#  define LZO_INFO_CC           "Zortech C"
#  if ((__ZTC__-0) == 0x310)
#    define LZO_INFO_CCVER      "0x310"
#  else
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__ZTC__)
#  endif
#elif defined(__GNUC__) && defined(__VERSION__)
#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
#  elif defined(__GNUC_MINOR__)
#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
#  else
#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
#  endif
#  define LZO_INFO_CC           "gcc"
#  define LZO_INFO_CCVER        __VERSION__
#elif defined(_MSC_VER) && ((_MSC_VER-0) > 0)
#  define LZO_CC_MSC            _MSC_VER
#  define LZO_INFO_CC           "Microsoft C"
#  if defined(_MSC_FULL_VER)
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
#  else
#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
#  endif
#else
#  define LZO_CC_UNKNOWN        1
#  define LZO_INFO_CC           "unknown"
#  define LZO_INFO_CCVER        "unknown"
#endif
#if (LZO_CC_GNUC) && defined(__OPEN64__)
#  if defined(__OPENCC__) && defined(__OPENCC_MINOR__) && defined(__OPENCC_PATCHLEVEL__)
#    define LZO_CC_OPEN64       (__OPENCC__ * 0x10000L + (__OPENCC_MINOR__-0) * 0x100 + (__OPENCC_PATCHLEVEL__-0))
#    define LZO_CC_OPEN64_GNUC  LZO_CC_GNUC
#  endif
#endif
#if (LZO_CC_GNUC) && defined(__PCC__)
#  if defined(__PCC__) && defined(__PCC_MINOR__) && defined(__PCC_MINORMINOR__)
#    define LZO_CC_PCC          (__PCC__ * 0x10000L + (__PCC_MINOR__-0) * 0x100 + (__PCC_MINORMINOR__-0))
#    define LZO_CC_PCC_GNUC     LZO_CC_GNUC
#  endif
#endif
#if 0 && (LZO_CC_MSC && (_MSC_VER >= 1200)) && !defined(_MSC_FULL_VER)
#  error "LZO_CC_MSC: _MSC_FULL_VER is not defined"
#endif
#if !defined(__LZO_ARCH_OVERRIDE) && !(LZO_ARCH_GENERIC) && defined(_CRAY)
#  if (UINT_MAX > LZO_0xffffffffL) && defined(_CRAY)
#    if defined(_CRAYMPP) || defined(_CRAYT3D) || defined(_CRAYT3E)
#      define LZO_ARCH_CRAY_MPP     1
#    elif defined(_CRAY1)
#      define LZO_ARCH_CRAY_PVP     1
#    endif
#  endif
#endif
#if !defined(__LZO_ARCH_OVERRIDE)
#if (LZO_ARCH_GENERIC)
#  define LZO_INFO_ARCH             "generic"
#elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
#  define LZO_ARCH_I086             1
#  define LZO_INFO_ARCH             "i086"
#elif defined(__aarch64__) || defined(_M_ARM64)
#  define LZO_ARCH_ARM64            1
#  define LZO_INFO_ARCH             "arm64"
#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
#  define LZO_ARCH_ALPHA            1
#  define LZO_INFO_ARCH             "alpha"
#elif (LZO_ARCH_CRAY_MPP) && (defined(_CRAYT3D) || defined(_CRAYT3E))
#  define LZO_ARCH_ALPHA            1
#  define LZO_INFO_ARCH             "alpha"
#elif defined(__amd64__) || defined(__x86_64__) || defined(_M_AMD64)
#  define LZO_ARCH_AMD64            1
#  define LZO_INFO_ARCH             "amd64"
#elif defined(__arm__) || defined(_M_ARM)
#  define LZO_ARCH_ARM              1
#  define LZO_INFO_ARCH             "arm"
#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCARM__)
#  define LZO_ARCH_ARM              1
#  define LZO_INFO_ARCH             "arm"
#elif (UINT_MAX <= LZO_0xffffL) && defined(__AVR__)
#  define LZO_ARCH_AVR              1
#  define LZO_INFO_ARCH             "avr"
#elif defined(__avr32__) || defined(__AVR32__)
#  define LZO_ARCH_AVR32            1
#  define LZO_INFO_ARCH             "avr32"
#elif defined(__bfin__)
#  define LZO_ARCH_BLACKFIN         1
#  define LZO_INFO_ARCH             "blackfin"
#elif (UINT_MAX == LZO_0xffffL) && defined(__C166__)
#  define LZO_ARCH_C166             1
#  define LZO_INFO_ARCH             "c166"
#elif defined(__cris__)
#  define LZO_ARCH_CRIS             1
#  define LZO_INFO_ARCH             "cris"
#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCEZ80__)
#  define LZO_ARCH_EZ80             1
#  define LZO_INFO_ARCH             "ez80"
#elif defined(__H8300__) || defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
#  define LZO_ARCH_H8300            1
#  define LZO_INFO_ARCH             "h8300"
#elif defined(__hppa__) || defined(__hppa)
#  define LZO_ARCH_HPPA             1
#  define LZO_INFO_ARCH             "hppa"
#elif defined(__386__) || defined(__i386__) || defined(__i386) || defined(_M_IX86) || defined(_M_I386)
#  define LZO_ARCH_I386             1
#  define LZO_ARCH_IA32             1
#  define LZO_INFO_ARCH             "i386"
#elif (LZO_CC_ZORTECHC && defined(__I86__))
#  define LZO_ARCH_I386             1
#  define LZO_ARCH_IA32             1
#  define LZO_INFO_ARCH             "i386"
#elif (LZO_OS_DOS32 && LZO_CC_HIGHC) && defined(_I386)
#  define LZO_ARCH_I386             1
#  define LZO_ARCH_IA32             1
#  define LZO_INFO_ARCH             "i386"
#elif defined(__ia64__) || defined(__ia64) || defined(_M_IA64)
#  define LZO_ARCH_IA64             1
#  define LZO_INFO_ARCH             "ia64"
#elif (UINT_MAX == LZO_0xffffL) && defined(__m32c__)
#  define LZO_ARCH_M16C             1
#  define LZO_INFO_ARCH             "m16c"
#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCM16C__)
#  define LZO_ARCH_M16C             1
#  define LZO_INFO_ARCH             "m16c"
#elif defined(__m32r__)
#  define LZO_ARCH_M32R             1
#  define LZO_INFO_ARCH             "m32r"
#elif (LZO_OS_TOS) || defined(__m68k__) || defined(__m68000__) || defined(__mc68000__) || defined(__mc68020__) || defined(_M_M68K)
#  define LZO_ARCH_M68K             1
#  define LZO_INFO_ARCH             "m68k"
#elif (UINT_MAX == LZO_0xffffL) && defined(__C251__)
#  define LZO_ARCH_MCS251           1
#  define LZO_INFO_ARCH             "mcs251"
#elif (UINT_MAX == LZO_0xffffL) && defined(__C51__)
#  define LZO_ARCH_MCS51            1
#  define LZO_INFO_ARCH             "mcs51"
#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC8051__)
#  define LZO_ARCH_MCS51            1
#  define LZO_INFO_ARCH             "mcs51"
#elif defined(__mips__) || defined(__mips) || defined(_MIPS_ARCH) || defined(_M_MRX000)
#  define LZO_ARCH_MIPS             1
#  define LZO_INFO_ARCH             "mips"
#elif (UINT_MAX == LZO_0xffffL) && defined(__MSP430__)
#  define LZO_ARCH_MSP430           1
#  define LZO_INFO_ARCH             "msp430"
#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC430__)
#  define LZO_ARCH_MSP430           1
#  define LZO_INFO_ARCH             "msp430"
#elif defined(__powerpc__) || defined(__powerpc) || defined(__ppc__) || defined(__PPC__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PWR)
#  define LZO_ARCH_POWERPC          1
#  define LZO_INFO_ARCH             "powerpc"
#elif defined(__powerpc64__) || defined(__powerpc64) || defined(__ppc64__) || defined(__PPC64__)
#  define LZO_ARCH_POWERPC          1
#  define LZO_INFO_ARCH             "powerpc"
#elif defined(__powerpc64le__) || defined(__powerpc64le) || defined(__ppc64le__) || defined(__PPC64LE__)
#  define LZO_ARCH_POWERPC          1
#  define LZO_INFO_ARCH             "powerpc"
#elif defined(__riscv)
#  define LZO_ARCH_RISCV            1
#  define LZO_INFO_ARCH             "riscv"
#elif defined(__s390__) || defined(__s390) || defined(__s390x__) || defined(__s390x)
#  define LZO_ARCH_S390             1
#  define LZO_INFO_ARCH             "s390"
#elif defined(__sh__) || defined(_M_SH)
#  define LZO_ARCH_SH               1
#  define LZO_INFO_ARCH             "sh"
#elif defined(__sparc__) || defined(__sparc) || defined(__sparcv8)
#  define LZO_ARCH_SPARC            1
#  define LZO_INFO_ARCH             "sparc"
#elif defined(__SPU__)
#  define LZO_ARCH_SPU              1
#  define LZO_INFO_ARCH             "spu"
#elif (UINT_MAX == LZO_0xffffL) && defined(__z80)
#  define LZO_ARCH_Z80              1
#  define LZO_INFO_ARCH             "z80"
#elif (LZO_ARCH_CRAY_PVP)
#  if defined(_CRAYSV1)
#    define LZO_ARCH_CRAY_SV1       1
#    define LZO_INFO_ARCH           "cray_sv1"
#  elif (_ADDR64)
#    define LZO_ARCH_CRAY_T90       1
#    define LZO_INFO_ARCH           "cray_t90"
#  elif (_ADDR32)
#    define LZO_ARCH_CRAY_YMP       1
#    define LZO_INFO_ARCH           "cray_ymp"
#  else
#    define LZO_ARCH_CRAY_XMP       1
#    define LZO_INFO_ARCH           "cray_xmp"
#  endif
#else
#  define LZO_ARCH_UNKNOWN          1
#  define LZO_INFO_ARCH             "unknown"
#endif
#endif
#if !defined(LZO_ARCH_ARM_THUMB2)
#if (LZO_ARCH_ARM)
#  if defined(__thumb__) || defined(__thumb) || defined(_M_THUMB)
#    if defined(__thumb2__)
#      define LZO_ARCH_ARM_THUMB2   1
#    elif 1 && defined(__TARGET_ARCH_THUMB) && ((__TARGET_ARCH_THUMB)+0 >= 4)
#      define LZO_ARCH_ARM_THUMB2   1
#    elif 1 && defined(_MSC_VER) && defined(_M_THUMB) && ((_M_THUMB)+0 >= 7)
#      define LZO_ARCH_ARM_THUMB2   1
#    endif
#  endif
#endif
#endif
#if (LZO_ARCH_ARM_THUMB2)
#  undef  LZO_INFO_ARCH
#  define LZO_INFO_ARCH             "arm_thumb2"
#endif
#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_DOS32 || LZO_OS_OS2)
#  error "FIXME - missing define for CPU architecture"
#endif
#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN32)
#  error "FIXME - missing LZO_OS_WIN32 define for CPU architecture"
#endif
#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN64)
#  error "FIXME - missing LZO_OS_WIN64 define for CPU architecture"
#endif
#if (LZO_OS_OS216 || LZO_OS_WIN16)
#  define LZO_ARCH_I086PM           1
#elif 1 && (LZO_OS_DOS16 && defined(BLX286))
#  define LZO_ARCH_I086PM           1
#elif 1 && (LZO_OS_DOS16 && defined(DOSX286))
#  define LZO_ARCH_I086PM           1
#elif 1 && (LZO_OS_DOS16 && LZO_CC_BORLANDC && defined(__DPMI16__))
#  define LZO_ARCH_I086PM           1
#endif
#if (LZO_ARCH_AMD64 && !LZO_ARCH_X64)
#  define LZO_ARCH_X64              1
#elif (!LZO_ARCH_AMD64 && LZO_ARCH_X64) && defined(__LZO_ARCH_OVERRIDE)
#  define LZO_ARCH_AMD64            1
#endif
#if (LZO_ARCH_ARM64 && !LZO_ARCH_AARCH64)
#  define LZO_ARCH_AARCH64          1
#elif (!LZO_ARCH_ARM64 && LZO_ARCH_AARCH64) && defined(__LZO_ARCH_OVERRIDE)
#  define LZO_ARCH_ARM64            1
#endif
#if (LZO_ARCH_I386 && !LZO_ARCH_X86)
#  define LZO_ARCH_X86              1
#elif (!LZO_ARCH_I386 && LZO_ARCH_X86) && defined(__LZO_ARCH_OVERRIDE)
#  define LZO_ARCH_I386            1
#endif
#if (LZO_ARCH_AMD64 && !LZO_ARCH_X64) || (!LZO_ARCH_AMD64 && LZO_ARCH_X64)
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_ARCH_ARM64 && !LZO_ARCH_AARCH64) || (!LZO_ARCH_ARM64 && LZO_ARCH_AARCH64)
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_ARCH_I386 && !LZO_ARCH_X86) || (!LZO_ARCH_I386 && LZO_ARCH_X86)
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_ARCH_ARM_THUMB1 && !LZO_ARCH_ARM)
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_ARCH_ARM_THUMB2 && !LZO_ARCH_ARM)
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_ARCH_ARM_THUMB1 && LZO_ARCH_ARM_THUMB2)
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_ARCH_I086PM && !LZO_ARCH_I086)
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_ARCH_I086)
#  if (UINT_MAX != LZO_0xffffL)
#    error "unexpected configuration - check your compiler defines"
#  endif
#  if (ULONG_MAX != LZO_0xffffffffL)
#    error "unexpected configuration - check your compiler defines"
#  endif
#endif
#if (LZO_ARCH_I386)
#  if (UINT_MAX != LZO_0xffffL) && defined(__i386_int16__)
#    error "unexpected configuration - check your compiler defines"
#  endif
#  if (UINT_MAX != LZO_0xffffffffL) && !defined(__i386_int16__)
#    error "unexpected configuration - check your compiler defines"
#  endif
#  if (ULONG_MAX != LZO_0xffffffffL)
#    error "unexpected configuration - check your compiler defines"
#  endif
#endif
#if (LZO_ARCH_AMD64 || LZO_ARCH_I386)
#  if !defined(LZO_TARGET_FEATURE_SSE2)
#    if defined(__SSE2__)
#      define LZO_TARGET_FEATURE_SSE2       1
#    elif defined(_MSC_VER) && (defined(_M_IX86_FP) && ((_M_IX86_FP)+0 >= 2))
#      define LZO_TARGET_FEATURE_SSE2       1
#    elif (LZO_CC_INTELC_MSC || LZO_CC_MSC) && defined(_M_AMD64)
#      define LZO_TARGET_FEATURE_SSE2       1
#    endif
#  endif
#  if !defined(LZO_TARGET_FEATURE_SSSE3)
#  if (LZO_TARGET_FEATURE_SSE2)
#    if defined(__SSSE3__)
#      define LZO_TARGET_FEATURE_SSSE3      1
#    elif defined(_MSC_VER) && defined(__AVX__)
#      define LZO_TARGET_FEATURE_SSSE3      1
#    endif
#  endif
#  endif
#  if !defined(LZO_TARGET_FEATURE_SSE4_2)
#  if (LZO_TARGET_FEATURE_SSSE3)
#    if defined(__SSE4_2__)
#      define LZO_TARGET_FEATURE_SSE4_2     1
#    endif
#  endif
#  endif
#  if !defined(LZO_TARGET_FEATURE_AVX)
#  if (LZO_TARGET_FEATURE_SSSE3)
#    if defined(__AVX__)
#      define LZO_TARGET_FEATURE_AVX        1
#    endif
#  endif
#  endif
#  if !defined(LZO_TARGET_FEATURE_AVX2)
#  if (LZO_TARGET_FEATURE_AVX)
#    if defined(__AVX2__)
#      define LZO_TARGET_FEATURE_AVX2       1
#    endif
#  endif
#  endif
#endif
#if (LZO_TARGET_FEATURE_SSSE3 && !(LZO_TARGET_FEATURE_SSE2))
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_TARGET_FEATURE_SSE4_2 && !(LZO_TARGET_FEATURE_SSSE3))
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_TARGET_FEATURE_AVX && !(LZO_TARGET_FEATURE_SSSE3))
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_TARGET_FEATURE_AVX2 && !(LZO_TARGET_FEATURE_AVX))
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_ARCH_ARM)
#  if !defined(LZO_TARGET_FEATURE_NEON)
#    if defined(__ARM_NEON) && ((__ARM_NEON)+0)
#      define LZO_TARGET_FEATURE_NEON       1
#    elif 1 && defined(__ARM_NEON__) && ((__ARM_NEON__)+0)
#      define LZO_TARGET_FEATURE_NEON       1
#    elif 1 && defined(__TARGET_FEATURE_NEON) && ((__TARGET_FEATURE_NEON)+0)
#      define LZO_TARGET_FEATURE_NEON       1
#    endif
#  endif
#elif (LZO_ARCH_ARM64)
#  if !defined(LZO_TARGET_FEATURE_NEON)
#    if 1
#      define LZO_TARGET_FEATURE_NEON       1
#    endif
#  endif
#endif
#if 0
#elif !defined(__LZO_MM_OVERRIDE)
#if (LZO_ARCH_I086)
#if (UINT_MAX != LZO_0xffffL)
#  error "unexpected configuration - check your compiler defines"
#endif
#if defined(__TINY__) || defined(M_I86TM) || defined(_M_I86TM)
#  define LZO_MM_TINY           1
#elif defined(__HUGE__) || defined(_HUGE_) || defined(M_I86HM) || defined(_M_I86HM)
#  define LZO_MM_HUGE           1
#elif defined(__SMALL__) || defined(M_I86SM) || defined(_M_I86SM) || defined(SMALL_MODEL)
#  define LZO_MM_SMALL          1
#elif defined(__MEDIUM__) || defined(M_I86MM) || defined(_M_I86MM)
#  define LZO_MM_MEDIUM         1
#elif defined(__COMPACT__) || defined(M_I86CM) || defined(_M_I86CM)
#  define LZO_MM_COMPACT        1
#elif defined(__LARGE__) || defined(M_I86LM) || defined(_M_I86LM) || defined(LARGE_MODEL)
#  define LZO_MM_LARGE          1
#elif (LZO_CC_AZTECC)
#  if defined(_LARGE_CODE) && defined(_LARGE_DATA)
#    define LZO_MM_LARGE        1
#  elif defined(_LARGE_CODE)
#    define LZO_MM_MEDIUM       1
#  elif defined(_LARGE_DATA)
#    define LZO_MM_COMPACT      1
#  else
#    define LZO_MM_SMALL        1
#  endif
#elif (LZO_CC_ZORTECHC && defined(__VCM__))
#  define LZO_MM_LARGE          1
#else
#  error "unknown LZO_ARCH_I086 memory model"
#endif
#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
#define LZO_HAVE_MM_HUGE_PTR        1
#define LZO_HAVE_MM_HUGE_ARRAY      1
#if (LZO_MM_TINY)
#  undef LZO_HAVE_MM_HUGE_ARRAY
#endif
#if (LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_ZORTECHC)
#  undef LZO_HAVE_MM_HUGE_PTR
#  undef LZO_HAVE_MM_HUGE_ARRAY
#elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
#  undef LZO_HAVE_MM_HUGE_ARRAY
#elif (LZO_CC_MSC && defined(_QC))
#  undef LZO_HAVE_MM_HUGE_ARRAY
#  if (_MSC_VER < 600)
#    undef LZO_HAVE_MM_HUGE_PTR
#  endif
#elif (LZO_CC_TURBOC && (__TURBOC__ < 0x0295))
#  undef LZO_HAVE_MM_HUGE_ARRAY
#endif
#if (LZO_ARCH_I086PM) && !(LZO_HAVE_MM_HUGE_PTR)
#  if (LZO_OS_DOS16)
#    error "unexpected configuration - check your compiler defines"
#  elif (LZO_CC_ZORTECHC)
#  else
#    error "unexpected configuration - check your compiler defines"
#  endif
#endif
#if defined(__cplusplus)
extern "C" {
#endif
#if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0200))
   extern void __near __cdecl _AHSHIFT(void);
#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
#elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
   extern void __near __cdecl _AHSHIFT(void);
#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
#elif (LZO_CC_MSC || LZO_CC_TOPSPEEDC)
   extern void __near __cdecl _AHSHIFT(void);
#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
#elif (LZO_CC_TURBOC && (__TURBOC__ >= 0x0295))
   extern void __near __cdecl _AHSHIFT(void);
#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
#elif ((LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_TURBOC) && LZO_OS_DOS16)
#  define LZO_MM_AHSHIFT      12
#elif (LZO_CC_WATCOMC)
   extern unsigned char _HShift;
#  define LZO_MM_AHSHIFT      ((unsigned) _HShift)
#else
#  error "FIXME - implement LZO_MM_AHSHIFT"
#endif
#if defined(__cplusplus)
}
#endif
#endif
#elif (LZO_ARCH_C166)
#if !defined(__MODEL__)
#  error "FIXME - LZO_ARCH_C166 __MODEL__"
#elif ((__MODEL__) == 0)
#  define LZO_MM_SMALL          1
#elif ((__MODEL__) == 1)
#  define LZO_MM_SMALL          1
#elif ((__MODEL__) == 2)
#  define LZO_MM_LARGE          1
#elif ((__MODEL__) == 3)
#  define LZO_MM_TINY           1
#elif ((__MODEL__) == 4)
#  define LZO_MM_XTINY          1
#elif ((__MODEL__) == 5)
#  define LZO_MM_XSMALL         1
#else
#  error "FIXME - LZO_ARCH_C166 __MODEL__"
#endif
#elif (LZO_ARCH_MCS251)
#if !defined(__MODEL__)
#  error "FIXME - LZO_ARCH_MCS251 __MODEL__"
#elif ((__MODEL__) == 0)
#  define LZO_MM_SMALL          1
#elif ((__MODEL__) == 2)
#  define LZO_MM_LARGE          1
#elif ((__MODEL__) == 3)
#  define LZO_MM_TINY           1
#elif ((__MODEL__) == 4)
#  define LZO_MM_XTINY          1
#elif ((__MODEL__) == 5)
#  define LZO_MM_XSMALL         1
#else
#  error "FIXME - LZO_ARCH_MCS251 __MODEL__"
#endif
#elif (LZO_ARCH_MCS51)
#if !defined(__MODEL__)
#  error "FIXME - LZO_ARCH_MCS51 __MODEL__"
#elif ((__MODEL__) == 1)
#  define LZO_MM_SMALL          1
#elif ((__MODEL__) == 2)
#  define LZO_MM_LARGE          1
#elif ((__MODEL__) == 3)
#  define LZO_MM_TINY           1
#elif ((__MODEL__) == 4)
#  define LZO_MM_XTINY          1
#elif ((__MODEL__) == 5)
#  define LZO_MM_XSMALL         1
#else
#  error "FIXME - LZO_ARCH_MCS51 __MODEL__"
#endif
#elif (LZO_ARCH_CRAY_PVP)
#  define LZO_MM_PVP            1
#else
#  define LZO_MM_FLAT           1
#endif
#if (LZO_MM_COMPACT)
#  define LZO_INFO_MM           "compact"
#elif (LZO_MM_FLAT)
#  define LZO_INFO_MM           "flat"
#elif (LZO_MM_HUGE)
#  define LZO_INFO_MM           "huge"
#elif (LZO_MM_LARGE)
#  define LZO_INFO_MM           "large"
#elif (LZO_MM_MEDIUM)
#  define LZO_INFO_MM           "medium"
#elif (LZO_MM_PVP)
#  define LZO_INFO_MM           "pvp"
#elif (LZO_MM_SMALL)
#  define LZO_INFO_MM           "small"
#elif (LZO_MM_TINY)
#  define LZO_INFO_MM           "tiny"
#else
#  error "unknown memory model"
#endif
#endif
#if !defined(__lzo_gnuc_extension__)
#if (LZO_CC_GNUC >= 0x020800ul)
#  define __lzo_gnuc_extension__    __extension__
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define __lzo_gnuc_extension__    __extension__
#elif (LZO_CC_IBMC >= 600)
#  define __lzo_gnuc_extension__    __extension__
#endif
#endif
#if !defined(__lzo_gnuc_extension__)
#  define __lzo_gnuc_extension__    /*empty*/
#endif
#if !defined(lzo_has_builtin)
#if (LZO_CC_CLANG) && defined(__has_builtin)
#  define lzo_has_builtin           __has_builtin
#endif
#endif
#if !defined(lzo_has_builtin)
#  define lzo_has_builtin(x)        0
#endif
#if !defined(lzo_has_attribute)
#if (LZO_CC_CLANG) && defined(__has_attribute)
#  define lzo_has_attribute         __has_attribute
#endif
#endif
#if !defined(lzo_has_attribute)
#  define lzo_has_attribute(x)      0
#endif
#if !defined(lzo_has_declspec_attribute)
#if (LZO_CC_CLANG) && defined(__has_declspec_attribute)
#  define lzo_has_declspec_attribute        __has_declspec_attribute
#endif
#endif
#if !defined(lzo_has_declspec_attribute)
#  define lzo_has_declspec_attribute(x)     0
#endif
#if !defined(lzo_has_feature)
#if (LZO_CC_CLANG) && defined(__has_feature)
#  define lzo_has_feature         __has_feature
#endif
#endif
#if !defined(lzo_has_feature)
#  define lzo_has_feature(x)        0
#endif
#if !defined(lzo_has_extension)
#if (LZO_CC_CLANG) && defined(__has_extension)
#  define lzo_has_extension         __has_extension
#elif (LZO_CC_CLANG) && defined(__has_feature)
#  define lzo_has_extension         __has_feature
#endif
#endif
#if !defined(lzo_has_extension)
#  define lzo_has_extension(x)      0
#endif
#if !defined(LZO_CFG_USE_NEW_STYLE_CASTS) && defined(__cplusplus) && 0
#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul))
#    define LZO_CFG_USE_NEW_STYLE_CASTS 0
#  elif (LZO_CC_INTELC && (__INTEL_COMPILER < 1200))
#    define LZO_CFG_USE_NEW_STYLE_CASTS 0
#  else
#    define LZO_CFG_USE_NEW_STYLE_CASTS 1
#  endif
#endif
#if !defined(LZO_CFG_USE_NEW_STYLE_CASTS)
#  define LZO_CFG_USE_NEW_STYLE_CASTS 0
#endif
#if !defined(__cplusplus)
#  if defined(LZO_CFG_USE_NEW_STYLE_CASTS)
#    undef LZO_CFG_USE_NEW_STYLE_CASTS
#  endif
#  define LZO_CFG_USE_NEW_STYLE_CASTS 0
#endif
#if !defined(LZO_REINTERPRET_CAST)
#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
#    define LZO_REINTERPRET_CAST(t,e)       (reinterpret_cast<t> (e))
#  endif
#endif
#if !defined(LZO_REINTERPRET_CAST)
#  define LZO_REINTERPRET_CAST(t,e)         ((t) (e))
#endif
#if !defined(LZO_STATIC_CAST)
#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
#    define LZO_STATIC_CAST(t,e)            (static_cast<t> (e))
#  endif
#endif
#if !defined(LZO_STATIC_CAST)
#  define LZO_STATIC_CAST(t,e)              ((t) (e))
#endif
#if !defined(LZO_STATIC_CAST2)
#  define LZO_STATIC_CAST2(t1,t2,e)         LZO_STATIC_CAST(t1, LZO_STATIC_CAST(t2, e))
#endif
#if !defined(LZO_UNCONST_CAST)
#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
#    define LZO_UNCONST_CAST(t,e)           (const_cast<t> (e))
#  elif (LZO_HAVE_MM_HUGE_PTR)
#    define LZO_UNCONST_CAST(t,e)           ((t) (e))
#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#    define LZO_UNCONST_CAST(t,e)           ((t) ((void *) ((lzo_uintptr_t) ((const void *) (e)))))
#  endif
#endif
#if !defined(LZO_UNCONST_CAST)
#  define LZO_UNCONST_CAST(t,e)             ((t) ((void *) ((const void *) (e))))
#endif
#if !defined(LZO_UNCONST_VOLATILE_CAST)
#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
#    define LZO_UNCONST_VOLATILE_CAST(t,e)  (const_cast<t> (e))
#  elif (LZO_HAVE_MM_HUGE_PTR)
#    define LZO_UNCONST_VOLATILE_CAST(t,e)  ((t) (e))
#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#    define LZO_UNCONST_VOLATILE_CAST(t,e)  ((t) ((volatile void *) ((lzo_uintptr_t) ((volatile const void *) (e)))))
#  endif
#endif
#if !defined(LZO_UNCONST_VOLATILE_CAST)
#  define LZO_UNCONST_VOLATILE_CAST(t,e)    ((t) ((volatile void *) ((volatile const void *) (e))))
#endif
#if !defined(LZO_UNVOLATILE_CAST)
#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
#    define LZO_UNVOLATILE_CAST(t,e)        (const_cast<t> (e))
#  elif (LZO_HAVE_MM_HUGE_PTR)
#    define LZO_UNVOLATILE_CAST(t,e)        ((t) (e))
#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#    define LZO_UNVOLATILE_CAST(t,e)        ((t) ((void *) ((lzo_uintptr_t) ((volatile void *) (e)))))
#  endif
#endif
#if !defined(LZO_UNVOLATILE_CAST)
#  define LZO_UNVOLATILE_CAST(t,e)          ((t) ((void *) ((volatile void *) (e))))
#endif
#if !defined(LZO_UNVOLATILE_CONST_CAST)
#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
#    define LZO_UNVOLATILE_CONST_CAST(t,e)  (const_cast<t> (e))
#  elif (LZO_HAVE_MM_HUGE_PTR)
#    define LZO_UNVOLATILE_CONST_CAST(t,e)  ((t) (e))
#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#    define LZO_UNVOLATILE_CONST_CAST(t,e)  ((t) ((const void *) ((lzo_uintptr_t) ((volatile const void *) (e)))))
#  endif
#endif
#if !defined(LZO_UNVOLATILE_CONST_CAST)
#  define LZO_UNVOLATILE_CONST_CAST(t,e)    ((t) ((const void *) ((volatile const void *) (e))))
#endif
#if !defined(LZO_PCAST)
#  if (LZO_HAVE_MM_HUGE_PTR)
#    define LZO_PCAST(t,e)                  ((t) (e))
#  endif
#endif
#if !defined(LZO_PCAST)
#  define LZO_PCAST(t,e)                    LZO_STATIC_CAST(t, LZO_STATIC_CAST(void *, e))
#endif
#if !defined(LZO_CCAST)
#  if (LZO_HAVE_MM_HUGE_PTR)
#    define LZO_CCAST(t,e)                  ((t) (e))
#  endif
#endif
#if !defined(LZO_CCAST)
#  define LZO_CCAST(t,e)                    LZO_STATIC_CAST(t, LZO_STATIC_CAST(const void *, e))
#endif
#if !defined(LZO_ICONV)
#  define LZO_ICONV(t,e)                    LZO_STATIC_CAST(t, e)
#endif
#if !defined(LZO_ICAST)
#  define LZO_ICAST(t,e)                    LZO_STATIC_CAST(t, e)
#endif
#if !defined(LZO_ITRUNC)
#  define LZO_ITRUNC(t,e)                   LZO_STATIC_CAST(t, e)
#endif
#if !defined(__lzo_cte)
#  if (LZO_CC_MSC || LZO_CC_WATCOMC)
#    define __lzo_cte(e)            ((void)0,(e))
#  elif 1
#    define __lzo_cte(e)            ((void)0,(e))
#  endif
#endif
#if !defined(__lzo_cte)
#  define __lzo_cte(e)              (e)
#endif
#if !defined(LZO_BLOCK_BEGIN)
#  define LZO_BLOCK_BEGIN           do {
#  define LZO_BLOCK_END             } while __lzo_cte(0)
#endif
#if !defined(LZO_UNUSED)
#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
#    define LZO_UNUSED(var)         ((void) &var)
#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
#    define LZO_UNUSED(var)         if (&var) ; else
#  elif (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x030200ul))
#    define LZO_UNUSED(var)         ((void) &var)
#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#    define LZO_UNUSED(var)         ((void) var)
#  elif (LZO_CC_MSC && (_MSC_VER < 900))
#    define LZO_UNUSED(var)         if (&var) ; else
#  elif (LZO_CC_KEILC)
#    define LZO_UNUSED(var)         {extern int lzo_unused__[1-2*!(sizeof(var)>0)]; (void)lzo_unused__;}
#  elif (LZO_CC_PACIFICC)
#    define LZO_UNUSED(var)         ((void) sizeof(var))
#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
#    define LZO_UNUSED(var)         ((void) var)
#  else
#    define LZO_UNUSED(var)         ((void) &var)
#  endif
#endif
#if !defined(LZO_UNUSED_RESULT)
#  define LZO_UNUSED_RESULT(var)    LZO_UNUSED(var)
#endif
#if !defined(LZO_UNUSED_FUNC)
#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
#    define LZO_UNUSED_FUNC(func)   ((void) func)
#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
#    define LZO_UNUSED_FUNC(func)   if (func) ; else
#  elif (LZO_CC_CLANG || LZO_CC_LLVM)
#    define LZO_UNUSED_FUNC(func)   ((void) &func)
#  elif (LZO_CC_MSC && (_MSC_VER < 900))
#    define LZO_UNUSED_FUNC(func)   if (func) ; else
#  elif (LZO_CC_MSC)
#    define LZO_UNUSED_FUNC(func)   ((void) &func)
#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
#    define LZO_UNUSED_FUNC(func)   {extern int lzo_unused__[1-2*!(sizeof((int)func)>0)]; (void)lzo_unused__;}
#  else
#    define LZO_UNUSED_FUNC(func)   ((void) func)
#  endif
#endif
#if !defined(LZO_UNUSED_LABEL)
#  if (LZO_CC_CLANG >= 0x020800ul)
#    define LZO_UNUSED_LABEL(l)     (__lzo_gnuc_extension__ ((void) ((const void *) &&l)))
#  elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_INTELC || LZO_CC_WATCOMC)
#    define LZO_UNUSED_LABEL(l)     if __lzo_cte(0) goto l
#  else
#    define LZO_UNUSED_LABEL(l)     switch (0) case 1:goto l
#  endif
#endif
#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
#  if 0
#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
#  elif 0 && (LZO_CC_GNUC)
#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
#  else
#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
#  endif
#endif
#if !defined(__lzo_inline)
#if (LZO_CC_TURBOC && (__TURBOC__ <= 0x0295))
#elif defined(__cplusplus)
#  define __lzo_inline          inline
#elif defined(__STDC_VERSION__) && (__STDC_VERSION__-0 >= 199901L)
#  define __lzo_inline          inline
#elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550))
#  define __lzo_inline          __inline
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
#  define __lzo_inline          __inline__
#elif (LZO_CC_DMC)
#  define __lzo_inline          __inline
#elif (LZO_CC_GHS)
#  define __lzo_inline          __inline__
#elif (LZO_CC_IBMC >= 600)
#  define __lzo_inline          __inline__
#elif (LZO_CC_INTELC)
#  define __lzo_inline          __inline
#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x2405))
#  define __lzo_inline          __inline
#elif (LZO_CC_MSC && (_MSC_VER >= 900))
#  define __lzo_inline          __inline
#elif (LZO_CC_SUNPROC >= 0x5100)
#  define __lzo_inline          __inline__
#endif
#endif
#if defined(__lzo_inline)
#  ifndef __lzo_HAVE_inline
#  define __lzo_HAVE_inline 1
#  endif
#else
#  define __lzo_inline          /*empty*/
#endif
#if !defined(__lzo_forceinline)
#if (LZO_CC_GNUC >= 0x030200ul)
#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
#elif (LZO_CC_IBMC >= 700)
#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450))
#  define __lzo_forceinline     __forceinline
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
#  define __lzo_forceinline     __forceinline
#elif (LZO_CC_PGI >= 0x0d0a00ul)
#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
#elif (LZO_CC_SUNPROC >= 0x5100)
#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
#endif
#endif
#if defined(__lzo_forceinline)
#  ifndef __lzo_HAVE_forceinline
#  define __lzo_HAVE_forceinline 1
#  endif
#else
#  define __lzo_forceinline     __lzo_inline
#endif
#if !defined(__lzo_noinline)
#if 1 && (LZO_ARCH_I386) && (LZO_CC_GNUC >= 0x040000ul) && (LZO_CC_GNUC < 0x040003ul)
#  define __lzo_noinline        __attribute__((__noinline__,__used__))
#elif (LZO_CC_GNUC >= 0x030200ul)
#  define __lzo_noinline        __attribute__((__noinline__))
#elif (LZO_CC_IBMC >= 700)
#  define __lzo_noinline        __attribute__((__noinline__))
#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 600))
#  define __lzo_noinline        __declspec(noinline)
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
#  define __lzo_noinline        __attribute__((__noinline__))
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define __lzo_noinline        __attribute__((__noinline__))
#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
#  define __lzo_noinline        __declspec(noinline)
#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x3200) && (LZO_OS_WIN32 || LZO_OS_WIN64))
#  if defined(__cplusplus)
#  else
#    define __lzo_noinline      __declspec(noinline)
#  endif
#elif (LZO_CC_PGI >= 0x0d0a00ul)
#  define __lzo_noinline        __attribute__((__noinline__))
#elif (LZO_CC_SUNPROC >= 0x5100)
#  define __lzo_noinline        __attribute__((__noinline__))
#endif
#endif
#if defined(__lzo_noinline)
#  ifndef __lzo_HAVE_noinline
#  define __lzo_HAVE_noinline 1
#  endif
#else
#  define __lzo_noinline        /*empty*/
#endif
#if (__lzo_HAVE_forceinline || __lzo_HAVE_noinline) && !(__lzo_HAVE_inline)
#  error "unexpected configuration - check your compiler defines"
#endif
#if !defined(__lzo_static_inline)
#if (LZO_CC_IBMC)
#  define __lzo_static_inline       __lzo_gnuc_extension__ static __lzo_inline
#endif
#endif
#if !defined(__lzo_static_inline)
#  define __lzo_static_inline       static __lzo_inline
#endif
#if !defined(__lzo_static_forceinline)
#if (LZO_CC_IBMC)
#  define __lzo_static_forceinline  __lzo_gnuc_extension__ static __lzo_forceinline
#endif
#endif
#if !defined(__lzo_static_forceinline)
#  define __lzo_static_forceinline  static __lzo_forceinline
#endif
#if !defined(__lzo_static_noinline)
#if (LZO_CC_IBMC)
#  define __lzo_static_noinline     __lzo_gnuc_extension__ static __lzo_noinline
#endif
#endif
#if !defined(__lzo_static_noinline)
#  define __lzo_static_noinline     static __lzo_noinline
#endif
#if !defined(__lzo_c99_extern_inline)
#if defined(__GNUC_GNU_INLINE__)
#  define __lzo_c99_extern_inline   __lzo_inline
#elif defined(__GNUC_STDC_INLINE__)
#  define __lzo_c99_extern_inline   extern __lzo_inline
#elif defined(__STDC_VERSION__) && (__STDC_VERSION__-0 >= 199901L)
#  define __lzo_c99_extern_inline   extern __lzo_inline
#endif
#if !defined(__lzo_c99_extern_inline) && (__lzo_HAVE_inline)
#  define __lzo_c99_extern_inline   __lzo_inline
#endif
#endif
#if defined(__lzo_c99_extern_inline)
#  ifndef __lzo_HAVE_c99_extern_inline
#  define __lzo_HAVE_c99_extern_inline 1
#  endif
#else
#  define __lzo_c99_extern_inline   /*empty*/
#endif
#if !defined(__lzo_may_alias)
#if (LZO_CC_GNUC >= 0x030400ul)
#  define __lzo_may_alias       __attribute__((__may_alias__))
#elif (LZO_CC_CLANG >= 0x020900ul)
#  define __lzo_may_alias       __attribute__((__may_alias__))
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1210)) && 0
#  define __lzo_may_alias       __attribute__((__may_alias__))
#elif (LZO_CC_PGI >= 0x0d0a00ul) && 0
#  define __lzo_may_alias       __attribute__((__may_alias__))
#endif
#endif
#if defined(__lzo_may_alias)
#  ifndef __lzo_HAVE_may_alias
#  define __lzo_HAVE_may_alias 1
#  endif
#else
#  define __lzo_may_alias       /*empty*/
#endif
#if !defined(__lzo_noreturn)
#if (LZO_CC_GNUC >= 0x020700ul)
#  define __lzo_noreturn        __attribute__((__noreturn__))
#elif (LZO_CC_IBMC >= 700)
#  define __lzo_noreturn        __attribute__((__noreturn__))
#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450))
#  define __lzo_noreturn        __declspec(noreturn)
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 600))
#  define __lzo_noreturn        __attribute__((__noreturn__))
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define __lzo_noreturn        __attribute__((__noreturn__))
#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
#  define __lzo_noreturn        __declspec(noreturn)
#elif (LZO_CC_PGI >= 0x0d0a00ul)
#  define __lzo_noreturn        __attribute__((__noreturn__))
#endif
#endif
#if defined(__lzo_noreturn)
#  ifndef __lzo_HAVE_noreturn
#  define __lzo_HAVE_noreturn 1
#  endif
#else
#  define __lzo_noreturn        /*empty*/
#endif
#if !defined(__lzo_nothrow)
#if (LZO_CC_GNUC >= 0x030300ul)
#  define __lzo_nothrow         __attribute__((__nothrow__))
#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450)) && defined(__cplusplus)
#  define __lzo_nothrow         __declspec(nothrow)
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 900))
#  define __lzo_nothrow         __attribute__((__nothrow__))
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define __lzo_nothrow         __attribute__((__nothrow__))
#elif (LZO_CC_MSC && (_MSC_VER >= 1200)) && defined(__cplusplus)
#  define __lzo_nothrow         __declspec(nothrow)
#endif
#endif
#if defined(__lzo_nothrow)
#  ifndef __lzo_HAVE_nothrow
#  define __lzo_HAVE_nothrow 1
#  endif
#else
#  define __lzo_nothrow         /*empty*/
#endif
#if !defined(__lzo_restrict)
#if (LZO_CC_GNUC >= 0x030400ul)
#  define __lzo_restrict        __restrict__
#elif (LZO_CC_IBMC >= 800) && !defined(__cplusplus)
#  define __lzo_restrict        __restrict__
#elif (LZO_CC_IBMC >= 1210)
#  define __lzo_restrict        __restrict__
#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 600))
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 600))
#  define __lzo_restrict        __restrict__
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM)
#  define __lzo_restrict        __restrict__
#elif (LZO_CC_MSC && (_MSC_VER >= 1400))
#  define __lzo_restrict        __restrict
#elif (LZO_CC_PGI >= 0x0d0a00ul)
#  define __lzo_restrict        __restrict__
#endif
#endif
#if defined(__lzo_restrict)
#  ifndef __lzo_HAVE_restrict
#  define __lzo_HAVE_restrict 1
#  endif
#else
#  define __lzo_restrict        /*empty*/
#endif
#if !defined(__lzo_alignof)
#if (LZO_CC_ARMCC || LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
#  define __lzo_alignof(e)      __alignof__(e)
#elif (LZO_CC_GHS) && !defined(__cplusplus)
#  define __lzo_alignof(e)      __alignof__(e)
#elif (LZO_CC_IBMC >= 600)
#  define __lzo_alignof(e)      (__lzo_gnuc_extension__ __alignof__(e))
#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
#  define __lzo_alignof(e)      __alignof__(e)
#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
#  define __lzo_alignof(e)      __alignof(e)
#elif (LZO_CC_SUNPROC >= 0x5100)
#  define __lzo_alignof(e)      __alignof__(e)
#endif
#endif
#if defined(__lzo_alignof)
#  ifndef __lzo_HAVE_alignof
#  define __lzo_HAVE_alignof 1
#  endif
#endif
#if !defined(__lzo_struct_packed)
#if   (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020700ul))
#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul)) && defined(__cplusplus)
#elif (LZO_CC_PCC && (LZO_CC_PCC < 0x010100ul))
#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC < 0x5110)) && !defined(__cplusplus)
#elif (LZO_CC_GNUC >= 0x030400ul) && !(LZO_CC_PCC_GNUC) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
#  define __lzo_struct_packed(s)        struct s {
#  define __lzo_struct_packed_end()     } __attribute__((__gcc_struct__,__packed__));
#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__gcc_struct__,__packed__));
#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || (LZO_CC_PGI >= 0x0d0a00ul) || (LZO_CC_SUNPROC >= 0x5100))
#  define __lzo_struct_packed(s)        struct s {
#  define __lzo_struct_packed_end()     } __attribute__((__packed__));
#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__packed__));
#elif (LZO_CC_IBMC >= 700)
#  define __lzo_struct_packed(s)        __lzo_gnuc_extension__ struct s {
#  define __lzo_struct_packed_end()     } __attribute__((__packed__));
#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__packed__));
#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
#  define __lzo_struct_packed(s)        __pragma(pack(push,1)) struct s {
#  define __lzo_struct_packed_end()     } __pragma(pack(pop));
#elif (LZO_CC_WATCOMC && (__WATCOMC__ >= 900))
#  define __lzo_struct_packed(s)        _Packed struct s {
#  define __lzo_struct_packed_end()     };
#endif
#endif
#if defined(__lzo_struct_packed) && !defined(__lzo_struct_packed_ma)
#  define __lzo_struct_packed_ma(s)     __lzo_struct_packed(s)
#endif
#if defined(__lzo_struct_packed_end) && !defined(__lzo_struct_packed_ma_end)
#  define __lzo_struct_packed_ma_end()  __lzo_struct_packed_end()
#endif
#if !defined(__lzo_byte_struct)
#if defined(__lzo_struct_packed)
#  define __lzo_byte_struct(s,n)        __lzo_struct_packed(s) unsigned char a[n]; __lzo_struct_packed_end()
#  define __lzo_byte_struct_ma(s,n)     __lzo_struct_packed_ma(s) unsigned char a[n]; __lzo_struct_packed_ma_end()
#elif (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_PGI || (LZO_CC_SUNPROC >= 0x5100))
#  define __lzo_byte_struct(s,n)        struct s { unsigned char a[n]; } __attribute__((__packed__));
#  define __lzo_byte_struct_ma(s,n)     struct s { unsigned char a[n]; } __lzo_may_alias __attribute__((__packed__));
#endif
#endif
#if defined(__lzo_byte_struct) &&  !defined(__lzo_byte_struct_ma)
#  define __lzo_byte_struct_ma(s,n)     __lzo_byte_struct(s,n)
#endif
#if !defined(__lzo_struct_align16) && (__lzo_HAVE_alignof)
#if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x030000ul))
#elif (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
#elif (LZO_CC_CILLY || LZO_CC_PCC)
#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
#  define __lzo_struct_align16(s)       struct __declspec(align(16)) s {
#  define __lzo_struct_align16_end()    };
#  define __lzo_struct_align32(s)       struct __declspec(align(32)) s {
#  define __lzo_struct_align32_end()    };
#  define __lzo_struct_align64(s)       struct __declspec(align(64)) s {
#  define __lzo_struct_align64_end()    };
#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || (LZO_CC_IBMC >= 700) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define __lzo_struct_align16(s)       struct s {
#  define __lzo_struct_align16_end()    } __attribute__((__aligned__(16)));
#  define __lzo_struct_align32(s)       struct s {
#  define __lzo_struct_align32_end()    } __attribute__((__aligned__(32)));
#  define __lzo_struct_align64(s)       struct s {
#  define __lzo_struct_align64_end()    } __attribute__((__aligned__(64)));
#endif
#endif
#if !defined(__lzo_union_um)
#if   (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020700ul))
#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul)) && defined(__cplusplus)
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER < 810))
#elif (LZO_CC_PCC && (LZO_CC_PCC < 0x010100ul))
#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC < 0x5110)) && !defined(__cplusplus)
#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || (LZO_CC_PGI >= 0x0d0a00ul) || (LZO_CC_SUNPROC >= 0x5100))
#  define __lzo_union_am(s)             union s {
#  define __lzo_union_am_end()          } __lzo_may_alias;
#  define __lzo_union_um(s)             union s {
#  define __lzo_union_um_end()          } __lzo_may_alias __attribute__((__packed__));
#elif (LZO_CC_IBMC >= 700)
#  define __lzo_union_am(s)             __lzo_gnuc_extension__ union s {
#  define __lzo_union_am_end()          } __lzo_may_alias;
#  define __lzo_union_um(s)             __lzo_gnuc_extension__ union s {
#  define __lzo_union_um_end()          } __lzo_may_alias __attribute__((__packed__));
#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
#  define __lzo_union_um(s)             __pragma(pack(push,1)) union s {
#  define __lzo_union_um_end()          } __pragma(pack(pop));
#elif (LZO_CC_WATCOMC && (__WATCOMC__ >= 900))
#  define __lzo_union_um(s)             _Packed union s {
#  define __lzo_union_um_end()          };
#endif
#endif
#if !defined(__lzo_union_am)
#  define __lzo_union_am(s)             union s {
#  define __lzo_union_am_end()          };
#endif
#if !defined(__lzo_constructor)
#if (LZO_CC_GNUC >= 0x030400ul)
#  define __lzo_constructor     __attribute__((__constructor__,__used__))
#elif (LZO_CC_GNUC >= 0x020700ul)
#  define __lzo_constructor     __attribute__((__constructor__))
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
#  define __lzo_constructor     __attribute__((__constructor__,__used__))
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define __lzo_constructor     __attribute__((__constructor__))
#endif
#endif
#if defined(__lzo_constructor)
#  ifndef __lzo_HAVE_constructor
#  define __lzo_HAVE_constructor 1
#  endif
#endif
#if !defined(__lzo_destructor)
#if (LZO_CC_GNUC >= 0x030400ul)
#  define __lzo_destructor      __attribute__((__destructor__,__used__))
#elif (LZO_CC_GNUC >= 0x020700ul)
#  define __lzo_destructor      __attribute__((__destructor__))
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
#  define __lzo_destructor      __attribute__((__destructor__,__used__))
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define __lzo_destructor      __attribute__((__destructor__))
#endif
#endif
#if defined(__lzo_destructor)
#  ifndef __lzo_HAVE_destructor
#  define __lzo_HAVE_destructor 1
#  endif
#endif
#if (__lzo_HAVE_destructor) && !(__lzo_HAVE_constructor)
#  error "unexpected configuration - check your compiler defines"
#endif
#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
#if (LZO_CC_GNUC >= 0x030200ul)
#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
#elif (LZO_CC_IBMC >= 1010)
#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
#elif (LZO_CC_CLANG && LZO_CC_CLANG_C2)
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
#endif
#endif
#if defined(__lzo_likely)
#  ifndef __lzo_HAVE_likely
#  define __lzo_HAVE_likely 1
#  endif
#else
#  define __lzo_likely(e)           (e)
#endif
#if defined(__lzo_very_likely)
#  ifndef __lzo_HAVE_very_likely
#  define __lzo_HAVE_very_likely 1
#  endif
#else
#  define __lzo_very_likely(e)      __lzo_likely(e)
#endif
#if defined(__lzo_unlikely)
#  ifndef __lzo_HAVE_unlikely
#  define __lzo_HAVE_unlikely 1
#  endif
#else
#  define __lzo_unlikely(e)         (e)
#endif
#if defined(__lzo_very_unlikely)
#  ifndef __lzo_HAVE_very_unlikely
#  define __lzo_HAVE_very_unlikely 1
#  endif
#else
#  define __lzo_very_unlikely(e)    __lzo_unlikely(e)
#endif
#if !defined(__lzo_loop_forever)
#  if (LZO_CC_IBMC)
#    define __lzo_loop_forever()    LZO_BLOCK_BEGIN for (;;) { ; } LZO_BLOCK_END
#  else
#    define __lzo_loop_forever()    do { ; } while __lzo_cte(1)
#  endif
#endif
#if !defined(__lzo_unreachable)
#if (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x020800ul)) && lzo_has_builtin(__builtin_unreachable)
#  define __lzo_unreachable()       __builtin_unreachable();
#elif (LZO_CC_GNUC >= 0x040500ul)
#  define __lzo_unreachable()       __builtin_unreachable();
#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1300)) && 1
#  define __lzo_unreachable()       __builtin_unreachable();
#endif
#endif
#if defined(__lzo_unreachable)
#  ifndef __lzo_HAVE_unreachable
#  define __lzo_HAVE_unreachable 1
#  endif
#else
#  if 0
#  define __lzo_unreachable()       ((void)0);
#  else
#  define __lzo_unreachable()       __lzo_loop_forever();
#  endif
#endif
#if !defined(lzo_unused_funcs_impl)
#  if 1 && (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
#    define lzo_unused_funcs_impl(r,f)  static r __attribute__((__unused__)) f
#  elif 1 && (LZO_CC_BORLANDC || LZO_CC_GNUC)
#    define lzo_unused_funcs_impl(r,f)  static r f
#  else
#    define lzo_unused_funcs_impl(r,f)  __lzo_static_forceinline r f
#  endif
#endif
#ifndef __LZO_CTA_NAME
#if (LZO_CFG_USE_COUNTER)
#  define __LZO_CTA_NAME(a)         LZO_PP_ECONCAT2(a,__COUNTER__)
#else
#  define __LZO_CTA_NAME(a)         LZO_PP_ECONCAT2(a,__LINE__)
#endif
#endif
#if !defined(LZO_COMPILE_TIME_ASSERT_HEADER)
#  if (LZO_CC_AZTECC || LZO_CC_ZORTECHC)
#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-!(e)]; LZO_EXTERN_C_END
#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1u-2*!(e)]; LZO_EXTERN_C_END
#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-!(e)]; LZO_EXTERN_C_END
#  elif (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020900ul)) && defined(__cplusplus)
#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN int __LZO_CTA_NAME(lzo_cta_f__)(int [1-2*!(e)]); LZO_EXTERN_C_END
#  elif (LZO_CC_GNUC) && defined(__CHECKER__) && defined(__SPARSE_CHECKER__)
#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN enum {__LZO_CTA_NAME(lzo_cta_e__)=1/!!(e)} __attribute__((__unused__)); LZO_EXTERN_C_END
#  else
#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-2*!(e)]; LZO_EXTERN_C_END
#  endif
#endif
#if !defined(LZO_COMPILE_TIME_ASSERT)
#  if (LZO_CC_AZTECC)
#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-!(e)];}
#  elif (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x030000ul))
#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-2*!(e)] __attribute__((__unused__));}
#  elif (LZO_CC_DMC || LZO_CC_PACIFICC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
#  elif (LZO_CC_GNUC) && defined(__CHECKER__) && defined(__SPARSE_CHECKER__)
#    define LZO_COMPILE_TIME_ASSERT(e)  {(void) (0/!!(e));}
#  elif (LZO_CC_GNUC >= 0x040700ul) && (LZO_CFG_USE_COUNTER) && defined(__cplusplus)
#    define LZO_COMPILE_TIME_ASSERT(e)  {enum {__LZO_CTA_NAME(lzo_cta_e__)=1/!!(e)} __attribute__((__unused__));}
#  elif (LZO_CC_GNUC >= 0x040700ul)
#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-2*!(e)] __attribute__((__unused__));}
#  elif (LZO_CC_MSC && (_MSC_VER < 900))
#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
#  else
#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-2*!(e)];}
#  endif
#endif
#if (LZO_LANG_ASSEMBLER)
#  undef LZO_COMPILE_TIME_ASSERT_HEADER
#  define LZO_COMPILE_TIME_ASSERT_HEADER(e)  /*empty*/
#else
LZO_COMPILE_TIME_ASSERT_HEADER(1 == 1)
#if defined(__cplusplus)
extern "C" { LZO_COMPILE_TIME_ASSERT_HEADER(2 == 2) }
#endif
LZO_COMPILE_TIME_ASSERT_HEADER(3 == 3)
#endif
#if (LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC)
#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
#    define __lzo_cdecl                 __cdecl
#    define __lzo_cdecl_atexit          /*empty*/
#    define __lzo_cdecl_main            __cdecl
#    if (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
#      define __lzo_cdecl_qsort         __pascal
#    elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
#      define __lzo_cdecl_qsort         _stdcall
#    else
#      define __lzo_cdecl_qsort         __cdecl
#    endif
#  elif (LZO_CC_WATCOMC)
#    define __lzo_cdecl                 __cdecl
#  else
#    define __lzo_cdecl                 __cdecl
#    define __lzo_cdecl_atexit          __cdecl
#    define __lzo_cdecl_main            __cdecl
#    define __lzo_cdecl_qsort           __cdecl
#  endif
#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC || LZO_CC_WATCOMC)
#  elif (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
#    define __lzo_cdecl_sighandler      __pascal
#  elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
#    define __lzo_cdecl_sighandler      _stdcall
#  elif (LZO_CC_MSC && (_MSC_VER >= 1400)) && defined(_M_CEE_PURE)
#    define __lzo_cdecl_sighandler      __clrcall
#  elif (LZO_CC_MSC && (_MSC_VER >= 600 && _MSC_VER < 700))
#    if defined(_DLL)
#      define __lzo_cdecl_sighandler    _far _cdecl _loadds
#    elif defined(_MT)
#      define __lzo_cdecl_sighandler    _far _cdecl
#    else
#      define __lzo_cdecl_sighandler    _cdecl
#    endif
#  else
#    define __lzo_cdecl_sighandler      __cdecl
#  endif
#elif (LZO_ARCH_I386) && (LZO_CC_WATCOMC)
#  define __lzo_cdecl                   __cdecl
#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
#  define __lzo_cdecl                   cdecl
#endif
#if !defined(__lzo_cdecl)
#  define __lzo_cdecl                   /*empty*/
#endif
#if !defined(__lzo_cdecl_atexit)
#  define __lzo_cdecl_atexit            /*empty*/
#endif
#if !defined(__lzo_cdecl_main)
#  define __lzo_cdecl_main              /*empty*/
#endif
#if !defined(__lzo_cdecl_qsort)
#  define __lzo_cdecl_qsort             /*empty*/
#endif
#if !defined(__lzo_cdecl_sighandler)
#  define __lzo_cdecl_sighandler        /*empty*/
#endif
#if !defined(__lzo_cdecl_va)
#  define __lzo_cdecl_va                __lzo_cdecl
#endif
#if !(LZO_CFG_NO_WINDOWS_H)
#if !defined(LZO_HAVE_WINDOWS_H)
#if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
#  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
#  elif ((LZO_OS_WIN32 && defined(__PW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x030000ul)))
#  elif ((LZO_OS_CYGWIN || defined(__MINGW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025f00ul)))
#  else
#    define LZO_HAVE_WINDOWS_H 1
#  endif
#endif
#endif
#endif
#define LZO_SIZEOF_CHAR             1
#ifndef LZO_SIZEOF_SHORT
#if defined(SIZEOF_SHORT)
#  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
#elif defined(__SIZEOF_SHORT__)
#  define LZO_SIZEOF_SHORT          (__SIZEOF_SHORT__)
#endif
#endif
#ifndef LZO_SIZEOF_INT
#if defined(SIZEOF_INT)
#  define LZO_SIZEOF_INT            (SIZEOF_INT)
#elif defined(__SIZEOF_INT__)
#  define LZO_SIZEOF_INT            (__SIZEOF_INT__)
#endif
#endif
#ifndef LZO_SIZEOF_LONG
#if defined(SIZEOF_LONG)
#  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
#elif defined(__SIZEOF_LONG__)
#  define LZO_SIZEOF_LONG           (__SIZEOF_LONG__)
#endif
#endif
#ifndef LZO_SIZEOF_LONG_LONG
#if defined(SIZEOF_LONG_LONG)
#  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
#elif defined(__SIZEOF_LONG_LONG__)
#  define LZO_SIZEOF_LONG_LONG      (__SIZEOF_LONG_LONG__)
#endif
#endif
#ifndef LZO_SIZEOF___INT16
#if defined(SIZEOF___INT16)
#  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
#endif
#endif
#ifndef LZO_SIZEOF___INT32
#if defined(SIZEOF___INT32)
#  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
#endif
#endif
#ifndef LZO_SIZEOF___INT64
#if defined(SIZEOF___INT64)
#  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
#endif
#endif
#ifndef LZO_SIZEOF_VOID_P
#if defined(SIZEOF_VOID_P)
#  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
#elif defined(__SIZEOF_POINTER__)
#  define LZO_SIZEOF_VOID_P         (__SIZEOF_POINTER__)
#endif
#endif
#ifndef LZO_SIZEOF_SIZE_T
#if defined(SIZEOF_SIZE_T)
#  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
#elif defined(__SIZEOF_SIZE_T__)
#  define LZO_SIZEOF_SIZE_T         (__SIZEOF_SIZE_T__)
#endif
#endif
#ifndef LZO_SIZEOF_PTRDIFF_T
#if defined(SIZEOF_PTRDIFF_T)
#  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
#elif defined(__SIZEOF_PTRDIFF_T__)
#  define LZO_SIZEOF_PTRDIFF_T      (__SIZEOF_PTRDIFF_T__)
#endif
#endif
#define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
#if !defined(LZO_SIZEOF_SHORT)
#  if (LZO_ARCH_CRAY_PVP)
#    define LZO_SIZEOF_SHORT        8
#  elif (USHRT_MAX == LZO_0xffffL)
#    define LZO_SIZEOF_SHORT        2
#  elif (__LZO_LSR(USHRT_MAX,7) == 1)
#    define LZO_SIZEOF_SHORT        1
#  elif (__LZO_LSR(USHRT_MAX,15) == 1)
#    define LZO_SIZEOF_SHORT        2
#  elif (__LZO_LSR(USHRT_MAX,31) == 1)
#    define LZO_SIZEOF_SHORT        4
#  elif (__LZO_LSR(USHRT_MAX,63) == 1)
#    define LZO_SIZEOF_SHORT        8
#  elif (__LZO_LSR(USHRT_MAX,127) == 1)
#    define LZO_SIZEOF_SHORT        16
#  else
#    error "LZO_SIZEOF_SHORT"
#  endif
#endif
LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_SHORT == sizeof(short))
#if !defined(LZO_SIZEOF_INT)
#  if (LZO_ARCH_CRAY_PVP)
#    define LZO_SIZEOF_INT          8
#  elif (UINT_MAX == LZO_0xffffL)
#    define LZO_SIZEOF_INT          2
#  elif (UINT_MAX == LZO_0xffffffffL)
#    define LZO_SIZEOF_INT          4
#  elif (__LZO_LSR(UINT_MAX,7) == 1)
#    define LZO_SIZEOF_INT          1
#  elif (__LZO_LSR(UINT_MAX,15) == 1)
#    define LZO_SIZEOF_INT          2
#  elif (__LZO_LSR(UINT_MAX,31) == 1)
#    define LZO_SIZEOF_INT          4
#  elif (__LZO_LSR(UINT_MAX,63) == 1)
#    define LZO_SIZEOF_INT          8
#  elif (__LZO_LSR(UINT_MAX,127) == 1)
#    define LZO_SIZEOF_INT          16
#  else
#    error "LZO_SIZEOF_INT"
#  endif
#endif
LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_INT == sizeof(int))
#if !defined(LZO_SIZEOF_LONG)
#  if (ULONG_MAX == LZO_0xffffffffL)
#    define LZO_SIZEOF_LONG         4
#  elif (__LZO_LSR(ULONG_MAX,7) == 1)
#    define LZO_SIZEOF_LONG         1
#  elif (__LZO_LSR(ULONG_MAX,15) == 1)
#    define LZO_SIZEOF_LONG         2
#  elif (__LZO_LSR(ULONG_MAX,31) == 1)
#    define LZO_SIZEOF_LONG         4
#  elif (__LZO_LSR(ULONG_MAX,39) == 1)
#    define LZO_SIZEOF_LONG         5
#  elif (__LZO_LSR(ULONG_MAX,63) == 1)
#    define LZO_SIZEOF_LONG         8
#  elif (__LZO_LSR(ULONG_MAX,127) == 1)
#    define LZO_SIZEOF_LONG         16
#  else
#    error "LZO_SIZEOF_LONG"
#  endif
#endif
LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_LONG == sizeof(long))
#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
#  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
#    if (LZO_CC_GNUC >= 0x030300ul)
#      if ((__LONG_MAX__-0) == (__LONG_LONG_MAX__-0))
#        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
#      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
#        define LZO_SIZEOF_LONG_LONG      4
#      endif
#    endif
#  endif
#endif
#endif
#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
#if (LZO_ARCH_I086 && LZO_CC_DMC)
#elif (LZO_CC_CILLY) && defined(__GNUC__)
#  define LZO_SIZEOF_LONG_LONG      8
#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
#  define LZO_SIZEOF_LONG_LONG      8
#elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
#  define LZO_SIZEOF_LONG_LONG      8
#elif (LZO_OS_WIN64 || defined(_WIN64))
#  define LZO_SIZEOF___INT64        8
#elif (LZO_ARCH_I386 && (LZO_CC_DMC))
#  define LZO_SIZEOF_LONG_LONG      8
#elif (LZO_ARCH_I386 && (LZO_CC_SYMANTECC && (__SC__ >= 0x700)))
#  define LZO_SIZEOF_LONG_LONG      8
#elif (LZO_ARCH_I386 && (LZO_CC_INTELC && defined(__linux__)))
#  define LZO_SIZEOF_LONG_LONG      8
#elif (LZO_ARCH_I386 && (LZO_CC_MWERKS || LZO_CC_PELLESC || LZO_CC_PGI || LZO_CC_SUNPROC))
#  define LZO_SIZEOF_LONG_LONG      8
#elif (LZO_ARCH_I386 && (LZO_CC_INTELC || LZO_CC_MSC))
#  define LZO_SIZEOF___INT64        8
#elif ((LZO_OS_WIN32 || defined(_WIN32)) && (LZO_CC_MSC))
#  define LZO_SIZEOF___INT64        8
#elif (LZO_ARCH_I386 && (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0520)))
#  define LZO_SIZEOF___INT64        8
#elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
#  define LZO_SIZEOF___INT64        8
#elif (LZO_CC_GHS && defined(__LLONG_BIT) && ((__LLONG_BIT-0) == 64))
#  define LZO_SIZEOF_LONG_LONG      8
#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && ((_INTEGRAL_MAX_BITS-0) == 64))
#  define LZO_SIZEOF___INT64        8
#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
#  define LZO_SIZEOF_LONG_LONG      8
#elif (defined(__vms) || defined(__VMS)) && ((__INITIAL_POINTER_SIZE-0) == 64)
#  define LZO_SIZEOF_LONG_LONG      8
#elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
#elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
#  define LZO_SIZEOF_LONG_LONG      8
#endif
#endif
#endif
#if defined(__cplusplus) && (LZO_CC_GNUC)
#  if (LZO_CC_GNUC < 0x020800ul)
#    undef LZO_SIZEOF_LONG_LONG
#  endif
#endif
#if (LZO_CFG_NO_LONG_LONG)
#  undef LZO_SIZEOF_LONG_LONG
#elif defined(__NO_LONG_LONG)
#  undef LZO_SIZEOF_LONG_LONG
#elif defined(_NO_LONGLONG)
#  undef LZO_SIZEOF_LONG_LONG
#endif
#if !defined(LZO_WORDSIZE)
#if (LZO_ARCH_ALPHA)
#  define LZO_WORDSIZE              8
#elif (LZO_ARCH_AMD64)
#  define LZO_WORDSIZE              8
#elif (LZO_ARCH_ARM64)
#  define LZO_WORDSIZE              8
#elif (LZO_ARCH_AVR)
#  define LZO_WORDSIZE              1
#elif (LZO_ARCH_H8300)
#  if defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
#    define LZO_WORDSIZE            4
#  else
#    define LZO_WORDSIZE            2
#  endif
#elif (LZO_ARCH_I086)
#  define LZO_WORDSIZE              2
#elif (LZO_ARCH_IA64)
#  define LZO_WORDSIZE              8
#elif (LZO_ARCH_M16C)
#  define LZO_WORDSIZE              2
#elif (LZO_ARCH_SPU)
#  define LZO_WORDSIZE              4
#elif (LZO_ARCH_Z80)
#  define LZO_WORDSIZE              1
#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
#  define LZO_WORDSIZE              8
#elif (LZO_OS_OS400 || defined(__OS400__))
#  define LZO_WORDSIZE              8
#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
#  define LZO_WORDSIZE              8
#endif
#endif
#if !defined(LZO_SIZEOF_VOID_P)
#if defined(__ILP32__) || defined(__ILP32) || defined(_ILP32)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int)  == 4)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 4)
#  define LZO_SIZEOF_VOID_P         4
#elif defined(__ILP64__) || defined(__ILP64) || defined(_ILP64)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int)  == 8)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 8)
#  define LZO_SIZEOF_VOID_P         8
#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 4)
#  define LZO_SIZEOF_VOID_P         8
#elif defined(__LP64__) || defined(__LP64) || defined(_LP64)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 8)
#  define LZO_SIZEOF_VOID_P         8
#elif (LZO_ARCH_AVR)
#  define LZO_SIZEOF_VOID_P         2
#elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
#  define LZO_SIZEOF_VOID_P         2
#elif (LZO_ARCH_H8300)
#  if defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
     LZO_COMPILE_TIME_ASSERT_HEADER(LZO_WORDSIZE == 4)
#    if defined(__NORMAL_MODE__)
#      define LZO_SIZEOF_VOID_P     2
#    else
#      define LZO_SIZEOF_VOID_P     4
#    endif
#  else
     LZO_COMPILE_TIME_ASSERT_HEADER(LZO_WORDSIZE == 2)
#    define LZO_SIZEOF_VOID_P       2
#  endif
#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
#  endif
#elif (LZO_ARCH_I086)
#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
#    define LZO_SIZEOF_VOID_P       2
#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
#    define LZO_SIZEOF_VOID_P       4
#  else
#    error "invalid LZO_ARCH_I086 memory model"
#  endif
#elif (LZO_ARCH_M16C)
#  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
#    define LZO_SIZEOF_VOID_P       4
#  else
#    define LZO_SIZEOF_VOID_P       2
#  endif
#elif (LZO_ARCH_SPU)
#  define LZO_SIZEOF_VOID_P         4
#elif (LZO_ARCH_Z80)
#  define LZO_SIZEOF_VOID_P         2
#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
#  define LZO_SIZEOF_VOID_P         4
#elif (LZO_OS_OS400 || defined(__OS400__))
#  if defined(__LLP64_IFC__)
#    define LZO_SIZEOF_VOID_P       8
#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_LONG
#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_LONG
#  else
#    define LZO_SIZEOF_VOID_P       16
#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_LONG
#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_LONG
#  endif
#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
#  define LZO_SIZEOF_VOID_P         8
#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
#endif
#endif
#if !defined(LZO_SIZEOF_VOID_P)
#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
#endif
LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_VOID_P == sizeof(void *))
#if !defined(LZO_SIZEOF_SIZE_T)
#if (LZO_ARCH_I086 || LZO_ARCH_M16C)
#  define LZO_SIZEOF_SIZE_T         2
#endif
#endif
#if !defined(LZO_SIZEOF_SIZE_T)
#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
#endif
#if defined(offsetof)
LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_SIZE_T == sizeof(size_t))
#endif
#if !defined(LZO_SIZEOF_PTRDIFF_T)
#if (LZO_ARCH_I086)
#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM || LZO_MM_HUGE)
#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_VOID_P
#  elif (LZO_MM_COMPACT || LZO_MM_LARGE)
#    if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
#      define LZO_SIZEOF_PTRDIFF_T  4
#    else
#      define LZO_SIZEOF_PTRDIFF_T  2
#    endif
#  else
#    error "invalid LZO_ARCH_I086 memory model"
#  endif
#endif
#endif
#if !defined(LZO_SIZEOF_PTRDIFF_T)
#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
#endif
#if defined(offsetof)
LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_PTRDIFF_T == sizeof(ptrdiff_t))
#endif
#if !defined(LZO_WORDSIZE)
#  define LZO_WORDSIZE              LZO_SIZEOF_VOID_P
#endif
#if (LZO_ABI_NEUTRAL_ENDIAN)
#  undef LZO_ABI_BIG_ENDIAN
#  undef LZO_ABI_LITTLE_ENDIAN
#elif !(LZO_ABI_BIG_ENDIAN) && !(LZO_ABI_LITTLE_ENDIAN)
#if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
#  define LZO_ABI_BIG_ENDIAN        1
#elif (LZO_ARCH_IA64) && (LZO_OS_POSIX_LINUX || LZO_OS_WIN64)
#  define LZO_ABI_LITTLE_ENDIAN     1
#elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430 || LZO_ARCH_RISCV)
#  define LZO_ABI_LITTLE_ENDIAN     1
#elif (LZO_ARCH_AVR32 || LZO_ARCH_M68K || LZO_ARCH_S390 || LZO_ARCH_SPU)
#  define LZO_ABI_BIG_ENDIAN        1
#elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
#  if (__LITTLE_ENDIAN__ == 1)
#    define LZO_ABI_LITTLE_ENDIAN   1
#  else
#    define LZO_ABI_BIG_ENDIAN      1
#  endif
#elif 1 && defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__)
#  define LZO_ABI_BIG_ENDIAN        1
#elif 1 && defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
#  define LZO_ABI_LITTLE_ENDIAN     1
#elif 1 && (LZO_ARCH_ARM) && defined(__ARM_BIG_ENDIAN) && ((__ARM_BIG_ENDIAN)+0)
#  define LZO_ABI_BIG_ENDIAN        1
#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEB__) && !defined(__ARMEL__)
#  define LZO_ABI_BIG_ENDIAN        1
#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
#  define LZO_ABI_LITTLE_ENDIAN     1
#elif 1 && (LZO_ARCH_ARM) && defined(_MSC_VER) && defined(_WIN32)
#  define LZO_ABI_LITTLE_ENDIAN     1
#elif 1 && (LZO_ARCH_ARM && LZO_CC_ARMCC_ARMCC)
#  if defined(__BIG_ENDIAN) && defined(__LITTLE_ENDIAN)
#    error "unexpected configuration - check your compiler defines"
#  elif defined(__BIG_ENDIAN)
#    define LZO_ABI_BIG_ENDIAN      1
#  else
#    define LZO_ABI_LITTLE_ENDIAN   1
#  endif
#  define LZO_ABI_LITTLE_ENDIAN     1
#elif 1 && (LZO_ARCH_ARM64) && defined(__ARM_BIG_ENDIAN) && ((__ARM_BIG_ENDIAN)+0)
#  define LZO_ABI_BIG_ENDIAN        1
#elif 1 && (LZO_ARCH_ARM64) && defined(__AARCH64EB__) && !defined(__AARCH64EL__)
#  define LZO_ABI_BIG_ENDIAN        1
#elif 1 && (LZO_ARCH_ARM64) && defined(__AARCH64EL__) && !defined(__AARCH64EB__)
#  define LZO_ABI_LITTLE_ENDIAN     1
#elif 1 && (LZO_ARCH_ARM64) && defined(_MSC_VER) && defined(_WIN32)
#  define LZO_ABI_LITTLE_ENDIAN     1
#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
#  define LZO_ABI_BIG_ENDIAN        1
#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
#  define LZO_ABI_LITTLE_ENDIAN     1
#endif
#endif
#if (LZO_ABI_BIG_ENDIAN) && (LZO_ABI_LITTLE_ENDIAN)
#  error "unexpected configuration - check your compiler defines"
#endif
#if (LZO_ABI_BIG_ENDIAN)
#  define LZO_INFO_ABI_ENDIAN       "be"
#elif (LZO_ABI_LITTLE_ENDIAN)
#  define LZO_INFO_ABI_ENDIAN       "le"
#elif (LZO_ABI_NEUTRAL_ENDIAN)
#  define LZO_INFO_ABI_ENDIAN       "neutral"
#endif
#if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
#  define LZO_ABI_I8LP16         1
#  define LZO_INFO_ABI_PM       "i8lp16"
#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
#  define LZO_ABI_ILP16         1
#  define LZO_INFO_ABI_PM       "ilp16"
#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
#  define LZO_ABI_LP32          1
#  define LZO_INFO_ABI_PM       "lp32"
#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
#  define LZO_ABI_ILP32         1
#  define LZO_INFO_ABI_PM       "ilp32"
#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 8 && LZO_SIZEOF_SIZE_T == 8)
#  define LZO_ABI_LLP64         1
#  define LZO_INFO_ABI_PM       "llp64"
#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
#  define LZO_ABI_LP64          1
#  define LZO_INFO_ABI_PM       "lp64"
#elif (LZO_SIZEOF_INT == 8 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
#  define LZO_ABI_ILP64         1
#  define LZO_INFO_ABI_PM       "ilp64"
#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 4)
#  define LZO_ABI_IP32L64       1
#  define LZO_INFO_ABI_PM       "ip32l64"
#endif
#if (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_VOID_P == 4 && LZO_WORDSIZE == 8)
#  define LZO_ABI_IP32W64       1
#  ifndef LZO_INFO_ABI_PM
#  define LZO_INFO_ABI_PM       "ip32w64"
#  endif
#endif
#if 0
#elif !defined(__LZO_LIBC_OVERRIDE)
#if (LZO_LIBC_NAKED)
#  define LZO_INFO_LIBC         "naked"
#elif (LZO_LIBC_FREESTANDING)
#  define LZO_INFO_LIBC         "freestanding"
#elif (LZO_LIBC_MOSTLY_FREESTANDING)
#  define LZO_INFO_LIBC         "mfreestanding"
#elif (LZO_LIBC_ISOC90)
#  define LZO_INFO_LIBC         "isoc90"
#elif (LZO_LIBC_ISOC99)
#  define LZO_INFO_LIBC         "isoc99"
#elif (LZO_CC_ARMCC_ARMCC) && defined(__ARMCLIB_VERSION)
#  define LZO_LIBC_ISOC90       1
#  define LZO_INFO_LIBC         "isoc90"
#elif defined(__dietlibc__)
#  define LZO_LIBC_DIETLIBC     1
#  define LZO_INFO_LIBC         "dietlibc"
#elif defined(_NEWLIB_VERSION)
#  define LZO_LIBC_NEWLIB       1
#  define LZO_INFO_LIBC         "newlib"
#elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
#  if defined(__UCLIBC_SUBLEVEL__)
#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + (__UCLIBC_MINOR__-0) * 0x100 + (__UCLIBC_SUBLEVEL__-0))
#  else
#    define LZO_LIBC_UCLIBC     0x00090bL
#  endif
#  define LZO_INFO_LIBC         "uc" "libc"
#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + (__GLIBC_MINOR__-0) * 0x100)
#  define LZO_INFO_LIBC         "glibc"
#elif (LZO_CC_MWERKS) && defined(__MSL__)
#  define LZO_LIBC_MSL          __MSL__
#  define LZO_INFO_LIBC         "msl"
#elif 1 && defined(__IAR_SYSTEMS_ICC__)
#  define LZO_LIBC_ISOC90       1
#  define LZO_INFO_LIBC         "isoc90"
#else
#  define LZO_LIBC_DEFAULT      1
#  define LZO_INFO_LIBC         "default"
#endif
#endif
#if (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
#  define LZO_ASM_SYNTAX_MSC 1
#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
#elif (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC == 0x011f00ul))
#elif (LZO_ARCH_I386 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
#  define LZO_ASM_SYNTAX_GNUC 1
#elif (LZO_ARCH_AMD64 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
#  define LZO_ASM_SYNTAX_GNUC 1
#elif (LZO_CC_GNUC)
#  define LZO_ASM_SYNTAX_GNUC 1
#endif
#if (LZO_ASM_SYNTAX_GNUC)
#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
#  define __LZO_ASM_CLOBBER                     "ax"
#  define __LZO_ASM_CLOBBER_LIST_CC             /*empty*/
#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      /*empty*/
#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
#elif (LZO_CC_INTELC && (__INTEL_COMPILER < 1000))
#  define __LZO_ASM_CLOBBER                     "memory"
#  define __LZO_ASM_CLOBBER_LIST_CC             /*empty*/
#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      : "memory"
#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
#else
#  define __LZO_ASM_CLOBBER                     "cc", "memory"
#  define __LZO_ASM_CLOBBER_LIST_CC             : "cc"
#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      : "cc", "memory"
#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
#endif
#endif
#if (LZO_ARCH_ALPHA)
#  define LZO_OPT_AVOID_UINT_INDEX          1
#elif (LZO_ARCH_AMD64)
#  define LZO_OPT_AVOID_INT_INDEX           1
#  define LZO_OPT_AVOID_UINT_INDEX          1
#  ifndef LZO_OPT_UNALIGNED16
#  define LZO_OPT_UNALIGNED16               1
#  endif
#  ifndef LZO_OPT_UNALIGNED32
#  define LZO_OPT_UNALIGNED32               1
#  endif
#  ifndef LZO_OPT_UNALIGNED64
#  define LZO_OPT_UNALIGNED64               1
#  endif
#elif (LZO_ARCH_ARM)
#  if defined(__ARM_FEATURE_UNALIGNED)
#   if ((__ARM_FEATURE_UNALIGNED)+0)
#    ifndef LZO_OPT_UNALIGNED16
#    define LZO_OPT_UNALIGNED16             1
#    endif
#    ifndef LZO_OPT_UNALIGNED32
#    define LZO_OPT_UNALIGNED32             1
#    endif
#   endif
#  elif 1 && (LZO_ARCH_ARM_THUMB2)
#    ifndef LZO_OPT_UNALIGNED16
#    define LZO_OPT_UNALIGNED16             1
#    endif
#    ifndef LZO_OPT_UNALIGNED32
#    define LZO_OPT_UNALIGNED32             1
#    endif
#  elif 1 && defined(__ARM_ARCH) && ((__ARM_ARCH)+0 >= 7)
#    ifndef LZO_OPT_UNALIGNED16
#    define LZO_OPT_UNALIGNED16             1
#    endif
#    ifndef LZO_OPT_UNALIGNED32
#    define LZO_OPT_UNALIGNED32             1
#    endif
#  elif 1 && defined(__TARGET_ARCH_ARM) && ((__TARGET_ARCH_ARM)+0 >= 7)
#    ifndef LZO_OPT_UNALIGNED16
#    define LZO_OPT_UNALIGNED16             1
#    endif
#    ifndef LZO_OPT_UNALIGNED32
#    define LZO_OPT_UNALIGNED32             1
#    endif
#  elif 1 && defined(__TARGET_ARCH_ARM) && ((__TARGET_ARCH_ARM)+0 >= 6) && (defined(__TARGET_PROFILE_A) || defined(__TARGET_PROFILE_R))
#    ifndef LZO_OPT_UNALIGNED16
#    define LZO_OPT_UNALIGNED16             1
#    endif
#    ifndef LZO_OPT_UNALIGNED32
#    define LZO_OPT_UNALIGNED32             1
#    endif
#  elif 1 && defined(_MSC_VER) && defined(_M_ARM) && ((_M_ARM)+0 >= 7)
#    ifndef LZO_OPT_UNALIGNED16
#    define LZO_OPT_UNALIGNED16             1
#    endif
#    ifndef LZO_OPT_UNALIGNED32
#    define LZO_OPT_UNALIGNED32             1
#    endif
#  endif
#elif (LZO_ARCH_ARM64)
#  ifndef LZO_OPT_UNALIGNED16
#  define LZO_OPT_UNALIGNED16               1
#  endif
#  ifndef LZO_OPT_UNALIGNED32
#  define LZO_OPT_UNALIGNED32               1
#  endif
#  ifndef LZO_OPT_UNALIGNED64
#  define LZO_OPT_UNALIGNED64               1
#  endif
#elif (LZO_ARCH_CRIS)
#  ifndef LZO_OPT_UNALIGNED16
#  define LZO_OPT_UNALIGNED16               1
#  endif
#  ifndef LZO_OPT_UNALIGNED32
#  define LZO_OPT_UNALIGNED32               1
#  endif
#elif (LZO_ARCH_I386)
#  ifndef LZO_OPT_UNALIGNED16
#  define LZO_OPT_UNALIGNED16               1
#  endif
#  ifndef LZO_OPT_UNALIGNED32
#  define LZO_OPT_UNALIGNED32               1
#  endif
#elif (LZO_ARCH_IA64)
#  define LZO_OPT_AVOID_INT_INDEX           1
#  define LZO_OPT_AVOID_UINT_INDEX          1
#  define LZO_OPT_PREFER_POSTINC            1
#elif (LZO_ARCH_M68K)
#  define LZO_OPT_PREFER_POSTINC            1
#  define LZO_OPT_PREFER_PREDEC             1
#  if defined(__mc68020__) && !defined(__mcoldfire__)
#    ifndef LZO_OPT_UNALIGNED16
#    define LZO_OPT_UNALIGNED16             1
#    endif
#    ifndef LZO_OPT_UNALIGNED32
#    define LZO_OPT_UNALIGNED32             1
#    endif
#  endif
#elif (LZO_ARCH_MIPS)
#  define LZO_OPT_AVOID_UINT_INDEX          1
#elif (LZO_ARCH_POWERPC)
#  define LZO_OPT_PREFER_PREINC             1
#  define LZO_OPT_PREFER_PREDEC             1
#  if (LZO_ABI_BIG_ENDIAN) || (LZO_WORDSIZE == 8)
#    ifndef LZO_OPT_UNALIGNED16
#    define LZO_OPT_UNALIGNED16             1
#    endif
#    ifndef LZO_OPT_UNALIGNED32
#    define LZO_OPT_UNALIGNED32             1
#    endif
#    if (LZO_WORDSIZE == 8)
#      ifndef LZO_OPT_UNALIGNED64
#      define LZO_OPT_UNALIGNED64           1
#      endif
#    endif
#  endif
#elif (LZO_ARCH_RISCV)
#  define LZO_OPT_AVOID_UINT_INDEX          1
#  ifndef LZO_OPT_UNALIGNED16
#  define LZO_OPT_UNALIGNED16               1
#  endif
#  ifndef LZO_OPT_UNALIGNED32
#  define LZO_OPT_UNALIGNED32               1
#  endif
#  if (LZO_WORDSIZE == 8)
#    ifndef LZO_OPT_UNALIGNED64
#    define LZO_OPT_UNALIGNED64             1
#    endif
#  endif
#elif (LZO_ARCH_S390)
#  ifndef LZO_OPT_UNALIGNED16
#  define LZO_OPT_UNALIGNED16               1
#  endif
#  ifndef LZO_OPT_UNALIGNED32
#  define LZO_OPT_UNALIGNED32               1
#  endif
#  if (LZO_WORDSIZE == 8)
#    ifndef LZO_OPT_UNALIGNED64
#    define LZO_OPT_UNALIGNED64             1
#    endif
#  endif
#elif (LZO_ARCH_SH)
#  define LZO_OPT_PREFER_POSTINC            1
#  define LZO_OPT_PREFER_PREDEC             1
#endif
#ifndef LZO_CFG_NO_INLINE_ASM
#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
#  define LZO_CFG_NO_INLINE_ASM 1
#elif (LZO_CC_LLVM)
#  define LZO_CFG_NO_INLINE_ASM 1
#endif
#endif
#if (LZO_CFG_NO_INLINE_ASM)
#  undef LZO_ASM_SYNTAX_MSC
#  undef LZO_ASM_SYNTAX_GNUC
#  undef __LZO_ASM_CLOBBER
#  undef __LZO_ASM_CLOBBER_LIST_CC
#  undef __LZO_ASM_CLOBBER_LIST_CC_MEMORY
#  undef __LZO_ASM_CLOBBER_LIST_EMPTY
#endif
#ifndef LZO_CFG_NO_UNALIGNED
#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
#  define LZO_CFG_NO_UNALIGNED 1
#endif
#endif
#if (LZO_CFG_NO_UNALIGNED)
#  undef LZO_OPT_UNALIGNED16
#  undef LZO_OPT_UNALIGNED32
#  undef LZO_OPT_UNALIGNED64
#endif
#if defined(__LZO_INFOSTR_MM)
#elif (LZO_MM_FLAT) && (defined(__LZO_INFOSTR_PM) || defined(LZO_INFO_ABI_PM))
#  define __LZO_INFOSTR_MM          ""
#elif defined(LZO_INFO_MM)
#  define __LZO_INFOSTR_MM          "." LZO_INFO_MM
#else
#  define __LZO_INFOSTR_MM          ""
#endif
#if defined(__LZO_INFOSTR_PM)
#elif defined(LZO_INFO_ABI_PM)
#  define __LZO_INFOSTR_PM          "." LZO_INFO_ABI_PM
#else
#  define __LZO_INFOSTR_PM          ""
#endif
#if defined(__LZO_INFOSTR_ENDIAN)
#elif defined(LZO_INFO_ABI_ENDIAN)
#  define __LZO_INFOSTR_ENDIAN      "." LZO_INFO_ABI_ENDIAN
#else
#  define __LZO_INFOSTR_ENDIAN      ""
#endif
#if defined(__LZO_INFOSTR_OSNAME)
#elif defined(LZO_INFO_OS_CONSOLE)
#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_CONSOLE
#elif defined(LZO_INFO_OS_POSIX)
#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_POSIX
#else
#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS
#endif
#if defined(__LZO_INFOSTR_LIBC)
#elif defined(LZO_INFO_LIBC)
#  define __LZO_INFOSTR_LIBC        "." LZO_INFO_LIBC
#else
#  define __LZO_INFOSTR_LIBC        ""
#endif
#if defined(__LZO_INFOSTR_CCVER)
#elif defined(LZO_INFO_CCVER)
#  define __LZO_INFOSTR_CCVER       " " LZO_INFO_CCVER
#else
#  define __LZO_INFOSTR_CCVER       ""
#endif
#define LZO_INFO_STRING \
    LZO_INFO_ARCH __LZO_INFOSTR_MM __LZO_INFOSTR_PM __LZO_INFOSTR_ENDIAN \
    " " __LZO_INFOSTR_OSNAME __LZO_INFOSTR_LIBC " " LZO_INFO_CC __LZO_INFOSTR_CCVER
#if !(LZO_CFG_SKIP_LZO_TYPES)
#if (!(LZO_SIZEOF_SHORT+0 > 0 && LZO_SIZEOF_INT+0 > 0 && LZO_SIZEOF_LONG+0 > 0))
#  error "missing defines for sizes"
#endif
#if (!(LZO_SIZEOF_PTRDIFF_T+0 > 0 && LZO_SIZEOF_SIZE_T+0 > 0 && LZO_SIZEOF_VOID_P+0 > 0))
#  error "missing defines for sizes"
#endif
#define LZO_TYPEOF_CHAR             1u
#define LZO_TYPEOF_SHORT            2u
#define LZO_TYPEOF_INT              3u
#define LZO_TYPEOF_LONG             4u
#define LZO_TYPEOF_LONG_LONG        5u
#define LZO_TYPEOF___INT8           17u
#define LZO_TYPEOF___INT16          18u
#define LZO_TYPEOF___INT32          19u
#define LZO_TYPEOF___INT64          20u
#define LZO_TYPEOF___INT128         21u
#define LZO_TYPEOF___INT256         22u
#define LZO_TYPEOF___MODE_QI        33u
#define LZO_TYPEOF___MODE_HI        34u
#define LZO_TYPEOF___MODE_SI        35u
#define LZO_TYPEOF___MODE_DI        36u
#define LZO_TYPEOF___MODE_TI        37u
#define LZO_TYPEOF_CHAR_P           129u
#if !defined(lzo_llong_t)
#if (LZO_SIZEOF_LONG_LONG+0 > 0)
#  if !(LZO_LANG_ASSEMBLER)
   __lzo_gnuc_extension__ typedef long long lzo_llong_t__;
   __lzo_gnuc_extension__ typedef unsigned long long lzo_ullong_t__;
#  endif
#  define lzo_llong_t               lzo_llong_t__
#  define lzo_ullong_t              lzo_ullong_t__
#endif
#endif
#if !defined(lzo_int16e_t)
#if (LZO_CFG_PREFER_TYPEOF_ACC_INT16E_T == LZO_TYPEOF_SHORT) && (LZO_SIZEOF_SHORT != 2)
#  undef LZO_CFG_PREFER_TYPEOF_ACC_INT16E_T
#endif
#if (LZO_SIZEOF_LONG == 2) && !(LZO_CFG_PREFER_TYPEOF_ACC_INT16E_T == LZO_TYPEOF_SHORT)
#  define lzo_int16e_t              long
#  define lzo_uint16e_t             unsigned long
#  define LZO_TYPEOF_LZO_INT16E_T   LZO_TYPEOF_LONG
#elif (LZO_SIZEOF_INT == 2) && !(LZO_CFG_PREFER_TYPEOF_ACC_INT16E_T == LZO_TYPEOF_SHORT)
#  define lzo_int16e_t              int
#  define lzo_uint16e_t             unsigned int
#  define LZO_TYPEOF_LZO_INT16E_T   LZO_TYPEOF_INT
#elif (LZO_SIZEOF_SHORT == 2)
#  define lzo_int16e_t              short int
#  define lzo_uint16e_t             unsigned short int
#  define LZO_TYPEOF_LZO_INT16E_T   LZO_TYPEOF_SHORT
#elif 1 && !(LZO_CFG_TYPE_NO_MODE_HI) && (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x025f00ul) || LZO_CC_LLVM)
#  if !(LZO_LANG_ASSEMBLER)
   typedef int lzo_int16e_hi_t__ __attribute__((__mode__(__HI__)));
   typedef unsigned int lzo_uint16e_hi_t__ __attribute__((__mode__(__HI__)));
#  endif
#  define lzo_int16e_t              lzo_int16e_hi_t__
#  define lzo_uint16e_t             lzo_uint16e_hi_t__
#  define LZO_TYPEOF_LZO_INT16E_T   LZO_TYPEOF___MODE_HI
#elif (LZO_SIZEOF___INT16 == 2)
#  define lzo_int16e_t              __int16
#  define lzo_uint16e_t             unsigned __int16
#  define LZO_TYPEOF_LZO_INT16E_T   LZO_TYPEOF___INT16
#else
#endif
#endif
#if defined(lzo_int16e_t)
#  define LZO_SIZEOF_LZO_INT16E_T   2
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16e_t) == 2)
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16e_t) == LZO_SIZEOF_LZO_INT16E_T)
#endif
#if !defined(lzo_int32e_t)
#if (LZO_CFG_PREFER_TYPEOF_ACC_INT32E_T == LZO_TYPEOF_INT) && (LZO_SIZEOF_INT != 4)
#  undef LZO_CFG_PREFER_TYPEOF_ACC_INT32E_T
#endif
#if (LZO_SIZEOF_LONG == 4) && !(LZO_CFG_PREFER_TYPEOF_ACC_INT32E_T == LZO_TYPEOF_INT)
#  define lzo_int32e_t              long int
#  define lzo_uint32e_t             unsigned long int
#  define LZO_TYPEOF_LZO_INT32E_T   LZO_TYPEOF_LONG
#elif (LZO_SIZEOF_INT == 4)
#  define lzo_int32e_t              int
#  define lzo_uint32e_t             unsigned int
#  define LZO_TYPEOF_LZO_INT32E_T   LZO_TYPEOF_INT
#elif (LZO_SIZEOF_SHORT == 4)
#  define lzo_int32e_t              short int
#  define lzo_uint32e_t             unsigned short int
#  define LZO_TYPEOF_LZO_INT32E_T   LZO_TYPEOF_SHORT
#elif (LZO_SIZEOF_LONG_LONG == 4)
#  define lzo_int32e_t              lzo_llong_t
#  define lzo_uint32e_t             lzo_ullong_t
#  define LZO_TYPEOF_LZO_INT32E_T   LZO_TYPEOF_LONG_LONG
#elif 1 && !(LZO_CFG_TYPE_NO_MODE_SI) && (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x025f00ul) || LZO_CC_LLVM) && (__INT_MAX__+0 > 2147483647L)
#  if !(LZO_LANG_ASSEMBLER)
   typedef int lzo_int32e_si_t__ __attribute__((__mode__(__SI__)));
   typedef unsigned int lzo_uint32e_si_t__ __attribute__((__mode__(__SI__)));
#  endif
#  define lzo_int32e_t              lzo_int32e_si_t__
#  define lzo_uint32e_t             lzo_uint32e_si_t__
#  define LZO_TYPEOF_LZO_INT32E_T   LZO_TYPEOF___MODE_SI
#elif 1 && !(LZO_CFG_TYPE_NO_MODE_SI) && (LZO_CC_GNUC >= 0x025f00ul) && defined(__AVR__) && (__LONG_MAX__+0 == 32767L)
#  if !(LZO_LANG_ASSEMBLER)
   typedef int lzo_int32e_si_t__ __attribute__((__mode__(__SI__)));
   typedef unsigned int lzo_uint32e_si_t__ __attribute__((__mode__(__SI__)));
#  endif
#  define lzo_int32e_t              lzo_int32e_si_t__
#  define lzo_uint32e_t             lzo_uint32e_si_t__
#  define LZO_INT32_C(c)            (c##LL)
#  define LZO_UINT32_C(c)           (c##ULL)
#  define LZO_TYPEOF_LZO_INT32E_T   LZO_TYPEOF___MODE_SI
#elif (LZO_SIZEOF___INT32 == 4)
#  define lzo_int32e_t              __int32
#  define lzo_uint32e_t             unsigned __int32
#  define LZO_TYPEOF_LZO_INT32E_T   LZO_TYPEOF___INT32
#else
#endif
#endif
#if defined(lzo_int32e_t)
#  define LZO_SIZEOF_LZO_INT32E_T   4
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32e_t) == 4)
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32e_t) == LZO_SIZEOF_LZO_INT32E_T)
#endif
#if !defined(lzo_int64e_t)
#if (LZO_SIZEOF___INT64 == 8)
#  if (LZO_CC_BORLANDC) && !defined(LZO_CFG_PREFER_TYPEOF_ACC_INT64E_T)
#    define LZO_CFG_PREFER_TYPEOF_ACC_INT64E_T  LZO_TYPEOF___INT64
#  endif
#endif
#if (LZO_CFG_PREFER_TYPEOF_ACC_INT64E_T == LZO_TYPEOF_LONG_LONG) && (LZO_SIZEOF_LONG_LONG != 8)
#  undef LZO_CFG_PREFER_TYPEOF_ACC_INT64E_T
#endif
#if (LZO_CFG_PREFER_TYPEOF_ACC_INT64E_T == LZO_TYPEOF___INT64) && (LZO_SIZEOF___INT64 != 8)
#  undef LZO_CFG_PREFER_TYPEOF_ACC_INT64E_T
#endif
#if (LZO_SIZEOF_INT == 8) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
#  define lzo_int64e_t              int
#  define lzo_uint64e_t             unsigned int
#  define LZO_TYPEOF_LZO_INT64E_T   LZO_TYPEOF_INT
#elif (LZO_SIZEOF_LONG == 8) && !(LZO_CFG_PREFER_TYPEOF_ACC_INT64E_T == LZO_TYPEOF_LONG_LONG) && !(LZO_CFG_PREFER_TYPEOF_ACC_INT64E_T == LZO_TYPEOF___INT64)
#  define lzo_int64e_t              long int
#  define lzo_uint64e_t             unsigned long int
#  define LZO_TYPEOF_LZO_INT64E_T   LZO_TYPEOF_LONG
#elif (LZO_SIZEOF_LONG_LONG == 8) && !(LZO_CFG_PREFER_TYPEOF_ACC_INT64E_T == LZO_TYPEOF___INT64)
#  define lzo_int64e_t              lzo_llong_t
#  define lzo_uint64e_t             lzo_ullong_t
#  define LZO_TYPEOF_LZO_INT64E_T   LZO_TYPEOF_LONG_LONG
#  if (LZO_CC_BORLANDC)
#    define LZO_INT64_C(c)          ((c) + 0ll)
#    define LZO_UINT64_C(c)         ((c) + 0ull)
#  elif 0
#    define LZO_INT64_C(c)          (__lzo_gnuc_extension__ (c##LL))
#    define LZO_UINT64_C(c)         (__lzo_gnuc_extension__ (c##ULL))
#  else
#    define LZO_INT64_C(c)          (c##LL)
#    define LZO_UINT64_C(c)         (c##ULL)
#  endif
#elif (LZO_SIZEOF___INT64 == 8)
#  define lzo_int64e_t              __int64
#  define lzo_uint64e_t             unsigned __int64
#  define LZO_TYPEOF_LZO_INT64E_T   LZO_TYPEOF___INT64
#  if (LZO_CC_BORLANDC)
#    define LZO_INT64_C(c)          ((c) + 0i64)
#    define LZO_UINT64_C(c)         ((c) + 0ui64)
#  else
#    define LZO_INT64_C(c)          (c##i64)
#    define LZO_UINT64_C(c)         (c##ui64)
#  endif
#else
#endif
#endif
#if defined(lzo_int64e_t)
#  define LZO_SIZEOF_LZO_INT64E_T   8
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64e_t) == 8)
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64e_t) == LZO_SIZEOF_LZO_INT64E_T)
#endif
#if !defined(lzo_int32l_t)
#if defined(lzo_int32e_t)
#  define lzo_int32l_t              lzo_int32e_t
#  define lzo_uint32l_t             lzo_uint32e_t
#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_LZO_INT32E_T
#  define LZO_TYPEOF_LZO_INT32L_T   LZO_TYPEOF_LZO_INT32E_T
#elif (LZO_SIZEOF_INT >= 4) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
#  define lzo_int32l_t              int
#  define lzo_uint32l_t             unsigned int
#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_INT
#  define LZO_TYPEOF_LZO_INT32L_T   LZO_SIZEOF_INT
#elif (LZO_SIZEOF_LONG >= 4)
#  define lzo_int32l_t              long int
#  define lzo_uint32l_t             unsigned long int
#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_LONG
#  define LZO_TYPEOF_LZO_INT32L_T   LZO_SIZEOF_LONG
#else
#  error "lzo_int32l_t"
#endif
#endif
#if 1
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32l_t) >= 4)
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32l_t) == LZO_SIZEOF_LZO_INT32L_T)
#endif
#if !defined(lzo_int64l_t)
#if defined(lzo_int64e_t)
#  define lzo_int64l_t              lzo_int64e_t
#  define lzo_uint64l_t             lzo_uint64e_t
#  define LZO_SIZEOF_LZO_INT64L_T   LZO_SIZEOF_LZO_INT64E_T
#  define LZO_TYPEOF_LZO_INT64L_T   LZO_TYPEOF_LZO_INT64E_T
#else
#endif
#endif
#if defined(lzo_int64l_t)
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64l_t) >= 8)
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64l_t) == LZO_SIZEOF_LZO_INT64L_T)
#endif
#if !defined(lzo_int32f_t)
#if (LZO_SIZEOF_SIZE_T >= 8)
#  define lzo_int32f_t              lzo_int64l_t
#  define lzo_uint32f_t             lzo_uint64l_t
#  define LZO_SIZEOF_LZO_INT32F_T   LZO_SIZEOF_LZO_INT64L_T
#  define LZO_TYPEOF_LZO_INT32F_T   LZO_TYPEOF_LZO_INT64L_T
#else
#  define lzo_int32f_t              lzo_int32l_t
#  define lzo_uint32f_t             lzo_uint32l_t
#  define LZO_SIZEOF_LZO_INT32F_T   LZO_SIZEOF_LZO_INT32L_T
#  define LZO_TYPEOF_LZO_INT32F_T   LZO_TYPEOF_LZO_INT32L_T
#endif
#endif
#if 1
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32f_t) >= 4)
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32f_t) == LZO_SIZEOF_LZO_INT32F_T)
#endif
#if !defined(lzo_int64f_t)
#if defined(lzo_int64l_t)
#  define lzo_int64f_t              lzo_int64l_t
#  define lzo_uint64f_t             lzo_uint64l_t
#  define LZO_SIZEOF_LZO_INT64F_T   LZO_SIZEOF_LZO_INT64L_T
#  define LZO_TYPEOF_LZO_INT64F_T   LZO_TYPEOF_LZO_INT64L_T
#else
#endif
#endif
#if defined(lzo_int64f_t)
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64f_t) >= 8)
   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64f_t) == LZO_SIZEOF_LZO_INT64F_T)
#endif
#if !defined(lzo_intptr_t)
#if 1 && (LZO_OS_OS400 && (LZO_SIZEOF_VOID_P == 16))
#  define __LZO_INTPTR_T_IS_POINTER 1
#  if !(LZO_LANG_ASSEMBLER)
   typedef char *                   lzo_intptr_t;
   typedef char *                   lzo_uintptr_t;
#  endif
#  define lzo_intptr_t              lzo_intptr_t
#  define lzo_uintptr_t             lzo_uintptr_t
#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_VOID_P
#  define LZO_TYPEOF_LZO_INTPTR_T   LZO_TYPEOF_CHAR_P
#elif (LZO_CC_MSC && (_MSC_VER >= 1300) && (LZO_SIZEOF_VOID_P == 4) && (LZO_SIZEOF_INT == 4))
#  if !(LZO_LANG_ASSEMBLER)
   typedef __w64 int                lzo_intptr_t;
   typedef __w64 unsigned int       lzo_uintptr_t;
#  endif
#  define lzo_intptr_t              lzo_intptr_t
#  define lzo_uintptr_t             lzo_uintptr_t
#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_INT
#  define LZO_TYPEOF_LZO_INTPTR_T   LZO_TYPEOF_INT
#elif (LZO_SIZEOF_SHORT == LZO_SIZEOF_VOID_P) && (LZO_SIZEOF_INT > LZO_SIZEOF_VOID_P)
#  define lzo_intptr_t              short
#  define lzo_uintptr_t             unsigned short
#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_SHORT
#  define LZO_TYPEOF_LZO_INTPTR_T   LZO_TYPEOF_SHORT
#elif (LZO_SIZEOF_INT >= LZO_SIZEOF_VOID_P) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
#  define lzo_intptr_t              int
#  define lzo_uintptr_t             unsigned int
#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_INT
#  define LZO_TYPEOF_LZO_INTPTR_T   LZO_TYPEOF_INT
#elif (LZO_SIZEOF_LONG >= LZO_SIZEOF_VOID_P)
#  define lzo_intptr_t              long
#  define lzo_uintptr_t             unsigned long
#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_LONG
#  define LZO_TYPEOF_LZO_INTPTR_T   LZO_TYPEOF_LONG
#elif (LZO_SIZEOF_LZO_INT64L_T >= LZO_SIZEOF_VOID_P)
#  define lzo_intptr_t              lzo_int64l_t
#  define lzo_uintptr_t             lzo_uint64l_t
#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_LZO_INT64L_T
#  define LZO_TYPEOF_LZO_INTPTR_T   LZO_TYPEOF_LZO_INT64L_T
#else
#  error "lzo_intptr_t"
#endif
#endif
#if 1
    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_intptr_t) >= sizeof(void *))
    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_intptr_t) == sizeof(lzo_uintptr_t))
#endif
#if !defined(lzo_word_t)
#if defined(LZO_WORDSIZE) && (LZO_WORDSIZE+0 > 0)
#if (LZO_WORDSIZE == LZO_SIZEOF_LZO_INTPTR_T) && !(__LZO_INTPTR_T_IS_POINTER)
#  define lzo_word_t                lzo_uintptr_t
#  define lzo_sword_t               lzo_intptr_t
#  define LZO_SIZEOF_LZO_WORD_T     LZO_SIZEOF_LZO_INTPTR_T
#  define LZO_TYPEOF_LZO_WORD_T     LZO_TYPEOF_LZO_INTPTR_T
#elif (LZO_WORDSIZE == LZO_SIZEOF_LONG)
#  define lzo_word_t                unsigned long
#  define lzo_sword_t               long
#  define LZO_SIZEOF_LZO_WORD_T     LZO_SIZEOF_LONG
#  define LZO_TYPEOF_LZO_WORD_T     LZO_TYPEOF_LONG
#elif (LZO_WORDSIZE == LZO_SIZEOF_INT)
#  define lzo_word_t                unsigned int
#  define lzo_sword_t               int
#  define LZO_SIZEOF_LZO_WORD_T     LZO_SIZEOF_INT
#  define LZO_TYPEOF_LZO_WORD_T     LZO_TYPEOF_INT
#elif (LZO_WORDSIZE == LZO_SIZEOF_SHORT)
#  define lzo_word_t                unsigned short
#  define lzo_sword_t               short
#  define LZO_SIZEOF_LZO_WORD_T     LZO_SIZEOF_SHORT
#  define LZO_TYPEOF_LZO_WORD_T     LZO_TYPEOF_SHORT
#elif (LZO_WORDSIZE == 1)
#  define lzo_word_t                unsigned char
#  define lzo_sword_t               signed char
#  define LZO_SIZEOF_LZO_WORD_T     1
#  define LZO_TYPEOF_LZO_WORD_T     LZO_TYPEOF_CHAR
#elif (LZO_WORDSIZE == LZO_SIZEOF_LZO_INT64L_T)
#  define lzo_word_t                lzo_uint64l_t
#  define lzo_sword_t               lzo_int64l_t
#  define LZO_SIZEOF_LZO_WORD_T     LZO_SIZEOF_LZO_INT64L_T
#  define LZO_TYPEOF_LZO_WORD_T     LZO_SIZEOF_LZO_INT64L_T
#elif (LZO_ARCH_SPU) && (LZO_CC_GNUC)
#if 0
#  if !(LZO_LANG_ASSEMBLER)
   typedef unsigned lzo_word_t  __attribute__((__mode__(__V16QI__)));
   typedef int      lzo_sword_t __attribute__((__mode__(__V16QI__)));
#  endif
#  define lzo_word_t                lzo_word_t
#  define lzo_sword_t               lzo_sword_t
#  define LZO_SIZEOF_LZO_WORD_T     16
#  define LZO_TYPEOF_LZO_WORD_T     LZO_TYPEOF___MODE_V16QI
#endif
#else
#  error "lzo_word_t"
#endif
#endif
#endif
#if 1 && defined(lzo_word_t)
    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_word_t)  == LZO_WORDSIZE)
    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_sword_t) == LZO_WORDSIZE)
#endif
#if 1
#define lzo_int8_t                  signed char
#define lzo_uint8_t                 unsigned char
#define LZO_SIZEOF_LZO_INT8_T       1
#define LZO_TYPEOF_LZO_INT8_T       LZO_TYPEOF_CHAR
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t) == 1)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t) == sizeof(lzo_uint8_t))
#endif
#if defined(lzo_int16e_t)
#define lzo_int16_t                 lzo_int16e_t
#define lzo_uint16_t                lzo_uint16e_t
#define LZO_SIZEOF_LZO_INT16_T      LZO_SIZEOF_LZO_INT16E_T
#define LZO_TYPEOF_LZO_INT16_T      LZO_TYPEOF_LZO_INT16E_T
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t) == 2)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t) == sizeof(lzo_uint16_t))
#endif
#if defined(lzo_int32e_t)
#define lzo_int32_t                 lzo_int32e_t
#define lzo_uint32_t                lzo_uint32e_t
#define LZO_SIZEOF_LZO_INT32_T      LZO_SIZEOF_LZO_INT32E_T
#define LZO_TYPEOF_LZO_INT32_T      LZO_TYPEOF_LZO_INT32E_T
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t) == 4)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t) == sizeof(lzo_uint32_t))
#endif
#if defined(lzo_int64e_t)
#define lzo_int64_t                 lzo_int64e_t
#define lzo_uint64_t                lzo_uint64e_t
#define LZO_SIZEOF_LZO_INT64_T      LZO_SIZEOF_LZO_INT64E_T
#define LZO_TYPEOF_LZO_INT64_T      LZO_TYPEOF_LZO_INT64E_T
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t) == 8)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t) == sizeof(lzo_uint64_t))
#endif
#if 1
#define lzo_int_least32_t           lzo_int32l_t
#define lzo_uint_least32_t          lzo_uint32l_t
#define LZO_SIZEOF_LZO_INT_LEAST32_T LZO_SIZEOF_LZO_INT32L_T
#define LZO_TYPEOF_LZO_INT_LEAST32_T LZO_TYPEOF_LZO_INT32L_T
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least32_t) >= 4)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least32_t) == sizeof(lzo_uint_least32_t))
#endif
#if defined(lzo_int64l_t)
#define lzo_int_least64_t           lzo_int64l_t
#define lzo_uint_least64_t          lzo_uint64l_t
#define LZO_SIZEOF_LZO_INT_LEAST64_T LZO_SIZEOF_LZO_INT64L_T
#define LZO_TYPEOF_LZO_INT_LEAST64_T LZO_TYPEOF_LZO_INT64L_T
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least64_t) >= 8)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least64_t) == sizeof(lzo_uint_least64_t))
#endif
#if 1
#define lzo_int_fast32_t           lzo_int32f_t
#define lzo_uint_fast32_t          lzo_uint32f_t
#define LZO_SIZEOF_LZO_INT_FAST32_T LZO_SIZEOF_LZO_INT32F_T
#define LZO_TYPEOF_LZO_INT_FAST32_T LZO_TYPEOF_LZO_INT32F_T
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast32_t) >= 4)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast32_t) == sizeof(lzo_uint_fast32_t))
#endif
#if defined(lzo_int64f_t)
#define lzo_int_fast64_t           lzo_int64f_t
#define lzo_uint_fast64_t          lzo_uint64f_t
#define LZO_SIZEOF_LZO_INT_FAST64_T LZO_SIZEOF_LZO_INT64F_T
#define LZO_TYPEOF_LZO_INT_FAST64_T LZO_TYPEOF_LZO_INT64F_T
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast64_t) >= 8)
LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast64_t) == sizeof(lzo_uint_fast64_t))
#endif
#if !defined(LZO_INT16_C)
#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 2)
#    define LZO_INT16_C(c)          ((c) + 0)
#    define LZO_UINT16_C(c)         ((c) + 0U)
#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 2)
#    define LZO_INT16_C(c)          ((c) + 0L)
#    define LZO_UINT16_C(c)         ((c) + 0UL)
#  elif (LZO_SIZEOF_INT >= 2)
#    define LZO_INT16_C(c)          (c)
#    define LZO_UINT16_C(c)         (c##U)
#  elif (LZO_SIZEOF_LONG >= 2)
#    define LZO_INT16_C(c)          (c##L)
#    define LZO_UINT16_C(c)         (c##UL)
#  else
#    error "LZO_INT16_C"
#  endif
#endif
#if !defined(LZO_INT32_C)
#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 4)
#    define LZO_INT32_C(c)          ((c) + 0)
#    define LZO_UINT32_C(c)         ((c) + 0U)
#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 4)
#    define LZO_INT32_C(c)          ((c) + 0L)
#    define LZO_UINT32_C(c)         ((c) + 0UL)
#  elif (LZO_SIZEOF_INT >= 4)
#    define LZO_INT32_C(c)          (c)
#    define LZO_UINT32_C(c)         (c##U)
#  elif (LZO_SIZEOF_LONG >= 4)
#    define LZO_INT32_C(c)          (c##L)
#    define LZO_UINT32_C(c)         (c##UL)
#  elif (LZO_SIZEOF_LONG_LONG >= 4)
#    define LZO_INT32_C(c)          (c##LL)
#    define LZO_UINT32_C(c)         (c##ULL)
#  else
#    error "LZO_INT32_C"
#  endif
#endif
#if !defined(LZO_INT64_C) && defined(lzo_int64l_t)
#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 8)
#    define LZO_INT64_C(c)          ((c) + 0)
#    define LZO_UINT64_C(c)         ((c) + 0U)
#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 8)
#    define LZO_INT64_C(c)          ((c) + 0L)
#    define LZO_UINT64_C(c)         ((c) + 0UL)
#  elif (LZO_SIZEOF_INT >= 8)
#    define LZO_INT64_C(c)          (c)
#    define LZO_UINT64_C(c)         (c##U)
#  elif (LZO_SIZEOF_LONG >= 8)
#    define LZO_INT64_C(c)          (c##L)
#    define LZO_UINT64_C(c)         (c##UL)
#  else
#    error "LZO_INT64_C"
#  endif
#endif
#endif

#endif /* already included */

/* vim:set ts=4 sw=4 et: */

```

`examples/shellcode obfuscation/shellcode obfuscation.cpp`:

```cpp

#include <Windows.h>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <time.h>
#include <stdio.h>
#include <sstream>
#include <iostream>
#include <iostream>
#include <stdarg.h> 
#include <cstdint>

using namespace std;

#include <capstone/include/capstone/capstone.h>
#include <enma_pe/enma_pe/enma_pe.h>
#include <fukutasm/fukutasm/fukutasm.h>
#include <furikuri/furikuri.h>



#include "lzo1z.h"

typedef int(__cdecl* _depack_algo)(const unsigned char* src, unsigned long  src_len, unsigned char* dst, unsigned long* dst_len, void* wrkmem);

unsigned char lzo_depack_32[] = {//0xCC,
    0x55, 0x8B, 0xEC, 0x8B, 0x55, 0x08, 0x8B, 0x45, 0x14, 0x01, 0x55, 0x0C, 0x53, 0x33, 0xDB, 0x56,
    0x57, 0x8B, 0x7D, 0x10, 0x89, 0x18, 0x8A, 0x02, 0x89, 0x5D, 0x08, 0x6A, 0x04, 0x5B, 0x3C, 0x11,
    0x76, 0x1C, 0x0F, 0xB6, 0xC8, 0x83, 0xE9, 0x11, 0x42, 0x3B, 0xCB, 0x0F, 0x82, 0xF6, 0x01, 0x00,
    0x00, 0x8A, 0x02, 0x88, 0x07, 0x47, 0x42, 0x83, 0xE9, 0x01, 0x75, 0xF5, 0xEB, 0x63, 0x0F, 0xB6,
    0x32, 0x42, 0x83, 0xFE, 0x10, 0x0F, 0x83, 0x90, 0x00, 0x00, 0x00, 0x85, 0xF6, 0x75, 0x17, 0xEB,
    0x07, 0x81, 0xC6, 0xFF, 0x00, 0x00, 0x00, 0x42, 0x80, 0x3A, 0x00, 0x74, 0xF4, 0x0F, 0xB6, 0x02,
    0x83, 0xC6, 0x0F, 0x03, 0xF0, 0x42, 0x8B, 0x02, 0x03, 0xD3, 0x89, 0x07, 0x03, 0xFB, 0x83, 0xEE,
    0x01, 0x74, 0x2E, 0x3B, 0xF3, 0x72, 0x1F, 0x8B, 0x02, 0x2B, 0xF3, 0x89, 0x07, 0x03, 0xD3, 0x03,
    0xFB, 0x3B, 0xF3, 0x73, 0xF2, 0x85, 0xF6, 0x74, 0x18, 0x8A, 0x02, 0x88, 0x07, 0x47, 0x42, 0x83,
    0xEE, 0x01, 0x75, 0xF5, 0xEB, 0x0B, 0x8A, 0x02, 0x88, 0x07, 0x47, 0x42, 0x83, 0xEE, 0x01, 0x75,
    0xF5, 0x0F, 0xB6, 0x32, 0x42, 0x83, 0xFE, 0x10, 0x73, 0x31, 0x0F, 0xB6, 0x02, 0x8B, 0xCF, 0xC1,
    0xE6, 0x06, 0xC1, 0xE8, 0x02, 0x8D, 0x9E, 0x01, 0x07, 0x00, 0x00, 0x03, 0xD8, 0x42, 0x2B, 0xCB,
    0x89, 0x5D, 0x08, 0x8A, 0x01, 0x88, 0x07, 0x8A, 0x41, 0x01, 0x88, 0x47, 0x01, 0x8A, 0x41, 0x02,
    0x88, 0x47, 0x02, 0x83, 0xC7, 0x03, 0xE9, 0x43, 0x01, 0x00, 0x00, 0x83, 0xFE, 0x40, 0x72, 0x47,
    0x8B, 0xCE, 0x8B, 0xDF, 0x83, 0xE1, 0x1F, 0x83, 0xF9, 0x1C, 0x72, 0x05, 0x2B, 0x5D, 0x08, 0xEB,
    0x12, 0x0F, 0xB6, 0x02, 0xC1, 0xE8, 0x02, 0xC1, 0xE1, 0x06, 0x40, 0x03, 0xC1, 0x42, 0x89, 0x45,
    0x08, 0x2B, 0xD8, 0xC1, 0xEE, 0x05, 0x4E, 0x8A, 0x03, 0x88, 0x07, 0x8A, 0x43, 0x01, 0x88, 0x47,
    0x01, 0x83, 0xC7, 0x02, 0x83, 0xC3, 0x02, 0x8A, 0x03, 0x88, 0x07, 0x47, 0x43, 0x83, 0xEE, 0x01,
    0x75, 0xF5, 0xE9, 0xF7, 0x00, 0x00, 0x00, 0x83, 0xFE, 0x20, 0x72, 0x35, 0x83, 0xE6, 0x1F, 0x75,
    0x17, 0xEB, 0x07, 0x81, 0xC6, 0xFF, 0x00, 0x00, 0x00, 0x42, 0x80, 0x3A, 0x00, 0x74, 0xF4, 0x0F,
    0xB6, 0x02, 0x83, 0xC6, 0x1F, 0x03, 0xF0, 0x42, 0x0F, 0xB6, 0x02, 0x8B, 0xDF, 0x0F, 0xB6, 0x4A,
    0x01, 0xC1, 0xE0, 0x06, 0xC1, 0xE9, 0x02, 0x40, 0x03, 0xC1, 0x2B, 0xD8, 0x83, 0xC2, 0x02, 0xEB,
    0x57, 0x83, 0xFE, 0x10, 0x0F, 0x82, 0x93, 0x00, 0x00, 0x00, 0x8B, 0xC6, 0x8B, 0xDF, 0x83, 0xE0,
    0x08, 0xC1, 0xE0, 0x0B, 0x2B, 0xD8, 0x83, 0xE6, 0x07, 0x75, 0x17, 0xEB, 0x07, 0x81, 0xC6, 0xFF,
    0x00, 0x00, 0x00, 0x42, 0x80, 0x3A, 0x00, 0x74, 0xF4, 0x0F, 0xB6, 0x02, 0x83, 0xC6, 0x07, 0x03,
    0xF0, 0x42, 0x0F, 0xB6, 0x4A, 0x01, 0x0F, 0xB6, 0x02, 0x83, 0xC2, 0x02, 0xC1, 0xE9, 0x02, 0xC1,
    0xE0, 0x06, 0x03, 0xC8, 0x2B, 0xD9, 0x3B, 0xDF, 0x0F, 0x84, 0xA6, 0x00, 0x00, 0x00, 0x81, 0xEB,
    0x00, 0x40, 0x00, 0x00, 0x8B, 0xC7, 0x2B, 0xC3, 0x89, 0x45, 0x08, 0x83, 0xFE, 0x06, 0x0F, 0x82,
    0x43, 0xFF, 0xFF, 0xFF, 0x8B, 0xC7, 0x6A, 0x04, 0x2B, 0xC3, 0x59, 0x3B, 0xC1, 0x0F, 0x8C, 0x34,
    0xFF, 0xFF, 0xFF, 0x8B, 0x03, 0x03, 0xD9, 0x89, 0x07, 0x03, 0xF9, 0x83, 0xEE, 0x02, 0x8B, 0x03,
    0x2B, 0xF1, 0x89, 0x07, 0x03, 0xD9, 0x03, 0xF9, 0x3B, 0xF1, 0x73, 0xF2, 0x85, 0xF6, 0x74, 0x2E,
    0x8A, 0x03, 0x88, 0x07, 0x47, 0x43, 0x83, 0xEE, 0x01, 0x75, 0xF5, 0xEB, 0x21, 0x0F, 0xB6, 0x02,
    0x8B, 0xCF, 0xC1, 0xE8, 0x02, 0x40, 0xC1, 0xE6, 0x06, 0x03, 0xC6, 0x42, 0x2B, 0xC8, 0x89, 0x45,
    0x08, 0x8A, 0x01, 0x88, 0x07, 0x8A, 0x41, 0x01, 0x88, 0x47, 0x01, 0x83, 0xC7, 0x02, 0x0F, 0xB6,
    0x4A, 0xFF, 0x83, 0xE1, 0x03, 0x74, 0x25, 0x8A, 0x02, 0x88, 0x07, 0x47, 0x42, 0x83, 0xF9, 0x01,
    0x76, 0x11, 0x8A, 0x02, 0x88, 0x07, 0x47, 0x42, 0x83, 0xF9, 0x02, 0x76, 0x06, 0x8A, 0x02, 0x88,
    0x07, 0x47, 0x42, 0x0F, 0xB6, 0x32, 0x42, 0xE9, 0x8F, 0xFE, 0xFF, 0xFF, 0x6A, 0x04, 0x5B, 0xE9,
    0xEA, 0xFD, 0xFF, 0xFF, 0x2B, 0x7D, 0x10, 0x8B, 0x45, 0x14, 0x3B, 0x55, 0x0C, 0x89, 0x38, 0x1B,
    0xC0, 0x83, 0xE0, 0xFC, 0x33, 0xF6, 0x83, 0xC0, 0xFC, 0x3B, 0x55, 0x0C, 0x5F, 0x0F, 0x44, 0xC6,
    0x5E, 0x5B, 0x5D, 0xC3
};

unsigned char lzo_depack_64[963] = {
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x18, 0x33,
    0xDB, 0x48, 0x8D, 0x3C, 0x11, 0x49, 0x89, 0x19, 0x49, 0x8B, 0xF0, 0x0F, 0xB6, 0x01, 0x4C, 0x8B,
    0xD1, 0x4D, 0x8B, 0xD8, 0x3C, 0x11, 0x76, 0x30, 0x0F, 0xB6, 0xC8, 0x48, 0x83, 0xE9, 0x11, 0x49,
    0xFF, 0xC2, 0x48, 0x83, 0xF9, 0x04, 0x0F, 0x82, 0x05, 0x03, 0x00, 0x00, 0x0F, 0x1F, 0x40, 0x00,
    0x41, 0x0F, 0xB6, 0x02, 0x49, 0xFF, 0xC2, 0x41, 0x88, 0x03, 0x49, 0xFF, 0xC3, 0x48, 0x83, 0xE9,
    0x01, 0x75, 0xED, 0xE9, 0xB7, 0x00, 0x00, 0x00, 0x0F, 0xB6, 0xC0, 0x49, 0xFF, 0xC2, 0x48, 0x83,
    0xF8, 0x10, 0x0F, 0x83, 0xF0, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x75, 0x30, 0x41, 0x0F, 0xB6,
    0x0A, 0x84, 0xC9, 0x75, 0x1D, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0x0F, 0xB6, 0x4A, 0x01, 0x49, 0xFF, 0xC2, 0x48, 0x05, 0xFF, 0x00, 0x00, 0x00, 0x84, 0xC9,
    0x74, 0xEE, 0x0F, 0xB6, 0xC9, 0x49, 0xFF, 0xC2, 0x48, 0x8D, 0x44, 0x08, 0x0F, 0x48, 0x83, 0xC0,
    0x03, 0x48, 0x83, 0xF8, 0x08, 0x72, 0x18, 0x49, 0x8B, 0x0A, 0x48, 0x83, 0xE8, 0x08, 0x49, 0x89,
    0x0B, 0x49, 0x83, 0xC2, 0x08, 0x49, 0x83, 0xC3, 0x08, 0x48, 0x83, 0xF8, 0x08, 0x73, 0xE8, 0x48,
    0x83, 0xF8, 0x04, 0x72, 0x12, 0x41, 0x8B, 0x0A, 0x49, 0x83, 0xC2, 0x04, 0x41, 0x89, 0x0B, 0x49,
    0x83, 0xC3, 0x04, 0x48, 0x83, 0xE8, 0x04, 0x48, 0x85, 0xC0, 0x74, 0x33, 0x41, 0x0F, 0xB6, 0x0A,
    0x49, 0xFF, 0xC2, 0x41, 0x88, 0x0B, 0x49, 0xFF, 0xC3, 0x48, 0x83, 0xF8, 0x01, 0x76, 0x20, 0x41,
    0x0F, 0xB6, 0x0A, 0x49, 0xFF, 0xC2, 0x41, 0x88, 0x0B, 0x49, 0xFF, 0xC3, 0x48, 0x83, 0xF8, 0x02,
    0x76, 0x0D, 0x41, 0x0F, 0xB6, 0x02, 0x41, 0x88, 0x03, 0x49, 0xFF, 0xC3, 0x49, 0xFF, 0xC2, 0x41,
    0x0F, 0xB6, 0x02, 0x49, 0xFF, 0xC2, 0x48, 0x83, 0xF8, 0x10, 0x73, 0x3C, 0x41, 0x0F, 0xB6, 0x0A,
    0x49, 0xFF, 0xC2, 0x48, 0xC1, 0xE0, 0x06, 0x48, 0xC1, 0xE9, 0x02, 0x48, 0x8D, 0x9C, 0x01, 0x01,
    0x07, 0x00, 0x00, 0x49, 0x8B, 0xCB, 0x48, 0x2B, 0xCB, 0x0F, 0xB6, 0x01, 0x41, 0x88, 0x03, 0x0F,
    0xB6, 0x41, 0x01, 0x41, 0x88, 0x43, 0x01, 0x0F, 0xB6, 0x41, 0x02, 0x41, 0x88, 0x43, 0x02, 0x49,
    0x83, 0xC3, 0x03, 0xE9, 0xDF, 0x01, 0x00, 0x00, 0x48, 0x83, 0xF8, 0x40, 0x72, 0x5E, 0x48, 0x8B,
    0xD0, 0x4D, 0x8B, 0xC3, 0x83, 0xE2, 0x1F, 0x48, 0x83, 0xFA, 0x1C, 0x73, 0x14, 0x41, 0x0F, 0xB6,
    0x0A, 0x48, 0xC1, 0xE9, 0x02, 0x48, 0xC1, 0xE2, 0x06, 0x49, 0xFF, 0xC2, 0x48, 0x8D, 0x5C, 0x11,
    0x01, 0x4C, 0x2B, 0xC3, 0x48, 0xC1, 0xE8, 0x05, 0x48, 0xFF, 0xC8, 0x41, 0x0F, 0xB6, 0x08, 0x41,
    0x88, 0x0B, 0x41, 0x0F, 0xB6, 0x48, 0x01, 0x41, 0x88, 0x4B, 0x01, 0x49, 0x83, 0xC3, 0x02, 0x49,
    0x83, 0xC0, 0x02, 0x41, 0x0F, 0xB6, 0x08, 0x4D, 0x8D, 0x40, 0x01, 0x41, 0x88, 0x0B, 0x49, 0xFF,
    0xC3, 0x48, 0x83, 0xE8, 0x01, 0x75, 0xEC, 0xE9, 0x7B, 0x01, 0x00, 0x00, 0x48, 0x83, 0xF8, 0x20,
    0x72, 0x5A, 0x83, 0xE0, 0x1F, 0x75, 0x36, 0x41, 0x0F, 0xB6, 0x0A, 0x84, 0xC9, 0x75, 0x23, 0x0F,
    0x1F, 0x40, 0x00, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x90,
    0x41, 0x0F, 0xB6, 0x4A, 0x01, 0x49, 0xFF, 0xC2, 0x48, 0x05, 0xFF, 0x00, 0x00, 0x00, 0x84, 0xC9,
    0x74, 0xEE, 0x0F, 0xB6, 0xC9, 0x49, 0xFF, 0xC2, 0x48, 0x8D, 0x44, 0x08, 0x1F, 0x41, 0x0F, 0xB6,
    0x52, 0x01, 0x4D, 0x8B, 0xC3, 0x41, 0x0F, 0xB6, 0x0A, 0xC1, 0xEA, 0x02, 0xC1, 0xE1, 0x06, 0x8D,
    0x5C, 0x0A, 0x01, 0x4C, 0x2B, 0xC3, 0x49, 0x83, 0xC2, 0x02, 0xEB, 0x72, 0x48, 0x83, 0xF8, 0x10,
    0x0F, 0x82, 0xE5, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0x4D, 0x8B, 0xC3, 0x83, 0xE1, 0x08, 0x48,
    0xC1, 0xE1, 0x0B, 0x4C, 0x2B, 0xC1, 0x83, 0xE0, 0x07, 0x75, 0x25, 0x41, 0x0F, 0xB6, 0x0A, 0x84,
    0xC9, 0x75, 0x12, 0x41, 0x0F, 0xB6, 0x4A, 0x01, 0x49, 0xFF, 0xC2, 0x48, 0x05, 0xFF, 0x00, 0x00,
    0x00, 0x84, 0xC9, 0x74, 0xEE, 0x0F, 0xB6, 0xC9, 0x49, 0xFF, 0xC2, 0x48, 0x8D, 0x44, 0x08, 0x07,
    0x41, 0x0F, 0xB6, 0x0A, 0x41, 0x0F, 0xB6, 0x52, 0x01, 0x49, 0x83, 0xC2, 0x02, 0xC1, 0xE1, 0x06,
    0xC1, 0xEA, 0x02, 0x03, 0xCA, 0x4C, 0x2B, 0xC1, 0x4D, 0x3B, 0xC3, 0x0F, 0x84, 0x08, 0x01, 0x00,
    0x00, 0x49, 0x81, 0xE8, 0x00, 0x40, 0x00, 0x00, 0x49, 0x8B, 0xDB, 0x49, 0x2B, 0xD8, 0x49, 0x8B,
    0xCB, 0x49, 0x2B, 0xC8, 0x48, 0x83, 0xF9, 0x08, 0x0F, 0x8C, 0xED, 0xFE, 0xFF, 0xFF, 0x48, 0x83,
    0xC0, 0x02, 0x48, 0x83, 0xF8, 0x08, 0x72, 0x18, 0x49, 0x8B, 0x08, 0x48, 0x83, 0xE8, 0x08, 0x49,
    0x89, 0x0B, 0x49, 0x83, 0xC0, 0x08, 0x49, 0x83, 0xC3, 0x08, 0x48, 0x83, 0xF8, 0x08, 0x73, 0xE8,
    0x48, 0x83, 0xF8, 0x04, 0x72, 0x12, 0x41, 0x8B, 0x08, 0x49, 0x83, 0xC0, 0x04, 0x41, 0x89, 0x0B,
    0x49, 0x83, 0xC3, 0x04, 0x48, 0x83, 0xE8, 0x04, 0x48, 0x85, 0xC0, 0x74, 0x5A, 0x41, 0x0F, 0xB6,
    0x08, 0x41, 0x88, 0x0B, 0x49, 0xFF, 0xC3, 0x48, 0x83, 0xF8, 0x01, 0x76, 0x4A, 0x41, 0x0F, 0xB6,
    0x48, 0x01, 0x41, 0x88, 0x0B, 0x49, 0xFF, 0xC3, 0x48, 0x83, 0xF8, 0x02, 0x76, 0x39, 0x41, 0x0F,
    0xB6, 0x40, 0x02, 0x41, 0x88, 0x03, 0x49, 0xFF, 0xC3, 0xEB, 0x2C, 0x41, 0x0F, 0xB6, 0x0A, 0x49,
    0xFF, 0xC2, 0x48, 0xC1, 0xE9, 0x02, 0x48, 0xC1, 0xE0, 0x06, 0x48, 0x8D, 0x5C, 0x01, 0x01, 0x49,
    0x8B, 0xCB, 0x48, 0x2B, 0xCB, 0x0F, 0xB6, 0x01, 0x41, 0x88, 0x03, 0x0F, 0xB6, 0x41, 0x01, 0x41,
    0x88, 0x43, 0x01, 0x49, 0x83, 0xC3, 0x02, 0x41, 0x0F, 0xB6, 0x4A, 0xFF, 0x83, 0xE1, 0x03, 0x74,
    0x3F, 0x41, 0x0F, 0xB6, 0x02, 0x49, 0xFF, 0xC2, 0x41, 0x88, 0x03, 0x49, 0xFF, 0xC3, 0x48, 0x83,
    0xF9, 0x01, 0x76, 0x20, 0x41, 0x0F, 0xB6, 0x02, 0x49, 0xFF, 0xC2, 0x41, 0x88, 0x03, 0x49, 0xFF,
    0xC3, 0x48, 0x83, 0xF9, 0x02, 0x76, 0x0D, 0x41, 0x0F, 0xB6, 0x02, 0x41, 0x88, 0x03, 0x49, 0xFF,
    0xC3, 0x49, 0xFF, 0xC2, 0x41, 0x0F, 0xB6, 0x02, 0x49, 0xFF, 0xC2, 0xE9, 0xD8, 0xFD, 0xFF, 0xFF,
    0x41, 0x0F, 0xB6, 0x02, 0xE9, 0xCF, 0xFC, 0xFF, 0xFF, 0x4C, 0x2B, 0xDE, 0x4D, 0x89, 0x19, 0x4C,
    0x3B, 0xD7, 0x75, 0x12, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x08, 0x48, 0x8B, 0x74, 0x24, 0x10,
    0x48, 0x8B, 0x7C, 0x24, 0x18, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x08, 0xB8, 0xFC, 0xFF, 0xFF, 0xFF,
    0x48, 0x8B, 0x74, 0x24, 0x10, 0xB9, 0xF8, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x18, 0x0F,
    0x42, 0xC1, 0xC3
};

#ifdef _M_X64

#ifdef _DEBUG 
#pragma comment(lib,"lzo2_mdd64.lib")
#else
#pragma comment(lib,"lzo2_mt64.lib")
#endif

#else

#ifdef _DEBUG 
#pragma comment(lib,"lzo2_mdd32.lib")
#else
#pragma comment(lib,"lzo2_mt32.lib")
#endif

#endif


const char test_message[] = "This is test message what passed through compression and decompression!!!";

int main() {

    bool allowed_relocs = true;

    unsigned long totaly_data_size = sizeof(test_message);
    lzo_uint packed_size = 0;


    uint8_t* compressed_buf = new uint8_t[totaly_data_size + (totaly_data_size / 16) + 64 + 3];
    
    {
        void* work_mem = new uint8_t[LZO1Z_999_MEM_COMPRESS];


        if (lzo1z_999_compress((const unsigned char*)test_message, totaly_data_size, 
            compressed_buf, &packed_size, work_mem) != LZO_E_OK) {

            delete[] work_mem;
            delete[] compressed_buf;
            return 0;
        }

        delete[] work_mem;
    }

    fuku_code_holder code_holder;
    fuku_code_analyzer anal_code;

#ifdef _M_X64
    fuku_code_profiler code_profiler(FUKU_ASSAMBLER_ARCH_X64);
    anal_code.set_arch(fuku_assambler_arch::FUKU_ASSAMBLER_ARCH_X64);
    anal_code.analyze_code(code_holder, lzo_depack_64, sizeof(lzo_depack_64), 0, 0);

#else
    fuku_code_profiler code_profiler(FUKU_ASSAMBLER_ARCH_X86);
    anal_code.set_arch(fuku_assambler_arch::FUKU_ASSAMBLER_ARCH_X86);
    anal_code.analyze_code(code_holder, lzo_depack_32, sizeof(lzo_depack_32), 0, 0);

#endif

    code_profiler.profile_code(code_holder);


    fuku_code_analyzer ob_anal_code = code_holder;

    fuku_obfuscator obfuscator;


    fuku_settings_obfuscation ob_set(3, 3, 30.f, 30.f, 30.f,
        FUKU_ASM_SHORT_CFG_USE_EAX_SHORT | FUKU_ASM_SHORT_CFG_USE_DISP_SHORT | FUKU_ASM_SHORT_CFG_USE_IMM_SHORT, false, !allowed_relocs);

    obfuscator.set_destination_virtual_address(0);
    obfuscator.set_settings(ob_set);
    obfuscator.set_code(&ob_anal_code.get_code());

    uint32_t s_time = GetTickCount();

    obfuscator.obfuscate_code();

    std::map<uint64_t, uint64_t> associations;
    std::vector<fuku_image_relocation> relocations;

    ob_anal_code.get_code().finalize_code(&associations, &relocations);

    std::vector<uint8_t> shell_code_result = ob_anal_code.get_code().dump_code();

    printf("shellcode obfuscated in %.4f sec | size scale %.2f | %.3f MIB \n",
        (GetTickCount() - s_time) / 1000.f, (float)shell_code_result.size() / sizeof(lzo_depack_32),
        (float)shell_code_result.size() / (float)(1024 * 1024));

    uint8_t* shell_code_result_ptr = shell_code_result.data();

    { //make page executable

        DWORD old_p;
        VirtualProtect(shell_code_result_ptr, shell_code_result.size(), PAGE_EXECUTE_READWRITE, &old_p);
    }

    _depack_algo depack = (_depack_algo)(shell_code_result_ptr + associations.begin()->second);

    if(allowed_relocs) { //fix relocs if allowed

#ifdef _M_X64
        for (auto& rel : relocations) {
            *(uint64_t*)& shell_code_result_ptr[rel.virtual_address] += (uint64_t)shell_code_result_ptr;
        }
#else
        for (auto& rel : relocations) {
            *(uint32_t*)& shell_code_result_ptr[rel.virtual_address] += (uint32_t)shell_code_result_ptr;
        }
#endif

    }


    char* decompressed_message = new char[totaly_data_size];

    depack(compressed_buf, packed_size, 
        (unsigned char*)decompressed_message, &totaly_data_size, 0);


    printf("%s\n", decompressed_message);

    delete decompressed_message;
    delete compressed_buf;


    return 0;
}
```

`examples/shellcode obfuscation/shellcode obfuscation.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29209.62
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shellcode obfuscation", "shellcode obfuscation.vcxproj", "{1A9E7495-2915-4539-8164-16B326BAFEF8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Debug|x64.ActiveCfg = Debug|x64
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Debug|x64.Build.0 = Debug|x64
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Debug|x86.ActiveCfg = Debug|Win32
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Debug|x86.Build.0 = Debug|Win32
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Release|x64.ActiveCfg = Release|x64
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Release|x64.Build.0 = Release|x64
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Release|x86.ActiveCfg = Release|Win32
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1EBD4E26-38F7-49C4-B636-C51696E55028}
	EndGlobalSection
EndGlobal

```

`examples/shellcode obfuscation/shellcode obfuscation.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{1A9E7495-2915-4539-8164-16B326BAFEF8}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>shellcodeobfuscation</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="shellcode obfuscation.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lzo1z.h" />
    <ClInclude Include="lzoconf.h" />
    <ClInclude Include="lzodefs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/shellcode obfuscation/shellcode obfuscation.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Исходные файлы\lzo">
      <UniqueIdentifier>{d3091fd9-6f15-4807-bda8-1458fd6077f7}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="shellcode obfuscation.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="lzo1z.h">
      <Filter>Исходные файлы\lzo</Filter>
    </ClInclude>
    <ClInclude Include="lzoconf.h">
      <Filter>Исходные файлы\lzo</Filter>
    </ClInclude>
    <ClInclude Include="lzodefs.h">
      <Filter>Исходные файлы\lzo</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`furikuri.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29209.62
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "furikuri", "furikuri\furikuri.vcxproj", "{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}"
	ProjectSection(ProjectDependencies) = postProject
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7} = {5B01D900-2359-44CA-9914-6B0C6AFB7BE7}
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7} = {0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC} = {5B0E07A2-6928-44E0-AF0A-445B067C71CC}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "enma", "enma", "{3A9C4149-02F2-4276-A81B-F93196E0A13E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "furikuri_console", "furikuri_console\furikuri_console.vcxproj", "{9C776AA4-29BB-480F-BADC-2D5385D4BA54}"
	ProjectSection(ProjectDependencies) = postProject
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62} = {88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "fuku", "fuku", "{2B75A5E8-6145-4753-A185-48B11BD293C5}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "dependencies", "dependencies", "{88426CCE-5EAD-46F9-B3EB-2AA4F02F0796}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "capstone", "capstone", "{9C9DC4DD-A192-46D9-BD4F-8D3FECEED122}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "capstone_static", "capstone\msvc\capstone_static\capstone_static.vcxproj", "{5B01D900-2359-44CA-9914-6B0C6AFB7BE7}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "fukutasm", "fukutasm\fukutasm\fukutasm.vcxproj", "{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "fuku_asm", "fuku_asm", "{31944A4F-4379-42ED-8134-785A272EEC9D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "enma_pe", "enma_pe\enma_pe\enma_pe.vcxproj", "{5B0E07A2-6928-44E0-AF0A-445B067C71CC}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "examples", "examples", "{509E6246-32DE-43D1-BF46-CAFF69445A53}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shellcode obfuscation", "examples\shellcode obfuscation\shellcode obfuscation.vcxproj", "{1A9E7495-2915-4539-8164-16B326BAFEF8}"
	ProjectSection(ProjectDependencies) = postProject
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62} = {88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "executable obfuscation", "examples\executable obfuscation\executable obfuscation.vcxproj", "{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}"
	ProjectSection(ProjectDependencies) = postProject
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62} = {88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}.Debug|x64.ActiveCfg = Debug|x64
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}.Debug|x64.Build.0 = Debug|x64
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}.Debug|x86.ActiveCfg = Debug|Win32
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}.Debug|x86.Build.0 = Debug|Win32
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}.Release|x64.ActiveCfg = Release|x64
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}.Release|x64.Build.0 = Release|x64
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}.Release|x86.ActiveCfg = Release|Win32
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}.Release|x86.Build.0 = Release|Win32
		{9C776AA4-29BB-480F-BADC-2D5385D4BA54}.Debug|x64.ActiveCfg = Debug|x64
		{9C776AA4-29BB-480F-BADC-2D5385D4BA54}.Debug|x64.Build.0 = Debug|x64
		{9C776AA4-29BB-480F-BADC-2D5385D4BA54}.Debug|x86.ActiveCfg = Debug|Win32
		{9C776AA4-29BB-480F-BADC-2D5385D4BA54}.Debug|x86.Build.0 = Debug|Win32
		{9C776AA4-29BB-480F-BADC-2D5385D4BA54}.Release|x64.ActiveCfg = Release|x64
		{9C776AA4-29BB-480F-BADC-2D5385D4BA54}.Release|x64.Build.0 = Release|x64
		{9C776AA4-29BB-480F-BADC-2D5385D4BA54}.Release|x86.ActiveCfg = Release|Win32
		{9C776AA4-29BB-480F-BADC-2D5385D4BA54}.Release|x86.Build.0 = Release|Win32
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7}.Debug|x64.ActiveCfg = Debug|x64
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7}.Debug|x64.Build.0 = Debug|x64
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7}.Debug|x86.ActiveCfg = Debug|Win32
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7}.Debug|x86.Build.0 = Debug|Win32
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7}.Release|x64.ActiveCfg = Release|x64
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7}.Release|x64.Build.0 = Release|x64
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7}.Release|x86.ActiveCfg = Release|Win32
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7}.Release|x86.Build.0 = Release|Win32
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}.Debug|x64.ActiveCfg = Debug|x64
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}.Debug|x64.Build.0 = Debug|x64
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}.Debug|x86.ActiveCfg = Debug|Win32
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}.Debug|x86.Build.0 = Debug|Win32
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}.Release|x64.ActiveCfg = Release|x64
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}.Release|x64.Build.0 = Release|x64
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}.Release|x86.ActiveCfg = Release|Win32
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7}.Release|x86.Build.0 = Release|Win32
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Debug|x64.ActiveCfg = Debug|x64
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Debug|x64.Build.0 = Debug|x64
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Debug|x86.ActiveCfg = Debug|Win32
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Debug|x86.Build.0 = Debug|Win32
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Release|x64.ActiveCfg = Release|x64
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Release|x64.Build.0 = Release|x64
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Release|x86.ActiveCfg = Release|Win32
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC}.Release|x86.Build.0 = Release|Win32
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Debug|x64.ActiveCfg = Debug|x64
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Debug|x64.Build.0 = Debug|x64
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Debug|x86.ActiveCfg = Debug|Win32
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Debug|x86.Build.0 = Debug|Win32
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Release|x64.ActiveCfg = Release|x64
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Release|x64.Build.0 = Release|x64
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Release|x86.ActiveCfg = Release|Win32
		{1A9E7495-2915-4539-8164-16B326BAFEF8}.Release|x86.Build.0 = Release|Win32
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Debug|x64.ActiveCfg = Debug|x64
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Debug|x64.Build.0 = Debug|x64
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Debug|x86.ActiveCfg = Debug|Win32
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Debug|x86.Build.0 = Debug|Win32
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Release|x64.ActiveCfg = Release|x64
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Release|x64.Build.0 = Release|x64
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Release|x86.ActiveCfg = Release|Win32
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62} = {2B75A5E8-6145-4753-A185-48B11BD293C5}
		{3A9C4149-02F2-4276-A81B-F93196E0A13E} = {88426CCE-5EAD-46F9-B3EB-2AA4F02F0796}
		{9C776AA4-29BB-480F-BADC-2D5385D4BA54} = {2B75A5E8-6145-4753-A185-48B11BD293C5}
		{9C9DC4DD-A192-46D9-BD4F-8D3FECEED122} = {88426CCE-5EAD-46F9-B3EB-2AA4F02F0796}
		{5B01D900-2359-44CA-9914-6B0C6AFB7BE7} = {9C9DC4DD-A192-46D9-BD4F-8D3FECEED122}
		{0A569853-B3F6-4BE5-A7DA-F88EFCE68EC7} = {31944A4F-4379-42ED-8134-785A272EEC9D}
		{31944A4F-4379-42ED-8134-785A272EEC9D} = {88426CCE-5EAD-46F9-B3EB-2AA4F02F0796}
		{5B0E07A2-6928-44E0-AF0A-445B067C71CC} = {3A9C4149-02F2-4276-A81B-F93196E0A13E}
		{1A9E7495-2915-4539-8164-16B326BAFEF8} = {509E6246-32DE-43D1-BF46-CAFF69445A53}
		{3D7CE960-CE33-4F44-88D7-E12E5AE617F2} = {509E6246-32DE-43D1-BF46-CAFF69445A53}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D1B2D2F8-89A0-4DB3-A979-5B2C3B809167}
	EndGlobalSection
EndGlobal

```

`furikuri/fuku_mutation_imp.h`:

```h
#pragma once

struct mutation_context {
    fuku_assambler* f_asm;
    fuku_code_holder* code_holder;
    fuku_settings_obfuscation* settings;

    cs_insn* instruction; //current instruction desc

    inststorage::iterator prev_inst_iter; //previus inst iter
    inststorage::iterator original_inst_iter; //current insts row iter 
    inststorage::iterator payload_inst_iter;  //current insts "payload" iter
    inststorage::iterator next_inst_iter; //next inst iter

    fuku_code_label* original_start_label;
    fuku_code_label* payload_start_label;

    bool is_first_inst; //is inst iter on begin
    bool is_next_last_inst; //is next inst iter on end
    bool has_source_address; //is inst has source address

    uint32_t inst_flags;
    uint64_t cpu_flags;
    uint64_t cpu_registers;
    uint64_t source_address;

    void initialize_context(inststorage::iterator& iter) {
        this->is_first_inst = iter == this->code_holder->get_insts().begin();
        

        this->prev_inst_iter = iter;
        if (!this->is_first_inst) { --this->prev_inst_iter; }
        this->original_inst_iter = iter;
        this->payload_inst_iter = iter;
        this->next_inst_iter = iter;
        ++this->next_inst_iter;

        this->is_next_last_inst = this->next_inst_iter == this->code_holder->get_insts().end();

        this->original_start_label = iter->get_label();
        this->payload_start_label = 0;

        this->cpu_flags = iter->get_cpu_flags();
        this->cpu_registers = iter->get_cpu_registers();
        this->inst_flags = iter->get_inst_flags();
        this->has_source_address = iter->has_source_address();

        if (this->has_source_address) {
            this->source_address = iter->get_source_address();
        }
    }

    fuku_code_label* generate_payload_label() {

        if (!payload_start_label) {
            payload_start_label = code_holder->create_label(fuku_code_label());
        }

        return payload_start_label;
    }

    inststorage::iterator calc_original_inst_iter() {

        if (this->is_first_inst) {
            return this->code_holder->get_insts().begin();
        }
        else {
            inststorage::iterator iter = this->prev_inst_iter;
            return ++iter;
        }
    }

    void update_payload_inst_iter() {
        this->payload_inst_iter = calc_next_inst_iter();
        --this->payload_inst_iter;
    }

    inststorage::iterator calc_next_inst_iter() {

        return this->next_inst_iter;
    }
};

typedef bool (*_fukutate_instruction)(mutation_context& ctx);

class fuku_mutation {
public:
    virtual ~fuku_mutation() {};

    virtual void obfuscate(fuku_code_holder& code_holder) {};
    virtual void generate_junk(std::vector<uint8_t>& junk, size_t junk_size) {};
};


#include "fuku_mutation_x86.h"
#include "fuku_mutation_x64.h"


```

`furikuri/fuku_mutation_x64.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_mutation_x64.h"

#include "fuku_mutation_x64_rules.h"
#include "fuku_mutation_x64_junk.h"

fuku_mutation_x64::fuku_mutation_x64(const fuku_settings_obfuscation& settings)
: settings(settings){
    f_asm.get_context().arch = FUKU_ASSAMBLER_ARCH_X64;
    cs_open(CS_ARCH_X86, CS_MODE_64, &cap_handle);
    cs_option(cap_handle, CS_OPT_DETAIL, CS_OPT_ON);

    inst_changers = new _fukutate_instruction[X86_INS_ENDING];
    memset(inst_changers, 0, sizeof(_fukutate_instruction) * X86_INS_ENDING);

    init_x64_rules((_fukutate_instruction*)inst_changers);
}

fuku_mutation_x64::~fuku_mutation_x64() {
    
    cs_close(&cap_handle);

    if (inst_changers) {

        delete inst_changers;
    }
}

void fuku_mutation_x64::obfuscate_lines(mutation_context& ctx, inststorage::iterator lines_iter_begin, inststorage::iterator lines_iter_end, unsigned int recurse_idx) {

    for (inststorage::iterator lines_iter = lines_iter_begin; lines_iter != lines_iter_end; ++lines_iter) {

        fukutation(ctx, lines_iter);

        unsigned int recurse_idx_up = 0;
        if (recurse_idx == -1) {
            recurse_idx_up = rand() % settings.get_complexity() + 1;
        }
        else {
            recurse_idx_up = recurse_idx - 1;
        }

        if (recurse_idx_up) {
            auto next_iter = lines_iter; ++next_iter;
            obfuscate_lines(ctx, lines_iter, next_iter, recurse_idx_up);
        }
    }
}

void fuku_mutation_x64::obfuscate(fuku_code_holder& code_holder) {

    mutation_context ctx;
    ctx.f_asm = &this->f_asm;
    ctx.code_holder = &code_holder;
    ctx.instruction = cs_malloc(cap_handle);
    ctx.settings = &settings;

    obfuscate_lines(ctx, code_holder.get_insts().begin(), code_holder.get_insts().end(), -1);

    cs_free(ctx.instruction, 1);
}

void fuku_mutation_x64::fukutation(mutation_context& ctx, inststorage::iterator& lines_iter) {

    if (lines_iter->get_inst_flags() & FUKU_INST_JUNK_CODE) {
        return;
    }

    bool is_chansed_junk = FUKU_GET_CHANCE(settings.get_junk_chance());
    bool is_chansed_mutate = (lines_iter->get_inst_flags() & FUKU_INST_NO_MUTATE) == 0 &&
        FUKU_GET_CHANCE(settings.get_mutate_chance());

    if (!is_chansed_junk &&
        !is_chansed_mutate) {

        return;
    }


    ctx.initialize_context(lines_iter);

    {
        size_t _size = lines_iter->get_oplength();
        const uint8_t* code = lines_iter->get_opcode();
        uint64_t address_ = 0;

        if (!cs_disasm_iter(cap_handle, &code, &_size, &address_, ctx.instruction)) {

            FUKU_DEBUG;
        }

    }

    f_asm.get_context().short_cfg = 0xFF & ~(this->settings.get_asm_cfg() & FUKU_GET_RAND(0, 0xFF));

    bool was_mutated = false;
    bool was_junked = false;

    if (is_chansed_junk) {

        was_junked = fuku_junk(ctx);

        if (was_junked) {
            ctx.update_payload_inst_iter();
        }
    }

    if (is_chansed_mutate) {

        _fukutate_instruction fukutate = ((_fukutate_instruction*)inst_changers)[lines_iter->get_id()];

        if (fukutate) {

            f_asm.set_holder(ctx.code_holder, ASSAMBLER_HOLD_TYPE_FIRST_OVERWRITE)
                .set_position(lines_iter)
                .set_first_emit(true);

            was_mutated = fukutate(ctx);
        }
    }

    if (was_junked || was_mutated) { //move label_idx and source_address to start of instruction's array 

        //reset labels
        if (ctx.original_start_label) {
            ctx.original_start_label->inst->set_label(0);
            ctx.calc_original_inst_iter()->set_label(ctx.original_start_label);
        }

        if (ctx.payload_start_label) {
            ctx.payload_inst_iter->set_label(ctx.payload_start_label);
        }

        //reset source address and flags
        if (ctx.has_source_address || 
            (ctx.settings->is_not_allowed_unstable_stack() == false && ctx.inst_flags & FUKU_INST_BAD_STACK) ) {

            auto& start_inst = ctx.calc_original_inst_iter();


            for (auto current_inst = start_inst; current_inst != ctx.calc_next_inst_iter(); ++current_inst) {

                if (ctx.inst_flags & FUKU_INST_BAD_STACK) {

                    current_inst->set_inst_flags(current_inst->get_inst_flags() | FUKU_INST_BAD_STACK);
                }

                if (ctx.has_source_address) {

                    if (current_inst != start_inst) {
                        current_inst->invalidate_source_address();
                    }
                    else {
                        current_inst->set_source_address(ctx.source_address);
                    }
                }
            }
        }
    }

}

bool fuku_mutation_x64::fuku_junk(mutation_context& ctx) {

    f_asm.set_holder(ctx.code_holder, ASSAMBLER_HOLD_TYPE_NOOVERWRITE)
        .set_position(ctx.payload_inst_iter)
        .set_first_emit(false);

   return fuku_junk_64_generic(ctx);
}

void fuku_mutation_x64::get_junk(
    fuku_code_holder& code_holder, size_t junk_size, bool unstable_stack,
    uint64_t eflags_changes, uint64_t regs_changes) {


    f_asm.set_holder(&code_holder, ASSAMBLER_HOLD_TYPE_NOOVERWRITE)
        .set_position(code_holder.get_insts().end())
        .set_first_emit(true);


    size_t current_size = 0;

    
}
```

`furikuri/fuku_mutation_x64.h`:

```h
#pragma once

#pragma once

class fuku_mutation_x64 :
    public fuku_mutation {

    void* inst_changers;

    csh cap_handle;
    fuku_assambler f_asm;
    fuku_settings_obfuscation settings;

    bool fuku_junk(mutation_context& ctx);

    void fukutation(mutation_context& ctx, inststorage::iterator& lines_iter);
    void obfuscate_lines(mutation_context& ctx, inststorage::iterator lines_iter_begin, inststorage::iterator lines_iter_end, unsigned int recurse_idx);

public:
    fuku_mutation_x64(const fuku_settings_obfuscation& settings);
    ~fuku_mutation_x64();

    void obfuscate(fuku_code_holder& code_holder);

    void get_junk(fuku_code_holder& code_holder, size_t junk_size, bool unstable_stack,
        uint64_t eflags_changes, uint64_t regs_changes);
};

```

`furikuri/fuku_mutation_x64_junk.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_mutation_x64_junk.h"

#define IsAllowedStackOperations (!HAS_FULL_MASK(ctx.inst_flags, FUKU_INST_BAD_STACK))

uint8_t reg_sizes_64[] = {
    1,
    2,
    4,
    8
};

uint8_t reg_sizes_16_64[] = {
    2,
    8
};


//transfer reg1,reg2
//transfer reg1,val
bool junk_64_low_pattern_1(mutation_context & ctx) {


    fuku_type dst;
    fuku_type src;


    switch (FUKU_GET_RAND(0, 7)) {
    case 0: {
        
        uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(0, 2)];

        if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
            reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
            return false;
        }

        if (!get_operand_src_x64(src, INST_ALLOW_REGISTER | INST_ALLOW_IMMEDIATE
            | (dst.get_type() == FUKU_T0_OPERAND ? 0 : INST_ALLOW_OPERAND),
            reg_size, 0)) {
            return false;
        }

        ctx.f_asm->mov(dst, src);
        break;
    }
    case 1: {
        if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
            1, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
            return false;
        }

        ctx.f_asm->setcc(fuku_condition(FUKU_GET_RAND(0, 15)), dst);
        break;
    }
    case 2: {
        uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(1, 3)];

        if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER,
            reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
            return false;
        }

        if (!get_operand_src_x64(src, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
            reg_size, 0)) {
            return false;
        }

        ctx.f_asm->cmovcc(fuku_condition(FUKU_GET_RAND(0, 15)), dst, src);
        break;
    }
    case 3: {
        uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(0, 3)];

        if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER,
            reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
            return false;
        }

        if (!get_operand_dst_x64(src, INST_ALLOW_REGISTER
            | (dst.get_type() == FUKU_T0_OPERAND ? 0 : INST_ALLOW_OPERAND),
            reg_size, ctx.cpu_registers, 0)) {
            return false;
        }

        ctx.f_asm->xchg(dst, src);
        break;
    }
    case 4: {

        uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(1, 3)];

        if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER,
            reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
            return false;
        }

        if (reg_size != 2) {
            reg_size = reg_sizes_64[FUKU_GET_RAND(0, 1)];
        }
        else {
            reg_size = 1;
        }

        if (!get_operand_src_x64(src, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
            reg_size, 0)) {
            return false;
        }

        ctx.f_asm->movzx(dst, src);
        break;
    }
    case 5: {
        uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(1, 3)];

        if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER,
            reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
            return false;
        }

        if (reg_size != 2) {
            reg_size = reg_sizes_64[FUKU_GET_RAND(0, 1)];
        }
        else {
            reg_size = 1;
        }

        if (!get_operand_src_x64(src, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
            reg_size, 0)) {
            return false;
        }

        ctx.f_asm->movsx(dst, src);
        break;
    }
    case 6: { return false;
        uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(1, 3)];

        if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER,
            reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
            return false;
        }
        
        if (!get_operand_src_x64(src, INST_ALLOW_REGISTER
            | (dst.get_type() == FUKU_T0_OPERAND ? 0 : INST_ALLOW_OPERAND),
            reg_size, 0)) {
            return false;
        }

        ctx.f_asm->movsxd(dst, src);
        break;
    }
    case 7: {
        uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(1, 2)];
        
        if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER,
            reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
            return false;
        }

        ctx.f_asm->bswap(dst);
        break;
    }
    }


    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);


    return true;
}


//logical reg1,reg2
//logical reg1,val
bool junk_64_low_pattern_2(mutation_context & ctx) {


    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_ZF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_CF | X86_EFLAGS_MODIFY_PF)) {

        return false;
    }


    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(0, 3)];

    if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
        return false;
    }

    bool has_src = get_operand_src_x64(src, INST_ALLOW_REGISTER | INST_ALLOW_IMMEDIATE
        | (dst.get_type() == FUKU_T0_OPERAND ? 0 : INST_ALLOW_OPERAND),
        reg_size, 0);

    switch (FUKU_GET_RAND(has_src ? 0 : 4, 4)) {

    case 0: {
        ctx.f_asm->xor_(dst, src);
        break;
    }
    case 1: {
        ctx.f_asm->and_(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->or_(dst, src);
        break;
    }
    case 3: {
        ctx.f_asm->test(dst, src);
        break;
    }
    case 4: {
        ctx.f_asm->not_(dst);
        break;
    }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//arithmetic reg1,reg2
//arithmetic reg1,val
bool junk_64_low_pattern_3(mutation_context & ctx) {


    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_ZF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_CF | X86_EFLAGS_MODIFY_PF)) {

        return false;
    }

    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(0, 3)];

    if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
        return false;
    }

    bool has_src = get_operand_src_x64(src, INST_ALLOW_REGISTER | INST_ALLOW_IMMEDIATE
        | (dst.get_type() == FUKU_T0_OPERAND ? 0 : INST_ALLOW_OPERAND),
        reg_size, 0);

    switch (FUKU_GET_RAND(has_src ? 0 : 5, 7)) {

    case 0: {
        ctx.f_asm->add(dst, src);
        break;
    }
    case 1: {
        ctx.f_asm->adc(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->sub(dst, src);
        break;
    }
    case 3: {
        ctx.f_asm->sbb(dst, src);
        break;
    }
    case 4: {
        ctx.f_asm->cmp(dst, src);
        break;
    }
    case 5: {
        ctx.f_asm->inc(dst);
        break;
    }
    case 6: {
        ctx.f_asm->dec(dst);
        break;
    }
    case 7: {
        ctx.f_asm->neg(dst);
        break;
    }
    default: {return false; }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);


    return true;
}


//rotate reg1,val
//rotate reg1,cl
bool junk_64_low_pattern_4(mutation_context & ctx) {


    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_CF)) {

        return false;
    }

    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(0, 3)];

    if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
        return false;
    }


    if (FUKU_GET_RAND(0, 1)) {
        src = fuku_register(FUKU_REG_CL);
    }
    else {
        src = fuku_immediate(FUKU_GET_RAND(1, reg_size * 16 - 1));
    }

    switch (FUKU_GET_RAND(0, 3)) {

    case 0: {
        ctx.f_asm->rol(dst, src);
        break;
    }
    case 1: {
        ctx.f_asm->ror(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->rcl(dst, src);
        break;
    }
    case 3: {
        ctx.f_asm->rcr(dst, src);
        break;
    }
    default: {return false; }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//shift reg1,val
//shift reg1,reg
bool junk_64_low_pattern_5(mutation_context & ctx) {


    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_ZF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_PF | X86_EFLAGS_MODIFY_CF)) {

        return false;
    }


    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(0, 2)];

    if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
        return false;
    }

    if (FUKU_GET_RAND(0, 1)) {
        src = fuku_register(FUKU_REG_CL);
    }
    else {
        src = fuku_immediate(FUKU_GET_RAND(1, reg_size * 16 - 1));
    }

    switch (FUKU_GET_RAND(0, 2)) {

    case 0: {
        ctx.f_asm->sar(dst, src);
        break;
    }

    case 1: {
        ctx.f_asm->shl(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->shr(dst, src);
        break;
    }
    default: {return false; }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}



//bittest reg1,val
//bittest reg1,reg
bool junk_64_low_pattern_6(mutation_context & ctx) {

    
    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_PF | X86_EFLAGS_MODIFY_CF)) {

        return false;
    }

    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(1, 3)];

    if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
        return false;
    }

    if (!get_operand_src_x64(src, INST_ALLOW_REGISTER | INST_ALLOW_IMMEDIATE,
        1, 0)) {
        return false;
    }
    switch (FUKU_GET_RAND(0, 3)) {

    case 0: {
        ctx.f_asm->bt(dst, src);
        break;
    }
    case 1: {
        ctx.f_asm->btc(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->bts(dst, src);
        break;
    }
    case 3: {
        ctx.f_asm->btr(dst, src);
        break;
    }

    default: {return false; }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//convert byte\word to word\dword
bool junk_64_low_pattern_7(mutation_context & ctx) {

    uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(1, 3)];

    fuku_type dst;

    if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER,
        reg_size, ctx.cpu_registers,
        FLAG_REGISTER_AL |
        FLAG_REGISTER_RCX | FLAG_REGISTER_ECX | FLAG_REGISTER_CX | FLAG_REGISTER_CL |
        FLAG_REGISTER_DL |
        FLAG_REGISTER_RBX | FLAG_REGISTER_EBX | FLAG_REGISTER_BX | FLAG_REGISTER_BL |
        FLAG_REGISTER_RSP | FLAG_REGISTER_ESP | FLAG_REGISTER_SP | FLAG_REGISTER_SPL |
        FLAG_REGISTER_RBP | FLAG_REGISTER_EBP | FLAG_REGISTER_BP | FLAG_REGISTER_BPL |
        FLAG_REGISTER_RSI | FLAG_REGISTER_ESI | FLAG_REGISTER_SI | FLAG_REGISTER_SIL |
        FLAG_REGISTER_RDI | FLAG_REGISTER_EDI | FLAG_REGISTER_DI | FLAG_REGISTER_DIL)) {
        return false;
    }


    if (dst.get_register().get_reg() == FUKU_REG_NONE) {
        return false;
    }


    switch (dst.get_register().get_reg()) {
    case FUKU_REG_AX: {
        ctx.f_asm->cbw();
        break;
    }
    case FUKU_REG_EAX: {
        ctx.f_asm->cwde();
        break;
    }
    case FUKU_REG_RAX: {
        ctx.f_asm->cdqe();
        break;
    }
    case FUKU_REG_DX: {
        if (!has_flag_free_register(ctx.cpu_registers, FLAG_REGISTER_AX)) { return false; }
        ctx.f_asm->cwd();
        break;
    }
    case FUKU_REG_EDX: {
        if (!has_flag_free_register(ctx.cpu_registers, FLAG_REGISTER_EAX)) { return false; }
        ctx.f_asm->cdq();
        break;
    }
    case FUKU_REG_RDX: {
        if (!has_flag_free_register(ctx.cpu_registers, FLAG_REGISTER_RAX)) { return false; }
        ctx.f_asm->cqo();
        break;
    }
    default: {return false; }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//set / reset flag
bool junk_64_low_pattern_8(mutation_context & ctx) {


    switch (FUKU_GET_RAND(0, 4)) {

    case 0: {
        if (!has_inst_free_eflags(ctx.cpu_flags, X86_EFLAGS_MODIFY_CF)) { return false; }
        ctx.f_asm->stc();
        break;
    }
    case 1: {
        if (!has_inst_free_eflags(ctx.cpu_flags, X86_EFLAGS_MODIFY_CF)) { return false; }
        ctx.f_asm->clc();
        break;
    }
    case 2: {
        if (!has_inst_free_eflags(ctx.cpu_flags, X86_EFLAGS_MODIFY_CF)) { return false; }
        ctx.f_asm->cmc();
        break;
    }
    case 3: {
        if (!has_inst_free_eflags(ctx.cpu_flags, X86_EFLAGS_MODIFY_DF)) { return false; }
        ctx.f_asm->cld();
        break;
    }
    case 4: {
        if (!has_inst_free_eflags(ctx.cpu_flags, X86_EFLAGS_MODIFY_DF)) { return false; }
        ctx.f_asm->std();
        break;
    }
    default: {return false; }
    }


    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}

//inc reg
//neg reg
//inc reg
//neg reg
bool junk_64_high_pattern_1(mutation_context & ctx) {

    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_ZF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_CF | X86_EFLAGS_MODIFY_PF)) {

        return false;
    }

    fuku_type dst;

    uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(0, 3)];

    if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
        return false;
    }

    ctx.f_asm->inc(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);
    ctx.f_asm->neg(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);
    ctx.f_asm->inc(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);
    ctx.f_asm->neg(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}

//not reg1
//not reg1
bool junk_64_high_pattern_2(mutation_context & ctx) {//what the hell rex64 "not" clear high 32 bits of 64 bits register all time

    fuku_type dst;

    uint32_t reg_size = reg_sizes_64[FUKU_GET_RAND(0, 3)];

    if (!get_operand_dst_x64(dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
        return false;
    }

    ctx.f_asm->not_(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);
    ctx.f_asm->not_(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}



//push reg1
//pop  reg1
bool junk_64_high_pattern_3(mutation_context & ctx) {

    if (!IsAllowedStackOperations) {
        return false;
    }

    fuku_type src;

    uint32_t reg_size = reg_sizes_16_64[FUKU_GET_RAND(0, 1)];

    if (!get_operand_src_x64(src, INST_ALLOW_REGISTER,
        reg_size, FLAG_REGISTER_SPL | FLAG_REGISTER_SP | FLAG_REGISTER_ESP | FLAG_REGISTER_RSP)) {
        return false;
    }

    uint64_t flag_reg = get_flag_complex_by_fuku_register(src.get_register().get_reg(), reg_size);


    ctx.f_asm->push(src);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    ctx.f_asm->pop(src);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers | flag_reg);

    return true;
}


//jcc next_inst
bool junk_64_high_pattern_4(mutation_context & ctx) {

    if (ctx.is_next_last_inst) {
        return false;
    }

    uint8_t cond = FUKU_GET_RAND(0, 15);

    ctx.f_asm->jcc(fuku_condition(cond), imm(-1));

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers)
        .set_rip_reloc(
            ctx.code_holder->create_rip_relocation(
                fuku_rip_relocation()
                .set_label(
                    ctx.generate_payload_label()
                )
                .set_offset(ctx.f_asm->get_context().immediate_offset)
            )
        );


    return true;
}


//jmp next_inst
//some code trash
bool junk_64_high_pattern_5(mutation_context & ctx) {

    if (ctx.is_next_last_inst) {
        return false;
    }

    ctx.f_asm->jmp(imm(-1));
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers)
        .set_rip_reloc(
            ctx.code_holder->create_rip_relocation(
                fuku_rip_relocation()
                .set_label(
                    ctx.generate_payload_label()
                )
                .set_offset(ctx.f_asm->get_context().immediate_offset)
            )
        );

    std::vector<uint8_t> trash;

    for (uint8_t t_size = 0; t_size < FUKU_GET_RAND(1, 15); t_size++) {
        trash.push_back(FUKU_GET_RAND(0, 0xFF));
    }

    ctx.f_asm->nop();
    ctx.f_asm->get_context().inst->set_opcode(trash.data(), (uint8_t)trash.size())
        .set_inst_flags(FUKU_INST_JUNK_CODE);

    return true;
}



bool fuku_junk_64_generic_low(mutation_context & ctx) {

    switch (FUKU_GET_RAND(0, 7)) {
    case 0: {
        return junk_64_low_pattern_1(ctx);
    }
    case 1: {
        return junk_64_low_pattern_2(ctx);
    }
    case 2: {
        return junk_64_low_pattern_3(ctx);
    }
    case 3: {
        return junk_64_low_pattern_4(ctx);
    }
    case 4: {
        return junk_64_low_pattern_5(ctx);
    }
    case 5: {
        return junk_64_low_pattern_6(ctx);
    }
    case 6: {
        return junk_64_low_pattern_7(ctx);
    }
    case 7: {
        return junk_64_low_pattern_8(ctx);
    }
    }

    return false;
}


bool fuku_junk_64_generic_high(mutation_context & ctx) {

    switch (FUKU_GET_RAND(0, 4)) {
    case 0: {
        return junk_64_high_pattern_1(ctx);
    }
    case 1: {
        return junk_64_high_pattern_2(ctx);
    }
    case 2: {
        return junk_64_high_pattern_3(ctx);
    }
    case 3: {
        return junk_64_high_pattern_4(ctx);
    }
    case 4: {
        return junk_64_high_pattern_5(ctx);
    }
    }

    return false;
}

bool fuku_junk_64_generic(mutation_context & ctx) {

    switch (FUKU_GET_RAND(0, 3)) {
    case 0:
    case 1: {

        return fuku_junk_64_generic_low(ctx);
    }
    case 2:
    case 3: {

        return fuku_junk_64_generic_high(ctx);
    }
    }

    return false;
}


```

`furikuri/fuku_mutation_x64_junk.h`:

```h
#pragma once

//junk generation
bool fuku_junk_64_generic(mutation_context & ctx);

```

`furikuri/fuku_mutation_x64_rules.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_mutation_x64_rules.h"

#define IsAllowedStackOperations (!HAS_FULL_MASK(ctx.inst_flags, FUKU_INST_BAD_STACK))

static uint64_t di_fl_jcc[] = {
    EFLAGS_MOD_OF , EFLAGS_MOD_OF, //jo   / jno
    EFLAGS_MOD_CF , EFLAGS_MOD_CF, //jb   / jae
    EFLAGS_MOD_ZF , EFLAGS_MOD_ZF, //je   / jne
    EFLAGS_MOD_ZF | EFLAGS_MOD_CF, EFLAGS_MOD_ZF | EFLAGS_MOD_CF, //jbe / jnbe
    EFLAGS_MOD_SF , EFLAGS_MOD_SF, //js   / jns
    EFLAGS_MOD_PF , EFLAGS_MOD_PF, //jp   / jnp
    EFLAGS_MOD_OF | EFLAGS_MOD_SF, EFLAGS_MOD_OF | EFLAGS_MOD_SF, //jnge / jge
    EFLAGS_MOD_OF | EFLAGS_MOD_SF | EFLAGS_MOD_ZF, EFLAGS_MOD_OF | EFLAGS_MOD_SF | EFLAGS_MOD_ZF //jng / jnle
};

#define restore_disp_relocate(op) \
           if (op.get_type() == FUKU_T0_OPERAND && reloc_disp && used_disp_reloc) {\
                ctx.f_asm->get_context().inst->\
                set_disp_reloc(reloc_disp);\
                reloc_disp->offset = ctx.f_asm->get_context().displacment_offset;\
           }

#define restore_imm_relocate(op) \
           if (inst_size == 8 && op.get_type() == FUKU_T0_IMMEDIATE && reloc_imm) {\
                ctx.f_asm->get_context().inst->\
                set_imm_reloc(reloc_imm);\
                reloc_imm->offset = ctx.f_asm->get_context().immediate_offset;\
           }

#define restore_rip_relocate_in_imm(op) \
           if (inst_size == 8 && op.get_type() == FUKU_T0_IMMEDIATE && reloc_rip && !used_disp_reloc) {\
                ctx.f_asm->get_context().inst->\
                set_rip_reloc(reloc_rip);\
                reloc_rip->offset = ctx.f_asm->get_context().immediate_offset;\
           }

#define restore_rip_relocate_in_disp(op) \
           if (inst_size == 8 && op.get_type() == FUKU_T0_OPERAND && reloc_rip && !used_disp_reloc) {\
                ctx.f_asm->get_context().inst->\
                set_rip_reloc(reloc_rip);\
                reloc_rip->offset = ctx.f_asm->get_context().displacment_offset;\
           }

#define restore_rip_to_imm_relocate(op) \
           if (op.get_type() == FUKU_T0_IMMEDIATE && reloc_rip && !used_disp_reloc) {\
                ctx.f_asm->get_context().inst->set_imm_reloc(\
                    ctx.code_holder->create_relocation(fuku_relocation()\
                        .set_label(reloc_rip->label)\
                        .set_offset(ctx.f_asm->get_context().immediate_offset)\
                    )\
                );\
                ctx.code_holder->release_rip_relocation(reloc_rip);\
           }

#define restore_rip_to_disp_relocate(op) \
           if (op.get_type() == FUKU_T0_OPERAND && reloc_rip && !used_disp_reloc) {\
                ctx.f_asm->get_context().inst->set_disp_reloc(\
                    ctx.code_holder->create_relocation(fuku_relocation()\
                        .set_label(reloc_rip->label)\
                        .set_offset(ctx.f_asm->get_context().displacment_offset)\
                    )\
                );\
                ctx.code_holder->release_rip_relocation(reloc_rip);\
           }

#define restore_imm_or_disp(op)         restore_disp_relocate(op) else restore_imm_relocate(op)
#define restore_rip_imm_or_disp(op)     restore_rip_relocate_in_imm(op) else restore_disp_relocate(op)
#define restore_rip_to_imm_or_disp(op)  restore_rip_to_imm_relocate(op) else restore_rip_to_disp_relocate(op)

#include "obf_templates/x64/obf_x64_mov_templates.h"
#include "obf_templates/x64/obf_x64_xchg_templates.h"
#include "obf_templates/x64/obf_x64_push_templates.h"
#include "obf_templates/x64/obf_x64_pop_templates.h"
#include "obf_templates/x64/obf_x64_lea_templates.h"

#include "obf_templates/x64/obf_x64_jcc_templates.h"
#include "obf_templates/x64/obf_x64_jmp_templates.h"
#include "obf_templates/x64/obf_x64_call_templates.h"
#include "obf_templates/x64/obf_x64_ret_templates.h"

#include "obf_templates/x64/obf_x64_add_templates.h"
#include "obf_templates/x64/obf_x64_sub_templates.h"
#include "obf_templates/x64/obf_x64_adc_templates.h"
#include "obf_templates/x64/obf_x64_sbb_templates.h"
#include "obf_templates/x64/obf_x64_cmp_templates.h"
#include "obf_templates/x64/obf_x64_neg_templates.h"
#include "obf_templates/x64/obf_x64_inc_templates.h"
#include "obf_templates/x64/obf_x64_dec_templates.h"
#include "obf_templates/x64/obf_x64_mul_templates.h"
#include "obf_templates/x64/obf_x64_imul_templates.h"
#include "obf_templates/x64/obf_x64_div_templates.h"
#include "obf_templates/x64/obf_x64_idiv_templates.h"

#include "obf_templates/x64/obf_x64_and_templates.h"
#include "obf_templates/x64/obf_x64_or_templates.h"
#include "obf_templates/x64/obf_x64_xor_templates.h"
#include "obf_templates/x64/obf_x64_test_templates.h"
#include "obf_templates/x64/obf_x64_not_templates.h"

#include "obf_templates/x64/obf_x64_ror_templates.h"
#include "obf_templates/x64/obf_x64_rol_templates.h"
#include "obf_templates/x64/obf_x64_rcl_templates.h"
#include "obf_templates/x64/obf_x64_rcr_templates.h"
#include "obf_templates/x64/obf_x64_shl_templates.h"
#include "obf_templates/x64/obf_x64_shr_templates.h"
#include "obf_templates/x64/obf_x64_sar_templates.h"

#include "obf_templates/x64/obf_x64_bt_templates.h"
#include "obf_templates/x64/obf_x64_bts_templates.h"
#include "obf_templates/x64/obf_x64_btr_templates.h"
#include "obf_templates/x64/obf_x64_btc_templates.h"
#include "obf_templates/x64/obf_x64_bsf_templates.h"
#include "obf_templates/x64/obf_x64_bsr_templates.h"



void init_x64_rules(_fukutate_instruction* rules) {

    rules[X86_INS_JMP] = fukutate_64_jmp;
    rules[X86_INS_CALL] = fukutate_64_call;
    rules[X86_INS_JO] = fukutate_64_jcc;
    rules[X86_INS_JNO] = fukutate_64_jcc;
    rules[X86_INS_JB] = fukutate_64_jcc;
    rules[X86_INS_JAE] = fukutate_64_jcc;
    rules[X86_INS_JE] = fukutate_64_jcc;
    rules[X86_INS_JNE] = fukutate_64_jcc;
    rules[X86_INS_JBE] = fukutate_64_jcc;
    rules[X86_INS_JA] = fukutate_64_jcc;
    rules[X86_INS_JS] = fukutate_64_jcc;
    rules[X86_INS_JNS] = fukutate_64_jcc;
    rules[X86_INS_JP] = fukutate_64_jcc;
    rules[X86_INS_JNP] = fukutate_64_jcc;
    rules[X86_INS_JL] = fukutate_64_jcc;
    rules[X86_INS_JGE] = fukutate_64_jcc;
    rules[X86_INS_JLE] = fukutate_64_jcc;
    rules[X86_INS_JG] = fukutate_64_jcc;
    rules[X86_INS_RET] = fukutate_64_ret;

    rules[X86_INS_MOV] = fukutate_64_mov;
    rules[X86_INS_XCHG] = fukutate_64_xchg;
    rules[X86_INS_LEA] = fukutate_64_lea;
    rules[X86_INS_PUSH] = fukutate_64_push;
    rules[X86_INS_POP] = fukutate_64_pop;

    //ARITHMETIC
    rules[X86_INS_ADD] = fukutate_64_add;
    rules[X86_INS_OR] = fukutate_64_or;
    rules[X86_INS_ADC] = fukutate_64_adc;
    rules[X86_INS_SBB] = fukutate_64_sbb;
    rules[X86_INS_AND] = fukutate_64_and;
    rules[X86_INS_SUB] = fukutate_64_sub;
    rules[X86_INS_XOR] = fukutate_64_xor;
    rules[X86_INS_CMP] = fukutate_64_cmp;
    rules[X86_INS_INC] = fukutate_64_inc;
    rules[X86_INS_DEC] = fukutate_64_dec;
    rules[X86_INS_TEST] = fukutate_64_test;
    rules[X86_INS_NOT] = fukutate_64_not;
    rules[X86_INS_NEG] = fukutate_64_neg;
    rules[X86_INS_MUL] = fukutate_64_mul;
    rules[X86_INS_IMUL] = fukutate_64_imul;
    rules[X86_INS_DIV] = fukutate_64_div;
    rules[X86_INS_IDIV] = fukutate_64_idiv;

    //SHIFT
    rules[X86_INS_ROL] = fukutate_64_rol;
    rules[X86_INS_ROR] = fukutate_64_ror;
    rules[X86_INS_RCL] = fukutate_64_rcl;
    rules[X86_INS_RCR] = fukutate_64_rcr;
    rules[X86_INS_SAL] = fukutate_64_shl;//SAL is too SHL
    rules[X86_INS_SHL] = fukutate_64_shl;
    rules[X86_INS_SHR] = fukutate_64_shr;
    rules[X86_INS_SAR] = fukutate_64_sar;

    //BITTEST
    rules[X86_INS_BT] = fukutate_64_bt;
    rules[X86_INS_BTS] = fukutate_64_bts;
    rules[X86_INS_BTR] = fukutate_64_btr;
    rules[X86_INS_BTC] = fukutate_64_btc;
    rules[X86_INS_BSF] = fukutate_64_bsf;
    rules[X86_INS_BSR] = fukutate_64_bsr;
}
```

`furikuri/fuku_mutation_x64_rules.h`:

```h
#pragma once

void init_x64_rules(_fukutate_instruction* rules);
```

`furikuri/fuku_mutation_x86.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_mutation_x86.h"

#include "fuku_mutation_x86_rules.h"
#include "fuku_mutation_x86_junk.h"

fuku_mutation_x86::fuku_mutation_x86(const fuku_settings_obfuscation& settings)
: settings(settings), inst_changers(0) {
    f_asm.get_context().arch = FUKU_ASSAMBLER_ARCH_X86;
    cs_open(CS_ARCH_X86, CS_MODE_32, &cap_handle);
    cs_option(cap_handle, CS_OPT_DETAIL, CS_OPT_ON);

    inst_changers = new _fukutate_instruction[X86_INS_ENDING];
    memset(inst_changers, 0, sizeof(_fukutate_instruction) * X86_INS_ENDING);

    init_x86_rules((_fukutate_instruction*)inst_changers);
}

fuku_mutation_x86::~fuku_mutation_x86() {
    cs_close(&cap_handle);

    if (inst_changers) {

        delete inst_changers;
    }
}

void fuku_mutation_x86::obfuscate_lines(mutation_context& ctx, inststorage::iterator lines_iter_begin, inststorage::iterator lines_iter_end, unsigned int recurse_idx) {

    for (inststorage::iterator lines_iter = lines_iter_begin; lines_iter != lines_iter_end; ++lines_iter) {

        fukutation(ctx, lines_iter);

        unsigned int recurse_idx_up = 0;

        if (recurse_idx == -1) {
            recurse_idx_up = rand() % settings.get_complexity() + 1;
        }
        else {
            recurse_idx_up = recurse_idx - 1;
        }

        if (recurse_idx_up) {
            auto next_iter = lines_iter; ++next_iter;
            obfuscate_lines(ctx, lines_iter, next_iter, recurse_idx_up);
        }
    }
}

void fuku_mutation_x86::obfuscate(fuku_code_holder& code_holder) {

    mutation_context ctx;
    ctx.f_asm = &this->f_asm;
    ctx.code_holder = &code_holder;
    ctx.instruction = cs_malloc(cap_handle);
    ctx.settings = &settings;

    obfuscate_lines(ctx, code_holder.get_insts().begin(), code_holder.get_insts().end(), -1);

    cs_free(ctx.instruction, 1);
}




void fuku_mutation_x86::fukutation(mutation_context& ctx, inststorage::iterator lines_iter) {

    if (lines_iter->get_inst_flags() & FUKU_INST_JUNK_CODE) {
        return;
    }

    bool is_chansed_junk = FUKU_GET_CHANCE(settings.get_junk_chance());
    bool is_chansed_mutate = (lines_iter->get_inst_flags() & FUKU_INST_NO_MUTATE) == 0 &&
        FUKU_GET_CHANCE(settings.get_mutate_chance());

    if (!is_chansed_junk &&
        !is_chansed_mutate) {

        return;
    }


    ctx.initialize_context(lines_iter);

    {
        size_t _size = lines_iter->get_oplength();
        const uint8_t* code = lines_iter->get_opcode();
        uint64_t address_ = 0;

        if (!cs_disasm_iter(cap_handle, &code, &_size, &address_, ctx.instruction)) {

            FUKU_DEBUG;
        }

    }

    f_asm.get_context().short_cfg = 0xFF & ~(this->settings.get_asm_cfg() & FUKU_GET_RAND(0, 0xFF));

    bool was_mutated = false;
    bool was_junked = false;

    if (is_chansed_junk) {

        was_junked = fuku_junk(ctx);

        if (was_junked) {
            ctx.update_payload_inst_iter();
        }
    }
    
    if (is_chansed_mutate) {

        _fukutate_instruction fukutate = ((_fukutate_instruction*)inst_changers)[lines_iter->get_id()];

        if (fukutate) {

            f_asm.set_holder(ctx.code_holder, ASSAMBLER_HOLD_TYPE_FIRST_OVERWRITE)
                .set_position(lines_iter)
                .set_first_emit(true);

            was_mutated = fukutate(ctx);
        }
    }
   
    if(was_junked || was_mutated) { //move label_idx and source_address to start of instruction's array 

        //reset labels
        if (ctx.original_start_label) {
            ctx.original_start_label->inst->set_label(0);
            ctx.calc_original_inst_iter()->set_label(ctx.original_start_label);
        }

        if (ctx.payload_start_label) {           
            ctx.payload_inst_iter->set_label(ctx.payload_start_label);
        }

        //reset source address and flags
        if (ctx.has_source_address || ctx.inst_flags & FUKU_INST_BAD_STACK) {

            auto& start_inst = ctx.calc_original_inst_iter();

         
            for (auto current_inst = start_inst; current_inst != ctx.calc_next_inst_iter(); ++current_inst) {

                if (ctx.inst_flags & FUKU_INST_BAD_STACK) {

                    current_inst->set_inst_flags(current_inst->get_inst_flags() | FUKU_INST_BAD_STACK);
                }

                if (ctx.has_source_address) {

                    if (current_inst != start_inst) {
                        current_inst->invalidate_source_address();
                    }
                    else {
                        current_inst->set_source_address(ctx.source_address);
                    }
                }
            }
        }
    }
    
}

bool fuku_mutation_x86::fuku_junk(mutation_context& ctx) {
   
    f_asm.set_holder(ctx.code_holder, ASSAMBLER_HOLD_TYPE_NOOVERWRITE)
        .set_position(ctx.original_inst_iter)
        .set_first_emit(false);

    return fuku_junk_86_generic(ctx);
}

void fuku_mutation_x86::get_junk(
    fuku_code_holder& code_holder, size_t junk_size, bool unstable_stack,
    uint64_t eflags_changes, uint64_t regs_changes) {

    f_asm.get_context().short_cfg = 0xFF;
    f_asm.set_holder(&code_holder, ASSAMBLER_HOLD_TYPE_NOOVERWRITE)
        .set_position(code_holder.get_insts().end())
        .set_first_emit(true);


    size_t current_size = 0;

  
}
```

`furikuri/fuku_mutation_x86.h`:

```h
#pragma once

class fuku_mutation_x86 : 
    public fuku_mutation {

    void* inst_changers;

    csh cap_handle;
    fuku_assambler f_asm;
    fuku_settings_obfuscation settings;

    bool fuku_junk(mutation_context& ctx);

    void fukutation(mutation_context& ctx, inststorage::iterator lines_iter);
    void obfuscate_lines(mutation_context& ctx, inststorage::iterator lines_iter_begin, inststorage::iterator lines_iter_end, unsigned int recurse_idx);

public:
    fuku_mutation_x86(const fuku_settings_obfuscation& settings);
    ~fuku_mutation_x86();

    void obfuscate(fuku_code_holder& code_holder);

    void get_junk(fuku_code_holder& code_holder, size_t junk_size, bool unstable_stack, 
        uint64_t eflags_changes, uint64_t regs_changes);
};
```

`furikuri/fuku_mutation_x86_junk.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_mutation_x86_junk.h"

#define IsAllowedStackOperations (!HAS_FULL_MASK(ctx.inst_flags, FUKU_INST_BAD_STACK))

uint8_t reg_sizes[] = {
    1,
    2,
    4
};


//transfer reg1,reg2
//transfer reg1,val
bool junk_86_low_pattern_1(mutation_context & ctx) {

    fuku_type dst;
    fuku_type src;

    switch (FUKU_GET_RAND(0, 6)) {
        case 0: {
            
            uint32_t reg_size = reg_sizes[FUKU_GET_RAND(0, 2)];

            if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
                reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
                return false;
            }

            if (!get_operand_src_x86( src, INST_ALLOW_REGISTER | INST_ALLOW_IMMEDIATE
                | (dst.get_type() == FUKU_T0_OPERAND ? 0 : INST_ALLOW_OPERAND),
                reg_size, 0)) {
                return false;
            }

            ctx.f_asm->mov(dst, src);
            break;
        }
        case 1: {

            if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
                1, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
                return false;
            }

            ctx.f_asm->setcc(fuku_condition(FUKU_GET_RAND(0, 15)), dst);
            break;
        }
        case 2: {
            uint32_t reg_size = reg_sizes[FUKU_GET_RAND(1, 2)];

            if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER,
                reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
                return false;
            }

            if (!get_operand_src_x86( src, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
                reg_size, 0)) {
                return false;
            }

            ctx.f_asm->cmovcc(fuku_condition(FUKU_GET_RAND(0, 15)), dst, src);
            break;
        }
        case 3: {
            uint32_t reg_size = reg_sizes[FUKU_GET_RAND(0, 2)];

            if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER,
                reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
                return false;
            }

            if (!get_operand_dst_x86( src, INST_ALLOW_REGISTER
                | (dst.get_type() == FUKU_T0_OPERAND ? 0 : INST_ALLOW_OPERAND),
                reg_size, ctx.cpu_registers, 0)) {
                return false;
            }

            ctx.f_asm->xchg(dst, src);
            break;
        }
        case 4: {

            uint32_t reg_size = reg_sizes[FUKU_GET_RAND(1, 2)];

            if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER,
                reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
                return false;
            }

            if (reg_size != 2) {
                reg_size = reg_sizes[FUKU_GET_RAND(0, 1)];
            }
            else {
                reg_size = 1;
            }

            if (!get_operand_src_x86( src, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
                reg_size, 0)) {
                return false;
            }

            ctx.f_asm->movzx(dst, src);
            break;
        }
        case 5: {
            uint32_t reg_size = reg_sizes[FUKU_GET_RAND(1, 2)];

            if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER,
                reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
                return false;
            }

            if (reg_size != 2) {
                reg_size = reg_sizes[FUKU_GET_RAND(0, 1)];
            }
            else {
                reg_size = 1;
            }

            if (!get_operand_src_x86( src, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
                reg_size, 0)) {
                return false;
            }

            ctx.f_asm->movsx(dst, src);
            break;
        }
        case 6: {
            uint32_t reg_size = reg_sizes[FUKU_GET_RAND(2, 3)];

            if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER,
                reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
                return false;
            }

            ctx.f_asm->bswap(dst);
            break;
        }
    }


    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//logical reg1,reg2
//logical reg1,val
bool junk_86_low_pattern_2(mutation_context & ctx) {


    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_ZF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_CF | X86_EFLAGS_MODIFY_PF)) {

        return false;
    }


    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes[FUKU_GET_RAND(0, 2)];

    if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
        return false;
    }

    bool has_src = get_operand_src_x86( src, INST_ALLOW_REGISTER | INST_ALLOW_IMMEDIATE
        | (dst.get_type() == FUKU_T0_OPERAND ? 0 : INST_ALLOW_OPERAND),
        reg_size, 0);

    switch (FUKU_GET_RAND(has_src ? 0 : 4, 4)) {

    case 0: {
        ctx.f_asm->xor_(dst, src);
        break;
    }
    case 1: {
        ctx.f_asm->and_(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->or_(dst, src);
        break;
    }
    case 3: {
        ctx.f_asm->test(dst, src);
        break;
    }
    case 4: {
       ctx.f_asm->not_(dst);
        break;
    }
    default: {return false; }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//arithmetic reg1,reg2
//arithmetic reg1,val
bool junk_86_low_pattern_3(mutation_context & ctx) {

    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_ZF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_CF | X86_EFLAGS_MODIFY_PF)) {
        return false;
    }

    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes[FUKU_GET_RAND(0, 2)];

    if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
        return false;
    }

    bool has_src = get_operand_src_x86( src, INST_ALLOW_REGISTER | INST_ALLOW_IMMEDIATE
        | (dst.get_type() == FUKU_T0_OPERAND ? 0 : INST_ALLOW_OPERAND),
        reg_size, 0);

    switch (FUKU_GET_RAND(has_src ? 0 : 5, 7)) {

    case 0: {
        ctx.f_asm->add(dst, src);
        break;
    }
    case 1: {
        ctx.f_asm->adc(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->sub(dst, src);
        break;
    }
    case 3: {
        ctx.f_asm->sbb(dst, src);
        break;
    }
    case 4: {
        ctx.f_asm->cmp(dst, src);
        break;
    }
    case 5: {
        ctx.f_asm->inc(dst);
        break;
    }
    case 6: {
        ctx.f_asm->dec(dst);
        break;
    }
    case 7: {
        ctx.f_asm->neg(dst);
        break;
    }
    default: {return false; }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//rotate reg1,val
//rotate reg1,cl
bool junk_86_low_pattern_4(mutation_context & ctx) {


    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_CF)) {

        return false;
    }


    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes[FUKU_GET_RAND(0, 2)];

    if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
        return false;
    }


    if (FUKU_GET_RAND(0, 1)) {
        src = fuku_register(FUKU_REG_CL);
    }
    else {
        src = fuku_immediate(FUKU_GET_RAND(1, reg_size * 16 - 1));
    }

    switch (FUKU_GET_RAND(0, 3)) {

    case 0: {
       ctx.f_asm->rol(dst, src);
        break;
    }
    case 1: {
        ctx.f_asm->ror(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->rcl(dst, src);
        break;
    }
    case 3: {
        ctx.f_asm->rcr(dst, src);
        break;
    }
    default: {return false; }
    }


    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//shift reg1,val
//shift reg1,reg
bool junk_86_low_pattern_5(mutation_context & ctx) {


    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_ZF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_PF | X86_EFLAGS_MODIFY_CF)) {

        return false;
    }

    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes[FUKU_GET_RAND(0, 2)];

    if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
        return false;
    }

    if (FUKU_GET_RAND(0, 1)) {
        src = fuku_register(FUKU_REG_CL);
    }
    else {
        src = fuku_immediate(FUKU_GET_RAND(1, reg_size * 16 - 1));
    }

    switch (FUKU_GET_RAND(0, 2)) {

    case 0: {
        ctx.f_asm->sar(dst, src);
        break;
    }
    case 1: {
        ctx.f_asm->shl(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->shr(dst, src);
        break;
    }
    default: {return false; }
    }


    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}



//bittest reg1,val
//bittest reg1,reg
bool junk_86_low_pattern_6(mutation_context & ctx) {


    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_PF | X86_EFLAGS_MODIFY_CF)) {

        return false;
    }

    fuku_type dst;
    fuku_type src;

    uint32_t reg_size = reg_sizes[FUKU_GET_RAND(1, 2)];

    if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
        return false;
    }

    if (!get_operand_src_x86( src, INST_ALLOW_REGISTER | INST_ALLOW_IMMEDIATE,
        1, 0)) {
        return false;
    }


    switch (FUKU_GET_RAND(0, 3)) {

    case 0: {
        ctx.f_asm->bt(dst, src);
        break;
    }
    case 1: {
        ctx.f_asm->btc(dst, src);
        break;
    }
    case 2: {
        ctx.f_asm->bts(dst, src);
        break;
    }
    case 3: {
        ctx.f_asm->btr(dst, src);
        break;
    }
    default: {return false; }
    }


    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//convert byte\word to word\dword
bool junk_86_low_pattern_7(mutation_context & ctx) {

    uint32_t reg_size = reg_sizes[FUKU_GET_RAND(0, 2)];

    fuku_type dst;

    if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER,
        reg_size, ctx.cpu_registers, 
        FLAG_REGISTER_AL |
        FLAG_REGISTER_RCX | FLAG_REGISTER_ECX | FLAG_REGISTER_CX | FLAG_REGISTER_CL |
        FLAG_REGISTER_DL |
        FLAG_REGISTER_RBX | FLAG_REGISTER_EBX | FLAG_REGISTER_BX | FLAG_REGISTER_BL |
        FLAG_REGISTER_RSP | FLAG_REGISTER_ESP | FLAG_REGISTER_SP | FLAG_REGISTER_SPL |
        FLAG_REGISTER_RBP | FLAG_REGISTER_EBP | FLAG_REGISTER_BP | FLAG_REGISTER_BPL |
        FLAG_REGISTER_RSI | FLAG_REGISTER_ESI | FLAG_REGISTER_SI | FLAG_REGISTER_SIL |
        FLAG_REGISTER_RDI | FLAG_REGISTER_EDI | FLAG_REGISTER_DI | FLAG_REGISTER_DIL)) {
        return false;
    }


    if (dst.get_register().get_reg() == FUKU_REG_NONE) {
        return false;
    }

    switch (dst.get_register().get_reg()) {
    case FUKU_REG_AX: {
        ctx.f_asm->cbw();
        break;
    }
    case FUKU_REG_EAX: {
        ctx.f_asm->cwde();
        break;
    }
    case FUKU_REG_DX: {
        if (!has_flag_free_register(ctx.cpu_registers, FLAG_REGISTER_AX)) { return false; }
        ctx.f_asm->cwd();
        break;
    }
    case FUKU_REG_EDX: {      
        if (!has_flag_free_register(ctx.cpu_registers, FLAG_REGISTER_EAX)) { return false; }
        ctx.f_asm->cdq();
        break;
    }
    default: {return false; }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}


//set / reset flag
bool junk_86_low_pattern_8(mutation_context & ctx) {


    switch (FUKU_GET_RAND(0, 4)) {

    case 0: {
        if (!has_inst_free_eflags(ctx.cpu_flags,X86_EFLAGS_MODIFY_CF)) { return false; }

        ctx.f_asm->stc();
        break;
    }
    case 1: {
        if (!has_inst_free_eflags(ctx.cpu_flags, X86_EFLAGS_MODIFY_CF)) { return false; }

        ctx.f_asm->clc();
        break;
    }
    case 2: {
        if (!has_inst_free_eflags(ctx.cpu_flags, X86_EFLAGS_MODIFY_CF)) { return false; }

        ctx.f_asm->cmc();
        break;
    }
    case 3: {
        if (!has_inst_free_eflags(ctx.cpu_flags, X86_EFLAGS_MODIFY_DF)) { return false; }

        ctx.f_asm->cld();
        break;
    }
    case 4: {
        if (!has_inst_free_eflags(ctx.cpu_flags, X86_EFLAGS_MODIFY_DF)) { return false; }

        ctx.f_asm->std();
        break;
    }
    default: {return false; }
    }

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}

//inc reg
//neg reg
//inc reg
//neg reg
bool junk_86_high_pattern_1(mutation_context & ctx) {

    if (!has_inst_free_eflags(ctx.cpu_flags,
        X86_EFLAGS_MODIFY_OF | X86_EFLAGS_MODIFY_SF | X86_EFLAGS_MODIFY_ZF | X86_EFLAGS_MODIFY_AF | X86_EFLAGS_MODIFY_CF | X86_EFLAGS_MODIFY_PF)) {

        return false;
    }

    fuku_type dst;
    
    uint32_t reg_size = reg_sizes[FUKU_GET_RAND(0, 2)];

    if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
        return false;
    }

    ctx.f_asm->inc(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);
    ctx.f_asm->neg(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);
    ctx.f_asm->inc(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);
    ctx.f_asm->neg(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    return true;
}

//not reg1
//not reg1
bool junk_86_high_pattern_2(mutation_context & ctx) {

    fuku_type dst;

    uint32_t reg_size = reg_sizes[FUKU_GET_RAND(0, 2)];

    

    if (!get_operand_dst_x86( dst, INST_ALLOW_REGISTER | INST_ALLOW_OPERAND,
        reg_size, ctx.cpu_registers, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
        return false;
    }

    uint64_t flag_reg = get_flag_complex_by_fuku_register(dst.get_register().get_reg(), reg_size);

    


    ctx.f_asm->not_(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);
    ctx.f_asm->not_(dst);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers & ~(flag_reg));

    return true;
}



//push reg1
//pop  reg1
bool junk_86_high_pattern_3(mutation_context & ctx) {

    if (!IsAllowedStackOperations) {
        return false;
    }


    fuku_type src;

    uint32_t reg_size = reg_sizes[FUKU_GET_RAND(1, 2)];
    
    if (!get_operand_src_x86( src, INST_ALLOW_REGISTER,
        reg_size, FLAG_REGISTER_SP | FLAG_REGISTER_ESP)) {
        return false;
    }

    uint64_t flag_reg = get_flag_complex_by_fuku_register(src.get_register().get_reg(), reg_size);

    ctx.f_asm->push(src);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers);

    ctx.f_asm->pop(src);
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers | flag_reg);

    return true;
}



//jcc next_inst
bool junk_86_high_pattern_4(mutation_context & ctx) {

    if (ctx.is_next_last_inst) {

        return false;
    }

    uint8_t cond = FUKU_GET_RAND(0, 15);

    ctx.f_asm->jcc(fuku_condition(cond), imm(-1));

    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers)
        .set_rip_reloc(
            ctx.code_holder->create_rip_relocation(
                    fuku_rip_relocation()
                    .set_label(
                        ctx.generate_payload_label()
                    )
                    .set_offset(ctx.f_asm->get_context().immediate_offset)   
            )
        );


    return true;
}


//jmp next_inst
//some code trash
bool junk_86_high_pattern_5(mutation_context & ctx) {

    if (ctx.is_next_last_inst) {

        return false;
    }

    ctx.f_asm->jmp(imm(-1));
    ctx.f_asm->get_context().inst->
        set_cpu_flags(ctx.cpu_flags)
        .set_cpu_registers(ctx.cpu_registers)
        .set_rip_reloc(
            ctx.code_holder->create_rip_relocation(
                fuku_rip_relocation()
                .set_label(
                    ctx.generate_payload_label()
                )
                .set_offset(ctx.f_asm->get_context().immediate_offset)
            )
        );

    std::vector<uint8_t> trash;

    for (uint8_t t_size = 0; t_size < FUKU_GET_RAND(1, 15); t_size++) {
        trash.push_back(FUKU_GET_RAND(0, 0xFF));
    }

    ctx.f_asm->nop();
    ctx.f_asm->get_context().inst->set_opcode(trash.data(), (uint8_t)trash.size())
        .set_inst_flags(FUKU_INST_JUNK_CODE);

    return true;
}



bool fuku_junk_86_generic_low(mutation_context & ctx) {

    switch (FUKU_GET_RAND(0, 7)) {
    case 0: {
        return junk_86_low_pattern_1(ctx);
    }
    case 1: {
        return junk_86_low_pattern_2(ctx);
    }
    case 2: {
        return junk_86_low_pattern_3(ctx);
    }
    case 3: {
        return junk_86_low_pattern_4(ctx);
    }
    case 4: {
        return junk_86_low_pattern_5(ctx);
    }
    case 5: {
        return junk_86_low_pattern_6(ctx);
    }
    case 6: {
        return junk_86_low_pattern_7(ctx);
    }
    case 7: {
        return junk_86_low_pattern_8(ctx);
    }
    }

    return false;
}


bool fuku_junk_86_generic_high(mutation_context & ctx) {

    switch (FUKU_GET_RAND(0, 4)) {
    case 0: {
        return junk_86_high_pattern_1(ctx);
    }
    case 1: {
        return junk_86_high_pattern_2(ctx);
    }
    case 2: {
        return junk_86_high_pattern_3(ctx);
    }
    case 3: {
        return junk_86_high_pattern_4(ctx);
    }
    case 4: {
        return junk_86_high_pattern_5(ctx);
    }
    }

    return false;
}

bool fuku_junk_86_generic(mutation_context & ctx) {

    switch (FUKU_GET_RAND(0, 3)) {
    case 0:
    case 1: {
        
        return fuku_junk_86_generic_low(ctx);
        break;
    }
    case 2:
    case 3: {

        return fuku_junk_86_generic_high(ctx);
        break;
    }
    }

    return false;
}

```

`furikuri/fuku_mutation_x86_junk.h`:

```h
#pragma once



bool fuku_junk_86_generic(mutation_context & ctx);
```

`furikuri/fuku_mutation_x86_rules.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_mutation_x86_rules.h"

#define IsAllowedStackOperations (!HAS_FULL_MASK(ctx.inst_flags, FUKU_INST_BAD_STACK))

static uint64_t di_fl_jcc[] = {
    EFLAGS_MOD_OF , EFLAGS_MOD_OF, //jo   / jno
    EFLAGS_MOD_CF , EFLAGS_MOD_CF, //jb   / jae
    EFLAGS_MOD_ZF , EFLAGS_MOD_ZF, //je   / jne
    EFLAGS_MOD_ZF | EFLAGS_MOD_CF, EFLAGS_MOD_ZF | EFLAGS_MOD_CF, //jbe / jnbe
    EFLAGS_MOD_SF , EFLAGS_MOD_SF, //js   / jns
    EFLAGS_MOD_PF , EFLAGS_MOD_PF, //jp   / jnp
    EFLAGS_MOD_OF | EFLAGS_MOD_SF, EFLAGS_MOD_OF | EFLAGS_MOD_SF, //jnge / jge
    EFLAGS_MOD_OF | EFLAGS_MOD_SF | EFLAGS_MOD_ZF, EFLAGS_MOD_OF | EFLAGS_MOD_SF | EFLAGS_MOD_ZF //jng / jnle
};


#define restore_disp_relocate(op) \
           if (op.get_type() == FUKU_T0_OPERAND && reloc_disp && used_disp_reloc) {\
                ctx.f_asm->get_context().inst->\
                set_disp_reloc(reloc_disp);\
                reloc_disp->offset = ctx.f_asm->get_context().displacment_offset;\
           }

#define restore_imm_relocate(op) \
           if (inst_size == 4 && op.get_type() == FUKU_T0_IMMEDIATE && reloc_imm) {\
                ctx.f_asm->get_context().inst->\
                set_imm_reloc(reloc_imm);\
                reloc_imm->offset = ctx.f_asm->get_context().immediate_offset;\
           }

#define restore_rip_relocate_in_imm(op) \
           if (inst_size == 4 && op.get_type() == FUKU_T0_IMMEDIATE && reloc_rip && !used_disp_reloc) {\
                ctx.f_asm->get_context().inst->\
                set_rip_reloc(reloc_rip);\
                reloc_rip->offset = ctx.f_asm->get_context().immediate_offset;\
           }

#define restore_rip_relocate_in_disp(op) \
           if (inst_size == 4 && op.get_type() == FUKU_T0_OPERAND && reloc_rip && !used_disp_reloc) {\
                ctx.f_asm->get_context().inst->\
                set_rip_reloc(reloc_rip);\
                reloc_rip->offset = ctx.f_asm->get_context().displacment_offset;\
           }

#define restore_rip_to_imm_relocate(op) \
           if (op.get_type() == FUKU_T0_IMMEDIATE && reloc_rip && !used_disp_reloc) {\
                ctx.f_asm->get_context().inst->set_imm_reloc(\
                    ctx.code_holder->create_relocation(fuku_relocation()\
                        .set_label(reloc_rip->label)\
                        .set_offset(ctx.f_asm->get_context().immediate_offset)\
                    )\
                );\
                ctx.code_holder->release_rip_relocation(reloc_rip);\
           }

#define restore_rip_to_disp_relocate(op) \
           if (op.get_type() == FUKU_T0_OPERAND && reloc_rip && !used_disp_reloc) {\
                ctx.f_asm->get_context().inst->set_disp_reloc(\
                    ctx.code_holder->create_relocation(fuku_relocation()\
                        .set_label(reloc_rip->label)\
                        .set_offset(ctx.f_asm->get_context().displacment_offset)\
                    )\
                );\
                ctx.code_holder->release_rip_relocation(reloc_rip);\
           }

#define restore_imm_or_disp(op)         restore_disp_relocate(op) else restore_imm_relocate(op)
#define restore_rip_imm_or_disp(op)     restore_rip_relocate_in_imm(op) else restore_disp_relocate(op)
#define restore_rip_to_imm_or_disp(op)  restore_rip_to_imm_relocate(op) else restore_rip_to_disp_relocate(op)


#include "obf_templates/x86/obf_x86_mov_templates.h"
#include "obf_templates/x86/obf_x86_xchg_templates.h"
#include "obf_templates/x86/obf_x86_push_templates.h"
#include "obf_templates/x86/obf_x86_pop_templates.h"
#include "obf_templates/x86/obf_x86_lea_templates.h"

#include "obf_templates/x86/obf_x86_jcc_templates.h"
#include "obf_templates/x86/obf_x86_jmp_templates.h"
#include "obf_templates/x86/obf_x86_call_templates.h"
#include "obf_templates/x86/obf_x86_ret_templates.h"

#include "obf_templates/x86/obf_x86_add_templates.h"
#include "obf_templates/x86/obf_x86_sub_templates.h"
#include "obf_templates/x86/obf_x86_adc_templates.h"
#include "obf_templates/x86/obf_x86_sbb_templates.h"
#include "obf_templates/x86/obf_x86_cmp_templates.h"
#include "obf_templates/x86/obf_x86_neg_templates.h"
#include "obf_templates/x86/obf_x86_inc_templates.h"
#include "obf_templates/x86/obf_x86_dec_templates.h"
#include "obf_templates/x86/obf_x86_mul_templates.h"
#include "obf_templates/x86/obf_x86_imul_templates.h"
#include "obf_templates/x86/obf_x86_div_templates.h"
#include "obf_templates/x86/obf_x86_idiv_templates.h"

#include "obf_templates/x86/obf_x86_and_templates.h"
#include "obf_templates/x86/obf_x86_or_templates.h"
#include "obf_templates/x86/obf_x86_xor_templates.h"
#include "obf_templates/x86/obf_x86_test_templates.h"
#include "obf_templates/x86/obf_x86_not_templates.h"

#include "obf_templates/x86/obf_x86_ror_templates.h"
#include "obf_templates/x86/obf_x86_rol_templates.h"
#include "obf_templates/x86/obf_x86_rcl_templates.h"
#include "obf_templates/x86/obf_x86_rcr_templates.h"
#include "obf_templates/x86/obf_x86_shl_templates.h"
#include "obf_templates/x86/obf_x86_shr_templates.h"
#include "obf_templates/x86/obf_x86_sar_templates.h"

#include "obf_templates/x86/obf_x86_bt_templates.h"
#include "obf_templates/x86/obf_x86_bts_templates.h"
#include "obf_templates/x86/obf_x86_btr_templates.h"
#include "obf_templates/x86/obf_x86_btc_templates.h"
#include "obf_templates/x86/obf_x86_bsf_templates.h"
#include "obf_templates/x86/obf_x86_bsr_templates.h"



void init_x86_rules(_fukutate_instruction* rules) {

    rules[X86_INS_JMP] = fukutate_86_jmp;
    rules[X86_INS_CALL] = fukutate_86_call;
    rules[X86_INS_JO] = fukutate_86_jcc;
    rules[X86_INS_JNO] = fukutate_86_jcc;
    rules[X86_INS_JB] = fukutate_86_jcc;
    rules[X86_INS_JAE] = fukutate_86_jcc;
    rules[X86_INS_JE] = fukutate_86_jcc;
    rules[X86_INS_JNE] = fukutate_86_jcc;
    rules[X86_INS_JBE] = fukutate_86_jcc;
    rules[X86_INS_JA] = fukutate_86_jcc;
    rules[X86_INS_JS] = fukutate_86_jcc;
    rules[X86_INS_JNS] = fukutate_86_jcc;
    rules[X86_INS_JP] = fukutate_86_jcc;
    rules[X86_INS_JNP] = fukutate_86_jcc;
    rules[X86_INS_JL] = fukutate_86_jcc;
    rules[X86_INS_JGE] = fukutate_86_jcc;
    rules[X86_INS_JLE] = fukutate_86_jcc;
    rules[X86_INS_JG] = fukutate_86_jcc;
    rules[X86_INS_RET] = fukutate_86_ret;

    rules[X86_INS_MOV] = fukutate_86_mov;
    rules[X86_INS_XCHG] = fukutate_86_xchg;
    rules[X86_INS_LEA] = fukutate_86_lea;
    rules[X86_INS_PUSH] = fukutate_86_push;
    rules[X86_INS_POP] = fukutate_86_pop;

    //ARITHMETIC
    rules[X86_INS_ADD] = fukutate_86_add;
    rules[X86_INS_OR] = fukutate_86_or;
    rules[X86_INS_ADC] = fukutate_86_adc;
    rules[X86_INS_SBB] = fukutate_86_sbb;
    rules[X86_INS_AND] = fukutate_86_and;
    rules[X86_INS_SUB] = fukutate_86_sub;
    rules[X86_INS_XOR] = fukutate_86_xor;
    rules[X86_INS_CMP] = fukutate_86_cmp;
    rules[X86_INS_INC] = fukutate_86_inc;
    rules[X86_INS_DEC] = fukutate_86_dec;
    rules[X86_INS_TEST] = fukutate_86_test;
    rules[X86_INS_NOT] = fukutate_86_not;
    rules[X86_INS_NEG] = fukutate_86_neg;
    rules[X86_INS_MUL] = fukutate_86_mul;
    rules[X86_INS_IMUL] = fukutate_86_imul;
    rules[X86_INS_DIV] = fukutate_86_div;
    rules[X86_INS_IDIV] = fukutate_86_idiv;

    //SHIFT
    rules[X86_INS_ROL] = fukutate_86_rol;
    rules[X86_INS_ROR] = fukutate_86_ror;
    rules[X86_INS_RCL] = fukutate_86_rcl;
    rules[X86_INS_RCR] = fukutate_86_rcr;
    rules[X86_INS_SAL] = fukutate_86_shl;//SAL is too SHL
    rules[X86_INS_SHL] = fukutate_86_shl;
    rules[X86_INS_SHR] = fukutate_86_shr;
    rules[X86_INS_SAR] = fukutate_86_sar;

    //BITTEST
    rules[X86_INS_BT] = fukutate_86_bt;
    rules[X86_INS_BTS] = fukutate_86_bts;
    rules[X86_INS_BTR] = fukutate_86_btr;
    rules[X86_INS_BTC] = fukutate_86_btc;
    rules[X86_INS_BSF] = fukutate_86_bsf;
    rules[X86_INS_BSR] = fukutate_86_bsr;
}
```

`furikuri/fuku_mutation_x86_rules.h`:

```h
#pragma once

/*
//graph
bool fukutate_86_jcc(mutation_context& ctx);
bool fukutate_86_jmp(mutation_context& ctx);
bool fukutate_86_call(mutation_context& ctx);
bool fukutate_86_ret(mutation_context& ctx);

//stack
bool fukutate_86_push(mutation_context& ctx);
bool fukutate_86_pop(mutation_context& ctx);

//data transfer
bool fukutate_86_mov(mutation_context& ctx);
bool fukutate_86_xchg(mutation_context& ctx);
bool fukutate_86_lea(mutation_context& ctx);

//aritch
bool fukutate_86_add(mutation_context& ctx);
bool fukutate_86_or(mutation_context& ctx);
bool fukutate_86_adc(mutation_context& ctx);
bool fukutate_86_sbb(mutation_context& ctx);
bool fukutate_86_and(mutation_context& ctx);
bool fukutate_86_sub(mutation_context& ctx);
bool fukutate_86_xor(mutation_context& ctx);
bool fukutate_86_cmp(mutation_context& ctx);
bool fukutate_86_inc(mutation_context& ctx);
bool fukutate_86_dec(mutation_context& ctx);
bool fukutate_86_test(mutation_context& ctx);
bool fukutate_86_not(mutation_context& ctx);
bool fukutate_86_neg(mutation_context& ctx);
bool fukutate_86_mul(mutation_context& ctx);
bool fukutate_86_imul(mutation_context& ctx);
bool fukutate_86_div(mutation_context& ctx);
bool fukutate_86_idiv(mutation_context& ctx);

//shift
bool fukutate_86_rol(mutation_context& ctx);
bool fukutate_86_ror(mutation_context& ctx);
bool fukutate_86_rcl(mutation_context& ctx);
bool fukutate_86_rcr(mutation_context& ctx);
bool fukutate_86_shl(mutation_context& ctx);
bool fukutate_86_shr(mutation_context& ctx);
bool fukutate_86_sar(mutation_context& ctx);

//bittest
bool fukutate_86_bt(mutation_context& ctx);
bool fukutate_86_bts(mutation_context& ctx);
bool fukutate_86_btr(mutation_context& ctx);
bool fukutate_86_btc(mutation_context& ctx);
bool fukutate_86_bsf(mutation_context& ctx);
bool fukutate_86_bsr(mutation_context& ctx);

*/
void init_x86_rules(_fukutate_instruction* rules);
```

`furikuri/fuku_obfuscator.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_obfuscator.h"



fuku_obfuscator::fuku_obfuscator()
    :code(0), destination_virtual_address(0){}


fuku_obfuscator::~fuku_obfuscator(){
}

void fuku_obfuscator::set_code(fuku_code_holder* code_holder) {
    this->code = code_holder;
}

void fuku_obfuscator::set_destination_virtual_address(uint64_t destination_virtual_address) {
    this->destination_virtual_address = destination_virtual_address;
}

void fuku_obfuscator::set_settings(const fuku_settings_obfuscation& settings) {
    memcpy(&this->settings, &settings, sizeof(fuku_settings_obfuscation));
}

fuku_assambler_arch fuku_obfuscator::get_arch() const {
    return this->code->get_arch();
}

uint64_t     fuku_obfuscator::get_destination_virtual_address() const {
    return this->destination_virtual_address;
}

const fuku_settings_obfuscation& fuku_obfuscator::get_settings() const {
    return this->settings;
}

fuku_code_holder* fuku_obfuscator::get_code() {
    return this->code;
}

const fuku_code_holder* fuku_obfuscator::get_code() const {
    return this->code;
}

void fuku_obfuscator::obfuscate_code() {

    if (code == nullptr) {
        return;
    }


    fuku_mutation * mutator = (code->get_arch() == fuku_assambler_arch::FUKU_ASSAMBLER_ARCH_X86) ?
        (fuku_mutation*)(new fuku_mutation_x86(settings)) : (fuku_mutation*)(new fuku_mutation_x64(settings));


    handle_jmps();

    for (unsigned int passes = 0; passes < settings.get_number_of_passes(); passes++) {

        if (settings.get_junk_chance() > 0.f || settings.get_mutate_chance() > 0.f) {
            mutator->obfuscate(*code);
        }

        if (settings.get_block_chance() > 0.f) {
            spagetti_code(); //mix lines
        }
    }

    if (code->get_arch() == fuku_assambler_arch::FUKU_ASSAMBLER_ARCH_X86) {
        delete (fuku_mutation_x86*)mutator;
    }
    else {
        delete (fuku_mutation_x64*)mutator;
    }

    code->update_current_address(destination_virtual_address);
}

void fuku_obfuscator::spagetti_code() {

    std::vector<inststorage> line_blocks;

    fuku_assambler_ctx context;
    fuku_inst inst;

    context.arch = code->get_arch();
    context.inst = &inst;
    _jmp(context, imm(0));
    //generate blocks of lines
    {
        std::vector<size_t> block_lens;
 
        {
            size_t lines_total = code->get_insts().size();
            size_t lines_in_blocks = 0;
            size_t current_block_size = 0;

            while (lines_in_blocks < lines_total) {

                if (FUKU_GET_CHANCE(settings.get_block_chance())) {

                    block_lens.push_back(current_block_size);
                    current_block_size = 0;
                }
                else {
                    lines_in_blocks++;
                    current_block_size++;
                }

            }

            if (current_block_size) {
                block_lens.push_back(current_block_size);
            }
        }

        line_blocks.resize(block_lens.size());

        for (size_t block_idx = 0; block_idx < block_lens.size(); block_idx++) {

            size_t block_len = block_lens[block_idx];
            uint32_t inst_flags = 0;
            uint64_t inst_eflags = 0;
            uint64_t inst_customflags = 0;

            if (block_len) {
                auto start = code->get_insts().begin();
                auto end = start;

                std::advance(end, block_len);

                line_blocks[block_idx].splice(line_blocks[block_idx].begin(), code->get_insts(), start, end);   
            }

            if (code->get_insts().size()) {
                inst_flags = (code->get_insts().begin()->get_inst_flags());
                inst_eflags = code->get_insts().begin()->get_cpu_flags();
                inst_customflags = code->get_insts().begin()->get_cpu_registers();
            }

            if (block_idx + 1 != block_lens.size()) { //insert jmp to next block
                line_blocks[block_idx].push_back(
                    inst.set_inst_flags(inst_flags)
                    .set_cpu_flags(inst_eflags)
                    .set_cpu_registers(inst_customflags)
                );
            }

            if (block_idx) {

                auto& prev_block_jmp = line_blocks[block_idx - 1].back();
                auto& first_item_of_current_block = line_blocks[block_idx].begin();

                prev_block_jmp.set_rip_reloc(
                        
                        code->create_rip_relocation(
                            fuku_rip_relocation()
                                .set_offset(1)
                                .set_label(
                                    code->create_label(
                                        fuku_code_label()
                                        .set_inst(&(*first_item_of_current_block))
                                    )
                                )
                        )
                );
                
                prev_block_jmp.set_cpu_flags(first_item_of_current_block->get_cpu_flags());
            }

        }

    }

    //rand blocks
    {
        std::vector<size_t> block_idxs;
        block_idxs.resize(line_blocks.size());

        for (size_t idx = 0; idx < block_idxs.size(); idx++) {
            block_idxs[idx] = idx;
        }

        if (line_blocks.size() > 2) {
            for (size_t r_block = 0; r_block < block_idxs.size(); r_block++) {
                std::swap(block_idxs[r_block], block_idxs[FUKU_GET_RAND(0, block_idxs.size() - 1)]);
            }
        }

        
        //push lines
        {
            auto& code_lines = code->get_insts();
            for (size_t block_idx : block_idxs) {
                code_lines.splice(code_lines.end(), line_blocks[block_idx]);
            }
        }

    }
}

void fuku_obfuscator::handle_jmps() {

    fuku_assambler fuku_asm(code->get_arch());
    fuku_asm.set_holder(code, ASSAMBLER_HOLD_TYPE_FIRST_OVERWRITE);

    for (auto& line_iter = code->get_insts().begin(); line_iter != code->get_insts().end(); ++line_iter) {

        fuku_inst& line = *line_iter;

        switch (line.get_id()) {

        case X86_INS_JMP: {

            if (line.get_opcode()[get_inst_prefixe_count(line)] == 0xEB) { //near jump

                uint8_t op_code[16];
                memcpy(op_code, line.get_opcode(), line.get_oplength());

                op_code[get_inst_prefixe_count(line)] = 0xE9;

                line.set_opcode(op_code, line.get_oplength() + 3);
            }

            break;
        }

        case  X86_INS_JO: case  X86_INS_JNO:
        case  X86_INS_JB: case  X86_INS_JAE:
        case  X86_INS_JE: case  X86_INS_JNE:
        case  X86_INS_JBE:case  X86_INS_JA:
        case  X86_INS_JS: case  X86_INS_JNS:
        case  X86_INS_JP: case  X86_INS_JNP:
        case  X86_INS_JL: case  X86_INS_JGE:
        case  X86_INS_JLE:case  X86_INS_JG: {

            if ( (line.get_opcode()[get_inst_prefixe_count(line)] & 0xF0) == 0x70) { //near jump

                uint8_t op_code[16];
                memcpy(op_code, line.get_opcode(), line.get_oplength());

                op_code[get_inst_prefixe_count(line)] = 0x0F;
                
                op_code[get_inst_prefixe_count(line) + 1] = 
                    (0x80 | (line.get_opcode()[get_inst_prefixe_count(line)] & 0x0F));

                line.set_opcode(op_code, line.get_oplength() + 4);

                line.get_rip_reloc()->set_offset(2);
            }

            break;
        }


        case X86_INS_JCXZ:
        case X86_INS_JECXZ: {

            fuku_asm.set_first_emit(true).set_position(line_iter);

            auto _label = line.get_label();
            auto _rip_reloc = line.get_rip_reloc();

            fuku_register reg;

            if (line.get_id() == X86_INS_JECXZ) { //or ecx,ecx
                reg = reg_(FUKU_REG_ECX);
            }
            else { //or cx,cx
                reg = reg_(FUKU_REG_CX);
            }

            fuku_asm.or_(reg, reg);
            fuku_asm.get_context().inst->set_label(_label);

            fuku_asm.jcc(FUKU_CONDITION_EQUAL, fuku_immediate(0));
            fuku_asm.get_context().inst->set_rip_reloc(_rip_reloc);

            _rip_reloc->set_offset(fuku_asm.get_context().immediate_offset);

            ++line_iter;
            break;
        }


        case X86_INS_LOOP: {
            fuku_asm.set_first_emit(true).set_position(line_iter);

            auto _label = line.get_label();
            auto _rip_reloc = line.get_rip_reloc();


            fuku_asm.dec(reg_(FUKU_REG_ECX));                  //dec ecx
            fuku_asm.get_context().inst->set_label(_label);

            fuku_asm.jcc(FUKU_CONDITION_NOT_EQUAL, imm(0));      //jnz
            fuku_asm.get_context().inst->set_rip_reloc(_rip_reloc);

            _rip_reloc->set_offset(fuku_asm.get_context().immediate_offset);

            ++line_iter;
            break;
        }

        case X86_INS_LOOPE: {
            fuku_asm.set_first_emit(true).set_position(line_iter);

            auto _label = line.get_label();
            auto _rip_reloc = line.get_rip_reloc();

            fuku_asm.dec(reg_(FUKU_REG_ECX));                  //dec ecx
            fuku_asm.get_context().inst->set_label(_label);

            fuku_asm.jcc(FUKU_CONDITION_EQUAL, imm(0));      //jz
            fuku_asm.get_context().inst->set_rip_reloc(_rip_reloc);

            _rip_reloc->set_offset(fuku_asm.get_context().immediate_offset);

            ++line_iter;
            break;
        }

        case X86_INS_LOOPNE: {
            fuku_asm.set_first_emit(true).set_position(line_iter);

            auto _label = line.get_label();
            auto _rip_reloc = line.get_rip_reloc();

            fuku_asm.dec(reg_(FUKU_REG_ECX));                  //dec ecx
            fuku_asm.get_context().inst->set_label(_label);

            fuku_asm.jcc(FUKU_CONDITION_NOT_EQUAL, imm(0));      //jne
            fuku_asm.get_context().inst->set_rip_reloc(_rip_reloc);

            _rip_reloc->set_offset(fuku_asm.get_context().immediate_offset);

            ++line_iter;
            break;
        }

        default:break;
        }
    }
}


```

`furikuri/fuku_obfuscator.h`:

```h
#pragma once

enum fuku_inst_flags {
    FUKU_INST_JUNK_CODE          = 1 << 0,
    FUKU_INST_BAD_STACK          = 1 << 1,
    FUKU_INST_NO_MUTATE          = 1 << 2,
};


#include "fuku_mutation_imp.h"


class fuku_obfuscator {
    fuku_code_holder *code;

    uint64_t destination_virtual_address;

    fuku_settings_obfuscation settings;

    void    handle_jmps();
    void    spagetti_code();
public:
    fuku_obfuscator();
    ~fuku_obfuscator();

    void obfuscate_code();
public:
    void set_code(fuku_code_holder* code_holder);

    void set_destination_virtual_address(uint64_t destination_virtual_address);
    void set_settings(const fuku_settings_obfuscation& settings);

public:  
    fuku_assambler_arch    get_arch() const;
    uint64_t     get_destination_virtual_address() const;
    const fuku_settings_obfuscation& get_settings() const;

    fuku_code_holder* get_code();
    const fuku_code_holder* get_code() const;
};

```

`furikuri/fuku_protect_mgr.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_protect_mgr.h"


bool find_profile_association(fuku_settings_mgr& settings, fuku_protection_profile& profile,
    uint32_t rva, std::pair<uint64_t, uint64_t>& result);

#include "fuku_protect_obfuscator_mgr.h"
#include "fuku_protect_virtualizer_mgr.h"




fuku_protect_mgr::fuku_protect_mgr() {}

fuku_protect_mgr::fuku_protect_mgr(const fuku_settings_mgr& settings)
   : settings(settings) {}


fuku_protect_mgr::~fuku_protect_mgr() {
    clear_profiles();
}


fuku_protect_mgr_result fuku_protect_mgr::step_to_stage(fuku_protect_stage stage) {

    if (stage > settings.get_stage_code() && check_regions_scope()) {

        if (stage > settings.get_stage_code() && initialize_profiles()) {

            if (stage > settings.get_stage_code() && process_profiles()) {

                if (stage > settings.get_stage_code() && post_process_profiles()) {

                    if (stage > settings.get_stage_code()) {
                        finish_process_module();
                    }
                }
            }
        }
    }

    return settings.get_result_code();
}


bool fuku_protect_mgr::check_regions_scope() {

    if (settings.get_stage_code() == (fuku_protect_stage_check - 1)) {

        if (settings.get_result_code() == fuku_protect_ok) {

            settings.set_stage_code(fuku_protect_stage_check);

            bool result = true;

            std::vector<fuku_protected_region>   regions;

            for (auto& item : settings.get_ob_profile().items) {
                regions.insert(regions.end(), item.regions.begin(), item.regions.end());
            }

            for (auto& item : settings.get_vm_profiles()) {
                regions.insert(regions.end(), item.second.regions.begin(), item.second.regions.end());
            }


            std::sort(regions.begin(), regions.end(), [](fuku_protected_region& lhs, fuku_protected_region& rhs) {
                return lhs.region_rva < rhs.region_rva;
            });

            for (size_t region_idx = 0; region_idx < regions.size(); region_idx++) {

                if (region_idx + 1 < regions.size()) {
                    auto& region_current = regions[region_idx];
                    auto& region_next = regions[region_idx + 1];

                    if ((region_next.region_rva == region_current.region_rva) ||
                        (region_current.region_rva + region_current.region_size - 1) >= region_next.region_rva
                        ) {
                        result = false;
                        break;
                    }
                }
            }

            return result;
        }

        return false;
    }

    return settings.get_result_code() == fuku_protect_ok;
}

bool fuku_protect_mgr::initialize_profiles() {

    if (settings.get_stage_code() == (fuku_protect_stage_initialization - 1) ) {

        if (settings.get_result_code() == fuku_protect_ok) {

            settings.set_stage_code(fuku_protect_stage_initialization);

            bool result = initialize_obfuscation_profiles() && initialize_virtualization_profiles();

            if (!result) {
                settings.set_result_code(fuku_protect_err_initialization);
            }
            else {
                settings.set_result_code(fuku_protect_ok);
            }

            
            return result;
        }

        return false;
    }

    return settings.get_result_code() == fuku_protect_ok;
}

bool fuku_protect_mgr::process_profiles() {

    if (settings.get_stage_code() == (fuku_protect_stage_processing - 1)) {

        if (settings.get_result_code() == fuku_protect_ok) {

            settings.set_stage_code(fuku_protect_stage_processing);

            bool result = process_obfuscation_profiles() && process_virtualization_profiles();

            if (!result) {
                settings.set_result_code(fuku_protect_err_processing);
            }
            else {
                settings.set_result_code(fuku_protect_ok);
            }
     
            return result;
        }

        return false;
    }

    return settings.get_result_code() == fuku_protect_ok;
}

bool fuku_protect_mgr::post_process_profiles() {

    if (settings.get_stage_code() == (fuku_protect_stage_post_processing - 1)) {

        if (settings.get_result_code() == fuku_protect_ok) {

            settings.set_stage_code(fuku_protect_stage_post_processing);

            bool result = postprocess_obfuscation() && postprocess_virtualization();

            if (!result) {
                settings.set_result_code(fuku_protect_err_post_processing);
            }
            else {
                settings.set_result_code(fuku_protect_ok);
            }

            return result;
        }

        return false;
    }

    return settings.get_result_code() == fuku_protect_ok;
}

bool fuku_protect_mgr::finish_process_module() {
    //todo do configuration of configuration \_(0-0)_/

    if (settings.get_stage_code() == (fuku_protect_stage_finish_processing - 1)) {

        if (settings.get_result_code() == fuku_protect_ok) {

            pe_image_full& image_full = settings.get_target_module();

            settings.set_stage_code(fuku_protect_stage_finish_processing);

            bool result = true;

            image_full.get_load_config().get_se_handlers().clear();
            image_full.get_load_config().get_guard_cf_functions().clear();

            if (!result) {
                settings.set_result_code(fuku_protect_err_module_processing);
            }
            else {
                settings.set_result_code(fuku_protect_ok);
            }

            return result;
        }

        return false;
    }

    return settings.get_result_code() == fuku_protect_ok;
}

void fuku_protect_mgr::add_ob_profile(const std::vector<fuku_protected_region>& regions, fuku_settings_obfuscation& settings) {
    this->settings.add_ob_profile(regions, settings);
}

void fuku_protect_mgr::add_vm_profile(const std::vector<fuku_protected_region>& regions, fuku_settings_virtualization& settings) {
    this->settings.add_vm_profile(regions, settings);
}


void fuku_protect_mgr::clear_profiles() {
    settings.get_ob_profile().items.clear();
    settings.get_vm_profiles().clear();
}

void fuku_protect_mgr::set_settings(const fuku_settings_mgr& settings) {
    this->settings = settings;
}

fuku_settings_mgr& fuku_protect_mgr::get_settings() {
    return this->settings;
}

const fuku_settings_mgr& fuku_protect_mgr::get_settings() const {
    return this->settings;
}

bool find_profile_association(fuku_settings_mgr& settings, fuku_protection_profile& profile, 
    uint32_t rva, std::pair<uint64_t, uint64_t>& result) {

    pe_image_full& image_full = settings.get_target_module();

    for (auto& region : profile.regions) {

        if (region.region_rva <= rva && region.region_rva + region.region_size > rva) {

            uint64_t real_address = image_full.get_image().rva_to_va((uint32_t)rva);

            auto _assoc = profile.association_table.find(real_address);

            if (_assoc != profile.association_table.end()) {

                result = *_assoc;
                return true;
            }
        }
    }

    return false;
}


bool protect_manager_create_stage_snapshot(fuku_settings_mgr& settings, fuku_protect_stage stage) {
    fuku_protect_mgr mgr(settings);

    mgr.step_to_stage(stage);

    settings = mgr.get_settings();

    return settings.get_result_code() == fuku_protect_ok;
}

bool protect_manager_load_snapshot(fuku_protect_mgr& mgr, const fuku_settings_mgr& settings) {
    
    mgr.get_settings() = settings;

    return true;
}
```

`furikuri/fuku_protect_mgr.h`:

```h
#pragma once

#include "fuku_settings_mgr.h"

class fuku_protect_mgr {
    
    fuku_settings_mgr settings;

    bool initialize_obfuscation_profiles();
    bool initialize_virtualization_profiles();

    bool process_obfuscation_profiles();
    bool process_virtualization_profiles();

    bool postprocess_obfuscation();
    bool postprocess_virtualization();

public:
    fuku_protect_mgr();
    fuku_protect_mgr(const fuku_settings_mgr& settings);

    ~fuku_protect_mgr();

public:
    fuku_protect_mgr_result step_to_stage(fuku_protect_stage stage);

public:
    bool check_regions_scope();
    bool initialize_profiles();
    bool process_profiles();
    bool post_process_profiles();
    bool finish_process_module();   
public:

    void add_vm_profile(const std::vector<fuku_protected_region>& regions, fuku_settings_virtualization& settings);
    void add_ob_profile(const std::vector<fuku_protected_region>& regions, fuku_settings_obfuscation& settings);

    void clear_profiles();

    void set_settings(const fuku_settings_mgr& settings);
public:

    fuku_settings_mgr& get_settings();
    const fuku_settings_mgr& get_settings() const;
};


bool protect_manager_create_stage_snapshot(
    fuku_settings_mgr& settings, fuku_protect_stage stage);
bool protect_manager_load_snapshot(
    fuku_protect_mgr& mgr, const fuku_settings_mgr& settings);
```

`furikuri/fuku_protect_obfuscator_mgr.h`:

```h
#pragma once

bool fuku_protect_mgr::initialize_obfuscation_profiles() {

    pe_image_full& image_full = settings.get_target_module();
    pe_image_io image_io(image_full.get_image());

    bool     is32arch = image_full.get_image().is_x32_image();
    uint64_t base_address = image_full.get_image().get_image_base();

    fuku_code_profiler code_profiler(is32arch ? FUKU_ASSAMBLER_ARCH_X86 : FUKU_ASSAMBLER_ARCH_X64);

    image_full.get_relocations().sort();

    for (auto& item : settings.get_ob_profile().items) {
        item.an_code.set_arch(is32arch ? FUKU_ASSAMBLER_ARCH_X86 : FUKU_ASSAMBLER_ARCH_X64);

        std::sort(item.regions.begin(), item.regions.end(), [](fuku_protected_region& lhs, fuku_protected_region& rhs) {
            return lhs.region_rva < rhs.region_rva;
        });

        struct code_region_buffer {
            uint32_t code_rva;
            std::vector<uint8_t> code_buffer;
            std::vector<fuku_image_relocation> used_relocs;
        };

        std::vector<code_region_buffer> code_regions;

        size_t last_reloc_idx = 0;

        for (auto& region : item.regions) {

            code_region_buffer code_region;

            code_region.code_rva = region.region_rva;

            if (image_io.set_image_offset(region.region_rva).read(code_region.code_buffer, region.region_size) != enma_io_success) {

                FUKU_DEBUG;
                return false;
            }

            auto& relocations = image_full.get_relocations().get_entries();

            for (size_t reloc_idx = last_reloc_idx; reloc_idx < relocations.size(); reloc_idx++, last_reloc_idx++) {
                auto& reloc_item = relocations[reloc_idx];

                if (reloc_item.relative_virtual_address > region.region_rva) {
                    if (reloc_item.relative_virtual_address < (region.region_rva + region.region_size)) {

                        code_region.used_relocs.push_back({
                             reloc_item.relocation_id, reloc_item.relative_virtual_address + base_address
                            });


                        relocations.erase(relocations.begin() + reloc_idx);

                        reloc_idx--;
                        last_reloc_idx--;
                    }
                    else {
                        break;
                    }
                }
            }

            code_regions.push_back(code_region);

            image_io.set_image_offset(region.region_rva).memory_set(region.region_size, 0);
        }

        {
            fuku_assambler_ctx context;
            fuku_inst inst;

            context.arch = is32arch ? FUKU_ASSAMBLER_ARCH_X86 : FUKU_ASSAMBLER_ARCH_X64;
            context.inst = &inst;
            _jmp(context, imm(0));

            for (auto& code_region : code_regions) {

                {
                    fuku_code_holder code_holder;

                    item.an_code.analyze_code(code_holder,
                        code_region.code_buffer.data(),
                        code_region.code_buffer.size(),
                        base_address + code_region.code_rva,
                        &code_region.used_relocs
                    );

                    if (code_holder.get_insts().size()) { //if taken a part of function we place a jmp to end of analyzed pieñe
                        uint16_t id = code_holder.get_insts().back().get_id();

                        if (id != X86_INS_JMP && id != X86_INS_RET) {

                            auto& _inst = code_holder.add_inst();

                            _inst = inst;

                            _inst.set_rip_reloc(
                                code_holder.create_rip_relocation(
                                    fuku_rip_relocation()
                                        .set_offset(context.immediate_offset)
                                        .set_label(
                                            code_holder.create_label(
                                                fuku_code_label()
                                                    .set_address(
                                                        code_holder.get_insts().back().get_source_address() + 
                                                        code_holder.get_insts().back().get_oplength()
                                                    )
                                            )
                                        )
                                 )
                            );

                        }
                    }

                    code_profiler.profile_code(code_holder);

                    item.an_code.push_code(code_holder);
                }
            }
        }
    }

    return true;
}

bool fuku_protect_mgr::process_obfuscation_profiles() {

    if (settings.get_ob_profile().items.size()) {

        pe_image_full& image_full = settings.get_target_module();
        pe_image_io image_io(image_full.get_image(), enma_io_mode::enma_io_mode_allow_expand);

        fuku_code_analyzer anal_code;

        anal_code.set_arch(image_full.get_image().is_x32_image() ? FUKU_ASSAMBLER_ARCH_X86 : FUKU_ASSAMBLER_ARCH_X64);

        if (settings.get_ob_profile().items.size()) {
            size_t item_idx = settings.get_ob_profile().items.size();

            do {
                item_idx--;

                auto& item = settings.get_ob_profile().items[item_idx];

                fuku_obfuscator obfuscator;

                obfuscator.set_settings(item.settings);
                obfuscator.set_destination_virtual_address(image_full.get_image().get_image_base());
                obfuscator.set_code(&item.an_code.get_code());

                obfuscator.obfuscate_code();

                if (!anal_code.splice_code(item.an_code.get_code())) { FUKU_DEBUG; return false; }

                settings.get_ob_profile().regions.insert(settings.get_ob_profile().regions.end(), 
                    item.regions.begin(), item.regions.end());

                settings.get_ob_profile().items.erase(settings.get_ob_profile().items.begin() + item_idx);

            } while (item_idx);
        }

        uint32_t dest_address_rva = ALIGN_UP(
            image_full.get_image().get_section_top_rva()->get_virtual_address() +
            image_full.get_image().get_section_top_rva()->get_virtual_size(),
            image_full.get_image().get_section_align());

        image_full.get_image().get_section_top_rva()->set_executable(true).set_readable(true);
        
        fuku_obfuscator obfuscator;
        obfuscator.set_settings(fuku_settings_obfuscation(1, 1, 0, 5.f, 0 ,0));

        obfuscator.set_destination_virtual_address(image_full.get_image().get_image_base() + dest_address_rva);

        obfuscator.set_code(&anal_code.get_code());

        obfuscator.obfuscate_code();

        anal_code.get_code().finalize_code(
            &settings.get_ob_profile().association_table, 
            &settings.get_ob_profile().relocation_table
        );

        std::vector<uint8_t> ob_code = anal_code.get_code().dump_code();

        if (image_io.set_image_offset(dest_address_rva).write(ob_code) != enma_io_success) { 
            
            FUKU_DEBUG;

            //todo 
            /* rewrite for dynamic code place */

            /*
              when we take a part of code we clear and set this area to 0
               this area's (without first's 5 bytes) must be used for obfuscated and vmed code
            */
            
            return false;
        }

    }

    return true;
}

bool    fuku_protect_mgr::postprocess_obfuscation() {

    if (settings.get_ob_profile().regions.size()) {

        pe_image_full& image_full = settings.get_target_module();
        pe_image_io image_io(image_full.get_image());

        fuku_assambler_ctx asm_ctx;
        fuku_inst inst;

        asm_ctx.arch = FUKU_ASSAMBLER_ARCH_X86;
        asm_ctx.short_cfg = 0xFF;
        asm_ctx.inst = &inst;
      
        uint64_t base_address = image_full.get_image().get_image_base();
        auto&   image_relocs = image_full.get_relocations();

        bool is32arch = image_full.get_image().is_x32_image();


        for (auto& reloc : image_relocs.get_entries()) {
            reloc.data = 0;
            if (image_io.set_image_offset(reloc.relative_virtual_address).read(
                &reloc.data, is32arch ? sizeof(uint32_t) : sizeof(uint64_t)) != enma_io_success) {

                FUKU_DEBUG;
                return false;
            }
            reloc.data = image_full.get_image().va_to_rva(reloc.data);
        }


        for (auto& region : settings.get_ob_profile().regions) {
            for (auto& reloc : image_relocs.get_entries()) {                              //fix relocations

                if (reloc.data > region.region_rva &&
                    reloc.data < (region.region_rva + region.region_size)) {


                    std::pair<uint64_t, uint64_t> assoc;

                    if (find_profile_association(settings,
                        settings.get_ob_profile(), (uint32_t)reloc.data, assoc)) {

                        reloc.data = assoc.second;

                        if (image_io.set_image_offset(reloc.relative_virtual_address).write(
                            &reloc.data, is32arch ? sizeof(uint32_t) : sizeof(uint64_t)) != enma_io_success) {

                            FUKU_DEBUG;
                            return false;
                        }
                    }
                    else {

                        FUKU_DEBUG;
                        return false;
                    }
                }
            }

            std::pair<uint64_t, uint64_t> assoc;

            if (find_profile_association(settings, settings.get_ob_profile(), region.region_rva, assoc)) {

                //set jumps to start of obfuscated funcs
                _jmp(asm_ctx, fuku_immediate(uint32_t(assoc.second - (region.region_rva + base_address) - 5)));

                if (image_io.set_image_offset(region.region_rva).write(
                    asm_ctx.bytecode, asm_ctx.length) != enma_io_success) {
                    
                    FUKU_DEBUG;
                    return false;
                }
            }
        }

        for (auto& reloc : settings.get_ob_profile().relocation_table) {

            image_relocs.add_relocation(uint32_t(reloc.virtual_address - base_address), reloc.relocation_id, 
                is32arch ? IMAGE_REL_BASED_HIGHLOW : IMAGE_REL_BASED_DIR64);
        }

        {
            std::pair<uint64_t, uint64_t> assoc;

            if (find_profile_association(settings, settings.get_ob_profile(), 
                image_full.get_image().get_entry_point(), assoc)) {

                image_full.get_image().set_entry_point(uint32_t(assoc.second - base_address));
            }
        }


        for (auto& export_item : image_full.get_exports().get_functions()) {

            std::pair<uint64_t, uint64_t> assoc;

            if (find_profile_association(settings, settings.get_ob_profile(),
                export_item.get_rva(), assoc)) {

                export_item.set_rva(uint32_t(assoc.second - base_address));
            }
        }
    }


    return true;
}


```

`furikuri/fuku_protect_virtualizer_mgr.h`:

```h
#pragma once

bool fuku_protect_mgr::initialize_virtualization_profiles() {

    pe_image_full& image_full = settings.get_target_module();
    pe_image_io image_io(image_full.get_image());
    bool     is32arch = image_full.get_image().is_x32_image();
    uint64_t base_address = image_full.get_image().get_image_base();

    fuku_code_profiler code_profiler(is32arch ? FUKU_ASSAMBLER_ARCH_X86 : FUKU_ASSAMBLER_ARCH_X64);

    image_full.get_relocations().sort();

    for (auto& profile : settings.get_vm_profiles()) {

        for (auto& item : profile.second.items) {
            item.an_code.set_arch(is32arch ? FUKU_ASSAMBLER_ARCH_X86 : FUKU_ASSAMBLER_ARCH_X64);

            std::sort(item.regions.begin(), item.regions.end(), [](fuku_protected_region& lhs, fuku_protected_region& rhs) {
                return lhs.region_rva < rhs.region_rva;
            });

            struct code_region_buffer {
                uint32_t code_rva;
                std::vector<uint8_t> code_buffer;
                std::vector<fuku_image_relocation> used_relocs;
            };

            std::vector<code_region_buffer> code_regions;


            size_t last_reloc_idx = 0;

            for (auto& region : item.regions) {

                code_region_buffer code_region;

                code_region.code_rva = region.region_rva;

                if (image_io.set_image_offset(region.region_rva).read(code_region.code_buffer, region.region_size) != enma_io_success) {
                    return false;
                }

                auto& relocations = image_full.get_relocations().get_entries();

                for (size_t reloc_idx = last_reloc_idx; reloc_idx < relocations.size(); reloc_idx++, last_reloc_idx++) {
                    auto& reloc_item = relocations[reloc_idx];

                    if (reloc_item.relative_virtual_address > region.region_rva) {
                        if (reloc_item.relative_virtual_address < (region.region_rva + region.region_size)) {

                            code_region.used_relocs.push_back({
                                reloc_item.relocation_id,
                                reloc_item.relative_virtual_address + base_address
                                });


                            relocations.erase(relocations.begin() + reloc_idx);

                            reloc_idx--;
                            last_reloc_idx--;
                        }
                        else {
                            break;
                        }
                    }
                }

                code_regions.push_back(code_region);

                image_io.set_image_offset(region.region_rva).memory_set(region.region_size, 0);
            }

            {
                fuku_assambler_ctx context;
                fuku_inst inst;

                context.arch = is32arch ? FUKU_ASSAMBLER_ARCH_X86 : FUKU_ASSAMBLER_ARCH_X64;
                context.inst = &inst;
                _jmp(context, imm(0));

                for (auto& code_region : code_regions) {

                    {
                        fuku_code_holder code_holder;

                        item.an_code.analyze_code(code_holder,
                            code_region.code_buffer.data(),
                            code_region.code_buffer.size(),
                            base_address + code_region.code_rva,
                            &code_region.used_relocs
                        );

                        if (code_holder.get_insts().size()) { //if taken a part of function we place a jmp to end of analyzed pieñe
                            uint16_t id = code_holder.get_insts().back().get_id();

                            if (id != X86_INS_JMP && id != X86_INS_RET) {

                                auto& _inst = code_holder.add_inst();

                                _inst = inst;

                                _inst.set_rip_reloc(
                                    code_holder.create_rip_relocation(
                                        fuku_rip_relocation()
                                        .set_offset(context.immediate_offset)
                                        .set_label(
                                            code_holder.create_label(
                                                fuku_code_label()
                                                .set_address(
                                                    code_holder.get_insts().back().get_source_address() +
                                                    code_holder.get_insts().back().get_oplength()
                                                )
                                            )
                                        )
                                    )
                                );

                            }
                        }

                        code_profiler.profile_code(code_holder);

                        item.an_code.push_code(code_holder);
                    }
                }
            }
        }
    }

    return true;
}

bool fuku_protect_mgr::process_virtualization_profiles() {

    if (settings.get_vm_profiles().size()) {

        pe_image_full& image_full = settings.get_target_module();
        pe_image_io image_io(image_full.get_image(), enma_io_mode::enma_io_mode_allow_expand);
        bool     is32arch = image_full.get_image().is_x32_image();

        image_io.seek_to_end();

        for (auto& profile : settings.get_vm_profiles()) {

            if (profile.second.items.size()) {

                fuku_code_analyzer anal_code;
                anal_code.set_arch(is32arch ? FUKU_ASSAMBLER_ARCH_X86 : FUKU_ASSAMBLER_ARCH_X64);

                size_t item_idx = profile.second.items.size();

                do {
                    item_idx--;

                    auto& item = profile.second.items[item_idx];

                    if (item.settings.is_null() != false) {
                        fuku_obfuscator obfuscator;

                        obfuscator.set_settings(item.settings);
                        obfuscator.set_destination_virtual_address(image_full.get_image().get_image_base());
                        obfuscator.set_code(&item.an_code.get_code());

                        obfuscator.obfuscate_code();

                        if (!anal_code.splice_code(item.an_code.get_code())) { FUKU_DEBUG; return false; }
                    }
                    else {
                        if (!anal_code.splice_code(item.an_code)) { FUKU_DEBUG; return false; }
                    }

                    profile.second.regions.insert(profile.second.regions.end(), item.regions.begin(), item.regions.end());
                    profile.second.items.erase(profile.second.items.begin() + item_idx);

                } while (item_idx);


                /*
                fuku_vm_result result = ((fuku_virtualization_environment&)profile.first).get_virtualizer()->build_bytecode(
                    settings.get_target_module(), anal_code.get_code(), std::vector<uint32_t>(), profile.second.relocation_table
                );
                */

               // if (result != fuku_vm_result::fuku_vm_ok) {

               //     FUKU_DEBUG;
               //     return false;
               // }

                if (image_io.write(profile.first.get_virtualizer()->get_bytecode()) != enma_io_success) {

                    FUKU_DEBUG;
                    return false;
                }
            }
        }
    }

    return true;
}

bool fuku_protect_mgr::postprocess_virtualization() {


    if (settings.get_vm_profiles().size()) {

        pe_image_full& image_full = settings.get_target_module();
        pe_image_io image_io(image_full.get_image());
        uint64_t base_address = image_full.get_image().get_image_base();
        auto&   image_relocs = image_full.get_relocations();
        bool    is32arch = image_full.get_image().is_x32_image();

        for (auto& profile : settings.get_vm_profiles()) {
            for (auto& region : profile.second.regions) {

                std::pair<uint64_t, uint64_t> assoc;


                //set jumps to start of virtualized funcs
                /* 
                if (find_profile_association(settings, profile.second, region.region_rva, assoc)) {

                    auto _jmp = profile.first.get_virtualizer()->create_vm_jumpout((region.region_rva + base_address), assoc.second,
                       profile.second.relocation_table);

                    if (image_io.set_image_offset(region.region_rva).write(_jmp) != enma_io_success) {

                        FUKU_DEBUG;
                        return false;
                    }

                } else {
                    FUKU_DEBUG;
                }
                */
            }

            for (auto& reloc : profile.second.relocation_table) {
                image_relocs.add_relocation(uint32_t(reloc.virtual_address - base_address), reloc.relocation_id,
                    is32arch ? IMAGE_REL_BASED_HIGHLOW : IMAGE_REL_BASED_DIR64);
            }
        }
    }

    return true;
}
```

`furikuri/fuku_settings_mgr.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_settings_mgr.h"


fuku_settings_mgr::fuku_settings_mgr()
    : result_code(fuku_protect_ok), stage_code(fuku_protect_stage_start), module_used_relocations(false) {}

fuku_settings_mgr::fuku_settings_mgr(const fuku_settings_mgr& mgr_set) {
    this->operator=(mgr_set);
}

fuku_settings_mgr::~fuku_settings_mgr() {}

fuku_settings_mgr& fuku_settings_mgr::operator=(const fuku_settings_mgr& mgr_set) {
   
    this->stage_code = mgr_set.stage_code;
    this->result_code = mgr_set.result_code;
    this->target_module = mgr_set.target_module;
    this->ob_profile = mgr_set.ob_profile;
    this->vm_profiles = mgr_set.vm_profiles;
    this->module_used_relocations = mgr_set.module_used_relocations;

    return *this;
}

void fuku_settings_mgr::set_target_module(const pe_image_full& target_module) {
    this->target_module = target_module;
}

void fuku_settings_mgr::set_ob_profile(const fuku_protection_profile& ob_profile) {
    this->ob_profile = ob_profile;
}

void fuku_settings_mgr::set_vm_profiles(const std::map <
    fuku_virtualization_environment,
    fuku_protection_profile>& vm_profiles) {

    this->vm_profiles = vm_profiles;
}

void fuku_settings_mgr::set_module_used_relocations(bool used) {
    this->module_used_relocations = used;
}

void fuku_settings_mgr::set_result_code(fuku_protect_mgr_result code) {
    this->result_code = code;
}

void fuku_settings_mgr::set_stage_code(fuku_protect_stage code) {
    this->stage_code = code;
}

pe_image_full& fuku_settings_mgr::get_target_module() {
    return this->target_module;
}
   
const pe_image_full& fuku_settings_mgr::get_target_module() const {
    return this->target_module;
}
    
fuku_protection_profile& fuku_settings_mgr::get_ob_profile() {
    return this->ob_profile;
}

const fuku_protection_profile& fuku_settings_mgr::get_ob_profile() const {
    return this->ob_profile;
}

std::map<
        fuku_virtualization_environment,
        fuku_protection_profile
>& fuku_settings_mgr::get_vm_profiles() {
    return this->vm_profiles;
}

const std::map<
        fuku_virtualization_environment,
        fuku_protection_profile
>& fuku_settings_mgr::get_vm_profiles() const {
    return this->vm_profiles;
}

bool fuku_settings_mgr::is_module_used_relocations() const {
    return this->module_used_relocations;
}

fuku_protect_mgr_result fuku_settings_mgr::get_result_code() const {
    return this->result_code;
}

fuku_protect_stage fuku_settings_mgr::get_stage_code() const {
    return this->stage_code;
}


void fuku_settings_mgr::add_ob_profile(const std::vector<fuku_protected_region>& regions, fuku_settings_obfuscation& settings) {
    ob_profile.items.push_back({ fuku_code_analyzer() , settings, regions });
}

void fuku_settings_mgr::add_vm_profile(const std::vector<fuku_protected_region>& regions, fuku_settings_virtualization& settings) {

    fuku_virtualization_environment env(settings.get_virtualizer());
    auto& vm_profile = vm_profiles.find(env);

    if (vm_profile != vm_profiles.end()) {
        vm_profile->second.items.push_back({ fuku_code_analyzer() , settings.get_obfuscation_settings(), regions });
    }
    else {
        vm_profiles[env] = {

            std::vector<fuku_protected_region>(),
            std::map<uint64_t, uint64_t>(),
            std::vector<fuku_image_relocation>(),

            std::vector<fuku_protection_item>(1,{ fuku_code_analyzer() , settings.get_obfuscation_settings(), regions })
        };
    }
}
```

`furikuri/fuku_settings_mgr.h`:

```h
#pragma once

enum fuku_protect_mgr_result {
    fuku_protect_ok,
    fuku_protect_err_code_range,
    fuku_protect_err_initialization,
    fuku_protect_err_processing,
    fuku_protect_err_post_processing,
    fuku_protect_err_module_processing,
};

enum fuku_protect_stage {
    fuku_protect_stage_start,
    fuku_protect_stage_check,
    fuku_protect_stage_initialization,
    fuku_protect_stage_processing,
    fuku_protect_stage_post_processing,
    fuku_protect_stage_finish_processing,
    fuku_protect_stage_full
};


struct fuku_protected_region {
    uint32_t region_rva;
    uint32_t region_size;
};

struct fuku_protection_item {
    fuku_code_analyzer an_code;
    fuku_settings_obfuscation settings;
    std::vector<fuku_protected_region> regions;
};

struct fuku_protection_profile {
    std::vector<fuku_protected_region> regions;
    std::map<uint64_t, uint64_t>  association_table;
    std::vector<fuku_image_relocation>  relocation_table;

    std::vector<fuku_protection_item> items;
};


class fuku_settings_mgr {
    fuku_protect_stage stage_code;
    fuku_protect_mgr_result result_code;

    pe_image_full target_module;

    fuku_protection_profile ob_profile;

    std::map<
        fuku_virtualization_environment,
        fuku_protection_profile
    > vm_profiles;

    bool module_used_relocations;
public:
    fuku_settings_mgr();
    fuku_settings_mgr(const fuku_settings_mgr& mgr_set);
    ~fuku_settings_mgr();

    fuku_settings_mgr& operator=(const fuku_settings_mgr& mgr_set);

    void add_ob_profile(const std::vector<fuku_protected_region>& regions, fuku_settings_obfuscation& settings);
    void add_vm_profile(const std::vector<fuku_protected_region>& regions, fuku_settings_virtualization& settings);
public:

    void set_target_module(const pe_image_full& target_module);

    void set_ob_profile(const fuku_protection_profile& ob_profile);
    void set_vm_profiles(const std::map <
        fuku_virtualization_environment,
        fuku_protection_profile>& vm_profiles);

    void set_module_used_relocations(bool used);

    void set_result_code(fuku_protect_mgr_result code);
    void set_stage_code(fuku_protect_stage code);
public:

    pe_image_full& get_target_module();
    const pe_image_full& get_target_module() const;

    fuku_protection_profile& get_ob_profile();
    const fuku_protection_profile& get_ob_profile() const;

    std::map<
        fuku_virtualization_environment,
        fuku_protection_profile
    >& get_vm_profiles();

    const std::map<
        fuku_virtualization_environment,
        fuku_protection_profile
    >& get_vm_profiles() const;

    bool is_module_used_relocations() const;

    fuku_protect_mgr_result get_result_code() const;
    fuku_protect_stage get_stage_code() const;
};


```

`furikuri/fuku_settings_obfuscation.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_settings_obfuscation.h"


fuku_settings_obfuscation::fuku_settings_obfuscation() 
    :complexity(0), number_of_passes(0), junk_chance(0), block_chance(0),
    mutate_chance(0), asm_cfg(0), not_allowed_unstable_stack(false), not_allowed_relocations(false) {}

fuku_settings_obfuscation::fuku_settings_obfuscation(unsigned int complexity, unsigned int number_of_passes,
    float junk_chance, float block_chance, float mutate_chance, uint8_t asm_cfg,
    bool not_allowed_unstable_stack, bool not_allowed_relocations)
    :complexity(complexity), number_of_passes(number_of_passes), junk_chance(junk_chance), block_chance(block_chance),
    mutate_chance(mutate_chance), asm_cfg(asm_cfg), 
    not_allowed_unstable_stack(not_allowed_unstable_stack), not_allowed_relocations(not_allowed_relocations) {}

fuku_settings_obfuscation::fuku_settings_obfuscation(const fuku_settings_obfuscation& obf_set) {
    operator=(obf_set);
}

fuku_settings_obfuscation::~fuku_settings_obfuscation() {

}
fuku_settings_obfuscation& fuku_settings_obfuscation::operator=(const fuku_settings_obfuscation& obf_set) {
    this->complexity        = obf_set.complexity;
    this->number_of_passes  = obf_set.number_of_passes;
    this->junk_chance       = obf_set.junk_chance;
    this->block_chance      = obf_set.block_chance;
    this->mutate_chance     = obf_set.mutate_chance;
    this->asm_cfg           = obf_set.asm_cfg;
    this->not_allowed_unstable_stack = obf_set.not_allowed_unstable_stack;
    this->not_allowed_relocations = obf_set.not_allowed_relocations;
    return *this;
}

bool fuku_settings_obfuscation::operator==(const fuku_settings_obfuscation& obf_set) const {
    return (
            this->complexity == obf_set.complexity && this->number_of_passes == obf_set.number_of_passes &&
            this->junk_chance == obf_set.junk_chance && this->block_chance == obf_set.block_chance &&
            this->mutate_chance == obf_set.mutate_chance && this->asm_cfg == obf_set.asm_cfg &&
            this->not_allowed_unstable_stack == obf_set.not_allowed_unstable_stack &&
            this->not_allowed_relocations == obf_set.not_allowed_relocations
          );
}

void fuku_settings_obfuscation::set_complexity(unsigned int complexity) {
    this->complexity = complexity;
}
void fuku_settings_obfuscation::set_number_of_passes(unsigned int passes) {
    this->number_of_passes = passes;
}
void fuku_settings_obfuscation::set_junk_chance(float chance) {
    this->junk_chance = chance;
}
void fuku_settings_obfuscation::set_block_chance(float chance) {
    this->block_chance = chance;
}
void fuku_settings_obfuscation::set_mutate_chance(float chance) {
    this->mutate_chance = chance;
}
void fuku_settings_obfuscation::set_asm_cfg(uint8_t flags) {
    this->asm_cfg = flags;
}
void fuku_settings_obfuscation::set_not_allowed_unstable_stack(bool en) {
    this->not_allowed_unstable_stack = en;
}
void fuku_settings_obfuscation::set_not_allowed_relocations(bool en) {
    this->not_allowed_relocations = en;
}

unsigned int fuku_settings_obfuscation::get_complexity() const {
    return this->complexity;
}
unsigned int fuku_settings_obfuscation::get_number_of_passes() const {
    return this->number_of_passes;
}
float   fuku_settings_obfuscation::get_junk_chance() const {
    return this->junk_chance;
}
float   fuku_settings_obfuscation::get_block_chance() const {
    return this->block_chance;
}
float   fuku_settings_obfuscation::get_mutate_chance() const {
    return this->mutate_chance;
}
uint8_t fuku_settings_obfuscation::get_asm_cfg() const {
    return this->asm_cfg;
}
bool fuku_settings_obfuscation::is_not_allowed_unstable_stack() const {
    return this->not_allowed_unstable_stack;
}
bool fuku_settings_obfuscation::is_not_allowed_relocations() const {
    return this->not_allowed_relocations;
}

bool fuku_settings_obfuscation::is_null() const {
    return !(
        this->complexity ||
        this->number_of_passes ||
        this->junk_chance ||
        this->block_chance ||
        this->mutate_chance ||
        this->asm_cfg ||
        this->not_allowed_unstable_stack ||
        this->not_allowed_relocations
        );
}
```

`furikuri/fuku_settings_obfuscation.h`:

```h
#pragma once


class fuku_settings_obfuscation {
    unsigned int complexity;        //number of passes for single line
    unsigned int number_of_passes;  //number of passes for full code
    float junk_chance;   //0.f - 100.f chance of adding junk
    float block_chance;  //0.f - 100.f chance of generation new code graph
    float mutate_chance; //0.f - 100.f chance of mutation line
    uint8_t asm_cfg; //assambler builder flags

    bool not_allowed_unstable_stack; //if true then obfuscator dont use stack above esp
    bool not_allowed_relocations; //if true then obfuscator dont create new relocations in code

public:
    fuku_settings_obfuscation();
    fuku_settings_obfuscation(unsigned int complexity,unsigned int number_of_passes,
    float junk_chance,float block_chance,float mutate_chance,uint8_t asm_cfg, 
        bool not_allowed_unstable_stack = false, bool not_allowed_relocations = false);

    fuku_settings_obfuscation(const fuku_settings_obfuscation& obf_set);
    ~fuku_settings_obfuscation();
    fuku_settings_obfuscation& operator=(const fuku_settings_obfuscation& obf_set);
    bool operator==(const fuku_settings_obfuscation& obf_set) const;
public:
    void set_complexity(unsigned int complexity);
    void set_number_of_passes(unsigned int passes);
    void set_junk_chance(float chance);
    void set_block_chance(float chance);
    void set_mutate_chance(float chance);
    void set_asm_cfg(uint8_t flags);
    void set_not_allowed_unstable_stack(bool en);
    void set_not_allowed_relocations(bool en);

public:
    unsigned int get_complexity() const;
    unsigned int get_number_of_passes() const;
    float   get_junk_chance() const;
    float   get_block_chance() const;
    float   get_mutate_chance() const;
    uint8_t get_asm_cfg() const;
    
    bool is_not_allowed_unstable_stack() const;
    bool is_not_allowed_relocations() const;

    bool is_null() const;
};


```

`furikuri/fuku_settings_virtualization.cpp`:

```cpp
#include "stdafx.h"
#include "fuku_settings_virtualization.h"


fuku_virtualization_environment::fuku_virtualization_environment() 
    :virtualizer(0) {}

fuku_virtualization_environment::fuku_virtualization_environment(fuku_virtualizer *  virtualizer)
    : virtualizer(virtualizer) {}

fuku_virtualization_environment::fuku_virtualization_environment(const fuku_virtualization_environment& env) {
    operator=(env);
}

fuku_virtualization_environment::~fuku_virtualization_environment() {

}

fuku_virtualization_environment& fuku_virtualization_environment::operator=(const fuku_virtualization_environment& env) {
    this->virtualizer = env.virtualizer;

    return *this;
}

bool fuku_virtualization_environment::operator==(const fuku_virtualization_environment& env) const {
    return this->virtualizer == env.virtualizer;
}

bool fuku_virtualization_environment::operator<(const fuku_virtualization_environment& rhs) const {
    return this->virtualizer < rhs.virtualizer;
}


void fuku_virtualization_environment::set_virtualizer(fuku_virtualizer * virt) {
    this->virtualizer = virt;
}

const fuku_virtualizer *  fuku_virtualization_environment::get_virtualizer() const {
    return this->virtualizer;
}

fuku_virtualizer *  fuku_virtualization_environment::get_virtualizer() {
    return this->virtualizer;
}

fuku_settings_virtualization::fuku_settings_virtualization() 
 : virtualizer(0){}

fuku_settings_virtualization::fuku_settings_virtualization(const fuku_settings_obfuscation& ob_settings, fuku_virtualizer* virtualizer)
    : ob_settings(ob_settings), virtualizer(virtualizer) {}

fuku_settings_virtualization::fuku_settings_virtualization(const fuku_settings_virtualization& virt_set) {
    operator=(virt_set);
}

fuku_settings_virtualization::~fuku_settings_virtualization() {

}

fuku_settings_virtualization& fuku_settings_virtualization::operator=(const fuku_settings_virtualization& virt_set) {
    this->ob_settings = virt_set.ob_settings;
    this->virtualizer = virt_set.virtualizer;

    return *this;
}
void fuku_settings_virtualization::set_obfuscation_settings(const fuku_settings_obfuscation& settings) {
    this->ob_settings = settings;
}
void fuku_settings_virtualization::set_virtualizer(fuku_virtualizer * virt) {
    this->virtualizer = virt;
}

const fuku_settings_obfuscation& fuku_settings_virtualization::get_obfuscation_settings() const {
    return this->ob_settings;
}

const fuku_virtualizer * fuku_settings_virtualization::get_virtualizer() const {
    return this->virtualizer;
}

fuku_virtualizer * fuku_settings_virtualization::get_virtualizer() {
    return this->virtualizer;
}
```

`furikuri/fuku_settings_virtualization.h`:

```h
#pragma once

class fuku_virtualization_environment {
    fuku_virtualizer *  virtualizer;

public:
    fuku_virtualization_environment();
    fuku_virtualization_environment(fuku_virtualizer *  virtualizer);
    fuku_virtualization_environment(const fuku_virtualization_environment& env);
    fuku_virtualization_environment& operator=(const fuku_virtualization_environment& env);

    ~fuku_virtualization_environment();

    bool operator==(const fuku_virtualization_environment& env) const;
    bool operator<(const fuku_virtualization_environment& rhs) const;

public:
    void set_virtualizer(fuku_virtualizer * virt);

public:
    const fuku_virtualizer *  get_virtualizer() const;
    fuku_virtualizer *  get_virtualizer();

};

class fuku_settings_virtualization {
    fuku_settings_obfuscation ob_settings;
    fuku_virtualizer * virtualizer;

public:
    fuku_settings_virtualization();
    fuku_settings_virtualization(const fuku_settings_obfuscation& ob_settings, fuku_virtualizer * virtualizer);
    fuku_settings_virtualization(const fuku_settings_virtualization& virt_set);
    ~fuku_settings_virtualization();

    fuku_settings_virtualization& operator=(const fuku_settings_virtualization& virt_set);
public:
    void set_obfuscation_settings(const fuku_settings_obfuscation& settings);
    void set_virtualizer(fuku_virtualizer * virt);

public:
    const fuku_settings_obfuscation& get_obfuscation_settings() const;
    const fuku_virtualizer * get_virtualizer() const;
    fuku_virtualizer * get_virtualizer();
};


```

`furikuri/fuku_virtualizer_imp.h`:

```h
#pragma once

enum fuku_vm_result {
    fuku_vm_ok,

    fuku_vm_not_supported_settings,
    fuku_vm_not_supported_instruction,
    fuku_vm_not_supported_arch,

    fuku_vm_internal_error
};

class fuku_virtualizer {

public:
    virtual ~fuku_virtualizer() {};

    //virtual fuku_vm_result build_bytecode(shibari_module& target_module, fuku_code_holder& code_holder,
    //    std::vector<uint32_t>& external_calls_dst, std::vector<fuku_image_relocation>& relocation_table) = 0;

    virtual std::vector<uint8_t> create_vm_jumpout(uint64_t source_address, std::vector<fuku_image_relocation>& relocation_table) const = 0;
    virtual std::vector<uint8_t> get_bytecode() const = 0;

    virtual fuku_assambler_arch get_target_arch() const { return fuku_assambler_arch::FUKU_ASSAMBLER_ARCH_X86; };
};
```

`furikuri/furikuri.cpp`:

```cpp
#include "stdafx.h"
#include "furikuri.h"



furikuri_protection_entry::furikuri_protection_entry() 
 :type(FURIKURI_PROTECTION_TYPE_NONE), virtualizer(0){}

furikuri_protection_entry::furikuri_protection_entry(furikuri_protection_type type, const std::vector<fuku_protected_region>& regions,
    const fuku_settings_obfuscation& settings, fuku_virtualizer* virtualizer)
    : type(type), functions(regions), settings(settings), virtualizer(virtualizer){}

furikuri_protection_entry::furikuri_protection_entry(const furikuri_protection_entry& list) {
    operator=(list);
}

furikuri_protection_entry::~furikuri_protection_entry() {

}

furikuri_protection_entry& furikuri_protection_entry::operator=(const furikuri_protection_entry& list) {
    this->functions     = list.functions;
    this->type          = list.type;
    this->settings      = list.settings;
    this->virtualizer   = list.virtualizer;

    return *this;
}

void furikuri_protection_entry::set_type(furikuri_protection_type type) {
    this->type = type;
}

void furikuri_protection_entry::set_functions(const std::vector<fuku_protected_region>& functions) {
    this->functions = functions;
}
void furikuri_protection_entry::set_settings(const fuku_settings_obfuscation& settings) {
    this->settings = settings;
}
void furikuri_protection_entry::set_virtualizer(fuku_virtualizer * virt) {
    this->virtualizer = virt;
}


std::vector<fuku_protected_region>& furikuri_protection_entry::get_functions() {
    return this->functions;
}
fuku_settings_obfuscation& furikuri_protection_entry::get_settings() {
    return this->settings;
}
fuku_virtualizer * furikuri_protection_entry::get_virtualizer() {
    return this->virtualizer;
}

const furikuri_protection_type furikuri_protection_entry::get_type() const {
    return this->type;
}
const std::vector<fuku_protected_region>& furikuri_protection_entry::get_functions() const {
    return this->functions;
}
const fuku_settings_obfuscation& furikuri_protection_entry::get_settings() const {
    return this->settings;
}
const fuku_virtualizer * furikuri_protection_entry::get_virtualizer() const {
    return this->virtualizer;
}

furikuri::furikuri()
:_image(0){}

furikuri::~furikuri(){

    if (_image) {
        delete _image; _image = 0;
    }
}


bool furikuri::fuku_protect(std::vector<uint8_t>& out_image) {

    bool main_has_relocations = _image->get_relocations().size() != 0;

    fuku_protect_mgr protect_manager;

    protect_manager.get_settings().set_target_module(*_image);
    protect_manager.get_settings().set_module_used_relocations(main_has_relocations);

    for (auto& list : protect_list) {

        if (list.get_type() == FURIKURI_PROTECTION_TYPE_OBFUSCATION) {
            protect_manager.add_ob_profile(list.get_functions(), list.get_settings());
        }
        else {

            protect_manager.add_vm_profile(list.get_functions(), fuku_settings_virtualization(
                list.get_settings(),
                list.get_virtualizer()
            ));
        }
        
    }

    fuku_protect_mgr_result code = protect_manager.step_to_stage(fuku_protect_stage_full);

    if (code == fuku_protect_ok) {

        build_pe_image_full(protect_manager.get_settings().get_target_module(),
            PE_IMAGE_BUILD_ALL_EXTENDED_SECTIONS | (PE_IMAGE_BUILD_ALL_DIRECTORIES & ~(PE_IMAGE_BUILD_DIR_IMPORT)), out_image);

        return true;
    }

    return false;
}

bool furikuri::fuku_protect(const fuku_settings_mgr& mgr_settings, std::vector<uint8_t>& out_image) {

    fuku_protect_mgr protect_manager;

    protect_manager_load_snapshot(protect_manager, mgr_settings);

    fuku_protect_mgr_result code = protect_manager.step_to_stage(fuku_protect_stage_full);

    if (code == fuku_protect_ok) {

        build_pe_image_full(protect_manager.get_settings().get_target_module(),
            PE_IMAGE_BUILD_ALL_EXTENDED_SECTIONS | (PE_IMAGE_BUILD_ALL_DIRECTORIES & ~(PE_IMAGE_BUILD_DIR_IMPORT)), out_image);

        return true;
    }

    return false;
}

bool furikuri::create_snapshot(fuku_settings_mgr& mgr_settings, fuku_protect_stage stage) {

    bool main_has_relocations = _image->get_relocations().size() != 0;

    mgr_settings.set_target_module(*_image);
    mgr_settings.set_module_used_relocations(main_has_relocations);

    for (auto& list : protect_list) {

        if (list.get_type() == FURIKURI_PROTECTION_TYPE_OBFUSCATION) {
            mgr_settings.add_ob_profile(list.get_functions(), list.get_settings());
        }
        else {

            mgr_settings.add_vm_profile(list.get_functions(), fuku_settings_virtualization(
                list.get_settings(),
                list.get_virtualizer()
            ));
        }

    }

    return protect_manager_create_stage_snapshot(mgr_settings, stage);
}

bool furikuri::set_image_protect(const pe_image& _module) {

    if (this->_image) {
        delete this->_image; this->_image = 0;
    }

    this->_image = new pe_image_full(_module);

    pe_placement placement;
  //  get_directories_placement(this->_image->get_image(), placement, &this->_image->get_bound_imports());

    placement.clear();
    get_placement_export_directory(this->_image->get_image(), placement);
    get_placement_resources_directory(this->_image->get_image(), placement);
    get_placement_exceptions_directory(this->_image->get_image(), placement);
    get_placement_security_directory(this->_image->get_image(), placement);
    get_placement_relocation_directory(this->_image->get_image(), placement);
    get_placement_debug_directory(this->_image->get_image(), placement);
    get_placement_tls_directory(this->_image->get_image(), placement);
    get_placement_load_config_directory(this->_image->get_image(), placement);
    get_placement_bound_import_directory(this->_image->get_image(), placement);
    get_placement_delay_import_directory(this->_image->get_image(), placement, this->_image->get_bound_imports());

    pe_erase_placement(this->_image->get_image(), placement, &this->_image->get_relocations(), true);

    return true;
}

bool furikuri::set_image_protect(const std::string& module_path) {

    if (this->_image) {
        delete this->_image; this->_image = 0;
    }

    pe_image new_image(module_path);

    if (new_image.get_image_status() == pe_image_status::pe_image_status_ok) {

        this->_image = new pe_image_full(new_image);

        pe_placement placement;
        get_directories_placement(this->_image->get_image(), placement, &this->_image->get_bound_imports());
        pe_erase_placement(this->_image->get_image(), placement, &this->_image->get_relocations(), true);

        return true;
    }

    return false;
}


bool furikuri::add_ob_code_list(fuku_protected_region region, fuku_settings_obfuscation& settings) {


    for (auto& list : protect_list) {

        if (list.get_type() == FURIKURI_PROTECTION_TYPE_OBFUSCATION) {
            if (list.get_settings() == settings) {
                list.get_functions().push_back(region);

                return true;
            }
        }
    }

    protect_list.push_back(furikuri_protection_entry(
        FURIKURI_PROTECTION_TYPE_OBFUSCATION,
        std::vector<fuku_protected_region>(1, region),
        settings,
        0
    ));

    return true;

}

bool furikuri::add_vm_code_list(fuku_protected_region region, fuku_settings_virtualization& settings) {

    for (auto& list : protect_list) {

        if (list.get_type() == FURIKURI_PROTECTION_TYPE_VIRTUALIZATION) {
            if (list.get_settings() == settings.get_obfuscation_settings() &&
                list.get_virtualizer() == settings.get_virtualizer()) {

                list.get_functions().push_back(region);
                return true;
            }
        }
    }

    protect_list.push_back(furikuri_protection_entry(
        FURIKURI_PROTECTION_TYPE_VIRTUALIZATION,
        std::vector<fuku_protected_region>(1, region),
        settings.get_obfuscation_settings(),
        settings.get_virtualizer()
    ));

    return true;

}

void furikuri::clear_protect_list() {
    this->protect_list.clear();
}

const std::vector<furikuri_protection_entry> & furikuri::get_protect_list() const {
    return this->protect_list;
}
 
pe_image_full* furikuri::get_image() {
    return this->_image;
}
```

`furikuri/furikuri.h`:

```h
#pragma once

using namespace fukutasm;

class fuku_code_analyzer;
class fuku_code_profiler;
class fuku_mutation;
class fuku_virtualizer;
class fuku_obfuscator;



//#include "psyche_storage.h"
#include "fuku_settings_obfuscation.h"
#include "fuku_settings_virtualization.h"
#include "fuku_obfuscator.h"
#include "fuku_virtualizer_imp.h"
#include "fuku_protect_mgr.h"



enum furikuri_protection_type {
    FURIKURI_PROTECTION_TYPE_NONE,
    FURIKURI_PROTECTION_TYPE_OBFUSCATION,
    FURIKURI_PROTECTION_TYPE_VIRTUALIZATION,
};

class furikuri_protection_entry {
    furikuri_protection_type type;

    std::vector<fuku_protected_region> functions;

    fuku_settings_obfuscation settings;

    fuku_virtualizer* virtualizer;

public:
    furikuri_protection_entry();
    furikuri_protection_entry(furikuri_protection_type type, const std::vector<fuku_protected_region>& regions,
        const fuku_settings_obfuscation& settings, fuku_virtualizer* virtualizer);

    furikuri_protection_entry(const furikuri_protection_entry& list);
    ~furikuri_protection_entry();

    furikuri_protection_entry& operator=(const furikuri_protection_entry& list);
public:
    void set_type(furikuri_protection_type type);
    void set_functions(const std::vector<fuku_protected_region>& functions);
    void set_settings(const fuku_settings_obfuscation& settings);
    void set_virtualizer(fuku_virtualizer* virt);

public:
    std::vector<fuku_protected_region>& get_functions();
    fuku_settings_obfuscation& get_settings();
    fuku_virtualizer* get_virtualizer();

public:
    const furikuri_protection_type get_type() const;
    const std::vector<fuku_protected_region>& get_functions() const;
    const fuku_settings_obfuscation& get_settings() const;
    const fuku_virtualizer* get_virtualizer() const;

};

class furikuri {

    pe_image_full * _image;
    std::vector<furikuri_protection_entry> protect_list;

public:
    furikuri();
    ~furikuri();

    bool fuku_protect(std::vector<uint8_t>& out_image); //for custom settings
    bool fuku_protect(const fuku_settings_mgr& mgr_settings, std::vector<uint8_t>& out_image); //for snapshot settings

    bool create_snapshot(fuku_settings_mgr& mgr_settings, fuku_protect_stage stage);

public:
    bool set_image_protect(const pe_image& _module);
    bool set_image_protect(const std::string& module_path);

    bool add_ob_code_list(fuku_protected_region region, fuku_settings_obfuscation& settings);
    bool add_vm_code_list(fuku_protected_region region, fuku_settings_virtualization& settings);

    void clear_protect_list();

public:
    const std::vector<furikuri_protection_entry>& get_protect_list() const;
    pe_image_full* get_image();

};


```

`furikuri/furikuri.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{88F9CD6C-BF6D-473B-A4A0-EDB1C7F57C62}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>furikuri</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="fuku_mutation_imp.h" />
    <ClInclude Include="fuku_mutation_x64_junk.h" />
    <ClInclude Include="fuku_mutation_x64_rules.h" />
    <ClInclude Include="fuku_mutation_x86_junk.h" />
    <ClInclude Include="fuku_mutation_x86_rules.h" />
    <ClInclude Include="fuku_protect_mgr.h" />
    <ClInclude Include="fuku_protect_obfuscator_mgr.h" />
    <ClInclude Include="fuku_protect_virtualizer_mgr.h" />
    <ClInclude Include="fuku_settings_obfuscation.h" />
    <ClInclude Include="fuku_settings_mgr.h" />
    <ClInclude Include="fuku_settings_virtualization.h" />
    <ClInclude Include="fuku_virtualizer_imp.h" />
    <ClInclude Include="furikuri.h" />
    <ClInclude Include="fuku_obfuscator.h" />
    <ClInclude Include="fuku_mutation_x64.h" />
    <ClInclude Include="fuku_mutation_x86.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_adc_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_add_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_and_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_bsf_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_bsr_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_btc_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_btr_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_bts_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_bt_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_call_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_cmp_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_dec_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_div_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_idiv_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_imul_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_inc_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_jcc_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_jmp_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_lea_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_mov_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_mul_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_neg_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_not_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_or_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_pop_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_push_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_rcl_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_rcr_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_ret_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_rol_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_ror_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_sar_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_sbb_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_shl_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_shr_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_sub_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_test_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_xchg_templates.h" />
    <ClInclude Include="obf_templates\x64\obf_x64_xor_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_adc_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_add_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_and_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_bsf_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_bsr_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_btc_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_btr_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_bts_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_bt_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_call_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_cmp_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_dec_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_div_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_idiv_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_imul_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_inc_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_jcc_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_jmp_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_lea_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_mov_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_mul_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_neg_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_not_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_or_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_pop_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_push_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_rcl_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_rcr_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_ret_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_rol_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_ror_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_sar_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_sbb_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_shl_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_shr_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_sub_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_test_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_xchg_templates.h" />
    <ClInclude Include="obf_templates\x86\obf_x86_xor_templates.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="fuku_mutation_x64.cpp" />
    <ClCompile Include="fuku_mutation_x64_junk.cpp" />
    <ClCompile Include="fuku_mutation_x64_rules.cpp" />
    <ClCompile Include="fuku_mutation_x86.cpp" />
    <ClCompile Include="fuku_mutation_x86_junk.cpp" />
    <ClCompile Include="fuku_mutation_x86_rules.cpp" />
    <ClCompile Include="fuku_protect_mgr.cpp" />
    <ClCompile Include="fuku_settings_obfuscation.cpp" />
    <ClCompile Include="fuku_settings_mgr.cpp" />
    <ClCompile Include="fuku_settings_virtualization.cpp" />
    <ClCompile Include="furikuri.cpp" />
    <ClCompile Include="fuku_obfuscator.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`furikuri/furikuri.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Файлы исходного кода">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri">
      <UniqueIdentifier>{47d56a82-b17d-4269-87c2-b1f5200dd68c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_protector">
      <UniqueIdentifier>{b1ec361b-10a5-4861-b39b-f8c1d18bb7d1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_settings">
      <UniqueIdentifier>{018367a8-16f5-4914-a556-c80f07e66243}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_settings\obfuscation">
      <UniqueIdentifier>{be5e046d-67f2-42ed-80ce-a9d082133ead}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_settings\virtualization">
      <UniqueIdentifier>{e74ba585-4bc3-4d09-a96f-976cf0fc1bce}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_protector\obfuscator">
      <UniqueIdentifier>{3bb0ab87-e93b-416a-807d-e4ae9cee945a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp">
      <UniqueIdentifier>{be02e024-84aa-40da-8397-1033a70cfd64}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86">
      <UniqueIdentifier>{1bed7b29-aa69-4f65-b0f2-ff60b7b0b303}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64">
      <UniqueIdentifier>{8c1583e0-a42d-4039-84a1-24d892d64829}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_protector\virtualizer">
      <UniqueIdentifier>{b10e78d1-0510-4dbb-94cd-b99a543cb725}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_protect_mgr">
      <UniqueIdentifier>{c0c9f967-82f1-4350-9757-80f028b78f15}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_settings\mgr">
      <UniqueIdentifier>{1ea0a418-5928-4831-a7f1-fc60eb31c3c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_vm_ir">
      <UniqueIdentifier>{2e27f76f-78a3-42f2-8a73-7fb2a473a903}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_vm_ir\block">
      <UniqueIdentifier>{67fa11fb-3749-4854-9c9f-b2045bbd6804}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_vm_ir\cmd">
      <UniqueIdentifier>{356b733e-855a-4db9-8f4f-2200118397f6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_vm_ir\handler">
      <UniqueIdentifier>{c3cc9aed-d9e1-41f3-a1ca-daa79f2883e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_vm_ir\pcode">
      <UniqueIdentifier>{75567c6c-a812-4f92-b2cf-a7b2bf10fb94}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates">
      <UniqueIdentifier>{d513f199-091d-49be-8dc8-ac8a34970c83}</UniqueIdentifier>
    </Filter>
    <Filter Include="Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates">
      <UniqueIdentifier>{aa28bac6-746a-447f-a0ad-ee7c261d0935}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Заголовочные файлы</Filter>
    </ClInclude>
    <ClInclude Include="furikuri.h">
      <Filter>Заголовочные файлы\furikuri</Filter>
    </ClInclude>
    <ClInclude Include="fuku_obfuscator.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator</Filter>
    </ClInclude>
    <ClInclude Include="fuku_mutation_x64.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64</Filter>
    </ClInclude>
    <ClInclude Include="fuku_mutation_x86.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86</Filter>
    </ClInclude>
    <ClInclude Include="fuku_mutation_imp.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp</Filter>
    </ClInclude>
    <ClInclude Include="fuku_virtualizer_imp.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\virtualizer</Filter>
    </ClInclude>
    <ClInclude Include="fuku_protect_obfuscator_mgr.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protect_mgr</Filter>
    </ClInclude>
    <ClInclude Include="fuku_protect_virtualizer_mgr.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protect_mgr</Filter>
    </ClInclude>
    <ClInclude Include="fuku_protect_mgr.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protect_mgr</Filter>
    </ClInclude>
    <ClInclude Include="fuku_settings_obfuscation.h">
      <Filter>Заголовочные файлы\furikuri\fuku_settings\obfuscation</Filter>
    </ClInclude>
    <ClInclude Include="fuku_settings_virtualization.h">
      <Filter>Заголовочные файлы\furikuri\fuku_settings\virtualization</Filter>
    </ClInclude>
    <ClInclude Include="fuku_settings_mgr.h">
      <Filter>Заголовочные файлы\furikuri\fuku_settings\mgr</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_adc_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_add_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_and_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_bsf_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_bsr_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_bt_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_btc_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_btr_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_bts_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_call_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_cmp_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_dec_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_div_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_idiv_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_imul_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_inc_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_jcc_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_jmp_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_lea_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_mov_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_mul_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_neg_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_not_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_or_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_pop_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_push_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_rcl_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_rcr_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_ret_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_rol_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_ror_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_sar_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_sbb_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_shl_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_shr_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_sub_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_test_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_xchg_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x86\obf_x86_xor_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86\templates</Filter>
    </ClInclude>
    <ClInclude Include="fuku_mutation_x86_rules.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86</Filter>
    </ClInclude>
    <ClInclude Include="fuku_mutation_x64_rules.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_adc_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_add_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_and_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_bsf_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_bsr_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_bt_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_btc_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_btr_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_bts_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_call_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_cmp_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_dec_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_div_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_idiv_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_imul_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_inc_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_jcc_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_jmp_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_lea_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_mov_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_mul_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_neg_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_not_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_or_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_pop_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_push_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_rcl_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_rcr_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_ret_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_rol_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_ror_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_sar_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_sbb_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_shl_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_shr_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_sub_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_test_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_xchg_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="obf_templates\x64\obf_x64_xor_templates.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64\templates</Filter>
    </ClInclude>
    <ClInclude Include="fuku_mutation_x86_junk.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86</Filter>
    </ClInclude>
    <ClInclude Include="fuku_mutation_x64_junk.h">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
    <ClCompile Include="furikuri.cpp">
      <Filter>Заголовочные файлы\furikuri</Filter>
    </ClCompile>
    <ClCompile Include="fuku_obfuscator.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator</Filter>
    </ClCompile>
    <ClCompile Include="fuku_mutation_x64.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64</Filter>
    </ClCompile>
    <ClCompile Include="fuku_mutation_x86.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86</Filter>
    </ClCompile>
    <ClCompile Include="fuku_protect_mgr.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_protect_mgr</Filter>
    </ClCompile>
    <ClCompile Include="fuku_settings_obfuscation.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_settings\obfuscation</Filter>
    </ClCompile>
    <ClCompile Include="fuku_settings_virtualization.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_settings\virtualization</Filter>
    </ClCompile>
    <ClCompile Include="fuku_settings_mgr.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_settings\mgr</Filter>
    </ClCompile>
    <ClCompile Include="fuku_mutation_x86_rules.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86</Filter>
    </ClCompile>
    <ClCompile Include="fuku_mutation_x64_rules.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64</Filter>
    </ClCompile>
    <ClCompile Include="fuku_mutation_x86_junk.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x86</Filter>
    </ClCompile>
    <ClCompile Include="fuku_mutation_x64_junk.cpp">
      <Filter>Заголовочные файлы\furikuri\fuku_protector\obfuscator\fuku_mutation_imp\x64</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`furikuri/psyche_block.cpp`:

```cpp
#include "stdafx.h"
#include "psyche_block.h"

psyche_block::psyche_block(uint8_t arch)
    :arch(arch), flags(0){
}

psyche_block::psyche_block(const psyche_block& block) {
    this->operator=(block);
}

psyche_block::psyche_block(uint8_t arch, uint64_t flags,
    size_t block_rva, size_t label_idx)
    :arch(arch), flags(flags), block_rva(block_rva), label_idx(label_idx) {}


psyche_block::~psyche_block() {

}


psyche_block& psyche_block::operator=(const psyche_block& block) {

    this->arch = block.arch;
    this->flags = block.flags;

    this->block_rva = block.block_rva;
    this->label_idx = block.label_idx;

    this->instructions = block.instructions;
    this->properties = block.properties;

    return *this;
}

void psyche_block::set_arch(uint8_t arch) {
    this->arch = arch;
}

void psyche_block::set_flags(uint64_t flags) {
    this->flags = flags;
}

void psyche_block::set_block_rva(uint32_t rva) {
    this->block_rva = rva;
}

void psyche_block::set_label_idx(size_t label) {
    this->label_idx = label;
}

void psyche_block::set_instructions(const psy_instructions& instructions) {
    this->instructions = instructions;
}

void psyche_block::set_properties(const psy_block_props& properties) {
    this->properties = properties;
}

void psyche_block::add_line(fuku_inst* line) {
    instructions[line] = commands_table();
}

uint8_t psyche_block::get_arch() const {
    return this->arch;
}

uint64_t psyche_block::get_flags() const {
    return this->flags;
}

uint32_t psyche_block::get_block_rva() const {
    return this->block_rva;
}

size_t psyche_block::get_label_idx() const {
    return this->label_idx;
}

psy_instructions& psyche_block::get_instructions() {
    return this->instructions;
}

const psy_instructions& psyche_block::get_instructions() const {
    return this->instructions;
}

psy_block_props& psyche_block::get_properties() {
    return this->properties;
}

const psy_block_props& psyche_block::get_properties() const {
    return this->properties;
}

```

`furikuri/psyche_block.h`:

```h
#pragma once

class psyche_block {
    uint8_t arch;

    uint64_t flags;

    uint32_t block_rva;
    size_t label_idx;

    psy_instructions instructions;
    psy_block_props properties;

public:
    psyche_block(uint8_t arch);
    psyche_block(const psyche_block& block);
    psyche_block(uint8_t arch, uint64_t flags,
        size_t block_rva, size_t label_idx);

    ~psyche_block();


    psyche_block& operator=(const psyche_block& block);

    void add_line(fuku_inst* line);
public:
    void set_arch(uint8_t arch);

    void set_block_rva(uint32_t rva);
    void set_label_idx(size_t label);

    void set_flags(uint64_t flags);

    void set_instructions(const psy_instructions& instructions);
    void set_properties(const psy_block_props& properties);

public:
    uint8_t get_arch() const;

    uint64_t get_flags() const;

    uint32_t get_block_rva() const;
    size_t get_label_idx() const;

    psy_instructions& get_instructions();
    const psy_instructions& get_instructions() const;

    psy_block_props& get_properties();
    const psy_block_props& get_properties() const;
};


```

`furikuri/psyche_cmd.cpp`:

```cpp
#include "stdafx.h"
#include "psyche_cmd.h"


psyche_cmd_arg::psyche_cmd_arg()
    :size(0), type(0), value(0) {}

psyche_cmd_arg::psyche_cmd_arg(const psyche_cmd_arg& arg) {
    this->operator=(arg);
}

psyche_cmd_arg::psyche_cmd_arg(uint8_t size, uint32_t type, uint64_t value)
    :size(size), type(type), value(value) {}

psyche_cmd_arg::~psyche_cmd_arg() {

}


psyche_cmd_arg& psyche_cmd_arg::operator=(const psyche_cmd_arg& arg) {

    this->size = arg.size;
    this->type = arg.type;
    this->value = arg.value;

    return *this;
}

void psyche_cmd_arg::set_size(uint8_t size) {
    this->size = size;
}

void psyche_cmd_arg::set_type(uint32_t type) {
    this->type = type;
}

void psyche_cmd_arg::set_value(uint64_t val) {
    this->value = val;
}


uint8_t psyche_cmd_arg::get_size() const {
    return this->size;
}

uint32_t psyche_cmd_arg::get_type() const {
    return this->type;
}

uint64_t psyche_cmd_arg::get_value() const {
    return this->value;
}


psyche_cmd::psyche_cmd() 
    :size(0), opcode(0), parent(0), handler_entry(0), pcode_entry(0) { }

psyche_cmd::psyche_cmd(const psyche_cmd& command) {
    this->operator=(command);
}

psyche_cmd::psyche_cmd(uint8_t size, uint32_t opcode)
    :size(size), opcode(opcode), parent(0), handler_entry(0), pcode_entry(0) { }

psyche_cmd::psyche_cmd(uint8_t size, uint32_t opcode, const psyche_cmd_arg& arg_1)
    : size(size), opcode(opcode), parent(0), handler_entry(0), pcode_entry(0) {

    args.push_back(arg_1);
}

psyche_cmd::psyche_cmd(uint8_t size, uint32_t opcode, const psyche_cmd_arg& arg_1, const psyche_cmd_arg& arg_2)
    : size(size), opcode(opcode), parent(0), handler_entry(0), pcode_entry(0) {

    args.push_back(arg_1);
    args.push_back(arg_2);
}

psyche_cmd::psyche_cmd(uint8_t size, uint32_t opcode, const psyche_cmd_arg& arg_1, const psyche_cmd_arg& arg_2, const psyche_cmd_arg& arg_3)
    : size(size), opcode(opcode), parent(0), handler_entry(0), pcode_entry(0) {

    args.push_back(arg_1);
    args.push_back(arg_2);
    args.push_back(arg_3);
}

psyche_cmd::~psyche_cmd(){}

psyche_cmd& psyche_cmd::operator=(const psyche_cmd& command) {

    this->size = command.size;
    this->opcode = command.opcode;
    this->args = command.args;
    this->parent = command.parent;
    this->handler_entry = command.handler_entry;
    this->pcode_entry = command.pcode_entry;
    return *this;
}

void psyche_cmd::set_size(uint8_t size) {
    this->size = size;
}

void psyche_cmd::set_opcode(uint32_t op) {
    this->opcode = op;
}

void psyche_cmd::set_args(const std::vector<psyche_cmd_arg>& args) {
    this->args = args;
}

void psyche_cmd::set_parent(psyche_block * parent) {
    this->parent = parent;
}

void psyche_cmd::set_handler_entry(psyche_handler* handler_entry) {
    this->handler_entry = handler_entry;
}

void psyche_cmd::set_pcode_entry(psyche_pcode* pcode_entry) {
    this->pcode_entry = pcode_entry;
}

uint8_t psyche_cmd::get_size() const {
    return this->size;
}

uint32_t psyche_cmd::get_opcode() const {
    return this->opcode;
}

const psyche_block* psyche_cmd::get_parent() const {
    return this->parent;
}

psyche_block* psyche_cmd::get_parent() {
    return this->parent;
}

const psyche_handler* psyche_cmd::get_handler_entry() const {
    return this->handler_entry;
}

psyche_handler* psyche_cmd::get_handler_entry() {
    return this->handler_entry;
}

const psyche_pcode* psyche_cmd::get_pcode_entry() const {
    return this->pcode_entry;
}

psyche_pcode* psyche_cmd::get_pcode_entry() {
    return this->pcode_entry;
}

const std::vector<psyche_cmd_arg>& psyche_cmd::get_args() const {
    return this->args;
}

std::vector<psyche_cmd_arg>& psyche_cmd::get_args() {
    return this->args;
}

```

`furikuri/psyche_cmd.h`:

```h
#pragma once

class psyche_cmd_arg {
    uint8_t size;
    uint32_t type;

    uint64_t value;

public:
    psyche_cmd_arg();
    psyche_cmd_arg(const psyche_cmd_arg& arg);
    psyche_cmd_arg(uint8_t size, uint32_t type, uint64_t value);
    ~psyche_cmd_arg();

    psyche_cmd_arg& operator=(const psyche_cmd_arg& arg);
public:
    void set_size(uint8_t size);
    void set_type(uint32_t type);
    void set_value(uint64_t val);

public:
    uint8_t get_size() const;
    uint32_t get_type() const;
    uint64_t get_value() const;
};


class psyche_cmd {
    uint8_t size;
    uint32_t opcode;

    std::vector<psyche_cmd_arg> args;

    psyche_block * parent;

    psyche_handler* handler_entry;
    psyche_pcode* pcode_entry;

public:
    psyche_cmd();
    psyche_cmd(const psyche_cmd& command);
    psyche_cmd(uint8_t size, uint32_t opcode);
    psyche_cmd(uint8_t size, uint32_t opcode, const psyche_cmd_arg& arg_1);
    psyche_cmd(uint8_t size, uint32_t opcode, const psyche_cmd_arg& arg_1, const psyche_cmd_arg& arg_2);
    psyche_cmd(uint8_t size, uint32_t opcode, const psyche_cmd_arg& arg_1, const psyche_cmd_arg& arg_2, const psyche_cmd_arg& arg_3);
    ~psyche_cmd();

    psyche_cmd& operator=(const psyche_cmd& command);
public:
    void set_size(uint8_t size);
    void set_opcode(uint32_t op);
    void set_args(const std::vector<psyche_cmd_arg>& args);
    void set_parent(psyche_block * parent);

    void set_handler_entry(psyche_handler* handler_entry);
    void set_pcode_entry(psyche_pcode* pcode_entry);

public:
    uint8_t get_size() const;
    uint32_t get_opcode() const;
    
    const psyche_block* get_parent() const;
    psyche_block* get_parent();

    const psyche_handler* get_handler_entry() const;
    psyche_handler* get_handler_entry();

    const psyche_pcode* get_pcode_entry() const;
    psyche_pcode* get_pcode_entry();

    const std::vector<psyche_cmd_arg>& get_args() const;
    std::vector<psyche_cmd_arg>& get_args();
};





```

`furikuri/psyche_handler.cpp`:

```cpp
#include "stdafx.h"
#include "psyche_handler.h"


psyche_handler_sign::psyche_handler_sign() {

}

psyche_handler_sign::psyche_handler_sign(const psyche_handler_sign& sign) {
    operator=(sign);
}

psyche_handler_sign::psyche_handler_sign(const psyche_block& parent_block, const psyche_cmd& cmd) {
    this->operator=(std::pair<const psyche_block&, const psyche_cmd&>(parent_block, cmd));
}

psyche_handler_sign::~psyche_handler_sign() {}

psyche_handler_sign& psyche_handler_sign::operator=(const psyche_handler_sign& sign) {

    this->sign = sign.sign;

    return *this;
}

psyche_handler_sign& psyche_handler_sign::operator=(std::pair<const psyche_block&, const psyche_cmd&> cmd) {

    size_t props_size = cmd.first.get_properties().size() * sizeof(uint16_t); 

    for (auto& prop : cmd.first.get_properties()) {
        props_size += sizeof(uint32_t) + (prop.second.size() * sizeof(uint32_t) + sizeof(uint16_t));
    }

    this->sign.resize(
        sizeof(fuku_assambler_arch) + //arch
        sizeof(uint32_t) + sizeof(uint8_t) + //opcode + size
        props_size //props
    );
    
    size_t vec_pos = 0;
    
    *(uint8_t*)&this->sign.data()[vec_pos] = cmd.first.get_arch(); vec_pos += sizeof(uint8_t);
    *(uint32_t*)&this->sign.data()[vec_pos] = cmd.second.get_opcode(); vec_pos += sizeof(uint32_t);
    *(uint8_t*)& this->sign.data()[vec_pos] = cmd.second.get_size(); vec_pos += sizeof(uint8_t);

    *(uint16_t*)&this->sign.data()[vec_pos] = (uint16_t)cmd.first.get_properties().size(); vec_pos += sizeof(uint16_t);

    for (auto prop : cmd.first.get_properties()) {
        *(uint32_t*)&this->sign.data()[vec_pos] = prop.first;  vec_pos += sizeof(uint32_t);
        *(uint16_t*)&this->sign.data()[vec_pos] = (uint16_t)prop.second.size();  vec_pos += sizeof(uint16_t);

        for (auto prop_val : prop.second) {
            *(uint32_t*)&this->sign.data()[vec_pos] = prop_val;  vec_pos += sizeof(uint32_t);
        }
    }


    return *this;
}

bool psyche_handler_sign::operator==(const psyche_handler_sign& sign) const {

    if (this->sign.size() == sign.sign.size() &&
        !memcmp(this->sign.data(), sign.sign.data(), this->sign.size())) {

        return true;
    }

    return false;
}

bool psyche_handler_sign::operator<(const psyche_handler_sign& rsign) const {
 
    return std::tie(sign, static_cast<std::vector<uint8_t> const&>(this->sign)) <
        std::tie(rsign.sign, static_cast<std::vector<uint8_t> const&>(rsign.sign));
}

void psyche_handler_sign::set_sign(std::vector<uint8_t>& sign) {
    this->sign = sign;
}

void psyche_handler_sign::get_extended_sign(psyche_handler_sign_extended& sign) const {
   
    sign.op.opcode = 0;
    sign.op.size = 0;
    sign.properies.clear();

    auto& raw_blob = this->sign;

    size_t vec_pos = 0;

    if (raw_blob.size() >= sizeof(uint8_t)) {
        
        sign.arch = *(uint8_t*)(&raw_blob.data()[vec_pos]); vec_pos += sizeof(uint8_t);

        if (raw_blob.size() >= sizeof(psyche_handler_sign_op_header) + sizeof(uint8_t)) {

            psyche_handler_sign_op_header* op = (psyche_handler_sign_op_header*)(&raw_blob.data()[vec_pos]);
            sign.op.opcode = op->opcode;
            sign.op.size = op->size;

            vec_pos += sizeof(psyche_handler_sign_op_header);


            if (raw_blob.size() > vec_pos) {

                uint16_t props_count = *(uint16_t*)&raw_blob.data()[vec_pos]; vec_pos += sizeof(uint16_t);

                for (uint8_t prop_idx = 0; prop_idx < props_count && raw_blob.size() > vec_pos; prop_idx++) {

                    uint32_t key = *(uint32_t*)&raw_blob.data()[vec_pos]; vec_pos += sizeof(uint32_t);
                    uint16_t val_count = *(uint16_t*)&raw_blob.data()[vec_pos]; vec_pos += sizeof(uint16_t);

                    std::vector<uint32_t> values;

                    for (uint8_t val_idx = 0; val_idx < val_count && raw_blob.size() > vec_pos; val_idx++) {
                        values.push_back(*(uint32_t*)&raw_blob.data()[vec_pos]); vec_pos += sizeof(uint32_t);
                    }

                    sign.properies[key] = values;
                }
            }
        }
    }
}

std::vector<uint8_t>& psyche_handler_sign::get_sign() {
    return this->sign;
}

const std::vector<uint8_t>& psyche_handler_sign::get_sign() const {
    return this->sign;
}

std::vector< psyche_cmd*>& psyche_handler_sign::get_refs() {
    return this->refs;
}

const std::vector< psyche_cmd*>& psyche_handler_sign::get_refs() const {
    return this->refs;
}

psyche_handler::psyche_handler() 
    : handler_label(-1) {}

psyche_handler::psyche_handler(const psyche_handler& handler) {
    this->operator=(handler);
}

psyche_handler::~psyche_handler() {

}

psyche_handler& psyche_handler::operator=(const psyche_handler& handler) {

    this->handler_label = handler.handler_label;
    this->handler_properies = handler.handler_properies;

    return *this;
}

void psyche_handler::set_handler_label(size_t label) {
    this->handler_label = label;
}

size_t psyche_handler::get_handler_label() const {
    return this->handler_label;
}


std::map<uint32_t, uint64_t>& psyche_handler::get_handler_properies() {
    return this->handler_properies;
}

const std::map<uint32_t, uint64_t>& psyche_handler::get_handler_properies() const {
    return this->handler_properies;
}



psyche_handler_manager::psyche_handler_manager() {

}

psyche_handler_manager::~psyche_handler_manager() {

}

void psyche_handler_manager::add_handler(const psyche_handler& handler, const psyche_handler_sign& signature) {

    handlers.push_back(handler);

    auto handle_ptr = &handlers.back();

    handlers_link[signature].push_back(handle_ptr);
    handlers_sign_link[handle_ptr] = signature;
}

void psyche_handler_manager::link_cmd_handler(psyche_cmd* cmd, psyche_handler* handler) {

    handlers_link_table[cmd] = handler;
    cmd->set_handler_entry(handler);
}

std::vector<psyche_handler*>* psyche_handler_manager::get_handler_vec(const psyche_handler_sign& signature) {

    auto link_sign = handlers_link.find(signature);

    if (link_sign != this->handlers_link.end()) {
        return &link_sign->second;
    }
    else {
        return 0;
    }
}

const std::vector<psyche_handler*>* psyche_handler_manager::get_handler_vec(const psyche_handler_sign& signature) const {

    auto link_sign = handlers_link.find(signature);

    if (link_sign != this->handlers_link.end()) {
        return &link_sign->second;
    }
    else {
        return 0;
    }
}

psyche_handler_sign* psyche_handler_manager::get_handler_sign(const psyche_handler* handler) {

    auto link_sign = handlers_sign_link.find((psyche_handler*)handler);

    if (link_sign != this->handlers_sign_link.end()) {
        return &link_sign->second;
    }
    else {
        return 0;
    }
}

const psyche_handler_sign* psyche_handler_manager::get_handler_sign(const psyche_handler* handler) const {

    auto link_sign = handlers_sign_link.find((psyche_handler*)handler);

    if (link_sign != this->handlers_sign_link.end()) {
        return &link_sign->second;
    }
    else {
        return 0;
    }
}

psyche_handler* psyche_handler_manager::get_handler(psyche_cmd* cmd) {
    auto link_handler = this->handlers_link_table.find(cmd);

    if (link_handler != this->handlers_link_table.end()) {
        return link_handler->second;
    }
    else {
        return 0;
    }
}

const psyche_handler* psyche_handler_manager::get_handler(psyche_cmd* cmd) const {
    auto link_handler = this->handlers_link_table.find(cmd);

    if (link_handler != this->handlers_link_table.end()) {
        return link_handler->second;
    }
    else {
        return 0;
    }
}

std::list<psyche_handler>& psyche_handler_manager::get_handlers() {
    return this->handlers;
}

const std::list<psyche_handler>& psyche_handler_manager::get_handlers() const {
    return this->handlers;
}

std::map<psyche_handler*, psyche_handler_sign>& psyche_handler_manager::get_handlers_sign_link() {
    return this->handlers_sign_link;
}

const std::map<psyche_handler*, psyche_handler_sign>& psyche_handler_manager::get_handlers_sign_link() const {
    return this->handlers_sign_link;
}

std::map<psyche_cmd*, psyche_handler*>& psyche_handler_manager::get_handlers_link_table() {
    return this->handlers_link_table;
}
const std::map<psyche_cmd*, psyche_handler*>& psyche_handler_manager::get_handlers_link_table() const {
    return this->handlers_link_table;
}
```

`furikuri/psyche_handler.h`:

```h
#pragma once

#pragma pack(push, 1)

struct psyche_handler_sign_op_header {
    uint32_t opcode;
    uint8_t size;
};

#pragma pack(pop)

struct psyche_handler_sign_extended {
    uint8_t arch;
    psyche_handler_sign_op_header op;
    psy_block_props properies;
};


class psyche_handler_sign {
    std::vector<uint8_t> sign;
    
    std::vector< psyche_cmd*> refs;

public:
    psyche_handler_sign();
    psyche_handler_sign(const psyche_handler_sign& sign);
    psyche_handler_sign(const psyche_block& parent_block, const psyche_cmd& cmd);
    ~psyche_handler_sign();

    psyche_handler_sign& operator=(const psyche_handler_sign& sign);
    psyche_handler_sign& operator=(std::pair<const psyche_block&, const psyche_cmd&> cmd);
    bool operator==(const psyche_handler_sign& sign) const;

    bool operator<(const psyche_handler_sign& sign) const;
public:
    void set_sign(std::vector<uint8_t>& sign);

public:
    void get_extended_sign(psyche_handler_sign_extended& sign) const;

    std::vector<uint8_t>& get_sign();
    const std::vector<uint8_t>& get_sign() const;

    std::vector< psyche_cmd*>& get_refs();
    const std::vector< psyche_cmd*>& get_refs() const;
};


class psyche_handler {
    size_t handler_label;
    std::map<uint32_t, uint64_t> handler_properies;

public:
    psyche_handler();
    psyche_handler(const psyche_handler& handler);
    ~psyche_handler();

    psyche_handler& operator=(const psyche_handler& handler);
public:
    void set_handler_label(size_t label);

public:
    size_t get_handler_label() const;

    std::map<uint32_t, uint64_t>& get_handler_properies();
    const std::map<uint32_t, uint64_t>& get_handler_properies() const;
};


class psyche_handler_manager {

    std::list<psyche_handler> handlers;
    
    std::map<psyche_handler_sign, std::vector<psyche_handler*>> handlers_link;
    std::map<psyche_handler*, psyche_handler_sign> handlers_sign_link;

    std::map<psyche_cmd*, psyche_handler*> handlers_link_table;

public:
    psyche_handler_manager();
    ~psyche_handler_manager();

public:

    void add_handler(const psyche_handler& handler, const psyche_handler_sign& signature);
    void link_cmd_handler(psyche_cmd* cmd, psyche_handler* handler);
  
public:

    std::vector<psyche_handler*>* get_handler_vec(const psyche_handler_sign& signature);
    const std::vector<psyche_handler*>* get_handler_vec(const psyche_handler_sign& signature) const;

    psyche_handler_sign* get_handler_sign(const psyche_handler* handler);
    const psyche_handler_sign* get_handler_sign(const psyche_handler* handler) const;

    psyche_handler* get_handler(psyche_cmd* cmd);
    const psyche_handler* get_handler(psyche_cmd* cmd) const;

    std::list<psyche_handler>& get_handlers();
    const std::list<psyche_handler>& get_handlers() const;

    std::map<psyche_handler_sign, std::vector<psyche_handler*>>& get_handlers_link();
    const std::map<psyche_handler_sign, std::vector<psyche_handler*>>& get_handlers_link() const;

    std::map<psyche_handler*, psyche_handler_sign>& get_handlers_sign_link();
    const std::map<psyche_handler*, psyche_handler_sign>& get_handlers_sign_link() const;

    std::map<psyche_cmd*, psyche_handler*>& get_handlers_link_table();
    const std::map<psyche_cmd*, psyche_handler*>& get_handlers_link_table() const;
};
```

`furikuri/psyche_pcode.cpp`:

```cpp
#include "stdafx.h"
#include "psyche_pcode.h"

psyche_pcode_manager::psyche_pcode_manager() {}
psyche_pcode_manager::~psyche_pcode_manager() {}





void psyche_pcode_manager::add_pcode(const psyche_block* block, psyche_cmd* cmd, const psyche_pcode& pcode_entry) {

}

psyche_pcode * psyche_pcode_manager::get_cmd_pcode(const  psyche_cmd* cmd) {

    auto link_cmd = this->cmd_link_table.find((psyche_cmd*)cmd);

    if (link_cmd != this->cmd_link_table.end()) {
        return link_cmd->second;
    }
    else {
        return 0;
    } 
}

const psyche_pcode * psyche_pcode_manager::get_cmd_pcode(const  psyche_cmd* cmd) const {

    auto link_cmd = this->cmd_link_table.find((psyche_cmd*)cmd);

    if (link_cmd != this->cmd_link_table.end()) {
        return link_cmd->second;
    }
    else {
        return 0;
    }
}

psyche_block_pcode_table * psyche_pcode_manager::get_block_pcode(const psyche_block* block) {

    auto link_block = this->block_link_table.find((psyche_block*)block);

    if (link_block != this->block_link_table.end()) {
        return link_block->second;
    }
    else {
        return 0;
    }
}

const psyche_block_pcode_table * psyche_pcode_manager::get_block_pcode(const  psyche_block* block) const {

    auto link_block = this->block_link_table.find((psyche_block*)block);

    if (link_block != this->block_link_table.end()) {
        return link_block->second;
    }
    else {
        return 0;
    }
}

std::list<psyche_block_pcode_table>&  psyche_pcode_manager::get_block_pcode_table() {
    return this->block_pcode_table;
}

const std::list<psyche_block_pcode_table>&  psyche_pcode_manager::get_block_pcode_table() const {
    return this->block_pcode_table;
}

std::list<psyche_pcode>& psyche_pcode_manager::get_cmd_pcode_table() {
    return this->cmd_pcode_table;
}

const std::list<psyche_pcode>& psyche_pcode_manager::get_cmd_pcode_table() const {
    return this->cmd_pcode_table;
}

std::map<psyche_block*, psyche_block_pcode_table*>& psyche_pcode_manager::get_block_link_table() {
    return this->block_link_table;
}

const std::map<psyche_block*, psyche_block_pcode_table*>& psyche_pcode_manager::get_block_link_table() const {
    return this->block_link_table;
}

std::map<psyche_cmd*, psyche_pcode*>& psyche_pcode_manager::get_cmd_link_table() {
    return this->cmd_link_table;
}

const std::map<psyche_cmd*, psyche_pcode*>& psyche_pcode_manager::get_cmd_link_table() const {
    return this->cmd_link_table;
}
```

`furikuri/psyche_pcode.h`:

```h
#pragma once


struct psyche_pcode_entry {
    uint32_t type;
    uint8_t size;
    uint64_t value;
};

struct psyche_pcode {
    uint32_t entry_rva;
    std::vector<psyche_pcode_entry> entries;
};


struct psyche_block_pcode_table {
    size_t   table_size;
    uint32_t table_rva;

    psyche_block* block;
    std::vector<std::pair<psyche_cmd*, psyche_pcode*>> cmds;
};


class psyche_pcode_manager {

    std::list<psyche_block_pcode_table>  block_pcode_table;
    std::list<psyche_pcode> cmd_pcode_table;

    std::map<psyche_block*, psyche_block_pcode_table*> block_link_table;
    std::map<psyche_cmd*, psyche_pcode*> cmd_link_table;
public:
    psyche_pcode_manager();
    ~psyche_pcode_manager();
 
public:
    
    void add_pcode(const psyche_block* block, psyche_cmd* cmd, const psyche_pcode& pcode_entry);

public:
    
    psyche_pcode * get_cmd_pcode(const psyche_cmd* cmd);
    const psyche_pcode * get_cmd_pcode(const psyche_cmd* cmd) const;

    psyche_block_pcode_table * get_block_pcode(const psyche_block* block);
    const psyche_block_pcode_table * get_block_pcode(const psyche_block* block) const;

    std::list<psyche_block_pcode_table>&  get_block_pcode_table();
    const std::list<psyche_block_pcode_table>&  get_block_pcode_table() const;

    std::list<psyche_pcode>& get_cmd_pcode_table();
    const std::list<psyche_pcode>& get_cmd_pcode_table() const;

    std::map<psyche_block*, psyche_block_pcode_table*>& get_block_link_table();
    const std::map<psyche_block*, psyche_block_pcode_table*>& get_block_link_table() const;

    std::map<psyche_cmd*, psyche_pcode*>& get_cmd_link_table();
    const std::map<psyche_cmd*, psyche_pcode*>& get_cmd_link_table() const;
};
```

`furikuri/psyche_storage.cpp`:

```cpp
#include "stdafx.h"
#include "psyche_storage.h"


psyche_storage::psyche_storage() 
    :target_module(0), code_holder(0) {}

psyche_storage::psyche_storage(shibari_module* target_module, fuku_code_holder* code_holder) 
    :target_module(target_module), code_holder(code_holder) {}

psyche_storage::~psyche_storage() {

}


void psyche_storage::set_target_module(shibari_module* module_) {
    this->target_module = module_;
}

void psyche_storage::set_code_holder(fuku_code_holder* holder) {
    this->code_holder = holder;
}

void psyche_storage::set_psy_blocks(const blocks_table& blocks) {
    this->blocks = blocks;
}

const shibari_module* psyche_storage::get_target_module() const {
    return this->target_module;
}

shibari_module* psyche_storage::get_target_module() {
    return this->target_module;
}

const psyche_pcode_manager& psyche_storage::get_pcode_manager() const {
    return this->pcode_manager;
}

psyche_pcode_manager& psyche_storage::get_pcode_manager() {
    return this->pcode_manager;
}

const fuku_code_holder* psyche_storage::get_code_holder() const {
    return this->code_holder;
}

fuku_code_holder* psyche_storage::get_code_holder() {
    return this->code_holder;
}

const blocks_table& psyche_storage::get_blocks_table() const {
    return this->blocks;
}

blocks_table& psyche_storage::get_blocks_table() {
    return this->blocks;
}

const psyche_handler_manager& psyche_storage::get_handler_manager() const{
    return this->handler_manager;
}

psyche_handler_manager& psyche_storage::get_handler_manager() {
    return this->handler_manager;
}

const fuku_code_holder& psyche_storage::get_vm() const {
    return this->vm;
}

fuku_code_holder& psyche_storage::get_vm() {
    return this->vm;
}
```

`furikuri/psyche_storage.h`:

```h
#pragma once

class psyche_cmd_arg;
class psyche_cmd;
class psyche_block;
class psyche_handler_sign;
class psyche_handler;

typedef std::list<psyche_block> blocks_table;
typedef std::list<psyche_cmd> commands_table;
typedef std::map<fuku_inst*, commands_table> psy_instructions;
typedef std::map<uint32_t, std::vector<uint32_t>> psy_block_props;

#include "psyche_handler.h"
#include "psyche_pcode.h"
#include "psyche_cmd.h"
#include "psyche_block.h"

class psyche_storage {
    //shibari_module* target_module;
    fuku_code_holder* code_holder;
    
    blocks_table blocks;
    psyche_handler_manager handler_manager;
    psyche_pcode_manager pcode_manager;

    fuku_code_holder vm;
    
public:
    psyche_storage();
    //psyche_storage(shibari_module* target_module, fuku_code_holder* code_holder);
    ~psyche_storage();


public:
    //void set_target_module(shibari_module* module_);
    void set_code_holder(fuku_code_holder* holder);
    void set_psy_blocks(const blocks_table& blocks);

public:

    //const shibari_module* get_target_module() const;
    //shibari_module* get_target_module();

    const fuku_code_holder* get_code_holder() const;
    fuku_code_holder* get_code_holder();

    const blocks_table& get_blocks_table() const;
    blocks_table& get_blocks_table();

    const psyche_pcode_manager& get_pcode_manager() const;
    psyche_pcode_manager& get_pcode_manager();

    const psyche_handler_manager& get_handler_manager() const;
    psyche_handler_manager& get_handler_manager();

    const fuku_code_holder& get_vm() const;
    fuku_code_holder& get_vm();
};


/*


        block_1->|
                 |
                 |instr1  ->| command_op1(arg1)               
                 |
                 |instr2  ->| command_op2(arg1,arg2)
                 |          | command_op3(arg1)
                 ...

        block_2->|
                 |
                 |instr1  ->| command_op6(arg1)
                 ...
        ...



*/
```

`furikuri/stdafx.cpp`:

```cpp
#include "stdafx.h"

```

`furikuri/stdafx.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN     

#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <time.h>
#include <stdio.h>
#include <sstream>
#include <iostream>
#include <iostream>
#include <stdarg.h> 
#include <cstdint>
#include <random>  
#include <intrin.h>

using namespace std;

#include <capstone/include/capstone/capstone.h>
#include <enma_pe/enma_pe/enma_pe.h>
#include <fukutasm/fukutasm/fukutasm.h>

#define FUKU_GET_RAND(_min,_max) ((_min) == (_max) ? (_min) : ((_min) + ( (rand() | rand() << 16) %(((_max) + (((_max) == UINT_MAX) ? 0 : 1)) - (_min)))))

#define FUKU_GET_CHANCE(x) (FUKU_GET_RAND(1,1000) <= (10*(x))) //0.f - 100.f in

#define GET_BITES(src, mask) ( (src) & (mask) )
#define HAS_FULL_MASK(src, mask) ( ( (src) & (mask) ) == (mask) )


#ifdef _DEBUG
#define FUKU_DEBUG {printf("%s:%d | %s\n",__FILE__,__LINE__,__FUNCTION__);}
#else
#define FUKU_DEBUG __nop();
#endif

#define FUKU_ASSERT(cond) if( !(cond)){FUKU_DEBUG}   
#define FUKU_ASSERT_EQ(lhs, rhs) if( !((lhs) == (rhs)) ){FUKU_DEBUG}
#define FUKU_ASSERT_GT(lhs, rhs) if( !((lhs) >  (rhs)) ){FUKU_DEBUG}

#include "furikuri.h"

```

`furikuri_console/furikuri_console.cpp`:

```cpp
#include "stdafx.h"


unsigned char data__[1776] = {
    0x60, 0x8B, 0x74, 0x24, 0x24, 0xC7, 0x06, 0x01, 0x23, 0x45, 0x67, 0xC7, 0x46, 0x04, 0x89, 0xAB,
    0xCD, 0xEF, 0xC7, 0x46, 0x08, 0xFE, 0xDC, 0xBA, 0x98, 0xC7, 0x46, 0x0C, 0x76, 0x54, 0x32, 0x10,
    0x8B, 0x44, 0x24, 0x2C, 0x50, 0x33, 0xD2, 0xB9, 0x40, 0x00, 0x00, 0x00, 0xF7, 0xF1, 0x40, 0x5A,
    0x83, 0xEC, 0x40, 0x8B, 0xDC, 0x8B, 0x74, 0x24, 0x68, 0x92, 0x8B, 0xFB, 0x4A, 0x75, 0x41, 0x85,
    0xC0, 0x78, 0x06, 0xC6, 0x04, 0x18, 0x80, 0xEB, 0x03, 0x33, 0xC0, 0x48, 0xB9, 0x40, 0x00, 0x00,
    0x00, 0x2B, 0xC8, 0x03, 0xF8, 0x50, 0x33, 0xC0, 0x47, 0x49, 0xF3, 0xAA, 0x58, 0x85, 0xC0, 0x78,
    0x05, 0x83, 0xF8, 0x38, 0x73, 0x19, 0x50, 0x8B, 0x44, 0x24, 0x70, 0x52, 0x33, 0xD2, 0xB9, 0x08,
    0x00, 0x00, 0x00, 0xF7, 0xE1, 0x89, 0x43, 0x38, 0x89, 0x53, 0x3C, 0x5A, 0x58, 0xEB, 0x01, 0x42,
    0x85, 0xC0, 0x78, 0x07, 0x83, 0xF8, 0x40, 0x73, 0x08, 0xEB, 0x02, 0x33, 0xC0, 0x8B, 0xC8, 0xEB,
    0x05, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x8B, 0xFB, 0xF3, 0xA4, 0x50, 0x52, 0x53, 0x56, 0x8D, 0x74,
    0x24, 0x10, 0x8B, 0x7C, 0x24, 0x74, 0x57, 0x8B, 0x07, 0x8B, 0x5F, 0x04, 0x8B, 0x4F, 0x08, 0x8B,
    0x57, 0x0C, 0x8B, 0xFB, 0x8B, 0xEB, 0x23, 0xF9, 0xF7, 0xD5, 0x23, 0xEA, 0x0B, 0xFD, 0x8D, 0x84,
    0x07, 0x78, 0xA4, 0x6A, 0xD7, 0x03, 0x06, 0xC1, 0xC0, 0x07, 0x03, 0xC3, 0x8B, 0xF8, 0x8B, 0xE8,
    0x23, 0xFB, 0xF7, 0xD5, 0x23, 0xE9, 0x0B, 0xFD, 0x8D, 0x94, 0x17, 0x56, 0xB7, 0xC7, 0xE8, 0x03,
    0x56, 0x04, 0xC1, 0xC2, 0x0C, 0x03, 0xD0, 0x8B, 0xFA, 0x8B, 0xEA, 0x23, 0xF8, 0xF7, 0xD5, 0x23,
    0xEB, 0x0B, 0xFD, 0x8D, 0x8C, 0x0F, 0xDB, 0x70, 0x20, 0x24, 0x03, 0x4E, 0x08, 0xC1, 0xC1, 0x11,
    0x03, 0xCA, 0x8B, 0xF9, 0x8B, 0xE9, 0x23, 0xFA, 0xF7, 0xD5, 0x23, 0xE8, 0x0B, 0xFD, 0x8D, 0x9C,
    0x1F, 0xEE, 0xCE, 0xBD, 0xC1, 0x03, 0x5E, 0x0C, 0xC1, 0xC3, 0x16, 0x03, 0xD9, 0x8B, 0xFB, 0x8B,
    0xEB, 0x23, 0xF9, 0xF7, 0xD5, 0x23, 0xEA, 0x0B, 0xFD, 0x8D, 0x84, 0x07, 0xAF, 0x0F, 0x7C, 0xF5,
    0x03, 0x46, 0x10, 0xC1, 0xC0, 0x07, 0x03, 0xC3, 0x8B, 0xF8, 0x8B, 0xE8, 0x23, 0xFB, 0xF7, 0xD5,
    0x23, 0xE9, 0x0B, 0xFD, 0x8D, 0x94, 0x17, 0x2A, 0xC6, 0x87, 0x47, 0x03, 0x56, 0x14, 0xC1, 0xC2,
    0x0C, 0x03, 0xD0, 0x8B, 0xFA, 0x8B, 0xEA, 0x23, 0xF8, 0xF7, 0xD5, 0x23, 0xEB, 0x0B, 0xFD, 0x8D,
    0x8C, 0x0F, 0x13, 0x46, 0x30, 0xA8, 0x03, 0x4E, 0x18, 0xC1, 0xC1, 0x11, 0x03, 0xCA, 0x8B, 0xF9,
    0x8B, 0xE9, 0x23, 0xFA, 0xF7, 0xD5, 0x23, 0xE8, 0x0B, 0xFD, 0x8D, 0x9C, 0x1F, 0x01, 0x95, 0x46,
    0xFD, 0x03, 0x5E, 0x1C, 0xC1, 0xC3, 0x16, 0x03, 0xD9, 0x8B, 0xFB, 0x8B, 0xEB, 0x23, 0xF9, 0xF7,
    0xD5, 0x23, 0xEA, 0x0B, 0xFD, 0x8D, 0x84, 0x07, 0xD8, 0x98, 0x80, 0x69, 0x03, 0x46, 0x20, 0xC1,
    0xC0, 0x07, 0x03, 0xC3, 0x8B, 0xF8, 0x8B, 0xE8, 0x23, 0xFB, 0xF7, 0xD5, 0x23, 0xE9, 0x0B, 0xFD,
    0x8D, 0x94, 0x17, 0xAF, 0xF7, 0x44, 0x8B, 0x03, 0x56, 0x24, 0xC1, 0xC2, 0x0C, 0x03, 0xD0, 0x8B,
    0xFA, 0x8B, 0xEA, 0x23, 0xF8, 0xF7, 0xD5, 0x23, 0xEB, 0x0B, 0xFD, 0x8D, 0x8C, 0x0F, 0xB1, 0x5B,
    0xFF, 0xFF, 0x03, 0x4E, 0x28, 0xC1, 0xC1, 0x11, 0x03, 0xCA, 0x8B, 0xF9, 0x8B, 0xE9, 0x23, 0xFA,
    0xF7, 0xD5, 0x23, 0xE8, 0x0B, 0xFD, 0x8D, 0x9C, 0x1F, 0xBE, 0xD7, 0x5C, 0x89, 0x03, 0x5E, 0x2C,
    0xC1, 0xC3, 0x16, 0x03, 0xD9, 0x8B, 0xFB, 0x8B, 0xEB, 0x23, 0xF9, 0xF7, 0xD5, 0x23, 0xEA, 0x0B,
    0xFD, 0x8D, 0x84, 0x07, 0x22, 0x11, 0x90, 0x6B, 0x03, 0x46, 0x30, 0xC1, 0xC0, 0x07, 0x03, 0xC3,
    0x8B, 0xF8, 0x8B, 0xE8, 0x23, 0xFB, 0xF7, 0xD5, 0x23, 0xE9, 0x0B, 0xFD, 0x8D, 0x94, 0x17, 0x93,
    0x71, 0x98, 0xFD, 0x03, 0x56, 0x34, 0xC1, 0xC2, 0x0C, 0x03, 0xD0, 0x8B, 0xFA, 0x8B, 0xEA, 0x23,
    0xF8, 0xF7, 0xD5, 0x23, 0xEB, 0x0B, 0xFD, 0x8D, 0x8C, 0x0F, 0x8E, 0x43, 0x79, 0xA6, 0x03, 0x4E,
    0x38, 0xC1, 0xC1, 0x11, 0x03, 0xCA, 0x8B, 0xF9, 0x8B, 0xE9, 0x23, 0xFA, 0xF7, 0xD5, 0x23, 0xE8,
    0x0B, 0xFD, 0x8D, 0x9C, 0x1F, 0x21, 0x08, 0xB4, 0x49, 0x03, 0x5E, 0x3C, 0xC1, 0xC3, 0x16, 0x03,
    0xD9, 0x8B, 0xFA, 0x8B, 0xEA, 0x23, 0xFB, 0xF7, 0xD5, 0x23, 0xE9, 0x0B, 0xFD, 0x8D, 0x84, 0x07,
    0x62, 0x25, 0x1E, 0xF6, 0x03, 0x46, 0x04, 0xC1, 0xC0, 0x05, 0x03, 0xC3, 0x8B, 0xF9, 0x8B, 0xE9,
    0x23, 0xF8, 0xF7, 0xD5, 0x23, 0xEB, 0x0B, 0xFD, 0x8D, 0x94, 0x17, 0x40, 0xB3, 0x40, 0xC0, 0x03,
    0x56, 0x18, 0xC1, 0xC2, 0x09, 0x03, 0xD0, 0x8B, 0xFB, 0x8B, 0xEB, 0x23, 0xFA, 0xF7, 0xD5, 0x23,
    0xE8, 0x0B, 0xFD, 0x8D, 0x8C, 0x0F, 0x51, 0x5A, 0x5E, 0x26, 0x03, 0x4E, 0x2C, 0xC1, 0xC1, 0x0E,
    0x03, 0xCA, 0x8B, 0xF8, 0x8B, 0xE8, 0x23, 0xF9, 0xF7, 0xD5, 0x23, 0xEA, 0x0B, 0xFD, 0x8D, 0x9C,
    0x1F, 0xAA, 0xC7, 0xB6, 0xE9, 0x03, 0x1E, 0xC1, 0xC3, 0x14, 0x03, 0xD9, 0x8B, 0xFA, 0x8B, 0xEA,
    0x23, 0xFB, 0xF7, 0xD5, 0x23, 0xE9, 0x0B, 0xFD, 0x8D, 0x84, 0x07, 0x5D, 0x10, 0x2F, 0xD6, 0x03,
    0x46, 0x14, 0xC1, 0xC0, 0x05, 0x03, 0xC3, 0x8B, 0xF9, 0x8B, 0xE9, 0x23, 0xF8, 0xF7, 0xD5, 0x23,
    0xEB, 0x0B, 0xFD, 0x8D, 0x94, 0x17, 0x53, 0x14, 0x44, 0x02, 0x03, 0x56, 0x28, 0xC1, 0xC2, 0x09,
    0x03, 0xD0, 0x8B, 0xFB, 0x8B, 0xEB, 0x23, 0xFA, 0xF7, 0xD5, 0x23, 0xE8, 0x0B, 0xFD, 0x8D, 0x8C,
    0x0F, 0x81, 0xE6, 0xA1, 0xD8, 0x03, 0x4E, 0x3C, 0xC1, 0xC1, 0x0E, 0x03, 0xCA, 0x8B, 0xF8, 0x8B,
    0xE8, 0x23, 0xF9, 0xF7, 0xD5, 0x23, 0xEA, 0x0B, 0xFD, 0x8D, 0x9C, 0x1F, 0xC8, 0xFB, 0xD3, 0xE7,
    0x03, 0x5E, 0x10, 0xC1, 0xC3, 0x14, 0x03, 0xD9, 0x8B, 0xFA, 0x8B, 0xEA, 0x23, 0xFB, 0xF7, 0xD5,
    0x23, 0xE9, 0x0B, 0xFD, 0x8D, 0x84, 0x07, 0xE6, 0xCD, 0xE1, 0x21, 0x03, 0x46, 0x24, 0xC1, 0xC0,
    0x05, 0x03, 0xC3, 0x8B, 0xF9, 0x8B, 0xE9, 0x23, 0xF8, 0xF7, 0xD5, 0x23, 0xEB, 0x0B, 0xFD, 0x8D,
    0x94, 0x17, 0xD6, 0x07, 0x37, 0xC3, 0x03, 0x56, 0x38, 0xC1, 0xC2, 0x09, 0x03, 0xD0, 0x8B, 0xFB,
    0x8B, 0xEB, 0x23, 0xFA, 0xF7, 0xD5, 0x23, 0xE8, 0x0B, 0xFD, 0x8D, 0x8C, 0x0F, 0x87, 0x0D, 0xD5,
    0xF4, 0x03, 0x4E, 0x0C, 0xC1, 0xC1, 0x0E, 0x03, 0xCA, 0x8B, 0xF8, 0x8B, 0xE8, 0x23, 0xF9, 0xF7,
    0xD5, 0x23, 0xEA, 0x0B, 0xFD, 0x8D, 0x9C, 0x1F, 0xED, 0x14, 0x5A, 0x45, 0x03, 0x5E, 0x20, 0xC1,
    0xC3, 0x14, 0x03, 0xD9, 0x8B, 0xFA, 0x8B, 0xEA, 0x23, 0xFB, 0xF7, 0xD5, 0x23, 0xE9, 0x0B, 0xFD,
    0x8D, 0x84, 0x07, 0x05, 0xE9, 0xE3, 0xA9, 0x03, 0x46, 0x34, 0xC1, 0xC0, 0x05, 0x03, 0xC3, 0x8B,
    0xF9, 0x8B, 0xE9, 0x23, 0xF8, 0xF7, 0xD5, 0x23, 0xEB, 0x0B, 0xFD, 0x8D, 0x94, 0x17, 0xF8, 0xA3,
    0xEF, 0xFC, 0x03, 0x56, 0x08, 0xC1, 0xC2, 0x09, 0x03, 0xD0, 0x8B, 0xFB, 0x8B, 0xEB, 0x23, 0xFA,
    0xF7, 0xD5, 0x23, 0xE8, 0x0B, 0xFD, 0x8D, 0x8C, 0x0F, 0xD9, 0x02, 0x6F, 0x67, 0x03, 0x4E, 0x1C,
    0xC1, 0xC1, 0x0E, 0x03, 0xCA, 0x8B, 0xF8, 0x8B, 0xE8, 0x23, 0xF9, 0xF7, 0xD5, 0x23, 0xEA, 0x0B,
    0xFD, 0x8D, 0x9C, 0x1F, 0x8A, 0x4C, 0x2A, 0x8D, 0x03, 0x5E, 0x30, 0xC1, 0xC3, 0x14, 0x03, 0xD9,
    0x8B, 0xEB, 0x33, 0xE9, 0x33, 0xEA, 0x8D, 0x84, 0x05, 0x42, 0x39, 0xFA, 0xFF, 0x03, 0x46, 0x14,
    0xC1, 0xC0, 0x04, 0x03, 0xC3, 0x8B, 0xE8, 0x33, 0xEB, 0x33, 0xE9, 0x8D, 0x94, 0x15, 0x81, 0xF6,
    0x71, 0x87, 0x03, 0x56, 0x20, 0xC1, 0xC2, 0x0B, 0x03, 0xD0, 0x8B, 0xEA, 0x33, 0xE8, 0x33, 0xEB,
    0x8D, 0x8C, 0x0D, 0x22, 0x61, 0x9D, 0x6D, 0x03, 0x4E, 0x2C, 0xC1, 0xC1, 0x10, 0x03, 0xCA, 0x8B,
    0xE9, 0x33, 0xEA, 0x33, 0xE8, 0x8D, 0x9C, 0x1D, 0x0C, 0x38, 0xE5, 0xFD, 0x03, 0x5E, 0x38, 0xC1,
    0xC3, 0x17, 0x03, 0xD9, 0x8B, 0xEB, 0x33, 0xE9, 0x33, 0xEA, 0x8D, 0x84, 0x05, 0x44, 0xEA, 0xBE,
    0xA4, 0x03, 0x46, 0x04, 0xC1, 0xC0, 0x04, 0x03, 0xC3, 0x8B, 0xE8, 0x33, 0xEB, 0x33, 0xE9, 0x8D,
    0x94, 0x15, 0xA9, 0xCF, 0xDE, 0x4B, 0x03, 0x56, 0x10, 0xC1, 0xC2, 0x0B, 0x03, 0xD0, 0x8B, 0xEA,
    0x33, 0xE8, 0x33, 0xEB, 0x8D, 0x8C, 0x0D, 0x60, 0x4B, 0xBB, 0xF6, 0x03, 0x4E, 0x1C, 0xC1, 0xC1,
    0x10, 0x03, 0xCA, 0x8B, 0xE9, 0x33, 0xEA, 0x33, 0xE8, 0x8D, 0x9C, 0x1D, 0x70, 0xBC, 0xBF, 0xBE,
    0x03, 0x5E, 0x28, 0xC1, 0xC3, 0x17, 0x03, 0xD9, 0x8B, 0xEB, 0x33, 0xE9, 0x33, 0xEA, 0x8D, 0x84,
    0x05, 0xC6, 0x7E, 0x9B, 0x28, 0x03, 0x46, 0x34, 0xC1, 0xC0, 0x04, 0x03, 0xC3, 0x8B, 0xE8, 0x33,
    0xEB, 0x33, 0xE9, 0x8D, 0x94, 0x15, 0xFA, 0x27, 0xA1, 0xEA, 0x03, 0x16, 0xC1, 0xC2, 0x0B, 0x03,
    0xD0, 0x8B, 0xEA, 0x33, 0xE8, 0x33, 0xEB, 0x8D, 0x8C, 0x0D, 0x85, 0x30, 0xEF, 0xD4, 0x03, 0x4E,
    0x0C, 0xC1, 0xC1, 0x10, 0x03, 0xCA, 0x8B, 0xE9, 0x33, 0xEA, 0x33, 0xE8, 0x8D, 0x9C, 0x1D, 0x05,
    0x1D, 0x88, 0x04, 0x03, 0x5E, 0x18, 0xC1, 0xC3, 0x17, 0x03, 0xD9, 0x8B, 0xEB, 0x33, 0xE9, 0x33,
    0xEA, 0x8D, 0x84, 0x05, 0x39, 0xD0, 0xD4, 0xD9, 0x03, 0x46, 0x24, 0xC1, 0xC0, 0x04, 0x03, 0xC3,
    0x8B, 0xE8, 0x33, 0xEB, 0x33, 0xE9, 0x8D, 0x94, 0x15, 0xE5, 0x99, 0xDB, 0xE6, 0x03, 0x56, 0x30,
    0xC1, 0xC2, 0x0B, 0x03, 0xD0, 0x8B, 0xEA, 0x33, 0xE8, 0x33, 0xEB, 0x8D, 0x8C, 0x0D, 0xF8, 0x7C,
    0xA2, 0x1F, 0x03, 0x4E, 0x3C, 0xC1, 0xC1, 0x10, 0x03, 0xCA, 0x8B, 0xE9, 0x33, 0xEA, 0x33, 0xE8,
    0x8D, 0x9C, 0x1D, 0x65, 0x56, 0xAC, 0xC4, 0x03, 0x5E, 0x08, 0xC1, 0xC3, 0x17, 0x03, 0xD9, 0x8B,
    0xEA, 0xF7, 0xD5, 0x0B, 0xEB, 0x33, 0xE9, 0x8D, 0x84, 0x05, 0x44, 0x22, 0x29, 0xF4, 0x03, 0x06,
    0xC1, 0xC0, 0x06, 0x03, 0xC3, 0x8B, 0xE9, 0xF7, 0xD5, 0x0B, 0xE8, 0x33, 0xEB, 0x8D, 0x94, 0x15,
    0x97, 0xFF, 0x2A, 0x43, 0x03, 0x56, 0x1C, 0xC1, 0xC2, 0x0A, 0x03, 0xD0, 0x8B, 0xEB, 0xF7, 0xD5,
    0x0B, 0xEA, 0x33, 0xE8, 0x8D, 0x8C, 0x0D, 0xA7, 0x23, 0x94, 0xAB, 0x03, 0x4E, 0x38, 0xC1, 0xC1,
    0x0F, 0x03, 0xCA, 0x8B, 0xE8, 0xF7, 0xD5, 0x0B, 0xE9, 0x33, 0xEA, 0x8D, 0x9C, 0x1D, 0x39, 0xA0,
    0x93, 0xFC, 0x03, 0x5E, 0x14, 0xC1, 0xC3, 0x15, 0x03, 0xD9, 0x8B, 0xEA, 0xF7, 0xD5, 0x0B, 0xEB,
    0x33, 0xE9, 0x8D, 0x84, 0x05, 0xC3, 0x59, 0x5B, 0x65, 0x03, 0x46, 0x30, 0xC1, 0xC0, 0x06, 0x03,
    0xC3, 0x8B, 0xE9, 0xF7, 0xD5, 0x0B, 0xE8, 0x33, 0xEB, 0x8D, 0x94, 0x15, 0x92, 0xCC, 0x0C, 0x8F,
    0x03, 0x56, 0x0C, 0xC1, 0xC2, 0x0A, 0x03, 0xD0, 0x8B, 0xEB, 0xF7, 0xD5, 0x0B, 0xEA, 0x33, 0xE8,
    0x8D, 0x8C, 0x0D, 0x7D, 0xF4, 0xEF, 0xFF, 0x03, 0x4E, 0x28, 0xC1, 0xC1, 0x0F, 0x03, 0xCA, 0x8B,
    0xE8, 0xF7, 0xD5, 0x0B, 0xE9, 0x33, 0xEA, 0x8D, 0x9C, 0x1D, 0xD1, 0x5D, 0x84, 0x85, 0x03, 0x5E,
    0x04, 0xC1, 0xC3, 0x15, 0x03, 0xD9, 0x8B, 0xEA, 0xF7, 0xD5, 0x0B, 0xEB, 0x33, 0xE9, 0x8D, 0x84,
    0x05, 0x4F, 0x7E, 0xA8, 0x6F, 0x03, 0x46, 0x20, 0xC1, 0xC0, 0x06, 0x03, 0xC3, 0x8B, 0xE9, 0xF7,
    0xD5, 0x0B, 0xE8, 0x33, 0xEB, 0x8D, 0x94, 0x15, 0xE0, 0xE6, 0x2C, 0xFE, 0x03, 0x56, 0x3C, 0xC1,
    0xC2, 0x0A, 0x03, 0xD0, 0x8B, 0xEB, 0xF7, 0xD5, 0x0B, 0xEA, 0x33, 0xE8, 0x8D, 0x8C, 0x0D, 0x14,
    0x43, 0x01, 0xA3, 0x03, 0x4E, 0x18, 0xC1, 0xC1, 0x0F, 0x03, 0xCA, 0x8B, 0xE8, 0xF7, 0xD5, 0x0B,
    0xE9, 0x33, 0xEA, 0x8D, 0x9C, 0x1D, 0xA1, 0x11, 0x08, 0x4E, 0x03, 0x5E, 0x34, 0xC1, 0xC3, 0x15,
    0x03, 0xD9, 0x8B, 0xEA, 0xF7, 0xD5, 0x0B, 0xEB, 0x33, 0xE9, 0x8D, 0x84, 0x05, 0x82, 0x7E, 0x53,
    0xF7, 0x03, 0x46, 0x10, 0xC1, 0xC0, 0x06, 0x03, 0xC3, 0x8B, 0xE9, 0xF7, 0xD5, 0x0B, 0xE8, 0x33,
    0xEB, 0x8D, 0x94, 0x15, 0x35, 0xF2, 0x3A, 0xBD, 0x03, 0x56, 0x2C, 0xC1, 0xC2, 0x0A, 0x03, 0xD0,
    0x8B, 0xEB, 0xF7, 0xD5, 0x0B, 0xEA, 0x33, 0xE8, 0x8D, 0x8C, 0x0D, 0xBB, 0xD2, 0xD7, 0x2A, 0x03,
    0x4E, 0x08, 0xC1, 0xC1, 0x0F, 0x03, 0xCA, 0x8B, 0xE8, 0xF7, 0xD5, 0x0B, 0xE9, 0x33, 0xEA, 0x8D,
    0x9C, 0x1D, 0x91, 0xD3, 0x86, 0xEB, 0x03, 0x5E, 0x24, 0xC1, 0xC3, 0x15, 0x03, 0xD9, 0x5F, 0x01,
    0x07, 0x01, 0x5F, 0x04, 0x01, 0x4F, 0x08, 0x01, 0x57, 0x0C, 0x5E, 0x5B, 0x5A, 0x58, 0x83, 0xE8,
    0x40, 0x85, 0xD2, 0x0F, 0x85, 0x51, 0xF9, 0xFF, 0xFF, 0x83, 0xC4, 0x40, 0x61, 0xC2, 0x0C, 0x00
};


//#define DO_TEST_32 0


//void test_on_shellcode();

DWORD WINAPI multithread_test(LPVOID) {
//    test_on_shellcode();
    return 0;
}


int main() {

    //  for (uint32_t i = 0x234235; i < 0xF0000000;i+= 0x10000000) {
    srand(222);
    //test_on_shellcode();

    /*
    HANDLE hthread[2];

    hthread[0] = CreateThread(0, 0, multithread_test, 0, 0, 0);
    hthread[1] = CreateThread(0, 0, multithread_test, 0, 0, 0);
    WaitForMultipleObjects(1, hthread, true, -1);

    system("PAUSE");
    return 0;
    */


    //shibari_module _module(
    //    std::string("..\\..\\app for test\\vm_test.exe")//std::string("..\\..\\app for test\\swhtest.exe")
    //);

    pe_image _module(std::string("..\\..\\app for test\\vm_test.exe"));
    /*

    pe_image_io image_io(_module.get_image(), enma_io_mode_allow_expand);
    image_io.seek_to_end();

    imported_library lib;
    lib.set_library_name("vm_fuku_x86.dll");
    lib.set_rva_iat(image_io.get_image_offset());

    imported_func func;
    func.set_func_name("_fuku_vm_entry@4");
    func.set_iat_rva(image_io.get_image_offset());

    lib.add_item(func);

    _module.get_image_imports().add_library(lib);

    uint8_t jmpvm[] = { 0xFF ,0x25 ,0,0,0,0 };
    *(uint32_t*)&jmpvm[2] = image_io.get_image_offset() + _module.get_image().get_image_base();


    image_io.memory_set(8,0);


    uint32_t rva_vm = image_io.get_image_offset();
    image_io.write(jmpvm, sizeof(jmpvm));
    


    shibari_module _vm_module(
        std::string("..\\Release\\vm_fuku_x86.dll")
    );
    */
    
    furikuri fuku;

    if (fuku.set_image_protect(_module)) {
        //    fuku.add_extended_module(&_vm_module);


        std::vector<uint8_t> out_image;

        //   fuku_ob_settings settings = { 2,2,50.f,50.f,50.f };
        //   fuku.add_ob_code_list({ 0x1000 , 0x6F0 }, &_module, settings);
           //fuku_virtualization_x86 vm;
           //0x1000 , 0x6F0


        fuku_settings_obfuscation ob_set(5, 3, 40.f, 30.f, 40.f,
            FUKU_ASM_SHORT_CFG_USE_EAX_SHORT | FUKU_ASM_SHORT_CFG_USE_DISP_SHORT | FUKU_ASM_SHORT_CFG_USE_IMM_SHORT);

        fuku_settings_obfuscation ob1_set(3, 3, 40.f, 10.f, 60.f, 
            FUKU_ASM_SHORT_CFG_USE_EAX_SHORT | FUKU_ASM_SHORT_CFG_USE_DISP_SHORT);


       fuku.add_ob_code_list({ 0x1000 , 0x6F0 }, ob_set);
     //   fuku.add_ob_code_list({ 0x103A , 0x6B6 }, &_module, ob1_set);
      // fuku.add_ob_code_list({ 0x16F0 , 0x1A6 }, ob1_set);
      //  fuku.add_ob_code_list({ 0x16915 , 0x29 }, &_module, ob1_set);
         /*
        fuku.add_vm_code_list({ 0x16F0 , 0x1A6 }, &_module, fuku_vm_settings({
            { 0,0,00.f,00.f,00.f },// { 2,2,50.f,50.f,50.f },
            &_vm_module,
            _vm_module.get_image_exports().get_items()[0].get_rva(),
            &vm
            }));

        fuku.add_vm_code_list({ 0x1000 , 0x6F0 }, &_module, fuku_vm_settings({
            { 0,0,00.f,00.f,00.f },// { 2,2,50.f,50.f,50.f },
            &_vm_module,
            _vm_module.get_image_exports().get_items()[0].get_rva(),
            &vm
        }));


        fuku.add_vm_code_list({ 0x174B , 0x5F }, &_module, fuku_vm_settings({
            {0, 0, 0, 0, 0},// { 2,2,50.f,50.f,50.f },
            &_vm_module,
            _vm_module.get_image_exports().get_items()[0].get_rva(),
            &vm
        }));

        fuku.add_vm_code_list({ 0x17AA , 0x18 }, &_module, fuku_vm_settings({
            { 0, 0, 0, 0, 0 },// { 2,2,50.f,50.f,50.f },
            &_vm_module,
            _vm_module.get_image_exports().get_items()[0].get_rva(),
            &vm
            }));


        fuku.add_vm_code_list({ 0x17C2 , 0xD4 }, &_module, fuku_vm_settings({
            { 0, 0, 0, 0, 0 },// { 2,2,50.f,50.f,50.f },
            &_vm_module,
            _vm_module.get_image_exports().get_items()[0].get_rva(),
            &vm
            }));
            //*/


            //fuku.add_code_list({ 0x1110 , 0x123 }, fuku_code_type::fuku_code_obfuscate, &_module, { 2,2,50.f,50.f,50.f });


        fuku_settings_mgr fuku_snapshot;

        //if (fuku.create_snapshot(fuku_snapshot, fuku_protect_stage_initialization)) {

        //    while (1) {

                if (fuku.fuku_protect(out_image)) {

                    FILE* hTargetFile;
                    fopen_s(&hTargetFile, "..\\..\\app for test\\fuku_test.exe", "wb");

                    if (hTargetFile) {
                        fwrite(out_image.data(), out_image.size(), 1, hTargetFile);
                        fclose(hTargetFile);

                        printf("fuku_protect good !\n");
                    }
                }
                else {
                    printf("fuku_protect error !\n");
                }

                //Sleep(100);
       //     }
       // }

       

    }
    //  }

      //*/



      
 
      //*/
    return 0;
}
//
//void test_on_shellcode() {
//
//   // srand(0x15464323);
//
//    uint8_t * data_ = new uint8_t[0x1000];
//    uint8_t * data_1 = new uint8_t[0x1000];
//    for (unsigned int i = 0; i < 0x1000 / 4; i += 4) {
//        (*(uint32_t*)&data_[i]) = rand();
//    }
//
//    uint8_t * compressed_buf = new uint8_t[0x1000 + (0x1000 / 16) + 64 + 3];
//    void * work_mem = new uint8_t[LZO1Z_999_MEM_COMPRESS];
//
//    lzo_uint packed_size = 0;
//
//    if (lzo1z_999_compress(data_, 0x1000, compressed_buf, &packed_size, work_mem) != LZO_E_OK) {
//        delete[] work_mem;
//        delete[] compressed_buf;
//        return;
//    }
//    
//    delete[] work_mem;
//    fuku_code_holder code_holder;
//    fuku_code_analyzer anal_code;
//
//#ifdef _M_X64
//    fuku_code_profiler code_profiler(FUKU_ASSAMBLER_ARCH_X64);
//    anal_code.set_arch(fuku_assambler_arch::FUKU_ASSAMBLER_ARCH_X64);
//    anal_code.analyze_code(code_holder, lzo_depack_64, sizeof(lzo_depack_64), 0, 0); 
//#else
//    fuku_code_profiler code_profiler(FUKU_ASSAMBLER_ARCH_X86);
//    anal_code.set_arch(fuku_assambler_arch::FUKU_ASSAMBLER_ARCH_X86);
//  //  anal_code.analyze_code(code_holder, data__, sizeof(data__), 0, 0);
//    
//    anal_code.analyze_code(code_holder, lzo_depack_32, sizeof(lzo_depack_32), 0, 0);
//#endif
//
//    code_profiler.profile_code(code_holder);
//
//    /*
//    typedef int(__stdcall * _md5_algo)(BYTE * sig, BYTE * data, int size);
//
//    BYTE originl_md5buf[16];
//
//    {
//        _md5_algo md5__ = (_md5_algo)(&data__[0]);
//        DWORD old;
//        VirtualProtect(data__, sizeof(data__), PAGE_EXECUTE_READWRITE, &old);
//        md5__(originl_md5buf, compressed_buf, packed_size);
//    }
//    */
//
//    typedef int(__cdecl * _depack_algo)(const unsigned char * src, unsigned long  src_len, unsigned char * dst, unsigned long * dst_len, void * wrkmem);
//    for (unsigned int i = 0; i < 10000; i++) {
//
//        if (i == 52) {
////            __debugbreak();
//        }
//
//        fuku_code_analyzer ob_anal_code = code_holder;
//
//        fuku_obfuscator obfuscator;
//
//
//        fuku_settings_obfuscation ob_set(4, 5, 30.f, 30.f, 30.f,
//            FUKU_ASM_SHORT_CFG_USE_EAX_SHORT | FUKU_ASM_SHORT_CFG_USE_DISP_SHORT | FUKU_ASM_SHORT_CFG_USE_IMM_SHORT, false, false);
//        obfuscator.set_destination_virtual_address(0);
//        // obfuscator.set_settings({ 1,1,00.f,00.f,30.f });
//        obfuscator.set_settings(ob_set);
//        obfuscator.set_code(&ob_anal_code.get_code());
//
//        unsigned int s_time = GetTickCount();
//
//        obfuscator.obfuscate_code();
//        std::map<uint64_t, uint64_t> associations;
//        std::vector<fuku_image_relocation> relocations;
//                    
//        ob_anal_code.get_code().finalize_code(&associations, &relocations);
//
//        std::vector<uint8_t> __obf_unpacker = ob_anal_code.get_code().dump_code();
//
//        printf("%08x : %d obfuscated in %.4f sec | size scale %.2f | %.3f MIB | ", 
//            GetCurrentThreadId(), i, 
//            (GetTickCount() - s_time) / 1000.f, (float)__obf_unpacker.size() / sizeof(lzo_depack_32),
//            (float)__obf_unpacker.size() / (float)(1024 * 1024));
//
//        uint8_t * __obf_unpacker_ = __obf_unpacker.data();
//
//        DWORD old_p;
//        VirtualProtect(__obf_unpacker_, __obf_unpacker.size(), PAGE_EXECUTE_READWRITE, &old_p);
//        
//        _depack_algo depack = (_depack_algo)(__obf_unpacker_ + associations.begin()->second);
//       // _md5_algo md5__ = (_md5_algo)(__obf_unpacker_ + associations.begin()->second);
//        unsigned long unpack_size = 0x1000;
//
//#ifdef _M_X64
//        for (auto &rel : relocations) { //fix reloc
//            *(uint64_t*)&__obf_unpacker_[rel.virtual_address] += (uint64_t)__obf_unpacker_;
//        }     
//#else
//        for (auto &rel : relocations) { //fix reloc
//            *(uint32_t*)&__obf_unpacker_[rel.virtual_address] += (uint32_t)__obf_unpacker_;
//        }
//#endif
//        unsigned int n_time = GetTickCount();
//
//        if (i == 52) {
//         //   code_profiler.print_code(ob_anal_code.get_code());
//        }
//
//    //    code_profiler.print_code(ob_anal_code.get_code());
//        // __try {
//     //   BYTE md5buf[16];
//      //  md5__(md5buf, compressed_buf, packed_size);
//         depack(compressed_buf, packed_size, data_1, &unpack_size, 0);
//        // }
//        // __except (1) {
//          //   system("PAUSE");
//        // }
//        
//        printf(" called in %.4f sec | ", (GetTickCount() - n_time) / 1000.f);
//        
//        /*
//        if (!memcmp(originl_md5buf, md5buf, sizeof(md5buf))) {
//            printf("good ! \n");
//        }
//        else {
//            code_profiler.print_code(ob_anal_code.get_code());
//            printf("error ! \n");
//        }
//        */
//
//        for (unsigned int i = 0; i < 0x1000; i++) {
//            if (data_[i] != data_1[i]) { 
//                printf("error! %x != %x : %d\n", data_[i], data_1[i], i); 
//                
//          //      Sleep(100000);
//
//                
//            }
//        }
//        
//
//        printf("good!\n");
//    }
//}
```

`furikuri_console/furikuri_console.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9C776AA4-29BB-480F-BADC-2D5385D4BA54}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>furikuri_console</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir);$(IncludePath)</IncludePath>
    <LibraryPath>$(OutDir);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir);</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(OutDir);</AdditionalLibraryDirectories>
      <AdditionalDependencies>enma_pe.lib;fukutasm.lib;capstone.lib;furikuri.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="furikuri_console.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`furikuri_console/furikuri_console.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Файлы исходного кода">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Заголовочные файлы">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Заголовочные файлы</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
    <ClCompile Include="furikuri_console.cpp">
      <Filter>Файлы исходного кода</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`furikuri_console/stdafx.cpp`:

```cpp
#include "stdafx.h"
```

`furikuri_console/stdafx.h`:

```h
#pragma once

#include <Windows.h>
#include <vector>
#include <list>
#include <string>
#include <algorithm>
#include <map>
#include <set>
#include <time.h>
#include <stdio.h>
#include <sstream>
#include <iostream>
#include <iostream>
#include <stdarg.h> 
#include <cstdint>

using namespace std;


#include <capstone/include/capstone/capstone.h>
#include <enma_pe/enma_pe/enma_pe.h>
#include <fukutasm/fukutasm/fukutasm.h>
#include <furikuri/furikuri.h>

```

`readme.md`:

```md
Furikuri
=============

[![License](https://img.shields.io/badge/license-BSD3-blue.svg)](https://github.com/jnastarot/enma_pe/blob/master/LICENSE) [![Build status](https://ci.appveyor.com/api/projects/status/4fa90sgo6c89fqcp?svg=true)](https://ci.appveyor.com/project/jnastarot/furikuri) [![Build Status](https://travis-ci.org/jnastarot/furikuri.svg?branch=master)](https://travis-ci.org/jnastarot/furikuri)
------


```
Furikuri is protection framework what targeting on shellcode and executable files 
Supported x32 and x64 archs
```
1. [Obfuscation techniques](#Obfuscation-techniques)
	* [Instruction mutation](#Instruction-mutation) 
    * [Junk generation](#Junk-generation) 
    * [Spaghetti code](#Spaghetti-code) 
    * [Bytecode obfuscation](#Bytecode-obfuscation) 
2. [Examples](#Examples)
3. [Compile](#Compile)
4. [Third party](#third-party)

Obfuscation techniques
-------------------------------------

##### Instruction mutation
 Mutation of original instruction into series of other equivalent instructions 

   example:

   ```
    mov rcx, rax
    mov rdx, [rsp + 38h]
    call SomeFunc
   ```
   becomes to :
   ```
    mov rdx, rax
    mov rcx, [rsp + 38h]
    push rcx
    mov rcx, rdx
    pop rdx
    call SomeFunc
   
   ```
------------------------

##### Junk generation
Inserting assembler instructions with out any payload between "original" instructions

   example:
   ```
    mov rcx, rax
    mov rdx, [rsp + 38h]
    call SomeFunc
   ```
   becomes to :
   ```
    mov rdx, rdx
    mov rdx, r8
    mov rcx, rax
    push r8
    mov r8, 12345678h
    pop r8
    mov rdx, [rsp + 38h]
    call SomeFunc
   ```
------------------------

##### Spaghetti code
Dividing original basic block of code on several but more smaller, through insertion `jmp` in middle of   block to start of second of "new" block

   example:
   ```
   mov r10, [rax+20h]
   mov eax, [rsp+98h]
   mov [rsp+40h], eax
   mov rax, [rsp+90h]
   mov [rsp+38h], rax
   mov eax, [rsp+88h]
   mov [rsp+30h], eax
   mov rax, [rsp+80h]
   mov [rsp+28h], rax
   mov [rsp+20h], r9d
   ```
   becomes to :
   ```
   mov r10, [rax+20h]
   mov eax, [rsp+98h]
   mov [rsp+40h], eax
   mov rax, [rsp+90h]
   mov [rsp+38h], rax
   jmp l1:
   ...
   ...
   ...
   
   l1 :
   mov eax, [rsp+88h]
   mov [rsp+30h], eax
   mov rax, [rsp+80h]
   mov [rsp+28h], rax
   mov [rsp+20h], r9d
   
   ```
------------------------

##### Bytecode obfuscation
Changes bytecode of instruction to another bytecode

   example:
   ```
    48 8B CA mov rcx,rdx
   ```
   becomes to :
   ```
    48 89 D1 mov rcx,rdx
   ```




Examples
--------------
[shellcode obfuscation](https://github.com/jnastarot/furikuri/tree/master/examples/shellcode%20obfuscation)<br>
[executable obfuscation](https://github.com/jnastarot/furikuri/tree/master/examples/executable%20obfuscation)

---
Compile 
-------------
* Windows
	1. Requirements 
	    * Git Bush
	    * Visual Studio 2019 (for now, but u can change runtime version and compile in on below versions)
	
	2. Clone repo and initialize submodules
	
	   ```
	   git clone https://github.com/jnastarot/furikuri.git
	   cd furikuri
	   git submodule update --init
	   ```
	
	3. Open `furikuri.sln` and build it in Visual Studio 
	
	   
	
* Linux

  TODO




Third Party
-----------------
[capstone](http://www.capstone-engine.org/)<br>
[enma pe](https://github.com/jnastarot/enma_pe)<br>
[fukutasm](https://github.com/jnastarot/fukutasm)<br>
```