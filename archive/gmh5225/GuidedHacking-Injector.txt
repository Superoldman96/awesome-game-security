Project Path: arc_gmh5225_GuidedHacking-Injector_38ma6sok

Source Tree:

```txt
arc_gmh5225_GuidedHacking-Injector_38ma6sok
├── GH Injector DNP
│   ├── DotNetInjection.cpp
│   ├── DotNetInjection.h
│   ├── FindModule.cpp
│   ├── FindModule.h
│   ├── GH Injector DNP.aps
│   ├── GH Injector DNP.rc
│   ├── GH Injector DNP.vcxproj
│   ├── GH Injector DNP.vcxproj.filters
│   ├── GH Injector DNP.vcxproj.user
│   ├── main.cpp
│   ├── main.h
│   ├── pch.cpp
│   ├── pch.h
│   └── resource.h
├── GH Injector Library
│   ├── DotNetInjection.cpp
│   ├── DotNetInjection.h
│   ├── Download Manager.cpp
│   ├── Download Manager.h
│   ├── Eject.cpp
│   ├── Eject.h
│   ├── Error.h
│   ├── FakeVEH WOW64.cpp
│   ├── FakeVEH.cpp
│   ├── GH Injector Library.aps
│   ├── GH Injector Library.rc
│   ├── GH Injector Library.vcxproj
│   ├── GH Injector Library.vcxproj.filters
│   ├── GH Injector Library.vcxproj.user
│   ├── Handle Hijacking.cpp
│   ├── Handle Hijacking.h
│   ├── Hook Scanner WOW64.cpp
│   ├── Hook Scanner.cpp
│   ├── Hook Scanner.h
│   ├── Import Handler WOW64.cpp
│   ├── Import Handler.cpp
│   ├── Import Handler.h
│   ├── Injection Generic WOW64.cpp
│   ├── Injection Generic.cpp
│   ├── Injection Internal.h
│   ├── Injection.cpp
│   ├── Injection.h
│   ├── KernelCallback WOW64.cpp
│   ├── KernelCallback.cpp
│   ├── Manual Mapping Internal.h
│   ├── Manual Mapping WOW64.cpp
│   ├── Manual Mapping.cpp
│   ├── Manual Mapping.h
│   ├── NT Defs.h
│   ├── NT Funcs.h
│   ├── NtCreateThreadEx WOW64.cpp
│   ├── NtCreateThreadEx.cpp
│   ├── Process Info.cpp
│   ├── Process Info.h
│   ├── QueueUserAPC WOW64.cpp
│   ├── QueueUserAPC.cpp
│   ├── SetWindowsHookEx WOW64.cpp
│   ├── SetWindowsHookEx.cpp
│   ├── Start Routine WOW64.cpp
│   ├── Start Routine.cpp
│   ├── Start Routine.h
│   ├── Symbol Loader.cpp
│   ├── Symbol Loader.h
│   ├── Symbol Parser.cpp
│   ├── Symbol Parser.h
│   ├── Thread Hijacking WOW64.cpp
│   ├── Thread Hijacking.cpp
│   ├── Tools.cpp
│   ├── Tools.h
│   ├── VEH Shell.cpp
│   ├── VEH Shell.h
│   ├── WOW64 Shells.h
│   ├── Win10.h
│   ├── Win11.h
│   ├── Win7.h
│   ├── Win8.h
│   ├── Win81.h
│   ├── main.cpp
│   ├── pch.cpp
│   ├── pch.h
│   └── resource.h
├── GH Injector Library.sln
├── GH Injector SM
│   ├── GH Injector SM
│   │   ├── GH Injector SM.aps
│   │   ├── GH Injector SM.rc
│   │   ├── GH Injector SM.vcxproj
│   │   ├── GH Injector SM.vcxproj.filters
│   │   ├── GH Injector SM.vcxproj.user
│   │   ├── KernelCallbackTable.cpp
│   │   ├── SetWindowsHookEx.cpp
│   │   ├── main.cpp
│   │   ├── main.h
│   │   ├── pch.cpp
│   │   ├── pch.h
│   │   └── resource.h
│   └── GH Injector SM.sln
├── Injection.h
├── LICENSE
└── README.md

```

`GH Injector DNP/DotNetInjection.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "DotNetInjection.h"
#include "FindModule.h"

HRESULT LoadDotNetDll(const std::wstring & FilePath, const std::wstring & Version, const std::wstring & TypeName, const std::wstring & MethodName, const std::wstring & Argument, HINSTANCE & ModuleBase, DWORD & ReturnValue);
void Log(const std::wstring & path, DWORD error, HINSTANCE base);

DWORD __stdcall LoadDotNetBinary(void * pArg)
{
	UNREFERENCED_PARAMETER(pArg);

	if (!g_hModuleBase)
	{
		CONSOLE_LOG("Invalid modules base\n");

		return 0;
	}

	wchar_t szInfoPath[MAX_PATH * 2]{ 0 };
	size_t max_size = sizeof(szInfoPath) / sizeof(wchar_t);

	DWORD dwRet = GetModuleFileNameW(g_hModuleBase, szInfoPath, (DWORD)max_size);
	if (!dwRet || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		CONSOLE_LOG("GetModuleFileNameW failed: %08X\n", dwRet);

		return 0;
	}

	std::wstring InfoPath = szInfoPath;
	auto pos = InfoPath.find_last_of('\\');
	if (pos == std::wstring::npos)
	{
		CONSOLE_LOG("Invalid InfoPath\n");

		return 0;
	}

	InfoPath.erase(pos, InfoPath.back());
	InfoPath += FILENAME;

	std::wifstream File(InfoPath);
	if (!File.good())
	{
		CONSOLE_LOG("Failed to open InfoPath\n");

		File.close();

		DeleteFileW(InfoPath.c_str());

		Log(InfoPath, DNP_ERR_CANT_OPEN_FILE, NULL);

		return 0;
	}

	std::wstringstream info_raw;
	info_raw << File.rdbuf();

	File.close();

	DeleteFileW(InfoPath.c_str());

	std::wstring info = info_raw.str();
	std::vector<std::wstring> dot_net_data;

	size_t current_position = info.find('\n');
	while (current_position != std::wstring::npos)
	{
		dot_net_data.push_back(info.substr(0, current_position));
		info.erase(0, current_position + sizeof('\n'));

		current_position = info.find('\n');
	}

	dot_net_data.push_back(info);

	if (dot_net_data.size() < 6)
	{
		CONSOLE_LOG("Invalid info: %d arguments provided (6 expected)\n", (DWORD)dot_net_data.size());

		Log(InfoPath, DNP_ERR_INVALID_DATA, NULL);

		return 0;
	}

	auto & dll_path			= dot_net_data[0];
	auto & dot_net_version	= dot_net_data[1];
	auto & info_typename	= dot_net_data[2].append(std::wstring(L".").append(dot_net_data[3]));
	auto & info_method		= dot_net_data[4];
	auto & info_argument	= dot_net_data[5];

	DWORD		ReturnValue = 0;
	HINSTANCE	ModuleBase	= NULL;
	auto hRet = LoadDotNetDll(dll_path, dot_net_version, info_typename, info_method, info_argument, ModuleBase, ReturnValue);

	if (hRet == S_OK)
	{
		Log(InfoPath, DNP_ERR_SUCCESS, ModuleBase);
	}
	else
	{
		Log(InfoPath, (DWORD)hRet, (HINSTANCE)DNP_ERR_HRESULT);
	}

	return 0;
}

HRESULT LoadDotNetDll(const std::wstring & FilePath, const std::wstring & Version, const std::wstring & TypeName, const std::wstring & MethodName, const std::wstring & Argument, HINSTANCE & ModuleBase, DWORD & ReturnValue)
{
	//I stole the following code years ago somewhere and am unable to fine the original source, I'm sorry :c

	ICLRMetaHost	* MetaHost		= nullptr;
	IEnumUnknown	* RuntimeEnum	= nullptr;
	ICLRRuntimeInfo * RuntimeInfo	= nullptr;
	ICLRRuntimeHost * RuntimeHost	= nullptr;

	bool AlreadyLoaded = false;

	HRESULT hRet = CLRCreateInstance(CLSID_CLRMetaHost, IID_ICLRMetaHost, reinterpret_cast<void **>(&MetaHost));
	if (hRet != S_OK)
	{
		CONSOLE_LOG("CLRCreateInstance failed: %08X\n", hRet);

		return hRet;
	}

	hRet = MetaHost->EnumerateLoadedRuntimes(GetCurrentProcess(), &RuntimeEnum);
	if (hRet == S_OK)
	{
		ICLRRuntimeInfo * current_runtime = nullptr;

		ULONG count = 0;
		wchar_t current_runtime_version[MAX_PATH]{ 0 };

		auto enum_ret = RuntimeEnum->Next(1, reinterpret_cast<IUnknown **>(&current_runtime), &count);
		while (enum_ret == S_OK)
		{
			DWORD size = MAX_PATH;

			hRet = current_runtime->GetVersionString(current_runtime_version, &size);
			if (hRet == S_OK)
			{
				if (!Version.compare(current_runtime_version))
				{
					RuntimeInfo = current_runtime;
					AlreadyLoaded = true;

					CONSOLE_LOG("Runtime version %ls already loaded\n", Version.c_str());

					break;
				}
			}

			current_runtime->Release();

			enum_ret = RuntimeEnum->Next(1, reinterpret_cast<IUnknown **>(&current_runtime), &count);
		}

		RuntimeEnum->Release();
	}

	if (!AlreadyLoaded)
	{
		hRet = MetaHost->GetRuntime(Version.c_str(), IID_ICLRRuntimeInfo, reinterpret_cast<void **>(&RuntimeInfo));
		if (hRet != S_OK)
		{
			CONSOLE_LOG("ICLRMetaHost::GetRuntime failed: %08X\n", hRet);

			MetaHost->Release();

			return hRet;
		}
	}

	hRet = RuntimeInfo->GetInterface(CLSID_CLRRuntimeHost, IID_ICLRRuntimeHost, reinterpret_cast<void **>(&RuntimeHost));
	if (hRet != S_OK)
	{
		CONSOLE_LOG("ICLRRuntimeInfo::GetInterface failed: %08X\n", hRet);

		RuntimeInfo->Release();
		MetaHost->Release();

		return hRet;
	}
	
	if (!AlreadyLoaded)
	{
		hRet = RuntimeHost->Start();
		if (hRet != S_OK)
		{
			CONSOLE_LOG("ICLRRuntimeHost::Start failed: %08X\n", hRet);

			RuntimeHost->Release();
			RuntimeInfo->Release();
			MetaHost->Release();

			return hRet;
		}
	}	

	hRet = RuntimeHost->ExecuteInDefaultAppDomain(FilePath.c_str(), TypeName.c_str(), MethodName.c_str(), Argument.c_str(), &ReturnValue);
	if (hRet == S_OK)
	{
		DWORD dwRet = FindModuleW(FilePath, ModuleBase);
		if (dwRet != ERROR_SUCCESS)
		{
			CONSOLE_LOG("FindModuleW failed: %08X\n", dwRet);

			hRet = (HRESULT)dwRet;
		}
	}
	else
	{
		CONSOLE_LOG("ICLRRuntimeHost::ExecuteInDefaultAppDomain failed: %08X\n", hRet);
	}

	RuntimeHost->Release();
	RuntimeInfo->Release();
	MetaHost->Release();

	return hRet;
}

void Log(const std::wstring & path, DWORD error, HINSTANCE base)
{
	std::wofstream File(path);
	if (!File.good())
	{
		return;
	}

	File << std::hex << base << std::endl;
	File << std::hex << error << std::endl;

	File.close();
}
```

`GH Injector DNP/DotNetInjection.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "pch.h"

#define FILENAME L"\\DNPD.txt"

DWORD __stdcall LoadDotNetBinary(void * pArg);

#define DNP_ERR_SUCCESS				0x00000000

#define DNP_ERR_CANT_OPEN_FILE		0x60000001
#define DNP_ERR_EMPTY_FILE			0x60000002
#define DNP_ERR_OUT_OF_MEMORY		0x60000003
#define DNP_ERR_INVALID_DATA		0x60000004
#define DNP_ERR_HRESULT				0x60000005
#define DNP_ERR_CANT_FIND_MODULE	0x60000006
```

`GH Injector DNP/FindModule.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "FindModule.h"

void StdWStringToLower(std::wstring & String)
{
	std::transform(String.begin(), String.end(), String.begin(),
		[](wchar_t c)
		{
			return std::towlower(c);
		}
	);
}

DWORD FindModuleW(const std::wstring & ModulePath, HINSTANCE & hOut)
{
	//Gotta VirtualQuery this shit because .NET files aren't linked to the PEB so normal methods like TH32 snapshots or GetModuleHandle don't work

	auto ModuleNamePos = ModulePath.find_last_of('\\');
	if (ModuleNamePos == std::wstring::npos)
	{
		CONSOLE_LOG("ModulePath is invalid\n");
		
		return ERROR_INVALID_PARAMETER;
	}

	auto ModuleName			= ModulePath.substr(ModuleNamePos + 1);
	auto hCurrentProcess	= GetCurrentProcess();

	StdWStringToLower(ModuleName);

	MEMORY_BASIC_INFORMATION MBI{ 0 };
	wchar_t NameBuffer[MAX_PATH * 2]{ 0 };

	while (VirtualQuery(MBI.BaseAddress, &MBI, sizeof(MBI)))
	{
		if ((MBI.Type == MEM_IMAGE) && (MBI.State & MEM_COMMIT))
		{
			if (K32GetMappedFileNameW(hCurrentProcess, MBI.BaseAddress, NameBuffer, sizeof(NameBuffer) / sizeof(wchar_t)))
			{
				auto FilePath = std::wstring(NameBuffer);
				auto FileNamePos = FilePath.find_last_of('\\');

				if (FileNamePos != std::wstring::npos)
				{
					auto FileName = FilePath.substr(FileNamePos + 1);
					StdWStringToLower(FileName);

					if (FileName.compare(ModuleName) == 0)
					{
						hOut = reinterpret_cast<HINSTANCE>(MBI.BaseAddress);

						return ERROR_SUCCESS;
					}
					else
					{
						CONSOLE_LOG("%ls - %ls\n", FileName.c_str(), ModuleName.c_str());

					}
				}
			}
		}

		MBI.BaseAddress = reinterpret_cast<BYTE *>(MBI.BaseAddress) + MBI.RegionSize;
	}

	return ERROR_MOD_NOT_FOUND;
}
```

`GH Injector DNP/FindModule.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "pch.h"

DWORD FindModuleW(const std::wstring & ModulePath, HINSTANCE & hOut);
```

`GH Injector DNP/GH Injector DNP.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Deutsch (Deutschland) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
LANGUAGE LANG_GERMAN, SUBLANG_GERMAN

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 4,8,0,0
 PRODUCTVERSION 4,8,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000904b0"
        BEGIN
            VALUE "CompanyName", "Guided Hacking"
            VALUE "FileDescription", ".NET loader for the Guided Hacking Injection Library"
            VALUE "FileVersion", "4.8.0.0"
            VALUE "LegalCopyright", "Broihon (C) 1987 - 2035"
            VALUE "ProductName", "GH .NET Loader"
            VALUE "ProductVersion", "4.8.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x9, 1200
    END
END

#endif    // Deutsch (Deutschland) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`GH Injector DNP/GH Injector DNP.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f49caf48-9a1b-438c-a06b-e90a0736392a}</ProjectGuid>
    <RootNamespace>GHInjectorDNP</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformShortName)\</IntDir>
    <TargetName>GH Injector DNP - $(PlatformShortName)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformShortName)\</IntDir>
    <TargetName>GH Injector DNP - $(PlatformShortName)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformShortName)\</IntDir>
    <TargetName>GH Injector DNP - $(PlatformShortName)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformShortName)\</IntDir>
    <TargetName>GH Injector DNP - $(PlatformShortName)</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;GHINJECTORDNP_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;GHINJECTORDNP_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;GHINJECTORDNP_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;GHINJECTORDNP_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="DotNetInjection.h" />
    <ClInclude Include="FindModule.h" />
    <ClInclude Include="main.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DotNetInjection.cpp" />
    <ClCompile Include="FindModule.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GH Injector DNP.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GH Injector DNP/GH Injector DNP.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Ressourcendateien">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="DotNetInjection.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="main.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="FindModule.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="DotNetInjection.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="FindModule.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GH Injector DNP.rc">
      <Filter>Ressourcendateien</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`GH Injector DNP/GH Injector DNP.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`GH Injector DNP/main.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "main.h"

BOOL WINAPI DllMain(HINSTANCE hDll, DWORD dwReason, void * pReserved)
{
	UNREFERENCED_PARAMETER(pReserved);

	if (dwReason == DLL_PROCESS_ATTACH)
	{
#ifdef DEBUG_INFO
		AllocConsole();
		FILE * pFile = nullptr;
		freopen_s(&pFile, "CONOUT$", "w", stdout);
#endif

		CONSOLE_LOG("%s Loaded at %p\n", GH_DNP_NAME, hDll);

		g_hModuleBase = hDll;

		g_hMainThread = CreateThread(nullptr, 0, LoadDotNetBinary, nullptr, NULL, nullptr);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		CONSOLE_LOG("DNP unloading\n");

		DWORD dwExitCode = STILL_ACTIVE;
		if (GetExitCodeThread(g_hMainThread, &dwExitCode))
		{
			if (dwExitCode == STILL_ACTIVE)
			{
				CONSOLE_LOG("DNP Terminating thread\n");
				TerminateThread(g_hMainThread, NULL);
			}
		}

		CloseHandle(g_hMainThread);
	}

	return TRUE;
}
```

`GH Injector DNP/main.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "pch.h"

#include "DotNetInjection.h"

#ifdef _WIN64
#define GH_DNP_NAME "GH Injector DNP - x64.dll"
#else
#define GH_DNP_NAME "GH Injector DNP - x86.dll"
#endif
```

`GH Injector DNP/pch.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#pragma comment(lib, "MSCorEE.lib")
```

`GH Injector DNP/pch.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#pragma warning(disable: 6258) //TerminateThread warning

#include <Windows.h>

#if (NTDDI_VERSION < NTDDI_WIN7)
#error The mininum requirement for this library is Windows 7.
#endif

#include <algorithm>
#include <cwctype>
#include <fstream>
#include <MetaHost.h>
#include <Psapi.h>
#include <sstream>
#include <vector>

inline HINSTANCE	g_hModuleBase = NULL;
inline HANDLE		g_hMainThread = NULL;

#define DEBUG_INFO

#ifdef DEBUG_INFO
#define CONSOLE_LOG printf
#else
#define CONSOLE_LOG
#endif
```

`GH Injector DNP/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by GH Injector DNP.rc

// Nächste Standardwerte für neue Objekte
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`GH Injector Library.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31612.314
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GH Injector Library", "GH Injector Library\GH Injector Library.vcxproj", "{AC732425-E265-40FF-842F-C59CECE9A96C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GH Injector SM", "GH Injector SM\GH Injector SM\GH Injector SM.vcxproj", "{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GH Injector DNP", "GH Injector DNP\GH Injector DNP.vcxproj", "{F49CAF48-9A1B-438C-A06B-E90A0736392A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AC732425-E265-40FF-842F-C59CECE9A96C}.Debug|x64.ActiveCfg = Debug|x64
		{AC732425-E265-40FF-842F-C59CECE9A96C}.Debug|x64.Build.0 = Debug|x64
		{AC732425-E265-40FF-842F-C59CECE9A96C}.Debug|x86.ActiveCfg = Debug|Win32
		{AC732425-E265-40FF-842F-C59CECE9A96C}.Debug|x86.Build.0 = Debug|Win32
		{AC732425-E265-40FF-842F-C59CECE9A96C}.Release|x64.ActiveCfg = Release|x64
		{AC732425-E265-40FF-842F-C59CECE9A96C}.Release|x64.Build.0 = Release|x64
		{AC732425-E265-40FF-842F-C59CECE9A96C}.Release|x86.ActiveCfg = Release|Win32
		{AC732425-E265-40FF-842F-C59CECE9A96C}.Release|x86.Build.0 = Release|Win32
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Debug|x64.ActiveCfg = Debug|x64
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Debug|x64.Build.0 = Debug|x64
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Debug|x86.ActiveCfg = Debug|Win32
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Debug|x86.Build.0 = Debug|Win32
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Release|x64.ActiveCfg = Release|x64
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Release|x64.Build.0 = Release|x64
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Release|x86.ActiveCfg = Release|Win32
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Release|x86.Build.0 = Release|Win32
		{F49CAF48-9A1B-438C-A06B-E90A0736392A}.Debug|x64.ActiveCfg = Debug|x64
		{F49CAF48-9A1B-438C-A06B-E90A0736392A}.Debug|x64.Build.0 = Debug|x64
		{F49CAF48-9A1B-438C-A06B-E90A0736392A}.Debug|x86.ActiveCfg = Debug|Win32
		{F49CAF48-9A1B-438C-A06B-E90A0736392A}.Debug|x86.Build.0 = Debug|Win32
		{F49CAF48-9A1B-438C-A06B-E90A0736392A}.Release|x64.ActiveCfg = Release|x64
		{F49CAF48-9A1B-438C-A06B-E90A0736392A}.Release|x64.Build.0 = Release|x64
		{F49CAF48-9A1B-438C-A06B-E90A0736392A}.Release|x86.ActiveCfg = Release|Win32
		{F49CAF48-9A1B-438C-A06B-E90A0736392A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {808F1ED8-0D22-41C5-93F1-5FD309E2843D}
	EndGlobalSection
EndGlobal

```

`GH Injector Library/DotNetInjection.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "DotNetInjection.h"

DWORD ValidateDotNetDllFile(const std::wstring & FilePath, DWORD target_machine, std::wstring & version_out);

DWORD DotNet_InitErrorStruct(const DOTNET_INJECTIONDATA_INTERNAL & Data, int Native, DWORD ErrorCode, const ERROR_DATA & error_data);

DWORD __stdcall DotNet_InjectA(DOTNET_INJECTIONDATAA * pData)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "DotNet_InjectA called with pData = %p\n", pData);
	
	if (WaitForSingleObject(g_hRunningEvent, 0) == WAIT_OBJECT_0)
	{
		LOG(0, "Different injection in progress. Wait for the other injection to finish first.\n");

		return INJ_ERR_ALREADY_RUNNING;
	}

	if (!pData)
	{
		LOG(0, "pData is invalid\n");

		return INJ_ERR_NO_DATA;
	}

	ERROR_DATA error_data{ 0 };

	if (!pData->szDllPath)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Invalid path\n");

		return INJ_ERR_INVALID_FILEPATH;
	}
	
	DOTNET_INJECTIONDATA_INTERNAL data_internal(pData);
	DWORD Ret = DotNet_Inject_Internal(&data_internal);
	pData->hDllOut = data_internal.hDllOut;

	return Ret;
}

DWORD __stdcall DotNet_InjectW(DOTNET_INJECTIONDATAW * pData)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "DotNet_InjectW called with pData = %p\n", pData);
	
	if (WaitForSingleObject(g_hRunningEvent, 0) == WAIT_OBJECT_0)
	{
		LOG(0, "Different injection in progress. Wait for the other injection to finish first.\n");

		return INJ_ERR_ALREADY_RUNNING;
	}

	if (!pData)
	{
		LOG(0, "pData is invalid\n");

		return INJ_ERR_NO_DATA;
	}

	ERROR_DATA error_data{ 0 };

	if (!pData->szDllPath)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Invalid path\n");

		return INJ_ERR_INVALID_FILEPATH;
	}
	
	DOTNET_INJECTIONDATA_INTERNAL data_internal(pData);
	DWORD Ret = DotNet_Inject_Internal(&data_internal);
	pData->hDllOut = data_internal.hDllOut;

	return Ret;
}

DWORD __stdcall DotNet_Inject_Internal(DOTNET_INJECTIONDATA_INTERNAL * pData)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	SetEvent(g_hRunningEvent);
	ResetEvent(g_hInterruptEvent);
	ResetEvent(g_hInterruptedEvent);

	DWORD RetVal = INJ_ERR_SUCCESS;

	ERROR_DATA error_data{ 0 };
	auto & Data = *pData;

	RetVal = GetImportState();
	if (RetVal != INJ_ERR_SUCCESS)
	{
		LOG(0, "Resolving imports failed: %08X\n", RetVal);

		error_data = import_handler_error_data;

		return DotNet_InitErrorStruct(Data, -1, INJ_ERR_IMPORT_HANDLER_NOT_DONE, error_data);
	}

	if (Data.Mode == INJECTION_MODE::IM_LdrpLoadDllInternal && !IsWin10OrGreater())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "LdrpLoadDllInternal is only supported on Windows 10\n");

		return DotNet_InitErrorStruct(Data, -1, INJ_ERR_NOT_SUPPORTED, error_data);
	}

	if (Data.DllPath.empty())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Invalid path provided (empty string)\n");

		return DotNet_InitErrorStruct(Data, -1, INJ_ERR_INVALID_FILEPATH, error_data);
	}

	if (!FileExistsW(Data.DllPath))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(0, "File doesn't exist: %08X\n", error_data.AdvErrorCode);

		return DotNet_InitErrorStruct(Data, -1, INJ_ERR_FILE_DOESNT_EXIST, error_data);
	}

	if (PathIsRelativeW(Data.DllPath.c_str()))
	{
		wchar_t buffer[MAX_PATH * 2]{ 0 };
		auto win_ret = GetFullPathNameW(Data.DllPath.c_str(), sizeof(buffer) / sizeof(wchar_t), buffer, nullptr);
		if (!win_ret || win_ret >= sizeof(buffer) / sizeof(wchar_t))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(0, "Failed to resolve absolute file path: %08X\n", error_data.AdvErrorCode);

			return DotNet_InitErrorStruct(Data, -1, INJ_ERR_FAILED_TO_RESOLVE_PATH, error_data);
		}

		Data.DllPath = buffer;
	}

	if (!Data.ProcessID)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Invalid process identifier specified\n");

		return DotNet_InitErrorStruct(Data, -1, INJ_ERR_INVALID_PID, error_data);
	}

	if (Data.Flags & INJ_LOAD_DLL_COPY)
	{
		LOG(0, "Copying dll into temp directory\n");

		DWORD win32err = NULL;

		auto dwRet = CreateTempFileCopy(Data.DllPath, win32err);
		if (dwRet != FILE_ERR_SUCCESS)
		{
			INIT_ERROR_DATA(error_data, win32err);

			LOG(0, "Failed to copy file to temp directory: %08X\n", dwRet);

			return DotNet_InitErrorStruct(Data, -1, dwRet, error_data);
		}

		LOG(0, "Path of dll copy: %ls\n", Data.DllPath.c_str());
	}

	if (Data.Flags & INJ_SCRAMBLE_DLL_NAME)
	{
		LOG(0, "Scrambling dll name\n");

		DWORD win32err = NULL;

		auto dwRet = ScrambleFileName(Data.DllPath, 10, win32err);
		if (dwRet != FILE_ERR_SUCCESS)
		{
			INIT_ERROR_DATA(error_data, win32err);

			LOG(0, "Failed to copy file to temp directory: %08X\n", dwRet);

			return DotNet_InitErrorStruct(Data, -1, dwRet, error_data);
		}

		LOG(0, "Path of renamed dll: %ls\n", Data.DllPath.c_str());
	}

	HANDLE hTargetProc = nullptr;
	hTargetProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, Data.ProcessID);
	if (!hTargetProc)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(0, "OpenProcess failed: %08X\n", (DWORD)error_data.AdvErrorCode);

		return DotNet_InitErrorStruct(Data, -1, INJ_ERR_CANT_OPEN_PROCESS, error_data);
	}

	DWORD handle_info = 0;
	if (!hTargetProc || !GetHandleInformation(hTargetProc, &handle_info))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(0, "Invalid process handle: %08X\n", (DWORD)error_data.AdvErrorCode);

		CloseHandle(hTargetProc);

		return DotNet_InitErrorStruct(Data, -1, INJ_ERR_INVALID_PROC_HANDLE, error_data);
	}

	LOG(0, "Attached to target process\n");

	wchar_t szExePath[MAX_PATH * 2]{ 0 };
	DWORD size_inout = sizeof(szExePath) / sizeof(szExePath[0]);
	if (!QueryFullProcessImageNameW(hTargetProc, NULL, szExePath, &size_inout))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(0, "QueryFullProcessImageNameW failed: %08X\n", (DWORD)error_data.AdvErrorCode);

		CloseHandle(hTargetProc);

		return DotNet_InitErrorStruct(Data, -1, INJ_ERR_CANT_GET_EXE_FILENAME, error_data);
	}

	auto ExePath	= std::wstring(szExePath);
	auto ExeNamePos	= ExePath.find_last_of('\\');

	if (ExeNamePos == std::string::npos)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Failed to extract exe name from path\n");

		CloseHandle(hTargetProc);

		return DotNet_InitErrorStruct(Data, -1, INJ_ERR_INVALID_EXE_PATH, error_data);
	}

	Data.TargetProcessExeFileName = ExePath.substr(ExeNamePos + 1);

	LOG(0, "Target process name = %ls\n", Data.TargetProcessExeFileName.c_str());

	LOG(0, "Validating specified file\n");

	DWORD FileErr = FILE_ERR_SUCCESS;
	std::wstring dot_net_version;
	bool native_target = true;
#ifdef _WIN64
	native_target = IsNativeProcess(hTargetProc);
	if (native_target)
	{
		FileErr = ValidateDotNetDllFile(Data.DllPath, IMAGE_FILE_MACHINE_AMD64, dot_net_version);
	}
	else
	{
		FileErr = ValidateDotNetDllFile(Data.DllPath, IMAGE_FILE_MACHINE_I386, dot_net_version);
	}
#else
	FileErr = ValidateDotNetDllFile(Data.DllPath, IMAGE_FILE_MACHINE_I386, dot_net_version);
#endif

	CloseHandle(hTargetProc);

	if (FileErr != FILE_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, FileErr);

		LOG(0, "Invalid file specified\n");

		return DotNet_InitErrorStruct(Data, native_target, INJ_ERR_PLATFORM_MISMATCH, error_data);
	}

	LOG(0, "File validated and prepared for injection:\n %ls\n", Data.DllPath.c_str());
	
	std::wstring dnpPath = g_RootPathW;
#ifdef _WIN64
	if (native_target)
	{
		dnpPath += DNP_DLL_FILENAME64;
	}
	else
	{
		dnpPath += DNP_DLL_FILENAME86;
	}
#else
	dnpPath += DNP_DLL_FILENAME;
#endif

	if (!FileExistsW(dnpPath))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "DNP remote loader DLL is missing: %ls\n", dnpPath.c_str());

		return DotNet_InitErrorStruct(Data, native_target, DNP_ERR_REMOTE_LOADER_MISSING, error_data);
	}

	std::wstring InfoPath = g_RootPathW + DNP_INFO_FILENAME;
	if (FileExistsW(InfoPath))
	{
		DeleteFileW(InfoPath.c_str());
	}

	std::wofstream dnp_info(InfoPath, std::ios_base::out | std::ios_base::app);
	if (!dnp_info.good())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Failed to create info file\n");

		return DotNet_InitErrorStruct(Data, native_target, DNP_ERR_CANT_OPEN_INFO_TXT, error_data);
	}

	dnp_info << Data.DllPath	<< std::endl;
	dnp_info << dot_net_version << std::endl;
	dnp_info << Data.Namespace	<< std::endl;
	dnp_info << Data.ClassName	<< std::endl;
	dnp_info << Data.MethodName << std::endl;
	dnp_info << Data.Argument	<< std::endl;

	auto original_info_size = dnp_info.tellp();

	dnp_info.close();

	DWORD flags_stripped = Data.Flags;

	if (flags_stripped & INJ_LOAD_DLL_COPY)
	{
		flags_stripped ^= INJ_LOAD_DLL_COPY;
	}

	if (flags_stripped & INJ_SCRAMBLE_DLL_NAME)
	{
		flags_stripped ^= INJ_SCRAMBLE_DLL_NAME;
	}
	
	if (flags_stripped & INJ_UNLINK_FROM_PEB)
	{
		flags_stripped ^= INJ_UNLINK_FROM_PEB;
	}

	if (flags_stripped & INJ_FAKE_HEADER)
	{
		flags_stripped ^= INJ_FAKE_HEADER;
	}

	if (flags_stripped & INJ_ERASE_HEADER)
	{
		flags_stripped ^= INJ_ERASE_HEADER;
	}

	INJECTIONDATA_INTERNAL loader_injection;
	loader_injection.DllPath			= dnpPath;
	loader_injection.ProcessID			= Data.ProcessID;
	loader_injection.Mode				= INJECTION_MODE::IM_LdrpLoadDll; //can't be mapped anyway
	loader_injection.Method				= Data.Method;
	loader_injection.Flags				= flags_stripped; //can't be rename scrambled/copied
	loader_injection.Timeout			= Data.Timeout;
	loader_injection.hHandleValue		= NULL;
	loader_injection.GenerateErrorLog	= Data.GenerateErrorLog;

	auto DNP_Error = Inject_Internal(&loader_injection);
	if (DNP_Error != INJ_ERR_SUCCESS || !loader_injection.hDllOut)
	{
		INIT_ERROR_DATA(error_data, DNP_Error);

		LOG(0, "Failed to load .NET loader into target process\n");

		DeleteFileW(InfoPath.c_str());

		return DotNet_InitErrorStruct(Data, native_target, DNP_ERR_CANT_OPEN_INFO_TXT, error_data);
	}

	bool dnp_info_updated = false;
	auto Timer = GetTickCount64();
	while (GetTickCount64() - Timer < Data.Timeout)
	{
		auto dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		std::wifstream FileOut(InfoPath);
		if (FileOut.good())
		{
			FileOut.seekg(std::ios::end);
			auto current_info_size = FileOut.tellg();

			if (current_info_size != original_info_size)
			{
				LOG(0, ".NET loader data updated\n");

				dnp_info_updated = true;

				break;
			}
		}
		
		if (dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(0, "Interrupt!\n");

			SetEvent(g_hInterruptedEvent);

			return DNP_ERR_INTERRUPT;
		}
	}

	if (!(loader_injection.Flags & INJ_HIJACK_HANDLE))
	{
		hTargetProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, loader_injection.ProcessID);
		if (hTargetProc != NULL)
		{
			ProcessInfo pi;
			pi.SetProcess(hTargetProc);
			auto entry = pi.GetLdrEntry(loader_injection.hDllOut);
			printf("ldr entry = %p\n", entry);

			LDR_DATA_TABLE_ENTRY ldr{};
			ReadProcessMemory(hTargetProc, entry, &ldr, sizeof(ldr), nullptr);
			printf("LDR::LoadFlags : %d\n", ldr.DependentLoadFlags);
			printf("LDR::LoadReason: %d\n", ldr.LoadReason);
			printf("LDR::Flags     : %d\n", ldr.Flags);
			printf("LDR::RefCount  : %d\n", ldr.ReferenceCount);

			LDR_DDAG_NODE ddag{};
			ReadProcessMemory(hTargetProc, ldr.DdagNode, &ddag, sizeof(ddag), nullptr);
			printf("DDAG::LoadCount : %d\n", ddag.LoadCount);
			printf("DDAG::State     : %d\n", ddag.State);
			printf("DDAG::LowestLink: %d\n", ddag.LowestLink);
			printf("DDAG::Preorder  : %d\n", ddag.PreorderNumber);


			EjectDll(hTargetProc, loader_injection.hDllOut, native_target ? false : true);

			


			CloseHandle(hTargetProc);
		}
	}

	if (!dnp_info_updated)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, ".NET loader timed out\n");

		return DotNet_InitErrorStruct(Data, native_target, DNP_ERR_CANT_OPEN_INFO_TXT, error_data);
	}

	std::wifstream FileOut(InfoPath);
	if (!FileOut.good())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, ".NET loader timed out\n");

		return DotNet_InitErrorStruct(Data, native_target, DNP_ERR_CANT_OPEN_INFO_TXT, error_data);
	}

	std::wstringstream info_raw;
	info_raw << FileOut.rdbuf();

	FileOut.close();

	DeleteFileW(InfoPath.c_str());

	std::wstring info = info_raw.str();
	std::vector<std::wstring> returned_data;

	size_t current_position = info.find('\n');
	while (current_position != std::wstring::npos)
	{
		returned_data.push_back(info.substr(0, current_position));
		info.erase(0, current_position + sizeof('\n'));

		current_position = info.find('\n');
	}

	returned_data.push_back(info);

	if (returned_data.size() < 2)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "The .NET loader returned invalid information\n");

		return DotNet_InitErrorStruct(Data, native_target, DNP_ERR_INVALID_DATA, error_data);
	}

	HINSTANCE base	= ReCa<HINSTANCE>(wcstoll(returned_data[0].c_str(), nullptr, 0x10));
	DWORD error		= wcstol(returned_data[1].c_str(), nullptr, 0x10);

	if (error != DNP_ERR_SUCCESS)
	{
		if (error == DNP_ERR_HRESULT)
		{
			INIT_ERROR_DATA(error_data, MDWD(base));

			LOG(0, "The .NET loader returned an HRESULT error code: %08X\n", MDWD(base));

			return DotNet_InitErrorStruct(Data, native_target, error, error_data);
		}

		INIT_ERROR_DATA(error_data, error);

		LOG(0, "The .NET loader returned an error code: %08X\n", error);

		return DotNet_InitErrorStruct(Data, native_target, DNP_ERR_LOADER_FAILED, error_data);
	}

	Data.hDllOut = base;

	return DNP_ERR_SUCCESS;
}

DWORD DotNet_InitErrorStruct(const DOTNET_INJECTIONDATA_INTERNAL & Data, int Native, DWORD ErrorCode, const ERROR_DATA & error_data)
{
	ResetEvent(g_hRunningEvent);

	if (!ErrorCode)
	{
		return INJ_ERR_SUCCESS;
	}

	if (Data.GenerateErrorLog)
	{
		ERROR_INFO info{ };
		info.DllFileName				= Data.DllPath;
		info.TargetProcessExeFileName	= Data.TargetProcessExeFileName;
		info.TargetProcessId			= Data.ProcessID;
		info.InjectionMode				= Data.Mode;
		info.LaunchMethod				= Data.Method;
		info.Flags						= Data.Flags;
		info.HandleValue				= Data.hHandleValue;
		info.bNative					= Native;
		
		info.ErrorCode		= ErrorCode;
		info.AdvErrorCode	= error_data.AdvErrorCode;
		info.SourceFile		= error_data.szFileName;
		info.FunctionName	= error_data.szFunctionName;
		info.Line			= error_data.Line;

		info.IsDotNet	= true;
		info.Namespace	= Data.Namespace;
		info.ClassName	= Data.ClassName;
		info.Method		= Data.MethodName;
		info.Argument	= Data.Argument;
		info.Version	= Data.Version;

		ErrorLog(info);
	}

	return ErrorCode;
}

DWORD ValidateDotNetDllFile(const std::wstring & FilePath, DWORD target_machine, std::wstring & version_out)
{
	std::ifstream File(FilePath, std::ios::binary | std::ios::ate);

	if (!File.good())
	{
		LOG(1, "Can't open file\n");
	
		return FILE_ERR_CANT_OPEN_FILE;
	}

	auto FileSize = File.tellg();
	if (FileSize < 0x1000)
	{
		LOG(1, "Specified file is too small\n");

		File.close();

		return FILE_ERR_INVALID_FILE_SIZE;
	}

	BYTE * raw_data = new(std::nothrow) BYTE[static_cast<size_t>(FileSize)]();
	if (!raw_data)
	{
		LOG(1, "Memory allocation failed\n");

		File.close();

		return FILE_ERR_MEMORY_ALLOCATION_FAILED;
	}

	File.seekg(0, std::ios::beg);
	File.read(ReCa<char *>(raw_data), FileSize);
	File.close();

	auto dos_header = ReCa<IMAGE_DOS_HEADER *>(raw_data);
	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
	{
		LOG(1, "Invalid DOS header signature\n");

		delete[] raw_data;

		return FILE_ERR_INVALID_FILE;
	}

	if (dos_header->e_lfanew > 0x1000)
	{
		delete[] raw_data;

		LOG(1, "Invalid nt header offset\n");

		return FILE_ERR_INVALID_FILE;
	}

	auto nt_headers = ReCa<IMAGE_NT_HEADERS64 *>(raw_data + dos_header->e_lfanew);
	if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
	{
		LOG(1, "Not a valid PE file (nt signature mismatch)\n");

		delete[] raw_data;

		return FILE_ERR_INVALID_FILE;
	}

	WORD character = nt_headers->FileHeader.Characteristics;	
	if (!(character & IMAGE_FILE_DLL))
	{
		LOG(1, "Not a valid DLL (characteristics mismatch)\n");

		delete[] raw_data;

		return false;
	}

	DWORD ComDirSize	= 0;
	DWORD SizeOfImage	= 0;
	DWORD SizeOfHeaders = 0;

	auto * nt64 = ReCa<IMAGE_NT_HEADERS64 *>(nt_headers);
	auto * nt32 = ReCa<IMAGE_NT_HEADERS32 *>(nt_headers);

	WORD machine = nt_headers->FileHeader.Machine;
	switch (machine)
	{
		case IMAGE_FILE_MACHINE_AMD64:
			ComDirSize		= nt64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
			SizeOfImage		= nt64->OptionalHeader.SizeOfImage;
			SizeOfHeaders	= nt64->OptionalHeader.SizeOfHeaders;
			break;

		case IMAGE_FILE_MACHINE_I386:
			ComDirSize		= nt32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
			SizeOfImage		= nt32->OptionalHeader.SizeOfImage;
			SizeOfHeaders	= nt32->OptionalHeader.SizeOfHeaders;
			break;
		
		default:
			LOG(1, "Invalid DLL platform\n");

			return FILE_ERR_INVALID_FILE;
			break;
	}

	if (machine != target_machine && target_machine != IMAGE_FILE_MACHINE_AMD64)
	{
		LOG(1, "Invalid DLL platform\n");

		delete[] raw_data;

		return FILE_ERR_INVALID_FILE;
	}

	if (!ComDirSize || !SizeOfImage || !SizeOfHeaders)
	{
		LOG(1, "DLL doesn't have a com directory or is not a managed binary\n");

		delete[] raw_data;

		return FILE_ERR_INVALID_FILE;
	}

	BYTE * mapped_image = new(std::nothrow) BYTE[SizeOfImage]();
	if (!mapped_image)
	{
		LOG(1, "Memory allocation for file mapping failed\n");

		delete[] raw_data;

		return FILE_ERR_MEMORY_ALLOCATION_FAILED;
	}

	memmove(mapped_image, raw_data, SizeOfHeaders);
	auto * pCurrentSectionHeader = IMAGE_FIRST_SECTION(nt_headers);
	for (UINT i = 0; i != nt_headers->FileHeader.NumberOfSections; ++i, ++pCurrentSectionHeader)
	{
		if (pCurrentSectionHeader->SizeOfRawData)
		{
			memmove(mapped_image + pCurrentSectionHeader->VirtualAddress, raw_data + pCurrentSectionHeader->PointerToRawData, pCurrentSectionHeader->SizeOfRawData);
		}
	}

	delete[] raw_data;

	dos_header = ReCa<IMAGE_DOS_HEADER *>(mapped_image);
	nt32 = ReCa<IMAGE_NT_HEADERS32 *>(mapped_image + dos_header->e_lfanew);
	nt64 = ReCa<IMAGE_NT_HEADERS64 *>(mapped_image + dos_header->e_lfanew);

	IMAGE_COR20_HEADER * cor20_header = nullptr;

	if (machine == IMAGE_FILE_MACHINE_AMD64)
	{
		cor20_header = ReCa<IMAGE_COR20_HEADER *>(mapped_image + nt64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress);
	}
	else
	{
		cor20_header = ReCa<IMAGE_COR20_HEADER *>(mapped_image + nt32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress);
	}

	if (!cor20_header->MetaData.Size || !cor20_header->MetaData.VirtualAddress)
	{
		LOG(1, "DLL doesn't have .NET meta data or is not a managed binary\n");

		delete[] mapped_image;

		return FILE_ERR_INVALID_FILE;
	}

	auto * meta_data = ReCa<DOTNET_META_DATA *>(mapped_image + cor20_header->MetaData.VirtualAddress);
	if (meta_data->Signature != DOT_NET_SIGNATURE)
	{
		LOG(1, "Invalid .NET signature in meta data\n");

		delete[] mapped_image;

		return FILE_ERR_INVALID_FILE;
	}

	version_out = std::wstring(meta_data->Version, meta_data->Version + meta_data->VersionStringLength);
	
	version_out.erase(
		std::remove_if(version_out.begin(), version_out.end(),
			[](wchar_t c)
			{ 
				return (c == 0); 
			}),
		version_out.end()
	);

	delete[] mapped_image;

	return FILE_ERR_SUCCESS;
}

DOTNET_INJECTIONDATA_INTERNAL::DOTNET_INJECTIONDATA_INTERNAL(const DOTNET_INJECTIONDATAA * pData)
{
	DllPath				= CharArrayToStdWstring(pData->szDllPath);
	ProcessID			= pData->ProcessID;
	Mode				= pData->Mode;
	Method				= pData->Method;
	Flags				= pData->Flags;
	Timeout				= pData->Timeout;
	hHandleValue		= pData->hHandleValue;
	GenerateErrorLog	= pData->GenerateErrorLog;

	Namespace	= CharArrayToStdWstring(pData->szNamespace);
	ClassName	= CharArrayToStdWstring(pData->szClassName);
	MethodName	= CharArrayToStdWstring(pData->szMethodName);
	Argument	= CharArrayToStdWstring(pData->szArgument);
}

DOTNET_INJECTIONDATA_INTERNAL::DOTNET_INJECTIONDATA_INTERNAL(const DOTNET_INJECTIONDATAW * pData)
{
	DllPath				= std::wstring(pData->szDllPath);
	ProcessID			= pData->ProcessID;
	Mode				= pData->Mode;
	Method				= pData->Method;
	Flags				= pData->Flags;
	Timeout				= pData->Timeout;
	hHandleValue		= pData->hHandleValue;
	GenerateErrorLog	= pData->GenerateErrorLog;

	Namespace	= std::wstring(pData->szNamespace);
	ClassName	= std::wstring(pData->szClassName);
	MethodName	= std::wstring(pData->szMethodName);
	Argument	= std::wstring(pData->szArgument);
}
```

`GH Injector Library/DotNetInjection.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "pch.h"

#include "Injection.h"

//Stolen from here:
//https://www.codeproject.com/Articles/12585/The-NET-File-Format#GetStarted
//Really epic article!

#define DOT_NET_SIGNATURE 0x424A5342 //"BSJB"

struct DOTNET_META_DATA
{
	DWORD Signature; //"BSJB" or 0x424A5342

	WORD MajorVersion;
	WORD MinorVersion;

	DWORD ExtraDataRVA;

	DWORD VersionStringLength;
	char Version[ANYSIZE_ARRAY];
};

//ansi version of the .NET info structure:
struct DOTNET_INJECTIONDATAA
{
	char			szDllPath[MAX_PATH * 2];
	DWORD			ProcessID;
	INJECTION_MODE	Mode;
	LAUNCH_METHOD	Method;
	DWORD			Flags;
	DWORD			Timeout;
	DWORD			hHandleValue;
	HINSTANCE		hDllOut;
	bool			GenerateErrorLog;

	char szNamespace[128];	//namespace of the class in the target module
	char szClassName[128];	//name of the class in the target module
	char szMethodName[128];	//name of the method in the target module
	char szArgument[128];	//argument to be send to the method
};

//unicode version of the .NET info structure:
struct DOTNET_INJECTIONDATAW
{
	wchar_t			szDllPath[MAX_PATH * 2];
	DWORD			ProcessID;
	INJECTION_MODE	Mode;
	LAUNCH_METHOD	Method;
	DWORD			Flags;
	DWORD			Timeout;
	DWORD			hHandleValue;
	HINSTANCE		hDllOut;
	bool			GenerateErrorLog;

	wchar_t szNamespace[128];
	wchar_t szClassName[128];
	wchar_t szMethodName[128];
	wchar_t szArgument[128];
};

//.NET modules will be loaded with ExecuteInDefaultAppDomain.
//The injection settings will be applied to the .NET loader module (see GH Injector DNP).
//Since that module can't be mapped due to technical reasons it will be loaded using LdrpLoadDll.
//Furthermore the following flags will also be ignored:
/// INJ_LOAD_DLL_COPY
/// INJ_SCRAMBLE_DLL_NAME
/// INJ_UNLINK_FROM_PEB
/// INJ_FAKE_HEADER
/// INJ_ERASE_HEADER

DWORD __stdcall DotNet_InjectA(DOTNET_INJECTIONDATAA * pData);
DWORD __stdcall DotNet_InjectW(DOTNET_INJECTIONDATAW * pData);
//.NET injection functions (ansi/unicode).
//
//Arguments:
//		pData (DOTNET_INJECTIONDATAA/DOTNET_INJECTIONDATAW):
///			Pointer to the information structure for the injection.
//
//Returnvalue (DWORD):
///		On success: INJ_ERR_SUCCESS.
///		On failure: One of the errorcodes defined in Error.h.

//internal stuff, use it if you know what you're doing
struct DOTNET_INJECTIONDATA_INTERNAL
{
	std::wstring	DllPath;
	std::wstring	TargetProcessExeFileName;

	DWORD			ProcessID;
	INJECTION_MODE	Mode;
	LAUNCH_METHOD	Method;
	DWORD			Flags;
	DWORD			Timeout;
	DWORD			hHandleValue;
	HINSTANCE		hDllOut;
	bool			GenerateErrorLog;

	std::wstring Namespace;
	std::wstring ClassName;
	std::wstring MethodName;
	std::wstring Argument;
	std::wstring Version;

	DOTNET_INJECTIONDATA_INTERNAL(const DOTNET_INJECTIONDATAA * pData);
	DOTNET_INJECTIONDATA_INTERNAL(const DOTNET_INJECTIONDATAW * pData);
};

DWORD __stdcall DotNet_Inject_Internal(DOTNET_INJECTIONDATA_INTERNAL * pData);
```

`GH Injector Library/Download Manager.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Download Manager.h"

DownloadManager::DownloadManager(bool ForceRedownload)
{
    m_bForceRedownload = ForceRedownload;
}

DownloadManager::~DownloadManager()
{
    if (m_hInterruptEvent)
    {
        CloseHandle(m_hInterruptEvent);
    }
}

HRESULT __stdcall DownloadManager::QueryInterface(const IID & riid, void ** ppvObject)
{
    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(ppvObject);

    return E_NOINTERFACE;
}

ULONG __stdcall DownloadManager::AddRef(void)
{
    return 1;
}

ULONG __stdcall DownloadManager::Release(void)
{
    return 1;
}

HRESULT __stdcall DownloadManager::OnStartBinding(DWORD dwReserved, IBinding * pib)
{
    UNREFERENCED_PARAMETER(dwReserved);
    UNREFERENCED_PARAMETER(pib);

    LOG(2, "DownloadManager: OnStartBinding\n");

    return S_OK;
}

HRESULT __stdcall DownloadManager::GetPriority(LONG * pnPriority)
{
    UNREFERENCED_PARAMETER(pnPriority);

    LOG(2, "DownloadManager: GetPriority\n");

    return S_OK;
}

HRESULT __stdcall DownloadManager::OnLowResource(DWORD reserved)
{
    UNREFERENCED_PARAMETER(reserved);

    LOG(2, "DownloadManager: OnLowResource\n");

    return S_OK;
}

HRESULT __stdcall DownloadManager::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    UNREFERENCED_PARAMETER(hresult);
    UNREFERENCED_PARAMETER(szError);

    LOG(2, "DownloadManager: OnStopBinding\n");

    return S_OK;
}

HRESULT __stdcall DownloadManager::GetBindInfo(DWORD * grfBINDF, BINDINFO * pbindinfo)
{
    LOG(2, "DownloadManager: GetBindInfo\n");

    if (m_bForceRedownload)
    {
        if (grfBINDF)
        {
            *grfBINDF = BINDF_GETNEWESTVERSION | BINDF_NEEDFILE;
        }

        if (pbindinfo)
        {
            pbindinfo->dwOptions        = BINDINFO_OPTIONS_WININETFLAG;
            pbindinfo->dwOptionsFlags   = INTERNET_FLAG_PRAGMA_NOCACHE | INTERNET_FLAG_RELOAD;
        }
    }

    return S_OK;
}

HRESULT __stdcall DownloadManager::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC * pformatetc, STGMEDIUM * pstgmed)
{
    UNREFERENCED_PARAMETER(grfBSCF);
    UNREFERENCED_PARAMETER(dwSize);
    UNREFERENCED_PARAMETER(pformatetc);
    UNREFERENCED_PARAMETER(pstgmed);

    LOG(2, "DownloadManager: OnDataAvailable\n");

    return S_OK;
}

HRESULT __stdcall DownloadManager::OnObjectAvailable(const IID & riid, IUnknown * punk)
{
    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(punk);

    LOG(2, "DownloadManager: OnObjectAvailable\n");

    return S_OK;
}

HRESULT __stdcall DownloadManager::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    UNREFERENCED_PARAMETER(ulStatusCode);
    UNREFERENCED_PARAMETER(szStatusText);

    if (m_hInterruptEvent && WaitForSingleObject(m_hInterruptEvent, 0) == WAIT_OBJECT_0)
    {
        LOG(2, "DownloadManager: Interrupting download\n");

        return E_ABORT;
    }

    if (ulProgressMax)
    {
        m_fProgress = (float)ulProgress / ulProgressMax;

        if (m_fProgress - m_fOldProgress >= 0.095f)
        {
            LOG(2, "DownloadManager: %2.0f%%\n", (double)100.0f * m_fProgress);
            m_fOldProgress = m_fProgress;
        }
    }

    return S_OK;
}

BOOL DownloadManager::SetInterruptEvent(HANDLE hInterrupt)
{
    if (m_hInterruptEvent)
    {
        if (!CloseHandle(m_hInterruptEvent))
        {
            LOG(2, "Failed to close previous interrupt handle object: %08X\n", GetLastError());
        }

        m_hInterruptEvent = nullptr;
    }

    LOG(2, "DownloadManager: New interrupt event specified\n");

    auto current_process = GetCurrentProcess();

    return DuplicateHandle(current_process, hInterrupt, current_process, &m_hInterruptEvent, NULL, FALSE, DUPLICATE_SAME_ACCESS);
}

float DownloadManager::GetDownloadProgress() const
{
    return m_fProgress;
}
```

`GH Injector Library/Download Manager.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

//Stolen from here:
//https://stackoverflow.com/a/5292277
//by User Hans Passant

#pragma once

#include "pch.h"

class DownloadManager : public IBindStatusCallback
{
    HANDLE  m_hInterruptEvent   = nullptr;
    float   m_fProgress         = 0.0f;
    float   m_fOldProgress      = 0.0f;
    bool    m_bForceRedownload  = false;

public:

    DownloadManager(bool ForceRedownload = true);

    ~DownloadManager();

    HRESULT __stdcall QueryInterface(const IID & riid, void ** ppvObject);

    ULONG STDMETHODCALLTYPE AddRef();

    ULONG STDMETHODCALLTYPE Release();

    virtual HRESULT STDMETHODCALLTYPE OnStartBinding(DWORD dwReserved, IBinding * pib);

    virtual HRESULT STDMETHODCALLTYPE GetPriority(LONG * pnPriority);

    virtual HRESULT STDMETHODCALLTYPE OnLowResource(DWORD reserved);

    virtual HRESULT STDMETHODCALLTYPE OnStopBinding(HRESULT hresult, LPCWSTR szError);

    virtual HRESULT STDMETHODCALLTYPE GetBindInfo(DWORD * grfBINDF, BINDINFO * pbindinfo);

    virtual HRESULT STDMETHODCALLTYPE OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC * pformatetc, STGMEDIUM * pstgmed);

    virtual HRESULT STDMETHODCALLTYPE OnObjectAvailable(const IID & riid, IUnknown * punk);

    HRESULT __stdcall OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText);

    BOOL SetInterruptEvent(HANDLE hInterrupt);

    float GetDownloadProgress() const;
};
```

`GH Injector Library/Eject.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Eject.h"
#include "Start Routine.h"

bool EjectDll(HANDLE hTargetProc, HINSTANCE hModule, bool WOW64)
{
	LOG(3, "EjectDll called\n");
	LOG(4, "PID     = %08X\n", GetProcessId(hTargetProc));
	LOG(4, "hModule = %p\n", hModule);

	ERROR_DATA eject_data;
	DWORD remote_ret	= 0;
	DWORD ret			= 0;

#ifdef _WIN64
	if (WOW64)
	{
		ret = StartRoutine_WOW64(hTargetProc, WOW64::LdrUnloadDll_WOW64, MDWD(hModule), LAUNCH_METHOD::LM_NtCreateThreadEx, NULL, remote_ret, INJ_EJECT_TIMEOUT, eject_data);
	}
	else
	{
		ret = StartRoutine(hTargetProc, ReCa<f_Routine>(NATIVE::LdrUnloadDll), hModule, LAUNCH_METHOD::LM_NtCreateThreadEx, NULL, remote_ret, INJ_EJECT_TIMEOUT, eject_data);
	}
#else
	UNREFERENCED_PARAMETER(WOW64);

	ret = StartRoutine(hTargetProc, ReCa<f_Routine>(NATIVE::LdrUnloadDll), hModule, LAUNCH_METHOD::LM_NtCreateThreadEx, NULL, remote_ret, INJ_EJECT_TIMEOUT, eject_data);
#endif

	if (ret != SR_ERR_SUCCESS)
	{
		LOG(3, "Failed to eject dll:\n");
		LOG(4, "ret        = %08X\n", ret);
		LOG(4, "advanced   = %08X\n", eject_data.AdvErrorCode);

		return false;
	}
	else if (NT_FAIL(remote_ret))
	{
		LOG(3, "Failed to eject dll:\n");
		LOG(4, "remote_ret = %08X:\n", remote_ret);

		return false;
	}

	LOG(3, "Dll ejected successfully\n");

	return true;
}

bool EjectHijackLibrary(HANDLE hTargetProc, HINSTANCE hInjectionModuleEx, bool Interrupt)
{
	LOG(2, "Ejecting hijack library\n");

	if (!Interrupt)
	{
		return EjectDll(hTargetProc, hInjectionModuleEx);
	}

	ERROR_DATA interrupt_data;
	DWORD remote_ret				= 0;
	DWORD ret						= 0;
	f_Routine pInterruptDownloadEx	= ReCa<f_Routine>(ReCa<UINT_PTR>(InterruptDownloadEx) - ReCa<UINT_PTR>(g_hInjMod) + ReCa<UINT_PTR>(hInjectionModuleEx));

	ret = StartRoutine(hTargetProc, pInterruptDownloadEx, nullptr, LAUNCH_METHOD::LM_NtCreateThreadEx, NULL, remote_ret, INJ_EJECT_TIMEOUT, interrupt_data);

	if (ret != SR_ERR_SUCCESS)
	{
		LOG(2, "Failed to interrupt hijack library:\n");
		LOG(3, "ret        = %08X\n", ret);
		LOG(3, "advanced   = %08X\n", interrupt_data.AdvErrorCode);
	} //try to eject even if interrupt failed
	
	return EjectDll(hTargetProc, hInjectionModuleEx);
}
```

`GH Injector Library/Eject.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "Import Handler.h"

#define INJ_EJECT_TIMEOUT 200

bool EjectDll(HANDLE hTargetProc, HINSTANCE hModule, bool WOW64 = false);
//Unloads a dll using LdrUnloadDll by creating a thread in the target process using NtCreateThreadEx (native only).
//
//Arguments:
//		hTargetProc (HANDLE):
///			HANDLE to the target process which needs:
///				PROCESS_CREATE_THREAD
///				PROCESS_QUERY_INFORMATION
///				PROCESS_VM_OPERATION
///				PROCESS_VM_WRITE
///				PROCESS_VM_READ
//		hModule (HINSTANCE):
///			The baseaddress of the module to unload.
//		WOW64 (bool):
///			Set to true if the target process is running under WOW64 and the calling process is native.
///			If the calling process is not native this argument is ignored.
//
//Returnvalue (bool):
///		true:	the module was unloaded successfully.
///		false:	something went wrong, see logs

bool EjectHijackLibrary(HANDLE hTargetProc, HINSTANCE hInjectionModuleEx, bool Interrupt = true);
//Unloads the injection library from another process during handle hijacking.
//
//Arguments:
//		hTargetProc (HANDLE):
///			HANDLE to the target process which needs:
///				PROCESS_CREATE_THREAD
///				PROCESS_QUERY_INFORMATION
///				PROCESS_VM_OPERATION
///				PROCESS_VM_WRITE
///				PROCESS_VM_READ
//		hInjectionModuleEx (HINSTANCE):
///			The baseaddress of the injection library in the target process.
//		Interrupt (bool):
///			If set to true InterruptDownloadEx is called remotely before unloading the dll.
//
//Returnvalue (bool):
///		true:	the module was unloaded successfully.
///		false:	something went wrong, see logs
```

`GH Injector Library/Error.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

/// ###############	##########		##########		     #######	   ##########			###			###
/// ###############	############	############	  ####     ####    ############			###			###
/// ###				###        ###	###        ###	 ###         ###   ###        ###		###			###
/// ###				###        ###	###        ###	###           ###  ###        ###		###			###
/// ###				###       ###	###       ###	###           ###  ###       ###		###			###
/// ###############	###########		###########		###           ###  ###########			###############
/// ###############	###########		########### 	###			  ###  ###########			###############
/// ###				###      ###	###		###     ###			  ###  ###		###			###			###
/// ###				###		  ###	###		  ###	###           ###  ###		  ###		###			###
/// ###				###		   ###	###		   ###	 ###         ###   ###		   ###	 #	###			###
/// ###############	###		   ###	###		   ###	  ####     ####    ###		   ###  ###	###			###
/// ###############	###        ###	###        ###	     #######	   ###         ###   #	###			###

//Injection errors:
#define INJ_ERR_SUCCESS					0x00000000
#define INJ_ERR_ADVANCED_NOT_DEFINED	0x00000000
#define INJ_ERR_SHELLCODE_DUMPED		0x80000000
													
														//Source							: advanced error type	: error description

#define INJ_ERR_NO_DATA						0x00000001	//internal error					: -						: nullptr passed to InjectA/InjectW
#define INJ_ERR_INVALID_FILEPATH			0x00000002	//internal error					: -						: INJECTIONDATA/W::szDllPath is a nullptr
#define INJ_ERR_STR_CONVERSION_TO_W_FAILED	0x00000003	//mbstowcs_s						: errno_t				: conversion to unicode of an ansi string failed
#define INJ_ERR_STRINGC_XXX_FAIL			0x00000004	//StringCXXX failed					: HRESULT				: string operation failed
#define INJ_ERR_FILE_DOESNT_EXIST			0x00000005	//GetFileAttributesW				: win32 error			: INJECTIONDATAW::szDllPath doesn't exist
#define INJ_ERR_INVALID_PID					0x00000006	//internal error					: -						: provided process id is 0
#define INJ_ERR_CANT_OPEN_PROCESS			0x00000007	//OpenProcess						: win32 error			: opening the specified target process failed
#define INJ_ERR_INVALID_PROC_HANDLE			0x00000008	//GetHandleInformation				: win32 error			: the provided handle value is not a valid handle
#define INJ_ERR_CANT_GET_EXE_FILENAME		0x00000009	//QueryFullProcessImageNameW		: win32 error			: failed to resolve the file name of the target process
#define INJ_ERR_PLATFORM_MISMATCH			0x0000000A	//internal error					: file error			: the provided file can't be injected (file error 0x20000001 - 0x20000003)
#define INJ_ERR_CANT_GET_TEMP_DIR			0x0000000B	//GetTempPathW						: win32 error			: unable to retrieve the path to the current users temp directory
#define INJ_ERR_CANT_COPY_FILE				0x0000000C	//CopyFileW							: win32 error			: unable to create a copy of the specified dll file
#define INJ_ERR_CANT_RENAME_FILE			0x0000000D	//_wrename							: errno					: renaming the file failed
#define INJ_ERR_INVALID_INJ_METHOD			0x0000000E	//bruh moment						: bruh moment			: bruh moment
#define INJ_ERR_REMOTE_CODE_FAILED			0x0000000F	//internal error					: -						: the remote code wasn't able to load the specified module
#define INJ_ERR_WPM_FAIL					0x00000010	//WriteProcessMemory				: win32 error			: write operation failed
#define	INJ_ERR_RPM_FAIL					0x00000011	//ReadProcessMemory					: win32 error			: read operation failed
#define INJ_ERR_GET_MODULE_HANDLE_FAIL		0x00000012	//GetModuleHandle					: win32 error			: address of the specified module couldn't be resolved
#define INJ_ERR_CANT_FIND_MOD_PEB			0x00000013	//internal error					: -						: injected module isn't linked to the peb
#define INJ_ERR_OUT_OF_MEMORY_EXT			0x00000015	//VirtualAllocEx					: win32 error			: memory allocation in the target process failed
#define INJ_ERR_OUT_OF_MEMORY_INT			0x00000016	//VirtualAlloc						: win32 error			: internal memory allocation failed
#define INJ_ERR_OUT_OF_MEMORY_NEW			0x00000017	//operator new						: -						: internal memory allocation on heap failed
#define INJ_ERR_IMAGE_CANT_RELOC			0x00000018	//internal error					: -						: image has to be relocated but base reloc directory is emtpy
#define INJ_ERR_GET_SYMBOL_ADDRESS_FAILED	0x00000019	//internal error					: -						: can't resolve the address of a required symbol
#define INJ_ERR_GET_PROC_ADDRESS_FAIL		0x0000001A	//GetProcAddress					: -						: resolving the address of a required function failed
#define INJ_ERR_VERIFY_RESULT_FAIL			0x0000001B	//ReadProcessMemory					: win32 error			: reading the result data of the injection failed
#define INJ_ERR_SYMBOL_INIT_NOT_DONE		0x0000001C	//SYMBOL_LOADER::Initialize			: -						: initializations process of the symbol loader isn't finished
#define INJ_ERR_SYMBOL_LOAD_FAIL			0x0000001D	//SYMBOL_LOADER::Initialize			: symbol error			: initialization failed (symbol error 0x40000001 - ...)
#define INJ_ERR_SYMBOL_GET_FAIL				0x0000001E	//SYMBOL_PARSER::GetSymbolAddress	: symbol error			: couldn't get address of required symbol (symbol error 0x40000001 - ...)
#define INJ_ERR_CANT_GET_MODULE_PATH		0x0000001F	//internal error					: -						: can't resolve the path of this instance of the injection library
#define INJ_ERR_FAILED_TO_LOAD_DLL			0x00000020	//internal error					: -						: the injection failed for unknown reasons
#define INJ_ERR_HIJACK_NO_HANDLES			0x00000021	//internal error					: -						: can't find a process handle to the target process
#define INJ_ERR_HIJACK_NO_NATIVE_HANDLE		0x00000022	//internal error					: -						: can't find a hijackable handle to the target process
#define INJ_ERR_HIJACK_INJ_FAILED			0x00000023	//internal error					: GH Inj error code		: injecting injection module into handle owner process failed
#define INJ_ERR_HIJACK_OUT_OF_MEMORY_EXT	0x00000024	//VirtualAllocEx					: win32 error			: memory allocation in the hijack process failed
#define INJ_ERR_HIJACK_WPM_FAIL				0x00000025	//WriteProcessMemory				: win32 error			: writing injection data to hijack process failed
#define INJ_ERR_HIJACK_INJECTW_MISSING		0x00000026	//internal error					: -						: can't locate remote injection function in hijack process
#define INJ_ERR_HIJACK_REMOTE_INJ_FAIL		0x00000027	//internal error					: GH Inj error code		: injection executed in the hijack process failed, additional error log was generated
#define INJ_ERR_LLEXW_FAILED				0x00000028	//LoadLibraryExW					: win32 error			: LoadLibraryExW failed loading the dll
#define INJ_ERR_LDRLDLL_FAILED				0x00000029	//LdrLoadDll						: NTSTATUS				: LdrLoadDll failed loading the dll
#define INJ_ERR_LDRPLDLL_FAILED				0x0000002A	//LdrpLoadDll						: NTSTATUS				: LdrpLoadDll failed loading the dll
#define INJ_ERR_LDRPLDLLINTERNAL_FAILED		0x0000002B	//LdrpLoadDllInternal				: NTSTATUS				: LdrpLoadDllInternal failed loading the dll
#define INJ_ERR_CANT_GET_PEB				0x0000002C	//__readgsqword or __readfsdword	: -						: reading the linear address of the PEB failed
#define INJ_ERR_INVALID_PEB_DATA			0x0000002D	//internal error					: -						: peb data required to erase/fake header or unlike the module from the peb wasn't findable
#define INJ_ERR_UPDATE_PROTECTION_FAILED	0x0000002E	//NtProtectVirtualMemory			: NTSTATUS				: updating the page protection of the pe header failed
#define INJ_ERR_WOW64_NTDLL_MISSING			0x0000002F	//internal error					: -						: can't resolve address of the wow64 ntdll.dll
#define INJ_ERR_INVALID_PATH_SEPERATOR		0x00000030	//internal error					: -						: can't find '\' in a path. '/' as seperators aren't supported
#define INJ_ERR_LDRP_PREPROCESS_FAILED		0x00000031	//LdrpPreprocessDllName				: NTSTATUS				: preprocessing the dll name for LdrpLoadDll(Internal) failed
#define INJ_ERR_INVALID_POINTER				0x00000032	//internal error					: -						: an invalid funtion pointer was passed to SetRawPrintCallback
#define INJ_ERR_NOT_IMPLEMENTED				0x00000033	//internal error					: -						: the module was compiled without DEBUG_INFO being defined, check pch.h for more information if you want to redirect debug output
#define INJ_ERR_KERNEL32_MISSING			0x00000034	//internal error					: -						: failed to resolve address of kernel32.dll (native)
#define INJ_ERR_WOW64_KERNEL32_MISSING		0x00000035	//internal error					: -						: can't resolve address of the wow64 kernel32.dll
#define INJ_ERR_OPEN_WOW64_PROCESS			0x00000036	//OpenProcess						: win32 error			: failed to attach to wow64 process to resolve addresses
#define INJ_ERR_IMPORT_HANDLER_NOT_DONE		0x00000037	//internal error					: -						: import handler isn't finished resolving all required functions or is waiting for symbol parser thread(s) to finish
#define INJ_ERR_WCSRCHR_FAILED				0x00000038	//wcsrchr							: -						: wcsrchr failed to find a character in a string (usually '\\' in a path)
#define INJ_ERR_TARGET_EXE_NAME_IS_NULL		0x00000039	//internal error					: -						: the length of the name of the specified process is 0
#define INJ_ERR_LDR_ENTRY_IS_NULL			0x0000003A	//internal error					: -						: LdrpLoadDll(Internal) didn't return a valid LDR_DATA_TABLE_ENTRY pointer
#define INJ_ERR_NOT_SUPPORTED				0x0000003B	//internal error					: -						: the requested operation is not supported on the current operating system or injector version
#define INJ_ERR_CREATE_EVENT_FAILED			0x0000003C	//CreateEventEx						: win32 error			: failed to create an event for wow64 process
#define INJ_ERR_CREATE_PROCESS_FAILED		0x0000003D	//CreateProcessW					: win32 error			: failed to create process for wow64 module addresses
#define INJ_ERR_WAIT_FAILED					0x0000003E	//WaitForSingleObject				: win32 error			: failed to wait for an event to trigger
#define INJ_ERR_WAIT_TIMEOUT				0x0000003F	//WaitForSingleObject				: -						: event timed out
#define INJ_ERR_WINDOWS_VERSION				0x00000040	//internal error					: -						: failed to resolve the version number of the operating system
#define INJ_ERR_WINDOWS_TOO_OLD				0x00000041	//internal error					: -						: the injection library only runs on Windows 7 or higher
#define INJ_ERR_ALREADY_RUNNING				0x00000042	//internal error					: -						: there's already an injection running
#define INJ_ERR_IMPORT_INTERRUPT			0x00000043	//internal error					: -						: the import handler was interrupted with InterruptDownload()
#define INJ_ERR_INVALID_SYMBOL_INDEX		0x00000044	//internal error					: -						: an invalid index was passed to the symbol loader
#define INJ_ERR_INTERRUPT					0x00000045	//internal error					: -						: the injection was interrupted because the interrupt event was set
#define INJ_ERR_SYMBOL_PARSE_FAIL			0x00000046	//SYMBOL_PARSER::Initialize			: symbol error			: initialization failed (symbol error 0x40000001 - ...)
#define	INJ_ERR_SM86_EXE_MISSING			0x00000047	//internal error					: -						: "GH Injector SM - x86.exe" is missing, this file is required for import resolving
#define INJ_ERR_INVALID_EXE_PATH			0x00000048	//internal error					: -						: failed to extract exe name from path
#define INJ_ERR_STRING_TOO_LONG				0x00000049	//internal error					: -						: string exceeds the amount of available characters
#define INJ_ERR_NO_RAW_DATA					0x0000004A	//internal error					: -						: RawData pointer is 0
#define INJ_ERR_INVALID_RAW_DATA			0x0000004B	//internal error					: -						: RawSize is less than 0x1000 bytes
#define INJ_ERR_FAILED_TO_RESOLVE_PATH		0x0000004C	//GetFullPathNameW					: win32 error			: failed to resolve the absolute file path of the specified file


///////////////////
///ManualMap
															//Source							: advanced error type	: error description

#define INJ_MM_ERR_NO_DATA						0x00400001	//internal error					: -						: pData is NULL
#define INJ_MM_ERR_NT_OPEN_FILE					0x00400002	//NtOpenFile						: NTSTATUS				: NtOpenFile failed
#define INJ_MM_ERR_HEAP_ALLOC					0x00400003	//NtAllocateHeap					: -						: memory allocation failed
#define INJ_MM_ERR_NT_READ_FILE					0x00400004	//NtReadFile						: NTSTATUS				: reading the file failed
#define INJ_MM_ERR_SET_FILE_POSITION			0x00400005	//NtSetInformationFile				: NTSTATUS				: failed to reset the file pointer to  the beginning of the file 
#define INJ_MM_ERR_UPDATE_PAGE_PROTECTION		0x00400006	//NtProtectVirtualMemory			: NTSTATUS				: setting the page protection of a section failed
#define INJ_MM_ERR_CANT_GET_FILE_SIZE			0x00400007	//NtQueryInformationFile			: NTSTATUS				: querying the file size failed
#define INJ_MM_ERR_MEMORY_ALLOCATION_FAILED		0x00400008	//NtAllocateVirtualMemory			: NTSTATUS				: couldn't allocate memory
#define INJ_MM_ERR_IMAGE_CANT_BE_RELOCATED		0x00400009	//internal error					: -						: the image has to be relocated but the reloc directory of the image is empty
#define INJ_MM_ERR_IMPORT_FAIL					0x0040000A	//internal error					: NTSTATUS				: one module couldn't be loaded or an import couldn't be resolved, if ntRet is STATUS_HEAP_CORRUPTION, memory allocation failed
#define INJ_MM_ERR_DELAY_IMPORT_FAIL			0x0040000B	//internal error					: NTSTATUS				: one module couldn't be loaded or an import couldn't be resolved, if ntRet is STATUS_HEAP_CORRUPTION, memory allocation failed
#define INJ_MM_ERR_ENABLING_SEH_FAILED			0x0040000C	//RtlInsertInvertedFunctionTable	: NTSTATUS				: enabling exception handling by calling RtlInsertInvertedFunctionTable failed
#define INJ_MM_ERR_NOT_IN_LDRP_SEH_TABLE		0x0040000D	//internal error					: -						: RtlInsertInvertedFunctionTable didn't insert data into LdrpInvertedFunctionTable, manual insertion currently not supported
#define INJ_MM_ERR_INVALID_HEAP_HANDLE			0x0040000E	//internal error					: -						: the provided pointer to the LdrpHeap is invalid
#define INJ_MM_ERR_CANT_GET_PEB					0x0040000F	//__readgsqword or __readfsdword	: -						: reading the linear address of the PEB failed
#define INJ_MM_ERR_INVALID_PEB_DATA				0x00400010	//internal error					: -						: peb data required to fake header wasn't findable



/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//Start Routine errors:
#define SR_ERR_SUCCESS					0x00000000
													
													//Source					: advanced error type	: error description
 
#define SR_ERR_CANT_QUERY_SESSION_ID	0x10000001	//NtQueryInformationProcess	: NTSTATUS				: querying the session id of the target process failed
#define SR_ERR_INVALID_LAUNCH_METHOD	0x10000002	//bruh moment				: bruh moment			: bruh moment
#define SR_ERR_NOT_LOCAL_SYSTEM			0x10000003	//internal error			: -						: SetWindowsHookEx with handle hijacking only works within the same session or from session 0 (LocalSystem account) because of the WtsAPIs
#define SR_ERR_INTERRUPT				0x10000004	//internal error			: -						: execution of the injection was interrupted by InterruptInjection()

///////////////////
///NtCreateThreadEx
														//Source					: advanced error type	: error description

#define SR_NTCTE_ERR_PROC_INFO_FAIL			0x10100001	//internal error			: -						: can't grab process information
#define SR_NTCTE_ERR_GET_ENTRYPOINT			0x10100002	//internal error			: -						: failed to resolve the entrypoint of the target process
#define SR_NTCTE_ERR_CANT_ALLOC_MEM			0x10100003	//VirtualAllocEx			: win32 error			: memory allocation for the shellcode failed
#define SR_NTCTE_ERR_WPM_FAIL				0x10100004	//WriteProcessMemory		: win32 error			: writing the shellcode into the target process' memory failed
#define SR_NTCTE_ERR_NTCTE_FAIL				0x10100005	//NtCreateThreadEx			: NTSTATUS				: thread creation using NtCreateThreadEx failed
#define SR_NTCTE_ERR_GET_CONTEXT_FAIL		0x10100006	//(Wow64)GetThreadContext	: win32 error			: can't get thread context
#define SR_NTCTE_ERR_SET_CONTEXT_FAIL		0x10100007	//(Wow64)SetThreadContext	: win32 error			: can't set thread context
#define SR_NTCTE_ERR_RESUME_FAIL			0x10100008	//ResumeThread				: win32 error			: resuming the thread failed
#define SR_NTCTE_ERR_REMOTE_TIMEOUT			0x10100009	//WaitForSingleObject		: win32 error			: execution time of the shellcode exceeded SR_REMOTE_TIMEOUT
#define SR_NTCTE_ERR_GECT_FAIL				0x1010000A	//GetExitCodeThread			: win32 error			: can't retrieve the exit code of the thread
#define SR_NTCTE_ERR_SHELLCODE_SETUP_FAIL	0x1010000B	//shellcode					: - 					: argument passed to the shellcode is 0
#define SR_NTCTE_ERR_RPM_FAIL				0x1010000C	//ReadProcessMemory			: win32 error			: reading the results of the shellcode failed
#define SR_NTCTE_ERR_CANT_FIND_THREAD		0x1010000D	//internal error			: -						: ProcessInfo class failed to resolve information about the new thread
#define SR_NTCTE_ERR_NTQIT_FAIL				0x1010000E	//NtQueryInformationThread	: NTSTATUS				: failed to get THREAD_BASIC_INFORMATION


///////////////
///HijackThread
														//Source					: advanced error type	: error description

#define SR_HT_ERR_PROC_INFO_FAIL			0x10200001	//internal error			: -						: can't grab process information
#define SR_HT_ERR_NO_THREADS				0x10200002	//internal error			: -						: no threads to hijack
#define SR_HT_ERR_OPEN_THREAD_FAIL			0x10200003	//OpenThread				: win32 error			: can't open handle to the target thread
#define SR_HT_ERR_SUSPEND_FAIL				0x10200004	//SuspendThread				: win32 error			: suspending the target thread failed
#define SR_HT_ERR_GET_CONTEXT_FAIL			0x10200005	//(Wow64)GetThreadContext	: win32 error			: can't get thread context
#define SR_HT_ERR_CANT_ALLOC_MEM			0x10200006	//VirtualAllocEx			: win32 error			: memory allocation for the shellcode failed
#define SR_HT_ERR_WPM_FAIL					0x10200007	//WriteProcessMemory		: win32 error			: writing the shellcode into the target process' memory failed
#define SR_HT_ERR_SET_CONTEXT_FAIL			0x10200008	//(Wow64)SetThreadContext	: win32 error			: can't update the thread context
#define SR_HT_ERR_RESUME_FAIL				0x10200009	//ResumeThread				: win32 error			: resuming the thread failed
#define SR_HT_ERR_REMOTE_TIMEOUT			0x1020000A	//internal error			: -						: execution time exceeded SR_REMOTE_TIMEOUT (can't be deallocated safely)
#define SR_HT_ERR_REMOTE_PENDING_TIMEOUT	0x1020000B	//internal error			: -						: execution time exceeded SR_REMOTE_TIMEOUT while pending (can be deallocated safely)
#define SR_HT_ERR_RPM_FAIL					0x1020000C	//ReadProcessMemory			: win32 error			: reading the results of the shellcode failed

////////////////////
///SetWindowsHookEx
														//Source				: advanced error type	: error description

#define SR_SWHEX_ERR_CANT_OPEN_INFO_TXT		0x10300001	//internal error		: -						: can't open swhex info file
#define SR_SWHEX_ERR_CANT_ALLOC_MEM			0x10300002	//VirtualAllocEx		: win32 error			: memory allocation for the shellcode failed
#define SR_SWHEX_ERR_WPM_FAIL				0x10300003	//WriteProcessMemory	: win32 error			: writing the shellcode into the target process' memory failed
#define SR_SWHEX_ERR_WTSQUERY_FAIL			0x10300004	//WTSQueryUserToken		: win32 error			: failed to query the token for the target process user session
#define SR_SWHEX_ERR_DUP_TOKEN_FAIL			0x10300005	//DuplicateTokenEx		: win32 error			: failed to duplicate the token for the target process user session
#define SR_SWHEX_ERR_GET_ADMIN_TOKEN_FAIL	0x10300006	//GetTokenInformation	: win32 error			: failed to retrieve information from the token handle
#define SR_SWHEX_ERR_CANT_CREATE_PROCESS	0x10300007	//CreateProcessAsUserW	: win32 error			: failed to launch SM_EXE_FILENAME.exe to execute shellcode
														//CreateProcessW		: win32 error			: failed to launch SM_EXE_FILENAME.exe to execute shellcode
#define SR_SWHEX_ERR_SWHEX_TIMEOUT			0x10300008	//WaitForSingleObject	: win32 error			: SM_EXE_FILENAME.exe execution time exceeded
#define SR_SWHEX_ERR_REMOTE_TIMEOUT			0x10300009	//internal error		: -						: execution time exceeded SR_REMOTE_TIMEOUT
#define SR_SWHEX_ERR_RPM_FAIL				0x1030000A	//ReadProcessMemory		: win32 error			: reading the results of the shellcode failed

#define SR_SWHEX_ERR_SWHEX_EXT_ERROR		0x1030000B	//SM_EXE_FILENAME.exe	: "GH Injector SM - XX.exe" error code, 0x30100001 - 0x30100006 (see below) or win32 exception

///////////////
///QueueUserAPC
														//Source					: advanced error type	: error description

#define SR_QUAPC_ERR_CANT_ALLOC_MEM			0x10400002	//VirtualAllocEx			: win32 error			: memory allocation for the shellcode failed
#define SR_QUAPC_ERR_WPM_FAIL				0x10400003	//WriteProcessMemory		: win32 error			: writing the shellcode into the target process' memory failed
#define SR_QUAPC_ERR_PROC_INFO_FAIL			0x10400004	//internal error			: -						: can't grab process information
#define SR_QUAPC_ERR_NO_THREADS				0x10400005	//internal error			: -						: no threads to queue an apc to
#define SR_QUAPC_ERR_REMOTE_TIMEOUT			0x10400006	//internal error			: -						: execution time exceeded SR_REMOTE_TIMEOUT
#define SR_QUAPC_ERR_RPM_FAIL				0x10400007	//WriteProcessMemory		: win32 error			: reading the results of the shellcode failed

///////////////
///KernelCallback
													//Source				: advanced error type	: error description

#define SR_KC_ERR_CANT_OPEN_INFO_TXT	0x10500001	//internal error		: -						: can't open kc info file
#define SR_KC_ERR_PROC_INFO_FAIL		0x10500002	//internal error		: -						: can't grab process information
#define SR_KC_ERR_CANT_GET_PEB			0x10500003	//internal error		: -						: failed to retrieve pointer to the (wow64) peb
#define SR_KC_ERR_RPM_FAIL				0x10500004	//ReadProcessMemory		: win32 error			: failed to read memory from the target process
#define SR_KC_ERR_NO_INITIALIZED		0x10500005	//internal error		: -						: the kernel callback table is not initialized
#define SR_KC_ERR_CANT_ALLOC_MEM		0x10500006	//VirtualAllocEx		: win32 error			: memory allocation for the shellcode/table failed
#define SR_KC_ERR_WPM_FAIL				0x10500007	//WriteProcessMemory	: win32 error			: writing the shellcode/table into the target process' memory failed
#define SR_KC_ERR_WTSQUERY_FAIL			0x10500008	//WTSQueryUserToken		: win32 error			: failed to query the token for the target process user session
#define SR_KC_ERR_DUP_TOKEN_FAIL		0x10500009	//DuplicateTokenEx		: win32 error			: failed to duplicate the token for the target process user session
#define SR_KC_ERR_GET_ADMIN_TOKEN_FAIL	0x1050000A	//GetTokenInformation	: win32 error			: failed to retrieve information from the token handle
#define SR_KC_ERR_CANT_CREATE_PROCESS	0x1050000B	//CreateProcessAsUserW	: win32 error			: failed to launch SM_EXE_FILENAME.exe to execute shellcode
													//CreateProcessW		: win32 error			: failed to launch SM_EXE_FILENAME.exe to execute shellcode
#define SR_KC_ERR_KC_TIMEOUT			0x1050000C	//WaitForSingleObject	: win32 error			: SM_EXE_FILENAME.exe execution time exceeded
#define SR_KC_ERR_REMOTE_TIMEOUT		0x1050000D	//internal error		: -						: execution time exceeded SR_REMOTE_TIMEOUT

#define SR_KC_ERR_KC_EXT_ERROR			0x1050000E	//SM_EXE_FILENAME.exe	: "GH Injector SM - XX.exe" error code, 0x50100001 - 0x50100006 (see below) or win32 exception

///////////////
///FakeVEH
												//Source				: advanced error type	: error description

#define SR_VEH_ERR_CANT_ALLOC_MEM	0x10600001	//VirtualAllocEx			: win32 error			: memory allocation for the shellcode failed
#define SR_VEH_ERR_WPM_FAIL			0x10600002	//WriteProcessMemory		: win32 error			: writing the shellcode into the target process' memory failed
#define SR_VEH_ERR_RPM_FAIL			0x10600003	//ReadProcessMemory			: win32 error			: failed to read memory from the target process
#define SR_VEH_ERR_PROCESS_COOKIE	0x10600004	//internal error			: -						: failed to get the process cookie
#define SR_VEH_ERR_PROC_INFO_FAIL	0x10600005	//internal error			: -						: can't grab process information
#define SR_VEH_ERR_CANT_GET_PEB		0x10600006	//internal error			: -						: failed to retrieve pointer to the (wow64) peb
#define SR_VEH_ERR_PROTECT_FAIL		0x10600007	//VirtualProtectEx			: win32 error			: failed to update page protection
#define SR_VEH_ERR_REMOTE_TIMEOUT	0x10600008	//internal error			: -						: execution time exceeded SR_REMOTE_TIMEOUT



/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//File errors:
#define FILE_ERR_SUCCESS					0x00000000

														//Source				: error description
#define FILE_ERR_CANT_OPEN_FILE				0x20000001	//std::ifstream::good	: opening the file failed
#define FILE_ERR_INVALID_FILE_SIZE			0x20000002	//internal error		: file isn't a valid PE
#define FILE_ERR_INVALID_FILE				0x20000003	//internal error		: PE isn't compatible with the injection settings
#define FILE_ERR_MEMORY_ALLOCATION_FAILED	0x20000004	//operator new			: failed to allocate data buffer



/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//GH Injector SM - XX.exe errors:

												//Source	:	error description

#define SM_ERR_INVALID_ARGC	0x30000001			//main		:	GH Injector SM - XX.exe was called with the wrong amount of arguments
#define SM_ERR_INVALID_ARGV	0x30000002			//main		:	GH Injector SM - XX.exe was called with invalid arguments

////////////////////////////////////////////////////////////
//GH Injector SM - XX.exe specific errors:

///SetWindowHookEx:
#define SWHEX_ERR_SUCCESS 0x00000000
												//Source						: error description

#define SWHEX_ERR_INVALID_PATH		0x30100001	//std::wstring::find_last_of	: path formatting is wrong
#define SWHEX_ERR_CANT_OPEN_FILE	0x30100002	//std::ifstream::good			: opening SMXX.txt failed
#define SWHEX_ERR_EMPTY_FILE		0x30100003	//internal error				: SMXX.txt is empty
#define SWHEX_ERR_INVALID_INFO		0x30100004	//internal error				: provided info is wrong / invalid
#define SWHEX_ERR_ENUM_WINDOWS_FAIL 0x30100005	//EnumWindows					: API fail
#define SWHEX_ERR_NO_WINDOWS		0x30100006	//internal error				: no compatible window found
#define SWHEX_ERR_NO_MODULEBASE		0x30100007	//GetModuleHandleW				: failed to resolve module base of SM process
#define SWHEX_ERR_OUT_OF_MEMORY		0x30100008	//operator new					: failed to allocated memory
#define SWHEX_ERR_NO_PATH			0x30100009	//GetModuleFileNameW			: failed to resolve own module path

///KernelCallbackTable
#define KC_ERR_SUCCESS 0x00000000
												//Source						: error description

#define KC_ERR_INVALID_PATH			0x50100001	//std::wstring::find_last_of	: path formatting is wrong
#define KC_ERR_CANT_OPEN_FILE		0x50100002	//std::ifstream::good			: opening SMXX.txt failed
#define KC_ERR_EMPTY_FILE			0x50100003	//internal error				: SMXX.txt is empty
#define KC_ERR_INVALID_INFO			0x50100004	//internal error				: provided info is wrong / invalid
#define KC_ERR_ENUM_WINDOWS_FAIL	0x50100005	//EnumWindows					: API fail
#define KC_ERR_NO_WINDOWS			0x50100006	//internal error				: no compatible window found
#define KC_ERR_NO_MODULEBASE		0x50100007	//GetModuleHandleW				: failed to resolve module base of SM process
#define KC_ERR_OUT_OF_MEMORY		0x50100008	//operator new					: failed to allocated memory
#define KC_ERR_NO_PATH				0x50100009	//GetModuleFileNameW			: failed to resolve own module path



/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//Symbol errors:
#define SYMBOL_ERR_SUCCESS						0x00000000

															//Source					: error description
#define SYMBOL_ERR_CANT_OPEN_MODULE				0x40000001	//std::ifstream::good		: can't open the specified module
#define SYMBOL_ERR_FILE_SIZE_IS_NULL			0x40000002	//std::ifstream::tellg		: file size of the specified module is 0
#define SYMBOL_ERR_CANT_ALLOC_MEMORY_NEW		0x40000003	//operator new				: can't allocate memory
#define SYMBOL_ERR_INVALID_FILE_ARCHITECTURE	0x40000004	//internal error			: the architecture of the specified file doesn't match AMD64 or I386
#define SYMBOL_ERR_CANT_ALLOC_MEMORY			0x40000005	//VirtualAlloc				: can't allocate memory
#define SYMBOL_ERR_NO_PDB_DEBUG_DATA			0x40000006	//internal error			: debug directory is empty or wrong type
#define SYMBOL_ERR_PATH_DOESNT_EXIST			0x40000007	//CreateDirectoryA			: path doesn't exit and can't be created
#define SYMBOL_ERR_CANT_CREATE_DIRECTORY		0x40000008	//CreateDirectoryA			: path doesn't exit and can't be created (x86/x64 subdirectory)
#define SYMBOL_ERR_CANT_CONVERT_PDB_GUID		0x40000008	//StringFromGUID2			: conversion of the GUID to string failed
#define SYMBOL_ERR_GUID_TO_ANSI_FAILED			0x40000009	//wcstombs_s				: conversion of GUID to ANSI string failed
#define SYMBOL_ERR_DOWNLOAD_FAILED				0x4000000A	//URLDownloadToCacheFileA	: downloading the pdb file failed
#define SYMBOL_ERR_CANT_ACCESS_PDB_FILE			0x4000000B	//GetFileAttributesExA		: can't access the pdb file
#define SYMBOL_ERR_CANT_OPEN_PDB_FILE			0x4000000C	//CreateFileA				: can't open the pdb file
#define SYMBOL_ERR_CANT_OPEN_PROCESS			0x4000000D	//OpenProcess				: can't open handle to current process
#define SYMBOL_ERR_SYM_INIT_FAIL				0x4000000E	//SymInitialize				: couldn't initialize pdb symbol stuff
#define SYMBOL_ERR_SYM_LOAD_TABLE				0x4000000F	//SymLoadModule64			: couldn't load symbol table
#define SYMBOL_ERR_ALREADY_INITIALIZED			0x40000010	//internal error			: this instance of the SYMBOL_PARSER has already been initialized
#define SYMBOL_ERR_NOT_INITIALIZED				0x40000011	//internal error			: this isntance of the SYMBOL_PARSER hasn't benen initialized
#define SYMBOL_ERR_IVNALID_SYMBOL_NAME			0x40000012	//internal error			: szSymbolName is NULL
#define SYMBOL_ERR_SYMBOL_SEARCH_FAILED			0x40000013	//SymFromName				: couldn't find szSymbolName in the specified pdb
#define SYMBOL_CANT_OPEN_PROCESS				0x40000014	//OpenProcess				: can't get PROCESS_QUERY_LIMITED_INFORMATION handle to current process
#define SYMBOL_ERR_COPYFILE_FAILED				0x40000015	//CopyFileA					: copying the file from the cache directory failed
#define SYMBOL_ERR_INTERRUPT					0x40000016	//internal error			: download has been interrupted
#define SYMBOL_ERR_CANNOT_CONNECT				0x40000017	//InternetCheckConnectionW	: GetLastError returned ERROR_INTERNET_CANNOT_CONNECT which might be caused by a firewall rule
#define SYMBOL_ERR_OBJECT_IS_NULL				0x40000018	//internal error			: the provided SYMBOL_LOADER object pointer is a nullptr
#define SYMBOL_ERR_OBJECT_NOT_READY				0x40000019	//internal error			: the provided SYMBOL_LOADER object is not in the ready state


/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//Symbol errors:
#define HOOK_SCAN_ERR_SUCCESS						0x00000000

																//Source				: error description
#define HOOK_SCAN_ERR_INVALID_PROCESS_ID			0x50000001	//internal error		: target process identifier is 0
#define HOOK_SCAN_ERR_CANT_OPEN_PROCESS				0x50000002	//OpenProcess			: target process identifier is 0
#define HOOK_SCAN_ERR_PLATFORM_MISMATCH				0x50000003	//internal error		: wow64 injector can't scan x64 process
#define HOOK_SCAN_ERR_GETPROCADDRESS_FAILED			0x50000004	//GetProcAddress		: GetProcAddress failed internally
#define HOOK_SCAN_ERR_READ_PROCESS_MEMORY_FAILED	0x50000005	//ReadProcessMemory		: ReadProcessMemory failed while reading the bytes of the target function
#define HOOK_SCAN_ERR_CANT_GET_OWN_MODULE_PATH		0x50000006	//GetOwnModulePath		: unable to obtain path to the GH Injector directory
#define HOOK_SCAN_ERR_CREATE_EVENT_FAILED			0x50000007	//CreateEventEx			: win32 error
#define HOOK_SCAN_ERR_CREATE_PROCESS_FAILED			0x50000008	//CreateProcessW		: win32 error
#define HOOK_SCAN_ERR_WAIT_FAILED					0x50000009	//WaitForSingleObject	: win32 error
#define HOOK_SCAN_ERR_WAIT_TIMEOUT					0x5000000A	//WaitForSingleObject	: waiting timed out
#define HOOK_SCAN_ERR_BUFFER_TOO_SMALL				0x5000000B	//internal error		: the buffer passed to ValidateInjectionFunctions is too small



/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//.NET
#define DNP_ERR_SUCCESS					0x00000000

													//Source				: advanced error type	: error description
#define DNP_ERR_CANT_OPEN_FILE			0x60000001	//std::ifstream::good	: -						: opening DNPD.txt failed
#define DNP_ERR_EMPTY_FILE				0x60000002	//internal error		: -						: file is empty
#define DNP_ERR_OUT_OF_MEMORY			0x60000003	//operator new			: -						: memory allocation failed
#define DNP_ERR_INVALID_DATA			0x60000004	//internal error		: -						: the data provided is invalid and/or incomplete
#define DNP_ERR_HRESULT					0x60000005	//internal error		: HRESULT				: one of the managed functions failed
#define DNP_ERR_CANT_FIND_MODULE		0x60000006	//interanl error		: win32 error code		: failed to resolve the module base of the loaded module
#define DNP_ERR_REMOTE_LOADER_MISSING	0x60000007	//internal error		: -						: "GH Injector DNP - x64/86.dll" is missing
#define DNP_ERR_CANT_OPEN_INFO_TXT		0x60000008	//internal error		: -						: failed to open dnp info file
#define DNP_ERR_FAILED_TO_LOAD_LOADER	0x60000009	//internal error		: any Error.h code		: failed to load the .NET loader into the target process
#define DNP_ERR_LOADER_TIMEOUT			0x6000000A	//internal error		: -						: .NET loader timed out in the target process
#define DNP_ERR_LOADER_FAILED			0x6000000B	//internal error		: DNP Error or HRESULT	: .NET loader failed and returned an error code
#define DNP_ERR_INTERRUPT				0x6000000C	//internal error		: -						: execution of the injection was interrupted by InterruptInjection()
#define DNP_ERR_UNKNOWN					0x6000000D	//internal error		: - 


/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


struct ERROR_DATA
{
	DWORD		AdvErrorCode;
	wchar_t		szFileName[MAX_PATH];
	wchar_t		szFunctionName[MAX_PATH];
	int			Line;
};

#define INIT_ERROR_DATA(data, error) \
data.AdvErrorCode = error;															\
data.Line = __LINE__;																\
memset(data.szFileName, 0, sizeof(data.szFileName));								\
memset(data.szFunctionName, 0, sizeof(data.szFunctionName));						\
memcpy(data.szFileName, __FILENAMEW__,  ((size_t)lstrlenW(__FILENAMEW__)) * 2);		\
memcpy(data.szFunctionName, __FUNCTIONW__, ((size_t)lstrlenW(__FUNCTIONW__)) * 2);
```

`GH Injector Library/FakeVEH WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Start Routine.h"

DWORD SR_FakeVEH_WOW64(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_FakeVEH\n");

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return SR_VEH_ERR_CANT_ALLOC_MEM;
	}

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER_VEH_86

		0x55,								// + 0x00			-> push ebp								; x86 stack frame creation
		0x8B, 0xEC,							// + 0x01			-> mov  ebp, esp

		0x8B, 0x4D, 0x08,					// + 0x03			-> mov  ecx, [ebp + 0x08]				; move ExceptionInfo pointer into ecx
		0x85, 0xC9,							// + 0x06			-> test ecx, ecx						; check if ExceptionInfo pointer is non-zero
		0x0F, 0x84, 0x7D, 0x00, 0x00, 0x00,	// + 0x08			-> je   0x8B							; jump if nullptr

		0x8B, 0x09,							// + 0x0D			-> mov  ecx, [ecx]						; move EXCEPTION_POINTERS::ExceptionRecord into ecx
		0x85, 0xC9,							// + 0x10			-> test ecx, ecx						; check if ExceptionRecord is non-zero
		0x74, 0x77,							// + 0x12			-> je   0x8B							; jump if nullptr

		0x81, 0x39, 0x01, 0x00, 0x00, 0x80,	// + 0x14			-> cmp  [ecx], 0x80000001				; check if ExceptionRecord::ExceptionCode matches EXCEPTION_GUARD_PAGE
		0x75, 0x6F,							// + 0x1A			-> jne  0x8B							; jump if not equal

		0x53,								// + 0x1C			-> push ebx								; push ebx on stack (non volatile)
		0xBB, 0x00, 0x00, 0x00,	0x00,		// + 0x1D (+ 0x1E)	-> mov  ebx, 0x00000000					; load pData into ebx

		0x80, 0x3B, 0x00,					// + 0x22			-> cmp  byte ptr [ebx], 0				; test if SR_REMOTE_DATA_VEH::Data::State is equal to SR_RS_ExecutionPending
		0x75, 0x63,							// + 0x25			-> jne  0x8A							; jump if not equal

		0xC6, 0x03, 0x01,					// + 0x27			-> mov  byte ptr [ebx], 1				; set SR_REMOTE_DATA_VEH::Data::State to SR_RS_Executing

		0x80, 0x7B, 0x24, 0x01,				// + 0x2A			-> cmp  byte ptr [ebx + 0x24], 1		: test if SR_REMOTE_DATA::bRemoveVEHBit is set
		0x75, 0x10,							// + 0x2E			-> jne  0x40							: jump if not equal
		0x64, 0xA1, 0x30, 0x00, 0x00, 0x00,	// + 0x30			-> mov  eax, fs:[0x30]					: mov PEB pointer into ecx
		0x83, 0x70, 0x28, 0x04,				// + 0x36			-> xor  dword ptr [ecx + 0x28], 0x04	: remove PEB->ProcessUsingVEH bit

		0x83, 0x7B, 0x18, 0x00,				// + 0x3A			-> cmp  dword ptr [ebx + 0x18], 0		; check if SR_REMOTE_DATA_VEH::pLdrProtectMrdata is non-zero
		0x74, 0x05,							// + 0x3E			-> je   0x45							; jump if nullptr
		0x6A, 0x00,							// + 0x40			-> push 0								; push FALSE on the stack
		0xFF, 0x53, 0x18,					// + 0x42			-> call dword ptr [ebx + 0x18]			; call LdrProtectMrdata to make LdrpVectorHandlerList writeable

		0x8B, 0x53, 0x1C,					// + 0x45			-> mov  edx, [ebx + 0x1C]				; move &LdrpVectorHandlerList.List (head) into edx
		0x8B, 0x0A,							// + 0x48			-> mov  ecx, [edx]						; move head->Flink into ecx (current)

		0x39, 0xD1,							// + 0x4A			-> cmp  ecx, edx						; compare current, head
		0x74, 0x13,							// + 0x4C			-> je   0x61							; exit loop if equal (end of list)
		0x3B, 0x4B, 0x20,					// + 0x4E			-> cmp  ecx, [ebx + 0x20]				; compare current, SR_REMOTE_DATA_VEH::pFakeEntry
		0x74, 0x04,							// + 0x51			-> je   0x57							; break loop if equal (found entry)
		0x8B, 0x09,							// + 0x53			-> mov  ecx, [ecx]						; set current to current->Flink
		0xEB, 0xF3,							// + 0x55			-> jmp  0x4A							; jmp to the start of the loop

		0x8B, 0x01,							// + 0x57			-> mov  eax, [ecx]						; store current->Flink in eax
		0x8B, 0x51, 0x04,					// + 0x59			-> mov  edx, [ecx + 0x04]				; store current->Blink in edx
		0x89, 0x02,							// + 0x5C			-> mov  [edx], eax						; current->Blink->Flink = current->Fink
		0x89, 0x50, 0x04,					// + 0x5E			-> mov  [eax + 0x04], edx				; current->Flink->Blink = current->Blink

		0x83, 0x7B, 0x18, 0x00,				// + 0x61			-> cmp  dword ptr [ebx + 0x18], 0		; check if SR_REMOTE_DATA_VEH::pLdrProtectMrdata is non-zero
		0x74, 0x05,							// + 0x65			-> je   0x6C							; jump if nullptr
		0x6A, 0x01,							// + 0x67			-> push 1								; push TRUE on the stack
		0xFF, 0x53, 0x18,					// + 0x69			-> call dword ptr [ebx + 0x18]			; call LdrProtectMrdata to protect LdrpVectorHandlerList

		0xFF, 0x73, 0x0C,					// + 0x6C			-> push [ebx + 0x0C]					; push pArg
		0xFF, 0x53, 0x10,					// + 0x6F			-> call dword ptr [ebx + 0x10]			; call pRoutine
		0x89, 0x43, 0x04,					// + 0x72			-> mov  [ebx + 0x04], eax				; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,	// + 0x75			-> mov  eax, fs:[0x18]					; GetLastError
		0x8B, 0x40, 0x34,					// + 0x7B			-> mov  eax, [eax + 0x34]
		0x89, 0x43, 0x08,					// + 0x7E			-> mov  [ebx + 0x08], eax				; store in SR_REMOTE_DATA_VEH::Data::LastWin32Error

		0xC6, 0x03, 0x02,					// + 0x81			-> mov  byte ptr [ebx], 2				; set SR_REMOTE_DATA_VEH::Data::State to SR_RS_ExecutionFinished

		0x83, 0xC8, 0xFF,					// + 0x84			-> or   eax, -1							; set eax to EXCEPTION_CONTINUE_EXECUTION
		0x5B,								// + 0x87			-> pop  ebx								; restore ebx
		0xEB, 0x03,							// + 0x88			-> jmp  0x8D							; jump to epilogue

		0x5B,								// + 0x8A			-> pop  ebx								; restore ebx
		0x31, 0xC0, 						// + 0x8B			-> xor  eax, eax						; set eax to EXCEPTION_CONTINUE_SEARCH

		0x5D,								// + 0x8D			-> pop  ebp								; x86 __stdcall epilogue
		0xC2, 0x04, 0x00					// + 0x8E			-> ret  0x04
	}; // SIZE = 0x91 (+ sizeof(SR_REMOTE_DATA_VEH_WOW64))

	*ReCa<DWORD *>(Shellcode + 0x1E + sizeof(SR_REMOTE_DATA_VEH_WOW64)) = MDWD(pMem);

	DWORD pRemoteFunc = MDWD(pMem) + sizeof(SR_REMOTE_DATA_VEH_WOW64);

	auto * sr_data = ReCa<SR_REMOTE_DATA_VEH_WOW64 *>(Shellcode);
	sr_data->Data.pArg		= pArg;
	sr_data->Data.pRoutine	= pRoutine;

	LOG(2, "VEH will be called with:\n");
	LOG(3, "pRoutine = %p\n", pRemoteFunc);
	LOG(3, "pArg     = %p\n", pMem);

	auto * pVEHHead = &ReCa<RTL_VECTORED_HANDLER_LIST_32 *>(MPTR(WOW64::LdrpVectorHandlerList_WOW64))->List;
	LIST_ENTRY32 VEHHead{ 0 };

	if (!ReadProcessMemory(hTargetProc, pVEHHead, &VEHHead, sizeof(VEHHead), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		return SR_VEH_ERR_RPM_FAIL;
	}

	ProcessInfo PI;
	if (!PI.SetProcess(hTargetProc))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Can't initialize ProcessInfo class\n");

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_PROC_INFO_FAIL;
	}

	DWORD ProcessCookie = PI.GetProcessCookie();
	if (!ProcessCookie)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to resolve process cookie\n");

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_PROCESS_COOKIE;
	}

	LOG(2, "ProcessCookie = %08X\n", ProcessCookie);

	auto EntrySize = 0;
	if (GetOSBuildVersion() >= g_Win10_2004)
	{
		EntrySize = sizeof(RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32);
	}
	else
	{
		EntrySize = sizeof(RTL_VECTORED_EXCEPTION_ENTRY_32);
	}

	BYTE * pNewEntry = ReCa<BYTE *>(VirtualAllocEx(hTargetProc, nullptr, EntrySize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
	if (pNewEntry == nullptr)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return SR_VEH_ERR_CANT_ALLOC_MEM;
	}

	LOG(2, "Allocated memory for VEH entry at\n");
	LOG(3, "pNewEntry = %p\n", pNewEntry);

	auto pVEHShell_Encoded = MDWD(pRemoteFunc);
	pVEHShell_Encoded ^= ProcessCookie;
	pVEHShell_Encoded = _rotr(pVEHShell_Encoded, ProcessCookie & 0x1F);

	BYTE buffer[sizeof(RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32)]{ 0 };
	if (GetOSBuildVersion() >= g_Win10_2004)
	{
		auto NewEntry = ReCa<RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32 *>(buffer);
	
		NewEntry->List.Flink	= VEHHead.Flink;
		NewEntry->List.Blink	= MDWD(pVEHHead);

		NewEntry->Flag			= 1;
		NewEntry->pFlag			= MDWD(&ReCa<RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32 *>(pNewEntry)->Flag);

		NewEntry->VectoredHandler = pVEHShell_Encoded;
	}
	else
	{
		auto NewEntry = ReCa<RTL_VECTORED_EXCEPTION_ENTRY_32 *>(buffer);

		NewEntry->List.Flink = VEHHead.Flink;
		NewEntry->List.Blink = MDWD(pVEHHead);

		NewEntry->Flag = 1;

		NewEntry->VectoredHandler = pVEHShell_Encoded;
	}

	sr_data->pLdrProtectMrdata	= WOW64::LdrProtectMrdata_WOW64;
	sr_data->pListHead			= MDWD(pVEHHead);
	sr_data->pFakeEntry			= MDWD(pNewEntry);
	sr_data->bRemoveVEHBit		= MDWD(FALSE);

	if (!WriteProcessMemory(hTargetProc, pNewEntry, &buffer, EntrySize, nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}

	LOG(2, "Copied fake VEH entry into target process\n");

	auto pPEB = PI.GetPEB_WOW64();

	if (!pPEB)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to get PEB pointer\n");

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_CANT_GET_PEB;
	}

	PEB_32 peb{ 0 };
	if (!ReadProcessMemory(hTargetProc, pPEB, &peb, sizeof(peb), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_RPM_FAIL;
	}

	DWORD dwOld1 = 0;
	DWORD dwOld2 = 0;
	if (!VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), PAGE_READWRITE, &dwOld1))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualProtectEx failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}

	if (!WriteProcessMemory(hTargetProc, &pVEHHead->Flink, &pNewEntry, sizeof(DWORD), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), dwOld1, &dwOld2);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}
	
	DWORD dwOld3 = 0;
	DWORD dwOld4 = 0;
	LIST_ENTRY32 * pFlink = ReCa<LIST_ENTRY32 *>(MPTR(VEHHead.Flink));
	if (!VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY32), PAGE_READWRITE, &dwOld3))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), PAGE_READWRITE, &dwOld2);
		WriteProcessMemory(hTargetProc, pVEHHead, &VEHHead.Flink, sizeof(DWORD), nullptr);
		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), dwOld1, &dwOld2);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_PROTECT_FAIL;
	}

	if (!WriteProcessMemory(hTargetProc, &pFlink->Blink, &pNewEntry, sizeof(DWORD), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY32), dwOld3, &dwOld4);

		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), PAGE_READWRITE, &dwOld2);
		WriteProcessMemory(hTargetProc, pVEHHead, &VEHHead.Flink, sizeof(DWORD), nullptr);
		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), dwOld1, &dwOld2);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}

	LOG(2, "VEH handler linked to LdrpVectorHandlerList\n");

	if (peb.ProcessUsingVEH == FALSE)
	{
		sr_data->bRemoveVEHBit = TRUE;
	}

	if (!WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}

	LOG(2, "Copied shellcode into target process\n");

	bool updated_peb = false;
	if (peb.ProcessUsingVEH == FALSE)
	{
		LOG(2, "Updating PEB::ProcessUsingVEH flag\n");

		peb.ProcessUsingVEH = TRUE;

		if (!WriteProcessMemory(hTargetProc, &pPEB->CrossProcessFlags, &peb.CrossProcessFlags, sizeof(peb.CrossProcessFlags), nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_VEH_ERR_WPM_FAIL;
		}

		updated_peb = true;
	}

	if (!VirtualProtectEx(hTargetProc, MPTR(WOW64::NtDelayExecution_WOW64), 1, PAGE_EXECUTE_READ | PAGE_GUARD, &dwOld2))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualProtectEx failed: %08X\n", error_data.AdvErrorCode);

		VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY32), PAGE_READWRITE, &dwOld4);
		WriteProcessMemory(hTargetProc, &pFlink->Blink, &pVEHHead, sizeof(DWORD), nullptr);
		VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY32), dwOld3, &dwOld4);

		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), PAGE_READWRITE, &dwOld2);
		WriteProcessMemory(hTargetProc, pVEHHead, &VEHHead.Flink, sizeof(DWORD), nullptr);
		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), dwOld1, &dwOld2);

		if (updated_peb)
		{
			peb.ProcessUsingVEH = FALSE;
			WriteProcessMemory(hTargetProc, &pPEB->CrossProcessFlags, &peb.CrossProcessFlags, sizeof(peb.CrossProcessFlags), nullptr);
		}

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_PROTECT_FAIL;
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	SR_REMOTE_DATA data{ };
	data.State			= SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	auto Timer = GetTickCount64();
	while (GetTickCount64() - Timer < Timeout)
	{
		auto dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		auto bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet)
		{
			if (data.State == SR_REMOTE_STATE::SR_RS_ExecutionFinished)
			{
				LOG(2, "Shelldata retrieved\n");

				break;
			}
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}
			
			VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY32), PAGE_READWRITE, &dwOld4);
			WriteProcessMemory(hTargetProc, &pFlink->Blink, &pVEHHead, sizeof(DWORD), nullptr);
			VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY32), dwOld3, &dwOld4);
			
			VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), PAGE_READWRITE, &dwOld2);
			WriteProcessMemory(hTargetProc, pVEHHead, &VEHHead.Flink, sizeof(DWORD), nullptr);
			VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY32), dwOld1, &dwOld2);

			if (updated_peb)
			{
				peb.ProcessUsingVEH = FALSE;
				WriteProcessMemory(hTargetProc, &pPEB->CrossProcessFlags, &peb.CrossProcessFlags, sizeof(peb.CrossProcessFlags), nullptr);
			}

			VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}

			return SR_VEH_ERR_RPM_FAIL;
		}

		Sleep(10);
	}

	VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);

	if (data.State != SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shell timed out\n");

		return SR_VEH_ERR_REMOTE_TIMEOUT;
	}

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out = data.Ret;

	return SR_ERR_SUCCESS;
}

#endif
```

`GH Injector Library/FakeVEH.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Start Routine.h"

DWORD SR_FakeVEH(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_FakeVEH\n");

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return SR_VEH_ERR_CANT_ALLOC_MEM;
	}

	/*
		LONG __stdcall VectoredExceptionHandler_Shell(EXCEPTION_POINTERS * ExceptionInfo)
		{
			if (ExceptionInfo != nullptr)
			{
				if (ExceptionInfo->ExceptionRecord != nullptr)
				{
					if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_GUARD_PAGE)
					{
						SR_REMOTE_DATA_VEH * data = ReCa<SR_REMOTE_DATA_VEH *>(ReCa<BYTE *>(VectoredExceptionHandler) - sizeof(SR_REMOTE_DATA_VEH));
						if (data->Data.State == SR_REMOTE_STATE::SR_RS_ExecutionPending)
						{
							if (data->remove_VEH_flag)
							{
								#ifdef _WIN64
									PEB * peb = reinterpret_cast<PEB *>(__readgsqword(0x60));
								#else
									PEB * peb = reinterpret_cast<PEB *>(__readfsdword(0x30));
								#endif

								peb->ProcessUsingVEH = FALSE;
							}

							if (data->pLdrProtectMrdata) //only Win8.1+
							{
								data->pLdrProtectMrdata(FALSE); //return value is irrelevant
							}

							LIST_ENTRY * current = data->pListHead.Flink; //find fake entry in LdrpVectoredHandlerList
							while (current != data->pListHead)
							{
								if (current == data->pFakeEntry) //found entry
								{
									current->Blink->Flink = current->Flink; //unlink it
									current->Flink->Blink = current->Blink;

									break;
								}

								current = current->Flink;
							} //can't do anything if not found in this list

							if (data->pLdrProtectMrdata)
							{
								data->pLdrProtectMrdata(TRUE); //restore protection state
							}

							data->Data.State = SR_REMOTE_STATE::SR_RS_Executing;

							data->Data.Ret = data->pRoutine(data->pArg);
							data->Data.LastWin32Error = GetLastError(); //inlined

							data->Data.State = SR_REMOTE_STATE::SR_RS_ExecutionFinished;

							return EXCEPTION_CONTINUE_EXECUTION;
						}
					}
				}
			}

			return EXCEPTION_CONTINUE_SEARCH;
		}
	*/

	#ifdef _WIN64

	BYTE Shellcode[] =
	{
		SR_REMOVE_DATA_BUFFER_VEH

		0x48, 0x85, 0xC9,										// + 0x00	-> test rcx, rcx						; check if rcx (ExceptionInfo pointer) is non-zero
		0x0F, 0x84, 0xB4, 0x00, 0x00, 0x00,						// + 0x03	-> je	0xBD							; jump if nullptr

		0x48, 0x8B, 0x09,										// + 0x09	-> mov	rcx, [rcx]						; move EXCEPTION_POINTERS::ExceptionRecord into rcx
		0x48, 0x85, 0xC9,										// + 0x0C	-> test rcx, rcx						; check if ExceptionRecord is non-zero
		0x0F, 0x84, 0xA8, 0x00, 0x00, 0x00,						// + 0x0F	-> je	0xBD							; jump if nullptr

		0x81, 0x39, 0x01, 0x00, 0x00, 0x80,						// + 0x15	-> cmp	dword ptr [rcx], 0x80000001		; check if ExceptionRecord::ExceptionCode matches EXCEPTION_GUARD_PAGE
		0x0F, 0x85, 0x9C, 0x00, 0x00, 0x00,						// + 0x1B	-> jne	0xBD							; jump if not equal

		0x53,													// + 0x21	-> push rbx								; push rbx on stack (non volatile)
		0x48, 0x8D, 0x1D, 0x87, 0xFF, 0xFF, 0xFF,				// + 0x22	-> lea	rbx, [-0x50]					; load pData into rbx

		0x80, 0x3B, 0x00,										// + 0x29	-> cmp	byte ptr [rbx], 0				; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x0F, 0x85, 0x8A, 0x00, 0x00, 0x00,						// + 0x2C	-> jne	0xBC							; jump if not equal

		0xC6, 0x03, 0x01,										// + 0x32	-> mov	byte ptr [rbx], 1				; set SR_REMOTE_DATA::State to SR_RS_Executing
		
		0x80, 0x7B, 0x48, 0x01,									// + 0x35	-> cmp  byte ptr [rbx + 0x48], 1		; test if SR_REMOTE_DATA::bRemoveVEHBit is set
		0x75, 0x0D,												// + 0x39	-> jne  0x48							; jump if not equal
		0x65, 0x48, 0x8B, 0x0C, 0x25, 0x60, 0x00, 0x00, 0x00,	// + 0x3B	-> mov  rcx, gs: [0x60]					; mov PEB pointer into rcx
		0x83, 0x71, 0x50, 0x04,									// + 0x44	-> xor  dword ptr [rcx + 0x50], 0x04	; remove PEB->ProcessUsingVEH bit

		0x48, 0x83, 0x7B, 0x30, 0x00,							// + 0x48	-> cmp  qword ptr [rbx + 0x30], 0		; check if SR_REMOTE_DATA_VEH::pLdrProtectMrdata is non-zero
		0x74, 0x0A,												// + 0x4D	-> je   0x59							; jump if nullptr
		0x48, 0x31, 0xC9,										// + 0x4F	-> xor  rcx, rcx						; move FALSE into rcx
		0x48, 0x83, 0xEC, 0x20,									// + 0x52	-> sub  rsp, 0x20						; reserve 0x20 bytes on the stack
		0xFF, 0x53, 0x30,										// + 0x56	-> call qword ptr [rbx + 0x30]			; call LdrProtectMrdata to make LdrpVectorHandlerList writeable

		0x48, 0x8B, 0x53, 0x38,									// + 0x59	-> mov  rdx, [rbx + 0x38]				; move &LdrpVectorHandlerList.List (head) into rdx
		0x48, 0x8B, 0x0A,										// + 0x5D	-> mov  rcx, [rdx]						; move head->Flink into rcx (current)

		0x48, 0x39, 0xD1,										// + 0x60	-> cmp  rcx, rdx						; compare current, head
		0x74, 0x19,												// + 0x63	-> je   0x7E							; exit loop if equal (end of list)
		0x48, 0x3B, 0x4B, 0x40,									// + 0x65	-> cmp  rcx, [rbx + 0x40]				; compare current, SR_REMOTE_DATA_VEH::pFakeEntry
		0x74, 0x05,												// + 0x69	-> je   0x70							; break loop if equal (found entry)
		0x48, 0x8B, 0x09,										// + 0x6B	-> mov  rcx, [rcx]						; set current to current->Flink
		0xEB, 0xF0,												// + 0x6E	-> jmp  0x60							; jmp to the start of the loop

		0x48, 0x8B, 0x01,										// + 0x70	-> mov  rax, [rcx]						; store current->Flink in rax
		0x48, 0x8B, 0x51, 0x08,									// + 0x73	-> mov  rdx, [rcx + 0x08]				; store current->Blink in rdx
		0x48, 0x89, 0x02,										// + 0x77	-> mov  [rdx], rax						; current->Blink->Flink = current->Fink
		0x48, 0x89, 0x50, 0x08,									// + 0x7A	-> mov  [rax + 0x08], rdx				; current->Flink->Blink = current->Blink

		0x48, 0x83, 0x7B, 0x30, 0x00,							// + 0x7E	-> cmp  qword ptr [rbx + 0x30], 0		; check if SR_REMOTE_DATA_VEH::pLdrProtectMrdata is non-zero
		0x74, 0x0C,												// + 0x83	-> je   0x91							; jump if nullptr
		0x48, 0x31, 0xC9,										// + 0x85	-> xor  rcx, rcx						; zero rcx
		0xB1, 0x01,												// + 0x88	-> mov  cl, 1							; move TRUE into rcx
		0xFF, 0x53, 0x30,										// + 0x8A	-> call qword ptr [rbx + 0x30]			; call LdrProtectMrdata to protect LdrpVectorHandlerList
		0x48, 0x83, 0xC4, 0x20,									// + 0x8D	-> add  rsp, 0x20						; restore stack (reserved at + 0x3B)

		0x48, 0x8B, 0x4B, 0x18,									// + 0x91	-> mov	rcx, [rbx + 0x18]				; move pArg into rcx
		0x48, 0x83, 0xEC, 0x20,									// + 0x95	-> sub	rsp, 0x20						; reserve stack
		0xFF, 0x53, 0x20,										// + 0x99	-> call qword ptr [rbx + 0x20]			; call pRoutine
		0x48, 0x83, 0xC4, 0x20,									// + 0x9C	-> add	rsp, 0x20						; update stack
		0x48, 0x89, 0x43, 0x08,									// + 0xA0	-> mov	[rbx + 0x08], rax				; store returned value

		0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00,	// + 0xA4	-> mov	rax, gs: [0x30]					; GetLastError
		0x8B, 0x40, 0x68,										// + 0xAD	-> mov	eax, [rax + 0x68]
		0x89, 0x43, 0x10,										// + 0xB0	-> mov	[rbx + 0x10], eax				; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,										// + 0xB3	-> mov	byte ptr [rbx], 2				; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x83, 0xC8, 0xFF,										// + 0xB6	-> or	eax, -1							; set eax to EXCEPTION_CONTINUE_EXECUTION
		0x5B,													// + 0xB9	-> pop	rbx								; restore rbx
		0xEB, 0x04,												// + 0xBA	-> jmp	0xC0							; jump to ret

		0x5B,													// + 0xBC	-> pop	rbx								; restore rbx			
		0x48, 0x31, 0xC0,										// + 0xBD	-> xor	rax, rax						; set rax to EXCEPTION_CONTINUE_SEARCH

		0xC3													// + 0xC0	-> ret									; return

	}; // SIZE = 0xC1 (+ sizeof(SR_REMOTE_DATA_VEH))
	
#else

	BYTE Shellcode[] =
	{
		SR_REMOVE_DATA_BUFFER_VEH

		0x55,								// + 0x00			-> push ebp								; x86 stack frame creation
		0x8B, 0xEC,							// + 0x01			-> mov  ebp, esp

		0x8B, 0x4D, 0x08,					// + 0x03			-> mov  ecx, [ebp + 0x08]				; move ExceptionInfo pointer into ecx
		0x85, 0xC9,							// + 0x06			-> test ecx, ecx						; check if ExceptionInfo pointer is non-zero
		0x0F, 0x84, 0x7D, 0x00, 0x00, 0x00,	// + 0x08			-> je   0x8B							; jump if nullptr

		0x8B, 0x09,							// + 0x0D			-> mov  ecx, [ecx]						; move EXCEPTION_POINTERS::ExceptionRecord into ecx
		0x85, 0xC9,							// + 0x10			-> test ecx, ecx						; check if ExceptionRecord is non-zero
		0x74, 0x77,							// + 0x12			-> je   0x8B							; jump if nullptr

		0x81, 0x39, 0x01, 0x00, 0x00, 0x80,	// + 0x14			-> cmp  [ecx], 0x80000001				; check if ExceptionRecord::ExceptionCode matches EXCEPTION_GUARD_PAGE
		0x75, 0x6F,							// + 0x1A			-> jne  0x8B							; jump if not equal

		0x53,								// + 0x1C			-> push ebx								; push ebx on stack (non volatile)
		0xBB, 0x00, 0x00, 0x00,	0x00,		// + 0x1D (+ 0x1E)	-> mov  ebx, 0x00000000					; load pData into ebx

		0x80, 0x3B, 0x00,					// + 0x22			-> cmp  byte ptr [ebx], 0				; test if SR_REMOTE_DATA_VEH::Data::State is equal to SR_RS_ExecutionPending
		0x75, 0x63,							// + 0x25			-> jne  0x8A							; jump if not equal

		0xC6, 0x03, 0x01,					// + 0x27			-> mov  byte ptr [ebx], 1				; set SR_REMOTE_DATA_VEH::Data::State to SR_RS_Executing

		0x80, 0x7B, 0x24, 0x01,				// + 0x2A			-> cmp  byte ptr [ebx + 0x24], 1		: test if SR_REMOTE_DATA::bRemoveVEHBit is set
		0x75, 0x10,							// + 0x2E			-> jne  0x40							: jump if not equal
		0x64, 0xA1, 0x30, 0x00, 0x00, 0x00,	// + 0x30			-> mov  eax, fs:[0x30]					: mov PEB pointer into ecx
		0x83, 0x70, 0x28, 0x04,				// + 0x36			-> xor  dword ptr [ecx + 0x28], 0x04	: remove PEB->ProcessUsingVEH bit

		0x83, 0x7B, 0x18, 0x00,				// + 0x3A			-> cmp  dword ptr [ebx + 0x18], 0		; check if SR_REMOTE_DATA_VEH::pLdrProtectMrdata is non-zero
		0x74, 0x05,							// + 0x3E			-> je   0x45							; jump if nullptr
		0x6A, 0x00,							// + 0x40			-> push 0								; push FALSE on the stack
		0xFF, 0x53, 0x18,					// + 0x42			-> call dword ptr [ebx + 0x18]			; call LdrProtectMrdata to make LdrpVectorHandlerList writeable

		0x8B, 0x53, 0x1C,					// + 0x45			-> mov  edx, [ebx + 0x1C]				; move &LdrpVectorHandlerList.List (head) into edx
		0x8B, 0x0A,							// + 0x48			-> mov  ecx, [edx]						; move head->Flink into ecx (current)

		0x39, 0xD1,							// + 0x4A			-> cmp  ecx, edx						; compare current, head
		0x74, 0x13,							// + 0x4C			-> je   0x61							; exit loop if equal (end of list)
		0x3B, 0x4B, 0x20,					// + 0x4E			-> cmp  ecx, [ebx + 0x20]				; compare current, SR_REMOTE_DATA_VEH::pFakeEntry
		0x74, 0x04,							// + 0x51			-> je   0x57							; break loop if equal (found entry)
		0x8B, 0x09,							// + 0x53			-> mov  ecx, [ecx]						; set current to current->Flink
		0xEB, 0xF3,							// + 0x55			-> jmp  0x4A							; jmp to the start of the loop

		0x8B, 0x01,							// + 0x57			-> mov  eax, [ecx]						; store current->Flink in eax
		0x8B, 0x51, 0x04,					// + 0x59			-> mov  edx, [ecx + 0x04]				; store current->Blink in edx
		0x89, 0x02,							// + 0x5C			-> mov  [edx], eax						; current->Blink->Flink = current->Fink
		0x89, 0x50, 0x04,					// + 0x5E			-> mov  [eax + 0x04], edx				; current->Flink->Blink = current->Blink

		0x83, 0x7B, 0x18, 0x00,				// + 0x61			-> cmp  dword ptr [ebx + 0x18], 0		; check if SR_REMOTE_DATA_VEH::pLdrProtectMrdata is non-zero
		0x74, 0x05,							// + 0x65			-> je   0x6C							; jump if nullptr
		0x6A, 0x01,							// + 0x67			-> push 1								; push TRUE on the stack
		0xFF, 0x53, 0x18,					// + 0x69			-> call dword ptr [ebx + 0x18]			; call LdrProtectMrdata to protect LdrpVectorHandlerList

		0xFF, 0x73, 0x0C,					// + 0x6C			-> push [ebx + 0x0C]					; push pArg
		0xFF, 0x53, 0x10,					// + 0x6F			-> call dword ptr [ebx + 0x10]			; call pRoutine
		0x89, 0x43, 0x04,					// + 0x72			-> mov  [ebx + 0x04], eax				; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,	// + 0x75			-> mov  eax, fs:[0x18]					; GetLastError
		0x8B, 0x40, 0x34,					// + 0x7B			-> mov  eax, [eax + 0x34]
		0x89, 0x43, 0x08,					// + 0x7E			-> mov  [ebx + 0x08], eax				; store in SR_REMOTE_DATA_VEH::Data::LastWin32Error

		0xC6, 0x03, 0x02,					// + 0x81			-> mov  byte ptr [ebx], 2				; set SR_REMOTE_DATA_VEH::Data::State to SR_RS_ExecutionFinished

		0x83, 0xC8, 0xFF,					// + 0x84			-> or   eax, -1							; set eax to EXCEPTION_CONTINUE_EXECUTION
		0x5B,								// + 0x87			-> pop  ebx								; restore ebx
		0xEB, 0x03,							// + 0x88			-> jmp  0x8D							; jump to epilogue

		0x5B,								// + 0x8A			-> pop  ebx								; restore ebx
		0x31, 0xC0, 						// + 0x8B			-> xor  eax, eax						; set eax to EXCEPTION_CONTINUE_SEARCH

		0x5D,								// + 0x8D			-> pop  ebp								; x86 __stdcall epilogue
		0xC2, 0x04, 0x00					// + 0x8E			-> ret  0x04
	}; // SIZE = 0x91 (+ sizeof(SR_REMOTE_DATA_VEH))

	*ReCa<void **>(Shellcode + 0x1E + sizeof(SR_REMOTE_DATA_VEH)) = pMem;

#endif

	void * pRemoteFunc = ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA_VEH);

	auto * sr_data = ReCa<SR_REMOTE_DATA_VEH *>(Shellcode);
	sr_data->Data.pArg		= pArg;
	sr_data->Data.pRoutine	= pRoutine;
	
	LOG(2, "VEH will be called with:\n");
	LOG(3, "pRoutine = %p\n", pRemoteFunc);
	LOG(3, "pArg     = %p\n", pMem);

	auto * pVEHHead = &NATIVE::LdrpVectorHandlerList->List;
	LIST_ENTRY VEHHead{ 0 };

	if (!ReadProcessMemory(hTargetProc, pVEHHead, &VEHHead, sizeof(VEHHead), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		return SR_VEH_ERR_RPM_FAIL;
	}

	ProcessInfo PI;
	if (!PI.SetProcess(hTargetProc))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Can't initialize ProcessInfo class\n");

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_PROC_INFO_FAIL;
	}

	DWORD ProcessCookie = PI.GetProcessCookie();
	if (!ProcessCookie)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to resolve process cookie\n");

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_PROCESS_COOKIE;
	}

	LOG(2, "ProcessCookie = %08X\n", ProcessCookie);

	auto EntrySize = 0;
	if (GetOSBuildVersion() >= g_Win10_2004)
	{
		EntrySize = sizeof(RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004);
	}
	else
	{
		EntrySize = sizeof(RTL_VECTORED_EXCEPTION_ENTRY);
	}

	BYTE * pNewEntry = ReCa<BYTE *>(VirtualAllocEx(hTargetProc, nullptr, EntrySize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
	if (pNewEntry == nullptr)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return SR_VEH_ERR_CANT_ALLOC_MEM;
	}

	LOG(2, "Allocated memory for VEH entry:\n");
	LOG(3, "pNewEntry = %p\n", pNewEntry);

	auto pVEHShell_Encoded = ReCa<ULONG_PTR>(pRemoteFunc);
	pVEHShell_Encoded ^= ProcessCookie;

#ifdef _WIN64
	pVEHShell_Encoded = _rotr64(pVEHShell_Encoded, ProcessCookie & 0x3F);
#else
	pVEHShell_Encoded = _rotr(pVEHShell_Encoded, ProcessCookie & 0x1F);
#endif
	
	BYTE buffer[sizeof(RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004)]{ 0 };
	if (GetOSBuildVersion() >= g_Win10_2004)
	{
		auto NewEntry = ReCa<RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004 *>(buffer);
	
		NewEntry->List.Flink	= VEHHead.Flink;
		NewEntry->List.Blink	= pVEHHead;

		NewEntry->Flag			= 1;
		NewEntry->pFlag			= &ReCa<RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004 *>(pNewEntry)->Flag;

		NewEntry->VectoredHandler = ReCa<PVECTORED_EXCEPTION_HANDLER>(pVEHShell_Encoded);
	}
	else
	{
		auto NewEntry = ReCa<RTL_VECTORED_EXCEPTION_ENTRY *>(buffer);

		NewEntry->List.Flink = VEHHead.Flink;
		NewEntry->List.Blink = pVEHHead;

		NewEntry->Flag = 1;

		NewEntry->VectoredHandler = ReCa<PVECTORED_EXCEPTION_HANDLER>(pVEHShell_Encoded);
	}

	sr_data->pLdrProtectMrdata	= NATIVE::LdrProtectMrdata;
	sr_data->pListHead			= pVEHHead;
	sr_data->pFakeEntry			= ReCa<LIST_ENTRY *>(pNewEntry);
	sr_data->bRemoveVEHBit		= FALSE;

	if (!WriteProcessMemory(hTargetProc, pNewEntry, &buffer, EntrySize, nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}

	LOG(2, "Copied fake VEH entry into target process\n");

	auto pPEB = PI.GetPEB();

	if (!pPEB)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to get PEB pointer\n");

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_CANT_GET_PEB;
	}

	PEB peb{ 0 };
	if (!ReadProcessMemory(hTargetProc, pPEB, &peb, sizeof(PEB), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_RPM_FAIL;
	}

	DWORD dwOld1 = 0;
	DWORD dwOld2 = 0;
	if (!VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), PAGE_READWRITE, &dwOld1))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualProtectEx failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}
		
	if (!WriteProcessMemory(hTargetProc, pVEHHead, &pNewEntry, sizeof(pNewEntry), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), dwOld1, &dwOld2);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}

	DWORD dwOld3 = 0;
	DWORD dwOld4 = 0;
	LIST_ENTRY * pFlink = VEHHead.Flink;
	if (!VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY), PAGE_READWRITE, &dwOld3))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY), dwOld3, &dwOld4);

		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), PAGE_READWRITE, &dwOld2);
		WriteProcessMemory(hTargetProc, pVEHHead, &VEHHead.Flink, sizeof(DWORD), nullptr);
		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), dwOld1, &dwOld2);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_PROTECT_FAIL;
	}

	if (!WriteProcessMemory(hTargetProc, &VEHHead.Flink->Blink, &pNewEntry, sizeof(pNewEntry), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), PAGE_READWRITE, &dwOld2);
		WriteProcessMemory(hTargetProc, pVEHHead, &VEHHead.Flink, sizeof(VEHHead.Flink), nullptr);
		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), dwOld1, &dwOld2);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}

	LOG(2, "VEH handler linked to LdrpVectorHandlerList\n");

	if (peb.ProcessUsingVEH == FALSE)
	{
		sr_data->bRemoveVEHBit = TRUE;
	}

	if (!WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_WPM_FAIL;
	}

	LOG(2, "Copied shellcode into target process\n");

	bool updated_peb = false;
	if (peb.ProcessUsingVEH == FALSE)
	{
		LOG(2, "Updating PEB::ProcessUsingVEH flag\n");

		peb.ProcessUsingVEH = TRUE;

		if (!WriteProcessMemory(hTargetProc, &pPEB->CrossProcessFlags, &peb.CrossProcessFlags, sizeof(peb.CrossProcessFlags), nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_VEH_ERR_WPM_FAIL;
		}

		updated_peb = true;
	}

	if (!VirtualProtectEx(hTargetProc, NATIVE::NtDelayExecution, 1, PAGE_EXECUTE_READ | PAGE_GUARD, &dwOld2))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualProtectEx failed: %08X\n", error_data.AdvErrorCode);


		VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY), PAGE_READWRITE, &dwOld4);
		WriteProcessMemory(hTargetProc, &pFlink->Blink, &pVEHHead, sizeof(pVEHHead), nullptr);
		VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY), dwOld3, &dwOld4);

		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), PAGE_READWRITE, &dwOld2);
		WriteProcessMemory(hTargetProc, pVEHHead, &VEHHead.Flink, sizeof(VEHHead.Flink), nullptr);
		VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), dwOld1, &dwOld2);


		if (updated_peb)
		{
			peb.ProcessUsingVEH = FALSE;
			WriteProcessMemory(hTargetProc, &pPEB->CrossProcessFlags, &peb.CrossProcessFlags, sizeof(peb.CrossProcessFlags), nullptr);
		}

		VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_VEH_ERR_PROTECT_FAIL;
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	SR_REMOTE_DATA data{ };
	data.State			= SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	auto Timer = GetTickCount64();
	while (GetTickCount64() - Timer < Timeout)
	{
		auto dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		auto bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet)
		{
			if (data.State == SR_REMOTE_STATE::SR_RS_ExecutionFinished)
			{
				LOG(2, "Shelldata retrieved\n");

				break;
			}
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");				
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}

			VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY), PAGE_READWRITE, &dwOld4);
			WriteProcessMemory(hTargetProc, &pFlink->Blink, &pVEHHead, sizeof(DWORD), nullptr);
			VirtualProtectEx(hTargetProc, pFlink, sizeof(LIST_ENTRY), dwOld3, &dwOld4);

			VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), PAGE_READWRITE, &dwOld2);
			WriteProcessMemory(hTargetProc, pVEHHead, &VEHHead.Flink, sizeof(DWORD), nullptr);
			VirtualProtectEx(hTargetProc, pVEHHead, sizeof(LIST_ENTRY), dwOld1, &dwOld2);

			if (updated_peb)
			{
				peb.ProcessUsingVEH = FALSE;
				WriteProcessMemory(hTargetProc, &pPEB->CrossProcessFlags, &peb.CrossProcessFlags, sizeof(peb.CrossProcessFlags), nullptr);
			}

			VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}

			return SR_VEH_ERR_RPM_FAIL;
		}
	}

	VirtualFreeEx(hTargetProc, pNewEntry, 0, MEM_RELEASE);

	if (data.State != SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shell timed out\n");		

		return SR_VEH_ERR_REMOTE_TIMEOUT;
	}

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out = data.Ret;

	return SR_ERR_SUCCESS;
}
```

`GH Injector Library/GH Injector Library.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Deutsch (Deutschland) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 4,8,0,0
 PRODUCTVERSION 4,8,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000904b0"
        BEGIN
            VALUE "CompanyName", "Guided Hacking"
            VALUE "FileDescription", "Injection library of the GH Injector"
            VALUE "FileVersion", "4.8.0.0"
            VALUE "LegalCopyright", "Broihon (C) 1987 - 2035"
            VALUE "ProductName", "GH Injection Library"
            VALUE "ProductVersion", "4.8.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x9, 1200
    END
END

#endif    // Deutsch (Deutschland) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`GH Injector Library/GH Injector Library.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{AC732425-E265-40FF-842F-C59CECE9A96C}</ProjectGuid>
    <RootNamespace>GHInjectorLibrary</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <TargetName>GH Injector - $(PlatformShortName)</TargetName>
    <IntDir>$(Configuration)\$(PlatformShortName)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <TargetName>GH Injector - $(PlatformShortName)</TargetName>
    <IntDir>$(Configuration)\$(PlatformShortName)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformShortName)\</IntDir>
    <TargetName>GH Injector - $(PlatformShortName)</TargetName>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformShortName)\</IntDir>
    <TargetName>GH Injector - $(PlatformShortName)</TargetName>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <SupportJustMyCode>true</SupportJustMyCode>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <TreatWarningAsError>true</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <TreatWarningAsError>true</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="DotNetInjection.h" />
    <ClInclude Include="Download Manager.h" />
    <ClInclude Include="Eject.h" />
    <ClInclude Include="Error.h" />
    <ClInclude Include="Handle Hijacking.h" />
    <ClInclude Include="Hook Scanner.h" />
    <ClInclude Include="Import Handler.h" />
    <ClInclude Include="Injection Internal.h" />
    <ClInclude Include="Injection.h" />
    <ClInclude Include="Manual Mapping Internal.h" />
    <ClInclude Include="Manual Mapping.h" />
    <ClInclude Include="NT Defs.h" />
    <ClInclude Include="NT Funcs.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="Process Info.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Start Routine.h" />
    <ClInclude Include="Symbol Loader.h" />
    <ClInclude Include="Symbol Parser.h" />
    <ClInclude Include="Tools.h" />
    <ClInclude Include="VEH Shell.h" />
    <ClInclude Include="Win10.h" />
    <ClInclude Include="Win11.h" />
    <ClInclude Include="Win7.h" />
    <ClInclude Include="Win8.h" />
    <ClInclude Include="Win81.h" />
    <ClInclude Include="WOW64 Shells.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DotNetInjection.cpp" />
    <ClCompile Include="Download Manager.cpp" />
    <ClCompile Include="Eject.cpp" />
    <ClCompile Include="FakeVEH WOW64.cpp" />
    <ClCompile Include="FakeVEH.cpp" />
    <ClCompile Include="Handle Hijacking.cpp" />
    <ClCompile Include="Hook Scanner WOW64.cpp" />
    <ClCompile Include="Hook Scanner.cpp" />
    <ClCompile Include="Import Handler.cpp" />
    <ClCompile Include="Import Handler WOW64.cpp" />
    <ClCompile Include="Injection Generic WOW64.cpp" />
    <ClCompile Include="Injection Generic.cpp" />
    <ClCompile Include="Injection.cpp" />
    <ClCompile Include="KernelCallback WOW64.cpp" />
    <ClCompile Include="KernelCallback.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="Manual Mapping WOW64.cpp" />
    <ClCompile Include="Manual Mapping.cpp" />
    <ClCompile Include="NtCreateThreadEx WOW64.cpp" />
    <ClCompile Include="NtCreateThreadEx.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <ClCompile Include="Process Info.cpp" />
    <ClCompile Include="QueueUserAPC WOW64.cpp" />
    <ClCompile Include="QueueUserAPC.cpp" />
    <ClCompile Include="SetWindowsHookEx WOW64.cpp" />
    <ClCompile Include="SetWindowsHookEx.cpp" />
    <ClCompile Include="Start Routine WOW64.cpp" />
    <ClCompile Include="Start Routine.cpp" />
    <ClCompile Include="Symbol Loader.cpp" />
    <ClCompile Include="Symbol Parser.cpp" />
    <ClCompile Include="Thread Hijacking WOW64.cpp" />
    <ClCompile Include="Thread Hijacking.cpp" />
    <ClCompile Include="Tools.cpp" />
    <ClCompile Include="VEH Shell.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GH Injector Library.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GH Injector Library/GH Injector Library.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Ressourcendateien">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Quelldateien\native">
      <UniqueIdentifier>{5ff20698-973e-477d-8c08-22f6451b3cee}</UniqueIdentifier>
    </Filter>
    <Filter Include="Quelldateien\wow64">
      <UniqueIdentifier>{9b97304f-da6c-4772-b09b-b9d220bc2b8f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Quelldateien\native\Injection Methods">
      <UniqueIdentifier>{d5fa2704-bd0a-49aa-935a-dd175543f290}</UniqueIdentifier>
    </Filter>
    <Filter Include="Quelldateien\wow64\Injection Methods">
      <UniqueIdentifier>{55a0bf0c-81f5-48b8-8bb9-1c73e57ccab7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Quelldateien\native\Start Routine Methods">
      <UniqueIdentifier>{76d1c640-61f3-484e-ae41-7405af75b480}</UniqueIdentifier>
    </Filter>
    <Filter Include="Quelldateien\wow64\Start Routine Methods">
      <UniqueIdentifier>{6fdc8522-3bbc-43c6-817e-43e093ce89f0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headerdateien\Injection Methods">
      <UniqueIdentifier>{d3c5e067-fa7b-4ff9-9579-418c449c7978}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headerdateien\NT">
      <UniqueIdentifier>{844b590b-6d34-422e-8d4f-d27e3e5defb5}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Handle Hijacking.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Import Handler.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Injection.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Process Info.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Start Routine.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Tools.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Eject.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Error.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Symbol Parser.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Manual Mapping.h">
      <Filter>Headerdateien\Injection Methods</Filter>
    </ClInclude>
    <ClInclude Include="Hook Scanner.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Injection Internal.h">
      <Filter>Headerdateien\Injection Methods</Filter>
    </ClInclude>
    <ClInclude Include="WOW64 Shells.h">
      <Filter>Quelldateien\wow64\Injection Methods</Filter>
    </ClInclude>
    <ClInclude Include="Download Manager.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="NT Funcs.h">
      <Filter>Headerdateien\NT</Filter>
    </ClInclude>
    <ClInclude Include="Win7.h">
      <Filter>Headerdateien\NT</Filter>
    </ClInclude>
    <ClInclude Include="Win8.h">
      <Filter>Headerdateien\NT</Filter>
    </ClInclude>
    <ClInclude Include="Win81.h">
      <Filter>Headerdateien\NT</Filter>
    </ClInclude>
    <ClInclude Include="Win10.h">
      <Filter>Headerdateien\NT</Filter>
    </ClInclude>
    <ClInclude Include="NT Defs.h">
      <Filter>Headerdateien\NT</Filter>
    </ClInclude>
    <ClInclude Include="Win11.h">
      <Filter>Headerdateien\NT</Filter>
    </ClInclude>
    <ClInclude Include="VEH Shell.h">
      <Filter>Headerdateien\Injection Methods</Filter>
    </ClInclude>
    <ClInclude Include="Symbol Loader.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="Manual Mapping Internal.h">
      <Filter>Headerdateien\Injection Methods</Filter>
    </ClInclude>
    <ClInclude Include="DotNetInjection.h">
      <Filter>Headerdateien\Injection Methods</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Handle Hijacking.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="Process Info.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="Tools.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="Import Handler WOW64.cpp">
      <Filter>Quelldateien\wow64</Filter>
    </ClCompile>
    <ClCompile Include="Start Routine WOW64.cpp">
      <Filter>Quelldateien\wow64</Filter>
    </ClCompile>
    <ClCompile Include="Eject.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="Manual Mapping.cpp">
      <Filter>Quelldateien\native\Injection Methods</Filter>
    </ClCompile>
    <ClCompile Include="Manual Mapping WOW64.cpp">
      <Filter>Quelldateien\wow64\Injection Methods</Filter>
    </ClCompile>
    <ClCompile Include="Import Handler.cpp">
      <Filter>Quelldateien\native</Filter>
    </ClCompile>
    <ClCompile Include="Injection.cpp">
      <Filter>Quelldateien\native</Filter>
    </ClCompile>
    <ClCompile Include="Start Routine.cpp">
      <Filter>Quelldateien\native</Filter>
    </ClCompile>
    <ClCompile Include="NtCreateThreadEx.cpp">
      <Filter>Quelldateien\native\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="Thread Hijacking.cpp">
      <Filter>Quelldateien\native\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="QueueUserAPC.cpp">
      <Filter>Quelldateien\native\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="SetWindowsHookEx.cpp">
      <Filter>Quelldateien\native\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="NtCreateThreadEx WOW64.cpp">
      <Filter>Quelldateien\wow64\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="QueueUserAPC WOW64.cpp">
      <Filter>Quelldateien\wow64\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="SetWindowsHookEx WOW64.cpp">
      <Filter>Quelldateien\wow64\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="Thread Hijacking WOW64.cpp">
      <Filter>Quelldateien\wow64\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="Symbol Parser.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="Hook Scanner.cpp">
      <Filter>Quelldateien\native</Filter>
    </ClCompile>
    <ClCompile Include="Hook Scanner WOW64.cpp">
      <Filter>Quelldateien\wow64</Filter>
    </ClCompile>
    <ClCompile Include="Injection Generic.cpp">
      <Filter>Quelldateien\native\Injection Methods</Filter>
    </ClCompile>
    <ClCompile Include="Injection Generic WOW64.cpp">
      <Filter>Quelldateien\wow64\Injection Methods</Filter>
    </ClCompile>
    <ClCompile Include="Download Manager.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="KernelCallback.cpp">
      <Filter>Quelldateien\native\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="KernelCallback WOW64.cpp">
      <Filter>Quelldateien\wow64\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="VEH Shell.cpp">
      <Filter>Quelldateien\native\Injection Methods</Filter>
    </ClCompile>
    <ClCompile Include="FakeVEH WOW64.cpp">
      <Filter>Quelldateien\wow64\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="FakeVEH.cpp">
      <Filter>Quelldateien\native\Start Routine Methods</Filter>
    </ClCompile>
    <ClCompile Include="Symbol Loader.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="DotNetInjection.cpp">
      <Filter>Quelldateien\native\Injection Methods</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GH Injector Library.rc">
      <Filter>Ressourcendateien</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`GH Injector Library/GH Injector Library.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`GH Injector Library/Handle Hijacking.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Handle Hijacking.h"

NTSTATUS EnumHandles(char * pBuffer, ULONG Size, ULONG * SizeOut, UINT & Count);
std::vector<SYSTEM_HANDLE_TABLE_ENTRY_INFO> EnumProcessHandles();

NTSTATUS EnumHandles(char * pBuffer, ULONG Size, ULONG * SizeOut, UINT & Count)
{
	NTSTATUS ntRet = NATIVE::NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS::SystemHandleInformation, pBuffer, Size, SizeOut);

	if (NT_FAIL(ntRet))
	{
		LOG(4, "Failed to grab handle list: %08X\n", ntRet);

		return ntRet;
	}

	auto * pHandleInfo = ReCa<SYSTEM_HANDLE_INFORMATION *>(pBuffer);
	Count = pHandleInfo->NumberOfHandles;
	
	LOG(4, "%d handles found\n", Count);

	return ntRet;
}

std::vector<SYSTEM_HANDLE_TABLE_ENTRY_INFO> EnumProcessHandles()
{
	std::vector<SYSTEM_HANDLE_TABLE_ENTRY_INFO> Ret;
	UINT Count		= 0;
	ULONG Size		= 0x10000;
	char * pBuffer	= new(std::nothrow) char[Size]();

	if (pBuffer == nullptr)
	{
		return Ret;
	}

	NTSTATUS ntRet = EnumHandles(pBuffer, Size, &Size, Count);

	if (NT_FAIL(ntRet))
	{
		while (ntRet == STATUS_INFO_LENGTH_MISMATCH)
		{
			delete[] pBuffer;
			pBuffer = new(std::nothrow) char[Size];

			if (pBuffer == nullptr)
			{
				return Ret;
			}

			ntRet = EnumHandles(pBuffer, Size, &Size, Count);
		}

		if (NT_FAIL(ntRet))
		{
			delete[] pBuffer;

			return Ret;
		}
	}

	auto * pEntry = ReCa<SYSTEM_HANDLE_INFORMATION *>(pBuffer)->Handles;
	for (UINT i = 0; i != Count; ++i)
	{
		if ((OBJECT_TYPE_NUMBER)pEntry[i].ObjectTypeIndex == OBJECT_TYPE_NUMBER::Process)
		{
			Ret.push_back(pEntry[i]);
		}
	}
		
	delete[] pBuffer;

	return Ret;
}

std::vector<handle_data> FindProcessHandles(DWORD TargetPID, DWORD WantedHandleAccess)
{
	std::vector<handle_data> Ret;
	DWORD OwnPID = GetCurrentProcessId();

	auto handles = EnumProcessHandles();

	LOG(2, "%d process handles found\n", (DWORD)handles.size());

	auto current_process = GetCurrentProcess();

	for (const auto & i : handles)
	{
		DWORD CurrentPID = i.UniqueProcessId;
		if (CurrentPID == OwnPID || CurrentPID == TargetPID)
		{
			continue;
		}

		HANDLE hCurrentProc = OpenProcess(PROCESS_DUP_HANDLE, FALSE, CurrentPID);
		if (!hCurrentProc)
		{
			continue;
		}

		if ((i.GrantedAccess & WantedHandleAccess) != WantedHandleAccess)
		{
			continue;
		}

		HANDLE hDup		= nullptr;
		HANDLE hOrig	= ReCa<HANDLE>(i.HandleValue);
		
		if (DuplicateHandle(hCurrentProc, hOrig, current_process, &hDup, PROCESS_QUERY_LIMITED_INFORMATION, FALSE, NULL))
		{
			if (GetProcessId(hDup) == TargetPID)
			{
				Ret.push_back(handle_data{ CurrentPID, i.HandleValue, i.GrantedAccess });
			}

			CloseHandle(hDup);
		}

		CloseHandle(hCurrentProc);
	}

	LOG(2, "%d handle(s) to target process found\n", (DWORD)Ret.size());

	return Ret;
}
```

`GH Injector Library/Handle Hijacking.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "Import Handler.h"

struct handle_data
{
	DWORD	OwnerPID;
	WORD	hValue;
	DWORD	Access;
};
//Structure to store data when enumerating handles.

std::vector<handle_data> FindProcessHandles(DWORD TargetPID, DWORD WantedHandleAccess);
//Used to find handles for a specific process
//
//Arguments:
//		TargetPID (DWORD):
///			Process identifier of the target process
//		WantedHandleAccess (DWORD):
///			Combination of process access rights:
//			https://docs.microsoft.com/en-gb/windows/desktop/ProcThread/process-security-and-access-rights
//
//Returnvalue:
///		On success: std::vector of handle_data structs which contain information on the handles
///		On failure: empty vector
```

`GH Injector Library/Hook Scanner WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Hook Scanner.h"

bool ScanForHook_WOW64(HookInfo & Info, HANDLE hTargetProc, HANDLE hRefProcess)
{
	DWORD Address = 0;
	if(!GetProcAddressEx_WOW64(hRefProcess, Info.hModuleBase, Info.FunctionName, Address))
	{
		Info.ErrorCode = HOOK_SCAN_ERR_GETPROCADDRESS_FAILED;

		LOG(1, "GetProcAddressEx_WOW64 failed on %s\n", Info.FunctionName);

		return false;
	}

	Info.pFunc = MPTR(Address);

	if (!ReadProcessMemory(hRefProcess, Info.pFunc, Info.OriginalBytes, sizeof(Info.OriginalBytes), nullptr))
	{
		Info.ErrorCode = HOOK_SCAN_ERR_READ_PROCESS_MEMORY_FAILED;

		LOG(1, "ReadProcessMemory (reference process) failed on %s with error %08X\n", Info.FunctionName, GetLastError());

		return false;
	}

	BYTE Buffer[HOOK_SCAN_BYTE_COUNT]{ 0 };
	if (!ReadProcessMemory(hTargetProc, Info.pFunc, Buffer, sizeof(Buffer), nullptr))
	{
		Info.ErrorCode = HOOK_SCAN_ERR_READ_PROCESS_MEMORY_FAILED;

		LOG(1, "ReadProcessMemory (target process) failed on %s with error %08X\n", Info.FunctionName, GetLastError());

		return false;
	}
	
	for (int i = 0; i != HOOK_SCAN_BYTE_COUNT; ++i)
	{
		if (Info.OriginalBytes[i] != Buffer[i])
		{
			++Info.ChangeCount;
		}
	}

	return (Info.ChangeCount != 0);
}

#endif
```

`GH Injector Library/Hook Scanner.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Hook Scanner.h"

#define MOD_COUNT 3

static const wchar_t Modules[][MAX_PATH] =
{
	L"kernel32.dll",
	L"KernelBase.dll",
	L"ntdll.dll"
};

static const char k32_functions[][MAX_PATH] =
{
	"LoadLibraryExW",
	"BaseThreadInitThunk"
};

static const char kb_functions[][MAX_PATH] =
{
	"LoadLibraryExW",
};

static const char nt_functions[][MAX_PATH] =
{
	"LdrLoadDll",
	"LdrGetDllHandleEx",
	"LdrGetProcedureAddressForCaller",
	"LdrLockLoaderLock",
	"LdrUnlockLoaderLock",
	"memmove",
	"RtlAllocateHeap",
	"RtlFreeHeap",
	"RtlHashUnicodeString",
	"RtlRbInsertNodeEx",
	"NtOpenFile",
	"NtReadFile",
	"NtSetInformationFile",
	"NtQueryInformationFile",
	"NtCreateSection",
	"NtMapViewOfSection",
	"NtAllocateVirtualMemory",
	"NtProtectVirtualMemory"
};

bool __stdcall ValidateInjectionFunctions(DWORD dwTargetProcessId, DWORD & ErrorCode, DWORD & LastWin32Error, HookInfo * HookDataOut, UINT Count, UINT * CountOut)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "ValidateInjectionFunctions:\n PID = %06X\n", dwTargetProcessId);

	if (!dwTargetProcessId)
	{
		ErrorCode = HOOK_SCAN_ERR_INVALID_PROCESS_ID;

		return false;
	}

	HANDLE hTargetProc = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION | PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwTargetProcessId);
	if (!hTargetProc)
	{
		LastWin32Error	= GetLastError();
		ErrorCode		= HOOK_SCAN_ERR_CANT_OPEN_PROCESS;

		LOG(0, "OpenProcess failed: %08X\n", LastWin32Error);

		return false;
	}

	bool bWow64 = !IsNativeProcess(hTargetProc);

#ifndef _WIN64
	if (!bWow64 && !IsNativeProcess(GetCurrentProcess()))
	{
		CloseHandle(hTargetProc);

		LOG(0, "WOW64 process can't scan x64 process\n");

		ErrorCode = HOOK_SCAN_ERR_PLATFORM_MISMATCH;

		return false;
	}

	bWow64 = false;
#endif

	std::vector<HookInfo> HookDataOutV;

	UINT ScanCount = 0;

	if (bWow64)
	{
#ifdef _WIN64

		LOG(0, "WOW64 hook scan\n");
		LOG(0, "Modules to scan:\n");

		HINSTANCE hModules[MOD_COUNT]{ 0 };
		for (int i = 0; i < MOD_COUNT; ++i)
		{
			hModules[i] = GetModuleHandleExW_WOW64(hTargetProc, Modules[i]);
			LOG(0, " %.11ls = %08X\n", Modules[i], MDWD(hModules[i]));
		}

		PROCESS_INFORMATION pi{ 0 };
		STARTUPINFOW si{ 0 };
		si.cb			= sizeof(si);
		si.dwFlags		= STARTF_USESHOWWINDOW;
		si.wShowWindow	= SW_HIDE;

		SECURITY_ATTRIBUTES sa{ 0 };
		sa.nLength			= sizeof(SECURITY_ATTRIBUTES);
		sa.bInheritHandle	= TRUE;

		HANDLE hEventStart = CreateEventEx(&sa, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_ALL_ACCESS);
		if (!hEventStart)
		{
			LastWin32Error	= GetLastError();
			ErrorCode		= HOOK_SCAN_ERR_CREATE_EVENT_FAILED;

			LOG(0, "CreateEventEx failed: %08X\n", LastWin32Error);

			CloseHandle(hTargetProc);

			return false;
		}

		HANDLE hEventEnd = CreateEventEx(&sa, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_ALL_ACCESS);
		if (!hEventEnd)
		{
			LastWin32Error	= GetLastError();
			ErrorCode		= HOOK_SCAN_ERR_CREATE_EVENT_FAILED;

			LOG(0, "CreateEventEx failed: %08X\n", LastWin32Error);

			CloseHandle(hEventStart);
			CloseHandle(hTargetProc);

			return false;
		}

		wchar_t hEventStart_string[9]{ 0 };
		_ultow_s(MDWD(hEventStart), hEventStart_string, 0x10);

		wchar_t hEventEnd_string[9]{ 0 };
		_ultow_s(MDWD(hEventEnd), hEventEnd_string, 0x10);

		auto RootPath = g_RootPathW + SM_EXE_FILENAME86;

		std::wstring CmdLine = L"\"" SM_EXE_FILENAME86 "\" " ID_WOW64 " ";
		CmdLine += hEventStart_string;
		CmdLine += L" ";
		CmdLine += hEventEnd_string;

		wchar_t szCmdLine[MAX_PATH]{ 0 };
		CmdLine.copy(szCmdLine, CmdLine.length()); //CmdLine will not exceed MAX_PATH characters (46 characters max)

		if (!CreateProcessW(RootPath.c_str(), szCmdLine, nullptr, nullptr, TRUE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
		{
			LastWin32Error	= GetLastError();
			ErrorCode		= HOOK_SCAN_ERR_CREATE_PROCESS_FAILED;

			LOG(0, "CreateProcessW failed: %08X\n", LastWin32Error);

			CloseHandle(hEventStart);
			CloseHandle(hEventEnd);

			CloseHandle(hTargetProc);

			return false;
		}		

		DWORD dwWaitRet = WaitForSingleObject(hEventStart, 1000);
		if (dwWaitRet != WAIT_OBJECT_0)
		{
			if (dwWaitRet == WAIT_FAILED)
			{				
				LastWin32Error	= GetLastError();
				ErrorCode		= HOOK_SCAN_ERR_WAIT_FAILED;
			}
			else
			{
				LastWin32Error	= dwWaitRet;
				ErrorCode		= HOOK_SCAN_ERR_WAIT_TIMEOUT;
			}

			LOG(0, "WaitForSingleObject failed: %08X\n", LastWin32Error);

			CloseHandle(hEventStart);
			CloseHandle(hEventEnd);

			CloseHandle(pi.hThread);
			CloseHandle(pi.hProcess);

			CloseHandle(hTargetProc);

			return false;
		}

		LOG(0, "Loading templates\n");

		if (hModules[0])
		{
			for (auto i = 0; i != sizeof(k32_functions) / sizeof(k32_functions[0]); ++i)
			{
				HookDataOutV.push_back({ Modules[0], k32_functions[i], hModules[0], nullptr, 0, 0, NULL });
				LOG(0, " %s\n", k32_functions[i]);
			}
		}

		if (hModules[1])
		{
			for (auto i = 0; i != sizeof(kb_functions) / sizeof(kb_functions[0]); ++i)
			{
				HookDataOutV.push_back({ Modules[1], kb_functions[i], hModules[1], nullptr, 0, 0, NULL });
				LOG(0, " %s\n", kb_functions[i]);
			}
		}

		if (hModules[2])
		{
			for (auto i = 0; i != sizeof(nt_functions) / sizeof(nt_functions[0]); ++i)
			{
				HookDataOutV.push_back({ Modules[2], nt_functions[i], hModules[2], nullptr, 0, 0, NULL });
				LOG(0, " %s\n", nt_functions[i]);
			}
		}

		LOG(0, "Scanning for hooks\n");

		for (auto & i : HookDataOutV)
		{
			if (ScanForHook_WOW64(i, hTargetProc, pi.hProcess))
			{
				LOG(0, " Hooked: %s (%d)\n", i.FunctionName, i.ChangeCount);

				if (ScanCount < Count)
				{
					HookDataOut[ScanCount] = i;
				}

				++ScanCount;
			}
		}

		SetEvent(hEventEnd);

		CloseHandle(hEventStart);
		CloseHandle(hEventEnd);
		
		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);
#endif
	}
	else
	{
		LOG(0, "Native hook scan\n");

		LOG(0, "Modules to scan:\n");

		HINSTANCE hModules[MOD_COUNT]{ 0 };
		for (int i = 0; i < MOD_COUNT; ++i)
		{
			hModules[i] = GetModuleHandleW(Modules[i]);
			LOG(0, " %.11ls = %p\n", Modules[i], hModules[i]);
		}

		LOG(0, "Loading templates\n");

		if (hModules[0])
		{
			for (auto i = 0; i != sizeof(k32_functions) / sizeof(k32_functions[0]); ++i)
			{
				HookDataOutV.push_back({ Modules[0], k32_functions[i], hModules[0], nullptr, 0, 0, NULL });
				LOG(0, " %s\n", k32_functions[i]);
			}
		}

		if (hModules[1])
		{
			for (auto i = 0; i != sizeof(kb_functions) / sizeof(kb_functions[0]); ++i)
			{
				HookDataOutV.push_back({ Modules[1], kb_functions[i], hModules[1], nullptr, 0, 0, NULL });
				LOG(0, " %s\n", kb_functions[i]);
			}
		}

		if (hModules[2])
		{
			for (auto i = 0; i != sizeof(nt_functions) / sizeof(nt_functions[0]); ++i)
			{
				HookDataOutV.push_back({ Modules[2], nt_functions[i], hModules[2], nullptr, 0, 0, NULL });
				LOG(0, " %s\n", nt_functions[i]);
			}
		}

		LOG(0, "Scanning for hooks\n");

		for (auto & i : HookDataOutV)
		{
			if(ScanForHook(i, hTargetProc))
			{
				LOG(0, " Hook: %s (%d)\n", i.FunctionName, i.ChangeCount);

				if (ScanCount < Count)
				{
					HookDataOut[ScanCount] = i;
				}

				++ScanCount;
			}
		}
	}

	CloseHandle(hTargetProc);

	if (CountOut)
	{
		*CountOut = ScanCount;
	}

	LOG(0, "%d hook(s) found\n", ScanCount);

	if (ScanCount > Count)
	{
		LOG(0, "Provided buffer too small: %d hooks found, buffer is %d hook entries big\n", ScanCount, Count);

		ErrorCode = HOOK_SCAN_ERR_BUFFER_TOO_SMALL;

		return false;
	}

	return true;
}

bool __stdcall RestoreInjectionFunctions(DWORD dwTargetProcessId, DWORD & ErrorCode, DWORD & LastWin32Error, HookInfo * HookDataIn, UINT Count, UINT * CountOut)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "RestoreInjectionFunctions:\n PID = %06X\n", dwTargetProcessId);

	if (!dwTargetProcessId)
	{
		ErrorCode = HOOK_SCAN_ERR_INVALID_PROCESS_ID;

		return false;
	}

	HANDLE hTargetProc = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, dwTargetProcessId);
	if (!hTargetProc)
	{
		LastWin32Error	= GetLastError();
		ErrorCode		= HOOK_SCAN_ERR_CANT_OPEN_PROCESS;

		LOG(0, "OpenProcess failed: %08X\n", LastWin32Error);

		return false;
	}

	UINT SuccessCount = 0;
	for (UINT i = 0; i != Count; ++i)
	{
		if (HookDataIn[i].ChangeCount && (HookDataIn[i].ErrorCode == HOOK_SCAN_ERR_SUCCESS))
		{
			LOG(0, " Restoring %s\n", HookDataIn[i].FunctionName);

			if (!WriteProcessMemory(hTargetProc, HookDataIn[i].pFunc, HookDataIn[i].OriginalBytes, sizeof(HookDataIn[i].OriginalBytes), nullptr))
			{
				HookDataIn[i].ErrorCode = GetLastError();

				LOG(0, "  WriteProcessMemory failed: %08X\n", HookDataIn[i].ErrorCode);
			}
			else
			{
				++SuccessCount;
			}
		}
	}

	if (CountOut)
	{
		*CountOut = SuccessCount;
	}

	CloseHandle(hTargetProc);

	LOG(0, "%d of %d hook(s) restored\n", SuccessCount, Count);

	return true;
}

bool ScanForHook(HookInfo & Info, HANDLE hTargetProc)
{
	Info.pFunc = ReCa<void *>(GetProcAddress(Info.hModuleBase, Info.FunctionName));
	if (!Info.pFunc)
	{
		Info.ErrorCode = HOOK_SCAN_ERR_GETPROCADDRESS_FAILED;

		LOG(1, "GetProcAddress failed on %s with error %08X\n", Info.FunctionName, GetLastError());

		return false;
	}

	BYTE Buffer[HOOK_SCAN_BYTE_COUNT]{ 0 };
	if (!ReadProcessMemory(hTargetProc, Info.pFunc, Buffer, sizeof(Buffer), nullptr))
	{
		Info.ErrorCode = HOOK_SCAN_ERR_READ_PROCESS_MEMORY_FAILED;

		LOG(1, "ReadProcessMemory failed on %s with error %08X\n", Info.FunctionName, GetLastError());

		return false;
	}

	memcpy(Info.OriginalBytes, Info.pFunc, HOOK_SCAN_BYTE_COUNT);

	for (int i = 0; i != HOOK_SCAN_BYTE_COUNT; ++i)
	{
		if (Info.OriginalBytes[i] != Buffer[i])
		{
			++Info.ChangeCount;
		}
	}

	return (Info.ChangeCount != 0);
}
```

`GH Injector Library/Hook Scanner.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "Import Handler.h"

#define HOOK_SCAN_BYTE_COUNT 0x10

struct HookInfo
{
	const wchar_t	* ModuleName;
	const char		* FunctionName;

	HINSTANCE		hModuleBase;
	void		*	pFunc;
	UINT			ChangeCount;
	BYTE			OriginalBytes[HOOK_SCAN_BYTE_COUNT];

	DWORD ErrorCode;
};

bool __stdcall ValidateInjectionFunctions(DWORD dwTargetProcessId, DWORD & ErrorCode, DWORD & LastWin32Error, HookInfo * HookDataOut, UINT Count, UINT * CountOut);
bool __stdcall RestoreInjectionFunctions(DWORD dwTargetProcessId, DWORD & ErrorCode, DWORD & LastWin32Error, HookInfo * HookDataIn, UINT Count, UINT * CountOut);

bool ScanForHook(HookInfo & Info, HANDLE hTargetProc);

#ifdef _WIN64
bool ScanForHook_WOW64(HookInfo & Info, HANDLE hTargetProc, HANDLE hRefProc);
#endif
```

`GH Injector Library/Import Handler WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Import Handler.h"

#ifdef UNICODE
#undef MODULEENTRY32
#undef Module32First
#undef Module32Next
#endif

using namespace WOW64;

#define S_FUNC(f) WOW64::f##_WOW64, #f

template <typename T>
DWORD LoadSymbolWOW64(T & Function, const char * szFunction, int index = IDX_NTDLL)
{
	DWORD RVA		= 0;
	DWORD sym_ret	= 0;
	DWORD out		= 0;

	sym_ret = sym_parser.GetSymbolAddress(szFunction, RVA);

	if (sym_ret != SYMBOL_ERR_SUCCESS)
	{
		LOG(1, "Failed to load WOW64 function: %s\n", szFunction);

		return 0;
	}

	switch (index)
	{
		case IDX_NTDLL:			
			out	= MDWD(g_hNTDLL_WOW64) + RVA;
			break;

		case IDX_KERNEL32:
			out	= MDWD(g_hKERNEL32_WOW64) + RVA;
			break;

		default:
			LOG(1, "Invalid symbol index specified. Failed to load WOW64 function: %s\n", szFunction);
			return 0;
	}

	Function = (T)out;

	return INJ_ERR_SUCCESS;
}

DWORD ResolveImports_WOW64(ERROR_DATA & error_data)
{
	LOG(1, "ResolveImports_WOW64 called\n");

	PROCESS_INFORMATION pi{ 0 };
	STARTUPINFOW		si{ 0 };
	si.cb			= sizeof(si);
	si.dwFlags		= STARTF_USESHOWWINDOW;
	si.wShowWindow	= SW_HIDE;

	SECURITY_ATTRIBUTES sa{ 0 };
	sa.nLength			= sizeof(SECURITY_ATTRIBUTES);
	sa.bInheritHandle	= TRUE;

	HANDLE hEventStart = CreateEventEx(&sa, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_ALL_ACCESS);
	if (!hEventStart)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "CreateEventEx failed: %08X\n", error_data.AdvErrorCode);

		return INJ_ERR_CREATE_EVENT_FAILED;
	}

	HANDLE hEventEnd = CreateEventEx(&sa, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_ALL_ACCESS);
	if (!hEventEnd)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "CreateEventEx failed: %08X\n", error_data.AdvErrorCode);

		CloseHandle(hEventStart);

		return INJ_ERR_CREATE_EVENT_FAILED;
	}

	wchar_t hEventStart_string[9]{ 0 };
	_ultow_s(MDWD(hEventStart), hEventStart_string, 0x10);

	wchar_t hEventEnd_string[9]{ 0 };
	_ultow_s(MDWD(hEventEnd), hEventEnd_string, 0x10);

	std::wstring SM_Path = g_RootPathW + SM_EXE_FILENAME86;

	if (!FileExistsW(SM_Path))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "GH Injector SM - x86.exe is missing\n");

		return INJ_ERR_SM86_EXE_MISSING;
	}

	std::wstring CmdLine = L"\"" SM_EXE_FILENAME86 "\" " ID_WOW64 " ";
	CmdLine += hEventStart_string;
	CmdLine += L" ";
	CmdLine += hEventEnd_string;

	wchar_t szCmdLine[MAX_PATH]{ 0 };
	CmdLine.copy(szCmdLine, CmdLine.length()); //CmdLine will not exceed MAX_PATH characters (46 characters max)

	if (!CreateProcessW(SM_Path.c_str(), szCmdLine, nullptr, nullptr, TRUE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "CreateProcessW failed: %08X\n", error_data.AdvErrorCode);

		CloseHandle(hEventStart);
		CloseHandle(hEventEnd);

		return INJ_ERR_CREATE_PROCESS_FAILED;
	}

	DWORD dwWaitRet = WaitForSingleObject(hEventStart, 1000);
	if (dwWaitRet != WAIT_OBJECT_0)
	{
		DWORD err_ret = INJ_ERR_WAIT_FAILED;

		if (dwWaitRet == WAIT_FAILED)
		{
			INIT_ERROR_DATA(error_data, GetLastError());
		}
		else
		{
			INIT_ERROR_DATA(error_data, dwWaitRet);
			err_ret = INJ_ERR_WAIT_TIMEOUT;
		}

		LOG(1, "WaitForSingleObject failed: %08X\n", error_data.AdvErrorCode);

		SetEvent(hEventEnd);

		CloseHandle(hEventStart);
		CloseHandle(hEventEnd);

		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);

		return err_ret;
	}

	auto wow64_pid = GetProcessId(pi.hProcess);
	LOG(1, "Successfully spawned wow64 dummy process: %08X (%d)\n", wow64_pid, wow64_pid);

	g_hNTDLL_WOW64		= GetModuleHandleExW_WOW64(pi.hProcess, L"ntdll.dll");
	g_hKERNEL32_WOW64	= GetModuleHandleExW_WOW64(pi.hProcess, L"kernel32.dll");

	if (!g_hNTDLL_WOW64 || !g_hKERNEL32_WOW64)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		if (!g_hNTDLL_WOW64)
		{
			LOG(1, "Failed to get WOW64 ntdll.dll\n");
		}

		if (!g_hKERNEL32_WOW64)
		{
			LOG(1, "Failed to get WOW64 kernel32.dll\n");
		}

		SetEvent(hEventEnd);

		CloseHandle(hEventStart);
		CloseHandle(hEventEnd);

		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);

		return INJ_ERR_WOW64_NTDLL_MISSING;
	}

	LOG(1, "WOW64 kernel32.dll loaded at %08X\n", MDWD(g_hKERNEL32_WOW64));

	bool b_lle	= GetProcAddressEx_WOW64(pi.hProcess, g_hKERNEL32_WOW64, "LoadLibraryExW", WOW64::LoadLibraryExW_WOW64);
	bool b_gle	= GetProcAddressEx_WOW64(pi.hProcess, g_hKERNEL32_WOW64, "GetLastError", WOW64::GetLastError_WOW64);

	SetEvent(hEventEnd);

	CloseHandle(hEventStart);
	CloseHandle(hEventEnd);

	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);

	if (!b_lle || !b_gle)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		if (!b_lle)
		{
			LOG(1, "Failed to resolve WOW64 address of LoadLibrarExW\n");
		}

		if (!b_gle)
		{
			LOG(1, "Failed to resolve WOW64 address of GetLastError\n");
		}

		return INJ_ERR_GET_PROC_ADDRESS_FAIL;
	}

	LOG(1, "LoadLibraryExW = %08X\n", WOW64::LoadLibraryExW_WOW64);
	LOG(1, "GetLastError   = %08X\n", WOW64::GetLastError_WOW64);

	LOG(1, "Waiting for WOW64 symbol parser to finish initialization\n");

	while (sym_ntdll_wow64_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
	{
		if (WaitForSingleObject(g_hInterruptImport, 10) == WAIT_OBJECT_0)
		{
			return INJ_ERR_IMPORT_INTERRUPT;
		}
	}

	LOG(1, "WOW64 ntdll.dll loaded at %08X\n", MDWD(g_hNTDLL_WOW64));

	DWORD sym_ret = sym_ntdll_wow64_ret.get();
	if (sym_ret != SYMBOL_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, sym_ret);

		LOG(1, "WOW64 symbol loading failed: %08X\n", sym_ret);

		return INJ_ERR_SYMBOL_LOAD_FAIL;
	}

	while (!import_handler_ret.valid())
	{
		if (WaitForSingleObject(g_hInterruptImport, 10) == WAIT_OBJECT_0)
		{
			return INJ_ERR_IMPORT_INTERRUPT;
		}
	}

	while (import_handler_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
	{
		if (WaitForSingleObject(g_hInterruptImport, 10) == WAIT_OBJECT_0)
		{
			return INJ_ERR_IMPORT_INTERRUPT;
		}
	}

	sym_ret = sym_parser.Initialize(&sym_ntdll_wow64);
	if (sym_ret != SYMBOL_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, sym_ret);

		LOG(1, "WOW64 symbol parsing failed: %08X\n", sym_ret);

		return INJ_ERR_SYMBOL_PARSE_FAIL;
	}

	LOG(1, "Start loading WOW64 ntdll symbols\n");

	if (LoadSymbolWOW64(S_FUNC(LdrLoadDll)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(LdrUnloadDll)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(LdrpLoadDll)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(LdrGetDllHandleEx)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(LdrGetProcedureAddress)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(memmove)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(RtlZeroMemory)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(RtlAllocateHeap)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(RtlFreeHeap)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	
	if (LoadSymbolWOW64(S_FUNC(RtlAnsiStringToUnicodeString)))		return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(RtlUnicodeStringToAnsiString)))		return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(RtlCompareUnicodeString)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(RtlCompareString)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(NtOpenFile)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(NtReadFile)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(NtSetInformationFile)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(NtQueryInformationFile)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(NtClose)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	
	if (LoadSymbolWOW64(S_FUNC(NtAllocateVirtualMemory)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(NtFreeVirtualMemory)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(NtProtectVirtualMemory)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(NtCreateSection)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(NtMapViewOfSection)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(RtlInsertInvertedFunctionTable)))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(LdrpHandleTlsData)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(LdrLockLoaderLock)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(LdrUnlockLoaderLock)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(RtlAddVectoredExceptionHandler)))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(RtlRemoveVectoredExceptionHandler)))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(NtDelayExecution)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolWOW64(S_FUNC(LdrpHeap)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(LdrpVectorHandlerList)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolWOW64(S_FUNC(LdrpTlsList)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (IsWin11OrGreater() && GetOSBuildVersion() >= g_Win11_22H2)
	{
		if (LoadSymbolWOW64(LdrpInvertedFunctionTable_WOW64, "LdrpInvertedFunctionTables")) return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}
	else
	{
		if (LoadSymbolWOW64(S_FUNC(LdrpInvertedFunctionTable))) return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

	if (GetOSVersion() == g_Win7)
	{
		if (LoadSymbolWOW64(S_FUNC(LdrpDefaultPath)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolWOW64(S_FUNC(RtlpUnhandledExceptionFilter)))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

	if (IsWin8OrGreater())
	{
		if (LoadSymbolWOW64(S_FUNC(LdrGetDllPath)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

		if (LoadSymbolWOW64(S_FUNC(RtlRbRemoveNode)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolWOW64(S_FUNC(LdrpModuleBaseAddressIndex)))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolWOW64(S_FUNC(LdrpMappingInfoIndex)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

	if (IsWin81OrGreater())
	{
		if (LoadSymbolWOW64(S_FUNC(LdrProtectMrdata)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

	if (IsWin10OrGreater())
	{
		if (LoadSymbolWOW64(S_FUNC(LdrpPreprocessDllName)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolWOW64(S_FUNC(LdrpLoadDllInternal)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolWOW64(S_FUNC(LdrpDereferenceModule)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

	sym_ntdll_wow64.Cleanup();

	if (GetOSVersion() == g_Win7)
	{
		while (sym_kernel32_wow64_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
		{
			if (WaitForSingleObject(g_hInterruptImport, 10) == WAIT_OBJECT_0)
			{
				return INJ_ERR_IMPORT_INTERRUPT;
			}
		}

		sym_ret = sym_kernel32_wow64_ret.get();
		if (sym_ret != SYMBOL_ERR_SUCCESS)
		{
			INIT_ERROR_DATA(error_data, sym_ret);

			LOG(1, "WOW64 symbol loading failed: %08X\n", sym_ret);

			return INJ_ERR_SYMBOL_LOAD_FAIL;
		}

		sym_ret = sym_parser.Initialize(&sym_kernel32_wow64);
		if (sym_ret != SYMBOL_ERR_SUCCESS)
		{
			INIT_ERROR_DATA(error_data, sym_ret);

			LOG(1, "WOW64 symbol loading failed: %08X\n", sym_ret);

			return INJ_ERR_SYMBOL_PARSE_FAIL;
		}

		if (LoadSymbolWOW64(S_FUNC(UnhandledExceptionFilter),	IDX_KERNEL32))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolWOW64(S_FUNC(SingleHandler),				IDX_KERNEL32))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolWOW64(S_FUNC(DefaultHandler),				IDX_KERNEL32))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

		sym_kernel32_wow64.Cleanup();

		LOG(1, "WOW64 kernel32 symbols loaded\n");
	}

	sym_parser.Cleanup();

	LOG(1, "WOW64 ntdll symbols loaded\n");

	g_LibraryState = true;

	return INJ_ERR_SUCCESS;
}

HINSTANCE GetModuleHandleExW_WOW64(HANDLE hTargetProc, const wchar_t * lpModuleName)
{
	MODULEENTRY32W ME32{ 0 };
	ME32.dwSize = sizeof(ME32);

	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE32 | TH32CS_SNAPMODULE, GetProcessId(hTargetProc));
	if (hSnap == INVALID_HANDLE_VALUE)
	{
		while (GetLastError() == ERROR_BAD_LENGTH)
		{
			hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE32 | TH32CS_SNAPMODULE, GetProcessId(hTargetProc));

			if (hSnap != INVALID_HANDLE_VALUE)
			{
				break;
			}
		}

		Sleep(5);
	}

	if (hSnap == INVALID_HANDLE_VALUE || !hSnap)
	{
		return NULL;
	}

	BOOL bRet = Module32FirstW(hSnap, &ME32);
	while (bRet)
	{
		if (ME32.modBaseAddr && !_wcsicmp(ME32.szModule, lpModuleName) && (ME32.modBaseAddr < (BYTE *)0x7FFFF000))
		{
			BYTE header[0x1000]{ 0 };
			if (!ReadProcessMemory(hTargetProc, ME32.modBaseAddr, header, sizeof(header), nullptr))
			{
				bRet = Module32NextW(hSnap, &ME32);

				continue;
			}

			IMAGE_DOS_HEADER	* pDos	= ReCa<IMAGE_DOS_HEADER		*>(header);
			IMAGE_NT_HEADERS32	* pNT	= ReCa<IMAGE_NT_HEADERS32	*>(header + pDos->e_lfanew);

			if (pNT->FileHeader.Machine != IMAGE_FILE_MACHINE_I386)
			{
				bRet = Module32NextW(hSnap, &ME32);

				continue;
			}

			break;
		}

		bRet = Module32NextW(hSnap, &ME32);
	}

	CloseHandle(hSnap);

	if (!bRet)
	{
		return NULL;
	}

	return ME32.hModule;
}

bool GetProcAddressExW_WOW64(HANDLE hTargetProc, const wchar_t * szModuleName, const char * szProcName, DWORD &pOut)
{
	return GetProcAddressEx_WOW64(hTargetProc, GetModuleHandleExW_WOW64(hTargetProc, szModuleName), szProcName, pOut);
}

bool GetProcAddressEx_WOW64(HANDLE hTargetProc, HINSTANCE hModule, const char * szProcName, DWORD &pOut)
{
	BYTE * modBase = ReCa<BYTE *>(hModule);

	if (!modBase)
	{
		return false;
	}

	BYTE * pBuffer = new(std::nothrow) BYTE[0x1000];
	if (!pBuffer)
	{
		return false;
	}

	if (!ReadProcessMemory(hTargetProc, modBase, pBuffer, 0x1000, nullptr))
	{
		delete[] pBuffer;

		return false;
	}

	auto * pNT = ReCa<IMAGE_NT_HEADERS32*>(ReCa<IMAGE_DOS_HEADER *>(pBuffer)->e_lfanew + pBuffer);
	auto * pDir = &pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

	auto ExportSize = pDir->Size;
	auto DirRVA		= pDir->VirtualAddress;

	if (!ExportSize)
	{
		delete[] pBuffer;

		return false;
	}

	BYTE * pExpDirBuffer = new(std::nothrow) BYTE[ExportSize];
	auto * pExportDir = ReCa<IMAGE_EXPORT_DIRECTORY *>(pExpDirBuffer);

	if (!pExpDirBuffer)
	{
		delete[] pBuffer;

		return false;
	}

	if (!ReadProcessMemory(hTargetProc, modBase + DirRVA, pExpDirBuffer, ExportSize, nullptr))
	{
		delete[] pExpDirBuffer;
		delete[] pBuffer;

		return false;
	}

	BYTE * pBase = pExpDirBuffer - DirRVA;

	auto Forward = [&](DWORD FuncRVA, DWORD &pForwarded) -> bool
	{		
		std::string FullExport = ReCa<char *>(pBase + FuncRVA);

		auto PosSplitter = FullExport.find('.');
		if (PosSplitter == std::string::npos)
		{
			return false;
		}

		bool IsOrdinal	= false;
		WORD Ordinal	= 0;

		std::string FuncName = FullExport.substr(PosSplitter + 1);
		if (FuncName[0] == '#')
		{
			IsOrdinal	= true;
			Ordinal		= LOWORD(atoi(FuncName.substr(1).c_str()));
		}
		
		auto ModName	= FullExport.substr(0, PosSplitter);
		auto ModNameW	= CharArrayToStdWstring(ModName.c_str());

		if (IsOrdinal)
		{
			return GetProcAddressExW_WOW64(hTargetProc, ModNameW.c_str(), ReCa<char *>(Ordinal), pForwarded);
		}
		else
		{
			return GetProcAddressExW_WOW64(hTargetProc, ModNameW.c_str(), FuncName.c_str(), pForwarded);
		}
	};

	if (ReCa<ULONG_PTR>(szProcName) <= MAXWORD)
	{
		WORD Base		= LOWORD(pExportDir->Base - 1);
		WORD Ordinal	= LOWORD(szProcName) - Base;
		DWORD FuncRVA	= ReCa<DWORD *>(pBase + pExportDir->AddressOfFunctions)[Ordinal];

		delete[] pExpDirBuffer;
		delete[] pBuffer;

		if (FuncRVA >= DirRVA && FuncRVA < DirRVA + ExportSize)
		{
			return Forward(FuncRVA, pOut);
		}
			
		pOut = MDWD(modBase) + FuncRVA;
		
		return true;
	}

	DWORD max		= pExportDir->NumberOfNames - 1;
	DWORD min		= 0;
	DWORD FuncRVA	= 0;

	while (min <= max)
	{
		DWORD mid = (min + max) / 2;

		DWORD CurrNameRVA	= ReCa<DWORD *>(pBase + pExportDir->AddressOfNames)[mid];
		char * szName		= ReCa<char *>(pBase + CurrNameRVA);

		int cmp = strcmp(szName, szProcName);
		if (cmp < 0)
		{
			min = mid + 1;
		}
		else if (cmp > 0)
		{
			max = mid - 1;
		}
		else 
		{
			WORD Ordinal = ReCa<WORD *>(pBase + pExportDir->AddressOfNameOrdinals)[mid];
			FuncRVA = ReCa<DWORD *>(pBase + pExportDir->AddressOfFunctions)[Ordinal];

			break;
		}
	}
	
	delete[] pExpDirBuffer;
	delete[] pBuffer;

	if (!FuncRVA)
	{
		return false;
	}

	if (FuncRVA >= DirRVA && FuncRVA < DirRVA + ExportSize)
	{
		return Forward(FuncRVA, pOut);
	}

	pOut = MDWD(modBase) + FuncRVA;

	return true;
}

#endif
```

`GH Injector Library/Import Handler.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Import Handler.h"

using namespace NATIVE;

#define S_FUNC(f) NATIVE::f, #f

template <typename T>
DWORD LoadSymbolNative(T & Function, const char * szFunction, int index = IDX_NTDLL)
{
	DWORD RVA = 0;
	DWORD sym_ret = 0;
	T out = nullptr;

	sym_ret = sym_parser.GetSymbolAddress(szFunction, RVA);

	if (sym_ret != SYMBOL_ERR_SUCCESS)
	{
		LOG(1, "Failed to load native function: %s\n", szFunction);

		return 0;
	}

	switch (index)
	{
		case IDX_NTDLL:
			out = ReCa<T>(ReCa<UINT_PTR>(g_hNTDLL) + RVA);
			break;

		case IDX_KERNEL32:
			out = ReCa<T>(ReCa<UINT_PTR>(g_hKERNEL32) + RVA);
			break;

		default:
			LOG(1, "Invalid symbol index specified. Failed to load native function: %s\n", szFunction);
			return 0;
	}

	Function = out;

	return INJ_ERR_SUCCESS;
}

DWORD ResolveImports(ERROR_DATA & error_data)
{
	LOG(1, "ResolveImports called\n");

	DWORD err = ERROR_SUCCESS;
	if (!GetOSVersion(&err))
	{
		INIT_ERROR_DATA(error_data, err);

		LOG(1, "Failed to determine Windows version\n");

		return INJ_ERR_WINDOWS_VERSION;
	}

	if (GetOSVersion() < g_Win7)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "This Windows version is not supported\n");

		return INJ_ERR_WINDOWS_TOO_OLD;
	}

	g_hNTDLL	= GetModuleHandle(TEXT("ntdll.dll"));
	g_hKERNEL32 = GetModuleHandle(TEXT("kernel32.dll"));

	LOG(1, "ntdll.dll    loaded at %p\n", g_hNTDLL);
	LOG(1, "kernel32.dll loaded at %p\n", g_hKERNEL32);
	LOG(1, "OSVersion = %d\nOSBuildVersion = %d\n", GetOSVersion(), GetOSBuildVersion());

	HINSTANCE hK32 = GetModuleHandle(TEXT("kernel32.dll"));
	if (!hK32)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "GetModuleHandle failed: %08X\n", error_data.AdvErrorCode);

		return INJ_ERR_KERNEL32_MISSING;
	}

	WIN32_FUNC_INIT(LoadLibraryA, hK32);
	WIN32_FUNC_INIT(LoadLibraryW, hK32);
	WIN32_FUNC_INIT(LoadLibraryExA, hK32);
	WIN32_FUNC_INIT(LoadLibraryExW, hK32);

	WIN32_FUNC_INIT(GetModuleHandleA, hK32);
	WIN32_FUNC_INIT(GetModuleHandleW, hK32);
	WIN32_FUNC_INIT(GetModuleHandleExA, hK32);
	WIN32_FUNC_INIT(GetModuleHandleExW, hK32);

	WIN32_FUNC_INIT(GetModuleFileNameA, hK32);
	WIN32_FUNC_INIT(GetModuleFileNameW, hK32);

	WIN32_FUNC_INIT(GetProcAddress, hK32);

	WIN32_FUNC_INIT(DisableThreadLibraryCalls, hK32);
	WIN32_FUNC_INIT(FreeLibrary, hK32);
	WIN32_FUNC_INIT(FreeLibraryAndExitThread, hK32);
	WIN32_FUNC_INIT(ExitThread, hK32);

	WIN32_FUNC_INIT(GetLastError, hK32);

	if (!NATIVE::pLoadLibraryExW || !NATIVE::pGetLastError)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "GetProcAddress failed: %08X\n", error_data.AdvErrorCode);

		return INJ_ERR_GET_PROC_ADDRESS_FAIL;
	}

	LOG(1, "Waiting for native symbol parser to finish initialization\n");

	while (sym_ntdll_native_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
	{
		if (WaitForSingleObject(g_hInterruptImport, 10) == WAIT_OBJECT_0)
		{
			return INJ_ERR_IMPORT_INTERRUPT;
		}
	}
	
	DWORD sym_ret = sym_ntdll_native_ret.get();
	if (sym_ret != SYMBOL_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, sym_ret);

		LOG(1, "Native symbol loading failed: %08X\n", sym_ret);

		return INJ_ERR_SYMBOL_LOAD_FAIL;
	}

	sym_ret = sym_parser.Initialize(&sym_ntdll_native);
	if (sym_ret != SYMBOL_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, sym_ret);

		LOG(1, "Native symbol parsing failed: %08X\n", sym_ret);

		return INJ_ERR_SYMBOL_PARSE_FAIL;
	}

	LOG(1, "LoadLibraryExW: %p\n", &LoadLibraryExW);

	LOG(1, "Start loading native ntdll symbols\n");

	if (LoadSymbolNative(S_FUNC(LdrLoadDll)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(LdrUnloadDll)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(LdrpLoadDll)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(LdrGetDllHandleEx)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(LdrGetProcedureAddress)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(NtQueryInformationProcess)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(NtQuerySystemInformation)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(NtQueryInformationThread)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(memmove)))								return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED; //I hate compilers
	if (LoadSymbolNative(S_FUNC(RtlZeroMemory)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(RtlAllocateHeap)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(RtlFreeHeap)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(RtlAnsiStringToUnicodeString)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED; 
	if (LoadSymbolNative(S_FUNC(RtlUnicodeStringToAnsiString)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(RtlCompareUnicodeString)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(RtlCompareString)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	
	if (LoadSymbolNative(S_FUNC(NtOpenFile)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(NtReadFile)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(NtSetInformationFile)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(NtQueryInformationFile)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(NtClose)))								return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(NtAllocateVirtualMemory)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(NtFreeVirtualMemory)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(NtProtectVirtualMemory)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(NtCreateSection)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(NtMapViewOfSection)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(NtCreateThreadEx)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(RtlQueueApcWow64Thread)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(RtlInsertInvertedFunctionTable)))		return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(LdrpHandleTlsData)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(LdrLockLoaderLock)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(LdrUnlockLoaderLock)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(RtlAddVectoredExceptionHandler)))		return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(RtlRemoveVectoredExceptionHandler)))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(NtDelayExecution)))						return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

	if (LoadSymbolNative(S_FUNC(LdrpHeap)))								return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(LdrpVectorHandlerList)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	if (LoadSymbolNative(S_FUNC(LdrpTlsList)))							return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	
	if (IsWin11OrGreater() && GetOSBuildVersion() >= g_Win11_22H2)
	{
		if (LoadSymbolNative(LdrpInvertedFunctionTable, "LdrpInvertedFunctionTables")) return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}
	else
	{
		if (LoadSymbolNative(S_FUNC(LdrpInvertedFunctionTable))) return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

	if (GetOSVersion() == g_Win7)
	{
		if (LoadSymbolNative(S_FUNC(LdrpDefaultPath)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolNative(S_FUNC(RtlpUnhandledExceptionFilter)))		return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

	if (IsWin8OrGreater())
	{
		if (LoadSymbolNative(S_FUNC(LdrGetDllPath)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

		if (LoadSymbolNative(S_FUNC(RtlRbRemoveNode)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolNative(S_FUNC(LdrpModuleBaseAddressIndex)))		return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolNative(S_FUNC(LdrpMappingInfoIndex)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

	if (IsWin81OrGreater())
	{
		if (LoadSymbolNative(S_FUNC(LdrProtectMrdata)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

	if (IsWin10OrGreater())
	{
		if (LoadSymbolNative(S_FUNC(LdrpPreprocessDllName)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolNative(S_FUNC(LdrpLoadDllInternal)))				return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolNative(S_FUNC(LdrpDereferenceModule)))			return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
	}

#ifdef _WIN64
	if (LoadSymbolNative(S_FUNC(RtlAddFunctionTable)))					return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
#endif

	sym_ntdll_native.Cleanup();

	if (GetOSVersion() == g_Win7)
	{
		while (sym_kernel32_native_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
		{
			if (WaitForSingleObject(g_hInterruptImport, 10) == WAIT_OBJECT_0)
			{
				return INJ_ERR_IMPORT_INTERRUPT;
			}
		}
	
		sym_ret = sym_kernel32_native_ret.get();
		if (sym_ret != SYMBOL_ERR_SUCCESS)
		{
			INIT_ERROR_DATA(error_data, sym_ret);

			LOG(1, "Native symbol loading failed: %08X\n", sym_ret);

			return INJ_ERR_SYMBOL_LOAD_FAIL;
		}

		sym_ret = sym_parser.Initialize(&sym_kernel32_native);
		if (sym_ret != SYMBOL_ERR_SUCCESS)
		{
			INIT_ERROR_DATA(error_data, sym_ret);

			LOG(1, "Native symbol parsing failed: %08X\n", sym_ret);

			return INJ_ERR_SYMBOL_PARSE_FAIL;
		}

		if (LoadSymbolNative(S_FUNC(UnhandledExceptionFilter),	IDX_KERNEL32))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolNative(S_FUNC(SingleHandler),				IDX_KERNEL32))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;
		if (LoadSymbolNative(S_FUNC(DefaultHandler),			IDX_KERNEL32))	return INJ_ERR_GET_SYMBOL_ADDRESS_FAILED;

		sym_kernel32_native.Cleanup();

		LOG(1, "Native kernel32 symbols loaded\n");
	}

	LOG(1, "Native ntdll symbols loaded\n");

#ifndef _WIN64
	sym_parser.Cleanup();

	g_LibraryState = true; //on x64 ResolveImports_WOW64 will update g_LibraryState and free parser resources
#endif

	return INJ_ERR_SUCCESS;
}
```

`GH Injector Library/Import Handler.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "NT Funcs.h"
#include "Symbol Parser.h"
#include "Tools.h"

inline HANDLE g_hRunningEvent		= nullptr;
inline HANDLE g_hInterruptEvent		= nullptr;
inline HANDLE g_hInterruptedEvent	= nullptr;
inline HANDLE g_hInterruptImport	= nullptr;

inline ERROR_DATA					import_handler_error_data;
inline std::shared_future<DWORD>	import_handler_ret;

#ifdef _WIN64
inline ERROR_DATA					import_handler_wow64_error_data;
inline std::shared_future<DWORD>	import_handler_wow64_ret;
#endif

//Macros for import definitions

#define NT_FUNC(func) inline f_##func func = nullptr
#define NT_FUNC_LOCAL(func) f_##func func
#define NT_FUNC_CONSTRUCTOR_INIT(func) this->func = NATIVE::func

#define WIN32_FUNC(func) inline decltype(func) * p##func = nullptr
#define WIN32_FUNC_LOCAL(func) decltype(func) * p##func
#define WIN32_FUNC_INIT(func, lib) NATIVE::p##func = ReCa<decltype(func) *>(GetProcAddress(lib, #func));
#define WIN32_FUNC_CONSTRUCTOR_INIT(func) this->p##func = NATIVE::p##func

#define K32_FUNC(func) inline f_##func func = nullptr
#define K32_FUNC_LOCAL(func) f_##func func
#define K32_FUNC_CONSTRUCTOR_INIT(func) this->func = NATIVE::func

#define WOW64_FUNCTION_POINTER(func) inline DWORD func##_WOW64 = 0
#define WOW64_FUNCTION_POINTER_LOCAL(func) DWORD func = 0
#define WOW64_FUNC_CONSTRUCTOR_INIT(func) this->func = WOW64::func##_WOW64

#define IDX_NTDLL		0
#define IDX_KERNEL32	1

//Command line codes for "GH Injector SM - XX.exe"

#define ID_SWHEX	"0" //use for SetWindowsHookEx
#define ID_WOW64	"1" //use for wow64 addresses
#define ID_KC		"2" //use for KernelCallbackTable

namespace NATIVE
{
	WIN32_FUNC(LoadLibraryA);
	WIN32_FUNC(LoadLibraryW);
	WIN32_FUNC(LoadLibraryExA);
	WIN32_FUNC(LoadLibraryExW);

	WIN32_FUNC(GetModuleHandleA);
	WIN32_FUNC(GetModuleHandleW);
	WIN32_FUNC(GetModuleHandleExA);
	WIN32_FUNC(GetModuleHandleExW);

	WIN32_FUNC(GetModuleFileNameA);
	WIN32_FUNC(GetModuleFileNameW);

	WIN32_FUNC(GetProcAddress);

	WIN32_FUNC(DisableThreadLibraryCalls);
	WIN32_FUNC(FreeLibrary);
	WIN32_FUNC(FreeLibraryAndExitThread);
	WIN32_FUNC(ExitThread);

	WIN32_FUNC(GetLastError);

	NT_FUNC(LdrLoadDll);
	NT_FUNC(LdrUnloadDll);

	NT_FUNC(LdrpLoadDll);
	NT_FUNC(LdrpLoadDllInternal);

	NT_FUNC(LdrGetDllHandleEx);
	NT_FUNC(LdrGetProcedureAddress);

	NT_FUNC(NtCreateThreadEx);
	NT_FUNC(RtlQueueApcWow64Thread);

	NT_FUNC(NtQueryInformationProcess);
	NT_FUNC(NtQuerySystemInformation);
	NT_FUNC(NtQueryInformationThread);

	NT_FUNC(LdrGetDllPath);
	NT_FUNC(LdrpPreprocessDllName);
	NT_FUNC(RtlInsertInvertedFunctionTable);
	NT_FUNC(LdrpHandleTlsData);

	NT_FUNC(LdrLockLoaderLock);
	NT_FUNC(LdrUnlockLoaderLock);

	NT_FUNC(LdrpDereferenceModule);

	NT_FUNC(memmove);
	NT_FUNC(RtlZeroMemory);
	NT_FUNC(RtlAllocateHeap);
	NT_FUNC(RtlFreeHeap);

	NT_FUNC(RtlAnsiStringToUnicodeString);
	NT_FUNC(RtlUnicodeStringToAnsiString);
	NT_FUNC(RtlCompareUnicodeString);
	NT_FUNC(RtlCompareString);

	NT_FUNC(RtlRbInsertNodeEx);
	NT_FUNC(RtlRbRemoveNode);

	NT_FUNC(NtOpenFile);
	NT_FUNC(NtReadFile);
	NT_FUNC(NtSetInformationFile);
	NT_FUNC(NtQueryInformationFile);

	NT_FUNC(NtClose);

	NT_FUNC(NtAllocateVirtualMemory);
	NT_FUNC(NtFreeVirtualMemory);
	NT_FUNC(NtProtectVirtualMemory);

	NT_FUNC(NtCreateSection);
	NT_FUNC(NtMapViewOfSection);

	NT_FUNC(LdrProtectMrdata);

	NT_FUNC(RtlAddVectoredExceptionHandler);
	NT_FUNC(RtlRemoveVectoredExceptionHandler);

	NT_FUNC(NtDelayExecution);

	NT_FUNC(LdrpModuleBaseAddressIndex);
	NT_FUNC(LdrpMappingInfoIndex);
	NT_FUNC(LdrpHeap);
	NT_FUNC(LdrpInvertedFunctionTable);
	NT_FUNC(LdrpDefaultPath);
	NT_FUNC(LdrpVectorHandlerList);
	NT_FUNC(LdrpTlsList);

	NT_FUNC(RtlpUnhandledExceptionFilter);
	K32_FUNC(UnhandledExceptionFilter);
	K32_FUNC(SingleHandler);
	K32_FUNC(DefaultHandler);

#ifdef _WIN64
	NT_FUNC(RtlAddFunctionTable);
#endif
}

DWORD ResolveImports(ERROR_DATA & error_data);
//Resolves the addresses of all the required functions (see the NATIVE namespace) using the ntdll.pdb file.
//
//Arguments:
//		error_data (ERROR_DATA &):
///			A reference to an ERROR_DATA structure which will contain information if the function fails.
//
//Returnvalue (DWORD):
///		On success: INJ_ERR_SUCCESS (0)
///		On failure: An error code. See Error.h.

#ifdef _WIN64

namespace WOW64
{
	WOW64_FUNCTION_POINTER(LoadLibraryExW);
	WOW64_FUNCTION_POINTER(GetLastError);
		
	WOW64_FUNCTION_POINTER(LdrLoadDll);
	WOW64_FUNCTION_POINTER(LdrUnloadDll);

	WOW64_FUNCTION_POINTER(LdrpLoadDll);
	WOW64_FUNCTION_POINTER(LdrpLoadDllInternal);

	WOW64_FUNCTION_POINTER(LdrGetDllHandleEx);
	WOW64_FUNCTION_POINTER(LdrGetProcedureAddress);

	WOW64_FUNCTION_POINTER(NtCreateThreadEx);
	WOW64_FUNCTION_POINTER(RtlQueueApcWow64Thread);

	WOW64_FUNCTION_POINTER(NtQueryInformationProcess);
	WOW64_FUNCTION_POINTER(NtQuerySystemInformation);
	WOW64_FUNCTION_POINTER(NtQueryInformationThread);

	WOW64_FUNCTION_POINTER(LdrGetDllPath);
	WOW64_FUNCTION_POINTER(LdrpPreprocessDllName);
	WOW64_FUNCTION_POINTER(RtlInsertInvertedFunctionTable);
	WOW64_FUNCTION_POINTER(LdrpHandleTlsData);

	WOW64_FUNCTION_POINTER(LdrLockLoaderLock);
	WOW64_FUNCTION_POINTER(LdrUnlockLoaderLock);

	WOW64_FUNCTION_POINTER(LdrpDereferenceModule);

	WOW64_FUNCTION_POINTER(memmove);
	WOW64_FUNCTION_POINTER(RtlZeroMemory);
	WOW64_FUNCTION_POINTER(RtlAllocateHeap);
	WOW64_FUNCTION_POINTER(RtlFreeHeap);

	WOW64_FUNCTION_POINTER(RtlAnsiStringToUnicodeString);
	WOW64_FUNCTION_POINTER(RtlUnicodeStringToAnsiString);
	WOW64_FUNCTION_POINTER(RtlCompareUnicodeString);
	WOW64_FUNCTION_POINTER(RtlCompareString);

	WOW64_FUNCTION_POINTER(RtlRbRemoveNode);

	WOW64_FUNCTION_POINTER(NtOpenFile);
	WOW64_FUNCTION_POINTER(NtReadFile);
	WOW64_FUNCTION_POINTER(NtSetInformationFile);
	WOW64_FUNCTION_POINTER(NtQueryInformationFile);

	WOW64_FUNCTION_POINTER(NtClose);

	WOW64_FUNCTION_POINTER(NtAllocateVirtualMemory);
	WOW64_FUNCTION_POINTER(NtFreeVirtualMemory);
	WOW64_FUNCTION_POINTER(NtProtectVirtualMemory);

	WOW64_FUNCTION_POINTER(NtCreateSection);
	WOW64_FUNCTION_POINTER(NtMapViewOfSection);

	WOW64_FUNCTION_POINTER(LdrProtectMrdata);

	WOW64_FUNCTION_POINTER(RtlAddVectoredExceptionHandler);
	WOW64_FUNCTION_POINTER(RtlRemoveVectoredExceptionHandler);

	WOW64_FUNCTION_POINTER(NtDelayExecution);

	WOW64_FUNCTION_POINTER(LdrpModuleBaseAddressIndex);
	WOW64_FUNCTION_POINTER(LdrpMappingInfoIndex);
	WOW64_FUNCTION_POINTER(LdrpHeap);
	WOW64_FUNCTION_POINTER(LdrpInvertedFunctionTable);
	WOW64_FUNCTION_POINTER(LdrpDefaultPath);
	WOW64_FUNCTION_POINTER(LdrpVectorHandlerList);
	WOW64_FUNCTION_POINTER(LdrpTlsList);

	WOW64_FUNCTION_POINTER(RtlpUnhandledExceptionFilter);
	WOW64_FUNCTION_POINTER(UnhandledExceptionFilter);
	WOW64_FUNCTION_POINTER(SingleHandler);
	WOW64_FUNCTION_POINTER(DefaultHandler);
}

DWORD ResolveImports_WOW64(ERROR_DATA & error_data);
//Resolves the addresses of all the required wow64 functions (see the WOW64 namespace) using the wntdll.pdb file.
//
//Arguments:
//		error_data (ERROR_DATA &):
///			A reference to an ERROR_DATA structure which will contain information if the function fails.
//
//Returnvalue (DWORD):
///		On success: INJ_ERR_SUCCESS (0)
///		On failure: An error code. See Error.h.

HINSTANCE GetModuleHandleExW_WOW64(HANDLE hTargetProc, const wchar_t * lpModuleName);
//Uses CreateToolHelp32Snapshot and Module32First/Next to retrieve the baseaddress of an image.
//Only scans WOW64 modules of a process.
//
//Arguments:
//		hTargetProc (HANDLE):
///			A handle to the target process with PROCESS_VM_READ and PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION.
//		szModuleName (const wchar_t *):
///			The name of the module including the file extension.
//
//Returnvalue (HINSTANCE):
///		On success: base address of the image.
///		On failure: NULL.

bool GetProcAddressExW_WOW64(HANDLE hTargetProc, const wchar_t * szModuleName, const char * szProcName, DWORD &pOut);
//A function which tries to get the address of a function by parsing the export directory of the specified module.
//(WOW64 compatible version of GetProcAddressEx)
//
//Arguments:
//		hTargetProc (HANDLE):
///			A handle to the target process with PROCESS_VM_READ and PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION.
//		szModuleName (const wchar_t *):
///			The name of the module including the file extension.
//		szProcName (const char *):
///			The name of the function as an ansi string.
//		pOut (DWORD &):
///			A reference to a wow64 pointer that (on success) will contain the pointer to the function in the specified target process.
//
//Returnvalue (bool):
///		true:	pOut now contains the address of the function.
///		false:	something went wrong.

bool GetProcAddressEx_WOW64(HANDLE hTargetProc, HINSTANCE hModule, const char * szProcName, DWORD &pOut);
//Same as other GetProcAddressExW_WOW64 overload but modulebase provided instead of modulename. For performance boost only.

#endif

//For internal usage only:
#ifdef __cplusplus
extern "C"
{
	__declspec(dllexport) inline extern bool g_LibraryState = false;
}
#endif
```

`GH Injector Library/Injection Generic WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Injection Internal.h"
#include "WOW64 Shells.h"

using namespace WOW64;

DWORD InjectDLL_WOW64(const INJECTION_SOURCE & Source, HANDLE hTargetProc, INJECTION_MODE Mode, LAUNCH_METHOD Method, DWORD Flags, HINSTANCE & hOut, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(1, "Begin InjectDLL_WOW64\n");

	if (Mode == INJECTION_MODE::IM_ManualMap)
	{
		LOG(1, "Forwarding call to ManualMap_WOW64\n");

		return MMAP_WOW64::ManualMap_WOW64(Source, hTargetProc, Method, Flags, hOut, Timeout, error_data);
	}

	INJECTION_DATA_MAPPED_WOW64 data{ 0 };
	data.Flags			= Flags;
	data.Mode			= Mode;
	data.OSVersion		= GetOSVersion();
	data.OSBuildNumber	= GetOSBuildVersion();

	size_t len = Source.DllPath.length();
	size_t max_len = sizeof(data.Path) / sizeof(wchar_t);
	if (len > max_len)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "Path too long: %d characters, buffer size: %d\n", len, max_len);

		return INJ_ERR_STRING_TOO_LONG;
	}
		
	data.ModuleFileName.Length		= (WORD)(len * sizeof(wchar_t));
	data.ModuleFileName.MaxLength	= (WORD)sizeof(data.Path);
	Source.DllPath.copy(data.Path, Source.DllPath.length());

	LOG(1, "Shell data initialized\n");

	ULONG_PTR ShellSize		= sizeof(InjectionShell_WOW64);
	ULONG_PTR VEHShellSize	= sizeof(VectoredHandlerShell_WOW64);

	if (!(Flags & INJ_UNLINK_FROM_PEB))
	{
		VEHShellSize = 0;
	}

	SIZE_T AllocationSize	= sizeof(INJECTION_DATA_MAPPED_WOW64) + ShellSize + BASE_ALIGNMENT;
	BYTE * pAllocBase = ReCa<BYTE *>(VirtualAllocEx(hTargetProc, nullptr, AllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
	
	BYTE * pArg			= pAllocBase;
	BYTE * pShell		= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pArg + sizeof(INJECTION_DATA_MAPPED_WOW64)), BASE_ALIGNMENT));
	BYTE * pVEHShell	= nullptr;

	if (!pArg)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return INJ_ERR_OUT_OF_MEMORY_EXT;
	}

	if (VEHShellSize)
	{
		pVEHShell = ReCa<BYTE *>(VirtualAllocEx(hTargetProc, nullptr, VEHShellSize + sizeof(VEH_SHELL_DATA) + BASE_ALIGNMENT, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
		//VEH_SHELL_DATA is bigger than the wow64 version of it, no need to define it, will be filled using wow64 anyway

		if (!pVEHShell)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

			return INJ_ERR_OUT_OF_MEMORY_EXT;
		}

		data.pVEHShell		= MDWD(pVEHShell);
		data.VEHShellSize	= MDWD(VEHShellSize);
	}

	LOG(2, "Shellsize	= %08X\n", MDWD(ShellSize));
	LOG(2, "Total size	= %08X\n", MDWD(AllocationSize));
	LOG(2, "pArg        = %08X\n", MDWD(pArg));
	LOG(2, "pShell      = %08X\n", MDWD(pShell));

	if (VEHShellSize)
	{
		LOG(2, "pVEHShell   = %08X\n", MDWD(pVEHShell));
	}

	if (!WriteProcessMemory(hTargetProc, pArg, &data, sizeof(INJECTION_DATA_MAPPED_WOW64), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		if (pVEHShell)
		{
			VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
		}

		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	if (!WriteProcessMemory(hTargetProc, pShell, InjectionShell_WOW64, ShellSize, nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		if (pVEHShell)
		{
			VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
		}

		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	LOG(1, "Shell written to memory\n");

	if (VEHShellSize)
	{
		if (!WriteProcessMemory(hTargetProc, pVEHShell, VectoredHandlerShell, VEHShellSize, nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			if (pVEHShell)
			{
				VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
			}

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

			return INJ_ERR_WPM_FAIL;
		}

		LOG(1, "VEHShell written to memory\n");
	}

	LOG(1, "Entering StartRoutine_WOW64\n");

	if (Flags & INJ_THREAD_CREATE_CLOAKED)
	{
		Flags |= (INJ_CTF_FAKE_START_ADDRESS | INJ_CTF_HIDE_FROM_DEBUGGER);
	}

	DWORD remote_ret = 0;
	DWORD dwRet = StartRoutine_WOW64(hTargetProc, (f_Routine_WOW64)(MDWD(pShell)), MDWD(pArg), Method, Flags, remote_ret, Timeout, error_data);

	LOG(1, "Return from StartRoutine_WOW64\n");

	if (dwRet != SR_ERR_SUCCESS)
	{
		LOG(1, "StartRoutine_WOW64 failed: %08X\n", dwRet);

		if (Method != LAUNCH_METHOD::LM_QueueUserAPC && !(Method == LAUNCH_METHOD::LM_HijackThread && dwRet == SR_HT_ERR_REMOTE_TIMEOUT))
		{
			if (pVEHShell)
			{
				VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
			}

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
		}

		return dwRet;
	}

	LOG(1, "Fetching routine data\n");

	if (!ReadProcessMemory(hTargetProc, pArg, &data, sizeof(INJECTION_DATA_MAPPED_WOW64), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		if (Method != LAUNCH_METHOD::LM_QueueUserAPC)
		{
			if (pVEHShell)
			{
				VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
			}

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
		}

		return INJ_ERR_VERIFY_RESULT_FAIL;
	}

	if (Method != LAUNCH_METHOD::LM_QueueUserAPC)
	{
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
	}

	if (remote_ret != INJ_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, data.LastError);

		LOG(1, "Shell failed: %08X\n", remote_ret);

		return remote_ret;
	}

	if (!data.hRet)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "Shell failed\n");

		return INJ_ERR_FAILED_TO_LOAD_DLL;
	}

	LOG(1, "Shell returned successfully\n");

	hOut = ReCa<HINSTANCE>(MPTR(data.hRet));

	LOG(1, "Imagebase = %p\n", ReCa<void *>(hOut));

	return INJ_ERR_SUCCESS;
}

INJECTION_FUNCTION_TABLE_WOW64::INJECTION_FUNCTION_TABLE_WOW64()
{
	WOW64_FUNC_CONSTRUCTOR_INIT(LoadLibraryExW);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrLoadDll);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpLoadDll);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpLoadDllInternal);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpPreprocessDllName);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpDereferenceModule);

	WOW64_FUNC_CONSTRUCTOR_INIT(GetLastError);

	WOW64_FUNC_CONSTRUCTOR_INIT(memmove);
	WOW64_FUNC_CONSTRUCTOR_INIT(RtlZeroMemory);

	WOW64_FUNC_CONSTRUCTOR_INIT(RtlRbRemoveNode);

	WOW64_FUNC_CONSTRUCTOR_INIT(NtProtectVirtualMemory);

	WOW64_FUNC_CONSTRUCTOR_INIT(RtlAddVectoredExceptionHandler);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrProtectMrdata);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpInvertedFunctionTable);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpModuleBaseAddressIndex);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpMappingInfoIndex);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpDefaultPath);
}

#endif
```

`GH Injector Library/Injection Generic.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Injection Internal.h"

#define UNLINK_IF(e)			\
if (e.Flink && e.Blink)			\
{								\
	e.Flink->Blink = e.Blink;	\
	e.Blink->Flink = e.Flink;	\
}

using namespace NATIVE;

DWORD __declspec(code_seg(".inj_sec$1")) __stdcall InjectionShell(INJECTION_DATA_MAPPED * pData);
DWORD __declspec(code_seg(".inj_sec$2")) INJ_SEC_END();

DWORD InjectDLL(const INJECTION_SOURCE & Source, HANDLE hTargetProc, INJECTION_MODE Mode, LAUNCH_METHOD Method, DWORD Flags, HINSTANCE & hOut, DWORD Timeout, ERROR_DATA & error_data)
{
#if !defined(_WIN64) && defined (DUMP_SHELLCODE)
	DUMP_WOW64(InjectionShell, INJ_SEC_END);

	return INJ_ERR_SHELLCODE_DUMPED;
#endif

	LOG(1, "Begin InjectDll\n");

	if (Mode == INJECTION_MODE::IM_ManualMap)
	{
		LOG(1, "Forwarding call to ManualMap\n");

		return MMAP_NATIVE::ManualMap(Source, hTargetProc, Method, Flags, hOut, Timeout, error_data);
	}

	INJECTION_DATA_MAPPED data{ 0 };
	data.Flags			= Flags;
	data.Mode			= Mode;
	data.OSVersion		= GetOSVersion();
	data.OSBuildNumber	= GetOSBuildVersion();

	size_t len = Source.DllPath.length();
	size_t max_len = sizeof(data.Path) / sizeof(wchar_t);
	if (len > max_len)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "Path too long: %d characters, buffer size: %d\n", len, max_len);

		return INJ_ERR_STRING_TOO_LONG;
	}
		
	data.ModuleFileName.Length		= (WORD)(len * sizeof(wchar_t));
	data.ModuleFileName.MaxLength	= (WORD)sizeof(data.Path);
	Source.DllPath.copy(data.Path, Source.DllPath.length());

	LOG(1, "Shell data initialized\n");

	ULONG_PTR ShellSize		= ReCa<ULONG_PTR>(INJ_SEC_END) - ReCa<ULONG_PTR>(InjectionShell);
	ULONG_PTR VEHShellSize	= ReCa<ULONG_PTR>(VEH_SEC_END) - ReCa<ULONG_PTR>(VectoredHandlerShell);

	if (!(Flags & INJ_UNLINK_FROM_PEB))
	{
		VEHShellSize = 0;
	}

	SIZE_T AllocationSize	= sizeof(INJECTION_DATA_MAPPED) + ShellSize + BASE_ALIGNMENT;
	BYTE * pAllocBase		= ReCa<BYTE *>(VirtualAllocEx(hTargetProc, nullptr, AllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));

	BYTE * pArg			= pAllocBase;
	BYTE * pShell		= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pArg) + sizeof(INJECTION_DATA_MAPPED), BASE_ALIGNMENT));
	BYTE * pVEHShell	= nullptr;

	if (!pArg)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return INJ_ERR_OUT_OF_MEMORY_EXT;
	}

	if(VEHShellSize)
	{
		pVEHShell = ReCa<BYTE *>(VirtualAllocEx(hTargetProc, nullptr, VEHShellSize + sizeof(VEH_SHELL_DATA) + BASE_ALIGNMENT, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));

		if (!pVEHShell)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

			return INJ_ERR_OUT_OF_MEMORY_EXT;
		}

		data.pVEHShell		= pVEHShell;
		data.VEHShellSize	= MDWD(VEHShellSize);
	}	

	LOG(2, "Shellsize  = %08X\n", MDWD(ShellSize));
	LOG(2, "Total size = %08X\n", MDWD(AllocationSize));
	LOG(2, "pArg       = %p\n", pArg);
	LOG(2, "pShell     = %p\n", pShell);

	if (VEHShellSize)
	{
		LOG(2, "pVEHShell   = %p\n", pVEHShell);
	}

	if (!WriteProcessMemory(hTargetProc, pArg, &data, sizeof(INJECTION_DATA_MAPPED), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		if (pVEHShell)
		{
			VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
		}

		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	if (!WriteProcessMemory(hTargetProc, pShell, InjectionShell, ShellSize, nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		if (pVEHShell)
		{
			VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
		}

		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	LOG(1, "Shell written to memory\n");

	if (VEHShellSize)
	{
		if (!WriteProcessMemory(hTargetProc, pVEHShell, VectoredHandlerShell, VEHShellSize, nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			if (pVEHShell)
			{
				VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
			}

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

			return INJ_ERR_WPM_FAIL;
		}

		LOG(1, "VEHShell written to memory\n");
	}

	LOG(1, "Entering StartRoutine\n");

	if (Flags & INJ_THREAD_CREATE_CLOAKED)
	{
		Flags |= (INJ_CTF_FAKE_START_ADDRESS | INJ_CTF_HIDE_FROM_DEBUGGER);
	}

	DWORD remote_ret = 0;
	DWORD dwRet = StartRoutine(hTargetProc, ReCa<f_Routine>(pShell), pArg, Method, Flags, remote_ret, Timeout, error_data);

	LOG(1, "Return from StartRoutine\n");

	if (dwRet != SR_ERR_SUCCESS)
	{
		LOG(1, "StartRoutine failed: %08X\n", dwRet);

		if (Method != LAUNCH_METHOD::LM_QueueUserAPC && !(Method == LAUNCH_METHOD::LM_HijackThread && dwRet == SR_HT_ERR_REMOTE_TIMEOUT))
		{
			if (pVEHShell)
			{
				VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
			}

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
		}

		return dwRet;
	}

	LOG(1, "Fetching routine data\n");

	if (!ReadProcessMemory(hTargetProc, pArg, &data, sizeof(INJECTION_DATA_MAPPED), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		if (Method != LAUNCH_METHOD::LM_QueueUserAPC)
		{
			if (pVEHShell)
			{
				VirtualFreeEx(hTargetProc, pVEHShell, 0, MEM_RELEASE);
			}

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
		}

		return INJ_ERR_VERIFY_RESULT_FAIL;
	}

	if (Method != LAUNCH_METHOD::LM_QueueUserAPC)
	{
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
	}

	if (remote_ret != INJ_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, data.LastError);

		LOG(1, "Shell failed: %08X\n", remote_ret);

		return remote_ret;
	}

	if (!data.hRet)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "Shell failed\n");

		return INJ_ERR_FAILED_TO_LOAD_DLL;
	}

	LOG(1, "Shell returned successfully\n");

	hOut = data.hRet;

	LOG(1, "Imagebase = %p\n", ReCa<void *>(hOut));

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".inj_sec$1")) __stdcall InjectionShell(INJECTION_DATA_MAPPED * pData)
{
	if (!pData)
	{
		return INJ_ERR_NO_DATA;
	}

	INJECTION_FUNCTION_TABLE * f = &pData->f;
	pData->ModuleFileName.szBuffer = pData->Path;

	if (pData->Mode == INJECTION_MODE::IM_LoadLibraryExW)
	{
		pData->hRet = f->pLoadLibraryExW(pData->ModuleFileName.szBuffer, nullptr, NULL);

		if (!pData->hRet)
		{
			pData->LastError = f->pGetLastError();

			return INJ_ERR_LLEXW_FAILED;
		}
	}
	else if (pData->Mode == INJECTION_MODE::IM_LdrLoadDll)
	{
		ULONG Flags = NULL;

		LDR_SEARCH_PATH optPath{ 0 };
		if (pData->OSVersion == g_Win7)
		{
			optPath.szSearchPath = f->LdrpDefaultPath->szBuffer;
		}
		else
		{
			optPath.NoPath = TRUE;
		}

		pData->LastError = (DWORD)f->LdrLoadDll(optPath, &Flags, &pData->ModuleFileName, ReCa<HANDLE *>(&pData->hRet));

		if (NT_FAIL(pData->LastError))
		{
			return INJ_ERR_LDRLDLL_FAILED;
		}
	}
	else if (pData->OSVersion >= g_Win10)
	{
		LDR_DATA_TABLE_ENTRY * entry_out = nullptr;
		LDRP_LOAD_CONTEXT_FLAGS ctx_flags{ 0 };

		LDRP_PATH_SEARCH_CONTEXT * ctx = &pData->SearchPathContext;
		ctx->OriginalFullDllName = pData->Path;

		if (pData->OSBuildNumber == g_Win10_1511)
		{
			ReCa<LDRP_PATH_SEARCH_CONTEXT_1511 *>(ctx)->OriginalFullDllName = pData->Path;
			ctx->OriginalFullDllName = nullptr;
		}

		if (pData->Mode == INJECTION_MODE::IM_LdrpLoadDll)
		{
			if (pData->OSBuildNumber <= g_Win10_1803)
			{
				auto _LdrpLoadDll = ReCa<f_LdrpLoadDll_1507>(f->LdrpLoadDll);
				pData->LastError = _LdrpLoadDll(&pData->ModuleFileName, ctx, ctx_flags, TRUE, ReCa<LDR_DATA_TABLE_ENTRY_WIN10 **>(&entry_out));
			}
			else
			{
				pData->LastError = f->LdrpLoadDll(&pData->ModuleFileName, ctx, ctx_flags, &entry_out);
			}
		}
		else
		{
			pData->ModuleFileNameBundle.String.szBuffer = pData->ModuleFileNameBundle.StaticBuffer;

			pData->LastError = (DWORD)f->LdrpPreprocessDllName(&pData->ModuleFileName, &pData->ModuleFileNameBundle, nullptr, &ctx_flags);

			if (NT_FAIL(pData->LastError))
			{
				return INJ_ERR_LDRP_PREPROCESS_FAILED;
			}

			NTSTATUS nt_out = 0;

			if (pData->OSBuildNumber >= g_Win11_21H2) //Win11 prototype has an additional argument
			{
				auto _LdrpLoadDllInternal = ReCa<f_LdrpLoadDllInternal_WIN11>(f->LdrpLoadDllInternal);
				_LdrpLoadDllInternal(&pData->ModuleFileNameBundle.String, ctx, ctx_flags, 4, nullptr, nullptr, ReCa<LDR_DATA_TABLE_ENTRY_WIN11 **>(&entry_out), &nt_out, 0);
			}
			else
			{
				f->LdrpLoadDllInternal(&pData->ModuleFileNameBundle.String, ctx, ctx_flags, 4, nullptr, nullptr, ReCa<LDR_DATA_TABLE_ENTRY_WIN10 **>(&entry_out), &nt_out);
			}

			if (NT_FAIL(nt_out))
			{
				pData->LastError = (DWORD)nt_out;

				return INJ_ERR_LDRPLDLLINTERNAL_FAILED;
			}
		}

		if (!entry_out)
		{
			return INJ_ERR_LDR_ENTRY_IS_NULL;
		}
		else
		{
			f->LdrpDereferenceModule(entry_out);
		}

		pData->hRet = ReCa<HINSTANCE>(entry_out->DllBase);
	}
	else if (pData->OSVersion == g_Win81 && pData->Mode == INJECTION_MODE::IM_LdrpLoadDll)
	{
		auto _LdrpLoadDll = ReCa<f_LdrpLoadDll_WIN81>(f->LdrpLoadDll);

		LDRP_PATH_SEARCH_CONTEXT_WIN81 ctx{ 0 };
		ctx.OriginalFullDllName = pData->ModuleFileName.szBuffer;

		LDRP_LOAD_CONTEXT_FLAGS ctx_flags{ 0 };

		LDR_DATA_TABLE_ENTRY_WIN81	* entry_out = nullptr;
		LDR_DDAG_NODE_WIN81			* ddag_out	= nullptr;

		pData->LastError = (DWORD)_LdrpLoadDll(&pData->ModuleFileName, &ctx, ctx_flags, TRUE, &entry_out, &ddag_out);

		if (NT_FAIL(pData->LastError))
		{
			return INJ_ERR_LDRPLDLL_FAILED;
		}

		if (!entry_out)
		{
			return INJ_ERR_LDR_ENTRY_IS_NULL;
		}

		pData->hRet = ReCa<HINSTANCE>(entry_out->DllBase);
	}
	else if (pData->OSVersion == g_Win8 && pData->Mode == INJECTION_MODE::IM_LdrpLoadDll)
	{
		auto _LdrpLoadDll = ReCa<f_LdrpLoadDll_WIN8>(f->LdrpLoadDll);

		LDRP_PATH_SEARCH_CONTEXT_WIN8 ctx{ 0 };
		ctx.OriginalFullDllName = pData->ModuleFileName.szBuffer;
		ctx.unknown2 = TRUE;

		LDRP_LOAD_CONTEXT_FLAGS ctx_flags{ 0 };

		LDR_DATA_TABLE_ENTRY_WIN8	* entry_out = nullptr;
		LDR_DDAG_NODE_WIN8			* ddag_out	= nullptr;

		pData->LastError = (DWORD)_LdrpLoadDll(&pData->ModuleFileName, &ctx, ctx_flags, TRUE, &entry_out, &ddag_out);

		if (NT_FAIL(pData->LastError))
		{
			return INJ_ERR_LDRPLDLL_FAILED;
		}

		if (!entry_out)
		{
			return INJ_ERR_LDR_ENTRY_IS_NULL;
		}

		pData->hRet = ReCa<HINSTANCE>(entry_out->DllBase);
	}
	else if (pData->OSVersion == g_Win7 && pData->Mode == INJECTION_MODE::IM_LdrpLoadDll)
	{
		auto _LdrpLoadDll = ReCa<f_LdrpLoadDll_WIN7>(f->LdrpLoadDll);

		LDRP_LOAD_CONTEXT_FLAGS ctx_flags{ 0 };

		LDR_DATA_TABLE_ENTRY_WIN7 * entry_out = nullptr;

		pData->LastError = (DWORD)_LdrpLoadDll(&pData->ModuleFileName, f->LdrpDefaultPath, ctx_flags, TRUE, nullptr, &entry_out);

		if (NT_FAIL(pData->LastError))
		{
			return INJ_ERR_LDRPLDLL_FAILED;
		}

		if (!entry_out)
		{
			return INJ_ERR_LDR_ENTRY_IS_NULL;
		}

		pData->hRet = ReCa<HINSTANCE>(entry_out->DllBase);
	}
	else
	{
		return INJ_ERR_INVALID_INJ_METHOD;
	}
	
	if (!(pData->Flags & (INJ_UNLINK_FROM_PEB | INJ_FAKE_HEADER | INJ_ERASE_HEADER)))
	{
		return INJ_ERR_SUCCESS;
	}	

	PEB						* pPEB		= nullptr;
	LDR_DATA_TABLE_ENTRY	* pEntry	= nullptr;

#ifdef  _WIN64
	pPEB = ReCa<PEB *>(__readgsqword(0x60));
#else
	pPEB = ReCa<PEB *>(__readfsdword(0x30));
#endif 

	if (!pPEB)
	{
		return INJ_ERR_CANT_GET_PEB;
	}

	if (!pPEB->Ldr || !pPEB->Ldr->InLoadOrderModuleListHead.Flink)
	{
		return INJ_ERR_INVALID_PEB_DATA;
	}

	if ((pData->Flags & (INJ_FAKE_HEADER | INJ_ERASE_HEADER)))
	{
		auto * dos_header	= ReCa<IMAGE_DOS_HEADER *>(ReCa<BYTE *>(pData->hRet));
		auto * nt_headers	= ReCa<IMAGE_NT_HEADERS *>(ReCa<BYTE *>(pData->hRet) + dos_header->e_lfanew);
		SIZE_T header_size	= nt_headers->OptionalHeader.SizeOfHeaders;

		HANDLE hProc = NtCurrentProcess();

		ULONG old_access	= NULL;
		void * base			= ReCa<void *>(pData->hRet);

		pData->LastError = (DWORD)f->NtProtectVirtualMemory(hProc, &base, &header_size, PAGE_EXECUTE_READWRITE, &old_access);

		if (NT_FAIL(pData->LastError))
		{
			return INJ_ERR_UPDATE_PROTECTION_FAILED;
		}

		if (pData->Flags & INJ_ERASE_HEADER)
		{
			f->RtlZeroMemory(base, header_size);
		}
		else if (pData->Flags & INJ_FAKE_HEADER)
		{
			auto * ntdll_ldr = ReCa<LDR_DATA_TABLE_ENTRY *>(pPEB->Ldr->InLoadOrderModuleListHead.Flink->Flink);

			if (!ntdll_ldr)
			{
				return INJ_ERR_INVALID_PEB_DATA;
			}

			f->memmove(base, ntdll_ldr->DllBase, header_size);
		}

		pData->LastError = (DWORD)f->NtProtectVirtualMemory(hProc, &base, &header_size, old_access, &old_access);

		if (NT_FAIL(pData->LastError))
		{
			return INJ_ERR_UPDATE_PROTECTION_FAILED;
		}
	}

	if (pData->Flags & INJ_UNLINK_FROM_PEB)
	{
		LIST_ENTRY * pHead		= &pPEB->Ldr->InLoadOrderModuleListHead;
		LIST_ENTRY * pCurrent	= pHead->Flink;

		while (pCurrent != pHead)
		{
			if (ReCa<LDR_DATA_TABLE_ENTRY *>(pCurrent)->DllBase == pData->hRet)
			{
				pEntry = ReCa<LDR_DATA_TABLE_ENTRY *>(pCurrent);

				break;
			}

			pCurrent = pCurrent->Flink;
		}

		if (!pEntry)
		{
			return INJ_ERR_CANT_FIND_MOD_PEB;
		}
		
		auto * veh_shell_data = ReCa<VEH_SHELL_DATA *>(ALIGN_UP(pData->pVEHShell + pData->VEHShellSize, BASE_ALIGNMENT));
		
		veh_shell_data->ImgBase		= ReCa<ULONG_PTR>(pEntry->DllBase);
		veh_shell_data->ImgSize		= pEntry->SizeOfImage;
		veh_shell_data->OSVersion	= pData->OSVersion;
		veh_shell_data->LdrpInvertedFunctionTable	= f->LdrpInvertedFunctionTable;
		veh_shell_data->LdrProtectMrdata			= f->LdrProtectMrdata;

		bool veh_shell_fixed = FindAndReplacePtr(pData->pVEHShell, pData->VEHShellSize, VEHDATASIG, ReCa<UINT_PTR>(veh_shell_data));

		if (veh_shell_fixed)
		{
			f->RtlAddVectoredExceptionHandler(0, ReCa<PVECTORED_EXCEPTION_HANDLER>(pData->pVEHShell));
		}

		UNLINK_IF(pEntry->InLoadOrderLinks);
		UNLINK_IF(pEntry->InInitializationOrderLinks);
		UNLINK_IF(pEntry->InMemoryOrderLinks);	
		UNLINK_IF(pEntry->HashLinks);

		size_t ldr_size		= sizeof(LDR_DATA_TABLE_ENTRY);
		size_t ddag_size	= sizeof(LDR_DDAG_NODE);
		void * pDDag		= nullptr;

		if (pData->OSVersion == g_Win7)
		{
			auto * pEntry7 = ReCa<LDR_DATA_TABLE_ENTRY_WIN7 *>(pEntry);
			UNLINK_IF(pEntry7->ForwarderLinks);
			UNLINK_IF(pEntry7->ServiceTagLinks);
			UNLINK_IF(pEntry7->StaticLinks);

			ldr_size = sizeof(LDR_DATA_TABLE_ENTRY_WIN7);
		}
		else
		{
			f->RtlRbRemoveNode(f->LdrpModuleBaseAddressIndex,	&pEntry->BaseAddressIndexNode);
			f->RtlRbRemoveNode(f->LdrpMappingInfoIndex,			&pEntry->MappingInfoIndexNode);

			if (pData->OSVersion == g_Win8)
			{
				ldr_size	= sizeof(LDR_DATA_TABLE_ENTRY_WIN8);
				ddag_size	= sizeof(LDR_DDAG_NODE_WIN8);
			}
			else if (pData->OSVersion == g_Win81)
			{
				ldr_size	= sizeof(LDR_DATA_TABLE_ENTRY_WIN81);
				ddag_size	= sizeof(LDR_DDAG_NODE_WIN81);
			}
			else if (pData->OSVersion >= g_Win10) //Win10 or Win11, same OSVersion...
			{
				if (pData->OSBuildNumber <= g_Win10_1511) //1507 - 1511
				{
					ldr_size = offsetof(LDR_DATA_TABLE_ENTRY_WIN10, DependentLoadFlags);
				}
				else if (pData->OSBuildNumber <= g_Win10_1607) //1607
				{
					ldr_size = offsetof(LDR_DATA_TABLE_ENTRY_WIN10, SigningLevel);
				}
				else if (pData->OSBuildNumber <= g_Win10_21H2) //1703 - 21H2 (Win10)
				{
					ldr_size	= sizeof(LDR_DATA_TABLE_ENTRY_WIN10);
					ddag_size	= sizeof(LDR_DDAG_NODE_WIN10);
				}
				else //21H2+ (Win11)
				{
					ldr_size	= sizeof(LDR_DATA_TABLE_ENTRY_WIN11);
					ddag_size	= sizeof(LDR_DDAG_NODE_WIN11);
				}
			}			

			pDDag = pEntry->DdagNode;
		}

		f->RtlZeroMemory(pEntry->BaseDllName.szBuffer, pEntry->BaseDllName.MaxLength);
		f->RtlZeroMemory(pEntry->FullDllName.szBuffer, pEntry->FullDllName.MaxLength);

		f->RtlZeroMemory(pEntry, ldr_size);

		if (pDDag)
		{
			f->RtlZeroMemory(pDDag, ddag_size);
		}
	}

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".inj_sec$2")) INJ_SEC_END()
{
	return 1338;
}

INJECTION_FUNCTION_TABLE::INJECTION_FUNCTION_TABLE()
{
	WIN32_FUNC_CONSTRUCTOR_INIT(LoadLibraryExW);
	NT_FUNC_CONSTRUCTOR_INIT(LdrLoadDll);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpLoadDll);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpLoadDllInternal);

	NT_FUNC_CONSTRUCTOR_INIT(LdrpPreprocessDllName);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpDereferenceModule);

	WIN32_FUNC_CONSTRUCTOR_INIT(GetLastError);

	NT_FUNC_CONSTRUCTOR_INIT(memmove);
	NT_FUNC_CONSTRUCTOR_INIT(RtlZeroMemory);

	NT_FUNC_CONSTRUCTOR_INIT(RtlRbRemoveNode);
	
	NT_FUNC_CONSTRUCTOR_INIT(NtProtectVirtualMemory);

	NT_FUNC_CONSTRUCTOR_INIT(RtlAddVectoredExceptionHandler);
	NT_FUNC_CONSTRUCTOR_INIT(LdrProtectMrdata);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpInvertedFunctionTable);

	NT_FUNC_CONSTRUCTOR_INIT(LdrpModuleBaseAddressIndex);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpMappingInfoIndex);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpDefaultPath);
}
```

`GH Injector Library/Injection Internal.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "Start Routine.h"
#include "Manual Mapping.h"

ALIGN struct INJECTION_FUNCTION_TABLE
{
	ALIGN WIN32_FUNC_LOCAL(LoadLibraryExW);
	ALIGN NT_FUNC_LOCAL(LdrLoadDll);
	ALIGN NT_FUNC_LOCAL(LdrpLoadDll);
	ALIGN NT_FUNC_LOCAL(LdrpLoadDllInternal);

	ALIGN NT_FUNC_LOCAL(LdrpPreprocessDllName);
	ALIGN NT_FUNC_LOCAL(LdrpDereferenceModule);

	ALIGN WIN32_FUNC_LOCAL(GetLastError);

	ALIGN NT_FUNC_LOCAL(memmove);
	ALIGN NT_FUNC_LOCAL(RtlZeroMemory);

	ALIGN NT_FUNC_LOCAL(RtlRbRemoveNode);

	ALIGN NT_FUNC_LOCAL(NtProtectVirtualMemory);
	
	ALIGN NT_FUNC_LOCAL(RtlAddVectoredExceptionHandler);
	ALIGN NT_FUNC_LOCAL(LdrProtectMrdata);
	ALIGN NT_FUNC_LOCAL(LdrpInvertedFunctionTable);

	ALIGN NT_FUNC_LOCAL(LdrpModuleBaseAddressIndex);
	ALIGN NT_FUNC_LOCAL(LdrpMappingInfoIndex);
	ALIGN NT_FUNC_LOCAL(LdrpDefaultPath);

	INJECTION_FUNCTION_TABLE();
};

struct INJECTION_DATA_MAPPED
{
	ALIGN HINSTANCE	hRet		= NULL;
	ALIGN DWORD		LastError	= 0;

	ALIGN DWORD				Flags	= NULL;
	ALIGN INJECTION_MODE	Mode	= INJECTION_MODE::IM_LoadLibraryExW;

	ALIGN UNICODE_STRING	ModuleFileName{ 0 };
	ALIGN wchar_t			Path[MAX_PATH]{ 0 };

	ALIGN LDRP_UNICODE_STRING_BUNDLE	ModuleFileNameBundle{ 0 };
	ALIGN LDRP_PATH_SEARCH_CONTEXT		SearchPathContext{ 0 };
	
	ALIGN DWORD OSVersion		= 0;
	ALIGN DWORD OSBuildNumber	= 0;

	ALIGN BYTE * pVEHShell		= nullptr;
	ALIGN DWORD VEHShellSize	= 0;

	ALIGN INJECTION_FUNCTION_TABLE f;
};

DWORD InjectDLL(const INJECTION_SOURCE & Source, HANDLE hTargetProc, INJECTION_MODE Mode, LAUNCH_METHOD Method, DWORD Flags, HINSTANCE & hOut, DWORD Timeout, ERROR_DATA & error_data);

#ifdef _WIN64

ALIGN_86 struct INJECTION_FUNCTION_TABLE_WOW64
{
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LoadLibraryExW);
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrLoadDll);
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpLoadDll);
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpLoadDllInternal);

	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpPreprocessDllName);
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpDereferenceModule);

	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(GetLastError);

	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(memmove);
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlZeroMemory);

	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlRbRemoveNode);

	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtProtectVirtualMemory);

	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlAddVectoredExceptionHandler);
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrProtectMrdata);
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpInvertedFunctionTable);

	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpModuleBaseAddressIndex);
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpMappingInfoIndex);
	ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpDefaultPath);

	INJECTION_FUNCTION_TABLE_WOW64();
};

ALIGN_86 struct INJECTION_DATA_MAPPED_WOW64
{
	ALIGN_86 DWORD hRet			= 0;
	ALIGN_86 DWORD LastError	= 0;

	ALIGN_86 DWORD			Flags	= NULL;
	ALIGN_86 INJECTION_MODE	Mode	= INJECTION_MODE::IM_LoadLibraryExW;

	ALIGN_86 UNICODE_STRING_32	ModuleFileName{ 0 };
	ALIGN_86 wchar_t			Path[MAX_PATH]{ 0 };

	ALIGN_86 LDRP_UNICODE_STRING_BUNDLE_32	ModuleFileNameBundle{ 0 };
	ALIGN_86 LDRP_PATH_SEARCH_CONTEXT_32	SearchPathContext{ 0 };

	ALIGN_86 DWORD OSVersion		= 0;
	ALIGN_86 DWORD OSBuildNumber	= 0;

	ALIGN_86 DWORD pVEHShell	= 0;
	ALIGN_86 DWORD VEHShellSize = 0;

	ALIGN_86 INJECTION_FUNCTION_TABLE_WOW64 f;
};

DWORD InjectDLL_WOW64(const INJECTION_SOURCE & Source, HANDLE hTargetProc, INJECTION_MODE Mode, LAUNCH_METHOD Method, DWORD Flags, HINSTANCE & hOut, DWORD Timeout, ERROR_DATA & error_data);

#endif
```

`GH Injector Library/Injection.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Injection.h"

DWORD HijackHandle(INJECTIONDATA_INTERNAL & Data, ERROR_DATA & error_data);

DWORD InitErrorStruct(const INJECTIONDATA_INTERNAL & Data, int Native, DWORD ErrorCode, const ERROR_DATA & error_data);

DWORD __stdcall InjectA(INJECTIONDATAA * pData)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "InjectA called with pData = %p\n", pData);

	if (WaitForSingleObject(g_hRunningEvent, 0) == WAIT_OBJECT_0)
	{
		LOG(0, "Different injection in progress. Wait for the other injection to finish first.\n");

		return INJ_ERR_ALREADY_RUNNING;
	}

	if (!pData)
	{
		LOG(0, "pData is invalid\n");

		return INJ_ERR_NO_DATA;
	}

	ERROR_DATA error_data{ 0 };

	if (!pData->szDllPath)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Invalid path\n");

		return INJ_ERR_INVALID_FILEPATH;
	}
	
	INJECTIONDATA_INTERNAL data_internal(pData);
	DWORD Ret = Inject_Internal(&data_internal);
	pData->hDllOut = data_internal.hDllOut;

	return Ret;
}

DWORD __stdcall InjectW(INJECTIONDATAW * pData)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "InjectW called with pData = %p\n", pData);

	if (WaitForSingleObject(g_hRunningEvent, 0) == WAIT_OBJECT_0)
	{
		LOG(0, "Different injection in progress. Wait for the other injection to finish first.\n");

		return INJ_ERR_ALREADY_RUNNING;
	}

	if (!pData)
	{
		LOG(0, "pData is invalid\n");

		return INJ_ERR_NO_DATA;
	}

	ERROR_DATA error_data{ 0 };
	
	if (!pData->szDllPath)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Invalid path\n");

		return INJ_ERR_INVALID_FILEPATH;
	}

	INJECTIONDATA_INTERNAL data_internal(pData);
	DWORD Ret = Inject_Internal(&data_internal);
	pData->hDllOut = data_internal.hDllOut;

	return Ret;	
}

DWORD __stdcall Inject_Internal(INJECTIONDATA_INTERNAL * pData)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "Inject_Internal called with pData = %p\n", pData);

	SetEvent(g_hRunningEvent);
	ResetEvent(g_hInterruptEvent);
	ResetEvent(g_hInterruptedEvent);

	DWORD RetVal = INJ_ERR_SUCCESS;

	ERROR_DATA error_data{ 0 };
	auto & Data = *pData;

	RetVal = GetImportState();
	if (RetVal != INJ_ERR_SUCCESS)
	{
		LOG(0, "Resolving imports failed: %08X\n", RetVal);

		error_data = import_handler_error_data;

		return InitErrorStruct(Data, -1, INJ_ERR_IMPORT_HANDLER_NOT_DONE, error_data);
	}

	if (Data.Mode == INJECTION_MODE::IM_LdrpLoadDllInternal && !IsWin10OrGreater())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "LdrpLoadDllInternal is only supported on Windows 10\n");

		return InitErrorStruct(Data, -1, INJ_ERR_NOT_SUPPORTED, error_data);
	}
		
	if (Data.DllPath.empty())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Invalid path provided (empty string)\n");

		return InitErrorStruct(Data, -1, INJ_ERR_INVALID_FILEPATH, error_data);
	}

	if (!FileExistsW(Data.DllPath))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(0, "File doesn't exist: %08X\n", error_data.AdvErrorCode);

		return InitErrorStruct(Data, -1, INJ_ERR_FILE_DOESNT_EXIST, error_data);
	}

	if (PathIsRelativeW(Data.DllPath.c_str()))
	{
		wchar_t buffer[MAX_PATH * 2]{ 0 };
		auto win_ret = GetFullPathNameW(Data.DllPath.c_str(), sizeof(buffer) / sizeof(wchar_t), buffer, nullptr);
		if (!win_ret || win_ret >= sizeof(buffer) / sizeof(wchar_t))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(0, "Failed to resolve absolute file path: %08X\n", error_data.AdvErrorCode);

			return InitErrorStruct(Data, -1, INJ_ERR_FAILED_TO_RESOLVE_PATH, error_data);
		}

		Data.DllPath = buffer;
	}

	if (!Data.ProcessID)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Invalid process identifier specified\n");

		return InitErrorStruct(Data, -1, INJ_ERR_INVALID_PID, error_data);
	}

	if (Data.Flags & INJ_MM_MAP_FROM_MEMORY)
	{
		Data.Flags ^= INJ_MM_MAP_FROM_MEMORY;
	}

	if (Data.Flags & INJ_LOAD_DLL_COPY)
	{
		LOG(0, "Copying dll into temp directory\n");

		DWORD win32err = NULL;

		auto dwRet = CreateTempFileCopy(Data.DllPath, win32err);
		if (dwRet != FILE_ERR_SUCCESS)
		{
			INIT_ERROR_DATA(error_data, win32err);

			LOG(0, "Failed to copy file to temp directory: %08X\n", dwRet);

			return InitErrorStruct(Data, -1, dwRet, error_data);
		}

		LOG(0, "Path of dll copy: %ls\n", Data.DllPath.c_str());
	}

	if (Data.Flags & INJ_SCRAMBLE_DLL_NAME)
	{
		LOG(0, "Scrambling dll name\n");

		DWORD win32err = NULL;

		auto dwRet = ScrambleFileName(Data.DllPath, 10, win32err);
		if (dwRet != FILE_ERR_SUCCESS)
		{
			INIT_ERROR_DATA(error_data, win32err);

			LOG(0, "Failed to copy file to temp directory: %08X\n", dwRet);

			return InitErrorStruct(Data, -1, dwRet, error_data);
		}

		LOG(0, "Path of renamed dll: %ls\n", Data.DllPath.c_str());
	}

	HANDLE hTargetProc = nullptr;
	if (Data.Flags & INJ_HIJACK_HANDLE)
	{
		if (Data.hHandleValue)
		{
			LOG(0, "hHandleValue = %08X\n", Data.hHandleValue);
			
			hTargetProc = MPTR(Data.hHandleValue);
		}
		else
		{
			LOG(0, "Forwarding call to handle hijacking\n");
			
			return HijackHandle(Data, error_data);
		}
	}
	else
	{
		DWORD access_mask = PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION | PROCESS_QUERY_LIMITED_INFORMATION;
		if (Data.Method == LAUNCH_METHOD::LM_NtCreateThreadEx)
		{
			access_mask |= PROCESS_CREATE_THREAD;
		}

		hTargetProc = OpenProcess(access_mask, FALSE, Data.ProcessID);
		if (!hTargetProc)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(0, "OpenProcess failed: %08X\n", (DWORD)error_data.AdvErrorCode);

			return InitErrorStruct(Data, -1, INJ_ERR_CANT_OPEN_PROCESS, error_data);
		}
	}

	DWORD handle_info = 0;
	if (!hTargetProc || !GetHandleInformation(hTargetProc, &handle_info))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(0, "Invalid process handle: %08X\n", (DWORD)error_data.AdvErrorCode);

		return InitErrorStruct(Data, -1, INJ_ERR_INVALID_PROC_HANDLE, error_data);
	}

	LOG(0, "Attached to target process\n");

	wchar_t szExePath[MAX_PATH * 2]{ 0 };
	DWORD size_inout = sizeof(szExePath) / sizeof(szExePath[0]);
	if (!QueryFullProcessImageNameW(hTargetProc, NULL, szExePath, &size_inout))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(0, "QueryFullProcessImageNameW failed: %08X\n", (DWORD)error_data.AdvErrorCode);

		return InitErrorStruct(Data, -1, INJ_ERR_CANT_GET_EXE_FILENAME, error_data);
	}

	auto ExePath	= std::wstring(szExePath);
	auto ExeNamePos = ExePath.find_last_of('\\');

	if (ExeNamePos == std::string::npos)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Failed to extract exe name from path\n");

		return InitErrorStruct(Data, -1, INJ_ERR_INVALID_EXE_PATH, error_data);
	}

	Data.TargetProcessExeFileName = ExePath.substr(ExeNamePos + 1);

	LOG(0, "Target process name = %ls\n", Data.TargetProcessExeFileName.c_str());

	LOG(0, "Validating specified file\n");

	DWORD FileErr = FILE_ERR_SUCCESS;
	bool native_target = true;
#ifdef _WIN64
	native_target = IsNativeProcess(hTargetProc);
	if (native_target)
	{
		FileErr = ValidateDllFile(Data.DllPath, IMAGE_FILE_MACHINE_AMD64);
	}
	else
	{
		FileErr = ValidateDllFile(Data.DllPath, IMAGE_FILE_MACHINE_I386);
	}
#else
	FileErr = ValidateDllFile(Data.DllPath, IMAGE_FILE_MACHINE_I386);
#endif

	if (FileErr != FILE_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, FileErr);

		LOG(0, "Invalid file specified\n");

		return InitErrorStruct(Data, native_target, INJ_ERR_PLATFORM_MISMATCH, error_data);
	}

	LOG(0, "File validated and prepared for injection:\n %ls\n", Data.DllPath.c_str());
	
	HINSTANCE hOut = NULL;

	INJECTION_SOURCE source;
	source.DllPath = Data.DllPath;

#ifdef _WIN64
	if (native_target)
	{
		RetVal = InjectDLL(source, hTargetProc, Data.Mode, Data.Method, Data.Flags, hOut, Data.Timeout, error_data);
	}
	else
	{		
		RetVal = InjectDLL_WOW64(source, hTargetProc, Data.Mode, Data.Method, Data.Flags, hOut, Data.Timeout, error_data);
	}	
#else
	RetVal = InjectDLL(source, hTargetProc, Data.Mode, Data.Method, Data.Flags, hOut, Data.Timeout, error_data);
#endif

	LOG(0, "Injection finished\n");

	if (!(Data.Flags & INJ_HIJACK_HANDLE))
	{
		CloseHandle(hTargetProc);
	}
	
	Data.hDllOut = hOut;

	return InitErrorStruct(Data, native_target, RetVal, error_data);
}

DWORD InitErrorStruct(const INJECTIONDATA_INTERNAL & Data, int Native, DWORD ErrorCode, const ERROR_DATA & error_data)
{
	ResetEvent(g_hRunningEvent);

	if (!ErrorCode)
	{
		return INJ_ERR_SUCCESS;
	}
	
	if (Data.GenerateErrorLog)
	{
		ERROR_INFO info{ };
		info.DllFileName				= Data.DllPath;
		info.TargetProcessExeFileName	= Data.TargetProcessExeFileName;
		info.TargetProcessId			= Data.ProcessID;
		info.InjectionMode				= Data.Mode;
		info.LaunchMethod				= Data.Method;
		info.Flags						= Data.Flags;
		info.HandleValue				= Data.hHandleValue;
		info.bNative					= Native;
		info.RawData					= Data.RawData;
		info.RawSize					= Data.RawSize;

		info.ErrorCode		= ErrorCode;
		info.AdvErrorCode	= error_data.AdvErrorCode;
		info.SourceFile		= error_data.szFileName;
		info.FunctionName	= error_data.szFunctionName;
		info.Line			= error_data.Line;

		info.IsDotNet = false;

		ErrorLog(info);
	}

	return ErrorCode;
}

DWORD HijackHandle(INJECTIONDATA_INTERNAL & Data, ERROR_DATA & error_data)
{
	LOG(1, "Begin HijackHandle\n");

	DWORD access_mask = PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION;
	if (Data.Method == LAUNCH_METHOD::LM_NtCreateThreadEx)
	{
		access_mask |= PROCESS_CREATE_THREAD;
	}

	auto handles = FindProcessHandles(Data.ProcessID, access_mask);
	if (handles.empty())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "No compatible handle found\n");

		return InitErrorStruct(Data, true, INJ_ERR_HIJACK_NO_HANDLES, error_data);
	}

	INJECTIONDATAW hijack_data{ 0 };
	hijack_data.Mode				= INJECTION_MODE::IM_LdrLoadDll;
	hijack_data.Method				= LAUNCH_METHOD::LM_NtCreateThreadEx;
	hijack_data.Timeout				= Data.Timeout;
	hijack_data.GenerateErrorLog	= Data.GenerateErrorLog;
	hijack_data.Flags				= NULL;
	
	auto FullModPath = g_RootPathW + GH_INJ_MOD_NAMEW;
	if (!StdWStringToWCharArray(FullModPath, hijack_data.szDllPath, sizeof(hijack_data.szDllPath) / sizeof(wchar_t)))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "String exceeded %d characters: %ls\n", sizeof(hijack_data.szDllPath) / sizeof(wchar_t), FullModPath.c_str());

		return InitErrorStruct(Data, true, INJ_ERR_STRING_TOO_LONG, error_data);
	}

	INJECTIONDATAW injection_data{ 0 };
	injection_data.ProcessID		= Data.ProcessID;
	injection_data.Mode				= Data.Mode;
	injection_data.Method			= Data.Method;
	injection_data.Flags			= Data.Flags;
	injection_data.Timeout			= Data.Timeout;
	injection_data.GenerateErrorLog = Data.GenerateErrorLog;
	if (!StdWStringToWCharArray(Data.DllPath, injection_data.szDllPath, sizeof(injection_data.szDllPath) / sizeof(wchar_t)))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "String exceeded %d characters: %ls\n", sizeof(hijack_data.szDllPath) / sizeof(wchar_t), Data.DllPath.c_str());

		return InitErrorStruct(Data, true, INJ_ERR_STRING_TOO_LONG,  error_data);
	}
	
	if (injection_data.Flags & INJ_SCRAMBLE_DLL_NAME)
	{
		injection_data.Flags ^= INJ_SCRAMBLE_DLL_NAME;
	}

	if (injection_data.Flags & INJ_LOAD_DLL_COPY)
	{
		injection_data.Flags ^= INJ_LOAD_DLL_COPY;
	}

	DWORD LastErrCode	= INJ_ERR_SUCCESS;
	HANDLE hHijackProc	= nullptr;
	for (const auto & i : handles)
	{
		hHijackProc = OpenProcess(access_mask | PROCESS_CREATE_THREAD, FALSE, i.OwnerPID);
		if (!hHijackProc)
		{
			LastErrCode = INJ_ERR_CANT_OPEN_PROCESS;
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "Failed to attach to process %06X\n", i.OwnerPID);

			continue;
		}

		LOG(1, "Attached to process %06X\n", i.OwnerPID);
					
		if (!IsElevatedProcess(hHijackProc) || !IsNativeProcess(hHijackProc))
		{
			LastErrCode = INJ_ERR_HIJACK_NO_NATIVE_HANDLE;
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(1, "Process isn't elevated or native\n");

			CloseHandle(hHijackProc);
			
			continue;
		}

		ResetEvent(g_hRunningEvent);

		hijack_data.ProcessID = i.OwnerPID;
		DWORD inj_ret = InjectW(&hijack_data);

		SetEvent(g_hRunningEvent);

		if (inj_ret || !hijack_data.hDllOut)
		{
			LastErrCode = INJ_ERR_HIJACK_INJ_FAILED;
			INIT_ERROR_DATA(error_data, inj_ret);

			LOG(1, "Failed to load injection module into process %06X: %08X\n", i.OwnerPID, inj_ret);

			CloseHandle(hHijackProc);
			
			continue;
		}

		LOG(1, "Injection module loaded into hijack process\n");

		HINSTANCE hInjectionModuleEx = hijack_data.hDllOut;
		f_Routine pRemoteInjectW = ReCa<f_Routine>(ReCa<UINT_PTR>(InjectW) - ReCa<UINT_PTR>(g_hInjMod) + ReCa<UINT_PTR>(hInjectionModuleEx));
		
		void * pArg = VirtualAllocEx(hHijackProc, nullptr, sizeof(INJECTIONDATAW), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (!pArg)
		{
			LastErrCode = INJ_ERR_HIJACK_OUT_OF_MEMORY_EXT;
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

			EjectHijackLibrary(hHijackProc, hInjectionModuleEx);

			CloseHandle(hHijackProc);
			
			continue;
		}

		injection_data.hHandleValue = i.hValue;
		if (!WriteProcessMemory(hHijackProc, pArg, &injection_data, sizeof(INJECTIONDATAW), nullptr))
		{
			LastErrCode = INJ_ERR_HIJACK_WPM_FAIL;
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hHijackProc, pArg, 0, MEM_RELEASE);
			EjectHijackLibrary(hHijackProc, hInjectionModuleEx);

			CloseHandle(hHijackProc);
			
			continue;
		}

		LOG(1, "Handle value: %04X\n", i.hValue);

		injection_data.hHandleValue = 0;

		LOG(1, "Injection data written to hijack process\n");

		bool b_Ready = false;
		bool * p_g_LibraryState = ReCa<bool *>(ReCa<UINT_PTR>(&g_LibraryState) - ReCa<UINT_PTR>(g_hInjMod) + ReCa<UINT_PTR>(hInjectionModuleEx));

		auto Timer = GetTickCount64();
		while (GetTickCount64() - Timer < INJ_HIJACK_TIMEOUT)
		{
			if (!ReadProcessMemory(hHijackProc, p_g_LibraryState, &b_Ready, sizeof(b_Ready), nullptr) || b_Ready)
			{
				break;
			}

			auto dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);
			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(1, "Interrupt!\n");
				LastErrCode = INJ_ERR_INTERRUPT;

				SetEvent(g_hInterruptedEvent);

				VirtualFreeEx(hHijackProc, pArg, 0, MEM_RELEASE);
				EjectHijackLibrary(hHijackProc, hInjectionModuleEx);
	
				CloseHandle(hHijackProc);

				break;
			}
		}

		if (!b_Ready)
		{
			LOG(1, "Hijack library timed out\n");

			VirtualFreeEx(hHijackProc, pArg, 0, MEM_RELEASE);
			EjectHijackLibrary(hHijackProc, hInjectionModuleEx);
	
			CloseHandle(hHijackProc);

			continue;
		}
		else
		{
			LOG(1, "Hijack library is ready\n");
		}

		DWORD hijack_ret = INJ_ERR_SUCCESS;
		DWORD remote_ret = StartRoutine(hHijackProc, pRemoteInjectW, pArg, LAUNCH_METHOD::LM_NtCreateThreadEx, NULL, hijack_ret, Data.Timeout, error_data);
				
		INJECTIONDATAW data_out{ 0 };
		ReadProcessMemory(hHijackProc, pArg, &data_out, sizeof(INJECTIONDATAW), nullptr);
		
		if (remote_ret != SR_NTCTE_ERR_REMOTE_TIMEOUT || remote_ret == SR_ERR_INTERRUPT)
		{
			if (remote_ret == SR_ERR_INTERRUPT)
			{
				ResetEvent(g_hInterruptEvent);
				ResetEvent(g_hInterruptedEvent);
				LOG(1, "Interrupt! Attempting to interrupt hijack injection\n");
			}
			else
			{
				LOG(1, "Hijack injection timed out\n");
			}

			ERROR_DATA interrupt_data;
			remote_ret	= 0;
			DWORD ret	= 0;
			f_Routine pInterruptInjectionEx	= ReCa<f_Routine>(ReCa<UINT_PTR>(InterruptInjectionEx) - ReCa<UINT_PTR>(g_hInjMod) + ReCa<UINT_PTR>(hInjectionModuleEx));

			ret = StartRoutine(hHijackProc, pInterruptInjectionEx, MPTR(INJ_EJECT_TIMEOUT), LAUNCH_METHOD::LM_NtCreateThreadEx, NULL, remote_ret, INJ_EJECT_TIMEOUT, interrupt_data);

			if (ret != SR_ERR_SUCCESS)
			{
				LOG(1, "Attempt to interrupt hijack injection failed: %08X\n", ret);
			}
			else if (remote_ret != (DWORD)true)
			{
				LOG(1, "Failed to interrupt hijack injection\n");
			}
		}

		VirtualFreeEx(hHijackProc, pArg, 0, MEM_RELEASE);
		EjectHijackLibrary(hHijackProc, hInjectionModuleEx, false);

		CloseHandle(hHijackProc);

		if (remote_ret != SR_ERR_SUCCESS)
		{
			LastErrCode = remote_ret;

			LOG(1, "StartRoutine failed: %08X\n", remote_ret);

			continue;
		}

		if (hijack_ret != INJ_ERR_SUCCESS || !data_out.hDllOut)
		{
			LastErrCode = INJ_ERR_HIJACK_REMOTE_INJ_FAIL;
			INIT_ERROR_DATA(error_data, hijack_ret);

			LOG(1, "Hijack injection failed: %08X\n", hijack_ret);

			continue;
		}

		LOG(1, "Hijack injection succeeded\nImagebase = %p\n", ReCa<void *>(data_out.hDllOut));

		Data.hDllOut = data_out.hDllOut;

		LastErrCode = INJ_ERR_SUCCESS;

		break;
	}

	LOG(1, "End HijackHandle\n");

	return InitErrorStruct(Data, true, LastErrCode, error_data);
}

DWORD __stdcall Memory_Inject(MEMORY_INJECTIONDATA * pData)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "Memory_Inject called with pData = %p\n", pData);

	if (WaitForSingleObject(g_hRunningEvent, 0) == WAIT_OBJECT_0)
	{
		LOG(0, "Different injection in progress. Wait for the other injection to finish first.\n");

		return INJ_ERR_ALREADY_RUNNING;
	}

	SetEvent(g_hRunningEvent);
	ResetEvent(g_hInterruptEvent);
	ResetEvent(g_hInterruptedEvent);

	if (!pData)
	{
		LOG(0, "pData is invalid\n");

		return INJ_ERR_NO_DATA;
	}

	if (!pData->RawData)
	{
		LOG(0, "No raw data\n");

		return INJ_ERR_NO_RAW_DATA;
	}

	pData->Flags |= INJ_MM_MAP_FROM_MEMORY;

	DWORD RetVal = INJ_ERR_SUCCESS;

	ERROR_DATA error_data{ 0 };
	INJECTIONDATA_INTERNAL Data(pData);

	RetVal = GetImportState();
	if (RetVal != INJ_ERR_SUCCESS)
	{
		LOG(0, "Resolving imports failed: %08X\n", RetVal);

		error_data = import_handler_error_data;

		return InitErrorStruct(Data, -1, INJ_ERR_IMPORT_HANDLER_NOT_DONE, error_data);
	}

	pData->Mode = INJECTION_MODE::IM_ManualMap;
	pData->Flags |= INJ_MM_MAP_FROM_MEMORY;

	if (!Data.ProcessID)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Invalid process identifier specified\n");

		return InitErrorStruct(Data, -1, INJ_ERR_INVALID_PID, error_data);
	}

	HANDLE hTargetProc = nullptr;
	if (Data.Flags & INJ_HIJACK_HANDLE)
	{
		if (Data.hHandleValue)
		{
			LOG(0, "hHandleValue = %08X\n", Data.hHandleValue);
			
			hTargetProc = MPTR(Data.hHandleValue);
		}
		else
		{
			LOG(0, "Forwarding call to handle hijacking\n");
			
			return HijackHandle(Data, error_data);
		}
	}
	else
	{
		DWORD access_mask = PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION | PROCESS_QUERY_LIMITED_INFORMATION;
		if (Data.Method == LAUNCH_METHOD::LM_NtCreateThreadEx)
		{
			access_mask |= PROCESS_CREATE_THREAD;
		}

		hTargetProc = OpenProcess(access_mask, FALSE, Data.ProcessID);
		if (!hTargetProc)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(0, "OpenProcess failed: %08X\n", (DWORD)error_data.AdvErrorCode);

			return InitErrorStruct(Data, -1, INJ_ERR_CANT_OPEN_PROCESS, error_data);
		}
	}

	DWORD handle_info = 0;
	if (!hTargetProc || !GetHandleInformation(hTargetProc, &handle_info))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(0, "Invalid process handle: %08X\n", (DWORD)error_data.AdvErrorCode);

		return InitErrorStruct(Data, -1, INJ_ERR_INVALID_PROC_HANDLE, error_data);
	}

	LOG(0, "Attached to target process\n");

	wchar_t szExePath[MAX_PATH * 2]{ 0 };
	DWORD size_inout = sizeof(szExePath) / sizeof(szExePath[0]);
	if (!QueryFullProcessImageNameW(hTargetProc, NULL, szExePath, &size_inout))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(0, "QueryFullProcessImageNameW failed: %08X\n", (DWORD)error_data.AdvErrorCode);

		return InitErrorStruct(Data, -1, INJ_ERR_CANT_GET_EXE_FILENAME, error_data);
	}

	auto ExePath	= std::wstring(szExePath);
	auto ExeNamePos = ExePath.find_last_of('\\');

	if (ExeNamePos == std::string::npos)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(0, "Failed to extract exe name from path\n");

		return InitErrorStruct(Data, -1, INJ_ERR_INVALID_EXE_PATH, error_data);
	}

	Data.TargetProcessExeFileName = ExePath.substr(ExeNamePos + 1);

	LOG(0, "Target process name = %ls\n", Data.TargetProcessExeFileName.c_str());

	LOG(0, "Validating specified file\n");

	DWORD FileErr = FILE_ERR_SUCCESS;
	bool native_target = true;
#ifdef _WIN64
	native_target = IsNativeProcess(hTargetProc);
	if (native_target)
	{
		FileErr = ValidateDllFileInMemory(Data.RawData, Data.RawSize, IMAGE_FILE_MACHINE_AMD64);
	}
	else
	{
		FileErr = ValidateDllFileInMemory(Data.RawData, Data.RawSize, IMAGE_FILE_MACHINE_I386);
	}
#else
	FileErr = ValidateDllFileInMemory(Data.RawData, Data.RawSize, IMAGE_FILE_MACHINE_I386);
#endif

	if (FileErr != FILE_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, FileErr);

		LOG(0, "Invalid file specified\n");

		return InitErrorStruct(Data, native_target, INJ_ERR_PLATFORM_MISMATCH, error_data);
	}

	LOG(0, "File validated and prepared for injection\n");

	HINSTANCE hOut = NULL;

	INJECTION_SOURCE Source;
	Source.FromMemory	= true;
	Source.RawData		= Data.RawData;
	Source.RawSize		= Data.RawSize;

#ifdef _WIN64
	if (native_target)
	{
		RetVal = InjectDLL(Source, hTargetProc, Data.Mode, Data.Method, Data.Flags, hOut, Data.Timeout, error_data);
	}
	else
	{		
		RetVal = InjectDLL_WOW64(Source, hTargetProc, Data.Mode, Data.Method, Data.Flags, hOut, Data.Timeout, error_data);
	}	
#else
	RetVal = InjectDLL(Source, hTargetProc, Data.Mode, Data.Method, Data.Flags, hOut, Data.Timeout, error_data);
#endif

	LOG(0, "Injection finished\n");

	if (!(Data.Flags & INJ_HIJACK_HANDLE))
	{
		CloseHandle(hTargetProc);
	}
	
	pData->hDllOut = hOut;

	return InitErrorStruct(Data, native_target, RetVal, error_data);
}

HRESULT __stdcall GetVersionA(char * out, size_t cb_size)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	if (!out)
	{
		LOG(0, "GetVersionA: out = nullptr\n");

		return E_INVALIDARG;
	}

	if (sizeof(GH_INJ_VERSIONA) > cb_size)
	{
		LOG(0, "GetVersionA: buffer too small (%d bytes required)\n", (int)sizeof(GH_INJ_VERSIONA));

		return TYPE_E_BUFFERTOOSMALL;
	}

	std::string s(GH_INJ_VERSIONA);
	s.copy(out, s.length());
	out[s.length()] = '\0';

	return S_OK;
}

HRESULT __stdcall GetVersionW(wchar_t * out, size_t cb_size)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	if (!out)
	{
		LOG(0, "GetVersionW: out = nullptr\n");

		return E_INVALIDARG;
	}

	if (sizeof(GH_INJ_VERSIONW) > cb_size)
	{
		LOG(0, "GetVersionA: buffer too small (%d bytes required)\n", (int)sizeof(GH_INJ_VERSIONW));

		return TYPE_E_BUFFERTOOSMALL;
	}

	std::wstring s(GH_INJ_VERSIONW);
	s.copy(out, s.length());
	out[s.length()] = '\0';

	return S_OK;
}

DWORD __stdcall GetSymbolState()
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	if (sym_ntdll_native_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
	{
		return INJ_ERR_SYMBOL_INIT_NOT_DONE;
	}

	DWORD sym_ret = sym_ntdll_native_ret.get();
	if (sym_ret != SYMBOL_ERR_SUCCESS)
	{
		LOG(0, "Native symbol loading failed: %08X\n", sym_ret);

		return sym_ret;
	}

#ifdef _WIN64
	if (sym_ntdll_wow64_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
	{
		return INJ_ERR_SYMBOL_INIT_NOT_DONE;
	}

	sym_ret = sym_ntdll_wow64_ret.get();
	if (sym_ret != SYMBOL_ERR_SUCCESS)
	{
		LOG(0, "WOW64 symbol loading failed: %08X\n", sym_ret);

		return sym_ret;
	}
#endif

	if (GetOSVersion() == g_Win7)
	{
		if (sym_kernel32_native_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
		{
			return INJ_ERR_SYMBOL_INIT_NOT_DONE;
		}

		sym_ret = sym_kernel32_native_ret.get();
		if (sym_ret != SYMBOL_ERR_SUCCESS)
		{
			LOG(0, "Native symbol loading failed: %08X\n", sym_ret);

			return sym_ret;
		}

#ifdef _WIN64
		if (sym_kernel32_wow64_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
		{
			return INJ_ERR_SYMBOL_INIT_NOT_DONE;
		}

		sym_ret = sym_kernel32_wow64_ret.get();
		if (sym_ret != SYMBOL_ERR_SUCCESS)
		{
			LOG(0, "WOW64 symbol loading failed: %08X\n", sym_ret);

			return sym_ret;
		}
#endif
	}

	LOG(0, "All symbols loaded\n");

	return SYMBOL_ERR_SUCCESS;
}

DWORD __stdcall GetImportState()
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__

	if (import_handler_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
	{
		return INJ_ERR_IMPORT_HANDLER_NOT_DONE;
	}

#ifdef _WIN64
	if (import_handler_wow64_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
	{
		return INJ_ERR_IMPORT_HANDLER_NOT_DONE;
	}
#endif

	DWORD imp_ret = import_handler_ret.get();
	if (imp_ret != INJ_ERR_SUCCESS)
	{
		LOG(0, "Import handler (native) failed: %08X\n", imp_ret);

		return imp_ret;
	}

#ifdef _WIN64
	imp_ret = import_handler_wow64_ret.get();
	if (imp_ret != INJ_ERR_SUCCESS)
	{
		LOG(0, "Import handler (wow64) failed: %08X\n", imp_ret);

		return imp_ret;
	}
#endif

	LOG(0, "Import handler finished\n");

	return INJ_ERR_SUCCESS;
}

INJECTIONDATA_INTERNAL::INJECTIONDATA_INTERNAL(const INJECTIONDATAA * pData)
{
	DllPath				= CharArrayToStdWstring(pData->szDllPath);
	ProcessID			= pData->ProcessID;
	Mode				= pData->Mode;
	Method				= pData->Method;
	Flags				= pData->Flags;
	Timeout				= pData->Timeout;
	hHandleValue		= pData->hHandleValue;
	GenerateErrorLog	= pData->GenerateErrorLog;
	hDllOut				= NULL;
}

INJECTIONDATA_INTERNAL::INJECTIONDATA_INTERNAL(const INJECTIONDATAW * pData)
{
	DllPath				= std::wstring(pData->szDllPath);
	ProcessID			= pData->ProcessID;
	Mode				= pData->Mode;
	Method				= pData->Method;
	Flags				= pData->Flags;
	Timeout				= pData->Timeout;
	hHandleValue		= pData->hHandleValue;
	GenerateErrorLog	= pData->GenerateErrorLog;
	hDllOut				= NULL;
}

INJECTIONDATA_INTERNAL::INJECTIONDATA_INTERNAL(const MEMORY_INJECTIONDATA * pData)
{
	RawData				= pData->RawData;
	RawSize				= pData->RawSize;
	ProcessID			= pData->ProcessID;
	Mode				= pData->Mode;
	Method				= pData->Method;
	Flags				= pData->Flags;
	Timeout				= pData->Timeout;
	hHandleValue		= pData->hHandleValue;
	GenerateErrorLog	= pData->GenerateErrorLog;
	hDllOut				= NULL;
}

INJECTIONDATA_INTERNAL::INJECTIONDATA_INTERNAL()
{
	RawData				= nullptr;
	RawSize				= 0;
	ProcessID			= 0;
	Mode				= INJECTION_MODE::IM_LoadLibraryExW;
	Method				= LAUNCH_METHOD::LM_NtCreateThreadEx;
	Flags				= NULL;
	Timeout				= 2000;
	hHandleValue		= 0;
	hDllOut				= NULL;
	GenerateErrorLog	= true;
}
```

`GH Injector Library/Injection.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "Injection Internal.h"
#include "Eject.h"
#include "Handle Hijacking.h"

//Cloaking options:
#define INJ_ERASE_HEADER				0x0001	//replaces the first 0x1000 bytes of the dll with 0's (takes priority over INJ_FAKE_HEADER if both are specified)
#define INJ_FAKE_HEADER					0x0002	//replaces the dlls header with the header of the ntdll.dll (superseded by INJ_ERASE_HEADER if both are specified)
#define INJ_UNLINK_FROM_PEB				0x0004	//unlinks the module from the process enviroment block (1)
#define INJ_THREAD_CREATE_CLOAKED		0x0008	//induces INJ_CTF_FAKE_START_ADDRESS | INJ_CTF_HIDE_FROM_DEBUGGER (2), see "Start Routine.h" for all options
#define INJ_SCRAMBLE_DLL_NAME			0x0010	//randomizes the dll name on disk before injecting it
#define INJ_LOAD_DLL_COPY				0x0020	//loads a copy of the dll from %temp% directory
#define INJ_HIJACK_HANDLE				0x0040	//tries to a hijack a handle from another process instead of using OpenProcess

//Notes:
///(1) ignored when manual mapping
///(2) launch method must be NtCreateThreadEx, ignored otherwise

//Manual mapping options:
#define INJ_MM_CLEAN_DATA_DIR			0x00010000	//removes data from the dlls PE header, ignored if INJ_MM_SET_PAGE_PROTECTIONS is set
#define INJ_MM_RESOLVE_IMPORTS			0x00020000	//resolves dll imports
#define INJ_MM_RESOLVE_DELAY_IMPORTS	0x00040000	//resolves delayed imports
#define INJ_MM_EXECUTE_TLS				0x00080000	//executes TLS callbacks and initializes static TLS data
#define INJ_MM_ENABLE_EXCEPTIONS		0x00100000	//enables exception handling
#define INJ_MM_SET_PAGE_PROTECTIONS		0x00200000	//sets page protections based on section characteristics, if set INJ_MM_CLEAN_DATA_DIR and INJ_MM_SHIFT_MODULE_BASE will be ignored
#define INJ_MM_INIT_SECURITY_COOKIE		0x00400000	//initializes security cookie for buffer overrun protection
#define INJ_MM_RUN_DLL_MAIN				0x00800000	//executes DllMain
													//this option induces INJ_MM_RESOLVE_IMPORTS
#define INJ_MM_RUN_UNDER_LDR_LOCK		0x01000000	//runs the DllMain under the loader lock
#define INJ_MM_SHIFT_MODULE_BASE		0x02000000	//shifts the module base by a random offset, ignored if INJ_MM_SET_PAGE_PROTECTIONS is set
#define INJ_MM_MAP_FROM_MEMORY			0x04000000	//loads the file from memory instead of from disk (1)
#define INJ_MM_LINK_MODULE				0x08000000	//links the module to the PEB

//Notes:
///(1) only works with Memory_Inject and is set automatically when that function is used, ignored when passed to (DotNet_)InjectA/W

#define MM_DEFAULT (INJ_MM_RESOLVE_IMPORTS | INJ_MM_RESOLVE_DELAY_IMPORTS | INJ_MM_INIT_SECURITY_COOKIE | INJ_MM_EXECUTE_TLS | INJ_MM_ENABLE_EXCEPTIONS | INJ_MM_RUN_DLL_MAIN | INJ_MM_SET_PAGE_PROTECTIONS | INJ_MM_RUN_UNDER_LDR_LOCK)
#define MM_MASK (MM_DEFAULT | INJ_MM_SHIFT_MODULE_BASE | INJ_MM_CLEAN_DATA_DIR | INJ_MM_MAP_FROM_MEMORY | INJ_MM_LINK_MODULE)

//ansi version of the info structure:
struct INJECTIONDATAA
{
	char			szDllPath[MAX_PATH * 2];	//fullpath to the dll to inject
	DWORD			ProcessID;					//process identifier of the target process
	INJECTION_MODE	Mode;						//injection mode
	LAUNCH_METHOD	Method;						//method to execute the remote shellcode
	DWORD			Flags;						//combination of the flags defined above
	DWORD			Timeout;					//timeout for DllMain return in milliseconds
	DWORD			hHandleValue;				//optional value to identify a handle in a process
	HINSTANCE		hDllOut;					//returned image base of the injection
	bool			GenerateErrorLog;			//if true error data is generated and stored in GH_Inj_Log.txt
};

//unicode version of the info structure (documentation above).
struct INJECTIONDATAW
{
	wchar_t			szDllPath[MAX_PATH * 2];
	DWORD			ProcessID;
	INJECTION_MODE	Mode;
	LAUNCH_METHOD	Method;
	DWORD			Flags;
	DWORD			Timeout;
	DWORD			hHandleValue;
	HINSTANCE		hDllOut;
	bool			GenerateErrorLog;
};

DWORD __stdcall InjectA(INJECTIONDATAA * pData);
DWORD __stdcall InjectW(INJECTIONDATAW * pData);
//Main injection functions (ansi/unicode).
//
//Arguments:
//		pData (INJECTIONDATAA/INJECTIONDATAW *):
///			Pointer to the information structure for the injection.
//
//Returnvalue (DWORD):
///		On success: INJ_ERR_SUCCESS.
///		On failure: One of the errorcodes defined in Error.h.

//use this to load a file from memory (manual mapping only, other methods will be ignored, make sure to set appropriate manual mapping flags)
struct MEMORY_INJECTIONDATA
{
	BYTE *			RawData;	//pointer to raw file data
	DWORD			RawSize;	//size in bytes of RawData
	DWORD			ProcessID;
	INJECTION_MODE	Mode;
	LAUNCH_METHOD	Method;
	DWORD			Flags;
	DWORD			Timeout;
	DWORD			hHandleValue;
	HINSTANCE		hDllOut;
	bool			GenerateErrorLog;
};

DWORD __stdcall Memory_Inject(MEMORY_INJECTIONDATA * pData);
//From memory injection function.
//
//Arguments:
//		pData (MEMORY_INJECTIONDATA *):
///			Pointer to the information structure for the injection
//
//Returnvalue (DWORD):
///		On success: INJ_ERR_SUCCESS.
///		On failure: One of the errorcodes defined in Error.h.

//Internal stuff
#define INJ_HIJACK_TIMEOUT	250

//Returns the version string of the current instance
HRESULT __stdcall GetVersionA(char		* out, size_t cb_size);
HRESULT __stdcall GetVersionW(wchar_t	* out, size_t cb_size);

//Returns the state of the symbol download threads
//If finished SYMBOL_ERR_SUCCESS (0) is returned 
//If still in progress INJ_ERR_SYMBOL_INIT_NOT_DONE (0x1C) is returned.
//Other error codes are defined in Error.h.
DWORD __stdcall GetSymbolState();

//Returns the state of the import handler.
//If finished INJ_ERR_SUCCESS (0) is returned.
//If still in progress INJ_ERR_IMPORT_HANDLER_NOT_DONE (0x37) is returned.
//Other error codes are defined in Error.h.
DWORD __stdcall GetImportState();

//internal stuff, use it if you know what you're doing
struct INJECTIONDATA_INTERNAL
{
	std::wstring	DllPath;
	std::wstring	TargetProcessExeFileName;

	BYTE *			RawData;
	DWORD			RawSize;

	DWORD			ProcessID;
	INJECTION_MODE	Mode;
	LAUNCH_METHOD	Method;
	DWORD			Flags;
	DWORD			Timeout;
	DWORD			hHandleValue;
	HINSTANCE		hDllOut;
	bool			GenerateErrorLog;

	INJECTIONDATA_INTERNAL(const INJECTIONDATAA			* pData);
	INJECTIONDATA_INTERNAL(const INJECTIONDATAW			* pData);
	INJECTIONDATA_INTERNAL(const MEMORY_INJECTIONDATA	* pData);
	INJECTIONDATA_INTERNAL();
};

DWORD __stdcall Inject_Internal(INJECTIONDATA_INTERNAL * pData);
```

`GH Injector Library/KernelCallback WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Start Routine.h"

DWORD SR_KernelCallback_WOW64(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, ULONG TargetSessionId, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_KernelCallback_WOW64\n");

	std::wstring InfoPath = g_RootPathW + SM_INFO_FILENAME86;

	if (FileExistsW(InfoPath))
	{
		DeleteFileW(InfoPath.c_str());
	}

	std::wofstream kc_info(InfoPath, std::ios_base::out | std::ios_base::app);
	if (!kc_info.good())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to create info file\n");

		return SR_KC_ERR_CANT_OPEN_INFO_TXT;
	}

	ProcessInfo PI;
	if (!PI.SetProcess(hTargetProc))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Can't initialize ProcessInfo class\n");

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_PROC_INFO_FAIL;
	}

	auto pPEB = PI.GetPEB_WOW64();

	if (!pPEB)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to get PEB pointer\n");

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_CANT_GET_PEB;
	}

	PEB_32 peb{ 0 };
	if (!ReadProcessMemory(hTargetProc, pPEB, &peb, sizeof(PEB_32), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_RPM_FAIL;
	}

	if (!peb.KernelCallbackTable)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Kernel callback table not initialized\n");

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_NO_INITIALIZED;
	}

	LOG(2, "Kernel callback table located at %08X\n", peb.KernelCallbackTable);

	DWORD kct[KERNEL_CALLBACK_TABLE_SIZE]{ 0 };
	SIZE_T size = KERNEL_CALLBACK_TABLE_SIZE;

	auto bRet = ReadProcessMemory(hTargetProc, MPTR(peb.KernelCallbackTable), kct, size * sizeof(DWORD), nullptr);
	if (!bRet)
	{
		if (GetLastError() == ERROR_PARTIAL_COPY) //guessed size may overlap with uninitalized page
		{
			SIZE_T base = (SIZE_T)peb.KernelCallbackTable;
			SIZE_T end = base + size * sizeof(DWORD);

			end &= 0xFFFFF000;

			size = (end - base) / sizeof(DWORD); //round down to next page boundary

			LOG(2, "Resized table to %08X bytes\n", size);

			bRet = ReadProcessMemory(hTargetProc, MPTR(peb.KernelCallbackTable), kct, size * sizeof(DWORD), nullptr);
		}

		if (!bRet)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			kc_info.close();
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_RPM_FAIL;
		}
	}

	LOG(2, "Copied kernel callback table\n");

	SIZE_T alloc_size = 0x100 + size * sizeof(DWORD);

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, alloc_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_CANT_ALLOC_MEM;
	}

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER_86

		0x53,								// + 0x00			-> push	ebx						; push ebx on stack (non volatile)
		0xBB, 0x00, 0x00, 0x00, 0x00,		// + 0x01 (+ 0x02)	-> mov	ebx, 0x00000000			; move pData into ebx (update address manually on runtime)
		0x83, 0x3B, 0x00,					// + 0x06			-> cmp	dword ptr [ebx], 0		; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x75, 0x1B,							// + 0x09			-> jne	0x26					; jump if not equal

		0xC6, 0x03, 0x01,					// + 0x0B			-> mov	byte ptr [ebx], 1		; set SR_REMOTE_DATA::State to SR_RS_Executing

		0xFF, 0x73, 0x0C,					// + 0x0E			-> push	[ebx + 0x0C]			; push pArg
		0xFF, 0x53, 0x10,					// + 0x11			-> call dword ptr [ebx + 0x10]	; call pRoutine
		0x89, 0x43, 0x04,					// + 0x14			-> mov	[ebx + 0x04], eax		; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,	// + 0x19			-> mov	eax, fs:[0x18]			; GetLastError
		0x8B, 0x40, 0x34,					// + 0x1D			-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,					// + 0x20			-> mov	[ebx + 0x08], eax		; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,					// + 0x23			-> mov	byte ptr [ebx], 2		; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,								// + 0x26			-> pop	ebx						; restore ebx
		0x31, 0xC0,							// + 0x27			-> xor	eax, eax				; set eax to 0 to prevent further handling of the message
		0xC2, 0x04, 0x00					// + 0x29			-> ret	0x04					; return
	}; // SIZE = 0x2A (+ sizeof(SR_REMOTE_DATA_WOW64))

	*ReCa<DWORD *>(Shellcode + 0x02 + sizeof(SR_REMOTE_DATA_WOW64)) = MDWD(pMem);

	DWORD pRemoteFunc = MDWD(pMem) + sizeof(SR_REMOTE_DATA_WOW64);

	auto * sr_data = ReCa<SR_REMOTE_DATA_WOW64 *>(Shellcode);
	sr_data->pArg		= pArg;
	sr_data->pRoutine	= pRoutine;

	if (!WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_WPM_FAIL;
	}

	LOG(2, "Hook will be called with:\n");
	LOG(3, "pRoutine = %08X\n", MDWD(pRemoteFunc));
	LOG(3, "pArg     = %08X\n", MDWD(pMem));

	kct[0] = pRemoteFunc;
	auto table_offset	= ALIGN_UP(sizeof(Shellcode), sizeof(DWORD));
	auto pTable			= ReCa<BYTE *>(pMem) + table_offset;

	if (!WriteProcessMemory(hTargetProc, pTable, kct, size * sizeof(DWORD), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_WPM_FAIL;
	}

	LOG(2, "Copied kernel callback table into target process at %08X\n", MDWD(pTable));

	if (!WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &pTable, sizeof(DWORD), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_WPM_FAIL;
	}

	LOG(2, "Updated kernel callback table pointer\n");

	kc_info << std::dec << GetProcessId(hTargetProc) << std::endl;
	kc_info.close();

	std::wstring smPath = g_RootPathW + SM_EXE_FILENAME86;

	wchar_t cmdLine[] = L"\"" SM_EXE_FILENAME86 "\" " ID_KC;

	PROCESS_INFORMATION pi{ 0 };
	STARTUPINFOW		si{ 0 };
	si.cb			= sizeof(si);
	si.dwFlags		= STARTF_USESHOWWINDOW;
	si.wShowWindow	= SW_HIDE;

	LOG(2, "Data and command line prepared\n");

	if (TargetSessionId != SESSION_ID_INVALID)
	{
		LOG(2, "Target process is in a different session\n");

		HANDLE hUserToken = nullptr;
		if (!WTSQueryUserToken(TargetSessionId, &hUserToken))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "WTSQueryUserToken failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(DWORD), nullptr);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_WTSQUERY_FAIL;
		}

		HANDLE hNewToken = nullptr;
		if (!DuplicateTokenEx(hUserToken, MAXIMUM_ALLOWED, nullptr, SecurityIdentification, TokenPrimary, &hNewToken))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "DuplicateTokenEx failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(DWORD), nullptr);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_DUP_TOKEN_FAIL;
		}

		DWORD SizeOut = 0;
		TOKEN_LINKED_TOKEN admin_token{ 0 };
		if (!GetTokenInformation(hNewToken, TokenLinkedToken, &admin_token, sizeof(admin_token), &SizeOut))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "GetTokenInformation failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(DWORD), nullptr);
			CloseHandle(hNewToken);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_GET_ADMIN_TOKEN_FAIL;
		}

		HANDLE hAdminToken = admin_token.LinkedToken;

		LOG(2, "Token prepared\n");

		LOG(2, "Launching %ls:\n       command line = %ls\n", SM_EXE_FILENAME86, cmdLine);

		if (!CreateProcessAsUserW(hAdminToken, smPath.c_str(), cmdLine, nullptr, nullptr, FALSE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "CreateProcessAsUserW failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(DWORD), nullptr);
			CloseHandle(hAdminToken);
			CloseHandle(hNewToken);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_CANT_CREATE_PROCESS;
		}

		LOG(2, "%ls launched\n", SM_EXE_FILENAME86);

		CloseHandle(hAdminToken);
		CloseHandle(hNewToken);
		CloseHandle(hUserToken);
	}
	else
	{
		LOG(2, "Launching %ls:\n       command line = %ls\n", SM_EXE_FILENAME86, cmdLine);

		if (!CreateProcessW(smPath.c_str(), cmdLine, nullptr, nullptr, FALSE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "CreateProcessW failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(DWORD), nullptr);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_CANT_CREATE_PROCESS;
		}

		LOG(2, "%ls launched\n", SM_EXE_FILENAME86);
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	auto Timer = GetTickCount64();

	DWORD dwWaitRet = WaitForSingleObject(pi.hProcess, Timeout);
	if (dwWaitRet != WAIT_OBJECT_0)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "%ls timed out: %08X\n", SM_EXE_FILENAME86, error_data.AdvErrorCode);

		WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(DWORD), nullptr);
		TerminateProcess(pi.hProcess, 0);
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_KC_TIMEOUT;
	}

	WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(DWORD), nullptr);

	DWORD ExitCode = 0;
	GetExitCodeProcess(pi.hProcess, &ExitCode);

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	DeleteFileW(InfoPath.c_str());

	if (ExitCode != KC_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, ExitCode);

		LOG(2, "%ls failed: %08X\n", SM_EXE_FILENAME, ExitCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return ExitCode;
	}

	SR_REMOTE_DATA_WOW64 data{ };
	data.State			= (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	while (GetTickCount64() - Timer < Timeout)
	{
		dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet && data.State == (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished)
		{
			LOG(2, "Shelldata retrieved\n");

			break;
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}

			return SR_KC_ERR_RPM_FAIL;
		}
	}

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	if (data.State != (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shell timed out\n");

		return SR_KC_ERR_REMOTE_TIMEOUT;
	}

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out = data.Ret;

	return SR_ERR_SUCCESS;
}

#endif
```

`GH Injector Library/KernelCallback.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Start Routine.h"

DWORD SR_KernelCallback(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, ULONG TargetSessionId, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_KernelCallback\n");

	std::wstring InfoPath = g_RootPathW + SM_INFO_FILENAME;
	if (FileExistsW(InfoPath))
	{
		DeleteFileW(InfoPath.c_str());
	}

	std::wofstream kc_info(InfoPath, std::ios_base::out | std::ios_base::app);
	if (!kc_info.good())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to create info file\n");

		return SR_KC_ERR_CANT_OPEN_INFO_TXT;
	}

	ProcessInfo PI;
	if (!PI.SetProcess(hTargetProc))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Can't initialize ProcessInfo class\n");

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_PROC_INFO_FAIL;
	}

	auto pPEB = PI.GetPEB();

	if (!pPEB)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to get PEB pointer\n");

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_CANT_GET_PEB;
	}

	PEB peb{ 0 };
	if (!ReadProcessMemory(hTargetProc, pPEB, &peb, sizeof(PEB), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_RPM_FAIL;
	}

	if (!peb.KernelCallbackTable)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Kernel callback table not initialized\n");

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_NO_INITIALIZED;
	}

	LOG(2, "Kernel callback table located at %p\n", peb.KernelCallbackTable);

	void * kct[KERNEL_CALLBACK_TABLE_SIZE]{ 0 };
	SIZE_T size = KERNEL_CALLBACK_TABLE_SIZE;

	auto bRet = ReadProcessMemory(hTargetProc, peb.KernelCallbackTable, kct, size * sizeof(void *), nullptr);
	if (!bRet)
	{
		if (GetLastError() == ERROR_PARTIAL_COPY) //guessed size may overlap with uninitalized page
		{
			ULONG_PTR base	= ReCa<ULONG_PTR>(peb.KernelCallbackTable);
			ULONG_PTR end	= base + size * sizeof(void *);
			
#ifdef _WIN64
			end &= 0xFFFFFFFFFFFFF000;
#else
			end &= 0xFFFFF000;
#endif

			size = (end - base) / sizeof(void *); //round down to next page boundary

			LOG(2, "Resized table to %08X bytes\n", size);

			bRet = ReadProcessMemory(hTargetProc, peb.KernelCallbackTable, kct, size * sizeof(void *), nullptr);
		}

		if (!bRet)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			kc_info.close();
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_RPM_FAIL;
		}
	}

	LOG(2, "Copied kernel callback table\n");

	SIZE_T alloc_size = 0x100 + size * sizeof(void *);

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, alloc_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_CANT_ALLOC_MEM;
	}

	/*
		DWORD __stdcall __fnCOPYDATA_Shell(FNCOPYDATAMSG * pMsg)
		{			
			UNREFERENCED_PARAMETER(pMsg);

			SR_REMOTE_DATA * data = ReCa<SR_REMOTE_DATA *>(ReCa<BYTE *>(Hookproc_Shell) - sizeof(SR_REMOTE_DATA));
			if (data->State == SR_REMOTE_STATE::SR_RS_ExecutionPending)
			{
				data->State = SR_REMOTE_STATE::SR_RS_Executing;
				
				data->Ret = data->pRoutine(data->pArg);
				data->LastWin32Error = GetLastError();

				data->State = SR_REMOTE_STATE::SR_RS_ExecutionFinished;
			}

			return 0;
		}
	*/

#ifdef _WIN64

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x53,													// + 0x00	-> push rbx						; push rbx on stack (non volatile)
		0x48, 0x8D, 0x1D, 0xC8, 0xFF, 0xFF, 0xFF,				// + 0x01	-> lea rbx, [-0x30]				; load pData into rbx

		0x80, 0x3B, 0x00,										// + 0x08	-> cmp	byte ptr [rbx], 0		; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x75, 0x28,												// + 0x0B	-> jne	0x35					; jump if not equal

		0xC6, 0x03, 0x01,										// + 0x0D	-> mov	byte ptr [rbx], 1		; set SR_REMOTE_DATA::State to SR_RS_Executing

		0x48, 0x8B, 0x4B, 0x18,									// + 0x10	-> mov  rcx, [rbx + 0x18]		; move pArg into rcx
		0x48, 0x83, 0xEC, 0x20,									// + 0x14	-> sub	rsp, 0x20				; reserve stack
		0xFF, 0x53, 0x20,										// + 0x17	-> call qword ptr [rbx + 0x20]	; call pRoutine
		0x48, 0x83, 0xC4, 0x20,									// + 0x1B	-> add	rsp, 0x20				; update stack
		0x48, 0x89, 0x43, 0x08,									// + 0x1F	-> mov	[rbx + 0x08], rax		; store returned value

		0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00,	// + 0x23	-> mov	rax, gs:[0x30]			; GetLastError
		0x8B, 0x40, 0x68,										// + 0x2C	-> mov	eax, [rax + 0x68]
		0x89, 0x43, 0x10,										// + 0x2F	-> mov	[rbx + 0x10], eax		; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,										// + 0x32	-> mov	byte ptr [rbx], 2		; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,													// + 0x35	-> pop	rbx						; restore rbx

		0x48, 0x31, 0xC0,										// + 0x36	-> xor	rax, rax				; set rax to 0 to prevent further handling of the message

		0xC3													// + 0x39	-> ret							; return
	}; // SIZE = 0x3A (+ sizeof(SR_REMOTE_DATA))

#else

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x53,								// + 0x00			-> push	ebx						; push ebx on stack (non volatile)
		0xBB, 0x00, 0x00, 0x00, 0x00,		// + 0x01 (+ 0x02)	-> mov	ebx, 0x00000000			; move pData into ebx (update address manually on runtime)
		0x83, 0x3B, 0x00,					// + 0x06			-> cmp	dword ptr [ebx], 0		; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x75, 0x1B,							// + 0x09			-> jne	0x26					; jump if not equal

		0xC6, 0x03, 0x01,					// + 0x0B			-> mov	byte ptr [ebx], 1		; set SR_REMOTE_DATA::State to SR_RS_Executing

		0xFF, 0x73, 0x0C,					// + 0x0E			-> push	[ebx + 0x0C]			; push pArg
		0xFF, 0x53, 0x10,					// + 0x11			-> call dword ptr [ebx + 0x10]	; call pRoutine
		0x89, 0x43, 0x04,					// + 0x14			-> mov	[ebx + 0x04], eax		; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,	// + 0x19			-> mov	eax, fs:[0x18]			; GetLastError
		0x8B, 0x40, 0x34,					// + 0x1D			-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,					// + 0x20			-> mov	[ebx + 0x08], eax		; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,					// + 0x23			-> mov	byte ptr [ebx], 2		; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,								// + 0x26			-> pop	ebx						; restore ebx
		0x31, 0xC0,							// + 0x27			-> xor	eax, eax				; set eax to 0 to prevent further handling of the message
		0xC2, 0x04, 0x00					// + 0x29			-> ret	0x04					; return
	}; // SIZE = 0x2A (+ sizeof(SR_REMOTE_DATA))

	*ReCa<void **>(Shellcode + 0x02 + sizeof(SR_REMOTE_DATA)) = pMem;

#endif

	void * pRemoteFunc = ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA);

	auto * sr_data = ReCa<SR_REMOTE_DATA *>(Shellcode);
	sr_data->pArg		= pArg;
	sr_data->pRoutine	= pRoutine;

	if (!WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_WPM_FAIL;
	}

	LOG(2, "Hook will be called with:\n");
	LOG(3, "pRoutine = %p\n", pRemoteFunc);
	LOG(3, "pArg     = %p\n", pMem);

	kct[0] = pRemoteFunc;
	auto table_offset	= ALIGN_UP(sizeof(Shellcode), sizeof(void *));
	auto pTable			= ReCa<BYTE *>(pMem) + table_offset;

	if (!WriteProcessMemory(hTargetProc, pTable, kct, size * sizeof(void *), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_WPM_FAIL;
	}

	LOG(2, "Copied kernel callback table into target process at %p\n", pTable);

	if (!WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &pTable, sizeof(void *), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		kc_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_KC_ERR_WPM_FAIL;
	}

	LOG(2, "Updated kernel callback table pointer\n");

	kc_info << std::dec << GetProcessId(hTargetProc) << std::endl;
	kc_info.close();

	std::wstring smPath = g_RootPathW + SM_EXE_FILENAME;

	wchar_t cmdLine[] = L"\"" SM_EXE_FILENAME "\" " ID_KC;

	PROCESS_INFORMATION pi{ 0 };
	STARTUPINFOW		si{ 0 };
	si.cb			= sizeof(si);
	si.dwFlags		= STARTF_USESHOWWINDOW;
	si.wShowWindow	= SW_HIDE;

	LOG(2, "Data and command line prepared\n");

	if (TargetSessionId != SESSION_ID_INVALID)
	{
		LOG(2, "Target process is in a different session\n");

		HANDLE hUserToken = nullptr;
		if (!WTSQueryUserToken(TargetSessionId, &hUserToken))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "WTSQueryUserToken failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(void *), nullptr);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_WTSQUERY_FAIL;
		}

		HANDLE hNewToken = nullptr;
		if (!DuplicateTokenEx(hUserToken, MAXIMUM_ALLOWED, nullptr, SecurityIdentification, TokenPrimary, &hNewToken))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "DuplicateTokenEx failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(void *), nullptr);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_DUP_TOKEN_FAIL;
		}

		DWORD SizeOut = 0;
		TOKEN_LINKED_TOKEN admin_token{ 0 };
		if (!GetTokenInformation(hNewToken, TokenLinkedToken, &admin_token, sizeof(admin_token), &SizeOut))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "GetTokenInformation failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(void *), nullptr);
			CloseHandle(hNewToken);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_GET_ADMIN_TOKEN_FAIL;
		}

		HANDLE hAdminToken = admin_token.LinkedToken;

		LOG(2, "Token prepared\n");

		LOG(2, "Launching %ls:\n       command line = %ls\n", SM_EXE_FILENAME, cmdLine);

		if (!CreateProcessAsUserW(hAdminToken, smPath.c_str(), cmdLine, nullptr, nullptr, FALSE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "CreateProcessAsUserW failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(void *), nullptr);
			CloseHandle(hAdminToken);
			CloseHandle(hNewToken);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_CANT_CREATE_PROCESS;
		}

		LOG(2, "%ls launched\n", SM_EXE_FILENAME);

		CloseHandle(hAdminToken);
		CloseHandle(hNewToken);
		CloseHandle(hUserToken);
	}
	else
	{
		LOG(2, "Launching %ls:\n       command line = %ls\n", SM_EXE_FILENAME, cmdLine);

		if (!CreateProcessW(smPath.c_str(), cmdLine, nullptr, nullptr, FALSE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "CreateProcessW failed: %08X\n", error_data.AdvErrorCode);

			WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(void *), nullptr);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_KC_ERR_CANT_CREATE_PROCESS;
		}

		LOG(2, "%ls launched\n", SM_EXE_FILENAME);
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	auto Timer = GetTickCount64();

	HANDLE handles[] = { pi.hProcess, g_hInterruptEvent };

	DWORD dwWaitRet = WaitForMultipleObjects(2, handles, FALSE, Timeout);
	if (dwWaitRet != WAIT_OBJECT_0)
	{
		if (dwWaitRet == (WAIT_OBJECT_0 + 1))
		{
			INIT_ERROR_DATA(error_data, dwWaitRet);

			LOG(2, "Interrupt!\n");
		}
		else
		{
			if (dwWaitRet == WAIT_FAILED)
			{
				INIT_ERROR_DATA(error_data, GetLastError());
			}
			else
			{
				INIT_ERROR_DATA(error_data, dwWaitRet);
			}

			LOG(2, "%ls timed out: %08X\n", SM_EXE_FILENAME, error_data.AdvErrorCode);
		}
		
		WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(void *), nullptr);
		TerminateProcess(pi.hProcess, 0);
		DeleteFileW(InfoPath.c_str());

		if (dwWaitRet == (WAIT_OBJECT_0 + 1))
		{
			SetEvent(g_hInterruptedEvent);

			return SR_ERR_INTERRUPT;
		}

		return SR_KC_ERR_KC_TIMEOUT;
	}

	WriteProcessMemory(hTargetProc, &pPEB->KernelCallbackTable, &peb.KernelCallbackTable, sizeof(void *), nullptr);

	DWORD ExitCode = 0;
	GetExitCodeProcess(pi.hProcess, &ExitCode);

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	DeleteFileW(InfoPath.c_str());

	if (ExitCode != KC_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, ExitCode);

		LOG(2, "%ls failed: %08X\n", SM_EXE_FILENAME, ExitCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return ExitCode;
	}

	SR_REMOTE_DATA data{ };
	data.State			= SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	while (GetTickCount64() - Timer < Timeout)
	{
		dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet && data.State == SR_REMOTE_STATE::SR_RS_ExecutionFinished)
		{
			LOG(2, "Shelldata retrieved\n");

			break;
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}

			return SR_KC_ERR_RPM_FAIL;
		}
	}

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	if (data.State != SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shell timed out\n");

		return SR_KC_ERR_REMOTE_TIMEOUT;
	}

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out = data.Ret;

	return SR_ERR_SUCCESS;
}
```

`GH Injector Library/Manual Mapping Internal.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "VEH Shell.h"

#define RELOC_FLAG86(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_HIGHLOW)
#define RELOC_FLAG64(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_DIR64)

#ifdef _WIN64
#define RELOC_FLAG RELOC_FLAG64
#else
#define RELOC_FLAG RELOC_FLAG86
#endif

#define HKDATASIG_64 0x1234123412341234
#define HKDATASIG_32 0x12341234

#ifdef _WIN64
#define HKDATASIG HKDATASIG_64
#else
#define HKDATASIG HKDATASIG_32
#endif

#define DLL_NAME_BUFFER_SIZE 0x20
#define HOOKED_FUNCS_NAME_BUFFER_SIZE 0x20

struct VEH_SHELL_DATA;

namespace MMAP_NATIVE
{
	struct MANUAL_MAPPING_DATA;
	struct MANUAL_MAPPING_FUNCTION_TABLE;
}

using f_DLL_ENTRY_POINT = BOOL(WINAPI *)(HINSTANCE hDll, DWORD dwReason, void * pReserved);
using f_MMI_FUNCTION = DWORD(__stdcall *)(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);

//list to track imports and unload on failure
typedef struct _MM_DEPENDENCY_RECORD
{
	struct _MM_DEPENDENCY_RECORD * Next = nullptr;
	struct _MM_DEPENDENCY_RECORD * Prev = nullptr;

	HANDLE DllHandle = nullptr;
	UNICODE_STRING DllName{ 0 };
	wchar_t Buffer[0x100] { 0 };
	
} MM_DEPENDENCY_RECORD, * PMM_DEPENDENCY_RECORD;

DWORD __declspec(code_seg(".mmap_sec$01")) __stdcall ManualMapping_Shell		(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$02")) __stdcall MMI_MapSections			(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$03")) __stdcall MMI_RelocateImage			(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$04")) __stdcall MMI_InitializeCookie		(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$06")) __stdcall MMI_LoadImports			(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$07")) __stdcall MMI_LoadDelayImports		(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$08")) __stdcall MMI_SetPageProtections		(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$09")) __stdcall MMI_EnableExceptions		(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$0A")) __stdcall MMI_HandleTLS				(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$0B")) __stdcall MMI_ExecuteDllMain			(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$0C")) __stdcall MMI_CleanDataDirectories	(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$0D")) __stdcall MMI_CloakHeader			(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);
DWORD __declspec(code_seg(".mmap_sec$0E")) __stdcall MMI_CleanUp				(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData);

NTSTATUS __declspec(code_seg(".mmap_sec$11")) __stdcall MMIH_ResolveFilePath(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData, UNICODE_STRING * Module);
NTSTATUS __declspec(code_seg(".mmap_sec$12")) __stdcall MMIH_PreprocessModuleName(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData, const char * szModule, UNICODE_STRING * ModuleName, LDRP_LOAD_CONTEXT_FLAGS * CtxFlags);
NTSTATUS __declspec(code_seg(".mmap_sec$13")) __stdcall MMIH_LoadModule(MMAP_NATIVE::MANUAL_MAPPING_DATA * pData, UNICODE_STRING * Module, LDRP_LOAD_CONTEXT_FLAGS CtxFlag, HINSTANCE * hModule, MM_DEPENDENCY_RECORD ** head);

DWORD __declspec(code_seg(".mmap_sec$14")) MMAP_SEC_END();

namespace MMAP_NATIVE
{
	using namespace NATIVE;

	ALIGN struct MANUAL_MAPPING_FUNCTION_TABLE
	{
		ALIGN NT_FUNC_LOCAL(NtOpenFile);
		ALIGN NT_FUNC_LOCAL(NtReadFile);
		ALIGN NT_FUNC_LOCAL(NtClose);

		ALIGN NT_FUNC_LOCAL(NtSetInformationFile);
		ALIGN NT_FUNC_LOCAL(NtQueryInformationFile);

		ALIGN NT_FUNC_LOCAL(NtAllocateVirtualMemory);
		ALIGN NT_FUNC_LOCAL(NtProtectVirtualMemory);
		ALIGN NT_FUNC_LOCAL(NtFreeVirtualMemory);

		ALIGN NT_FUNC_LOCAL(NtCreateSection);
		ALIGN NT_FUNC_LOCAL(NtMapViewOfSection);

		ALIGN NT_FUNC_LOCAL(memmove);
		ALIGN NT_FUNC_LOCAL(RtlZeroMemory);
		ALIGN NT_FUNC_LOCAL(RtlAllocateHeap);
		ALIGN NT_FUNC_LOCAL(RtlFreeHeap);

		ALIGN NT_FUNC_LOCAL(LdrpLoadDll);
		ALIGN NT_FUNC_LOCAL(LdrpLoadDllInternal);
		ALIGN NT_FUNC_LOCAL(LdrGetProcedureAddress);

		ALIGN NT_FUNC_LOCAL(LdrUnloadDll);

		ALIGN NT_FUNC_LOCAL(RtlAnsiStringToUnicodeString);
		ALIGN NT_FUNC_LOCAL(RtlUnicodeStringToAnsiString);
		ALIGN NT_FUNC_LOCAL(RtlCompareUnicodeString);
		ALIGN NT_FUNC_LOCAL(RtlCompareString);

		ALIGN NT_FUNC_LOCAL(LdrGetDllPath);
		ALIGN NT_FUNC_LOCAL(LdrpPreprocessDllName);
		ALIGN NT_FUNC_LOCAL(RtlInsertInvertedFunctionTable);
#ifdef _WIN64
		ALIGN NT_FUNC_LOCAL(RtlAddFunctionTable);
#endif
		ALIGN NT_FUNC_LOCAL(LdrpHandleTlsData);

		ALIGN NT_FUNC_LOCAL(LdrLockLoaderLock);
		ALIGN NT_FUNC_LOCAL(LdrUnlockLoaderLock);

		ALIGN NT_FUNC_LOCAL(LdrpDereferenceModule);

		ALIGN NT_FUNC_LOCAL(LdrProtectMrdata);

		ALIGN NT_FUNC_LOCAL(RtlAddVectoredExceptionHandler);
		ALIGN NT_FUNC_LOCAL(RtlRemoveVectoredExceptionHandler);

		ALIGN NT_FUNC_LOCAL(LdrpModuleBaseAddressIndex);
		ALIGN NT_FUNC_LOCAL(LdrpMappingInfoIndex);
		ALIGN NT_FUNC_LOCAL(LdrpHeap);
		ALIGN NT_FUNC_LOCAL(LdrpInvertedFunctionTable);
		ALIGN NT_FUNC_LOCAL(LdrpDefaultPath);
		ALIGN NT_FUNC_LOCAL(LdrpTlsList);

		ALIGN f_MMI_FUNCTION MMP_Shell					= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_MapSections			= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_RelocateImage			= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_InitializeCookie		= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_LoadImports			= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_LoadDelayImports		= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_SetPageProtections	= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_EnableExceptions		= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_HandleTLS				= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_ExecuteDllMain		= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_CleanDataDirectories	= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_CloakHeader			= nullptr;
		ALIGN f_MMI_FUNCTION MMIP_CleanUp				= nullptr;

		ALIGN decltype(MMIH_ResolveFilePath)			* MMIHP_ResolveFilePath				= nullptr;
		ALIGN decltype(MMIH_PreprocessModuleName)		* MMIHP_PreprocessModuleName		= nullptr;
		ALIGN decltype(MMIH_LoadModule)					* MMIHP_LoadModule					= nullptr;

		ALIGN void * pLdrpHeap = nullptr;

		MANUAL_MAPPING_FUNCTION_TABLE();
	};

	ALIGN struct MANUAL_MAPPING_DATA
	{
		ALIGN HINSTANCE	hRet		= NULL;
		ALIGN DWORD		Flags		= NULL;
		ALIGN NTSTATUS	ntRet		= STATUS_SUCCESS;

		ALIGN WORD ShiftOffset = 0;

		ALIGN UNICODE_STRING DllPath{ 0 };
		ALIGN wchar_t szPathBuffer[MAX_PATH]{ 0 };

		ALIGN wchar_t NtPathPrefix[8] = L"\\??\\\0\0\0";

		ALIGN DWORD OSVersion		= 0;
		ALIGN DWORD OSBuildNumber	= 0;

		ALIGN BYTE				*	pVEHShell			= nullptr;
		ALIGN DWORD					VEHShellSize		= 0;

		ALIGN HANDLE				hVEH				= nullptr;
		ALIGN BYTE				*	pVEHShellMapped		= nullptr;
		ALIGN VEH_SHELL_DATA	*	pVEHShellData		= nullptr;
		ALIGN void				*	pFakeSEHDirectory	= nullptr;

		ALIGN BYTE *	pAllocationBase	= nullptr;
		ALIGN BYTE *	pImageBase		= nullptr;
		ALIGN BYTE *	pRawData		= nullptr;
		ALIGN DWORD		RawSize			= 0;
		ALIGN HANDLE	hDllFile		= nullptr;
		
		ALIGN IMAGE_DOS_HEADER		* pDosHeader		= nullptr;
		ALIGN IMAGE_NT_HEADERS		* pNtHeaders		= nullptr;
		ALIGN IMAGE_OPTIONAL_HEADER	* pOptionalHeader	= nullptr;
		ALIGN IMAGE_FILE_HEADER		* pFileHeader		= nullptr;

		ALIGN MM_DEPENDENCY_RECORD * pImportsHead		= nullptr;
		ALIGN MM_DEPENDENCY_RECORD * pDelayImportsHead	= nullptr;

		ALIGN MANUAL_MAPPING_FUNCTION_TABLE * FunctionTable = nullptr;
	};
}

#ifdef _WIN64

namespace MMAP_WOW64
{
	using namespace WOW64;

	ALIGN_86 struct MANUAL_MAPPING_FUNCTION_TABLE_WOW64
	{
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtOpenFile);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtReadFile);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtClose);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtSetInformationFile);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtQueryInformationFile);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtAllocateVirtualMemory);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtProtectVirtualMemory);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtFreeVirtualMemory);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtCreateSection);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(NtMapViewOfSection);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(memmove);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlZeroMemory);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlAllocateHeap);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlFreeHeap);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpLoadDll);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpLoadDllInternal);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrGetProcedureAddress);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrUnloadDll);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlAnsiStringToUnicodeString);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlUnicodeStringToAnsiString);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlCompareUnicodeString);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlCompareString);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrGetDllPath);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpPreprocessDllName);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlInsertInvertedFunctionTable);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpHandleTlsData);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrLockLoaderLock);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrUnlockLoaderLock);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpDereferenceModule);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrProtectMrdata);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlAddVectoredExceptionHandler);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(RtlRemoveVectoredExceptionHandler);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpModuleBaseAddressIndex);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpMappingInfoIndex);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpHeap);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpInvertedFunctionTable);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpDefaultPath);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(LdrpTlsList);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMP_Shell);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_MapSections);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_RelocateImage);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_InitializeCookie);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_LoadImports);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_LoadDelayImports);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_SetPageProtections);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_EnableExceptions);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_HandleTLS);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_ExecuteDllMain);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_CleanDataDirectories);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_CloakHeader);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIP_CleanUp);

		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIHP_ResolveFilePath);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIHP_PreprocessModuleName);
		ALIGN_86 WOW64_FUNCTION_POINTER_LOCAL(MMIHP_LoadModule);

		ALIGN_86 DWORD pLdrpHeap = 0;

		MANUAL_MAPPING_FUNCTION_TABLE_WOW64();
	};
	
	ALIGN_86 struct MANUAL_MAPPING_DATA_WOW64
	{
		ALIGN_86 DWORD	hRet	= NULL;
		ALIGN_86 DWORD	Flags	= NULL;
		ALIGN_86 DWORD	ntRet	= STATUS_SUCCESS;

		ALIGN_86 WORD ShiftOffset = 0;

		ALIGN_86 UNICODE_STRING_32 DllPath{ 0 };
		ALIGN_86 wchar_t szPathBuffer[MAX_PATH]{ 0 };

		ALIGN_86 wchar_t NtPathPrefix[8] = L"\\??\\\0\0\0";

		ALIGN_86 DWORD OSVersion		= 0;
		ALIGN_86 DWORD OSBuildNumber	= 0;

		ALIGN_86 DWORD pVEHShell	= 0;
		ALIGN_86 DWORD VEHShellSize = 0;

		ALIGN_86 DWORD hVEH					= 0;
		ALIGN_86 DWORD pVEHShellMapped		= 0;
		ALIGN_86 DWORD pVEHShellData		= 0;
		ALIGN_86 DWORD pFakeSEHDirectory	= 0;

		ALIGN_86 DWORD pAllocationBase	= 0;
		ALIGN_86 DWORD pImageBase		= 0;
		ALIGN_86 DWORD pRawData			= 0;
		ALIGN_86 DWORD RawSize			= 0;
		ALIGN_86 DWORD hDllFile			= 0;
		
		ALIGN_86 DWORD pDosHeader		= 0;
		ALIGN_86 DWORD pNtHeaders		= 0;
		ALIGN_86 DWORD pOptionalHeader	= 0;
		ALIGN_86 DWORD pFileHeader		= 0;

		ALIGN_86 DWORD pImportsHead			= 0;
		ALIGN_86 DWORD pDelayImportsHead	= 0;

		ALIGN_86 DWORD FunctionTable = 0;
	};
}

#endif

#pragma region inlined helper functions

__forceinline UINT_PTR bit_rotate_r(UINT_PTR val, int count)
{
	return (val >> count) | (val << (-count));
}

template <class T>
__forceinline T * NewObject(MMAP_NATIVE::MANUAL_MAPPING_FUNCTION_TABLE * f, size_t Count = 1)
{
	return ReCa<T *>(f->RtlAllocateHeap(f->pLdrpHeap, HEAP_ZERO_MEMORY, sizeof(T) * Count));
}

template <class T>
__forceinline void DeleteObject(MMAP_NATIVE::MANUAL_MAPPING_FUNCTION_TABLE * f, T * Object)
{
	if (Object)
	{
		f->RtlFreeHeap(f->pLdrpHeap, NULL, Object);
	}
}

__forceinline WORD SizeAnsiString(const char * szString)
{
	const char * c = szString;
	while (*c)
	{
		c++;
	}

	return (WORD)((c - szString) * sizeof(char));
}

__forceinline WORD SizeUnicodeString(const wchar_t * szString)
{
	const wchar_t * c = szString;
	while (*c)
	{
		c++;
	}

	return (WORD)((c - szString) * sizeof(wchar_t));
}

__forceinline bool InitAnsiString(MMAP_NATIVE::MANUAL_MAPPING_FUNCTION_TABLE * f, ANSI_STRING * String, const char * szString)
{
	const char * c = szString;
	while (*c)
	{
		c++;
	}

	WORD Length = (WORD)(c - szString);
	if (!Length)
	{
		return false;
	}

	String->szBuffer = NewObject<char>(f, (((size_t)Length) + 1) / sizeof(char));
	if (!String->szBuffer)
	{
		return false;
	}

	String->Length = Length;
	String->MaxLength = Length + 1 * sizeof(char);
	f->memmove(String->szBuffer, szString, Length);

	return true;
}

#pragma endregion
```

`GH Injector Library/Manual Mapping WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Manual Mapping.h"
#include "WOW64 Shells.h"

using namespace WOW64;
using namespace MMAP_WOW64;

DWORD MMAP_WOW64::ManualMap_WOW64(const INJECTION_SOURCE & Source, HANDLE hTargetProc, LAUNCH_METHOD Method, DWORD Flags, HINSTANCE & hOut, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(1, "Begin ManualMap_WOW64\n");

	MANUAL_MAPPING_DATA_WOW64 data{ 0 };
	data.Flags			= Flags;
	data.OSVersion		= GetOSVersion();
	data.OSBuildNumber	= GetOSBuildVersion();

	if (Source.FromMemory)
	{
		data.RawSize = Source.RawSize;
	}
	else
	{
		size_t len = Source.DllPath.length();
		size_t max_len = sizeof(data.szPathBuffer) / sizeof(wchar_t);
		if (len > max_len)
		{
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(1, "Path too long: %d characters, buffer size: %d\n", len, max_len);

			return INJ_ERR_STRING_TOO_LONG;
		}

		data.DllPath.Length = (WORD)(len * sizeof(wchar_t));
		data.DllPath.MaxLength = (WORD)sizeof(data.szPathBuffer);
		Source.DllPath.copy(data.szPathBuffer, Source.DllPath.length());
	}

	LOG(1, "Shell data initialized\n");

	if (Flags & INJ_MM_SHIFT_MODULE_BASE && !(Flags & INJ_MM_SET_PAGE_PROTECTIONS))
	{
		DWORD seed = GetTickCount();
		std::mt19937 gen(seed);
		std::uniform_int_distribution<WORD> dis(MIN_SHIFT_OFFSET, MAX_SHIFT_OFFSET);

		WORD shift_offset = dis(gen);
		shift_offset = ALIGN_UP(shift_offset, BASE_ALIGNMENT);

		data.ShiftOffset = shift_offset;

		LOG(1, "Shift offset = %04X\n", shift_offset);
	}

	ULONG_PTR ShellSize		= WOW64_SEC_END - ManualMapping_Shell_WOW64;
	ULONG_PTR VEHShellSize	= sizeof(VectoredHandlerShell_WOW64);

	if ((Flags & INJ_MM_ENABLE_EXCEPTIONS) == 0)
	{
		VEHShellSize = 0;
	}

	auto AllocationSize = sizeof(MANUAL_MAPPING_DATA_WOW64) + sizeof(MANUAL_MAPPING_FUNCTION_TABLE_WOW64) + ShellSize + VEHShellSize + BASE_ALIGNMENT * 4;
	if (Source.FromMemory)
	{
		AllocationSize += (SIZE_T)Source.RawSize + BASE_ALIGNMENT;
	}

	BYTE * pAllocBase = ReCa<BYTE *>(VirtualAllocEx(hTargetProc, nullptr, AllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
	if (!pAllocBase)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return INJ_ERR_OUT_OF_MEMORY_EXT;
	}

	BYTE * pArg				= pAllocBase;
	BYTE * pShells			= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pArg)			+ sizeof(MANUAL_MAPPING_DATA_WOW64),			BASE_ALIGNMENT));
	BYTE * pVEHShell		= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pShells)		+ ShellSize,									BASE_ALIGNMENT));
	BYTE * pFunctionTable	= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pVEHShell)		+ VEHShellSize,									BASE_ALIGNMENT));
	BYTE * pRawData			= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pFunctionTable) + sizeof(MANUAL_MAPPING_FUNCTION_TABLE_WOW64),	BASE_ALIGNMENT));

	auto table_local = new(std::nothrow) MANUAL_MAPPING_FUNCTION_TABLE_WOW64();
	if (!table_local)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "operator new failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_OUT_OF_MEMORY_NEW;
	}

	BYTE * mmap_sec_wow64_base = ManualMapping_Shell_WOW64;

	table_local->MMP_Shell = MDWD(pShells);
	table_local->MMIP_MapSections			= MDWD(pShells + MMI_MapSections_WOW64			- mmap_sec_wow64_base);
	table_local->MMIP_RelocateImage			= MDWD(pShells + MMI_RelocateImage_WOW64		- mmap_sec_wow64_base);
	table_local->MMIP_InitializeCookie		= MDWD(pShells + MMI_InitializeCookie_WOW64		- mmap_sec_wow64_base);
	table_local->MMIP_LoadImports			= MDWD(pShells + MMI_LoadImports_WOW64			- mmap_sec_wow64_base);
	table_local->MMIP_LoadDelayImports		= MDWD(pShells + MMI_LoadDelayImports_WOW64		- mmap_sec_wow64_base);
	table_local->MMIP_SetPageProtections	= MDWD(pShells + MMI_SetPageProtections_WOW64	- mmap_sec_wow64_base);
	table_local->MMIP_EnableExceptions		= MDWD(pShells + MMI_EnableExceptions_WOW64		- mmap_sec_wow64_base);
	table_local->MMIP_HandleTLS				= MDWD(pShells + MMI_HandleTLS_WOW64			- mmap_sec_wow64_base);
	table_local->MMIP_ExecuteDllMain		= MDWD(pShells + MMI_ExecuteDllMain_WOW64		- mmap_sec_wow64_base);
	table_local->MMIP_CleanDataDirectories	= MDWD(pShells + MMI_CleanDataDirectories_WOW64	- mmap_sec_wow64_base);
	table_local->MMIP_CloakHeader			= MDWD(pShells + MMI_CloakHeader_WOW64			- mmap_sec_wow64_base);
	table_local->MMIP_CleanUp				= MDWD(pShells + MMI_CleanUp_WOW64				- mmap_sec_wow64_base);

	table_local->MMIHP_ResolveFilePath		= MDWD(pShells + MMIH_ResolveFilePath_WOW64			- mmap_sec_wow64_base);
	table_local->MMIHP_PreprocessModuleName	= MDWD(pShells + MMIH_PreprocessModuleName_WOW64	- mmap_sec_wow64_base);
	table_local->MMIHP_LoadModule			= MDWD(pShells + MMIH_LoadModule_WOW64				- mmap_sec_wow64_base);

	data.FunctionTable = MDWD(pFunctionTable);

	if (VEHShellSize)
	{
		data.pVEHShell		= MDWD(pVEHShell);
		data.VEHShellSize	= MDWD(VEHShellSize);
	}

	if (Source.FromMemory)
	{
		data.pRawData = MDWD(pRawData);
	}

	LOG(2, "Shellsize      = %08X\n", MDWD(ShellSize));
	LOG(2, "Total size     = %08X\n", MDWD(AllocationSize));
	LOG(2, "pArg           = %08X\n", MDWD(pArg));
	LOG(2, "pShells        = %08X\n", MDWD(pShells));

	if (VEHShellSize)
	{
		LOG(2, "pVEHShell   = %08X\n", MDWD(pVEHShell));
	}

	if (!WriteProcessMemory(hTargetProc, pArg, &data, sizeof(MANUAL_MAPPING_DATA_WOW64), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		delete table_local;
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	LOG(1, "Shelldata written to memory\n");

	if (!WriteProcessMemory(hTargetProc, pShells, mmap_sec_wow64_base, ShellSize, nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		delete table_local;
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	LOG(1, "Shells written to memory\n");

	if (VEHShellSize)
	{
		if (!WriteProcessMemory(hTargetProc, pVEHShell, VectoredHandlerShell_WOW64, VEHShellSize, nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			delete table_local;
			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

			return INJ_ERR_WPM_FAIL;
		}

		LOG(1, "VEHShell written to memory\n");
	}

	if (!WriteProcessMemory(hTargetProc, pFunctionTable, table_local, sizeof(MANUAL_MAPPING_FUNCTION_TABLE_WOW64), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		delete table_local;
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	LOG(1, "Function table written to memory\n");

	delete table_local;

	if (Source.FromMemory)
	{
		if (!WriteProcessMemory(hTargetProc, pRawData, Source.RawData, Source.RawSize, nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

			return INJ_ERR_WPM_FAIL;
		}

		LOG(1, "Raw data written to memory\n");
	}

	if (Flags & INJ_THREAD_CREATE_CLOAKED)
	{
		Flags |= (INJ_CTF_FAKE_START_ADDRESS | INJ_CTF_HIDE_FROM_DEBUGGER);
	}

	LOG(1, "Entering StartRoutine_WOW64\n");

	DWORD remote_ret = 0;
	DWORD dwRet = StartRoutine_WOW64(hTargetProc, (f_Routine_WOW64)(MDWD(pShells)), MDWD(pArg), Method, Flags, remote_ret, Timeout, error_data);

	LOG(1, "Return from StartRoutine_WOW64\n");

	if (dwRet != SR_ERR_SUCCESS)
	{
		LOG(1, "StartRoutine_WOW64 failed: %08X\n", dwRet);

		if (Method != LAUNCH_METHOD::LM_QueueUserAPC && !(Method == LAUNCH_METHOD::LM_HijackThread && dwRet == SR_HT_ERR_REMOTE_TIMEOUT))
		{
			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
		}

		return dwRet;
	}

	LOG(1, "Fetching routine data\n");

	if (!ReadProcessMemory(hTargetProc, pAllocBase, &data, sizeof(MANUAL_MAPPING_DATA_WOW64), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		if (Method != LAUNCH_METHOD::LM_QueueUserAPC)
		{
			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
		}

		return INJ_ERR_VERIFY_RESULT_FAIL;
	}

	if (Method != LAUNCH_METHOD::LM_QueueUserAPC)
	{
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
	}

	if (remote_ret != INJ_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, (DWORD)data.ntRet);

		LOG(1, "Shell failed: %08X\n", remote_ret);

		return remote_ret;
	}

	if (!data.hRet)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "Shell failed\n");

		return INJ_ERR_FAILED_TO_LOAD_DLL;
	}

	LOG(1, "Shell returned successfully\n");

	hOut = ReCa<HINSTANCE>(MPTR(data.hRet));

	LOG(1, "Imagebase = %p\n", ReCa<void *>(hOut));

	return INJ_ERR_SUCCESS;
}

MANUAL_MAPPING_FUNCTION_TABLE_WOW64::MANUAL_MAPPING_FUNCTION_TABLE_WOW64()
{
	WOW64_FUNC_CONSTRUCTOR_INIT(NtOpenFile);
	WOW64_FUNC_CONSTRUCTOR_INIT(NtReadFile);
	WOW64_FUNC_CONSTRUCTOR_INIT(NtClose);

	WOW64_FUNC_CONSTRUCTOR_INIT(NtSetInformationFile);
	WOW64_FUNC_CONSTRUCTOR_INIT(NtQueryInformationFile);

	WOW64_FUNC_CONSTRUCTOR_INIT(NtAllocateVirtualMemory);
	WOW64_FUNC_CONSTRUCTOR_INIT(NtProtectVirtualMemory);
	WOW64_FUNC_CONSTRUCTOR_INIT(NtFreeVirtualMemory);

	WOW64_FUNC_CONSTRUCTOR_INIT(NtCreateSection);
	WOW64_FUNC_CONSTRUCTOR_INIT(NtMapViewOfSection);

	WOW64_FUNC_CONSTRUCTOR_INIT(memmove);
	WOW64_FUNC_CONSTRUCTOR_INIT(RtlZeroMemory);
	WOW64_FUNC_CONSTRUCTOR_INIT(RtlAllocateHeap);
	WOW64_FUNC_CONSTRUCTOR_INIT(RtlFreeHeap);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpLoadDll);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpLoadDllInternal);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrGetProcedureAddress);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrUnloadDll);

	WOW64_FUNC_CONSTRUCTOR_INIT(RtlAnsiStringToUnicodeString);
	WOW64_FUNC_CONSTRUCTOR_INIT(RtlUnicodeStringToAnsiString);
	WOW64_FUNC_CONSTRUCTOR_INIT(RtlCompareUnicodeString);
	WOW64_FUNC_CONSTRUCTOR_INIT(RtlCompareString);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrGetDllPath);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpPreprocessDllName);
	WOW64_FUNC_CONSTRUCTOR_INIT(RtlInsertInvertedFunctionTable);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpHandleTlsData);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrLockLoaderLock);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrUnlockLoaderLock);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpDereferenceModule);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpMappingInfoIndex);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrProtectMrdata);

	WOW64_FUNC_CONSTRUCTOR_INIT(RtlAddVectoredExceptionHandler);
	WOW64_FUNC_CONSTRUCTOR_INIT(RtlRemoveVectoredExceptionHandler);

	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpModuleBaseAddressIndex);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpMappingInfoIndex);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpHeap);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpInvertedFunctionTable);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpDefaultPath);
	WOW64_FUNC_CONSTRUCTOR_INIT(LdrpTlsList);
}

#endif
```

`GH Injector Library/Manual Mapping.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Manual Mapping.h"

using namespace NATIVE;
using namespace MMAP_NATIVE;

DWORD MMAP_NATIVE::ManualMap(const INJECTION_SOURCE & Source, HANDLE hTargetProc, LAUNCH_METHOD Method, DWORD Flags, HINSTANCE & hOut, DWORD Timeout, ERROR_DATA & error_data)
{
#if !defined(_WIN64) && defined (DUMP_SHELLCODE)
	DUMP_WOW64(ManualMapping_Shell,			MMI_MapSections);
	DUMP_WOW64(MMI_MapSections,				MMI_RelocateImage);
	DUMP_WOW64(MMI_RelocateImage,			MMI_InitializeCookie);
	DUMP_WOW64(MMI_InitializeCookie,		MMI_LoadImports);
	DUMP_WOW64(MMI_LoadImports,				MMI_LoadDelayImports);
	DUMP_WOW64(MMI_LoadDelayImports,		MMI_SetPageProtections);
	DUMP_WOW64(MMI_SetPageProtections,		MMI_EnableExceptions);
	DUMP_WOW64(MMI_EnableExceptions,		MMI_HandleTLS);
	DUMP_WOW64(MMI_HandleTLS,				MMI_ExecuteDllMain);
	DUMP_WOW64(MMI_ExecuteDllMain,			MMI_CleanDataDirectories);
	DUMP_WOW64(MMI_CleanDataDirectories,	MMI_CloakHeader);
	DUMP_WOW64(MMI_CloakHeader,				MMI_CleanUp);
	DUMP_WOW64(MMI_CleanUp,					MMIH_ResolveFilePath);
	DUMP_WOW64(MMIH_ResolveFilePath,		MMIH_PreprocessModuleName);
	DUMP_WOW64(MMIH_PreprocessModuleName,	MMIH_LoadModule);
	DUMP_WOW64(MMIH_LoadModule,				MMAP_SEC_END);

	DUMP_WOW64(VectoredHandlerShell, VEH_SEC_END);

	return INJ_ERR_SHELLCODE_DUMPED;
#endif

	LOG(1, "Begin ManualMap\n");

	MANUAL_MAPPING_DATA data{ 0 };
	data.Flags			= Flags;
	data.OSVersion		= GetOSVersion();
	data.OSBuildNumber	= GetOSBuildVersion();

	if (Source.FromMemory)
	{
		data.RawSize = Source.RawSize;
	}
	else
	{
		size_t len		= Source.DllPath.length();
		size_t max_len	= sizeof(data.szPathBuffer) / sizeof(wchar_t);
		if (len > max_len)
		{
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(1, "Path too long: %d characters, buffer size: %d\n", len, max_len);

			return INJ_ERR_STRING_TOO_LONG;
		}

		data.DllPath.Length		= (WORD)(len * sizeof(wchar_t));
		data.DllPath.MaxLength	= (WORD)sizeof(data.szPathBuffer);
		Source.DllPath.copy(data.szPathBuffer, Source.DllPath.length());
	}
	
	LOG(1, "Shell data initialized\n");

	if (Flags & INJ_MM_SHIFT_MODULE_BASE && !(Flags & INJ_MM_SET_PAGE_PROTECTIONS))
	{
		auto seed = GetTickCount();
		std::mt19937 gen(seed);
		std::uniform_int_distribution<WORD> dis(MIN_SHIFT_OFFSET, MAX_SHIFT_OFFSET);

		WORD shift_offset = dis(gen);
		shift_offset = ALIGN_UP(shift_offset, BASE_ALIGNMENT);

		data.ShiftOffset = shift_offset;

		LOG(1, "Shift offset = %04X\n", shift_offset);
	}

	//.mmap_sec include mapping functions and helper functions
	ULONG_PTR ShellSize		= ReCa<ULONG_PTR>(MMAP_SEC_END) - ReCa<ULONG_PTR>(ManualMapping_Shell);

	//.veh_sec currently only contains handler shell
	ULONG_PTR VEHShellSize	= ReCa<ULONG_PTR>(VEH_SEC_END) - ReCa<ULONG_PTR>(VectoredHandlerShell);
	
	//ignore VEH shell if exceptions aren't enabled
	if (!(Flags & INJ_MM_ENABLE_EXCEPTIONS))
	{
		VEHShellSize = 0;
	}

	auto AllocationSize = sizeof(MANUAL_MAPPING_DATA) + sizeof(MANUAL_MAPPING_FUNCTION_TABLE) + ShellSize + VEHShellSize + BASE_ALIGNMENT * 4;
	if (Source.FromMemory)
	{
		AllocationSize += (SIZE_T)Source.RawSize + BASE_ALIGNMENT;
	}

	BYTE * pAllocBase = ReCa<BYTE *>(VirtualAllocEx(hTargetProc, nullptr, AllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
	if (!pAllocBase)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "memory allocation failed: %08X\n", error_data.AdvErrorCode);

		return INJ_ERR_OUT_OF_MEMORY_EXT;
	}

	BYTE * pArg				= pAllocBase;
	BYTE * pShells			= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pArg)			+ sizeof(MANUAL_MAPPING_DATA),				BASE_ALIGNMENT));
	BYTE * pVEHShell		= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pShells)		+ ShellSize,								BASE_ALIGNMENT));
	BYTE * pFunctionTable	= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pVEHShell)		+ VEHShellSize,								BASE_ALIGNMENT));
	BYTE * pRawData			= ReCa<BYTE *>(ALIGN_UP(ReCa<ULONG_PTR>(pFunctionTable) + sizeof(MANUAL_MAPPING_FUNCTION_TABLE),	BASE_ALIGNMENT));

	auto table_local = new(std::nothrow) MANUAL_MAPPING_FUNCTION_TABLE();
	if (!table_local)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "operator new failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_OUT_OF_MEMORY_NEW;
	}

	//initialze local function table with remote addresses
	BYTE * mmap_sec_base = ReCa<BYTE *>(ManualMapping_Shell);

	table_local->MMP_Shell = ReCa<f_MMI_FUNCTION>(pShells);
	table_local->MMIP_MapSections			= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_MapSections)				- mmap_sec_base));
	table_local->MMIP_RelocateImage			= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_RelocateImage)			- mmap_sec_base));
	table_local->MMIP_InitializeCookie		= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_InitializeCookie)		- mmap_sec_base));
	table_local->MMIP_LoadImports			= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_LoadImports)				- mmap_sec_base));
	table_local->MMIP_LoadDelayImports		= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_LoadDelayImports)		- mmap_sec_base));
	table_local->MMIP_SetPageProtections	= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_SetPageProtections)		- mmap_sec_base));
	table_local->MMIP_EnableExceptions		= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_EnableExceptions)		- mmap_sec_base));
	table_local->MMIP_HandleTLS				= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_HandleTLS)				- mmap_sec_base));
	table_local->MMIP_ExecuteDllMain		= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_ExecuteDllMain)			- mmap_sec_base));
	table_local->MMIP_CleanDataDirectories	= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_CleanDataDirectories)	- mmap_sec_base));
	table_local->MMIP_CloakHeader			= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_CloakHeader)				- mmap_sec_base));
	table_local->MMIP_CleanUp				= ReCa<f_MMI_FUNCTION>(pShells + (ReCa<BYTE *>(MMI_CleanUp)					- mmap_sec_base));
	
	table_local->MMIHP_ResolveFilePath			= ReCa<decltype(MMIH_ResolveFilePath)			*>(pShells + (ReCa<BYTE *>(MMIH_ResolveFilePath)			- mmap_sec_base));
	table_local->MMIHP_PreprocessModuleName		= ReCa<decltype(MMIH_PreprocessModuleName)		*>(pShells + (ReCa<BYTE *>(MMIH_PreprocessModuleName)		- mmap_sec_base));
	table_local->MMIHP_LoadModule				= ReCa<decltype(MMIH_LoadModule)				*>(pShells + (ReCa<BYTE *>(MMIH_LoadModule)					- mmap_sec_base));

	data.FunctionTable = ReCa<MANUAL_MAPPING_FUNCTION_TABLE *>(pFunctionTable);

	if (VEHShellSize)
	{
		data.pVEHShell		= pVEHShell;
		data.VEHShellSize	= MDWD(VEHShellSize);
	}

	if (Source.FromMemory)
	{
		data.pRawData = pRawData;
	}

	LOG(2, "Shellsize      = %08X\n", MDWD(ShellSize));
	LOG(2, "Total size     = %08X\n", MDWD(AllocationSize));
	LOG(2, "pArg           = %p\n", pArg);
	LOG(2, "pShells        = %p\n", pShells);

	if (VEHShellSize)
	{
		LOG(2, "pVEHShell      = %p\n", data.pVEHShell);
	}

	LOG(2, "pFunctionTable = %p\n", pFunctionTable);

	if (!WriteProcessMemory(hTargetProc, pArg, &data, sizeof(MANUAL_MAPPING_DATA), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		delete table_local;
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	LOG(1, "Shelldata written to memory\n");

	if (!WriteProcessMemory(hTargetProc, pShells, mmap_sec_base, ShellSize, nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		delete table_local;
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	LOG(1, "Shells written to memory\n");

	if (VEHShellSize)
	{
		if (!WriteProcessMemory(hTargetProc, pVEHShell, VectoredHandlerShell, VEHShellSize, nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			delete table_local;
			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

			return INJ_ERR_WPM_FAIL;
		}

		LOG(1, "VEH shell written to memory\n");
	}

	if (!WriteProcessMemory(hTargetProc, pFunctionTable, table_local, sizeof(MANUAL_MAPPING_FUNCTION_TABLE), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		delete table_local;
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

		return INJ_ERR_WPM_FAIL;
	}

	LOG(1, "Function table written to memory\n");

	delete table_local;

	if (Source.FromMemory)
	{
		if (!WriteProcessMemory(hTargetProc, pRawData, Source.RawData, Source.RawSize, nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(1, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);

			return INJ_ERR_WPM_FAIL;
		}

		LOG(1, "Raw data written to memory\n");
	}

	if (Flags & INJ_THREAD_CREATE_CLOAKED)
	{
		Flags |= (INJ_CTF_FAKE_START_ADDRESS | INJ_CTF_HIDE_FROM_DEBUGGER);
	}

	DWORD remote_ret = 0;
	DWORD dwRet = StartRoutine(hTargetProc, ReCa<f_Routine>(pShells), pArg, Method, Flags, remote_ret, Timeout, error_data);

	LOG(1, "Return from StartRoutine\n");

	if (dwRet != SR_ERR_SUCCESS)
	{
		LOG(1, "StartRoutine failed: %08X\n", dwRet);

		if (Method != LAUNCH_METHOD::LM_QueueUserAPC && !(Method == LAUNCH_METHOD::LM_HijackThread && dwRet == SR_HT_ERR_REMOTE_TIMEOUT))
		{
			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
		}

		return dwRet;
	}

	LOG(1, "Fetching routine data\n");

	if (!ReadProcessMemory(hTargetProc, pAllocBase, &data, sizeof(MANUAL_MAPPING_DATA), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(1, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		if (Method != LAUNCH_METHOD::LM_QueueUserAPC)
		{
			VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
		}

		return INJ_ERR_VERIFY_RESULT_FAIL;
	}

	if (Method != LAUNCH_METHOD::LM_QueueUserAPC)
	{
		VirtualFreeEx(hTargetProc, pAllocBase, 0, MEM_RELEASE);
	}

	if (remote_ret != INJ_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, (DWORD)data.ntRet);

		LOG(1, "Shell failed: %08X\n", remote_ret);

		return remote_ret;
	}

	if (!data.hRet)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(1, "Shell failed\n");

		return INJ_ERR_FAILED_TO_LOAD_DLL;
	}

	LOG(1, "Shell returned successfully\n");

	hOut = data.hRet;

	LOG(1, "Imagebase = %p\n", ReCa<void *>(hOut));

	return INJ_ERR_SUCCESS;
}

#pragma region inlined dependency record functions

__forceinline MM_DEPENDENCY_RECORD * BuildDependencyRecord(MANUAL_MAPPING_FUNCTION_TABLE * f, MM_DEPENDENCY_RECORD ** head, HANDLE DllHandle, const UNICODE_STRING * DllPath)
{
	if (!head)
	{
		return nullptr;
	}

	//create new list (head)
	if (!(*head))
	{
		*head = NewObject<MM_DEPENDENCY_RECORD>(f);

		if (!(*head))
		{
			return nullptr;
		}

		(*head)->Next = *head;
		(*head)->Prev = *head;
		(*head)->DllHandle = DllHandle;
		
		if (DllPath)
		{
			auto len = DllPath->Length;
			if (len < sizeof(MM_DEPENDENCY_RECORD::Buffer))
			{
				(*head)->DllName.Length		= len;
				(*head)->DllName.MaxLength	= sizeof(MM_DEPENDENCY_RECORD::Buffer);
				(*head)->DllName.szBuffer	= (*head)->Buffer;

				f->memmove((*head)->Buffer, DllPath->szBuffer, len);
			}
		}

		return (*head);
	}	

	//create new entry
	auto next = NewObject<MM_DEPENDENCY_RECORD>(f);
	if (next)
	{
		next->Next			= (*head);
		next->Prev			= (*head)->Prev;

		(*head)->Prev->Next	= next;
		(*head)->Prev		= next;

		next->DllHandle = DllHandle;

		if (DllPath)
		{
			auto len = DllPath->Length;
			if (len < sizeof(MM_DEPENDENCY_RECORD::Buffer))
			{
				next->DllName.Length	= len;
				next->DllName.MaxLength	= sizeof(MM_DEPENDENCY_RECORD::Buffer);
				next->DllName.szBuffer	= next->Buffer;

				f->memmove(next->Buffer, DllPath->szBuffer, len);
			}
		}
	}

	return next;
}

__forceinline void RemoveDependencyEntry(MANUAL_MAPPING_FUNCTION_TABLE * f, MM_DEPENDENCY_RECORD * pEntry)
{
	if (pEntry)
	{
		pEntry->Next->Prev = pEntry->Prev;
		pEntry->Prev->Next = pEntry->Next;

		DeleteObject(f, pEntry);
	}
}

__forceinline MM_DEPENDENCY_RECORD * SearchDependencyRecordByHandle(MM_DEPENDENCY_RECORD * head, HANDLE hDll)
{
	if (!head)
	{
		return nullptr;
	}

	auto cur = head;

	do
	{
		if (cur->DllHandle == hDll)
		{
			return cur;
		}

		cur = cur->Next;
	} while (cur != head);

	return nullptr;
}

__forceinline void UnloadAndDeleteDependencyRecord(MANUAL_MAPPING_FUNCTION_TABLE * f, MM_DEPENDENCY_RECORD * head)
{
	if (!head)
	{
		return;
	}
	
	//unload in reverse order, won't unload everything because dependency loading is fucked since Win 1.0
	auto cur = head;

	while (true)
	{
		cur = head->Prev;

		f->LdrUnloadDll(cur->DllHandle);

		if (cur == head)
		{
			break;
		}
		else
		{
			head->Prev = cur->Prev;

			DeleteObject(f, cur);
		}
	}
}

#pragma endregion

#pragma region manual mapping internal helper functions

NTSTATUS __declspec(code_seg(".mmap_sec$11")) __stdcall MMIH_ResolveFilePath(MANUAL_MAPPING_DATA * pData, UNICODE_STRING * Module)
{
	auto f = pData->FunctionTable;

	NTSTATUS ntRet = STATUS_SUCCESS;

	if (Module->szBuffer[1] == ':')
	{
		return STATUS_SUCCESS;
	}

	wchar_t * DllSearchPath = nullptr;

	if (pData->OSVersion <= g_Win7)
	{
		DllSearchPath = f->LdrpDefaultPath->szBuffer;
	}
	else
	{
		wchar_t * Unknown = nullptr;
		ntRet = f->LdrGetDllPath(Module->szBuffer, NULL, &DllSearchPath, &Unknown);

		if (NT_FAIL(ntRet))
		{
			return ntRet;
		}
	}

	if (!DllSearchPath)
	{
		return STATUS_UNSUCCESSFUL;
	}

	auto len = SizeUnicodeString(DllSearchPath);
	if (!len)
	{
		return STATUS_UNSUCCESSFUL;
	}

	auto DllSearchPathBuffer = NewObject<wchar_t>(f, len / sizeof(wchar_t) + 1);
	if (!DllSearchPathBuffer)
	{
		return STATUS_NO_MEMORY;
	}

	f->memmove(DllSearchPathBuffer, DllSearchPath, len);

	int PathCounter = 1;
	
	for (auto i = DllSearchPathBuffer; *i; ++i)
	{
		if (*i == ';')
		{
			PathCounter++;
		}
	}

	auto DllSearchPathPointers = NewObject<wchar_t *>(f, PathCounter);
	if (!DllSearchPathPointers)
	{
		DeleteObject(f, DllSearchPathBuffer);

		return STATUS_NO_MEMORY;
	}

	PathCounter = 1;
	DllSearchPathPointers[0] = DllSearchPathBuffer;

	for (auto i = DllSearchPathBuffer; *i; ++i)
	{
		if (*i == ';')
		{
			*i = 0;
			DllSearchPathPointers[PathCounter] = i + 1;
			++PathCounter;
		}
	};

	auto * NtFilePathBuffer = NewObject<wchar_t>(f, MAX_PATH);
	if (!NtFilePathBuffer)
	{
		DeleteObject(f, DllSearchPathPointers);
		DeleteObject(f, DllSearchPathBuffer);

		return STATUS_NO_MEMORY;
	}

	auto DllNameSize = Module->Length;
	f->memmove(NtFilePathBuffer, pData->NtPathPrefix, sizeof(pData->NtPathPrefix));
	auto FilePathBuffer = NtFilePathBuffer + 4;

	IO_STATUS_BLOCK io_status{ 0 };
	auto * oa = NewObject<OBJECT_ATTRIBUTES>(f);
	if (!oa)
	{
		DeleteObject(f, NtFilePathBuffer);
		DeleteObject(f, DllSearchPathPointers);
		DeleteObject(f, DllSearchPathBuffer);

		return STATUS_NO_MEMORY;
	}

	bool file_found = false;

	for (int i = 0; i < PathCounter; ++i)
	{
		auto PathSize = SizeUnicodeString(DllSearchPathPointers[i]);
		auto FullSize = (ULONG_PTR)PathSize + (ULONG_PTR)DllNameSize + sizeof(wchar_t);
		auto NtFullSize = FullSize + sizeof(wchar_t[4]);

		if (NtFullSize > MAX_PATH * sizeof(wchar_t))
		{
			continue;
		}

		f->memmove(FilePathBuffer, DllSearchPathPointers[i], PathSize);
		FilePathBuffer[PathSize / sizeof(wchar_t)] = '\\';
		f->memmove(FilePathBuffer + PathSize / sizeof(wchar_t) + 1, Module->szBuffer, DllNameSize);
		FilePathBuffer[FullSize / sizeof(wchar_t)] = 0;

		UNICODE_STRING FilePath{ 0 };
		FilePath.Length		= SizeUnicodeString(NtFilePathBuffer);
		FilePath.MaxLength	= MAX_PATH * sizeof(wchar_t);
		FilePath.szBuffer	= NtFilePathBuffer;

		InitializeObjectAttributes(oa, &FilePath, OBJ_CASE_INSENSITIVE, nullptr, nullptr);

		HANDLE hFile = nullptr;
		ntRet = f->NtOpenFile(&hFile, SYNCHRONIZE, oa, &io_status, FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT);

		if (NT_FAIL(ntRet) || !hFile)
		{
			continue;
		}

		f->NtClose(hFile);

		f->memmove(Module->szBuffer, FilePathBuffer, FullSize);
		Module->Length = SizeUnicodeString(FilePathBuffer);
		file_found = true;

		break;
	}

	DeleteObject(f, oa);
	DeleteObject(f, NtFilePathBuffer);
	DeleteObject(f, DllSearchPathPointers);
	DeleteObject(f, DllSearchPathBuffer);

	if (file_found)
	{
		ntRet = STATUS_SUCCESS;
	}
	
	return ntRet;
}

NTSTATUS __declspec(code_seg(".mmap_sec$12")) __stdcall MMIH_PreprocessModuleName(MANUAL_MAPPING_DATA * pData, const char * szModule, UNICODE_STRING * Module, LDRP_LOAD_CONTEXT_FLAGS * CtxFlags)
{
	auto f = pData->FunctionTable;

	NTSTATUS ntRet = STATUS_SUCCESS;

	//create ANSI_STRING
	auto * ModNameA = NewObject<ANSI_STRING>(f);
	if (!ModNameA)
	{
		return STATUS_NO_MEMORY;
	}

	//move szModule into ANSI_STRING
	if (!InitAnsiString(f, ModNameA, szModule))
	{
		DeleteObject(f, ModNameA);

		return STATUS_NO_MEMORY;
	}

	//create UNICODE_STRING
	auto * ModNameW = NewObject<UNICODE_STRING>(f);
	if (!ModNameW)
	{
		DeleteObject(f, ModNameA->szBuffer);
		DeleteObject(f, ModNameA);

		return STATUS_NO_MEMORY;
	}

	//allocate buffer for UNICODE_STRING
	ModNameW->szBuffer	= NewObject<wchar_t>(f, MAX_PATH);
	ModNameW->MaxLength = sizeof(wchar_t[MAX_PATH]);

	if (!ModNameW->szBuffer)
	{
		DeleteObject(f, ModNameW);
		DeleteObject(f, ModNameA->szBuffer);
		DeleteObject(f, ModNameA);

		return STATUS_NO_MEMORY;
	}

	//convert dll name from ansi to unicode
	ntRet = f->RtlAnsiStringToUnicodeString(ModNameW, ModNameA, FALSE);
	if (NT_FAIL(ntRet))
	{
		DeleteObject(f, ModNameW->szBuffer);
		DeleteObject(f, ModNameW);

		DeleteObject(f, ModNameA->szBuffer);
		DeleteObject(f, ModNameA);

		return ntRet;
	}

	DeleteObject(f, ModNameA->szBuffer);
	DeleteObject(f, ModNameA);

	//Win10+ needs LdrpPreprocessDllName
	if (pData->OSVersion >= g_Win10)
	{
		LDRP_UNICODE_STRING_BUNDLE * pModPathW = NewObject<LDRP_UNICODE_STRING_BUNDLE>(f);
		if (!pModPathW)
		{
			DeleteObject(f, ModNameW->szBuffer);
			DeleteObject(f, ModNameW);

			return STATUS_NO_MEMORY;
		}

		pModPathW->String.MaxLength = sizeof(pModPathW->StaticBuffer);
		pModPathW->String.szBuffer	= pModPathW->StaticBuffer;

		ntRet = f->LdrpPreprocessDllName(ModNameW, pModPathW, nullptr, CtxFlags);

		if (NT_SUCCESS(ntRet))
		{
			//copy preprocessed dll name and create new buffer
			Module->Length		= pModPathW->String.Length;
			Module->MaxLength	= pModPathW->String.MaxLength;
			Module->szBuffer	= NewObject<wchar_t>(f, Module->MaxLength / sizeof(wchar_t));

			if (!Module->szBuffer)
			{
				DeleteObject(f, pModPathW);
				DeleteObject(f, ModNameW->szBuffer);
				DeleteObject(f, ModNameW);

				return STATUS_NO_MEMORY;
			}
			else
			{
				f->memmove(Module->szBuffer, pModPathW->StaticBuffer, Module->Length);
			}
		}
		else
		{
			DeleteObject(f, pModPathW);
			DeleteObject(f, ModNameW->szBuffer);
			DeleteObject(f, ModNameW);

			return ntRet;
		}
	}
	else
	{
		//don't create new buffer
		Module->Length		= ModNameW->Length;
		Module->MaxLength	= ModNameW->MaxLength;
		Module->szBuffer	= ModNameW->szBuffer;
	}

	DeleteObject(f, ModNameW);

	return STATUS_SUCCESS;
}

NTSTATUS __declspec(code_seg(".mmap_sec$13")) __stdcall MMIH_LoadModule(MANUAL_MAPPING_DATA * pData, UNICODE_STRING * Module, LDRP_LOAD_CONTEXT_FLAGS CtxFlag, HINSTANCE * hModule, MM_DEPENDENCY_RECORD ** head)
{
	//load module using LdrpLoadDll(Internal)
	//function protoype is heavily platform dependent

	auto f = pData->FunctionTable;

	NTSTATUS ntRet = STATUS_SUCCESS;

	LDR_DATA_TABLE_ENTRY * entry_out = nullptr;

	if (pData->OSVersion >= g_Win10)
	{
		auto * ctx = NewObject<LDRP_PATH_SEARCH_CONTEXT>(f);
		if (!ctx)
		{
			return STATUS_NO_MEMORY;
		}

		if (pData->OSBuildNumber == g_Win10_1511)
		{
			ReCa<LDRP_PATH_SEARCH_CONTEXT_1511 *>(ctx)->OriginalFullDllName = Module->szBuffer;
		}
		else
		{
			ctx->OriginalFullDllName = Module->szBuffer;
		}

		if (pData->OSBuildNumber >= g_Win11_21H2)
		{
			auto _LdrpLoadDllInternal = ReCa<f_LdrpLoadDllInternal_WIN11>(f->LdrpLoadDllInternal);
			_LdrpLoadDllInternal(Module, ctx, CtxFlag, 4, nullptr, nullptr, ReCa<LDR_DATA_TABLE_ENTRY_WIN11 **>(&entry_out), &ntRet, 0);
		}
		else
		{
			f->LdrpLoadDllInternal(Module, ctx, CtxFlag, 4, nullptr, nullptr, ReCa<LDR_DATA_TABLE_ENTRY_WIN10 **>(&entry_out), &ntRet);
		}

		DeleteObject(f, ctx);
	}
	else if (pData->OSVersion == g_Win81)
	{
		auto * ctx = NewObject<LDRP_PATH_SEARCH_CONTEXT_WIN81>(f);
		if (!ctx)
		{
			return STATUS_NO_MEMORY;
		}
		
		ctx->OriginalFullDllName = Module->szBuffer;

		LDR_DDAG_NODE_WIN81 * ddag_out = nullptr;

		auto _LdrpLoadDll = ReCa<f_LdrpLoadDll_WIN81>(f->LdrpLoadDll);
		ntRet = _LdrpLoadDll(Module, ctx, CtxFlag, TRUE, ReCa<LDR_DATA_TABLE_ENTRY_WIN81 **>(&entry_out), &ddag_out);

		DeleteObject(f, ctx);
	}
	else if (pData->OSVersion == g_Win8)
	{
		auto * ctx = NewObject<LDRP_PATH_SEARCH_CONTEXT_WIN8>(f);
		if (!ctx)
		{
			return STATUS_NO_MEMORY;
		}

		ctx->OriginalFullDllName = Module->szBuffer;
		ctx->unknown2 = TRUE;

		LDR_DDAG_NODE_WIN8 * ddag_out = nullptr;

		auto _LdrpLoadDll = ReCa<f_LdrpLoadDll_WIN8>(f->LdrpLoadDll);
		ntRet = _LdrpLoadDll(Module, ctx, CtxFlag, TRUE, ReCa<LDR_DATA_TABLE_ENTRY_WIN8 **>(&entry_out), &ddag_out);

		DeleteObject(f, ctx);
	}
	else if (pData->OSVersion == g_Win7)
	{
		auto _LdrpLoadDll = ReCa<f_LdrpLoadDll_WIN7>(f->LdrpLoadDll);
		ntRet = _LdrpLoadDll(Module, f->LdrpDefaultPath, CtxFlag, TRUE, nullptr, ReCa<LDR_DATA_TABLE_ENTRY_WIN7 **>(&entry_out));
	}
	else
	{
		ntRet = STATUS_NOT_IMPLEMENTED;
	}
	
	if (NT_SUCCESS(ntRet))
	{
		if (entry_out)
		{
			*hModule = ReCa<HINSTANCE>(entry_out->DllBase);

			MM_DEPENDENCY_RECORD * entry = nullptr;

			if (head)
			{
				entry = SearchDependencyRecordByHandle(*head, entry_out->DllBase);
			}

			if (!entry)
			{
				entry = BuildDependencyRecord(f, head, ReCa<HANDLE>(*hModule), &entry_out->FullDllName);
			}

			if (pData->OSVersion >= g_Win10)
			{
				f->LdrpDereferenceModule(entry_out);
			}
		}
		else
		{
			ntRet = STATUS_DLL_NOT_FOUND;
		}
	}

	return ntRet;
}

#pragma endregion

DWORD __declspec(code_seg(".mmap_sec$01")) __stdcall ManualMapping_Shell(MANUAL_MAPPING_DATA * pData)
{
	if (!pData)
	{
		return INJ_MM_ERR_NO_DATA;
	}

	pData->DllPath.szBuffer = pData->szPathBuffer;

	//grab LdrpHeap pointer
	auto * f = pData->FunctionTable;
	if (!f->pLdrpHeap)
	{
		f->pLdrpHeap = *f->LdrpHeap;
	}

	if (!f->pLdrpHeap)
	{
		return INJ_MM_ERR_INVALID_HEAP_HANDLE;
	}

	auto ret = f->MMIP_MapSections(pData);
	if (ret != INJ_ERR_SUCCESS)
	{
		f->MMIP_CleanUp(pData);

		return ret;
	}

	ret = f->MMIP_RelocateImage(pData);
	if (ret != INJ_ERR_SUCCESS)
	{
		f->MMIP_CleanUp(pData);

		return ret;
	}

	ret = f->MMIP_InitializeCookie(pData);
	if (ret != INJ_ERR_SUCCESS)
	{
		f->MMIP_CleanUp(pData);

		return ret;
	}
	
	ret = f->MMIP_LoadImports(pData);
	if (ret != INJ_ERR_SUCCESS)
	{
		f->MMIP_CleanUp(pData);

		return ret;
	}

	ret = f->MMIP_LoadDelayImports(pData);
	if (ret != INJ_ERR_SUCCESS)
	{
		f->MMIP_CleanUp(pData);

		return ret;
	}

	ret = f->MMIP_SetPageProtections(pData);
	if (ret != INJ_ERR_SUCCESS)
	{
		f->MMIP_CleanUp(pData);

		return ret;
	}

	ret = f->MMIP_EnableExceptions(pData);
	if (ret != INJ_ERR_SUCCESS)
	{
		f->MMIP_CleanUp(pData);

		return ret;
	}

	ret = f->MMIP_HandleTLS(pData);
	if (ret != INJ_ERR_SUCCESS)
	{
		f->MMIP_CleanUp(pData);

		return ret;
	}

	ret = f->MMIP_ExecuteDllMain(pData);
	if (ret != INJ_ERR_SUCCESS)
	{
		f->MMIP_CleanUp(pData);

		return ret;
	}
		
	//ignore cloaking return values since the module is loaded and executed already
	f->MMIP_CleanDataDirectories(pData);
	f->MMIP_CloakHeader(pData);

	//unlock file
	if (pData->hDllFile)
	{
		f->NtClose(pData->hDllFile);
	}

	//grab image base
	pData->hRet = ReCa<HINSTANCE>(pData->pImageBase);

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$02")) __stdcall MMI_MapSections(MANUAL_MAPPING_DATA * pData)
{
	auto f = pData->FunctionTable;

	if (!(pData->Flags & INJ_MM_MAP_FROM_MEMORY))
	{
		//convert path to nt path
		UNICODE_STRING DllNtPath{ 0 };
		DllNtPath.Length = pData->DllPath.Length;
		DllNtPath.MaxLength = sizeof(wchar_t[MAX_PATH + 4]);
		DllNtPath.szBuffer = NewObject<wchar_t>(f, DllNtPath.MaxLength / sizeof(wchar_t));

		if (!DllNtPath.szBuffer)
		{
			return INJ_MM_ERR_HEAP_ALLOC;
		}

		//nt path prefix "\??\"
		f->memmove(DllNtPath.szBuffer + 0, pData->NtPathPrefix, sizeof(wchar_t[4]));
		f->memmove(DllNtPath.szBuffer + 4, pData->szPathBuffer, DllNtPath.Length);
		DllNtPath.Length += sizeof(wchar_t[4]);

		//update string buffer addresse
		UNICODE_STRING DllPath = pData->DllPath;
		DllPath.szBuffer = pData->szPathBuffer;

		auto * oa = NewObject<OBJECT_ATTRIBUTES>(f);
		if (!oa)
		{
			DeleteObject(f, DllNtPath.szBuffer);

			return INJ_MM_ERR_HEAP_ALLOC;
		}

		InitializeObjectAttributes(oa, &DllNtPath, OBJ_CASE_INSENSITIVE, nullptr, nullptr);

		IO_STATUS_BLOCK io_status{ 0 };

		//open dll file
		pData->ntRet = f->NtOpenFile(&pData->hDllFile, FILE_GENERIC_READ, oa, &io_status, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

		DeleteObject(f, oa);
		DeleteObject(f, DllNtPath.szBuffer);

		if (NT_FAIL(pData->ntRet))
		{
			return INJ_MM_ERR_NT_OPEN_FILE;
		}

		auto * fsi = NewObject<FILE_STANDARD_INFO>(f);
		if (!fsi)
		{
			return INJ_MM_ERR_HEAP_ALLOC;
		}

		//query basic file information
		pData->ntRet = f->NtQueryInformationFile(pData->hDllFile, &io_status, fsi, sizeof(FILE_STANDARD_INFO), FILE_INFORMATION_CLASS::FileStandardInformation);
		if (NT_FAIL(pData->ntRet))
		{
			DeleteObject(f, fsi);

			return INJ_MM_ERR_CANT_GET_FILE_SIZE;
		}

		SIZE_T RawSize = fsi->AllocationSize.LowPart;

		//allocate memory for the raw dll file
		pData->ntRet = f->NtAllocateVirtualMemory(NtCurrentProcess(), ReCa<void **>(&pData->pRawData), 0, &RawSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (NT_FAIL(pData->ntRet))
		{
			DeleteObject(f, fsi);

			return INJ_MM_ERR_MEMORY_ALLOCATION_FAILED;
		}

		auto * pos = NewObject<FILE_POSITION_INFORMATION>(f);
		if (!pos)
		{
			DeleteObject(f, fsi);

			return INJ_MM_ERR_HEAP_ALLOC;
		}

		//reset file pointer
		pData->ntRet = f->NtSetInformationFile(pData->hDllFile, &io_status, pos, sizeof(FILE_POSITION_INFORMATION), FILE_INFORMATION_CLASS::FilePositionInformation);
		if (NT_FAIL(pData->ntRet))
		{
			DeleteObject(f, fsi);

			return INJ_MM_ERR_SET_FILE_POSITION;
		}

		DeleteObject(f, pos);

		//read raw dll file into memory
		pData->ntRet = f->NtReadFile(pData->hDllFile, nullptr, nullptr, nullptr, &io_status, pData->pRawData, fsi->AllocationSize.LowPart, nullptr, nullptr);
		if (NT_FAIL(pData->ntRet))
		{
			DeleteObject(f, fsi);

			return INJ_MM_ERR_NT_READ_FILE;
		}

		DeleteObject(f, fsi);
	}
	
	//grab pe header pointers (assuming the file is a valid dll)
	pData->pDosHeader		= ReCa<IMAGE_DOS_HEADER *>(pData->pRawData);
	pData->pNtHeaders		= ReCa<IMAGE_NT_HEADERS *>(pData->pRawData + pData->pDosHeader->e_lfanew);
	pData->pOptionalHeader	= &pData->pNtHeaders->OptionalHeader;
	pData->pFileHeader		= &pData->pNtHeaders->FileHeader;

	SIZE_T ImgSize = static_cast<SIZE_T>(pData->pOptionalHeader->SizeOfImage);

	//update allocation size depending on flags
	if (pData->Flags & INJ_MM_SHIFT_MODULE_BASE && !(pData->Flags & INJ_MM_SET_PAGE_PROTECTIONS))
	{
		ImgSize += pData->ShiftOffset;
	}

	if (pData->Flags & INJ_MM_ENABLE_EXCEPTIONS)
	{
		//allocate additional memory for the VEH shell/data
		ImgSize += ALIGN_UP(pData->VEHShellSize + sizeof(VEH_SHELL_DATA) + 0x10, 0x1000);
	}

	//allocate memory for the dll
	pData->ntRet = f->NtAllocateVirtualMemory(NtCurrentProcess(), ReCa<void **>(&pData->pAllocationBase), 0, &ImgSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (NT_FAIL(pData->ntRet))
	{
		return INJ_MM_ERR_MEMORY_ALLOCATION_FAILED;
	}

	//update pointers depending on flags
	if (pData->Flags & INJ_MM_SHIFT_MODULE_BASE && !(pData->Flags & INJ_MM_SET_PAGE_PROTECTIONS))
	{
		pData->pImageBase = pData->pAllocationBase + pData->ShiftOffset;
	}
	else
	{
		pData->pImageBase = pData->pAllocationBase;
	}

	//copy header and sections
	f->memmove(pData->pImageBase, pData->pRawData, pData->pOptionalHeader->SizeOfHeaders);

	auto * pCurrentSectionHeader = IMAGE_FIRST_SECTION(pData->pNtHeaders);
	for (UINT i = 0; i != pData->pFileHeader->NumberOfSections; ++i, ++pCurrentSectionHeader)
	{
		if (pCurrentSectionHeader->SizeOfRawData)
		{
			f->memmove(pData->pImageBase + pCurrentSectionHeader->VirtualAddress, pData->pRawData + pCurrentSectionHeader->PointerToRawData, pCurrentSectionHeader->SizeOfRawData);
		}
	}

	if (!(pData->Flags & INJ_MM_MAP_FROM_MEMORY))
	{
		//remove raw data
		SIZE_T RawSize = 0;
		f->NtFreeVirtualMemory(NtCurrentProcess(), ReCa<void **>(&pData->pRawData), &RawSize, MEM_RELEASE);
		pData->pRawData = nullptr;
	}	
	
	//update pe headers to the new location
	pData->pDosHeader		= ReCa<IMAGE_DOS_HEADER *>(pData->pImageBase);
	pData->pNtHeaders		= ReCa<IMAGE_NT_HEADERS *>(pData->pImageBase + pData->pDosHeader->e_lfanew);
	pData->pOptionalHeader	= &pData->pNtHeaders->OptionalHeader;
	pData->pFileHeader		= &pData->pNtHeaders->FileHeader;

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$03")) __stdcall MMI_RelocateImage(MANUAL_MAPPING_DATA * pData)
{
	BYTE * LocationDelta = pData->pImageBase - pData->pOptionalHeader->ImageBase;

	//relocate the image if necessary
	if (LocationDelta)
	{
		auto * pRelocDir = ReCa<IMAGE_DATA_DIRECTORY *>(&pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);

		if (!pRelocDir->Size)
		{
			return INJ_MM_ERR_IMAGE_CANT_BE_RELOCATED;
		}

		auto * pRelocData = ReCa<IMAGE_BASE_RELOCATION *>(pData->pImageBase + pRelocDir->VirtualAddress);

		while (pRelocData->VirtualAddress)
		{
			WORD * pRelativeInfo = ReCa<WORD *>(pRelocData + 1);
			UINT RelocCount = (pRelocData->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);

			for (UINT i = 0; i < RelocCount; ++i, ++pRelativeInfo)
			{
				if (RELOC_FLAG(*pRelativeInfo))
				{
					ULONG_PTR * pPatch = ReCa<ULONG_PTR *>(pData->pImageBase + pRelocData->VirtualAddress + ((*pRelativeInfo) & 0xFFF));
					*pPatch += ReCa<ULONG_PTR>(LocationDelta);
				}
			}

			pRelocData = ReCa<IMAGE_BASE_RELOCATION *>(ReCa<BYTE *>(pRelocData) + pRelocData->SizeOfBlock);

			if (pRelocData >= ReCa<IMAGE_BASE_RELOCATION *>(pData->pImageBase + pRelocDir->VirtualAddress + pRelocDir->Size))
			{
				break;
			}
		}

		pData->pOptionalHeader->ImageBase += ReCa<ULONG_PTR>(LocationDelta);
	}

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$04")) __stdcall MMI_InitializeCookie(MANUAL_MAPPING_DATA * pData)
{
	if (!(pData->Flags & INJ_MM_INIT_SECURITY_COOKIE) || !pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size)
	{
		//technically not good but what u gonna do about it

		return INJ_ERR_SUCCESS;
	}

#ifdef _WIN64
	ULONGLONG new_cookie = ((UINT_PTR)pData->pImageBase) & 0x0000FFFFFFFFFFFF;
	if (new_cookie == 0x2B992DDFA232)
	{
		++new_cookie;
	}
	else if (!(new_cookie & 0x0000FFFF00000000))
	{
		new_cookie |= (new_cookie | 0x4711) << 0x10;
	}
#else
	DWORD new_cookie = (UINT_PTR)pData->pImageBase;
	if (new_cookie == 0xBB40E64E)
	{
		++new_cookie;
	}
	else if (!(new_cookie & 0xFFFF0000))
	{
		new_cookie |= (new_cookie | 0x4711) << 16;
	}
#endif

	auto pLoadConfigData = ReCa<IMAGE_LOAD_CONFIG_DIRECTORY *>(pData->pImageBase + pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress);
	pLoadConfigData->SecurityCookie = new_cookie;

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$06")) __stdcall MMI_LoadImports(MANUAL_MAPPING_DATA * pData)
{
	if (!(pData->Flags & (INJ_MM_RESOLVE_IMPORTS | INJ_MM_RUN_DLL_MAIN)))
	{
		return INJ_ERR_SUCCESS;
	}

	auto f = pData->FunctionTable;

	NTSTATUS ntRet = STATUS_SUCCESS;

	IMAGE_DATA_DIRECTORY	* pImportDir	= ReCa<IMAGE_DATA_DIRECTORY *>(&pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
	IMAGE_IMPORT_DESCRIPTOR * pImportDescr	= nullptr;

	if (pImportDir->Size)
	{
		pImportDescr = ReCa<IMAGE_IMPORT_DESCRIPTOR *>(pData->pImageBase + pImportDir->VirtualAddress);
	}

	bool ErrorBreak = false;

	while (pImportDescr && pImportDescr->Name)
	{
		//grab import name
		auto * szModule = ReCa<const char *>(pData->pImageBase + pImportDescr->Name);

		UNICODE_STRING ModNameW{ 0 };

		ModNameW.MaxLength	= MAX_PATH * sizeof(wchar_t);
		ModNameW.szBuffer	= NewObject<wchar_t>(f, MAX_PATH);
		if (!ModNameW.szBuffer)
		{
			ntRet = STATUS_NO_MEMORY;

			ErrorBreak = true;
			break;
		}

		LDRP_LOAD_CONTEXT_FLAGS ctx_flags{ 0 };
		ntRet = f->MMIHP_PreprocessModuleName(pData, szModule, &ModNameW, &ctx_flags);
		if (NT_FAIL(ntRet))
		{
			DeleteObject(f, ModNameW.szBuffer);

			if (ntRet == STATUS_APISET_NOT_HOSTED)
			{
				++pImportDescr;

				if (pImportDescr >= ReCa<IMAGE_IMPORT_DESCRIPTOR *>(pData->pImageBase + pImportDir->VirtualAddress + pImportDir->Size))
				{
					break;
				}

				continue;
			}

			ErrorBreak = true;
			break;
		}


		bool is_path = false;

		UNICODE_STRING ModNameW2 = ModNameW;
		//check if preprocess returned full path, maybe use ctx_flags for this?
		if (ModNameW.szBuffer[1] == ':')
		{
			is_path = true;

			auto * end = ModNameW2.szBuffer + ModNameW2.Length / sizeof(wchar_t);
			while (*(end - 1) != '\\')
			{
				--end;
			}

			ModNameW2.szBuffer	= end;
			ModNameW2.Length	= ModNameW.Length - (WORD)(sizeof(wchar_t) * (end - ModNameW.szBuffer));
			ModNameW2.MaxLength -= ModNameW.Length - ModNameW2.Length;
		}

		//load import
		HINSTANCE hDll = NULL;

		pData->ntRet = f->MMIHP_LoadModule(pData, &ModNameW, ctx_flags, &hDll, &pData->pImportsHead);
		
		if (NT_FAIL(pData->ntRet))
		{
			DeleteObject(f, ModNameW.szBuffer);

			if (pData->ntRet == STATUS_APISET_NOT_HOSTED)
			{
				++pImportDescr;

				if (pImportDescr >= ReCa<IMAGE_IMPORT_DESCRIPTOR *>(pData->pImageBase + pImportDir->VirtualAddress + pImportDir->Size))
				{
					break;
				}

				continue;
			}

			//unable to load required library
			ErrorBreak = true;
			break;
		}

		//grab import data
		IMAGE_THUNK_DATA * pThunk	= ReCa<IMAGE_THUNK_DATA *>(pData->pImageBase + pImportDescr->OriginalFirstThunk);
		IMAGE_THUNK_DATA * pIAT		= ReCa<IMAGE_THUNK_DATA *>(pData->pImageBase + pImportDescr->FirstThunk);

		if (!pImportDescr->OriginalFirstThunk)
		{
			pThunk = pIAT;
		}

		for (; pThunk->u1.AddressOfData; ++pThunk, ++pIAT)
		{
			UINT_PTR * pFuncRef = ReCa<UINT_PTR *>(pIAT);

			IMAGE_IMPORT_BY_NAME * pImport;
			if (IMAGE_SNAP_BY_ORDINAL(pThunk->u1.Ordinal))
			{
				//by ordinal

				pData->ntRet = f->LdrGetProcedureAddress(ReCa<void *>(hDll), nullptr, IMAGE_ORDINAL(pThunk->u1.Ordinal), ReCa<void **>(pFuncRef));
			}
			else
			{
				//by name

				pImport = ReCa<IMAGE_IMPORT_BY_NAME *>(pData->pImageBase + (pThunk->u1.AddressOfData));

				//convert c string import into ANSI_STRING
				auto * ansi_import = NewObject<ANSI_STRING>(f);
				if (!ansi_import)
				{
					ErrorBreak = true;
					break;
				}

				ansi_import->szBuffer	= pImport->Name;
				ansi_import->Length		= SizeAnsiString(ansi_import->szBuffer);
				ansi_import->MaxLength	= ansi_import->Length + 1 * sizeof(char);

				//load imported function address and save to IAT

				pData->ntRet = f->LdrGetProcedureAddress(ReCa<void *>(hDll), ansi_import, 0, ReCa<void **>(pFuncRef));

				DeleteObject(f, ansi_import);
			}

			if (NT_FAIL(pData->ntRet))
			{
				//unable to resolve function address
				ErrorBreak = true;
				break;
			}
		}

		if (ErrorBreak)
		{
			break;
		}

		++pImportDescr;

		//range check in some cases necessary, if(pImportDescr->Name) might not be sufficient
		if (pImportDescr >= ReCa<IMAGE_IMPORT_DESCRIPTOR *>(pData->pImageBase + pImportDir->VirtualAddress + pImportDir->Size))
		{
			break;
		}
	}

	if (ErrorBreak)
	{
		return INJ_MM_ERR_IMPORT_FAIL;
	}

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$07")) __stdcall MMI_LoadDelayImports(MANUAL_MAPPING_DATA * pData)
{
	if (!(pData->Flags & INJ_MM_RESOLVE_DELAY_IMPORTS))
	{
		return INJ_ERR_SUCCESS;
	}

	auto f = pData->FunctionTable;

	NTSTATUS ntRet = STATUS_SUCCESS;

	IMAGE_DATA_DIRECTORY		* pDelayImportDir	= ReCa<IMAGE_DATA_DIRECTORY *>(&pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT]);
	IMAGE_DELAYLOAD_DESCRIPTOR	* pDelayImportDescr = nullptr;

	if (pDelayImportDir->Size)
	{
		pDelayImportDescr = ReCa<IMAGE_DELAYLOAD_DESCRIPTOR *>(pData->pImageBase + pDelayImportDir->VirtualAddress);
	}

	bool ErrorBreak = false;

	while (pDelayImportDescr && pDelayImportDescr->DllNameRVA)
	{
		auto * szModule = ReCa<const char *>(pData->pImageBase + pDelayImportDescr->DllNameRVA);
		
		UNICODE_STRING ModNameW{ 0 };

		ModNameW.MaxLength	= MAX_PATH * sizeof(wchar_t);
		ModNameW.szBuffer	= NewObject<wchar_t>(f, MAX_PATH);
		if (!ModNameW.szBuffer)
		{
			ntRet = STATUS_NO_MEMORY;

			ErrorBreak = true;
			break;
		}

		LDRP_LOAD_CONTEXT_FLAGS ctx_flags{ 0 };
		ntRet = f->MMIHP_PreprocessModuleName(pData, szModule, &ModNameW, &ctx_flags);
		if (NT_FAIL(ntRet))
		{
			DeleteObject(f, ModNameW.szBuffer);

			if (ntRet == STATUS_APISET_NOT_HOSTED)
			{
				++pDelayImportDescr;

				if (pDelayImportDescr >= ReCa<IMAGE_DELAYLOAD_DESCRIPTOR *>(pData->pImageBase + pDelayImportDir->VirtualAddress + pDelayImportDir->Size))
				{
					break;
				}

				continue;
			}

			ErrorBreak = true;
			break;
		}

		bool is_path = false;

		UNICODE_STRING ModNameW2 = ModNameW;
		if (ModNameW.szBuffer[1] == ':')
		{
			is_path = true;

			auto * end = ModNameW2.szBuffer + ModNameW2.Length / sizeof(wchar_t);
			while (*(end - 1) != '\\')
			{
				--end;
			}

			ModNameW2.szBuffer	= end;
			ModNameW2.Length	= ModNameW.Length - (WORD)(sizeof(wchar_t) * (end - ModNameW.szBuffer));
			ModNameW2.MaxLength -= ModNameW.Length - ModNameW2.Length;
		}

		HINSTANCE hDll = NULL;

		pData->ntRet = f->MMIHP_LoadModule(pData, &ModNameW, ctx_flags, &hDll, &pData->pImportsHead);
		
		if (NT_FAIL(pData->ntRet))
		{
			DeleteObject(f, ModNameW.szBuffer);

			if (pData->ntRet == STATUS_APISET_NOT_HOSTED)
			{
				++pDelayImportDescr;

				if (pDelayImportDescr >= ReCa<IMAGE_DELAYLOAD_DESCRIPTOR *>(pData->pImageBase + pDelayImportDir->VirtualAddress + pDelayImportDir->Size))
				{
					break;
				}

				continue;
			}

			ErrorBreak = true;
			break;
		}

		DeleteObject(f, ModNameW.szBuffer);

		if (pDelayImportDescr->ModuleHandleRVA)
		{
			HINSTANCE * pModule = ReCa<HINSTANCE *>(pData->pImageBase + pDelayImportDescr->ModuleHandleRVA);
			*pModule = hDll;
		}

		IMAGE_THUNK_DATA * pIAT			= ReCa<IMAGE_THUNK_DATA *>(pData->pImageBase + pDelayImportDescr->ImportAddressTableRVA);
		IMAGE_THUNK_DATA * pNameTable	= ReCa<IMAGE_THUNK_DATA *>(pData->pImageBase + pDelayImportDescr->ImportNameTableRVA);

		for (; pIAT->u1.Function; ++pIAT, ++pNameTable)
		{
			if (IMAGE_SNAP_BY_ORDINAL(pNameTable->u1.Ordinal))
			{
				pData->ntRet = f->LdrGetProcedureAddress(ReCa<void *>(hDll), nullptr, IMAGE_ORDINAL(pNameTable->u1.Ordinal), ReCa<void **>(pIAT));
			}
			else
			{
				auto pImport = ReCa<IMAGE_IMPORT_BY_NAME *>(pData->pImageBase + (pNameTable->u1.AddressOfData));

				auto * ansi_import= NewObject<ANSI_STRING>(f);
				if (!ansi_import)
				{
					ErrorBreak = true;
					break;
				}

				ansi_import->szBuffer	= pImport->Name;
				ansi_import->Length		= SizeAnsiString(ansi_import->szBuffer);
				ansi_import->MaxLength	= ansi_import->Length + 1 * sizeof(char);

				pData->ntRet = f->LdrGetProcedureAddress(ReCa<void *>(hDll), ansi_import, IMAGE_ORDINAL(pNameTable->u1.Ordinal), ReCa<void **>(pIAT));
			}

			if (NT_FAIL(pData->ntRet))
			{
				ErrorBreak = true;
				break;
			}
		}

		++pDelayImportDescr;

		if (pDelayImportDescr >= ReCa<IMAGE_DELAYLOAD_DESCRIPTOR *>(pData->pImageBase + pDelayImportDir->VirtualAddress + pDelayImportDir->Size))
		{
			break;
		}
	}

	if (ErrorBreak)
	{
		return INJ_MM_ERR_DELAY_IMPORT_FAIL;
	}

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$08")) __stdcall MMI_SetPageProtections(MANUAL_MAPPING_DATA * pData)
{
	if (!(pData->Flags & INJ_MM_SET_PAGE_PROTECTIONS))
	{
		return INJ_ERR_SUCCESS;
	}

	auto f = pData->FunctionTable;

	ULONG OldProtection = 0;
	SIZE_T SizeOut = pData->pOptionalHeader->SizeOfHeaders;
	pData->ntRet = f->NtProtectVirtualMemory(NtCurrentProcess(), ReCa<void **>(&pData->pImageBase), &SizeOut, PAGE_EXECUTE_READ, &OldProtection);

	if (NT_FAIL(pData->ntRet))
	{
		return INJ_MM_ERR_UPDATE_PAGE_PROTECTION;
	}

	//iterate over all the previously mapped sections
	auto pCurrentSectionHeader = IMAGE_FIRST_SECTION(pData->pNtHeaders);

	for (UINT i = 0; i != pData->pFileHeader->NumberOfSections; ++i, ++pCurrentSectionHeader)
	{
		void * pSectionBase		= pData->pImageBase + pCurrentSectionHeader->VirtualAddress;
		DWORD characteristics	= pCurrentSectionHeader->Characteristics;
		SIZE_T SectionSize		= pCurrentSectionHeader->SizeOfRawData;

		if (SectionSize)
		{
			//identify protection state for current section
			ULONG NewProtection = PAGE_NOACCESS;

			if (characteristics & IMAGE_SCN_MEM_EXECUTE)
			{
				if (characteristics & IMAGE_SCN_MEM_WRITE)
				{
					NewProtection = PAGE_EXECUTE_READWRITE;
				}
				else if (characteristics & IMAGE_SCN_MEM_READ)
				{
					NewProtection = PAGE_EXECUTE_READ;
				}
				else
				{
					NewProtection = PAGE_EXECUTE;
				}
			}
			else
			{
				if (characteristics & IMAGE_SCN_MEM_WRITE)
				{
					NewProtection = PAGE_READWRITE;
				}
				else if (characteristics & IMAGE_SCN_MEM_READ)
				{
					NewProtection = PAGE_READONLY;
				}
			}

			//update page protection
			pData->ntRet = f->NtProtectVirtualMemory(NtCurrentProcess(), &pSectionBase, &SectionSize, NewProtection, &OldProtection);
			if (NT_FAIL(pData->ntRet))
			{
				break;
			}
		}
	}

	if (NT_FAIL(pData->ntRet))
	{
		return INJ_MM_ERR_UPDATE_PAGE_PROTECTION;
	}

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$09")) __stdcall MMI_EnableExceptions(MANUAL_MAPPING_DATA * pData)
{
	if (!(pData->Flags & INJ_MM_ENABLE_EXCEPTIONS))
	{
		return INJ_ERR_SUCCESS;
	}

	auto f = pData->FunctionTable;

	pData->pVEHShellMapped	= pData->pImageBase + pData->pOptionalHeader->SizeOfImage;
	pData->pVEHShellData	= ReCa<VEH_SHELL_DATA *>(ALIGN_UP(pData->pVEHShellMapped + pData->VEHShellSize, 0x10));

	bool veh_shell_fixed = false;
	
	//set up veh data structure
	pData->pVEHShellData->ImgBase	= ReCa<ULONG_PTR>(pData->pImageBase);
	pData->pVEHShellData->ImgSize	= pData->pOptionalHeader->SizeOfImage;
	pData->pVEHShellData->OSVersion	= pData->OSVersion;
		
	pData->pVEHShellData->LdrpInvertedFunctionTable	= f->LdrpInvertedFunctionTable;
	pData->pVEHShellData->LdrProtectMrdata			= f->LdrProtectMrdata;

	f->memmove(pData->pVEHShellMapped, pData->pVEHShell, pData->VEHShellSize);

	//insert veh data structure pointer into mapped veh shell
	veh_shell_fixed = FindAndReplacePtr(pData->pVEHShellMapped, pData->VEHShellSize, VEHDATASIG, ReCa<UINT_PTR>(pData->pVEHShellData));

	//try RtlInsertInvertedFunctionTable first
	if (pData->OSVersion >= g_Win81)
	{
		f->RtlInsertInvertedFunctionTable(pData->pImageBase, pData->pOptionalHeader->SizeOfImage);
	}
	else if (pData->OSVersion == g_Win8)
	{
		auto _RtlInsertInvertedFunctionTable = ReCa<f_RtlInsertInvertedFunctionTable_WIN8>(f->RtlInsertInvertedFunctionTable);
		_RtlInsertInvertedFunctionTable(pData->pImageBase, pData->pOptionalHeader->SizeOfImage);
	}
	else if (pData->OSVersion == g_Win7)
	{
		auto _RtlInsertInvertedFunctionTable = ReCa<f_RtlInsertInvertedFunctionTable_WIN7>(f->RtlInsertInvertedFunctionTable);
		_RtlInsertInvertedFunctionTable(ReCa<RTL_INVERTED_FUNCTION_TABLE_WIN7 *>(f->LdrpInvertedFunctionTable), pData->pImageBase, pData->pOptionalHeader->SizeOfImage);
	}

	pData->ntRet = STATUS_DLL_NOT_FOUND;
	bool partial = true;

#ifdef _WIN64
	if (veh_shell_fixed)
	{
		//register VEH shell to fill SEH handler list
		pData->hVEH = f->RtlAddVectoredExceptionHandler(0, ReCa<PVECTORED_EXCEPTION_HANDLER>(pData->pVEHShellMapped));
	}
#endif

	//check LdrpInvertedFunctionTable if module exists
	for (ULONG i = 0; i < f->LdrpInvertedFunctionTable->Count; ++i)
	{
		RTL_INVERTED_FUNCTION_TABLE_ENTRY * entry = nullptr;
		if (pData->OSVersion >= g_Win8)
		{
			entry = &f->LdrpInvertedFunctionTable->Entries[i];
		}
		else
		{
			entry = &ReCa<RTL_INVERTED_FUNCTION_TABLE_WIN7 *>(f->LdrpInvertedFunctionTable)->Entries[i];
		}

		if (entry->ImageBase != pData->pImageBase)
		{
			continue;
		}

		if (entry->ExceptionDirectorySize)
		{
			//module exists, entries have been initialized
			partial = false;
			pData->ntRet = STATUS_SUCCESS;

			break;
		}

		//module exists, entries don't
		//create fake entry which will be filled at runtime using a VEH shell
		SIZE_T FakeDirSize = 0x800 * sizeof(void *);
		pData->ntRet = f->NtAllocateVirtualMemory(NtCurrentProcess(), &pData->pFakeSEHDirectory, 0, &FakeDirSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

		if (NT_FAIL(pData->ntRet))
		{
			break;
		}

		//EncodeSystemPointer
		UINT_PTR pRaw = ReCa<UINT_PTR>(pData->pFakeSEHDirectory);
		auto cookie = *P_KUSER_SHARED_DATA_COOKIE;

#ifdef _WIN64
		UINT_PTR pEncoded = bit_rotate_r(cookie ^ pRaw, cookie & 0x3F);
#else
		UINT_PTR pEncoded = bit_rotate_r(cookie ^ pRaw, cookie & 0x1F);
#endif

		if (pData->OSVersion >= g_Win81)
		{
			f->LdrProtectMrdata(FALSE);
		}

		entry->ExceptionDirectory = ReCa<IMAGE_RUNTIME_FUNCTION_ENTRY *>(pEncoded);

		if (pData->OSVersion >= g_Win81)
		{
			f->LdrProtectMrdata(TRUE);
		}

		if (veh_shell_fixed && !pData->hVEH)
		{
			//register VEH shell to fill handler list
			pData->hVEH = f->RtlAddVectoredExceptionHandler(0, ReCa<PVECTORED_EXCEPTION_HANDLER>(pData->pVEHShellMapped));
		}

		break;
	}

#ifdef _WIN64
	if (NT_SUCCESS(pData->ntRet) && partial)
	{
		//on x64 also try documented method
		auto size = pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
		if (size)
		{
			auto * pExceptionHandlers = ReCa<RUNTIME_FUNCTION *>(pData->pImageBase + pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress);
			auto EntryCount = size / sizeof(RUNTIME_FUNCTION);

			if (!f->RtlAddFunctionTable(pExceptionHandlers, MDWD(EntryCount), ReCa<DWORD64>(pData->pImageBase)))
			{
				pData->ntRet = STATUS_UNSUCCESSFUL;
			}
		}
		else
		{
			pData->ntRet = STATUS_UNSUCCESSFUL;
		}
	}
#endif

	if (NT_FAIL(pData->ntRet))
	{
		return INJ_MM_ERR_ENABLING_SEH_FAILED;
	}

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$0A")) __stdcall MMI_HandleTLS(MANUAL_MAPPING_DATA * pData)
{
	if (!(pData->Flags & INJ_MM_EXECUTE_TLS))
	{
		return INJ_ERR_SUCCESS;
	}

	if (!pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size)
	{
		return INJ_ERR_SUCCESS;
	}

	auto f = pData->FunctionTable;

	auto * pTLS = ReCa<IMAGE_TLS_DIRECTORY *>(pData->pImageBase + pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);

	auto * pDummyLdr = NewObject<LDR_DATA_TABLE_ENTRY>(f);
	if (!pDummyLdr)
	{
		return INJ_MM_ERR_HEAP_ALLOC;
	}

	//LdrpHandleTlsData either crashes or returns STATUS_SUCCESS -> no point in error checking
	//it also only accesses the DllBase member of the ldr entry thus a dummy ldr entry is sufficient

	pDummyLdr->DllBase = pData->pImageBase;

	if (pData->OSVersion <= g_Win8)
	{
		//Win7 & Win8 __stdcall
		auto _LdrpHandleTlsData = ReCa<f_LdrpHandleTlsData_WIN8>(f->LdrpHandleTlsData);
		_LdrpHandleTlsData(ReCa<LDR_DATA_TABLE_ENTRY_WIN8 *>(pDummyLdr));
	}
	else
	{
		//Win8.1+ __fastcall
		f->LdrpHandleTlsData(pDummyLdr);
	}

	//iterate through and call TLS callbacks
	auto * pCallback = ReCa<PIMAGE_TLS_CALLBACK *>(pTLS->AddressOfCallBacks);
	for (; pCallback && (*pCallback); ++pCallback)
	{
		auto Callback = *pCallback;
		Callback(pData->pImageBase, DLL_PROCESS_ATTACH, nullptr);
	}

	//unlink from tls list so the dummy ldr entry can be released
	auto current = f->LdrpTlsList->Flink;
	while (current != f->LdrpTlsList)
	{
		auto entry = ReCa<TLS_ENTRY *>(current);
		if (entry->ModuleEntry == pDummyLdr)
		{
			entry->ModuleEntry = nullptr;

			break;
		}

		current = current->Flink;
	}

	//delete the dummy ldr entry
	DeleteObject(f, pDummyLdr);

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$0B")) __stdcall MMI_ExecuteDllMain(MANUAL_MAPPING_DATA * pData)
{
	if (!(pData->Flags & INJ_MM_RUN_DLL_MAIN))
	{
		return INJ_ERR_SUCCESS;
	}

	auto f = pData->FunctionTable;

	if (!pData->pOptionalHeader->AddressOfEntryPoint)
	{
		return INJ_ERR_SUCCESS;
	}

	ULONG		State	= 0;
	ULONG_PTR	Cookie	= 0;
	bool		locked	= false;

	if (pData->Flags & INJ_MM_RUN_UNDER_LDR_LOCK)
	{
		pData->ntRet = f->LdrLockLoaderLock(NULL, &State, &Cookie);

		//don't interrupt only because loader lock wasn't acquired
		locked = NT_SUCCESS(pData->ntRet);
	}

	f_DLL_ENTRY_POINT DllMain = ReCa<f_DLL_ENTRY_POINT>(pData->pImageBase + pData->pOptionalHeader->AddressOfEntryPoint);
	DllMain(ReCa<HINSTANCE>(pData->pImageBase), DLL_PROCESS_ATTACH, nullptr);

	if ((pData->Flags & INJ_MM_RUN_UNDER_LDR_LOCK) && locked)
	{
		f->LdrUnlockLoaderLock(NULL, Cookie);
	}

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$0C")) __stdcall MMI_CleanDataDirectories(MANUAL_MAPPING_DATA * pData)
{
	if (!(pData->Flags & INJ_MM_CLEAN_DATA_DIR && !(pData->Flags & INJ_MM_SET_PAGE_PROTECTIONS)))
	{
		return INJ_ERR_SUCCESS;
	}

	auto f = pData->FunctionTable;

	//remove strings from the import directory
	DWORD Size = pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
	if (Size)
	{
		auto * pImportDescr = ReCa<IMAGE_IMPORT_DESCRIPTOR *>(pData->pImageBase + pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
		while (pImportDescr->Name)
		{
			char * szMod = ReCa<char *>(pData->pImageBase + pImportDescr->Name);
			for (; *szMod++; *szMod = '\0');
			pImportDescr->Name = 0;

			IMAGE_THUNK_DATA * pThunk	= ReCa<IMAGE_THUNK_DATA *>(pData->pImageBase + pImportDescr->OriginalFirstThunk);
			IMAGE_THUNK_DATA * pIAT		= ReCa<IMAGE_THUNK_DATA *>(pData->pImageBase + pImportDescr->FirstThunk);

			if (!pImportDescr->OriginalFirstThunk)
			{
				pThunk = pIAT;
			}

			for (; pThunk->u1.AddressOfData; ++pThunk, ++pIAT)
			{
				if (IMAGE_SNAP_BY_ORDINAL(pThunk->u1.Ordinal))
				{
					pThunk->u1.Ordinal = 0;
				}
				else
				{
					auto * pImport	= ReCa<IMAGE_IMPORT_BY_NAME *>(pData->pImageBase + (pThunk->u1.AddressOfData));
					char * szFunc	= pImport->Name;
					for (; *szFunc++; *szFunc = '\0');
				}
			}

			pImportDescr->OriginalFirstThunk = 0;
			pImportDescr->FirstThunk = 0;

			++pImportDescr;
		}

		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = 0;
		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = 0;
	}

	//remove strings from the delay import directory
	Size = pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size;
	if (Size && !(pData->Flags & INJ_MM_RESOLVE_DELAY_IMPORTS))
	{
		auto * pDelayImportDescr = ReCa<IMAGE_DELAYLOAD_DESCRIPTOR *>(pData->pImageBase + pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress);

		while (pDelayImportDescr->DllNameRVA)
		{
			char * szMod = ReCa<char *>(pData->pImageBase + pDelayImportDescr->DllNameRVA);
			for (; *szMod++; *szMod = '\0');
			pDelayImportDescr->DllNameRVA = 0;

			pDelayImportDescr->ModuleHandleRVA = 0;

			IMAGE_THUNK_DATA * pIAT			= ReCa<IMAGE_THUNK_DATA *>(pData->pImageBase + pDelayImportDescr->ImportAddressTableRVA);
			IMAGE_THUNK_DATA * pNameTable	= ReCa<IMAGE_THUNK_DATA *>(pData->pImageBase + pDelayImportDescr->ImportNameTableRVA);

			for (; pIAT->u1.Function; ++pIAT, ++pNameTable)
			{

				if (IMAGE_SNAP_BY_ORDINAL(pNameTable->u1.Ordinal))
				{
					pNameTable->u1.Ordinal = 0;
				}
				else
				{
					auto * pImport	= ReCa<IMAGE_IMPORT_BY_NAME *>(pData->pImageBase + (pNameTable->u1.AddressOfData));
					char * szFunc	= pImport->Name;
					for (; (*szFunc)++; *szFunc = '\0');
				}
			}

			pDelayImportDescr->ImportAddressTableRVA = 0;
			pDelayImportDescr->ImportNameTableRVA = 0;

			++pDelayImportDescr;
		}

		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress = 0;
		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size = 0;
	}

	//remove debug data
	Size = pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
	if (Size)
	{
		auto * pDebugDir = ReCa<IMAGE_DEBUG_DIRECTORY *>(pData->pImageBase + pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress);

		BYTE * pDebugData = pData->pImageBase + pDebugDir->AddressOfRawData;
		f->RtlZeroMemory(pDebugData, pDebugDir->SizeOfData);

		pDebugDir->SizeOfData = 0;
		pDebugDir->AddressOfRawData = 0;
		pDebugDir->PointerToRawData = 0;

		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress = 0;
		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size = 0;
	}

	//remove base relocation information
	Size = pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
	if (Size)
	{
		auto * pRelocData = ReCa<IMAGE_BASE_RELOCATION *>(pData->pImageBase + pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
		while (pRelocData->VirtualAddress)
		{
			WORD * pRelativeInfo = ReCa<WORD *>(pRelocData + 1);
			UINT RelocCount = (pRelocData->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION));

			f->RtlZeroMemory(pRelativeInfo, RelocCount);

			pRelocData = ReCa<IMAGE_BASE_RELOCATION *>(ReCa<BYTE *>(pRelocData) + pRelocData->SizeOfBlock);
		}

		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = 0;
	}

	//remove TLS callback information
	Size = pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
	if (Size)
	{
		auto * pTLS			= ReCa<IMAGE_TLS_DIRECTORY *>(pData->pImageBase + pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
		auto * pCallback	= ReCa<PIMAGE_TLS_CALLBACK *>(pTLS->AddressOfCallBacks);
		for (; pCallback && (*pCallback); ++pCallback)
		{
			*pCallback = nullptr;
		}

		pTLS->AddressOfCallBacks	= 0;
		pTLS->AddressOfIndex		= 0;
		pTLS->EndAddressOfRawData	= 0;
		pTLS->SizeOfZeroFill		= 0;
		pTLS->StartAddressOfRawData = 0;

		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress	= 0;
		pData->pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size			= 0;
	}

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$0D")) __stdcall MMI_CloakHeader(MANUAL_MAPPING_DATA * pData)
{
	if (!(pData->Flags & (INJ_ERASE_HEADER | INJ_FAKE_HEADER)))
	{
		return INJ_ERR_SUCCESS;
	}

	auto f = pData->FunctionTable;

	void * base			= pData->pImageBase;
	SIZE_T header_size	= pData->pOptionalHeader->SizeOfHeaders;
	ULONG old_access	= NULL;

	//PE header is R/E only
	if (pData->Flags & INJ_MM_SET_PAGE_PROTECTIONS)
	{
		pData->ntRet = f->NtProtectVirtualMemory(NtCurrentProcess(), &base, &header_size, PAGE_EXECUTE_READWRITE, &old_access);

		if (NT_FAIL(pData->ntRet))
		{
			return INJ_MM_ERR_UPDATE_PAGE_PROTECTION;
		}
	}

	if (pData->Flags & INJ_ERASE_HEADER)
	{
		f->RtlZeroMemory(pData->pImageBase, header_size);
	}
	else if (pData->Flags & INJ_FAKE_HEADER)
	{
		//grab ntdll from the ldr

		PEB * pPEB = nullptr;

#ifdef  _WIN64
		pPEB = ReCa<PEB *>(__readgsqword(0x60));
#else
		pPEB = ReCa<PEB *>(__readfsdword(0x30));
#endif 
		if (!pPEB)
		{
			return INJ_MM_ERR_CANT_GET_PEB;
		}

		if (!pPEB->Ldr || !pPEB->Ldr->InLoadOrderModuleListHead.Flink || !pPEB->Ldr->InLoadOrderModuleListHead.Flink->Flink)
		{
			return INJ_MM_ERR_INVALID_PEB_DATA;
		}

		auto * ntdll_ldr = ReCa<LDR_DATA_TABLE_ENTRY *>(pPEB->Ldr->InLoadOrderModuleListHead.Flink->Flink);
		if (!ntdll_ldr || !ntdll_ldr->DllBase)
		{
			return INJ_MM_ERR_INVALID_PEB_DATA;
		}

		BYTE * p_ntdll = ReCa<BYTE *>(ntdll_ldr->DllBase);
		IMAGE_DOS_HEADER * p_nt_dos = ReCa<IMAGE_DOS_HEADER *>(p_ntdll);
		IMAGE_NT_HEADERS * p_nt_nt	= ReCa<IMAGE_NT_HEADERS *>(p_ntdll + p_nt_dos->e_lfanew);

		f->RtlZeroMemory(pData->pImageBase, header_size);

		f->memmove(pData->pImageBase, ntdll_ldr->DllBase, min(p_nt_nt->OptionalHeader.SizeOfHeaders, header_size));
	}

	//update PE header protection back to R/E
	if (pData->Flags & INJ_MM_SET_PAGE_PROTECTIONS)
	{
		pData->ntRet = f->NtProtectVirtualMemory(NtCurrentProcess(), &base, &header_size, old_access, &old_access);

		if (NT_FAIL(pData->ntRet))
		{
			return INJ_MM_ERR_UPDATE_PAGE_PROTECTION;
		}
	}

	return INJ_ERR_SUCCESS;
}

DWORD __declspec(code_seg(".mmap_sec$0E")) __stdcall MMI_CleanUp(MANUAL_MAPPING_DATA * pData)
{
	auto f = pData->FunctionTable;

	if (pData->pFakeSEHDirectory)
	{
		SIZE_T Size = 0;
		f->NtFreeVirtualMemory(NtCurrentProcess(), ReCa<void **>(&pData->pFakeSEHDirectory), &Size, MEM_RELEASE);
	}

	if (pData->hVEH)
	{
		f->RtlRemoveVectoredExceptionHandler(pData->hVEH);
	}

	if (pData->pDelayImportsHead)
	{
		UnloadAndDeleteDependencyRecord(f, pData->pDelayImportsHead);
	}

	if (pData->pImportsHead)
	{
		UnloadAndDeleteDependencyRecord(f, pData->pImportsHead);
	}

	if (pData->pAllocationBase)
	{
		SIZE_T Size = 0;
		f->NtFreeVirtualMemory(NtCurrentProcess(), ReCa<void **>(&pData->pAllocationBase), &Size, MEM_RELEASE);
	}

	if (pData->pRawData && !(pData->Flags & INJ_MM_MAP_FROM_MEMORY))
	{
		SIZE_T Size = 0;
		f->NtFreeVirtualMemory(NtCurrentProcess(), ReCa<void **>(&pData->pRawData), &Size, MEM_RELEASE);
	}

	if (pData->hDllFile)
	{
		f->NtClose(pData->hDllFile);
	}

	return 0;
}

DWORD __declspec(code_seg(".mmap_sec$14")) MMAP_SEC_END()
{
	return 1337;
}

MANUAL_MAPPING_FUNCTION_TABLE::MANUAL_MAPPING_FUNCTION_TABLE()
{
	NT_FUNC_CONSTRUCTOR_INIT(NtOpenFile);
	NT_FUNC_CONSTRUCTOR_INIT(NtReadFile);
	NT_FUNC_CONSTRUCTOR_INIT(NtClose);

	NT_FUNC_CONSTRUCTOR_INIT(NtSetInformationFile);
	NT_FUNC_CONSTRUCTOR_INIT(NtQueryInformationFile);

	NT_FUNC_CONSTRUCTOR_INIT(NtAllocateVirtualMemory);
	NT_FUNC_CONSTRUCTOR_INIT(NtProtectVirtualMemory);
	NT_FUNC_CONSTRUCTOR_INIT(NtFreeVirtualMemory);

	NT_FUNC_CONSTRUCTOR_INIT(NtCreateSection);
	NT_FUNC_CONSTRUCTOR_INIT(NtMapViewOfSection);

	NT_FUNC_CONSTRUCTOR_INIT(memmove);
	NT_FUNC_CONSTRUCTOR_INIT(RtlZeroMemory);
	NT_FUNC_CONSTRUCTOR_INIT(RtlAllocateHeap);
	NT_FUNC_CONSTRUCTOR_INIT(RtlFreeHeap);

	NT_FUNC_CONSTRUCTOR_INIT(LdrpLoadDll);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpLoadDllInternal);
	NT_FUNC_CONSTRUCTOR_INIT(LdrGetProcedureAddress);

	NT_FUNC_CONSTRUCTOR_INIT(LdrUnloadDll);

	NT_FUNC_CONSTRUCTOR_INIT(RtlAnsiStringToUnicodeString);
	NT_FUNC_CONSTRUCTOR_INIT(RtlUnicodeStringToAnsiString);
	NT_FUNC_CONSTRUCTOR_INIT(RtlCompareUnicodeString);
	NT_FUNC_CONSTRUCTOR_INIT(RtlCompareString);

	NT_FUNC_CONSTRUCTOR_INIT(LdrGetDllPath);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpPreprocessDllName);
	NT_FUNC_CONSTRUCTOR_INIT(RtlInsertInvertedFunctionTable);
#ifdef _WIN64
	NT_FUNC_CONSTRUCTOR_INIT(RtlAddFunctionTable);
#endif
	NT_FUNC_CONSTRUCTOR_INIT(LdrpHandleTlsData);

	NT_FUNC_CONSTRUCTOR_INIT(LdrLockLoaderLock);
	NT_FUNC_CONSTRUCTOR_INIT(LdrUnlockLoaderLock);

	NT_FUNC_CONSTRUCTOR_INIT(LdrpDereferenceModule);

	NT_FUNC_CONSTRUCTOR_INIT(LdrProtectMrdata);

	NT_FUNC_CONSTRUCTOR_INIT(RtlAddVectoredExceptionHandler);
	NT_FUNC_CONSTRUCTOR_INIT(RtlRemoveVectoredExceptionHandler);

	NT_FUNC_CONSTRUCTOR_INIT(LdrpModuleBaseAddressIndex);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpMappingInfoIndex);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpHeap);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpInvertedFunctionTable);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpDefaultPath);
	NT_FUNC_CONSTRUCTOR_INIT(LdrpTlsList);
}
```

`GH Injector Library/Manual Mapping.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "Manual Mapping Internal.h"

#define MIN_SHIFT_OFFSET	0x100
#define MAX_SHIFT_OFFSET	0x1000

namespace MMAP_NATIVE
{
	DWORD ManualMap(const INJECTION_SOURCE & DllPath, HANDLE hTargetProc, LAUNCH_METHOD Method, DWORD Flags, HINSTANCE & hOut, DWORD Timeout, ERROR_DATA & error_data);
}

#ifdef _WIN64

namespace MMAP_WOW64
{
	DWORD ManualMap_WOW64(const INJECTION_SOURCE & DllPath, HANDLE hTargetProc, LAUNCH_METHOD Method, DWORD Flags, HINSTANCE & hOut, DWORD Timeout, ERROR_DATA & error_data);
}

#endif
```

`GH Injector Library/NT Defs.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "pch.h"

#pragma region nt (un)defines

#ifndef NT_FAIL
#define NT_FAIL(status) (status < 0)
#endif

#ifndef NT_SUCCESS
#define NT_SUCCESS(status) (status >= 0)
#endif

#ifdef memmove
#undef memmove
#endif

#ifdef RtlZeroMemory
#undef RtlZeroMemory
#endif

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED	0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH	0x00000002 //broken?!
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER	0x00000004

#define OBJ_CASE_INSENSITIVE 0x00000040

#define STATUS_SUCCESS				0x00000000
#define STATUS_UNSUCCESSFUL			0xC0000001
#define STATUS_NOT_IMPLEMENTED		0xC0000002
#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004
#define STATUS_APISET_NOT_HOSTED	0xC0000481

#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020

////
#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000
////


#define InitializeObjectAttributes(p, n, a, r, s) \
{ \
	(p)->Length = sizeof(OBJECT_ATTRIBUTES); \
	(p)->RootDirectory				= r; \
	(p)->Attributes					= a; \
	(p)->ObjectName					= n; \
	(p)->SecurityDescriptor			= s; \
	(p)->SecurityQualityOfService	= NULL; \
}

typedef LONG KPRIORITY;

#define KUSER_SHARED_DATA (DWORD)0x7FFE0000
#define P_KUSER_SHARED_DATA_COOKIE ReCa<DWORD *>(KUSER_SHARED_DATA + 0x0330)

#define NtCurrentProcess() ( (HANDLE)(LONG_PTR) -1 ) 

#pragma endregion

#pragma region enums

typedef enum class _PROCESSINFOCLASS
{
	ProcessBasicInformation			= 0,
	ProcessSessionInformation		= 24,
	ProcessWow64Information			= 26,
	ProcessCookie					= 36,
	ProcessProtectionInformation	= 61
} PROCESSINFOCLASS;

typedef enum class _SYSTEM_INFORMATION_CLASS
{
	SystemProcessInformation	= 5,
	SystemHandleInformation		= 16
} SYSTEM_INFORMATION_CLASS;

typedef enum class _THREADINFOCLASS
{
	ThreadBasicInformation			= 0,
	ThreadQuerySetWin32StartAddress = 9
} THREADINFOCLASS;

typedef enum class _KTHREAD_STATE
{
	Running = 0x02,
	Waiting = 0x05
} KTHREAD_STATE;

typedef enum class _KWAIT_REASON
{
	WrQueue = 0x0F
} KWAIT_REASON;

typedef enum class _OBEJECT_TYPE_NUMBER
{
	Process = 0x07
} OBJECT_TYPE_NUMBER;

typedef enum _FILE_INFORMATION_CLASS
{
	FileStandardInformation = 5,
	FilePositionInformation = 14
} FILE_INFORMATION_CLASS, * PFILE_INFORMATION_CLASS;

typedef enum _LDR_DDAG_STATE : int
{
	LdrModulesMerged					= -5,
	LdrModulesInitError					= -4,
	LdrModulesSnapError					= -3,
	LdrModulesUnloaded					= -2,
	LdrModulesUnloading					= -1,
	LdrModulesPlaceHolder				= 0,
	LdrModulesMapping					= 1,
	LdrModulesMapped					= 2,
	LdrModulesWaitingForDependencies	= 3,
	LdrModulesSnapping					= 4,
	LdrModulesSnapped					= 5,
	LdrModulesCondensed					= 6,
	LdrModulesReadyToInit				= 7,
	LdrModulesInitializing				= 8,
	LdrModulesReadyToRun				= 9
} LDR_DDAG_STATE, * PLDR_DDAG_STATE;

typedef enum _LDR_DLL_LOAD_REASON : int
{
	LoadReasonUnknown						= -1,
	LoadReasonStaticDependency				= 0,
	LoadReasonStaticForwarderDependency		= 1,
	LoadReasonDynamicForwarderDependency	= 2,
	LoadReasonDelayloadDependency			= 3,
	LoadReasonDynamicLoad					= 4,
	LoadReasonAsImageLoad					= 5,
	LoadReasonAsDataLoad					= 6,
	LoadReasonEnclavePrimary				= 7, 
	LoadReasonEnclaveDependency				= 8,
	LoadReasonPatchImage					= 9
} LDR_DLL_LOAD_REASON, * PLDR_DLL_LOAD_REASON;

typedef enum _SECTION_INHERIT
{
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;

typedef enum _LDR_HOT_PATCH_STATE
{
    LdrHotPatchBaseImage		= 0,
    LdrHotPatchNotApplied		= 1,
    LdrHotPatchAppliedReverse	= 2,
    LdrHotPatchAppliedForward	= 3,
    LdrHotPatchFailedToPatch	= 4,
    LdrHotPatchStateMax			= 5
} LDR_HOT_PATCH_STATE, * PLDR_HOT_PATCH_STATE;

#pragma endregion

struct PEB;

typedef struct _ANSI_STRING
{
	USHORT	Length;
	USHORT	MaxLength;
	char *	szBuffer;
} ANSI_STRING, * PANSI_STRING;

typedef struct _UNICODE_STRING
{
	WORD		Length;
	WORD		MaxLength;
	wchar_t *	szBuffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _RTL_BALANCED_NODE
{
	union
	{
		struct _RTL_BALANCED_NODE * Children[2];
		struct
		{
			struct _RTL_BALANCED_NODE * Left;
			struct _RTL_BALANCED_NODE * Right;
		};
	};

	union
	{
		UCHAR Red		: 1;
		UCHAR Balance	: 2;
		ULONG_PTR ParentValue;
	};
} RTL_BALANCED_NODE, * PRTL_BALANCED_NODE;

typedef struct _RTL_RB_TREE
{
	RTL_BALANCED_NODE * Root;
	RTL_BALANCED_NODE * Min;
} RTL_RB_TREE, * PRTL_RB_TREE;

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	WORD		UniqueProcessId;
	WORD		CreateBackTraceIndex;
	BYTE		ObjectTypeIndex;
	BYTE		HandleAttributes;
	WORD		HandleValue;
	void	*	Object;
	ULONG		GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS	ExitStatus;
	PVOID		TebBaseAddress;
	CLIENT_ID	ClientId;
	KAFFINITY	AffinityMask;
	KPRIORITY	Priority;
	KPRIORITY	BasePriority;
} THREAD_BASIC_INFORMATION, * PTHREAD_BASIC_INFORMATION;

typedef struct _PROCESS_BASIC_INFORMATION
{
	NTSTATUS	ExitStatus;
	PEB	*		pPEB;
	ULONG_PTR	AffinityMask;
	LONG		BasePriority;
	HANDLE		UniqueProcessId;
	HANDLE		InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, * PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_SESSION_INFORMATION
{
	ULONG SessionId;
} PROCESS_SESSION_INFORMATION, * PPROCESS_SESSION_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER	KernelTime;
	LARGE_INTEGER	UserTime;
	LARGE_INTEGER	CreateTime;
	ULONG			WaitTime;
	PVOID			StartAddress;
	CLIENT_ID		ClientId;
	KPRIORITY		Priority;
	LONG			BasePriority;
	ULONG			ContextSwitches;
	KTHREAD_STATE	ThreadState;
	KWAIT_REASON	WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG			NextEntryOffset;
	ULONG			NumberOfThreads;
	LARGE_INTEGER	WorkingSetPrivateSize;
	ULONG			HardFaultCount;
	ULONG			NumberOfThreadsHighWatermark;
	ULONGLONG		CycleTime;
	LARGE_INTEGER	CreateTime;
	LARGE_INTEGER	UserTime;
	LARGE_INTEGER	KernelTime;
	UNICODE_STRING	ImageName;
	KPRIORITY		BasePriority;
	HANDLE			UniqueProcessId;
	HANDLE			InheritedFromUniqueProcessId;
	ULONG			HandleCount;
	ULONG			SessionId;
	ULONG_PTR		UniqueProcessKey;
	SIZE_T			PeakVirtualSize;
	SIZE_T			VirtualSize;
	ULONG			PageFaultCount;
	SIZE_T 			PeakWorkingSetSize;
	SIZE_T			WorkingSetSize;
	SIZE_T			QuotaPeakPagedPoolUsage;
	SIZE_T 			QuotaPagedPoolUsage;
	SIZE_T 			QuotaPeakNonPagedPoolUsage;
	SIZE_T 			QuotaNonPagedPoolUsage;
	SIZE_T 			PagefileUsage;
	SIZE_T 			PeakPagefileUsage;
	SIZE_T 			PrivatePageCount;
	LARGE_INTEGER	ReadOperationCount;
	LARGE_INTEGER	WriteOperationCount;
	LARGE_INTEGER	OtherOperationCount;
	LARGE_INTEGER 	ReadTransferCount;
	LARGE_INTEGER	WriteTransferCount;
	LARGE_INTEGER	OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION
{
	LARGE_INTEGER AllocationSize;
	LARGE_INTEGER EndOfFile;
	ULONG         NumberOfLinks;
	BOOLEAN       DeletePending;
	BOOLEAN       Directory;
} FILE_STANDARD_INFORMATION, * PFILE_STANDARD_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION
{
	LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, * PFILE_POSITION_INFORMATION;

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG				Length;
	HANDLE				RootDirectory;
	UNICODE_STRING *	ObjectName;
	ULONG				Attributes;
	PVOID				SecurityDescriptor;
	PVOID				SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK
{
	union
	{
		NTSTATUS	Status;
		PVOID		Pointer;
	} DUMMYUNIONNAME;

	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef struct _PEB_LDR_DATA
{
	ULONG		Length;
	BYTE		Initialized;
	HANDLE		SsHandle;
	LIST_ENTRY	InLoadOrderModuleListHead;
	LIST_ENTRY	InMemoryOrderModuleListHead;
	LIST_ENTRY	InInitializationOrderModuleListHead;
	PVOID		EntryInProgress;
	BYTE		ShutdownInProgress;
	HANDLE		ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

struct PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;

	union
	{
		UCHAR BitField;
		struct
		{
			UCHAR ImageUsedLargePages			: 1;
			UCHAR IsProtectedProcess			: 1;
			UCHAR IsImageDynamicallyRelocated	: 1;
			UCHAR SkipPatchingUser32Forwarders	: 1;
			UCHAR IsPackagedProcess				: 1;
			UCHAR IsAppContainer				: 1;
			UCHAR IsProtectedProcessLight		: 1;
			UCHAR IsLongPathAwareProcess		: 1;
		};
	};

	HANDLE Mutant;

	PVOID ImageBaseAddress;

	PEB_LDR_DATA * Ldr;

	PVOID					*	ProcessParameters;
	PVOID						SubSystemData;
	HANDLE						ProcessHeap;
	RTL_CRITICAL_SECTION	*	FastPebLock;
	PVOID						AtlThunkSListPtr;
	PVOID						IFEOKey;

	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob					: 1;
			ULONG ProcessInitializing			: 1;
			ULONG ProcessUsingVEH				: 1;
			ULONG ProcessUsingVCH				: 1;
			ULONG ProcessUsingFTH				: 1;
			ULONG ProcessPreviouslyThrottled	: 1;
			ULONG ProcessCurrentlyThrottled		: 1;
			ULONG ProcessImagesHotPatched		: 1;
			ULONG ReservedBits0					: 24;
		};
	};

#ifdef _WIN64
	UCHAR Padding1[4];
#endif

	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};

	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
	ULONG TlsExpansionCounter;

#ifdef _WIN64
	UCHAR Padding2[4];
#endif

	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];
	PVOID ReadOnlySharedMemoryBase;

	union
	{
		PVOID HotpatchInformation;	// till Win8
		PVOID SparePvoid0;			// Win8.1 -> Win10 (1607)
		PVOID SharedData;			// Win10 (1703) +
	};

	PVOID * ReadOnlyStaticServerData;
	PVOID AnsiCodePageData;
	PVOID OemCodePageData;
	PVOID UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	LARGE_INTEGER CriticalSectionTimeout;
	ULONG_PTR HeapSegmentReserve;
	ULONG_PTR HeapSegmentCommit;
	ULONG_PTR HeapDeCommitTotalFreeThreshold;
	ULONG_PTR HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID * ProcessHeaps;
	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;

#ifdef _WIN64
	UCHAR Padding3[4];
#endif

	RTL_CRITICAL_SECTION * LoaderLock;
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;

	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
};

typedef struct _LDR_SERVICE_TAG_RECORD
{
	struct _LDR_SERVICE_TAG_RECORD * Next;
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
	struct _SINGLE_LIST_ENTRY * Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef struct _LDRP_UNICODE_STRING_BUNDLE
{
	UNICODE_STRING	String;
	WCHAR			StaticBuffer[128];
} LDRP_UNICODE_STRING_BUNDLE, * PLDRP_UNICODE_STRING_BUNDLE;

typedef struct _RTL_INVERTED_FUNCTION_TABLE_ENTRY
{
	IMAGE_RUNTIME_FUNCTION_ENTRY *	ExceptionDirectory;
	PVOID							ImageBase;
	ULONG							ImageSize;
	ULONG							ExceptionDirectorySize;
} RTL_INVERTED_FUNCTION_TABLE_ENTRY, * PRTL_INVERTED_FUNCTION_TABLE_ENTRY;

typedef struct _RTL_INVERTED_FUNCTION_TABLE
{
	ULONG Count;
	ULONG MaxCount;
	ULONG Epoch;
	UCHAR Overflow;
	RTL_INVERTED_FUNCTION_TABLE_ENTRY Entries[ANYSIZE_ARRAY];
} RTL_INVERTED_FUNCTION_TABLE, * PRTL_INVERTED_FUNCTION_TABLE;

typedef union _LDR_SEARCH_PATH
{
	BOOLEAN NoPath : 1;
	wchar_t * szSearchPath;
} LDR_SEARCH_PATH, * PLDR_SEARCH_PATH;

//Win10 1511
typedef struct _LDRP_PATH_SEARCH_CONTEXT_1511
{
	wchar_t *	DllSearchPathOut;
	void	*	Unknown_0[2];
	wchar_t *	OriginalFullDllName;
	void	*	unknown_1[7];
	ULONG64		unknown_2[4];
} LDRP_PATH_SEARCH_CONTEXT_1511, * PLDRP_PATH_SEARCH_CONTEXT_1511; //x86 size = 0x4C, x64 size = 0x78

//Win10 1507, 1607+
typedef struct _LDRP_PATH_SEARCH_CONTEXT
{
	wchar_t *	DllSearchPathOut;
	void	*	Unknown_0[3];
	wchar_t *	OriginalFullDllName;
	void	*	unknown_1[7];
	ULONG64		unknown_2[4];
} LDRP_PATH_SEARCH_CONTEXT, * PLDRP_PATH_SEARCH_CONTEXT; //x86 size <= 0x50, x64 size <= 0x80

typedef union _LDRP_LOAD_CONTEXT_FLAGS
{
	ULONG32 Flags;
	struct //These are very most likely wrong!
	{
		ULONG32 Redirected					: 1;
		ULONG32 Static						: 1;
		ULONG32 BaseNameOnly				: 1;
		ULONG32 HasFullPath					: 1;
		ULONG32 KnownDll					: 1;
		ULONG32 SystemImage					: 1;
		ULONG32 ExecutableImage				: 1;
		ULONG32 AppContainerImage			: 1;
		ULONG32 CallInit					: 1;
		ULONG32 UserAllocated				: 1;
		ULONG32 SearchOnlyFirstPathSegment	: 1;
		ULONG32 RedirectedByAPISet			: 1;
	};
} LDRP_LOAD_CONTEXT_FLAGS, * PLDRP_LOAD_CONTEXT_FLAGS;

typedef struct _RTL_VECTORED_HANDLER_LIST
{
	SRWLOCK     Lock;
	LIST_ENTRY  List;
} RTL_VECTORED_HANDLER_LIST, * PRTL_VECTORED_HANDLER_LIST;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY //Win7 till Win10 1909
{
	LIST_ENTRY					List;
	DWORD						Flag;
	PVECTORED_EXCEPTION_HANDLER	VectoredHandler;
} RTL_VECTORED_EXCEPTION_ENTRY, * PRTL_VECTORED_EXCEPTION_ENTRY;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004 //Win10 2004+
{
	LIST_ENTRY                  List;
	PULONG_PTR                  pFlag; //points to Flag
	ULONG                       RefCount;
	PVECTORED_EXCEPTION_HANDLER VectoredHandler;
	ULONG_PTR					Flag; //normally allocated somewhere else on LdrpMrdataHeap, just for convenience
} RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004, * PRTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004;

typedef struct _TLS_ENTRY
{
	LIST_ENTRY				TlsEntryLinks;
	IMAGE_TLS_DIRECTORY		TlsDirectory;
	PVOID 					ModuleEntry; //LdrDataTableEntry
	SIZE_T					TlsIndex;
} TLS_ENTRY, * PTLS_ENTRY;

#ifdef _WIN64

typedef ALIGN_86 struct _UNICODE_STRING_32
{
	WORD	Length;
	WORD	MaxLength;
	DWORD	szBuffer;
} UNICODE_STRING_32, * PUNICODE_STRING_32;

typedef ALIGN_86 struct _RTL_BALANCED_NODE_32
{
	union
	{
		DWORD Children[2];
		struct
		{
			DWORD Left;
			DWORD Right;
		};
	};

	union
	{
		UCHAR Red		: 1;
		UCHAR Balance	: 2;
		DWORD ParentValue;
	};
} RTL_BALANCED_NODE_32, * PRTL_BALANCED_NODE_32;

typedef ALIGN_86 struct _SINGLE_LIST_ENTRY_32
{
	DWORD Next; // -> SINGLE_LIST_ENTRY_32
} SINGLE_LIST_ENTRY_32, * PSINGLE_LIST_ENTRY_32;

typedef ALIGN_86 struct _LDR_SERVICE_TAG_RECORD_32
{
	DWORD Next; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD_32, * PLDR_SERVICE_TAG_RECORD_32;

typedef ALIGN_86 struct _LDRP_CSLIST_32
{
	DWORD Tail; // -> SINGLE_LIST_ENTRY_32
} LDRP_CSLIST_32, * PLDRP_CSLIST_32;

typedef ALIGN_86 struct _RTL_CRITICAL_SECTION_32
{
	DWORD	DebugInfo; // -> RTL_CRITICAL_SECTION_DEBUG_32
	LONG	LockCount;
	LONG	RecursionCount;
	DWORD	OwningThread;
	DWORD	LockSemaphore;
	DWORD	SpinCount;
} RTL_CRITICAL_SECTION_32, * PRTL_CRITICAL_SECTION_32;

typedef ALIGN_86 struct _RTL_CRITICAL_SECTION_DEBUG_32
{
	WORD			Type;
	WORD			CreatorBackTraceIndex;
	DWORD			CriticalSection; // -> RTL_CRITICAL_SECTION_32
	LIST_ENTRY32	ProcessLocksList;
	DWORD			EntryCount;
	DWORD			ContentionCount;
	DWORD			Flags;
	WORD			CreatorBackTraceIndexHigh;
	WORD			SpareWORD;
} RTL_CRITICAL_SECTION_DEBUG_32, * PRTL_CRITICAL_SECTION_DEBUG_32, _RTL_RESOURCE_DEBUG_32, RTL_RESOURCE_DEBUG_32, * PRTL_RESOURCE_DEBUG_32;

typedef ALIGN_86 struct _PEB_LDR_DATA_32
{
	ULONG			Length;
	BYTE			Initialized;
	DWORD			SsHandle;
	LIST_ENTRY32	InLoadOrderModuleListHead;
	LIST_ENTRY32	InMemoryOrderModuleListHead;
	LIST_ENTRY32	InInitializationOrderModuleListHead;
	DWORD			EntryInProgress;
	BYTE			ShutdownInProgress;
	DWORD			ShutdownThreadId;
} PEB_LDR_DATA_32, * PPEB_LDR_DATA_32;

typedef struct _PEB_32
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;

	union
	{
		UCHAR BitField;
		struct
		{
			UCHAR ImageUsedLargePages			: 1;
			UCHAR IsProtectedProcess			: 1;
			UCHAR IsImageDynamicallyRelocated	: 1;
			UCHAR SkipPatchingUser32Forwarders	: 1;
			UCHAR IsPackagedProcess				: 1;
			UCHAR IsAppContainer				: 1;
			UCHAR IsProtectedProcessLight		: 1;
			UCHAR IsLongPathAwareProcess		: 1;
		};
	};

	DWORD Mutant;

	DWORD ImageBaseAddress;
	DWORD Ldr; // -> PEB_LDR_DATA_32

	DWORD ProcessParameters;
	DWORD SubSystemData;
	DWORD ProcessHeap;
	DWORD FastPebLock; // -> RTL_CRITICAL_SECTION_32
	DWORD AtlThunkSListPtr;
	DWORD IFEOKey;

	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob					: 1;
			ULONG ProcessInitializing			: 1;
			ULONG ProcessUsingVEH				: 1;
			ULONG ProcessUsingVCH				: 1;
			ULONG ProcessUsingFTH				: 1;
			ULONG ProcessPreviouslyThrottled	: 1;
			ULONG ProcessCurrentlyThrottled		: 1;
			ULONG ProcessImagesHotPatched		: 1;
			ULONG ReservedBits0					: 24;
		};
	};

	union
	{
		DWORD KernelCallbackTable;
		DWORD UserSharedInfoPtr;
	};

	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	DWORD ApiSetMap;
	ULONG TlsExpansionCounter;

	DWORD TlsBitmap;
	ULONG TlsBitmapBits[2];
	DWORD ReadOnlySharedMemoryBase;

	union
	{
		DWORD HotpatchInformation;	// till Win8
		DWORD SparePvoid0;			// Win8.1 -> Win10 (1607)
		DWORD SharedData;			// Win10 (1703) +
	};

	DWORD ReadOnlyStaticServerData;
	DWORD AnsiCodePageData;
	DWORD OemCodePageData;
	DWORD UnicodeCaseTableData;
	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;
	LARGE_INTEGER CriticalSectionTimeout;
	DWORD HeapSegmentReserve;
	DWORD HeapSegmentCommit;
	DWORD HeapDeCommitTotalFreeThreshold;
	DWORD HeapDeCommitFreeBlockThreshold;
	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	DWORD ProcessHeaps;
	DWORD GdiSharedHandleTable;
	DWORD ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	DWORD LoaderLock; // -> RTL_CRITICAL_SECTION_32
	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
} PEB_32, * PPEB_32;

typedef ALIGN_86 struct _LDRP_UNICODE_STRING_BUNDLE_32
{
	UNICODE_STRING_32	String;
	WCHAR				StaticBuffer[128];
} LDRP_UNICODE_STRING_BUNDLE_32, * PLDRP_UNICODE_STRING_BUNDLE_32;

typedef ALIGN_86 struct _LDRP_PATH_SEARCH_CONTEXT_32 //dummy structure, needs to be at least 0x50 bytes in size, members don't matter
{
	DWORD DllSearchPathOut; // wchar_t *
	DWORD unknown_0[3];
	DWORD OriginalFullDllName; // wchar_t *
	DWORD unknown_1[15];
} LDRP_PATH_SEARCH_CONTEXT_32, * PLDRP_PATH_SEARCH_CONTEXT_32;

typedef ALIGN_86 struct _RTL_INVERTED_FUNCTION_TABLE_ENTRY_32
{
	DWORD ExceptionDirectory; // -> IMAGE_RUNTIME_FUNCTION_ENTRY
	DWORD ImageBase;
	ULONG ImageSize;
	ULONG ExceptionDirectorySize;
} RTL_INVERTED_FUNCTION_TABLE_ENTRY_32, * PRTL_INVERTED_FUNCTION_TABLE_ENTRY_32;

typedef ALIGN_86 struct _RTL_INVERTED_FUNCTION_TABLE_32
{
	ULONG Count;
	ULONG MaxCount;
	ULONG Epoch;
	UCHAR Overflow;
	RTL_INVERTED_FUNCTION_TABLE_ENTRY_32 Entries[ANYSIZE_ARRAY];
} RTL_INVERTED_FUNCTION_TABLE_32, * PRTL_INVERTED_FUNCTION_TABLE_32;

typedef ALIGN_86 union _LDRP_PATH_SEARCH_OPTIONS_32
{
	ULONG32 Flags;

	struct
	{
		ULONG32 Unknown;
	};
} LDRP_PATH_SEARCH_OPTIONS_32, * PLDRP_PATH_SEARCH_OPTIONS_32;

typedef ALIGN_86 union _LDRP_LOAD_CONTEXT_FLAGS_32
{
	ULONG32 Flags;
	struct
	{
		ULONG32 Redirected					: 1;
		ULONG32 BaseNameOnly				: 1;
		ULONG32 HasFullPath					: 1;
		ULONG32 KnownDll					: 1;
		ULONG32 SystemImage					: 1;
		ULONG32 ExecutableImage				: 1;
		ULONG32 AppContainerImage			: 1;
		ULONG32 CallInit					: 1;
		ULONG32 UserAllocated				: 1;
		ULONG32 SearchOnlyFirstPathSegment	: 1;
		ULONG32 RedirectedByAPISet			: 1;
	};
} LDRP_LOAD_CONTEXT_FLAGS_32, * PLDRP_LOAD_CONTEXT_FLAGS_32;

typedef struct _RTL_VECTORED_HANDLER_LIST_32
{
	DWORD			Lock;
	LIST_ENTRY32	List;
} RTL_VECTORED_HANDLER_LIST_32, * PRTL_VECTORED_HANDLER_LIST_32;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_32 //Win7 till Win10 1909
{
	LIST_ENTRY32	List;
	DWORD			Flag;
	DWORD			VectoredHandler;
} RTL_VECTORED_EXCEPTION_ENTRY_32, * PRTL_VECTORED_EXCEPTION_ENTRY_32;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32 //Win10 2004+
{
	LIST_ENTRY32	List;
	DWORD			pFlag; //DWORD *
	ULONG			RefCount;
	DWORD			VectoredHandler; //PVECTORED_EXCEPTION_HANDLER
	DWORD			Flag;
} RTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32, * PRTL_VECTORED_EXCEPTION_ENTRY_WIN10_2004_32;

#endif
```

`GH Injector Library/NT Funcs.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

//I honestly can't give proper credit here as most of the stuff is stolen from somewhere ages ago
//Sources I definitely stole from:
//https://www.geoffchappell.com
//https://github.com/DarthTon
//https://github.com/reactos
//Bill Gates

#include "Win7.h"
#include "Win8.h"
#include "Win81.h"
#include "Win10.h"
#include "Win11.h"

#define DEF_STRUCT_DEFAULT(name, suffix)	\
using name		= name##suffix;				\
using P##name	= P##name##suffix;			\
using _##name	= _##name##suffix;

#define DEF_STRUCT_DEFAULT_32(name, suffix)	\
using name##_32		= name##suffix##_32;	\
using P##name##_32	= P##name##suffix##_32;	\
using _##name##_32	= _##name##suffix##_32;

#ifndef _WIN32_WINNT
	#error Not supported
#else
	#if(_WIN32_WINNT == _WIN32_WINNT_WIN7)
		DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN7)
		DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN7)

		#ifdef _WIN64
			DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN7)
			DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN7)
		#endif
	#elif (_WIN32_WINNT == _WIN32_WINNT_WIN8)
		DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN8)
		DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN8)

		#ifdef _WIN64
			DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN8)
			DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN8)
		#endif
	#elif (_WIN32_WINNT == _WIN32_WINNT_WINBLUE)
		DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN81)
		DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN81)

		#ifdef _WIN64
			DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN81)
			DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN81)
		#endif
	#elif (_WIN32_WINNT == _WIN32_WINNT_WIN10) //includes Win11
		#if (WDK_NTDDI_VERSION >= NTDDI_WIN10_CO) //Win11 SDK is called NTDDI_WIN10_CO
			DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN11)
			DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN11)

			#ifdef _WIN64
				DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN11)
				DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN11)
			#endif
		#else
			DEF_STRUCT_DEFAULT(LDR_DATA_TABLE_ENTRY, _WIN10)
			DEF_STRUCT_DEFAULT(LDR_DDAG_NODE, _WIN10)

			#ifdef _WIN64
				DEF_STRUCT_DEFAULT_32(LDR_DATA_TABLE_ENTRY, _WIN10)
				DEF_STRUCT_DEFAULT_32(LDR_DDAG_NODE, _WIN10)
			#endif
		#endif
	#else
		#error Not supported
	#endif
#endif

#pragma region function prototypes

using f_NtCreateThreadEx = NTSTATUS (__stdcall *)	
(
	HANDLE		*	pHandle, 
	ACCESS_MASK		DesiredAccess, 
	void		*	pAttr, 
	HANDLE			hTargetProc, 
	void		*	pFunc, 
	void		*	pArg,
	ULONG			Flags, 
	SIZE_T			ZeroBits, 
	SIZE_T			StackSize, 
	SIZE_T			MaxStackSize, 
	void		*	pAttrListOut
);

using f_LdrLoadDll = NTSTATUS (__stdcall *)
(
	LDR_SEARCH_PATH		ldrSearchPath,
	ULONG			*	pFlags,
	UNICODE_STRING	*	pModuleFileName,
	HANDLE			*	pOut
);

using f_LdrLoadDll_WIN8 = NTSTATUS (__stdcall *)
(
	BOOLEAN				Unknown1, //set to TRUE
	ULONG			*	LoadFlags,
	UNICODE_STRING	*	pModuleFileName,
	HANDLE			*	pOut
);

using f_LdrUnloadDll = NTSTATUS (__stdcall *)
(
	HANDLE DllHandle
);

using f_LdrpLoadDll_WIN7 = NTSTATUS (__stdcall *)
(
	UNICODE_STRING				*	dll_path,
	UNICODE_STRING				*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	BOOLEAN							Unknown1, //set to TRUE
	PVOID							Unknown2, //can be nullptr
	LDR_DATA_TABLE_ENTRY_WIN7	**	ldr_out
);

using f_LdrpLoadDll_WIN8 = NTSTATUS (__stdcall *)
(
	UNICODE_STRING					*	dll_path,
	LDRP_PATH_SEARCH_CONTEXT_WIN8	*	search_ctx,
	LDRP_LOAD_CONTEXT_FLAGS				Flags,
	BOOLEAN								Unknown, //set to TRUE
	LDR_DATA_TABLE_ENTRY_WIN8		**	entry_out,
	LDR_DDAG_NODE_WIN8				**	ddag_out
);

using f_LdrpLoadDll_WIN81 = NTSTATUS (__fastcall *)
(
	UNICODE_STRING					*	dll_path,
	LDRP_PATH_SEARCH_CONTEXT_WIN81	*	search_ctx,
	LDRP_LOAD_CONTEXT_FLAGS				Flags,
	BOOLEAN								Unknown, //set to TRUE
	LDR_DATA_TABLE_ENTRY_WIN81		**	entry_out,
	LDR_DDAG_NODE_WIN81				**	ddag_out
);

//1507-1803
using f_LdrpLoadDll_1507 = NTSTATUS (__fastcall *)
(
	UNICODE_STRING				*	dll_path,
	LDRP_PATH_SEARCH_CONTEXT	*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	BOOLEAN							bUnknown, //set to TRUE
	LDR_DATA_TABLE_ENTRY_WIN10	**	ldr_out
);

//1809+
using f_LdrpLoadDll = NTSTATUS (__fastcall *)
(
	UNICODE_STRING				*	dll_path, 
	LDRP_PATH_SEARCH_CONTEXT	*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	LDR_DATA_TABLE_ENTRY		**	ldr_out
);

using f_LdrpLoadDllInternal = VOID (__fastcall *)
(
	UNICODE_STRING				*	dll_path, 
	LDRP_PATH_SEARCH_CONTEXT	*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	ULONG32							Unknown0,	//set to 4
	LDR_DATA_TABLE_ENTRY_WIN10	*	Unknown1,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN10	*	Unknown2,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN10	**	ldr_out,
	NTSTATUS					*	ntRet
);

using f_LdrpLoadDllInternal_WIN11 = VOID (__fastcall *)
(
	UNICODE_STRING				*	dll_path, 
	LDRP_PATH_SEARCH_CONTEXT	*	search_path,
	LDRP_LOAD_CONTEXT_FLAGS			Flags,
	ULONG32							Unknown0,	//set to 4
	LDR_DATA_TABLE_ENTRY_WIN11	*	Unknown1,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN11	*	Unknown2,	//set to nullptr
	LDR_DATA_TABLE_ENTRY_WIN11	**	ldr_out,
	NTSTATUS					*	ntRet,
	ULONG							Unknown4	//set to 0
);

using f_LdrGetDllHandleEx = NTSTATUS (__stdcall *)
(
	ULONG				Flags,
	PWSTR				OptDllPath,
	PULONG				OptDllCharacteristics,
	UNICODE_STRING	*	DllName,
	PVOID			*	DllHandle
);

using f_LdrGetProcedureAddress = NTSTATUS (__stdcall *)
(
	PVOID				BaseAddress,
	ANSI_STRING		*	Name,
	ULONG				Ordinal,
	PVOID			*	ProcedureAddress
);

using f_NtQueryInformationProcess = NTSTATUS (__stdcall *)
(
	HANDLE					hTargetProc, 
	PROCESSINFOCLASS		PIC, 
	void				*	pBuffer, 
	ULONG					BufferSize, 
	ULONG				*	SizeOut
);

using f_NtQuerySystemInformation = NTSTATUS	(__stdcall *)
(
	SYSTEM_INFORMATION_CLASS		SIC, 
	void						*	pBuffer, 
	ULONG							BufferSize, 
	ULONG						*	SizeOut
);

using f_NtQueryInformationThread = NTSTATUS (__stdcall *)
(
	HANDLE				hThread, 
	THREADINFOCLASS		TIC, 
	void			*	pBuffer, 
	ULONG				BufferSize, 
	ULONG			*	SizeOut
);

using f_RtlQueueApcWow64Thread = NTSTATUS (__stdcall *)
(
	HANDLE		hThread, 
	void	*	pRoutine, 
	void	*	pArg1, 
	void	*	pArg2, 
	void	*	pArg3
);

using f_LdrGetDllPath = NTSTATUS (__stdcall *)
(
	const wchar_t	*	DllName,
	ULONG				Flags,
	wchar_t			**	PathOut,
	wchar_t			**	Unknown
);

using f_LdrpPreprocessDllName = NTSTATUS (__fastcall *)
(
	UNICODE_STRING				* DllName,
	LDRP_UNICODE_STRING_BUNDLE	* OutputDllName,
	LDR_DATA_TABLE_ENTRY		* pOptParentEntry,
	LDRP_LOAD_CONTEXT_FLAGS		* LoadContextFlags
);

using f_RtlInsertInvertedFunctionTable_WIN7 = NTSTATUS (__stdcall *)
(
	RTL_INVERTED_FUNCTION_TABLE_WIN7 *	pTable,
	void *								ImageBase,
	DWORD								SizeOfImage
);

using f_RtlInsertInvertedFunctionTable_WIN8 = NTSTATUS (__stdcall *)
(
	void *	ImageBase,
	DWORD	SizeOfImage
);

using f_RtlInsertInvertedFunctionTable = BOOL (__fastcall *)
(
	void *	ImageBase,
	DWORD	SizeOfImage
);

#ifdef _WIN64
using f_RtlAddFunctionTable = BOOL (__stdcall *)
(
	RUNTIME_FUNCTION *	FunctionTable,
	DWORD				EntryCount,
	DWORD64				BaseAddress
);
#endif

using f_LdrpHandleTlsData_WIN8 = NTSTATUS (__stdcall *)
(
	LDR_DATA_TABLE_ENTRY_WIN8 * pEntry
);

using f_LdrpHandleTlsData = NTSTATUS (__fastcall *)
(
	LDR_DATA_TABLE_ENTRY * pEntry
);

using f_LdrLockLoaderLock = NTSTATUS (__stdcall *)
(
	ULONG			Flags, 
	ULONG		*	State, 
	ULONG_PTR	*	Cookie
);

using f_LdrUnlockLoaderLock = NTSTATUS (__stdcall *)
(
	ULONG		Flags, 
	ULONG_PTR	Cookie
);

using f_LdrpDereferenceModule = NTSTATUS(__fastcall *)
(
	LDR_DATA_TABLE_ENTRY * pEntry
);

using f_memmove = VOID (__cdecl *)
(
	PVOID	UNALIGNED	Destination,
	LPCVOID	UNALIGNED	Source,
	SIZE_T				Length
);

using f_RtlZeroMemory = VOID (__stdcall *)
(
	PVOID	UNALIGNED	Destination,
	SIZE_T				Length
);

using f_RtlAllocateHeap = PVOID (__stdcall *)
(
	PVOID	HeapHandle,
	ULONG	Flags,
	SIZE_T	Size
);

using f_RtlFreeHeap = BOOLEAN (__stdcall *)
(
	PVOID	HeapHandle,
	ULONG	Flags,
	PVOID	BaseAddress
);

using f_RtlAnsiStringToUnicodeString = NTSTATUS (__stdcall *)
(
	UNICODE_STRING		*	DestinationString,
	const ANSI_STRING	*	SourceString,
	BOOLEAN					AllocateDestinationString
);

using f_RtlUnicodeStringToAnsiString = NTSTATUS (__stdcall *)
(
	ANSI_STRING				*	DestinationString,
	const UNICODE_STRING	*	SourceString,
	BOOLEAN						AllocateDestinationString
);

using f_RtlCompareString = LONG (__stdcall *)
(
	const ANSI_STRING * String1,
	const ANSI_STRING * String2,
	BOOLEAN				CaseInSensitive
);

using f_RtlCompareUnicodeString = LONG (__stdcall *)
(
	const UNICODE_STRING *	String1,
	const UNICODE_STRING *	String2,
	BOOLEAN					CaseInSensitive
);

using f_RtlRbInsertNodeEx = VOID (__stdcall *)
(
	RTL_RB_TREE			*	Tree,
	RTL_BALANCED_NODE	*	Parent,
	BOOLEAN					Right,
	RTL_BALANCED_NODE	*	Node
);

using f_RtlRbRemoveNode = VOID (__stdcall *)
(
	RTL_RB_TREE			* pTree,
	RTL_BALANCED_NODE	* pNode
);

using f_NtOpenFile = NTSTATUS (__stdcall *)
(
	HANDLE				*	hFileOut,
	ACCESS_MASK				DesiredAccess,
	OBJECT_ATTRIBUTES	*	pAtrributes,
	IO_STATUS_BLOCK		*	pIoStatusBlock,
	ULONG					ShareAccess,
	ULONG					OpenOptions
);

using f_NtReadFile = NTSTATUS (__stdcall *)
(
	HANDLE					FileHandle,
	HANDLE					hOptEvent,
	PVOID					pOptApc,
	PVOID					pOptApcContext,
	IO_STATUS_BLOCK		*	IoStatusBlock,
	PVOID					Buffer,
	ULONG					Length,
	LARGE_INTEGER		*	pOptByteOffset,
	ULONG				*	pOptKey
);

using f_NtSetInformationFile = NTSTATUS (__stdcall *)
(
	HANDLE						FileHandle,
	IO_STATUS_BLOCK			*	IoStatusBlock,
	PVOID						FileInformation,
	ULONG						Length,
	FILE_INFORMATION_CLASS		FileInformationClass
);

using f_NtQueryInformationFile = NTSTATUS (__stdcall *)
(
	HANDLE						FileHandle,
	IO_STATUS_BLOCK			*	pIoStatusBlock,
	PVOID						FileInformation,
	ULONG						Length,
	FILE_INFORMATION_CLASS		FileInformationClass
);

using f_NtClose = NTSTATUS (__stdcall *)
(
	HANDLE Handle
);

using f_NtAllocateVirtualMemory = NTSTATUS (__stdcall *)
(
	HANDLE			ProcessHandle,
	PVOID		*	BaseAddress,
	ULONG_PTR		ZeroBits,
	SIZE_T		*	RegionSize,
	ULONG			AllocationType,
	ULONG			Protect
);

using f_NtFreeVirtualMemory = NTSTATUS (__stdcall *)
(
	HANDLE		ProcessHandle,
	PVOID	*	BaseAddress,
	SIZE_T	*	RegionSize,
	ULONG		FreeType
);

using f_NtProtectVirtualMemory = NTSTATUS (__stdcall *)
(
	HANDLE		ProcessHandle,
	PVOID	*	BaseAddress,
	SIZE_T	*	Size,
	ULONG		NewAccess,
	ULONG	*	OldAccess
);

using f_NtCreateSection = NTSTATUS (__stdcall *)
(
	HANDLE				*	SectionHandle,
	ACCESS_MASK				DesiredAccess,
	OBJECT_ATTRIBUTES	*	ObjectAttributes,
	LARGE_INTEGER		*	MaximumSize,
	ULONG					SectionPageProtection,
	ULONG					AllocationAttributes,
	HANDLE					FileHandle
);

using f_NtMapViewOfSection = NTSTATUS (__stdcall *)
(
	HANDLE				SectionHandle,
	HANDLE				ProcessHandle,
	PVOID			*	BaseAddress,
	ULONG_PTR			ZeroBits,
	SIZE_T				CommitSize,
	LARGE_INTEGER	*	SectionOffset,
	SIZE_T			*	ViewSize,
	SECTION_INHERIT		InheritDisposition,
	ULONG				AllocationType,
	ULONG				Win32Protect
);

using f_LdrProtectMrdata = VOID (__stdcall *)
(
	BOOL bProtected
);

using f_RtlAddVectoredExceptionHandler = PVOID (__stdcall *)
(
	ULONG						FirstHandler,
	PVECTORED_EXCEPTION_HANDLER VectoredHandler
);

using f_RtlRemoveVectoredExceptionHandler = ULONG (__stdcall *)
(
	PVOID Handle
);

using f_NtDelayExecution = NTSTATUS (__stdcall *)
(
	BOOLEAN			Alertable,
	LARGE_INTEGER * DelayInterval
);

using f_LdrpModuleBaseAddressIndex	= RTL_RB_TREE *;
using f_LdrpMappingInfoIndex		= RTL_RB_TREE *;
using f_LdrpHeap					= PVOID *;
using f_LdrpInvertedFunctionTable	= RTL_INVERTED_FUNCTION_TABLE *;
using f_LdrpDefaultPath				= UNICODE_STRING *;
using f_LdrpVectorHandlerList		= RTL_VECTORED_HANDLER_LIST *;
using f_LdrpTlsList					= LIST_ENTRY *;

//ntdll.dll:
using f_RtlpUnhandledExceptionFilter	= ULONG_PTR *; //encrypted with RtlEncodePointer, points to kernel32.UnhandledExceptionFilter

//kernel32.dll:
using f_UnhandledExceptionFilter		= ULONG_PTR *; //PTOP_LEVEL_EXCEPTION_FILTER
using f_SingleHandler					= ULONG_PTR *; //encrypted with RtlEncodePointer, points to kernel32.DefaultHandler
using f_DefaultHandler					= ULONG_PTR *; //PTOP_LEVEL_EXCEPTION_FILTER

#pragma endregion

inline HINSTANCE g_hNTDLL;
inline HINSTANCE g_hKERNEL32;

#ifdef  _WIN64
inline HINSTANCE g_hNTDLL_WOW64;
inline HINSTANCE g_hKERNEL32_WOW64;
#endif
```

`GH Injector Library/NtCreateThreadEx WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Start Routine.h"

DWORD SR_NtCreateThreadEx_WOW64(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, DWORD Flags, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_NtCreateThreadEx_WOW64\n");

	ProcessInfo pi;
	void * pEntrypoint	= nullptr;
	DWORD FakeTID		= 0;

	if (Flags & (INJ_CTF_FAKE_START_ADDRESS | INJ_CTF_FAKE_TEB_CLIENT_ID))
	{
		LOG(2, "Thread cloaking specified\n");

		if (!pi.SetProcess(hTargetProc))
		{
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(2, "Can't initialize ProcessInfo class\n");

			return SR_NTCTE_ERR_PROC_INFO_FAIL;
		}

		pEntrypoint = pi.GetEntrypoint_WOW64();
		if (pEntrypoint == nullptr)
		{
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(2, "Failed to resolve entrypoint\n");

			return SR_NTCTE_ERR_GET_ENTRYPOINT;
		}

		FakeTID = pi.GetThreadId();
	}

	DWORD ntFlags	= NULL;
	HANDLE hThread	= nullptr;

	bool FakeStartAddress	= false;
	bool FakeClientId		= false;

	if (Flags & INJ_CTF_FAKE_START_ADDRESS)
	{
		FakeStartAddress = true;
		ntFlags |= THREAD_CREATE_FLAGS_CREATE_SUSPENDED;
	}

	if (Flags & INJ_CTF_HIDE_FROM_DEBUGGER)
	{
		ntFlags |= THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER;
	}

	if (Flags & INJ_CTF_SKIP_THREAD_ATTACH)
	{
		ntFlags |= THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH;
	}

	if (Flags & INJ_CTF_FAKE_TEB_CLIENT_ID)
	{
		FakeClientId = true;
	}

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, 0x200, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return SR_NTCTE_ERR_CANT_ALLOC_MEM;
	}

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER_86

		0x55,										// + 0x00	-> push	ebp							; x86 stack frame creation
		0x89, 0xE5,									// + 0x01	-> mov	ebp, esp

		0x53,										// + 0x03	-> push	ebx							; push ebx on stack (non volatile)
		0x8B, 0x5D, 0x08,							// + 0x04	-> mov	ebx, [ebp + 0x08]			; store pData in ebx
		0x85, 0xDB,									// + 0x07	-> test	ebx, ebx					; check if pData is valid
		0x74, 0x42,									// + 0x09	-> je	0x4D						; jmp to ret if not and set eax to -1

		0xC6, 0x03, 0x01,							// + 0x0B	-> mov	byte ptr [ebx], 1			; set SR_REMOTE_DATA::State to SR_RS_Executing

		0x83, 0x7B, 0x14, 0x00,						// + 0x0E	-> cmp  dword ptr [ebx + 0x14], 0	; check if SR_REMOTE_DATA::Buffer is 0 (fake TID)
		0x74, 0x0D,									// + 0x12	-> je   0x21						; skip if no fake TID has been provided
		0x8B, 0x53, 0x14,							// + 0x14	-> mov  edx, [ebx + 0x14]			; load fake thread ID
		0x64, 0x87, 0x15, 0x24, 0x00, 0x00, 0x00,	// + 0x17	-> xchg fs:[0x24], edx				; set fake thread ID and grab real thread ID
		0x89, 0x53, 0x14,							// + 0x1E	-> mov  [ebx + 0x14], edx			; set SR_REMOTE_DATA::Buffer to the real thread ID

		0xFF, 0x73, 0x0C,							// + 0x21	-> push	[ebx + 0x0C]				; push pArg
		0xFF, 0x53, 0x10,							// + 0x24	-> call	dword ptr [ebx + 0x10]		; call pRoutine
		0x89, 0x43, 0x04,							// + 0x27	-> mov	[ebx + 0x04], eax			; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,			// + 0x2D	-> mov	eax, fs:[0x18]				; GetLastError
		0x8B, 0x40, 0x34,							// + 0x30	-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,							// + 0x33	-> mov	[ebx + 0x08], eax			; store in SR_REMOTE_DATA::LastWin32Error

		0x83, 0x7B, 0x14, 0x00,						// + 0x36	-> cmp  dword ptr [ebx + 0x14], 0	; check if SR_REMOTE_DATA::Buffer is 0 (real TID)
		0x74, 0x0A,									// + 0x3A	-> je   0x46						; skip if no TID was saved
		0x8B, 0x53, 0x14,							// + 0x3C	-> mov  edx, [ebx + 0x14]			; load real thread ID
		0x64, 0x89, 0x15, 0x24, 0x00, 0x00, 0x00,	// + 0x3F	-> mov  fs:[0x24], edx				; move real thread ID back into TEB

		0xC6, 0x03, 0x02,							// + 0x46	-> mov	byte ptr [ebx], 2			; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished
		0x31, 0xC0,									// + 0x49	-> xor	eax, eax					; zero eax (thread exitcode = 0)
		0xEB, 0x03,									// + 0x4B	-> jmp	0x50						; jump to ret

		0x83, 0xC8, 0xFF,							// + 0x4D	-> or	eax, -1						; set eax to -1 (thread exitcode = -1)

		0x5B,										// + 0x50	-> pop	ebx							; restore ebx

		0x5D,										// + 0x51	-> pop	ebp							; x86 __stdcall epilogue
		0xC2, 0x04, 0x00							// + 0x52	-> ret	0x04
	}; // SIZE = 0x55 (+ sizeof(SR_REMOTE_DATA_WOW64))

	void * pRemoteFunc = ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA_WOW64);

	auto * sr_data = ReCa<SR_REMOTE_DATA_WOW64 *>(Shellcode);
	sr_data->pArg		= MDWD(pArg);
	sr_data->pRoutine	= MDWD(pRoutine);
	sr_data->Buffer		= FakeTID;

	LOG(2, "Codecave allocated at %p\n", pMem);

	BOOL bRet = WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr);
	if (!bRet)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_NTCTE_ERR_WPM_FAIL;
	}

	LOG(2, "Creating thread with:\n");
	LOG(3, "pRoutine = %08X\n", MDWD(pRemoteFunc));
	LOG(3, "pArg     = %08X\n", MDWD(pMem));

	NTSTATUS ntRet = NATIVE::NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, nullptr, hTargetProc, FakeStartAddress ? pEntrypoint : pRemoteFunc, pMem, ntFlags, 0, 0, 0, nullptr);
	if (NT_FAIL(ntRet) || !hThread)
	{
		INIT_ERROR_DATA(error_data, (DWORD)ntRet);

		LOG(2, "NtCreateThreadEx failed: %08X\n", (DWORD)ntRet);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_NTCTE_ERR_NTCTE_FAIL;
	}

	auto TID = GetThreadId(hThread);

	LOG(2, "Thread created with TID = %06X (%06d)\n", TID, TID);

	if (FakeStartAddress)
	{
		WOW64_CONTEXT ctx{ 0 };
		ctx.ContextFlags = WOW64_CONTEXT_ALL;

		if (!Wow64GetThreadContext(hThread, &ctx))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "Wow64GetThreadContext failed: %08X\n", error_data.AdvErrorCode);

			TerminateThread(hThread, 0);
			CloseHandle(hThread);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_NTCTE_ERR_GET_CONTEXT_FAIL;
		}

		LOG(2, "Loaded thread context\n");

		ctx.Eax = MDWD(pRemoteFunc);

		if (!Wow64SetThreadContext(hThread, &ctx))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "Wow64SetThreadContext failed: %08X\n", error_data.AdvErrorCode);

			TerminateThread(hThread, 0);
			CloseHandle(hThread);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_NTCTE_ERR_SET_CONTEXT_FAIL;
		}

		LOG(2, "Thread redirected\n");		

		if (ResumeThread(hThread) == (DWORD)-1)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "ResumeThread failed: %08X\n", error_data.AdvErrorCode);

			TerminateThread(hThread, 0);
			CloseHandle(hThread);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_NTCTE_ERR_RESUME_FAIL;
		}

		LOG(2, "Thread resumed\n");
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	DWORD dwExitCode = 0;

	SR_REMOTE_DATA_WOW64 data{ };
	data.State			= (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	HANDLE handles[] = { hThread, g_hInterruptedEvent };

	DWORD dwWaitRet = WaitForMultipleObjects(2, handles, FALSE, Timeout);
	if (dwWaitRet != WAIT_OBJECT_0)
	{
		if (dwWaitRet == (WAIT_OBJECT_0 + 1))
		{
			INIT_ERROR_DATA(error_data, dwWaitRet);

			LOG(2, "Interrupt!\n");
		}
		else
		{
			if (dwWaitRet == WAIT_FAILED)
			{
				INIT_ERROR_DATA(error_data, GetLastError());
			}
			else
			{
				INIT_ERROR_DATA(error_data, dwWaitRet);
			}

			LOG(2, "WaitForSingleObject failed: %08X\n", error_data.AdvErrorCode);
		}

		TerminateThread(hThread, 0);
		CloseHandle(hThread);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		if (dwWaitRet == (WAIT_OBJECT_0 + 1))
		{
			SetEvent(g_hInterruptedEvent);

			return SR_ERR_INTERRUPT;
		}

		return SR_NTCTE_ERR_REMOTE_TIMEOUT;
	}

	LOG(2, "Thread finished execution\n");

	if (!GetExitCodeThread(hThread, &dwExitCode))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "GetExitCodeThread failed: %08X\n", error_data.AdvErrorCode);

		CloseHandle(hThread);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_NTCTE_ERR_GECT_FAIL;
	}

	bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);

	DWORD dwErr = GetLastError();

	CloseHandle(hThread);

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	if (bRet)
	{
		LOG(2, "Thread exit data retrieved\n");

		if (data.State != (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished)
		{
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(2, "Shell timed out\n");

			return SR_NTCTE_ERR_REMOTE_TIMEOUT;
		}
	}

	if (dwExitCode == 0xFFFFFFFF)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shellcode creation failed\n");

		return SR_NTCTE_ERR_SHELLCODE_SETUP_FAIL;
	}
	else if (!bRet)
	{
		INIT_ERROR_DATA(error_data, dwErr);

		LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		return SR_NTCTE_ERR_RPM_FAIL;
	}

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out = data.Ret;

	return SR_ERR_SUCCESS;
}

#endif
```

`GH Injector Library/NtCreateThreadEx.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Start Routine.h"

DWORD SR_NtCreateThreadEx(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, DWORD Flags, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_NtCreateThreadEx\n");

	ProcessInfo pi;
	void * pEntrypoint	= nullptr;
	DWORD FakeTID		= 0;

	if (Flags & (INJ_CTF_FAKE_START_ADDRESS | INJ_CTF_FAKE_TEB_CLIENT_ID))
	{
		LOG(2, "Thread cloaking specified\n");

		if (!pi.SetProcess(hTargetProc))
		{
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(2, "Can't initialize ProcessInfo class\n");

			return SR_NTCTE_ERR_PROC_INFO_FAIL;
		}

		pEntrypoint = pi.GetEntrypoint();
		if (pEntrypoint == nullptr)
		{
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(2, "Failed to resolve entrypoint\n");

			return SR_NTCTE_ERR_GET_ENTRYPOINT;
		}

		FakeTID = pi.GetThreadId();
	}

	DWORD ntFlags	= NULL;
	HANDLE hThread	= nullptr;

	bool FakeStartAddress	= false;
	bool FakeClientId		= false;

	if (Flags & INJ_CTF_FAKE_START_ADDRESS)
	{
		FakeStartAddress = true;
		ntFlags |= THREAD_CREATE_FLAGS_CREATE_SUSPENDED;
	}

	if (Flags & INJ_CTF_HIDE_FROM_DEBUGGER)
	{
		ntFlags |= THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER;
	}

	if (Flags & INJ_CTF_SKIP_THREAD_ATTACH)
	{
		ntFlags |= THREAD_CREATE_FLAGS_CREATE_SUSPENDED;
		//ntFlags |= THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH;
	}

	if (Flags & INJ_CTF_FAKE_TEB_CLIENT_ID)
	{
		FakeClientId = true;
	}

	/*
		DWORD __stdcall Thread_Shell(void * lpThreadParameter)
		{
			SR_REMOTE_DATA * data = ReCa<SR_REMOTE_DATA *>(lpThreadParameter);

			if (data != nullptr)
			{
				if (data->Buffer)
				{
					#ifdef _WIN64
						TEB * teb = (TEB *)__readfsdword(0x18);
					#else
						TEB * teb = (TEB *)__readgsgword(0x30);
					#endif

					auto buffer = teb->ClientID.UniqueThreadID;
					teb->ClientId.UniqueThread = (void *)data->Buffer;
					data->Buffer = (UINT_PTR)buffer;
				}

				data->State = SR_REMOTE_STATE::SR_RS_Executing;

				data->Ret = data->pRoutine(data->pArg);
				data->LastWin32Error = GetLastError();

				data->State = SR_REMOTE_STATE::SR_RS_ExecutionFinished;

				if (data->Buffer)
				{
					#ifdef _WIN64
						TEB * teb = (TEB *)__readfsdword(0x18);
					#else
						TEB * teb = (TEB *)__readgsgword(0x30);
					#endif

					teb->ClientID.UniqueThread = (void *)data->Buffer;
				}
			}
			else
			{
				return (DWORD)-1;
			}

			return ERROR_SUCCESS;
		}
	*/

#ifdef _WIN64

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x48, 0x85, 0xC9,										// + 0x00	-> test	rcx, rcx					; check if pData is valid
		0x74, 0x5B,												// + 0x03	-> je	0x60						; jmp to ret if not and set eax to -1

		0x53,													// + 0x05	-> push rbx							; push rbx on stack (non volatile)
		0x48, 0x8B, 0xD9,										// + 0x06	-> mov	rbx, rcx					; store pArg in rbx
		0xC6, 0x03, 0x01,										// + 0x09	-> mov	byte ptr [rbx], 1			; set SR_REMOTE_DATA::State to SR_RS_Executing

		0x83, 0x7B, 0x28, 0x00,									// + 0x0C	-> cmp  dword ptr [rbx + 0x28], 0	; check if SR_REMOTE_DATA::Buffer is 0 (fake TID)
		0x74, 0x11,												// + 0x10	-> je   0x23						; skip if no fake TID has been provided
		0x48, 0x8B, 0x53, 0x28,									// + 0x12	-> mov  rdx, [rbx + 0x28]			; load fake thread ID
		0x65, 0x48, 0x87, 0x14, 0x25, 0x48, 0x00, 0x00, 0x00,	// + 0x16	-> xchg gs:[0x48], rdx				; set fake thread ID and grab real thread ID
		0x48, 0x89, 0x53, 0x28,									// + 0x1F	-> mov  [rbx + 0x28], rdx			; set SR_REMOTE_DATA::Buffer to the real thread ID

		0x48, 0x8B, 0x4B, 0x18,									// + 0x23	-> mov  rcx, [rbx + 0x18]			; move pArg into rcx
		0x48, 0x83, 0xEC, 0x20,									// + 0x27	-> sub	rsp, 0x20					; reserve stack
		0xFF, 0x53, 0x20,										// + 0x2B	-> call qword ptr [rbx + 0x20]		; call pRoutine
		0x48, 0x83, 0xC4, 0x20,									// + 0x2E	-> add	rsp, 0x20					; update stack
		0x48, 0x89, 0x43, 0x08,									// + 0x32	-> mov	[rbx + 0x08], rax			; store returned value

		0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00,	// + 0x36	-> mov	rax, gs:[0x30]				; GetLastError
		0x8B, 0x40, 0x68,										// + 0x3F	-> mov	eax, [rax + 0x68]
		0x89, 0x43, 0x10,										// + 0x42	-> mov	[rbx + 0x10], eax			; store in SR_REMOTE_DATA::LastWin32Error

		0x83, 0x7B, 0x28, 0x00,									// + 0x45	-> cmp  dword ptr [rbx + 0x28], 0	; check if SR_REMOTE_DATA::Buffer is 0 (real TID)
		0x74, 0x0D,												// + 0x49	-> je   0x58						; skip if no TID was saved
		0x48, 0x8B, 0x53, 0x28,									// + 0x4B	-> mov  rdx, [rbx + 0x28]			; load real thread ID
		0x65, 0x48, 0x89, 0x14, 0x25, 0x48, 0x00, 0x00, 0x00,	// + 0x4F	-> mov  gs:[0x48], rdx				; move real thread ID back into TEB

		0xC6, 0x03, 0x02,										// + 0x58	-> mov	byte ptr [rbx], 2			; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished
		0x5B,													// + 0x5B	-> pop	rbx							; restore rbx

		0x31, 0xC0,												// + 0x5C	-> xor	rax, rax					; zero eax (thread exitcode = 0)
		0xEB, 0x03,												// + 0x5E	-> jmp	0x63						; jmp to ret

		0x83, 0xC8, 0xFF,										// + 0x60	-> or rax, -1						; set eax to -1 (thread exitcode = -1)

		0xC3													// + 0x63	-> ret								; return
	}; // SIZE = 0x64 (+ sizeof(SR_REMOTE_DATA))

#else

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x55,										// + 0x00	-> push	ebp							; x86 stack frame creation
		0x89, 0xE5,									// + 0x01	-> mov	ebp, esp

		0x53,										// + 0x03	-> push	ebx							; push ebx on stack (non volatile)
		0x8B, 0x5D, 0x08,							// + 0x04	-> mov	ebx, [ebp + 0x08]			; store pData in ebx
		0x85, 0xDB,									// + 0x07	-> test	ebx, ebx					; check if pData is valid
		0x74, 0x42,									// + 0x09	-> je	0x4D						; jmp to ret if not and set eax to -1

		0xC6, 0x03, 0x01,							// + 0x0B	-> mov	byte ptr [ebx], 1			; set SR_REMOTE_DATA::State to SR_RS_Executing
		
		0x83, 0x7B, 0x14, 0x00,						// + 0x0E	-> cmp  dword ptr [ebx + 0x14], 0	; check if SR_REMOTE_DATA::Buffer is 0 (fake TID)
		0x74, 0x0D,									// + 0x12	-> je   0x21						; skip if no fake TID has been provided
		0x8B, 0x53, 0x14,							// + 0x14	-> mov  edx, [ebx + 0x14]			; load fake thread ID
		0x64, 0x87, 0x15, 0x24, 0x00, 0x00, 0x00,	// + 0x17	-> xchg fs:[0x24], edx				; set fake thread ID and grab real thread ID
		0x89, 0x53, 0x14,							// + 0x1E	-> mov  [ebx + 0x14], edx			; set SR_REMOTE_DATA::Buffer to the real thread ID

		0xFF, 0x73, 0x0C,							// + 0x21	-> push	[ebx + 0x0C]				; push pArg
		0xFF, 0x53, 0x10,							// + 0x24	-> call	dword ptr [ebx + 0x10]		; call pRoutine
		0x89, 0x43, 0x04,							// + 0x27	-> mov	[ebx + 0x04], eax			; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,			// + 0x2D	-> mov	eax, fs:[0x18]				; GetLastError
		0x8B, 0x40, 0x34,							// + 0x30	-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,							// + 0x33	-> mov	[ebx + 0x08], eax			; store in SR_REMOTE_DATA::LastWin32Error

		0x83, 0x7B, 0x14, 0x00,						// + 0x36	-> cmp  dword ptr [ebx + 0x14], 0	; check if SR_REMOTE_DATA::Buffer is 0 (real TID)
		0x74, 0x0A,									// + 0x3A	-> je   0x46						; skip if no TID was saved
		0x8B, 0x53, 0x14,							// + 0x3C	-> mov  edx, [ebx + 0x14]			; load real thread ID
		0x64, 0x89, 0x15, 0x24, 0x00, 0x00, 0x00,	// + 0x3F	-> mov  fs:[0x24], edx				; move real thread ID back into TEB

		0xC6, 0x03, 0x02,							// + 0x46	-> mov	byte ptr [ebx], 2			; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished
		0x31, 0xC0,									// + 0x49	-> xor	eax, eax					; zero eax (thread exitcode = 0)
		0xEB, 0x03,									// + 0x4B	-> jmp	0x50						; jump to ret

		0x83, 0xC8, 0xFF,							// + 0x4D	-> or	eax, -1						; set eax to -1 (thread exitcode = -1)

		0x5B,										// + 0x50	-> pop	ebx							; restore ebx

		0x5D,										// + 0x51	-> pop	ebp							; x86 __stdcall epilogue
		0xC2, 0x04, 0x00							// + 0x52	-> ret	0x04
	}; // SIZE = 0x55 (+ sizeof(SR_REMOTE_DATA))

#endif

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, sizeof(Shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return SR_NTCTE_ERR_CANT_ALLOC_MEM;
	}

	void * pRemoteFunc = ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA);

	auto * sr_data = ReCa<SR_REMOTE_DATA *>(Shellcode);
	sr_data->pArg		= pArg;
	sr_data->pRoutine	= pRoutine;
	sr_data->Buffer		= FakeTID;

	LOG(2, "Codecave allocated at %p\n", pMem);

	BOOL bRet = WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr);
	if (!bRet)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_NTCTE_ERR_WPM_FAIL;
	}

	LOG(2, "Creating thread with:\n");
	LOG(3, "pRoutine = %p\n", pRemoteFunc);
	LOG(3, "pArg     = %p\n", pMem);

	NTSTATUS ntRet = NATIVE::NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, nullptr, hTargetProc, FakeStartAddress ? pEntrypoint : pRemoteFunc, pMem, ntFlags, 0, 0, 0, nullptr);
	if (NT_FAIL(ntRet) || !hThread)
	{
		INIT_ERROR_DATA(error_data, (DWORD)ntRet);

		LOG(2, "NtCreateThreadEx failed: %08X\n", (DWORD)ntRet);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_NTCTE_ERR_NTCTE_FAIL;
	}

	auto TID = GetThreadId(hThread);

	LOG(2, "Thread created with TID = %06X (%06d)\n", TID, TID);

	if (FakeStartAddress)
	{
		CONTEXT ctx{ 0 };
		ctx.ContextFlags = CONTEXT_ALL;

		if (!GetThreadContext(hThread, &ctx))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "GetThreadContext failed: %08X\n", error_data.AdvErrorCode);

			TerminateThread(hThread, 0);
			CloseHandle(hThread);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_NTCTE_ERR_GET_CONTEXT_FAIL;
		}

		LOG(2, "Loaded thread context\n");

#ifdef _WIN64
		ctx.Rcx = ReCa<DWORD64>(pRemoteFunc);
#else
		ctx.Eax = ReCa<DWORD>(pRemoteFunc);
#endif

		if (!SetThreadContext(hThread, &ctx))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "SetThreadContext failed: %08X\n", error_data.AdvErrorCode);

			TerminateThread(hThread, 0);
			CloseHandle(hThread);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_NTCTE_ERR_SET_CONTEXT_FAIL;
		}

		LOG(2, "Thread redirected\n");
	}

	if (Flags & INJ_CTF_SKIP_THREAD_ATTACH)
	{
		THREAD_BASIC_INFORMATION tbi{ 0 };
		ntRet = NATIVE::NtQueryInformationThread(hThread, THREADINFOCLASS::ThreadBasicInformation, &tbi, sizeof(tbi), nullptr);
		if (NT_FAIL(ntRet) || !tbi.TebBaseAddress)
		{
			INIT_ERROR_DATA(error_data, ntRet);

			LOG(2, "NtQueryInformationThread failed: %08X\n", error_data.AdvErrorCode);

			TerminateThread(hThread, 0);
			CloseHandle(hThread);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_NTCTE_ERR_NTQIT_FAIL;
		}

		WORD same_teb_flags = 0;
		if (!ReadProcessMemory(hTargetProc, ReCa<BYTE *>(tbi.TebBaseAddress) + TEB_SameTebFlags, &same_teb_flags, sizeof(same_teb_flags), nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			TerminateThread(hThread, 0);
			CloseHandle(hThread);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_NTCTE_ERR_RPM_FAIL;
		}

		same_teb_flags |= TEB_SAMETEB_FLAGS_SkipAttach;
		if (!WriteProcessMemory(hTargetProc, ReCa<BYTE *>(tbi.TebBaseAddress) + TEB_SameTebFlags, &same_teb_flags, sizeof(same_teb_flags), nullptr))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

			TerminateThread(hThread, 0);
			CloseHandle(hThread);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_NTCTE_ERR_WPM_FAIL;
		}

		LOG(2, "Fixed TEB flags\n");
	}

	if (ntFlags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED)
	{
		if (ResumeThread(hThread) == (DWORD)-1)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "ResumeThread failed: %08X\n", error_data.AdvErrorCode);

			TerminateThread(hThread, 0);
			CloseHandle(hThread);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_NTCTE_ERR_RESUME_FAIL;
		}

		LOG(2, "Thread resumed\n");
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	DWORD dwExitCode = 0;

	SR_REMOTE_DATA data{ };
	data.State			= SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	HANDLE handles[] = { hThread, g_hInterruptedEvent };

	DWORD dwWaitRet = WaitForMultipleObjects(2, handles, FALSE, Timeout);
	if (dwWaitRet != WAIT_OBJECT_0)
	{
		if (dwWaitRet == (WAIT_OBJECT_0 + 1))
		{
			INIT_ERROR_DATA(error_data, dwWaitRet);

			LOG(2, "Interrupt!\n");
		}
		else
		{
			if (dwWaitRet == WAIT_FAILED)
			{
				INIT_ERROR_DATA(error_data, GetLastError());
			}
			else
			{
				INIT_ERROR_DATA(error_data, dwWaitRet);
			}

			LOG(2, "WaitForSingleObject failed: %08X\n", error_data.AdvErrorCode);
		}

		TerminateThread(hThread, 0);
		CloseHandle(hThread);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		if (dwWaitRet == (WAIT_OBJECT_0 + 1))
		{
			SetEvent(g_hInterruptedEvent);

			return SR_ERR_INTERRUPT;
		}

		return SR_NTCTE_ERR_REMOTE_TIMEOUT;
	}

	LOG(2, "Thread finished execution\n");

	if (!GetExitCodeThread(hThread, &dwExitCode))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "GetExitCodeThread failed: %08X\n", error_data.AdvErrorCode);

		CloseHandle(hThread);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_NTCTE_ERR_GECT_FAIL;
	}

	bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
	
	DWORD dwErr = GetLastError();

	CloseHandle(hThread);

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	if (bRet)
	{
		LOG(2, "Thread exit data retrieved\n");

		if (data.State != SR_REMOTE_STATE::SR_RS_ExecutionFinished)
		{
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			LOG(2, "Shell timed out\n");

			return SR_NTCTE_ERR_REMOTE_TIMEOUT;
		}
	}

	if (dwExitCode == 0xFFFFFFFF)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shellcode creation failed\n");

		return SR_NTCTE_ERR_SHELLCODE_SETUP_FAIL;
	}
	else if (!bRet)
	{
		INIT_ERROR_DATA(error_data, dwErr);

		LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		return SR_NTCTE_ERR_RPM_FAIL;
	}

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out	= data.Ret;
			
	return SR_ERR_SUCCESS;
}
```

`GH Injector Library/Process Info.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Process Info.h"

#define NEXT_SYSTEM_PROCESS_ENTRY(pCurrent) ReCa<SYSTEM_PROCESS_INFORMATION *>(ReCa<BYTE *>(pCurrent) + pCurrent->NextEntryOffset)

ProcessInfo::ProcessInfo()
{
	HINSTANCE hNTDLL = GetModuleHandleW(L"ntdll.dll");
	if (!hNTDLL)
	{
		return;
	}

	LOG(3, "Creating ProcessInfo\n");

	m_pNtQueryInformationProcess	= ReCa<f_NtQueryInformationProcess>	(GetProcAddress(hNTDLL, "NtQueryInformationProcess"));
	m_pNtQuerySystemInformation		= ReCa<f_NtQuerySystemInformation>	(GetProcAddress(hNTDLL, "NtQuerySystemInformation"));
	m_pNtQueryInformationThread		= ReCa<f_NtQueryInformationThread>	(GetProcAddress(hNTDLL, "NtQueryInformationThread"));

	if (!m_pNtQueryInformationProcess || !m_pNtQuerySystemInformation || !m_pNtQueryInformationThread)
	{
		return;
	}

	m_BufferSize	= 0x10000;
	m_pFirstProcess = nullptr;

	ULONG nt_ret_offset = 0;

#ifdef _WIN64
	if (GetOSBuildVersion() <= g_Win10_1507)
	{
		nt_ret_offset = NT_RET_OFFSET_64_WIN7;
	}
	else
	{
		nt_ret_offset = NT_RET_OFFSET_64_WIN10_1511;
	}
#else
	if (GetOSVersion() == g_Win7)
	{
		nt_ret_offset = NT_RET_OFFSET_86_WIN7;
	}
	else
	{
		nt_ret_offset = NT_RET_OFFSET_86_WIN8;
	}
#endif

	m_WaitFunctionReturnAddress[0] = ReCa<UINT_PTR>(GetProcAddress(hNTDLL, "NtDelayExecution"				)) + nt_ret_offset;
	m_WaitFunctionReturnAddress[1] = ReCa<UINT_PTR>(GetProcAddress(hNTDLL, "NtWaitForSingleObject"			)) + nt_ret_offset;
	m_WaitFunctionReturnAddress[2] = ReCa<UINT_PTR>(GetProcAddress(hNTDLL, "NtWaitForMultipleObjects"		)) + nt_ret_offset;
	m_WaitFunctionReturnAddress[3] = ReCa<UINT_PTR>(GetProcAddress(hNTDLL, "NtSignalAndWaitForSingleObject"	)) + nt_ret_offset;

	if (GetOSBuildVersion() >= g_Win10_1607)
	{
		m_hWin32U = LoadLibraryW(L"win32u.dll");
		if (m_hWin32U)
		{
			m_WaitFunctionReturnAddress[4] = ReCa<UINT_PTR>(GetProcAddress(m_hWin32U, "NtUserMsgWaitForMultipleObjectsEx")) + nt_ret_offset;
		}
	}

	LOG(3, "ProcessInfo initialized\n");
}

ProcessInfo::~ProcessInfo()
{
	if (m_hWin32U)
	{
		FreeLibrary(m_hWin32U);
	}

	if (m_pFirstProcess)
	{
		delete[] m_pFirstProcess;
	}
}

bool ProcessInfo::SetProcess(HANDLE hTargetProc)
{
	DWORD dwHandleInfo = 0;
	if (!hTargetProc || hTargetProc == INVALID_HANDLE_VALUE || !GetHandleInformation(hTargetProc, &dwHandleInfo))
	{
		return false;
	}

	if (!m_pFirstProcess)
	{
		if (!RefreshInformation())
		{
			return false;
		}
	}

	m_hCurrentProcess = hTargetProc;

#ifdef _WIN64
	m_IsWow64 = IsNative() ? false : true;
#endif

	ULONG_PTR PID = GetProcessId(m_hCurrentProcess);

	while (NEXT_SYSTEM_PROCESS_ENTRY(m_pCurrentProcess) != m_pCurrentProcess)
	{
		if (m_pCurrentProcess->UniqueProcessId == ReCa<void *>(PID))
		{
			break;
		}

		m_pCurrentProcess = NEXT_SYSTEM_PROCESS_ENTRY(m_pCurrentProcess);
	}

	if (m_pCurrentProcess->UniqueProcessId != ReCa<void *>(PID))
	{
		m_pCurrentProcess = m_pFirstProcess;
		return false;
	}

	m_CurrentThreadIndex = 0;
	m_pCurrentThread = &m_pCurrentProcess->Threads[0];

	return true;
}

bool ProcessInfo::SetThread(DWORD TID)
{
	if (!m_pFirstProcess)
	{
		return false;
	}

	m_pCurrentThread = nullptr;

	for (UINT i = 0; i != m_pCurrentProcess->NumberOfThreads; ++i)
	{
		if (m_pCurrentProcess->Threads[i].ClientId.UniqueThread == ReCa<void *>(ULONG_PTR(TID)))
		{
			m_CurrentThreadIndex = i;
			m_pCurrentThread = &m_pCurrentProcess->Threads[i];

			break;
		}
	}
	
	if (m_pCurrentThread == nullptr)
	{
		m_CurrentThreadIndex = 0;
		m_pCurrentThread = &m_pCurrentProcess->Threads[0];

		return false;
	}

	return true;
}

bool ProcessInfo::FirstThread()
{
	if (!m_pFirstProcess)
	{
		return false;
	}

	m_CurrentThreadIndex = 0;
	m_pCurrentThread = &m_pCurrentProcess->Threads[0];

	return true;
}

bool ProcessInfo::NextThread()
{
	if (!m_pFirstProcess)
	{
		return false;
	}

	if (m_CurrentThreadIndex == m_pCurrentProcess->NumberOfThreads - 1)
	{
		return false;
	}

	m_pCurrentThread = &m_pCurrentProcess->Threads[++m_CurrentThreadIndex];

	return true;
}

bool ProcessInfo::RefreshInformation()
{
	if (!m_pFirstProcess)
	{
		m_pFirstProcess = ReCa<SYSTEM_PROCESS_INFORMATION *>(new(std::nothrow) BYTE[m_BufferSize]());
		if (!m_pFirstProcess)
		{
			return false;
		}
	}
	else
	{
		delete[] m_pFirstProcess;
		m_pFirstProcess = nullptr;

		return RefreshInformation();
	}

	ULONG size_out = 0;
	NTSTATUS ntRet = m_pNtQuerySystemInformation(SYSTEM_INFORMATION_CLASS::SystemProcessInformation, m_pFirstProcess, m_BufferSize, &size_out);

	while (ntRet == STATUS_INFO_LENGTH_MISMATCH)
	{
		delete[] m_pFirstProcess;

		m_BufferSize	= size_out + 0x1000;
		m_pFirstProcess = ReCa<SYSTEM_PROCESS_INFORMATION *>(new(std::nothrow) BYTE[m_BufferSize]);
		if (!m_pFirstProcess)
		{
			return false;
		}

		ntRet = m_pNtQuerySystemInformation(SYSTEM_INFORMATION_CLASS::SystemProcessInformation, m_pFirstProcess, m_BufferSize, &size_out);
	}

	if (NT_FAIL(ntRet))
	{
		delete[] m_pFirstProcess;
		m_pFirstProcess = nullptr;

		return false;
	}

	m_pCurrentProcess	= m_pFirstProcess;
	m_pCurrentThread	= &m_pCurrentProcess->Threads[0];

	return true;
}

PEB * ProcessInfo::GetPEB()
{
	return GetPEB_Native();
}

LDR_DATA_TABLE_ENTRY * ProcessInfo::GetLdrEntry(HINSTANCE hMod)
{
	return GetLdrEntry_Native(hMod);
}

PEB * ProcessInfo::GetPEB_Native()
{
	if (!m_pFirstProcess)
	{
		return nullptr;
	}

	PROCESS_BASIC_INFORMATION PBI{ 0 };
	ULONG size_out = 0;
	NTSTATUS ntRet = m_pNtQueryInformationProcess(m_hCurrentProcess, PROCESSINFOCLASS::ProcessBasicInformation, &PBI, sizeof(PROCESS_BASIC_INFORMATION), &size_out);

	if (NT_FAIL(ntRet))
	{
		return nullptr;
	}

	return PBI.pPEB;
}

LDR_DATA_TABLE_ENTRY * ProcessInfo::GetLdrEntry_Native(HINSTANCE hMod)
{
	if (!m_pFirstProcess)
	{
		return nullptr;
	}

	PEB * ppeb = GetPEB();
	if (!ppeb)
	{
		return nullptr;
	}

	PEB	peb{ 0 };
	if (!ReadProcessMemory(m_hCurrentProcess, ppeb, &peb, sizeof(peb), nullptr))
	{
		return nullptr;
	}

	PEB_LDR_DATA ldrdata{ 0 };
	if (!ReadProcessMemory(m_hCurrentProcess, peb.Ldr, &ldrdata, sizeof(ldrdata), nullptr))
	{
		return nullptr;
	}

	LIST_ENTRY * pCurrentEntry = ldrdata.InLoadOrderModuleListHead.Flink;
	LIST_ENTRY * pLastEntry = ldrdata.InLoadOrderModuleListHead.Blink;

	while (true)
	{
		LDR_DATA_TABLE_ENTRY CurrentEntry{ };
		ReadProcessMemory(m_hCurrentProcess, pCurrentEntry, &CurrentEntry, sizeof(CurrentEntry), nullptr);

		if (CurrentEntry.DllBase == hMod)
		{
			return ReCa<LDR_DATA_TABLE_ENTRY *>(pCurrentEntry);
		}
		else if (pCurrentEntry == pLastEntry)
		{
			break;
		}

		pCurrentEntry = CurrentEntry.InLoadOrderLinks.Flink;
	}

	return nullptr;
}

void * ProcessInfo::GetEntrypoint()
{
	if (!m_pFirstProcess)
	{
		return nullptr;
	}

	PEB * ppeb = GetPEB();
	if (!ppeb)
	{
		return nullptr;
	}

	PEB	peb{ };
	if (!ReadProcessMemory(m_hCurrentProcess, ppeb, &peb, sizeof(peb), nullptr))
	{
		return nullptr;
	}

	PEB_LDR_DATA ldrdata{ };
	if (!ReadProcessMemory(m_hCurrentProcess, peb.Ldr, &ldrdata, sizeof(ldrdata), nullptr))
	{
		return nullptr;
	}

	LIST_ENTRY * pCurrentEntry	= ldrdata.InLoadOrderModuleListHead.Flink;
	LIST_ENTRY * pLastEntry		= ldrdata.InLoadOrderModuleListHead.Blink;

	wchar_t NameBuffer[MAX_PATH]{ 0 };
	while (true)
	{
		LDR_DATA_TABLE_ENTRY CurrentEntry{ };
		if (ReadProcessMemory(m_hCurrentProcess, pCurrentEntry, &CurrentEntry, sizeof(CurrentEntry), nullptr))
		{
			if (CurrentEntry.BaseDllName.Length < sizeof(NameBuffer) && CurrentEntry.BaseDllName.szBuffer)
			{
				if (ReadProcessMemory(m_hCurrentProcess, CurrentEntry.BaseDllName.szBuffer, NameBuffer, CurrentEntry.BaseDllName.Length, nullptr))
				{
					std::wstring Name = NameBuffer + CurrentEntry.BaseDllName.Length / sizeof(wchar_t) - 3; //std::wstring::ends_with doesn't support case insensitive comparisons...
					if (lstrcmpiW(Name.c_str(), L"exe") == 0)
					{
						return MPTR(CurrentEntry.EntryPoint);
					}
				}
			}			
		}

		if (pCurrentEntry == pLastEntry)
		{
			break;
		}

		pCurrentEntry = CurrentEntry.InLoadOrderLinks.Flink;
	}

	return nullptr;
}

DWORD ProcessInfo::GetPID()
{
	return GetProcessId(m_hCurrentProcess);
}

DWORD ProcessInfo::GetSessionID()
{
	if (m_pFirstProcess)
	{
		return m_pCurrentProcess->SessionId;
	}

	return SESSION_ID_INVALID;
}

bool ProcessInfo::IsNative()
{
	BOOL bOut = FALSE;
	IsWow64Process(m_hCurrentProcess, &bOut);
	return (bOut == FALSE);
}

bool ProcessInfo::IsProtected()
{
	BYTE info = 0;

	if (NT_FAIL(m_pNtQueryInformationProcess(m_hCurrentProcess, PROCESSINFOCLASS::ProcessProtectionInformation, &info, sizeof(info), nullptr)))
	{
		return true;
	}

	return (info != 0);
}

DWORD ProcessInfo::GetTID()
{
	if (!m_pCurrentThread)
	{
		return 0;
	}

	return DWORD(ReCa<ULONG_PTR>(m_pCurrentThread->ClientId.UniqueThread) & 0xFFFFFFFF);
}

DWORD ProcessInfo::GetThreadId()
{
	if (!m_pCurrentThread)
	{
		return 0;
	}

	return DWORD(ReCa<ULONG_PTR>(m_pCurrentThread->ClientId.UniqueThread) & 0xFFFFFFFF);
}

//Stolen from here:
//https://github.com/changeofpace/Remote-Process-Cookie-for-Windows-7/blob/master/Remote%20Process%20Cookie%20for%20Windows%207/main.cpp
//Thanks, changeofpace!
ULONG ProcessInfo::GetProcessCookie()
{
	if (!m_pFirstProcess)
	{
		return 0;
	}

	ULONG cookie = 0;
	if (GetOSVersion() == g_Win7)
	{
#ifdef _WIN64
		if (m_IsWow64)
		{
			DWORD ctrl1 = WOW64::UnhandledExceptionFilter_WOW64;
			DWORD ctrl2 = WOW64::DefaultHandler_WOW64;

			DWORD ptr1 = 0;
			DWORD ptr2 = 0;

			BOOL bRet = TRUE;
			bRet &= ReadProcessMemory(m_hCurrentProcess, MPTR(WOW64::RtlpUnhandledExceptionFilter_WOW64), &ptr1, sizeof(ptr1), nullptr);
			bRet &= ReadProcessMemory(m_hCurrentProcess, MPTR(WOW64::SingleHandler_WOW64), &ptr2, sizeof(ptr2), nullptr);

			if (!bRet)
			{
				return 0;
			}

			for (int i = 0; i < 0x20; ++i)
			{
				ULONG guess = _rotr(ptr1, i) ^ ctrl1;
				DWORD test	= _rotl(ptr2, guess & 0x1F) ^ guess;

				if (test == ctrl2)
				{
					cookie = guess;
					break;
				}
			}
		}
		else
		{
			ULONG_PTR ctrl1 = ReCa<ULONG_PTR>(NATIVE::UnhandledExceptionFilter);
			ULONG_PTR ctrl2 = ReCa<ULONG_PTR>(NATIVE::DefaultHandler);
		
			ULONG_PTR ptr1 = 0;
			ULONG_PTR ptr2 = 0;

			BOOL bRet = TRUE;
			bRet &= ReadProcessMemory(m_hCurrentProcess, NATIVE::RtlpUnhandledExceptionFilter, &ptr1, sizeof(ptr1), nullptr);
			bRet &= ReadProcessMemory(m_hCurrentProcess, NATIVE::SingleHandler, &ptr2, sizeof(ptr2), nullptr);

			if (!bRet)
			{
				return 0;
			}

			for (int i = 0; i < 0x40; ++i)
			{
				ULONG guess = ULONG(_rotr64(ptr1, i) ^ ctrl1);
				ULONG_PTR test = _rotl64(ptr2, guess & 0x3F) ^ guess;
				if (test == ctrl2)
				{
					cookie = guess;
					break;
				}
			}
		}
#else
		ULONG_PTR ctrl1 = ReCa<ULONG_PTR>(NATIVE::UnhandledExceptionFilter);
		ULONG_PTR ctrl2 = ReCa<ULONG_PTR>(NATIVE::DefaultHandler);

		ULONG_PTR ptr1 = 0;
		ULONG_PTR ptr2 = 0;

		BOOL bRet = TRUE;
		bRet &= ReadProcessMemory(m_hCurrentProcess, NATIVE::RtlpUnhandledExceptionFilter, &ptr1, sizeof(ptr1), nullptr);
		bRet &= ReadProcessMemory(m_hCurrentProcess, NATIVE::SingleHandler, &ptr2, sizeof(ptr2), nullptr);

		if (!bRet)
		{
			return 0;
		}

		for (int i = 0; i < 0x20; ++i)
		{
			ULONG guess		= ULONG(_rotr(ptr1, i) ^ ctrl1);
			ULONG_PTR test	= _rotl(ptr2, guess & 0x1F) ^ guess;

			if (test == ctrl2)
			{
				cookie = guess;
				break;
			}
		}
#endif
	}
	else
	{
		m_pNtQueryInformationProcess(m_hCurrentProcess, PROCESSINFOCLASS::ProcessCookie, &cookie, sizeof(cookie), nullptr);
	}

	return cookie;
}

bool ProcessInfo::GetThreadState(KTHREAD_STATE & state, KWAIT_REASON & reason)
{
	if (!m_pCurrentThread)
	{
		return 0;
	}

	state	= m_pCurrentThread->ThreadState;
	reason	= m_pCurrentThread->WaitReason;

	return true;
}

bool ProcessInfo::GetThreadStartAddress(void *& start_address)
{
	if (!m_pCurrentThread)
	{
		return false;
	}

	start_address = m_pCurrentThread->StartAddress;

	return true;
}

void * ProcessInfo::GetTEB()
{
	if (!m_pCurrentThread)
	{
		return nullptr;
	}

	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION | THREAD_QUERY_LIMITED_INFORMATION, FALSE, MDWD(m_pCurrentThread->ClientId.UniqueThread));
	if (!hThread)
	{
		return nullptr;
	}

	THREAD_BASIC_INFORMATION tbi{ 0 };
	auto ntRet = m_pNtQueryInformationThread(hThread, THREADINFOCLASS::ThreadBasicInformation, &tbi, sizeof(tbi), nullptr);

	CloseHandle(hThread);

	if (NT_FAIL(ntRet))
	{
		return nullptr;
	}

	return tbi.TebBaseAddress;
}

bool ProcessInfo::IsThreadInAlertableState()
{
	if (!m_pCurrentThread)
	{
		return false;
	}

	HANDLE hThread = OpenThread(THREAD_GET_CONTEXT, FALSE, MDWD(m_pCurrentThread->ClientId.UniqueThread));
	if (!hThread)
	{
		return false;
	}

	CONTEXT ctx{ 0 };
	ctx.ContextFlags = CONTEXT_ALL;

	if (!GetThreadContext(hThread, &ctx))
	{
		CloseHandle(hThread);

		return false;
	}

	CloseHandle(hThread);

#ifdef _WIN64

	if (!ctx.Rip || !ctx.Rsp)
	{
		return false;
	}

	if (ctx.Rip == m_WaitFunctionReturnAddress[0]) //NtDelayExecution
	{
		if (GetOSVersion() == g_Win7)
		{
			return (ctx.Rdi == TRUE);
		}
		else if (GetOSBuildVersion() <= g_Win10_1709)
		{
			return (ctx.Rbx == TRUE);
		}
		else
		{
			return (ctx.Rcx == TRUE);
		}
	}
	else if (ctx.Rip == m_WaitFunctionReturnAddress[1]) //NtWaitForSingleObject
	{
		return (ctx.Rbx == TRUE);
	}
	else if (ctx.Rip == m_WaitFunctionReturnAddress[2] || ctx.Rip == m_WaitFunctionReturnAddress[3]) //NtWaitForMultipleObjects & NtSignalAndWaitForSingleObject
	{
		return (ctx.Rsi == TRUE);
	}
	else if (ctx.Rip == m_WaitFunctionReturnAddress[4]) //NtUserMsgWaitForMultipleObjectsEx
	{
		DWORD Flags = FALSE;
		if (ReadProcessMemory(m_hCurrentProcess, ReCa<void *>(ctx.Rsp + 0x28), &Flags, sizeof(Flags), nullptr))
		{
			return ((Flags & MWMO_ALERTABLE) != 0);
		}
	}

#else

	if (!ctx.Eip || !ctx.Esp)
	{
		return false;
	}

	DWORD stack_buffer[6] = { 0 };
	if (!ReadProcessMemory(m_hCurrentProcess, ReCa<void *>(ctx.Esp), stack_buffer, sizeof(stack_buffer), nullptr))
	{
		return false;
	}

	if (ctx.Eip == m_WaitFunctionReturnAddress[0]) //NtDelayExecution
	{
		if (GetOSVersion() == g_Win7)
		{
			return (stack_buffer[2] == TRUE);
		}
		else
		{
			return (stack_buffer[1] == TRUE);
		}
	}
	else if (ctx.Eip == m_WaitFunctionReturnAddress[1]) //NtWaitForSingleObject
	{
		if (GetOSVersion() == g_Win7)
		{
			return (stack_buffer[3] == TRUE);
		}
		else
		{
			return (stack_buffer[2] == TRUE);
		}
	}
	else if (ctx.Eip == m_WaitFunctionReturnAddress[2]) //NtWaitForMultipleObjects
	{
		if (GetOSVersion() == g_Win7)
		{
			return (stack_buffer[5] == TRUE);
		}
		else
		{
			return (stack_buffer[4] == TRUE);
		}
	}
	else if (ctx.Eip == m_WaitFunctionReturnAddress[3]) //NtSignalAndWaitForSingleObject
	{
		if (GetOSVersion() == g_Win7)
		{
			return (stack_buffer[4] == TRUE);
		}
		else
		{
			return (stack_buffer[3] == TRUE);
		}
	}
	else if (ctx.Eip == m_WaitFunctionReturnAddress[4]) //NtUserMsgWaitForMultipleObjectsEx
	{
		return ((stack_buffer[5] & MWMO_ALERTABLE) != 0);
	}

#endif

	return false;
}

bool ProcessInfo::IsThreadWorkerThread()
{
	if (GetOSVersion() < g_Win10)
	{
		//TEB_SAMETEB_FLAGS::LoaderWorker is Win10+ only

		return false;
	}

	if (!m_pCurrentThread)
	{
		return false;
	}

	BYTE * teb = ReCa<BYTE *>(GetTEB());
	if (!teb)
	{
		return false;
	}

	USHORT TebInfo = NULL;
	if (ReadProcessMemory(m_hCurrentProcess, teb + TEB_SameTebFlags, &TebInfo, sizeof(TebInfo), nullptr))
	{
		return ((TebInfo & TEB_SAMETEB_FLAGS_LoaderWorker) != 0);
	}

	return false;
}

const SYSTEM_PROCESS_INFORMATION * ProcessInfo::GetProcessInfo()
{
	return m_pFirstProcess ? m_pCurrentProcess : nullptr;
}

const SYSTEM_THREAD_INFORMATION * ProcessInfo::GetThreadInfo()
{
	return m_pFirstProcess ? m_pCurrentThread : nullptr;
}

#ifdef _WIN64

PEB_32 * ProcessInfo::GetPEB_WOW64()
{
	if (!m_pFirstProcess || !m_IsWow64)
	{
		return 0;
	}

	ULONG_PTR pPEB;
	ULONG size_out = 0;
	NTSTATUS ntRet = m_pNtQueryInformationProcess(m_hCurrentProcess, PROCESSINFOCLASS::ProcessWow64Information, &pPEB, sizeof(pPEB), &size_out);

	if (NT_FAIL(ntRet))
	{ 
		return nullptr;
	}

	return ReCa<PEB_32 *>(pPEB);
}

LDR_DATA_TABLE_ENTRY_32 * ProcessInfo::GetLdrEntry_WOW64(HINSTANCE hMod)
{
	if (!m_pFirstProcess || !m_IsWow64)
	{
		return nullptr;
	}
	
	PEB_32 * ppeb = GetPEB_WOW64();
	if (!ppeb)
	{
		return nullptr;
	}

	PEB_32 peb{ 0 };
	if (!ReadProcessMemory(m_hCurrentProcess, ppeb, &peb, sizeof(peb), nullptr))
	{
		return nullptr;
	}
	
	PEB_LDR_DATA_32 ldrdata{ 0 };
	if (!ReadProcessMemory(m_hCurrentProcess, MPTR(peb.Ldr), &ldrdata, sizeof(ldrdata), nullptr))
	{
		return nullptr;
	}
		
	LIST_ENTRY32 * pCurrentEntry	= ReCa<LIST_ENTRY32 *>((ULONG_PTR)ldrdata.InLoadOrderModuleListHead.Flink);
	LIST_ENTRY32 * pLastEntry		= ReCa<LIST_ENTRY32 *>((ULONG_PTR)ldrdata.InLoadOrderModuleListHead.Blink);

	while (true)
	{
		LDR_DATA_TABLE_ENTRY_32 CurrentEntry{ };
		ReadProcessMemory(m_hCurrentProcess, pCurrentEntry, &CurrentEntry, sizeof(CurrentEntry), nullptr);

		if (CurrentEntry.DllBase == MDWD(hMod))
		{
			return ReCa<LDR_DATA_TABLE_ENTRY_32 *>(pCurrentEntry);
		}
		else if (pCurrentEntry == pLastEntry)			
		{
			break;
		}

		pCurrentEntry = ReCa<LIST_ENTRY32 *>((ULONG_PTR)CurrentEntry.InLoadOrderLinks.Flink);
	}

	return nullptr;
}

void * ProcessInfo::GetEntrypoint_WOW64()
{
	if (!m_pFirstProcess)
	{
		return nullptr;
	}

	PEB_32 * ppeb = GetPEB_WOW64();
	if (!ppeb)
	{
		return nullptr;
	}

	PEB_32 peb{ };
	if (!ReadProcessMemory(m_hCurrentProcess, ppeb, &peb, sizeof(peb), nullptr))
	{
		return nullptr;
	}

	PEB_LDR_DATA_32 ldrdata{ };
	if (!ReadProcessMemory(m_hCurrentProcess, MPTR(peb.Ldr), &ldrdata, sizeof(ldrdata), nullptr))
	{
		return nullptr;
	}

	auto * pCurrentEntry	= ReCa<LIST_ENTRY32 *>(MPTR(ldrdata.InLoadOrderModuleListHead.Flink));
	auto * pLastEntry		= ReCa<LIST_ENTRY32 *>(MPTR(ldrdata.InLoadOrderModuleListHead.Blink));

	wchar_t NameBuffer[MAX_PATH]{ 0 };
	while (true)
	{
		LDR_DATA_TABLE_ENTRY_32 CurrentEntry{ };
		if (ReadProcessMemory(m_hCurrentProcess, pCurrentEntry, &CurrentEntry, sizeof(CurrentEntry), nullptr))
		{
			if (CurrentEntry.BaseDllName.Length < sizeof(NameBuffer) && CurrentEntry.BaseDllName.Length > 4 && CurrentEntry.BaseDllName.szBuffer)
			{
				if (ReadProcessMemory(m_hCurrentProcess, MPTR(CurrentEntry.BaseDllName.szBuffer), NameBuffer, CurrentEntry.BaseDllName.Length, nullptr))
				{
					std::wstring Name = NameBuffer + CurrentEntry.BaseDllName.Length / sizeof(wchar_t) - 3; //std::wstring::ends_with doesn't support case insensitive comparisons...
					if (lstrcmpiW(Name.c_str(), L"exe") == 0)
					{
						return MPTR(CurrentEntry.EntryPoint);
					}
				}
			}
		}

		if (pCurrentEntry == pLastEntry)
		{
			break;
		}

		pCurrentEntry = ReCa<LIST_ENTRY32 *>(MPTR(CurrentEntry.InLoadOrderLinks.Flink));
	}

	return nullptr;
}

bool ProcessInfo::GetThreadStartAddress_WOW64(void *& start_address)
{
	if (!m_pCurrentThread || !m_IsWow64)
	{
		return false;
	}

	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION | THREAD_QUERY_LIMITED_INFORMATION, FALSE, MDWD(m_pCurrentThread->ClientId.UniqueThread));
	if (!hThread)
	{
		return false;
	}

	if (NT_SUCCESS(m_pNtQueryInformationThread(hThread, THREADINFOCLASS::ThreadQuerySetWin32StartAddress, &start_address, sizeof(start_address), nullptr)))
	{
		CloseHandle(hThread);

		return true;
	}

	CloseHandle(hThread);

	return false;
}

bool ProcessInfo::IsThreadInAlertableState_WOW64()
{
	if (!m_pCurrentThread || !m_IsWow64)
	{
		return false;
	}

	if (m_WaitFunctionReturnAddress_WOW64[0] == 0)
	{
		HINSTANCE hNTDLL = GetModuleHandleExW_WOW64(m_hCurrentProcess, L"ntdll.dll");
		if (!hNTDLL)
		{
			return false;
		}
		
		DWORD Address = 0;

		ULONG nt_ret_offset = 0;

		if (GetOSVersion() > g_Win7)
		{
			nt_ret_offset = NT_RET_OFFSET_86_WIN8;
		}
		else
		{
			nt_ret_offset = NT_RET_OFFSET_86_WIN7;
		}

		GetProcAddressEx_WOW64(m_hCurrentProcess, hNTDLL, "NtDelayExecution", Address);
		m_WaitFunctionReturnAddress_WOW64[0] = Address + nt_ret_offset;

		GetProcAddressEx_WOW64(m_hCurrentProcess, hNTDLL, "NtWaitForSingleObject", Address);
		m_WaitFunctionReturnAddress_WOW64[1] = Address + nt_ret_offset;

		GetProcAddressEx_WOW64(m_hCurrentProcess, hNTDLL, "NtWaitForMultipleObjects", Address);
		m_WaitFunctionReturnAddress_WOW64[2] = Address + nt_ret_offset;

		GetProcAddressEx_WOW64(m_hCurrentProcess, hNTDLL, "NtSignalAndWaitForSingleObject", Address);
		m_WaitFunctionReturnAddress_WOW64[3] = Address + nt_ret_offset;

		if (GetOSBuildVersion() >= g_Win10_1607)
		{
			HINSTANCE hWIN32U = GetModuleHandleExW_WOW64(m_hCurrentProcess, L"win32u.dll");
			if (hWIN32U)
			{
				GetProcAddressEx_WOW64(m_hCurrentProcess, hWIN32U, "NtUserMsgWaitForMultipleObjectsEx", Address);
				m_WaitFunctionReturnAddress_WOW64[4] = Address + nt_ret_offset;
			}
		}
	}

	HANDLE hThread = OpenThread(THREAD_GET_CONTEXT, FALSE, MDWD(m_pCurrentThread->ClientId.UniqueThread));
	if (!hThread)
	{
		return false;
	}

	WOW64_CONTEXT ctx{ 0 };
	ctx.ContextFlags = WOW64_CONTEXT_ALL;

	if (!Wow64GetThreadContext(hThread, &ctx) || !ctx.Eip || !ctx.Esp)
	{
		CloseHandle(hThread);

		return false;
	}
	
	CloseHandle(hThread);
	
	DWORD stack_buffer[6] = { 0 };
	if (!ReadProcessMemory(m_hCurrentProcess, MPTR(ctx.Esp), stack_buffer, sizeof(stack_buffer), nullptr))
	{
		return false;
	}

	if (ctx.Eip == m_WaitFunctionReturnAddress_WOW64[0]) //NtDelayExecution
	{
		if (GetOSVersion() == g_Win7)
		{
			return (stack_buffer[2] == TRUE);
		}
		else
		{
			return (stack_buffer[1] == TRUE);
		}
	}
	else if (ctx.Eip == m_WaitFunctionReturnAddress_WOW64[1]) //NtWaitForSingleObject
	{
		if (GetOSVersion() == g_Win7)
		{
			return (stack_buffer[3] == TRUE);
		}
		else
		{
			return (stack_buffer[2] == TRUE);
		}
	}
	else if (ctx.Eip == m_WaitFunctionReturnAddress_WOW64[2]) //NtWaitForMultipleObjects
	{
		if (GetOSVersion() == g_Win7)
		{
			return (stack_buffer[5] == TRUE);
		}
		else
		{
			return (stack_buffer[4] == TRUE);
		}
	}
	else if (ctx.Eip == m_WaitFunctionReturnAddress_WOW64[3]) //NtSignalAndWaitForSingleObject
	{
		if (GetOSVersion() == g_Win7)
		{
			return (stack_buffer[4] == TRUE);
		}
		else
		{
			return (stack_buffer[3] == TRUE);
		}
	}
	else if (ctx.Eip == m_WaitFunctionReturnAddress_WOW64[4]) //NtUserMsgWaitForMultipleObjectsEx
	{
		return ((stack_buffer[5] & MWMO_ALERTABLE) != 0);
	}
	
	return false;		
}

void * ProcessInfo::GetTEB_WOW64()
{
	if (!m_pCurrentThread || !m_IsWow64)
	{
		return nullptr;
	}
	
	BYTE * ret = ReCa<BYTE *>(GetTEB());
	if (!ret)
	{
		return nullptr;
	}

	if (GetOSVersion() >= g_Win10)
	{
		LONG WowTebOffset = 0;
		if (ReadProcessMemory(m_hCurrentProcess, ret + TEB_WowTebOffset_64, &WowTebOffset, sizeof(WowTebOffset), nullptr))
		{
			//TEB32 = TEB64 + TEB64.WowTebOffset
			return ret + WowTebOffset;
		}
	}
	
	//TEB32 = TEB64 + 0x2000
	return ret + 0x2000;
}

#endif
```

`GH Injector Library/Process Info.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "Import Handler.h"

//Wrapper class which relies on information from NtQuerySystemInformation and NtQueryInformationProcess

//Used to enumerate threads, retrieve PEBs, etc...

//Honestly, too lazy to document

#define NT_RET_OFFSET_64_WIN7		0x0A //Win7 - Win10 1507
#define NT_RET_OFFSET_64_WIN10_1511 0x14 //Win10 1511+

#define NT_RET_OFFSET_86_WIN7 0x15 //Win7 only
#define NT_RET_OFFSET_86_WIN8 0x0C //Win8+

#define TEB_SameTebFlags_64 0x17EE
#define TEB_SameTebFlags_86 0xFCA

#define TEB_WowTebOffset_64 0x180C //Win10+ only

#define TEB_SAMETEB_FLAGS_SkipAttach	0x0008
#define TEB_SAMETEB_FLAGS_LoaderWorker	0x2000

#ifdef _WIN64
#define TEB_SameTebFlags TEB_SameTebFlags_64
#else
#define TEB_SameTebFlags TEB_SameTebFlags_86
#endif

class ProcessInfo
{
	SYSTEM_PROCESS_INFORMATION	* m_pCurrentProcess = nullptr;
	SYSTEM_PROCESS_INFORMATION	* m_pFirstProcess	= nullptr;
	SYSTEM_THREAD_INFORMATION	* m_pCurrentThread	= nullptr;

	ULONG m_BufferSize = 0;

	HANDLE m_hCurrentProcess = nullptr;

	DWORD m_CurrentThreadIndex = 0;

	f_NtQueryInformationProcess m_pNtQueryInformationProcess	= nullptr;
	f_NtQuerySystemInformation	m_pNtQuerySystemInformation		= nullptr;
	f_NtQueryInformationThread	m_pNtQueryInformationThread		= nullptr;

	PEB						* GetPEB_Native();
	LDR_DATA_TABLE_ENTRY	* GetLdrEntry_Native(HINSTANCE hMod);

	UINT_PTR m_WaitFunctionReturnAddress[5] = { 0 };

	HINSTANCE m_hWin32U = NULL;

#ifdef _WIN64
	DWORD	m_WaitFunctionReturnAddress_WOW64[5]	= { 0 };
	bool	m_IsWow64								= false;
#endif

public:

	ProcessInfo();
	~ProcessInfo();

	bool SetProcess(HANDLE hTargetProc);
	bool SetThread(DWORD TID);

	bool FirstThread();
	bool NextThread();

	bool RefreshInformation();

	PEB						* GetPEB();
	LDR_DATA_TABLE_ENTRY	* GetLdrEntry(HINSTANCE hMod);
	void					* GetEntrypoint();

	DWORD GetPID();
	DWORD GetSessionID();

	bool IsNative();
	bool IsProtected();

	DWORD GetTID();
	DWORD GetThreadId();

	DWORD GetProcessCookie();

	bool GetThreadState(KTHREAD_STATE & state, KWAIT_REASON & reason);
	bool GetThreadStartAddress(void *& start_address);
	void * GetTEB();

	bool IsThreadInAlertableState();
	bool IsThreadWorkerThread();

	const SYSTEM_PROCESS_INFORMATION	* GetProcessInfo();
	const SYSTEM_THREAD_INFORMATION		* GetThreadInfo();

#ifdef _WIN64

	PEB_32					* GetPEB_WOW64();
	LDR_DATA_TABLE_ENTRY_32	* GetLdrEntry_WOW64(HINSTANCE hMod);
	void					* GetEntrypoint_WOW64();

	bool GetThreadStartAddress_WOW64(void *& start_address);
	bool IsThreadInAlertableState_WOW64();
	void * GetTEB_WOW64();

#endif
};
```

`GH Injector Library/QueueUserAPC WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Start Routine.h"

DWORD SR_QueueUserAPC_WOW64(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_QueueUserAPC_WOW64\n");

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER_86

		0x55,								// + 0x00	-> push	ebp					; x86 stack frame creation
		0x89, 0xE5,							// + 0x01	-> mov	ebp, esp

		0x53,								// + 0x03	-> push	ebx					; push ebx on stack (non volatile)
		0x8B, 0x5D, 0x08,					// + 0x04	-> mov	ebx, [ebp + 0x08]	; store pData in ebx
		0x85, 0xDB,							// + 0x07	-> test	ebx, ebx			; check if pData is valid
		0x74, 0x20,							// + 0x09	-> je	0x2B				; jump if nullptr

		0x83, 0x3B, 0x00,					// + 0x0B	-> cmp	dword ptr [ebx], 0	; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x75, 0x1B,							// + 0x0E	-> jne	0x2B				; jump if not equal

		0xC6, 0x03, 0x01,					// + 0x10	-> mov	byte ptr [ebx], 1	; set SR_REMOTE_DATA::State to SR_RS_Executing

		0xFF, 0x73, 0x0C,					// + 0x13	-> push	[ebx + 0x0C]		; push pArg
		0xFF, 0x53, 0x10,					// + 0x16	-> call	[ebx + 0x10]		; call pRoutine
		0x89, 0x43, 0x04,					// + 0x19	-> mov	[ebx + 0x04], eax	; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,	// + 0x1C	-> mov	eax, fs:[0x18]		; GetLastError
		0x8B, 0x40, 0x34,					// + 0x22	-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,					// + 0x25	-> mov	[ebx + 0x08], eax	; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,					// + 0x28	-> mov	byte ptr [ebx], 2	; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,								// + 0x2B	-> pop	ebx					; restore ebx

		0x5D,								// + 0x2C	-> pop	ebp					; x86 __stdcall epilogue
		0xC2, 0x04, 0x00					// + 0x2D	-> ret	0x04
	}; // SIZE = 0x30 (+ sizeof(SR_REMOTE_DATA_WOW64))

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, sizeof(Shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return SR_QUAPC_ERR_CANT_ALLOC_MEM;
	}

	void * pRemoteFunc = ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA_WOW64);

	auto * sr_data = ReCa<SR_REMOTE_DATA_WOW64*>(Shellcode);
	sr_data->pArg	  = pArg;
	sr_data->pRoutine = pRoutine;

	LOG(2, "Codecave allocated at %p\n", pMem);

	BOOL bRet = WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr);
	if (!bRet)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_QUAPC_ERR_WPM_FAIL;
	}

	LOG(2, "Queueing APCs with:\n");
	LOG(3, "pRoutine = %08X\n", MDWD(pRemoteFunc));
	LOG(3, "pArg     = %08X\n", MDWD(pMem));

	ProcessInfo PI;
	if (!PI.SetProcess(hTargetProc))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Can't initialize ProcessInfo class\n");

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_QUAPC_ERR_PROC_INFO_FAIL;
	}

	bool APC_Queued = false;

	do
	{
		KWAIT_REASON reason;
		KTHREAD_STATE state;
		if (!PI.GetThreadState(state, reason) || reason == KWAIT_REASON::WrQueue)
		{
			continue;
		}

		if (!PI.IsThreadWorkerThread() && (PI.IsThreadInAlertableState_WOW64() || state == KTHREAD_STATE::Running))
		{
			DWORD ThreadID = PI.GetThreadId();
			HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, ThreadID);
			if (!hThread)
			{
				continue;
			}

			if (NT_SUCCESS(NATIVE::RtlQueueApcWow64Thread(hThread, pRemoteFunc, pMem, nullptr, nullptr)))
			{
				LOG(2, "APC queued to thread %06X\n", ThreadID);

				PostThreadMessageW(ThreadID, WM_NULL, 0, 0);
				APC_Queued = true;
			}

			CloseHandle(hThread);
		}
	} while (PI.NextThread());

	if (!APC_Queued)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "No compatible thread found\n");

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_QUAPC_ERR_NO_THREADS;
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	SR_REMOTE_DATA_WOW64 data{ };
	data.State			= (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	auto Timer = GetTickCount64();
	while (GetTickCount64() - Timer < Timeout)
	{
		auto dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet)
		{
			if (data.State == (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished)
			{
				LOG(2, "Shelldata retrieved\n");

				break;
			}
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");

				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}

			if (bRet && data.State == (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionPending)
			{
				data.State = (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished;
				WriteProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
			}

			return SR_QUAPC_ERR_RPM_FAIL;
		}
	}

	if (data.State != (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shell timed out\n");

		return SR_QUAPC_ERR_REMOTE_TIMEOUT;
	}

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out = data.Ret;

	return SR_ERR_SUCCESS;
}

#endif
```

`GH Injector Library/QueueUserAPC.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Start Routine.h"

DWORD SR_QueueUserAPC(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_QueueUserAPC\n");

	/*
		void __stdcall UserAPC_Shell(ULONG_PTR Parameter)
		{
			SR_REMOTE_DATA * data = ReCa<SR_REMOTE_DATA *>(Parameter);

			if (data != nullptr)
			{
				if (data->State == SR_REMOTE_STATE::SR_RS_ExecutionPending)
				{
					data->State = SR_REMOTE_STATE::SR_RS_Executing;

					data->Ret = data->pRoutine(data->pArg);
					data->LastWin32Error = GetLastError();

					data->State = SR_REMOTE_STATE::SR_RS_ExecutionFinished;
				}
			}
		}
	*/

#ifdef _WIN64

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x48, 0x85, 0xC9,										// + 0x00	-> test	rcx, rcx				; check if pData is valid
		0x74, 0x32,												// + 0x03	-> je	0x37					; jmp to ret if not

		0x53,													// + 0x05	-> push rbx						; push rbx on stack (non volatile)
		0x48, 0x8B, 0xD9,										// + 0x06	-> mov	rbx, rcx				; store pArg in rbx
		0x80, 0x3B, 0x00,										// + 0x09	-> cmp	byte ptr [rbx], 0		; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x75, 0x28,												// + 0x0C	-> jne	0x3C					; jump if not equal

		0xC6, 0x03, 0x01,										// + 0x0E	-> mov	byte ptr [rbx], 1		; set SR_REMOTE_DATA::State to SR_RS_Executing

		0x48, 0x8B, 0x4B, 0x18,									// + 0x11	-> mov  rcx, [rbx + 0x18]		; move pArg into rcx
		0x48, 0x83, 0xEC, 0x20,									// + 0x15	-> sub	rsp, 0x20				; reserve stack
		0xFF, 0x53, 0x20,										// + 0x19	-> call qword ptr [rbx + 0x20]	; call pRoutine
		0x48, 0x83, 0xC4, 0x20,									// + 0x1C	-> add	rsp, 0x20				; update stack
		0x48, 0x89, 0x43, 0x08,									// + 0x20	-> mov	[rbx + 0x08], rax		; store returned value

		0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00,	// + 0x24	-> mov	rax, gs:[0x30]			; GetLastError
		0x8B, 0x40, 0x68,										// + 0x2D	-> mov	eax, [rax + 0x68]
		0x89, 0x43, 0x10,										// + 0x30	-> mov	[rbx + 0x10], eax		; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,										// + 0x33	-> mov	byte ptr [rbx], 2		; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,													// + 0x36	-> pop	rbx						; restore rbx

		0xC3													// + 0x37	-> ret							; return
	}; // SIZE = 0x38 (+ sizeof(SR_REMOTE_DATA))

#else

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x55,								// + 0x00	-> push	ebp					; x86 stack frame creation
		0x89, 0xE5,							// + 0x01	-> mov	ebp, esp

		0x53,								// + 0x03	-> push	ebx					; push ebx on stack (non volatile)
		0x8B, 0x5D, 0x08,					// + 0x04	-> mov	ebx, [ebp + 0x08]	; store pData in ebx
		0x85, 0xDB,							// + 0x07	-> test	ebx, ebx			; check if pData is valid
		0x74, 0x20,							// + 0x09	-> je	0x2B				; jump if nullptr

		0x83, 0x3B, 0x00,					// + 0x0B	-> cmp	dword ptr [ebx], 0	; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x75, 0x1B,							// + 0x0E	-> jne	0x2B				; jump if not equal

		0xC6, 0x03, 0x01,					// + 0x10	-> mov	byte ptr [ebx], 1	; set SR_REMOTE_DATA::State to SR_RS_Executing

		0xFF, 0x73, 0x0C,					// + 0x13	-> push	[ebx + 0x0C]		; push pArg
		0xFF, 0x53, 0x10,					// + 0x16	-> call	[ebx + 0x10]		; call pRoutine
		0x89, 0x43, 0x04,					// + 0x19	-> mov	[ebx + 0x04], eax	; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,	// + 0x1C	-> mov	eax, fs:[0x18]		; GetLastError
		0x8B, 0x40, 0x34,					// + 0x22	-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,					// + 0x25	-> mov	[ebx + 0x08], eax	; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,					// + 0x28	-> mov	byte ptr [ebx], 2	; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,								// + 0x2B	-> pop	ebx					; restore ebx

		0x5D,								// + 0x2C	-> pop	ebp					; x86 __stdcall epilogue
		0xC2, 0x04, 0x00					// + 0x2D	-> ret	0x04
	}; // SIZE = 0x30 (+ sizeof(SR_REMOTE_DATA))

#endif

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, sizeof(Shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		return SR_QUAPC_ERR_CANT_ALLOC_MEM;
	}

	void * pRemoteFunc = ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA);

	auto * sr_data = ReCa<SR_REMOTE_DATA *>(Shellcode);
	sr_data->pArg		= pArg;
	sr_data->pRoutine	= pRoutine;

	LOG(2, "Codecave allocated at %p\n", pMem);

	BOOL bRet = WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr);
	if (!bRet)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_QUAPC_ERR_WPM_FAIL;
	}

	LOG(2, "Queueing APCs with:\n");
	LOG(3, "pRoutine = %p\n", pRemoteFunc);
	LOG(3, "pArg     = %p\n", pMem);

	ProcessInfo PI;
	if (!PI.SetProcess(hTargetProc))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Can't initialize ProcessInfo class\n");

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_QUAPC_ERR_PROC_INFO_FAIL;
	}
	
	bool APC_Queued = false;

	do
	{
		KWAIT_REASON reason;
		KTHREAD_STATE state;
		if (!PI.GetThreadState(state, reason) || reason == KWAIT_REASON::WrQueue)
		{
			continue;
		}
		
		if ((!PI.IsThreadWorkerThread() && (PI.IsThreadInAlertableState() || state == KTHREAD_STATE::Running)) && PI.GetThreadId() != GetCurrentThreadId())
		{
			DWORD ThreadID = PI.GetThreadId();
			HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, ThreadID);
			if (!hThread)
			{
				continue;
			}

			if (QueueUserAPC(ReCa<PAPCFUNC>(pRemoteFunc), hThread, ReCa<ULONG_PTR>(pMem)))
			{
				LOG(2, "APC queued to thread %06X\n", ThreadID);

				PostThreadMessageW(ThreadID, WM_NULL, 0, 0);
				APC_Queued = true;
			}

			CloseHandle(hThread);
		}
	}
	while (PI.NextThread());

	if (!APC_Queued)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "No compatible thread found\n");

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_QUAPC_ERR_NO_THREADS;
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	SR_REMOTE_DATA data{ };
	data.State			= SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	auto Timer = GetTickCount64();
	while (GetTickCount64() - Timer < Timeout)
	{
		auto dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet)
		{
			if (data.State == SR_REMOTE_STATE::SR_RS_ExecutionFinished)
			{
				LOG(2, "Shelldata retrieved\n");

				break;
			}
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");

				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}

			if (bRet && data.State == SR_REMOTE_STATE::SR_RS_ExecutionPending)
			{
				data.State = SR_REMOTE_STATE::SR_RS_ExecutionFinished;
				WriteProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
			}

			return SR_QUAPC_ERR_RPM_FAIL;
		}
	}

	if (data.State != SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shell timed out\n");

		return SR_QUAPC_ERR_REMOTE_TIMEOUT;
	}

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out	= data.Ret;
		
	return SR_ERR_SUCCESS;
}
```

`GH Injector Library/SetWindowsHookEx WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Start Routine.h"

DWORD SR_SetWindowsHookEx_WOW64(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, ULONG TargetSessionId, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_SetWindowsHookEx_WOW64\n");

	std::wstring InfoPath = g_RootPathW + SM_INFO_FILENAME86;

	if (FileExistsW(InfoPath))
	{
		DeleteFileW(InfoPath.c_str());
	}

	std::wofstream swhex_info(InfoPath, std::ios_base::out | std::ios_base::app);
	if (!swhex_info.good())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to create info file\n");

		return SR_SWHEX_ERR_CANT_OPEN_INFO_TXT;
	}

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		swhex_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_SWHEX_ERR_CANT_ALLOC_MEM;
	}

	LOG(2, "Codecave allocated at %p\n", pMem);

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER_86

		0x53,								// + 0x00			-> push	ebx						; push ebx on stack (non volatile)
		0xBB, 0x00, 0x00, 0x00, 0x00,		// + 0x01 (+ 0x02)	-> mov	ebx, 0x00000000			; move pData into ebx (update address manually on runtime)
		0x83, 0x3B, 0x00,					// + 0x06			-> cmp	dword ptr [ebx], 0		; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x75, 0x1B,							// + 0x09			-> jne	0x26					; jump if not equal

		0xC6, 0x03, 0x01,					// + 0x0B			-> mov	byte ptr [ebx], 1		; set SR_REMOTE_DATA::State to SR_RS_Executing

		0xFF, 0x73, 0x0C,					// + 0x0E			-> push	[ebx + 0x0C]			; push pArg
		0xFF, 0x53, 0x10,					// + 0x11			-> call dword ptr [ebx + 0x10]	; call pRoutine
		0x89, 0x43, 0x04,					// + 0x14			-> mov	[ebx + 0x04], eax		; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,	// + 0x17			-> mov	eax, fs:[0x18]			; GetLastError
		0x8B, 0x40, 0x34,					// + 0x1D			-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,					// + 0x20			-> mov	[ebx + 0x08], eax		; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,					// + 0x23			-> mov	byte ptr [ebx], 2		; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,								// + 0x26			-> pop	ebx						; restore ebx
		0x31, 0xC0,							// + 0x27			-> xor	eax, eax				; set eax to 0 to prevent further handling of the message
		0xC2, 0x0C, 0x00					// + 0x29			-> ret	0x0C					; return
	}; // SIZE = 0x2C (+ sizeof(SR_REMOTE_DATA_WOW64))

	*ReCa<DWORD *>(Shellcode + 0x02 + sizeof(SR_REMOTE_DATA_WOW64)) = MDWD(pMem);

	void * pRemoteFunc = ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA_WOW64);

	auto * sr_data = ReCa<SR_REMOTE_DATA_WOW64 *>(Shellcode);
	sr_data->pArg		= pArg;
	sr_data->pRoutine	= pRoutine;

	if (!WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
		swhex_info.close();

		return SR_SWHEX_ERR_WPM_FAIL;
	}

	LOG(2, "Hook will be called with:\n");
	LOG(3, "pRoutine = %08X\n", MDWD(pRemoteFunc));
	LOG(3, "pArg     = %08X\n", MDWD(pMem));

	swhex_info << std::dec << GetProcessId(hTargetProc) << '!' << std::hex << MDWD(pRemoteFunc) << std::endl;
	swhex_info.close();

	std::wstring smPath = g_RootPathW + SM_EXE_FILENAME86;

	wchar_t cmdLine[] = L"\"" SM_EXE_FILENAME86 "\" " ID_SWHEX;

	PROCESS_INFORMATION pi{ 0 };
	STARTUPINFOW		si{ 0 };
	si.cb			= sizeof(si);
	si.dwFlags		= STARTF_USESHOWWINDOW;
	si.wShowWindow	= SW_HIDE;

	LOG(2, "Data and command line prepared\n");

	if (TargetSessionId != SESSION_ID_INVALID)
	{
		LOG(2, "Target process is in a different session\n");

		HANDLE hUserToken = nullptr;
		if (!WTSQueryUserToken(TargetSessionId, &hUserToken))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "WTSQueryUserToken failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_SWHEX_ERR_WTSQUERY_FAIL;
		}

		HANDLE hNewToken = nullptr;
		if (!DuplicateTokenEx(hUserToken, MAXIMUM_ALLOWED, nullptr, SecurityIdentification, TokenPrimary, &hNewToken))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "DuplicateTokenEx failed: %08X\n", error_data.AdvErrorCode);

			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_SWHEX_ERR_DUP_TOKEN_FAIL;
		}

		DWORD SizeOut = 0;
		TOKEN_LINKED_TOKEN admin_token{ 0 };
		if (!GetTokenInformation(hNewToken, TokenLinkedToken, &admin_token, sizeof(admin_token), &SizeOut))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "GetTokenInformation failed: %08X\n", error_data.AdvErrorCode);

			CloseHandle(hNewToken);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_SWHEX_ERR_GET_ADMIN_TOKEN_FAIL;
		}

		HANDLE hAdminToken = admin_token.LinkedToken;

		LOG(2, "Token prepared\n");

		LOG(2, "Launching %ls:\n       command line = %ls\n", SM_EXE_FILENAME86, cmdLine);

		if (!CreateProcessAsUserW(hAdminToken, smPath.c_str(), cmdLine, nullptr, nullptr, FALSE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "CreateProcessAsUserW failed: %08X\n", error_data.AdvErrorCode);

			CloseHandle(hAdminToken);
			CloseHandle(hNewToken);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_SWHEX_ERR_CANT_CREATE_PROCESS;
		}

		LOG(2, "%ls launched\n", SM_EXE_FILENAME86);

		CloseHandle(hAdminToken);
		CloseHandle(hNewToken);
		CloseHandle(hUserToken);
	}
	else
	{
		LOG(2, "Launching %ls:\n       command line = %ls\n", SM_EXE_FILENAME86, cmdLine);

		if (!CreateProcessW(smPath.c_str(), cmdLine, nullptr, nullptr, FALSE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "CreateProcessW failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

			return SR_SWHEX_ERR_CANT_CREATE_PROCESS;
		}

		LOG(2, "%ls launched\n", SM_EXE_FILENAME86);
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	auto Timer = GetTickCount64();

	DWORD dwWaitRet = WaitForSingleObject(pi.hProcess, Timeout);
	if (dwWaitRet != WAIT_OBJECT_0)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "%ls timed out: %08X\n", SM_EXE_FILENAME86, error_data.AdvErrorCode);

		TerminateProcess(pi.hProcess, 0);

		return SR_SWHEX_ERR_SWHEX_TIMEOUT;
	}

	DWORD ExitCode = 0;
	GetExitCodeProcess(pi.hProcess, &ExitCode);

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	if (ExitCode != SWHEX_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, ExitCode);

		LOG(2, "%ls failed: %08X\n", SM_EXE_FILENAME86, ExitCode);
		
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
		
		return ExitCode;
	}

	SR_REMOTE_DATA_WOW64 data{ };
	data.State			= (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	while (GetTickCount64() - Timer < Timeout)
	{
		dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		BOOL bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet && data.State == (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished)
		{
			LOG(2, "Shelldata retrieved\n");

			break;
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}

			if (bRet && data.State != (DWORD)SR_REMOTE_STATE::SR_RS_Executing)
			{
				VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			}

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}

			return SR_SWHEX_ERR_RPM_FAIL;
		}
	}

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	if (data.State != (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shell timed out\n");

		return SR_SWHEX_ERR_REMOTE_TIMEOUT;
	}

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out	= data.Ret;

	return SR_ERR_SUCCESS;
}

#endif
```

`GH Injector Library/SetWindowsHookEx.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Start Routine.h"

DWORD SR_SetWindowsHookEx(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, ULONG TargetSessionId, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_SetWindowsHookEx\n");

	std::wstring InfoPath = g_RootPathW;
	InfoPath += SM_INFO_FILENAME;
		
	if (FileExistsW(InfoPath))
	{
		DeleteFileW(InfoPath.c_str());
	}

	std::wofstream swhex_info(InfoPath, std::ios_base::out | std::ios_base::app);
	if (!swhex_info.good())
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Failed to create info file\n");

		return SR_SWHEX_ERR_CANT_OPEN_INFO_TXT;
	}

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		swhex_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_SWHEX_ERR_CANT_ALLOC_MEM;
	}

	LOG(2, "Codecave allocated at %p\n", pMem);
	
	/*
		LRESULT __stdcall Hookproc_Shell(int code, WPARAM wParam, LPARAM lParam)
		{
			UNREFERENCED_PARAMETER(code);
			UNREFERENCED_PARAMETER(wParam);
			UNREFERENCED_PARAMETER(lParam);

			SR_REMOTE_DATA * data = ReCa<SR_REMOTE_DATA *>(ReCa<BYTE *>(Hookproc_Shell) - sizeof(SR_REMOTE_DATA));
			if (data->State == SR_REMOTE_STATE::SR_RS_ExecutionPending)
			{
				data->State = SR_REMOTE_STATE::SR_RS_Executing;
				
				data->Ret = data->pRoutine(data->pArg);
				data->LastWin32Error = GetLastError();

				data->State = SR_REMOTE_STATE::SR_RS_ExecutionFinished;
			}

			return 0;
		}
	*/

#ifdef _WIN64
	
	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x53,													// + 0x00	-> push rbx						; push rbx on stack (non volatile)
		0x48, 0x8D, 0x1D, 0xC8, 0xFF, 0xFF, 0xFF,				// + 0x01	-> lea rbx, [-0x30]				; load pData into rbx

		0x80, 0x3B, 0x00,										// + 0x08	-> cmp	byte ptr [rbx], 0		; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x75, 0x28,												// + 0x0B	-> jne	0x35					; jump if not equal

		0xC6, 0x03, 0x01,										// + 0x0D	-> mov	byte ptr [rbx], 1		; set SR_REMOTE_DATA::State to SR_RS_Executing

		0x48, 0x8B, 0x4B, 0x18,									// + 0x10	-> mov  rcx, [rbx + 0x18]		; move pArg into rcx
		0x48, 0x83, 0xEC, 0x20,									// + 0x14	-> sub	rsp, 0x20				; reserve stack
		0xFF, 0x53, 0x20,										// + 0x18	-> call qword ptr [rbx + 0x20]	; call pRoutine
		0x48, 0x83, 0xC4, 0x20,									// + 0x1B	-> add	rsp, 0x20				; update stack
		0x48, 0x89, 0x43, 0x08,									// + 0x1F	-> mov	[rbx + 0x08], rax		; store returned value

		0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00,	// + 0x23	-> mov	rax, gs:[0x30]			; GetLastError
		0x8B, 0x40, 0x68,										// + 0x2C	-> mov	eax, [rax + 0x68]
		0x89, 0x43, 0x10,										// + 0x2F	-> mov	[rbx + 0x10], eax		; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,										// + 0x32	-> mov	byte ptr [rbx], 2		; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,													// + 0x35	-> pop	rbx						; restore rbx

		0x48, 0x31, 0xC0,										// + 0x36	-> xor	rax, rax				; set rax to 0 to prevent further handling of the message

		0xC3													// + 0x39	-> ret							; return
	}; // SIZE = 0x3A (+ sizeof(SR_REMOTE_DATA))
	
#else

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x53,								// + 0x00			-> push	ebx						; push ebx on stack (non volatile)
		0xBB, 0x00, 0x00, 0x00, 0x00,		// + 0x01 (+ 0x02)	-> mov	ebx, 0x00000000			; move pData into ebx (update address manually on runtime)
		0x83, 0x3B, 0x00,					// + 0x06			-> cmp	dword ptr [ebx], 0		; test if SR_REMOTE_DATA::State is equal to SR_RS_ExecutionPending
		0x75, 0x1B,							// + 0x09			-> jne	0x26					; jump if not equal

		0xC6, 0x03, 0x01,					// + 0x0B			-> mov	byte ptr [ebx], 1		; set SR_REMOTE_DATA::State to SR_RS_Executing

		0xFF, 0x73, 0x0C,					// + 0x0E			-> push	[ebx + 0x0C]			; push pArg
		0xFF, 0x53, 0x10,					// + 0x11			-> call dword ptr [ebx + 0x10]	; call pRoutine
		0x89, 0x43, 0x04,					// + 0x14			-> mov	[ebx + 0x04], eax		; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,	// + 0x17			-> mov	eax, fs:[0x18]			; GetLastError
		0x8B, 0x40, 0x34,					// + 0x1D			-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,					// + 0x20			-> mov	[ebx + 0x08], eax		; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,					// + 0x23			-> mov	byte ptr [ebx], 2		; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,								// + 0x26			-> pop	ebx						; restore ebx
		0x31, 0xC0,							// + 0x27			-> xor	eax, eax				; set eax to 0 to prevent further handling of the message
		0xC2, 0x0C, 0x00					// + 0x29			-> ret	0x0C					; return
	}; // SIZE = 0x2C (+ sizeof(SR_REMOTE_DATA))

	*ReCa<void **>(Shellcode + 0x02 + sizeof(SR_REMOTE_DATA)) = pMem;

#endif
	
	void * pRemoteFunc = ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA);

	auto * sr_data = ReCa<SR_REMOTE_DATA *>(Shellcode);
	sr_data->pArg		= pArg;
	sr_data->pRoutine	= pRoutine;

	if (!WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		swhex_info.close();
		DeleteFileW(InfoPath.c_str());

		return SR_SWHEX_ERR_WPM_FAIL;
	}

	LOG(2, "Hook will be called with:\n");
	LOG(3, "pRoutine = %p\n", pRemoteFunc);
	LOG(3, "pArg     = %p\n", pMem);

	swhex_info << std::dec << GetProcessId(hTargetProc) << '!' << std::hex << ReCa<ULONG_PTR>(pRemoteFunc) << std::endl;
	swhex_info.close();

	std::wstring smPath = g_RootPathW + SM_EXE_FILENAME;

	wchar_t cmdLine[] = L"\"" SM_EXE_FILENAME "\" " ID_SWHEX;

	PROCESS_INFORMATION pi{ 0 };
	STARTUPINFOW		si{ 0 };
	si.cb			= sizeof(si);
	si.dwFlags		= STARTF_USESHOWWINDOW;
	si.wShowWindow	= SW_HIDE;

	LOG(2, "Data and command line prepared\n");

	if (TargetSessionId != SESSION_ID_INVALID)
	{
		LOG(2, "Target process is in a different session\n");

		HANDLE hUserToken = nullptr;
		if (!WTSQueryUserToken(TargetSessionId, &hUserToken))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "WTSQueryUserToken failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_SWHEX_ERR_WTSQUERY_FAIL;
		}

		HANDLE hNewToken = nullptr;
		if (!DuplicateTokenEx(hUserToken, MAXIMUM_ALLOWED, nullptr, SecurityIdentification, TokenPrimary, &hNewToken))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "DuplicateTokenEx failed: %08X\n", error_data.AdvErrorCode);

			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_SWHEX_ERR_DUP_TOKEN_FAIL;
		}

		DWORD SizeOut = 0;
		TOKEN_LINKED_TOKEN admin_token{ 0 };
		if (!GetTokenInformation(hNewToken, TokenLinkedToken, &admin_token, sizeof(admin_token), &SizeOut))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "GetTokenInformation failed: %08X\n", error_data.AdvErrorCode);

			CloseHandle(hNewToken);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_SWHEX_ERR_GET_ADMIN_TOKEN_FAIL;
		}

		HANDLE hAdminToken = admin_token.LinkedToken;

		LOG(2, "Token prepared\n");

		LOG(2, "Launching %ls:\n       command line = %ls\n", SM_EXE_FILENAME, cmdLine);

		if (!CreateProcessAsUserW(hAdminToken, smPath.c_str(), cmdLine, nullptr, nullptr, FALSE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "CreateProcessAsUserW failed: %08X\n", error_data.AdvErrorCode);

			CloseHandle(hAdminToken);
			CloseHandle(hNewToken);
			CloseHandle(hUserToken);
			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_SWHEX_ERR_CANT_CREATE_PROCESS;
		}

		LOG(2, "%ls launched\n", SM_EXE_FILENAME);

		CloseHandle(hAdminToken);
		CloseHandle(hNewToken);
		CloseHandle(hUserToken);
	}
	else
	{
		LOG(2, "Launching %ls:\n       command line = %ls\n", SM_EXE_FILENAME, cmdLine);

		if (!CreateProcessW(smPath.c_str(), cmdLine, nullptr, nullptr, FALSE, CREATE_NO_WINDOW, nullptr, nullptr, &si, &pi))
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			LOG(2, "CreateProcessW failed: %08X\n", error_data.AdvErrorCode);

			VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			DeleteFileW(InfoPath.c_str());

			return SR_SWHEX_ERR_CANT_CREATE_PROCESS;
		}

		LOG(2, "%ls launched\n", SM_EXE_FILENAME);
	}

	LOG(2, "Entering wait state\n");

	Sleep(SR_REMOTE_DELAY);

	auto Timer = GetTickCount64();

	HANDLE handles[] = { pi.hProcess, g_hInterruptEvent };

	DWORD dwWaitRet = WaitForMultipleObjects(2, handles, FALSE, Timeout);
	if (dwWaitRet != WAIT_OBJECT_0)
	{
		if (dwWaitRet == (WAIT_OBJECT_0 + 1))
		{
			INIT_ERROR_DATA(error_data, dwWaitRet);

			LOG(2, "Interrupt!\n");
		}
		else
		{
			if (dwWaitRet == WAIT_FAILED)
			{
				INIT_ERROR_DATA(error_data, GetLastError());
			}
			else
			{
				INIT_ERROR_DATA(error_data, dwWaitRet);
			}

			LOG(2, "%ls timed out: %08X\n", SM_EXE_FILENAME, error_data.AdvErrorCode);
		}

		TerminateProcess(pi.hProcess, 0);
		DeleteFileW(InfoPath.c_str());

		if (dwWaitRet == (WAIT_OBJECT_0 + 1))
		{
			SetEvent(g_hInterruptedEvent);

			return SR_ERR_INTERRUPT;
		}

		return SR_SWHEX_ERR_SWHEX_TIMEOUT;
	}

	DWORD ExitCode = 0;
	GetExitCodeProcess(pi.hProcess, &ExitCode);

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	DeleteFileW(InfoPath.c_str());

	if (ExitCode != SWHEX_ERR_SUCCESS)
	{
		INIT_ERROR_DATA(error_data, ExitCode);

		LOG(2, "%ls failed: %08X\n", SM_EXE_FILENAME, ExitCode);

		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return ExitCode;
	}
	
	SR_REMOTE_DATA data{ };
	data.State			= SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	while (GetTickCount64() - Timer < Timeout)
	{
		dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		BOOL bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet && data.State == SR_REMOTE_STATE::SR_RS_ExecutionFinished)
		{
			LOG(2, "Shelldata retrieved\n");

			break;
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}

			if (bRet && data.State != SR_REMOTE_STATE::SR_RS_Executing)
			{
				VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
			}

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}

			return SR_SWHEX_ERR_RPM_FAIL;
		}
	}

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	if (data.State != SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Shell timed out\n");

		return SR_SWHEX_ERR_REMOTE_TIMEOUT;
	}

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out = data.Ret;

	return SR_ERR_SUCCESS;
}
```

`GH Injector Library/Start Routine WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Start Routine.h"

DWORD StartRoutine_WOW64(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, LAUNCH_METHOD Method, DWORD Flags, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	DWORD Ret = 0;
	
	switch (Method)
	{
		case LAUNCH_METHOD::LM_NtCreateThreadEx:
			Ret = SR_NtCreateThreadEx_WOW64(hTargetProc, pRoutine, pArg, Flags, Out, Timeout, error_data);
			break;

		case LAUNCH_METHOD::LM_HijackThread:
			Ret = SR_HijackThread_WOW64(hTargetProc, pRoutine, pArg, Out, Timeout, error_data);
			break;

		case LAUNCH_METHOD::LM_SetWindowsHookEx:
		case LAUNCH_METHOD::LM_KernelCallback:
		{
			NTSTATUS ntRet = 0;
			ULONG OwnSession	= GetSessionId(GetCurrentProcess(), ntRet);
			ULONG TargetSession = GetSessionId(hTargetProc, ntRet);

			if (TargetSession == SESSION_ID_INVALID)
			{
				INIT_ERROR_DATA(error_data, (DWORD)ntRet);

				Ret = SR_ERR_CANT_QUERY_SESSION_ID;
				break;
			}
			else if (OwnSession != SESSION_ID_LOCAL_SYSTEM && OwnSession != TargetSession)
			{
				INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

				Ret = SR_ERR_NOT_LOCAL_SYSTEM;
				break;
			}
			else if (TargetSession == OwnSession)
			{
				TargetSession = SESSION_ID_INVALID;
			}

			if (Method == LAUNCH_METHOD::LM_SetWindowsHookEx)
			{
				Ret = SR_SetWindowsHookEx_WOW64(hTargetProc, pRoutine, pArg, TargetSession, Out, Timeout, error_data);
			}
			else
			{
				Ret = SR_KernelCallback_WOW64(hTargetProc, pRoutine, pArg, TargetSession, Out, Timeout, error_data);
			}
			
			break;
		}
		
		case LAUNCH_METHOD::LM_QueueUserAPC:
			Ret = SR_QueueUserAPC_WOW64(hTargetProc, pRoutine, pArg, Out, Timeout, error_data);
			break;

		case LAUNCH_METHOD::LM_FakeVEH:
			Ret = SR_FakeVEH_WOW64(hTargetProc, pRoutine, pArg, Out, Timeout, error_data);
			break;

		default:
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			Ret = SR_ERR_INVALID_LAUNCH_METHOD;
			break;
	}
	
	return Ret;
}

#endif
```

`GH Injector Library/Start Routine.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Start Routine.h"

DWORD StartRoutine(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, LAUNCH_METHOD Method, DWORD Flags, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	DWORD Ret = 0;
	
	switch (Method)
	{
		case LAUNCH_METHOD::LM_NtCreateThreadEx:
			Ret = SR_NtCreateThreadEx(hTargetProc, pRoutine, pArg, Flags, Out, Timeout, error_data);
			break;

		case LAUNCH_METHOD::LM_HijackThread:
			Ret = SR_HijackThread(hTargetProc, pRoutine, pArg, Out, Timeout, error_data);
			break;

		case LAUNCH_METHOD::LM_SetWindowsHookEx:
		case LAUNCH_METHOD::LM_KernelCallback:
		{
			NTSTATUS ntRet = 0;
			ULONG OwnSession	= GetSessionId(GetCurrentProcess(), ntRet);
			ULONG TargetSession = GetSessionId(hTargetProc, ntRet);

			if (TargetSession == SESSION_ID_INVALID)
			{
				INIT_ERROR_DATA(error_data, (DWORD)ntRet);

				Ret = SR_ERR_CANT_QUERY_SESSION_ID;
				break;
			}
			else if (OwnSession != SESSION_ID_LOCAL_SYSTEM && OwnSession != TargetSession)
			{
				INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

				Ret = SR_ERR_NOT_LOCAL_SYSTEM;
				break;
			}
			else if (OwnSession == TargetSession)
			{
				TargetSession = SESSION_ID_INVALID;
			}

			if (Method == LAUNCH_METHOD::LM_SetWindowsHookEx)
			{
				Ret = SR_SetWindowsHookEx(hTargetProc, pRoutine, pArg, TargetSession, Out, Timeout, error_data);
			}
			else
			{
				Ret = SR_KernelCallback(hTargetProc, pRoutine, pArg, TargetSession, Out, Timeout, error_data);
			}

			break;
		}

		case LAUNCH_METHOD::LM_QueueUserAPC:
			Ret = SR_QueueUserAPC(hTargetProc, pRoutine, pArg, Out, Timeout, error_data);
			break;

		case LAUNCH_METHOD::LM_FakeVEH:
			Ret = SR_FakeVEH(hTargetProc, pRoutine, pArg, Out, Timeout, error_data);
			break;
		
		default:
			INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

			Ret = SR_ERR_INVALID_LAUNCH_METHOD;
			break;
	}
		
	return Ret;
}
```

`GH Injector Library/Start Routine.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "Process Info.h"
#include "Tools.h"

//Thread creation options:
#define INJ_CTF_FAKE_START_ADDRESS	0x00001000
#define INJ_CTF_HIDE_FROM_DEBUGGER	0x00002000
#define INJ_CTF_SKIP_THREAD_ATTACH	0x00004000
#define INJ_CTF_FAKE_TEB_CLIENT_ID	0x00008000
#define CTF_MASK (INJ_CTF_FAKE_START_ADDRESS | INJ_CTF_HIDE_FROM_DEBUGGER | INJ_CTF_SKIP_THREAD_ATTACH | INJ_CTF_FAKE_TEB_CLIENT_ID)

#define TEB_CLIENTID_64 0x40
#define TEB_CLIENTID_86 0x20

#ifdef _WIN64
#define TEB_CLIENTID TEB_CLIENTID_64
#else
#define TEB_CLIENTID TEB_CLIENTID_86
#endif

enum class SR_REMOTE_STATE : ULONG_PTR
{
	SR_RS_ExecutionPending	= 0,
	SR_RS_Executing			= 1,
	SR_RS_ExecutionFinished	= 2
};
//enum which is used to determine the state of the remote code

#ifdef _WIN64
using f_Routine			= DWORD(__fastcall *)(void * pArg);
using f_Routine_WOW64	= DWORD; //DWORD(__stdcall *)(void * pArg);
#else
using f_Routine = DWORD(__stdcall *)(void * pArg);
#endif

#define SR_REMOTE_DELAY 50
//small waiting period before checking remote results, probably not necessary

#define KERNEL_CALLBACK_TABLE_SIZE 200

ALIGN struct SR_REMOTE_DATA
{
	ALIGN SR_REMOTE_STATE	State			= SR_REMOTE_STATE::SR_RS_ExecutionPending;
	ALIGN DWORD				Ret				= 0;
	ALIGN DWORD				LastWin32Error	= 0;
	ALIGN void *			pArg			= nullptr;
	ALIGN f_Routine			pRoutine		= nullptr;
	ALIGN UINT_PTR			Buffer			= 0;
};

ALIGN struct SR_REMOTE_DATA_VEH
{
	SR_REMOTE_DATA Data{ };

	ALIGN f_LdrProtectMrdata	pLdrProtectMrdata	= nullptr;
	ALIGN LIST_ENTRY	*		pListHead			= nullptr;
	ALIGN LIST_ENTRY	*		pFakeEntry			= nullptr;
	ALIGN bool					bRemoveVEHBit		= false;
};

#define PTR_64_ARR 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#define PTR_86_ARR 0x00, 0x00, 0x00, 0x00,

#define SR_REMOTE_DATA_BUFFER_64 PTR_64_ARR PTR_64_ARR PTR_64_ARR PTR_64_ARR PTR_64_ARR PTR_64_ARR
#define SR_REMOTE_DATA_BUFFER_86 PTR_86_ARR PTR_86_ARR PTR_86_ARR PTR_86_ARR PTR_86_ARR PTR_86_ARR

#define SR_REMOTE_DATA_BUFFER_VEH_64 SR_REMOTE_DATA_BUFFER_64 PTR_64_ARR PTR_64_ARR PTR_64_ARR PTR_64_ARR
#define SR_REMOTE_DATA_BUFFER_VEH_86 SR_REMOTE_DATA_BUFFER_86 PTR_86_ARR PTR_86_ARR PTR_86_ARR PTR_86_ARR

#ifdef _WIN64
	#define SR_REMOTE_DATA_BUFFER SR_REMOTE_DATA_BUFFER_64
	#define SR_REMOVE_DATA_BUFFER_VEH SR_REMOTE_DATA_BUFFER_VEH_64
#else
	#define SR_REMOTE_DATA_BUFFER SR_REMOTE_DATA_BUFFER_86
	#define SR_REMOVE_DATA_BUFFER_VEH SR_REMOTE_DATA_BUFFER_VEH_86
#endif

DWORD StartRoutine(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, LAUNCH_METHOD Method, DWORD Flags, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
//Executes shellcode in the target process.
//
//Arguments:
//		hTargetProc (HANDLE):
///			A handle to the target process. Access rights depend on the launch method. PROCESS_ALL_ACCESS is the best option here.
//		pRoutine (f_Routine):
///			A pointer to the shellcode in the virtual memory of the target process.
//		pArg (void *):
///			A pointer to the argument which gets passed to the shellcode.
//		Method (LAUNCH_METHOD):
///			A LAUNCH_METHOD enum which defines the method to be used when executing the shellcode.
//		Flags (DWORD):
///			The injection flags contain cloaking options for NtCreateThreadEx.
//		LastWin32Error (DWORD &):
///			A reference to a DWORD which can be used to store an errorcode if something goes wrong. Otherwise it's INJ_ERROR_SUCCESS (0).
//		hOut (ULONG_PTR &):
///			A reference to a ULONG_PTR which is used to store the returned value of the shellcode. This can be changed into any datatype (a 32 bit type on x86 and a 64 bit type on x64).
//		Timeout (DWORD):
///			The time the method waits for the shellcode to finish executing in milliseconds.
//
//Returnvalue (DWORD):
///		On success: 0 (INJ_ERR_SUCCESS).
///		On failure:	An errorcode from Error.h (start routine section).

DWORD SR_NtCreateThreadEx	(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, DWORD Flags,				DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_HijackThread		(HANDLE hTargetProc, f_Routine pRoutine, void * pArg,							DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_SetWindowsHookEx	(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, ULONG TargetSessionId,	DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_QueueUserAPC		(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, 							DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_KernelCallback		(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, ULONG TargetSessionId,	DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_FakeVEH			(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, 							DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
//Subroutines called by StartRoutine.

#ifdef _WIN64
ALIGN_86 struct SR_REMOTE_DATA_WOW64
{
	ALIGN_86 DWORD State			= 0;
	ALIGN_86 DWORD Ret				= 0;
	ALIGN_86 DWORD LastWin32Error	= 0;
	ALIGN_86 DWORD pArg				= 0;
	ALIGN_86 DWORD pRoutine			= 0;
	ALIGN_86 DWORD Buffer			= 0;
};

ALIGN_86 struct SR_REMOTE_DATA_VEH_WOW64
{
	SR_REMOTE_DATA_WOW64 Data{ };

	ALIGN_86 DWORD pLdrProtectMrdata	= 0;
	ALIGN_86 DWORD pListHead			= 0;
	ALIGN_86 DWORD pFakeEntry			= 0;
	ALIGN_86 DWORD bRemoveVEHBit		= 0;
};

#define SR_REMOTE_DATA_BUFFER_WOW64 SR_REMOTE_DATA_BUFFER_86

DWORD StartRoutine_WOW64(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, LAUNCH_METHOD Method, DWORD Flags, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
//Equivalent of StartRoutine when injecting from x64 into a WOW64 process. For documentation check the comments on StartRoutine.

DWORD SR_NtCreateThreadEx_WOW64	(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, DWORD Flags,				DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_HijackThread_WOW64		(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg,							DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_SetWindowsHookEx_WOW64	(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, ULONG TargetSessionId,	DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_QueueUserAPC_WOW64		(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg,							DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_KernelCallback_WOW64	(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, ULONG TargetSessionId,	DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
DWORD SR_FakeVEH_WOW64			(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg,							DWORD & Out, DWORD Timeout, ERROR_DATA & error_data);
//Subroutines called by StartRoutine_WOW64.
#endif
```

`GH Injector Library/Symbol Loader.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Symbol Loader.h"

SYMBOL_LOADER::SYMBOL_LOADER()
{
	m_hInterruptEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
}

SYMBOL_LOADER::~SYMBOL_LOADER()
{
	Cleanup();

	if (m_hInterruptEvent)
	{
		CloseHandle(m_hInterruptEvent);
	}
}

bool SYMBOL_LOADER::VerifyExistingPdb(const GUID & guid)
{
	LOG(2, "SYMBOL_LOADER::VerifyExistingPdb called\n");

	std::ifstream f(m_szPdbPath.c_str(), std::ios::binary | std::ios::ate);
	if (f.bad())
	{
		LOG(2, "SYMBOL_LOADER: failed to open PDB for verification\n");

		return false;
	}

	size_t size_on_disk = static_cast<size_t>(f.tellg());
	if (!size_on_disk)
	{
		f.close();

		LOG(2, "SYMBOL_LOADER: invaild file size\n");

		return false;
	}

	char * pdb_raw = new(std::nothrow) char[size_on_disk];
	if (!pdb_raw)
	{
		f.close();

		LOG(2, "SYMBOL_LOADER: failed to allocate memory\n");

		return false;
	}

	f.seekg(std::ios::beg);
	f.read(pdb_raw, size_on_disk);
	f.close();

	LOG(2, "SYMBOL_LOADER: PDB loaded into memory\n");

	if (size_on_disk < sizeof(PDBHeader7))
	{
		delete[] pdb_raw;

		LOG(2, "SYMBOL_LOADER: raw size smaller than PDBHeader7\n");

		return false;
	}

	auto * pPDBHeader = ReCa<PDBHeader7*>(pdb_raw);

	if (memcmp(pPDBHeader->signature, "Microsoft C/C++ MSF 7.00\r\n\x1A""DS\0\0\0", sizeof(PDBHeader7::signature)))
	{
		delete[] pdb_raw;

		LOG(2, "SYMBOL_LOADER: PDB signature mismatch\n");

		return false;
	}

	if (size_on_disk < (size_t)pPDBHeader->page_size * pPDBHeader->file_page_count)
	{
		delete[] pdb_raw;

		LOG(2, "SYMBOL_LOADER: PDB size smaller than page_size * page_count\n");

		return false;
	}

	LOG(2, "SYMBOL_LOADER: PDB size validated\n");

	int		* pRootPageNumber	= ReCa<int *>(pdb_raw + (size_t)pPDBHeader->root_stream_page_number_list_number * pPDBHeader->page_size);
	auto	* pRootStream		= ReCa<RootStream7 *>(pdb_raw + (size_t)(*pRootPageNumber) * pPDBHeader->page_size);

	std::map<int, std::vector<int>> streams;
	int current_page_number = 0;
	
	for (int i = 0; i != pRootStream->num_streams; ++i)
	{
		int current_size = pRootStream->stream_sizes[i] == 0xFFFFFFFF ? 0 : pRootStream->stream_sizes[i];

		int current_page_count = current_size / pPDBHeader->page_size;
		if (current_size % pPDBHeader->page_size)
		{
			++current_page_count;
		}

		std::vector<int> numbers;

		for (int j = 0; j != current_page_count; ++j, ++current_page_number)
		{
			numbers.push_back(pRootStream->stream_sizes[pRootStream->num_streams + current_page_number]);
		}

		streams.insert({ i, numbers });
	}


	LOG(2, "SYMBOL_LOADER: PDB size parsed\n");

	auto pdb_info_page_index = streams.at(1).at(0);

	auto * stream_data = ReCa<GUID_StreamData *>(pdb_raw + (size_t)(pdb_info_page_index) * pPDBHeader->page_size);

	int guid_eq = memcmp(&stream_data->guid, &guid, sizeof(GUID));

	delete[] pdb_raw;
	
	auto ret = (guid_eq == 0);

	if (ret)
	{
		LOG(2, "SYMBOL_LOADER: guid match\n");
	}
	else
	{
		LOG(2, "SYMBOL_LOADER: guid mismatch\n");
	}

	return ret;
}

DWORD SYMBOL_LOADER::Initialize(const std::wstring & szModulePath, const std::wstring & path, std::wstring * pdb_path_out, bool Redownload, bool WaitForConnection, bool AutoDownload)
{
	Cleanup();

	if (AutoDownload)
	{
		m_bStartDownload = true;
	}

	LOG(1, "SYMBOL_LOADER::Initialize called in thread %08X (%d)\n", GetCurrentThreadId(), GetCurrentThreadId());

	std::ifstream File(szModulePath.c_str(), std::ios::binary | std::ios::ate);
	if (!File.good())
	{
		LOG(1, "SYMBOL_LOADER: can't open module path\n");

		return SYMBOL_ERR_CANT_OPEN_MODULE;
	}

	auto FileSize = File.tellg();
	if (!FileSize)
	{
		LOG(1, "SYMBOL_LOADER: invalid file size\n");

		return SYMBOL_ERR_FILE_SIZE_IS_NULL;
	}

	BYTE * pRawData = new(std::nothrow) BYTE[static_cast<size_t>(FileSize)];
	if (!pRawData)
	{
		delete[] pRawData;

		File.close();

		LOG(1, "SYMBOL_LOADER: can't allocate memory\n");

		return SYMBOL_ERR_CANT_ALLOC_MEMORY_NEW;
	}

	File.seekg(0, std::ios::beg);
	File.read(ReCa<char *>(pRawData), FileSize);
	File.close();

	LOG(1, "SYMBOL_LOADER: ready to parse PE headers\n");

	IMAGE_DOS_HEADER	* pDos	= ReCa<IMAGE_DOS_HEADER *>(pRawData);
	IMAGE_NT_HEADERS	* pNT	= ReCa<IMAGE_NT_HEADERS *>(pRawData + pDos->e_lfanew);
	IMAGE_FILE_HEADER	* pFile = &pNT->FileHeader;

	IMAGE_OPTIONAL_HEADER64 * pOpt64 = nullptr;
	IMAGE_OPTIONAL_HEADER32 * pOpt32 = nullptr;

	bool x86 = false;

	if (pFile->Machine == IMAGE_FILE_MACHINE_AMD64)
	{
		pOpt64 = ReCa<IMAGE_OPTIONAL_HEADER64 *>(&pNT->OptionalHeader);

		LOG(1, "SYMBOL_LOADER: x64 target identified\n");
	}
	else if (pFile->Machine == IMAGE_FILE_MACHINE_I386)
	{
		pOpt32 = ReCa<IMAGE_OPTIONAL_HEADER32 *>(&pNT->OptionalHeader);
		x86 = true;

		LOG(1, "SYMBOL_LOADER: x86 target identified\n");
	}
	else
	{
		delete[] pRawData;

		LOG(1, "SYMBOL_LOADER: invalid file architecture\n");

		return SYMBOL_ERR_INVALID_FILE_ARCHITECTURE;
	}

	DWORD ImageSize = x86 ? pOpt32->SizeOfImage : pOpt64->SizeOfImage;
	BYTE * pLocalImageBase = ReCa<BYTE *>(VirtualAlloc(nullptr, ImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
	if (!pLocalImageBase)
	{
		delete[] pRawData;

		LOG(1, "SYMBOL_LOADER: can't allocate memory: 0x%08X\n", GetLastError());

		return SYMBOL_ERR_CANT_ALLOC_MEMORY;
	}

	memcpy(pLocalImageBase, pRawData, x86 ? pOpt32->SizeOfHeaders : pOpt64->SizeOfHeaders);

	auto * pCurrentSectionHeader = IMAGE_FIRST_SECTION(pNT);
	for (UINT i = 0; i != pFile->NumberOfSections; ++i, ++pCurrentSectionHeader)
	{
		if (pCurrentSectionHeader->SizeOfRawData)
		{
			memcpy(pLocalImageBase + pCurrentSectionHeader->VirtualAddress, pRawData + pCurrentSectionHeader->PointerToRawData, pCurrentSectionHeader->SizeOfRawData);
		}
	}
	
	LOG(1, "SYMBOL_LOADER: sections mapped\n");

	IMAGE_DATA_DIRECTORY * pDataDir = nullptr;
	if (x86)
	{
		pDataDir = &pOpt32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
	}
	else
	{
		pDataDir = &pOpt64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
	}

	IMAGE_DEBUG_DIRECTORY * pDebugDir = ReCa<IMAGE_DEBUG_DIRECTORY *>(pLocalImageBase + pDataDir->VirtualAddress);

	if (!pDataDir->Size || IMAGE_DEBUG_TYPE_CODEVIEW != pDebugDir->Type)
	{
		VirtualFree(pLocalImageBase, 0, MEM_RELEASE);

		delete[] pRawData;

		LOG(1, "SYMBOL_LOADER: no PDB debug data\n");

		return SYMBOL_ERR_NO_PDB_DEBUG_DATA;
	}

	PdbInfo * pdb_info = ReCa<PdbInfo *>(pLocalImageBase + pDebugDir->AddressOfRawData);
	if (pdb_info->Signature != 0x53445352)
	{
		VirtualFree(pLocalImageBase, 0, MEM_RELEASE);

		delete[] pRawData;

		LOG(1, "SYMBOL_LOADER: invalid PDB signature\n");

		return SYMBOL_ERR_NO_PDB_DEBUG_DATA;
	}
	
	m_szPdbPath = path;
	
	if (m_szPdbPath[m_szPdbPath.length() - 1] != '\\')
	{
		m_szPdbPath += '\\';
	}

	LOG(1, "SYMBOL_LOADER: PDB signature identified\n");

	if (!CreateDirectoryW(m_szPdbPath.c_str(), nullptr))
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			LOG(1, "SYMBOL_LOADER: can't create/open download path: 0x%08X\n", GetLastError());

			return SYMBOL_ERR_PATH_DOESNT_EXIST;
		}
	}

	m_szPdbPath += x86 ? L"x86\\" : L"x64\\";

	if (!CreateDirectoryW(m_szPdbPath.c_str(), nullptr))
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			LOG(1, "SYMBOL_LOADER: can't create/open download path: 0x%08X\n", GetLastError());

			return SYMBOL_ERR_CANT_CREATE_DIRECTORY;
		}
	}

	auto PdbFileName = CharArrayToStdWstring(pdb_info->PdbFileName);
	m_szPdbPath += PdbFileName;

	LOG(1, "SYMBOL_LOADER: PDB path = %ls\n", m_szPdbPath.c_str());
		
	m_Filesize = 0;
	WIN32_FILE_ATTRIBUTE_DATA file_attr_data{ 0 };
	if (GetFileAttributesExW(m_szPdbPath.c_str(), GetFileExInfoStandard, &file_attr_data))
	{
		m_Filesize = file_attr_data.nFileSizeLow;

		if (!Redownload && !VerifyExistingPdb(pdb_info->Guid))
		{
			LOG(1, "SYMBOL_LOADER: verification failed, PDB will be redownloaded\n");

			Redownload = true;
		}

		if (Redownload)
		{
			DeleteFileW(m_szPdbPath.c_str());
		}
	}	
	else
	{
		LOG(1, "SYMBOL_LOADER: file doesn't exist, PDB will be downloaded\n");

		Redownload = true;
	}

	if (Redownload)
	{
		wchar_t w_GUID[100]{ 0 };
		if (!StringFromGUID2(pdb_info->Guid, w_GUID, 100))
		{
			VirtualFree(pLocalImageBase, 0, MEM_RELEASE);

			delete[] pRawData;

			LOG(1, "SYMBOL_LOADER: failed to parse GUID");

			return SYMBOL_ERR_CANT_CONVERT_PDB_GUID;
		}

		LOG(1, "SYMBOL_LOADER: GUID = %ls\n", w_GUID);

		std::wstring guid_filtered;
		for (UINT i = 0; w_GUID[i]; ++i)
		{
			if ((w_GUID[i] >= '0' && w_GUID[i] <= '9') || (w_GUID[i] >= 'A' && w_GUID[i] <= 'F') || (w_GUID[i] >= 'a' && w_GUID[i] <= 'f'))
			{
				guid_filtered += w_GUID[i];
			}
		}
		
		std::wstring url = L"https://msdl.microsoft.com/download/symbols/";
		url += PdbFileName;
		url += '/';
		url += guid_filtered;
		url += std::to_wstring(pdb_info->Age);
		url += '/';
		url += PdbFileName;

		LOG(1, "SYMBOL_LOADER: URL = %ls\n", url.c_str());

		if (WaitForConnection)
		{
			LOG(1, "SYMBOL_LOADER: checking internet connection\n");

			while (InternetCheckConnectionW(L"https://msdl.microsoft.com", FLAG_ICC_FORCE_CONNECTION, NULL) == FALSE)
			{
				if (GetLastError() == ERROR_INTERNET_CANNOT_CONNECT)
				{
					VirtualFree(pLocalImageBase, 0, MEM_RELEASE);

					delete[] pRawData;

					LOG(1, "SYMBOL_LOADER: cannot connect to Microsoft Symbol Server\n");

					return SYMBOL_ERR_CANNOT_CONNECT;
				}

				Sleep(25);

				if (m_bInterruptEvent)
				{
					VirtualFree(pLocalImageBase, 0, MEM_RELEASE);

					delete[] pRawData;

					LOG(1, "SYMBOL_LOADER: interrupt event triggered\n");

					return SYMBOL_ERR_INTERRUPT;
				}
			}

			LOG(1, "SYMBOL_LOADER: connection verified\n");
		}

		wchar_t szCacheFile[MAX_PATH]{ 0 };

		if (m_hInterruptEvent)
		{
			m_DlMgr.SetInterruptEvent(m_hInterruptEvent);
		}

		if (!m_bStartDownload)
		{
			LOG(1, "SYMBOL_LOADER: waiting for download start\n");
		}

		while (!m_bStartDownload && !m_bInterruptEvent)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
		}

		if (m_bInterruptEvent)
		{
			VirtualFree(pLocalImageBase, 0, MEM_RELEASE);

			delete[] pRawData;

			LOG(1, "SYMBOL_LOADER: download interrupted\n");

			return SYMBOL_ERR_INTERRUPT;
		}

		LOG(1, "SYMBOL_LOADER: downloading PDB\n");

		auto hr = URLDownloadToCacheFileW(nullptr, url.c_str(), szCacheFile, sizeof(szCacheFile) / sizeof(szCacheFile[0]), NULL, &m_DlMgr);
		if (FAILED(hr))
		{
			VirtualFree(pLocalImageBase, 0, MEM_RELEASE);

			delete[] pRawData;

			LOG(1, "SYMBOL_LOADER: failed to download file: 0x%08X\n", hr);

			return SYMBOL_ERR_DOWNLOAD_FAILED;
		}

		LOG(1, "SYMBOL_LOADER: download finished\n");

		if (!CopyFileW(szCacheFile, m_szPdbPath.c_str(), FALSE))
		{
			VirtualFree(pLocalImageBase, 0, MEM_RELEASE);

			delete[] pRawData;

			LOG(1, "SYMBOL_LOADER: failed to copy file into working directory: 0x%08X\n", GetLastError());

			return SYMBOL_ERR_COPYFILE_FAILED;
		}

		DeleteFileW(szCacheFile);
	}

	m_fProgress = 1.0f;

	VirtualFree(pLocalImageBase, 0, MEM_RELEASE);

	delete[] pRawData;

	LOG(1, "SYMBOL_LOADER: PDB verified\n");

	if (!m_Filesize)
	{
		if (!GetFileAttributesExW(m_szPdbPath.c_str(), GetFileExInfoStandard, &file_attr_data))
		{
			LOG(1, "SYMBOL_LOADER: can't access PDB file: 0x%08X\n", GetLastError());

			return SYMBOL_ERR_CANT_ACCESS_PDB_FILE;
		}

		m_Filesize = file_attr_data.nFileSizeLow;
	}

	m_hPdbFile = CreateFileW(m_szPdbPath.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, NULL, nullptr);
	if (m_hPdbFile == INVALID_HANDLE_VALUE)
	{
		LOG(1, "SYMBOL_LOADER: can't open PDB file: 0x%08X\n", GetLastError());

		return SYMBOL_ERR_CANT_OPEN_PDB_FILE;
	}

	if (pdb_path_out)
	{
		*pdb_path_out = m_szPdbPath;
	}

	m_bReady = true;

	return SYMBOL_ERR_SUCCESS;
}

void SYMBOL_LOADER::Cleanup()
{
	LOG(1, "SYMBOL_LOADER::Cleanup\n");

	m_bReady = false;

	if (m_hPdbFile)
	{
		CloseHandle(m_hPdbFile);

		m_hPdbFile = nullptr;
	}
}

void SYMBOL_LOADER::SetDownload(bool bDownload)
{
	m_bStartDownload = bDownload;
}

void SYMBOL_LOADER::Interrupt()
{
	LOG(1, "SYMBOL_LOADER::Interrupt\n");

	m_bInterruptEvent = true;

	if (m_hInterruptEvent)
	{
		if (!SetEvent(m_hInterruptEvent))
		{
			LOG(1, "SYMBOL_LOADER: SetEvent failed to trigger interrupt event: %08X\n", GetLastError());
		}
		else
		{
			LOG(1, "SYMBOL_LOADER: interrupt event set\n");
		}
	}
	else
	{
		LOG(1, "SYMBOL_LOADER: no interrupt event specified\n");
	}
}

const std::wstring & SYMBOL_LOADER::GetFilepath() const
{
	return m_szPdbPath;
}

DWORD SYMBOL_LOADER::GetFilesize() const
{
	return m_Filesize;
}

float SYMBOL_LOADER::GetDownloadProgress() const
{
	if (m_fProgress == 1.0f)
	{
		return m_fProgress;
	}

	return m_DlMgr.GetDownloadProgress();
}

bool SYMBOL_LOADER::IsReady() const
{
	return m_bReady;
}
```

`GH Injector Library/Symbol Loader.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "pch.h"

#include "Error.h"
#include "Download Manager.h"
#include "Tools.h"

class SYMBOL_LOADER
{
	HANDLE			m_hPdbFile		= NULL;
	std::wstring	m_szPdbPath		= std::wstring();
	std::wstring	m_szModulePath	= std::wstring();
	DWORD			m_Filesize		= 0;

	HANDLE	m_hInterruptEvent = NULL;
	bool	m_bInterruptEvent = false;

	DownloadManager m_DlMgr		= DownloadManager(false);
	float	m_fProgress			= 0.0f;
	bool	m_bStartDownload	= false;
	
	bool m_bReady = false;

	bool VerifyExistingPdb(const GUID & guid);

public:

	SYMBOL_LOADER();
	~SYMBOL_LOADER();

	DWORD Initialize(const std::wstring & szModulePath, const std::wstring & path, std::wstring * pdb_path_out, bool Redownload, bool WaitForConnection = false, bool AutoDownload = false);
	void Cleanup();

	void SetDownload(bool bDownload);
	void Interrupt();

	const std::wstring &	GetFilepath() const;
	DWORD					GetFilesize() const;
	float					GetDownloadProgress() const;

	bool IsReady() const;
};

struct PdbInfo
{
	DWORD	Signature;
	GUID	Guid;
	DWORD	Age;
	char	PdbFileName[1];
};

//Thanks mambda
//https://bitbucket.org/mambda/pdb-parser/src/master/
struct PDBHeader7
{
	char signature[0x20];
	int page_size;
	int allocation_table_pointer;
	int file_page_count;
	int root_stream_size;
	int reserved;
	int root_stream_page_number_list_number;
};

struct RootStream7
{
	int num_streams;
	int stream_sizes[ANYSIZE_ARRAY]; //num_streams
};

struct GUID_StreamData
{
	int ver;
	int date;
	int age;
	GUID guid;
};

#ifdef  _WIN64
inline SYMBOL_LOADER				sym_ntdll_wow64;
inline std::shared_future<DWORD>	sym_ntdll_wow64_ret;
#endif

inline SYMBOL_LOADER				sym_ntdll_native;
inline std::shared_future<DWORD>	sym_ntdll_native_ret;

#ifdef  _WIN64
inline SYMBOL_LOADER				sym_kernel32_wow64;
inline std::shared_future<DWORD>	sym_kernel32_wow64_ret;
#endif

inline SYMBOL_LOADER				sym_kernel32_native;
inline std::shared_future<DWORD>	sym_kernel32_native_ret;
```

`GH Injector Library/Symbol Parser.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Symbol Parser.h"

SYMBOL_PARSER::SYMBOL_PARSER()
{

}

SYMBOL_PARSER::~SYMBOL_PARSER()
{
	Cleanup();
}

DWORD SYMBOL_PARSER::Initialize(const SYMBOL_LOADER * pSymbolObject)
{
	LOG(1, "SYMBOL_LOADER::Initialize\n");

	if (!pSymbolObject)
	{
		LOG(1, "SYMBOL_PARSER: symbol object is NULL\n");

		return SYMBOL_ERR_OBJECT_IS_NULL;
	}

	if (!pSymbolObject->IsReady())
	{
		LOG(1, "SYMBOL_PARSER: symbol object isn't ready\n");

		return SYMBOL_ERR_OBJECT_NOT_READY;
	}

	if (m_SymbolTable)
	{
		SymUnloadModule64(m_hProcess, m_SymbolTable);

		m_SymbolTable = 0;
	}

	if (!m_hProcess)
	{
		m_hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, GetCurrentProcessId());
		if (!m_hProcess)
		{
			LOG(1, "SYMBOL_PARSER: can't open current process: 0x%08X\n", GetLastError());

			return SYMBOL_ERR_CANT_OPEN_PROCESS;
		}
	}

	if (!m_bInitialized)
	{
		SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_AUTO_PUBLICS);

		if (!SymInitializeW(m_hProcess, nullptr, FALSE))
		{
			CloseHandle(m_hProcess);

			LOG(1, "SYMBOL_PARSER: SymInitializeW failed: 0x%08X\n", GetLastError());

			return SYMBOL_ERR_SYM_INIT_FAIL;
		}

		m_bInitialized = true;
	}

	m_SymbolTable = SymLoadModuleExW(m_hProcess, nullptr, pSymbolObject->GetFilepath().c_str(), nullptr, 0x10000000, pSymbolObject->GetFilesize(), nullptr, NULL);
	if (!m_SymbolTable)
	{
		SymCleanup(m_hProcess);

		CloseHandle(m_hProcess);

		LOG(1, "SYMBOL_PARSER: SymLoadModuleExW failed: 0x%08X\n", GetLastError());

		return SYMBOL_ERR_SYM_LOAD_TABLE;
	}

	m_bReady = true;

	LOG(1, "SYMBOL_PARSER: initialization finished\n");

	return SYMBOL_ERR_SUCCESS;
}

DWORD SYMBOL_PARSER::GetSymbolAddress(const char * szSymbolName, DWORD & RvaOut)
{
	if (!m_bReady)
	{
		LOG(2, "SYMBOL_PARSER: not ready\n");

		return SYMBOL_ERR_NOT_INITIALIZED;
	}

	if (!szSymbolName)
	{
		LOG(2, "SYMBOL_PARSER: invalid symbol name\n");

		return SYMBOL_ERR_IVNALID_SYMBOL_NAME;
	}

	SYMBOL_INFO si{ 0 };
	si.SizeOfStruct = sizeof(SYMBOL_INFO);
	if (!SymFromName(m_hProcess, szSymbolName, &si))
	{
		LOG(2, "SYMBOL_PARSER: search failed: 0x%08X\n", GetLastError());

		return SYMBOL_ERR_SYMBOL_SEARCH_FAILED;
	}

	RvaOut = (DWORD)(si.Address - si.ModBase);

	LOG(2, "SYMBOL_PARSER: RVA %08X -> %s\n", RvaOut, szSymbolName);

	return SYMBOL_ERR_SUCCESS;
}

void SYMBOL_PARSER::Cleanup()
{
	LOG(1, "SYMBOL_PARSER::Cleanup\n");

	if (m_bInitialized)
	{
		if (m_SymbolTable)
		{
			SymUnloadModule64(m_hProcess, m_SymbolTable);

			m_SymbolTable = 0;
		}

		SymCleanup(m_hProcess);

		m_bInitialized = false;
	}

	if (m_hProcess)
	{
		CloseHandle(m_hProcess);

		m_hProcess = nullptr;
	}
}
```

`GH Injector Library/Symbol Parser.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "pch.h"

#include "Symbol Loader.h"

class SYMBOL_PARSER
{
	HANDLE m_hProcess		= NULL;
	bool m_bInitialized		= false;
	bool m_bReady			= false;
	DWORD64 m_SymbolTable	= 0;

public:

	SYMBOL_PARSER();
	~SYMBOL_PARSER();

	DWORD Initialize(const SYMBOL_LOADER * pSymbolObject);
	void Cleanup();

	DWORD GetSymbolAddress(const char * szSymbolName, DWORD & RvaOut);
};

inline SYMBOL_PARSER sym_parser;
```

`GH Injector Library/Thread Hijacking WOW64.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#ifdef _WIN64

#include "Start Routine.h"

DWORD SR_HijackThread_WOW64(HANDLE hTargetProc, f_Routine_WOW64 pRoutine, DWORD pArg, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_HijackThread_WOW64\n");

	ProcessInfo PI;
	if (!PI.SetProcess(hTargetProc))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Can't initialize ProcessInfo class\n");

		return SR_HT_ERR_PROC_INFO_FAIL;
	}

	DWORD ThreadID = 0;

	do
	{
		KWAIT_REASON reason;
		KTHREAD_STATE state;
		if (!PI.GetThreadState(state, reason) || reason == KWAIT_REASON::WrQueue)
		{
			continue;
		}		

		if ((!PI.IsThreadWorkerThread() && (PI.IsThreadInAlertableState_WOW64() || state == KTHREAD_STATE::Running)) && PI.GetThreadId() != GetCurrentThreadId())
		{
			ThreadID = PI.GetThreadId();
			break;
		}

	} 
	while (PI.NextThread());

	if (!ThreadID)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "No compatible thread found\n");

		return SR_HT_ERR_NO_THREADS;
	}

	LOG(2, "Target thread %06X\n", ThreadID);

	HANDLE hThread = OpenThread(THREAD_SET_CONTEXT | THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME, FALSE, ThreadID);
	if (!hThread)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "OpenThread failed: %08X\n", error_data.AdvErrorCode);

		return SR_HT_ERR_OPEN_THREAD_FAIL;
	}

	if (SuspendThread(hThread) == (DWORD)-1)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "SuspendThread failed: %08X\n", error_data.AdvErrorCode);

		CloseHandle(hThread);

		return SR_HT_ERR_SUSPEND_FAIL;
	}

	LOG(2, "Target thread suspended\n");

	WOW64_CONTEXT OldContext{ 0 };
	OldContext.ContextFlags = WOW64_CONTEXT_ALL;

	if (!Wow64GetThreadContext(hThread, &OldContext))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "Wow64GetThreadContext failed: %08X\n", error_data.AdvErrorCode);

		ResumeThread(hThread);
		CloseHandle(hThread);

		return SR_HT_ERR_GET_CONTEXT_FAIL;
	}

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		CloseHandle(hThread);

		return SR_HT_ERR_CANT_ALLOC_MEM;
	}

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER_86

		0x83, 0xEC, 0x04,							// + 0x00				-> sub	esp, 0x04							; prepare stack for ret
		0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00,	// + 0x03 (+ 0x06)		-> mov	[esp], OldEip						; store old eip as return address

		0x50, 0x51, 0x52, 0x53,						// + 0x0A				-> push e(a/c/d/b)							; save e(a/c/d/b)x
		0x9C,										// + 0x0E				-> pushfd									; save flags register

		0xBB, 0x00, 0x00, 0x00, 0x00,				// + 0x0F (+ 0x10)		-> mov	ebx, 0x00000000						; move pData into ebx (update address manually on runtime)

		0xC6, 0x03, 0x01,							// + 0x14				-> mov  byte ptr [ebx], 1					; set SR_REMOTE_DATA::State to SR_RS_Executing

		0xFF, 0x73, 0x0C,							// + 0x17				-> push [ebx + 0x0C]						; push pArg
		0xFF, 0x53, 0x10,							// + 0x1A				-> call dword ptr [ebx + 0x10]				; call pRoutine
		0x89, 0x43, 0x04,							// + 0x1D				-> mov	[ebx + 0x04], eax					; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,			// + 0x20				-> mov	eax, fs:[0x18]						; GetLastError
		0x8B, 0x40, 0x34,							// + 0x26				-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,							// + 0x29				-> mov	[ebx + 0x08], eax					; store in SR_REMOTE_DATA::LastWin32Error

		0xC7, 0x03, 0x02, 0x00, 0x00, 0x00,			// + 0x2C				-> mov	byte ptr [ebx], 2					; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x9D,										// + 0x32				-> popfd									; restore flags register
		0x5B, 0x5A, 0x59, 0x58,						// + 0x33				-> pop e(d/c/a)								; restore e(b/d/c/a)x

		0xC3										// + 0x37				-> ret										; return to OldEip
	}; // SIZE = 0x38 (+ 0x04)

	auto OldEIP = OldContext.Eip;
	*ReCa<DWORD *>(Shellcode + 0x06 + sizeof(SR_REMOTE_DATA_WOW64)) = OldEIP;
	*ReCa<DWORD *>(Shellcode + 0x10 + sizeof(SR_REMOTE_DATA_WOW64)) = MDWD(pMem);

	LOG(2, "Shellcode prepared\n");

	void * pRemoteFunc	= ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA_WOW64);
	OldContext.Eip		= MDWD(pRemoteFunc);

	auto * sr_data = ReCa<SR_REMOTE_DATA_WOW64 *>(Shellcode);
	sr_data->pArg		= pArg;
	sr_data->pRoutine	= pRoutine;

	LOG(2, "Hijacking thread with:\n");
	LOG(3, "pRoutine = %08X\n", MDWD(pRemoteFunc));
	LOG(3, "pArg     = %08X\n", MDWD(pMem));

	if (!WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		ResumeThread(hThread);
		CloseHandle(hThread);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_HT_ERR_WPM_FAIL;
	}

	if (!Wow64SetThreadContext(hThread, &OldContext))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "Wow64SetThreadContext failed: %08X\n", error_data.AdvErrorCode);

		ResumeThread(hThread);
		CloseHandle(hThread);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_HT_ERR_SET_CONTEXT_FAIL;
	}

	LOG(2, "EIP replaced\n");

	if (ResumeThread(hThread) == (DWORD)-1)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "ResumeThread failed: %08X\n", error_data.AdvErrorCode);

		OldContext.Eip = OldEIP;
		Wow64SetThreadContext(hThread, &OldContext);
		ResumeThread(hThread);

		CloseHandle(hThread);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_HT_ERR_RESUME_FAIL;
	}

	LOG(2, "Thread resumed\n");

	PostThreadMessageW(ThreadID, WM_NULL, 0, 0);

	Sleep(SR_REMOTE_DELAY);

	SR_REMOTE_DATA_WOW64 data{ };
	data.State			= (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	LOG(2, "Entering wait state\n");

	auto Timer = GetTickCount64();
	while (GetTickCount64() - Timer < Timeout)
	{
		auto dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		BOOL bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet && data.State == (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished)
		{
			LOG(2, "Shelldata retrieved\n");

			break;
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}

			if (bRet && data.State == (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionPending && SuspendThread(hThread) != (DWORD)-1)
			{
				OldContext.Eip = OldEIP;

				if (Wow64SetThreadContext(hThread, &OldContext) && ResumeThread(hThread) != (DWORD)-1)
				{
					ResumeThread(hThread);

					CloseHandle(hThread);

					VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
				}
			}

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}

			return SR_HT_ERR_RPM_FAIL;
		}
	}

	if (data.State != (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		if (data.State == (DWORD)SR_REMOTE_STATE::SR_RS_ExecutionPending)
		{
			if (SuspendThread(hThread) != (DWORD)-1)
			{
				LOG(2, "Shell timed out\n");

				OldContext.Eip = OldEIP;

				if (Wow64SetThreadContext(hThread, &OldContext) && ResumeThread(hThread) != (DWORD)-1)
				{
					CloseHandle(hThread);

					VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

					return SR_HT_ERR_REMOTE_PENDING_TIMEOUT;
				}
			}
		}

		LOG(2, "pRoutine timed out\n");

		CloseHandle(hThread);

		return SR_HT_ERR_REMOTE_TIMEOUT;
	}

	CloseHandle(hThread);

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out = data.Ret;
	
	return SR_ERR_SUCCESS;
}

#endif
```

`GH Injector Library/Thread Hijacking.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Start Routine.h"

DWORD SR_HijackThread(HANDLE hTargetProc, f_Routine pRoutine, void * pArg, DWORD & Out, DWORD Timeout, ERROR_DATA & error_data)
{
	LOG(2, "Begin SR_HijackThread\n");

	ProcessInfo PI;
	if (!PI.SetProcess(hTargetProc))
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "Can't initialize ProcessInfo class\n");

		return SR_HT_ERR_PROC_INFO_FAIL;
	}

	DWORD ThreadID = 0;

	do
	{
		KWAIT_REASON reason;
		KTHREAD_STATE state;
		if (!PI.GetThreadState(state, reason) || reason == KWAIT_REASON::WrQueue)
		{
			continue;
		}

		if ((!PI.IsThreadWorkerThread() && (PI.IsThreadInAlertableState() || state == KTHREAD_STATE::Running)) && PI.GetThreadId() != GetCurrentThreadId())
		{
			ThreadID = PI.GetThreadId();
			break;
		}

	}
	while (PI.NextThread());
	
	if (!ThreadID)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		LOG(2, "No compatible thread found\n");

		return SR_HT_ERR_NO_THREADS;
	}

	LOG(2, "Target thread %06X\n", ThreadID);

	HANDLE hThread = OpenThread(THREAD_SET_CONTEXT | THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME, FALSE, ThreadID);
	if (!hThread)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "OpenThread failed: %08X\n", error_data.AdvErrorCode);

		return SR_HT_ERR_OPEN_THREAD_FAIL;
	}

	if (SuspendThread(hThread) == (DWORD)-1)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "SuspendThread failed: %08X\n", error_data.AdvErrorCode);

		CloseHandle(hThread);

		return SR_HT_ERR_SUSPEND_FAIL;
	}

	LOG(2, "Target thread suspended\n");

	CONTEXT OldContext{ 0 };
	OldContext.ContextFlags = CONTEXT_CONTROL;

	if (!GetThreadContext(hThread, &OldContext))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "GetThreadContext failed: %08X\n", error_data.AdvErrorCode);

		ResumeThread(hThread);
		CloseHandle(hThread);

		return SR_HT_ERR_GET_CONTEXT_FAIL;
	}

	void * pMem = VirtualAllocEx(hTargetProc, nullptr, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pMem)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "VirtualAllocEx failed: %08X\n", error_data.AdvErrorCode);

		CloseHandle(hThread);

		return SR_HT_ERR_CANT_ALLOC_MEM;
	}
	
	/*
		__declspec(naked) void ThreadHijack_Shell()
		{
			//Stack setup
			//Save registers

			SR_REMOTE_DATA * data = ReCa<SR_REMOTE_DATA *>(ReCa<BYTE *>(ThreadHijack_Shell) - sizeof(SR_REMOTE_DATA));
			data->State = SR_REMOTE_STATE::SR_RS_Executing;

			data->Ret = data->pRoutine(data->pArg);
			data->LastWin32Error = GetLastError();
			data->State = SR_REMOTE_STATE::SR_RS_ExecutionFinished;

			//Restore stack
			//Restore registers

			//Return to hijacked code
		}
	*/

#ifdef _WIN64
	
	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x48, 0x83, 0xEC, 0x08,													// + 0x00			-> sub	rsp, 0x08				; prepare stack for ret
		0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00,								// + 0x04 (+ 0x07)	-> mov	[rsp + 0x00], RipLo		; store old rip as return address
		0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00, 0x00,							// + 0x0B (+ 0x0F)	-> mov	[rsp + 0x04], RipHi		; 

		0x50, 0x51, 0x52, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53,		// + 0x13			-> push	r(a/c/d)x / r (8 - 11)	; save volatile registers
		0x9C,																	// + 0x1E			-> pushfq						; save flags register

		0x53,																	// + 0x1F			-> push rbx						; push rbx on stack (non volatile)
		0x48, 0x8D, 0x1D, 0xA9, 0xFF, 0xFF, 0xFF,								// + 0x20			-> lea	rbx, [-0x30]			; load pData into rbx

		0xC6, 0x03, 0x01,														// + 0x27			-> mov	byte ptr [rbx], 1		; set SR_REMOTE_DATA::State to SR_RS_Executing

		0x55,																	// + 0x2A			-> push rbp						; store rbp
		0x48, 0x8B, 0xEC,														// + 0x2B			-> mov	rbp, rsp				; save rsp to rbp
		0x48, 0x83, 0xE4, 0xF0,													// + 0x2E			-> and	rsp, -0x10				; 16-bit align rsp

		0x48, 0x8B, 0x4B, 0x18,													// + 0x32			-> mov  rcx, [rbx + 0x18]		; move pArg into rcx
		0x48, 0x83, 0xEC, 0x20,													// + 0x36			-> sub	rsp, 0x20				; reserve stack
		0xFF, 0x53, 0x20, 														// + 0x3A			-> call qword ptr [rbx + 0x20]	; call pRoutine
		0x48, 0x83, 0xC4, 0x20, 												// + 0x3D			-> add	rsp, 0x20				; update stack
		0x48, 0x89, 0x43, 0x08,													// + 0x41			-> mov	[rbx + 0x08], rax		; store returned value
		
		0x48, 0x8B, 0xE5,														// + 0x45			-> mov	rsp, rbp				; restore rsp
		0x5D,																	// + 0x48			-> pop	rbp						; restore rbp

		0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00,					// + 0x49			-> mov	rax, gs:[0x30]			; GetLastError
		0x8B, 0x40, 0x68,														// + 0x52			-> mov	eax, [rax + 0x68]
		0x89, 0x43, 0x10,														// + 0x55			-> mov	[rbx + 0x10], eax		; store in SR_REMOTE_DATA::LastWin32Error

		0xC6, 0x03, 0x02,														// + 0x58			-> mov	byte ptr [rbx], 2		; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished

		0x5B,																	// + 0x5B			-> pop rbx						; restore rbx

		0x9D,																	// + 0x5C			-> popfq						; restore flags register
		0x41, 0x5B, 0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5A, 0x59, 0x58,		// + 0x5D			-> pop r(11-8) / r(d/c/a)x		; restore volatile registers

		0xC3																	// + 0x68			-> ret							; return to old rip and continue execution
	}; // SIZE = 0x69 (+ sizeof(SR_REMOTE_DATA))

	auto OldRIP = OldContext.Rip;
	DWORD dwLoRIP = (DWORD)((OldRIP		   ) & 0xFFFFFFFF);
	DWORD dwHiRIP = (DWORD)((OldRIP >> 0x20) & 0xFFFFFFFF);

	*ReCa<DWORD *>(Shellcode + 0x07 + sizeof(SR_REMOTE_DATA)) = dwLoRIP;
	*ReCa<DWORD *>(Shellcode + 0x0F + sizeof(SR_REMOTE_DATA)) = dwHiRIP;

	void * pRemoteFunc	= ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA);
	OldContext.Rip		= ReCa<ULONG_PTR>(pRemoteFunc);

#else

	BYTE Shellcode[] =
	{
		SR_REMOTE_DATA_BUFFER

		0x83, 0xEC, 0x04,							// + 0x00				-> sub	esp, 0x04							; prepare stack for ret
		0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00,	// + 0x03 (+ 0x06)		-> mov	[esp], OldEip						; store old eip as return address

		0x50, 0x51, 0x52, 0x53,						// + 0x0A				-> push e(a/c/d/b)							; save e(a/c/d/b)x
		0x9C,										// + 0x0E				-> pushfd									; save flags register

		0xBB, 0x00, 0x00, 0x00, 0x00,				// + 0x0F (+ 0x10)		-> mov	ebx, 0x00000000						; move pData into ebx (update address manually on runtime)

		0xC6, 0x03, 0x01,							// + 0x14				-> mov  byte ptr [ebx], 1					; set SR_REMOTE_DATA::State to SR_RS_Executing

		0xFF, 0x73, 0x0C,							// + 0x17				-> push [ebx + 0x0C]						; push pArg
		0xFF, 0x53, 0x10,							// + 0x1A				-> call dword ptr [ebx + 0x10]				; call pRoutine
		0x89, 0x43, 0x04,							// + 0x1D				-> mov	[ebx + 0x04], eax					; store returned value

		0x64, 0xA1, 0x18, 0x00, 0x00, 0x00,			// + 0x20				-> mov	eax, fs:[0x18]						; GetLastError
		0x8B, 0x40, 0x34,							// + 0x26				-> mov	eax, [eax + 0x34]
		0x89, 0x43, 0x08,							// + 0x29				-> mov	[ebx + 0x08], eax					; store in SR_REMOTE_DATA::LastWin32Error

		0xC7, 0x03, 0x02, 0x00, 0x00, 0x00,			// + 0x2C				-> mov	byte ptr [ebx], 2					; set SR_REMOTE_DATA::State to SR_RS_ExecutionFinished
		
		0x9D,										// + 0x32				-> popfd									; restore flags register
		0x5B, 0x5A, 0x59, 0x58,						// + 0x33				-> pop e(d/c/a)								; restore e(b/d/c/a)x
		
		0xC3										// + 0x37				-> ret										; return to OldEip
	}; // SIZE = 0x38 (+ sizeof(SR_REMOTE_DATA))

	auto OldEIP = OldContext.Eip;
	*ReCa<DWORD *>(Shellcode + 0x06 + sizeof(SR_REMOTE_DATA)) = OldEIP;
	*ReCa<void **>(Shellcode + 0x10 + sizeof(SR_REMOTE_DATA)) = pMem;

	void * pRemoteFunc	= ReCa<BYTE *>(pMem) + sizeof(SR_REMOTE_DATA);
	OldContext.Eip		= ReCa<DWORD>(pRemoteFunc);

#endif

	LOG(2, "Shellcode prepared\n");

	auto * sr_data = ReCa<SR_REMOTE_DATA *>(Shellcode);
	sr_data->pArg		= pArg;
	sr_data->pRoutine	= pRoutine;

	LOG(2, "Hijacking thread with:\n");
	LOG(3, "pRoutine = %p\n", pRemoteFunc);
	LOG(3, "pArg     = %p\n", pMem);

	if (!WriteProcessMemory(hTargetProc, pMem, Shellcode, sizeof(Shellcode), nullptr))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "WriteProcessMemory failed: %08X\n", error_data.AdvErrorCode);

		ResumeThread(hThread);
		CloseHandle(hThread);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_HT_ERR_WPM_FAIL;
	}

	if (!SetThreadContext(hThread, &OldContext))
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "SetThreadContext failed: %08X\n", error_data.AdvErrorCode);

		ResumeThread(hThread);
		CloseHandle(hThread);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_HT_ERR_SET_CONTEXT_FAIL;
	}

#ifdef _WIN64
	LOG(2, "RIP replaced\n");
#else
	LOG(2, "EIP replaced\n");
#endif

	if (ResumeThread(hThread) == (DWORD)-1)
	{
		INIT_ERROR_DATA(error_data, GetLastError());

		LOG(2, "ResumeThread failed: %08X\n", error_data.AdvErrorCode);

#ifdef _WIN64
		OldContext.Rip = OldRIP;
#else
		OldContext.Eip = OldEIP;
#endif
		SetThreadContext(hThread, &OldContext);
		ResumeThread(hThread);

		CloseHandle(hThread);
		VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

		return SR_HT_ERR_RESUME_FAIL;
	}

	LOG(2, "Thread resumed\n");

	PostThreadMessageW(ThreadID, WM_NULL, 0, 0);

	Sleep(SR_REMOTE_DELAY);

	SR_REMOTE_DATA data{ };
	data.State			= SR_REMOTE_STATE::SR_RS_ExecutionPending;
	data.Ret			= ERROR_SUCCESS;
	data.LastWin32Error = ERROR_SUCCESS;

	LOG(2, "Entering wait state\n");

	auto Timer = GetTickCount64();
	while (GetTickCount64() - Timer < Timeout)
	{
		auto dwWaitRet = WaitForSingleObject(g_hInterruptEvent, 10);

		BOOL bRet = ReadProcessMemory(hTargetProc, pMem, &data, sizeof(data), nullptr);
		if (bRet && data.State == SR_REMOTE_STATE::SR_RS_ExecutionFinished)
		{
			LOG(2, "Shelldata retrieved\n");

			break;
		}
		else if (!bRet || dwWaitRet == WAIT_OBJECT_0)
		{
			INIT_ERROR_DATA(error_data, GetLastError());

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				LOG(2, "Interrupt!\n");
			}
			else
			{
				LOG(2, "ReadProcessMemory failed: %08X\n", error_data.AdvErrorCode);
			}

			if (bRet && data.State == SR_REMOTE_STATE::SR_RS_ExecutionPending && SuspendThread(hThread) != (DWORD)-1)
			{
#ifdef _WIN64
				OldContext.Rip = OldRIP;
#else
				OldContext.Eip = OldEIP;
#endif
				if (SetThreadContext(hThread, &OldContext) && ResumeThread(hThread) != (DWORD)-1)
				{
					ResumeThread(hThread);

					CloseHandle(hThread);
					
					VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);
				}
			}

			if (dwWaitRet == WAIT_OBJECT_0)
			{
				SetEvent(g_hInterruptedEvent);

				return SR_ERR_INTERRUPT;
			}

			return SR_HT_ERR_RPM_FAIL;
		}
	}

	if (data.State != SR_REMOTE_STATE::SR_RS_ExecutionFinished)
	{
		INIT_ERROR_DATA(error_data, INJ_ERR_ADVANCED_NOT_DEFINED);

		if (data.State == SR_REMOTE_STATE::SR_RS_ExecutionPending)
		{
			if (SuspendThread(hThread) != (DWORD)-1)
			{
				LOG(2, "Shell timed out\n");

#ifdef _WIN64
				OldContext.Rip = OldRIP;
#else
				OldContext.Eip = OldEIP;
#endif
				if (SetThreadContext(hThread, &OldContext) && ResumeThread(hThread) != (DWORD)-1)
				{
					CloseHandle(hThread);

					VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

					return SR_HT_ERR_REMOTE_PENDING_TIMEOUT;
				}
			}
		}

		LOG(2, "pRoutine timed out\n");

		CloseHandle(hThread);

		return SR_HT_ERR_REMOTE_TIMEOUT;
	}

	CloseHandle(hThread);

	VirtualFreeEx(hTargetProc, pMem, 0, MEM_RELEASE);

	LOG(2, "pRoutine returned: %08X\n", data.Ret);

	Out	= data.Ret;

	return SR_ERR_SUCCESS;
}
```

`GH Injector Library/Tools.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Tools.h"
#include "Import Handler.h"

std::wstring InjectionModeToString(INJECTION_MODE mode);
std::wstring LaunchMethodToString(LAUNCH_METHOD method);
std::wstring BuildNumberToVersionString(int OSBuildNumber);

bool IsWin7OrGreater()
{
	return (GetOSVersion() >= g_Win7);
}

bool IsWin8OrGreater()
{
	return (GetOSVersion() >= g_Win8);
}

bool IsWin81OrGreater()
{
	return (GetOSVersion() >= g_Win81);
}

bool IsWin10OrGreater()
{
	return (GetOSVersion() >= g_Win10);
}

bool IsWin11OrGreater()
{
	return (GetOSVersion() >= g_Win10 && GetOSBuildVersion() >= g_Win11_21H2);
}

DWORD GetOSVersion(DWORD * error_code)
{
	if (g_OSVersion != 0)
	{
		return g_OSVersion;
	}

#ifdef _WIN64
	PEB * pPEB = ReCa<PEB *>(__readgsqword(0x60));
#else
	PEB * pPEB = ReCa<PEB *>(__readfsdword(0x30));
#endif

	if (!pPEB)
	{
		if (error_code)
		{
			*error_code = INJ_ERR_CANT_GET_PEB;
		}

		return 0;
	}

	DWORD v_hi = pPEB->OSMajorVersion;
	DWORD v_lo = pPEB->OSMinorVersion;

	for (; v_lo >= 10; v_lo /= 10);

	g_OSVersion = v_hi * 10 + v_lo;

	g_OSBuildNumber = pPEB->OSBuildNumber;

	return g_OSVersion;
}

DWORD GetOSBuildVersion()
{
	return g_OSBuildNumber;
}

bool FileExistsW(const std::wstring & FilePath)
{
	return (GetFileAttributesW(FilePath.c_str()) != INVALID_FILE_ATTRIBUTES);
}

DWORD ValidateDllFile(const std::wstring & FilePath, DWORD target_machine)
{
	std::ifstream File(FilePath, std::ios::binary | std::ios::ate);
	if (!File.good())
	{
		LOG(1, "Can't open file\n");

		return FILE_ERR_CANT_OPEN_FILE;
	}

	auto FileSize = File.tellg();
	if (FileSize < 0x1000)
	{
		LOG(1, "Specified file is too small\n");

		File.close();

		return FILE_ERR_INVALID_FILE_SIZE;
	}

	BYTE * headers = new(std::nothrow) BYTE[0x1000]();
	if (headers == nullptr)
	{
		LOG(1, "Memory allocation failed\n");

		return FILE_ERR_MEMORY_ALLOCATION_FAILED;
	}

	File.seekg(0, std::ios::beg);
	File.read(ReCa<char *>(headers), 0x1000);
	File.close();

	auto * dos_header = ReCa<IMAGE_DOS_HEADER *>(headers);
	
	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) //"MZ"
	{
		delete[] headers;

		LOG(1, "Invalid DOS header signature\n");

		return FILE_ERR_INVALID_FILE;
	}

	if (dos_header->e_lfanew > 0x1000)
	{
		delete[] headers;

		LOG(1, "Invalid nt header offset\n");

		return FILE_ERR_INVALID_FILE;
	}

	auto nt_headers = ReCa<IMAGE_NT_HEADERS *>(headers + dos_header->e_lfanew);
	if (nt_headers->Signature != IMAGE_NT_SIGNATURE)  //"PE"
	{
		LOG(1, "Not a valid PE file (nt signature mismatch)\n");

		delete[] headers;

		return FILE_ERR_INVALID_FILE;
	}

	WORD character = nt_headers->FileHeader.Characteristics;
	if (!(character & IMAGE_FILE_DLL))
	{
		LOG(1, "Not a valid DLL (characteristics mismatch)\n");

		delete[] headers;

		return FILE_ERR_INVALID_FILE;
	}

	if (nt_headers->FileHeader.Machine != target_machine)
	{
		LOG(1, "DLL platform mismatch\n");
		
		delete[] headers;

		return FILE_ERR_INVALID_FILE;
	}

	delete[] headers;
	return FILE_ERR_SUCCESS;
}

DWORD ValidateDllFileInMemory(const BYTE * RawData, DWORD RawSize, DWORD target_machine)
{
	if (RawSize < 0x1000)
	{
		LOG(1, "Specified file is too small\n");

		return FILE_ERR_INVALID_FILE_SIZE;
	}

	auto * dos_header = ReCa<const IMAGE_DOS_HEADER *>(RawData);

	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE) //"MZ"
	{
		LOG(1, "Invalid DOS header signature\n");

		return FILE_ERR_INVALID_FILE;
	}

	if (dos_header->e_lfanew > 0x1000)
	{
		LOG(1, "Invalid nt header offset\n");

		return FILE_ERR_INVALID_FILE;
	}

	auto nt_headers = ReCa<const IMAGE_NT_HEADERS *>(RawData + dos_header->e_lfanew);
	if (nt_headers->Signature != IMAGE_NT_SIGNATURE)  //"PE"
	{
		LOG(1, "Not a valid PE file (nt signature mismatch)\n");

		return FILE_ERR_INVALID_FILE;
	}

	WORD character = nt_headers->FileHeader.Characteristics;
	if (!(character & IMAGE_FILE_DLL))
	{
		LOG(1, "Not a valid DLL (characteristics mismatch)\n");

		return FILE_ERR_INVALID_FILE;
	}

	if (nt_headers->FileHeader.Machine != target_machine)
	{
		LOG(1, "DLL platform mismatch\n");

		return FILE_ERR_INVALID_FILE;
	}

	return FILE_ERR_SUCCESS;
}

bool GetOwnModulePathA(std::string & out)
{
	char buffer[MAX_PATH * 2]{ 0 };
	DWORD mod_ret = GetModuleFileNameA(g_hInjMod, buffer, sizeof(buffer));
	if (!mod_ret || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		return false;
	}

	std::string temp = buffer;
	auto pos = temp.find_last_of('\\');
	if (pos == std::string::npos)
	{
		return false;
	}

	out = temp.substr(0, pos + 1);

	return true;
}

bool GetOwnModulePathW(std::wstring & out)
{
	wchar_t buffer[MAX_PATH * 2]{ 0 };
	DWORD mod_ret = GetModuleFileNameW(g_hInjMod, buffer, sizeof(buffer) / sizeof(wchar_t));
	if (!mod_ret || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		return false;
	}

	std::wstring temp = buffer;
	auto pos = temp.find_last_of('\\');
	if (pos == std::string::npos)
	{
		return false;
	}

	out = temp.substr(0, pos + 1);

	return true;
}

bool IsNativeProcess(HANDLE hTargetProc)
{
	BOOL bWOW64 = FALSE;
	IsWow64Process(hTargetProc, &bWOW64);

	return (bWOW64 == FALSE);
}

ULONG GetSessionId(HANDLE hTargetProc, NTSTATUS & ntRetOut)
{
	PROCESS_SESSION_INFORMATION psi{ 0 };
	ntRetOut = NATIVE::NtQueryInformationProcess(hTargetProc, PROCESSINFOCLASS::ProcessSessionInformation, &psi, sizeof(psi), nullptr);
	if (NT_FAIL(ntRetOut))
	{
		return SESSION_ID_INVALID;
	}

	return psi.SessionId;
}

bool IsElevatedProcess(HANDLE hTargetProc)
{
	HANDLE hToken = nullptr;
	if (!OpenProcessToken(hTargetProc, TOKEN_QUERY, &hToken))
	{
		return false;
	}

	TOKEN_ELEVATION te{ 0 };
	DWORD SizeOut = 0;
	GetTokenInformation(hToken, TokenElevation, &te, sizeof(te), &SizeOut);

	CloseHandle(hToken);
	
	return (te.TokenIsElevated != 0);
}

void ErrorLog(const ERROR_INFO & info)
{
	auto FullPath = g_RootPathW + L"GH_Inj_Log.txt";

	time_t time_raw	= time(nullptr);
	tm time_info;
	localtime_s(&time_info, &time_raw);
	wchar_t szTime[30]{ 0 };
	wcsftime(szTime, 30, L"%d-%m-%Y %H:%M:%S", &time_info);

	std::wstring szWinCurrentBuild	= std::format(L"{:d}", GetOSBuildVersion());
	std::wstring szWinReleaseId		= BuildNumberToVersionString(GetOSBuildVersion());
	
	std::wstring WinProductName;
	switch (GetOSVersion())
	{
		case g_Win7:
			WinProductName = L"Windows 7";
			break;
			
		case g_Win8:
			WinProductName = L"Windows 8";
			break;

		case g_Win81:
			WinProductName = L"Windows 8.1";
			break;

		default:
			WinProductName = L"Windows 10";
	}

	if (GetOSVersion() == g_Win10 && GetOSBuildVersion() >= g_Win11_21H2)
	{
		WinProductName = L"Windows 11";
	}

	auto Flags			= std::format(L"{:08X}", info.Flags);
	auto ErrorCode		= std::format(L"{:08X}", info.ErrorCode);
	auto AdvErrorCode	= std::format(L"{:08X}", info.AdvErrorCode);
	auto HandleValue	= std::format(L"{:08X}", info.HandleValue);

	auto RawSize = std::format(L"{:08X}", info.RawSize);
#ifdef _WIN64
	auto RawData = std::format(L"{:016X}", ReCa<ULONG_PTR>(info.RawData));
#else
	auto RawData = std::format(L"{:08X}", ReCa<ULONG_PTR>(info.RawData));
#endif

	std::wstringstream old_log;
	std::wifstream error_log_in(FullPath);
	if (error_log_in.good())
	{
		old_log << error_log_in.rdbuf();
		error_log_in.close();
	}
	
	std::wofstream error_log_out(FullPath, std::ios::out | std::ios::trunc);
	if (!error_log_out.good())
	{
		LOG(1, "Failed to open/create error log file:\n%ls\n", FullPath.c_str());

		return;
	}

	error_log_out << szTime																															<< std::endl;
	error_log_out << L"Version            : "	<< L"GH Injector V" << GH_INJ_VERSION																<< std::endl;

	if (szWinReleaseId.length() > 1)
	{
		error_log_out << L"OS                 : " << WinProductName << L" " << szWinReleaseId << L" (Build " << szWinCurrentBuild << L")" << std::endl;
	}
	else
	{
		error_log_out << L"OS                 : " << WinProductName << L" (Build " << szWinCurrentBuild << L")" << std::endl;
	}
	
	if (info.RawData)
	{
		error_log_out << L"RawData            : 0x" << RawData << std::endl;
		error_log_out << L"RawSize            : 0x" << RawSize << L" bytes" << std::endl;
	}
	else
	{
		error_log_out << L"File               : " << info.DllFileName.c_str() << std::endl;
	}

	error_log_out << L"Target             : "	<< info.TargetProcessExeFileName.c_str()												<< std::endl;
	error_log_out << L"Target PID         : "	<< info.TargetProcessId																	<< std::endl;
	error_log_out << L"Source             : "	<< info.SourceFile << L" in " << info.FunctionName << L" at line " << info.Line			<< std::endl;
	error_log_out << L"Errorcode          : 0x"	<< ErrorCode																			<< std::endl;
	error_log_out << L"Advanced errorcode : 0x"	<< AdvErrorCode																			<< std::endl;
	error_log_out << L"Injectionmode      : "	<< InjectionModeToString(info.InjectionMode)											<< std::endl;
	error_log_out << L"Launchmethod       : "	<< LaunchMethodToString(info.LaunchMethod)												<< std::endl;
	error_log_out << L"Platform           : "	<< (info.bNative > 0 ? L"x64/x86 (native)" : (info.bNative == 0 ? L"wow64" : L"---"))	<< std::endl;
	error_log_out << L"HandleValue        : 0x"	<< HandleValue																			<< std::endl;
	error_log_out << L"Flags              : 0x"	<< Flags																				<< std::endl;

	if (info.IsDotNet)
	{
		error_log_out << L".NET Version       : " << info.Version	<< std::endl;
		error_log_out << L"Namespace          : " << info.Namespace << std::endl;
		error_log_out << L"Classname          : " << info.ClassName << std::endl;
		error_log_out << L"Method             : " << info.Method	<< std::endl;
		error_log_out << L"Argument           : " << info.Argument	<< std::endl;
	}

	error_log_out << std::endl;

	if (old_log.rdbuf()->in_avail() > 0)
	{
		error_log_out << old_log.rdbuf();
	}

	error_log_out.close();
}

std::wstring CharArrayToStdWstring(const char * szString)
{
	if (!szString)
	{
		return std::wstring();
	}

	std::string s(szString);
	std::vector<char> v(s.begin(), s.end());
	return std::wstring(v.begin(), v.end());
}

bool StdWStringToWCharArray(const std::wstring & Source, wchar_t * szBuffer, size_t Size)
{
	if (!szBuffer)
	{
		return false;
	}

	auto len = Source.length();
	if (len >= Size)
	{
		return false;
	}

	Source.copy(szBuffer, len);
	szBuffer[len + 1] = '\0';

	return true;
}

std::wstring InjectionModeToString(INJECTION_MODE mode)
{
	switch (mode)
	{
		case INJECTION_MODE::IM_LoadLibraryExW:
			return std::wstring(L"LoadLibraryExW");

		case INJECTION_MODE::IM_LdrLoadDll:
			return std::wstring(L"LdrLoadDll");

		case INJECTION_MODE::IM_LdrpLoadDll:
			return std::wstring(L"LdrpLoadDll");

		case INJECTION_MODE::IM_LdrpLoadDllInternal:
			return std::wstring(L"LdrpLoadDllInternal");

		case INJECTION_MODE::IM_ManualMap:
			return std::wstring(L"ManualMap");

		default:
			break;
	}

	return std::wstring(L"bruh moment");
}

std::wstring LaunchMethodToString(LAUNCH_METHOD method)
{
	switch (method)
	{
		case LAUNCH_METHOD::LM_NtCreateThreadEx:
			return std::wstring(L"NtCreateThreadEx");

		case LAUNCH_METHOD::LM_HijackThread:
			return std::wstring(L"HijackThread");

		case LAUNCH_METHOD::LM_SetWindowsHookEx:
			return std::wstring(L"SetWindowsHookEx");

		case LAUNCH_METHOD::LM_QueueUserAPC:
			return std::wstring(L"QueueUserAPC");

		case LAUNCH_METHOD::LM_KernelCallback:
			return std::wstring(L"KernelCallback");

		case LAUNCH_METHOD::LM_FakeVEH:
			return std::wstring(L"FakeVEH");

		default:
			break;
	}

	return std::wstring(L"bruh moment");
}

std::wstring BuildNumberToVersionString(int OSBuildNumber)
{
	switch (OSBuildNumber)
	{
		case g_Win7_SP1:
		case g_Win8_SP1:
			return std::wstring(L"SP1");

		case g_Win10_1507:
			return std::wstring(L"1507");

		case g_Win10_1511:
			return std::wstring(L"1511");

		case g_Win10_1607:
			return std::wstring(L"1607");

		case g_Win10_1703:
			return std::wstring(L"1703");

		case g_Win10_1709:
			return std::wstring(L"1709");

		case g_Win10_1803:
			return std::wstring(L"1803");

		case g_Win10_1809:
			return std::wstring(L"1809");

		case g_Win10_1903:
			return std::wstring(L"1903");

		case g_Win10_1909:
			return std::wstring(L"1909");

		case g_Win10_2004:
			return std::wstring(L"2004");

		case g_Win10_20H2:
			return std::wstring(L"20H2");

		case g_Win10_21H1:
			return std::wstring(L"21H1");

		case g_Win10_21H2:
			return std::wstring(L"21H2");

		case g_Win10_22H2:
			return std::wstring(L"22H2");

		case g_Win11_21H2:
			return std::wstring(L"21H2");

		case g_Win11_22H2:
			return std::wstring(L"22H2");

		default:
			return std::wstring(L"");
	}
}

#if !defined(_WIN64) && defined(DUMP_SHELLCODE)

int section_index = 0;

void DumpShellcode(BYTE * start, int length, const wchar_t * szShellname)
{
	auto FullPath = g_RootPathW;
	FullPath += L"Shellcodes.txt";

	std::wofstream shellcodes(FullPath, std::ios_base::out | std::ios_base::app);
	if (!shellcodes.good())
	{
		LOG(2, "Failed to open/create Shellcodes.txt:\n%ls\n", FullPath.c_str());

		return;
	}

	++section_index;

	wchar_t sec_idx[3]{ 0 };
	swprintf_s(sec_idx, 3, L"%02X", section_index);

	shellcodes << "#pragma section(\"wow64_sec$" << sec_idx << "\", read, write)\n";
	shellcodes << "__declspec(allocate(\"wow64_sec$" << sec_idx << "\"))";
	shellcodes << L" inline unsigned char " << szShellname << L"[] =\n{";

	int row_length = 500;
	int char_count = 6 * length - 2 + (length / row_length + 1) * 2 + 1; 
	wchar_t * array_out = new(std::nothrow) wchar_t[char_count]();

	if (!array_out)
	{
		LOG(2, "Failed to allocate buffer for shellcode data\n");
	
		shellcodes.close();
	}

	int idx = 0;

	for (auto i = 0; i < length; ++i)
	{
		if (!(i % row_length))
		{
			array_out[idx++] = '\n';
			array_out[idx++] = '\t';
		}

		swprintf_s(&array_out[idx], char_count - idx, L"0x%02X", start[i]);

		idx += 4;

		if (i == length - 1)
		{
			break;
		}

		array_out[idx++] = ',';
		array_out[idx++] = ' ';
	}

	shellcodes << array_out;
	shellcodes << L"\n};\n\n";

	shellcodes.close();
}

#endif

float __stdcall GetDownloadProgress(bool bWow64)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	return GetDownloadProgressEx(0, bWow64);
}

float __stdcall GetDownloadProgressEx(int index, bool bWow64)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	if (index == PDB_DOWNLOAD_INDEX_NTDLL)
	{
#ifdef _WIN64
		if (bWow64)
		{
			return sym_ntdll_wow64.GetDownloadProgress();
		}
		else
		{
			return sym_ntdll_native.GetDownloadProgress();
		}
#else
		UNREFERENCED_PARAMETER(bWow64);

		return sym_ntdll_native.GetDownloadProgress();
#endif
	}
	else if (index == PDB_DOWNLOAD_INDEX_KERNEL32 && GetOSVersion() == g_Win7)
	{
#ifdef _WIN64
		if (bWow64)
		{
			return sym_kernel32_wow64.GetDownloadProgress();
		}
		else
		{
			return sym_kernel32_native.GetDownloadProgress();
		}
#else
		UNREFERENCED_PARAMETER(bWow64);

		return sym_kernel32_native.GetDownloadProgress();
#endif
	}

	return 0.0f;
}

void __stdcall StartDownload()
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "Beginning download(s)\n");

	sym_ntdll_native.SetDownload(true);

#ifdef _WIN64
	sym_ntdll_wow64.SetDownload(true);
#endif

	if (GetOSVersion() == g_Win7)
	{
		sym_kernel32_native.SetDownload(true);

#ifdef _WIN64
		sym_kernel32_wow64.SetDownload(true);
#endif
	}
}

void __stdcall InterruptDownload()
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	LOG(0, "Interupting download thread(s)\n");

	sym_ntdll_native.Interrupt();

#ifdef _WIN64
	sym_ntdll_wow64.Interrupt();
#endif

	if (GetOSVersion() == g_Win7)
	{
		sym_kernel32_native.Interrupt();

#ifdef _WIN64
		sym_kernel32_wow64.Interrupt();
#endif
	}

	SetEvent(g_hInterruptImport);

	LOG(0, "Waiting for download thread(s) to exit\n");

	while (sym_ntdll_native_ret.wait_for(std::chrono::milliseconds(50)) != std::future_status::ready);
	LOG(0, "ntdll.pdb download thread exited successfully\n");

#ifdef _WIN64
	while (sym_ntdll_native_ret.wait_for(std::chrono::milliseconds(50)) != std::future_status::ready);
	LOG(0, "wntdll.pdb download thread exited successfully\n");
#endif
	
	if (GetOSVersion() == g_Win7)
	{
		while (sym_kernel32_native_ret.wait_for(std::chrono::milliseconds(50)) != std::future_status::ready);
		LOG(0, "kernel32.pdb download thread exited successfully\n");

#ifdef _WIN64
		while (sym_kernel32_wow64_ret.wait_for(std::chrono::milliseconds(50)) != std::future_status::ready);
		LOG(0, "wkernel32.pdb download thread exited successfully\n");
#endif
	}

	while (import_handler_ret.wait_for(std::chrono::milliseconds(50)) != std::future_status::ready);
	LOG(0, "Import handler thread (native) exited successfully\n");

#ifdef _WIN64
	while (import_handler_wow64_ret.wait_for(std::chrono::milliseconds(50)) != std::future_status::ready);
	LOG(0, "Import handler thread (wow64) exited successfully\n");
#endif
}

DWORD __stdcall InterruptDownloadEx(void * pArg)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	UNREFERENCED_PARAMETER(pArg);

	InterruptDownload();

	return 0;
}

bool __stdcall InterruptInjection(DWORD Timeout)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	auto ret = WaitForSingleObject(g_hRunningEvent, 0);
	if (ret != WAIT_OBJECT_0)
	{
		LOG(0, "No injection running\n");

		return false;
	}

	if (!SetEvent(g_hInterruptEvent))
	{
		LOG(0, "Failed to set interrupt event: %08X\n", GetLastError());

		return false;
	}

	ret = WaitForSingleObject(g_hInterruptedEvent, Timeout);
	if (ret != WAIT_OBJECT_0)
	{
		if (ret == WAIT_FAILED)
		{
			LOG(0, "Interrupt failed:\n", GetLastError());
		}
		else
		{
			LOG(0, "Interrupt timed out: %08X\n", ret);
		}

		return false;
	}

	LOG(0, "Successfully interrupted injection thread\n");

	return true;
}

DWORD __stdcall InterruptInjectionEx(void * Timeout)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	return InterruptInjection(MDWD(Timeout));
}

DWORD CreateTempFileCopy(std::wstring & FilePath, DWORD & win32err)
{
	auto FileNamePos = FilePath.find_last_of('\\');
	if (FileNamePos == std::wstring::npos)
	{
		return INJ_ERR_INVALID_FILEPATH;
	}

	auto FileName = std::wstring(FilePath.substr(FileNamePos + 1));
	
	wchar_t szTempPath[MAXPATH_IN_TCHAR]{ 0 };
	if (!GetTempPathW(sizeof(szTempPath) / sizeof(wchar_t), szTempPath))
	{
		win32err = GetLastError();

		return INJ_ERR_CANT_GET_TEMP_DIR;
	}

	std::wstring TempPath = szTempPath;
	TempPath += FileName;

	if (!CopyFileW(FilePath.c_str(), TempPath.c_str(), FALSE))
	{
		win32err = GetLastError();

		return INJ_ERR_CANT_COPY_FILE;
	}

	FilePath = TempPath;

	return FILE_ERR_SUCCESS;
}

DWORD ScrambleFileName(std::wstring & FilePath, UINT Length, DWORD & win32err)
{
	auto FileNamePos = FilePath.find_last_of('\\');
	if (FileNamePos == std::wstring::npos)
	{
		return INJ_ERR_INVALID_FILEPATH;
	}

	auto NewPath = std::wstring(FilePath.substr(0, FileNamePos + 1));
	
	int seed = rand() + (int)(MDWD(&NewPath) & 0x7FFFFFFF); //epic rng
	LARGE_INTEGER pfc{ 0 };
	QueryPerformanceCounter(&pfc);
	seed += pfc.LowPart;
	srand(seed);

	for (UINT i = 0; i != Length; ++i)
	{
		auto val = rand() % 3;
		if (val == 0)
		{
			val = rand() % 10;
			NewPath += wchar_t('0' + val);
		}
		else if (val == 1)
		{
			val = rand() % 26;
			NewPath += wchar_t('A' + val);
		}
		else
		{
			val = rand() % 26;
			NewPath += wchar_t('a' + val);
		}
	}
	NewPath += L".dll";

	auto ren_ret = _wrename(FilePath.c_str(), NewPath.c_str());
	if (ren_ret)
	{
		win32err = (DWORD)errno;

		return INJ_ERR_CANT_RENAME_FILE;
	}

	FilePath = NewPath;

	return FILE_ERR_SUCCESS;
}

```

`GH Injector Library/Tools.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "pch.h"

#include "Error.h"
#include "NT Defs.h"
#include "NT Funcs.h"

//Filenames

#define GH_INJ_MOD_NAME64W L"GH Injector - x64.dll"
#define GH_INJ_MOD_NAME86W L"GH Injector - x86.dll"
#define GH_INJ_VERSIONW L"4.8"

#define GH_INJ_MOD_NAME64A "GH Injector - x64.dll"
#define GH_INJ_MOD_NAME86A "GH Injector - x86.dll"
#define GH_INJ_VERSIONA "4.8"

#ifdef _WIN64
#define GH_INJ_MOD_NAMEW GH_INJ_MOD_NAME64W
#define GH_INJ_MOD_NAMEA GH_INJ_MOD_NAME64A
#else
#define GH_INJ_MOD_NAMEW GH_INJ_MOD_NAME86W
#define GH_INJ_MOD_NAMEA GH_INJ_MOD_NAME86A
#endif

#ifdef UNICODE
#define GH_INJ_MOD_NAME GH_INJ_MOD_NAMEW
#define GH_INJ_VERSION GH_INJ_VERSIONW
#else
#define GH_INJ_MOD_NAME GH_INJ_MOD_NAMEA
#define GH_INJ_VERSION GH_INJ_VERSIONA
#endif

//Global macro round up addresses and offsets
#define ALIGN_UP(X, A) ((ULONG_PTR)X + (A - 1)) & (~(A - 1))

//String stuff
#define MAXPATH_IN_TCHAR	MAX_PATH
#define MAXPATH_IN_BYTE_A	MAX_PATH * sizeof(char)
#define MAXPATH_IN_BYTE_W	MAX_PATH * sizeof(wchar_t)
#define MAXPATH_IN_BYTE		MAX_PATH * sizeof(TCHAR)

#define PDB_DOWNLOAD_INDEX_NTDLL	(int)0
#define PDB_DOWNLOAD_INDEX_KERNEL32 (int)1

#define SESSION_ID_INVALID		(ULONG)-1
#define SESSION_ID_LOCAL_SYSTEM (ULONG)0

//Global variable to store the base address of the current image of the injector. Initialized in DllMain.
inline HINSTANCE g_hInjMod = NULL;

struct ERROR_INFO
	//A structure used to pass information to the error log function.
{
	std::wstring	DllFileName;
	std::wstring	TargetProcessExeFileName;
	DWORD			TargetProcessId;
	INJECTION_MODE	InjectionMode;
	LAUNCH_METHOD	LaunchMethod;
	DWORD			Flags;
	DWORD			ErrorCode;
	DWORD			AdvErrorCode;
	DWORD			HandleValue;
	int				bNative;
	std::wstring	SourceFile;
	std::wstring	FunctionName;
	int				Line;

	//from memory only
	BYTE *	RawData;
	DWORD	RawSize;

	//.NET only
	bool			IsDotNet;
	std::wstring	Version;
	std::wstring	Namespace;
	std::wstring	ClassName;
	std::wstring	Method;
	std::wstring	Argument;	
};

struct INJECTION_SOURCE
{
	std::wstring DllPath;

	BYTE *	RawData		= nullptr;
	DWORD	RawSize		= 0;
	bool	FromMemory	= false;
};

//Global variable to store the root directory of the module (including '\\' at the end)
inline std::wstring	g_RootPathW;

inline DWORD g_OSVersion = 0;
inline DWORD g_OSBuildNumber = 0;

#define g_Win7	61
#define g_Win8	62
#define g_Win81	63
#define g_Win10	100
#define g_Win11	100

#define g_Win7_SP1 7601
#define g_Win8_SP1 9600
#define g_Win10_1507 10240
#define g_Win10_1511 10586
#define g_Win10_1607 14393
#define g_Win10_1703 15063
#define g_Win10_1709 16299
#define g_Win10_1803 17134
#define g_Win10_1809 17763
#define g_Win10_1903 18362
#define g_Win10_1909 18363
#define g_Win10_2004 19041
#define g_Win10_20H2 19042
#define g_Win10_21H1 19043
#define g_Win10_21H2 19044
#define g_Win10_22H2 19045
#define g_Win11_21H2 22000
#define g_Win11_22H2 22621

bool IsWin7OrGreater();
bool IsWin8OrGreater();
bool IsWin81OrGreater();
bool IsWin10OrGreater();
bool IsWin11OrGreater();
//These functions are used to determine the currently running version of windows. GetNTDLLVersion needs to be successfully called before these work.
//
//Arguements:
//		none
//
//Returnvalue (bool):
///		true:	Running OS is equal or newer than specified in the function name.
///		false:	Running OS is older than specified in the function name.

DWORD GetOSVersion(DWORD * error_code = nullptr);
//This function is used to determine the version of the operating system.
// 
//Arguments:
//		errode_code (DWORD *):
///			A reference to a DWORD which will receive an error code if the function fails (optional).
//
//Returnvalue (DWORD):
///		On success:	The version of the operating system to 1 decimal place (multiplied by 10 as an integer)
///		On failure:	0.

DWORD GetOSBuildVersion();
//This function is used to determine the build version of the operating system.
// 
//Arguments:
//		none
//
//Returnvalue (DWORD):
///		On success:	The build version of the operating system.
///		On failure:	0.
/// 
bool FileExistsW(const std::wstring & FilePath);
//A function to quickly check whether a file exists or not.
//
//Arguments:
//		FilePath (const std::wstring &):
///			A reference to an std::wstring object which contains the path to the to be verified file.
//
//Returnvalue (bool):
///		true:	the file exists.
///		false:	the file doesn't exist.

DWORD ValidateDllFile(const std::wstring & FilePath, DWORD target_machine);
//A function used to verify whether the file fits the requirements of current injection settings.
//
//Arguments:
//		FilePath (const std::wstring &):
///			A reference to an std::wstring object containing the full path to the file.
//		target_machine (DWORD):
///			A value to be compared to the Machine member of the files IMAGE_FILE_HEADER.
//
//Returnvalue (DWORD):
///		On success: 0.
///		On failure: an errocode from Error.h.

DWORD ValidateDllFileInMemory(const BYTE * RawData, DWORD RawSize, DWORD target_machine);
//A function used to verify whether the file in memory fits the requirements of current injection settings.
//
//Arguments:
//		FilePath (const BYTE * ):
///			A pointer to the raw data of the file.
//		RawSize (DWORD):
///			The size of the raw data in bytes.
//		target_machine (DWORD):
///			A value to be compared to the Machine member of the files IMAGE_FILE_HEADER.
//
//Returnvalue (DWORD):
///		On success: 0.
///		On failure: an errocode from Error.h.

bool GetOwnModulePathA(std::string & out);
bool GetOwnModulePathW(std::wstring & out);
//A function to get the filepath to the file of this image of the injector.
//
//Arguments:
//		out (std::(w)string &):
///			A reference to an std::(w)string object which will recieve the path.
//
//Returnvalue (bool):
///		true:	out now contains the path.
///		false:	error enumerating the modules.

bool IsNativeProcess(HANDLE hTargetProc);
//A function to determine whether a process runs natively or under WOW64.
//
//Arguments:
//		hTargetProc (HANDLE):
///			A handle to the desired process. This handle must have the PROCESS_QUERY_LIMITED_INFORMATION or PROCESS_QUERY_INFORMATION access right.
//
//Returnvalue (bool):
///		true: the specified process runs natively.
///		false: the specified process doesn't run natively.

ULONG GetSessionId(HANDLE hTargetProc, NTSTATUS & ntRetOut);
//A function to retrieve the session identifier of a process.
//
//Arguments:
//		hTargetproc (HANDLE):
///			A handle to the desired process. This handle must have the PROCESS_QUERY_LIMITED_INFORMATION or PROCESS_QUERY_INFORMATION access right.
//		ntRetOut (NTSTATUS &):
///			A reference to an NTSTATUS variable which will receive the returnvalue of NtQueryInformationProcess.
//
//Returnvalue (ULONG):
///		On success: The session identifier of the specified process.
///		On failure: -1, check ntRetOut for more information.

bool IsElevatedProcess(HANDLE hTargetProc);
//A function used to determine whether a process is running elevated or not (administrator vs. user).
//
//Arguments:
//		hTargetproc (HANDLE):
///			A handle to the desired process. This handle must have the PROCESS_QUERY_INFORMATION access right.
//
//Returnvalue (bool):
///		true:	process is elevated.
///		false:	process is not elevated.

void ErrorLog(const ERROR_INFO & info);
//A function used to generate an error log file in case shit hit the fan for some reason.
//
//Arguments:
//		info (ERROR_INFO *):
///			A pointer to an ERROR_INFO structure which contains information about what went wrong.
//
//Returnvalue (void)

std::wstring CharArrayToStdWstring(const char * szString);
//A function to easily convert an ascii string to a unicode string.
//
//Arguments:
//		szString (const char *)
///			A pointer to a zero terminated ascii string.
//
//Returnvalue (std::wstring):
///		The converted wstring object.

bool StdWStringToWCharArray(const std::wstring & Source, wchar_t * szBuffer, size_t Size);
//This function copies the content of an std::wstring into a wchar_t array of a given size.
//
//Arguments:
//		Source (const std::wstring &):
///			A reference to a string object to be copied.
//		szBuffer (wchar_t *):
///			A pointer to a wchar_t array to be filled with the content of the source string.
//		Size (size_t):
///			The maximum amount of characters to be copied into buffer.
//
//Returnvalue (bool):
///		true: the string has been copied successfully.
///		false: the provided buffer is too small or one of the arguments was invalid.

#if !defined(_WIN64) && defined(DUMP_SHELLCODE)
//Rad function to dump the injection / mapping shells to paste them into "WOW64 Shells.h"
void DumpShellcode(BYTE * start, int length, const wchar_t * szShellname);

//Terrible macro to do terrible things
#define DUMP_WOW64(start, end) DumpShellcode(ReCa<BYTE *>(start), ReCa<BYTE *>(end) - ReCa<BYTE *>(start), L#start L"_WOW64")
#endif

float __stdcall GetDownloadProgress(bool bWow64);
//This function returns the current state of the ntdll PDB download. This function is provided for downward compatibility only. Use GetDownloadProgressEx instead.
//
//Arguments:
//		bWow64 (bool):
///			If true the progress of the WoW64 PDB download will be returned, otherwise the progress of the native pdb download.
//
//Returnvalue (float):
///		A value 0 <= ret <= 1. 1 indicates that the download is finished.

float __stdcall GetDownloadProgressEx(int index, bool bWow64);
//This function returns the current state of the PDB download.
//
//Arguments:
//		index (int):
//			Index of the dll download:
//				PDB_DOWNLOAD_INDEX_NTDLL	(0): ntdll
//				PDB_DOWNLOAD_INDEX_KERNEL32 (1): kernel32 (Windows 7 only)
//		bWow64 (bool):
///			If true the progress of the WoW64 PDB download will be returned, otherwise the progress of the native pdb download.
//
//Returnvalue (float):
///		A value 0 <= ret <= 1. 1 indicates that the download is finished.

void __stdcall StartDownload();
//Starts the download(s) of the PDB file(s).
// 
//Arguments:
//		none
//
//Returnvalue (void)

void __stdcall InterruptDownload();
//Interrupts the download(s) of the PDB file(s). This function returns after all download/imports threads were interrupted.
// 
//Arguments:
//		none
//
//Returnvalue (void)

DWORD __stdcall InterruptDownloadEx(void * pArg);
//A wrapper function for InterruptDownload that is compatible with the f_Routine prototype (and thus compatible with StartRoutine and Create(Remote)Thread/NtCreateThreadEx etc.).
//
//Arguments:
//		pArg (void *):
///			This argument is ignored.
//
//Returnvalue (DWORD):
///		This function returns 0.

bool __stdcall InterruptInjection(DWORD Timeout);
//Interrupts the injection. This can lead to shit hitting the fan really hard and is not recommended.
//
//Arguments:
//		Timeout (DWORD):
///			Timeout in ms for the function to wait to verify that the injection was interrupted.
//
//Returnvalue (bool):
///		true:	the injection thread was interrupted successfully.
///		false:	interrupt failed.

DWORD __stdcall InterruptInjectionEx(void * Timeout);
//A wrapper function for InterruptInjection that is compatible with the f_Routine prototype (and thus compatible with StartRoutine and Create(Remote)Thread/NtCreateThreadEx etc.).
//
//Arguments:
//		Timeout (void *):
///			Not a pointer!
///				On x64: the low 32 bit define the timeout in ms
///				On x86: the timeout in ms
//
//Returnvalue (DWORD):
///		non zero:	the injection thread was interrupted successfully.
///		0:			interrupted failed.

DWORD CreateTempFileCopy(std::wstring & FilePath, DWORD & win32err);
//Simple function to create a copy of a file in the %TEMP% directory.
//
//Arguments:
//		FilePath (std::wstring &):
///			The path to the copied file.
///			On success this variable will recieve the new path.
//		win32errr (DWORD &):
///			A reference to DWORD value which will receive a win32 error code on failure.
//
//Returnvalue (DWORD):
///		On success: FILE_ERR_SUCCESS (0)
///		On failure: an error code specified in Error.h

DWORD ScrambleFileName(std::wstring & FilePath, UINT Length, DWORD & win32err);
//Simple function to scramble the name of an existing file.
//
//Arguments:
//		FilePath (std::wstring &):
///			The path to the renamed file.
///			On success this variable will recieve the new path.
//		Length (UINT):
///			Length of the new name in characters excluding the file extension.
//		win32errr (DWORD &):
///			A reference to DWORD value which will receive a win32 error code on failure.
//
//Returnvalue (DWORD):
///		On success: FILE_ERR_SUCCESS (0)
///		On failure: an error code specified in Error.h
```

`GH Injector Library/VEH Shell.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once
#include "pch.h"

#include "VEH Shell.h"

#pragma optimize( "", off ) //even with volatile this doesn't work, disabling optimizations seems to be the only way

// This code is 100% stolen from DarthTon:
// https://github.com/DarthTon/Blackbone/blob/master/src/BlackBone/ManualMap/MExcept.cpp
// Also Raymond Chen - of course - has written an article about C++ exception handling more than a decade ago:
// https://devblogs.microsoft.com/oldnewthing/20100730-00/?p=13273

#ifdef _WIN64

LONG __declspec(code_seg(".veh_sec$01")) CALLBACK VectoredHandlerShell(EXCEPTION_POINTERS * ExceptionInfo)
{
	volatile auto * pData = ReCa<VEH_SHELL_DATA *>(VEHDATASIG_64);

	if (ExceptionInfo->ExceptionRecord->ExceptionCode == EH_EXCEPTION_NUMBER)
	{
		if (ExceptionInfo->ExceptionRecord->ExceptionInformation[2] >= pData->ImgBase && ExceptionInfo->ExceptionRecord->ExceptionInformation[2] < pData->ImgBase + pData->ImgSize)
		{
			if (ExceptionInfo->ExceptionRecord->ExceptionInformation[0] == EH_PURE_MAGIC_NUMBER1 && ExceptionInfo->ExceptionRecord->ExceptionInformation[3] == 0)
			{
				ExceptionInfo->ExceptionRecord->ExceptionInformation[0] = (ULONG_PTR)EH_MAGIC_NUMBER1;

				ExceptionInfo->ExceptionRecord->ExceptionInformation[3] = pData->ImgBase;
			}
		}
	}

	return EXCEPTION_CONTINUE_SEARCH;
}

#else

__forceinline UINT_PTR bit_rotate_l(UINT_PTR val, int count)
{
	return (val << count) | (val >> (-count));
}

LONG __declspec(code_seg(".veh_sec$01")) CALLBACK VectoredHandlerShell(EXCEPTION_POINTERS * ExceptionInfo)
{
	UNREFERENCED_PARAMETER(ExceptionInfo);

	volatile auto * pData = ReCa<VEH_SHELL_DATA *>(VEHDATASIG_32);
	EXCEPTION_REGISTRATION_RECORD * pERR = nullptr;
	
	pERR = ReCa<EXCEPTION_REGISTRATION_RECORD *>(__readfsdword(0x00));

	if (!pERR)
	{
		return EXCEPTION_CONTINUE_SEARCH;
	}	

	RTL_INVERTED_FUNCTION_TABLE_ENTRY * Entries = nullptr;
	bool UseWin7Table = (pData->OSVersion == g_Win7);

	if (UseWin7Table)
	{
		Entries = &(ReCa<RTL_INVERTED_FUNCTION_TABLE_WIN7 *>(pData->LdrpInvertedFunctionTable))->Entries[0];
	}
	else
	{
		Entries = &pData->LdrpInvertedFunctionTable->Entries[0];
	}

	if (pData->OSVersion >= g_Win81)
	{
		pData->LdrProtectMrdata(FALSE);
	}

	auto cookie = *P_KUSER_SHARED_DATA_COOKIE;

	for (; pERR && pERR != ReCa<EXCEPTION_REGISTRATION_RECORD *>(0xFFFFFFFF) && pERR->Next != ReCa<EXCEPTION_REGISTRATION_RECORD *>(0xFFFFFFFF); pERR = pERR->Next)
	{
		for (ULONG idx = 0; idx < pData->LdrpInvertedFunctionTable->Count; ++idx)
		{
			if (!UseWin7Table && idx == 0)
			{
				continue;
			}

			if (Entries[idx].ImageBase != ReCa<void *>(pData->ImgBase))
			{
				continue;
			}

			if (ReCa<ULONG_PTR>(pERR->Handler) < pData->ImgBase || ReCa<ULONG_PTR>(pERR->Handler) >= pData->ImgBase + pData->ImgSize)
			{
				continue;
			}

			bool NewHandler = false;

			//DecodeSystemPointer
			DWORD ptr_enc = ReCa<DWORD>(Entries[idx].ExceptionDirectory);
			ptr_enc = bit_rotate_l(ptr_enc, cookie & 0x1F);
			ptr_enc ^= cookie;

			DWORD * pStart = ReCa<DWORD *>(ptr_enc);

			for (auto * pRVA = pStart; pRVA != nullptr && pRVA < pStart + 0x100; ++pRVA)
			{
				if (*pRVA == 0)
				{
					*pRVA = ReCa<DWORD>(pERR->Handler) - ReCa<DWORD>(Entries[idx].ImageBase);
										
					Entries[idx].ExceptionDirectorySize++;
					NewHandler = true;					

					break;
				}
				else if (ReCa<DWORD>(pERR->Handler) == ReCa<DWORD>(Entries[idx].ImageBase) + *pRVA)
				{
					break;
				}
			}

			if (NewHandler)
			{
				for (ULONG i = 0; i < Entries[idx].ExceptionDirectorySize; ++i)
				{
					for (ULONG j = Entries[idx].ExceptionDirectorySize - 1; j > i; --j)
					{
						if (pStart[j - 1] > pStart[j])
						{
							//high efficient xor-swap to outperform DarthTon's code 5Head
							pStart[j - 1] ^= pStart[j];
							pStart[j] ^= pStart[j - 1];
							pStart[j - 1] ^= pStart[j];
						}
					}
				}
			}
		}
	}

	if (pData->OSVersion >= g_Win81)
	{
		pData->LdrProtectMrdata(TRUE);
	}

	return EXCEPTION_CONTINUE_SEARCH;
}

#endif

DWORD __declspec(code_seg(".veh_sec$02")) VEH_SEC_END()
{
	return 1339;
}

#pragma optimize( "", on)
```

`GH Injector Library/VEH Shell.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "Injection.h"

#define BASE_ALIGNMENT		0x10

#define EH_MAGIC_NUMBER1        0x19930520    
#define EH_PURE_MAGIC_NUMBER1   0x01994000
#define EH_EXCEPTION_NUMBER     ('msc' | 0xE0000000)

#define VEHDATASIG_32 0xFACEB00C
#define VEHDATASIG_64 0xB16B00B500B16A33

#ifdef  _WIN64
#define VEHDATASIG VEHDATASIG_64
#else
#define VEHDATASIG VEHDATASIG_32
#endif

ALIGN struct VEH_SHELL_DATA
{
	ULONG_PTR	ImgBase;
	DWORD		ImgSize;
	DWORD		OSVersion;

	f_LdrpInvertedFunctionTable LdrpInvertedFunctionTable;
	f_LdrProtectMrdata			LdrProtectMrdata;
};

LONG __declspec(code_seg(".veh_sec$01")) CALLBACK VectoredHandlerShell(EXCEPTION_POINTERS * EP);
DWORD __declspec(code_seg(".veh_sec$02")) VEH_SEC_END();

__forceinline bool FindAndReplacePtr(BYTE * start, DWORD size, UINT_PTR stub, UINT_PTR value)
{
	if (!start)
	{
		return false;
	}

	auto end = start + size - sizeof(UINT_PTR);
	for (; start <= end; ++start)
	{
		if (*ReCa<UINT_PTR *>(start) == stub)
		{
			*ReCa<UINT_PTR *>(start) = value;

			return true;
		}
	}

	return false;
}
```

`GH Injector Library/WOW64 Shells.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#ifdef _WIN64

#pragma section("wow64_sec$01", read, write)
__declspec(allocate("wow64_sec$01")) inline unsigned char InjectionShell_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x28, 0x53, 0x56, 0x8B, 0x75, 0x08, 0x57, 0x85, 0xF6, 0x75, 0x0C, 0x8D, 0x46, 0x01, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x4E, 0x0C, 0x8D, 0x56, 0x18, 0x89, 0x56, 0x14, 0x85, 0xC9, 0x75, 0x2E, 0x8B, 0x86, 0x88, 0x03, 0x00, 0x00, 0x51, 0x51, 0x52, 0xFF, 0xD0, 0x89, 0x06, 0x85, 0xC0, 0x0F, 0x85, 0xC3, 0x01, 0x00, 0x00, 0x8B, 0x86, 0xA0, 0x03, 0x00, 0x00, 0xFF, 0xD0, 0x89, 0x46, 0x04, 0xB8, 0x28, 0x00, 0x00, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x86, 0x78, 0x03, 0x00, 0x00, 0x83, 0xF9, 0x01, 0x75, 0x3F, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x83, 0xF8, 0x3D, 0x75, 0x0B, 0x8B, 0x86, 0xC8, 0x03, 0x00, 0x00, 0x8B, 0x40, 0x04, 0xEB, 0x07, 0x80, 0x4D, 0x08, 0x01, 0x8B, 0x45, 0x08, 0x8B, 0x96, 0x8C, 0x03, 0x00, 0x00, 0x8D, 0x4E, 0x10, 0x56, 0x51, 0x8D, 0x4D, 0xF4, 0x51, 0x50, 0xFF, 0xD2, 0x89, 0x46, 0x04, 0xE9, 0x60, 0x01, 0x00, 0x00, 0x83, 0xF8, 0x64, 0x0F, 0x82, 0xFD, 0x00, 0x00, 0x00, 0x8D, 0xBE, 0x28, 0x03, 0x00, 0x00, 0x33, 0xC0, 0x89, 0x57, 0x10, 0x81, 0xBE, 0x7C, 0x03, 0x00, 0x00, 0x5A, 0x29, 0x00, 0x00, 0xC7, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x89, 0x45, 0xF8, 0x75, 0x06, 0x89, 0x57, 0x0C, 0x89, 0x47, 0x10, 0x83, 0x7E, 0x0C, 0x02, 0x8D, 0x4E, 0x10, 0x75, 0x40, 0x81, 0xBE, 0x7C, 0x03, 0x00, 0x00, 0xEE, 0x42, 0x00, 0x00, 0x8D, 0x55, 0x08, 0x8B, 0x9E, 0x90, 0x03, 0x00, 0x00, 0x52, 0x8B, 0xD7, 0x77, 0x07, 0x6A, 0x01, 0x50, 0xFF, 0xD3, 0xEB, 0x03, 0x50, 0xFF, 0xD3, 0x89, 0x46, 0x04, 0x8B, 0x4D, 0x08, 0x85, 0xC9, 0x0F, 0x84, 0x9D, 0x01, 0x00, 0x00, 0x8B, 0x86, 0x9C, 0x03, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x45, 0x08, 0xE9, 0xE2, 0x00, 0x00, 0x00, 0x8D, 0x55, 0xF8, 0x8D, 0x86, 0x28, 0x02, 0x00, 0x00, 0x52, 0x89, 0x86, 0x24, 0x02, 0x00, 0x00, 0x8D, 0x96, 0x20, 0x02, 0x00, 0x00, 0x8B, 0x86, 0x98, 0x03, 0x00, 0x00, 0x6A, 0x00, 0xFF, 0xD0, 0x81, 0xBE, 0x7C, 0x03, 0x00, 0x00, 0xF0, 0x55, 0x00, 0x00, 0x8D, 0x4D, 0xF4, 0x89, 0x46, 0x04, 0x8B, 0xD7, 0x8B, 0x86, 0x94, 0x03, 0x00, 0x00, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x72, 0x1A, 0x6A, 0x00, 0x51, 0x8D, 0x4D, 0x08, 0x51, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x04, 0xFF, 0x75, 0xF8, 0x8D, 0x8E, 0x20, 0x02, 0x00, 0x00, 0xFF, 0xD0, 0xEB, 0x16, 0x51, 0x8D, 0x4D, 0x08, 0x51, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x04, 0xFF, 0x75, 0xF8, 0x8D, 0x8E, 0x20, 0x02, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x45, 0xF4, 0x85, 0xC0, 0x0F, 0x89, 0x69, 0xFF, 0xFF, 0xFF, 0x89, 0x46, 0x04, 0xB8, 0x2B, 0x00, 0x00, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x83, 0xF8, 0x3F, 0x75, 0x6B, 0x83, 0xF9, 0x02, 0x0F, 0x85, 0x23, 0x04, 0x00, 0x00, 0x8B, 0x86, 0x90, 0x03, 0x00, 0x00, 0x8D, 0x4D, 0xF4, 0x51, 0x8D, 0x4D, 0x08, 0xC7, 0x45, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x51, 0x0F, 0x57, 0xC0, 0xC7, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x45, 0xE0, 0x6A, 0x01, 0x89, 0x55, 0xEC, 0x8D, 0x4E, 0x10, 0x6A, 0x00, 0x8D, 0x55, 0xE0, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x89, 0x46, 0x04, 0x8B, 0x45, 0x08,
	0x85, 0xC0, 0x0F, 0x84, 0xAB, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x18, 0x89, 0x06, 0x8B, 0x46, 0x08, 0xA8, 0x07, 0x0F, 0x85, 0xA9, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x83, 0xF8, 0x3E, 0x75, 0x48, 0x83, 0xF9, 0x02, 0x0F, 0x85, 0xB3, 0x03, 0x00, 0x00, 0x8B, 0x8E, 0x90, 0x03, 0x00, 0x00, 0x8D, 0x45, 0xF4, 0x50, 0x8D, 0x45, 0x08, 0xC7, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x50, 0x6A, 0x01, 0x6A, 0x00, 0x8D, 0x45, 0xDC, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x50, 0x0F, 0x57, 0xC0, 0x8D, 0x46, 0x10, 0x0F, 0x11, 0x45, 0xDC, 0x50, 0x66, 0x0F, 0xD6, 0x45, 0xEC, 0x89, 0x55, 0xE0, 0xC6, 0x45, 0xE4, 0x01, 0xFF, 0xD1, 0xEB, 0x8A, 0x83, 0xF8, 0x3D, 0x0F, 0x85, 0x6B, 0x03, 0x00, 0x00, 0x83, 0xF9, 0x02, 0x0F, 0x85, 0x62, 0x03, 0x00, 0x00, 0x8B, 0x8E, 0x90, 0x03, 0x00, 0x00, 0x8D, 0x45, 0x08, 0x50, 0x6A, 0x00, 0x6A, 0x01, 0x6A, 0x00, 0xFF, 0xB6, 0xC8, 0x03, 0x00, 0x00, 0x8D, 0x46, 0x10, 0xC7, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x50, 0xFF, 0xD1, 0x89, 0x46, 0x04, 0x8B, 0x45, 0x08, 0x85, 0xC0, 0x0F, 0x85, 0x55, 0xFF, 0xFF, 0xFF, 0xB8, 0x3A, 0x00, 0x00, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x64, 0x8B, 0x3D, 0x30, 0x00, 0x00, 0x00, 0x85, 0xFF, 0x75, 0x0C, 0x8D, 0x47, 0x2C, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x4F, 0x0C, 0x85, 0xC9, 0x0F, 0x84, 0xF3, 0x02, 0x00, 0x00, 0x83, 0x79, 0x0C, 0x00, 0x0F, 0x84, 0xE9, 0x02, 0x00, 0x00, 0xA8, 0x03, 0x0F, 0x84, 0x8C, 0x00, 0x00, 0x00, 0x8B, 0x0E, 0x8B, 0x41, 0x3C, 0x8B, 0x44, 0x08, 0x54, 0x89, 0x4D, 0xF8, 0x8D, 0x4D, 0xF4, 0x51, 0x6A, 0x40, 0x8D, 0x4D, 0x08, 0x89, 0x45, 0x08, 0x8B, 0x86, 0xB0, 0x03, 0x00, 0x00, 0x51, 0x8D, 0x4D, 0xF8, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x51, 0x6A, 0xFF, 0xFF, 0xD0, 0x89, 0x46, 0x04, 0x8B, 0x46, 0x08, 0xA8, 0x01, 0x74, 0x10, 0xFF, 0x75, 0x08, 0x8B, 0x86, 0xA8, 0x03, 0x00, 0x00, 0xFF, 0x75, 0xF8, 0xFF, 0xD0, 0xEB, 0x28, 0xA8, 0x02, 0x74, 0x24, 0x8B, 0x47, 0x0C, 0x8B, 0x40, 0x0C, 0x8B, 0x00, 0x85, 0xC0, 0x0F, 0x84, 0x85, 0x02, 0x00, 0x00, 0xFF, 0x75, 0x08, 0xFF, 0x70, 0x18, 0x8B, 0x86, 0xA4, 0x03, 0x00, 0x00, 0xFF, 0x75, 0xF8, 0xFF, 0xD0, 0x83, 0xC4, 0x0C, 0x8B, 0x86, 0xB0, 0x03, 0x00, 0x00, 0x8D, 0x4D, 0xF4, 0x51, 0xFF, 0x75, 0xF4, 0x8D, 0x4D, 0x08, 0x51, 0x8D, 0x4D, 0xF8, 0x51, 0x6A, 0xFF, 0xFF, 0xD0, 0x89, 0x46, 0x04, 0xF6, 0x46, 0x08, 0x04, 0x0F, 0x84, 0x8D, 0xFE, 0xFF, 0xFF, 0x8B, 0x47, 0x0C, 0x8B, 0x78, 0x0C, 0x83, 0xC0, 0x0C, 0x3B, 0xF8, 0x74, 0x11, 0x8B, 0x0E, 0x66, 0x90, 0x8B, 0x57, 0x18, 0x3B, 0xD1, 0x74, 0x14, 0x8B, 0x3F, 0x3B, 0xF8, 0x75, 0xF3, 0xB8, 0x13, 0x00, 0x00, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x8E, 0x84, 0x03, 0x00, 0x00, 0x8B, 0x9E, 0x80, 0x03, 0x00, 0x00, 0x83, 0xC1, 0x0F, 0x03, 0xD9, 0x83, 0xE3, 0xF0, 0x89, 0x13, 0x8B, 0x47, 0x20, 0x89, 0x43, 0x04, 0x8B, 0x86, 0x78, 0x03, 0x00, 0x00, 0x89, 0x43, 0x08, 0x8B, 0x86, 0xBC, 0x03, 0x00, 0x00, 0x89, 0x43, 0x0C, 0x8B, 0x86, 0xB8, 0x03, 0x00, 0x00, 0x89, 0x43, 0x10, 0x8B, 0x8E, 0x80, 0x03, 0x00, 0x00,
	0x85, 0xC9, 0x74, 0x35, 0x8B, 0x86, 0x84, 0x03, 0x00, 0x00, 0x83, 0xC0, 0xFC, 0x03, 0xC1, 0x3B, 0xC8, 0x77, 0x26, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x81, 0x39, 0x0C, 0xB0, 0xCE, 0xFA, 0x74, 0x07, 0x41, 0x3B, 0xC8, 0x76, 0xF3, 0xEB, 0x12, 0x89, 0x19, 0xFF, 0xB6, 0x80, 0x03, 0x00, 0x00, 0x8B, 0x86, 0xB4, 0x03, 0x00, 0x00, 0x6A, 0x00, 0xFF, 0xD0, 0x8B, 0x07, 0x85, 0xC0, 0x74, 0x11, 0x8B, 0x4F, 0x04, 0x85, 0xC9, 0x74, 0x0A, 0x89, 0x48, 0x04, 0x8B, 0x4F, 0x04, 0x8B, 0x07, 0x89, 0x01, 0x8B, 0x47, 0x10, 0x85, 0xC0, 0x74, 0x12, 0x8B, 0x4F, 0x14, 0x85, 0xC9, 0x74, 0x0B, 0x89, 0x48, 0x04, 0x8B, 0x4F, 0x14, 0x8B, 0x47, 0x10, 0x89, 0x01, 0x8B, 0x47, 0x08, 0x85, 0xC0, 0x74, 0x12, 0x8B, 0x4F, 0x0C, 0x85, 0xC9, 0x74, 0x0B, 0x89, 0x48, 0x04, 0x8B, 0x4F, 0x0C, 0x8B, 0x47, 0x08, 0x89, 0x01, 0x8B, 0x47, 0x3C, 0x85, 0xC0, 0x74, 0x12, 0x8B, 0x4F, 0x40, 0x85, 0xC9, 0x74, 0x0B, 0x89, 0x48, 0x04, 0x8B, 0x4F, 0x40, 0x8B, 0x47, 0x3C, 0x89, 0x01, 0x33, 0xC0, 0xC7, 0x45, 0x08, 0x2C, 0x00, 0x00, 0x00, 0x83, 0xBE, 0x78, 0x03, 0x00, 0x00, 0x3D, 0xBB, 0xB8, 0x00, 0x00, 0x00, 0x89, 0x45, 0xF4, 0x75, 0x55, 0x8B, 0x47, 0x50, 0x85, 0xC0, 0x74, 0x12, 0x8B, 0x4F, 0x54, 0x85, 0xC9, 0x74, 0x0B, 0x89, 0x48, 0x04, 0x8B, 0x4F, 0x54, 0x8B, 0x47, 0x50, 0x89, 0x01, 0x8B, 0x47, 0x58, 0x85, 0xC0, 0x74, 0x12, 0x8B, 0x4F, 0x5C, 0x85, 0xC9, 0x74, 0x0B, 0x89, 0x48, 0x04, 0x8B, 0x4F, 0x5C, 0x8B, 0x47, 0x58, 0x89, 0x01, 0x8B, 0x47, 0x60, 0x85, 0xC0, 0x74, 0x12, 0x8B, 0x4F, 0x64, 0x85, 0xC9, 0x74, 0x0B, 0x89, 0x48, 0x04, 0x8B, 0x4F, 0x64, 0x8B, 0x47, 0x60, 0x89, 0x01, 0xBB, 0x78, 0x00, 0x00, 0x00, 0xE9, 0x8C, 0x00, 0x00, 0x00, 0x8D, 0x47, 0x68, 0x50, 0xFF, 0xB6, 0xC0, 0x03, 0x00, 0x00, 0x8B, 0x86, 0xAC, 0x03, 0x00, 0x00, 0xFF, 0xD0, 0x8D, 0x47, 0x74, 0x50, 0xFF, 0xB6, 0xC4, 0x03, 0x00, 0x00, 0x8B, 0x86, 0xAC, 0x03, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x86, 0x78, 0x03, 0x00, 0x00, 0x83, 0xF8, 0x3E, 0x75, 0x0C, 0x8D, 0x58, 0x5A, 0xC7, 0x45, 0x08, 0x30, 0x00, 0x00, 0x00, 0xEB, 0x4B, 0x83, 0xF8, 0x3F, 0x75, 0x0C, 0x8D, 0x58, 0x61, 0xC7, 0x45, 0x08, 0x30, 0x00, 0x00, 0x00, 0xEB, 0x3A, 0x83, 0xF8, 0x64, 0x72, 0x35, 0x8B, 0x86, 0x7C, 0x03, 0x00, 0x00, 0x3D, 0x5A, 0x29, 0x00, 0x00, 0x77, 0x07, 0xBB, 0xA0, 0x00, 0x00, 0x00, 0xEB, 0x21, 0x3D, 0x39, 0x38, 0x00, 0x00, 0x77, 0x07, 0xBB, 0xA4, 0x00, 0x00, 0x00, 0xEB, 0x13, 0xC7, 0x45, 0x08, 0x2C, 0x00, 0x00, 0x00, 0x3D, 0x64, 0x4A, 0x00, 0x00, 0x77, 0x05, 0xBB, 0xA8, 0x00, 0x00, 0x00, 0x8B, 0x47, 0x50, 0x89, 0x45, 0xF4, 0x0F, 0xB7, 0x47, 0x2E, 0x50, 0xFF, 0x77, 0x30, 0x8B, 0x86, 0xA8, 0x03, 0x00, 0x00, 0xFF, 0xD0, 0x0F, 0xB7, 0x47, 0x26, 0x50, 0xFF, 0x77, 0x28, 0x8B, 0x86, 0xA8, 0x03, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x86, 0xA8, 0x03, 0x00, 0x00, 0x53, 0x57, 0xFF, 0xD0, 0x8B, 0x45, 0xF4, 0x85, 0xC0, 0x0F, 0x84, 0x59, 0xFC, 0xFF, 0xFF, 0xFF, 0x75, 0x08, 0x50, 0x8B, 0x86, 0xA8, 0x03, 0x00, 0x00, 0xFF, 0xD0, 0x33, 0xC0, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xB8, 0x2D, 0x00, 0x00, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x5F, 0x5E, 0xB8, 0x0E,
	0x00, 0x00, 0x00, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$02", read, write)
__declspec(allocate("wow64_sec$02")) inline unsigned char ManualMapping_Shell_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x56, 0x8B, 0x75, 0x08, 0x85, 0xF6, 0x75, 0x0A, 0xB8, 0x01, 0x00, 0x40, 0x00, 0x5E, 0x5D, 0xC2, 0x04, 0x00, 0x57, 0x8B, 0xBE, 0x7C, 0x02, 0x00, 0x00, 0x8D, 0x46, 0x18, 0x89, 0x46, 0x14, 0x8B, 0x87, 0xD8, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x1D, 0x8B, 0x87, 0x88, 0x00, 0x00, 0x00, 0x8B, 0x00, 0x89, 0x87, 0xD8, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x0B, 0x5F, 0xB8, 0x0E, 0x00, 0x40, 0x00, 0x5E, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x87, 0x9C, 0x00, 0x00, 0x00, 0x53, 0x56, 0xFF, 0xD0, 0x8B, 0xD8, 0x56, 0x85, 0xDB, 0x75, 0x78, 0x8B, 0x87, 0xA0, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x56, 0x85, 0xDB, 0x75, 0x69, 0x8B, 0x87, 0xA4, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x56, 0x85, 0xDB, 0x75, 0x5A, 0x8B, 0x87, 0xA8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x56, 0x85, 0xDB, 0x75, 0x4B, 0x8B, 0x87, 0xAC, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x56, 0x85, 0xDB, 0x75, 0x3C, 0x8B, 0x87, 0xB0, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x56, 0x85, 0xDB, 0x75, 0x2D, 0x8B, 0x87, 0xB4, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x56, 0x85, 0xDB, 0x75, 0x1E, 0x8B, 0x87, 0xB8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x56, 0x85, 0xDB, 0x75, 0x0F, 0x8B, 0x87, 0xBC, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x56, 0x85, 0xDB, 0x74, 0x11, 0x8B, 0x8F, 0xC8, 0x00, 0x00, 0x00, 0xFF, 0xD1, 0x8B, 0xC3, 0x5B, 0x5F, 0x5E, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x87, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x87, 0xC4, 0x00, 0x00, 0x00, 0x56, 0xFF, 0xD0, 0x8B, 0x86, 0x60, 0x02, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x06, 0x50, 0x8B, 0x47, 0x08, 0xFF, 0xD0, 0x8B, 0x86, 0x54, 0x02, 0x00, 0x00, 0x5B, 0x89, 0x06, 0x33, 0xC0, 0x5F, 0x5E, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$03", read, write)
__declspec(allocate("wow64_sec$03")) inline unsigned char MMI_MapSections_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x83, 0xEC, 0x1C, 0x53, 0x56, 0x8B, 0x75, 0x08, 0x57, 0xF7, 0x46, 0x04, 0x00, 0x00, 0x00, 0x04, 0x8B, 0xBE, 0x7C, 0x02, 0x00, 0x00, 0x0F, 0x85, 0x6C, 0x02, 0x00, 0x00, 0x66, 0x8B, 0x46, 0x10, 0x0F, 0x57, 0xC0, 0x66, 0x0F, 0x13, 0x44, 0x24, 0x18, 0x68, 0x10, 0x02, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24, 0x1C, 0xB8, 0x10, 0x02, 0x00, 0x00, 0x6A, 0x08, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24, 0x26, 0x8B, 0x47, 0x30, 0xFF, 0xD0, 0x89, 0x44, 0x24, 0x1C, 0x85, 0xC0, 0x0F, 0x84, 0x9A, 0x01, 0x00, 0x00, 0x6A, 0x08, 0x8D, 0x8E, 0x20, 0x02, 0x00, 0x00, 0x51, 0x50, 0x8B, 0x47, 0x28, 0xFF, 0xD0, 0x0F, 0xB7, 0x44, 0x24, 0x24, 0x50, 0x8D, 0x46, 0x18, 0x50, 0x8B, 0x44, 0x24, 0x30, 0x83, 0xC0, 0x08, 0x50, 0x8B, 0x47, 0x28, 0xFF, 0xD0, 0x8B, 0x47, 0x30, 0x83, 0xC4, 0x18, 0x66, 0x83, 0x44, 0x24, 0x18, 0x08, 0x6A, 0x18, 0x6A, 0x08, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x85, 0xDB, 0x75, 0x12, 0x8B, 0x44, 0x24, 0x1C, 0x85, 0xC0, 0x0F, 0x84, 0x4A, 0x01, 0x00, 0x00, 0x50, 0xE9, 0x37, 0x01, 0x00, 0x00, 0x6A, 0x20, 0x6A, 0x01, 0x8D, 0x54, 0x24, 0x28, 0xC7, 0x03, 0x18, 0x00, 0x00, 0x00, 0x52, 0x53, 0x8D, 0x44, 0x24, 0x28, 0xC7, 0x43, 0x04, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x43, 0x0C, 0x40, 0x00, 0x00, 0x00, 0x8D, 0x8E, 0x60, 0x02, 0x00, 0x00, 0x89, 0x43, 0x08, 0x0F, 0x57, 0xC0, 0xC7, 0x43, 0x10, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x43, 0x14, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x07, 0x68, 0x89, 0x00, 0x12, 0x00, 0x51, 0x66, 0x0F, 0x13, 0x44, 0x24, 0x38, 0xFF, 0xD0, 0x53, 0x89, 0x46, 0x08, 0x8B, 0x47, 0x34, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x44, 0x24, 0x1C, 0x85, 0xC0, 0x74, 0x0E, 0x50, 0x8B, 0x47, 0x34, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x83, 0x7E, 0x08, 0x00, 0x7D, 0x0E, 0xB8, 0x02, 0x00, 0x40, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x47, 0x30, 0x6A, 0x18, 0x6A, 0x08, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x85, 0xDB, 0x0F, 0x84, 0xA4, 0x00, 0x00, 0x00, 0x8B, 0x4F, 0x10, 0x8D, 0x44, 0x24, 0x20, 0x6A, 0x05, 0x6A, 0x18, 0x53, 0x50, 0xFF, 0xB6, 0x60, 0x02, 0x00, 0x00, 0xFF, 0xD1, 0x89, 0x46, 0x08, 0x85, 0xC0, 0x79, 0x1C, 0x8B, 0x47, 0x34, 0x53, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xB8, 0x07, 0x00, 0x40, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x03, 0x8D, 0x54, 0x24, 0x10, 0x6A, 0x40, 0x68, 0x00, 0x30, 0x00, 0x00, 0x52, 0x6A, 0x00, 0x8D, 0x8E, 0x58, 0x02, 0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0x8B, 0x47, 0x14, 0x51, 0x6A, 0xFF, 0xFF, 0xD0, 0x89, 0x46, 0x08, 0x85, 0xC0, 0x79, 0x1C, 0x8B, 0x47, 0x34, 0x53, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xB8, 0x08, 0x00, 0x40, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x47, 0x30, 0x6A, 0x08, 0x6A, 0x08, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xC8, 0x89, 0x4C, 0x24, 0x14, 0x85, 0xC9, 0x75, 0x1C, 0x53, 0x8B, 0x47, 0x34, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00,
	0xFF, 0xD0, 0xB8, 0x03, 0x00, 0x40, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x47, 0x0C, 0x6A, 0x0E, 0x6A, 0x08, 0x51, 0x8D, 0x4C, 0x24, 0x2C, 0x51, 0xFF, 0xB6, 0x60, 0x02, 0x00, 0x00, 0xFF, 0xD0, 0x89, 0x46, 0x08, 0x8B, 0x8F, 0xD8, 0x00, 0x00, 0x00, 0x8B, 0x57, 0x34, 0x85, 0xC0, 0x79, 0x14, 0x53, 0x6A, 0x00, 0x51, 0xFF, 0xD2, 0xB8, 0x05, 0x00, 0x40, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xFF, 0x74, 0x24, 0x14, 0x6A, 0x00, 0x51, 0xFF, 0xD2, 0x8B, 0x47, 0x04, 0x8D, 0x4C, 0x24, 0x20, 0x6A, 0x00, 0x6A, 0x00, 0xFF, 0x33, 0xFF, 0xB6, 0x58, 0x02, 0x00, 0x00, 0x51, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x00, 0xFF, 0xB6, 0x60, 0x02, 0x00, 0x00, 0xFF, 0xD0, 0x89, 0x46, 0x08, 0x8B, 0x8F, 0xD8, 0x00, 0x00, 0x00, 0x8B, 0x57, 0x34, 0x53, 0x6A, 0x00, 0x51, 0x85, 0xC0, 0x79, 0x10, 0xFF, 0xD2, 0xB8, 0x04, 0x00, 0x40, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xFF, 0xD2, 0x8B, 0x8E, 0x58, 0x02, 0x00, 0x00, 0x8D, 0x9E, 0x58, 0x02, 0x00, 0x00, 0x8B, 0x56, 0x04, 0x89, 0x8E, 0x64, 0x02, 0x00, 0x00, 0x8B, 0x41, 0x3C, 0x03, 0xC1, 0x89, 0x86, 0x68, 0x02, 0x00, 0x00, 0x8D, 0x48, 0x18, 0x83, 0xC0, 0x04, 0x89, 0x86, 0x70, 0x02, 0x00, 0x00, 0x8B, 0xC2, 0x25, 0x00, 0x00, 0x20, 0x02, 0x89, 0x8E, 0x6C, 0x02, 0x00, 0x00, 0x8B, 0x49, 0x38, 0x89, 0x4C, 0x24, 0x0C, 0x3D, 0x00, 0x00, 0x00, 0x02, 0x75, 0x0A, 0x0F, 0xB7, 0x46, 0x0C, 0x03, 0xC8, 0x89, 0x4C, 0x24, 0x0C, 0xF7, 0xC2, 0x00, 0x00, 0x10, 0x00, 0x74, 0x16, 0x8B, 0x86, 0x3C, 0x02, 0x00, 0x00, 0x05, 0x23, 0x10, 0x00, 0x00, 0x25, 0x00, 0xF0, 0xFF, 0xFF, 0x03, 0xC1, 0x89, 0x44, 0x24, 0x0C, 0x8B, 0x47, 0x14, 0x8D, 0x54, 0x24, 0x0C, 0x6A, 0x40, 0x68, 0x00, 0x30, 0x00, 0x00, 0x52, 0x6A, 0x00, 0x8D, 0x8E, 0x50, 0x02, 0x00, 0x00, 0x51, 0x6A, 0xFF, 0xFF, 0xD0, 0x89, 0x46, 0x08, 0x85, 0xC0, 0x0F, 0x88, 0x9D, 0xFE, 0xFF, 0xFF, 0x8B, 0x46, 0x04, 0x8B, 0x96, 0x50, 0x02, 0x00, 0x00, 0x25, 0x00, 0x00, 0x20, 0x02, 0x3D, 0x00, 0x00, 0x00, 0x02, 0x75, 0x08, 0x0F, 0xB7, 0x4E, 0x0C, 0x03, 0xCA, 0xEB, 0x02, 0x8B, 0xCA, 0x89, 0x8E, 0x54, 0x02, 0x00, 0x00, 0x8B, 0x86, 0x6C, 0x02, 0x00, 0x00, 0xFF, 0x70, 0x3C, 0x8B, 0x47, 0x28, 0xFF, 0x33, 0x51, 0xFF, 0xD0, 0x8B, 0x86, 0x68, 0x02, 0x00, 0x00, 0x33, 0xC9, 0x83, 0xC4, 0x0C, 0x89, 0x4C, 0x24, 0x10, 0x0F, 0xB7, 0x50, 0x14, 0x03, 0xD0, 0x8B, 0x86, 0x70, 0x02, 0x00, 0x00, 0x66, 0x39, 0x48, 0x02, 0x74, 0x48, 0x8D, 0x5A, 0x2C, 0x66, 0x90, 0x8B, 0x43, 0xFC, 0x85, 0xC0, 0x74, 0x20, 0x50, 0x8B, 0x86, 0x58, 0x02, 0x00, 0x00, 0x03, 0x03, 0x50, 0x8B, 0x43, 0xF8, 0x03, 0x86, 0x54, 0x02, 0x00, 0x00, 0x50, 0x8B, 0x47, 0x28, 0xFF, 0xD0, 0x8B, 0x4C, 0x24, 0x1C, 0x83, 0xC4, 0x0C, 0x8B, 0x86, 0x70, 0x02, 0x00, 0x00, 0x41, 0x83, 0xC3, 0x28, 0x89, 0x4C, 0x24, 0x10, 0x0F, 0xB7, 0x40, 0x02, 0x3B, 0xC8, 0x75, 0xC3, 0x8D, 0x9E, 0x58, 0x02, 0x00, 0x00, 0xF7, 0x46, 0x04, 0x00, 0x00, 0x00, 0x04, 0x75, 0x20, 0x68, 0x00, 0x80, 0x00, 0x00, 0x8D, 0x44, 0x24, 0x18, 0xC7, 0x44, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00, 0x50, 0x8B, 0x47, 0x1C, 0x53, 0x6A, 0xFF, 0xFF, 0xD0, 0xC7, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x8B, 0x8E, 0x54, 0x02, 0x00, 0x00, 0x89, 0x8E, 0x64, 0x02, 0x00, 0x00, 0x5F, 0x03, 0x49, 0x3C, 0x89, 0x8E, 0x68, 0x02, 0x00, 0x00, 0x8D, 0x41, 0x18, 0x89, 0x86, 0x6C, 0x02, 0x00, 0x00, 0x8D, 0x41, 0x04, 0x89, 0x86, 0x70, 0x02, 0x00, 0x00, 0x33, 0xC0, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC
};

#pragma section("wow64_sec$04", read, write)
__declspec(allocate("wow64_sec$04")) inline unsigned char MMI_RelocateImage_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x08, 0x53, 0x8B, 0x5D, 0x08, 0x57, 0x8B, 0xBB, 0x6C, 0x02, 0x00, 0x00, 0x8B, 0x83, 0x54, 0x02, 0x00, 0x00, 0x8B, 0xC8, 0x89, 0x7D, 0xF8, 0x2B, 0x4F, 0x1C, 0x89, 0x4D, 0x08, 0x0F, 0x84, 0x95, 0x00, 0x00, 0x00, 0x83, 0xBF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0D, 0x5F, 0xB8, 0x09, 0x00, 0x40, 0x00, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0xBF, 0x88, 0x00, 0x00, 0x00, 0x03, 0xF8, 0x83, 0x3F, 0x00, 0x74, 0x69, 0x56, 0x0F, 0x1F, 0x40, 0x00, 0x8B, 0x77, 0x04, 0x8D, 0x47, 0x04, 0x83, 0xEE, 0x08, 0x89, 0x45, 0xFC, 0xD1, 0xEE, 0x8D, 0x57, 0x08, 0x74, 0x30, 0x0F, 0xB7, 0x02, 0x8B, 0xC8, 0x81, 0xE1, 0x00, 0xF0, 0x00, 0x00, 0x81, 0xF9, 0x00, 0x30, 0x00, 0x00, 0x8B, 0x4D, 0x08, 0x75, 0x0F, 0x25, 0xFF, 0x0F, 0x00, 0x00, 0x03, 0x83, 0x54, 0x02, 0x00, 0x00, 0x03, 0x07, 0x01, 0x08, 0x83, 0xC2, 0x02, 0x83, 0xEE, 0x01, 0x75, 0xD3, 0x8B, 0x45, 0xFC, 0x03, 0x38, 0x8B, 0x55, 0xF8, 0x8B, 0x83, 0x54, 0x02, 0x00, 0x00, 0x03, 0x82, 0x88, 0x00, 0x00, 0x00, 0x03, 0x82, 0x8C, 0x00, 0x00, 0x00, 0x3B, 0xF8, 0x73, 0x05, 0x83, 0x3F, 0x00, 0x75, 0x9D, 0x5E, 0x8B, 0x83, 0x6C, 0x02, 0x00, 0x00, 0x01, 0x48, 0x1C, 0x5F, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$05", read, write)
__declspec(allocate("wow64_sec$05")) inline unsigned char MMI_InitializeCookie_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x8B, 0x45, 0x08, 0xF7, 0x40, 0x04, 0x00, 0x00, 0x40, 0x00, 0x74, 0x55, 0x8B, 0x90, 0x6C, 0x02, 0x00, 0x00, 0x83, 0xBA, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x74, 0x46, 0x56, 0x8B, 0xB0, 0x54, 0x02, 0x00, 0x00, 0x8B, 0xCE, 0x81, 0xF9, 0x4E, 0xE6, 0x40, 0xBB, 0x75, 0x16, 0x8B, 0x82, 0xB0, 0x00, 0x00, 0x00, 0xB9, 0x4F, 0xE6, 0x40, 0xBB, 0x89, 0x4C, 0x30, 0x3C, 0x33, 0xC0, 0x5E, 0x5D, 0xC2, 0x04, 0x00, 0xF7, 0xC1, 0x00, 0x00, 0xFF, 0xFF, 0x75, 0x0C, 0x8B, 0xC1, 0x0D, 0x11, 0x47, 0x00, 0x00, 0xC1, 0xE0, 0x10, 0x0B, 0xC8, 0x8B, 0x82, 0xB0, 0x00, 0x00, 0x00, 0x89, 0x4C, 0x30, 0x3C, 0x5E, 0x33, 0xC0, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$06", read, write)
__declspec(allocate("wow64_sec$06")) inline unsigned char MMI_LoadImports_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x30, 0x53, 0x56, 0x8B, 0x75, 0x08, 0x57, 0xF7, 0x46, 0x04, 0x00, 0x00, 0x82, 0x00, 0x0F, 0x84, 0x1C, 0x02, 0x00, 0x00, 0x8B, 0x8E, 0x6C, 0x02, 0x00, 0x00, 0x8B, 0xBE, 0x7C, 0x02, 0x00, 0x00, 0x83, 0xC1, 0x68, 0x89, 0x4D, 0xEC, 0x83, 0x79, 0x04, 0x00, 0x0F, 0x84, 0x00, 0x02, 0x00, 0x00, 0x8B, 0x19, 0x03, 0x9E, 0x54, 0x02, 0x00, 0x00, 0x89, 0x5D, 0xF4, 0x0F, 0x84, 0xEF, 0x01, 0x00, 0x00, 0x8B, 0x43, 0x0C, 0xBA, 0x08, 0x02, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x84, 0xDF, 0x01, 0x00, 0x00, 0x8B, 0x8E, 0x54, 0x02, 0x00, 0x00, 0x0F, 0x57, 0xC0, 0x52, 0x6A, 0x08, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0x03, 0xC8, 0x66, 0x0F, 0x13, 0x45, 0xD4, 0x8B, 0x47, 0x30, 0x89, 0x4D, 0xE0, 0x66, 0x89, 0x55, 0xD6, 0xFF, 0xD0, 0x89, 0x45, 0xD8, 0x85, 0xC0, 0x74, 0x45, 0x8B, 0x87, 0xD0, 0x00, 0x00, 0x00, 0x8D, 0x4D, 0xE8, 0x51, 0x8D, 0x4D, 0xD4, 0xC7, 0x45, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x51, 0xFF, 0x75, 0xE0, 0x56, 0xFF, 0xD0, 0x8B, 0x4D, 0xD8, 0x89, 0x45, 0xE0, 0x85, 0xC0, 0x79, 0x2E, 0x85, 0xC9, 0x74, 0x11, 0x8B, 0x47, 0x34, 0x51, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x45, 0xE0, 0x3D, 0x81, 0x04, 0x00, 0xC0, 0x0F, 0x84, 0x4F, 0x01, 0x00, 0x00, 0xB8, 0x0A, 0x00, 0x40, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x66, 0x83, 0x79, 0x02, 0x3A, 0x75, 0x0A, 0x0F, 0xB7, 0x45, 0xD4, 0xD1, 0xE8, 0x48, 0x8D, 0x04, 0x41, 0x8B, 0x8F, 0xD4, 0x00, 0x00, 0x00, 0x8D, 0x86, 0x74, 0x02, 0x00, 0x00, 0x50, 0x8D, 0x45, 0xF0, 0xC7, 0x45, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x50, 0xFF, 0x75, 0xE8, 0x8D, 0x45, 0xD4, 0x50, 0x56, 0xFF, 0xD1, 0x89, 0x46, 0x08, 0x85, 0xC0, 0x79, 0x23, 0x8B, 0x45, 0xD8, 0x85, 0xC0, 0x74, 0x0E, 0x50, 0x8B, 0x47, 0x34, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x81, 0x7E, 0x08, 0x81, 0x04, 0x00, 0xC0, 0x75, 0x9A, 0xE9, 0xE4, 0x00, 0x00, 0x00, 0x8B, 0x96, 0x54, 0x02, 0x00, 0x00, 0x8B, 0x4B, 0x10, 0x8B, 0x03, 0x85, 0xC0, 0x8D, 0x34, 0x11, 0x0F, 0x45, 0xC8, 0x89, 0x75, 0xF8, 0x8B, 0x75, 0x08, 0x8D, 0x04, 0x11, 0x89, 0x45, 0xE0, 0x8B, 0x00, 0x85, 0xC0, 0x0F, 0x84, 0xBB, 0x00, 0x00, 0x00, 0x8B, 0x5D, 0xF8, 0x8D, 0x4F, 0x40, 0x89, 0x4D, 0xE4, 0x85, 0xC0, 0x79, 0x16, 0x8B, 0x09, 0x53, 0x0F, 0xB7, 0xC0, 0x50, 0x6A, 0x00, 0xFF, 0x75, 0xF0, 0xFF, 0xD1, 0x89, 0x46, 0x08, 0x8D, 0x4F, 0x40, 0xEB, 0x72, 0x8B, 0x9E, 0x54, 0x02, 0x00, 0x00, 0x6A, 0x08, 0x6A, 0x08, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0x03, 0xD8, 0x8B, 0x47, 0x30, 0xFF, 0xD0, 0x89, 0x45, 0xDC, 0x85, 0xC0, 0x0F, 0x84, 0x27, 0xFF, 0xFF, 0xFF, 0x8D, 0x4B, 0x02, 0x8B, 0xD8, 0x0F, 0xB7, 0xD1, 0x89, 0x55, 0xDC, 0x8B, 0xC2, 0x89, 0x4B, 0x04, 0x80, 0x39, 0x00, 0x74, 0x09, 0x41, 0x0F, 0xB7, 0xC1, 0x80, 0x39, 0x00, 0x75, 0xF7, 0x2B, 0x45, 0xDC, 0xFF, 0x75, 0xF8, 0x66, 0x89, 0x03, 0x40, 0x66, 0x89, 0x43, 0x02, 0x8B, 0x45, 0xE4, 0x6A, 0x00, 0x53, 0xFF, 0x75, 0xF0, 0x8B, 0x00, 0xFF, 0xD0, 0x53, 0x89, 0x46, 0x08, 0x8B, 0x47, 0x34, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x4D, 0xE4, 0x8B, 0x5D, 0xF8, 0x83, 0x7E, 0x08, 0x00,
	0x0F, 0x8C, 0xCD, 0xFE, 0xFF, 0xFF, 0x8B, 0x55, 0xE0, 0x83, 0xC3, 0x04, 0x83, 0xC2, 0x04, 0x89, 0x5D, 0xF8, 0x89, 0x55, 0xE0, 0x8B, 0x02, 0x85, 0xC0, 0x0F, 0x85, 0x4E, 0xFF, 0xFF, 0xFF, 0x8B, 0x5D, 0xF4, 0x8B, 0x4D, 0xEC, 0x83, 0xC3, 0x14, 0x8B, 0x86, 0x54, 0x02, 0x00, 0x00, 0x89, 0x5D, 0xF4, 0x03, 0x01, 0x03, 0x41, 0x04, 0x3B, 0xD8, 0x73, 0x07, 0x85, 0xDB, 0xE9, 0x0B, 0xFE, 0xFF, 0xFF, 0x5F, 0x5E, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00
};

#pragma section("wow64_sec$07", read, write)
__declspec(allocate("wow64_sec$07")) inline unsigned char MMI_LoadDelayImports_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x30, 0x53, 0x8B, 0x5D, 0x08, 0x56, 0x57, 0xF7, 0x43, 0x04, 0x00, 0x00, 0x04, 0x00, 0x0F, 0x84, 0x87, 0x02, 0x00, 0x00, 0x8B, 0x8B, 0x6C, 0x02, 0x00, 0x00, 0x8B, 0xBB, 0x7C, 0x02, 0x00, 0x00, 0x81, 0xC1, 0xC8, 0x00, 0x00, 0x00, 0x89, 0x7D, 0xF0, 0x89, 0x4D, 0xEC, 0x83, 0x79, 0x04, 0x00, 0x0F, 0x84, 0x65, 0x02, 0x00, 0x00, 0x8B, 0x31, 0x32, 0xC9, 0x03, 0xB3, 0x54, 0x02, 0x00, 0x00, 0x89, 0x75, 0xF8, 0x88, 0x4D, 0x0B, 0x85, 0xF6, 0x0F, 0x84, 0x4D, 0x02, 0x00, 0x00, 0xBA, 0x08, 0x02, 0x00, 0x00, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x46, 0x04, 0x85, 0xC0, 0x0F, 0x84, 0x95, 0x00, 0x00, 0x00, 0x8B, 0x8B, 0x54, 0x02, 0x00, 0x00, 0x0F, 0x57, 0xC0, 0x68, 0x08, 0x02, 0x00, 0x00, 0x6A, 0x08, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0x03, 0xC8, 0x66, 0x0F, 0x13, 0x45, 0xD4, 0x8B, 0x47, 0x30, 0x89, 0x4D, 0xE0, 0x66, 0x89, 0x55, 0xD6, 0xFF, 0xD0, 0x89, 0x45, 0xD8, 0x85, 0xC0, 0x0F, 0x84, 0xF3, 0x01, 0x00, 0x00, 0x8B, 0x87, 0xD0, 0x00, 0x00, 0x00, 0x8D, 0x4D, 0xE8, 0x51, 0x8D, 0x4D, 0xD4, 0xC7, 0x45, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x51, 0xFF, 0x75, 0xE0, 0x53, 0xFF, 0xD0, 0x8B, 0x4D, 0xD8, 0x89, 0x45, 0xE0, 0x85, 0xC0, 0x79, 0x52, 0x85, 0xC9, 0x74, 0x11, 0x8B, 0x47, 0x34, 0x51, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x45, 0xE0, 0x3D, 0x81, 0x04, 0x00, 0xC0, 0x0F, 0x85, 0xAE, 0x01, 0x00, 0x00, 0x8B, 0x4D, 0xEC, 0x83, 0xC6, 0x20, 0x8B, 0x83, 0x54, 0x02, 0x00, 0x00, 0x89, 0x75, 0xF8, 0x03, 0x01, 0x03, 0x41, 0x04, 0x3B, 0xF0, 0x0F, 0x82, 0x80, 0x01, 0x00, 0x00, 0x33, 0xC0, 0xBA, 0x0B, 0x00, 0x40, 0x00, 0x38, 0x45, 0x0B, 0x0F, 0x45, 0xC2, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x66, 0x83, 0x79, 0x02, 0x3A, 0x75, 0x0A, 0x0F, 0xB7, 0x45, 0xD4, 0xD1, 0xE8, 0x48, 0x8D, 0x04, 0x41, 0x8B, 0x8F, 0xD4, 0x00, 0x00, 0x00, 0x8D, 0x83, 0x74, 0x02, 0x00, 0x00, 0x50, 0x8D, 0x45, 0xF4, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x50, 0xFF, 0x75, 0xE8, 0x8D, 0x45, 0xD4, 0x50, 0x53, 0xFF, 0xD1, 0x89, 0x43, 0x08, 0x85, 0xC0, 0x8B, 0x45, 0xD8, 0x79, 0x1E, 0x85, 0xC0, 0x74, 0x0E, 0x50, 0x8B, 0x47, 0x34, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x81, 0x7B, 0x08, 0x81, 0x04, 0x00, 0xC0, 0xE9, 0x6D, 0xFF, 0xFF, 0xFF, 0x85, 0xC0, 0x74, 0x0E, 0x50, 0x8B, 0x47, 0x34, 0x6A, 0x00, 0xFF, 0xB7, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x56, 0x08, 0x85, 0xD2, 0x74, 0x0C, 0x8B, 0x8B, 0x54, 0x02, 0x00, 0x00, 0x8B, 0x45, 0xF4, 0x89, 0x04, 0x0A, 0x8B, 0x4D, 0xF8, 0x8B, 0x83, 0x54, 0x02, 0x00, 0x00, 0x8B, 0x76, 0x0C, 0x03, 0xF0, 0x8B, 0x79, 0x10, 0x03, 0xF8, 0x89, 0x7D, 0xE0, 0x83, 0x3E, 0x00, 0x0F, 0x84, 0xA9, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xF0, 0x8D, 0x51, 0x40, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x8B, 0x07, 0x89, 0x55, 0xE4, 0x85, 0xC0, 0x79, 0x16, 0x8B, 0x0A, 0x56, 0x0F, 0xB7, 0xC0, 0x50, 0x6A, 0x00, 0xFF, 0x75, 0xF4, 0xFF, 0xD1, 0x8B, 0x4D, 0xF0, 0x8D, 0x51, 0x40, 0xEB, 0x60, 0x8B, 0xBB, 0x54, 0x02, 0x00, 0x00, 0x6A, 0x08, 0x6A, 0x08, 0xFF, 0xB1, 0xD8, 0x00, 0x00, 0x00, 0x03, 0xF8, 0x8B, 0x41, 0x30,
	0xFF, 0xD0, 0x89, 0x45, 0xDC, 0x85, 0xC0, 0x74, 0x5D, 0x8D, 0x4F, 0x02, 0x89, 0x48, 0x04, 0x80, 0x39, 0x00, 0x0F, 0xB7, 0xD1, 0x8B, 0xFA, 0x8B, 0xC2, 0x74, 0x0A, 0x90, 0x41, 0x0F, 0xB7, 0xC1, 0x80, 0x39, 0x00, 0x75, 0xF7, 0x8B, 0x55, 0xDC, 0x2B, 0xC7, 0x8B, 0x7D, 0xE0, 0x8B, 0x4D, 0xE4, 0x56, 0x66, 0x89, 0x02, 0x40, 0x66, 0x89, 0x42, 0x02, 0x0F, 0xB7, 0x07, 0x8B, 0x09, 0x50, 0x52, 0xFF, 0x75, 0xF4, 0xFF, 0xD1, 0x8B, 0x4D, 0xF0, 0x8B, 0x55, 0xE4, 0x89, 0x43, 0x08, 0x85, 0xC0, 0x78, 0x14, 0x83, 0xC6, 0x04, 0x83, 0xC7, 0x04, 0x89, 0x7D, 0xE0, 0x83, 0x3E, 0x00, 0x0F, 0x85, 0x68, 0xFF, 0xFF, 0xFF, 0xEB, 0x04, 0xC6, 0x45, 0x0B, 0x01, 0x8B, 0x4D, 0xEC, 0x8B, 0x83, 0x54, 0x02, 0x00, 0x00, 0x8B, 0x75, 0xF8, 0x83, 0xC6, 0x20, 0x03, 0x01, 0x03, 0x41, 0x04, 0x89, 0x75, 0xF8, 0x3B, 0xF0, 0x0F, 0x83, 0x83, 0xFE, 0xFF, 0xFF, 0x8B, 0x7D, 0xF0, 0xBA, 0x08, 0x02, 0x00, 0x00, 0x85, 0xF6, 0x0F, 0x85, 0xD3, 0xFD, 0xFF, 0xFF, 0xE9, 0x6E, 0xFE, 0xFF, 0xFF, 0xB8, 0x0B, 0x00, 0x40, 0x00, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x5F, 0x5E, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$08", read, write)
__declspec(allocate("wow64_sec$08")) inline unsigned char MMI_SetPageProtections_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x10, 0x57, 0x8B, 0x7D, 0x08, 0xF7, 0x47, 0x04, 0x00, 0x00, 0x20, 0x00, 0x0F, 0x84, 0x17, 0x01, 0x00, 0x00, 0x8B, 0x8F, 0x7C, 0x02, 0x00, 0x00, 0x8D, 0x55, 0x08, 0x8B, 0x87, 0x6C, 0x02, 0x00, 0x00, 0x52, 0xC7, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x55, 0xFC, 0x6A, 0x20, 0x8B, 0x40, 0x3C, 0x89, 0x45, 0xFC, 0x8B, 0x41, 0x18, 0x89, 0x4D, 0xF8, 0x8D, 0x8F, 0x54, 0x02, 0x00, 0x00, 0x52, 0x51, 0x6A, 0xFF, 0xFF, 0xD0, 0x89, 0x47, 0x08, 0x85, 0xC0, 0x0F, 0x88, 0xCC, 0x00, 0x00, 0x00, 0x8B, 0x87, 0x68, 0x02, 0x00, 0x00, 0x53, 0x56, 0x33, 0xDB, 0x0F, 0xB7, 0x70, 0x14, 0x03, 0xF0, 0x8B, 0x87, 0x70, 0x02, 0x00, 0x00, 0x66, 0x39, 0x58, 0x02, 0x0F, 0x84, 0x96, 0x00, 0x00, 0x00, 0x83, 0xC6, 0x3C, 0x8D, 0x53, 0x02, 0x0F, 0x1F, 0x40, 0x00, 0x8B, 0x46, 0xE8, 0x03, 0x87, 0x54, 0x02, 0x00, 0x00, 0x8B, 0x4E, 0xEC, 0x89, 0x45, 0xF0, 0x8B, 0x06, 0x89, 0x4D, 0xF4, 0x85, 0xC9, 0x74, 0x5E, 0xA9, 0x00, 0x00, 0x00, 0x20, 0x74, 0x1C, 0x85, 0xC0, 0x79, 0x07, 0xB8, 0x40, 0x00, 0x00, 0x00, 0xEB, 0x29, 0x25, 0x00, 0x00, 0x00, 0x40, 0xF7, 0xD8, 0x1B, 0xC0, 0x83, 0xE0, 0x10, 0x83, 0xC0, 0x10, 0xEB, 0x18, 0x85, 0xC0, 0x79, 0x07, 0xB8, 0x04, 0x00, 0x00, 0x00, 0xEB, 0x0D, 0xA9, 0x00, 0x00, 0x00, 0x40, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x45, 0xC2, 0x8B, 0x4D, 0xF8, 0x8D, 0x55, 0x08, 0x52, 0x50, 0x8D, 0x45, 0xF4, 0x8B, 0x49, 0x18, 0x50, 0x8D, 0x45, 0xF0, 0x50, 0x6A, 0xFF, 0xFF, 0xD1, 0x89, 0x47, 0x08, 0x85, 0xC0, 0x78, 0x1B, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x8B, 0x87, 0x70, 0x02, 0x00, 0x00, 0x43, 0x83, 0xC6, 0x28, 0x0F, 0xB7, 0x40, 0x02, 0x3B, 0xD8, 0x0F, 0x85, 0x74, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0xB9, 0x06, 0x00, 0x40, 0x00, 0x39, 0x47, 0x08, 0x5E, 0x5B, 0x0F, 0x4C, 0xC1, 0x5F, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xB8, 0x06, 0x00, 0x40, 0x00, 0x5F, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x33, 0xC0, 0x5F, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$09", read, write)
__declspec(allocate("wow64_sec$09")) inline unsigned char MMI_EnableExceptions_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x0C, 0x56, 0x8B, 0x75, 0x08, 0xF7, 0x46, 0x04, 0x00, 0x00, 0x10, 0x00, 0x0F, 0x84, 0x4B, 0x02, 0x00, 0x00, 0x8B, 0x86, 0x6C, 0x02, 0x00, 0x00, 0x8B, 0x96, 0x54, 0x02, 0x00, 0x00, 0x57, 0x8B, 0xBE, 0x7C, 0x02, 0x00, 0x00, 0x8B, 0x48, 0x38, 0x8B, 0x86, 0x3C, 0x02, 0x00, 0x00, 0x03, 0xCA, 0x83, 0xC0, 0x0F, 0x89, 0x8E, 0x44, 0x02, 0x00, 0x00, 0x03, 0xC1, 0x89, 0x7D, 0xFC, 0x83, 0xE0, 0xF0, 0x89, 0x86, 0x48, 0x02, 0x00, 0x00, 0x89, 0x10, 0x8B, 0x86, 0x6C, 0x02, 0x00, 0x00, 0x8B, 0x8E, 0x48, 0x02, 0x00, 0x00, 0x8B, 0x40, 0x38, 0x89, 0x41, 0x04, 0x8B, 0x8E, 0x48, 0x02, 0x00, 0x00, 0x8B, 0x86, 0x30, 0x02, 0x00, 0x00, 0x89, 0x41, 0x08, 0x8B, 0x8E, 0x48, 0x02, 0x00, 0x00, 0x8B, 0x87, 0x8C, 0x00, 0x00, 0x00, 0x89, 0x41, 0x0C, 0x8B, 0x8E, 0x48, 0x02, 0x00, 0x00, 0x8B, 0x47, 0x74, 0x89, 0x41, 0x10, 0xFF, 0xB6, 0x3C, 0x02, 0x00, 0x00, 0x8B, 0x47, 0x28, 0xFF, 0xB6, 0x38, 0x02, 0x00, 0x00, 0xFF, 0xB6, 0x44, 0x02, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x8E, 0x44, 0x02, 0x00, 0x00, 0x83, 0xC4, 0x0C, 0x8B, 0x96, 0x48, 0x02, 0x00, 0x00, 0x85, 0xC9, 0x74, 0x1C, 0x8B, 0x86, 0x3C, 0x02, 0x00, 0x00, 0x83, 0xC0, 0xFC, 0x03, 0xC1, 0x3B, 0xC8, 0x77, 0x0D, 0x81, 0x39, 0x0C, 0xB0, 0xCE, 0xFA, 0x74, 0x2A, 0x41, 0x3B, 0xC8, 0x76, 0xF3, 0xC6, 0x45, 0x0B, 0x00, 0x8B, 0x86, 0x30, 0x02, 0x00, 0x00, 0x83, 0xF8, 0x3F, 0x72, 0x1E, 0x8B, 0x96, 0x6C, 0x02, 0x00, 0x00, 0x8B, 0x8E, 0x54, 0x02, 0x00, 0x00, 0x8B, 0x47, 0x60, 0x8B, 0x52, 0x38, 0xFF, 0xD0, 0xEB, 0x42, 0x89, 0x11, 0xC6, 0x45, 0x0B, 0x01, 0xEB, 0xD7, 0x83, 0xF8, 0x3E, 0x75, 0x16, 0x8B, 0x86, 0x6C, 0x02, 0x00, 0x00, 0xFF, 0x70, 0x38, 0x8B, 0x47, 0x60, 0xFF, 0xB6, 0x54, 0x02, 0x00, 0x00, 0xFF, 0xD0, 0xEB, 0x1F, 0x83, 0xF8, 0x3D, 0x75, 0x1A, 0x8B, 0x86, 0x6C, 0x02, 0x00, 0x00, 0xFF, 0x70, 0x38, 0x8B, 0x47, 0x60, 0xFF, 0xB6, 0x54, 0x02, 0x00, 0x00, 0xFF, 0xB7, 0x8C, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xC7, 0x46, 0x08, 0x35, 0x01, 0x00, 0xC0, 0x33, 0xC0, 0x8B, 0x8F, 0x8C, 0x00, 0x00, 0x00, 0x8B, 0x09, 0x85, 0xC9, 0x0F, 0x84, 0xFD, 0x00, 0x00, 0x00, 0x83, 0xBE, 0x30, 0x02, 0x00, 0x00, 0x3E, 0x8B, 0x96, 0x54, 0x02, 0x00, 0x00, 0x53, 0x1B, 0xDB, 0x83, 0xE3, 0xFC, 0x83, 0xC3, 0x10, 0x03, 0x9F, 0x8C, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x40, 0x00, 0x39, 0x53, 0x04, 0x74, 0x1E, 0x40, 0x83, 0xC3, 0x10, 0x3B, 0xC1, 0x72, 0xF3, 0x33, 0xC0, 0xB9, 0x0C, 0x00, 0x40, 0x00, 0x39, 0x46, 0x08, 0x5B, 0x5F, 0x0F, 0x4C, 0xC1, 0x5E, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x83, 0x7B, 0x0C, 0x00, 0x74, 0x1D, 0x33, 0xC0, 0xC7, 0x46, 0x08, 0x00, 0x00, 0x00, 0x00, 0x39, 0x46, 0x08, 0xB9, 0x0C, 0x00, 0x40, 0x00, 0x5B, 0x5F, 0x0F, 0x4C, 0xC1, 0x5E, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x47, 0x14, 0x8D, 0x55, 0xF8, 0x6A, 0x04, 0x68, 0x00, 0x30, 0x00, 0x00, 0x52, 0x6A, 0x00, 0x8D, 0x8E, 0x4C, 0x02, 0x00, 0x00, 0xC7, 0x45, 0xF8, 0x00, 0x20, 0x00, 0x00, 0x51, 0x6A, 0xFF, 0xFF, 0xD0, 0x89, 0x46, 0x08, 0x85, 0xC0, 0x78, 0x6D, 0xA1, 0x30, 0x03, 0xFE, 0x7F, 0x8B, 0xF8, 0x8B, 0x96, 0x4C, 0x02, 0x00, 0x00, 0x83, 0xE7, 0x1F, 0x33, 0xD0, 0x8B, 0xCF, 0xF7,
	0xD9, 0x8B, 0xC2, 0xD3, 0xE0, 0x8B, 0xCF, 0x8B, 0x7D, 0xFC, 0xD3, 0xEA, 0x0B, 0xC2, 0x83, 0xBE, 0x30, 0x02, 0x00, 0x00, 0x3F, 0x89, 0x45, 0xF4, 0x72, 0x0A, 0x8B, 0x47, 0x74, 0x6A, 0x00, 0xFF, 0xD0, 0x8B, 0x45, 0xF4, 0x89, 0x03, 0x83, 0xBE, 0x30, 0x02, 0x00, 0x00, 0x3F, 0x72, 0x07, 0x8B, 0x47, 0x74, 0x6A, 0x01, 0xFF, 0xD0, 0x80, 0x7D, 0x0B, 0x00, 0x74, 0x1C, 0x83, 0xBE, 0x40, 0x02, 0x00, 0x00, 0x00, 0x75, 0x13, 0xFF, 0xB6, 0x44, 0x02, 0x00, 0x00, 0x8B, 0x47, 0x78, 0x6A, 0x00, 0xFF, 0xD0, 0x89, 0x86, 0x40, 0x02, 0x00, 0x00, 0x5B, 0x33, 0xC0, 0xB9, 0x0C, 0x00, 0x40, 0x00, 0x39, 0x46, 0x08, 0x5F, 0x0F, 0x4C, 0xC1, 0x5E, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x33, 0xC0, 0x5E, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$0A", read, write)
__declspec(allocate("wow64_sec$0A")) inline unsigned char MMI_HandleTLS_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x51, 0x57, 0x8B, 0x7D, 0x08, 0xF7, 0x47, 0x04, 0x00, 0x00, 0x08, 0x00, 0x0F, 0x84, 0xCE, 0x00, 0x00, 0x00, 0x8B, 0x87, 0x6C, 0x02, 0x00, 0x00, 0x83, 0xB8, 0xAC, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x84, 0xBB, 0x00, 0x00, 0x00, 0x8B, 0x80, 0xA8, 0x00, 0x00, 0x00, 0x03, 0x87, 0x54, 0x02, 0x00, 0x00, 0x53, 0x56, 0x8B, 0xB7, 0x7C, 0x02, 0x00, 0x00, 0x68, 0xB8, 0x00, 0x00, 0x00, 0x6A, 0x08, 0x89, 0x45, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0x8B, 0x46, 0x30, 0x89, 0x75, 0xFC, 0xFF, 0xD0, 0x8B, 0xD8, 0x85, 0xDB, 0x75, 0x0E, 0x5E, 0x5B, 0xB8, 0x03, 0x00, 0x40, 0x00, 0x5F, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x87, 0x54, 0x02, 0x00, 0x00, 0x89, 0x43, 0x18, 0x83, 0xBF, 0x30, 0x02, 0x00, 0x00, 0x3E, 0x8B, 0x46, 0x64, 0x77, 0x05, 0x53, 0xFF, 0xD0, 0xEB, 0x04, 0x8B, 0xCB, 0xFF, 0xD0, 0x8B, 0x75, 0x08, 0x8B, 0x76, 0x0C, 0x85, 0xF6, 0x74, 0x17, 0x8B, 0x06, 0x85, 0xC0, 0x74, 0x11, 0x6A, 0x00, 0x6A, 0x01, 0xFF, 0xB7, 0x54, 0x02, 0x00, 0x00, 0xFF, 0xD0, 0x83, 0xC6, 0x04, 0x75, 0xE9, 0x8B, 0x55, 0xFC, 0x8B, 0x8A, 0x94, 0x00, 0x00, 0x00, 0x8B, 0x01, 0x3B, 0xC1, 0x74, 0x14, 0x39, 0x58, 0x20, 0x74, 0x08, 0x8B, 0x00, 0x3B, 0xC1, 0x75, 0xF5, 0xEB, 0x07, 0xC7, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x42, 0x34, 0x53, 0x6A, 0x00, 0xFF, 0xB2, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x5E, 0x5B, 0x33, 0xC0, 0x5F, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x33, 0xC0, 0x5F, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$0B", read, write)
__declspec(allocate("wow64_sec$0B")) inline unsigned char MMI_ExecuteDllMain_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x51, 0x56, 0x8B, 0x75, 0x08, 0x8B, 0x4E, 0x04, 0xF7, 0xC1, 0x00, 0x00, 0x80, 0x00, 0x0F, 0x84, 0x8A, 0x00, 0x00, 0x00, 0x8B, 0x86, 0x6C, 0x02, 0x00, 0x00, 0x57, 0x8B, 0xBE, 0x7C, 0x02, 0x00, 0x00, 0x83, 0x78, 0x10, 0x00, 0x74, 0x6D, 0x53, 0x32, 0xDB, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0xF7, 0xC1, 0x00, 0x00, 0x00, 0x01, 0x74, 0x1A, 0x8B, 0x47, 0x68, 0x8D, 0x4D, 0x08, 0x51, 0x8D, 0x4D, 0xFC, 0x51, 0x6A, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x89, 0x5E, 0x08, 0xC1, 0xEB, 0x1F, 0x80, 0xF3, 0x01, 0x8B, 0x86, 0x6C, 0x02, 0x00, 0x00, 0x8B, 0x8E, 0x54, 0x02, 0x00, 0x00, 0x6A, 0x00, 0x6A, 0x01, 0x8B, 0x40, 0x10, 0x51, 0x03, 0xC1, 0xFF, 0xD0, 0xF7, 0x46, 0x04, 0x00, 0x00, 0x00, 0x01, 0x74, 0x0E, 0x84, 0xDB, 0x74, 0x0A, 0xFF, 0x75, 0x08, 0x8B, 0x47, 0x6C, 0x6A, 0x00, 0xFF, 0xD0, 0x5B, 0x5F, 0x33, 0xC0, 0x5E, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x5F, 0x33, 0xC0, 0x5E, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x33, 0xC0, 0x5E, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$0C", read, write)
__declspec(allocate("wow64_sec$0C")) inline unsigned char MMI_CleanDataDirectories_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x8B, 0x55, 0x08, 0x83, 0xEC, 0x10, 0x8B, 0x42, 0x04, 0x25, 0x00, 0x00, 0x21, 0x00, 0x3D, 0x00, 0x00, 0x01, 0x00, 0x0F, 0x85, 0xE1, 0x02, 0x00, 0x00, 0x8B, 0x82, 0x7C, 0x02, 0x00, 0x00, 0x53, 0x56, 0x8B, 0xB2, 0x6C, 0x02, 0x00, 0x00, 0x57, 0x8D, 0xBA, 0x54, 0x02, 0x00, 0x00, 0x89, 0x45, 0xF4, 0x89, 0x7D, 0xFC, 0x83, 0x7E, 0x6C, 0x00, 0x0F, 0x84, 0x8F, 0x00, 0x00, 0x00, 0x8B, 0x76, 0x68, 0x03, 0x37, 0x83, 0x7E, 0x0C, 0x00, 0x74, 0x68, 0x0F, 0x1F, 0x40, 0x00, 0x8B, 0x07, 0x03, 0x46, 0x0C, 0x80, 0x38, 0x00, 0x74, 0x04, 0xC6, 0x40, 0x01, 0x00, 0x8B, 0x06, 0xC7, 0x46, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x0F, 0x85, 0xC0, 0x75, 0x03, 0x8B, 0x46, 0x10, 0x8D, 0x14, 0x01, 0x8B, 0x0A, 0x85, 0xC9, 0x74, 0x22, 0x79, 0x08, 0xC7, 0x02, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x0E, 0x8B, 0x07, 0x80, 0x7C, 0x08, 0x02, 0x00, 0x74, 0x05, 0xC6, 0x44, 0x08, 0x03, 0x00, 0x8B, 0x4A, 0x04, 0x83, 0xC2, 0x04, 0x85, 0xC9, 0x75, 0xDE, 0xC7, 0x06, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x46, 0x10, 0x00, 0x00, 0x00, 0x00, 0x83, 0xC6, 0x14, 0x83, 0x7E, 0x0C, 0x00, 0x75, 0x9F, 0x8B, 0x55, 0x08, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x40, 0x68, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x40, 0x6C, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x03, 0x89, 0x7D, 0xFC, 0x8B, 0x9A, 0x6C, 0x02, 0x00, 0x00, 0x83, 0xBB, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x84, 0xD5, 0x00, 0x00, 0x00, 0xF7, 0x42, 0x04, 0x00, 0x00, 0x04, 0x00, 0x0F, 0x85, 0xC8, 0x00, 0x00, 0x00, 0x8B, 0x9B, 0xC8, 0x00, 0x00, 0x00, 0x03, 0x1F, 0x83, 0x7B, 0x04, 0x00, 0x0F, 0x84, 0x96, 0x00, 0x00, 0x00, 0x83, 0xC3, 0x0C, 0x89, 0x5D, 0xF8, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x8B, 0x43, 0xF8, 0x03, 0x07, 0x80, 0x38, 0x00, 0x74, 0x04, 0xC6, 0x40, 0x01, 0x00, 0x8B, 0x43, 0x04, 0xC7, 0x43, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x43, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x0F, 0x03, 0xC1, 0x8B, 0x3B, 0x03, 0xF9, 0x83, 0x3F, 0x00, 0x74, 0x3C, 0x8B, 0x5D, 0xFC, 0x90, 0x8B, 0x10, 0x85, 0xD2, 0x79, 0x08, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x1C, 0x8B, 0x33, 0x03, 0xF2, 0xC7, 0x45, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x8A, 0x4E, 0x02, 0x84, 0xC9, 0x0F, 0xB6, 0xD1, 0x0F, 0x45, 0x55, 0xF0, 0xFE, 0xC2, 0x88, 0x56, 0x02, 0x83, 0xC7, 0x04, 0x83, 0xC0, 0x04, 0x83, 0x3F, 0x00, 0x75, 0xCB, 0x8B, 0x5D, 0xF8, 0x8B, 0x7D, 0xFC, 0xC7, 0x03, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x43, 0x04, 0x00, 0x00, 0x00, 0x00, 0x83, 0xC3, 0x20, 0x89, 0x5D, 0xF8, 0x83, 0x7B, 0xF8, 0x00, 0x0F, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0x8B, 0x55, 0x08, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x80, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x80, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0xB2, 0x6C, 0x02, 0x00, 0x00, 0x83, 0xBE, 0x94, 0x00, 0x00, 0x00, 0x00, 0x74, 0x51, 0x8B, 0xB6, 0x90, 0x00, 0x00, 0x00, 0x03, 0x37, 0x8B, 0x46, 0x14, 0x03, 0x07, 0xFF, 0x76, 0x10, 0x50, 0x8B, 0x45, 0xF4, 0x8B, 0x40, 0x2C, 0xFF, 0xD0, 0x8B, 0x55, 0x08, 0xC7, 0x46, 0x10, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x46, 0x14, 0x00, 0x00, 0x00, 0x00,
	0xC7, 0x46, 0x18, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x80, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x80, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0xBA, 0x6C, 0x02, 0x00, 0x00, 0x8B, 0x5D, 0xFC, 0x83, 0xBF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x74, 0x51, 0x8B, 0xBF, 0x88, 0x00, 0x00, 0x00, 0x03, 0x3B, 0x83, 0x3F, 0x00, 0x74, 0x24, 0x8B, 0x5D, 0xF4, 0x0F, 0x1F, 0x00, 0x8B, 0x47, 0x04, 0x83, 0xE8, 0x08, 0x50, 0x8D, 0x47, 0x08, 0x50, 0x8B, 0x43, 0x2C, 0xFF, 0xD0, 0x03, 0x7F, 0x04, 0x83, 0x3F, 0x00, 0x75, 0xE8, 0x8B, 0x5D, 0xFC, 0x8B, 0x55, 0x08, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x80, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x80, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x8A, 0x6C, 0x02, 0x00, 0x00, 0x83, 0xB9, 0xAC, 0x00, 0x00, 0x00, 0x00, 0x74, 0x65, 0x8B, 0x89, 0xA8, 0x00, 0x00, 0x00, 0x03, 0x0B, 0x8B, 0x41, 0x0C, 0x85, 0xC0, 0x74, 0x14, 0x0F, 0x1F, 0x40, 0x00, 0x83, 0x38, 0x00, 0x74, 0x0B, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0xC0, 0x04, 0x75, 0xF0, 0xC7, 0x41, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x41, 0x08, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x41, 0x04, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x80, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x82, 0x6C, 0x02, 0x00, 0x00, 0xC7, 0x80, 0xAC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x5E, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x33, 0xC0, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$0D", read, write)
__declspec(allocate("wow64_sec$0D")) inline unsigned char MMI_CloakHeader_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x10, 0x53, 0x57, 0x8B, 0x7D, 0x08, 0x8B, 0x4F, 0x04, 0xF6, 0xC1, 0x03, 0x0F, 0x84, 0x30, 0x01, 0x00, 0x00, 0x8B, 0x87, 0x54, 0x02, 0x00, 0x00, 0x8B, 0x97, 0x7C, 0x02, 0x00, 0x00, 0x89, 0x45, 0xF4, 0x8B, 0x87, 0x6C, 0x02, 0x00, 0x00, 0x89, 0x55, 0xF8, 0x8D, 0x5A, 0x18, 0x8B, 0x40, 0x3C, 0x89, 0x45, 0x08, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xF7, 0xC1, 0x00, 0x00, 0x20, 0x00, 0x74, 0x21, 0x8B, 0x03, 0x8D, 0x4D, 0xFC, 0x51, 0x6A, 0x40, 0x8D, 0x4D, 0x08, 0x51, 0x8D, 0x4D, 0xF4, 0x51, 0x6A, 0xFF, 0xFF, 0xD0, 0x89, 0x47, 0x08, 0x85, 0xC0, 0x78, 0x55, 0x8B, 0x45, 0x08, 0x8B, 0x55, 0xF8, 0x8B, 0x4F, 0x04, 0xF6, 0xC1, 0x01, 0x74, 0x54, 0x50, 0xFF, 0xB7, 0x54, 0x02, 0x00, 0x00, 0x8B, 0x42, 0x2C, 0xFF, 0xD0, 0xF7, 0x47, 0x04, 0x00, 0x00, 0x20, 0x00, 0x0F, 0x84, 0xBE, 0x00, 0x00, 0x00, 0x8B, 0x03, 0x8D, 0x4D, 0xFC, 0x51, 0xFF, 0x75, 0xFC, 0x8D, 0x4D, 0x08, 0x51, 0x8D, 0x4D, 0xF4, 0x51, 0x6A, 0xFF, 0xFF, 0xD0, 0x33, 0xC9, 0x89, 0x47, 0x08, 0x85, 0xC0, 0xBA, 0x06, 0x00, 0x40, 0x00, 0x5F, 0x0F, 0x48, 0xCA, 0x8B, 0xC1, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x5F, 0xB8, 0x06, 0x00, 0x40, 0x00, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xF6, 0xC1, 0x02, 0x74, 0xB3, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x0D, 0x5F, 0xB8, 0x0F, 0x00, 0x40, 0x00, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x8B, 0x40, 0x0C, 0x85, 0xC0, 0x74, 0x53, 0x8B, 0x40, 0x0C, 0x85, 0xC0, 0x74, 0x4C, 0x8B, 0x00, 0x89, 0x45, 0xF0, 0x85, 0xC0, 0x74, 0x43, 0x8B, 0x40, 0x18, 0x85, 0xC0, 0x74, 0x3C, 0x56, 0x8B, 0x70, 0x3C, 0xFF, 0x75, 0x08, 0x03, 0xF0, 0x8B, 0x42, 0x2C, 0xFF, 0xB7, 0x54, 0x02, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x45, 0xF8, 0x8B, 0x4D, 0x08, 0x39, 0x4E, 0x54, 0x8B, 0x50, 0x28, 0x8B, 0x45, 0xF0, 0x0F, 0x42, 0x4E, 0x54, 0x51, 0xFF, 0x70, 0x18, 0xFF, 0xB7, 0x54, 0x02, 0x00, 0x00, 0xFF, 0xD2, 0x83, 0xC4, 0x0C, 0x5E, 0xE9, 0x42, 0xFF, 0xFF, 0xFF, 0x5F, 0xB8, 0x10, 0x00, 0x40, 0x00, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0x5F, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$0E", read, write)
__declspec(allocate("wow64_sec$0E")) inline unsigned char MMI_CleanUp_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x51, 0x56, 0x57, 0x8B, 0x7D, 0x08, 0x83, 0xBF, 0x4C, 0x02, 0x00, 0x00, 0x00, 0x8D, 0x87, 0x4C, 0x02, 0x00, 0x00, 0x8B, 0xB7, 0x7C, 0x02, 0x00, 0x00, 0x74, 0x18, 0x68, 0x00, 0x80, 0x00, 0x00, 0x8D, 0x4D, 0xFC, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x51, 0x50, 0x8B, 0x46, 0x1C, 0x6A, 0xFF, 0xFF, 0xD0, 0x8B, 0x87, 0x40, 0x02, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x06, 0x50, 0x8B, 0x46, 0x7C, 0xFF, 0xD0, 0x8B, 0x87, 0x78, 0x02, 0x00, 0x00, 0x89, 0x45, 0xFC, 0x53, 0x85, 0xC0, 0x74, 0x39, 0x8B, 0x58, 0x04, 0x8B, 0x46, 0x44, 0xFF, 0x73, 0x08, 0xFF, 0xD0, 0x3B, 0x5D, 0xFC, 0x74, 0x29, 0x8B, 0x7D, 0xFC, 0x8B, 0x43, 0x04, 0x53, 0x89, 0x47, 0x04, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x5F, 0x04, 0x8B, 0x46, 0x44, 0xFF, 0x73, 0x08, 0xFF, 0xD0, 0x3B, 0xDF, 0x75, 0xDD, 0x8B, 0x7D, 0x08, 0x8B, 0x87, 0x74, 0x02, 0x00, 0x00, 0x89, 0x45, 0xFC, 0x85, 0xC0, 0x74, 0x3C, 0x8B, 0x58, 0x04, 0x8B, 0x46, 0x44, 0xFF, 0x73, 0x08, 0xFF, 0xD0, 0x3B, 0x5D, 0xFC, 0x74, 0x2C, 0x8B, 0x7D, 0xFC, 0x0F, 0x1F, 0x00, 0x8B, 0x43, 0x04, 0x53, 0x89, 0x47, 0x04, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x5F, 0x04, 0x8B, 0x46, 0x44, 0xFF, 0x73, 0x08, 0xFF, 0xD0, 0x3B, 0xDF, 0x75, 0xDD, 0x8B, 0x7D, 0x08, 0x83, 0xBF, 0x50, 0x02, 0x00, 0x00, 0x00, 0x8D, 0x87, 0x50, 0x02, 0x00, 0x00, 0x5B, 0x74, 0x18, 0x68, 0x00, 0x80, 0x00, 0x00, 0x8D, 0x4D, 0x08, 0xC7, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x51, 0x50, 0x8B, 0x46, 0x1C, 0x6A, 0xFF, 0xFF, 0xD0, 0x83, 0xBF, 0x58, 0x02, 0x00, 0x00, 0x00, 0x8D, 0x87, 0x58, 0x02, 0x00, 0x00, 0x74, 0x21, 0xF7, 0x47, 0x04, 0x00, 0x00, 0x00, 0x04, 0x75, 0x18, 0x68, 0x00, 0x80, 0x00, 0x00, 0x8D, 0x4D, 0x08, 0xC7, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x51, 0x50, 0x8B, 0x46, 0x1C, 0x6A, 0xFF, 0xFF, 0xD0, 0x8B, 0x87, 0x60, 0x02, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x06, 0x50, 0x8B, 0x46, 0x08, 0xFF, 0xD0, 0x5F, 0x33, 0xC0, 0x5E, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$0F", read, write)
__declspec(allocate("wow64_sec$0F")) inline unsigned char MMIH_ResolveFilePath_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x3C, 0x8B, 0x4D, 0x0C, 0x8B, 0x45, 0x08, 0x53, 0x56, 0x8B, 0x49, 0x04, 0x8B, 0xB0, 0x7C, 0x02, 0x00, 0x00, 0x57, 0xC7, 0x45, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x66, 0x83, 0x79, 0x02, 0x3A, 0x75, 0x0B, 0x33, 0xC0, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x08, 0x00, 0x83, 0xB8, 0x30, 0x02, 0x00, 0x00, 0x3D, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x77, 0x0E, 0x8B, 0x86, 0x90, 0x00, 0x00, 0x00, 0x8B, 0x48, 0x04, 0x89, 0x4D, 0xFC, 0xEB, 0x27, 0x8B, 0x46, 0x58, 0x8D, 0x55, 0xD4, 0x52, 0x8D, 0x55, 0xFC, 0xC7, 0x45, 0xD4, 0x00, 0x00, 0x00, 0x00, 0x52, 0x6A, 0x00, 0x51, 0xFF, 0xD0, 0x8B, 0xD0, 0x89, 0x55, 0xE4, 0x85, 0xD2, 0x0F, 0x88, 0x33, 0x03, 0x00, 0x00, 0x8B, 0x4D, 0xFC, 0x85, 0xC9, 0x0F, 0x84, 0x23, 0x03, 0x00, 0x00, 0x66, 0x83, 0x39, 0x00, 0x8B, 0xC1, 0x74, 0x09, 0x83, 0xC0, 0x02, 0x66, 0x83, 0x38, 0x00, 0x75, 0xF7, 0x2B, 0xC1, 0x83, 0xE0, 0xFE, 0x0F, 0xB7, 0xC0, 0x66, 0x85, 0xC0, 0x0F, 0x84, 0x01, 0x03, 0x00, 0x00, 0x8B, 0x4E, 0x30, 0x8B, 0xF8, 0x8D, 0x47, 0x02, 0x50, 0x6A, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD1, 0x8B, 0xD8, 0x89, 0x5D, 0xF0, 0x85, 0xDB, 0x74, 0x69, 0x8B, 0x46, 0x28, 0x57, 0xFF, 0x75, 0xFC, 0x53, 0xFF, 0xD0, 0x0F, 0xB7, 0x03, 0x83, 0xC4, 0x0C, 0xBA, 0x01, 0x00, 0x00, 0x00, 0x8B, 0xCB, 0x66, 0x85, 0xC0, 0x74, 0x21, 0x8B, 0xF8, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x66, 0x83, 0xFF, 0x3B, 0x8D, 0x42, 0x01, 0x8D, 0x49, 0x02, 0x0F, 0x45, 0xC2, 0x8B, 0xD0, 0x0F, 0xB7, 0x01, 0x8B, 0xF8, 0x66, 0x85, 0xC0, 0x75, 0xE7, 0x8B, 0x4E, 0x30, 0x8D, 0x04, 0x95, 0x00, 0x00, 0x00, 0x00, 0x50, 0x6A, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD1, 0x8B, 0xF8, 0x89, 0x7D, 0xE8, 0x85, 0xFF, 0x75, 0x1C, 0x53, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xB8, 0x17, 0x00, 0x00, 0xC0, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x08, 0x00, 0x8B, 0x45, 0xF0, 0xBB, 0x01, 0x00, 0x00, 0x00, 0x89, 0x07, 0x8B, 0xC8, 0x0F, 0xB7, 0x00, 0x66, 0x85, 0xC0, 0x74, 0x27, 0x8B, 0xD0, 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x41, 0x02, 0x66, 0x83, 0xFA, 0x3B, 0x75, 0x09, 0x33, 0xD2, 0x66, 0x89, 0x11, 0x89, 0x04, 0x9F, 0x43, 0x8B, 0xC8, 0x0F, 0xB7, 0x01, 0x8B, 0xD0, 0x66, 0x85, 0xC0, 0x75, 0xE2, 0x8B, 0x46, 0x30, 0x68, 0x08, 0x02, 0x00, 0x00, 0x6A, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xC8, 0x89, 0x4D, 0xF4, 0x85, 0xC9, 0x75, 0x16, 0x57, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xFF, 0x75, 0xF0, 0xE9, 0x79, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0x0C, 0x6A, 0x10, 0x0F, 0xB7, 0x00, 0x89, 0x45, 0xD4, 0x8B, 0x45, 0x08, 0x05, 0x20, 0x02, 0x00, 0x00, 0x50, 0x8B, 0x46, 0x28, 0x51, 0xFF, 0xD0, 0x8B, 0x45, 0xF4, 0x83, 0xC4, 0x0C, 0x83, 0xC0, 0x08, 0x0F, 0x57, 0xC0, 0x66, 0x0F, 0x13, 0x45, 0xC4, 0x89, 0x45, 0xF8, 0x8B, 0x46, 0x30, 0x6A, 0x18, 0x6A, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xF8, 0x89, 0x7D, 0xDC, 0x85, 0xFF, 0x75, 0x14, 0xFF, 0x75, 0xF4, 0x50, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0x8B, 0x46, 0x34, 0xFF, 0xD0,
	0xFF, 0x75, 0xE8, 0xEB, 0x91, 0x33, 0xC0, 0xC6, 0x45, 0x0B, 0x00, 0x89, 0x45, 0xD8, 0x85, 0xDB, 0x0F, 0x8E, 0x2E, 0x01, 0x00, 0x00, 0x8B, 0x4D, 0xD4, 0x0F, 0xB7, 0xD1, 0x89, 0x55, 0xEC, 0x8B, 0x4D, 0xE8, 0x8B, 0x0C, 0x81, 0x8B, 0xC1, 0x66, 0x83, 0x39, 0x00, 0x74, 0x09, 0x83, 0xC0, 0x02, 0x66, 0x83, 0x38, 0x00, 0x75, 0xF7, 0x2B, 0xC1, 0x83, 0xE0, 0xFE, 0x0F, 0xB7, 0xF8, 0x8D, 0x47, 0x02, 0x03, 0xC2, 0x89, 0x45, 0xD4, 0x83, 0xC0, 0x08, 0x3D, 0x08, 0x02, 0x00, 0x00, 0x0F, 0x87, 0x40, 0x01, 0x00, 0x00, 0x8B, 0x46, 0x28, 0x57, 0x51, 0xFF, 0x75, 0xF8, 0xFF, 0xD0, 0x8B, 0x45, 0xF8, 0xB9, 0x5C, 0x00, 0x00, 0x00, 0xFF, 0x75, 0xEC, 0xD1, 0xEF, 0x66, 0x89, 0x0C, 0x78, 0x8D, 0x04, 0x78, 0x8B, 0x4D, 0x0C, 0x83, 0xC0, 0x02, 0xFF, 0x71, 0x04, 0x50, 0x8B, 0x46, 0x28, 0xFF, 0xD0, 0x8B, 0x45, 0xD4, 0x33, 0xD2, 0x8B, 0x4D, 0xF8, 0x83, 0xC4, 0x18, 0xD1, 0xE8, 0x66, 0x89, 0x14, 0x41, 0x8B, 0x4D, 0xF4, 0x8B, 0xC1, 0x66, 0x39, 0x11, 0x74, 0x08, 0x83, 0xC0, 0x02, 0x66, 0x39, 0x10, 0x75, 0xF8, 0x8B, 0x7D, 0xDC, 0x2B, 0xC1, 0x6A, 0x20, 0x83, 0xE0, 0xFE, 0x89, 0x4D, 0xD0, 0x6A, 0x04, 0x66, 0x89, 0x45, 0xCC, 0x8D, 0x4D, 0xC4, 0x51, 0xB8, 0x08, 0x02, 0x00, 0x00, 0xC7, 0x07, 0x18, 0x00, 0x00, 0x00, 0x66, 0x89, 0x45, 0xCE, 0x8D, 0x4D, 0xE0, 0x57, 0x8D, 0x45, 0xCC, 0x89, 0x57, 0x04, 0x68, 0x00, 0x00, 0x10, 0x00, 0xC7, 0x47, 0x0C, 0x40, 0x00, 0x00, 0x00, 0x89, 0x47, 0x08, 0x89, 0x57, 0x10, 0x89, 0x57, 0x14, 0x8B, 0x06, 0x51, 0x89, 0x55, 0xE0, 0xFF, 0xD0, 0x89, 0x45, 0xE4, 0x85, 0xC0, 0x0F, 0x88, 0x9D, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xE0, 0x85, 0xC0, 0x0F, 0x84, 0x92, 0x00, 0x00, 0x00, 0x50, 0x8B, 0x46, 0x08, 0xFF, 0xD0, 0xFF, 0x75, 0xD4, 0x8B, 0x45, 0x0C, 0x8B, 0x5D, 0xF8, 0x53, 0xFF, 0x70, 0x04, 0x8B, 0x46, 0x28, 0xFF, 0xD0, 0x83, 0xC4, 0x0C, 0x8B, 0xC3, 0x66, 0x83, 0x3B, 0x00, 0x74, 0x0B, 0x66, 0x90, 0x83, 0xC0, 0x02, 0x66, 0x83, 0x38, 0x00, 0x75, 0xF7, 0x8B, 0x4D, 0x0C, 0x2B, 0xC3, 0x83, 0xE0, 0xFE, 0xC6, 0x45, 0x0B, 0x01, 0x66, 0x89, 0x01, 0x8B, 0x46, 0x34, 0x57, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xFF, 0x75, 0xF4, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xFF, 0x75, 0xE8, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xFF, 0x75, 0xF0, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x33, 0xC0, 0x38, 0x45, 0x0B, 0x0F, 0x44, 0x45, 0xE4, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x08, 0x00, 0x8B, 0x7D, 0xDC, 0xEB, 0x03, 0x8B, 0x55, 0xEC, 0x8B, 0x45, 0xD8, 0x40, 0x89, 0x45, 0xD8, 0x3B, 0xC3, 0x0F, 0x8C, 0x74, 0xFE, 0xFF, 0xFF, 0xEB, 0x97, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x08, 0x00, 0xCC
};

#pragma section("wow64_sec$10", read, write)
__declspec(allocate("wow64_sec$10")) inline unsigned char MMIH_PreprocessModuleName_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x51, 0x53, 0x56, 0x8B, 0x75, 0x08, 0x6A, 0x08, 0x6A, 0x08, 0x8B, 0xB6, 0x7C, 0x02, 0x00, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0x8B, 0x46, 0x30, 0xFF, 0xD0, 0x8B, 0xD8, 0x85, 0xDB, 0x75, 0x0D, 0x5E, 0xB8, 0x17, 0x00, 0x00, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x10, 0x00, 0x57, 0x8B, 0x7D, 0x0C, 0x8B, 0xCF, 0x0F, 0xB7, 0xC7, 0x8B, 0xD0, 0x80, 0x3F, 0x00, 0x74, 0x09, 0x41, 0x0F, 0xB7, 0xC1, 0x80, 0x39, 0x00, 0x75, 0xF7, 0x2B, 0xC2, 0x0F, 0xB7, 0xC0, 0x89, 0x45, 0x0C, 0x66, 0x85, 0xC0, 0x0F, 0x84, 0x8D, 0x00, 0x00, 0x00, 0x8B, 0x4E, 0x30, 0x0F, 0xB7, 0xC0, 0x89, 0x45, 0xFC, 0x40, 0x50, 0x6A, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD1, 0x89, 0x43, 0x04, 0x85, 0xC0, 0x74, 0x71, 0xFF, 0x75, 0xFC, 0x8B, 0x4D, 0x0C, 0x66, 0x89, 0x0B, 0x41, 0x57, 0x66, 0x89, 0x4B, 0x02, 0x50, 0x8B, 0x46, 0x28, 0xFF, 0xD0, 0x8B, 0x46, 0x30, 0x83, 0xC4, 0x0C, 0x6A, 0x08, 0x6A, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xF8, 0x85, 0xFF, 0x74, 0x2F, 0x8B, 0x46, 0x30, 0x68, 0x08, 0x02, 0x00, 0x00, 0x6A, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x89, 0x47, 0x04, 0xB9, 0x08, 0x02, 0x00, 0x00, 0x66, 0x89, 0x4F, 0x02, 0x85, 0xC0, 0x75, 0x3E, 0x57, 0x50, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0x8B, 0x46, 0x34, 0xFF, 0xD0, 0x8B, 0x43, 0x04, 0x85, 0xC0, 0x74, 0x0E, 0x50, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x53, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x5F, 0x5E, 0xB8, 0x17, 0x00, 0x00, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x10, 0x00, 0x8B, 0x46, 0x48, 0x6A, 0x00, 0x53, 0x57, 0xFF, 0xD0, 0x89, 0x45, 0x0C, 0x85, 0xC0, 0x79, 0x52, 0x8B, 0x4F, 0x04, 0x85, 0xC9, 0x74, 0x0E, 0x8B, 0x46, 0x34, 0x51, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x46, 0x34, 0x57, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x43, 0x04, 0x85, 0xC0, 0x74, 0x0E, 0x50, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x46, 0x34, 0x53, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x45, 0x0C, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x10, 0x00, 0x8B, 0x43, 0x04, 0x85, 0xC0, 0x74, 0x0E, 0x50, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x46, 0x34, 0x53, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x45, 0x08, 0x83, 0xB8, 0x30, 0x02, 0x00, 0x00, 0x64, 0x0F, 0x82, 0xE2, 0x00, 0x00, 0x00, 0x8B, 0x46, 0x30, 0x68, 0x08, 0x01, 0x00, 0x00, 0x6A, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xD8, 0x85, 0xDB, 0x74, 0x5F, 0xFF, 0x75, 0x14, 0xB8, 0x00, 0x01, 0x00, 0x00, 0x8B, 0xD3, 0x66, 0x89, 0x43, 0x02, 0x8B, 0xCF, 0x8D, 0x43, 0x08, 0x89, 0x43, 0x04, 0x8B, 0x46, 0x5C, 0x6A, 0x00, 0xFF, 0xD0, 0x89, 0x45, 0x08, 0x85, 0xC0, 0x78, 0x69, 0x8B, 0x4D, 0x10, 0x66, 0x8B, 0x03, 0x66, 0x89, 0x01, 0x0F, 0xB7, 0x43, 0x02, 0x66, 0x89, 0x41, 0x02, 0x83, 0xE0, 0xFE, 0x8B, 0x4E, 0x30, 0x50, 0x6A, 0x08, 0xFF, 0xB6, 0xD8, 0x00, 0x00,
	0x00, 0xFF, 0xD1, 0x8B, 0xC8, 0x8B, 0x45, 0x10, 0x89, 0x48, 0x04, 0x85, 0xC9, 0x75, 0x28, 0x8B, 0x46, 0x34, 0x53, 0x51, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x47, 0x04, 0x85, 0xC0, 0x74, 0x0E, 0x50, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x57, 0xE9, 0xBE, 0xFE, 0xFF, 0xFF, 0x0F, 0xB7, 0x00, 0x50, 0x8D, 0x43, 0x08, 0x50, 0x8B, 0x46, 0x28, 0x51, 0xFF, 0xD0, 0x83, 0xC4, 0x0C, 0xEB, 0x54, 0x8B, 0x46, 0x34, 0x53, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x47, 0x04, 0x85, 0xC0, 0x74, 0x0E, 0x50, 0x8B, 0x46, 0x34, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x46, 0x34, 0x57, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0x45, 0x08, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x10, 0x00, 0x8B, 0x4D, 0x10, 0x0F, 0xB7, 0x07, 0x66, 0x89, 0x01, 0x0F, 0xB7, 0x47, 0x02, 0x66, 0x89, 0x41, 0x02, 0x8B, 0x47, 0x04, 0x89, 0x41, 0x04, 0x8B, 0x46, 0x34, 0x57, 0x6A, 0x00, 0xFF, 0xB6, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x5F, 0x5E, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x10, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$11", read, write)
__declspec(allocate("wow64_sec$11")) inline unsigned char MMIH_LoadModule_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x10, 0x53, 0x56, 0x57, 0x8B, 0x7D, 0x08, 0xC7, 0x45, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x87, 0x30, 0x02, 0x00, 0x00, 0x8B, 0x9F, 0x7C, 0x02, 0x00, 0x00, 0x83, 0xF8, 0x64, 0x0F, 0x82, 0x91, 0x00, 0x00, 0x00, 0x8B, 0x43, 0x30, 0x6A, 0x50, 0x6A, 0x08, 0xFF, 0xB3, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xF0, 0x85, 0xF6, 0x0F, 0x84, 0xEB, 0x00, 0x00, 0x00, 0x81, 0xBF, 0x34, 0x02, 0x00, 0x00, 0x5A, 0x29, 0x00, 0x00, 0x8B, 0x4D, 0x0C, 0x8B, 0x41, 0x04, 0x75, 0x05, 0x89, 0x46, 0x0C, 0xEB, 0x03, 0x89, 0x46, 0x10, 0x81, 0xBF, 0x34, 0x02, 0x00, 0x00, 0xF0, 0x55, 0x00, 0x00, 0x8D, 0x55, 0xF8, 0x8B, 0x43, 0x3C, 0x72, 0x27, 0x6A, 0x00, 0x52, 0x8D, 0x55, 0xFC, 0x52, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x04, 0xFF, 0x75, 0x10, 0x8B, 0xD6, 0xFF, 0xD0, 0x8B, 0x43, 0x34, 0x56, 0x6A, 0x00, 0xFF, 0xB3, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xE9, 0x06, 0x01, 0x00, 0x00, 0x52, 0x8D, 0x55, 0xFC, 0x52, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0x04, 0xFF, 0x75, 0x10, 0x8B, 0xD6, 0xFF, 0xD0, 0x8B, 0x43, 0x34, 0x56, 0x6A, 0x00, 0xFF, 0xB3, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xE9, 0xE1, 0x00, 0x00, 0x00, 0x83, 0xF8, 0x3F, 0x75, 0x54, 0x8B, 0x43, 0x30, 0x6A, 0x14, 0x6A, 0x08, 0xFF, 0xB3, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x89, 0x45, 0xF0, 0x85, 0xC0, 0x74, 0x58, 0x8B, 0x7D, 0x0C, 0x8B, 0xD0, 0x8B, 0x4F, 0x04, 0x89, 0x48, 0x0C, 0x8D, 0x4D, 0xF4, 0x8B, 0x73, 0x38, 0x51, 0x8D, 0x4D, 0xFC, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x51, 0x6A, 0x01, 0xFF, 0x75, 0x10, 0x8B, 0xCF, 0xFF, 0xD6, 0xFF, 0x75, 0xF0, 0x89, 0x45, 0xF8, 0x8B, 0x43, 0x34, 0x6A, 0x00, 0xFF, 0xB3, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xE9, 0x88, 0x00, 0x00, 0x00, 0x83, 0xF8, 0x3E, 0x75, 0x5E, 0x8B, 0x43, 0x30, 0x6A, 0x18, 0x6A, 0x08, 0xFF, 0xB3, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x8B, 0xF0, 0x85, 0xF6, 0x75, 0x0E, 0x5F, 0x5E, 0xB8, 0x17, 0x00, 0x00, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x14, 0x00, 0x8B, 0x4D, 0x0C, 0x8D, 0x55, 0xF0, 0x52, 0x8D, 0x55, 0xFC, 0x52, 0x8B, 0x41, 0x04, 0x6A, 0x01, 0xFF, 0x75, 0x10, 0x89, 0x46, 0x04, 0xC6, 0x46, 0x08, 0x01, 0x8B, 0x43, 0x38, 0x56, 0x51, 0xC7, 0x45, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x56, 0x89, 0x45, 0xF8, 0x8B, 0x43, 0x34, 0x6A, 0x00, 0xFF, 0xB3, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xEB, 0x25, 0x83, 0xF8, 0x3D, 0x0F, 0x85, 0x69, 0x01, 0x00, 0x00, 0x8B, 0x43, 0x38, 0x8D, 0x4D, 0xFC, 0x51, 0x6A, 0x00, 0x6A, 0x01, 0xFF, 0x75, 0x10, 0xFF, 0xB3, 0x90, 0x00, 0x00, 0x00, 0xFF, 0x75, 0x0C, 0xFF, 0xD0, 0x89, 0x45, 0xF8, 0x83, 0x7D, 0xF8, 0x00, 0x0F, 0x8C, 0x4A, 0x01, 0x00, 0x00, 0x8B, 0x4D, 0xFC, 0x85, 0xC9, 0x0F, 0x84, 0x25, 0x01, 0x00, 0x00, 0x8B, 0x55, 0x14, 0x8B, 0x75, 0x18, 0x8B, 0x41, 0x18, 0x89, 0x02, 0x85, 0xF6, 0x0F, 0x84, 0xF5, 0x00, 0x00, 0x00, 0x8B, 0x16, 0x85, 0xD2, 0x75, 0x6F, 0x8B, 0x45, 0x14, 0x8D, 0x79, 0x24, 0x68, 0x14, 0x02, 0x00, 0x00, 0x6A, 0x08, 0xFF, 0xB3, 0xD8, 0x00, 0x00, 0x00, 0x8B, 0x00, 0x89, 0x45, 0x10, 0x8B, 0x43, 0x30, 0xFF, 0xD0, 0x89, 0x06, 0x85, 0xC0, 0x0F, 0x84, 0xC5, 0x00,
	0x00, 0x00, 0x8B, 0x4D, 0x10, 0x89, 0x00, 0x8B, 0x06, 0x89, 0x40, 0x04, 0x8B, 0x06, 0x89, 0x48, 0x08, 0x85, 0xFF, 0x0F, 0x84, 0xAE, 0x00, 0x00, 0x00, 0x0F, 0xB7, 0x17, 0xB9, 0x00, 0x02, 0x00, 0x00, 0x66, 0x3B, 0xD1, 0x0F, 0x83, 0x9D, 0x00, 0x00, 0x00, 0x8B, 0x06, 0x52, 0x66, 0x89, 0x50, 0x0C, 0x8B, 0x06, 0x66, 0x89, 0x48, 0x0E, 0x8B, 0x0E, 0x8D, 0x41, 0x14, 0x89, 0x41, 0x10, 0x8B, 0x06, 0xFF, 0x77, 0x04, 0x83, 0xC0, 0x14, 0x50, 0xEB, 0x75, 0x8B, 0x79, 0x18, 0x8B, 0xC2, 0x39, 0x78, 0x08, 0x74, 0x76, 0x8B, 0x00, 0x3B, 0xC2, 0x75, 0xF5, 0x8B, 0x45, 0x14, 0x8D, 0x79, 0x24, 0x68, 0x14, 0x02, 0x00, 0x00, 0x6A, 0x08, 0xFF, 0xB3, 0xD8, 0x00, 0x00, 0x00, 0x8B, 0x00, 0x89, 0x45, 0x10, 0x8B, 0x43, 0x30, 0xFF, 0xD0, 0x8B, 0xD0, 0x85, 0xD2, 0x74, 0x4A, 0x8B, 0x0E, 0x89, 0x0A, 0x8B, 0x0E, 0x8B, 0x49, 0x04, 0x89, 0x4A, 0x04, 0x8B, 0x0E, 0x8B, 0x41, 0x04, 0x89, 0x10, 0x8B, 0x06, 0x89, 0x50, 0x04, 0x8B, 0x45, 0x10, 0x89, 0x42, 0x08, 0x85, 0xFF, 0x74, 0x28, 0x0F, 0xB7, 0x07, 0xB9, 0x00, 0x02, 0x00, 0x00, 0x66, 0x3B, 0xC1, 0x73, 0x1B, 0x66, 0x89, 0x4A, 0x0E, 0x8D, 0x4A, 0x14, 0x50, 0x66, 0x89, 0x42, 0x0C, 0x89, 0x4A, 0x10, 0xFF, 0x77, 0x04, 0x51, 0x8B, 0x43, 0x28, 0xFF, 0xD0, 0x83, 0xC4, 0x0C, 0x8B, 0x4D, 0xFC, 0x8B, 0x45, 0x08, 0x83, 0xB8, 0x30, 0x02, 0x00, 0x00, 0x64, 0x72, 0x2B, 0x8B, 0x43, 0x70, 0xFF, 0xD0, 0x8B, 0x45, 0xF8, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x14, 0x00, 0x5F, 0x5E, 0xC7, 0x45, 0xF8, 0x35, 0x01, 0x00, 0xC0, 0x8B, 0x45, 0xF8, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x14, 0x00, 0xC7, 0x45, 0xF8, 0x02, 0x00, 0x00, 0xC0, 0x8B, 0x45, 0xF8, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC2, 0x14, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$12", read, write)
__declspec(allocate("wow64_sec$12")) inline unsigned char VectoredHandlerShell_WOW64[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x3C, 0x56, 0xC7, 0x45, 0xEC, 0x0C, 0xB0, 0xCE, 0xFA, 0xC7, 0x45, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x64, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x89, 0x45, 0xE8, 0x83, 0x7D, 0xE8, 0x00, 0x75, 0x07, 0x33, 0xC0, 0xE9, 0xC8, 0x02, 0x00, 0x00, 0xC7, 0x45, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xEC, 0x83, 0x79, 0x08, 0x3D, 0x75, 0x09, 0xC7, 0x45, 0xD4, 0x01, 0x00, 0x00, 0x00, 0xEB, 0x07, 0xC7, 0x45, 0xD4, 0x00, 0x00, 0x00, 0x00, 0x8A, 0x55, 0xD4, 0x88, 0x55, 0xFF, 0x0F, 0xB6, 0x45, 0xFF, 0x85, 0xC0, 0x74, 0x17, 0x8B, 0x4D, 0xEC, 0x8B, 0x51, 0x0C, 0xB8, 0x10, 0x00, 0x00, 0x00, 0x6B, 0xC8, 0x00, 0x8D, 0x54, 0x0A, 0x0C, 0x89, 0x55, 0xE4, 0xEB, 0x15, 0x8B, 0x45, 0xEC, 0x8B, 0x48, 0x0C, 0xBA, 0x10, 0x00, 0x00, 0x00, 0x6B, 0xC2, 0x00, 0x8D, 0x4C, 0x01, 0x10, 0x89, 0x4D, 0xE4, 0x8B, 0x55, 0xEC, 0x83, 0x7A, 0x08, 0x3F, 0x72, 0x0E, 0x8B, 0x45, 0xEC, 0x8B, 0x48, 0x10, 0x89, 0x4D, 0xC8, 0x6A, 0x00, 0xFF, 0x55, 0xC8, 0x8B, 0x15, 0x30, 0x03, 0xFE, 0x7F, 0x89, 0x55, 0xCC, 0xEB, 0x08, 0x8B, 0x45, 0xE8, 0x8B, 0x08, 0x89, 0x4D, 0xE8, 0x83, 0x7D, 0xE8, 0x00, 0x0F, 0x84, 0x21, 0x02, 0x00, 0x00, 0x83, 0x7D, 0xE8, 0xFF, 0x0F, 0x84, 0x17, 0x02, 0x00, 0x00, 0x8B, 0x55, 0xE8, 0x83, 0x3A, 0xFF, 0x0F, 0x84, 0x0B, 0x02, 0x00, 0x00, 0xC7, 0x45, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x09, 0x8B, 0x45, 0xF0, 0x83, 0xC0, 0x01, 0x89, 0x45, 0xF0, 0x8B, 0x4D, 0xEC, 0x8B, 0x51, 0x0C, 0x8B, 0x45, 0xF0, 0x3B, 0x02, 0x0F, 0x83, 0xE3, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0x4D, 0xFF, 0x85, 0xC9, 0x75, 0x08, 0x83, 0x7D, 0xF0, 0x00, 0x75, 0x02, 0xEB, 0xD6, 0x8B, 0x55, 0xF0, 0xC1, 0xE2, 0x04, 0x8B, 0x45, 0xEC, 0x8B, 0x08, 0x8B, 0x45, 0xE4, 0x39, 0x4C, 0x10, 0x04, 0x74, 0x02, 0xEB, 0xC0, 0x8B, 0x4D, 0xEC, 0x8B, 0x11, 0x8B, 0x45, 0xE8, 0x39, 0x50, 0x04, 0x72, 0x13, 0x8B, 0x4D, 0xEC, 0x8B, 0x11, 0x8B, 0x45, 0xEC, 0x03, 0x50, 0x04, 0x8B, 0x4D, 0xE8, 0x39, 0x51, 0x04, 0x72, 0x02, 0xEB, 0x9E, 0xC6, 0x45, 0xFE, 0x00, 0x8B, 0x55, 0xF0, 0xC1, 0xE2, 0x04, 0x8B, 0x45, 0xE4, 0x8B, 0x0C, 0x10, 0x89, 0x4D, 0xDC, 0x8B, 0x55, 0xCC, 0x83, 0xE2, 0x1F, 0x89, 0x55, 0xD0, 0x8B, 0x4D, 0xD0, 0xF7, 0xD9, 0x8B, 0x45, 0xDC, 0xD3, 0xE8, 0x8B, 0x55, 0xDC, 0x8B, 0x4D, 0xD0, 0xD3, 0xE2, 0x0B, 0xD0, 0x89, 0x55, 0xDC, 0x8B, 0x45, 0xDC, 0x33, 0x45, 0xCC, 0x89, 0x45, 0xDC, 0x8B, 0x4D, 0xDC, 0x89, 0x4D, 0xF4, 0x8B, 0x55, 0xF4, 0x89, 0x55, 0xE0, 0xEB, 0x09, 0x8B, 0x45, 0xE0, 0x83, 0xC0, 0x04, 0x89, 0x45, 0xE0, 0x83, 0x7D, 0xE0, 0x00, 0x74, 0x71, 0x8B, 0x4D, 0xF4, 0x81, 0xC1, 0x00, 0x04, 0x00, 0x00, 0x39, 0x4D, 0xE0, 0x73, 0x63, 0x8B, 0x55, 0xE0, 0x83, 0x3A, 0x00, 0x75, 0x3D, 0x8B, 0x45, 0xF0, 0xC1, 0xE0, 0x04, 0x8B, 0x4D, 0xE8, 0x8B, 0x55, 0xE4, 0x8B, 0x49, 0x04, 0x2B, 0x4C, 0x02, 0x04, 0x8B, 0x55, 0xE0, 0x89, 0x0A, 0x8B, 0x45, 0xF0, 0xC1, 0xE0, 0x04, 0x8B, 0x4D, 0xE4, 0x8B, 0x54, 0x01, 0x0C, 0x83, 0xC2, 0x01, 0x8B, 0x45, 0xF0, 0xC1, 0xE0, 0x04, 0x8B, 0x4D, 0xE4, 0x89, 0x54, 0x01, 0x0C, 0xC6, 0x45, 0xFE, 0x01, 0xEB, 0x20, 0xEB, 0x1C, 0x8B, 0x55, 0xF0, 0xC1, 0xE2, 0x04, 0x8B, 0x45, 0xE4, 0x8B, 0x4C, 0x10, 0x04, 0x8B,
	0x55, 0xE0, 0x03, 0x0A, 0x8B, 0x45, 0xE8, 0x39, 0x48, 0x04, 0x75, 0x02, 0xEB, 0x02, 0xEB, 0x80, 0x0F, 0xB6, 0x4D, 0xFE, 0x85, 0xC9, 0x0F, 0x84, 0xC0, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xD8, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x09, 0x8B, 0x55, 0xD8, 0x83, 0xC2, 0x01, 0x89, 0x55, 0xD8, 0x8B, 0x45, 0xF0, 0xC1, 0xE0, 0x04, 0x8B, 0x4D, 0xE4, 0x8B, 0x55, 0xD8, 0x3B, 0x54, 0x01, 0x0C, 0x0F, 0x83, 0x98, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xF0, 0xC1, 0xE0, 0x04, 0x8B, 0x4D, 0xE4, 0x8B, 0x54, 0x01, 0x0C, 0x83, 0xEA, 0x01, 0x89, 0x55, 0xF8, 0xEB, 0x09, 0x8B, 0x45, 0xF8, 0x83, 0xE8, 0x01, 0x89, 0x45, 0xF8, 0x8B, 0x4D, 0xF8, 0x3B, 0x4D, 0xD8, 0x76, 0x6D, 0x8B, 0x55, 0xF8, 0x8B, 0x45, 0xF4, 0x8B, 0x4D, 0xF8, 0x8B, 0x75, 0xF4, 0x8B, 0x54, 0x90, 0xFC, 0x3B, 0x14, 0x8E, 0x76, 0x56, 0x8B, 0x45, 0xF8, 0x8B, 0x4D, 0xF4, 0x8B, 0x55, 0xF8, 0x8B, 0x75, 0xF4, 0x8B, 0x44, 0x81, 0xFC, 0x33, 0x04, 0x96, 0x8B, 0x4D, 0xF8, 0x8B, 0x55, 0xF4, 0x89, 0x44, 0x8A, 0xFC, 0x8B, 0x45, 0xF8, 0x8B, 0x4D, 0xF4, 0x8B, 0x55, 0xF8, 0x8B, 0x75, 0xF4, 0x8B, 0x04, 0x81, 0x33, 0x44, 0x96, 0xFC, 0x8B, 0x4D, 0xF8, 0x8B, 0x55, 0xF4, 0x89, 0x04, 0x8A, 0x8B, 0x45, 0xF8, 0x8B, 0x4D, 0xF4, 0x8B, 0x55, 0xF8, 0x8B, 0x75, 0xF4, 0x8B, 0x44, 0x81, 0xFC, 0x33, 0x04, 0x96, 0x8B, 0x4D, 0xF8, 0x8B, 0x55, 0xF4, 0x89, 0x44, 0x8A, 0xFC, 0xEB, 0x82, 0xE9, 0x49, 0xFF, 0xFF, 0xFF, 0xE9, 0x03, 0xFE, 0xFF, 0xFF, 0xE9, 0xCD, 0xFD, 0xFF, 0xFF, 0x8B, 0x45, 0xEC, 0x83, 0x78, 0x08, 0x3F, 0x72, 0x0E, 0x8B, 0x4D, 0xEC, 0x8B, 0x51, 0x10, 0x89, 0x55, 0xC4, 0x6A, 0x01, 0xFF, 0x55, 0xC4, 0x33, 0xC0, 0x5E, 0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC
};

#pragma section("wow64_sec$13", read, write)
__declspec(allocate("wow64_sec$13")) inline unsigned char WOW64_SEC_END[] =
{
	1, 3, 3, 7
};

#endif
```

`GH Injector Library/Win10.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "NT Defs.h"

typedef struct _LDR_DDAG_NODE_WIN10
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	PLDRP_CSLIST			Dependencies;
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN10, * PLDR_DDAG_NODE_WIN10;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN10
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG LoadConfigProcessed		: 1;
			ULONG EntryProcessed			: 1;
			ULONG ProtectDelayLoad			: 1;
			ULONG ReservedFlags3			: 2;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ChpeImage					: 1;
			ULONG ReservedFlags5			: 2;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID Lock;

	LDR_DDAG_NODE_WIN10 * DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		LoadContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;

	//1607+
	ULONG DependentLoadFlags;

	//1703+
	UCHAR SigningLevel;
} LDR_DATA_TABLE_ENTRY_WIN10, * PLDR_DATA_TABLE_ENTRY_WIN10;

#ifdef _WIN64

typedef ALIGN_86 struct _LDR_DDAG_NODE_WIN10_32
{
	LIST_ENTRY32			Modules;
	DWORD					ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	DWORD					Dependencies; // -> LDRP_CSLIST_32
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN10_32, * PLDR_DDAG_NODE_WIN10_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN10_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG LoadConfigProcessed		: 1;
			ULONG EntryProcessed			: 1;
			ULONG ProtectDelayLoad			: 1;
			ULONG ReservedFlags3			: 2;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ChpeImage					: 1;
			ULONG ReservedFlags5			: 2;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD Spare;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN10_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			LoadContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel;
} LDR_DATA_TABLE_ENTRY_WIN10_32, * PLDR_DATA_TABLE_ENTRY_WIN10_32;

#endif
```

`GH Injector Library/Win11.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "NT Defs.h"

typedef struct _LDR_DDAG_NODE_WIN11
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	PLDRP_CSLIST			Dependencies;
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN11, * PLDR_DDAG_NODE_WIN11;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN11
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG LoadConfigProcessed		: 1;
			ULONG EntryProcessed			: 1;
			ULONG ProtectDelayLoad			: 1;
			ULONG ReservedFlags3			: 2;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ChpeImage					: 1;
			ULONG ReservedFlags5			: 2;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID Lock;

	LDR_DDAG_NODE_WIN11 * DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		LoadContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel;

	ULONG CheckSum;
	PVOID ActivePathImageBase;
	LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY_WIN11, * PLDR_DATA_TABLE_ENTRY_WIN11;

#ifdef _WIN64

typedef ALIGN_86 struct _LDR_DDAG_NODE_WIN11_32
{
	LIST_ENTRY32			Modules;
	DWORD					ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG					LoadCount;
	ULONG					LoadWhileUnloadingCount;
	ULONG					LowestLink;
	DWORD					Dependencies; // -> LDRP_CSLIST_32
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
} LDR_DDAG_NODE_WIN11_32, * PLDR_DDAG_NODE_WIN11_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN11_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG LoadConfigProcessed		: 1;
			ULONG EntryProcessed			: 1;
			ULONG ProtectDelayLoad			: 1;
			ULONG ReservedFlags3			: 2;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ChpeImage					: 1;
			ULONG ReservedFlags5			: 2;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD Spare;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN11_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			LoadContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
	ULONG				ImplicitPathOptions;

	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel;

	ULONG CheckSum;
	DWORD ActivePathImageBase;
	LDR_HOT_PATCH_STATE HotPatchState;
} LDR_DATA_TABLE_ENTRY_WIN11_32, * PLDR_DATA_TABLE_ENTRY_WIN11_32;

#endif
```

`GH Injector Library/Win7.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "NT Defs.h"

//some flags might not be Win7 but w/e, stolen from here:
//https://doxygen.reactos.org/d1/d97/ldrtypes_8h_source.html#l00034

//0x00000001
#define LDRP_STATIC_LINK				0x00000002
#define LDRP_IMAGE_DLL					0x00000004
#define LDRP_SHIMENG_ENTRY_PROCESSED	0x00000008
#define LDRP_TELEMETRY_ENTRY_PROCESSED	0x00000010
#define LDRP_IMAGE_INTEGRITY_FORCED		0x00000020
//0x00000040 - 0x00000800
#define LDRP_LOAD_IN_PROGRESS			0x00001000
#define LDRP_UNLOAD_IN_PROGRESS			0x00002000
#define LDRP_ENTRY_PROCESSED			0x00004000
#define LDRP_ENTRY_INSERTED				0x00008000  
#define LDRP_CURRENT_LOAD				0x00010000
#define LDRP_FAILED_BUILTIN_LOAD		0x00020000
#define LDRP_DONT_CALL_FOR_THREADS		0x00040000
#define LDRP_PROCESS_ATTACH_CALLED		0x00080000
#define LDRP_DEBUG_SYMBOLS_LOADED		0x00100000 
#define LDRP_IMAGE_NOT_AT_BASE			0x00200000 
#define LDRP_COR_IMAGE					0x00400000 
#define LDR_COR_OWNS_UNMAP				0x00800000 
#define LDRP_SYSTEM_MAPPED				0x01000000 
#define LDRP_IMAGE_VERIFYING			0x02000000 
#define LDRP_DRIVER_DEPENDENT_DLL		0x04000000 
#define LDRP_ENTRY_NATIVE				0x08000000 
#define LDRP_REDIRECTED					0x10000000 
#define LDRP_NON_PAGED_DEBUG_INFO		0x20000000 
#define LDRP_MM_LOADED					0x40000000 
#define LDRP_COMPAT_DATABASE_PROCESSED	0x80000000

typedef struct _LDR_DDAG_NODE_WIN7 //dummy for macros
{
} LDR_DDAG_NODE_WIN7, * PLDR_DDAG_NODE_WIN7;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN7
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING	FullDllName;
	UNICODE_STRING	BaseDllName;

	ULONG	Flags;
	WORD	LoadCount;
	WORD	TlsIndex;

	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};

	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};

	PVOID EntryPointActivationContext;
	PVOID PatchInformation;

	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;

	PVOID			ContextInformation;
	ULONG_PTR		OriginalBase;
	LARGE_INTEGER	LoadTime;
} LDR_DATA_TABLE_ENTRY_WIN7, * PLDR_DATA_TABLE_ENTRY_WIN7;

typedef struct _RTL_INVERTED_FUNCTION_TABLE_WIN7
{
	ULONG Count;
	ULONG MaxCount;
	ULONG Epoch;
	RTL_INVERTED_FUNCTION_TABLE_ENTRY Entries[ANYSIZE_ARRAY];
} RTL_INVERTED_FUNCTION_TABLE_WIN7, * PRTL_INVERTED_FUNCTION_TABLE_WIN7;

#ifdef _WIN64

typedef struct _LDR_DDAG_NODE_WIN7_32 //dummy for macros
{
} LDR_DDAG_NODE_WIN7_32, * PLDR_DDAG_NODE_WIN7_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN7_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	ULONG	Flags;
	WORD	LoadCount;
	WORD	TlsIndex;

	union
	{
		LIST_ENTRY32 HashLinks;
		struct
		{
			DWORD SectionPointer;
			ULONG CheckSum;
		};
	};

	union
	{
		ULONG TimeDateStamp;
		DWORD LoadedImports;
	};

	DWORD EntryPointActivationContext;
	DWORD PatchInformation;

	LIST_ENTRY32 ForwarderLinks;
	LIST_ENTRY32 ServiceTagLinks;
	LIST_ENTRY32 StaticLinks;

	DWORD			ContextInformation;
	DWORD			OriginalBase;
	LARGE_INTEGER	LoadTime;
} LDR_DATA_TABLE_ENTRY_WIN7_32, * PLDR_DATA_TABLE_ENTRY_WIN7_32;

typedef struct _RTL_VECTORED_EXCEPTION_ENTRY_WIN7_32 //prototype
{
	LIST_ENTRY32	List;
	DWORD			Flag;
	DWORD			VectoredHandler; //PVECTORED_EXCEPTION_HANDLER
} RTL_VECTORED_EXCEPTION_ENTRY_WIN7_32, * PRTL_VECTORED_EXCEPTION_ENTRY_WIN7_32;

#endif
```

`GH Injector Library/Win8.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "NT Defs.h"

typedef struct _LDR_DDAG_NODE_WIN8
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					ReferenceCount;
	ULONG					DependencyCount;
	union
	{
		LDRP_CSLIST			Dependencies;
		SINGLE_LIST_ENTRY * RemovalLink;
	};
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN8, * PLDR_DDAG_NODE_WIN8;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN8
{
	LIST_ENTRY		InLoadOrderLinks;
	LIST_ENTRY		InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING	FullDllName;
	UNICODE_STRING	BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG ReservedFlags2			: 1; 
			ULONG EntryProcessed			: 1;
			ULONG ReservedFlags3			: 3;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ReservedFlags5			: 3;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID PatchInformation;

	LDR_DDAG_NODE_WIN8 * DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		SnapContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
} LDR_DATA_TABLE_ENTRY_WIN8, * PLDR_DATA_TABLE_ENTRY_WIN8;

typedef struct _LDRP_PATH_SEARCH_CONTEXT_WIN8
{
	ULONG_PTR Flags; //probably LDRP_LOAD_CONTEXT_FLAGS
	wchar_t * OriginalFullDllName; //can be path
	BOOLEAN		unknown2; //only low byte relevant
	ULONG_PTR	unknown3[3]; //sometimes imagebase?
} LDRP_PATH_SEARCH_CONTEXT_WIN8, * PLDRP_PATH_SEARCH_CONTEXT_WIN8;

#ifdef _WIN64

typedef ALIGN_86 struct _LDR_DDAG_NODE_WIN8_32
{
	LIST_ENTRY32	Modules;
	DWORD			ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG			LoadCount;
	ULONG			ReferenceCount;
	ULONG			DependencyCount;
	union
	{
		LDRP_CSLIST_32	Dependencies;
		DWORD			RemovalLink; // -> SINGLE_LIST_ENTRY_32
	};
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN8_32, * PLDR_DDAG_NODE_WIN8_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN8_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	union
	{
		LIST_ENTRY32 InInitializationOrderLinks;
		LIST_ENTRY32 InProgressLinks;
	};

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG ReservedFlags2			: 1;
			ULONG EntryProcessed			: 1;
			ULONG ReservedFlags3			: 3;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ReservedFlags5			: 3;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD PatchInformation;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN8_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			SnapContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;
} LDR_DATA_TABLE_ENTRY_WIN8_32, * PLDR_DATA_TABLE_ENTRY_WIN8_32;

#endif
```

`GH Injector Library/Win81.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "NT Defs.h"

typedef struct _LDR_DDAG_NODE_WIN81
{
	LIST_ENTRY				Modules;
	PLDR_SERVICE_TAG_RECORD	ServiceTagList;
	ULONG					LoadCount;
	ULONG					ReferenceCount;
	ULONG					DependencyCount;
	union
	{
		LDRP_CSLIST			Dependencies;
		SINGLE_LIST_ENTRY * RemovalLink;
	};
	PLDRP_CSLIST			IncomingDependencies;
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY		CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN81, * PLDR_DDAG_NODE_WIN81;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN81
{
	LIST_ENTRY		InLoadOrderLinks;
	LIST_ENTRY		InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};

	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING	FullDllName;
	UNICODE_STRING	BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG ReservedFlags2			: 1; 
			ULONG EntryProcessed			: 1;
			ULONG ReservedFlags3			: 3;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ReservedFlags5			: 3;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY HashLinks;

	ULONG TimedateStamp;
	PVOID EntryPointActivationContext;
	PVOID Spare;

	LDR_DDAG_NODE_WIN81 * DdagNode;

	LIST_ENTRY	NodeModuleLink;
	PVOID		SnapContext;
	PVOID		ParentDllBase;
	PVOID		SwitchBackContext;

	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;

	ULONG_PTR			OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;

	ULONG ImplicitPathOptions;
} LDR_DATA_TABLE_ENTRY_WIN81, * PLDR_DATA_TABLE_ENTRY_WIN81;

typedef struct _LDRP_PATH_SEARCH_CONTEXT_WIN81
{
	UINT_PTR unknown_0[3];
	wchar_t * OriginalFullDllName;
	UINT_PTR unknown_1[1];
} LDRP_PATH_SEARCH_CONTEXT_WIN81, * PLDRP_PATH_SEARCH_CONTEXT_WIN81; //x86 size = 0x14, x64 size = 0x28

#ifdef _WIN64

typedef ALIGN_86 struct _LDR_DDAG_NODE_WIN81_32
{
	LIST_ENTRY32	Modules;
	DWORD			ServiceTagList; // -> LDR_SERVICE_TAG_RECORD_32
	ULONG			LoadCount;
	ULONG			ReferenceCount;
	ULONG			DependencyCount;
	union
	{
		LDRP_CSLIST_32	Dependencies;
		DWORD			RemovalLink; // -> SINGLE_LIST_ENTRY_32
	};
	DWORD					IncomingDependencies; // -> LDRP_CSLIST_32
	LDR_DDAG_STATE			State;
	SINGLE_LIST_ENTRY_32	CondenseLink;
	ULONG					PreorderNumber;
	ULONG					LowestLink;
} LDR_DDAG_NODE_WIN81_32, * PLDR_DDAG_NODE_WIN81_32;

typedef struct _LDR_DATA_TABLE_ENTRY_WIN81_32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	union
	{
		LIST_ENTRY32 InInitializationOrderLinks;
		LIST_ENTRY32 InProgressLinks;
	};

	DWORD DllBase;
	DWORD EntryPoint;
	ULONG SizeOfImage;

	UNICODE_STRING_32 FullDllName;
	UNICODE_STRING_32 BaseDllName;

	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;

		struct
		{
			ULONG PackagedBinary			: 1;
			ULONG MarkedForRemoval			: 1;
			ULONG ImageDll					: 1;
			ULONG LoadNotificationsSent		: 1;
			ULONG TelemetryEntryProcessed	: 1;
			ULONG ProcessStaticImport		: 1;
			ULONG InLegacyLists				: 1;
			ULONG InIndexes					: 1;
			ULONG ShimDll					: 1;
			ULONG InExceptionTable			: 1;
			ULONG ReservedFlags1			: 2;
			ULONG LoadInProgress			: 1;
			ULONG ReservedFlags2			: 1;
			ULONG EntryProcessed			: 1;
			ULONG ReservedFlags3			: 3;
			ULONG DontCallForThreads		: 1;
			ULONG ProcessAttachCalled		: 1;
			ULONG ProcessAttachFailed		: 1;
			ULONG CorDeferredValidate		: 1;
			ULONG CorImage					: 1;
			ULONG DontRelocate				: 1;
			ULONG CorILOnly					: 1;
			ULONG ReservedFlags5			: 3;
			ULONG Redirected				: 1;
			ULONG ReservedFlags6			: 2;
			ULONG CompatDatabaseProcessed	: 1;
		};
	};

	WORD ObsoleteLoadCount;
	WORD TlsIndex;

	LIST_ENTRY32 HashLinks;

	ULONG TimedateStamp;
	DWORD EntryPointActivationContext;
	DWORD Spare;

	DWORD DdagNode; // -> LDR_DDAG_NODE_WIN81_32

	LIST_ENTRY32	NodeModuleLink;
	DWORD			SnapContext;
	DWORD			ParentDllBase;
	DWORD			SwitchBackContext;

	RTL_BALANCED_NODE_32 BaseAddressIndexNode;
	RTL_BALANCED_NODE_32 MappingInfoIndexNode;

	DWORD				OriginalBase;
	LARGE_INTEGER		LoadTime;
	ULONG				BaseNameHashValue;
	LDR_DLL_LOAD_REASON	LoadReason;

	ULONG ImplicitPathOptions;
} LDR_DATA_TABLE_ENTRY_WIN81_32, * PLDR_DATA_TABLE_ENTRY_WIN81_32;

#endif
```

`GH Injector Library/main.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Import Handler.h"

#if !defined(_WIN64) && defined (DUMP_SHELLCODE)
#include "Manual Mapping.h"
#include "Injection Internal.h"
#endif

BOOL WINAPI DllMain(HINSTANCE hDll, DWORD dwReason, void * pReserved)
{
	UNREFERENCED_PARAMETER(pReserved);
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		GetOSVersion();

#if !defined(_WIN64) && defined (DUMP_SHELLCODE)
		HINSTANCE	dummy_instance{ 0 };
		ERROR_DATA	dummy_data{ 0 };
		INJECTION_SOURCE s;
		InjectDLL(s, nullptr, INJECTION_MODE::IM_LoadLibraryExW, LAUNCH_METHOD::LM_NtCreateThreadEx, NULL, dummy_instance, 0, dummy_data);
		MMAP_NATIVE::ManualMap(s, nullptr, LAUNCH_METHOD::LM_NtCreateThreadEx, NULL, dummy_instance, 0, dummy_data);
#endif

		LOG(0, "GH Injector V%ls loaded\nImagebase = %p\n", GH_INJ_VERSIONW, hDll);

		g_hInjMod = hDll;

		if (!GetOwnModulePathW(g_RootPathW))
		{
			LOG(0, "Couldn't resolve own module path (unicode)\n");

			return FALSE;
		}

		wchar_t * szWindowsDir = nullptr;
		if (_wdupenv_s(&szWindowsDir, nullptr, L"WINDIR") || !szWindowsDir)
		{
			LOG(0, "Couldn't resolve %%WINDIR%%\n");

			if (szWindowsDir)
			{
				free(szWindowsDir);
			}

			return FALSE;
		}

		std::wstring szNtDllNative = szWindowsDir;
		szNtDllNative += L"\\System32\\ntdll.dll";

		LOG(0, "Launching PDB thread(s)\n");

		sym_ntdll_native_ret = std::async(std::launch::async, &SYMBOL_LOADER::Initialize, &sym_ntdll_native, szNtDllNative, g_RootPathW, nullptr, false, true, false);

#ifdef _WIN64
		std::wstring szNtDllWOW64 = szWindowsDir;
		szNtDllWOW64 += L"\\SysWOW64\\ntdll.dll";

		sym_ntdll_wow64_ret = std::async(std::launch::async, &SYMBOL_LOADER::Initialize, &sym_ntdll_wow64, szNtDllWOW64, g_RootPathW, nullptr, false, true, false);
#endif

		if (GetOSVersion() == g_Win7)
		{
			std::wstring szKernel32Native = szWindowsDir;
			szKernel32Native += L"\\System32\\kernel32.dll";

			LOG(0, "Launching PDB thread(s)\n");

			sym_kernel32_native_ret = std::async(std::launch::async, &SYMBOL_LOADER::Initialize, &sym_kernel32_native, szKernel32Native, g_RootPathW, nullptr, false, true, false);

#ifdef _WIN64
			std::wstring szKernel32WOW64 = szWindowsDir;
			szKernel32WOW64 += L"\\SysWOW64\\kernel32.dll";

			sym_kernel32_wow64_ret = std::async(std::launch::async, &SYMBOL_LOADER::Initialize, &sym_kernel32_wow64, szKernel32WOW64, g_RootPathW, nullptr, false, true, false);
#endif
		}

		free(szWindowsDir);

		LOG(0, "Launching import resolver thread\n");

		import_handler_ret = std::async(std::launch::async, &ResolveImports, std::ref(import_handler_error_data));

#ifdef _WIN64
		import_handler_wow64_ret = std::async(std::launch::async, &ResolveImports_WOW64, std::ref(import_handler_error_data));
#endif

		g_hRunningEvent	= CreateEvent(nullptr, TRUE, FALSE, nullptr);
		if (!g_hRunningEvent)
		{
			LOG(0, "Failed to create event (1): %08X\n", GetLastError());
		}

		g_hInterruptEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
		if (!g_hInterruptEvent)
		{
			LOG(0, "Failed to create event (2): %08X\n", GetLastError());
		}

		g_hInterruptedEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
		if (!g_hInterruptedEvent)
		{
			LOG(0, "Failed to create event (3): %08X\n", GetLastError());
		}

		g_hInterruptImport = CreateEvent(nullptr, TRUE, FALSE, nullptr);
		if (!g_hInterruptImport)
		{
			LOG(0, "Failed to create event (4): %08X\n", GetLastError());
		}

		LOG(0, "DllMain exit\n");
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		if (sym_ntdll_native_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
		{
			LOG(0, "ntdll.pdb download thread didn't exit properly.\n");
		}

#ifdef _WIN64
		if (sym_ntdll_wow64_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
		{
			LOG(0, "wntdll.pdb download thread didn't exit properly.\n");
		}
#endif

		if (GetOSVersion() == g_Win7)
		{
			if (sym_kernel32_native_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
			{
				LOG(0, "kernel32.pdb download thread didn't exit properly.\n");
			}

#ifdef _WIN64
			if (sym_kernel32_wow64_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
			{
				LOG(0, "wkernel32.pdb download thread didn't exit properly.\n");
			}
#endif
		}

		if (import_handler_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
		{
			LOG(0, "import handler (native) thread didn't exit properly.\n");
		}

#ifdef _WIN64
		if (import_handler_wow64_ret.wait_for(std::chrono::milliseconds(0)) != std::future_status::ready)
		{
			LOG(0, "import handler (wow64) thread didn't exit properly.\n");
		}
#endif

		if (g_hRunningEvent)
		{
			CloseHandle(g_hRunningEvent);
		}

		if (g_hInterruptEvent)
		{
			CloseHandle(g_hInterruptEvent);
		}

		if (g_hInterruptedEvent)
		{
			CloseHandle(g_hInterruptedEvent);
		}

		if (g_hInterruptImport)
		{
			CloseHandle(g_hInterruptImport);
		}

		LOG(0, "GH Injector V%ls detached\n", GH_INJ_VERSIONW);
	}
	
	return TRUE;
}
```

`GH Injector Library/pch.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "Error.h"

#pragma comment (lib, "DbgHelp.lib")
#pragma comment (lib, "Shlwapi.lib")
#pragma comment (lib, "Urlmon.lib")
#pragma comment (lib, "Version.lib")
#pragma comment (lib, "WinInet.lib")
#pragma comment (lib, "wtsapi32.lib")

#if (PSAPI_VERSION == 1)
#pragma comment(lib, "Psapi.lib")
#endif

#ifdef DEBUG_INFO

DWORD __stdcall SetRawPrintCallback(f_raw_print_callback print)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	if (!print)
	{
		g_print_raw_callback = nullptr;

		LOG(0, "Removed print callback\n");

		return INJ_ERR_INVALID_POINTER;
	}

	g_print_raw_callback = print;

	LOG(0, "Set print callback: %p\n", g_print_raw_callback);

	return INJ_ERR_SUCCESS;
}

void ImTheTrashMan(const wchar_t * expression, const wchar_t * function, const wchar_t * file, unsigned int line, uintptr_t pReserved)
{
	UNREFERENCED_PARAMETER(expression);
	UNREFERENCED_PARAMETER(function);
	UNREFERENCED_PARAMETER(file);
	UNREFERENCED_PARAMETER(line);
	UNREFERENCED_PARAMETER(pReserved);

	//take that, CRT
	//but for real, the CRT error "handlers" are the dumbest shit ever because other than some strings you get no info to actually handle the error
	//or I am too dumb
	//probably both
}

void custom_print(int indention_offset, const char * format, ...)
{
	size_t size = 1024;
	char * buffer = new(std::nothrow) char[size + indention_offset]();

	if (!buffer)
	{
		return;
	}

	memset(buffer, '\x20', indention_offset);

	auto old = _set_thread_local_invalid_parameter_handler(ImTheTrashMan);

	int result = 0;

	do
	{
		va_list args;
		va_start(args, format);

		int err = 0;
		result = vsprintf_s(buffer + indention_offset, size, format, args);

		if (result <= 0)
		{
			err = errno;
		}

		va_end(args);

		if (result < 0 && err == ERANGE)
		{
			delete[] buffer;

			size += 1024;
			buffer = new(std::nothrow) char[size + indention_offset]();

			if (!buffer)
			{
				break;
			}

			memset(buffer, '\x20', indention_offset);
		}
		else if (result < 0)
		{
			break;
		}
	} while (result < 0);

	_set_thread_local_invalid_parameter_handler(old);

	if (result > 0)
	{

#ifdef CUSTOM_PRINT
		if (g_print_raw_callback)
		{
			g_print_raw_callback(buffer);
		}
		else
		{
			auto len = strlen(buffer);

			if (len > 0)
			{
				if (buffer[len - 1] == '\n')
				{
					buffer[len - 1] = '\0';
				}

				puts(buffer);
			}
		}
#else
		auto len = strlen(buffer);

		if (len > 0)
		{
			if (buffer[len - 1] == '\n')
			{
				buffer[len - 1] = '\0';
			}

			puts(buffer);
		}
#endif

	}

	if (buffer)
	{
		delete[] buffer;
	}
}

#else

DWORD __stdcall SetRawPrintCallback(f_raw_print_callback print)
{
#pragma EXPORT_FUNCTION(__FUNCTION__, __FUNCDNAME__)

	UNREFERENCED_PARAMETER(print);

	return INJ_ERR_NOT_IMPLEMENTED;
}

#endif
```

`GH Injector Library/pch.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

//winapi shit
#include <Windows.h>

#if (NTDDI_VERSION < NTDDI_WIN7)
#error The mininum requirement for this library is Windows 7.
#endif

//enum shit
#include <TlHelp32.h>
#include <Psapi.h>

//string shit
#include <format>
#include <sstream>
#include <string>
#include <tchar.h>

//file shit
#include <fstream>
#include <shlwapi.h>

//dank shit
#include <ctime>
#include <map>
#include <random>
#include <vector>

//session shit
#include <wtsapi32.h>

//symbol shit
#include <DbgHelp.h>
#include <future>

//internet shit
#include <WinInet.h>
#include <Urlmon.h>

//warning shit
#pragma warning(disable: 4201) //unnamed union (nt structures)
#pragma warning(disable: 4324) //structure member alignment resulting in additional bytes being added as padding
#pragma warning(disable: 6001) //uninitialized memory & handles (false positive in for loops with continue statements)
#pragma warning(disable: 6258) //TerminateThread warning
#pragma warning(disable: 28159) //I want to use GetTickCount, suck it Bill

//reinterpret_cast = too long to type
#define ReCa reinterpret_cast

//Macro to convert 32-bit DWORD into void*
#define MPTR(d) (void *)(ULONG_PTR)d

//Macro to convert dumb 64-types into a DWORD without triggereing C4302 or C4311 (also works on 32-bit sized pointers)
#define MDWD(p) (DWORD)((ULONG_PTR)p & 0xFFFFFFFF)

//Macro used to export the functions with a proper name
#define EXPORT_FUNCTION(export_name, link_name) comment(linker, "/EXPORT:" export_name "=" link_name)

//converts the __FILEW__ macro to filename only (thanks stackoverflow)
#define __FILENAMEW__ (wcsrchr(__FILEW__, '\\') + 1)

#define SM_EXE_FILENAME64 L"GH Injector SM - x64.exe"
#define SM_EXE_FILENAME86 L"GH Injector SM - x86.exe"

#define SM_INFO_FILENAME64 L"SM64.txt"
#define SM_INFO_FILENAME86 L"SM86.txt"

#define DNP_DLL_FILENAME64 L"GH Injector DNP - x64.dll"
#define DNP_DLL_FILENAME86 L"GH Injector DNP - x86.dll"

#define DNP_INFO_FILENAME L"DNPD.txt"

#ifdef _WIN64
#define SM_INFO_FILENAME SM_INFO_FILENAME64
#define SM_EXE_FILENAME SM_EXE_FILENAME64
#define DNP_DLL_FILENAME DNP_DLL_FILENAME64
#else
#define SM_INFO_FILENAME SM_INFO_FILENAME86
#define SM_EXE_FILENAME SM_EXE_FILENAME86
#define DNP_DLL_FILENAME DNP_DLL_FILENAME86
#endif

//Enum to define the injection mode.
enum class INJECTION_MODE
{
	IM_LoadLibraryExW,
	IM_LdrLoadDll,
	IM_LdrpLoadDll,
	IM_LdrpLoadDllInternal,
	IM_ManualMap
};

//enum which is used to select the method to execute the shellcode
enum class LAUNCH_METHOD
{
	LM_NtCreateThreadEx,
	LM_HijackThread,
	LM_SetWindowsHookEx,
	LM_QueueUserAPC,
	LM_KernelCallback,
	LM_FakeVEH
};

//macro to avoid compiler and shellcode related alignment issues (unlikely but just to be sure)
#define ALIGN_64 __declspec(align(8))
#define ALIGN_86 __declspec(align(4))

#ifdef _WIN64
#define ALIGN ALIGN_64
#else
#define ALIGN ALIGN_86
#endif

//Define DEBUG_INFO for console output
//Define CUSTOM_PRINT (and DEBUG_INFO) to redirect the output to a custom window/file/control etc.
//With SetRawPrintCallback you can specify the callback to be called when a debug print occurs. The passed string is raw meaning all parameters have been parsed and converted.
//Call SetRawPrintCallback(nullptr) if you want to reset the callback pointer
//If both DEBUG_INFO and CUSTOM_PRINT are defined but no callback was passed to SetRawPrintCallback puts it's used instead

#define DEBUG_INFO
#define CUSTOM_PRINT
//#define DUMP_SHELLCODE

#ifdef DEBUG_INFO
using f_raw_print_callback = void(__stdcall *)(const char * szText);
inline f_raw_print_callback g_print_raw_callback = nullptr;

void custom_print(int indention_offset, const char * format, ...);
#else
using f_raw_print_callback = void *;
#endif

DWORD __stdcall SetRawPrintCallback(f_raw_print_callback print);

#ifdef DEBUG_INFO
	#define LOG custom_print
#else
	#define LOG
#endif
```

`GH Injector Library/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by GH Injector Library.rc

// Nächste Standardwerte für neue Objekte
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`GH Injector SM/GH Injector SM.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GH Injector SM", "GH Injector SM\GH Injector SM.vcxproj", "{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Debug|x64.ActiveCfg = Debug|x64
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Debug|x64.Build.0 = Debug|x64
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Debug|x86.ActiveCfg = Debug|Win32
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Debug|x86.Build.0 = Debug|Win32
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Release|x64.ActiveCfg = Release|x64
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Release|x64.Build.0 = Release|x64
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Release|x86.ActiveCfg = Release|Win32
		{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {808F1ED8-0D22-41C5-93F1-5FD309E2843D}
	EndGlobalSection
EndGlobal

```

`GH Injector SM/GH Injector SM/GH Injector SM.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// German (Germany) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
LANGUAGE LANG_GERMAN, SUBLANG_GERMAN
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 4,8,0,0
 PRODUCTVERSION 4,8,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000904b0"
        BEGIN
            VALUE "CompanyName", "Guided Hacking"
            VALUE "FileDescription", "Utility program for the GH Injector"
            VALUE "FileVersion", "4.8.0.0"
            VALUE "LegalCopyright", "Broihon (C) 1987 - 2035"
            VALUE "ProductName", "GH StartMethod"
            VALUE "ProductVersion", "4.8.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x9, 1200
    END
END

#endif    // German (Germany) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`GH Injector SM/GH Injector SM/GH Injector SM.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{6F0A0AA5-4B61-4323-B9A5-B3EF0088DC1B}</ProjectGuid>
    <RootNamespace>GHInjectorSM</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>$(ProjectName) - $(PlatformShortName)</TargetName>
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(PlatformShortName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>$(ProjectName) - $(PlatformShortName)</TargetName>
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(PlatformShortName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(PlatformShortName)\$(Configuration)\</IntDir>
    <TargetName>$(ProjectName) - $(PlatformShortName)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformShortName)\</OutDir>
    <IntDir>$(PlatformShortName)\$(Configuration)\</IntDir>
    <TargetName>$(ProjectName) - $(PlatformShortName)</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <SupportJustMyCode>true</SupportJustMyCode>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <SupportJustMyCode>true</SupportJustMyCode>
      <TreatWarningAsError>false</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <TreatWarningAsError>true</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <TreatWarningAsError>true</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="KernelCallbackTable.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="SetWindowsHookEx.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GH Injector SM.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GH Injector SM/GH Injector SM/GH Injector SM.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Ressourcendateien">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="SetWindowsHookEx.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="KernelCallbackTable.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Headerdateien</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="GH Injector SM.rc">
      <Filter>Ressourcendateien</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`GH Injector SM/GH Injector SM/GH Injector SM.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`GH Injector SM/GH Injector SM/KernelCallbackTable.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "main.h"

BOOL CALLBACK _KC_EnumWindowsCallback(HWND hWnd, LPARAM lParam)
{
	auto * data = reinterpret_cast<EnumWindowsCallback_Data *>(lParam);

	DWORD winPID = 0;
	GetWindowThreadProcessId(hWnd, &winPID);

	if (winPID == data->m_PID)
	{
		wchar_t szWindow[MAX_PATH]{ 0 };
		if (IsWindowVisible(hWnd) && GetWindowTextW(hWnd, szWindow, MAX_PATH))
		{
			data->m_HookData.push_back({ NULL, hWnd });
		}
	}

	return TRUE;
}

DWORD _KernelCallbackTable()
{
	auto ModuleBase = GetModuleHandleW(nullptr);
	if (!ModuleBase)
	{
		return KC_ERR_NO_MODULEBASE;
	}

	wchar_t szInfoPath[MAX_PATH * 2]{ 0 };
	size_t max_size = sizeof(szInfoPath) / sizeof(wchar_t);

	DWORD dwRet = GetModuleFileNameW(ModuleBase, szInfoPath, (DWORD)max_size);
	if (!dwRet || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		return KC_ERR_NO_PATH;
	}

	std::wstring InfoPath = szInfoPath;
	auto pos = InfoPath.find_last_of('\\');
	if (pos == std::wstring::npos)
	{
		return KC_ERR_INVALID_PATH;
	}

	InfoPath.erase(pos, InfoPath.back());
	InfoPath += FILENAME;

	std::ifstream File(InfoPath);
	if (!File.good())
	{
		File.close();

		DeleteFileW(InfoPath.c_str());

		return KC_ERR_CANT_OPEN_FILE;
	}

	std::stringstream info;
	info << File.rdbuf();

	File.close();

	DeleteFileW(InfoPath.c_str());

	std::string sPID = info.str();
	if (sPID.length() < 1)
	{
		return KC_ERR_EMPTY_FILE;
	}

	DWORD ProcID = strtol(sPID.c_str(), nullptr, 10);

	if (!ProcID)
	{
		return KC_ERR_INVALID_INFO;
	}

	EnumWindowsCallback_Data data;
	data.m_PID		= ProcID;
	data.m_pHook	= NULL;
	data.m_hModule	= LoadLibraryW(L"user32.dll");

	if (!EnumWindows(_KC_EnumWindowsCallback, reinterpret_cast<LPARAM>(&data)))
	{
		return KC_ERR_ENUM_WINDOWS_FAIL;
	}

	if (data.m_HookData.empty())
	{
		return KC_ERR_NO_WINDOWS;
	}

	TCHAR msg[] = TEXT("This sentence is false.");

	COPYDATASTRUCT cds{ 0 };
	cds.dwData = 1;
	cds.lpData = msg;
	cds.cbData = sizeof(msg);	

	for (const auto & i : data.m_HookData)
	{
		SendMessage(i.m_hWnd, WM_COPYDATA, reinterpret_cast<WPARAM>(i.m_hWnd), reinterpret_cast<LPARAM>(&cds));
	}

	return KC_ERR_SUCCESS;
}
```

`GH Injector SM/GH Injector SM/SetWindowsHookEx.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "main.h"

BOOL CALLBACK _SWHEX_EnumWindowsCallback(HWND hWnd, LPARAM lParam)
{
	auto * data = reinterpret_cast<EnumWindowsCallback_Data *>(lParam);

	DWORD winPID = 0;
	DWORD winTID = GetWindowThreadProcessId(hWnd, &winPID);

	if (winPID == data->m_PID)
	{
		wchar_t szWindow[MAX_PATH]{ 0 };
		if (IsWindowVisible(hWnd) && GetWindowTextW(hWnd, szWindow, MAX_PATH))
		{
			if (GetClassNameW(hWnd, szWindow, MAX_PATH) && wcscmp(szWindow, L"ConsoleWindowClass"))
			{
				HHOOK hHook = SetWindowsHookEx(WH_CALLWNDPROC, data->m_pHook, data->m_hModule, winTID);
				if (hHook)
				{
					data->m_HookData.push_back({ hHook, hWnd });
				}
			}
		}
	}

	return TRUE;
}

DWORD _SetWindowsHookEx()
{
	auto ModuleBase = GetModuleHandleW(nullptr);
	if (!ModuleBase)
	{
		return SWHEX_ERR_NO_MODULEBASE;
	}

	wchar_t szInfoPath[MAX_PATH * 2]{ 0 };
	size_t max_size = sizeof(szInfoPath) / sizeof(wchar_t);

	DWORD dwRet = GetModuleFileNameW(ModuleBase, szInfoPath, (DWORD)max_size);
	if (!dwRet || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		return SWHEX_ERR_NO_PATH;
	}

	std::wstring InfoPath = szInfoPath;
	auto pos = InfoPath.find_last_of('\\');
	if (pos == std::wstring::npos)
	{
		return SWHEX_ERR_INVALID_PATH;
	}

	InfoPath.erase(pos, InfoPath.back());
	InfoPath += FILENAME;

	std::ifstream File(InfoPath);
	if (!File.good())
	{
		File.close();

		DeleteFileW(InfoPath.c_str());

		return SWHEX_ERR_CANT_OPEN_FILE;
	}

	std::stringstream info;
	info << File.rdbuf();
	
	File.close();

	DeleteFileW(InfoPath.c_str());

	std::string sPID = info.str();
	if (sPID.length() < 1)
	{
		return SWHEX_ERR_EMPTY_FILE;
	}

	pos = sPID.find('!');
	if (pos == std::string::npos)
	{
		return SWHEX_ERR_INVALID_INFO;
	}
	
	std::string sHook = sPID.substr(pos + 1, std::string::npos);
	sPID.erase(pos, std::string::npos);

	DWORD ProcID = strtol(sPID.c_str(), nullptr, 10);

#ifdef _WIN64
	ULONG_PTR pHook = strtoll(sHook.c_str(), nullptr, 0x10);
#else
	DWORD pHook = strtol(sHook.c_str(), nullptr, 0x10);
#endif

	if (!ProcID || !pHook)
	{
		return SWHEX_ERR_INVALID_INFO;
	}

	EnumWindowsCallback_Data data;
	data.m_PID		= ProcID;
	data.m_pHook	= reinterpret_cast<HOOKPROC>(pHook);
	data.m_hModule	= LoadLibraryW(L"user32.dll");

	if (!EnumWindows(_SWHEX_EnumWindowsCallback, reinterpret_cast<LPARAM>(&data)))
	{
		return SWHEX_ERR_ENUM_WINDOWS_FAIL;
	}

	if (data.m_HookData.empty())
	{
		return SWHEX_ERR_NO_WINDOWS;
	}

	for (const auto & i : data.m_HookData)
	{
		SetForegroundWindow(i.m_hWnd);
		SendMessageW(i.m_hWnd, WM_KEYDOWN, VK_SPACE, 0);
		Sleep(10);
		SendMessageW(i.m_hWnd, WM_KEYUP, VK_SPACE, 0);
		UnhookWindowsHookEx(i.m_hHook);
	}

	return SWHEX_ERR_SUCCESS;
}
```

`GH Injector SM/GH Injector SM/main.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"

#include "main.h"

#pragma comment(linker, "/SUBSYSTEM:WINDOWS /ENTRY:wmainCRTStartup")

int wmain(int argc, wchar_t * argv[])
{
	if (argc < 2)
	{
		return SM_ERR_INVALID_ARGC;
	}

	if (argv[1][0] == ID_SWHEX)
	{
		return (int)_SetWindowsHookEx();
	}
	else if (argv[1][0] == ID_KC)
	{
		return (int)_KernelCallbackTable();
	}
#ifndef _WIN64
	else if (argv[1][0] == ID_WOW64)
	{
		HANDLE hEventStart	= reinterpret_cast<HANDLE>(wcstol(argv[2], nullptr, 0x10));
		HANDLE hEventEnd	= reinterpret_cast<HANDLE>(wcstol(argv[3], nullptr, 0x10));

		SignalObjectAndWait(hEventStart, hEventEnd, INFINITE, FALSE);

		CloseHandle(hEventStart);
		CloseHandle(hEventEnd);

		return SM_ERR_SUCCESS;
	}
#endif
	
	return SM_ERR_INVALID_ARGV;
}
```

`GH Injector SM/GH Injector SM/main.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include "pch.h"

#ifdef _WIN64
#define FILENAME L"\\SM64.txt"
#else
#define FILENAME L"\\SM86.txt"
#endif

#define ID_SWHEX	'0'
#define ID_WOW64	'1'
#define ID_KC		'2'

#define SM_ERR_SUCCESS		0x00000000
#define SM_ERR_INVALID_ARGC	0x30000001
#define SM_ERR_INVALID_ARGV	0x30000002

#define SWHEX_ERR_SUCCESS			0x00000000
#define SWHEX_ERR_INVALID_PATH		0x30100001
#define SWHEX_ERR_CANT_OPEN_FILE	0x30100002
#define SWHEX_ERR_EMPTY_FILE		0x30100003
#define SWHEX_ERR_INVALID_INFO		0x30100004
#define SWHEX_ERR_ENUM_WINDOWS_FAIL 0x30100005
#define SWHEX_ERR_NO_WINDOWS		0x30100006
#define SWHEX_ERR_NO_MODULEBASE		0x30100007
#define SWHEX_ERR_OUT_OF_MEMORY		0x30100008
#define SWHEX_ERR_NO_PATH			0x30100009

#define KC_ERR_SUCCESS				0x00000000
#define KC_ERR_INVALID_PATH			0x50100001
#define KC_ERR_CANT_OPEN_FILE		0x50100002
#define KC_ERR_EMPTY_FILE			0x50100003
#define KC_ERR_INVALID_INFO			0x50100004
#define KC_ERR_ENUM_WINDOWS_FAIL	0x50100005
#define KC_ERR_NO_WINDOWS			0x50100006
#define KC_ERR_NO_MODULEBASE		0x50100007
#define KC_ERR_OUT_OF_MEMORY		0x50100008
#define KC_ERR_NO_PATH				0x50100009

struct HookData
{
	HHOOK	m_hHook;
	HWND	m_hWnd;
};

struct EnumWindowsCallback_Data
{
	std::vector<HookData>	m_HookData;
	DWORD					m_PID		= 0;
	HOOKPROC				m_pHook		= nullptr;
	HINSTANCE				m_hModule	= NULL;
};

DWORD _SetWindowsHookEx();

DWORD _KernelCallbackTable();
```

`GH Injector SM/GH Injector SM/pch.cpp`:

```cpp
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#include "pch.h"
```

`GH Injector SM/GH Injector SM/pch.h`:

```h
/*
 * Author:       Broihon
 * Copyright:    Guided Hacking™ © 2012-2023 Guided Hacking LLC
*/

#pragma once

#include <Windows.h>

#if (NTDDI_VERSION < NTDDI_WIN7)
#error The mininum requirement for this library is Windows 7.
#endif

#include <fstream>
#include <sstream>
#include <vector>
```

`GH Injector SM/GH Injector SM/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by GH Injector SM.rc

// Nächste Standardwerte für neue Objekte
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Injection.h`:

```h
//Include this file if you want to use the injection library in your own project
//
//Use LoadLibrary to import the injection library:
//HINSTANCE hInjectionMod = LoadLibrary(GH_INJ_MOD_NAME);
//
//Grab the injection functions with GetProcAddress:
//auto InjectA = (f_InjectA)GetProcAddress(hInjectionMod, "InjectA");
//auto InjectW = (f_InjectW)GetProcAddress(hInjectionMod, "InjectW");
//
//If needed:
//auto ValidateInjectionFunctions	= (f_ValidateInjectionFunctions)GetProcAddress(hInjectionMod, "ValidateInjectionFunctions");
//auto RestorenjectionFunctions		= (f_RestoreInjectionFunctions)GetProcAddress(hInjectionMod, "RestorenjectionFunctions");
//
//Symbol state:
//auto GetSymbolState 			= (f_GetSymbolState)GetProcAddress(hInjectionMod, "GetSymbolState");
//auto GetImportState			= (f_GetImportState)GetProcAddress(hInjectionMod, "GetImportState");
//
//Download progress:
//auto GetDownloadProgressEx 	= (f_GetDownloadProgress)GetProcAddress(hInjectionMod, "GetDownloadProgressEx");

#pragma once

#define GH_INJ_VERSIONW L"4.6"
#define GH_INJ_VERSIONA "4.6"

#define GH_INJ_MOD_NAME64W L"GH Injector - x64.dll"
#define GH_INJ_MOD_NAME86W L"GH Injector - x86.dll"

#define GH_INJ_MOD_NAME64A "GH Injector - x64.dll"
#define GH_INJ_MOD_NAME86A "GH Injector - x86.dll"

#ifdef _WIN64
#define GH_INJ_MOD_NAMEW GH_INJ_MOD_NAME64W
#define GH_INJ_MOD_NAMEA GH_INJ_MOD_NAME64A
#else
#define GH_INJ_MOD_NAMEW GH_INJ_MOD_NAME86W
#define GH_INJ_MOD_NAMEA GH_INJ_MOD_NAME86A
#endif

#ifdef UNICODE
#define GH_INJ_MOD_NAME GH_INJ_MOD_NAMEW
#define GH_INJ_VERSION GH_INJ_VERSIONW
#else
#define GH_INJ_MOD_NAME GH_INJ_MOD_NAMEA
#define GH_INJ_VERSION GH_INJ_VERSIONA
#endif

#include <Windows.h>

enum class INJECTION_MODE
{
	IM_LoadLibraryExW,
	IM_LdrLoadDll,
	IM_LdrpLoadDll,
	IM_LdrpLoadDllInternal,
	IM_ManualMap
};

enum class LAUNCH_METHOD
{
	LM_NtCreateThreadEx,
	LM_HijackThread,
	LM_SetWindowsHookEx,
	LM_QueueUserAPC,
	LM_KernelCallback,
	LM_FakeVEH
};

//ansi version of the info structure:
struct INJECTIONDATAA
{
	char			szDllPath[MAX_PATH * 2];	//fullpath to the dll to inject
	DWORD			ProcessID;					//process identifier of the target process
	INJECTION_MODE	Mode;						//injection mode
	LAUNCH_METHOD	Method;						//method to execute the remote shellcode
	DWORD			Flags;						//combination of the flags defined above
	DWORD			Timeout;					//timeout for DllMain return in milliseconds
	DWORD			hHandleValue;				//optional value to identify a handle in a process
	HINSTANCE		hDllOut;					//returned image base of the injection
	bool			GenerateErrorLog;			//if true error data is generated and stored in GH_Inj_Log.txt
};

//unicode version of the info structure (documentation above)
struct INJECTIONDATAW
{
	wchar_t			szDllPath[MAX_PATH * 2];
	wchar_t			szTargetProcessExeFileName[MAX_PATH];	//exe name of the target process, this value gets set automatically and should be initialized with 0s
	DWORD			ProcessID;
	INJECTION_MODE	Mode;
	LAUNCH_METHOD	Method;
	DWORD			Flags;
	DWORD			Timeout;
	DWORD			hHandleValue;
	HINSTANCE		hDllOut;
	bool			GenerateErrorLog;
};

#ifdef _UNICODE
#define INJECTIONDATA INJECTIONDATAW
#else
#define INJECTIONDATA INJECTIONDATAA
#endif

//amount of bytes to be scanned by ValidateInjectionFunctions and restored by RestoreInjectionFunctions
#define HOOK_SCAN_BYTE_COUNT 0x10

//ValidateInjectionFunctions fills an std::vector with this info, result can simply be passed to RestoreInjectionFunctions
struct HookInfo
{
	const char * ModuleName;
	const char * FunctionName;

	HINSTANCE		hModuleBase;
	void		*	pFunc;
	UINT			ChangeCount;
	BYTE			OriginalBytes[HOOK_SCAN_BYTE_COUNT];

	DWORD ErrorCode;
};

//Cloaking options:
#define INJ_ERASE_HEADER				0x0001	//replaces the first 0x1000 bytes of the dll with 0's (takes priority over INJ_FAKE_HEADER if both are specified)
#define INJ_FAKE_HEADER					0x0002	//replaces the dlls header with the header of the ntdll.dll (superseded by INJ_ERASE_HEADER if both are specified)
#define INJ_UNLINK_FROM_PEB				0x0004	//unlinks the module from the process enviroment block (1)
#define INJ_THREAD_CREATE_CLOAKED		0x0008	//passes certain flags to NtCreateThreadEx to make the thread creation more stealthy (2)
#define INJ_SCRAMBLE_DLL_NAME			0x0010	//randomizes the dll name on disk before injecting it
#define INJ_LOAD_DLL_COPY				0x0020	//loads a copy of the dll from %temp% directory
#define INJ_HIJACK_HANDLE				0x0040	//tries to a hijack a handle from another process instead of using OpenProcess

//Notes:
///(1) ignored when manual mapping
///(2) launch method must be NtCreateThreadEx, ignored otherwise

//Manual mapping options:
#define INJ_MM_CLEAN_DATA_DIR			0x00010000	//removes data from the dlls PE header, ignored if INJ_MM_SET_PAGE_PROTECTIONS is set
#define INJ_MM_RESOLVE_IMPORTS			0x00020000	//resolves dll imports
#define INJ_MM_RESOLVE_DELAY_IMPORTS	0x00040000	//resolves delayed imports
#define INJ_MM_EXECUTE_TLS				0x00080000	//executes TLS callbacks and initializes static TLS data
#define INJ_MM_ENABLE_EXCEPTIONS		0x00100000	//enables exception handling
#define INJ_MM_SET_PAGE_PROTECTIONS		0x00200000	//sets page protections based on section characteristics, if set INJ_MM_CLEAN_DATA_DIR will be ignored
#define INJ_MM_INIT_SECURITY_COOKIE		0x00400000	//initializes security cookie for buffer overrun protection
#define INJ_MM_RUN_DLL_MAIN				0x00800000	//executes DllMain
								//this option induces INJ_MM_RESOLVE_IMPORTS
#define INJ_MM_RUN_UNDER_LDR_LOCK		0x01000000	//runs the DllMain under the loader lock
#define INJ_MM_SHIFT_MODULE_BASE		0x02000000	//shifts the module base by a random offset

#define MM_DEFAULT (INJ_MM_RESOLVE_IMPORTS | INJ_MM_RESOLVE_DELAY_IMPORTS | INJ_MM_INIT_SECURITY_COOKIE | INJ_MM_EXECUTE_TLS | INJ_MM_ENABLE_EXCEPTIONS | INJ_MM_RUN_DLL_MAIN | INJ_MM_SET_PAGE_PROTECTIONS)

//Arguments for GetDownloadProgressEx
#define PDB_DOWNLOAD_INDEX_NTDLL	(int)0 //ntdll pdb download
#define PDB_DOWNLOAD_INDEX_KERNEL32 (int)1 //kernel32 pdb download (Windows 7 only)

using f_InjectA = DWORD(__stdcall*)(INJECTIONDATAA * pData);
using f_InjectW = DWORD(__stdcall*)(INJECTIONDATAW * pData);

using f_ValidateInjectionFunctions = bool(__stdcall*)(DWORD dwTargetProcessId, DWORD & ErrorCode, DWORD & LastWin32Error, HookInfo * HookDataOut, UINT Count, UINT * CountOut);
using f_RestoreInjectionFunctions = bool(__stdcall*)(DWORD dwTargetProcessId, DWORD & ErrorCode, DWORD & LastWin32Error, HookInfo * HookDataIn, UINT Count, UINT * CountOut);

using f_GetVersionA = HRESULT(__stdcall *)(char		* out, size_t cb_size);
using f_GetVersionW = HRESULT(__stdcall *)(wchar_t	* out, size_t cb_size);

using f_GetSymbolState = DWORD(__stdcall *)();
using f_GetImportState = DWORD(__stdcall *)();

using f_GetDownloadProgressEx = float(__stdcall *)(int index, bool bWow64);
using f_StartDownload = void(__stdcall *)();
using f_InterruptDownload = void(__stdcall *)();

using f_raw_print_callback = void(__stdcall *)(const char * szText);
using f_SetRawPrintCallback = DWORD(__stdcall *)(f_raw_print_callback callback);
```

`LICENSE`:

```
GuidedHacking.com Source Available License
Version 1, 05-14-2025

Disclaimer:
This project contains code developed and published by Guided Hacking LLC.
GuidedHacking® sells educational content including source codes like this.

GuidedHacking® - The Game Hacking Bible® - © 2025 Guided Hacking LLC. All Rights Reserved.

Licensed Materials:
Source code, compiled binaries, documentation, image and video assets, including original, modified or derivative versions.

Limited Use License:
1. You may use these materials only in non-commercial private, personal projects.
2. Distribution of these materials in any form, including compiled, modified, or derivative works is not permitted.

This software is provided AS IS without any warranties, express or implied, and Guided Hacking LLC is not liable for any damages arising from the use of these materials.

Any rights not expressly granted by the license are reserved by Guided Hacking LLC.
```

`README.md`:

```md
# GuidedHacking DLL Injector Library

A feature-rich DLL injection library which supports x86, WOW64 and x64 injections.
Developed by [Broihon](https://guidedhacking.com/members/broihon.49430/) for Guided Hacking.
It features five injection methods, six  shellcode execution methods and various additional options.
Session separation can be bypassed with all methods.

If you want to use this library with a GUI check out the [GH Injector GUI](https://github.com/guided-hacking/GH-Injector-GUI).

Release Downloads: [Download DLL Injector Here ](https://guidedhacking.com/resources/guided-hacking-dll-injector.4/)

![image](https://github.com/guided-hacking/GH-Injector-Library/assets/15186628/d5c6670c-538f-4a48-a565-bb277e4dc46e)
![image](https://github.com/guided-hacking/GH-Injector-Library/assets/15186628/3ca83e0f-0e8b-4bc9-a101-0bb28e105698)![image](https://github.com/guided-hacking/GH-Injector-Library/assets/15186628/d070f0f0-8469-48f1-9744-6b199f0d1b73)

----

### DLL Injection methods

- LoadLibraryExW
- LdrLoadDll
- LdrpLoadDll
- LdrpLoadDllInternal
- ManualMapping

### Shellcode execution methods

- NtCreateThreadEx
- Thread hijacking
- SetWindowsHookEx
- QueueUserAPC
- KernelCallback
- FakeVEH

### DLL Manual mapping features:

- Section mapping
- Base relocation
- Imports
- Delayed imports
- SEH support
- TLS initialization
- Security cookie initalization
- Loader Lock
- Shift image
- Clean datadirectories

### Additional features:

- Various cloaking options
	- PEB unlinking
	- PE header cloaking
	- Thread cloaking
- Handle hijacking
- Hook scanning/restoring

----

<h3>Official Guided Hacking Courses</h3>
<ul>
	<li><a href="https://guidedhacking.com/ghb" target="_blank">The Game Hacking Bible</a>&nbsp;- a massive 70 chapter Game Hacking Course</li>
	<li><a href="https://guidedhacking.com/threads/squally-cs420-game-hacking-course.14191/" target="_blank">Computer Science 420</a>&nbsp;- an eight chapter lecture on CS, Data Types &amp; Assembly</li>
	<li><a href="https://guidedhacking.com/forums/binary-exploit-development-course.551/" target="_blank">Binary Exploit Development</a>&nbsp;- a 9 chapter series on exploit dev&nbsp;from a certified OSED</li>
	<li><a href="https://guidedhacking.com/forums/game-hacking-shenanigans/" target="_blank">Game Hacking Shenanigans</a>&nbsp;- a twenty lesson Cheat Engine hacking course</li>
	<li><a href="https://guidedhacking.com/threads/python-game-hacking-tutorial-1-1-introduction.18695/" target="_blank">Python Game Hacking Course</a>&nbsp;- 7 chapter external &amp; internal python hack lesson</li>
	<li><a href="https://guidedhacking.com/threads/python-game-hacking-tutorial-2-1-introduction.19199/" target="_blank">Python App Reverse Engineering</a>&nbsp;- Learn to reverse python apps in 5 lessons</li>
	<li><a href="https://guidedhacking.com/threads/web-browser-game-hacking-intro-part-1.17726/" target="_blank">Web Browser Game Hacking</a>&nbsp;- Hack javascript games with this 4 chapter course</li>
	<li><a href="https://guidedhacking.com/forums/roblox-exploit-scripting-course-res100.521/" target="_blank">Roblox Exploiting Course</a>&nbsp;- 7 Premium Lessons on Hacking Roblox</li>
	<li><a href="https://guidedhacking.com/forums/java-reverse-engineering-course-jre100.538/" target="_blank">Java Reverse Engineering Course</a>&nbsp;- 5 chapter beginner guide</li>
	<li><a href="https://guidedhacking.com/forums/java-game-hacking-course-jgh100.553/" target="_blank">Java Game Hacking Course</a>&nbsp;- 6 Chapter Beginner Guide</li>
</ul>

----

### Where to download the compiled binaries?
This repo doesn't contain the compiled binaries, just the source code for the library. If you want to download the compiled program, you must be a paying customer on our website where you can download it. If you can compile it yourself and get it working, then great, enjoy it, but you do not have permission/license to distribute the compiled binaries or any of our other content from our website.

### Getting Started With The GH DLL Injector

You can easily use mapper by including the compiled binaries in your project. Check the provided Injection.h header for more information.
Make sure you have the compiled binaries in the working directory of your program.
On first run the injection module has to download PDB files for the native (and when run on x64 the wow64) version of the ntdll.dll to resolve symbol addresses. Use the exported StartDownload function to begin the download.
The injector can only function if the downloads are finished. The injection module exports GetSymbolState and GetImportState which will return INJ_ERROR_SUCCESS (0) if the PDB download and resolving of all required addresses is completed.
Additionally GetDownloadProgress can be used to determine the progress of the download as percentage. If the injection module is to be unloaded during the download process call InterruptDownload or there's a chance that the dll will deadlock your process.

```cpp

#include "Injection.h"

HINSTANCE hInjectionMod = LoadLibrary(GH_INJ_MOD_NAME);
	
auto InjectA = (f_InjectA)GetProcAddress(hInjectionMod, "InjectA");
auto GetSymbolState = (f_GetSymbolState)GetProcAddress(hInjectionMod, "GetSymbolState");
auto GetImportState = (f_GetSymbolState)GetProcAddress(hInjectionMod, "GetImportState");
auto StartDownload = (f_StartDownload)GetProcAddress(hInjectionMod, "StartDownload");
auto GetDownloadProgressEx = (f_GetDownloadProgressEx)GetProcAddress(hInjectionMod, "GetDownloadProgressEx");

//due to a minor bug in the current version you have to wait a bit before starting the download
	//will be fixed in version 4.7
Sleep(500);

StartDownload();

//since GetSymbolState and GetImportState only return after the downloads are finished 
	//checking the download progress is not necessary
while (GetDownloadProgressEx(PDB_DOWNLOAD_INDEX_NTDLL, false) != 1.0f)
{
	Sleep(10);
}

#ifdef _WIN64
while (GetDownloadProgressEx(PDB_DOWNLOAD_INDEX_NTDLL, true) != 1.0f)
{
	Sleep(10);
}
#endif

while (GetSymbolState() != 0)
{
	Sleep(10);
}

while (GetImportState() != 0)
{
	Sleep(10);
}

DWORD TargetProcessId;

INJECTIONDATAA data =
{
	"",
	TargetProcessId,
	INJECTION_MODE::IM_LoadLibraryExW,
	LAUNCH_METHOD::LM_NtCreateThreadEx,
	NULL,
	0,
	NULL,
	NULL,
	true
};

strcpy(data.szDllPath, DllPathToInject);

InjectA(&data);

```

---

### What is a DLL Injector?​

DLL injection is a technique where code is run in the space of another process by forcing it to load a dynamic library. This is often done by external programs to change the behavior of the target program in an unintended way. For example, injected code could hook function calls or copy data variables. A program used to inject code into processes is called a DLL injector

If you're making an internal hack you must use a DLL injector to inject it.

### What is a DLL?​

A DLL is a library of code that is loaded into a process at runtime. Large code bases led to the development of libraries like SSL and cURL, which are used by many programs. These libraries are statically linked, meaning that every executable includes the code from the library. However, this can lead to a lot of wasted disk space if multiple programs all statically link the same library.

Dynamic link libraries were created in order to save space on smaller hard drives. With DLLs, there only needs to be one copy on the hard drive, and hundreds of programs can dynamically load and resolve them at run time.

### Why is DLL injection so common?​

It's common because the easiest way to modify a program is via hooking, especially when you want to display something on the screen or make a copy of what's on the screen. You can hook things without a DLL but importing 1 file which does everything is a modular and convenient way of performing this task. In addition, when you inject a DLL, it's code is running inside the target process, which is much faster than doing the same task from an external program.

DLL injection is so popular for game hacking for the same reasons. Rather than modifying a program externally, you can get your code executing inside the process, which allows for easy & efficient hooking and memory modification.

### DLL Injector Credits

Special thank you to [Kage](https://guidedhacking.com/members/kage.109622/) / [Multikill](https://github.com/multikill) for developing the Qt GUI of the GH Injector, it's a a huge improvement.

First of all I want to credit Joachim Bauch whose Memory Module Library was a great source to learn from:  
https://github.com/fancycode/MemoryModule

He also made a great write-up explaining the basics of mapping a module:  
https://www.joachim-bauch.de/tutorials/loading-a-dll-from-memory/

I also want to thank Akaion/Dewera for helping me with SEH support and their C# mapping library which was another great resource to learn from:  
[C# Manual Map DLL Injection Library](https://guidedhacking.com/threads/c-manual-map-dll-injection-library-lunar.14238/)

Big thanks to mambda who made this PDB parser which I could steal code from to verify GUIDs:  
[C++ Windows PDB Parser](https://guidedhacking.com/threads/windows-c-pdb-parser.12159/)

GuidedHacking® - The Game Hacking Bible® - © 2025 Guided Hacking LLC. All Rights Reserved.

```